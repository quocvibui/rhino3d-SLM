{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/debug_pickup_retract.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/debug_pickup_retract.py",
  "instruction": "Debug pickup retract",
  "code": "import Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport re\nfrom integral_timber_joints.rhino.load import get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.geometry import JointHalfLap, JointNonPlanarLap\nfrom integral_timber_joints.rhino.assembly_artist import AssemblyNurbsArtist\nfrom integral_timber_joints.assembly import BeamAssemblyMethod\nfrom integral_timber_joints.tools import Clamp, Screwdriver, Gripper\nfrom integral_timber_joints.process import RobotClampAssemblyProcess\n\nimport json\n\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_mesh\nfrom compas.data import DataEncoder\n\n\nfrom compas.geometry import Cylinder, Transformation, Translation, Vector, Frame\n\n\n\ndef compute_beam_pickupretract(process, beam_id, verbose=False):\n    # type: (RobotClampAssemblyProcess, str, bool) -> ComputationalResult\n    \"\"\"Compute 'assembly_wcf_pickupretract' from beam attributes:\n    by transforming 'assembly_wcf_pickup' along 'PickupStation.pickup_retract_vector'.\n\n    For Beams in BeamAssemblyMethod.screw_methods, compute 'assembly_wcf_screwdriver_attachment_pose'\n    The Beam assembly direction (representing the screwdriver pointy end direction)\n    is used to guide the rotation of the beam above the retract frame.\n\n    State Change\n    ------------\n    This functions sets the following beam_attribute\n    - 'assembly_wcf_pickupretract'\n    - 'assembly_wcf_screwdriver_attachment_pose' (BeamAssemblyMethod in screw_methods)\n\n    Return\n    ------\n    `ComputationalResult.ValidCannotContinue` if prerequisite not satisfied\n    `ComputationalResult.ValidCanContinue` otherwise (this function should not fail)\n\n    \"\"\"\n    # Check to ensure prerequisite\n    if process.pickup_station is None:\n        print(\"pickup_station is not set\")\n\n    def vprint(str):\n        if verbose:\n            print(str)\n\n    # * Compute assembly_wcf_pickupretract\n    assembly_wcf_pickup = process.assembly.get_beam_attribute(beam_id, 'assembly_wcf_pickup')\n    vprint(\"assembly_wcf_pickup = %s\" % (assembly_vector_at_pickup_in_wcf))\n\n    retract_vector = process.pickup_station.pickup_retract_vector\n    vprint(\"retract_vector = %s\" % (retract_vector))\n    t_beam_final_from_beam_at_pickup = Translation.from_vector(retract_vector)\n    assembly_wcf_pickupretract = assembly_wcf_pickup.transformed(t_beam_final_from_beam_at_pickup)\n    vprint(\"assembly_wcf_pickupretract = %s\" % (assembly_wcf_pickupretract))\n\n    process.assembly.set_beam_attribute(beam_id, 'assembly_wcf_pickupretract', assembly_wcf_pickupretract)\n    vprint(\"process.assembly.set_beam_attribute(%s, 'assembly_wcf_pickupretract', %s)\" % (beam_id, assembly_wcf_pickupretract))\n\n    # Check if beam is of type SCREWED, otherwise stop here\n    if process.assembly.get_beam_attribute(beam_id, 'assembly_method') not in BeamAssemblyMethod.screw_methods:\n        vprint(\"return ComputationalResult.ValidCanContinue\")\n\n    # * Compute assembly_wcf_screwdriver_attachment_pose\n    beam = process.assembly.beam(beam_id)\n    assembly_vector_final_in_wcf = process.assembly.get_beam_attribute(beam_id, 'assembly_vector_final')\n    t_beam_final_from_beam_at_pickup = process.assembly.get_beam_transformaion_to(beam_id, 'assembly_wcf_pickup')\n    assembly_vector_at_pickup_in_wcf = assembly_vector_final_in_wcf.transformed(t_beam_final_from_beam_at_pickup)\n    vprint(\"assembly_vector_at_pickup_in_wcf = %s\" % (assembly_vector_at_pickup_in_wcf))\n\n    assembly_vector_up_amount = Vector(0, 0, 1).dot(assembly_vector_at_pickup_in_wcf)\n    vprint(\"assembly_vector_up_amount = %s\" % (assembly_vector_up_amount))\n\n    def four_possible_rotations():\n        rotations = []\n        for i in range(1, 5):\n            # ! This is the same code spelled out in matrix transformation:\n            # t_world_from_beam_final = Transformation.from_frame(beam.get_face_frame(1))\n            # t_world_from_beam_final_newpose = Transformation.from_frame(beam.get_face_frame(i))\n            # t_beam_at_pickupretract_from_beam_newpose = t_world_from_beam_final.inverse() * t_world_from_beam_final_newpose\n            # rotations.append(t_beam_at_pickupretract_from_beam_newpose)\n            rotations.append(Transformation.from_change_of_basis(beam.get_face_frame(i), beam.get_face_frame(1)))\n        return rotations\n\n    t_world_from_beam_at_final = Transformation.from_frame(beam.frame)\n    assembly_vector_in_ocf = assembly_vector_final_in_wcf.transformed(t_world_from_beam_at_final.inverse())\n    vprint('assembly_vector_final_in_wcf = %s' % assembly_vector_final_in_wcf)\n    vprint('assembly_vector_in_ocf = %s' % assembly_vector_in_ocf)\n\n    possible_rotation_vectors = []\n    possible_rotation_vector_dowm_amount = []\n    # Trying all four possible rotations to get a new assembly and compare it so see which one points downwards\n    for t_change_of_basis_rotation_at_final in four_possible_rotations():\n        vprint(\"t_change_of_basis_rotation_at_final = %s\" % t_change_of_basis_rotation_at_final)\n        new_assembly_vector_in_ocf = assembly_vector_in_ocf.transformed(t_change_of_basis_rotation_at_final)\n        vprint('new_assembly_vector_in_ocf = %s' % new_assembly_vector_in_ocf)\n        new_assembly_vector_at_pickup_in_wcf = new_assembly_vector_in_ocf.transformed(t_world_from_beam_at_final).transformed(t_beam_final_from_beam_at_pickup)\n        vprint('new_assembly_vector_at_pickup_in_wcf = %s' % new_assembly_vector_at_pickup_in_wcf)\n        new_assembly_vector_down_amount = Vector(0, 0, -1).dot(new_assembly_vector_at_pickup_in_wcf)\n        vprint('new_assembly_vector_down_amount = %s' % new_assembly_vector_down_amount)\n        possible_rotation_vectors.append(t_change_of_basis_rotation_at_final)\n        possible_rotation_vector_dowm_amount.append(new_assembly_vector_down_amount)\n        vprint(\"--------------\")\n\n    # After identifying the best rotation. Apply it to find the new pose of the beam after pickup\n    x = max(possible_rotation_vector_dowm_amount)\n\n    best_rotation_index = possible_rotation_vector_dowm_amount.index(x)\n    t_world_from_beam_at_pickupretract = Transformation.from_frame(assembly_wcf_pickupretract)\n    t_world_from_beam_at_newpose = t_world_from_beam_at_pickupretract * possible_rotation_vectors[best_rotation_index]\n\n    f_world_from_beam_at_newpose = Frame.from_transformation(t_world_from_beam_at_newpose)\n    process.assembly.set_beam_attribute(beam_id, 'assembly_wcf_screwdriver_attachment_pose', f_world_from_beam_at_newpose)\n    vprint(\"process.assembly.set_beam_attribute(%s, 'assembly_wcf_screwdriver_attachment_pose', %s)\" % (beam_id, f_world_from_beam_at_newpose))\n\n    return ComputationalResult.ValidCanContinue\n\n\nif __name__ == '__main__':\n    process = get_process()\n    assembly = process.assembly\n    artist = get_process_artist()\n    beam_id = 'b12'\n\n    compute_beam_pickupretract(process, beam_id, verbose=True)\n    # artist.draw_beam_brep(beam_id)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}