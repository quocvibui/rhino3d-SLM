{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_View%20Analysis.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_View Analysis.py",
  "instruction": "Use this component to evaluate the visibility of input _geometry from a set of key viewing points.\r\nFor example, this component can be used to evaluate the visibility of an 3D architectural feature...",
  "code": "# This script used to be ladybug all in one\r\n# I separated them into three parts before distribution which made it such a mess\r\n#\r\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\r\n# \r\n# This file is part of Ladybug.\r\n# \r\n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> and Chris Mackey <Chris@MackeyArchitecture.com>\r\n# Ladybug is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# Ladybug is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# You should have received a copy of the GNU General Public License\r\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n\r\n\r\n\"\"\"\r\nUse this component to evaluate the visibility of input _geometry from a set of key viewing points.\r\nFor example, this component can be used to evaluate the visibility of an 3D architectural feature from a set of key viewing points along a nearby street or park where people congregate.\r\nAnother example would be evaluating the visibility of park vegetation geometry from a set of key sun position points from the sunPath component.\r\nYet another example would be evaluating the \"visibility\" of an outdoor overhead radiative heater from a set of key \"viewing\" points located over a human body standing beneath it.\r\nThis component outputs a percentage of viewpoints seen by the input _geometry.  In the three examples here, this would be the percentage of the 3D architectural feature seen from the street, the percentage of sunlit hours received by the vegetation, or the percentage of the human body warmed by the heater.\r\nThis component will evaluate view from the test points objectively in all directions. \r\n\r\n-\r\nProvided by Ladybug 0.0.69\r\n    \r\n    Args:\r\n        _geometry: Geometry for which visibility analysis will be conducted.  Geometry must be either a Brep, a Mesh, or a list of Breps or Meshes.\r\n        context_: Context geometry that could block the view from the _viewTypeOrPoints to the test _geometry.  Conext geometry must be either a Brep, a Mesh, or a list of Breps or Meshes.\r\n        _gridSize_: A number in Rhino model units that represents the average size of a grid cell for visibility analysis on the test _geometry.  This value should be smaller than the smallest dimension of the test _geometry for meaningful results.  Note that, the smaller the grid size, the higher the resolution of the analysis and the longer the calculation will take.\r\n        _disFromBase: A number in Rhino model units that represents the offset distance of the test point grid from the input test _geometry.  Usually, the test point grid is offset by a small amount from the test _geometry in order to ensure that visibility analysis is done for the correct side of the test _geometry.  If the resulting testPts of this component are offset to the wrong side of test _geometry, you should use the \"Flip\" Rhino command on the test _geometry before inputting it to this component.\r\n        orientationStudyP_: Optional output from the \"Orientation Study Parameter\" component.  You can use an Orientation Study input here to answer questions like \"What orientation of my building will give me the highest or lowest visibility from the street?\"  An Orientation Study will automatically rotate your input _geometry around several times and record the visibility results each time in order to output a list of values for averageView and a grafted data stream for viewStudyResult.\r\n        _viewTypeOrPoints: An integer representing the type of view analysis that you would like to conduct or a list of points to which you would like to test the view.  For integer options, choose from the following options:\r\n            0 - Horizontal Radial - The percentage of the 360 horizontal view band visible from each test point. Use this to study horizontal views from interior spaces to the outdoors.\r\n            1 - Horizontal 60 Degree Cone of Vision - The percentage of the 360 horizontal view band bounded on top and bottom by a 30 degree offset from the horizontal (derived from the human cone of vision). Use this to study views from interior spaces to the outdoors.\r\n            2 - Spherical - The percentage of the sphere surrounding each of the test points that is not blocked by context geometry.\r\n            3 - Sky Exposure - The percentage of the sky that is visible from the points of the input _geometry (as opposed to Sky View, which is the amount of sky seen by a surface).  This is equivalent to a solid angle or even-spaced ray-tracing calculation from the point.  It is useful for evaluating one's general visual connection to the sky at a given set of points.\r\n            4 - Sky View - The percentage of the sky that is visible from the surface _geometry (as opposed to Sky Exposure, which is the amount of sky seen by the points).  While Sky Exposure treats each patch of the sky with relatively equal weight, Sky View weights these patches by their area projected into the plane of the surface being evaluated.  In other words, Sky View for a horizontal surface would give more importance to the sky patches that are overhead vs near the horizon.  Sky View is an important factor in for modelling urban heat island since the inability of warm urban surfaces to radiate heat to a cool night sky is one of the largest contributors of the heat island effect.\r\n        viewPtsWeights_: A list of numbers that align with the test points to assign weights of importance to the several _viewTypeOrPoints that have been connected.  Weighted values should be between 0 and 1 and should be closer to 1 if a certain point is more important. The default value for all points is 0, which means they all have an equal importance. This input could be useful in cases such as the radiative heater example where points on the human body with exposed skin could be weighted at a higher value.\r\n        geometryBlocksView_: Set to \"True\" to have the component count the input _geometry as opaque and set to \"False\" to discount the _geometry from the calculation and only look at context_ that blocks the view.  The default is set to \"False\" for all types of view studies except for (3 - Sky Exposure) and (4 - Sky View), where the default is set to \"True.\"\r\n        viewConeParameters_: Optional parameters from the 'Ladybug_Cone of Vision' component to further restrict the view to just the range defined by the view cone.\r\n        _____________________: ...\r\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\r\n        parallel_: Set to \"True\" to run the visibility analysis using multiple CPUs.  This can dramatically decrease calculation time but can interfere with other intense computational processes that might be running on your machine.\r\n        _runIt: Set to \"True\" to run the component and perform visibility analysis of the input _geometry.\r\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\r\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\r\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \r\n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\r\n    Returns:\r\n        readMe!: ...\r\n        contextMesh: An uncolored mesh representing the context_ geometry that was input to this component. Connect this output to a \"Mesh\" grasshopper component to preview this output seperately from the others of this component. Note that this mesh is generated before the analysis is run, allowing you to be sure that the right geometry will be run through the analysis before running this component.\r\n        analysisMesh: An uncolored mesh representing the test _geometry that will be analyzed.  Connect this output to a \"Mesh\" grasshopper component to preview this output seperately from the others of this component. Note that this mesh is generated before the analysis is run, allowing you to be sure that the right geometry will be run through the analysis before running this component.\r\n        testPts: The grid of test points on the test _geometry that will be used to perform the visibility analysis.  Note that these points are generated before the analysis is run, allowing you to preview the resolution of the result before you run the component.\r\n        testVec: Vectors for each of the test points on the test _geometry, which indicate the direction for which visibility analysis is performed.  Hook this and the test points up to a Grasshopper \"Vector Display\" component to see how analysis is performed on the test _geometry.\r\n        _____________________: ...\r\n        viewStudyResult: The percentage of _viewTypeOrPoints visible from each of the test points of the input test _geometry.\r\n        viewStudyMesh: A colored mesh of the test _geometry representing the percentage of _viewTypeOrPoints visible by each part of the input _geometry.\r\n        viewStudyLegend: A legend for the visibility analysis showing the percentage of visible points that correspond to the colors of the viewStudyMesh. Connect this output to a grasshopper \"Geo\" component in order to preview the legend separately in the Rhino scene.  \r\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the view study mesh with the grasshopper \"move\" component.\r\n        averageView: The average percentage of the _viewTypeOrPoints seen by all of the test _geometry.\r\n        ptIsVisible: A grafted data stream for each _geometry test point with a \"1\" for each _viewPoint that is visible by the test point and a \"0\" for each _viewPoint that is blocked.\r\n\"\"\"\r\n\r\nghenv.Component.Name = \"Ladybug_View Analysis\"\r\nghenv.Component.NickName = 'viewAnalysis'\r\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\nghenv.Component.Category = \"LB-Legacy\"\r\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\r\n#compatibleLBVersion = VER 0.0.59\\nFEB_14_2016\r\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\r\nexcept: pass\r\n\r\n\r\n\r\nimport rhinoscriptsyntax as rs\r\nfrom clr import AddReference\r\nAddReference('Grasshopper')\r\nimport Grasshopper.Kernel as gh\r\nimport math\r\nimport Rhino as rc\r\nimport sys\r\nimport scriptcontext as sc\r\nimport System.Threading.Tasks as tasks\r\nimport System\r\nimport time\r\nfrom Grasshopper import DataTree\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\n\r\n\r\nw = gh.GH_RuntimeMessageLevel.Warning\r\ne = gh.GH_RuntimeMessageLevel.Error\r\n\r\ninputsDict = {\r\n0: [\"_geometry\", \"Geometry for which visibility analysis will be conducted.  Geometry must be either a Brep, a Mesh, or a list of Breps or Meshes.\"],\r\n1: [\"context_\", \"Context geometry that could block the view from the _viewTypeOrPoints to the test _geometry.  Conext geometry must be either a Brep, a Mesh, or a list of Breps or Meshes.\"],\r\n2: [\"_gridSize_\", \"A number in Rhino model units that represents the average size of a grid cell for visibility analysis on the test _geometry.  This value should be smaller than the smallest dimension of the test _geometry for meaningful results.  Note that, the smaller the grid size, the higher the resolution of the analysis and the longer the calculation will take.\"],\r\n3: [\"_disFromBase\", \"A number in Rhino model units that represents the offset distance of the test point grid from the input test _geometry.  Usually, the test point grid is offset by a small amount from the test _geometry in order to ensure that visibility analysis is done for the correct side of the test _geometry.  If the resulting mesh of this component is offset to the wrong side of test _geometry, you should use the 'Flip' Rhino command on the test _geometry before inputting it to this component.\"],\r\n4: [\"orientationStudyP_\", \"Optional output from the 'Orientation Study Parameter' component.  You can use an Orientation Study input here to answer questions like 'What orientation of my building will give me the highest or lowest visibility from the street?'  An Orientation Study will automatically rotate your input _geometry around several times and record the visibility results each time in order to output a list of values for averageView and a grafted data stream for viewStudyResult.\"],\r\n5: [\"_viewTypeOrPoints\", \"An integer representing the type of view analysis that you would like to conduct or a list of points to which you would like to test the view.  For integer options, choose from the following options: \\n0 - Horizontal Radial - The percentage of the 360 horizontal view band visible from each test point. Use this to study horizontal views from interior spaces to the outdoors. \\n 1 - Horizontal 60 Degree Cone of Vision - The percentage of the 360 horizontal view band bounded on top and bottom by a 30 degree offset from the horizontal (derived from the human cone of vision). Use this to study views from interior spaces to the outdoors. Note that this will discount the _geometry from the calculation and only look at _context that blocks the scene. \\n2 - Spherical - The percentage of the sphere surrounding each of the test points that is not blocked by context geometry. Note that this will discount the _geometry from the calculation and only look at _context that blocks the scene. \\n3 - Sky Exposure - The percentage of the sky that is visible from the points of the input _geometry (as opposed to Sky View, which is the amount of sky seen by a surface).  This is equivalent to a solid angle or even-spaced ray-tracing calculation from the point.  It is useful for evaluating one's general visual connection to the sky at a given set of points. \\n4 - Sky View - The percentage of the sky that is visible from the surface _geometry (as opposed to Sky Exposure, which is the amount of sky seen by the points).  While Sky Exposure treats each patch of the sky with relatively equal weight, sky view weights these patches by their area projected into the plane of the surface being evaluated.  In other words, sky view for a horizontal surface would give more importance to the sky patches that are overhead vs near the horizon.  Sky view is an important factor in for modelling urban heat island since the inability of warm urban surfaces to radiate heat to a cool night sky is one of the largest contributors of the heat island effect.\"],\r\n6: [\"viewPtsWeights_\", \"A list of numbers that align with the test points to assign weights of importance to the several _viewTypeOrPoints that have been connected.  Weighted values should be between 0 and 1 and should be closer to 1 if a certain point is more important. The default value for all points is 0, which means they all have an equal importance. This input could be useful in cases such as the radiative heater example where points on the human body with exposed skin could be weighted at a higher value.\"],\r\n7: [\"geometryBlocksView_\", \"Set to 'True' to have the component count the input _geometry as opaque and set to 'False' to discount the _geometry from the calculation and only look at context_ that blocks the view.  The default is set to 'False' for all types of view studies except for (3 - Sky Exposure) and (4 - Sky View), where the default is set to 'True.'\"],\r\n8: [\"-----\", \"...\"],\r\n9: [\"_____________________\", \"...\"],\r\n10: [\"legendPar_\", \"Optional legend parameters from the Ladybug Legend Parameters component.\"],\r\n11: [\"parallel_\", \"Set to 'True' to run the visibility analysis using multiple CPUs.  This can dramatically decrease calculation time but can interfere with other intense computational processes that might be running on your machine.\"],\r\n12: [\"_runIt\", \"Set to 'True' to run the component and perform visibility analysis of the input _geometry.\"],\r\n13: [\"bakeIt_\", \"An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options: \\n     0 (or False) - No geometry will be baked into the Rhino scene (this is the default). \\n     1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \\n     2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\"]\r\n}\r\n\r\n\r\ndef setComponentInputs():\r\n    for input in range(14):\r\n        if input == 6:\r\n            ghenv.Component.Params.Input[input].NickName = 'viewResolution_'\r\n            ghenv.Component.Params.Input[input].Name = 'viewResolution_'\r\n            ghenv.Component.Params.Input[input].Description = 'An interger between 0 and 4 to set the number of times that the tergenza skyview patches are split.  A higher number will ensure a greater accuracy but will take longer.  The default is set to 0 for a quick calculation.' \r\n        elif input == 8:\r\n            ghenv.Component.Params.Input[input].NickName = 'viewConeParameters_'\r\n            ghenv.Component.Params.Input[input].Name = 'viewConeParameters_'\r\n            ghenv.Component.Params.Input[input].Description = 'Optional parameters from the \"Ladybug_Cone of Vision\" component to further restrict the view to just the range defined by the view cone.' \r\n        else:\r\n            ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\r\n            ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\r\n            ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\r\n\r\ndef restoreComponentInputs():\r\n    for input in range(14):\r\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\r\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\r\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\r\n\r\ndef checkViewType(lb_preparation):\r\n    #Assign default values.\r\n    viewVecs, viewType, patchAreas, geoBlockView = [], -1, [], False\r\n    \r\n    try:\r\n        viewType = int(_viewTypeOrPoints[0])\r\n        if viewType >= 0 and viewType <= 4:\r\n            if viewType >= 3: geoBlockView = True\r\n        else:\r\n            warning = \"_viewTypeOrPoints must be between 0 and 3.\"\r\n            print warning\r\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\r\n            return -1\r\n        \r\n        viewRes = 0\r\n        if viewResolution_ != []:\r\n            try: viewRes = int(viewResolution_[0])\r\n            except:\r\n                warning = \"viewResolution_ must be an integer.\"\r\n                print warning\r\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\r\n                return -1\r\n        viewVecs, patchAreas = checkViewResolution(viewRes, viewType, viewConeParameters_, lb_preparation)\r\n    except:\r\n        try:\r\n            for val in _viewTypeOrPoints:\r\n                vSplit = val.split(',')\r\n                vect = rc.Geometry.Point3d(float(vSplit[0]), float(vSplit[1]), float(vSplit[2]))\r\n                viewVecs.append(vect)\r\n        except:\r\n            warning = \"Input for _viewTypeOrPoints not recognized.\"\r\n            print warning\r\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\r\n            return -1\r\n    \r\n    #Check geometryBlocksView_.\r\n    if geometryBlocksView_ != None: geoBlockView = geometryBlocksView_\r\n    \r\n    return viewVecs, viewType, patchAreas, geoBlockView\r\n\r\ndef checkViewResolution(viewResolution, viewType, viewPar, lb_preparation):\r\n    newVecs = []\r\n    patchAreas = []\r\n    \r\n    #Creeate the view vectors.\r\n    if viewType != 0:\r\n        # View vectors should be generated from Tregenza sky patches.\r\n        skyPatches = lb_preparation.generateSkyGeo(rc.Geometry.Point3d.Origin, viewResolution, 1)\r\n        for patch in skyPatches:\r\n            patchAreaProp = rc.Geometry.AreaMassProperties.Compute(patch)\r\n            patchPt = patchAreaProp.Centroid\r\n            patchA = patchAreaProp.Area\r\n            Vec = None\r\n            if viewType >= 2: Vec = rc.Geometry.Vector3d(patchPt.X, patchPt.Y, patchPt.Z)\r\n            elif viewType == 1 and patchPt.Z < 0.5: Vec = rc.Geometry.Vector3d(patchPt.X, patchPt.Y, patchPt.Z)\r\n            \r\n            if Vec != None:\r\n                newVecs.append(Vec)\r\n                patchAreas.append(patchA)\r\n                if viewType == 1 or viewType == 2:\r\n                    revVec = rc.Geometry.Vector3d(-patchPt.X, -patchPt.Y, -patchPt.Z)\r\n                    newVecs.append(revVec)\r\n                    patchAreas.append(patchA)\r\n    else:\r\n        # View vectors should be generated by a rotation around a circle.\r\n        numberDivisions = (viewResolution+1) * 20\r\n        initAngle = 0\r\n        divisionAngleDeg = 360/numberDivisions\r\n        divisionAngle = math.radians(divisionAngleDeg)\r\n        for count in range(numberDivisions):\r\n            viewVecInit = rc.Geometry.Vector3d.YAxis\r\n            viewVecInit.Rotate(initAngle, rc.Geometry.Vector3d.ZAxis)\r\n            newVecs.append(viewVecInit)\r\n            initAngle += divisionAngle\r\n    \r\n    # If there are view parameters, then apply them to the view vectors.\r\n    if viewPar != []:\r\n        # Find the acceptable horizontal range of the view analysis.\r\n        maxHorizAng = viewPar[4] + viewPar[2]\r\n        minHorizAng = viewPar[4] - viewPar[2]\r\n        orOperator = False\r\n        print minHorizAng\r\n        if maxHorizAng > 360:\r\n            maxHorizAng = maxHorizAng - 360\r\n            orOperator = True\r\n        elif minHorizAng < 0:\r\n            minHorizAng = minHorizAng + 360\r\n            orOperator = True\r\n        \r\n        # Find the acceptable maximum/minimum Z values for the vector.\r\n        maxZVal = math.sin(math.radians(viewPar[0]))\r\n        minZVal = -math.sin(math.radians(viewPar[1]))\r\n        \r\n        # Test each vector to see if it is in the range.\r\n        finalVecs = []\r\n        finalPatchAreas = []\r\n        for count, vec in enumerate(newVecs):\r\n            vecHorizAng = math.degrees(rc.Geometry.Vector3d.VectorAngle(rc.Geometry.Vector3d(vec.X,vec.Y,0), rc.Geometry.Vector3d.YAxis))\r\n            if vec.X < 0:\r\n                vecHorizAng = 360 - vecHorizAng\r\n            if orOperator == False:\r\n                if vecHorizAng > minHorizAng and vecHorizAng < maxHorizAng:\r\n                    if vec.Z > minZVal and vec.Z < maxZVal:\r\n                        finalVecs.append(vec)\r\n                        finalPatchAreas.append(patchAreas[count])\r\n            elif orOperator == True:\r\n                if vecHorizAng > minHorizAng or vecHorizAng < maxHorizAng:\r\n                    if vec.Z > minZVal and vec.Z < maxZVal:\r\n                        finalVecs.append(vec)\r\n                        finalPatchAreas.append(patchAreas[count])\r\n        newVecs = finalVecs\r\n        patchAreas = finalPatchAreas\r\n    \r\n    return newVecs, patchAreas\r\n\r\n\r\ndef openLegend(legendRes):\r\n    if len(legendRes)!=0:\r\n        meshAndCrv = []\r\n        meshAndCrv.append(legendRes[0])\r\n        [meshAndCrv.append(c) for c in legendRes[1]]\r\n        return meshAndCrv\r\n    else: return\r\n\r\n\r\ndef runAnalyses(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs, parallel, viewPoints_viewStudy, viewPtsWeights, conversionFac, viewType, patchAreas, geoBlockView, lb_mesh, lb_runStudy_GH):\r\n    listInfo = ['key:location/dataType/units/frequency/startsAt/endsAt', 'City/Latitude', 'View Analysis', '%', 'NA', (1, 1, 1), (12, 31, 24)]\r\n    if parallel:\r\n        try:\r\n            for geo in analysisSrfs + contextSrfs: geo.EnsurePrivateCopy()\r\n        except: pass\r\n    \r\n    # join the meshes\r\n    joinedAnalysisMesh = lb_mesh.joinMesh(analysisSrfs)\r\n    if contextSrfs: joinedContext = lb_mesh.joinMesh(contextSrfs)\r\n    else: joinedContext = None\r\n    \r\n    viewResults, averageViewResults, ptVisibility = lb_runStudy_GH.parallel_viewCalculator(testPoints, ptsNormals, meshSrfAreas, joinedAnalysisMesh, joinedContext, parallel, viewPoints_viewStudy, viewPtsWeights, conversionFac, viewType, patchAreas, geoBlockView)\r\n    \r\n    return [viewResults], [averageViewResults], listInfo, ptVisibility\r\n\r\n\r\ndef resultVisualization(contextSrfs, analysisSrfs, results, totalResults, legendPar, legendTitle, studyLayerName, bakeIt, checkTheName, l, angle, listInfo, runOrientation, viewType, lb_visualization, lb_preparation):\r\n    #Check the analysis Type.\r\n    projectName = 'ViewStudy'\r\n    \r\n    #Read Legend Parameters.\r\n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\r\n    if len(legendPar_) == 0: customColors = lb_visualization.gradientLibrary[3]\r\n    elif legendPar_[3] == []: customColors = lb_visualization.gradientLibrary[3]\r\n    \r\n    colors = lb_visualization.gradientColor(results, lowB, highB, customColors)\r\n    \r\n    # color mesh surfaces\r\n    analysisSrfs = lb_visualization.colorMesh(colors, analysisSrfs)\r\n    \r\n    ## generate legend\r\n    # calculate the boundingbox to find the legendPosition\r\n    if not (runOrientation and legendBasePoint==None):\r\n        lb_visualization.calculateBB([analysisSrfs, contextSrfs])\r\n    # legend geometry\r\n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(results, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\r\n    \r\n    # legend colors\r\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\r\n    # color legend surfaces\r\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\r\n    \r\n    if viewType == -1: customHeading = '\\n\\nView Analysis' + '\\n#View Points = ' + `len(_viewTypeOrPoints)`\r\n    elif viewType == 0: customHeading = '\\n\\nHorizontal Radial View Analysis'\r\n    elif viewType == 1: customHeading = '\\n\\nHorizontal 60-Degree Cone-Of-Vision Analysis'\r\n    elif viewType == 2: customHeading = '\\n\\nSpherical View Analysis'\r\n    elif viewType == 3: customHeading = '\\n\\nSky Exposure Analysis'\r\n    else: customHeading = '\\n\\nSky View Analysis'\r\n    if runOrientation:\r\n        try: customHeading = customHeading + '\\nRotation Angle: ' + `angle` + ' Degrees'\r\n        except: pass\r\n    titleTextCurve, titleStr, titlebasePt = lb_visualization.createTitle([listInfo], lb_visualization.BoundingBoxPar, legendScale, customHeading, True, legendFont, legendFontSize, legendBold)\r\n    \r\n    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\r\n    \r\n    if bakeIt > 0:\r\n        legendText.append(titleStr)\r\n        textPt.append(titlebasePt)\r\n        # check the study type\r\n        newLayerIndex, l = lb_visualization.setupLayers(totalResults, 'LADYBUG', projectName,\r\n                                                        studyLayerName, checkTheName,\r\n                                                        runOrientation, angle, l)\r\n        if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, analysisSrfs, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, True)\r\n        else: lb_visualization.bakeObjects(newLayerIndex, analysisSrfs, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, False)\r\n    \r\n    return analysisSrfs, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], l, legendBasePoint\r\n\r\n\r\n\r\ndef main(geometry, context, gridSize, disFromBase, orientationStudyP, viewPoints_viewStudy, legendPar, parallel, bakeIt):\r\n    # import the classes\r\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\r\n    lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\r\n    lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\r\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\r\n    \r\n    conversionFac = lb_preparation.checkUnits()\r\n    \r\n    #Check the view type.\r\n    viewType = -1\r\n    viewCheck = checkViewType(lb_preparation)\r\n    if viewCheck != -1:\r\n        viewPoints_viewStudy, viewType, patchAreas, geoBlockView = viewCheck\r\n    else: return -1\r\n    \r\n    try: viewPtsWeights = viewPtsWeights_\r\n    except: viewPtsWeights = viewResolution_\r\n    \r\n    # read orientation study parameters\r\n    runOrientation, rotateContext, rotationBasePt, angles = lb_preparation.readOrientationParameters(orientationStudyP)\r\n    \r\n    # mesh the test buildings\r\n    ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\r\n    analysisMesh, analysisBrep = lb_preparation.cleanAndCoerceList(geometry)\r\n    \r\n    originalTestPoints = []\r\n    if gridSize == None:\r\n        gridSize = 4/conversionFac\r\n    \r\n    ## mesh Brep\r\n    analysisMeshedBrep = lb_mesh.parallel_makeSurfaceMesh(analysisBrep, float(gridSize))\r\n    \r\n    ## Flatten the list of surfaces\r\n    analysisMeshedBrep = lb_preparation.flattenList(analysisMeshedBrep)\r\n    analysisSrfs = analysisMesh + analysisMeshedBrep\r\n    \r\n    ## extract test points\r\n    testPoints, ptsNormals, meshSrfAreas = lb_mesh.parallel_testPointCalculator(analysisSrfs, float(disFromBase), parallel)\r\n    originalTestPoints = testPoints\r\n    testPoints = lb_preparation.flattenList(testPoints)\r\n    ptsNormals = lb_preparation.flattenList(ptsNormals)\r\n    meshSrfAreas = lb_preparation.flattenList(meshSrfAreas)\r\n    \r\n    ## mesh context\r\n    if len(context)!=0 and gridSize and disFromBase:\r\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\r\n        contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(context)\r\n        \r\n        ## mesh Brep\r\n        contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\r\n        \r\n        ## Flatten the list of surfaces\r\n        contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\r\n        contextSrfs = contextMesh + contextMeshedBrep\r\n    else: contextSrfs = []\r\n    \r\n    \r\n    ## data for visualization\r\n    CheckTheName = True\r\n    resV = 0 # Result visualization\r\n    l = [0, 0, 0] # layer name indicator\r\n    \r\n    ## check for orientation Study\r\n    if runOrientation and (len(viewPoints_viewStudy)!= 0 and viewPoints_viewStudy!=[]):\r\n        if not isinstance(rotateContext, System.Boolean):\r\n            #inputs are geometries and should be set as the context to be rotated\r\n            rContextMesh, rContextBrep = rotateContext\r\n            \r\n            ## mesh Brep\r\n            rContextMeshedBrep = lb_mesh.parallel_makeContextMesh(rContextBrep)\r\n            \r\n            ## Flatten the list of surfaces\r\n            rContextMeshedBrep = lb_preparation.flattenList(rContextMeshedBrep)\r\n            rContextSrfs = rContextMesh + rContextMeshedBrep\r\n            rotateContext = \"Partial\"\r\n        elif rotateContext == True:\r\n            rContextSrfs = contextSrfs\r\n        else:\r\n            rContextSrfs = None\r\n            \r\n        # create rotation base point\r\n        if rotationBasePt == 'set2center'and rotateContext==\"Partial\":\r\n            # find the bounding box for the test geometry and context\r\n            lb_visualization.calculateBB([analysisSrfs, rContextSrfs])\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n        elif rotationBasePt == 'set2center'and rotateContext:\r\n            # find the bounding box for the test geometry and context\r\n            lb_visualization.calculateBB([analysisSrfs, rContextSrfs])\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n        elif rotationBasePt == 'set2center'and not rotateContext:\r\n            lb_visualization.calculateBB(analysisSrfs)\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n            # this is stupid and should be fixed later but for now I let it be!\r\n            lb_visualization.calculateBB([analysisSrfs, contextSrfs])\r\n            \r\n        # total result is a list of lists\r\n        orirntationStudyRes = {}\r\n        totalResults = []\r\n        angleCount = 0\r\n        for angle in range(len(angles) - 1):\r\n            rotationT = (rc.Geometry.Transform.Rotation(math.radians(angles[angle + 1] - angles[angle]) , rc.Geometry.Vector3d.ZAxis, rotationBasePt))\r\n            # rotate the geometry, and points (and maybe the context)\r\n            # print angles[angle + 1] - angles[angle] # there is a bug here!\r\n            [srf.Transform(rotationT) for srf in analysisSrfs]\r\n            [p.Transform(rotationT) for p in testPoints]\r\n            [n.Transform(rotationT) for n in  ptsNormals]\r\n            if rotateContext == \"Partial\":\r\n                [msh.Transform(rotationT) for msh in rContextSrfs]\r\n                # put the rotated mesh next to the rest of the context\r\n                mergedContextSrfs = rContextSrfs + contextSrfs\r\n            elif rotateContext:\r\n                [msh.Transform(rotationT) for msh in rContextSrfs]\r\n                mergedContextSrfs = rContextSrfs\r\n            else:\r\n                mergedContextSrfs = contextSrfs\r\n                        \r\n            ## run the analysis\r\n            cumSky_radiationStudy = []\r\n            sunVectors_sunlightHour = []\r\n            \r\n            results, eachTotalResult, listInfo, pointVisiblity = runAnalyses(testPoints, ptsNormals, meshSrfAreas,\r\n                                        analysisSrfs, mergedContextSrfs, parallel, viewPoints_viewStudy, viewPtsWeights,\r\n                                        conversionFac, viewType, patchAreas, geoBlockView, lb_mesh, lb_runStudy_GH)\r\n            \r\n            #collect surfaces, results, and values\r\n            orirntationStudyRes[angle] = {\"angle\" : angle,\r\n                                          \"totalResult\": eachTotalResult,\r\n                                          \"results\": results,\r\n                                          \"listInfo\": listInfo,\r\n                                          \"contextSrf\" : lb_mesh.joinMesh(mergedContextSrfs),\r\n                                          \"analysisSrf\": lb_mesh.joinMesh(analysisSrfs)\r\n                                          }\r\n            \r\n            # print\r\n            totalResults.append(eachTotalResult)\r\n            angleCount += 1\r\n            \r\n        if legendPar== [] or (legendPar[0] == None and legendPar[1] == None):\r\n            # find max and min for the legend\r\n            minValue = float(\"inf\") \r\n            maxValue = 0\r\n            allBuildingsAndContext = []\r\n            for key in orirntationStudyRes.keys():\r\n                # results is a nested list because the component used to be all in one\r\n                # I should re-write this component at some point\r\n                listMin = min(orirntationStudyRes[key][\"results\"][0])\r\n                listMax = max(orirntationStudyRes[key][\"results\"][0])\r\n                if  listMin < minValue: minValue = listMin\r\n                if  listMax > maxValue: maxValue = listMax\r\n                \r\n                if legendPar== [] or legendPar[4] == None:\r\n                    allBuildingsAndContext.extend([orirntationStudyRes[key][\"analysisSrf\"], orirntationStudyRes[key][\"contextSrf\"]])\r\n            \r\n            # find the collective bounding box\r\n            if legendPar== [] or legendPar[4] == None:\r\n                lb_visualization.calculateBB(allBuildingsAndContext)\r\n            \r\n            # preset the legend parameters if it is not set by the user\r\n            if legendPar== []:\r\n                legendPar = [minValue, maxValue, None, [], lb_visualization.BoundingBoxPar, 1, 'Verdana', None, False, 2, False]\r\n            else:\r\n                if legendPar[0] == None: legendPar[0] = minValue\r\n                if legendPar[1] == None: legendPar[1] = maxValue\r\n                if legendPar[4] == None: legendPar[4] = lb_visualization.BoundingBoxPar\r\n                if legendPar[5] == None or float(legendPar[5])==0: legendPar[5] = 1\r\n                if legendPar[6] == None: legendPar[6] = 'Verdana'\r\n                if legendPar[7] == None: legendPar[7] = None\r\n                if legendPar[8] == None: legendPar[8] = False\r\n                if legendPar[9] == None: legendPar[9] = 2\r\n                if legendPar[10] == None: legendPar[10] = False\r\n        \r\n        for angleCount, angle in enumerate(range(len(angles) - 1)):\r\n            if (bakeIt or angles[angle + 1] == angles[-1]) and results!=-1:\r\n                \r\n                # read the values for each angle from the dictionary\r\n                eachTotalResult = orirntationStudyRes[angle][\"totalResult\"]\r\n                mergedContextSrfs = orirntationStudyRes[angle][\"contextSrf\"]\r\n                analysisSrfs = orirntationStudyRes[angle][\"analysisSrf\"]\r\n                listInfo = orirntationStudyRes[angle][\"listInfo\"]\r\n                results = orirntationStudyRes[angle][\"results\"]\r\n                \r\n                \r\n                resultColored = [[] for x in range(len(results))]\r\n                legendColored = [[] for x in range(len(results))]\r\n                if angleCount > 0: CheckTheName = False\r\n                \r\n                for i in range(len(results)):\r\n                    if results[0]!=[] and results[i]!= None:\r\n                        # Add an option for orientation study\r\n                        # The i is a reminder from the time that all the analysis components was a single component\r\n                        # so confusing!\r\n                        #eachTotalResult = [[],[],[]]\r\n                        resultColored[i], legendColored[i], l[i], legendBasePoint = resultVisualization(mergedContextSrfs, analysisSrfs,\r\n                                          results[0], eachTotalResult[0], legendPar, '%',\r\n                                          'VIEW_STUDIES', bakeIt, CheckTheName, l[i], angles[angle + 1], listInfo, runOrientation, viewType, lb_visualization, lb_preparation)\r\n                        resV += 1\r\n    else:\r\n        # no orientation study\r\n        angle = 0; l = [0]\r\n        results, totalResults, listInfo, pointVisiblity = runAnalyses(testPoints, ptsNormals, meshSrfAreas,\r\n                                analysisSrfs, contextSrfs, parallel, viewPoints_viewStudy, viewPtsWeights,\r\n                                conversionFac, viewType, patchAreas, geoBlockView, lb_mesh, lb_runStudy_GH)\r\n    \r\n    #Returen view vectors is the vector method is specified.\r\n    viewVecs = []\r\n    if viewType != -1: viewVecs = viewPoints_viewStudy\r\n    \r\n    #Return the results\r\n    if results!=-1 and viewPoints_viewStudy == []:\r\n        #No view type or points have been selected.  We're just showing the gridsize.\r\n        #contextSrfs, analysisSrfs, testPoints, ptsNormals = results\r\n        return contextSrfs, analysisSrfs, testPoints, ptsNormals, originalTestPoints, viewVecs\r\n    elif results != -1:\r\n        #A view study has been run.\r\n        if not runOrientation:\r\n            totalResults = [totalResults] # make a list of the list so the same process can be applied to orientation study and normal run\r\n        else:\r\n            bakeIt = False\r\n        \r\n        resultColored = []\r\n        legendColored = []\r\n        [resultColored.append([]) for x in range(len(results))]\r\n        [legendColored.append([]) for x in range(len(results))]\r\n        \r\n        for i in range(len(results)):\r\n            if results[i]!= None:\r\n                # Add an option for orientation study\r\n                resultColored[i], legendColored[i], l[i], legendBasePoint = resultVisualization(contextSrfs, analysisSrfs,\r\n                                  results[i], totalResults[0][i], legendPar, '%',\r\n                                  'VIEW_STUDIES', bakeIt, CheckTheName, 0, angles[-1], listInfo, runOrientation, viewType, lb_visualization, lb_preparation)\r\n                resV += 1\r\n        \r\n        # return outputs\r\n        if runOrientation: contextSrfs = mergedContextSrfs\r\n        if resV != 0: return contextSrfs, analysisSrfs, testPoints, ptsNormals, viewVecs, results, resultColored, legendColored, totalResults, legendBasePoint, originalTestPoints, pointVisiblity\r\n        else: return -1\r\n    else:\r\n        return -1\r\n\r\n\r\n\r\n\r\n\r\ninitCheck = True\r\n#Ladybug check.\r\nif not sc.sticky.has_key('ladybug_release') == True:\r\n    initCheck = False\r\n    print \"You should first let Ladybug fly...\"\r\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\r\nelse:\r\n    try:\r\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\r\n        if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): pass\r\n    except:\r\n        initCheck = False\r\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\r\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\r\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\r\n        \"into canvas and try again.\"\r\n        ghenv.Component.AddRuntimeMessage(w, warning)\r\n\r\n#Set the Inputs.\r\ntry:\r\n    viewType = int(_viewTypeOrPoints[0])\r\n    setComponentInputs()\r\nexcept:\r\n    restoreComponentInputs()\r\n\r\n#Run the component.\r\nif _runIt and len(_geometry)!=0 and _geometry[0] != None and _disFromBase and initCheck == True and _viewTypeOrPoints:\r\n    result = main(_geometry, context_, _gridSize_, _disFromBase, orientationStudyP_, _viewTypeOrPoints, legendPar_, parallel_, bakeIt_)\r\n    \r\n    if result!= -1:\r\n        if len(result) == 6:\r\n            contextMesh, analysisMesh, testPts_flatten, testVec_flatten, originalTestPoints, viewVec = result\r\n            viewStudyMesh, viewStudyLegend = None, None\r\n        elif len(result) > 6:\r\n            # Assign the result to GH component outputs\r\n            contextMesh, analysisMesh, testPts_flatten, testVec_flatten, viewVec = result[0], result[1], result[2], result[3], result[4]\r\n            \r\n            viewStudyResult_flatten = result[5][0]\r\n            viewStudyMesh = result[6][0]\r\n            viewStudyLegend = openLegend(result[7][0])\r\n            \r\n            # total results\r\n            averageView = []\r\n            for res in result[8]:\r\n                averageView.append(res[0])\r\n            \r\n            legendBasePt = result[-3]\r\n            originalTestPoints = result[-2]\r\n            pointsVisibility = result[-1]\r\n        \r\n        testPts = DataTree[System.Object]()\r\n        testVec = DataTree[System.Object]() \r\n        ptIsVisible = DataTree[System.Object]()\r\n        viewStudyResult = DataTree[System.Object]()\r\n        \r\n        # graft test points\r\n        ptCount = 0\r\n        for i, ptList in enumerate(originalTestPoints):\r\n            p = GH_Path(i)\r\n            for pCount, pt in enumerate(ptList):\r\n                testPts.Add(pt, p)\r\n                testVec.Add(testVec_flatten[ptCount], p)\r\n                if result!= -1 and len(result) != 5:\r\n                    #try:\r\n                    q = GH_Path(i, pCount)\r\n                    viewStudyResult.Add(viewStudyResult_flatten[ptCount], p)\r\n                    ptIsVisible.AddRange(pointsVisibility[ptCount], q)\r\n                    #except: pass\r\n                ptCount += 1\r\n    else: print \"Canceled by user!\"\r\n\r\n\r\nghenv.Component.Params.Output[1].Hidden = True\r\nghenv.Component.Params.Output[2].Hidden = True\r\nghenv.Component.Params.Output[3].Hidden = True\r\nghenv.Component.Params.Output[10].Hidden = True",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}