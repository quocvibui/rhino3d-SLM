{
  "source_url": "https://github.com/andrewili/shape-grammar-engine/blob/2859d8021442542561bdd1387deebc85e26f2d03/rhino-translators/rule_exporter_oo.py",
  "repo": "andrewili/shape-grammar-engine",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "rhino-translators/rule_exporter_oo.py",
  "instruction": "rule_exporter_oo.py",
  "code": "#   rule_exporter_oo.py\n\nimport rhinoscriptsyntax as rs\nimport rule\nimport shape\n\nclass RuleExporterOO(object):\n    def __init__(self):\n        pass\n\n    ###\n    def export_rule(self):\n        left_shape = self._get_shape('left')\n        right_shape = self._get_shape('right')\n        the_rule = self._get_rule(left_shape, right_shape)\n        self._write_rule_file(the_rule)\n\n    ###\n    def _get_shape(self, side):\n        \"\"\"Receives 'left' or 'right':\n            str\n        Prompts for elements (lines and textdots) and a name. Returns the new \n        shape:\n            Shape\n        \"\"\"\n                                        #   left shape must not be empty\n        prompt_for_elements = (\n            'Select the lines and textdots in the %s shape' % side)\n        guids = rs.GetObjects(\n            prompt_for_elements,\n            rs.filter.curve + rs.filter.textdot)\n        if side == 'left':\n            while guids == None:\n                prompt_for_elements = (\n                    'The left shape may not be empty. ' +\n                    'Select the lines and textdots in the left shape')\n                guids = rs.GetObjects(\n                    prompt_for_elements,\n                    rs.filter.curve + rs.filter.textdot)\n        elif side == 'right':\n            if guids == None:\n                guids = []\n        else:\n            pass\n        line_specs, lpoint_specs = (\n            self._get_line_specs_and_lpoint_specs(guids))\n        prompt_for_name = (\n            'Enter the name of the %s shape' % side)\n        name = rs.GetString(prompt_for_name)\n        new_shape = shape.Shape(name, line_specs, lpoint_specs)\n        return new_shape\n\n    def _get_line_specs_and_lpoint_specs(self, guids):\n        \"\"\"Receives a list of line or textdot guids:\n            [guid, ...]\n        Returns a list of coord-coord pairs and a list of coord-label pairs:\n            (   [((num, num, num), (num, num, num)), ...],\n                [((num, num, num), str), ...]\n            )\n        \"\"\"\n        line_specs = []\n        lpoint_specs = []\n        line_type = 4\n        textdot_type = 8192\n        for guid in guids:\n            guid_type = rs.ObjectType(guid)\n            if guid_type == line_type:\n                line_spec = self._get_line_spec(guid)\n                line_specs.append(line_spec)\n            elif guid_type == textdot_type:\n                coord, label = self._get_lpoint_spec(guid)\n                lpoint_spec = (coord, label)\n                lpoint_specs.append(lpoint_spec)\n        return (line_specs, lpoint_specs)\n\n    def _get_line_spec(self, line_guid):\n        \"\"\"Receives a line guid:\n            Guid\n        Returns a line spec:\n            ((num, num, num,), (num, num, num))\n        \"\"\"\n        point_pair = rs.CurvePoints(line_guid)\n        coord_pair = []\n        for point in point_pair:\n            coord = self._point_to_coord(point)\n            coord_pair.append(coord)\n        return (coord_pair[0], coord_pair[1])\n\n    def _get_lpoint_spec(self, textdot_guid):\n        \"\"\"Receives a textdot guid:\n            Guid\n        Returns a labeled point spec:\n            ((num, num, num), label)\n        \"\"\"\n        point = rs.TextDotPoint(textdot_guid)\n        coord = self._point_to_coord(point)\n        label = rs.TextDotText(textdot_guid)\n        return (coord, label)\n\n    def _point_to_coord(self, point):\n        \"\"\"Receives a point guid:\n            Guid\n        Returns a coord:\n            ((num, num, num))\n        \"\"\"\n        coord = (point.X, point.Y, point.Z)\n        return coord\n\n    ###\n    def _get_rule(self, left_shape, right_shape):\n        \"\"\"Receives the left and right shapes:\n            Shape\n            Shape\n        Prompts for a name. Returns the new rule:\n            Rule\n        \"\"\"\n        prompt_for_name = 'Enter the name of the rule'\n        name = rs.GetString(prompt_for_name)\n        new_rule = rule.Rule(name, left_shape, right_shape)\n        return new_rule\n\n    ###\n    def _write_rule_file(self, rule_in):\n        \"\"\"Writes the rule string to the file <rule name>.rul\n        \"\"\"\n        filter = \"RUL file (*.rul)|*.rul|All files (*.*)|*.*||\"\n        rule_name = rule_in.name\n        file_name = (\n            rs.SaveFileName('Save rule as', filter, '', rule_name))\n        if not file_name: \n            return\n        file = open(file_name, \"w\" )\n        empty_line = ''\n        rule_string = '\\n'.join([\n            rule_in.__str__(), \n            empty_line])\n        # rule_string = rule_in.__str__()\n        file.write(rule_string)\n        file.close()\n        print(rule_string)\n\nif __name__ == '__main__':\n    exporter = RuleExporterOO()\n    exporter.export_rule()\n    # import doctest\n    # doctest.testfile('tests/rule_exporter_oo_test.txt')\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}