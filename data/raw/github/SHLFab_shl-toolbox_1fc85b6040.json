{
  "source_url": "https://github.com/SHLFab/shl-toolbox/blob/268349a38b254c507c73a5a12f81f05d8af3acfc/lib/geo.py",
  "repo": "SHLFab/shl-toolbox",
  "repo_stars": 1,
  "repo_description": "SHL Fabrication tools",
  "license": "AGPL-3.0",
  "filepath": "lib/geo.py",
  "instruction": "help docstring",
  "code": "\"\"\"help docstring\"\"\"\n#workshop_lib\n#rhino geometry functions\n\n#SHL Architects\n#Sean Lamb 2018-11-02\n#TODO: define an __all__\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nfrom scriptcontext import doc\nimport scriptcontext as sc\nimport System\n\nimport shl_toolbox_lib.util as wut\nreload(wut)\n\nimport random as rand\nfrom collections import namedtuple\n\n\ndef get_bounding_dims(brep):\n\t\"\"\"return bounding box x,y,z dims for a brep or many breps\"\"\"\n\tbb = rs.BoundingBox(brep)\n\tDimensions = namedtuple('Dimensions','X Y Z')\n\tdims = Dimensions( rs.Distance(bb[0],bb[1]), rs.Distance(bb[0],bb[3]), rs.Distance(bb[0],bb[4]) )\n\treturn dims\n\n\ndef get_brep_base_plane(brep):\n\t\"\"\"param: brep\n\treturn: xy plane at bb lower left corner\"\"\"\n\tbb = rs.BoundingBox(brep)\n\treturn rs.PlaneFromNormal(bb[0],[0,0,1],[1,0,0])\n\n\ndef get_brep_height(brep):\n\t\"\"\"get height of a brep's bounding box\n \tparam: brep\n\treturn: height (z of bounding box)\"\"\"\n\tbb = rs.BoundingBox(brep)\n\treturn rs.Distance(bb[0],bb[4])\n\n\ndef get_brep_plan_cut(brep,cut_height,tolerance):\n\t\"\"\"cut a brep at a certain height. returns list of geometry.polycurve\n\ttolerance should be the document tolerance.\n\tNOTE: attempts to join the curves.\"\"\"\n\tbb = rs.BoundingBox(brep)\n\theight = rs.Distance(bb[0],bb[4])\n\n\t#get middle section and get polycurve\n\tmidplane_pts = rs.MoveObjects(bb[0:4],[0,0,cut_height])\n\tplane = rs.PlaneFromPoints(bb[0],bb[1],bb[3])\n\trs.DeleteObjects(midplane_pts)\n\n\tbool_merged = Rhino.Geometry.Brep.MergeCoplanarFaces(brep,tolerance)\n\tg = Rhino.Geometry.Intersect.Intersection.BrepPlane(brep,plane,tolerance)\n\tg_polycurves = g[1]\n\tg_polycurves = Rhino.Geometry.Curve.JoinCurves(g_polycurves,tolerance)\n\n\treturn g_polycurves\n\n\ndef get_brep_plan_cut_use_plane(brep,plane,tolerance):\n\t\"\"\"cut a brep at a certain plane. returns list of geometry.polycurve\n\tmerge_tolerance should be the document tolerance.\n\tNOTE: attempts to join the curves.\"\"\"\n\n\tbool_merged = Rhino.Geometry.Brep.MergeCoplanarFaces(brep,tolerance)\n\tg = Rhino.Geometry.Intersect.Intersection.BrepPlane(brep,plane,tolerance)\n\tg_polycurves = g[1]\n\tg_polycurves = Rhino.Geometry.Curve.JoinCurves(g_polycurves,tolerance)\n\n\treturn g_polycurves\n\n\ndef get_internal_angles(pts):\n\t\"\"\"get the internal angles of a set of pts representing a\n\tcounter-clockwise polyline.\"\"\"\n\tangle_list = []\n\tfor i in xrange(0,len(pts)):\n\t\tstart = (i-1)%len(pts)\n\t\tmid = (i)%len(pts)\n\t\tend = (i+1)%len(pts)\n\t\tline_a = [pts[mid],pts[end]]\n\t\tline_b = [pts[mid],pts[start]]\n\n\t\tangle = rs.Angle2(line_a, line_b) #returns [smaller,larger] angles.\n\t\tangle_index = 1\n\n\t\tvect_a = rs.VectorCreate(line_a[0],line_a[1])\n\t\tvect_b = rs.VectorCreate(line_b[0],line_b[1])\n\t\tif wut.xprod(vect_a,vect_b) > 0:\n\t\t\tangle_index = 0\n\n\t\tangle_list.append(angle[angle_index])\n\treturn angle_list\n\n\ndef make_pcurve_ccw(geo_polycurve):\n\t\"\"\"accepts a rhino geometry.polycurve object and makes it counter-clockwise.\n\tTODO: make this general for all curve types if possible.\"\"\"\n\torientation = geo_polycurve.ClosedCurveOrientation()\n\tif str(orientation) == \"Clockwise\":\n\t\tgeo_polycurve.Reverse()\n\n\ndef get_interior_pt(g_curve,sample_distance,quality=10):\n\t\"\"\"get an interior point in the brep.\n\tg_curve: curve geometry\n\tquality=100: number of spots to try.\n\treturn: point3d.\"\"\"\n\tvector_size = doc.ActiveDoc.ModelAbsoluteTolerance*5000\n\n\tplanarBrep = Rhino.Geometry.Brep.CreatePlanarBreps(g_curve)[0]\n\tsrf = planarBrep.Faces[0]\n\tdomU = srf.Domain(0)\n\tdomV = srf.Domain(1)\n\n\tpts = []\n\toutside =  Rhino.Geometry.PointContainment.Outside\n\tfailure = Rhino.Geometry.PointContainment.Unset\n\n\tv = rs.VectorCreate([0,0,0],[0,1,0])\n\textremes = g_curve.ExtremeParameters(v)\n\n\tinterior_pt = None\n\tfor param in extremes:\n\n\t\tfor j in xrange(quality):\n\n\t\t\tpointat = g_curve.PointAt(param)\n\t\t\tmove_vector = rs.VectorCreate([0,0,0],[rand.uniform(-1,1),rand.uniform(-1,1),0])\n\t\t\tmove_vector = rs.VectorScale( rs.VectorUnitize(move_vector), sample_distance )\n\t\t\ttransform = Rhino.Geometry.Transform.Translation(move_vector)\n\t\t\tpointat.Transform(transform)\n\t\t\trs.AddPoint(pointat)\n\t\t\tprint g_curve.Contains(pointat)\n\t\t\tif g_curve.Contains(pointat) != ( outside or failure ):\n\t\t\t\tprint \"containment\"\n\t\t\t\treturn pointat\n\treturn pointat\n\n\ndef get_polycurve_segment_points(g_polycurve):\n\t\"\"\"returns [startpts,endpts,midpts] list for a polycurve\"\"\"\n\tstartpts = []\n\tendpts = []\n\tmidpts = []\n\n\tfor i in xrange(g_polycurve.SegmentCount):\n\t\tseg = g_polycurve.SegmentCurve(i)\n\t\tseg_len = seg.GetLength()\n\t\tendpts.append(seg.PointAtEnd)\n\t\tstartpts.append(seg.PointAtStart)\n\t\tmidpts.append(seg.PointAtLength(seg_len/2))\n\n\treturn [startpts,endpts,midpts]\n\n\ndef get_extreme_srf(brep,h_tol,top=True):\n\n\t\"\"\"\n\talgorithm:\n\t1. pick n random pts on each surface, P\n\t2. get the 3 lowest points in P (disabled for now; just does straight averaging)\n\t3. determine their dot product with the unit z and their avg height\n\t4. throw out all surfaces that aren't within the dot product threshold.\n\t5. of the remaining surfaces, sort to get the lowest one. if any of them have a height within the\n\theight tolerance, select them as well.\n\t6. return these lowest srfs.\n\t\"\"\"\n\tsample_num = 100\n\ts_avg_normal, s_avg_height, s_srf = [ [],[],[] ]\n\tdotprod_threshold = 0.9\n\n\tfor s in brep.Faces:\n\t\tu, v = [s.Domain(0), s.Domain(1)]\n\t\ttest_params = [(rand.uniform(u.T0,u.T1), rand.uniform(v.T0,v.T1)) for i in xrange(sample_num)]\n\t\ttest_points = [s.PointAt(p[0],p[1]) for p in test_params]\n\t\t#sort params and points by z\n\t\ttest_points, test_params = zip(*sorted(zip(test_points,test_params), key=lambda x: x[0].Z, reverse=False))\n\n\t\ttest_Z = sum([t.Z for t in test_points]) / len(test_points)\n\t\tdotprods = [rs.VectorDotProduct(s.NormalAt(p[0],p[1]),[0,0,1]) for p in test_params]\n\t\tavg_dotprod = sum(dotprods) / len(dotprods)\n\n\t\tif top == False: avg_dotprod = -avg_dotprod #flip if searching for bottom.\n\t\tif (avg_dotprod) > dotprod_threshold:\n\t\t\ts_avg_normal.append(avg_dotprod)\n\t\t\ts_avg_height.append(test_Z)\n\t\t\ts_srf.append(s)\n#\t\t\tfor i,p in enumerate(test_points):\n#\t\t\t\tdocpt = rs.AddPoint(p)\n#\t\t\t\tif i<5:\n#\t\t\t\t\trs.ObjectLayer(docpt,\"Layer 05\")\n\n\t#if top == True, search from the top...\n\tif top == False:\n\t\ts_avg_normal,s_avg_height,s_srf = zip(*sorted(zip(s_avg_normal,s_avg_height,s_srf), key=lambda x: x[1],reverse=False))\n\n\t\theight_threshold = s_avg_height[0] + h_tol\n\t\textreme_surfaces = []\n\n\t\tfor srf,height in zip(s_srf,s_avg_height):\n\t\t\tif height < height_threshold: extreme_surfaces.append(srf)\n\telse:\n\t\ts_avg_normal,s_avg_height,s_srf = zip(*sorted(zip(s_avg_normal,s_avg_height,s_srf), key=lambda x: x[1],reverse=True))\n\n\t\theight_threshold = s_avg_height[0] - h_tol\n\t\textreme_surfaces = []\n\n\t\tfor srf,height in zip(s_srf,s_avg_height):\n\t\t\tif height > height_threshold: extreme_surfaces.append(srf)\n\n\treturn extreme_surfaces\n\n\ndef brepClosestPoint(b1,b2,precision):\n\tbb1 = b1.GetBoundingBox(False)\n\tbbPt1 = bb1.PointAt(random.random(), random.random(), random.random())\n\n\tpt1 = b1.ClosestPoint(bbPt1)\n\tpt2 = b2.ClosestPoint(pt1)\n\n\tfor i in range(precision):\n\t\tpt1 = b1.ClosestPoint(pt2)\n\t\tpt2 = b2.ClosestPoint(pt1)\n\n\tprint 'done brepclosestpoint'\n\tprint 'pts are', pt1, pt2\n\treturn [pt1,pt2]\n\n\ndef multi_test_in_or_out(test_crv, vols):\n\t\"\"\"tests midpoint of curve for containment inside one of several volumes\n\t#returns True if point is inside at least one of the volumes, otherwise False\"\"\"\n\trc=False\n\tdom=rs.CurveDomain(test_crv)\n\tif dom==None:\n\t\t#debug print \"bad domain\"\n\t\treturn rc\n\tc_midpt=rs.EvaluateCurve(test_crv,(dom[0]+dom[1])/2)\n\tif c_midpt==None:\n\t\t#debug print \"bad curve\"\n\t\treturn rc\n\tfor vol in vols:\n\t\tif rs.IsPointInSurface(vol,c_midpt,True,sc.doc.ModelAbsoluteTolerance):\n\t\t\t#curve is inside one of the volumes\n\t\t\trc=True\n\t\t\tbreak\n\treturn rc\n\n\ndef check_planar_curves_collision(crvs):\n\t#curves must be planar, returns True if any two curves overlap\n\tfor i in range(len(crvs)-1):\n\t\tfor j in range(i+1,len(crvs)):\n\t\t\tif rs.PlanarCurveCollision(crvs[i],crvs[j]): return True\n\treturn False\n\n\ndef trim_boundary(e_crvs,cb_crvs,tol,inside=True):\n\t\"\"\"input:\n\te_crvs: etch curves to be trimmed\n\tcb_crvs: closed boundary curves\n\ttol: tolerance. document tolerance recommended\n\tinside=True: trim the inside if true, trim outside if false\n\treturns the trimmed curves.\n\tNOTE: assumes redraw is turned off. assumes curves are planar.\n\tfuture versions to use projection method to avoid these assumptions.\"\"\"\n\n\t#remove non-crv inputs\n\te_crvs = [x for x in e_crvs if rs.ObjectType(x) == 4]\n\tcb_crvs = [x for x in cb_crvs if rs.ObjectType(x) == 4]\n\n\t#split curves\n\tsplit_crvs = []\n\tfor e in e_crvs:\n\t\tintersection_list = []\n\t\tfor c in cb_crvs:\n\t\t\tccx_out = rs.CurveCurveIntersection(e,c,tol)\n\t\t\tif ccx_out is None: continue\n\t\t\tparams = [x[5] for x in ccx_out if x[0] == 1] #if pt intersection type; get param on etch crv\n\t\t\tintersection_list.extend(params)\n\t\tif intersection_list: split_crvs.extend(rs.SplitCurve(e,intersection_list))\n\n\t#append non-split curves\n\tno_split = []\n\tfor e in e_crvs:\n\t\tid=sc.doc.Objects.Find(e)\n\t\tif id != None: no_split.append(e)\n\tsplit_crvs.extend(no_split)\n\t#rs.ObjectLayer(split_crvs,\"XXX_LCUT_02-SCORE\")\n\n\t#build regions for boundary test\n\tsrfs = rs.AddPlanarSrf(cb_crvs)\n\tline=rs.AddLine([0,0,-5],[0,0,5])\n\trs.MoveObjects(srfs,[0,0,-5])\n\tvols = []\n\tfor srf in srfs:\n\t\text=rs.ExtrudeSurface(srf,line,True)\n\t\tif ext != None: vols.append(ext)\n\trs.DeleteObjects(srfs)\n\trs.DeleteObject(line)\n\n\t#categorize inside/outside curves\n\tkeep_crvs = []\n\tdelete_crvs = []\n\tfor c in split_crvs:\n\t\tif inside == True:\n\t\t\tkeep_crvs.append(c) if not multi_test_in_or_out(c,vols) else delete_crvs.append(c)\n\t\telse:\n\t\t\tkeep_crvs.append(c) if multi_test_in_or_out(c,vols) else delete_crvs.append(c)\n\n\t#rs.ObjectLayer(keep_crvs,\"XXX_LCUT_04-ENGRAVE\")\n\trs.DeleteObjects(vols)\n\trs.DeleteObjects(delete_crvs)\n\n\treturn keep_crvs\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}