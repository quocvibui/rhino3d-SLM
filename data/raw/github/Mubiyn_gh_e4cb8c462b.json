{
  "source_url": "https://github.com/Mubiyn/gh/blob/c930335c36dd52d02d88ac44db0676b531677270/services/rhino_operations.py",
  "repo": "Mubiyn/gh",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "services/rhino_operations.py",
  "instruction": "Rhino operations",
  "code": "from pathlib import Path\nimport compute_rhino3d.Brep\nimport compute_rhino3d.Mesh\nimport rhino3dm\nimport math\nimport requests\nfrom fastapi import HTTPException\n\nfrom models.models import MeshParams\nfrom utils.strings import BASE_URL\n\n\ndef create_mesh(params: MeshParams):\n    print(f\"Param is: {params}\")\n    try:\n        if params.type == \"box\":\n            # Create a simple box geometry\n            box = rhino3dm.BoundingBox(\n                rhino3dm.Point3d(0, 0, 0),\n                rhino3dm.Point3d(params.length, params.width, params.height)\n            )\n            brep = box.ToBrep()\n        \n        elif params.type == \"flexure_box\":\n            # Create the base box geometry\n            box = rhino3dm.BoundingBox(\n                rhino3dm.Point3d(0, 0, 0),\n                rhino3dm.Point3d(params.length, params.width, params.height)\n            )\n            brep = box.ToBrep()\n\n            # Apply lattice flexures\n            flexure_regions = params.flexure_regions\n            flexure_density = params.flexure_density\n\n            if flexure_regions and flexure_density:\n                brep = apply_lattice_flexures(brep, flexure_regions, flexure_density)\n        \n        elif params.type == \"sphere\":\n            # Create a sphere geometry\n            sphere = rhino3dm.Sphere(rhino3dm.Point3d(params.length, params.width, params.height), params.radius)\n            brep = sphere.ToBrep()\n        \n        elif params.type == \"cylinder\":\n            # Create a cylinder geometry\n            cylinder = rhino3dm.Cylinder(\n                rhino3dm.Circle(rhino3dm.Point3d(params.length, params.width, params.height), params.radius),\n                params.height\n            )\n            brep = cylinder.ToBrep(True, True)\n        \n        else:\n            raise ValueError(\"Unsupported mesh type\")\n\n        # Convert the brep to a mesh\n        d = compute_rhino3d.Mesh.CreateFromBrep(brep)\n        if not d or len(d) == 0:\n            raise Exception(\"Failed to create a mesh from the Brep\")\n\n        # Assuming we use the first mesh\n        mesh = d[0]\n\n        # Save the mesh as an OBJ file\n        obj_output_path = Path(f\"{params.name}_mesh.obj\")\n        save_mesh_to_obj(mesh, obj_output_path)\n\n        # Save the mesh and Brep to a Rhino file\n        rhino_output_path = Path(f\"{params.name}_geometry.3dm\")\n        save_to_rhino_file(brep, mesh, rhino_output_path)\n\n        return {\n            \"message\": f\"{params.name.capitalize()} mesh created successfully\",\n            \"obj_file_path\": obj_output_path,\n            \"rhino_file_path\": rhino_output_path,\n        }\n    \n    except Exception as e:\n        raise Exception(f\"Error creating mesh: {e}\")\n\ndef save_to_rhino_file(brep, mesh, file_path):\n    try:\n        rhino_file = rhino3dm.File3dm()\n\n        # Add Brep to the file\n        if brep and brep.IsValid:\n            rhino_file.Objects.AddBrep(brep)\n\n        # Add Mesh to the file\n        if mesh and mesh.IsValid:\n            rhino_file.Objects.AddMesh(mesh)\n\n        # Save the file\n        rhino_file.Write(str(file_path))\n        return {\"message\": \"Saved to Rhino file successfully\", \"file_path\": str(file_path)}\n\n    except Exception as e:\n        raise Exception(f\"Error saving to Rhino file: {e}\")\n\n\ndef save_mesh_to_obj(mesh, file_path):\n    try:\n        with open(file_path, 'w') as obj_file:\n            # Write vertices\n            for vertex in mesh.Vertices:\n                obj_file.write(f\"v {vertex.X} {vertex.Y} {vertex.Z}\\n\")\n            \n            # Write normals\n            for normal in mesh.Normals:\n                obj_file.write(f\"vn {normal.X} {normal.Y} {normal.Z}\\n\")\n            \n            # Write faces\n            for face in mesh.Faces:\n                if len(face) == 4:  # Quad face\n                    obj_file.write(f\"f {face[0]+1} {face[1]+1} {face[2]+1} {face[3]+1}\\n\")\n                elif len(face) == 3:  # Triangle face\n                    obj_file.write(f\"f {face[0]+1} {face[1]+1} {face[2]+1}\\n\")\n                else:\n                    raise ValueError(\"Unsupported face type: faces must be triangles or quads\")\n        return {\"message\": \"Mesh saved successfully\", \"file_path\": str(file_path)}\n    except Exception as e:\n        raise ValueError(f\"Error saving mesh to OBJ: {e}\")\n\n\n\n\ndef apply_lattice_flexures(brep, regions, density):\n    print(\"Generating lattice flexures::::\")\n\n    # Define lattice element size based on density\n    density_map = {\n        \"low\": 1.0,  # Larger elements, lower density\n        \"medium\": 0.5,\n        \"high\": 0.25  # Smaller elements, higher density\n    }\n    element_size = density_map.get(density, 0.5)  # Default to medium if undefined\n\n    lattice_brep = brep  # Start with the input Brep\n\n    for region in regions:\n        x_min = region.get(\"x_min\")\n        x_max = region.get(\"x_max\")\n        y_min = region.get(\"y_min\", brep.GetBoundingBox().Min.Y)\n        y_max = region.get(\"y_max\", brep.GetBoundingBox().Max.Y)\n        z_min = region.get(\"z_min\", brep.GetBoundingBox().Min.Z)\n        z_max = region.get(\"z_max\", brep.GetBoundingBox().Max.Z)\n\n        if x_min is None or x_max is None:\n            print(f\"Skipping invalid region: {region}\")\n            continue\n\n        # Create region box\n        region_box = rhino3dm.BoundingBox(\n            rhino3dm.Point3d(x_min, y_min, z_min),\n            rhino3dm.Point3d(x_max, y_max, z_max)\n        )\n        box_brep = region_box.ToBrep()\n\n        # Use Rhino.Compute to split the brep\n        split_result = compute_rhino3d.Brep.Split(lattice_brep, box_brep, 0.01)  # 0.01 is the tolerance\n        if not split_result or len(split_result) == 0:\n            print(f\"Splitting failed for region box: {region_box}\")\n            continue\n\n        region_brep = split_result[0]  # Assume the first part is the desired one\n\n        # Generate lattice and merge\n        lattice = generate_lattice(region_brep, element_size)\n        if not lattice or not lattice.IsValid:\n            print(f\"Skipping invalid lattice for region: {region}\")\n            continue\n\n        print(f\"Joining Breps: lattice_brep validity: {lattice_brep.IsValid}, lattice validity: {lattice.IsValid}\")\n\n        try:\n            result = compute_rhino3d.Brep.JoinBreps([lattice_brep, lattice], 0.01)\n            if not result or len(result) == 0:\n                raise Exception(\"JoinBreps failed to return a valid Brep.\")\n            \n            new_lattice_brep = result[0]  # Extract the first Brep\n            if new_lattice_brep and isinstance(new_lattice_brep, rhino3dm.Brep):\n                lattice_brep = new_lattice_brep  # Update lattice_brep\n            else:\n                raise Exception(\"JoinBreps returned an invalid result.\")\n\n        except Exception as e:\n            print(f\"Error during JoinBreps: {e}\")\n            continue\n\n    print(\"Generated lattice flexures::::\")\n    return lattice_brep\n\n\n\ndef generate_lattice(region_brep, element_size):\n    import rhino3dm\n    import compute_rhino3d\n\n    # Validate the input Brep\n    if not isinstance(region_brep, rhino3dm.Brep) or not region_brep.IsValid:\n        raise Exception(\"Invalid Brep provided to generate_lattice\")\n\n    # Get the bounding box of the Brep\n    try:\n        bbox = region_brep.GetBoundingBox()  # Ensure no arguments are passed\n        min_pt = bbox.Min\n        max_pt = bbox.Max\n    except Exception as e:\n        raise Exception(f\"Error obtaining bounding box: {e}\")\n\n    # Initialize an empty lattice Brep\n    lattice_brep = None\n\n    # Iterate to create lattice struts\n\n    x = min_pt.X\n\n    while x < max_pt.X:\n\n        y = min_pt.Y\n        while y < max_pt.Y:\n\n            z = min_pt.Z\n            while z < max_pt.Z:\n      \n                # Define strut endpoints\n                p1 = rhino3dm.Point3d(x, y, z)\n                p2 = rhino3dm.Point3d(x + element_size, y + element_size, z + element_size)\n      \n                # Create a strut\n                strut = create_strut(p1, p2)\n                if strut is None or not strut.IsValid:\n                    print(f\"Skipping invalid strut: {p1} to {p2}\")\n                    z += element_size\n                    continue\n\n                # Join the strut to the lattice\n       \n                if lattice_brep is None:\n                    lattice_brep = strut  # Initialize lattice_brep with the first valid strut\n                else:\n                    try:\n                        result = compute_rhino3d.Brep.JoinBreps([lattice_brep, strut], 0.01)\n                        if result and len(result) > 0:\n                            lattice_brep = result[0]\n                        else:\n                            print(f\"Failed to join strut at {p1}\")\n                    except Exception as e:\n                        print(f\"Error joining strut: {e}\")\n\n                z += element_size\n            y += element_size\n        x += element_size\n\n    if lattice_brep is None:\n        raise Exception(\"Failed to generate lattice structure\")\n\n    return lattice_brep\n\n\n\n\ndef create_strut(start, end):\n\n    # Create a cylinder or strut between two points\n    line = rhino3dm.Line(start, end)\n    circle = rhino3dm.Circle(line.PointAt(0.5), 0.1)  # Strut radius = 0.1\n    cylinder = rhino3dm.Cylinder(circle, line.Length)\n\n    return cylinder.ToBrep(True, True)\n\n\ndef create_sphere(params):\n    center = rhino3dm.Point3d(params.center_x, params.center_y, params.center_z)\n    sphere = rhino3dm.Sphere(center, params.radius)\n    brep = sphere.ToBrep()\n    return {\n        \"radius\": sphere.Radius,\n        \"center\": {\"x\": center.X, \"y\": center.Y, \"z\": center.Z},\n        \"brep\": brep.Encode()\n    }\n\ndef transform_geometry(params):\n    brep = rhino3dm.CommonObject.Decode(params.brep_str)\n    if not isinstance(brep, rhino3dm.Brep):\n        raise ValueError(\"Invalid Brep string provided\")\n    \n    if params.scale != 1.0:\n        scale_transform = rhino3dm.Transform.Scale(rhino3dm.Point3d(0, 0, 0), params.scale)\n        brep.Transform(scale_transform)\n\n    if params.rotation_degrees != 0.0:\n        rotation_radians = math.radians(params.rotation_degrees)\n        rotation_transform = rhino3dm.Transform.Rotation(\n            rotation_radians, rhino3dm.Vector3d(0, 0, 1), rhino3dm.Point3d(0, 0, 0)\n        )\n        brep.Transform(rotation_transform)\n\n    return {\"message\": \"Transformation successful\", \"brep\": brep.Encode()}\n\n\ndef convert_to_mesh(params):\n    try:\n        # Deserialize Brep from input string\n        brep = rhino3dm.CommonObject.Decode(params.brep_str)\n        if not isinstance(brep, rhino3dm.Brep):\n            raise HTTPException(status_code=400, detail=\"Invalid Brep string provided\")\n\n        # Create mesh from Brep using Rhino.Compute\n        meshes = compute_rhino3d.Mesh.CreateFromBrep(brep)\n        if not meshes or len(meshes) == 0:\n            raise Exception(\"Failed to create mesh from Brep\")\n\n        # Use the first mesh\n        mesh = meshes[0]\n\n        # Serialize mesh for return\n        mesh_str = mesh.Encode()\n\n        return {\n            \"message\": \"Mesh conversion successful\",\n            \"mesh\": mesh_str\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error converting to mesh: {e}\")\n\n\n\ndef export_geometry(params):\n    brep = rhino3dm.CommonObject.Decode(params.brep_str)\n    file_name = f\"geometry.{params.format}\"\n    try:\n        if params.format == \"obj\":\n            save_mesh_to_obj(brep, file_name)\n        elif params.format == \"3dm\":\n            save_to_rhino_file(brep, None, file_name)\n        else:\n            raise ValueError(\"Unsupported format\")\n        return {\"message\": \"Export successful\", \"file_path\": file_name}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error exporting geometry: {e}\")\n\n\n\n\ndef run_grasshopper_definition(file_path: str, inputs: dict):\n    \"\"\"\n    Runs a Grasshopper definition via Rhino.Compute and returns the result.\n    \"\"\"\n    try:\n        payload = {\n            \"script\": file_path,\n            \"values\": [\n                {\n                    \"ParamName\": key,\n                    \"InnerTree\": {\n                        \"(0)\": [{\"type\": \"System.String\", \"data\": str(value)}]\n                    }\n                } for key, value in inputs.items()\n            ]\n        }\n\n        url = f\"{BASE_URL}grasshopper\"\n        response = requests.post(url, json=payload)\n\n        if response.status_code != 200:\n            raise HTTPException(status_code=response.status_code, detail=f\"Error from Rhino.Compute: {response.text}\")\n\n        return response.json()\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error running Grasshopper definition: {e}\")\n\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}