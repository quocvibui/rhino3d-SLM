{
  "source_url": "https://github.com/lm2-me/CORE/blob/6dd1d257c7701d255cbda9a6c4d75d843bda2fde/unpack/hops/prog_place/siteprocessing.py",
  "repo": "lm2-me/CORE",
  "repo_stars": 0,
  "repo_description": null,
  "license": "GPL-3.0",
  "filepath": "unpack/hops/prog_place/siteprocessing.py",
  "instruction": "functions related to creating and optimizing hub locations",
  "code": "\n\"\"\"\nfunctions related to creating and optimizing hub locations\n\nBy: \nLisa-Marie Mueller, TU Delft\n\nClasses:\n    - NetworkClustering\n\nMethods:\n    >>> divide_site: Turn site into grid\n    >>> place_packages: Place package module on site\n    >>> place_modules: Place modules on site\n    >>> labelstopoints: Convert labels to points\n\"\"\"\n\nfrom cmath import nan\nimport ghhops_server as hs\nimport rhino3dm as r3d\nimport prog_place.helpers as h\nimport math as m\nimport numpy as np\nimport copy\n\n#see app.py file for description of each gh node and more specific information regarding the inputs and outputs\n\ndef divide_site(site: r3d.Surface, road_lines_tree, sidewalk_lines_tree, grid_size: float, context, sun_hours):\n    \"\"\"Grasshopper component: Turn site into grid\n        \n        Developed by Lisa-Marie Mueller\n\n        Parameters\n        ----------\n        site : r3d.Surface\n            Surface of site\n\n        road_lines_tree : tree\n            Lines representing roads.\n        \n        sidewalk_lines_tree : tree\n            Lines representing sidewalks.\n        \n        grid_size : integer\n            Distance of grid step size.\n        \n        context : list\n            Points locating context.\n        \n        site_hours : tree\n            number of sun hours per point\n\n        \"\"\"  \n\n    sidewalk_lines: list[r3d.Line] = sidewalk_lines_tree['{0}']\n    road_lines: list[r3d.Line] = road_lines_tree['{0}']\n    context_matrix = np.array(h.tree_to_matrix(context))\n    sun_hours_matrix = np.array(h.tree_to_matrix(sun_hours))\n    \n    nearby_buildings = context_matrix[0]\n    landmarks = context_matrix[1]\n    views = context_matrix[2]\n\n    srfpts = []\n    values = []\n    values_floats = []\n    \n    srf_u_start = int(site.Domain(0).T0)\n    srf_u_end = int(site.Domain(0).T1)\n    srf_v_start = int(site.Domain(1).T0)\n    srf_v_end = int(site.Domain(1).T1)\n\n    srf_btm_left_corner = site.PointAt(srf_u_start, srf_v_start)\n\n    ### cost function includes: road distance, sidewalk distance, sun hours, nearby buildings, distance to landmark, distance to view\n    for y in range(srf_v_end, srf_v_start-int(grid_size), -int(grid_size)):\n        rowpts = []\n        rowpts_vals = []\n        rowpts_floats = []\n        for x in range(srf_u_start, srf_u_end+int(grid_size), int(grid_size)):\n            road_weight = m.inf\n            sidewalk_weight = m.inf\n            sun_hours = m.inf\n            nearby_buildings_weight = m.inf\n            landmarks_weight = m.inf\n            views_weight = m.inf\n\n            point = r3d.Point3d(site.PointAt(x,y).X,site.PointAt(x,y).Y,0)\n            rowpts.append(point)\n\n            for r in road_lines:\n                new_road_weight = h.line_closest_point(r, point)\n                if new_road_weight < road_weight:\n                    road_weight = new_road_weight    \n            \n            for s in sidewalk_lines:\n                new_sidewalk_weight = h.line_closest_point(s, point)\n                if new_sidewalk_weight < sidewalk_weight:\n                    sidewalk_weight = new_sidewalk_weight\n            \n            sun_weight = sun_hours_matrix[x][y]\n\n            for b in nearby_buildings:\n                new_nearby_buildings_weight = b.DistanceTo(point)\n                if new_nearby_buildings_weight < nearby_buildings_weight:\n                    nearby_buildings_weight = new_nearby_buildings_weight\n            \n            for l in landmarks:\n                new_landmarks_weight = l.DistanceTo(point)\n                if new_landmarks_weight < landmarks_weight:\n                    landmarks_weight = new_landmarks_weight\n            \n            for v in views:\n                new_views_weight = v.DistanceTo(point)\n                if new_views_weight < views_weight:\n                    views_weight = new_views_weight\n\n            rowpts_floats.append([road_weight, sidewalk_weight, sun_weight, nearby_buildings_weight, landmarks_weight, views_weight])           \n            rowpts_vals.append('{0},{1},{2},{3},{4},{5}'.format(road_weight, sidewalk_weight, sun_weight, nearby_buildings_weight, landmarks_weight, views_weight))\n        srfpts.append(rowpts)\n        values.append(rowpts_vals)\n        values_floats.append(rowpts_floats)\n    \n    values_floats_normalized = h.normalize_weight(values_floats)\n\n    values_normalized = []\n    for row in values_floats_normalized:\n        row_norm = []\n        for cost in row:\n            row_norm.append('{0},{1},{2},{3},{4},{5}'.format(cost[0], cost[1], cost[2], cost[3], cost[4], cost[5]))\n        values_normalized.append(row_norm)\n\n    label_array_np = np.full_like(np.array(srfpts), 's', str)\n\n    site_grid, site_edge  = h.divide_surface(site, grid_size)\n    for row, list in enumerate(srfpts):\n        for column1, pt1 in enumerate(list):\n            for pt2 in site_edge:\n                distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (pt2.X, pt2.Y, pt2.Z)))\n                if distance < 0.05:\n                    label_array_np[row][column1] = 'e'\n                else:\n                    continue\n    \n    return h.list_to_tree(srfpts), h.list_to_tree(values_normalized), h.list_to_tree(label_array_np.tolist())\n\ndef place_packages(srfpts_tree, cost_function_tree, labels_tree, module_use, module_geometry: r3d.Surface, module_mask, door):\n    \"\"\"Grasshopper component: Place package module on site\n    \n    Developed by Lisa-Marie Mueller\n\n    Parameters\n    ----------\n    srfpts_tree : tree\n        points dividing site surface\n\n    cost_function_tree : tree\n        cost function for entire site.\n    \n    labels_tree : tree\n        labels of each point in grid.\n    \n    module_use : tree\n        human readable designation for module.\n    \n    module_geometry : r3d.Geometry\n        surface for module area.\n    \n    module_mask : tree\n        module mask to mask cost function for relevant values\n    \n    door : tree\n        point of door locations\n\n    \"\"\"  \n\n    ### convert door locations to points\n    door_points = []\n    door_floats = [float(v) for v in door.split(',')]\n\n    for j in range(0, len(door_floats), 2):\n            door_points.append(r3d.Point3d(door_floats[j], door_floats[j+1], 0))\n\n    ### width and height of packages module\n    point1 = module_geometry.PointAt(int(module_geometry.Domain(0).T0), int(module_geometry.Domain(1).T0))\n    point2 = module_geometry.PointAt(int(module_geometry.Domain(0).T1), int(module_geometry.Domain(1).T1))\n\n    width = int(abs(point1.X - point2.X))\n    height = int(abs(point1.Y - point2.Y))\n    rotation = 0\n    center = r3d.Point3d(width/2, height/2, 0)\n    axis = h.vector3d_2pts(center, r3d.Point3d(center.X, center.Y, 10))\n    _, tp_left, tp_right, _,_ = h.corners(module_geometry)\n    move_from = tp_left\n\n    ### convert cost function and srf points information from gh trees to np array\n    srfpts_matrix = np.array(h.tree_to_matrix(srfpts_tree))\n    grid_size = abs(srfpts_matrix[0,0].X - srfpts_matrix[0,1].X)\n    cost_function_matrix = h.matrix_str2floats(h.tree_to_matrix(cost_function_tree))\n    out_cost_function_matrix = copy.deepcopy(cost_function_matrix)\n\n    ### generate array of labels for each point\n    ### s - site\n    ### e - site edge\n    ### b - boundary\n    ### i - interior\n    ### o - outside of site edge\n    ### x - door\n    label_array_np = np.array(h.tree_to_matrix(labels_tree))\n\n    ### convert module cost function information from strings to np array \n    module_mask_np = np.array([float(v) for v in module_mask.split(',')])\n\n    for i, val in enumerate(module_mask_np):\n        if val == 0:\n            module_mask_np[i] = m.inf\n\n    module_mask_expanded = copy.deepcopy(cost_function_matrix)\n    for i, row in enumerate(cost_function_matrix):\n        for j, _ in enumerate(row):\n            module_mask_expanded[i][j] = module_mask_np\n\n    ### mask cost function with module parameters\n    module_masked_cost = copy.deepcopy(cost_function_matrix)\n    num_weights = len(cost_function_matrix[0][0])\n    for num in range(num_weights):\n        for i, row in enumerate(cost_function_matrix):\n            for j, weights in enumerate(row):\n                if module_mask_expanded[i][j][num] == -1.:\n                    module_masked_cost[i][j][num] = m.pow(weights[num], module_mask_expanded[i][j][num])\n                else:\n                    if weights[num] < 1 and module_mask_expanded[i][j][num] == m.inf:\n                        module_masked_cost[i][j][num] = m.inf\n                    else:\n                        module_masked_cost[i][j][num] = weights[num] * module_mask_expanded[i][j][num]\n\n    ### remove locations that place packages module outside of the site area\n    min_cost_value = []\n    masked_cost_placement_zerodeg = np.copy(module_masked_cost)\n    masked_cost_placement_zerodeg[width:, :] = m.inf\n    masked_cost_placement_zerodeg[:, height:] = m.inf\n    min_cost_value.append([masked_cost_placement_zerodeg, masked_cost_placement_zerodeg.min(), 0, tp_left])\n\n    masked_cost_placement_ninetydeg = np.copy(module_masked_cost)\n    masked_cost_placement_ninetydeg[height:, :] = m.inf\n    masked_cost_placement_ninetydeg[:, width:] = m.inf\n    min_cost_value.append([masked_cost_placement_ninetydeg, masked_cost_placement_ninetydeg.min(), 1.5708, tp_right])\n\n    masked_cost_placement_onetwentydeg = np.copy(module_masked_cost)\n    masked_cost_placement_onetwentydeg[:height, :] = m.inf\n    masked_cost_placement_onetwentydeg[:, :width] = m.inf\n    min_cost_value.append([masked_cost_placement_onetwentydeg, masked_cost_placement_onetwentydeg.min(), 3.14159, tp_left])\n \n    masked_cost_placement_twoseventydeg = np.copy(module_masked_cost)\n    masked_cost_placement_twoseventydeg[:width, :] = m.inf\n    masked_cost_placement_twoseventydeg[:, :height] = m.inf\n    min_cost_value.append([masked_cost_placement_twoseventydeg, masked_cost_placement_twoseventydeg.min(), 4.712392, tp_right])\n\n    min_value = m.inf\n\n    for func, value, module_rotation, move_pt in min_cost_value:\n        if value < min_value:\n            min_value = value\n            masked_cost_placement = func\n            rotation = module_rotation\n            move_from = move_pt\n\n    best_points_locs = np.where(masked_cost_placement == masked_cost_placement.min())\n    best_points = [(x,y) for y,x in zip(best_points_locs[0], best_points_locs[1])]\n    best_points.sort()\n    best_point = best_points[int(len(best_points) / 2)]\n\n    top_left_corner = srfpts_matrix[best_point[1], best_point[0]]\n\n    success_rot = module_geometry.Rotate(rotation, axis, tp_left)\n    rotation_transform = r3d.Transform.Rotation(rotation, axis, tp_left)\n    print('rotate packages module?', success_rot)\n        \n    ### rotate door location\n    for i, d in enumerate(door_points):\n        rotated_x, rotated_y = h.rotate_point(tp_left, d, rotation)\n        door_points[i] = r3d.Point3d(rotated_x, rotated_y, 0)\n        print('rotated packages module doors')\n\n    rot_mat_flat = r3d.Transform.ToFloatArray(rotation_transform, True)\n    rot_mat = np.asarray(rot_mat_flat).reshape(4, 4)\n    move_from_np = np.array([move_from.X, move_from.Y, move_from.Z, 1])\n    move_from_new = np.dot(rot_mat, move_from_np.T)\n    move_from = r3d.Point3d(move_from_new[0], move_from_new[1], 0)\n\n    move_vector = h.vector3d_2pts(move_from, top_left_corner)\n    success_move = module_geometry.Translate(move_vector)\n    print('moved packages module?', success_move)\n\n    ### move door location\n    for i, d in enumerate(door_points):\n        door_points[i] = r3d.Point3d(d.X + move_vector.X, d.Y + move_vector.Y, 0)\n        print('moved packages module doors')\n\n    module_grid, module_edge  = h.divide_surface(module_geometry, grid_size)\n    module_grid_np = np.array(module_grid)\n  \n    for row, list in enumerate(srfpts_matrix):\n        for column1, pt1 in enumerate(list):\n            for i in module_grid_np:\n                for j, pt2 in enumerate(i):\n                    distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (pt2.X, pt2.Y, pt2.Z)))\n                    if distance < 0.05:\n                        out_cost_function_matrix[row][column1][0] = str(m.inf)\n                        out_cost_function_matrix[row][column1][1] = str(m.inf)\n                        label_array_np[row][column1] = 'i'\n                    else:\n                        continue\n \n    label_array_np = h.update_label(label_array_np, srfpts_matrix, module_edge, 'b')\n\n    for row, list in enumerate(srfpts_matrix):\n        for column1, pt1 in enumerate(list):\n            for d in door_points:\n                distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (d.X, d.Y, d.Z)))\n                if distance < 0.05:\n                    label_array_np[row][column1] = 'x'\n\n    label_array = label_array_np.tolist()\n\n    return module_geometry, h.list_to_tree(h.matrix_floats2str(out_cost_function_matrix)), module_edge, h.list_to_tree(label_array)\n\ndef place_modules(srfpts_tree, cost_function_tree, label_array, module_use_tree, module_geometry_list, module_mask_tree, door_tree):\n    \"\"\"Grasshopper component: Place modules on site\n    \n    Developed by Lisa-Marie Mueller\n\n    Parameters\n    ----------\n    srfpts_tree : tree\n        points dividing site surface\n\n    cost_function_tree : tree\n        cost function for entire site.\n    \n    label_array : list\n        labels of each point in grid.\n    \n    module_use : tree\n        human readable designation for module.\n    \n    module_geometry : list\n        surface for module area.\n    \n    module_mask : tree\n        module mask to mask cost function for relevant values\n    \n    door : tree\n        point of door locations\n\n    \"\"\"  \n\n    ### convert cost function and srf points information from gh trees to np array\n    srfpts_matrix = np.array(h.tree_to_matrix(srfpts_tree))\n    grid_size = abs(srfpts_matrix[0,0].X - srfpts_matrix[0,1].X)\n    module_mask_matrix = h.tree_to_matrix(module_mask_tree)\n    cost_function_matrix = h.matrix_str2floats(h.tree_to_matrix(cost_function_tree))\n    label_array_matrix = np.array(h.tree_to_matrix(label_array))\n    module_use = h.tree_to_list(module_use_tree)\n\n    door_array = h.matrix_str2floats(h.tree_to_matrix(door_tree))\n    ### convert door locations to points\n    door_points = []\n    for i in range(len(door_array)):\n        if door_array[i] == None:\n            door_points.append([None])\n        else:\n            points = []\n            for j in range(0, len(door_array[i][0]), 2):\n                points.append(r3d.Point3d(door_array[i][0][j], door_array[i][0][j+1], 0))\n            door_points.append(points)\n\n    ### convert module cost function information from strings to np array \n    module_mask_np = []\n    module_masked_cost_all = []\n\n    for i, item in enumerate(module_mask_matrix):\n        mask = [float(v) for v in item[0].split(',')]\n\n        for j, val in enumerate(mask):\n            if val == 0:\n                mask[j] = m.inf\n\n        module_mask_np.append(mask)\n\n        module_mask_expanded = copy.deepcopy(cost_function_matrix)\n        for k, row in enumerate(cost_function_matrix):\n            for l, _ in enumerate(row):\n                module_mask_expanded[k][l] = mask\n\n        ### mask cost function with module parameters\n        module_masked_cost = copy.deepcopy(cost_function_matrix)\n        num_weights = len(cost_function_matrix[0][0])\n        for num in range(num_weights):\n            for k, row in enumerate(cost_function_matrix):\n                for l, weights in enumerate(row):\n                    if module_mask_expanded[k][l][num] == -1.:\n                        if weights[num] == 0:\n                            module_masked_cost[k][l][num] = m.inf\n                        else:\n                            module_masked_cost[k][l][num] = m.pow(weights[num], module_mask_expanded[i][j][num])\n                    else:\n                        if weights[num] < 1 and module_mask_expanded[k][l][num] == m.inf:\n                            module_masked_cost[k][l][num] = m.inf\n                        else:\n                            module_masked_cost[k][l][num] = weights[num] * module_mask_expanded[i][j][num]\n        module_masked_cost_all.append(module_masked_cost)\n\n    combined_module_masked_cost_all = copy.deepcopy(module_masked_cost_all)\n    for num, matrix in enumerate(module_masked_cost_all):\n        for i, row in enumerate(matrix):\n            for j, weights in enumerate(row):\n                total_weight = 0\n                for weight in weights:\n                    if weight != m.inf:\n                        total_weight += weight\n                if total_weight == 0:\n                    combined_module_masked_cost_all[num][i][j] = m.inf\n                else:\n                    combined_module_masked_cost_all[num][i][j] = total_weight\n\n    label_array_matrix_revised = copy.deepcopy(label_array_matrix)\n\n    out_module_edges = []\n    \n    #place each module, update label array,\n    for num, geo in enumerate(module_geometry_list):\n        print('placing module ',  module_use[num])\n        use_cost_function_matrix = copy.deepcopy(combined_module_masked_cost_all[num])\n\n        for i, row in enumerate(label_array_matrix_revised):\n            for j, label in enumerate(row):\n                if label == 's' or label == 'i' or label == 'e' or label == 'x':\n                    use_cost_function_matrix[i][j] = m.inf\n\n        print(label_array_matrix_revised)\n\n        points_to_order = []\n        values_to_order = []\n        for i, row in enumerate(use_cost_function_matrix):\n            for j, cost in enumerate(row):\n                if cost != m.inf:\n                    values_to_order.append(cost)\n                    points_to_order.append(srfpts_matrix[i][j])\n                else:\n                    continue\n\n        ### order best locations in order best to worst \n        values_ordered = np.array(values_to_order)\n        points_ordered = np.array(points_to_order)\n        idx   = np.argsort(values_ordered)\n\n        values_ordered = values_ordered[idx]\n        points_ordered = points_ordered[idx]\n\n        valid_placement = False\n\n        for i, corner in enumerate(points_ordered):\n            _, tp_left, _, _,_ = h.corners(geo)\n\n            #move geometry to point\n            move_vector = h.vector3d_2pts(tp_left, corner)\n            success_move = geo.Translate(move_vector)\n            \n            _, mvd_tp_left, _, _, _ = h.corners(geo)\n\n            rotation_count = 0\n            for j in range(4):\n                _, _, _, _, corners_list = h.corners(geo)\n                corner_locations = h.location_closest_grid_point(srfpts_matrix, corners_list)\n\n                corner_labels = []\n                for c in corner_locations:\n                    if c != None:\n                        corner_labels.append(label_array_matrix_revised[c[0],c[1]])\n                    else:\n                        corner_labels.append(None)\n\n                corner_labels_np = np.array(corner_labels)\n\n                centers, edges = h.divide_surface(geo, grid_size)\n\n                edge_labels = []\n                for point in edges:\n                    valid_index = False\n\n                    if (0 <= round(point.X) < len(label_array_matrix_revised[0])) and (0 <= round(point.Y) < len(label_array_matrix_revised)):\n                        valid_index = True\n\n                    if point != None and valid_index:\n                        edge_labels.append(label_array_matrix_revised[round(point.X), round(point.Y)])\n                    else:\n                        edge_labels.append(None)\n                edge_labels_np = np.array(edge_labels)\n\n                center_labels = []\n                \n                if isinstance(centers[0], list):\n                    center_list = centers[0]\n                \n                else:\n                    center_list = centers\n\n                for cntr_pt in center_list:\n                    valid_index = False\n\n                    if 0 <= round(cntr_pt.X) < len(label_array_matrix_revised[0]) and (0 <= round(cntr_pt.Y) < len(label_array_matrix_revised)):\n                        valid_index = True\n\n                    if point != None and valid_index:\n                        center_labels.append(label_array_matrix_revised[round(cntr_pt.X), round(cntr_pt.Y)])\n                    else:\n                        center_labels.append(None)\n                center_labels_np = np.array(center_labels)\n\n                if ((np.isin('b', center_labels_np)) or\n                    (np.isin('x', center_labels_np)) or\n                    (np.isin('i', center_labels_np)) or\n                    (np.isin('o', center_labels_np)) or\n                    (np.isin('i', corner_labels_np)) or\n                    (np.isin('o', corner_labels_np)) or\n                    (np.isin('x', corner_labels_np)) or\n                    (np.isin(None, corner_labels_np)) or\n                    (np.count_nonzero(corner_labels_np == 'b') < 2) or\n                    (np.isin('x', edge_labels_np)) or\n                    (np.count_nonzero(edge_labels_np == 'b') == len(edge_labels_np)) or\n                    ((np.count_nonzero(edge_labels_np == 'b') + np.count_nonzero(edge_labels_np == 'i')) == len(edge_labels_np))\n                ):\n                    \n                    axis = h.vector3d_2pts(mvd_tp_left, r3d.Point3d(mvd_tp_left.X, mvd_tp_left.Y, 10))\n                    success_rot = geo.Rotate(m.pi / 2., axis, mvd_tp_left)\n                    rotation_count +=1\n                else:\n                    valid_placement = True\n                    break\n\n            if valid_placement:\n                corner_rot_point = mvd_tp_left\n                rotation_degree = rotation_count * (m.pi / 2.)\n                move_amount = move_vector\n\n                break\n\n            print(\"no valid position for this module at this location\")\n        \n        if not valid_placement:\n            print(\"no valid position for this module\")\n\n        ### move door locations\n        for i, d in enumerate(door_points[num]):\n            if d == None:\n                break\n            else:\n                moved_point = r3d.Point3d(d.X + move_amount.X, d.Y + move_amount.Y, 0)\n                door_points[num][i] = moved_point\n                print('moved module doors')\n\n        ### rotate door location\n        for i, d in enumerate(door_points[num]):\n            if d == None:\n                break\n            else:\n                rotated_x, rotated_y = h.rotate_point(corner_rot_point, d, rotation_degree)\n                door_points[num][i] = r3d.Point3d(rotated_x, rotated_y, 0)\n                print('rotated module doors')\n\n        module_grid, module_edge  = h.divide_surface(geo, grid_size)\n        ### list of module edges to output\n        out_module_edges.append(module_edge)\n\n        ### update label array matrix\n        label_array_matrix_revised = h.update_label(label_array_matrix_revised, srfpts_matrix, module_edge, 'b')\n        label_array_matrix_revised = h.update_label(label_array_matrix_revised, srfpts_matrix, module_grid, 'i')\n        if door_points[num][0] != None and door_points[num] != None:\n            label_array_matrix_revised = h.update_label(label_array_matrix_revised, srfpts_matrix, door_points[num], 'x')\n        ### check if diagonal of each b contains at least one 's' if yes, it is still a boundary, if no, then it becomes an 'i'\n        label_array_matrix_revised = h.convert_interior_boundaries(label_array_matrix_revised)\n\n    #return \"surface\", [excluded] \"cost\", \"module edges\", \"label\"\n    return module_geometry_list, h.list_to_tree(out_module_edges), h.list_to_tree(label_array_matrix_revised.tolist())\n\ndef labelstopoints(srfpts_tree, label_array):\n    \"\"\"Grasshopper component: conver labels to points\n    \n    Developed by Lisa-Marie Mueller\n\n    Parameters\n    ----------\n    srfpts_tree : tree\n        points dividing site surface\n\n    label_array : tree\n        labels of each point in grid.\n\n    \"\"\"  \n\n    srfpts_matrix = np.array(h.tree_to_matrix(srfpts_tree))\n    label_array_matrix = np.array(h.tree_to_matrix(label_array))\n\n    points_site = []\n    points_edges = []\n    points_boundary = []\n    points_interior = []\n    points_doors = []\n    points_outside_site = []\n\n    for i, row in enumerate(label_array_matrix):\n        for j, label in enumerate(row):\n            if label == 's':\n                points_site.append(srfpts_matrix[i, j])\n            if label == 'e':\n                points_edges.append(srfpts_matrix[i, j])\n            if label == 'b':\n                points_boundary.append(srfpts_matrix[i, j])\n            if label == 'i':\n                points_interior.append(srfpts_matrix[i, j])\n            if label == 'x':\n                points_doors.append(srfpts_matrix[i, j])\n            if label == 'o':\n                points_outside_site.append(srfpts_matrix[i, j])\n            else:\n                continue\n\n    return points_site, points_edges, points_boundary, points_interior, points_doors, points_outside_site",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}