{
  "source_url": "https://github.com/Mufasa58/TNA/blob/49dfff99579f489c3179470ce8507bbb849e1226/thrust_1.py",
  "repo": "Mufasa58/TNA",
  "repo_stars": 0,
  "repo_description": "Compas_TNA and Rhino Models and Scripts",
  "license": "unknown",
  "filepath": "thrust_1.py",
  "instruction": "Funicular Floor System — COMPAS-TNA scripted exemplar (Rhino 8, Python 3.9)",
  "code": "\"\"\"\nFunicular Floor System — COMPAS-TNA scripted exemplar (Rhino 8, Python 3.9)\n\nImplements:\n- FormDiagram creation (grid mesh -> FormDiagram)\n- Column supports (at bay intersections)\n- Uniform nodal vertical loads (pz = -w)\n- ForceDiagram creation (dual)\n- Horizontal equilibrium (TNA reciprocity)\n- Vertical equilibrium (\"lifting\") via vertical_from_zmax\n- Rhino drawing: form + force diagrams\n- Edge force extraction + simple efficiency metrics\n- Edge coloring by |force| magnitude\n\nDocs anchors (API + concepts):\n- ForceDiagram.from_formdiagram :contentReference[oaicite:0]{index=0}\n- horizontal_nodal(form, force, alpha=100, kmax=100, ...) :contentReference[oaicite:1]{index=1}\n- vertical_from_q(...) meaning of q/h/l :contentReference[oaicite:2]{index=2}\n- TNA overview: form/force diagram roles :contentReference[oaicite:3]{index=3}\n- Mesh.from_meshgrid(dx, nx, dy=None, ny=None) :contentReference[oaicite:4]{index=4}\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom typing import Dict, Tuple, List\n\nimport Rhino\nimport scriptcontext as sc\n\nfrom compas.datastructures import Mesh\nfrom compas_tna.diagrams import FormDiagram, ForceDiagram\nfrom compas_tna.equilibrium import horizontal_nodal, vertical_from_zmax\n\n\n# ==============================================================================\n# Parameters (single source of truth)\n# ==============================================================================\n\nPARAMS: Dict[str, float] = {\n    # Geometry\n    \"bay\": 7.0,                 # [m] bay size in X and Y\n    \"bays_x\": 3,                # 3 bays -> total span = 21m\n    \"bays_y\": 3,\n    \"subdiv_per_bay\": 8,        # refine mesh so there are free nodes between columns\n    \"zmax\": 2.0,                # [m] target max height (lift) for the thrust network\n\n    # Loads\n    \"w\": 10.0,                  # abstract nodal load magnitude (downwards), units arbitrary\n\n    # Solver\n    \"kmax_hor\": 200,\n    \"alpha\": 100.0,             # alpha=100 keeps the *form* XY mostly fixed during parallelisation :contentReference[oaicite:5]{index=5}\n\n    # Drawing\n    \"draw_scale_form\": 1.0,     # Rhino units assumed meters\n    \"draw_scale_force\": 1.0,    # force diagram drawn \"as is\" then scaled\n    \"force_offset_x\": 24.0,     # move force diagram to the right in Rhino view\n    \"force_offset_y\": 0.0,\n    \"layer_form\": \"TNA_FORM\",\n    \"layer_force\": \"TNA_FORCE\",\n}\n\n\n# ==============================================================================\n# Rhino helpers\n# ==============================================================================\n\ndef _ensure_layer(name: str) -> int:\n    \"\"\"Create layer if missing. Return layer index.\"\"\"\n    doc = sc.doc\n    layer = doc.Layers.FindName(name)\n    if layer is None:\n        layer = Rhino.DocObjects.Layer()\n        layer.Name = name\n        idx = doc.Layers.Add(layer)\n        return idx\n    return layer.Index\n\n\ndef _add_line(a: Tuple[float, float, float],\n              b: Tuple[float, float, float],\n              layer: str,\n              color: Rhino.Display.Color4f | None = None) -> Rhino.Geometry.Line:\n    doc = sc.doc\n    idx = _ensure_layer(layer)\n\n    p0 = Rhino.Geometry.Point3d(*a)\n    p1 = Rhino.Geometry.Point3d(*b)\n    line = Rhino.Geometry.Line(p0, p1)\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = idx\n    if color is not None:\n        # Convert Color4f -> System.Drawing.Color\n        c = Rhino.Display.Color4f(color)\n        sd = Rhino.Display.Color4f.ToArgbColor(c)  # stable conversion helper in RhinoCommon\n        attr.ObjectColor = sd\n        attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n\n    doc.Objects.AddLine(line, attr)\n    return line\n\n\ndef _add_point(p: Tuple[float, float, float], layer: str) -> None:\n    doc = sc.doc\n    idx = _ensure_layer(layer)\n\n    pt = Rhino.Geometry.Point3d(*p)\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = idx\n    doc.Objects.AddPoint(pt, attr)\n\n\ndef _color_map_blue_red(t: float) -> Rhino.Display.Color4f:\n    \"\"\"t in [0,1] -> blue->red.\"\"\"\n    t = max(0.0, min(1.0, t))\n    r = float(t)\n    g = 0.0\n    b = float(1.0 - t)\n    return Rhino.Display.Color4f(r, g, b, 1.0)\n\n\n# ==============================================================================\n# Phase 1 — Topology (grid mesh -> FormDiagram)\n# ==============================================================================\n\ndef make_form(params: Dict[str, float]) -> FormDiagram:\n    bay = float(params[\"bay\"])\n    bays_x = int(params[\"bays_x\"])\n    bays_y = int(params[\"bays_y\"])\n    subdiv = int(params[\"subdiv_per_bay\"])\n\n    # Mesh resolution (faces):\n    # 3 bays, each subdivided -> gives interior nodes between columns\n    nx = bays_x * subdiv\n    ny = bays_y * subdiv\n\n    # Regular quad mesh: (nx faces) x (ny faces) :contentReference[oaicite:6]{index=6}\n    mesh = Mesh.from_meshgrid(dx=bay / subdiv, nx=nx, dy=bay / subdiv, ny=ny)\n\n    # FormDiagram stores XY from mesh, Z starts at 0 :contentReference[oaicite:7]{index=7}\n    form = FormDiagram.from_mesh(mesh)\n\n    # Move/scale into a 0..21 range (meshgrid starts at origin already; dx sets spacing)\n    # Ensure explicit z=0\n    for v in form.vertices():\n        x, y, _ = form.vertex_coordinates(v)\n        form.vertex_attributes(v, [\"x\", \"y\", \"z\"], [x, y, 0.0])\n\n    return form\n\ndef _ray_square_intersection(cx, cy, dx, dy, ox, oy, bay):\n    \"\"\"\n    Intersect ray from (cx,cy) in direction (dx,dy) with square [ox,ox+bay]x[oy,oy+bay].\n    Returns intersection point on perimeter.\n    \"\"\"\n    eps = 1e-12\n    t_candidates = []\n\n    # x = ox\n    if abs(dx) > eps:\n        t = (ox - cx) / dx\n        y = cy + t * dy\n        if t > 0 and oy - eps <= y <= oy + bay + eps:\n            t_candidates.append((t, ox, y))\n\n    # x = ox+bay\n    if abs(dx) > eps:\n        t = (ox + bay - cx) / dx\n        y = cy + t * dy\n        if t > 0 and oy - eps <= y <= oy + bay + eps:\n            t_candidates.append((t, ox + bay, y))\n\n    # y = oy\n    if abs(dy) > eps:\n        t = (oy - cy) / dy\n        x = cx + t * dx\n        if t > 0 and ox - eps <= x <= ox + bay + eps:\n            t_candidates.append((t, x, oy))\n\n    # y = oy+bay\n    if abs(dy) > eps:\n        t = (oy + bay - cy) / dy\n        x = cx + t * dx\n        if t > 0 and ox - eps <= x <= ox + bay + eps:\n            t_candidates.append((t, x, oy + bay))\n\n    # pick closest positive intersection\n    t_candidates.sort(key=lambda a: a[0])\n    if not t_candidates:\n        # fallback: no hit (shouldn't happen)\n        return (cx, cy)\n    _, x, y = t_candidates[0]\n    return (x, y)\n\n\ndef bay_seam_polylines_9piece(ox, oy, bay, theta_rad, r_frac=0.22):\n    \"\"\"\n    Returns seam polylines (as list of 2D point lists) for one bay.\n    Pattern:\n      - inner octagon (center piece boundary)\n      - 8 spokes from inner octagon vertices to perimeter points\n    \"\"\"\n    cx = ox + 0.5 * bay\n    cy = oy + 0.5 * bay\n    r = r_frac * bay\n\n    inner = []\n    outer = []\n\n    # 8 directions at 45deg increments, rotated by theta\n    for k in range(8):\n        a = theta_rad + k * (math.pi / 4.0)\n        dx = math.cos(a)\n        dy = math.sin(a)\n\n        ix = cx + r * dx\n        iy = cy + r * dy\n        inner.append((ix, iy))\n\n        px, py = _ray_square_intersection(cx, cy, dx, dy, ox, oy, bay)\n        outer.append((px, py))\n\n    polylines = []\n\n    # inner octagon loop\n    polylines.append(inner + [inner[0]])\n\n    # 8 spokes: inner[k] -> outer[k]\n    for k in range(8):\n        polylines.append([inner[k], outer[k]])\n\n    return polylines\n\n\n# ==============================================================================\n# Phase 2 — Boundary conditions (supports at column grid intersections)\n# ==============================================================================\n\ndef apply_supports(form: FormDiagram, params: Dict[str, float]) -> List[int]:\n    bay = float(params[\"bay\"])\n    subdiv = int(params[\"subdiv_per_bay\"])\n    tol = 1e-6\n\n    # Column locations are at multiples of 7m in X and Y:\n    # (0,7,14,21) x (0,7,14,21)\n    col_coords = set()\n    for i in range(int(params[\"bays_x\"]) + 1):\n        for j in range(int(params[\"bays_y\"]) + 1):\n            col_coords.add((i * bay, j * bay))\n\n    supports: List[int] = []\n    for v in form.vertices():\n        x, y, _ = form.vertex_coordinates(v)\n        # snap check: x,y should be multiples of (bay/subdiv); columns are multiples of bay\n        for (cx, cy) in col_coords:\n            if abs(x - cx) < tol and abs(y - cy) < tol:\n                form.vertex_attribute(v, \"is_fixed\", True)\n                supports.append(v)\n                break\n\n    return supports\n\ndef snap_pt_to_grid_xy(x, y, dx):\n    sx = round(x / dx) * dx\n    sy = round(y / dx) * dx\n    return sx, sy\n\ndef snap_polyline_to_grid(polyline_xy, dx):\n    return [snap_pt_to_grid_xy(x, y, dx) for (x, y) in polyline_xy]\n\ndef bay_force_direction_xy(form, ox, oy, bay):\n    \"\"\"\n    Dominant XY direction near bay center using weighted sum of incident edge directions.\n    \"\"\"\n    cx, cy = ox + 0.5 * bay, oy + 0.5 * bay\n\n    # pick nearest vertex to bay center\n    v0 = min(\n        form.vertices(),\n        key=lambda v: (form.vertex_attribute(v, \"x\") - cx) ** 2 + (form.vertex_attribute(v, \"y\") - cy) ** 2\n    )\n\n    vx, vy = 0.0, 0.0\n    x0, y0, _ = form.vertex_coordinates(v0)\n\n    for nbr in form.vertex_neighbors(v0):\n        x1, y1, _ = form.vertex_coordinates(nbr)\n        ex, ey = (x1 - x0), (y1 - y0)\n        L = (ex * ex + ey * ey) ** 0.5\n        if L < 1e-12:\n            continue\n        ex /= L\n        ey /= L\n\n        # try common edge force keys\n        h = form.edge_attribute((v0, nbr), \"h\")\n        if h is None:\n            h = form.edge_attribute((v0, nbr), \"f\")\n        if h is None:\n            h = form.edge_attribute((v0, nbr), \"q\")\n        w = abs(float(h or 0.0))\n\n        vx += w * ex\n        vy += w * ey\n\n    L = (vx * vx + vy * vy) ** 0.5\n    if L < 1e-12:\n        return (1.0, 0.0)\n    return (vx / L, vy / L)\n\n\n# ==============================================================================\n# Phase 3 — Loads (uniform nodal pz on free vertices)\n# ==============================================================================\n\ndef apply_loads(form: FormDiagram, supports: List[int], params: Dict[str, float]) -> None:\n    w = float(params[\"w\"])\n\n    # TNA assumes vertical loads at nodes (px,py,pz); here only pz is used :contentReference[oaicite:8]{index=8}\n    for v in form.vertices():\n        if v in supports:\n            form.vertex_attributes(v, [\"px\", \"py\", \"pz\"], [0.0, 0.0, 0.0])\n        else:\n            form.vertex_attributes(v, [\"px\", \"py\", \"pz\"], [0.0, 0.0, -w])\n\ndef _seg_intersect_2d(a, b, c, d):\n    \"\"\"\n    Proper 2D segment intersection test (including touching).\n    a,b,c,d are (x,y)\n    \"\"\"\n    def orient(p, q, r):\n        return (q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0])\n\n    def on_seg(p, q, r):\n        return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n                min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\n    o1 = orient(a, b, c)\n    o2 = orient(a, b, d)\n    o3 = orient(c, d, a)\n    o4 = orient(c, d, b)\n\n    eps = 1e-12\n    # general case\n    if (o1 > eps and o2 < -eps or o1 < -eps and o2 > eps) and (o3 > eps and o4 < -eps or o3 < -eps and o4 > eps):\n        return True\n\n    # collinear / touching\n    if abs(o1) <= eps and on_seg(a, c, b): return True\n    if abs(o2) <= eps and on_seg(a, d, b): return True\n    if abs(o3) <= eps and on_seg(c, a, d): return True\n    if abs(o4) <= eps and on_seg(c, b, d): return True\n\n    return False\n\n\ndef edge_force_mag_proxy(form, u, v):\n    for key in (\"h\", \"f\", \"q\"):\n        val = form.edge_attribute((u, v), key)\n        if isinstance(val, (int, float)):\n            return abs(float(val))\n    return 0.0\n\n\ndef seam_traffic_for_bay(form, seam_polylines_xy, ox, oy, bay):\n    \"\"\"\n    Sum |force| of form edges that intersect any seam segment.\n    Only consider edges whose midpoint lies inside the bay.\n    \"\"\"\n    total = 0.0\n\n    # flatten seam segments\n    seam_segs = []\n    for pl in seam_polylines_xy:\n        for i in range(len(pl) - 1):\n            seam_segs.append((pl[i], pl[i + 1]))\n\n    for u, v in form.edges():\n        x0, y0, _ = form.vertex_coordinates(u)\n        x1, y1, _ = form.vertex_coordinates(v)\n        mx, my = 0.5 * (x0 + x1), 0.5 * (y0 + y1)\n\n        if not (ox <= mx <= ox + bay and oy <= my <= oy + bay):\n            continue\n\n        a = (x0, y0)\n        b = (x1, y1)\n\n        hit = False\n        for (c, d) in seam_segs:\n            if _seg_intersect_2d(a, b, c, d):\n                hit = True\n                break\n\n        if hit:\n            total += edge_force_mag_proxy(form, u, v)\n\n    return total\n\n# ==============================================================================\n# Phase 4 — Equilibrium (horizontal reciprocity + vertical lifting)\n# ==============================================================================\n\ndef solve_equilibrium(form: FormDiagram, params: Dict[str, float]) -> Tuple[ForceDiagram, float]:\n    # Force diagram is the dual of the form diagram :contentReference[oaicite:9]{index=9}\n    force = ForceDiagram.from_formdiagram(form)\n\n    # Horizontal equilibrium: parallelise corresponding edges (reciprocity) :contentReference[oaicite:10]{index=10}\n    horizontal_nodal(\n        form,\n        force,\n        alpha=float(params[\"alpha\"]),\n        kmax=int(params[\"kmax_hor\"]),\n    )\n\n    # Vertical equilibrium (\"lifting\"): pick a scale that gives desired zmax :contentReference[oaicite:11]{index=11}\n    scale = vertical_from_zmax(form, float(params[\"zmax\"]))\n\n    return force, float(scale)\n\n\n# ==============================================================================\n# Phase 5 — Visualization (Rhino draw + color edges by force magnitude)\n# ==============================================================================\n\ndef draw_form(form: FormDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_form\"])\n\n    # Draw vertices (optional, light)\n    for v in form.vertices():\n        x, y, z = form.vertex_coordinates(v)\n        _add_point((x, y, z), layer)\n\n    # Draw edges\n    for u, v in form.edges():\n        a = form.vertex_coordinates(u)\n        b = form.vertex_coordinates(v)\n        _add_line(tuple(a), tuple(b), layer)\n\n\ndef _edge_force_magnitude(form: FormDiagram, u: int, v: int) -> float:\n    \"\"\"\n    Robustly extract a force magnitude proxy from edge attributes.\n\n    In compas_tna, horizontal forces and/or force densities relate through:\n    q = scale * (l_force / l_form) and h = q * l_form :contentReference[oaicite:12]{index=12}\n\n    We try common keys in order: 'h', 'f', 'q' (fallback uses |q|).\n    \"\"\"\n    for key in (\"h\", \"f\"):\n        val = form.edge_attribute((u, v), key)\n        if isinstance(val, (int, float)) and not math.isnan(float(val)):\n            return abs(float(val))\n\n    q = form.edge_attribute((u, v), \"q\")\n    if isinstance(q, (int, float)) and not math.isnan(float(q)):\n        return abs(float(q))\n\n    return 0.0\n\n\ndef draw_form_colored_by_force(form: FormDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_form\"])\n\n    # collect magnitudes\n    mags = []\n    edges = []\n    for u, v in form.edges():\n        m = _edge_force_magnitude(form, u, v)\n        mags.append(m)\n        edges.append((u, v))\n\n    mmax = max(mags) if mags else 1.0\n    if mmax <= 0.0:\n        mmax = 1.0\n\n    # redraw edges colored (does not delete previous geometry; use a fresh layer name if you want)\n    colored_layer = layer + \"_FORCECOLOR\"\n    for (u, v), m in zip(edges, mags):\n        t = m / mmax\n        col = _color_map_blue_red(t)\n        a = form.vertex_coordinates(u)\n        b = form.vertex_coordinates(v)\n        _add_line(tuple(a), tuple(b), colored_layer, color=col)\n\n\ndef draw_force(force: ForceDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_force\"])\n    ox = float(params[\"force_offset_x\"])\n    oy = float(params[\"force_offset_y\"])\n    s = float(params[\"draw_scale_force\"])\n\n    # The force diagram is 2D (XY); draw it next to the form diagram\n    for u, v in force.edges():\n        ax, ay, _ = force.vertex_coordinates(u)\n        bx, by, _ = force.vertex_coordinates(v)\n        a = (ox + s * ax, oy + s * ay, 0.0)\n        b = (ox + s * bx, oy + s * by, 0.0)\n        _add_line(a, b, layer)\n\n\n# ==============================================================================\n# Phase 6 — Metrics (forces + reactions proxy)\n# ==============================================================================\n\ndef compute_metrics(form: FormDiagram, supports: List[int]) -> Dict[str, float]:\n    edge_mags = [_edge_force_magnitude(form, u, v) for (u, v) in form.edges()]\n    if not edge_mags:\n        edge_mags = [0.0]\n\n    # Reactions:\n    # If compas_tna stored reactions, they'd be vertex attributes (varies by version).\n    # We attempt 'rz' and fall back to load-balance proxy (sum of applied pz / number of supports).\n    rz_vals = []\n    for v in supports:\n        rz = form.vertex_attribute(v, \"rz\")\n        if isinstance(rz, (int, float)) and not math.isnan(float(rz)):\n            rz_vals.append(float(rz))\n\n    if rz_vals:\n        rmax = max(abs(r) for r in rz_vals)\n        ravg = sum(abs(r) for r in rz_vals) / len(rz_vals)\n    else:\n        total_pz = 0.0\n        for v in form.vertices():\n            pz = form.vertex_attribute(v, \"pz\") or 0.0\n            total_pz += float(pz)\n        # support reaction sum should balance -total_pz\n        per_support = abs(total_pz) / max(1, len(supports))\n        rmax = per_support\n        ravg = per_support\n\n    return {\n        \"edge_force_max\": max(edge_mags),\n        \"edge_force_avg\": sum(edge_mags) / len(edge_mags),\n        \"reaction_max_abs\": rmax,\n        \"reaction_avg_abs\": ravg,\n    }\n\n\n# ==============================================================================\n# Main entrypoint\n# ==============================================================================\n\ndef run(params: Dict[str, float] = None) -> None:\n    params = dict(PARAMS if params is None else params)\n\n    # Phase 0 — Setup: ensure layers exist\n    _ensure_layer(str(params[\"layer_form\"]))\n    _ensure_layer(str(params[\"layer_force\"]))\n\n    # Phase 1 — Topology\n    form = make_form(params)\n\n    # Phase 2 — Supports\n    supports = apply_supports(form, params)\n\n    # Phase 3 — Loads\n    apply_loads(form, supports, params)\n\n    # Phase 4 — Equilibrium\n    force, scale = solve_equilibrium(form, params)\n\n    # Phase 5 — Draw\n    draw_form(form, params)\n    draw_force(force, params)\n    draw_form_colored_by_force(form, params)\n\n    # Phase 6 — Metrics\n    metrics = compute_metrics(form, supports)\n\n    sc.doc.Views.Redraw()\n\n    print(\"=== TNA Funicular Floor: results ===\")\n    print(f\"supports (count): {len(supports)}\")\n    print(f\"vertical scale (from zmax): {scale:.6g}\")\n    print(f\"max edge |force| (proxy): {metrics['edge_force_max']:.6g}\")\n    print(f\"avg edge |force| (proxy): {metrics['edge_force_avg']:.6g}\")\n    print(f\"max |reaction| (proxy):   {metrics['reaction_max_abs']:.6g}\")\n    print(f\"avg |reaction| (proxy):   {metrics['reaction_avg_abs']:.6g}\")\n\n\n# If you press \"Run\" in Rhino Script Editor, this will execute.\nif __name__ == \"__main__\":\n    run()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}