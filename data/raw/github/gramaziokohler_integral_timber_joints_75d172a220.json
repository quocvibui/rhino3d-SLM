{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/actions_movements.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/actions_movements.py",
  "instruction": "Actions movements",
  "code": "import json\nimport os\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nfrom compas.utilities import DataDecoder\nfrom compas_rhino.geometry import RhinoMesh, RhinoPoint\nfrom compas_rhino.ui import CommandMenu\nfrom compas_rhino.utilities.objects import get_object_name\n\nfrom integral_timber_joints.assembly import Assembly\nfrom integral_timber_joints.process import RobotClampAssemblyProcess\nfrom integral_timber_joints.process.dependency import ComputationalDependency, ComputationalResult\nfrom integral_timber_joints.rhino.load import get_activedoc_path_no_ext, get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.rhino.utility import get_existing_beams_filter, recompute_dependent_solutions\nfrom integral_timber_joints.tools import Clamp, Gripper, PickupStation, StackedPickupStation\n\n\ndef reset_dependency_graph(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    process.attributes['dependency'] = ComputationalDependency(process)\n    print(\"Dependency graph is reset.\")\n\n\ndef compute_states(process, verbose=False, beam_ids=None):\n    # type: (RobotClampAssemblyProcess, bool, str) -> None\n    \"\"\"User triggered function to compute Actions from Assembly Sequence\n    \"\"\"\n    process.recompute_initial_state()\n\n    # Make sure everything is computed and nothing is missing\n    if beam_ids is None:\n        beam_ids = process.assembly.sequence\n    for beam_id in beam_ids:\n        process.dependency.invalidate_all(beam_id)\n        process.dependency.compute_all(beam_id, attempt_all_parents_even_failure=False, verbose=verbose)\n\n    invalid_beams = process.dependency.get_invalid_beam_ids()\n    if len(invalid_beams) > 0:\n        print(\"Warning: The following beams are not yet computationally valid: %s\" % invalid_beams)\n        print(\"States are not valid.\")\n        return\n\n    # Assign unique numbers across the entire process file.\n    process.assign_unique_action_numbers()\n\n    # Save action description to log file.\n    log_file_path = get_activedoc_path_no_ext() + \"_process.log\"\n    process.debug_print_process_actions_movements(log_file_path)\n    print(\"Action Log saved to: %s\" % log_file_path)\n\n    # Print out some information to user\n    diff_count = 0\n    for movement in process.movements:\n        diff_count += len(movement.state_diff)\n    print(\"Total: %i diffs computed for %i object states.\" % (diff_count, len(process.initial_state)))\n    print(\"Total: %i Movements in %i Acttions for %i Beams.\" % (len(process.movements), len(process.actions), len(process.assembly.sequence)))\n\n\ndef compute_states_verbose(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    \"\"\"Similar to compute states.\n    Users can pick chich beam_id or seq_n to recompute.\n    \"\"\"\n    sequence = process.assembly.sequence\n    str = rs.GetString('Which seq_n (0 to %i) or beam_id to recompute [default = all]' % (len(sequence)), 'all')\n    if str == 'all':\n        return compute_states(process, verbose=True)\n\n    if str in sequence:\n        beam_id = str\n        return compute_states(process, verbose=True, beam_ids=[beam_id])\n\n    if all([char.isdigit() for char in str]):\n        seq_n = int(str)\n        if seq_n >= 0 and seq_n < len(sequence):\n            beam_id = sequence[seq_n]\n            return compute_states(process, verbose=True, beam_ids=[beam_id])\n\n    print(\"Input %s is not valid\" % str)\n\n\ndef remove_actions(process):\n    # type: (RobotClampAssemblyProcess) -> None\n\n    for beam_id in process.assembly.sequence:\n        process.assembly.set_beam_attribute(beam_id, 'actions', [])\n        process.dependency.invalidate(beam_id, process.create_actions_from_sequence)\n\n    # Legacy file process level actions removal\n    if 'actions' in process.attributes:\n        process.attributes.pop('actions')\n\n    print(\"Actions and states Removed\")\n\n\ndef not_implemented(process):\n    #\n    print('This function is not implemented')\n\n\ndef show_menu(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n\n    while (True):\n        # Create Menu\n        # Check if it is ready to compute Actions and Movements\n        message = \"Compute Actions and Movements:\"\n\n        config = {\n            'message': message,\n            'options': [\n                {'name': 'Finish', 'action': 'Exit'\n                 },\n                {'name': 'ResetDependencyGraph', 'action': reset_dependency_graph\n                 },\n                {'name': 'ComputeStates', 'action': compute_states\n                 },\n                {'name': 'ComputeStatesVerbose', 'action': compute_states_verbose\n                 },\n                {'name': 'RemoveActionsAndStates', 'action': remove_actions\n                 },\n            ]\n\n        }\n\n        result = CommandMenu(config).select_action()\n        # User cancel command by Escape\n        if result is None or 'action' not in result:\n            print('Exit Function')\n            return Rhino.Commands.Result.Cancel\n\n        action = result['action']\n\n        # User click Exit Button\n        if action == 'Exit':\n            print('Exit Function')\n            return Rhino.Commands.Result.Cancel\n        if action == 'Back':\n            # Back is simply redisplaying the menu again from root.\n            continue\n        else:\n            # Run the selected command\n            action(process)\n\n\n######################\n# Rhino Entry Point\n######################\n# Below is the functions that get evoked when user press UI Button\n# Put this in the Rhino button ! _-RunPythonScript 'integral_timber_joints.rhino.tools_environment.py'\nif __name__ == '__main__':\n    process = get_process()\n    if process_is_none(process):\n        print(\"Load json first\")\n    else:\n        show_menu(process)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}