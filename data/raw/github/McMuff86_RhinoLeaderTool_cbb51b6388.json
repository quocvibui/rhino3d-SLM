{
  "source_url": "https://github.com/McMuff86/RhinoLeaderTool/blob/880966d9ae5c50786ba91882e3ffffcddcc64e1d/migrate_leader_usertext_keys.py",
  "repo": "McMuff86/RhinoLeaderTool",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "migrate_leader_usertext_keys.py",
  "instruction": "Migrate leader usertext keys",
  "code": "#! python 3\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport os\nimport json\nimport csv\nfrom datetime import datetime\n\n\ndef load_config():\n    user_dir = os.path.expanduser(\"~\")\n    base_path = os.path.join(user_dir, \"source\", \"repos\", \"work\", \"library\", \"RhinoLeaderTool\")\n    cfg_path = os.path.join(base_path, \"config.json\")\n    default = {\n        \"export\": {\n            \"target_styles\": [\n                \"Standard 1:10 Rahmenbeschriftung\",\n                \"Standard 1:10 Rahmenbeschriftung WHG Eingang\",\n                \"Standard 1:10 Zargenbeschriftung\",\n                \"Standard 1:10 Schiebetürbeschriftung\",\n                \"Standard 1:10 Spez.Rahmenbeschriftung\"\n            ],\n            \"na_value\": \"NA\"\n        }\n    }\n    try:\n        if os.path.isfile(cfg_path):\n            with open(cfg_path, \"r\", encoding=\"utf-8\") as f:\n                file_cfg = json.load(f)\n            for k, v in file_cfg.items():\n                default[k] = v\n    except Exception:\n        pass\n    return default\ndef sync_leaders_with_docdata(keys_to_sync=None):\n    try:\n        # keys_to_sync: Liste von UserText-Schlüsseln auf Leader-Ebene, die aus DocData aktualisiert werden sollen\n        # Verwendet LeaderType, um den DocData-Abschnitt zu bestimmen: \"RhinoLeaderToolType:<typ>\"\n        if keys_to_sync is None:\n            keys_to_sync = []\n        updated = 0\n        total = 0\n        for obj in sc.doc.Objects:\n            if isinstance(obj, Rhino.DocObjects.LeaderObject):\n                total += 1\n                rhobj = obj\n                leader_id = rhobj.Id\n                leader_type = rs.GetUserText(leader_id, \"LeaderType\")\n                if not leader_type:\n                    continue\n                section = f\"RhinoLeaderToolType:{leader_type}\"\n                for k in keys_to_sync:\n                    try:\n                        new_val = rs.GetDocumentData(section, k)\n                        if new_val is not None:\n                            old_val = rs.GetUserText(leader_id, k)\n                            if old_val != new_val:\n                                rs.SetUserText(leader_id, k, new_val)\n                                updated += 1\n                    except Exception:\n                        pass\n        print(\"Leader gesamt:\", total, \"aktualisierte Felder:\", updated)\n    except Exception as e:\n        print(\"Fehler bei Sync DocData → Leader:\", e)\n\n\n\ndef get_base_path(cfg):\n    user_dir = os.path.expanduser(\"~\")\n    default_base = os.path.join(user_dir, \"source\", \"repos\", \"work\", \"library\", \"RhinoLeaderTool\")\n    cfg_base = cfg.get(\"base_path\") if isinstance(cfg, dict) else None\n    return cfg_base if (cfg_base and os.path.isdir(cfg_base)) else default_base\n\ndef get_selected_csv_folder(cfg, prompt_if_missing=False):\n    try:\n        section = \"RhinoLeaderToolGlobals\"\n        key = \"CsvFolder\"\n        selected = None\n        try:\n            selected = rs.GetDocumentData(section, key)\n        except Exception:\n            selected = None\n        if selected and os.path.isdir(selected):\n            return selected\n        if not prompt_if_missing:\n            return None\n        try:\n            start_dir = (cfg.get(\"base_path\") or get_base_path(cfg))\n        except Exception:\n            start_dir = get_base_path(cfg)\n        try:\n            folder = rs.BrowseForFolder(folder=start_dir, message=\"Select CSV folder for this document\")\n        except Exception:\n            folder = None\n        if folder and os.path.isdir(folder):\n            try:\n                rs.SetDocumentData(section, key, folder)\n            except Exception:\n                pass\n            return folder\n    except Exception:\n        pass\n    return None\n\n\ndef read_csv_keys(csv_path):\n    keys = []\n    try:\n        with open(csv_path, mode=\"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n                parts = line.split(\",\", 1)\n                if len(parts) >= 1:\n                    key = parts[0].strip()\n                    if key and key not in keys:\n                        keys.append(key)\n    except Exception:\n        pass\n    return keys\n\n\ndef compute_required_keys_from_config(cfg):\n    required = []\n    try:\n        base_path = get_selected_csv_folder(cfg, prompt_if_missing=False) or get_base_path(cfg)\n        types_cfg = (cfg or {}).get(\"types\", {})\n        seen = set()\n        for _typ, spec in types_cfg.items():\n            csv_name = spec.get(\"csv\")\n            if not csv_name:\n                continue\n            if os.path.isabs(csv_name):\n                csv_path = csv_name\n            else:\n                # recursive lookup\n                csv_path = csv_name\n                try:\n                    direct = os.path.join(base_path, csv_name)\n                    if os.path.isfile(direct):\n                        csv_path = direct\n                    else:\n                        target = os.path.basename(csv_name).lower()\n                        picked = None\n                        best_rel = None\n                        for root, _dirs, files in os.walk(base_path):\n                            for fn in files:\n                                if fn.lower() == target:\n                                    rel = os.path.relpath(os.path.join(root, fn), base_path)\n                                    if best_rel is None or len(rel) < len(best_rel) or (len(rel) == len(best_rel) and rel.lower() < best_rel.lower()):\n                                        best_rel = rel\n                                        picked = os.path.join(root, fn)\n                        if picked:\n                            csv_path = picked\n                except Exception:\n                    pass\n            for key in read_csv_keys(csv_path):\n                if key not in seen:\n                    seen.add(key)\n                    required.append(key)\n    except Exception:\n        pass\n    return required\n\n\ndef migrate_leaders(delete_old_keys=True, write_report=True):\n    cfg = load_config()\n    target_styles = cfg.get(\"export\", {}).get(\"target_styles\", [])\n    na_value = cfg.get(\"export\", {}).get(\"na_value\", \"NA\")\n    # Report-Ziel über Prompt bestimmen\n    def choose_report_target(default_filename):\n        # Soll ein Report erstellt werden?\n        ans = rs.GetBoolean(\"Create migration report?\", (\"Report\", \"No\", \"Yes\"), True)\n        if ans is None or not ans[0]:\n            return False, None\n        # Wohin speichern?\n        ans2 = rs.GetBoolean(\"Save report to Desktop?\", (\"Desktop\", \"No\", \"Yes\"), True)\n        user_dir = os.path.expanduser(\"~\")\n        desktop = os.path.join(user_dir, \"Desktop\")\n        if ans2 is not None and ans2[0]:\n            return True, os.path.join(desktop, default_filename)\n        # An das Rhino-Dokument anlehnen\n        doc_path = sc.doc.Path or \"\"\n        base_dir = os.path.dirname(doc_path) if doc_path else desktop\n        report_dir = os.path.join(base_dir, \"report\")\n        if not os.path.isdir(report_dir):\n            try:\n                os.makedirs(report_dir)\n            except Exception:\n                report_dir = base_dir\n        return True, os.path.join(report_dir, default_filename)\n\n    # Mapping alter → neuer Schlüssel\n    key_mapping = {\n        \"Mauerlichtbreite\": \"Mauerlichtbreite_plan\",\n        \"Mauerlichthöhe\": \"Mauerlichthöhe_plan\",\n        \"Mauerstärke\": \"Mauerstärke_plan\",\n    }\n\n    # Sicherzustellende neuen Schlüssel (Union aller CSV-Keys aus config.json)\n    required_keys = compute_required_keys_from_config(cfg)\n    # Zusätzlich hart erforderliche Metadaten-Schlüssel\n    for meta_key in [\"Haus\", \"Betriebsauftrag\"]:\n        if meta_key not in required_keys:\n            required_keys.append(meta_key)\n\n    total = 0\n    modified = 0\n    report_rows = []\n\n    for obj in sc.doc.Objects:\n        if isinstance(obj, Rhino.DocObjects.LeaderObject):\n            total += 1\n\n            # Filtern nach DimStyle, falls konfiguriert\n            process = True\n            try:\n                dimstyle = sc.doc.DimStyles.FindId(obj.Geometry.DimensionStyleId)\n                if target_styles:\n                    process = dimstyle is not None and dimstyle.Name in target_styles\n            except Exception:\n                pass\n            if not process:\n                continue\n\n            # Bestehende UserText-Werte lesen\n            current = {}\n            key_store = obj.Attributes.GetUserStrings()\n            if key_store:\n                for k in key_store.AllKeys:\n                    current[k] = key_store[k]\n\n            obj_id = obj.Id\n            changed_this = False\n\n            # Mapping anwenden (alte → neue Schlüssel), nur setzen wenn neuer noch nicht existiert\n            for old_key, new_key in key_mapping.items():\n                if old_key in current:\n                    if new_key not in current or (current.get(new_key) is None or current.get(new_key) == \"\"):\n                        rs.SetUserText(obj_id, new_key, current[old_key])\n                        changed_this = True\n                    if delete_old_keys:\n                        rs.SetUserText(obj_id, old_key, None)\n                        changed_this = True\n\n            # Fehlende required_keys mit NA auffüllen (nur wenn nicht vorhanden)\n            # Dazu aktuellen Stand neu lesen\n            key_store = sc.doc.Objects.Find(obj_id).Attributes.GetUserStrings()\n            existing_now = set(key_store.AllKeys) if key_store else set()\n            for req_key in required_keys:\n                if req_key not in existing_now:\n                    rs.SetUserText(obj_id, req_key, na_value)\n                    changed_this = True\n\n            # LeaderGUID sicherstellen\n            existing_guid = rs.GetUserText(obj_id, \"LeaderGUID\")\n            if not existing_guid:\n                rs.SetUserText(obj_id, \"LeaderGUID\", str(obj_id))\n                changed_this = True\n\n            # SchemaVersion setzen, falls nicht vorhanden\n            existing_schema = rs.GetUserText(obj_id, \"SchemaVersion\")\n            if not existing_schema:\n                rs.SetUserText(obj_id, \"SchemaVersion\", \"1.0\")\n                changed_this = True\n\n            # Reporting sammeln\n            if changed_this:\n                row = {\n                    \"LeaderGUID\": str(obj_id),\n                    \"DimStyle\": dimstyle.Name if dimstyle else \"\",\n                    \"ChangedKeys\": \";\".join(sorted(list(existing_now.symmetric_difference(set(sc.doc.Objects.Find(obj_id).Attributes.GetUserStrings().AllKeys))))) if key_store else \"\"\n                }\n                report_rows.append(row)\n\n            if changed_this:\n                modified += 1\n\n    print(\"Leader-Objekte gesamt:\", total)\n    print(\"Davon angepasst:\", modified)\n\n    # Report schreiben\n    if write_report and report_rows:\n        default_name = f\"leader_migration_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\"\n        should_write, report_path = choose_report_target(default_name)\n        if should_write and report_path:\n            try:\n                with open(report_path, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n                    writer = csv.DictWriter(f, fieldnames=[\"LeaderGUID\", \"DimStyle\", \"ChangedKeys\"])\n                    writer.writeheader()\n                    for r in report_rows:\n                        writer.writerow(r)\n                print(\"Migrationsreport gespeichert:\", report_path)\n            except Exception as e:\n                print(\"Konnte Migrationsreport nicht schreiben:\", e)\n\n\n# Bulk-Update: Setzt für alle passenden Leader einen bestimmten UserText-Key auf einen neuen Wert\ndef bulk_update_key_for_leaders(target_key, new_value, only_if_missing=False, styles=None, write_report=True):\n    cfg = load_config()\n    target_styles = styles if styles is not None else cfg.get(\"export\", {}).get(\"target_styles\", [])\n    # Report-Ziel über Prompt bestimmen\n    def choose_report_target(default_filename):\n        ans = rs.GetBoolean(\"Create bulk-update report?\", (\"Report\", \"No\", \"Yes\"), True)\n        if ans is None or not ans[0]:\n            return False, None\n        ans2 = rs.GetBoolean(\"Save report to Desktop?\", (\"Desktop\", \"No\", \"Yes\"), True)\n        user_dir = os.path.expanduser(\"~\")\n        desktop = os.path.join(user_dir, \"Desktop\")\n        if ans2 is not None and ans2[0]:\n            return True, os.path.join(desktop, default_filename)\n        doc_path = sc.doc.Path or \"\"\n        base_dir = os.path.dirname(doc_path) if doc_path else desktop\n        report_dir = os.path.join(base_dir, \"report\")\n        if not os.path.isdir(report_dir):\n            try:\n                os.makedirs(report_dir)\n            except Exception:\n                report_dir = base_dir\n        return True, os.path.join(report_dir, default_filename)\n\n    total = 0\n    touched = 0\n    rows = []\n\n    for obj in sc.doc.Objects:\n        if isinstance(obj, Rhino.DocObjects.LeaderObject):\n            total += 1\n            dimstyle = None\n            try:\n                dimstyle = sc.doc.DimStyles.FindId(obj.Geometry.DimensionStyleId)\n            except Exception:\n                pass\n            # Filtern nach DimStyles, falls konfiguriert\n            if target_styles:\n                if not dimstyle or dimstyle.Name not in target_styles:\n                    continue\n\n            obj_id = obj.Id\n            current_store = obj.Attributes.GetUserStrings()\n            old_val = None\n            if current_store and target_key in current_store.AllKeys:\n                old_val = current_store[target_key]\n\n            # Bedingung: nur setzen wenn fehlend\n            if only_if_missing and old_val not in (None, \"\"):\n                continue\n\n            rs.SetUserText(obj_id, target_key, new_value)\n\n            # LeaderGUID sicherstellen\n            if not rs.GetUserText(obj_id, \"LeaderGUID\"):\n                rs.SetUserText(obj_id, \"LeaderGUID\", str(obj_id))\n\n            # SchemaVersion, wenn noch nicht vorhanden\n            if not rs.GetUserText(obj_id, \"SchemaVersion\"):\n                rs.SetUserText(obj_id, \"SchemaVersion\", \"1.0\")\n\n            touched += 1\n            rows.append({\n                \"LeaderGUID\": str(obj_id),\n                \"DimStyle\": (dimstyle.Name if dimstyle else \"\"),\n                \"Key\": target_key,\n                \"OldValue\": (old_val if old_val is not None else \"\"),\n                \"NewValue\": new_value\n            })\n\n    print(\"Leaders gefunden:\", total)\n    print(\"Geänderte Leaders:\", touched)\n\n    if write_report and rows:\n        default_name = f\"leader_bulk_update_{target_key}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\"\n        should_write, report_path = choose_report_target(default_name)\n        if should_write and report_path:\n            try:\n                with open(report_path, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n                    writer = csv.DictWriter(f, fieldnames=[\"LeaderGUID\", \"DimStyle\", \"Key\", \"OldValue\", \"NewValue\"])\n                    writer.writeheader()\n                    for r in rows:\n                        writer.writerow(r)\n                print(\"Bulk-Update-Report gespeichert:\", report_path)\n            except Exception as e:\n                print(\"Konnte Bulk-Update-Report nicht schreiben:\", e)\n\n# Ausführen\nif __name__ == \"__main__\":\n    migrate_leaders(delete_old_keys=True, write_report=True)\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}