{
  "source_url": "https://discourse.mcneel.com/t/script-share-engrave-text-in-solid/214651",
  "topic_id": 214651,
  "title": "Script Share - Engrave Text in Solid",
  "question": "Here’s a Python script for engraving text on a solid in relation to a surface edge (parallel to and ‘pointing at’ an edge)\n\n\nthe hardcoded text is Arial but you should be able to change that at the top of the script.. the default parameters are for inches so it might be too tiny if modeling in millimeters.\n\n\n\n\n\n\n# -*- coding: utf-8 -*-\n\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport System\n\n\n# ============================================================\n# STICKY DEFAULTS (edit script defaults here)\n# ============================================================\nDEFAULT_FONT_NAME = \"Arial\"\n\nDEFAULT_INSET = 0.875\nDEFAULT_TEXT_HEIGHT = 1.0\nDEFAULT_DEPTH = 0.09\nDEFAULT_LABEL_TEXT = \"\"\nDEFAULT_PREVIEW = True\n\n\n# ============================================================\n# TEXT HELPERS\n# ============================================================\ndef create_text_curves_worldxy(text, text_height, font_name):\n    \"\"\"\n    Creates text outline curves in WorldXY using a centralized text definition.\n    Returns a list of curves or None.\n    \"\"\"\n\n    text_entity = Rhino.Geometry.TextEntity()\n    text_entity.Plane = Rhino.Geometry.Plane.WorldXY\n    text_entity.Text = text\n    text_entity.TextHeight = text_height\n    text_entity.Justification = Rhino.Geometry.TextJustification.TopCenter\n\n    font_index = sc.doc.Fonts.FindOrCreate(font_name, False, False)\n    text_entity.Font = sc.doc.Fonts[font_index]\n\n    curves = text_entity.CreateCurves(text_entity.DimensionStyle, False, 0, 0)\n    if not curves:\n        return None\n\n    return curves\n\n\n# ============================================================\n# FACE-TRIM / INNER-LOOP DIRECTION RESOLUTION\n# ============================================================\ndef resolve_perp_vec_on_face(face, origin_pt, perp_vec, inset_val):\n    \"\"\"\n    Ensures perp_vec points toward the usable trimmed region of the BrepFace.\n\n    This solves cases where a face contains holes / inner loops and the\n    centroid-based...",
  "code_blocks": [
    {
      "code": "# -*- coding: utf-8 -*-\n\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport System\n\n\n# ============================================================\n# STICKY DEFAULTS (edit script defaults here)\n# ============================================================\nDEFAULT_FONT_NAME = \"Arial\"\n\nDEFAULT_INSET = 0.875\nDEFAULT_TEXT_HEIGHT = 1.0\nDEFAULT_DEPTH = 0.09\nDEFAULT_LABEL_TEXT = \"\"\nDEFAULT_PREVIEW = True\n\n\n# ============================================================\n# TEXT HELPERS\n# ============================================================\ndef create_text_curves_worldxy(text, text_height, font_name):\n    \"\"\"\n    Creates text outline curves in WorldXY using a centralized text definition.\n    Returns a list of curves or None.\n    \"\"\"\n\n    text_entity = Rhino.Geometry.TextEntity()\n    text_entity.Plane = Rhino.Geometry.Plane.WorldXY\n    text_entity.Text = text\n    text_entity.TextHeight = text_height\n    text_entity.Justification = Rhino.Geometry.TextJustification.TopCenter\n\n    font_index = sc.doc.Fonts.FindOrCreate(font_name, False, False)\n    text_entity.Font = sc.doc.Fonts[font_index]\n\n    curves = text_entity.CreateCurves(text_entity.DimensionStyle, False, 0, 0)\n    if not curves:\n        return None\n\n    return curves\n\n\n# ============================================================\n# FACE-TRIM / INNER-LOOP DIRECTION RESOLUTION\n# ============================================================\ndef resolve_perp_vec_on_face(face, origin_pt, perp_vec, inset_val):\n    \"\"\"\n    Ensures perp_vec points toward the usable trimmed region of the BrepFace.\n\n    This solves cases where a face contains holes / inner loops and the\n    centroid-based heuristic may point \"inward\" toward a void instead of onto\n    the actual usable face area.\n\n    Method:\n    - Test two candidate points at +/- inset distance from the edge\n    - Choose the perp direction whose test point lies on the trimmed face\n\n    Notes:\n    - Uses ClosestPoint + IsPointOnFace(u,v) to avoid RhinoCommon overload\n      ambiguity on Mac/pythonnet.\n    \"\"\"\n    tol = max(sc.doc.ModelAbsoluteTolerance * 5.0, 0.001)\n\n    def is_on_trimmed_face(test_pt):\n        ok, u, v = face.ClosestPoint(test_pt)\n        if not ok:\n            return False\n\n        face_pt = face.PointAt(u, v)\n        if face_pt.DistanceTo(test_pt) > tol:\n            return False\n\n        rel = face.IsPointOnFace(u, v)\n        return (rel == Rhino.Geometry.PointFaceRelation.Interior or\n                rel == Rhino.Geometry.PointFaceRelation.Boundary)\n\n    pt_plus = origin_pt + perp_vec * inset_val\n    pt_minus = origin_pt - perp_vec * inset_val\n\n    plus_on = is_on_trimmed_face(pt_plus)\n    minus_on = is_on_trimmed_face(pt_minus)\n\n    if plus_on and not minus_on:\n        return perp_vec\n    if minus_on and not plus_on:\n        return -perp_vec\n\n    return perp_vec\n\n\n# ============================================================\n# PREVIEW GETPOINT CLASS (DynamicDraw overlay)\n# ============================================================\nclass PreviewPointGetter(Rhino.Input.Custom.GetPoint):\n    def __init__(self, brep, face, face_index, label_text, font_name, opt_inset, opt_height, opt_depth):\n        super(PreviewPointGetter, self).__init__()\n        self.brep = brep\n        self.face = face\n        self.face_index = face_index\n        self.label_text = label_text\n        self.font_name = font_name\n\n        self.opt_inset = opt_inset\n        self.opt_height = opt_height\n        self.opt_depth = opt_depth\n\n        # Cached preview curves (rebuilt only when mouse/options meaningfully change)\n        self._preview_curves = None\n        self._last_point = None\n        self._last_inset = None\n        self._last_height = None\n\n    def _build_preview_curves(self, picked_pt, inset_val, text_height):\n        \"\"\"\n        Builds transformed text outline curves to match the final engraving placement.\n        Returns curves only (no breps), for lightweight preview drawing.\n        \"\"\"\n\n        brep = self.brep\n        face = self.face\n\n        # ----------------------------\n        # PREVIEW GEO 1: Find closest edge\n        # ----------------------------\n        closest_edge = None\n        best_dist = float(\"inf\")\n        edge_t = 0.0\n\n        for idx in face.AdjacentEdges():\n            edge = brep.Edges[idx]\n            success, t = edge.ClosestPoint(picked_pt)\n            if not success:\n                continue\n\n            pt = edge.PointAt(t)\n            dist = pt.DistanceTo(picked_pt)\n\n            if dist < best_dist:\n                best_dist = dist\n                closest_edge = edge\n                edge_t = t\n\n        if closest_edge is None:\n            return None\n\n        origin_pt = closest_edge.PointAt(edge_t)\n\n        # ----------------------------\n        # PREVIEW GEO 2: Face normal (forced outward)\n        # ----------------------------\n        success, u, v = face.ClosestPoint(origin_pt)\n        if not success:\n            return None\n\n        face_normal = face.NormalAt(u, v)\n        face_normal.Unitize()\n\n        test_pt = origin_pt + face_normal * max(sc.doc.ModelAbsoluteTolerance * 10, 0.01)\n        if brep.IsPointInside(test_pt, sc.doc.ModelAbsoluteTolerance, False):\n            face_normal = -face_normal\n\n        # ----------------------------\n        # PREVIEW GEO 3: Tangent + perpendicular\n        # ----------------------------\n        tangent_vec = closest_edge.TangentAt(edge_t)\n        tangent_vec -= face_normal * (tangent_vec * face_normal)\n        if not tangent_vec.Unitize():\n            return None\n\n        perp_vec = Rhino.Geometry.Vector3d.CrossProduct(face_normal, tangent_vec)\n        if not perp_vec.Unitize():\n            return None\n\n        # ----------------------------\n        # PREVIEW GEO 4: Resolve inward direction (centroid heuristic)\n        # ----------------------------\n        amp = Rhino.Geometry.AreaMassProperties.Compute(face)\n        if amp:\n            centroid = amp.Centroid\n            ok, cu, cv = face.ClosestPoint(centroid)\n            if ok:\n                interior_vec = face.PointAt(cu, cv) - origin_pt\n                interior_vec -= face_normal * (interior_vec * face_normal)\n                if interior_vec.Unitize() and perp_vec * interior_vec < 0:\n                    perp_vec = -perp_vec\n\n        # ----------------------------\n        # PREVIEW GEO 4B: Trim-aware override (handles holes / inner loops)\n        # ----------------------------\n        perp_vec = resolve_perp_vec_on_face(face, origin_pt, perp_vec, inset_val)\n\n        # ----------------------------\n        # PREVIEW GEO 5: Target text plane\n        # ----------------------------\n        text_location = origin_pt + perp_vec * inset_val\n\n        plane_y = origin_pt - text_location\n        if not plane_y.Unitize():\n            return None\n\n        plane_x = tangent_vec\n        target_plane = Rhino.Geometry.Plane(text_location, plane_x, plane_y)\n\n        if target_plane.ZAxis * face_normal < 0:\n            target_plane = Rhino.Geometry.Plane(\n                target_plane.Origin,\n                -target_plane.XAxis,\n                target_plane.YAxis\n            )\n\n        # ----------------------------\n        # PREVIEW GEO 6: Text → curves (preview output)\n        # ----------------------------\n        curves = create_text_curves_worldxy(self.label_text, text_height, self.font_name)\n        if not curves:\n            return None\n\n        xform = Rhino.Geometry.Transform.PlaneToPlane(\n            Rhino.Geometry.Plane.WorldXY,\n            target_plane\n        )\n\n        out = []\n        for crv in curves:\n            dup = crv.DuplicateCurve()\n            dup.Transform(xform)\n            out.append(dup)\n\n        return out\n\n    def OnDynamicDraw(self, e):\n        \"\"\"\n        Draw preview curves during mouse movement.\n        \"\"\"\n\n        try:\n            pt = e.CurrentPoint\n            inset_val = self.opt_inset.CurrentValue\n            height_val = self.opt_height.CurrentValue\n\n            # Rebuild preview only when needed\n            needs_rebuild = (\n                self._preview_curves is None or\n                self._last_point is None or\n                pt.DistanceTo(self._last_point) > (sc.doc.ModelAbsoluteTolerance * 0.5) or\n                inset_val != self._last_inset or\n                height_val != self._last_height\n            )\n\n            if needs_rebuild:\n                self._preview_curves = self._build_preview_curves(pt, inset_val, height_val)\n                self._last_point = pt\n                self._last_inset = inset_val\n                self._last_height = height_val\n\n            if self._preview_curves:\n                color = System.Drawing.Color.Purple\n                thickness = 2\n                for crv in self._preview_curves:\n                    e.Display.DrawCurve(crv, color, thickness)\n\n        except:\n            # Preview should never crash the command\n            pass\n\n\ndef label_engrave():\n\n    # ============================================================\n    # UI PHASE\n    # ============================================================\n\n    # ----------------------------\n    # Sticky defaults (persistent between runs)\n    # ----------------------------\n    inset_val = sc.sticky.get(\"Inset\", DEFAULT_INSET)\n    text_height = sc.sticky.get(\"TextHeight\", DEFAULT_TEXT_HEIGHT)\n    depth_val = sc.sticky.get(\"Depth\", DEFAULT_DEPTH)\n    label_text = sc.sticky.get(\"LabelText\", DEFAULT_LABEL_TEXT)\n\n    font_name = sc.sticky.get(\"FontName\", DEFAULT_FONT_NAME)\n    preview_on = sc.sticky.get(\"Preview\", DEFAULT_PREVIEW)\n\n    # ----------------------------\n    # UI STEP 1A: Select target surface\n    # ----------------------------\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"Select target surface\")\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\n    go.SubObjectSelect = True\n    go.EnablePreSelect(True, True)\n\n    res = go.Get()\n    if res != Rhino.Input.GetResult.Object:\n        return\n\n    obj_ref = go.Object(0)\n    face = obj_ref.Face()\n    if face is None:\n        return\n\n    # Parent solid + face identification\n    brep = face.Brep\n    face_index = face.FaceIndex\n    target_id = obj_ref.ObjectId\n\n    # Capture original object layer so the boolean result stays on that layer\n    target_obj = obj_ref.Object()\n    target_layer_index = target_obj.Attributes.LayerIndex\n\n    # ----------------------------\n    # UI STEP 1B: Enter label text\n    # ----------------------------\n    gs = Rhino.Input.Custom.GetString()\n    gs.SetCommandPrompt(\"Enter label text (Enter to reuse last)\")\n    gs.AcceptNothing(True)\n\n    res = gs.Get()\n    if res == Rhino.Input.GetResult.Cancel:\n        return\n\n    if res == Rhino.Input.GetResult.String:\n        entered = gs.StringResult()\n        if entered:\n            label_text = entered\n\n    if not label_text:\n        print(\"No label text specified.\")\n        return\n\n    sc.sticky[\"LabelText\"] = label_text\n\n    # ----------------------------\n    # UI STEP 2: Select point on edge + options\n    # ----------------------------\n    opt_inset = Rhino.Input.Custom.OptionDouble(inset_val)\n    opt_height = Rhino.Input.Custom.OptionDouble(text_height)\n    opt_depth = Rhino.Input.Custom.OptionDouble(depth_val)\n    opt_preview = Rhino.Input.Custom.OptionToggle(preview_on, \"Off\", \"On\")\n\n    if preview_on:\n        gp = PreviewPointGetter(brep, face, face_index, label_text, font_name, opt_inset, opt_height, opt_depth)\n    else:\n        gp = Rhino.Input.Custom.GetPoint()\n\n    gp.SetCommandPrompt(\"Select point on edge\")\n    gp.Constrain(brep, -1, face_index, False)\n\n    gp.AddOptionDouble(\"Inset\", opt_inset)\n    gp.AddOptionDouble(\"Height\", opt_height)\n    gp.AddOptionDouble(\"Depth\", opt_depth)\n    gp.AddOptionToggle(\"Preview\", opt_preview)\n\n    while True:\n        res = gp.Get()\n\n        if res == Rhino.Input.GetResult.Point:\n            picked_pt = gp.Point()\n            break\n\n        if res == Rhino.Input.GetResult.Option:\n            inset_val = opt_inset.CurrentValue\n            text_height = opt_height.CurrentValue\n            depth_val = opt_depth.CurrentValue\n            preview_on = opt_preview.CurrentValue\n\n            # If preview was toggled, restart the picker so DynamicDraw matches the new state\n            if preview_on != sc.sticky.get(\"Preview\", DEFAULT_PREVIEW):\n                sc.sticky[\"Preview\"] = preview_on\n                sc.sticky[\"Inset\"] = inset_val\n                sc.sticky[\"TextHeight\"] = text_height\n                sc.sticky[\"Depth\"] = depth_val\n                return label_engrave()\n\n            continue\n\n        if res == Rhino.Input.GetResult.Cancel:\n            return\n\n    sc.sticky[\"Inset\"] = inset_val\n    sc.sticky[\"TextHeight\"] = text_height\n    sc.sticky[\"Depth\"] = depth_val\n    sc.sticky[\"FontName\"] = font_name\n    sc.sticky[\"Preview\"] = preview_on\n\n    # ============================================================\n    # GEOMETRY PHASE (deterministic + orientation-safe)\n    # ============================================================\n\n    # ----------------------------\n    # FINAL GEO 1: Find closest edge\n    # ----------------------------\n    closest_edge = None\n    best_dist = float(\"inf\")\n    edge_t = 0.0\n\n    for idx in face.AdjacentEdges():\n        edge = brep.Edges[idx]\n        success, t = edge.ClosestPoint(picked_pt)\n        if not success:\n            continue\n\n        pt = edge.PointAt(t)\n        dist = pt.DistanceTo(picked_pt)\n\n        if dist < best_dist:\n            best_dist = dist\n            closest_edge = edge\n            edge_t = t\n\n    if closest_edge is None:\n        return\n\n    origin_pt = closest_edge.PointAt(edge_t)\n\n    # ----------------------------\n    # FINAL GEO 2: Face normal (forced outward)\n    # ----------------------------\n    success, u, v = face.ClosestPoint(origin_pt)\n    if not success:\n        return\n\n    face_normal = face.NormalAt(u, v)\n    face_normal.Unitize()\n\n    test_pt = origin_pt + face_normal * max(sc.doc.ModelAbsoluteTolerance * 10, 0.01)\n    if brep.IsPointInside(test_pt, sc.doc.ModelAbsoluteTolerance, False):\n        face_normal = -face_normal\n\n    # ----------------------------\n    # FINAL GEO 3: Tangent + perpendicular\n    # ----------------------------\n    tangent_vec = closest_edge.TangentAt(edge_t)\n    tangent_vec -= face_normal * (tangent_vec * face_normal)\n    if not tangent_vec.Unitize():\n        return\n\n    perp_vec = Rhino.Geometry.Vector3d.CrossProduct(face_normal, tangent_vec)\n    if not perp_vec.Unitize():\n        return\n\n    # ----------------------------\n    # FINAL GEO 4: Resolve inward direction (centroid heuristic)\n    # ----------------------------\n    amp = Rhino.Geometry.AreaMassProperties.Compute(face)\n    if amp:\n        centroid = amp.Centroid\n        ok, cu, cv = face.ClosestPoint(centroid)\n        if ok:\n            interior_vec = face.PointAt(cu, cv) - origin_pt\n            interior_vec -= face_normal * (interior_vec * face_normal)\n            if interior_vec.Unitize() and perp_vec * interior_vec < 0:\n                perp_vec = -perp_vec\n\n    # ----------------------------\n    # FINAL GEO 4B: Trim-aware override (handles holes / inner loops)\n    # ----------------------------\n    perp_vec = resolve_perp_vec_on_face(face, origin_pt, perp_vec, inset_val)\n\n    # ----------------------------\n    # FINAL GEO 5: Target text plane\n    # ----------------------------\n    text_location = origin_pt + perp_vec * inset_val\n\n    plane_y = origin_pt - text_location\n    if not plane_y.Unitize():\n        return\n\n    plane_x = tangent_vec\n    target_plane = Rhino.Geometry.Plane(text_location, plane_x, plane_y)\n\n    if target_plane.ZAxis * face_normal < 0:\n        target_plane = Rhino.Geometry.Plane(\n            target_plane.Origin,\n            -target_plane.XAxis,\n            target_plane.YAxis\n        )\n\n    # ----------------------------\n    # FINAL GEO 6: Text → planar regions\n    # ----------------------------\n    curves = create_text_curves_worldxy(label_text, text_height, font_name)\n    if not curves:\n        return\n\n    xform = Rhino.Geometry.Transform.PlaneToPlane(\n        Rhino.Geometry.Plane.WorldXY,\n        target_plane\n    )\n\n    for crv in curves:\n        crv.Transform(xform)\n\n    planar_breps = Rhino.Geometry.Brep.CreatePlanarBreps(\n        curves, sc.doc.ModelAbsoluteTolerance\n    )\n    if not planar_breps:\n        print(\"Failed to create planar regions.\")\n        return\n\n    # ----------------------------\n    # FINAL GEO 7: Create engraving cutters\n    # ----------------------------\n    cutters = []\n\n    for pb in planar_breps:\n        cutter = Rhino.Geometry.Brep.CreateFromOffsetFace(\n            pb.Faces[0],\n            -depth_val,\n            sc.doc.ModelAbsoluteTolerance,\n            False,\n            True\n        )\n        if cutter:\n            cutters.append(cutter)\n\n    # ============================================================\n    # BOOLEAN PHASE (command-engine boolean)\n    # ============================================================\n\n    cutter_ids = []\n    for cutter in cutters:\n        cid = sc.doc.Objects.AddBrep(cutter)\n        if cid != System.Guid.Empty:\n            cutter_ids.append(cid)\n\n    if not cutter_ids:\n        print(\"No engraving cutters created.\")\n        return\n\n    # Switch current layer so boolean results land on the same layer as the selected solid\n    prev_layer_index = sc.doc.Layers.CurrentLayerIndex\n    sc.doc.Layers.SetCurrentLayerIndex(target_layer_index, True)\n\n    try:\n        result_ids = rs.BooleanDifference([target_id], cutter_ids, delete_input=True)\n    finally:\n        # Always restore previous current layer\n        sc.doc.Layers.SetCurrentLayerIndex(prev_layer_index, True)\n\n    if not result_ids:\n        for cid in cutter_ids:\n            rs.DeleteObject(cid)\n        print(\"Boolean difference failed.\")\n        return\n\n    if isinstance(result_ids, list) and len(result_ids) > 1:\n        for extra in result_ids[1:]:\n            rs.DeleteObject(extra)\n\n    sc.doc.Views.Redraw()\n    print(\"Engrave complete.\")\n\n\nif __name__ == \"__main__\":\n    label_engrave()",
      "language": "python",
      "author": "jeff_hammond",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "csharp",
    "file-io",
    "geometry",
    "layers",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 1,
  "views": 84
}