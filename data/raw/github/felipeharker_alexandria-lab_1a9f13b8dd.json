{
  "source_url": "https://github.com/felipeharker/alexandria-lab/blob/1d3696f4b28ecc45579b5fbe5809a7e00699fa08/alexandria-application-files/alexandria-scripts/ghpython/region_grid.py",
  "repo": "felipeharker/alexandria-lab",
  "repo_stars": 1,
  "repo_description": "a repo of documents, links, visual assets, drawings, videos, articles, etc. I find interesting. Brain dump, catch-all repo with limited structure. ",
  "license": "unknown",
  "filepath": "alexandria-application-files/alexandria-scripts/ghpython/region_grid.py",
  "instruction": "ALEXANDRIA IO SPEC (standardized) Inputs: - Boundary (GH: B) | Rhino.Geometry.Curve | Closed planar boundary - RadiusX (GH: RadX) | float | Cell radius in X - RadiusY (GH: RadY) | float | Cell radius in Y (0 => RadiusX) - UseHex (GH: Type) | bool | True=hex, False=rect Outputs: - GridCells (GH: GridCells) | list[Rhino.Geometry.Curve] | Accepted in-boundary cells - Rows (GH: R) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Cells grouped by row - Cols (GH: C) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Cells grouped by column",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - Boundary (GH: B) | Rhino.Geometry.Curve | Closed planar boundary\n# - RadiusX (GH: RadX) | float | Cell radius in X\n# - RadiusY (GH: RadY) | float | Cell radius in Y (0 => RadiusX)\n# - UseHex (GH: Type) | bool | True=hex, False=rect\n# Outputs:\n# - GridCells (GH: GridCells) | list[Rhino.Geometry.Curve] | Accepted in-boundary cells\n# - Rows (GH: R) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Cells grouped by row\n# - Cols (GH: C) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Cells grouped by column\n\nimport math\nimport Rhino\nfrom Rhino.Geometry import Point3d, Polyline, PolylineCurve\nfrom Rhino.Geometry.Intersect import Intersection\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\ndef _is_closed_planar(crv, tol):\n    if crv is None: return False\n    if not crv.IsClosed: return False\n    ok, _ = crv.TryGetPlane(tol)\n    return ok\n\ndef _curve_plane(crv, tol):\n    ok, pln = crv.TryGetPlane(tol)\n    return pln if ok else None\n\ndef _hex_pts_xy(cx, cy, rx, ry):\n    # pointy-top hex; rx stretches X, ry stretches Y\n    pts = []\n    for k in range(6):\n        ang = math.radians(30.0 + 60.0 * k)\n        pts.append((cx + rx * math.cos(ang), cy + ry * math.sin(ang)))\n    return pts\n\ndef _rect_pts_xy(cx, cy, rx, ry):\n    # axis-aligned rectangle; if rx==ry it's a square\n    return [\n        (cx - rx, cy - ry),\n        (cx + rx, cy - ry),\n        (cx + rx, cy + ry),\n        (cx - rx, cy + ry),\n    ]\n\ndef _poly_fully_inside(cell_crv, boundary, plane, tol):\n    ok, pl = cell_crv.TryGetPolyline()\n    if not ok:\n        return False\n\n    # all vertices must be inside (or on boundary)\n    for i in range(pl.Count - 1):\n        if boundary.Contains(pl[i], plane, tol) == Rhino.Geometry.PointContainment.Outside:\n            return False\n\n    # any intersection (including touching) rejects\n    x = Intersection.CurveCurve(cell_crv, boundary, tol, tol)\n    if x and x.Count > 0:\n        return False\n\n    return True\n\n# ----------------------------\n# Main\n# ----------------------------\nGridCells = []\nR = DataTree[object]()  # rows\nC = DataTree[object]()  # cols\n\nif B is None or RadX is None:\n    GridCells = []\nelse:\n    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance if Rhino.RhinoDoc.ActiveDoc else 1e-6\n\n    rx = float(RadX)\n    if rx <= 0.0:\n        GridCells = []\n    else:\n        # Critical rule: if RadY == 0 -> regular polygons\n        if RadY is None:\n            ry = rx\n        else:\n            ry_in = float(RadY)\n            ry = rx if abs(ry_in) <= tol else ry_in\n\n        if not _is_closed_planar(B, tol):\n            GridCells = []\n        else:\n            plane = _curve_plane(B, tol)\n\n            # boundary plane coords -> World XY\n            xform_w2p = Rhino.Geometry.Transform.ChangeBasis(plane, Rhino.Geometry.Plane.WorldXY)\n            xform_p2w = Rhino.Geometry.Transform.ChangeBasis(Rhino.Geometry.Plane.WorldXY, plane)\n\n            B2 = B.DuplicateCurve()\n            B2.Transform(xform_w2p)\n\n            mp = Rhino.Geometry.AreaMassProperties.Compute(B2)\n            ctr2 = mp.Centroid if mp else B2.GetBoundingBox(True).Center\n\n            use_hex = True if Type else False\n\n            # Grid spacing derived from rx/ry\n            if use_hex:\n                dx = math.sqrt(3.0) * rx\n                dy = 1.5 * ry\n            else:\n                dx = 2.0 * rx\n                dy = 2.0 * ry\n\n            bb = B2.GetBoundingBox(True)\n            minx = bb.Min.X - 2.0 * dx\n            maxx = bb.Max.X + 2.0 * dx\n            miny = bb.Min.Y - 2.0 * dy\n            maxy = bb.Max.Y + 2.0 * dy\n\n            j_min = int(math.floor((miny - ctr2.Y) / dy)) - 1\n            j_max = int(math.ceil((maxy - ctr2.Y) / dy)) + 1\n            i_min = int(math.floor((minx - ctr2.X) / dx)) - 1\n            i_max = int(math.ceil((maxx - ctr2.X) / dx)) + 1\n\n            cells_by_row = {}  # j -> list of (i, curve)\n            cells_by_col = {}  # i -> list of (j, curve)\n\n            for j in range(j_min, j_max + 1):\n                y = ctr2.Y + j * dy\n                row_offset = (0.5 * dx if (use_hex and (j & 1)) else 0.0)\n\n                for i in range(i_min, i_max + 1):\n                    x = ctr2.X + i * dx + row_offset\n                    cpt2 = Point3d(x, y, 0.0)\n\n                    # quick cull: center must be inside\n                    if B2.Contains(cpt2, Rhino.Geometry.Plane.WorldXY, tol) == Rhino.Geometry.PointContainment.Outside:\n                        continue\n\n                    # build candidate cell in plane coords (WorldXY)\n                    if use_hex:\n                        verts = _hex_pts_xy(x, y, rx, ry)\n                    else:\n                        verts = _rect_pts_xy(x, y, rx, ry)\n\n                    pts = [Point3d(vx, vy, 0.0) for (vx, vy) in verts]\n                    pts.append(pts[0])\n\n                    pline = Polyline(pts)\n                    if not pline.IsValid:\n                        continue\n\n                    cell2 = PolylineCurve(pline)\n\n                    if not _poly_fully_inside(cell2, B2, Rhino.Geometry.Plane.WorldXY, tol):\n                        continue\n\n                    cell_w = cell2.DuplicateCurve()\n                    cell_w.Transform(xform_p2w)\n\n                    GridCells.append(cell_w)\n                    cells_by_row.setdefault(j, []).append((i, cell_w))\n                    cells_by_col.setdefault(i, []).append((j, cell_w))\n\n            # Rows -> R (branches ordered by j, items ordered by i)\n            row_keys = sorted(cells_by_row.keys())\n            for r_idx, j in enumerate(row_keys):\n                path = GH_Path(r_idx)\n                for (_, crv) in sorted(cells_by_row[j], key=lambda t: t[0]):\n                    R.Add(crv, path)\n\n            # Cols -> C (branches ordered by i, items ordered by j)\n            col_keys = sorted(cells_by_col.keys())\n            for c_idx, i in enumerate(col_keys):\n                path = GH_Path(c_idx)\n                for (_, crv) in sorted(cells_by_col[i], key=lambda t: t[0]):\n                    C.Add(crv, path)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}