{
  "source_url": "https://github.com/j0hnm4r5/portfolio-projects/blob/fe4f5b2fd5be055b59ae6bcf0387b0dd4b07691b/Computing%20Drawing/Boids-Code/*boids.py",
  "repo": "j0hnm4r5/portfolio-projects",
  "repo_stars": 1,
  "repo_description": "Code for projects on john-mars.com",
  "license": "NOASSERTION",
  "filepath": "Computing Drawing/Boids-Code/*boids.py",
  "instruction": "*boids",
  "code": "import rhinoscriptsyntax as rs\nimport random, math\n\n\"\"\"\nFor each agent, for each increment of time:\na) Avoid crowding local flockmates. Steer to keep a minimum distance between each agent and the ones around it. In flocking models, a boid (bird/droid) reacts only to flockmates within a certain neighborhood around itself; there is no global steering intelligence. The neighborhood is defined by a distance from the center of the boid and the angle around it, measured by its direction of travel.\nb) Align towards the average heading of local flockmates.\nc) Cohere to the flock: move toward the center of mass of local flockmates. The center of mass is the average position of all the agents.\n\"\"\"\n\nclass Boid(object):\n\n\tSZ_radius = 1\n\tNZ_radius = 10\n\tNZ_angle = 270\n\n\tseparation_factor = .5\n\talignment_factor = .5\n\tcohesion_factor = .1\n\n\tdef __init__(self, guid, heading):\n\t\t\"\"\" CREATE A BOID \"\"\"\n\n\t\tself.guid = guid\n\n\t\tself.position = rs.PointCoordinates(self.guid)\n\t\tself.heading = heading\n\n\t\tself.SZ_neighbors = []\n\t\tself.NZ_neighbors = []\n\n\t\tself.NZ_avg_heading = []\n\t\tself.NZ_center_of_mass = []\n\n\t\tself.separation_vector = (0,0,0)\n\t\tself.alignment_vector = (0,0,0)\n\t\tself.cohesion_vector = (0,0,0)\n\n\t\tself.path_pts = []\n\t\tself.path_guid = \"\"\n\t\tself.path_pts.append(self.position)\n\n\tdef get_SZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN SZ, MAKE IT AN SZ NEIGHBOR \"\"\"\n\n\t\tself.SZ_neighbors = []\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif (distance != 0) and (distance < Boid.SZ_radius):\n\t\t\t\tself.SZ_neighbors.append(agent)\n\n\tdef get_NZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN NZ, MAKE IT AN NZ NEIGHBOR \"\"\"\n\n\t\tself.NZ_neighbors = []\n\t\tcenter_cone = rs.VectorReverse(self.heading)\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif distance != 0:\n\t\t\t\tagent_angle = rs.VectorAngle(rs.VectorCreate(self.guid, agent.guid), center_cone)\n\t\t\t\tif (distance < Boid.NZ_radius) and (agent_angle < Boid.NZ_angle / 2):\n\t\t\t\t\tself.NZ_neighbors.append(agent)\n\n\n\tdef separate(self):\n\t\t\"\"\" MOVE AWAY FROM NEIGHBORS IN SZ \"\"\"\n\t\tself.separation_vector = (0,0,0)\n\t\tif len(self.SZ_neighbors) > 0:\n\n\n\t\t\tfor neighbor in self.SZ_neighbors:\n\t\t\t\tself.separation_vector = rs.VectorAdd(rs.VectorCreate(self.position, neighbor.position), self.separation_vector)\n\n\t\t\tself.separation_vector = rs.VectorDivide(self.separation_vector, len(self.SZ_neighbors))\n\t\t\tself.separation_vector = rs.VectorScale(self.separation_vector, Boid.separation_factor)\n\n\tdef align(self):\n\t\t\"\"\" ALIIGN TOWARDS AVERAGE HEADING OF NEIGHBORS \"\"\"\n\t\tself.NZ_avg_heading = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_avg_heading = rs.VectorAdd(self.NZ_avg_heading, neighbor.heading)\n\n\t\t\tself.NZ_avg_heading = rs.VectorDivide(self.NZ_avg_heading, len(self.NZ_neighbors))\n\n\t\t\tself.alignment_vector = rs.VectorScale(self.NZ_avg_heading, Boid.alignment_factor)\n\n\tdef cohere(self):\n\t\t\"\"\" MOVE TOWARD THE CENTER OF MASS OF NEIGHBORS \"\"\"\n\t\tself.NZ_center_of_mass = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_center_of_mass = rs.VectorAdd(self.NZ_center_of_mass, neighbor.position)\n\n\t\t\tself.NZ_center_of_mass = rs.VectorDivide(self.NZ_center_of_mass, len(self.NZ_neighbors))\n\n\t\t\tself.cohesion_vector = rs.VectorCreate(self.NZ_center_of_mass, self.position)\n\t\t\tself.cohesion_vector = rs.VectorScale(self.cohesion_vector, Boid.cohesion_factor)\n\n\tdef avoid(self):\n\t\t\"\"\" AVOID OBSTACLES \"\"\"\n\t\tpass\n\n\tdef strive(self):\n\t\t\"\"\" HEAD TOWARDS GOAL \"\"\"\n\t\tpass\n\n\n\tdef update_heading(self):\n\t\t\"\"\" AVERAGE SEPARATION, ALIGNMENT, AND COHESION VECTORS \"\"\"\n\n\t\tself.separate()\n\t\tself.align()\n\t\tself.cohere()\n\n\t\tself.heading = rs.VectorAdd(self.heading, self.separation_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.alignment_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.cohesion_vector)\n\t\tself.heading = rs.VectorDivide(self.heading, 3)\n\n\tdef move(self):\n\t\t\"\"\" MOVE A BOID \"\"\"\n\n\t\tself.position = rs.PointAdd(self.position, self.heading)\n\t\tself.path_pts.append(self.position)\n\t\trs.DeleteObject(self.guid)\n\t\tself.guid = rs.AddPoint(self.position)\n\n\n\tdef update(self, population):\n\t\t\"\"\" CHANGE HEADING AND MOVE BOID \"\"\"\n\n\t\tself.get_SZ_neighbors(population)\n\t\tself.get_NZ_neighbors(population)\n\t\tself.update_heading()\n\t\tself.move()\n\n\tdef draw_path(self):\n\t\t\"\"\" DRAW BOID'S PATH \"\"\"\n\n\t\tif self.path_guid:\n\t\t\trs.DeleteObject(self.path_guid)\n\t\tself.path_guid = rs.AddCurve(self.path_pts)\n\ndef Main():\n\tpopulation_pts = rs.GetObjects(\"Pick starting points:\", 1)\n\tsteps = rs.GetInteger(\"How many steps?\", 50)\n\n\tinitial_heading = rs.VectorCreate((1,1,0), (0,0,0))\n\n\tpopulation = []\n\ti = 0\n\twhile i < len(population_pts):\n\t\tpopulation.append(Boid(population_pts[i], initial_heading))\n\t\ti += 1\n\n\n\tfor t in range(steps):\n\t\tfor boid in population:\n\t\t\tboid.update(population)\n\n\n\tfor boid in population:\n\t\tboid.draw_path()\n\nMain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}