{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/solar_radiation.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/solar_radiation.py",
  "instruction": "import os\nimport json\nimport numpy as np\nimport rhino3dm\nimport matplotlib.pyplot as plt\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom pygltflib import GLTF2, Buffer, Accessor,...",
  "code": "\"\"\"\nimport os\nimport json\nimport numpy as np\nimport rhino3dm\nimport matplotlib.pyplot as plt\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom pygltflib import GLTF2, Buffer, Accessor, BufferView, Mesh, Asset, Primitive, Material, Scene, Node\n\n# üìÇ Define file paths\nPIPELINE_OUTPUT_DIR = r\"D:\\spz_pipeline\\pipeline_outputs\"\nEPW_FILE_PATH = os.path.join(PIPELINE_OUTPUT_DIR, \"newyork.epw\")\nRESULTS_FILE = os.path.join(PIPELINE_OUTPUT_DIR, \"solar_results_example_image.json\")\nGLB_FILE_PATH = os.path.join(PIPELINE_OUTPUT_DIR, \"example_image.glb\")  # Ensure this is correct\nSOLAR_OUTPUT_GLB = os.path.join(PIPELINE_OUTPUT_DIR, \"solar_radiation_example_image.glb\")\n\n# ‚úÖ Load EPW weather data\ndef load_epw(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå EPW file not found: {file_path}\")\n    return EPW(file_path)\n\n# ‚òÄÔ∏è Generate sun vectors\ndef get_sun_vectors(epw):\n    sunpath = Sunpath.from_location(epw.location)\n    return [sunpath.calculate_sun(6, 21, h).sun_vector for h in range(8, 15, 1)]\n\n# üìÇ Extract surfaces from GLB file\ndef extract_surfaces_from_glb(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå GLB file not found: {file_path}\")\n\n    # Load the GLB file\n    gltf = GLTF2().load_binary(file_path)\n\n    # Ensure GLB file has meshes\n    if not gltf.meshes or len(gltf.meshes) == 0:\n        raise ValueError(\"‚ùå No meshes found in the GLB file.\")\n\n    binary_blob = gltf.binary_blob()\n    surfaces = []\n    for mesh_index, mesh in enumerate(gltf.meshes):\n        print(f\"üìå Processing mesh {mesh_index + 1}/{len(gltf.meshes)}\")\n        for prim_index, primitive in enumerate(mesh.primitives):\n            print(f\"   üîπ Processing primitive {prim_index + 1}/{len(mesh.primitives)}\")\n            if not hasattr(primitive.attributes, \"POSITION\"):\n                print(f\"‚ö†Ô∏è Warning: No POSITION attribute in primitive {prim_index}, skipping.\")\n                continue\n            pos_accessor_index = primitive.attributes.POSITION\n            pos_accessor = gltf.accessors[pos_accessor_index]\n            buffer_view = gltf.bufferViews[pos_accessor.bufferView]\n            vertex_start = buffer_view.byteOffset\n            vertex_end = vertex_start + buffer_view.byteLength\n            vertices = np.frombuffer(binary_blob[vertex_start:vertex_end], dtype=np.float32).reshape(-1, 3)\n            print(f\"   ‚úÖ Extracted {len(vertices)} vertices for primitive {prim_index}.\")\n            if primitive.indices is None:\n                print(f\"‚ö†Ô∏è Warning: No face index data found in primitive {prim_index}. Creating default faces.\")\n                faces = np.array([], dtype=np.uint32).reshape(0, 3)\n            else:\n                index_accessor = gltf.accessors[primitive.indices]\n                index_buffer_view = gltf.bufferViews[index_accessor.bufferView]\n                index_start = index_buffer_view.byteOffset\n                index_end = index_start + index_buffer_view.byteLength\n                faces = np.frombuffer(binary_blob[index_start:index_end], dtype=np.uint32).reshape(-1, 3)\n                print(f\"   ‚úÖ Extracted {len(faces)} faces for primitive {prim_index}.\")\n            rhino_mesh = rhino3dm.Mesh()\n            for v in vertices:\n                rhino_mesh.Vertices.Add(v[0], v[1], v[2])\n            for f in faces:\n                if len(f) == 3:\n                    rhino_mesh.Faces.AddFace(int(f[0]), int(f[1]), int(f[2]))\n            surfaces.append(rhino_mesh)\n    if not surfaces:\n        raise ValueError(\"‚ùå No valid geometry extracted from the GLB file.\")\n    print(f\"‚úÖ Final: Extracted {len(surfaces)} mesh surfaces.\")\n    return surfaces\n\n# üîÜ Compute Solar Radiation\ndef compute_solar_radiation(epw, surfaces):\n    sun_vectors = get_sun_vectors(epw)\n    all_radiation_values = []\n    for i, surface in enumerate(surfaces):\n        normals = [surface.Normals[j] for j in range(len(surface.Vertices))] if len(surface.Normals) > 0 else [rhino3dm.Vector3d(0, 0, 1)]\n        print(f\"   üîπ Processing surface {i + 1}/{len(surfaces)} with {len(normals)} normals.\")\n        solar_exposure = [\n            max(0, np.dot([normals[0].X, normals[0].Y, normals[0].Z], [sun_vec.x, sun_vec.y, sun_vec.z]))\n            for sun_vec in sun_vectors\n        ]\n        direct_radiation = [epw.direct_normal_radiation[hour % 24] for hour in range(6, 18)]\n        max_radiation = max(direct_radiation) if max(direct_radiation) > 0 else 1\n        normalized_exposure = [(solar / max_radiation) * rad for solar, rad in zip(solar_exposure, direct_radiation)]\n        all_radiation_values.append(normalized_exposure)\n    min_value = min(map(min, all_radiation_values))\n    max_value = max(map(max, all_radiation_values))\n    normalized_radiation_values = [[(value - min_value) / (max_value - min_value) if max_value != min_value else 1.0 for value in radiation] for radiation in all_radiation_values]\n    with open(RESULTS_FILE, \"w\") as f:\n        json.dump(normalized_radiation_values, f, indent=4)\n    save_mesh_to_glb(surfaces, normalized_radiation_values, SOLAR_OUTPUT_GLB)\n    print(f\"‚úÖ solar_radiation.glb saved to {SOLAR_OUTPUT_GLB}\")\n\n# üé≠ Save a Mesh with Solar Radiation Data to GLB\ndef save_mesh_to_glb(meshes, radiation_values, filename):\n    gltf = GLTF2(asset=Asset(version=\"2.0\"))\n    all_vertices, all_faces = [], []\n    vertex_offset = 0\n    for mesh in meshes:\n        vertices = np.array([[v.X, v.Y, v.Z] for v in mesh.Vertices], dtype=np.float32)\n        faces = np.array([[f[0], f[1], f[2]] for f in mesh.Faces], dtype=np.uint32)\n        all_vertices.append(vertices)\n        all_faces.append(faces + vertex_offset)\n        vertex_offset += len(vertices)\n    final_vertices = np.vstack(all_vertices)\n    final_faces = np.vstack(all_faces)\n    vertex_buffer = Buffer(uri=None, byteLength=final_vertices.nbytes)\n    face_buffer = Buffer(uri=None, byteLength=final_faces.nbytes)\n    gltf.buffers.extend([vertex_buffer, face_buffer])\n    buffer_view_vertices = BufferView(buffer=0, byteOffset=0, byteLength=final_vertices.nbytes, target=34962)\n    buffer_view_faces = BufferView(buffer=1, byteOffset=0, byteLength=final_faces.nbytes, target=34963)\n    gltf.bufferViews.extend([buffer_view_vertices, buffer_view_faces])\n    accessor_vertices = Accessor(bufferView=0, byteOffset=0, componentType=5126, count=len(final_vertices), type=\"VEC3\")\n    accessor_faces = Accessor(bufferView=1, byteOffset=0, componentType=5125, count=len(final_faces) * 3, type=\"SCALAR\")\n    gltf.accessors.extend([accessor_vertices, accessor_faces])\n    primitive = Primitive(attributes={\"POSITION\": 0}, indices=1)\n    mesh = Mesh(primitives=[primitive])\n    gltf.meshes.append(mesh)\n    node = Node(mesh=0)\n    gltf.nodes.append(node)\n    scene = Scene(nodes=[0])\n    gltf.scenes.append(scene)\n    gltf.scene = 0\n    gltf.set_binary_blob(final_vertices.tobytes() + final_faces.tobytes())\n    gltf.save_binary(filename)\n    print(f\"‚úÖ Successfully saved {filename} as a proper GLB file.\")\n\n# üöÄ Run Analysis\nif __name__ == \"__main__\":\n    try:\n        epw_data = load_epw(EPW_FILE_PATH)\n        surfaces = extract_surfaces_from_glb(GLB_FILE_PATH)\n        compute_solar_radiation(epw_data, surfaces)\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n\"\"\"\n\nimport os\nimport json\nimport numpy as np\nimport rhino3dm\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom pygltflib import GLTF2, Scene, Node, Mesh, Buffer, BufferView, Accessor, Asset, Primitive, Material\n\n# üìÇ Define file paths (Updated)\nPIPELINE_FOLDER = r\"D:\\spz_pipeline\\pipeline_outputs\"\n\nEPW_FILE_PATH = os.path.join(PIPELINE_FOLDER, \"newyork.epw\")  # Assuming EPW file is here\nTHREEDM_FILE_PATH = os.path.join(PIPELINE_FOLDER, \"merged_model.3dm\")  # ‚úÖ Updated input file\nRESULTS_FILE = os.path.join(PIPELINE_FOLDER, \"solar_results_example_image.json\")  # ‚úÖ Updated JSON output\nGLB_FILE_PATH = os.path.join(PIPELINE_FOLDER, \"solar_radiation_example_image.glb\")  # ‚úÖ Corrected output file\n\n# ‚úÖ Load EPW weather data\ndef load_epw(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå EPW file not found: {file_path}\")\n    return EPW(file_path)\n\n# ‚òÄÔ∏è Generate sun vectors\ndef get_sun_vectors(epw):\n    sunpath = Sunpath.from_location(epw.location)\n    return [sunpath.calculate_sun(6, 21, h).sun_vector for h in range(8, 15, 1)]\n\n# üè¢ Extract surfaces from 3DM file\ndef extract_surfaces_from_3dm(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"‚ùå 3DM file not found: {file_path}\")\n\n    model = rhino3dm.File3dm.Read(file_path)\n    return [obj.Geometry for obj in model.Objects if isinstance(obj.Geometry, rhino3dm.Mesh)]\n\n# üîÜ Compute Solar Radiation\ndef compute_solar_radiation(epw, surfaces):\n    sun_vectors = get_sun_vectors(epw)\n    all_radiation_values = []\n    \n    for i, surface in enumerate(surfaces):\n        normals = [surface.Normals[j] for j in range(len(surface.Vertices))] if len(surface.Normals) > 0 else [rhino3dm.Vector3d(0, 0, 1)]\n\n        solar_exposure = [\n            max(0, np.dot([normals[0].X, normals[0].Y, normals[0].Z], [sun_vec.x, sun_vec.y, sun_vec.z]))\n            for sun_vec in sun_vectors\n        ]\n        direct_radiation = [epw.direct_normal_radiation[hour % 24] for hour in range(6, 18)]\n        max_radiation = max(direct_radiation) if max(direct_radiation) > 0 else 1\n\n        normalized_exposure = [(solar / max_radiation) * rad for solar, rad in zip(solar_exposure, direct_radiation)]\n        all_radiation_values.append(normalized_exposure)\n\n    min_value = min(map(min, all_radiation_values))\n    max_value = max(map(max, all_radiation_values))\n\n    normalized_radiation_values = [[(value - min_value) / (max_value - min_value) if max_value != min_value else 1.0 for value in radiation] for radiation in all_radiation_values]\n\n    with open(RESULTS_FILE, \"w\") as f:\n        json.dump(normalized_radiation_values, f, indent=4)\n\n    save_multiple_meshes_to_glb(surfaces, normalized_radiation_values, GLB_FILE_PATH)\n\n# üé≠ Save a Mesh with Color Data to GLB\ndef save_multiple_meshes_to_glb(surfaces, radiation_values, filename):\n    all_vertices, all_faces, all_colors = [], [], []\n    vertex_offset = 0\n    colormap = plt.colormaps.get_cmap('viridis')\n\n    for i, surface in enumerate(surfaces):\n        vertices = np.array([[pt.X, pt.Y, pt.Z] for pt in surface.Vertices], dtype=np.float32)\n        faces = np.array([[f[0], f[1], f[2]] for f in surface.Faces], dtype=np.uint32) + vertex_offset\n        vertex_offset += len(vertices)\n\n        # Calculate face-based colors (instead of per-vertex)\n        face_colors = np.zeros((len(faces), 4), dtype=np.float32)\n        for j, face in enumerate(faces):\n            face_avg_radiation = np.mean([radiation_values[i][v % len(radiation_values[i])] for v in face])  # Compute avg radiation for face\n            mapped_color = colormap(face_avg_radiation)  # Map to colormap\n            face_colors[j] = mapped_color  # Assign color\n\n        all_vertices.append(vertices)\n        all_faces.append(faces)\n        all_colors.append(face_colors)\n\n    save_mesh_to_glb(np.vstack(all_vertices), np.vstack(all_faces), np.vstack(all_colors), filename)\n\n# üé≠ Save a Mesh to GLB\ndef save_mesh_to_glb(vertices, faces, colors, filename):\n    gltf = GLTF2(asset=Asset(version=\"2.0\"))\n    buffer_data = vertices.tobytes() + faces.tobytes() + colors.tobytes()\n    \n    gltf.buffers.append(Buffer(uri=None, byteLength=len(buffer_data)))\n\n    buffer_views = [\n        BufferView(buffer=0, byteOffset=0, byteLength=vertices.nbytes, target=34962),\n        BufferView(buffer=0, byteOffset=vertices.nbytes, byteLength=faces.nbytes, target=34963),\n        BufferView(buffer=0, byteOffset=vertices.nbytes + faces.nbytes, byteLength=colors.nbytes, target=34962),\n    ]\n    \n    gltf.bufferViews.extend(buffer_views)\n\n    gltf.accessors.extend([\n        Accessor(bufferView=0, componentType=5126, count=len(vertices), type=\"VEC3\"),\n        Accessor(bufferView=1, componentType=5125, count=len(faces) * 3, type=\"SCALAR\"),\n        Accessor(bufferView=2, componentType=5126, count=len(colors), type=\"VEC4\"),\n    ])\n\n    gltf.materials.append(Material(\n        pbrMetallicRoughness={\"baseColorFactor\": [1.0, 1.0, 1.0, 1.0]},\n        doubleSided=True\n    ))\n\n    gltf.meshes.append(Mesh(primitives=[Primitive(attributes={\"POSITION\": 0, \"COLOR_0\": 2}, indices=1, material=0)]))\n    gltf.nodes.append(Node(mesh=0))\n    gltf.scenes.append(Scene(nodes=[0]))\n    gltf.scene = 0\n\n    gltf.set_binary_blob(buffer_data)\n    gltf.save_binary(filename)\n\n    print(f\"‚úÖ Successfully saved `{filename}`\")\n\n# üöÄ Run Analysis\nif __name__ == \"__main__\":\n    try:\n        epw_data = load_epw(EPW_FILE_PATH)\n        surfaces = extract_surfaces_from_3dm(THREEDM_FILE_PATH)\n        compute_solar_radiation(epw_data, surfaces)\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}