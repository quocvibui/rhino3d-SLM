{
  "source_url": "https://github.com/Mufasa58/TNA/blob/49dfff99579f489c3179470ce8507bbb849e1226/fan_vault_bake.py",
  "repo": "Mufasa58/TNA",
  "repo_stars": 0,
  "repo_description": "Compas_TNA and Rhino Models and Scripts",
  "license": "unknown",
  "filepath": "fan_vault_bake.py",
  "instruction": "fan_vault_bake.py RunnerV2-compatible: exposes run() with no args.",
  "code": "# fan_vault_bake.py\n# RunnerV2-compatible: exposes run() with no args.\n\nimport os\nimport math\nimport System\nimport Rhino\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport System.Drawing as Drawing\n\n# ==========================\n# USER SETTINGS (EDIT THESE)\n# ==========================\n\nOUT_DIR = r\"/Users/mmg/dev/tna_playground/JSON Files\"\n\nTHRUST_JSON   = os.path.join(OUT_DIR, \"Pattern_simple_v2_THRUST_SOLVED.json\")\nINTRADOS_JSON = os.path.join(OUT_DIR, \"Pattern_simple_v2_INTRADOS.json\")\nEXTRADOS_JSON = os.path.join(OUT_DIR, \"Pattern_simple_v2_EXTRADOS.json\")\nFORCE_JSON = os.path.join(OUT_DIR, \"Pattern_simple_v2_FORCE.json\")\n\n\nBAKE_AS_BREP = True          # try Brep first\nBAKE_BOTH = True   # bake BOTH brep-attempt and raw mesh for comparison\n\nBAKE_EDGES   = True          # bake thrust edges as curves\nBAKE_FORCE   = True          # bake force diagram edges as curves\nCLEAR_LAYER  = False         # if True, deletes existing objs on the target layers before baking\n\nBAKE_REACTIONS = True\n\n# Scale for arrow length in Rhino units (pure visualization).\nREACTION_SCALE = 0.35\n\n# Arrow head size in Rhino units (visual)\nARROW_SIZE = 0.12\n\n\n# ==========================\n# HELPERS\n# ==========================\n\ndef ensure_layer(fullname):\n    \"\"\"\n    Ensure a (possibly nested) Rhino layer exists, return its full name.\n    Example fullname: \"TNA::THRUST\"\n    \"\"\"\n    parts = fullname.split(\"::\")\n    parent_id = System.Guid.Empty\n    current_name = \"\"\n    for i, p in enumerate(parts):\n        current_name = p if i == 0 else current_name + \"::\" + p\n        layer_index = sc.doc.Layers.FindByFullPath(current_name, True)\n        if layer_index >= 0:\n            parent_id = sc.doc.Layers[layer_index].Id\n            continue\n\n        layer = Rhino.DocObjects.Layer()\n        layer.Name = p\n        if i > 0:\n            layer.ParentLayerId = parent_id\n        layer_index = sc.doc.Layers.Add(layer)\n        parent_id = sc.doc.Layers[layer_index].Id\n\n    return current_name\n\n\ndef clear_objects_on_layer(layer_fullname):\n    idx = sc.doc.Layers.FindByFullPath(layer_fullname, True)\n    if idx < 0:\n        return 0\n    layer = sc.doc.Layers[idx]\n    to_delete = []\n    for obj in sc.doc.Objects:\n        if obj.Attributes.LayerIndex == layer.LayerIndex:\n            to_delete.append(obj.Id)\n    for gid in to_delete:\n        sc.doc.Objects.Delete(gid, True)\n    return len(to_delete)\n\n\ndef compas_mesh_to_rhino_mesh(mesh):\n    \"\"\"\n    Convert a COMPAS Mesh-like object to Rhino.Geometry.Mesh.\n    Works for compas.datastructures.Mesh and diagrams (they inherit Mesh).\n    \"\"\"\n    rm = Rhino.Geometry.Mesh()\n    vmap = {}\n\n    # add vertices\n    for k in mesh.vertices():\n        x, y, z = mesh.vertex_coordinates(k)\n        vmap[k] = rm.Vertices.Add(x, y, z)\n\n    # add faces\n    for f in mesh.faces():\n        vs = mesh.face_vertices(f)\n        if not vs:\n            continue\n        if len(vs) == 3:\n            rm.Faces.AddFace(vmap[vs[0]], vmap[vs[1]], vmap[vs[2]])\n        elif len(vs) == 4:\n            rm.Faces.AddFace(vmap[vs[0]], vmap[vs[1]], vmap[vs[2]], vmap[vs[3]])\n        else:\n            # ngon: triangulate fan from first vertex\n            a = vs[0]\n            for i in range(1, len(vs) - 1):\n                rm.Faces.AddFace(vmap[a], vmap[vs[i]], vmap[vs[i + 1]])\n\n    rm.Normals.ComputeNormals()\n    rm.Compact()\n    return rm\n\n\ndef bake_mesh_and_or_brep(rmesh, layer_fullname, name):\n    \"\"\"\n    If BAKE_BOTH:\n      - always bake the raw mesh (stable reference)\n      - also try Brep-from-mesh and bake it if it succeeds\n    Else:\n      - behave like before (try brep then fallback to mesh)\n    \"\"\"\n    layer_fullname = ensure_layer(layer_fullname)\n    layer_index = sc.doc.Layers.FindByFullPath(layer_fullname, True)\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = layer_index\n    attr.Name = name\n\n    baked = {\"layer\": layer_fullname, \"name\": name, \"mesh_id\": None, \"brep_id\": None, \"brep_ok\": False}\n\n    # Always compute some stability improvements for the mesh\n    rmesh.Normals.ComputeNormals()\n    rmesh.Compact()\n\n    # Always bake mesh if BAKE_BOTH, or if brep attempt fails\n    def bake_mesh():\n        gid = sc.doc.Objects.AddMesh(rmesh, attr)\n        if gid != System.Guid.Empty:\n            baked[\"mesh_id\"] = str(gid)\n\n    if BAKE_BOTH:\n        # bake mesh reference first\n        bake_mesh()\n\n        # try brep as a comparison object\n        if BAKE_AS_BREP:\n            brep = Rhino.Geometry.Brep.CreateFromMesh(rmesh, True)\n            if brep:\n                gid = sc.doc.Objects.AddBrep(brep, attr)\n                if gid != System.Guid.Empty:\n                    baked[\"brep_ok\"] = True\n                    baked[\"brep_id\"] = str(gid)\n\n        return baked\n\n    # old behavior: try brep first, else mesh\n    if BAKE_AS_BREP:\n        brep = Rhino.Geometry.Brep.CreateFromMesh(rmesh, True)\n        if brep:\n            gid = sc.doc.Objects.AddBrep(brep, attr)\n            if gid != System.Guid.Empty:\n                baked[\"brep_ok\"] = True\n                baked[\"brep_id\"] = str(gid)\n                return baked\n\n    # fallback to mesh\n    bake_mesh()\n    return baked\n\n\n\ndef bake_thrust_edges(mesh_like, layer_fullname, name_prefix=\"edge\"):\n    \"\"\"\n    Bake edges as line curves (polyline segments).\n    \"\"\"\n    layer_fullname = ensure_layer(layer_fullname)\n    layer_index = sc.doc.Layers.FindByFullPath(layer_fullname, True)\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = layer_index\n    attr.Name = name_prefix\n\n    ids = []\n    for u, v in mesh_like.edges():\n        a = Rhino.Geometry.Point3d(*mesh_like.vertex_coordinates(u))\n        b = Rhino.Geometry.Point3d(*mesh_like.vertex_coordinates(v))\n        crv = Rhino.Geometry.LineCurve(a, b)\n        gid = sc.doc.Objects.AddCurve(crv, attr)\n        if gid != System.Guid.Empty:\n            ids.append(str(gid))\n    return ids\n\ndef clamp01(x):\n    return 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)\n\ndef lerp(a, b, t):\n    return a + (b - a) * t\n\ndef color_ramp_blue_to_red(t):\n    # t: 0..1  -> blue-ish to red-ish\n    t = clamp01(t)\n    r = int(lerp(30, 230, t))\n    g = int(lerp(80,  40, t))\n    b = int(lerp(230, 30, t))\n    return Drawing.Color.FromArgb(r, g, b)\n\ndef bake_edges_styled(mesh_like, layer_name, name_prefix, style_fn):\n    \"\"\"\n    style_fn(u, v, i): returns (System.Drawing.Color, plot_weight_float)\n    \"\"\"\n    doc = Rhino.RhinoDoc.ActiveDoc\n    if doc is None:\n        raise Exception(\"No active Rhino document.\")\n\n    ids = []\n    idx = 0\n\n    for u, v in mesh_like.edges():\n        a = mesh_like.vertex_coordinates(u)\n        b = mesh_like.vertex_coordinates(v)\n\n        # for line geometry\n        line = rg.Line(rg.Point3d(a[0], a[1], a[2]), rg.Point3d(b[0], b[1], b[2]))\n        crv = line.ToNurbsCurve()\n\n        color, w = style_fn(u, v, idx)\n\n        att = Rhino.DocObjects.ObjectAttributes()\n        layer_fullname = ensure_layer(layer_name)\n        layer_index = sc.doc.Layers.FindByFullPath(layer_fullname, True)\n        att.LayerIndex = layer_index\n        att.Name = \"{}_{}\".format(name_prefix, idx)\n\n        # Object color\n        att.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        att.ObjectColor = color\n\n        # Plot weight (useful for print/PDF; viewport thickness depends on display mode)\n        if w is not None:\n            att.PlotWeightSource = Rhino.DocObjects.ObjectPlotWeightSource.PlotWeightFromObject\n            att.PlotWeight = float(w)\n\n        gid = doc.Objects.AddCurve(crv, att)\n        if gid != System.Guid.Empty:\n            ids.append(gid)\n\n        idx += 1\n\n    doc.Views.Redraw()\n    return ids\n\n\ndef bake_reaction_arrows(thrust, layer_fullname, scale=1.0, arrow_size=0.1, name_prefix=\"R\"):\n    \"\"\"\n    Bake reaction vectors at fixed (support) vertices.\n    Uses vertex attributes: is_fixed, Rx, Ry, Rz.\n    Draws a line + 2 small 'wings' as an arrow head.\n    \"\"\"\n    layer_fullname = ensure_layer(layer_fullname)\n    layer_index = sc.doc.Layers.FindByFullPath(layer_fullname, True)\n\n    ids = []\n    for v in thrust.vertices():\n        if not thrust.vertex_attribute(v, \"is_fixed\"):\n            continue\n\n        Rx = thrust.vertex_attribute(v, \"Rx\")\n        Ry = thrust.vertex_attribute(v, \"Ry\")\n        Rz = thrust.vertex_attribute(v, \"Rz\")\n\n        # Skip if reactions not present\n        if Rx is None or Ry is None or Rz is None:\n            continue\n\n        x, y, z = thrust.vertex_coordinates(v)\n        p0 = Rhino.Geometry.Point3d(x, y, z)\n\n        # reaction direction (scaled for visualization)\n        dx, dy, dz = float(Rx) * scale, float(Ry) * scale, float(Rz) * scale\n        p1 = Rhino.Geometry.Point3d(x + dx, y + dy, z + dz)\n\n        # main shaft\n        shaft = Rhino.Geometry.LineCurve(p0, p1)\n\n        attr = Rhino.DocObjects.ObjectAttributes()\n        attr.LayerIndex = layer_index\n        attr.Name = \"{}_{}\".format(name_prefix, v)\n        # (optional) color supports distinctly\n        attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n        attr.ObjectColor = Drawing.Color.FromArgb(0, 0, 0)  # black\n\n        gid = sc.doc.Objects.AddCurve(shaft, attr)\n        if gid != System.Guid.Empty:\n            ids.append(str(gid))\n\n        # --- arrow head (two wings) ---\n        # Build two small lines near p1, roughly perpendicular to the vector\n        vec = Rhino.Geometry.Vector3d(dx, dy, dz)\n        if vec.Length > 1e-9:\n            vec.Unitize()\n\n            # pick an arbitrary \"up\" to build a perpendicular basis\n            up = Rhino.Geometry.Vector3d(0, 0, 1)\n            if abs(Rhino.Geometry.Vector3d.Multiply(vec, up)) > 0.95:\n                up = Rhino.Geometry.Vector3d(0, 1, 0)\n\n            side = Rhino.Geometry.Vector3d.CrossProduct(vec, up)\n            side.Unitize()\n\n            back = Rhino.Geometry.Vector3d(-vec.X, -vec.Y, -vec.Z)\n\n            w = float(arrow_size)\n            p_w1 = p1 + back * (2.0 * w) + side * (1.0 * w)\n            p_w2 = p1 + back * (2.0 * w) - side * (1.0 * w)\n\n            wing1 = Rhino.Geometry.LineCurve(p1, p_w1)\n            wing2 = Rhino.Geometry.LineCurve(p1, p_w2)\n\n            gid1 = sc.doc.Objects.AddCurve(wing1, attr)\n            gid2 = sc.doc.Objects.AddCurve(wing2, attr)\n            if gid1 != System.Guid.Empty: ids.append(str(gid1))\n            if gid2 != System.Guid.Empty: ids.append(str(gid2))\n\n    return ids\n\n\n# ==========================\n# ENTRYPOINT FOR RunnerV2\n# ==========================\ndef run():\n    from compas.data import json_load\n\n    dbg = {}\n    try:\n        for p in (THRUST_JSON, INTRADOS_JSON, EXTRADOS_JSON, FORCE_JSON):\n            if not os.path.isfile(p):\n                raise FileNotFoundError(\"Missing JSON: {}\".format(p))\n\n        thrust   = json_load(THRUST_JSON)\n        intrados = json_load(INTRADOS_JSON)\n        extrados = json_load(EXTRADOS_JSON)\n        force = json_load(FORCE_JSON)\n\n        dbg[\"loaded\"] = {\n            \"thrust\": THRUST_JSON,\n            \"intrados\": INTRADOS_JSON,\n            \"extrados\": EXTRADOS_JSON,\n            \"force\": FORCE_JSON,\n        }\n\n        # layers\n        L_THRUST   = \"TNA::THRUST\"\n        L_INTRADOS = \"TNA::INTRADOS\"\n        L_EXTRADOS = \"TNA::EXTRADOS\"\n        L_EDGES    = \"TNA::THRUST_EDGES\"\n        L_FORCE    = \"TNA::FORCE_EDGES\"\n        L_REACT = \"TNA::REACTIONS\"\n\n        baked = {}\n        if BAKE_REACTIONS:\n            baked[\"reactions\"] = {\n                \"layer\": ensure_layer(L_REACT),\n                \"ids\": bake_reaction_arrows(thrust, L_REACT, scale=REACTION_SCALE, arrow_size=ARROW_SIZE, name_prefix=\"R\"),\n                \"scale\": REACTION_SCALE,\n                \"arrow_size\": ARROW_SIZE,\n            }\n\n        if CLEAR_LAYER:\n            dbg[\"cleared\"] = {\n                \"thrust\": clear_objects_on_layer(L_THRUST),\n                \"intrados\": clear_objects_on_layer(L_INTRADOS),\n                \"extrados\": clear_objects_on_layer(L_EXTRADOS),\n                \"edges\": clear_objects_on_layer(L_EDGES),\n                \"force\": clear_objects_on_layer(L_FORCE),\n                \"reactions\": clear_objects_on_layer(L_REACT),\n            }\n\n        # convert to Rhino meshes\n        r_thrust   = compas_mesh_to_rhino_mesh(thrust)\n        r_intrados = compas_mesh_to_rhino_mesh(intrados)\n        r_extrados = compas_mesh_to_rhino_mesh(extrados)\n        r_force    = compas_mesh_to_rhino_mesh(force)\n        \n        dbg[\"rhino_meshes\"] = {\n            \"thrust\": r_thrust.Vertices.Count,\n            \"intrados\": r_intrados.Vertices.Count,\n            \"extrados\": r_extrados.Vertices.Count,\n            \"force\": r_force.Vertices.Count,\n        }\n\n        # bake\n        baked[\"thrust\"]   = bake_mesh_and_or_brep(r_thrust,   L_THRUST,   \"THRUST_SOLVED\")\n        baked[\"intrados\"] = bake_mesh_and_or_brep(r_intrados, L_INTRADOS, \"INTRADOS\")\n        baked[\"extrados\"] = bake_mesh_and_or_brep(r_extrados, L_EXTRADOS, \"EXTRADOS\")\n\n        # --- THRUST EDGES colored by compression magnitude N ---\n        L_THRUST_N = \"TNA::THRUST_EDGES_N\"\n\n        # 1) collect N magnitudes for normalization\n        Ns = []\n        for u, v in thrust.edges():\n            N = thrust.edge_attribute((u, v), \"N\")\n            if N is None:\n                # fallback: compute N = q * L\n                q = thrust.edge_attribute((u, v), \"q\") or 0.0\n                a = thrust.vertex_coordinates(u)\n                b = thrust.vertex_coordinates(v)\n                dx = (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n                L = (dx[0]**2 + dx[1]**2 + dx[2]**2) ** 0.5\n                N = q * L\n            #Ns.append(abs(float(N)))\n            Ns.append(math.log10(1.0 + abs(float(N))))\n\n\n\n\n        Nmin = min(Ns) if Ns else 0.0\n        Nmax = max(Ns) if Ns else 1.0\n        \n        \n        Ncap = 0.18 * Nmax   # tune: 0.15â€“0.40\n        Nmax = max(Nmax, Ncap)\n        print(\"N range:\", Nmin, Nmax)\n\n        \n        den  = (Nmax - Nmin) if (Nmax - Nmin) > 1e-12 else 1.0\n\n        def style_thrust_N(u, v, i):\n            N = thrust.edge_attribute((u, v), \"N\")\n            if N is None:\n                q = thrust.edge_attribute((u, v), \"q\") or 0.0\n                a = thrust.vertex_coordinates(u)\n                b = thrust.vertex_coordinates(v)\n                dx = (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n                L = (dx[0]**2 + dx[1]**2 + dx[2]**2) ** 0.5\n                N = q * L\n\n\n            \n          \n            \n            #N = abs(float(N))\n            N = math.log10(1.0 + abs(float(N))) # log scale, use this only when N ranges over multiple orders of magnitude\n\n            N = min(N, Ncap)\n            t = (N - Nmin) / (Ncap - Nmin + 1e-12)\n\n            #t = (N - Nmin) / den  # 0..1\n            t = t ** 1.0 # higher - lower forces pop, lower - higher forces \n            #t = 0.5 - 0.5 * math.cos(math.pi * t) # s-curve try1\n\n\n\n\n\n            #blue red map does not really show differences in low N range well\n            #here is a new map:\n            \n            def color_ramp_multi(t):\n                    t = clamp01(t)\n                    #stops = [\n                    #    (0.00, (0,   0,  80)),   # deep blue\n                    #    (0.25, (0, 120, 255)),   # bright blue\n                    #    (0.50, (0, 255, 180)),   # cyan/green\n                    #    (0.75, (255, 230, 0)),   # yellow\n                    #    (1.00, (255, 40,  0)),   # red\n                    #]\n                    stops = [\n                        (0.00, (  0,   0,  60)),\n                        (0.125,(  0,  60, 160)),\n                        (0.25, (  0, 120, 255)),\n                        (0.375,(  0, 200, 255)),\n                        (0.50, (  0, 255, 180)),\n                        (0.625,(120, 255,  80)),\n                        (0.75, (255, 230,   0)),\n                        (0.875,(255, 140,   0)),\n                        (1.00, (255,  40,   0)),\n                    ]\n\n                    # find segment\n                    for i in range(len(stops)-1):\n                        t0, c0 = stops[i]\n                        t1, c1 = stops[i+1]\n                        if t <= t1:\n                            u = (t - t0) / (t1 - t0 + 1e-12)\n                            r = int(lerp(c0[0], c1[0], u))\n                            g = int(lerp(c0[1], c1[1], u))\n                            b = int(lerp(c0[2], c1[2], u))\n                            return Drawing.Color.FromArgb(r, g, b)\n                    return Drawing.Color.FromArgb(255, 40, 0)\n\n\n            # SETTINGS !!!\n            col = color_ramp_multi(t)\n            #col = color_ramp_blue_to_red(t) # color ramp\n            w = lerp(0.05, 2.00, t) # plot weight\n            return col, w\n\n        baked[\"thrust_edges_N\"] = {\n            \"layer\": ensure_layer(L_THRUST_N),\n            \"ids\": bake_edges_styled(thrust, L_THRUST_N, \"thrustN\", style_thrust_N),\n            \"Nmin\": float(Nmin),\n            \"Nmax\": float(Nmax),\n        }\n\n\n        if BAKE_FORCE:\n            baked[\"force\"] = {\n                \"layer\": ensure_layer(L_FORCE),\n                \"ids\": bake_thrust_edges(force, L_FORCE, \"force_edge\"),\n            }\n        sc.doc.Views.Redraw()\n\n        return {\"ok\": True, \"baked\": baked, \"dbg\": dbg}\n\n    except Exception as e:\n        import traceback\n        return {\"ok\": False, \"error\": traceback.format_exc(), \"dbg\": dbg}\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}