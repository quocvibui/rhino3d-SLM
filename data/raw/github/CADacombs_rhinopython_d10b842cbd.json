{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xNurbsSurface_decreaseDegreeFromSide.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xNurbsSurface_decreaseDegreeFromSide.py",
  "instruction": "201119-30: Created.",
  "code": "\"\"\"\r\n201119-30: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bConservePickedSide'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'ConserveContinuitySide'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'OppPicked', 'Picked')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            if key == 'fTol':\r\n                if cls.riOpts[key].CurrentValue < 0.0:\r\n                    cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edge of untrimmed NURBS surface\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.EdgeFilter\r\n\r\n\r\n    def geomFilter_TrimOfFull4TrimNS(rdObj, geom, compIdx):\r\n        #print rdObj, geom, compIdx.ComponentIndexType, compIdx.Index\r\n\r\n        if not isinstance(geom, rg.BrepTrim):\r\n            return False\r\n\r\n        rgT = geom\r\n        rgB = rgT.Brep\r\n        #if rgB.Faces.Count > 1:\r\n        #    return False\r\n\r\n        rgF = rgT.Face\r\n        if not rgF.IsSurface:\r\n            return False\r\n\r\n        if not rgF.Loops.Count == 1:\r\n            return False\r\n\r\n        rgL = rgF.Loops[0]\r\n\r\n        rgS = rgF.UnderlyingSurface()\r\n\r\n        if isinstance(rgS, rg.NurbsSurface):\r\n            ns = rgS\r\n        elif isinstance(rgS, rg.SumSurface):\r\n            ns = rgS.ToNurbsSurface()\r\n        else:\r\n            return False\r\n\r\n        if ns.IsPeriodic(0) or ns.IsPeriodic(1):\r\n            print \"Periodic surfaces are not supported.\"\r\n            return False\r\n\r\n        if ns.IsRational:\r\n            print \"Rational NURBS surfaces are not supported.\"\r\n            return False\r\n\r\n        if not rgL.Trims.Count == 4:\r\n            return False\r\n\r\n        # Reject any NS with singular trims.\r\n        for iT in range(4):\r\n            if rgB.Trims[iT].TrimType == rg.BrepTrimType.Singular:\r\n                print \"NurbsSurface with singular trim is not supported.\"\r\n                return False\r\n\r\n        if rgT.IsoStatus == rg.IsoStatus.East:\r\n            iDegree_Start = ns.Degree(0)\r\n            iSpanCt = ns.SpanCount(0)\r\n        elif rgT.IsoStatus == rg.IsoStatus.West:\r\n            iDegree_Start = ns.Degree(0)\r\n            iSpanCt = ns.SpanCount(0)\r\n        else:\r\n            iDegree_Start = ns.Degree(1)\r\n            iSpanCt = ns.SpanCount(1)\r\n\r\n        if iDegree_Start == 1:\r\n            print \"Ignorded edge because its surface is degree 1 from edge.\"\r\n            return False\r\n\r\n        #if iSpanCt > 1:\r\n        #    print \"Ignored edge because surface has {} spans from edge.\".format(iSpanCt)\r\n        #    return False\r\n\r\n\r\n        return True\r\n\r\n\r\n    go.SetCustomGeometryFilter(geomFilter_TrimOfFull4TrimNS)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        key = 'bConservePickedSide'; idxs_Opt[key] = Opts.addOption(go, key)\r\n        key = 'bReplace'; idxs_Opt[key] = Opts.addOption(go, key)\r\n        key = 'bEcho'; idxs_Opt[key] = Opts.addOption(go, key)\r\n        key = 'bDebug'; idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            rdBrep_In = objref.Object()\r\n            rgSrf = objref.Surface()\r\n            rgTrim = objref.Trim()\r\n            if rgTrim.IsoStatus == rg.IsoStatus.East:\r\n                iDegree_Start = rgSrf.Degree(0)\r\n            elif rgTrim.IsoStatus == rg.IsoStatus.West:\r\n                iDegree_Start = rgSrf.Degree(0)\r\n            else:\r\n                iDegree_Start = rgSrf.Degree(1)\r\n            \r\n            rc, bDegree_Target = ri.RhinoGet.GetInteger(\r\n                \"Change degree from {} to\".format(iDegree_Start),\r\n                acceptNothing=True,\r\n                outputNumber=iDegree_Start-1 if iDegree_Start < 5 else 3,\r\n                lowerLimit=1,\r\n                upperLimit=iDegree_Start-1)\r\n\r\n            if rc == Rhino.Commands.Result.Cancel:\r\n                return\r\n\r\n            return tuple([objref, bDegree_Target] + [Opts.values[key] for key in Opts.keys])\r\n\r\n        # An option was selected.\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef getScaleFactorForDegreeChange(ns_From, side_ToConserve, iDeg_To):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    iDir = int(side_ToConserve in (rg.IsoStatus.South, rg.IsoStatus.North))\r\n\r\n    degree = ns_From.Degree(iDir)\r\n\r\n    scale = 1.0\r\n\r\n\r\n    for i in range(degree-1, iDeg_To-1, -1):\r\n        scale *= (float(i)**2 - 1.0) / (float(i)**2)\r\n\r\n\r\n    if ns_From.SpanCount(iDir) > 1:\r\n        knots = ns_From.KnotsV if iDir else ns_From.KnotsU\r\n        if side_ToConserve in (rg.IsoStatus.East, rg.IsoStatus.North):\r\n            iKnot_AdjToEnd = knots.Count - degree - 1\r\n        else:\r\n            iKnot_AdjToEnd = degree\r\n\r\n        multy_AdjKnot = knots.KnotMultiplicity(iKnot_AdjToEnd)\r\n\r\n        if multy_AdjKnot == 1:\r\n            # Adjust scale factor for knot vector.\r\n            iCt_Span = ns_From.SpanCount(iDir)\r\n            t_Knots_Span = ns_From.GetSpanVector(iDir)\r\n\r\n            if side_ToConserve in (rg.IsoStatus.East, rg.IsoStatus.North):\r\n                fLen_spanEnd = t_Knots_Span[iCt_Span] - t_Knots_Span[iCt_Span-1]\r\n                fLen_spanAdj = t_Knots_Span[iCt_Span-1] - t_Knots_Span[iCt_Span-2]\r\n            else:\r\n                fLen_spanEnd = t_Knots_Span[1] - t_Knots_Span[0]\r\n                fLen_spanAdj = t_Knots_Span[2] - t_Knots_Span[1]\r\n\r\n            m = (fLen_spanEnd + fLen_spanAdj) / fLen_spanEnd\r\n\r\n            scale *= m\r\n\r\n\r\n    return scale\r\n\r\n\r\ndef createSurface(ns_From, iDeg_To, side_ToConserve, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        ns_From: rg.NurbsSurface\r\n        iDeg_To: int of target degree\r\n        side_ToConserve: rg.IsoStatus\r\n        bDebug: bool\r\n    Returns on success: rg.NurbsSurface\r\n    Returns on fail: None\r\n    \"\"\"\r\n\r\n    if not isinstance(ns_From, rg.NurbsSurface): return\r\n\r\n    ns_In = ns_From\r\n\r\n    if ns_In.IsRational: return\r\n\r\n    if ns_In.IsPeriodic(0) or ns_In.IsPeriodic(1): return\r\n\r\n\r\n    pts_New = [] # Order for NurbsSurface.CreateFromPoints is u0,v0, u0,v1, ...\r\n\r\n    scale = getScaleFactorForDegreeChange(ns_In, side_ToConserve, iDeg_To) if iDeg_To > 1 else 1.0\r\n\r\n    if side_ToConserve in (rg.IsoStatus.South, rg.IsoStatus.North):\r\n\r\n        if side_ToConserve == rg.IsoStatus.South:\r\n            # Don't include northernmost rows.\r\n            for iU in range(ns_In.Points.CountU):\r\n                pt_Anchor = ns_In.Points.GetControlPoint(iU, 0).Location\r\n                pts_New.append(pt_Anchor)\r\n                xform = rg.Transform.Scale(pt_Anchor, scale)\r\n                for iV in range(1, iDeg_To+1):\r\n                    pt_New = rg.Point3d(ns_In.Points.GetControlPoint(iU, iV).Location)\r\n                    pt_New.Transform(rg.Transform.Scale(pt_Anchor, scale))\r\n                    pts_New.append(pt_New)\r\n        else:\r\n            # Don't include southernmost rows.\r\n            for iU in range(ns_In.Points.CountU):\r\n                pt_Anchor = ns_In.Points.GetControlPoint(iU, ns_In.Points.CountV-1).Location\r\n                xform = rg.Transform.Scale(pt_Anchor, scale)\r\n                for iV in range(ns_In.Points.CountV-iDeg_To-1, ns_In.Points.CountV-1):\r\n                    pt_New = rg.Point3d(ns_In.Points.GetControlPoint(iU, iV).Location)\r\n                    pt_New.Transform(rg.Transform.Scale(pt_Anchor, scale))\r\n                    pts_New.append(pt_New)\r\n                pts_New.append(pt_Anchor)\r\n\r\n        uCount_New = ns_In.Points.CountU\r\n        vCount_New = iDeg_To + 1\r\n        uDegree_New = ns_In.Degree(0)\r\n        vDegree_New = iDeg_To\r\n\r\n    elif side_ToConserve in (rg.IsoStatus.West, rg.IsoStatus.East):\r\n\r\n        if side_ToConserve == rg.IsoStatus.West:\r\n            # Don't include easternmost columns.\r\n            for iV in range(ns_In.Points.CountV):\r\n                pts_New.append(ns_In.Points.GetControlPoint(0, iV).Location)\r\n\r\n            for iU in range(1, iDeg_To+1):\r\n                for iV in range(ns_In.Points.CountV):\r\n                    pt_New = rg.Point3d(ns_In.Points.GetControlPoint(iU, iV).Location)\r\n                    pt_New.Transform(rg.Transform.Scale(pts_New[iV], scale))\r\n                    pts_New.append(pt_New)\r\n        else:\r\n            # Don't include westernmost columns.\r\n            for iU in range(ns_In.Points.CountU-iDeg_To-1, ns_In.Points.CountU-1):\r\n                for iV in range(ns_In.Points.CountV):\r\n                    pt_Anchor = ns_In.Points.GetControlPoint(ns_In.Points.CountU-1, iV).Location\r\n                    pt_New = rg.Point3d(ns_In.Points.GetControlPoint(iU, iV).Location)\r\n                    pt_New.Transform(rg.Transform.Scale(pt_Anchor, scale))\r\n                    pts_New.append(pt_New)\r\n\r\n            for iV in range(ns_In.Points.CountV):\r\n                pts_New.append(ns_In.Points.GetControlPoint(ns_In.Points.CountU-1, iV).Location)\r\n\r\n        uCount_New = iDeg_To + 1\r\n        vCount_New = ns_In.Points.CountV\r\n        uDegree_New = iDeg_To\r\n        vDegree_New = ns_In.Degree(1)\r\n\r\n    else:\r\n        ns_Out = None\r\n\r\n    if bDebug:\r\n        for i in range(len(pts_New)):\r\n            pt = pts_New[i]\r\n            rgDot = rg.TextDot(\"{}\".format(i), pt)\r\n            rgDot.FontHeight = 11\r\n            sc.doc.Objects.AddTextDot(rgDot)\r\n        sc.doc.Views.Redraw()\r\n\r\n    ns_Out = rg.NurbsSurface.CreateFromPoints(\r\n        points=pts_New,\r\n        uCount=uCount_New,\r\n        vCount=vCount_New,\r\n        uDegree=uDegree_New,\r\n        vDegree=vDegree_New)\r\n\r\n    ns_In.Dispose()\r\n\r\n    return ns_Out\r\n\r\n\r\ndef processBrepObject(objref_In, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    iDegree = getOpt('iDegree')\r\n    bConservePickedSide = getOpt('bConservePickedSide')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rdBrep_In = objref_In.Object()\r\n    #rgBrep_In = rdBrep_In.Geometry.Duplicate() # So it is not DocumentControlled.\r\n    rgF_In = objref_In.Surface()\r\n    rgS_In = rgF_In.UnderlyingSurface()\r\n    if isinstance(rgS_In, rg.NurbsSurface):\r\n        ns_In = rgS_In.Duplicate()\r\n    elif isinstance(rgS_In, rg.SumSurface):\r\n        ns_In = rgS_In.ToNurbsSurface()\r\n    else:\r\n        return\r\n\r\n\r\n    rgT_Sel = objref_In.Trim()\r\n\r\n    if bConservePickedSide:\r\n        side_Conserve = rgT_Sel.IsoStatus\r\n    else:\r\n        side_Conserve = rg.IsoStatus.ToObject(\r\n            rg.IsoStatus, ((rgT_Sel.IsoStatus.value__ - 1) % 4) + 3)\r\n\r\n\r\n    ns_Res = createSurface(\r\n        ns_From=ns_In,\r\n        iDeg_To=iDegree,\r\n        side_ToConserve=side_Conserve,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if ns_Res is None:\r\n        print \"Surface could not be created.\"\r\n        return\r\n\r\n    if not bReplace:\r\n        gB_Out = sc.doc.Objects.AddSurface(ns_Res)\r\n        if gB_Out == gB_Out.Empty:\r\n            print \"Could not add modified surface.\"\r\n        else:\r\n            print \"Surface was added.\"\r\n    else:\r\n        rdB_In = objref_In.Object()\r\n        rgB_In = objref_In.Brep()\r\n        rgB_WIP = rgB_In.DuplicateBrep()\r\n        rgB_WIP.Faces.RemoveAt(objref_In.Face().FaceIndex)\r\n        rgBs_Out = rg.Brep.CreateBooleanUnion([rgB_WIP], sc.doc.ModelAbsoluteTolerance)\r\n        rgB_WIP.Dispose()\r\n\r\n        if rgB_In.Faces.Count == 1:\r\n            rgB_Out = ns_Res.ToBrep()\r\n            if sc.doc.Objects.Replace(objref_In.ObjectId, rgB_Out):\r\n                gB_Out = objref_In.ObjectId\r\n                print \"Replaced monoface brep with new surface.\"\r\n            else:\r\n                print \"Could not replace monoface brep with new surface.\"\r\n        else:\r\n            attr = rdB_In.Attributes\r\n            gB_Out = sc.doc.Objects.AddSurface(ns_Res, attr)\r\n            if gB_Out == gB_Out.Empty:\r\n                print \"Could not add modified surface.\"\r\n            else:\r\n                if len(rgBs_Out) == 1:\r\n                    if sc.doc.Objects.Replace(objref_In.ObjectId, rgBs_Out[0]):\r\n                        print \"Added new surface and deleted face of brep.\"\r\n                    else:\r\n                        print \"Added new surface but could not delete face of brep.\"\r\n                else:\r\n                    gBs_Out = []\r\n                    for rgB in rgBs_Out:\r\n                        gBs_Out.append(sc.doc.Objects.AddBrep(rgB, attr))\r\n\r\n                    if gBs_Out[0].Empty in gBs_Out:\r\n                        for gB_Out in gBs_Out:\r\n                            if gB_Out != gB_Out.Empty:\r\n                                sc.doc.Objects.Delete(objectId=gB_Out, quiet=False)\r\n                        print \"Added new surface but could not delete face of brep.\"\r\n                    else:\r\n                        sc.doc.Objects.Delete(rdB_In)\r\n                        print \"Added new surface and deleted face of brep.\" \\\r\n                            \"  Remainder of brep is now {} breps.\".format(len(gBs_Out))\r\n\r\n    return gB_Out\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        objref_In,\r\n        iDegree,\r\n        bConservePickedSide,\r\n        bReplace,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    gB_Res = processBrepObject(\r\n        objref_In=objref_In,\r\n        iDegree=iDegree,\r\n        bConservePickedSide=bConservePickedSide,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n    if gB_Res is None:\r\n        return\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}