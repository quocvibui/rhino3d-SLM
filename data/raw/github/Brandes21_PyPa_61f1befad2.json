{
  "source_url": "https://github.com/Brandes21/PyPa/blob/713d1e35bd5490521eab2d0efe869fff9692e351/Packages/PSL_Tracer/src/PSL_Tracer/Tracer_B.py",
  "repo": "Brandes21/PyPa",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Packages/PSL_Tracer/src/PSL_Tracer/Tracer_B.py",
  "instruction": "Tracer b",
  "code": "\ndef main(h,num_steps,k,collision_threshold,snap_radius,n_back,offset_distance,sample_interval,sample_count,k_edge,ratio_minseed_coll,seed_point,principal_vectors,points,domain_surface,boundary_curves):\n\n    import math\n    import numpy as np\n    import rhinoscriptsyntax as rs\n    import Rhino.Geometry as rg\n    import scriptcontext as sc\n    from scipy.spatial import KDTree\n    from ghpythonlib import treehelpers as tr\n\n\n    # ------------------------------------------------------------------------\n    # Set variables\n    # ------------------------------------------------------------------------\n    min_seed_distance = collision_threshold * ratio_minseed_coll\n    closing_threshold=h\n    boundary_tolerance = h\n    seed_boundary_dist = min_seed_distance\n\n\n    # ------------------------------------------------------------------------\n    # Helper functions\n    # ------------------------------------------------------------------------\n    def build_polyline_curve_3d(poly_pts):\n        pts3d = [rg.Point3d(pt[0], pt[1], pt[2]) for pt in poly_pts]\n        poly = rg.Polyline(pts3d)\n        return rg.PolylineCurve(poly)\n\n    def to_xyz(pt_or_vec):\n        \n        if hasattr(pt_or_vec, \"X\"):\n            return [pt_or_vec.X, pt_or_vec.Y, pt_or_vec.Z]\n        else:\n            \n            return [pt_or_vec[0], pt_or_vec[1], pt_or_vec[2]]\n\n    def distance_3d(a, b):\n        return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)\n\n    def normalize(vector):\n      \n        magnitude = math.sqrt(vector[0]**2 + vector[1]**2+vector[2]**2)\n        return [vector[0] / magnitude, vector[1] / magnitude,vector[2] / magnitude] if magnitude != 0 else [0, 0, 0]\n\n    def find_closest_neighbors_kd(point, kd_tree, k):\n\n\n        distances, indices = kd_tree.query(point,k=k)\n        if isinstance(indices, int):\n            return [indices]\n        return list(indices)\n\n    def is_point_close_to_any(point_list, single_point, threshold):\n        flat = [item for sublist in point_list for item in sublist]\n        #print(f\"single = {single_point}\")\n        single_point_1 = rg.Point3d(single_point[0],single_point[1],single_point[2])\n        \n        \n        for pt in flat:\n            #print(f\"pt = {pt}\")\n            if single_point_1.DistanceTo(pt) <= threshold:\n                return pt\n        return single_point\n\n    def project_onto_surface(surface, pt3d, tolerance=200):\n        pt_rh = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n        \n        if isinstance(surface, rg.Brep):\n            \n            rc, closest_pt, cindex, u, v, normal = surface.ClosestPoint(pt_rh, tolerance)\n            if rc:\n                # Check if cindex is a face\n                if cindex.ComponentIndexType == rg.ComponentIndexType.BrepFace:\n                    face_id = cindex.Index\n                    face = surface.Faces[face_id]\n                    \n                    # 'closest_pt' is the 3D point on that face\n                    \n                    \n                    return [closest_pt.X, closest_pt.Y, closest_pt.Z]\n                else:\n                    \n                    return None\n            else:\n                return None\n        \n        elif isinstance(surface, rg.Surface):\n            rc, u, v = surface.ClosestPoint(pt_rh)\n            if rc:\n                pt_srf = surface.PointAt(u, v)\n                return [pt_srf.X, pt_srf.Y, pt_srf.Z]\n            else:\n                return None\n        else:\n            return None\n\n    def distance_to_brep_edges(pt3d, boundary_curves):\n        test_pt = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n        min_dist = float('inf')\n        best_cp = None  # keep track of the closest point\n        \n        for crv in boundary_curves:\n            rc, t = crv.ClosestPoint(test_pt)\n            if rc:\n                cp = crv.PointAt(t)\n                dist = cp.DistanceTo(test_pt)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_cp = cp\n        \n        return min_dist, best_cp\n\n    def is_on_surface(surface, pt3d, tol=0.01):\n        \"\"\"\n        Returns True if pt3d is within 'tol' of the surface. \n        \"\"\"\n        if not surface: \n            return True  # no surface provided\n        pproj = project_onto_surface(surface, pt3d)\n        if pproj is None:\n            return False\n        dx = pt3d[0] - pproj[0]\n        dy = pt3d[1] - pproj[1]\n        dz = pt3d[2] - pproj[2]\n        dist = math.sqrt(dx*dx + dy*dy + dz*dz)\n        return (dist < tol)\n\n    # ------------------------------------------------------------------------\n    # Tracing functions\n    # ------------------------------------------------------------------------\n\n    def interpolate_vector(point, points, vectors, neighbors, ref_dir):\n        \n        # Distance-weighted interpolation of neighbor vectors in 3D,\n        # flipping each neighbor's vector if dot < 0 with respect to 'ref_dir'.\n\n        # - pt: [x, y, z], the point where we want the interpolated vector\n        # - points_3d: Nx3 array of point coords\n        # - vectors_3d: Nx3 array of principal vectors\n        # - neighbors: list of indices from the KDTree\n        # - ref_dir: [dx, dy, dz], the direction from the previous step (or None if first step)\n        \n        weights = []\n        weighted_vec = [0.0, 0.0, 0.0]\n\n        for i in neighbors:\n            vx, vy, vz = vectors[i]  # copy - flip locally\n            if ref_dir is not None:\n                dotp = vx*ref_dir[0] + vy*ref_dir[1] + vz*ref_dir[2]\n                if dotp < 0:\n                    vx, vy, vz = -vx, -vy, -vz\n            \n            npt = points[i]\n            dx = point[0] - npt[0]\n            dy = point[1] - npt[1]\n            dz = point[2] - npt[2]\n            dist = (dx*dx + dy*dy + dz*dz)**0.5\n            \n            w = 1.0 / (dist + 1e-6)\n            weights.append(w)\n            \n            weighted_vec[0] += vx*w\n            weighted_vec[1] += vy*w\n            weighted_vec[2] += vz*w\n\n        total_w = sum(weights)\n        if total_w > 1e-12:\n            weighted_vec[0] /= total_w\n            weighted_vec[1] /= total_w\n            weighted_vec[2] /= total_w\n\n        mag = (weighted_vec[0]**2 + weighted_vec[1]**2 + weighted_vec[2]**2)**0.5\n        if mag < 1e-12:\n            return [0.0, 0.0, 0.0]\n        \n        return [weighted_vec[0]/mag, weighted_vec[1]/mag, weighted_vec[2]/mag]\n\n    def runge_kutta_step_3d(\n        current_point, \n        current_dir,\n        h, \n        k, \n        principal_vectors, \n        points_3d, \n        step_sign, \n        kd_tree, \n        boundary_curves=None, \n        boundary_tolerance=5, prev_dir=None):\n        \n        # Perform one RK4 step in 3D. Stop if next point is within 'boundary_tolerance'\n        # of any boundary curve (edges).\n        # Returns the next 3D point or None if out-of-bound / near boundary.\n        \n        \n        # 1) \n        neighbors = find_closest_neighbors_kd(current_point, kd_tree, k)\n        h = h * step_sign\n        \n        # k1\n        k1_dir = interpolate_vector(current_point, points_3d, principal_vectors, neighbors, current_dir)\n        mid1 = [\n            current_point[0] + 0.5*h*k1_dir[0],\n            current_point[1] + 0.5*h*k1_dir[1],\n            current_point[2] + 0.5*h*k1_dir[2]\n        ]\n        \n        # k2\n        neigh_mid1 = find_closest_neighbors_kd(mid1, kd_tree, k)\n        k2_dir = interpolate_vector(mid1, points_3d, principal_vectors, neigh_mid1, k1_dir)\n        mid2 = [\n            current_point[0] + 0.5*h*k2_dir[0],\n            current_point[1] + 0.5*h*k2_dir[1],\n            current_point[2] + 0.5*h*k2_dir[2]\n        ]\n        \n        # k3\n        neigh_mid2 = find_closest_neighbors_kd(mid2, kd_tree, k)\n        k3_dir = interpolate_vector(mid2, points_3d, principal_vectors, neigh_mid2, k2_dir)\n        end_pt = [\n            current_point[0] + h*k3_dir[0],\n            current_point[1] + h*k3_dir[1],\n            current_point[2] + h*k3_dir[2]\n        ]\n        \n        # k4\n        neigh_end = find_closest_neighbors_kd(end_pt, kd_tree, k)\n        k4_dir = interpolate_vector(end_pt, points_3d, principal_vectors, neigh_end, k3_dir)\n        \n        # Summation\n        dx = h*(k1_dir[0] + 2*k2_dir[0] + 2*k3_dir[0] + k4_dir[0]) / 6.0\n        dy = h*(k1_dir[1] + 2*k2_dir[1] + 2*k3_dir[1] + k4_dir[1]) / 6.0\n        dz = h*(k1_dir[2] + 2*k2_dir[2] + 2*k3_dir[2] + k4_dir[2]) / 6.0\n        \n        next_point = [\n            current_point[0] + dx,\n            current_point[1] + dy,\n            current_point[2] + dz\n        ]\n        next_dir = k4_dir\n\n        if domain_surface is not None:\n            projected = project_onto_surface(domain_surface, next_point)\n            print(projected)\n            if projected is None:\n                \n                return None\n            next_point = projected  \n\n\n\n        # Otherwise return the next valid point\n        return next_point, next_dir\n\n    # ------------------------------------------------------------------------\n    # Collision checks\n    # ------------------------------------------------------------------------\n\n    def closest_point_on_polyline_3d(pt3d, poly_curve):\n        \n        # Return (closest_point, distance) from a 3D point to a polyline curve.\n        \n        test_pt = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n        rc, t = poly_curve.ClosestPoint(test_pt)\n        if rc:\n            cp = poly_curve.PointAt(t)\n            dist = cp.DistanceTo(test_pt)\n            return [cp.X, cp.Y, cp.Z], dist\n        else:\n            return None, float('inf')\n\n    def find_closest_existing_line_3d(next_point, existing_trajectories, threshold):\n        \n        # Among all previously traced lines (in 3D), find if 'next_point' is within 'threshold' of any line.\n        # Returns (closest_line_index, closest_point_on_line, distance).\n        \n        min_dist = float('inf')\n        closest_line_idx = None\n        closest_pt = None\n        \n        for i, (polyline_pts, poly_curve) in enumerate(existing_trajectories):\n            cp, dist = closest_point_on_polyline_3d(next_point, poly_curve)\n            if dist < min_dist:\n                min_dist = dist\n                closest_line_idx = i\n                closest_pt = cp\n        \n        if min_dist < threshold:\n            return (closest_line_idx, closest_pt, min_dist)\n        else:\n            return (None, None, float('inf'))\n\n    def find_most_parallel_boundary_point(\n        current_pt,\n        last_step_vec,\n        boundary_points,\n        k=10):\n        \n        # Given a KD-tree of boundary sample points (boundary_kdtree)\n        # and the original array (boundary_points),\n        # find the boundary sample whose direction from current_pt \n        # is most opposite (or \"most parallel\" â€“ depends on how you measure) \n        # to last_step_vec. Return (best_point, min_dist).\n\n        # boundary_points should be a Nx3 np.array or a list of [x,y,z].\n        \n        \n        if boundary_kdtree is None:\n            return None, float('inf')\n        \n        cur_np = np.array(current_pt, dtype=float)\n        step_np = np.array(last_step_vec, dtype=float)\n        \n        # if zero length, can't define direction\n        step_len = np.linalg.norm(step_np)\n        if step_len < 1e-12:\n            return None, float('inf')\n        step_np /= step_len\n        \n        # 1) Quickly find the 'k' closest boundary samples to current_pt\n\n        distances, indices = boundary_kdtree.query(cur_np, k=k)\n\n        # If k=1, make them arrays for consistency\n        if k == 1:\n            distances = [distances]\n            indices = [indices]\n\n        # 2) Among these k points, pick the direction which has \n        #    the smallest dot or largest negative dot, etc.\n        best_dot = 9999\n        best_pt = None\n        min_dist = float('inf')\n\n        # boundary_points is Nx3\n\n        for dist, idx in zip(distances, indices):\n            cand_np = boundary_points_array[idx]  \n            dir_vec = cand_np - cur_np\n            dir_len = np.linalg.norm(dir_vec)\n            if dir_len < 1e-12:\n                continue\n            dir_unit = dir_vec / dir_len\n            dot_val = np.dot(dir_unit, step_np)\n            \n    \n            if dot_val < best_dot:\n                best_dot = dot_val\n                best_pt = cand_np\n                \n                if dist < min_dist:\n                    min_dist = dist\n\n        # Convert best_pt to Rhino point\n        if best_pt is not None:\n            return rg.Point3d(best_pt[0], best_pt[1], best_pt[2]), min_dist\n        else:\n            return None, float('inf')\n\n\n    # ------------------------------------------------------------------------\n    # Sampling and offset functions\n    # ------------------------------------------------------------------------\n\n    def surface_normal_at_point(surface, pt3d, tolerance=2):\n        \n        # Returns the surface normal [nx, ny, nz] at a 3D point on a multi-face Brep or rg.Surface.\n        # If near an open edge or invalid, returns None.\n        \n        pt_rh = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n\n        if isinstance(surface, rg.Brep):\n            stuff = surface.ClosestPoint(pt_rh, tolerance)\n            if not stuff or len(stuff) < 6:\n                return None\n            b = stuff[0]\n            rc = stuff[1]\n            print(rc)\n            comp_index = stuff[2]\n            u = stuff[3]\n            v = stuff[4]\n            # stuff[4] => cpt\n            # stuff[5] => guess_normal\n            if not rc:\n                return None\n            \n            # If it's a face, evaluate the face normal at (u, v)\n            if comp_index.ComponentIndexType == rg.ComponentIndexType.BrepFace:\n                face_id = comp_index.Index\n                face = surface.Faces[face_id]\n                exact_normal = face.NormalAt(u, v)\n                if exact_normal:\n                    return [exact_normal.X, exact_normal.Y, exact_normal.Z]\n                else:\n                    return None\n            else:\n                # edge/vertex\n                return None\n        \n        elif isinstance(surface, rg.Surface):\n            rc, u, v = surface.ClosestPoint(pt_rh)\n            if rc:\n                exact_normal = surface.NormalAt(u, v)\n                return [exact_normal.X, exact_normal.Y, exact_normal.Z]\n            else:\n                return None\n\n        # Not a Brep or Surface\n        return None\n\n    def offset_seed(psl_pts_3d, index, offset_distance, surface):\n        \n        # Offsets the PSL at psl_pts_3d[index] in the local tangent plane of 'surface'.\n        # Steps:\n        # 1) Compute PSL tangent at index\n        # 2) Get surface normal at that point\n        # 3) binormal = cross(surface_normal, psl_tangent)\n        # 4) candidate1 = point + offset_distance*binormal\n        #     candidate2 = point - offset_distance*binormal\n        # 5) (optional) project candidates back onto the surface\n        # Returns: (candidate1, candidate2) as [x, y, z], or (None, None) on error.\n        \n        n = len(psl_pts_3d)\n        if n < 2:\n            return None, None\n        \n        # 0) Current point\n        px, py, pz = psl_pts_3d[index]\n        \n        # 1) PSL TANGENT\n        if index == 0:\n            # Use next point - current point\n            nx, ny, nz = psl_pts_3d[1]\n            tx = nx - px\n            ty = ny - py\n            tz = nz - pz\n        elif index == n - 1:\n            # Use current point - prev point\n            px_prev, py_prev, pz_prev = psl_pts_3d[n - 2]\n            tx = px - px_prev\n            ty = py - py_prev\n            tz = pz - pz_prev\n        else:\n            # Middle: use psl_pts_3d[index+1] - psl_pts_3d[index-1]\n            px_prev, py_prev, pz_prev = psl_pts_3d[index - 1]\n            px_next, py_next, pz_next = psl_pts_3d[index + 1]\n            tx = px_next - px_prev\n            ty = py_next - py_prev\n            tz = pz_next - pz_prev\n\n        # Normalize tangent\n        t_len = math.sqrt(tx*tx + ty*ty + tz*tz)\n        if t_len < 1e-12:\n            return None, None\n        tx /= t_len\n        ty /= t_len\n        tz /= t_len\n        \n        # 2) SURFACE NORMAL\n        normal = surface_normal_at_point(surface, [px, py, pz])\n        if not normal:\n            print(\"no normal\")\n            return None, None\n        nx, ny, nz = normal\n        n_len = math.sqrt(nx*nx + ny*ny + nz*nz)\n        if n_len < 1e-12:\n            return None, None\n        nx /= n_len\n        ny /= n_len\n        nz /= n_len\n        \n        # 3) BINORMAL = cross(normal, tangent)\n        # This is guaranteed to be in the tangent plane if PSL is truly tangent to the surface\n        # If the PSL isn't exactly tangent, you'll get some tilt. \n        bx = ny*tz - nz*ty\n        by = nz*tx - nx*tz\n        bz = nx*ty - ny*tx\n        b_len = math.sqrt(bx*bx + by*by + bz*bz)\n        if b_len < 1e-12:\n            # Means normal and tangent are parallel \n            return None, None\n        bx /= b_len\n        by /= b_len\n        bz /= b_len\n        \n        # 4) OFFSET POINTS\n        candidate1 = [px + offset_distance*bx,\n                    py + offset_distance*by,\n                    pz + offset_distance*bz]\n        candidate2 = [px - offset_distance*bx,\n                    py - offset_distance*by,\n                    pz - offset_distance*bz]\n        \n        # 5) (OPTIONAL) Project \n        candidate1_proj = project_onto_surface(surface, candidate1)\n        print(f\"this point is seed {candidate1_proj}\")\n        candidate2_proj = project_onto_surface(surface, candidate2)\n\n\n\n        return candidate1_proj, candidate2_proj\n\n    def sample_psl_3d(psl_pts):\n        \n        # Given a PSL (list of Rhino Point3d or numeric [x,y,z] points),\n        # sample it every 'sample_interval' points.\n        # Returns a list of tuples: ( [x,y,z], original_index )\n        \n        samples = []\n        for i in range(0, len(psl_pts), sample_interval):\n            pt3d = psl_pts[i]\n            # Convert to numeric [x,y,z] if it's a Point3d\n            if hasattr(pt3d, \"X\"):\n                samples.append(([pt3d.X, pt3d.Y, pt3d.Z], i))\n            else:\n                samples.append((pt3d, i))\n        return samples\n\n    def is_valid_seed(candidate, existing_trajectories, min_distance, boundary_curves):\n        \n        # Check if candidate seed is valid:\n        # - It is not too close to any existing PSL (using min_distance).\n        # - It is not too close to any boundary curves (if boundary_curves is provided and\n        #     candidate's distance < boundary_tolerance).\n        \n        # Check candidate against existing PSLs\n        idx, cp, dist = find_closest_existing_line_3d(candidate, existing_trajectories, min_distance)\n        if idx is not None:\n            return False\n\n        # Check candidate against boundary curves if provided\n        if boundary_curves:\n            dist_edge, cp_edge = distance_to_brep_edges(candidate, boundary_curves)\n            if dist_edge < seed_boundary_dist:\n                return False\n\n        return True\n\n\n    # ------------------------------------------------------------------------\n    # Tracing logic\n    # ------------------------------------------------------------------------\n\n    def trace_psl_both_directions(\n        seed_point_3d, \n        h, \n        num_steps, \n        k, \n        principal_vectors, \n        points_3d,\n        boundary_curves=None,\n        boundary_tolerance=boundary_tolerance,\n        existing_trajectories=None,\n        collision_threshold=collision_threshold,\n        closing_threshold=closing_threshold, \n        kd_tree=None,\n        existing_merge_pts = None):\n        \n        # Single-loop approach where forward/backward can stop independently.\n        # If forward hits a collision/boundary, it stops, but backward can continue, and vice versa.\n        # We only stop the entire PSL when BOTH directions are inactive, or when tips meet.\n        \n        if existing_trajectories is None:\n            existing_trajectories = []\n        \n        import Rhino.Geometry as rg\n        bridging_lines = []\n        merge_points = []\n\n        # We'll keep two lines: forward and backward\n        forward_line = [rg.Point3d(*seed_point_3d)]\n        backward_line = [rg.Point3d(*seed_point_3d)]\n        \n        # Current forward/backward points + directions\n        f_current_pt = list(seed_point_3d)\n        f_current_dir = None\n        b_current_pt = list(seed_point_3d)\n        b_current_dir = None\n\n        # NEW: Boolean flags \n        forward_active = True\n        backward_active = True\n\n        for step_i in range(num_steps):\n            \n            # ---------------------------\n            # FORWARD STEP (if still active)\n            # ---------------------------\n            if forward_active:\n                f_next = runge_kutta_step_3d(\n                    f_current_pt,\n                    f_current_dir,\n                    h,\n                    k,\n                    principal_vectors,\n                    points_3d,\n                    step_sign=+1,\n                    kd_tree=kd_tree,\n                    boundary_curves=boundary_curves,\n                    boundary_tolerance=boundary_tolerance\n                )\n                if not f_next or f_next[0] is None:\n                    print(f\"PSL forward direction stopped at iteration {step_i}.\")\n                    forward_active = False\n                else:\n                    f_next_pt, f_next_dir = f_next\n                    # Collision check with existing PSLs\n                    if existing_trajectories:\n                        line_idx, close_pt, dist_cl = find_closest_existing_line_3d(\n                            f_next_pt, existing_trajectories, collision_threshold\n                        )\n\n                        if len(existing_merge_pts) > 1 and close_pt is not None:\n                            print(f\"merged = {merge_points}\")\n                            close_pt = is_point_close_to_any(existing_merge_pts, close_pt, snap_radius)\n\n                        if line_idx is not None and close_pt is not None:\n                            # Instead of break, bridging & disable forward\n                            \n                            if len(forward_line) > n_back:\n                                bridging_line = rg.Line(\n                                    forward_line[-n_back],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                                del forward_line[-(n_back-1):]\n\n                            if len(forward_line)==0 or len(backward_line)==1:\n                                print(\"too short for bridge\")\n                            else:\n                                bridging_line = rg.Line(\n                                    forward_line[-1],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                            \n                            print(f\"PSL forward collided with line {line_idx} at dist {dist_cl:.3f}.\")\n                            forward_active = False\n\n                        # 2) Check distance to boundary edges\n                    if boundary_curves:\n                        dir_vec = [-1*x for x in f_next_dir]\n                        cp,dist_to_edge = find_most_parallel_boundary_point(f_next_pt,dir_vec,boundary_curves,k_edge)\n                        if dist_to_edge < boundary_tolerance:\n                            #\"off\" or \"too close\" => stop\n                            print(f\"PSL forward reached boundary.\")\n                            forward_active = False\n                            bridging_line = rg.Line(\n                                    forward_line[-1],\n                                    rg.Point3d(cp)\n                            )\n                            bridging_lines.append(bridging_line)\n\n\n                    if forward_active:\n                        forward_line.append(rg.Point3d(*f_next_pt))\n                        f_current_pt = f_next_pt\n                        f_current_dir = f_next_dir\n\n            # ---------------------------\n            # BACKWARD STEP (if still active)\n            # ---------------------------\n            if backward_active:\n                b_next = runge_kutta_step_3d(\n                    b_current_pt,\n                    b_current_dir,\n                    h,\n                    k,\n                    principal_vectors,\n                    points_3d,\n                    step_sign=-1,\n                    kd_tree=kd_tree,\n                    boundary_curves=boundary_curves,\n                    boundary_tolerance=boundary_tolerance\n                )\n                if not b_next or b_next[0] is None:\n                    print(f\"PSL backward direction stopped at iteration {step_i}.\")\n                    backward_active = False\n                else:\n                    b_next_pt, b_next_dir = b_next\n                    # Collision check with existing PSLs\n                    if existing_trajectories:\n                        line_idx, close_pt, dist_cl = find_closest_existing_line_3d(\n                            b_next_pt, existing_trajectories, collision_threshold\n                        )\n\n\n                        if len(existing_merge_pts) > 1 and close_pt is not None:\n                            print(f\"merged = {merge_points}\")\n                            close_pt = is_point_close_to_any(existing_merge_pts, close_pt, snap_radius)\n\n                        if line_idx is not None and close_pt is not None:\n                            \n                            if len(backward_line) > n_back:\n                                bridging_line = rg.Line(\n                                    backward_line[-n_back],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                                del backward_line[-(n_back-1):]\n\n                            if len(backward_line)==0 or len(backward_line)==1:\n                                print(\"too short for bridge\")\n                            else:\n                                bridging_line = rg.Line(\n                                    backward_line[-1],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n\n                            print(f\"PSL backward collided with line {line_idx} at dist {dist_cl:.3f}.\")\n                            backward_active = False\n\n\n                    if boundary_curves:\n                        \n                        cp,dist_to_edge = find_most_parallel_boundary_point(b_next_pt,b_next_dir,boundary_curves,k_edge)\n                        if dist_to_edge < boundary_tolerance:\n                            #\"off\" or \"too close\" => stop\n                            print(f\"PSL forward reached boundary.\")\n                            backward_active = False\n                            bridging_line = rg.Line(\n                                    backward_line[-1],\n                                    rg.Point3d(cp)\n                            )\n                            bridging_lines.append(bridging_line)\n\n                    if backward_active:\n                        backward_line.append(rg.Point3d(*b_next_pt))\n                        b_current_pt = b_next_pt\n                        b_current_dir = b_next_dir\n            \n            # ---------------------------\n            # Check if BOTH directions are done\n            # ---------------------------\n            if not forward_active and not backward_active:\n                print(\"Both forward & backward directions inactive => stopping PSL.\")\n                break\n\n            # ---------------------------\n            # TIP DISTANCE CHECK\n            # ---------------------------\n            # Only if both are still active\n            if forward_active and backward_active and step_i >= 10:\n                f_xyz = [forward_line[-1].X, forward_line[-1].Y, forward_line[-1].Z]\n                b_xyz = [backward_line[-1].X, backward_line[-1].Y, backward_line[-1].Z]\n                dist_fb = distance_3d(f_xyz, b_xyz)\n                if dist_fb < closing_threshold:\n                    bridging_line = rg.Line(\n                        forward_line[-1],\n                        backward_line[-1]\n                    )\n                    bridging_lines.append(bridging_line)\n\n                    print(\n                        f\"PSL tips meet at iteration {step_i}, dist= {dist_fb:.3f} < {closing_threshold}.\"\n                    )\n                    \n                    forward_active = False\n                    backward_active = False\n                    break\n        \n        # Merge lines\n        backward_line.reverse()\n        if len(backward_line) > 1:\n            backward_line.pop()\n        merged_pts = backward_line + forward_line\n        \n        return merged_pts, bridging_lines,merge_points\n\n    def generate_all_psls_3d(\n        initial_seed_3d,\n        h, \n        num_steps, \n        k, \n        principal_vectors, \n        points_3d,\n        kd_tree,\n        boundary_curves,\n        collision_threshold,\n        sample_interval,\n        offset_distance,\n        min_seed_distance):\n\n        existing_merge_pts = []\n\n        initial_psl, initial_bridges, merge_points = trace_psl_both_directions(\n            seed_point_3d=initial_seed_3d,\n            h=h,\n            num_steps=num_steps,\n            k=k,\n            principal_vectors=principal_vectors,\n            points_3d=points_3d,\n            boundary_curves=boundary_curves,\n            boundary_tolerance=boundary_tolerance,\n            existing_trajectories=None,\n            collision_threshold=collision_threshold,\n            closing_threshold=closing_threshold,  \n            kd_tree=kd_tree,\n            existing_merge_pts = existing_merge_pts\n        )\n\n\n        # Build polyline curve (3D) for collision checking\n        initial_curve = build_polyline_curve_3d(initial_psl)\n        all_psls = [(initial_psl, initial_curve)]\n        bridging_lines = []\n        positive_candidates = []\n        if initial_bridges:\n            bridging_lines.extend(initial_bridges)\n        \n        # 2) PSL queue\n        psl_queue = [(initial_psl, initial_curve)]\n\n        \n        # 3) BFS-like expansion\n        while psl_queue:\n            \n            current_psl, current_curve = psl_queue.pop(0)\n            # numeric version\n            psl_numeric_3d = [[pt.X, pt.Y, pt.Z] for pt in current_psl]\n            \n            # Sample\n            samples = sample_psl_3d(current_psl)  # returns ( [x,y,z], index )\n            \n            # For each sample, offset in 3D\n            for sample_pt_3d, orig_index in samples:\n                cand1, cand2 = offset_seed(psl_numeric_3d, orig_index, offset_distance, domain_surface)\n                if not cand1 or not cand2:\n                    continue  # offset failed or degenerate tangent\n                \n                # We'll try both\n                candidates_3d = [cand1, cand2]\n                \n                traced_this_sample = False\n                for candidate_3d in candidates_3d:\n                    # Check if candidate is valid:\n                    #   1) at least min_seed_distance from existing PSL\n                    if not is_valid_seed(candidate_3d, all_psls, min_seed_distance,boundary_curves):\n                        continue\n \n                    \n\n                    print(\"Candidate seed found:\", candidate_3d)\n                    positive_candidates.append(candidate_3d)\n                    \n                    # Trace a new PSL\n                    new_psl, new_bridges, merge_points = trace_psl_both_directions(\n                        seed_point_3d=candidate_3d,\n                        h=h,\n                        num_steps=num_steps,\n                        k=k,\n                        principal_vectors=principal_vectors,\n                        points_3d=points_3d,\n                        boundary_curves=boundary_curves,\n                        boundary_tolerance=boundary_tolerance,\n                        existing_trajectories=all_psls,\n                        collision_threshold=collision_threshold,\n                        closing_threshold=closing_threshold,  \n                        kd_tree=kd_tree,\n                        existing_merge_pts = existing_merge_pts\n\n                    )\n                    new_curve = build_polyline_curve_3d(new_psl)\n                    \n                    # Add to collection\n                    all_psls.append((new_psl, new_curve))\n                    psl_queue.append((new_psl, new_curve))\n                    existing_merge_pts.append(merge_points)\n                    if new_bridges:\n                        bridging_lines.extend(new_bridges)\n                    \n                    traced_this_sample = True\n\n                    break\n        \n        return all_psls, bridging_lines, positive_candidates\n\n\n\n\n    # ------------------------------------------------------------------------\n    # Build KD Trees\n    # ------------------------------------------------------------------------\n\n    #1) mesh points kdtree\n    points_array_3d = [to_xyz(pt) for pt in points]\n    points_np = np.array(points_array_3d)  # shape (N, 3)\n    kd_tree = KDTree(points_np)\n\n    initial_seed_3d = to_xyz(seed_point)\n    principal_vectors_3d = [to_xyz(vec) for vec in principal_vectors]\n\n\n    #2) boundary sample points kdtree\n    sampled_boundary_pts = []\n    for crv in boundary_curves:\n        params = crv.DivideByCount(sample_count, True)\n        for t in params:\n            p = crv.PointAt(t)\n            sampled_boundary_pts.append([p.X, p.Y, p.Z])\n\n    if sampled_boundary_pts:\n        boundary_points_array = np.array(sampled_boundary_pts, dtype=float)\n        boundary_kdtree = KDTree(boundary_points_array)\n    else:\n        boundary_kdtree = None\n\n\n\n\n    # ----------------------------------------------------------------------\n    # CALL YOUR 3D PSL GENERATION FUNCTION\n    # ----------------------------------------------------------------------\n    all_psls, bridging_lines, positive_candidates = generate_all_psls_3d(\n        initial_seed_3d,\n        h,\n        num_steps,\n        k,\n        principal_vectors_3d,   \n        points_array_3d,        \n        kd_tree,\n        boundary_curves,\n        collision_threshold,\n        sample_interval,\n        offset_distance,\n        min_seed_distance\n    )\n\n\n\n    # ----------------------------------------------------------------------\n    # PREPARE OUTPUTS FOR GH\n    # ----------------------------------------------------------------------\n    # 1) PSL polylines as GH curves\n    psl_curves = [psl_curve for (psl_points, psl_curve) in all_psls]\n    generated_seed_points = [rg.Point3d(pc[0], pc[1], pc[2]) for pc in positive_candidates]\n\n    # 4) Finally set GH outputs (A, B, C, e.g.)\n    psl = tr.list_to_tree(psl_curves)\n    connect = tr.list_to_tree(bridging_lines)\n    valid_seeds = tr.list_to_tree(generated_seed_points)\n\n    return psl, connect, valid_seeds",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}