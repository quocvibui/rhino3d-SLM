{
  "source_url": "https://github.com/germanbodenbender/MACAD-AIA-GEO_OPT/blob/4127a5112369717b43c647b04d84d2cda485ac60/SESSION%2002-A02/A02.py",
  "repo": "germanbodenbender/MACAD-AIA-GEO_OPT",
  "repo_stars": 1,
  "repo_description": "Repository for the AIA-Geometry Optimization Seminar that includes all the exercises and tests done during the semester using Pytho, NetworkX, Numpy, Rhinoinside and Hops",
  "license": "unknown",
  "filepath": "SESSION 02-A02/A02.py",
  "instruction": "Provides a scripting component.\n    Inputs:\n        m: a mesh\n        s: sun vector\n    Output:\n        a: List of Vectors\n        b: List of Points\n        c: list of angles\n        d: exploded mesh",
  "code": "# MACAD // AIA + GEOMETRY OPTIMIZATION\n# GERMAN OTTO BODENBENDER\n# ASSIGNMENT 02 - 2021/04/11\n\n\n\"\"\"Provides a scripting component.\n    Inputs:\n        m: a mesh\n        s: sun vector\n    Output:\n        a: List of Vectors\n        b: List of Points\n        c: list of angles\n        d: exploded mesh\n        \"\"\"\n        \nimport Rhino\nimport Rhino.Geometry as rg\nimport Rhino.Render as rr\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.treehelpers as th \nimport math\n\n\n\n#1.\n#compute face normals using rg.Mesh.FaceNormals.ComputeFaceNormals()\n#output the vectors to a\n\nm.FaceNormals.ComputeFaceNormals()\na = m.FaceNormals \n\n\n\n\n\n#2.\n#get the centers of each faces using rg.Mesh.Faces.GetFaceCenter()\n#store the centers into a list called centers \n#output that list to b\n\nb = []\n\nvector3d = []\n\nfor i in range(len(a)):\n    x = m.Faces.GetFaceCenter(i)\n    vec = rg.Vector3d(x)\n    b.append(x)\n    vector3d.append(vec)\n\n#print(vec)\n\n\n#3.\n#calculate the angle between the sun and each FaceNormal using rg.Vector3d.VectorAngle()\n#store the angles in a list called angleList and output it to c\n\nsVec = Rhino.RhinoDoc.ActiveDoc.Lights.Sun.Vector\n\nc = []\nfor i in range(len(a)):\n    z = rg.Vector3d.VectorAngle(a[i], sVec)\n    c.append(z)\n\n\n\n#4. explode the mesh - convert each face of the mesh into a mesh\n#for this, you have to first copy the mesh using rg.Mesh.Duplicate()\n#then iterate through each face of the copy, extract it using rg.Mesh.ExtractFaces\n#and store the result into a list called exploded in output d\n\nexploded=[]\nmesh_copy = rg.Mesh.Duplicate(m)\n\nfor i in range(len(mesh_copy.Faces)):\n    extract_faces= mesh_copy.Faces.ExtractFaces([0])\n    exploded.append(extract_faces)\n\nd = exploded\n\n\n#z = meshduplicate.Faces.ExtractFaces([i])\n#after here, your task is to apply a transformation to each face of the mesh\n#the transformation should correspond to the angle value that corresponds that face to it... \n#the result should be a mesh that responds to the sun position... its up to you!\n\n\n\n#Create lines based on the normal and the lenght is based on the sun angle\nlines=[]\nfor i in range(len(m.Faces)):\n    line=rg.Line(b[i],a[i], c[i]/2)\n    lines.append(line)\n\n\n#Trying to get the mesh edges\np = d[1].GetNakedEdges()\n#Gives a polyline curve as a result\n\n\n\n#Trying to use the mesh edges to do a tapered extrude, but having the issue of \"1. Solution exception:expected Curve, got Polyline\"\nmesh_edges = []\nfor i in range(len(m.Faces)):\n    x = d[i].GetNakedEdges()\n    lnnurb = x[0].ToNurbsCurve()\n    mesh_edges.append(lnnurb)\n\n\n#Create offseted planes to use for the rectangules (FAILED)\n\"\"\"\nplane = []\nfor i in range(len(m.Faces)):\n\n    pl = rg.Plane(g[i],a[i])\n    h.append(plane)\n\"\"\"\n\n\n#Create Brep tapered  (FAILED)\n\"\"\"\nextrude = []\nfor i in range(len(m.Faces)):\n    ex = rg.Brep.CreateFromTaperedExtrude(mesh_edges[i], 0.1, vector3d[i], b[i], c[i], 0)\n    extrude.append(ex)\nbrep = th.list_to_tree(extrude)\n\"\"\"\n\n#Create mesh edges extrusion (FAILED)\n\"\"\"\nextrude = []\nfor i in range(len(m.Faces)):\n    ex = rg.Extrusion.Create(mesh_edges[i],0.3,True)\n    extrude.append(ex)\nbrep = th.list_to_tree(extrude)\n\"\"\"\n\n#Create pipe extrusion from lines and lenght based on sun vector\npipes = []\nfor i in range(len(lines)):\n    pi = rg.Brep.CreateFromSweep(rg.LineCurve(lines[i]),mesh_edges[i],True,0.1)\n    pipes.append(pi)\nexpipe = th.list_to_tree(pipes)\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}