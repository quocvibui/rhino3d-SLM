{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/read3dm.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/read3dm.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2018-2024 Nathan Letwory, Joel Putnam, Tom Svilans, Lukas Fertig\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport os.path\nimport bpy\nimport sys\nimport os\nfrom pathlib import Path\nfrom typing import Any, Dict, Set\n\n\ndef modules_path():\n    # set up addons/modules under the user\n    # script path. Here we'll install the\n    # dependencies\n    modulespath = os.path.normpath(\n        os.path.join(\n            bpy.utils.script_path_user(),\n            \"addons\",\n            \"modules\"\n        )\n    )\n    if not os.path.exists(modulespath):\n        os.makedirs(modulespath)\n\n    # set user modules path at beginning of paths for earlier hit\n    if sys.path[1] != modulespath:\n        sys.path.insert(1, modulespath)\n\n    return modulespath\n\nmodules_path()\n\n\nimport rhino3dm as r3d\nfrom . import converters\n\n\ndef create_or_get_top_layer(context, filepath):\n    top_collection_name = Path(filepath).stem\n    if top_collection_name in context.blend_data.collections.keys():\n        toplayer = context.blend_data.collections[top_collection_name]\n    else:\n        toplayer = context.blend_data.collections.new(name=top_collection_name)\n    return toplayer\n\n\ndef read_3dm(\n        context : bpy.types.Context,\n        options : Dict[str, Any]\n    )   -> Set[str]:\n\n    converters.initialize(context)\n\n    # Parse options\n    import_views = options.get(\"import_views\", False)\n    import_annotations = options.get(\"import_annotations\", False)\n    import_curves = options.get(\"import_curves\", False)\n    import_pointset = options.get(\"import_pointset\", False)\n    import_meshes = options.get(\"import_meshes\", False)\n    import_subd = options.get(\"import_subd\", False)\n    import_extrusions = options.get(\"import_extrusions\", False)\n    import_brep = options.get(\"import_brep\", False)\n    import_named_views = options.get(\"import_named_views\", False)\n    import_hidden_objects = options.get(\"import_hidden_objects\", False)\n    import_hidden_layers = options.get(\"import_hidden_layers\", False)\n    import_layers_as_empties = options.get(\"import_layers_as_empties\", False)\n    import_groups = options.get(\"import_groups\", False)\n    import_nested_groups = options.get(\"import_nested_groups\", False)\n    import_instances = options.get(\"import_instances\",False)\n    update_materials = options.get(\"update_materials\", False)\n\n    filepath : str = options.get(\"filepath\", \"\")\n    model = None\n\n    try:\n        model = r3d.File3dm.Read(filepath)\n    except:\n        print(\"Failed to import .3dm model: {}\".format(filepath))\n        return {'CANCELLED'}\n\n\n    # place model in context so we can access it when we need to\n    # find data from different tables, like for instance dimension\n    # styles while working on annotation import.\n    options[\"rh_model\"] = model\n\n    toplayer = create_or_get_top_layer(context, filepath)\n\n    # Get proper scale for conversion\n    scale = r3d.UnitSystem.UnitScale(model.Settings.ModelUnitSystem, r3d.UnitSystem.Meters) / context.scene.unit_settings.scale_length\n\n    layerids = {}\n    materials = {}\n\n    # Import Views and NamedViews\n    if import_views:\n        converters.handle_views(context, model, toplayer, model.Views, \"Views\", scale)\n    if import_named_views:\n        converters.handle_views(context, model, toplayer, model.NamedViews, \"NamedViews\", scale)\n\n    # Handle materials\n    converters.handle_materials(context, model, materials, update_materials)\n\n    # Handle layers\n    converters.handle_layers(context, model, toplayer, layerids, materials, update_materials, import_hidden_layers, import_layers_as_empties)\n    materials[converters.DEFAULT_RHINO_MATERIAL] = None\n\n    #build skeletal hierarchy of instance definitions as collections (will be populated by object importer)\n    if import_instances:\n        converters.handle_instance_definitions(context, model, toplayer, \"Instance Definitions\")\n\n    # Handle objects\n    ob : r3d.File3dmObject = None\n    for ob in model.Objects:\n        og : r3d.GeometryBase = ob.Geometry\n\n        # Skip unsupported object types early\n        if og.ObjectType not in converters.RHINO_TYPE_TO_IMPORT and og.ObjectType != r3d.ObjectType.InstanceReference:\n            print(\"Unsupported object type: {}\".format(og.ObjectType))\n            continue\n\n        if not import_curves and og.ObjectType == r3d.ObjectType.Curve:\n            continue\n        if not import_annotations and og.ObjectType == r3d.ObjectType.Annotation:\n            continue\n        if not import_pointset and og.ObjectType == r3d.ObjectType.PointSet:\n            continue\n        if not import_brep and og.ObjectType == r3d.ObjectType.Brep:\n            continue\n        if not import_extrusions and og.ObjectType == r3d.ObjectType.Extrusion:\n            continue\n        if not import_subd and og.ObjectType == r3d.ObjectType.SubD:\n            continue\n        if not import_meshes and og.ObjectType == r3d.ObjectType.Mesh:\n            continue\n\n\n        # Check object visibility\n        attr = ob.Attributes\n        if not attr.Visible and not import_hidden_objects:\n            continue\n\n        # Check object layer visibility\n        rhinolayer = model.Layers.FindIndex(attr.LayerIndex)\n        if not rhinolayer.Visible and not import_hidden_layers:\n            continue\n\n        # Create object name if none exists or it is an empty string.\n        # Otherwise use the name from the 3dm file.\n        if attr.Name == \"\" or attr.Name is None:\n            object_name = str(og.ObjectType).split(\".\")[1]+\" \" + str(attr.Id)\n        else:\n            object_name = attr.Name\n\n        # Get render material, either from object. or if MaterialSource\n        # is set to MaterialFromLayer, from the layer.\n        mat_index = attr.MaterialIndex\n        if attr.MaterialSource == r3d.ObjectMaterialSource.MaterialFromLayer:\n            mat_index = rhinolayer.RenderMaterialIndex\n        rhino_material = model.Materials.FindIndex(mat_index)\n\n        # Get material name. In case of the Rhino default material use\n        # DEFAULT_RHINO_MATERIAL, otherwise compute a name from the material\n        # so that it is fit for Blender usage.\n        if mat_index == -1 or rhino_material.Name == \"\":\n            matname = converters.material.DEFAULT_RHINO_MATERIAL\n        else:\n            matname = converters.material_name(rhino_material)\n\n        # Handle object view color\n        if ob.Attributes.ColorSource == r3d.ObjectColorSource.ColorFromLayer:\n            view_color = rhinolayer.Color\n        else:\n            view_color = ob.Attributes.ObjectColor\n\n        # Get the corresponding Blender material based on the material name\n        # from the material dictionary\n        if matname not in materials.keys():\n            matname = converters.material.DEFAULT_RHINO_MATERIAL\n        blender_material = materials[matname]\n        if og.ObjectType == r3d.ObjectType.Annotation:\n            blender_material = materials[converters.material.DEFAULT_TEXT_MATERIAL]\n\n        # Fetch layer\n        layer = layerids[str(rhinolayer.Id)][1]\n\n        if og.ObjectType==r3d.ObjectType.InstanceReference and import_instances:\n            object_name = model.InstanceDefinitions.FindId(og.ParentIdefId).Name\n\n        # Convert object\n        converters.convert_object(context, ob, object_name, layer, blender_material, view_color, scale, options)\n\n        if import_groups:\n            converters.handle_groups(context,attr,toplayer,import_nested_groups)\n\n    if import_instances:\n        converters.populate_instance_definitions(context, model, toplayer, \"Instance Definitions\", options, scale)\n\n    # finally link in the container collection (top layer) into the main\n    # scene collection.\n    if toplayer.name not in context.scene.collection.children:\n        context.scene.collection.children.link(toplayer)\n    if bpy.app.version[0] < 4:\n        bpy.ops.object.shade_smooth({'selected_editable_objects': toplayer.all_objects})\n    else:\n        with context.temp_override(selected_editable_objects=toplayer.all_objects):\n            bpy.ops.object.shade_smooth()\n\n    converters.cleanup()\n\n    return {'FINISHED'}\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}