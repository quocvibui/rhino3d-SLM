{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_retrimAllFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_retrimAllFaces.py",
  "instruction": "This script uses Brep.CutUpSurface and optionally BrepFace.RebuildEdges\r\n(before 1st CutUpSurface) to attempt to retrim all faces of a brep individually\r\nto simplify edge curves and BrepTrim...",
  "code": "\"\"\"\r\nThis script uses Brep.CutUpSurface and optionally BrepFace.RebuildEdges\r\n(before 1st CutUpSurface) to attempt to retrim all faces of a brep individually\r\nto simplify edge curves and BrepTrim curves.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250327-28,30: Created.\r\n250603: Bug fixes.\r\n251001: Bug fixes. Refactored. Added a command option. Added more printed output, debug and not debug.\r\n\r\nuseEdgeCurves\r\nFrom https://developer.rhino3d.com/api/rhinocommon/rhino.geometry.brep/cutupsurface :\r\nThe 2D trimming curves are made by pulling back the 3D curves using the fitting tolerance.\r\nIf useEdgeCurves is true, the input 3D curves will be used as the edge curves in the result.\r\nOtherwise, the edges will come from pushing up the 2D pullbacks.\r\n\r\nRestated:\r\nuseEdgeCurves is True: Use input curves as the edge curves\r\nuseEdgeCurves is False: Generate new edge curves from the newly created BrepTrim curves.\r\n\r\nTODO:\r\n    Try tighter tolerances on trim fails.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fTol_Edge_and_trim'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'EdgeAndTrimTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'fTol_Join'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'JoinTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bRebuildEdges'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bStartingCrvs_Edge_not_UV'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'StartingCrvs'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'UV', 'Edge')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryShrinkOnFail'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryExtendOnFail'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTryOtherTolsOnFail'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    #key = 'bUntrimFailedFaces'; keys.append(key)\r\n    #values[key] = True\r\n    #names[key] = 'FailedTrimFaces'\r\n    #riOpts[key] = ri.Custom.OptionToggle(values[key], 'InputFace', 'Untrim')\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'OutputBrep'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fTol_Edge_and_trim':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n            return\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getInput(bDebug=False):\r\n    \"\"\"\r\n    Get breps.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    \r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Brep\r\n\r\n    #go.AcceptNumber(True, acceptZero=False)\r\n    go.EnableClearObjectsOnEntry(False) # If not set to False, faces will be unselected when result == ri.GetResult.Object \r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fTol_Edge_and_trim')\r\n        addOption('fTol_Join')\r\n        addOption('bRebuildEdges')\r\n        if Opts.values['bRebuildEdges']:\r\n            addOption('bStartingCrvs_Edge_not_UV')\r\n        addOption('bTryShrinkOnFail')\r\n        addOption('bTryExtendOnFail')\r\n        addOption('bTryOtherTolsOnFail')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTol_Edge_and_trim'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef createBrepOfUntrimmedFace(rgFace_In):\r\n    rgB_Out = rgFace_In.DuplicateSurface().ToBrep()\r\n    rgB_Out.Faces[0].PerFaceColor = rgFace_In.PerFaceColor\r\n    return rgB_Out\r\n\r\n\r\ndef _areaComp(rgBrep, fAreaRef, fDeltaTol, bDebug=False):\r\n    \"\"\"\r\n    fDeltaTol: 0.01 means 1% tolerance\r\n    \"\"\"\r\n    fArea_New = rgBrep.GetArea() # Value is 0.0, not None, for no area compute.\r\n    if not fArea_New:\r\n        return False, None\r\n    relDiff = (abs(fAreaRef-fArea_New)/max((fAreaRef, fArea_New)))\r\n    if bDebug: sEval = \"relDiff\"; print(sEval,'=',eval(sEval))\r\n    return relDiff <= fDeltaTol\r\n\r\n\r\ndef cutUpSurface(surface, curves, useEdgeCurves, tolerance, fAreaRef, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n    Returns:\r\n        (rg.Brep, None) on success\r\n        (None, str(Fail label)) on fail\r\n    \"\"\"\r\n\r\n    if bDebug:\r\n        print(\"cutUpSurface:\")\r\n\r\n    breps_Res = rg.Brep.CutUpSurface(\r\n        surface=surface,\r\n        curves=curves,\r\n        useEdgeCurves=useEdgeCurves,\r\n        tolerance=tolerance)\r\n\r\n    if len(breps_Res) == 0:\r\n        #raise Exception(\"No result of CutUpSurface for duplicated face.\")\r\n        return None, 'CutUpSrfFail'\r\n\r\n    if len(breps_Res) > 1:\r\n        for _ in breps_Res: _.Dispose()\r\n        return None, 'MultiRes'\r\n        #[sc.doc.Objects.AddBrep(b) for b in breps_Res]\r\n        #print(\"Multiple breps from CutUpSurface. They were added to model.\")\r\n        #sc.doc.Views.Redraw()\r\n        #CutUpSrfFail.append(iF)\r\n        #return\r\n\r\n    rgB_1F_Out = breps_Res[0]\r\n\r\n    if not rgB_1F_Out.IsValid:\r\n        rgB_1F_Out.Dispose()\r\n        return None, 'InvalidRes'\r\n\r\n    #sc.doc.Objects.AddBrep(rgB_1F_Out); sc.doc.Views.Redraw(); 1/0\r\n\r\n    bAreaPass = _areaComp(\r\n        rgB_1F_Out, fAreaRef=fAreaRef, fDeltaTol=0.05, bDebug=bDebug)\r\n\r\n    if not bAreaPass:\r\n        rgB_1F_Out.Dispose()\r\n        return None, 'AreaFail'\r\n\r\n    return rgB_1F_Out, None\r\n\r\n\r\ndef _extendSrf(srf_In, extensionLength):\r\n    if srf_In.IsClosed(0) and srf_In.IsClosed(1):\r\n        return\r\n\r\n    bModified = False\r\n    srf_WIP = srf_In.Duplicate()\r\n\r\n    if not srf_In.IsClosed(0):\r\n        rv = srf_WIP.Extend(\r\n            edge=rg.IsoStatus.West,\r\n            extensionLength=extensionLength,\r\n            smooth=True)\r\n        if rv:\r\n            srf_WIP.Dispose()\r\n            srf_WIP = rv\r\n            bModified = True\r\n        rv = srf_WIP.Extend(\r\n            edge=rg.IsoStatus.East,\r\n            extensionLength=extensionLength,\r\n            smooth=True)\r\n        if rv:\r\n            srf_WIP.Dispose()\r\n            srf_WIP = rv\r\n            bModified = True\r\n\r\n    if not srf_In.IsClosed(1):\r\n        rv = srf_WIP.Extend(\r\n            edge=rg.IsoStatus.South,\r\n            extensionLength=extensionLength,\r\n            smooth=True)\r\n        if rv:\r\n            srf_WIP.Dispose()\r\n            srf_WIP = rv\r\n            bModified = True\r\n        rv = srf_WIP.Extend(\r\n            edge=rg.IsoStatus.North,\r\n            extensionLength=extensionLength,\r\n            smooth=True)\r\n        if rv:\r\n            srf_WIP.Dispose()\r\n            srf_WIP = rv\r\n            bModified = True\r\n    return srf_WIP\r\n\r\n\r\ndef ncptct(crv):\r\n    nc = crv.ToNurbsCurve()\r\n    ct = nc.Points.Count\r\n    nc.Dispose()\r\n    return ct\r\n\r\n\r\ndef _createCurvesFromEdges(brep, minLength=None, bDebug=False):\r\n    if minLength is None: minLength = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    curves_forCUS = []\r\n    for iE in brep.Faces[0].AdjacentEdges():\r\n        edge = brep.Edges[iE]\r\n        length = rg.Curve.GetLength(edge) # Zero on failure.\r\n        if length == 0:\r\n            continue\r\n        if length < minLength:\r\n            if bDebug: print(\"Skipped {}-long curve.\".format(length))\r\n            continue\r\n        curve = edge.DuplicateCurve()\r\n        curves_forCUS.append(curve)\r\n    return curves_forCUS\r\n\r\n\r\ndef _retrimFace(rgFace_In, fTol_Edge_and_trim, bRebuildEdges, bStartingCrvs_Edge_not_UV, bTryShrinkOnFail, bTryExtendOnFail, bTryOtherTolsOnFail, bDebug=False):\r\n    \"\"\"\r\n    Returns tuple of 2:\r\n        rg.Brep (Just a duplicate of face when the retrim fails.)\r\n        None on success, str on fail\r\n    \"\"\"\r\n\r\n    rgBs_1F = [rgFace_In.DuplicateFace(duplicateMeshes=False)]\r\n    # rgBs_1F  [0] is DuplicateFace of rgFace_In.  The rest are mods/WIPs.\r\n\r\n    if bDebug:\r\n        print(\"_retrimFace:\")\r\n        sEval = \"sum([ncptct(rgE) for rgE in rgBs_1F[0].Edges])\"; print(sEval,'=',eval(sEval))\r\n        sEval = \"sum([ncptct(rgT) for rgT in rgBs_1F[0].Trims])\"; print(sEval,'=',eval(sEval))\r\n\r\n    if bRebuildEdges and not bStartingCrvs_Edge_not_UV:\r\n        rgBs_1F.append(rgBs_1F[0].DuplicateBrep())\r\n        bRebuilt = rgBs_1F[-1].Faces[0].RebuildEdges(\r\n            tolerance=fTol_Edge_and_trim,\r\n            rebuildSharedEdges=True,\r\n            rebuildVertices=True)\r\n\r\n        if bDebug:\r\n            sEval = \"bRebuilt\"; print(sEval,'=',eval(sEval))\r\n            sEval = \"sum([ncptct(rgE) for rgE in rgBs_1F[-1].Edges])\"; print(sEval,'=',eval(sEval))\r\n            sEval = \"sum([ncptct(rgT) for rgT in rgBs_1F[-1].Trims])\"; print(sEval,'=',eval(sEval))\r\n\r\n    if bDebug: print(\"\\n## Phase 1 (P1)\")\r\n\r\n    area_In = rgBs_1F[-1].GetArea()\r\n    if not area_In:\r\n        for brep in rgBs_1F[:-1]: brep.Dispose()\r\n        return rgBs_1F[-1], 'AreaFail'\r\n\r\n    curves_forCUS = _createCurvesFromEdges(rgBs_1F[-1])\r\n    #[sc.doc.Objects.AddCurve(c) for c in curves_forCUS]\r\n\r\n    rgB_1F_Res_P1, sFailType = cutUpSurface(\r\n        surface=rgBs_1F[0].Faces[0].UnderlyingSurface(),\r\n        curves=curves_forCUS,\r\n        useEdgeCurves=not(bRebuildEdges and bStartingCrvs_Edge_not_UV),\r\n        tolerance=fTol_Edge_and_trim,\r\n        fAreaRef=area_In,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    # useEdgeCurves conditional explained:\r\n    #    bRebuildEdges bStartingCrvs_Edge_not_UV : result\r\n    #    T T (Start with edges) : F (Use edges pushed up from new BrepTrims.)\r\n    #    T F (Start with trims) : T (Use provided curves as edges. curves are resultant edges of BrepFace.RebuildEdges of input BrepFace (not CutUpSurface output).)\r\n    #    F T (Start with edges) : T (Use provided curves as edges. curves are edges of input BrepFace.)\r\n    #    F F (Start with trims) : T (Use provided curves as edges. curves are edges of input BrepFace.)\r\n\r\n\r\n    if not rgB_1F_Res_P1:\r\n        if not (bTryShrinkOnFail or bTryExtendOnFail):\r\n            for brep in rgBs_1F[:-1]: brep.Dispose()\r\n            return rgBs_1F[-1], sFailType\r\n\r\n\r\n        def try_cutUpSurface_on_modified_srf():\r\n\r\n            rgB_1F_WIP = rgBs_1F[-1].Duplicate()\r\n\r\n            if bTryShrinkOnFail:\r\n                if rgB_1F_WIP.Faces[0].ShrinkFace(\r\n                    disableSide=rg.BrepFace.ShrinkDisableSide.ShrinkAllSides\r\n                ):\r\n                    rgB_1F_Res_P1, _ = cutUpSurface(\r\n                        surface=rgB_1F_WIP.Faces[0].UnderlyingSurface(),\r\n                        curves=curves_forCUS,\r\n                        useEdgeCurves=True,\r\n                        tolerance=fTol_Edge_and_trim,\r\n                        fAreaRef=area_In,\r\n                        bDebug=bDebug,\r\n                        )\r\n                    if rgB_1F_Res_P1:\r\n                        rgB_1F_WIP.Dispose()\r\n                        return rgB_1F_Res_P1\r\n\r\n            if not bTryExtendOnFail:\r\n                rgB_1F_WIP.Dispose()\r\n                return\r\n\r\n            rgS_Extended = _extendSrf(\r\n                rgB_1F_WIP.Faces[0].UnderlyingSurface(),\r\n                10.0*fTol_Edge_and_trim)\r\n\r\n            rgB_1F_WIP.Dispose()\r\n\r\n            if rgS_Extended is None:\r\n                return \r\n\r\n            rgB_1F_Res_P1, _ = cutUpSurface(\r\n                surface=rgS_Extended,\r\n                curves=curves_forCUS,\r\n                useEdgeCurves=True,\r\n                tolerance=fTol_Edge_and_trim,\r\n                fAreaRef=area_In,\r\n                bDebug=bDebug,\r\n                )\r\n            if rgB_1F_Res_P1:\r\n                return rgB_1F_Res_P1\r\n\r\n        rgB_1F_Res_P1 = try_cutUpSurface_on_modified_srf()\r\n        if not rgB_1F_Res_P1:\r\n            for brep in rgBs_1F[:-1]: brep.Dispose()\r\n            return rgBs_1F[-1], sFailType\r\n\r\n    if bDebug:\r\n        sEval = \"sum([ncptct(rgE) for rgE in rgB_1F_Res_P1.Edges])\"; print(sEval,'=',eval(sEval))\r\n        sEval = \"sum([ncptct(rgT) for rgT in rgB_1F_Res_P1.Trims])\"; print(sEval,'=',eval(sEval))\r\n\r\n    if rgBs_1F[0].Faces[0].PerFaceColor is not None:\r\n        rgB_1F_Res_P1.Faces[0].PerFaceColor = rgBs_1F[0].Faces[0].PerFaceColor\r\n\r\n\r\n    # Postpone Phase 2 until further investigation seems warranted.\r\n\r\n    for brep in rgBs_1F: brep.Dispose()\r\n    return rgB_1F_Res_P1, None\r\n\r\n\r\n\r\n    if not bRebuilt:\r\n        for brep in rgBs_1F: brep.Dispose()\r\n        return rgB_1F_Res_P1, None\r\n\r\n\r\n    if bDebug: print(\"\\n## Phase 2: cutUpSurface the result of Phase 1 to attempt to further simplify BrepTrim curves.\")\r\n\r\n    rgF_Res_P1 = rgB_1F_Res_P1.Faces[0]\r\n    rgS_Res_P1 = rgF_Res_P1.UnderlyingSurface()\r\n    rgCs_Res_P1 = [rgB_1F_Res_P1.Edges[iE].DuplicateCurve() for iE in rgF_Res_P1.AdjacentEdges()]\r\n\r\n    rgB_1F_Res_P2, sFailType = cutUpSurface(\r\n        surface=rgS_Res_P1,\r\n        curves=rgCs_Res_P1,\r\n        useEdgeCurves=True,\r\n        tolerance=fTol_Edge_and_trim,\r\n        fAreaRef=area_In,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if rgB_1F_Res_P2 is None:\r\n        sc.doc.Objects.AddBrep(rgB_1F_Res_P1)\r\n        raise Exception(\"Phase 2 failure. Phase 1 result was added.\")\r\n        #return rgB_1Face, 'CutUpSrfFail'\r\n\r\n    rgB_1F_Res_P1.Dispose()\r\n\r\n    if rgBs_1F[0].Faces[0].PerFaceColor is not None:\r\n        rgB_1F_Res_P2.Faces[0].PerFaceColor = rgBs_1F[0].Faces[0].PerFaceColor\r\n\r\n    if bDebug:\r\n        sEval = \"sum([ncptct(rgE) for rgE in rgB_1F_Res_P2.Edges])\"; print(sEval,'=',eval(sEval))\r\n        sEval = \"sum([ncptct(rgT) for rgT in rgB_1F_Res_P2.Trims])\"; print(sEval,'=',eval(sEval))\r\n\r\n    return rgB_1F_Res_P2, None\r\n\r\n\r\ndef processBrepObject(rdBrep, fTol_Edge_and_trim, fTol_Join, bRebuildEdges, bStartingCrvs_Edge_not_UV, bTryShrinkOnFail, bTryExtendOnFail, bTryOtherTolsOnFail, bReplace, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rdB_Full_In = rdBrep\r\n    rgB_Full_In = rdB_Full_In.BrepGeometry\r\n\r\n    #if rgB_Full_In.Faces.Count == 1:\r\n    #    rdBs_1F = [rdB_Full_In]\r\n    #else:\r\n    #    rdBs_1F = rdB_Full_In.GetSubObjects()\r\n    #    if not rdBs_1F:\r\n    #        print(\"No GetSubObjects result for {}.\".format(rdB_Full_In.Id))\r\n    #        return\r\n\r\n    rgBs_1F_Res = []\r\n    rgBs_toManuallyRetrim = []\r\n\r\n    dict_iFs = {\r\n        'Success': [],\r\n        'AreaFail': [],\r\n        'CutUpSrfFail': [],\r\n        'MultiRes': [],\r\n        'InvalidRes': [],\r\n        }\r\n\r\n\r\n    #sLogs = []\r\n\r\n\r\n    nCPs_Es_Pre = nCPs_Es_Post = nCPs_Ts_Pre = nCPs_Ts_Post = 0\r\n    nEs_Pre = nEs_Post = nTs_Pre = nTs_Post = 0\r\n\r\n    iDivision = 20\r\n    iFs_atDivision = [int(round((1.0/iDivision)*i*rgB_Full_In.Faces.Count,0)) for i in range(iDivision)]\r\n    iCounter = 0\r\n\r\n    for iF, rgF_In in enumerate(rgB_Full_In.Faces):\r\n        sc.escape_test()\r\n        Rhino.RhinoApp.Wait()\r\n\r\n        if rgB_Full_In.Faces.Count == 1:\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\"Processing face...\")\r\n        elif rgB_Full_In.Faces.Count < iDivision:\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\r\n                \"Processing face {} of {} ({}% complete)...\".format(\r\n                    iF+1,\r\n                    rgB_Full_In.Faces.Count,\r\n                    int(100*(iF+1)/rgB_Full_In.Faces.Count),\r\n                    ))\r\n        elif iF in iFs_atDivision:\r\n            iCounter += 1\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\r\n                \"Processing face {} of {} ({}% complete)...\".format(\r\n                    iF+1,\r\n                    rgB_Full_In.Faces.Count,\r\n                    int(100*(iF+1)/rgB_Full_In.Faces.Count),\r\n                    ))\r\n            #Rhino.RhinoApp.SetCommandPromptMessage(\r\n            #    \"Processing face {} of {}...\".format(iF+1, rgB_Full_In.Faces.Count))\r\n\r\n        rgB_1F_Res, sFailType = _retrimFace(\r\n            rgF_In,\r\n            fTol_Edge_and_trim=fTol_Edge_and_trim,\r\n            bRebuildEdges=bRebuildEdges,\r\n            bStartingCrvs_Edge_not_UV=bStartingCrvs_Edge_not_UV,\r\n            bTryShrinkOnFail=bTryShrinkOnFail,\r\n            bTryExtendOnFail=bTryExtendOnFail,\r\n            bTryOtherTolsOnFail=bTryOtherTolsOnFail,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if sFailType:\r\n            rgBs_toManuallyRetrim.append(rgB_1F_Res)\r\n            #rgBs_toManuallyTrim.append(createBrepOfUntrimmedFace(rgF_In))\r\n            #rdB_1F.Dispose()\r\n            dict_iFs[sFailType].append(iF)\r\n            continue\r\n\r\n        rgBs_1F_Res.append(rgB_1F_Res)\r\n        dict_iFs['Success'].append(iF)\r\n\r\n        nCPs_Es_Pre += sum([ncptct(rgB_Full_In.Edges[iE]) for iE in rgF_In.AdjacentEdges()])\r\n        nCPs_Es_Post += sum([ncptct(rgE) for rgE in rgB_1F_Res.Edges])\r\n        nCPs_Ts_Pre += sum([ncptct(rgB_Full_In.Trims[rgT.TrimIndex]) for rgL in rgF_In.Loops for rgT in rgL.Trims])\r\n        nCPs_Ts_Post += sum([ncptct(rgT) for rgT in rgB_1F_Res.Trims])\r\n\r\n        nEs_Pre += rgF_In.AdjacentEdges().Count\r\n        nEs_Post += rgB_1F_Res.Edges.Count\r\n        nTs_Pre += sum([loop.Trims.Count for loop in rgF_In.Loops])\r\n        nTs_Post += rgB_1F_Res.Trims.Count\r\n\r\n\r\n    if len(rgBs_1F_Res) == 0:\r\n        pass\r\n    elif len(rgBs_1F_Res) == 1:\r\n        if bReplace:\r\n            sc.doc.Objects.Replace(\r\n                objectId=rdB_Full_In.Id,\r\n                brep=rgBs_1F_Res[0])\r\n        else:\r\n            sc.doc.Objects.AddBrep(\r\n                rgBs_1F_Res[0]\r\n                )\r\n    else:\r\n        breps_Joined = rg.Brep.JoinBreps(\r\n            brepsToJoin=rgBs_1F_Res,\r\n            tolerance=fTol_Join)\r\n        \r\n        if len(breps_Joined) == 0:\r\n            raise Exception(\"No result from JoinBreps.\")\r\n        if len(breps_Joined) > 1:\r\n            print(\"Multiple breps output of JoinBreps.\")\r\n            gB_Outs = [\r\n                sc.doc.Objects.AddBrep(\r\n                    brep_Joined, attributes=rdB_Full_In.Attributes)\r\n                    for brep_Joined in breps_Joined]\r\n            if bReplace and not any([gB_Out == Guid.Empty for gB_Out in gB_Outs]):\r\n                sc.doc.Objects.Delete(obj=rdB_Full_In, quiet=False)\r\n        else:\r\n            if bReplace:\r\n                sc.doc.Objects.Replace(\r\n                    objectId=rdB_Full_In.Id,\r\n                    brep=breps_Joined[0])\r\n            else:\r\n                sc.doc.Objects.AddBrep(\r\n                    breps_Joined[0]\r\n                    )\r\n\r\n    gB_toManuallyTrim = [\r\n        sc.doc.Objects.AddBrep(\r\n            rgB, attributes=rdB_Full_In.Attributes) for rgB in rgBs_toManuallyRetrim]\r\n    if gB_toManuallyTrim:\r\n        if not all(gB==Guid.Empty for gB in gB_toManuallyTrim):\r\n            print(\"Added {} untrimmed faces. Trim this manually.\".format(\r\n                len(gB_toManuallyTrim) - gB_toManuallyTrim.count(Guid.Empty)))\r\n        if Guid.Empty in gB_toManuallyTrim:\r\n            print(\"{} surfaces could not be added. Check results.\".format(\r\n                gB_toManuallyTrim.count(Guid.Empty)))\r\n\r\n    print(\"Retrimmed {} out of {} faces.\".format(\r\n        len(dict_iFs['Success']), rgB_Full_In.Faces.Count))\r\n    for key in 'AreaFail', 'CutUpSrfFail', 'MultiRes', 'InvalidRes':\r\n        if dict_iFs[key]:\r\n            print(\"{}: {}\".format(key, len(dict_iFs[key])))\r\n    #print(\"Trim fail count: {}\".format(\r\n    #    len(dict_iFs['CutUpSrfFail'])))\r\n    #print(\"Invalid brep result (skipped) count: {}\".format(\r\n    #    len(dict_iFs['InvalidRes'])))\r\n    #if sLogs:\r\n    #    print(\"Logs of invalid breps:\")\r\n    #    print(*sLogs)\r\n\r\n    if nEs_Post != nEs_Pre:\r\n        print(\"Edge count (for individual faces (exploded polysrf)): {} -> {}, Delta {:+}.\".format(\r\n            nEs_Pre,\r\n            nEs_Post,\r\n            nEs_Post-nEs_Pre))\r\n    else:\r\n        print(\"Edge CP count (for individual faces (exploded polysrf)): {} -> {}, Delta {:+}.\".format(\r\n            nCPs_Es_Pre,\r\n            nCPs_Es_Post,\r\n            nCPs_Es_Post-nCPs_Es_Pre))\r\n\r\n    if nTs_Post != nTs_Pre:\r\n        print(\"Trim count: {} -> {}, Delta {:+}.\".format(\r\n            nTs_Pre,\r\n            nTs_Post,\r\n            nTs_Post-nTs_Pre))\r\n    else:\r\n        print(\"Trim CP count: {} -> {}, Delta {:+}.\".format(\r\n            nCPs_Ts_Pre,\r\n            nCPs_Ts_Post,\r\n            nCPs_Ts_Post-nCPs_Ts_Pre))\r\n\r\n\r\ndef main():\r\n    \r\n    #res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n    #    \"Select breps\",\r\n    #    acceptNothing=False,\r\n    #    filter=rd.ObjectType.Brep)\r\n    #if res != Rhino.Commands.Result.Success: return\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fTol_Edge_and_trim = Opts.values['fTol_Edge_and_trim']\r\n    fTol_Join = Opts.values['fTol_Join']\r\n    bRebuildEdges = Opts.values['bRebuildEdges']\r\n    bStartingCrvs_Edge_not_UV = Opts.values['bStartingCrvs_Edge_not_UV']\r\n    bTryShrinkOnFail = Opts.values['bTryShrinkOnFail']\r\n    bTryExtendOnFail = Opts.values['bTryExtendOnFail']\r\n    bTryOtherTolsOnFail = Opts.values['bTryOtherTolsOnFail']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n    \r\n    for objref in objrefs:\r\n        rdBrep_In = objref.Object()\r\n        processBrepObject(\r\n            rdBrep_In,\r\n            fTol_Edge_and_trim=fTol_Edge_and_trim,\r\n            fTol_Join=fTol_Join,\r\n            bRebuildEdges=bRebuildEdges,\r\n            bStartingCrvs_Edge_not_UV=bStartingCrvs_Edge_not_UV,\r\n            bTryShrinkOnFail=bTryShrinkOnFail,\r\n            bTryExtendOnFail=bTryExtendOnFail,\r\n            bTryOtherTolsOnFail=bTryOtherTolsOnFail,\r\n            bReplace=bReplace,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}