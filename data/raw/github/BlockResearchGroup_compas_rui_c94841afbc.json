{
  "source_url": "https://github.com/BlockResearchGroup/compas_rui/blob/16ceee4528ba6725f6f73b3a001850ff7ad91f8a/src/compas_rui/scene/meshobject.py",
  "repo": "BlockResearchGroup/compas_rui",
  "repo_stars": 1,
  "repo_description": "Collection of components to build graphical user interfaces (GUIs) in Rhino 8 for COMPAS packages.",
  "license": "NOASSERTION",
  "filepath": "src/compas_rui/scene/meshobject.py",
  "instruction": "Meshobject",
  "code": "from typing import Optional\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs  # type: ignore\n\nimport compas_rhino.conversions\nimport compas_rhino.objects\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas.itertools import flatten\nfrom compas_rhino.scene import RhinoMeshObject\nfrom compas_rui.forms import NamedValuesForm\n\n\nclass RUIMeshObject(RhinoMeshObject):\n    mesh: Mesh  # type: ignore\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Select\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    def select_vertices(self, message=\"Select Vertices\", use_edges=True) -> Optional[list[int]]:\n        if use_edges:\n            options = [\"All\", \"Boundary\", \"Degree\", \"EdgeLoop\", \"Manual\"]\n        else:\n            options = [\"All\", \"Boundary\", \"Degree\", \"Manual\"]\n\n        option = rs.GetString(message=message, strings=options)\n\n        if option == \"All\":\n            vertices = self.select_vertices_all()\n\n        elif option == \"Boundary\":\n            vertices = self.select_vertices_boundary()\n\n        elif option == \"Degree\":\n            vertices = self.select_vertices_degree()\n\n        elif option == \"EdgeLoop\":\n            vertices = self.select_vertices_edgeloop()\n\n        elif option == \"Manual\":\n            vertices = self.select_vertices_manual(message)\n\n        else:\n            return\n\n        vertex_guid = {vertex: guid for guid, vertex in self._guid_vertex.items()}\n        guids = [vertex_guid[vertex] for vertex in vertices if vertex in vertex_guid]\n\n        rs.UnselectAllObjects()\n        rs.SelectObjects(guids)\n\n        return vertices  # type: ignore\n\n    def select_vertices_all(self):\n        return list(self.mesh.vertices())\n\n    def select_vertices_boundary(self):\n        return list(set(flatten(self.mesh.vertices_on_boundaries())))\n\n    def select_vertices_degree(self):\n        D = rs.GetInteger(message=\"Vertex Degree\", number=2, minimum=1)\n        D = D or 0\n        vertices = list(self.mesh.vertices_where(vertex_degree=D))\n        return vertices\n\n    def select_vertices_edgeloop(self):\n        guids = compas_rhino.objects.select_lines(message=\"Select Loop Edges\")\n        edges = [self._guid_edge[guid] for guid in guids if guid in self._guid_edge] if guids else []\n        temp = []\n        for edge in edges:\n            for u, v in self.mesh.edge_loop(edge):\n                temp.append(u)\n                temp.append(v)\n        vertices = list(set(temp))\n        return vertices\n\n    def select_vertices_edgestrip(self):\n        raise NotImplementedError\n\n    def select_vertices_manual(self, message=\"Select Vertices\"):\n        guids = compas_rhino.objects.select_points(message=message)\n        vertices = [self._guid_vertex[guid] for guid in guids if guid in self._guid_vertex] if guids else []\n        return vertices\n\n    def select_edges(self, message=\"Select Edges\") -> Optional[list[tuple[int, int]]]:\n        options = [\"All\", \"Boundary\", \"EdgeLoop\", \"EdgeStrip\", \"Manual\"]\n        option = rs.GetString(message=message, strings=options)\n\n        if option == \"All\":\n            edges = self.select_edges_all()\n\n        elif option == \"Boundary\":\n            edges = self.select_edges_boundary()\n\n        elif option == \"EdgeLoop\":\n            edges = self.select_edges_loop()\n\n        elif option == \"EdgeStrip\":\n            edges = self.select_edges_strip()\n\n        elif option == \"Manual\":\n            edges = self.select_edges_manual(message)\n\n        else:\n            return\n\n        edges = [(u, v) if self.mesh.has_edge((u, v)) else (v, u) for u, v in edges]\n        edge_guid = {edge: guid for guid, edge in self._guid_edge.items()}\n        guids = [edge_guid[edge] for edge in edges if edge in edge_guid]\n\n        rs.UnselectAllObjects()\n        rs.SelectObjects(guids)\n\n        return edges  # type: ignore\n\n    def select_edges_all(self):\n        return list(self.mesh.edges())\n\n    def select_edges_boundary(self):\n        return list(set(flatten(self.mesh.edges_on_boundaries())))\n\n    def select_edges_loop(self):\n        guids = compas_rhino.objects.select_lines(message=\"Select Loop Edges\")\n        edges = []\n        for guid in guids:\n            edge = self._guid_edge[guid]\n            for edge in self.mesh.edge_loop(edge):\n                edges.append(edge)\n        return edges\n\n    def select_edges_strip(self):\n        guids = compas_rhino.objects.select_lines(message=\"Select Strip Edges\")\n        edges = []\n        for guid in guids:\n            edge = self._guid_edge[guid]\n            for edge in self.mesh.edge_strip(edge):\n                edges.append(edge)\n        return edges\n\n    def select_edges_manual(self, message=\"Select Edges\"):\n        guids = compas_rhino.objects.select_lines(message=message)\n        edges = [self._guid_edge[guid] for guid in guids if guid in self._guid_edge] if guids else []\n        return edges\n\n    def select_faces(self, message=\"Select Faces\") -> Optional[list[int]]:\n        options = [\"All\", \"Boundary\", \"Strip\", \"Manual\"]\n        option = rs.GetString(message=message, strings=options)\n\n        if option == \"All\":\n            faces = self.select_faces_all()\n\n        elif option == \"Boundary\":\n            faces = self.select_faces_boundary()\n\n        elif option == \"Strip\":\n            faces = self.select_faces_strip()\n\n        elif option == \"Manual\":\n            faces = self.select_faces_manual()\n\n        else:\n            return\n\n        face_guid = {face: guid for guid, face in self._guid_face.items()}\n        guids = [face_guid[face] for face in faces]\n\n        rs.UnselectAllObjects()\n        rs.SelectObjects(guids)\n\n        return faces  # type: ignore\n\n    def select_faces_all(self):\n        return list(self.mesh.faces())\n\n    def select_faces_boundary(self):\n        return list(set(flatten(self.mesh.faces_on_boundaries())))\n\n    def select_faces_strip(self):\n        raise NotImplementedError\n\n    def select_faces_manual(self):\n        guids = compas_rhino.objects.select_meshes(message=\"Select Faces\")\n        faces = [self._guid_face[guid] for guid in guids if guid in self._guid_face] if guids else []\n        return faces\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Draw\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Modify\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    def update_attributes(self) -> bool:\n        names = sorted(self.mesh.attributes.keys())\n        values = [str(self.mesh.attributes[name]) for name in names]\n\n        form = NamedValuesForm(names=names, values=values)\n        if form.show():\n            self.mesh.attributes.update(form.attributes)\n            return True\n        return False\n\n    def update_vertex_attributes(self, vertices: list[int], names: Optional[list[str]] = None) -> bool:\n        if not vertices:\n            return False\n\n        names = names or sorted(self.mesh.default_vertex_attributes.keys())\n        names = sorted([name for name in names if not name.startswith(\"_\")])\n\n        values: list = self.mesh.vertex_attributes(vertices[0], names)  # type: ignore\n        if len(vertices) > 1:\n            for i, name in enumerate(names):\n                for vertex in vertices[1:]:\n                    if values[i] != self.mesh.vertex_attribute(vertex, name):\n                        values[i] = \"-\"\n                        break\n        values = list(map(str, values))\n\n        form = NamedValuesForm(names=names, values=values)\n        if form.show():\n            for name, value in form.attributes.items():\n                if value == \"-\":\n                    continue\n                self.mesh.vertices_attribute(name=name, value=value, keys=vertices)\n            return True\n        return False\n\n    def update_face_attributes(self, faces: list[int], names: Optional[list[str]] = None) -> bool:\n        if not faces:\n            return False\n\n        names = names or sorted(self.mesh.default_face_attributes.keys())\n        names = sorted([name for name in names if not name.startswith(\"_\")])\n\n        values: list = self.mesh.face_attributes(faces[0], names)  # type: ignore\n        if len(faces) > 1:\n            for i, name in enumerate(names):\n                for face in faces[1:]:\n                    if values[i] != self.mesh.face_attribute(face, name):\n                        values[i] = \"-\"\n                        break\n        values = list(map(str, values))\n\n        form = NamedValuesForm(names=names, values=values)\n        if form.show():\n            for name, value in form.attributes.items():\n                if value == \"-\":\n                    continue\n                self.mesh.faces_attribute(name=name, value=value, keys=faces)\n            return True\n        return False\n\n    def update_edge_attributes(self, edges: list[tuple[int, int]], names: Optional[list[str]] = None) -> bool:\n        if not edges:\n            return False\n\n        names = names or sorted(self.mesh.default_edge_attributes.keys())\n        names = sorted([name for name in names if not name.startswith(\"_\")])\n\n        values: list = self.mesh.edge_attributes(edges[0], names)  # type: ignore\n        if len(edges) > 1:\n            for i, name in enumerate(names):\n                for edge in edges[1:]:\n                    if values[i] != self.mesh.edge_attribute(edge, name):\n                        values[i] = \"-\"\n                        break\n        values = list(map(str, values))\n\n        form = NamedValuesForm(names=names, values=values)\n        if form.show():\n            for name, value in form.attributes.items():\n                if value == \"-\":\n                    continue\n                self.mesh.edges_attribute(name=name, value=value, keys=edges)\n            return True\n        return False\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Move\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    def move(self) -> bool:\n        color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n\n        vertex_p0 = {v: Rhino.Geometry.Point3d(*self.mesh.vertex_coordinates(v)) for v in self.mesh.vertices()}  # type: ignore\n        vertex_p1 = {v: Rhino.Geometry.Point3d(*self.mesh.vertex_coordinates(v)) for v in self.mesh.vertices()}  # type: ignore\n\n        edges = list(self.mesh.edges())\n\n        def OnDynamicDraw(sender, e):\n            try:\n                current = e.CurrentPoint\n                vector = current - start\n\n                for v in vertex_p1:\n                    vertex_p1[v] = vertex_p0[v] + vector\n\n                for u, v in iter(edges):\n                    sp = vertex_p0[u]\n                    ep = vertex_p1[v]\n                    e.Display.DrawDottedLine(sp, ep, color)\n\n            except Exception as e:\n                print(e)\n\n        gp = Rhino.Input.Custom.GetPoint()\n\n        gp.SetCommandPrompt(\"Point to move from?\")\n        gp.Get()\n\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        start = gp.Point()\n\n        gp = Rhino.Input.Custom.GetPoint()\n        gp.SetCommandPrompt(\"Point to move to?\")\n        gp.DynamicDraw += OnDynamicDraw\n        gp.Get()\n\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        end = gp.Point()\n        vector = compas_rhino.conversions.vector_to_compas(end - start)\n\n        attr: dict\n        for _, attr in self.mesh.vertices(True):  # type: ignore\n            attr[\"x\"] += vector[0]\n            attr[\"y\"] += vector[1]\n            attr[\"z\"] += vector[2]\n\n        return True\n\n    def move_vertex(\n        self,\n        vertex: int,\n        constraint: Rhino.Geometry.GeometryBase = None,\n        allow_off: bool = True,\n    ) -> bool:\n        def OnDynamicDraw(sender, e):\n            for ep in nbrs:\n                sp = e.CurrentPoint\n                e.Display.DrawDottedLine(sp, ep, color)\n\n        color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n        nbrs = [self.mesh.vertex_coordinates(nbr) for nbr in self.mesh.vertex_neighbors(vertex)]\n        nbrs = [Rhino.Geometry.Point3d(*xyz) for xyz in nbrs]  # type: ignore\n\n        gp = Rhino.Input.Custom.GetPoint()\n\n        gp.SetCommandPrompt(\"Point to move to?\")\n        gp.DynamicDraw += OnDynamicDraw\n        if constraint:\n            gp.Constrain(constraint, allow_off)\n\n        gp.Get()\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        self.mesh.vertex_attributes(vertex, \"xyz\", list(gp.Point()))\n        return True\n\n    def move_vertices(self, vertices: list[int]) -> bool:\n        def OnDynamicDraw(sender, e):\n            end = e.CurrentPoint\n            vector = end - start\n            for a, b in lines:\n                a = a + vector\n                b = b + vector\n                e.Display.DrawDottedLine(a, b, color)\n            for a, b in connectors:\n                a = a + vector\n                e.Display.DrawDottedLine(a, b, color)\n\n        color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n        lines = []\n        connectors = []\n\n        for vertex in vertices:\n            a = self.mesh.vertex_coordinates(vertex)\n            nbrs = self.mesh.vertex_neighbors(vertex)\n            for nbr in nbrs:\n                b = self.mesh.vertex_coordinates(nbr)\n                line = [Rhino.Geometry.Point3d(*a), Rhino.Geometry.Point3d(*b)]  # type: ignore\n                if nbr in vertices:\n                    lines.append(line)\n                else:\n                    connectors.append(line)\n\n        gp = Rhino.Input.Custom.GetPoint()\n\n        gp.SetCommandPrompt(\"Point to move from?\")\n        gp.Get()\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        start = gp.Point()\n\n        gp.SetCommandPrompt(\"Point to move to?\")\n        gp.SetBasePoint(start, False)\n        gp.DrawLineFromPoint(start, True)\n        gp.DynamicDraw += OnDynamicDraw\n        gp.Get()\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        end = gp.Point()\n        vector = compas_rhino.conversions.vector_to_compas(end - start)\n\n        for vertex in vertices:\n            point = Point(*self.mesh.vertex_attributes(vertex, \"xyz\"))  # type: ignore\n            self.mesh.vertex_attributes(vertex, \"xyz\", point + vector)\n        return True\n\n    def move_vertices_direction(self, vertices: list[int], direction: str) -> bool:\n        def OnDynamicDraw(sender, e):\n            draw = e.Display.DrawDottedLine\n            end = e.CurrentPoint\n            vector = end - start\n            for a, b in lines:\n                a = a + vector\n                b = b + vector\n                draw(a, b, color)\n            for a, b in connectors:\n                a = a + vector\n                draw(a, b, color)\n\n        direction = direction.lower()\n        color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n        lines = []\n        connectors = []\n\n        for vertex in vertices:\n            a = Rhino.Geometry.Point3d(*self.mesh.vertex_coordinates(vertex))  # type: ignore\n            nbrs = self.mesh.vertex_neighbors(vertex)\n            for nbr in nbrs:\n                b = Rhino.Geometry.Point3d(*self.mesh.vertex_coordinates(nbr))  # type: ignore\n                if nbr in vertices:\n                    lines.append((a, b))\n                else:\n                    connectors.append((a, b))\n\n        gp = Rhino.Input.Custom.GetPoint()\n        gp.SetCommandPrompt(\"Point to move from?\")\n        gp.Get()\n\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        start = gp.Point()\n\n        if direction == \"x\":\n            geometry = Rhino.Geometry.Line(start, start + Rhino.Geometry.Vector3d(1, 0, 0))\n        elif direction == \"y\":\n            geometry = Rhino.Geometry.Line(start, start + Rhino.Geometry.Vector3d(0, 1, 0))\n        elif direction == \"z\":\n            geometry = Rhino.Geometry.Line(start, start + Rhino.Geometry.Vector3d(0, 0, 1))\n        elif direction == \"xy\":\n            geometry = Rhino.Geometry.Plane(start, Rhino.Geometry.Vector3d(0, 0, 1))\n        elif direction == \"yz\":\n            geometry = Rhino.Geometry.Plane(start, Rhino.Geometry.Vector3d(1, 0, 0))\n        elif direction == \"zx\":\n            geometry = Rhino.Geometry.Plane(start, Rhino.Geometry.Vector3d(0, 1, 0))\n\n        gp.SetCommandPrompt(\"Point to move to?\")\n        gp.SetBasePoint(start, False)\n        gp.DrawLineFromPoint(start, True)\n        gp.DynamicDraw += OnDynamicDraw\n\n        if direction in (\"x\", \"y\", \"z\"):\n            gp.Constrain(geometry)  # type: ignore\n        else:\n            gp.Constrain(geometry, False)  # type: ignore\n\n        gp.Get()\n\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return False\n\n        end = gp.Point()\n        vector = compas_rhino.conversions.vector_to_compas(end - start)\n\n        for vertex in vertices:\n            point = self.mesh.vertex_point(vertex)\n            self.mesh.vertex_attributes(vertex, \"xyz\", point + vector)\n\n        return True\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Conduits\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    def clear_conduits(self):\n        pass\n\n    def clear(self):\n        super().clear()\n        self.clear_conduits()\n\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # Redraw\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n    # =============================================================================\n\n    def redraw(self):\n        rs.EnableRedraw(False)\n        self.clear()\n        self.draw()\n        rs.EnableRedraw(True)\n        rs.Redraw()\n\n    def redraw_vertices(self):\n        rs.EnableRedraw(False)\n        self.clear_vertices()\n        self.draw_vertices()\n        rs.EnableRedraw(True)\n        rs.Redraw()\n\n    def redraw_edges(self):\n        rs.EnableRedraw(False)\n        self.clear_edges()\n        self.draw_edges()\n        rs.EnableRedraw(True)\n        rs.Redraw()\n\n    def redraw_faces(self):\n        rs.EnableRedraw(False)\n        self.clear_faces()\n        self.draw_faces()\n        rs.EnableRedraw(True)\n        rs.Redraw()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}