{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Visualize%20Microclimate%20Map.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Visualize Microclimate Map.py",
  "instruction": "Use this component to produce a colored mesh from a comfResultsMtx.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _comfResultsMtx: Any matrix output from the 'Honeybee_Microclimate Map...",
  "code": "# This component creates an air temperature map based on an energy simulation output.\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to produce a colored mesh from a comfResultsMtx.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _comfResultsMtx: Any matrix output from the 'Honeybee_Microclimate Map Analysis' component, the 'Honeybee_Thermal Comfort Autonomy Analysis' component, or the 'Honeybee_Read Microclimate Matrix' component.\n        _viewFactorMesh: The list of view factor meshes that comes out of the  \"Honeybee_Indoor View Factor Calculator\".  These will be colored with result data.\n        ===========: ...\n        analysisPeriod_: Note that that connecting a value to 'stepOfSimulation_' will override this input.\n        stepOfSimulation_: Optional analysisPeriod_ to take a slice out of the data stream.  Optional interger to select out a step of the simulation to color the mesh with.  Connecting a value here will override the analysisPeriod_ input.\n        percentOrTotal_: Set to 'True' to have the component compute comfort values as a percent of occupied hours or all hours.  Set to 'False' to have the component compute comfort values as a total number of hours.  The default is set to 'True' to calculate comfort as a percent.  Note that this input only works for comfort matrices and not temperature ones.\n        legendPar_: Optional legend parameters from the Ladybug \"Legend Parameters\" component.\n        runIt_: Set boolean to \"True\" to run the component and produce a colored mesh from a comfResultsMtx.\n    Returns:\n        readMe!: ...\n        ==========: ...\n        resultMesh: A list of colored meshes showing the results form the comfResultsMtx.\n        legend: A legend for the colored mesh. Connect this output to a grasshopper \"Geo\" component in order to preview the legend spearately in the Rhino scene.\n        legendBasePt: The legend base point, which can be used to move the legend with the grasshopper \"move\" component.\n        ==========: ...\n        resultValues: The values of results that are being used to color the results.\n        resultColors: The colors used for each mesh face.\n\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Visualize Microclimate Map\"\nghenv.Component.NickName = 'VisualizeMicroclimate'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\n#compatibleLBVersion = VER 0.0.59\\nNOV_20_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"6\"\nexcept: pass\n\n\nfrom System import Object\nfrom System import Drawing\nimport System\nimport Grasshopper.Kernel as gh\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport Rhino as rc\nimport scriptcontext as sc\nimport math\n\n\nw = gh.GH_RuntimeMessageLevel.Warning\n\n\ninputsDict = {\n    \n0: [\"_comfResultsMtx\", \"Any matrix output from the 'Honeybee_Microclimate Map Analysis' component, the 'Honeybee_Thermal Comfort Autonomy Analysis' component, or the 'Honeybee_Read Microclimate Matrix' component.\"],\n1: [\"_viewFactorMesh\", \"The list of view factor meshes that comes out of the  'Honeybee_Indoor View Factor Calculator'.  These will be colored with result data.\"],\n2: [\"===========\", \"...\"],\n3: [\"analysisPeriod_\", \"Optional analysisPeriod_ to take a slice out of the data stream.  Note that that connecting a value to 'stepOfSimulation_' will override this input.\"],\n4: [\"stepOfSimulation_\", \"Optional interger to select out a step of the simulation to color the mesh with.  Connecting a value here will override the analysisPeriod_ input.\"],\n5: [\"percentOrTotal_\", \"Set to 'True' to have the component compute comfort values as a percent of occupied hours or all hours.  Set to 'False' to have the component compute comfort values as a total number of hours.  The default is set to 'True' to calculate comfort as a percent.  Note that this input only works for comfort matrices and not temperature ones.\"],\n6: [\"legendPar_\", \"Optional legend parameters from the Ladybug Legend Parameters component.\"],\n7: [\"runIt_\", \"Set boolean to 'True' to run the component and visualize indoor comfort.\"]\n}\n\n\ndef checkTheInputs():\n    #Convert the data tree of _viewFactorMesh to py data.\n    viewFactorMesh = []\n    checkData1 = True\n    if len(_viewFactorMesh) != 0:\n        viewFactorMesh = _viewFactorMesh\n    else:\n        checkData1 = False\n        print \"Connect a data tree of view factor meshes from the 'Honeybee_Indoor View Factor Calculator' component.\"\n    \n    #Check to be sure that the length of the test points and the mesh faces match.\n    checkData2 = False\n    dataType = None\n    if len(_comfResultsMtx) > 0 and len(viewFactorMesh) > 0:\n        dataType = _comfResultsMtx[0].split(\";\")[0]\n        ptLen1 = len(_comfResultsMtx[1])\n        meshFaceCount = []\n        for mesh in viewFactorMesh:\n            meshFaceCount.append(mesh.Faces.Count)\n        ptLen2 = sum(meshFaceCount)\n        if ptLen1 == ptLen2: checkData2 = True\n        else:\n            warning = \"The length of data in the comfResultsMTX does not match the number of faces in the viewFactorMesh.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n    else: pass\n    \n    #Check the analysis period.\n    try:\n        analysisPeriod1 = (int(_comfResultsMtx[0].split(\";\")[-2].split(\",\")[0].split(\"(\")[-1]), int(_comfResultsMtx[0].split(\";\")[-2].split(\",\")[1].split(\" \")[-1]), int(_comfResultsMtx[0].split(\";\")[-2].split(\",\")[-1].split(\" \")[-1].split(\")\")[0]))\n        analysisPeriod2 = (int(_comfResultsMtx[0].split(\";\")[-1].split(\",\")[0].split(\"(\")[-1]), int(_comfResultsMtx[0].split(\";\")[-1].split(\",\")[1].split(\" \")[-1]), int(_comfResultsMtx[0].split(\";\")[-1].split(\",\")[-1].split(\" \")[-1].split(\")\")[0]))\n        analysisPeriod = [analysisPeriod1, analysisPeriod2]\n    except:\n        analysisPeriod = []\n    if _comfResultsMtx[0].split(\";\")[-2] == \"(1, 1, 1)\" and _comfResultsMtx[0].split(\";\")[-1] == \"(12, 31, 24)\": annualData = True\n    else: annualData = False\n    if len(_comfResultsMtx[1:]) == 1: simStepPossible = False\n    else: simStepPossible = True\n    \n    #Check the HOY to be sure that it is in the counds of the matrix.\n    checkData3 = True\n    try:\n        if not stepOfSimulation_ == None:\n            if stepOfSimulation_ <=0 or stepOfSimulation_ > len(_comfResultsMtx):\n                checkData3 = False\n                warning = \"stepOfSimulation_ is outside the bounds of the comfResultsMTX.\"\n                print warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n    except: pass\n    \n    #Check if the matrix is special and includes the number of occupied hours to divide each summed point by.\n    if 'Occupied Thermal Comfort Percent' in dataType or 'Thermal Autonomy' in dataType or 'Over-Heated Percent' in dataType or 'Under-Heated Percent' in dataType: occDataType = True\n    else: occDataType = False\n    \n    #Check if the matrix is total-able or if it should always be viewed as an average.\n    totalAble = False\n    if occDataType == True or 'Thermal Comfort Percent' in dataType: totalAble = True\n    \n    #Do a final check of everything.\n    if checkData1 == True and checkData2 == True  and checkData3 == True: checkData = True\n    else: checkData = False\n    \n    return checkData, viewFactorMesh, dataType, annualData, simStepPossible, analysisPeriod, occDataType, totalAble\n\n\ndef manageInputOutput(annualData, simStep, totalAble):\n    #If some of the component inputs and outputs are not right, blot them out or change them.\n    for input in range(8):\n        if input == 3 and simStep == False:\n            ghenv.Component.Params.Input[input].NickName = \"__________\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        elif input == 4 and simStep == False:\n            ghenv.Component.Params.Input[input].NickName = \"___________\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        elif input == 5 and totalAble == False:\n            ghenv.Component.Params.Input[input].NickName = \"___________\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        else:\n            ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n\ndef restoreInputOutput():\n    for input in range(7):\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n\n\ndef computeComfValues(comfResultsMtx, analysisP, comfMtxAnalysisP, stepOfSimulation, annualData, simStepPossible, occDataType, percentOrTotal, totalAble, lb_preparation):\n    #Create a list to be filled with values of comfort.\n    comfortFactorVals = []\n    \n    if stepOfSimulation != None and simStepPossible == True:\n        comfortFactorVals = comfResultsMtx[stepOfSimulation]\n    elif len(analysisP) > 0 and analysisP != comfMtxAnalysisP and annualData == True:\n        #Get the HOYs of the analysis period\n        HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisP, 1)\n        \n        #Pick out just the hours that are in the analysis period.\n        newcomfResultsMtx = []\n        for lineCount, line in enumerate(comfResultsMtx):\n            if lineCount in HOYS: newcomfResultsMtx.append(line)\n        \n        #Transpose the matrix\n        newcomfResultsMtx2 = zip(*newcomfResultsMtx)\n        \n        if percentOrTotal == False and totalAble == True:\n            for lineCount, line in enumerate(newcomfResultsMtx2):\n                comfortFactorVals.append(sum(line))\n        else:\n            #If the dataType is meant to be divided by occupie hours, recompute the occupied hours for the analysis period.\n            occMtxInit = []\n            for val in comfResultsMtx[1]: occMtxInit.append(0)\n            if occDataType == True:\n                for line in newcomfResultsMtx:\n                    for ptCt, pointVal in enumerate(line):\n                        if isinstance(pointVal, int): occMtxInit[ptCt] += 1\n            occMtx = [occMtxInit]\n            \n            #Compute the total percentage of comfortable hours.\n            if occDataType == False:\n                for lineCount, line in enumerate(newcomfResultsMtx2):\n                    comfortFactorVals.append(sum(line)/len(line))\n            else:\n                occMtx2 = zip(*occMtx)\n                for lineCount, line in enumerate(newcomfResultsMtx2):\n                    comfortFactorVals.append(sum(line)/occMtx2[lineCount][0])\n    elif len(analysisP) > 0 and analysisP != comfMtxAnalysisP and annualData == False and simStepPossible == True:\n        #Check the data anlysis period and subtract the start day from each of the HOYs.\n        HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisP, 1)\n        FinalHOYs, mon, days = lb_preparation.getHOYsBasedOnPeriod(comfMtxAnalysisP, 1)\n        for hCount, hour in enumerate(HOYS):\n            HOYS[hCount] = hour - FinalHOYs[0] + 1\n        \n        #Check to see if the hours of the requested analysis period are in the comfResultsMtx.\n        periodsAlign = True\n        for hour in HOYS:\n            if hour < 0: periodsAlign = False\n            try: comfResultsMtx[hour]\n            except: periodsAlign = False\n        \n        if periodsAlign == False:\n            warning = 'The analysis period of the confResultsMtx and that which is plugged into this component do not align.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n        else:\n            \n            #Pick out just the hours that are in the analysis period.\n            newcomfResultsMtx = []\n            for lineCount, line in enumerate(comfResultsMtx):\n                if lineCount in HOYS:\n                    newcomfResultsMtx.append(line)\n            \n            #Transpose the matrix\n            newcomfResultsMtx2 = zip(*newcomfResultsMtx)\n            \n            if percentOrTotal == False and totalAble == True:\n                for lineCount, line in enumerate(newcomfResultsMtx2):\n                    comfortFactorVals.append(sum(line))\n            else:\n                #If the dataType is meant to be divided by occupie hours, recompute the occupied hours for the analysis period.\n                occMtxInit = []\n                for val in comfResultsMtx[1]: occMtxInit.append(0)\n                if occDataType == True:\n                    for line in newcomfResultsMtx:\n                        for ptCt, pointVal in enumerate(line):\n                            if isinstance(pointVal, int): occMtxInit[ptCt] += 1\n                occMtx = [occMtxInit]\n                \n                #Compute the total percentage of comfortable hours.\n                if occDataType == False:\n                    for lineCount, line in enumerate(newcomfResultsMtx2):\n                        comfortFactorVals.append(sum(line)/len(line))\n                else:\n                    occMtx2 = zip(*occMtx)\n                    for lineCount, line in enumerate(newcomfResultsMtx2):\n                        comfortFactorVals.append(sum(line)/occMtx2[lineCount][0])\n    else:\n        #Transpose the matrix\n        if occDataType == False: newcomfResultsMtx1 = comfResultsMtx[1:]\n        else: newcomfResultsMtx1 = comfResultsMtx[1:-1]\n        newcomfResultsMtx2 = zip(*newcomfResultsMtx1)\n        \n        if percentOrTotal == False and totalAble == True:\n            for lineCount, line in enumerate(newcomfResultsMtx2):\n                comfortFactorVals.append(sum(line))\n        else:\n            #Compute the average across the hours.\n            if occDataType == False:\n                for lineCount, line in enumerate(newcomfResultsMtx2):\n                    comfortFactorVals.append(sum(line)/len(line))\n            else:\n                occMtx = [comfResultsMtx[-1]]\n                occMtx2 = zip(*occMtx)\n                for lineCount, line in enumerate(newcomfResultsMtx2):\n                    comfortFactorVals.append(sum(line)/occMtx2[lineCount][0])\n    \n    \n    return comfortFactorVals\n\n\n\ndef main(pointValues, viewFactorMesh, dataType, lb_preparation, lb_visualization, legendPar, analysisPeriod, simStepPossible, annualData, percentOrTotal):\n    #Read the legend parameters.\n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    \n    #Read the data type and assign default values for mesh types.\n    if dataType == 'Degrees From Target' or dataType == 'Predicted Mean Vote' or dataType == 'Degrees From Neutral UTCI' or dataType == 'PET Category':\n        pointValuesFinal = pointValues\n        if dataType == 'Degrees From Target' or dataType == 'Degrees From Neutral UTCI': legendTitle = 'C'\n        elif dataType == 'PET Category': legendTitle = 'PET Category'\n        else: legendTitle = 'PMV'\n        if dataType == 'Degrees From Target': dataType = dataType + ' Temperature'\n        if len(legendPar_) == 0:\n            if dataType == 'Degrees From Neutral UTCI': customColors = lb_visualization.gradientLibrary[9]\n            else: customColors = lb_visualization.gradientLibrary[8]\n            if dataType == 'Degrees From Target Temperature':\n                numSeg = 11\n                lowB = -5\n                highB = 5\n            elif dataType == 'Degrees From Neutral UTCI':\n                numSeg = 12\n                lowB = -32\n                highB = 12\n            elif dataType == 'PET Category':\n                numSeg = 11\n                lowB = -2\n                highB = 2\n            else:\n                numSeg = 11\n                lowB = -1\n                highB = 1\n        elif legendPar_[3] == []:\n            if dataType == 'Degrees From Neutral UTCI': customColors = lb_visualization.gradientLibrary[9]\n            else: customColors = lb_visualization.gradientLibrary[8]\n    elif 'Thermal Comfort Percent' in dataType or 'Thermal Autonomy' in dataType or 'Over-Heated Percent' in dataType or 'Under-Heated Percent' in dataType:\n        if percentOrTotal == False:\n            if 'Percent' in dataType: dataType = dataType.split('Percent')[0] + 'Hours'\n            legendTitle = 'Hours'\n        else: legendTitle = '%'\n        all100Comf = True\n        pointValuesFinal = []\n        for valCount, value in enumerate(pointValues):\n            if value < 1.0: all100Comf = False\n            if percentOrTotal == False:\n                all100Comf = False\n                pointValuesFinal.append(value)\n            else: pointValuesFinal.append(value*100)\n        if len(legendPar_) == 0:\n            if all100Comf == False:\n                if 'Thermal Comfort' in dataType or 'Thermal Autonomy' in dataType: customColors = lb_visualization.gradientLibrary[7]\n                elif 'Over-Heated' in dataType: customColors = lb_visualization.gradientLibrary[10]\n                else: customColors = lb_visualization.gradientLibrary[11]\n            else: customColors = [System.Drawing.Color.FromArgb(255,255,255), System.Drawing.Color.FromArgb(255,255,255)]\n        elif legendPar_[3] == []:\n            if all100Comf == False:\n                if 'Thermal Comfort' in dataType or 'Thermal Autonomy' in dataType: customColors = lb_visualization.gradientLibrary[7]\n                elif 'Over-Heated' in dataType: customColors = lb_visualization.gradientLibrary[10]\n                else: customColors = lb_visualization.gradientLibrary[11]\n            else: customColors = [System.Drawing.Color.FromArgb(255,255,255), System.Drawing.Color.FromArgb(255,255,255)]\n    else:\n        pointValuesFinal = pointValues\n        legendTitle = 'C'\n    \n    #Get the colors for each zone.\n    allColors = []\n    transparentColors = []\n    colors = lb_visualization.gradientColor(pointValuesFinal, lowB, highB, customColors)\n    allColors.append(colors)\n    \n    #Get a list of colors with alpha values as transparent\n    for color in colors:\n        transparentColors.append(Drawing.Color.FromArgb(125, color.R, color.G, color.B))\n    \n    #Color the view factor meshes.\n    resultMesh = []\n    segmentedColors = []\n    segmentedTanspColors = []\n    segmentedValues = []\n    \n    colorCounter = 0\n    for meshCount, mesh in enumerate(viewFactorMesh):\n        mesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n        resultMesh.append(mesh)\n        segmentedColors.append(colors[colorCounter:(colorCounter+mesh.Faces.Count)])\n        segmentedTanspColors.append(transparentColors[colorCounter:(colorCounter+mesh.Faces.Count)])\n        segmentedValues.append(pointValuesFinal[colorCounter:(colorCounter+mesh.Faces.Count)])\n        colorCounter+=mesh.Faces.Count\n    \n    for meshCount, mesh in enumerate(resultMesh):\n        counter = 0\n        for srfNum in range(mesh.Faces.Count):\n            if mesh.Faces[srfNum].IsQuad:\n                mesh.VertexColors[counter + 0] = segmentedColors[meshCount][srfNum]\n                mesh.VertexColors[counter + 1] = segmentedColors[meshCount][srfNum]\n                mesh.VertexColors[counter + 2] = segmentedColors[meshCount][srfNum]\n                mesh.VertexColors[counter + 3] = segmentedColors[meshCount][srfNum]\n                counter+=4\n            else:\n                mesh.VertexColors[counter + 0] = segmentedColors[meshCount][srfNum]\n                mesh.VertexColors[counter + 1] = segmentedColors[meshCount][srfNum]\n                mesh.VertexColors[counter + 2] = segmentedColors[meshCount][srfNum]\n                counter+=3\n    \n    #Create the legend.\n    lb_visualization.calculateBB(resultMesh, True)\n    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(pointValuesFinal, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    \n    #Make lists that assist with the labaeling of the rest of the title.\n    monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n    timeNames = [\"1:00\", \"2:00\", \"3:00\", \"4:00\", \"5:00\", \"6:00\", \"7:00\", \"8:00\", \"9:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\", \"24:00\"]\n    \n    #If there is an analysis period, format the text for it in the legend title.\n    try:\n        if len(analysisPeriod_) == 0 and annualData == False:\n            startMonth = analysisPeriod[0][0]\n            endMonth = analysisPeriod[1][0]\n            startDay = analysisPeriod[0][1]\n            endDay = analysisPeriod[1][1]\n            startHour = analysisPeriod[0][2]\n            endHour = analysisPeriod[1][2]\n            if analysisPeriod[0] != analysisPeriod[1]:\n                titleDate = str(monthNames[startMonth-1]) + \" \" + str(startDay) + \" \" + str(timeNames[startHour-1]) + \" - \" + str(monthNames[endMonth-1]) + \" \" + str(endDay) + \" \" + str(timeNames[endHour-1])\n            else: titleDate = str(monthNames[startMonth-1]) + \" \" + str(startDay) + \" \" + str(timeNames[startHour-1])\n        else:\n            startMonth = analysisPeriod_[0][0]\n            endMonth = analysisPeriod_[1][0]\n            startDay = analysisPeriod_[0][1]\n            endDay = analysisPeriod_[1][1]\n            startHour = analysisPeriod_[0][2]\n            endHour = analysisPeriod_[1][2]\n            titleDate = str(monthNames[startMonth-1]) + \" \" + str(startDay) + \" \" + str(timeNames[startHour-1]) + \" - \" + str(monthNames[endMonth-1]) + \" \" + str(endDay) + \" \" + str(timeNames[endHour-1])\n    except:\n        startMonth = analysisPeriod[0][0]\n        endMonth = analysisPeriod[1][0]\n        startDay = analysisPeriod[0][1]\n        endDay = analysisPeriod[1][1]\n        startHour = analysisPeriod[0][2]\n        endHour = analysisPeriod[1][2]\n        if analysisPeriod[0] != analysisPeriod[1]:\n            titleDate = str(monthNames[startMonth-1]) + \" \" + str(startDay) + \" \" + str(timeNames[startHour-1]) + \" - \" + str(monthNames[endMonth-1]) + \" \" + str(endDay) + \" \" + str(timeNames[endHour-1])\n        else: titleDate = str(monthNames[startMonth]) + \" \" + str(startDay) + \" \" + str(timeNames[startHour-1])\n    \n    #Create the Title.\n    try:\n        if stepOfSimulation_ != None and simStepPossible == True:\n            startHOY = lb_preparation.date2Hour(startMonth, startDay, startHour)\n            actualHOY = startHOY + stepOfSimulation_ - 1\n            date = lb_preparation.hour2Date(actualHOY)\n            titleTxt = '\\n' + dataType + '\\n' + date\n        elif len(analysisPeriod) > 0: titleTxt = '\\n' + dataType + '\\n' + titleDate\n        else: titleTxt = '\\n' + 'Average ' + dataType\n    except:\n        titleTxt = '\\n' + 'Average ' + dataType\n    titleBasePt = lb_visualization.BoundingBoxPar[5]\n    titleTextCurve = lb_visualization.text2srf([titleTxt], [titleBasePt], legendFont, textSize, legendBold)\n    \n    #Bring the legend and the title together.\n    fullLegTxt = lb_preparation.flattenList(legendTextCrv + titleTextCurve)\n    \n    \n    return segmentedValues, segmentedTanspColors, resultMesh, [legendSrfs, fullLegTxt], legendBasePoint\n\n\n\n\n\n#Import the classes, check the inputs, and generate default values for grid size if the user has given none.\ncheckLB = True\nif sc.sticky.has_key('ladybug_release'):\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nelse:\n    checkLB = False\n    print \"You should let the Ladybug fly first...\"\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"You should let the Ladybug fly first...\")\n\ncheckData = False\nannualData = True\nsimStepPossible = True\ntotalAble = True\nif len(_comfResultsMtx) > 0 and len(_viewFactorMesh) > 0:\n    if _comfResultsMtx[0] != None and _viewFactorMesh[0] != None:\n        checkData, viewFactorMesh, dataType, annualData, simStepPossible, analysisPeriod, occDataType, totalAble = checkTheInputs()\n\nif annualData == False or simStepPossible == False or totalAble == False:\n    manageInputOutput(annualData, simStepPossible, totalAble)\nelse:\n    restoreInputOutput()\n\n#In case the input/output has wiped out these terms, replace them with null values.\ntry: analysisPeriod_[0]\nexcept: analysisPeriod_ = []\ntry: stepOfSimulation_\nexcept: stepOfSimulation_ = None\ntry: percentOrTotal_\nexcept: percentOrTotal_ = True\nif runIt_ == None: runIt = True\nelse: runIt = runIt_\n\nif checkData == True and runIt == True:\n    resultValues = computeComfValues(_comfResultsMtx, analysisPeriod_, analysisPeriod, stepOfSimulation_, annualData, simStepPossible, occDataType, percentOrTotal_, totalAble, lb_preparation)\n    if resultValues != []:\n        resultValuesInit, resultColorsInit, resultMeshInit, legendInit, legendBasePt = main(resultValues, viewFactorMesh, dataType, lb_preparation, lb_visualization, legendPar_, analysisPeriod, simStepPossible, annualData, percentOrTotal_)\n        \n        #Unpack the legend.\n        legend = []\n        for count, item in enumerate(legendInit):\n            if count == 0:\n                legend.append(item)\n            if count == 1:\n                for srf in item:\n                    legend.append(srf)\n        \n        #Unpack the other data trees.\n        resultValues = DataTree[Object]()\n        resultColors = DataTree[Object]()\n        resultMesh = DataTree[Object]()\n        \n        for brCount, branch in enumerate(resultValuesInit):\n            for item in branch:resultValues.Add(item, GH_Path(brCount))\n        for brCount, branch in enumerate(resultColorsInit):\n            for item in branch:resultColors.Add(item, GH_Path(brCount))\n        for meshCt, mesh in enumerate(resultMeshInit):\n            resultMesh.Add(mesh, GH_Path(meshCt))\n        \n        ghenv.Component.Params.Output[4].Hidden = True\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}