{
  "source_url": "https://github.com/SMArndt/GridTools/blob/d1d776c0aa2b6897b3ed3618ce0fef5e2ac6348b/rhino3d/example_stress_analysis.py",
  "repo": "SMArndt/GridTools",
  "repo_stars": 1,
  "repo_description": "Tools and tests for grid analysis and visualisation (AMIRA Mine Seismicity Research)",
  "license": "GPL-3.0",
  "filepath": "rhino3d/example_stress_analysis.py",
  "instruction": "Example: Stress Analysis and Principal Stress Calculation in Rhino3D",
  "code": "\"\"\"\nExample: Stress Analysis and Principal Stress Calculation in Rhino3D\n\nThis script demonstrates:\n1. Loading stress tensor data from CSV\n2. Calculating principal stresses using gridtools\n3. Analyzing stress orientations\n4. Visualizing results in Rhino (optional)\n\nNote: Uses gridtools core functionality (no matplotlib required)\n\"\"\"\n\nimport sys\nimport os\nimport numpy as np\n\n# Add project root to path if running from Rhino\nproject_root = r'C:\\Users\\Stephan\\source\\vscode\\GridTools'\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\nfrom gridtools.xyzData import xyzData\nfrom gridtools.stressUtils import rot_z, getPrincipalStress, getStressOrientation\n\n# ---------------------------------------------------------------------------\n# Load stress data\n# ---------------------------------------------------------------------------\n\ndata_file = os.path.join(project_root, 'test_data', 'regular_stress.csv')\nprint(f\"Loading stress data from: {data_file}\")\n\n# Create xyzData object and load CSV\ndata = xyzData(data_file)\n\nprint(f\"\\nLoaded {len(data.current)} data points\")\nprint(f\"Columns: {list(data.index.keys())}\")\n\n# ---------------------------------------------------------------------------\n# Extract stress tensor components\n# ---------------------------------------------------------------------------\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"STRESS TENSOR ANALYSIS\")\nprint(\"=\" * 60)\n\n# Get indices for stress components\nsxx_idx = data.index['Sxx']\nsyy_idx = data.index['Syy']\nszz_idx = data.index['Szz']\nsxy_idx = data.index['Sxy']\nsxz_idx = data.index['Sxz']\nsyz_idx = data.index['Syz']\n\n# Extract stress components\nsxx = data.current[:, sxx_idx]\nsyy = data.current[:, syy_idx]\nszz = data.current[:, szz_idx]\nsxy = data.current[:, sxy_idx]\nsxz = data.current[:, sxz_idx]\nsyz = data.current[:, syz_idx]\n\nprint(f\"\\nStress component ranges (Pa):\")\nprint(f\"  Sxx: {sxx.min():.2e} to {sxx.max():.2e}\")\nprint(f\"  Syy: {syy.min():.2e} to {syy.max():.2e}\")\nprint(f\"  Szz: {szz.min():.2e} to {szz.max():.2e}\")\nprint(f\"  Sxy: {sxy.min():.2e} to {sxy.max():.2e}\")\nprint(f\"  Sxz: {sxz.min():.2e} to {sxz.max():.2e}\")\nprint(f\"  Syz: {syz.min():.2e} to {syz.max():.2e}\")\n\n# ---------------------------------------------------------------------------\n# Calculate principal stresses\n# ---------------------------------------------------------------------------\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"PRINCIPAL STRESS CALCULATION\")\nprint(\"=\" * 60)\n\n# Build stress tensors for each point\n# principals() expects stress tensor in form:\n# [[sxx, sxy, sxz],\n#  [sxy, syy, syz],\n#  [sxz, syz, szz]]\n\nprincipal_stresses = []\nprincipal_vectors = []\n\nprint(f\"\\nCalculating principal stresses for {len(data.current)} points...\")\n\nfor i in range(len(data.current)):\n    # Build symmetric stress tensor\n    stress_tensor = np.array([\n        [sxx[i], sxy[i], sxz[i]],\n        [sxy[i], syy[i], syz[i]],\n        [sxz[i], syz[i], szz[i]]\n    ])\n    \n    # Calculate eigenvalues and eigenvectors\n    eigenvalues, eigenvectors = getPrincipalStress(stress_tensor)\n    \n    # Store sorted principal stresses (S1 >= S2 >= S3)\n    sorted_idx = np.argsort(eigenvalues)[::-1]\n    principal_stresses.append(eigenvalues[sorted_idx])\n    principal_vectors.append(eigenvectors[:, sorted_idx])\n\n# Convert to numpy arrays\nprincipal_stresses = np.array(principal_stresses)\n\n# ---------------------------------------------------------------------------\n# Analyze principal stresses\n# ---------------------------------------------------------------------------\n\nS1 = principal_stresses[:, 0]  # Maximum principal stress\nS2 = principal_stresses[:, 1]  # Intermediate principal stress\nS3 = principal_stresses[:, 2]  # Minimum principal stress\n\nprint(f\"\\nPrincipal stress statistics (MPa):\")\nprint(f\"  S1 (max): {S1.min()/1e6:.2f} to {S1.max()/1e6:.2f}, mean: {S1.mean()/1e6:.2f}\")\nprint(f\"  S2 (mid): {S2.min()/1e6:.2f} to {S2.max()/1e6:.2f}, mean: {S2.mean()/1e6:.2f}\")\nprint(f\"  S3 (min): {S3.min()/1e6:.2f} to {S3.max()/1e6:.2f}, mean: {S3.mean()/1e6:.2f}\")\n\n# Calculate stress ratios\nk_ratio = (S1 - S2) / (S1 - S3)  # Stress ratio parameter\nprint(f\"\\nStress ratio k = (S1-S2)/(S1-S3):\")\nprint(f\"  Range: {k_ratio.min():.3f} to {k_ratio.max():.3f}\")\nprint(f\"  Mean: {k_ratio.mean():.3f}\")\n\n# ---------------------------------------------------------------------------\n# Example: Demonstrate rotation matrix\n# ---------------------------------------------------------------------------\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"COORDINATE TRANSFORMATION EXAMPLE\")\nprint(\"=\" * 60)\n\n# Example: Rotate around Z-axis by 45 degrees\nangle = np.pi / 4  # 45 degrees in radians\nrotation_matrix = rot_z(angle)\n\nprint(f\"\\nRotation matrix (45Â° around Z-axis):\")\nprint(rotation_matrix)\n\n# Apply rotation to first stress tensor\nsample_tensor = np.array([\n    [sxx[0], sxy[0], sxz[0]],\n    [sxy[0], syy[0], syz[0]],\n    [sxz[0], syz[0], szz[0]]\n])\n\nrotated_tensor = rotation_matrix @ sample_tensor @ rotation_matrix.T\n\nprint(f\"\\nOriginal stress tensor at point 0:\")\nprint(sample_tensor / 1e6)  # Show in MPa\nprint(f\"\\nRotated stress tensor:\")\nprint(rotated_tensor / 1e6)  # Show in MPa\n\n# ---------------------------------------------------------------------------\n# Sample results\n# ---------------------------------------------------------------------------\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"SAMPLE RESULTS\")\nprint(\"=\" * 60)\n\n# Show first 5 points\nx, y, z = data.current[:, 0], data.current[:, 1], data.current[:, 2]\n\nprint(\"\\nFirst 5 points with principal stresses (MPa):\")\nfor i in range(min(5, len(data.current))):\n    print(f\"\\nPoint {i+1}: ({x[i]:.1f}, {y[i]:.1f}, {z[i]:.1f})\")\n    print(f\"  S1: {S1[i]/1e6:.2f}, S2: {S2[i]/1e6:.2f}, S3: {S3[i]/1e6:.2f}\")\n    print(f\"  k-ratio: {k_ratio[i]:.3f}\")\n\n# ---------------------------------------------------------------------------\n# Optional: Create Rhino visualization with principal stress vectors\n# ---------------------------------------------------------------------------\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"RHINO VISUALIZATION\")\nprint(\"=\" * 60)\n\ntry:\n    import rhinoscriptsyntax as rs\n    import Rhino.Geometry as rg\n    \n    print(\"\\nCreating stress visualization in Rhino...\")\n    \n    # Normalize S1 values for color mapping\n    s1_min, s1_max = S1.min(), S1.max()\n    s1_normalized = (S1 - s1_min) / (s1_max - s1_min)\n    \n    # Helper function to convert value to RGB color (blue -> cyan -> green -> yellow -> red)\n    def value_to_color(value):\n        \"\"\"Convert 0-1 value to RGB color in spectrum blue->red\"\"\"\n        if value < 0.25:\n            # Blue to Cyan\n            t = value / 0.25\n            r, g, b = 0, int(t * 255), 255\n        elif value < 0.5:\n            # Cyan to Green\n            t = (value - 0.25) / 0.25\n            r, g, b = 0, 255, int((1-t) * 255)\n        elif value < 0.75:\n            # Green to Yellow\n            t = (value - 0.5) / 0.25\n            r, g, b = int(t * 255), 255, 0\n        else:\n            # Yellow to Red\n            t = (value - 0.75) / 0.25\n            r, g, b = 255, int((1-t) * 255), 0\n        return (r, g, b)\n    \n    # Calculate vector scaling factor (use average of spatial extent / 50)\n    spatial_range = max(x.max() - x.min(), y.max() - y.min(), z.max() - z.min())\n    vector_scale = spatial_range / 50.0\n    \n    print(f\"Vector scale factor: {vector_scale:.2f}\")\n    \n    # Create points and principal stress vectors\n    point_ids = []\n    s1_line_ids = []\n    s2_line_ids = []\n    s3_line_ids = []\n    \n    for i in range(len(data.current)):\n        pt = rg.Point3d(x[i], y[i], z[i])\n        \n        # Color based on S1 magnitude\n        r, g, b = value_to_color(s1_normalized[i])\n        \n        # Add point with color\n        point_id = rs.AddPoint(pt)\n        if point_id:\n            rs.ObjectColor(point_id, (r, g, b))\n            point_ids.append(point_id)\n        \n        # Add principal stress direction vectors\n        # S1 (max principal stress) - Red lines\n        v1 = principal_vectors[i][:, 0]  # Eigenvector for S1\n        end_pt1 = rg.Point3d(x[i] + v1[0] * vector_scale, \n                             y[i] + v1[1] * vector_scale, \n                             z[i] + v1[2] * vector_scale)\n        line_id = rs.AddLine(pt, end_pt1)\n        if line_id:\n            rs.ObjectColor(line_id, (255, 0, 0))  # Red for S1\n            s1_line_ids.append(line_id)\n        \n        # S2 (intermediate principal stress) - Green lines\n        v2 = principal_vectors[i][:, 1]  # Eigenvector for S2\n        end_pt2 = rg.Point3d(x[i] + v2[0] * vector_scale, \n                             y[i] + v2[1] * vector_scale, \n                             z[i] + v2[2] * vector_scale)\n        line_id = rs.AddLine(pt, end_pt2)\n        if line_id:\n            rs.ObjectColor(line_id, (0, 255, 0))  # Green for S2\n            s2_line_ids.append(line_id)\n        \n        # S3 (min principal stress) - Blue lines\n        v3 = principal_vectors[i][:, 2]  # Eigenvector for S3\n        end_pt3 = rg.Point3d(x[i] + v3[0] * vector_scale, \n                             y[i] + v3[1] * vector_scale, \n                             z[i] + v3[2] * vector_scale)\n        line_id = rs.AddLine(pt, end_pt3)\n        if line_id:\n            rs.ObjectColor(line_id, (0, 0, 255))  # Blue for S3\n            s3_line_ids.append(line_id)\n    \n    # Group objects by type\n    if point_ids:\n        group_name = f\"StressPoints_S1_{s1_min/1e6:.1f}to{s1_max/1e6:.1f}MPa\"\n        rs.AddGroup(group_name)\n        rs.AddObjectsToGroup(point_ids, group_name)\n    \n    if s1_line_ids:\n        rs.AddGroup(\"S1_Vectors_Red\")\n        rs.AddObjectsToGroup(s1_line_ids, \"S1_Vectors_Red\")\n    \n    if s2_line_ids:\n        rs.AddGroup(\"S2_Vectors_Green\")\n        rs.AddObjectsToGroup(s2_line_ids, \"S2_Vectors_Green\")\n    \n    if s3_line_ids:\n        rs.AddGroup(\"S3_Vectors_Blue\")\n        rs.AddObjectsToGroup(s3_line_ids, \"S3_Vectors_Blue\")\n    \n    rs.ZoomExtents()\n    \n    print(f\"\\nAdded {len(point_ids)} colored points to Rhino document\")\n    print(f\"Color spectrum: Blue (S1={s1_min/1e6:.2f} MPa) -> Red (S1={s1_max/1e6:.2f} MPa)\")\n    print(f\"\\nAdded principal stress vectors:\")\n    print(f\"  S1 (max): {len(s1_line_ids)} red lines\")\n    print(f\"  S2 (mid): {len(s2_line_ids)} green lines\")\n    print(f\"  S3 (min): {len(s3_line_ids)} blue lines\")\n    print(f\"\\nVector length represents direction only (scaled to {vector_scale:.2f})\")\n    print(\"\\nGroups created:\")\n    print(f\"  - Points: '{group_name}'\")\n    print(\"  - S1 vectors: 'S1_Vectors_Red'\")\n    print(\"  - S2 vectors: 'S2_Vectors_Green'\")\n    print(\"  - S3 vectors: 'S3_Vectors_Blue'\")\n    \nexcept ImportError:\n    print(\"\\nRhino scripting not available (running outside Rhino)\")\n    print(\"To visualize in Rhino:\")\n    print(\"1. Copy this script to Rhino's ScriptEditor\")\n    print(\"2. Run it to add stress points colored by S1 magnitude\")\n    print(\"3. Principal stress directions shown as colored vectors:\")\n    print(\"   - Red lines = S1 (maximum principal stress)\")\n    print(\"   - Green lines = S2 (intermediate principal stress)\")\n    print(\"   - Blue lines = S3 (minimum principal stress)\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"DONE\")\nprint(\"=\" * 60)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}