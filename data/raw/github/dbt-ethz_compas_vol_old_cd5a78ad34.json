{
  "source_url": "https://github.com/dbt-ethz/compas_vol_old/blob/5731d940b587c0e86e5be701dbda9189903f0dc3/src/compas_vol/microstructures/tpms_attractor.py",
  "repo": "dbt-ethz/compas_vol_old",
  "repo_stars": 11,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/compas_vol/microstructures/tpms_attractor.py",
  "instruction": "Tpms attractor",
  "code": "from math import pi, sin, cos\nfrom compas import PRECISION\nfrom compas.geometry import Point\nfrom compas.utilities import remap_values\n\nclass TPMSAttractor(object):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, tpmstype=0, wavelength=1.0):\n        self.tpmstypes = ['Gyroid', 'SchwartzP']\n        self.tpmstypesl = [s.lower() for s in self.tpmstypes]\n        self._tpmstype = None\n        self.tpmstype = tpmstype\n        self._wavelength = None\n        self.wavelength = wavelength\n        self._factor = self.wavelength/pi\n\n\n    # ==========================================================================\n    # distance function\n    # ==========================================================================\n\n    def get_distance(self, point):\n        \"\"\"\n        single point distance function\n        \"\"\"\n        x, y, z = point\n        px = x/self._factor\n        py = y/self._factor\n        pz = z/self._factor\n\n        d = 0\n        if self.tpmstype == 0:  # 'Gyroid':\n            d = sin(px)*cos(py) + sin(py)*cos(pz) + sin(pz)*cos(px)\n        elif self.tpmstype == 1:  # 'SchwartzP':\n            d = cos(px) + cos(py) + cos(pz)\n        return d\n\n    def get_distance_numpy(self, x, y, z):\n        \"\"\"\n        vectorized distance function\n        \"\"\"\n        import numpy as np\n\n        px = x/self._factor\n        py = y/self._factor\n        pz = z/self._factor\n\n        d = 0\n        # Gyroid\n        if self.tpmstype == 0:\n            d = np.sin(px) * np.cos(py) + np.sin(py)*np.cos(pz) + np.sin(pz)*np.cos(px)\n        # SchwartzP\n        elif self.tpmstype == 1:\n            d = np.cos(px) + np.cos(py) + np.cos(pz)\n        return d\n\n\n\n# import Rhino.Geometry as rg\n\n# def remap(val, min, max, minOut, maxOut):\n#     if val > max:\n#         val = max\n#     elif val < min:\n#         val = min\n    \n#     span = max-min\n#     spanOut = maxOut - minOut\n#     thrust = (val-min)/span\n    \n#     return minOut + (thrust*spanOut)\n\n# class Attractor(object):\n#     \"\"\"\n#     this is the attractor class\n#     \"\"\"\n#     def __init__(self,obj,dist,targ):\n#         self.obj = obj\n#         self.dist = dist\n#         self.targ = targ\n    \n#     def getFactor(self,x,y,z):\n#         f = 1\n#         newPt = rg.Point3d(x,y,z)\n#         if type(self.obj) is list:\n#             distances = []\n#             factors = []\n#             for o in self.obj:\n#                 if type(o) is rg.Point3d:\n#                     d = rg.Point3d.DistanceTo(o, newPt)\n#                     distances.append(d)\n#                     f = remap(d, self.dist[0], self.dist[1], self.targ[0], self.targ[1])\n#                     factors.append(f)\n#                 elif type(o) is rg.Plane:\n#                     projectedPt = rg.Plane.ClosestPoint(o, newPt)\n#                     d = rg.Point3d.DistanceTo(projectedPt, newPt)\n#                     distances.append(d)\n#                     f = remap(d, self.dist[0], self.dist[1], self.targ[0], self.targ[1])\n#                     factors.append(f)\n            \n#             m = min(distances)\n#             for d,newf in zip(distances, factors):\n#                 if d == m:\n#                     f = newf\n#         else:\n#             if type(self.obj) is rg.Point3d:\n#                 d = rg.Point3d.DistanceTo(self.obj, newPt)\n#                 f = remap(d, self.dist[0], self.dist[1], self.targ[0], self.targ[1])\n#             elif type(self.obj) is rg.Plane:\n#                 projectedPt = rg.Plane.ClosestPoint(self.obj, newPt)\n#                 d = rg.Point3d.DistanceTo(projectedPt, newPt)\n#                 f = remap(d, self.dist[0], self.dist[1], self.targ[0], self.targ[1])\n        \n#         return f",
  "language": "python",
  "imports": [
    "Rhino.Geometry"
  ],
  "has_docstring": false
}