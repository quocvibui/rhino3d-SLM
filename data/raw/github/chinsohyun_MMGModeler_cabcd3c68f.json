{
  "source_url": "https://github.com/chinsohyun/MMGModeler/blob/f9e8fb18e08fc9ac13d56a9abd5158315ef4facc/Archives/python_for%20cuboctahedron_240915_2.py",
  "repo": "chinsohyun/MMGModeler",
  "repo_stars": 0,
  "repo_description": "3D Interface for Minimal Making Grammar",
  "license": "unknown",
  "filepath": "Archives/python_for cuboctahedron_240915_2.py",
  "instruction": "Python for cuboctahedron 240915 2",
  "code": "import rhinoscriptsyntax as rs\n\nrs.DefaultRenderer(False)\n\ndef square(w, l, offset, pt_cord, next_cord): #3\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2] * 2 * w/l))\n        pt1a = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2]* (1-2 * w/l))) \n        pt2 = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* (1-2 * w/l)))\n        pt2a = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* 2 * w/l))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        ptb = rs.AddPoint((a, b, next_cord[2]))\n        nptb = rs.AddPoint((next_cord[0], next_cord[1], c))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.2))\n        pt1a = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.2))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.8))\n        pt2a = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.8))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n        ptb = rs.AddPoint((next_cord[0], b, c))\n        nptb = rs.AddPoint((a, next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * 2 * w/l, c))\n        pt1a = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * (1-2 * w/l), c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * (1-2 * w/l), c))\n        pt2a = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * 2 * w/l, c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n        ptb = rs.AddPoint((a, next_cord[1], c))\n        nptb = rs.AddPoint((next_cord[0], b, next_cord[2]))\n\n    rect = [pt1, pt1a, pt2, pt2a, pt1]\n    big_rect = [pt_cord, ptb, next_cord, nptb, pt_cord]\n#    poly_points = [pt0, pt1, pt1a, pt2, pt2a, npt]\n    rs.HideObjects(rect)\n    rs.HideObjects([ptb, nptb])\n#    polyline = rs.AddPolyline(rect)\n    polyline1 = rs.AddPolyline(big_rect)\n    \n    polyline2 = rs.AddPolyline([pt0, pt1, pt2, npt])\n#    rs.AddSweep2(big_rect, big_rect, False )\n    return [polyline1, polyline2]\n    \ndef diagonal(w, l, offset, pt_cord, next_cord): #0\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.1, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.9, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.1))\n        pt2 = rs.AddPoint((a + offset[0] *(1-2 * w/l), b, c + offset[2] * 0.9))\n        npt = rs.AddPoint((a + offset[0] *(1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.1, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.9, b + offset[1]  * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2*w/l), next_cord[2]))\n\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n    \n    \ndef triangle_shape(w, l, offset, pt_cord, next_cord): #2\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n        \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.95 , c + offset[2]* (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.95))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.95, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n    \ndef z_shape(w, l, offset, pt_cord, next_cord): #1\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.5))\n        npt = rs.AddPoint((a + offset[0] * (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    \n    polyline = rs.AddPolyline(poly_points)\n    rs.DeleteObjects(poly_points)\n    return polyline\n\ndef surface(w, l, offset, pt_cord, next_cord): #4\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b, c + offset[2] * 4 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c + offset[2] * 4 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c))\n        \n        pt3 = rs.AddPoint((a, b + offset[1], c + offset[2] * (1-4 * w/l)))\n        pt4 = rs.AddPoint((a, b + offset[1] * (1-4 * w/l), c + offset[2] * (1-4 * w/l)))\n        pt5 = rs.AddPoint((a, b + offset[1] * (1-4 * w/l), c + offset[2]))\n        \n        ptb = rs.AddPoint((a, b, next_cord[2]))\n        nptb = rs.AddPoint((next_cord[0], next_cord[1], c))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c + offset[2] * 4 * w/l))\n        pt2 = rs.AddPoint((a, b, c + offset[2] * 4 * w/l))\n        \n        pt3 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b, c + offset[2]))\n        pt4 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b, c + offset[2] * (1-4 * w/l)))\n        pt5 = rs.AddPoint((a + offset[0], b, c + offset[2] * (1-4 * w/l)))\n        \n        ptb = rs.AddPoint((next_cord[0], b, c))\n        nptb = rs.AddPoint((a, next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 4 * w/l, b + offset[1] * 4 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c))\n        \n        pt3 = rs.AddPoint((a + offset[0], b + offset[1] * (1-4 * w/l), c))\n        pt4 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b + offset[1] * (1-4 * w/l), c))\n        pt5 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b + offset[1], c))\n\n        ptb = rs.AddPoint((a, next_cord[1], c))\n        nptb = rs.AddPoint((next_cord[0], b, next_cord[2]))\n\n    big_rect = [pt_cord, ptb, next_cord, nptb, pt_cord]\n    small_rect1 = [pt_cord, pt0, pt1, pt2, pt_cord]\n    small_rect2 = [next_cord, pt3, pt4, pt5, next_cord]\n    rs.HideObjects([pt0, pt1, pt2, pt3, pt4, pt5, nptb, ptb])\n    square1 = rs.AddPolyline(big_rect)\n    point = rs.CurveAreaCentroid(square1)\n    \n    square2 = rs.ScaleObject(square1, point[0], [0.8, 0.8, 0.8])\n    square3 = rs.AddPolyline(small_rect1)\n    square4 = rs.AddPolyline(small_rect2)\n\n    rs.HideObjects([square1, square2, square3, square4])\n    assemble = rs.CurveBooleanUnion([square2, square3, square4])\n    \n    return assemble\n\ndef cuboctahedron_symmetry(pt_cord, rotation, mode, number, container, boundary, ps_box, c_box):\n    \n    if rotation >= number:\n        delete = []\n#        rs.DeleteObject(brep)\n        for i in range(len(c_box)):\n            if not rs.IsPointInSurface(boundary, c_box[i]):\n                delete.append(ps_box[i])\n                rs.HideObjects(delete)\n        return\n    length = 30\n    width = 1\n    \n\n    container.append(pt_cord)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    x = length/2\n    \n    offsets = [\n            (x, x, 0), (x, -x, 0), (-x, x, 0), (-x, -x, 0),  # p_xy plane\n            (0, x, x), (0, x, -x), (0, -x, x), (0, -x, -x),  # p_yz plane\n            (x, 0, x), (-x, 0, x), (x, 0, -x), (-x, 0, -x)   # p_zx plane\n    ]\n            \n    for offset in offsets:\n        next_pt = rs.AddPoint((a + offset[0], b + offset[1], c + offset[2]))\n        rs.HideObject(next_pt)\n        next_cord = rs.PointCoordinates(next_pt)\n\n        if next_cord not in container:\n            if mode in [0, 1, 2]:\n                if mode == 0:\n                     polyline = diagonal(width, length, offset, pt_cord, next_cord)\n        \n                elif mode == 1:\n                     polyline = z_shape(width, length, offset, pt_cord, next_cord)\n\n                elif mode == 2:\n                     polyline = triangle_shape(width, length, offset, pt_cord, next_cord)\n\n                rs.HideObjects(polyline)\n\n                if offset[0] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n                if offset[1] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n                if offset[2] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n                shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n                shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n                ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n                rs.DeleteObjects([shape1, pl1, shape2, pl2])\n            else:\n                 if mode == 3:\n                    polylines = square(width, length, offset, pt_cord, next_cord)\n                 \n                 elif mode == 4:\n                    polylines = surface(width, length, offset, pt_cord, next_cord)\n                    \n                 ps = rs.AddPlanarSrf(polylines)\n                 if type(polylines) == list:\n                     rs.DeleteObjects(polylines)\n                 else:\n                    rs.DeleteObject(polylines)\n            c_box.append(next_cord)\n            ps_box.append(ps)\n           \n            cuboctahedron_symmetry(next_cord, rotation + 1, mode, number, container, brep, ps_box, c_box)\n\ndef cuboctahedron(pt_cord, rotation, mode, number, container):\n    rs.DefaultRenderer(False)\n    if rotation >= number:\n        return\n    len = 30\n    width = 1\n    \n\n    container.append(pt_cord)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    x = len/2\n    \n    offsets = [\n            (x, x, 0), (x, -x, 0), (-x, x, 0), (-x, -x, 0),  # p_xy plane\n            (0, x, x), (0, x, -x), (0, -x, x), (0, -x, -x),  # p_yz plane\n            (x, 0, x), (-x, 0, x), (x, 0, -x), (-x, 0, -x)   # p_zx plane\n    ]\n    \n    next_pts = []\n    for offset in offsets:\n        next_pt = rs.AddPoint((a + offset[0], b + offset[1], c + offset[2]))\n        next_pts.append(next_pt)\n        next_cord = rs.PointCoordinates(next_pt)\n        \n        if next_cord not in container:\n            if mode in [0, 1, 2]:\n                if mode == 0:\n                     polyline = diagonal(width, len, offset, pt_cord, next_cord)\n        \n                elif mode == 1:\n                     polyline = z_shape(width, len, offset, pt_cord, next_cord)\n\n                elif mode == 2:\n                     polyline = triangle_shape(width, len, offset, pt_cord, next_cord)\n\n                rs.HideObjects(polyline)\n                #offset\n                if offset[0] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n                if offset[1] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n                if offset[2] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n                shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n                shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n                \n                ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n            else:\n                 if mode == 3:\n                    polylines = square(width, len, offset, pt_cord, next_cord)\n                 \n                 elif mode == 4:\n                    polylines = surface(width, len, offset, pt_cord, next_cord)\n                    \n                    rs.AddPlanarSrf(polylines)\n    pick_pt = rs.GetPoint(\"Select the next point: \", (0, 0, 0))\n    \n    cuboctahedron(pick_pt, rotation + 1, mode, number, container)\n\n\ndef point_set(pt_cord, len):\n    x = len/2\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    offset_cords = [\n        (a + x, b + x, c), (a + x, b - x, c), (a - x, b + x, c), (a - x, b - x, c),  # p_xy plane\n        (a, b + x, c + x), (a, b + x, c - x), (a, b - x, c + x), (a, b - x, c - x),  # p_yz plane\n        (a + x, b, c + x), (a - x, b, c + x), (a + x, b, c - x), (a - x, b, c - x)   # p_zx plane\n    ]\n    return offset_cords\n\ndef draw_mode(mode, width, len, offset, pt_cord, next_cord):\n    \n    \n    if mode in [0, 1, 2]:\n        if mode == 0:\n             polyline = diagonal(width, len, offset, pt_cord, next_cord)\n\n        elif mode == 1:\n             polyline = z_shape(width, len, offset, pt_cord, next_cord)\n\n        elif mode == 2:\n             polyline = triangle_shape(width, len, offset, pt_cord, next_cord)\n\n        rs.HideObjects(polyline)\n        #offset\n        if offset[0] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n        if offset[1] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n        if offset[2] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n        shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n        shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n        \n        ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n        \n    else:\n         if mode == 3:\n            polylines = square(width, len, offset, pt_cord, next_cord)\n         \n         elif mode == 4:\n            polylines = surface(width, len, offset, pt_cord, next_cord)\n         ps = rs.AddPlanarSrf(polylines)\n    return ps\n\n#def point_set_when_rotation_1(point):\n#    pass\n\n\ndef cuboctahedron_unit(pt_cord, rotation, mode, threshold, container):\n\n    if rotation >= threshold:\n        return\n        \n    len = 30\n    width = 1\n    offset_cords = point_set(pt_cord, len)\n    \n    #s_points\n    if rotation == 3:\n        rotation = 0\n        s_points= []\n        for s_point in container:\n            s_points.append(rs.AddPoint(s_point))\n        pt_cord = rs.GetPoint(\"Select a new center: \", container[-1])\n        \n        #update offset_cords\n        offset_cords = point_set(pt_cord, len)\n        #hide s_points\n        rs.HideObjects(s_points)\n       \n        \n    #n_points\n    n_points = []\n    if rotation == 1 or 2:\n        pt1 = pt_cord\n        pt2 = container[-1]\n        vec = pt2 - pt1\n        a = vec[0]\n        b = vec[1]\n        c = vec[2]\n        x = len/2\n        if a == 0:\n            offset_cords = [[(a + x, b, 0), (a - x, b, 0)], #perpendicular\n                        [(a + x, 0, c), (a - x, 0, c)],\n                        [(a + x, b, 0), (a, b, -c)], #extension\n                        [(a - x, b, 0), (a, b, -c)],\n                        [(a + x, 0, c), (a, -b, c)],\n                        [(a - x, 0, c), (a, -b, c)]]\n        if b == 0:\n            offset_cords = [[(a, b + x, 0), (a, b - x, 0)],\n                        [(0, b + x, c), (0, b - x, c)],\n                        [(a, b + x, 0), (a, b, -c)], #extension\n                        [(a, b - x, 0), (a, b, -c)],\n                        [(0, b + x, c), (-a, b, c)],\n                        [(0, b - x, c), (-a, b, c)]]\n        if c == 0:\n            offset_cords = [[(0, b, c + x), (0, b, c - x)],\n                        [(a, 0, c + x), (a, 0, c - x)],\n                        [(0, b, c + x), (-a, b, c)], #extension\n                        [(0, b, c - x), (-a, b, c)],\n                        [(a, 0, c + x), (a, -b, c)],\n                        [(a, 0, c - x), (a, -b, c)]]\n        \n        for set in offset_cords:\n            for point in set:\n                n_point = rs.AddPoint(point)\n                n_points.append(n_point)\n        next_cord = rs.GetPoint(\"Select the next point: \", n_points[0])\n   \n        rs.HideObjects(n_points)\n        \n        for set in offset_cords:\n            if tuple(next_cord) in set:\n                for n_point in set:\n\n                    offset = [0,0,0]\n                    for i in range(3):\n                        offset[0] = n_point[0] - pt_cord[0]\n                        offset[1] = n_point[1] - pt_cord[1]\n                        offset[2] = n_point[2] - pt_cord[2]\n                    if next_cord not in container:\n                        ps = draw_mode(mode, width, len, offset, pt_cord, n_point)\n#                        ps_box.append(ps)\n\n    else: \n\n        for cord in offset_cords:\n            point = rs.AddPoint(cord)\n            n_points.append(point)\n            \n        next_cord = rs.GetPoint(\"Select the next point: \", n_points[0])\n        rs.HideObjects(n_points)\n        offset = next_cord - pt_cord\n        \n        #start draw according to the mode\n        if next_cord not in container:\n            ps = draw_mode(mode, width, len, offset, pt_cord, next_cord)\n#            ps_box.append(ps)\n            \n    container.append(next_cord)\n    cuboctahedron_unit(pt_cord, rotation + 1, mode, threshold, container)\n\n\n\n\ncenter_pt = rs.AddPoint( (0, 0, 0) )\n#brep = rs.AddSphere((0, 0, 0), 30)\n#brep = rs.GetObject(\"select 3D object\")\n\nrs.HideObject(center_pt)\ncenter_cord = rs.PointCoordinates(center_pt)\ncontainer = [center_cord]\nps_box = []\nc_box = []\nthreshold = 10   #rs.GetInteger(\"Insert the rotation rumber: \", 3)\n#cuboctahedron_symmetry(center_cord, 0, 2, threshold, container, brep, ps_box, c_box)\n#cuboctahedron(center_cord, 0, 0, threshold, container)\ncuboctahedron_unit(center_cord, 0, 4, threshold, container)\n#rs.HideObject(brep)\n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}