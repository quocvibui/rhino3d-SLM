{
  "source_url": "https://github.com/dhardestylewis/rhino_helper_scripts/blob/1902d7840da7adb94549860d6b6369a4f9856314/DivideFacades.py",
  "repo": "dhardestylewis/rhino_helper_scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "DivideFacades.py",
  "instruction": "Divide facades",
  "code": "import rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport time\nimport Rhino.Geometry as rg\n\ndef subdivide_curve(curve, new_layer, min_length=1.0):\n    try:\n        curve_length = rs.CurveLength(curve)\n        if curve_length < min_length:\n            return 0\n\n        segments = 4 if curve_length > 100 else 3 if curve_length > 50 else 2\n        \n        points = [rs.EvaluateCurve(curve, rs.CurveParameter(curve, i / segments)) for i in range(segments + 1)]\n        \n        subdivided_curves = []\n        for i in range(len(points) - 1):\n            sub_curve = rs.AddLine(points[i], points[i + 1])\n            if sub_curve:\n                rs.ObjectLayer(sub_curve, new_layer)\n                subdivided_curves.append(sub_curve)\n        \n        rs.DeleteObject(curve)\n        \n        return len(subdivided_curves)\n    except Exception as e:\n        print(\"Error in subdivide_curve: {}\".format(e))\n        return -1\n\ndef subdivide_mesh(mesh_id, new_layer, min_edge_length=1.0):\n    try:\n        mesh = rs.coercemesh(mesh_id)\n        if not mesh:\n            return 0\n\n        new_mesh = rg.Mesh()\n        vertices = mesh.Vertices.ToPoint3dArray()\n        face_indices = []\n\n        for i in range(mesh.Faces.Count):\n            face = mesh.Faces[i]\n            if face.IsQuad:\n                face_indices.append([face.A, face.B, face.C, face.D])\n            else:\n                face_indices.append([face.A, face.B, face.C])\n\n        new_vertices = list(vertices)\n        new_faces = []\n\n        for face in face_indices:\n            face_vertices = [vertices[i] for i in face]\n            edge_lengths = [face_vertices[i].DistanceTo(face_vertices[(i + 1) % len(face_vertices)]) for i in range(len(face_vertices))]\n            \n            if all(length <= min_edge_length for length in edge_lengths):\n                new_faces.append(face)\n            else:\n                midpoints = []\n                midpoint_indices = []\n                for i in range(len(face_vertices)):\n                    midpoint = face_vertices[i] + (face_vertices[(i + 1) % len(face_vertices)] - face_vertices[i]) * 0.5\n                    if midpoint not in new_vertices:\n                        new_vertices.append(midpoint)\n                    midpoint_indices.append(new_vertices.index(midpoint))\n                    midpoints.append(midpoint)\n                \n                if len(face) == 4:\n                    new_faces.append([face[0], midpoint_indices[0], midpoint_indices[3], face[3]])\n                    new_faces.append([midpoint_indices[0], face[1], midpoint_indices[1], midpoint_indices[3]])\n                    new_faces.append([midpoint_indices[3], midpoint_indices[1], face[2], face[3]])\n                    new_faces.append([midpoint_indices[0], midpoint_indices[1], midpoint_indices[2], midpoint_indices[3]])\n                else:\n                    new_faces.append([face[0], midpoint_indices[0], midpoint_indices[2]])\n                    new_faces.append([midpoint_indices[0], face[1], midpoint_indices[1]])\n                    new_faces.append([midpoint_indices[2], midpoint_indices[1], face[2]])\n                    new_faces.append([midpoint_indices[0], midpoint_indices[1], midpoint_indices[2]])\n\n        new_vertices_f = [rg.Point3f(v.X, v.Y, v.Z) for v in new_vertices]\n        print(\"Adding {} vertices and {} faces\".format(len(new_vertices_f), len(new_faces)))\n        \n        # Debugging: Print types and sample of vertices\n        print(\"Vertex types and samples:\")\n        for i, v in enumerate(new_vertices_f[:5]):\n            print(\"Type: {}, Value: {}\".format(type(v), v))\n\n        for v in new_vertices_f:\n            new_mesh.Vertices.Add(v)\n\n        for f in new_faces:\n            if len(f) == 4:\n                new_mesh.Faces.AddFace(f[0], f[1], f[2], f[3])\n            else:\n                new_mesh.Faces.AddFace(f[0], f[1], f[2])\n\n        new_mesh_id = sc.doc.Objects.AddMesh(new_mesh)\n        if new_mesh_id:\n            rs.ObjectLayer(new_mesh_id, new_layer)\n            rs.DeleteObject(mesh_id)\n            return 1\n        return 0\n    except Exception as e:\n        print(\"Error in subdivide_mesh: {}\".format(e))\n        return -1\n\ndef get_object_details(obj):\n    details = []\n    details.append(\"GUID: {}\".format(obj))\n    object_type = rs.ObjectType(obj)\n    details.append(\"Type: {}\".format(object_type))\n    \n    if rs.IsCurve(obj):\n        details.append(\"Object is a curve\")\n        details.append(\"Length: {}\".format(rs.CurveLength(obj)))\n    elif rs.IsMesh(obj):\n        details.append(\"Object is a mesh\")\n        details.append(\"Vertices: {}\".format(len(rs.MeshVertices(obj))))\n    else:\n        details.append(\"Object is neither a curve nor a mesh\")\n    \n    details.append(\"Layer: {}\".format(rs.ObjectLayer(obj)))\n    details.append(\"Name: {}\".format(rs.ObjectName(obj) or 'Unnamed'))\n    return \"\\n\".join(details)\n\ndef divide_all_facades(layer_name, min_curve_length=1.0, min_edge_length=1.0):\n    objects = rs.ObjectsByLayer(layer_name)\n    if not objects:\n        print(\"No objects found on the layer {}. Exiting.\".format(layer_name))\n        return\n\n    new_layer = \"{}_Subdivided\".format(layer_name)\n    if not rs.IsLayer(new_layer):\n        rs.AddLayer(new_layer)\n\n    total_objects = len(objects)\n    curve_count = sum(1 for obj in objects if rs.IsCurve(obj))\n    mesh_count = sum(1 for obj in objects if rs.IsMesh(obj))\n\n    print(\"\\nInitial Count:\\nTotal objects: {}\\nCurves: {}\\nMeshes: {}\".format(total_objects, curve_count, mesh_count))\n\n    chunk_size = 50\n    \n    rs.EnableRedraw(False)\n    \n    total_subdivisions = 0\n    processed_objects = 0\n    curve_processed_count = 0\n    mesh_processed_count = 0\n    \n    start_time = time.time()\n    \n    for i in range(0, total_objects, chunk_size):\n        chunk = objects[i:i + chunk_size]\n        for obj in chunk:\n            if rs.IsCurve(obj):\n                curve_processed_count += 1\n                subdivisions_count = subdivide_curve(obj, new_layer, min_length=min_curve_length)\n                if subdivisions_count == -1:\n                    print(\"Terminating script due to error in subdivide_curve.\")\n                    return\n                total_subdivisions += subdivisions_count\n            elif rs.IsMesh(obj):\n                mesh_processed_count += 1\n                subdivisions_count = subdivide_mesh(obj, new_layer, min_edge_length=min_edge_length)\n                if subdivisions_count == -1:\n                    print(\"Error encountered. Skipping problematic mesh.\")\n                    continue  # Skip the problematic mesh and continue processing\n                total_subdivisions += subdivisions_count\n        \n        processed_objects += len(chunk)\n        rs.EnableRedraw(True)\n        sc.doc.Views.Redraw()\n        rs.EnableRedraw(False)\n        sc.escape_test(False)\n    \n    end_time = time.time()\n    processing_time = end_time - start_time\n    \n    rs.EnableRedraw(True)\n    print(\"\\nFinal Report:\\nProcessed {} objects: {} curves, {} meshes\".format(total_objects, curve_processed_count, mesh_processed_count))\n    print(\"Created {} subdivided objects on layer '{}'\".format(total_subdivisions, new_layer))\n    print(\"Processing time: {:.2f} seconds\".format(processing_time))\n\nif __name__ == \"__main__\":\n    layer_name = rs.GetString(\"Enter the name of the layer containing facades to subdivide\", rs.CurrentLayer())\n    if layer_name and rs.IsLayer(layer_name):\n        divide_all_facades(layer_name)\n    else:\n        print(\"Invalid layer name. Exiting.\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}