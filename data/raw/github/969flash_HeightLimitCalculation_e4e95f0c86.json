{
  "source_url": "https://github.com/969flash/HeightLimitCalculation/blob/e793366dae588cbea91bc240d86dcce9cd52a2a1/src/utils.py",
  "repo": "969flash/HeightLimitCalculation",
  "repo_stars": 0,
  "repo_description": "가로구역별 높이제한 산정구역의 제한 높이 계산 자동화",
  "license": "unknown",
  "filepath": "src/utils.py",
  "instruction": null,
  "code": "# r: pyshp\n\nimport shapefile\nimport os\nfrom typing import List, Tuple, Any, Optional, Union\nimport ghpythonlib.components as ghcomp\nimport Rhino.Geometry as geo\nimport math\n\nTOL = 0.001  # 연산 허용 오차\nRAW_TOL = 0.1  # 원시 데이터 허용 오차\n\n\nclass Parcel:\n    \"\"\"기본 필지 클래스\"\"\"\n\n    def __init__(\n        self,\n        region: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = region  # 외부 경계 커브\n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  # 내부 구멍들\n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n        self._area = None\n\n    @property\n    def area(self) -> float:\n        \"\"\"필지 면적 계산\"\"\"\n        if self._area is None:\n            outer_area = get_area(self.region)\n            hole_area = get_area(self.hole_regions) if self.hole_regions else 0.0\n            self._area = outer_area - hole_area\n        return self._area\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"커브 전처리 (invalid 제거, 자체교차 제거, 단순화)\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        # 자체교차 확인\n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, TOL)\n        if intersection_events:\n            simplified = self.region.Simplify(\n                geo.CurveSimplifyOptions.All, RAW_TOL, 1.0\n            )\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        # 일반 단순화\n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, RAW_TOL, 1.0)\n        if simplified:\n            self.region = simplified\n\n        # 내부 구멍들도 처리\n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(\n                    geo.CurveSimplifyOptions.All, RAW_TOL, 1.0\n                )\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\"도로 클래스\"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\"대지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  # 자루형 토지 여부\n        self.has_road_access = False  # 도로 접근 여부\n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile을 읽어서 shapes와 records를 반환\"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"점 리스트에서 특정 구간의 커브를 생성\"\"\"\n    # 최소 3개의 점이 필요\n    if end_idx - start_idx < 3:\n        return None\n\n    # 시작과 끝 점이 동일하지 않으면(닫혀있지 않으면) None 반환\n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape의 각 파트의 시작과 끝 인덱스를 반환\"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"두 커브 사이의 교차점을 계산합니다.\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections]\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 모든 정점(Vertex)들을 추출합니다.\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef is_pt_on_crv(pt: geo.Point3d, crv: geo.Curve, tol=TOL):\n    \"\"\"pt가 crv 위에 있는지 확인\"\"\"\n    rc, param = crv.ClosestPoint(pt, tol)\n    if not rc:\n        return False\n\n    closest_pt = crv.PointAt(param)\n    if closest_pt.DistanceTo(pt) <= tol:\n        return True\n\n    return False\n\n\ndef is_seg_on_crv(seg: geo.Curve, crv: geo.Curve, tol=TOL):\n    \"\"\"seg가 crv 위에 있는지 확인\"\"\"\n    # seg의 끝점 밑 중점은 crv 위에 있어야 한다.\n    for pt in (seg.PointAtStart, seg.PointAtEnd):\n        if not is_pt_on_crv(pt, crv, tol):\n            return False\n\n    pt_mid = seg.PointAtNormalizedLength(0.5)\n    if not is_pt_on_crv(pt_mid, crv, tol):\n        return False\n\n    return True\n\n\ndef get_overlapped_curves(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Curve]:\n    \"\"\"두 커브가 겹치는 구간의 커브들을 반환합니다.\"\"\"\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    if not intersection_points:\n        return []\n\n    params = [curve_a.SpanDomain(i)[0] for i in range(curve_a.SpanCount)]\n    params += [curve_a.ClosestPoint(pt, tol)[1] for pt in intersection_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [seg for seg in shatter_result if is_seg_on_crv(seg, curve_b)]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브가 겹치는 총 길이를 계산합니다.\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape에서 외부 경계와 내부 구멍 커브들을 추출\"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    # 단일 폴리곤이고 닫혀있지 않은 경우 처리\n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > TOL:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"레코드에서 특정 필드값을 안전하게 추출\"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape에서 Parcel 객체 생성\"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  # 구 PNU\n    jimok = get_field_value(record, fields, \"A11\")  # 구 JIMOK\n\n    if jimok == \"도로\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"두 커브가 교차하는지 여부를 확인합니다.\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\"모든 shape에서 Parcel 객체들을 생성\"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel 리스트를 Lot과 Road로 분류\"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"영역 커브의 면적을 계산합니다.\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, 6)\n\n\ndef get_straight_skeleton(region_curve):\n    \"\"\"\n    스트레이트 스켈레톤 알고리즘 기반 중심선 추출\n    \"\"\"\n    # 1. 입력 커브를 폴리라인으로 변환\n    if not region_curve.IsClosed:\n        return None\n\n    polyline = None\n    if isinstance(region_curve, geo.PolylineCurve):\n        polyline = region_curve.ToPolyline()\n    else:\n        # 곡선일 경우 분할하여 근사화\n        polyline_curve = region_curve.ToPolyline(0, 0, 0.1, 0.1, 0.1, 0, 0, 0, True)\n        polyline = polyline_curve.ToPolyline()\n\n    points = list(polyline)\n    if points[0].DistanceTo(points[-1]) < 0.001:\n        points.pop()  # 중복 끝점 제거\n\n    n = len(points)\n    skeleton_lines = []\n\n    # 2. 각 꼭짓점에서 이등분선(Bisector) 방향 계산\n    bisectors = []\n    for i in range(n):\n        p_prev = points[(i - 1 + n) % n]\n        p_curr = points[i]\n        p_next = points[(i + 1) % n]\n\n        v1 = p_prev - p_curr\n        v2 = p_next - p_curr\n        v1.Unitize()\n        v2.Unitize()\n\n        # 두 벡터의 합으로 이등분선 방향 설정\n        bisect_vec = v1 + v2\n\n        # 직선이 평행한 경우 처리\n        if bisect_vec.Length < 1e-6:\n            bisect_vec = geo.Vector3d(-v1.Y, v1.X, 0)\n        else:\n            bisect_vec.Unitize()\n\n        # 내부 방향 확인 (Cross Product 활용)\n        cross = geo.Vector3d.CrossProduct(v1, v2)\n        if cross.Z > 0:  # 시계/반시계 방향에 따라 반전 필요할 수 있음\n            bisect_vec *= -1\n\n        bisectors.append(bisect_vec)\n\n    # 3. 이웃한 이등분선 간의 교점 계산 (Event Simulation)\n    # 단순화를 위해 각 꼭짓점에서 시작하는 이등분선과 다음 이등분선의 교점을 연결\n    new_points = []\n    for i in range(n):\n        line1 = geo.Line(points[i], points[i] + bisectors[i] * 1000)\n        next_idx = (i + 1) % n\n        line2 = geo.Line(\n            points[next_idx], points[next_idx] + bisectors[next_idx] * 1000\n        )\n\n        rc, a, b = geo.Intersect.Intersection.LineLine(line1, line2)\n        if rc:\n            intersect_pt = line1.PointAt(a)\n            # 원래 꼭짓점에서 교점까지의 선을 스켈레톤의 일부로 추가\n            skeleton_lines.append(geo.LineCurve(points[i], intersect_pt))\n            skeleton_lines.append(geo.LineCurve(points[next_idx], intersect_pt))\n            new_points.append(intersect_pt)\n\n    # 4. 교점들끼리 연결하여 내부 중심선 완성\n    for i in range(len(new_points)):\n        p1 = new_points[i]\n        p2 = new_points[(i + 1) % len(new_points)]\n        if p1.DistanceTo(p2) > 0.001:\n            skeleton_lines.append(geo.LineCurve(p1, p2))\n\n    return geo.Curve.JoinCurves(skeleton_lines)\n\n\n# 실행 예시\n# skeleton = get_straight_skeleton(input_region)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}