{
  "source_url": "https://github.com/Mluminance/model/blob/412a64af7d685e468f8d174225ba597aa90967d6/grasshopper_model/archive/app.py",
  "repo": "Mluminance/model",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "grasshopper_model/archive/app.py",
  "instruction": null,
  "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm as rdm\nimport math\nfrom load_model_rhino import runDaylightPrediction\n\n# utilties:\n# calculate area\n# (X[i], Y[i]) are coordinates of i'th point.\n# This code is contributed by\n# Smitha Dinesh Semwal\ndef polygonArea(X, Y, n):\n \n    # Initialize area\n    area = 0.0\n \n    # Calculate value of shoelace formula\n    j = n - 1\n    for i in range(0,n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i   # j is previous vertex to i\n \n    # Return absolute value\n    return int(abs(area / 2.0))\n\n# register hops app as middleware\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n@hops.component(\n    \"/getUDIPrediction\",\n    name=\"Get UDI prediction\",\n    description=\"Predicts the UDI of a given room object\",\n    #icon=\"learncarbon_logo_without_text.png\",\n    inputs=[\n        hs.HopsCurve(\"roomBoundary\", \"Room Boundary Curve\", \"Closed curve representing the room boundary\"),\n        hs.HopsNumber(\"windowWidth\", \"Window Width\", \"Width of Window\"),\n        hs.HopsNumber(\"windowHeight\", \"Window Height\", \"Height of Window\"),\n    ],\n    outputs=[\n        hs.HopsNumber(\"UDIPrediction\", \"UDI Prediction\", \"Prediction of UDI for room\")\n    ]\n)\ndef getUDIPrediction(roomBoundary, windowWidth,windowHeight):\n\n    #convert to polyline to be able to measure distances\n    myPolyline = roomBoundary.ToPolyline()\n    \n    point0: rdm.Point3d = myPolyline[0]\n    point1: rdm.Point3d = myPolyline[1]\n    point2: rdm.Point3d = myPolyline[2]\n    point3: rdm.Point3d = myPolyline[3]\n\n    # calculating distances\n    sideA = point0.DistanceTo(point1)\n    sideB = point1.DistanceTo(point2)\n    sideC = point2.DistanceTo(point3)\n    sideD = point3.DistanceTo(point0)\n\n    # calculating orientation\n    # get first vector\n    vX = point1.X - point0.X\n    vY = point1.Y - point0.Y\n    vZ = point1.Z - point0.Z \n\n    fVector = rdm.Vector3d(vX,vY,vZ)\n\n    #compute north vector\n    nVector = rdm.Vector3d(0.0,0.0,0.0)\n\n    # calculate angle according to x access\n    # based on https://stackoverflow.com/questions/42258637/how-to-know-the-angle-between-two-vectors\n    radAngle = math.atan2(fVector.X-nVector.X, fVector.Y-nVector.Y) - math.pi*0.5\n    degAngle = abs(math.degrees(radAngle))\n\n    if degAngle <= 180 and degAngle >= 90:\n        orientation = abs(degAngle - 180)\n    elif degAngle <= 90 and degAngle >= 0 and radAngle < 0:\n        orientation = abs(degAngle - 180)\n    elif degAngle <= 90 and degAngle >= 0 and radAngle > 0:\n        orientation = degAngle + 180\n    elif degAngle  <= 270 and degAngle >= 180:\n        orientation = (360 - degAngle) + 180\n\n    # calcute area:\n    X = [point0.X, point1.X, point2.X, point3.X]\n    Y = [point0.Y, point1.Y, point2.Y, point3.Y]\n    n = len(X)\n    area = polygonArea(X, Y, n)\n\n    prediction = runDaylightPrediction(sideA,sideB,sideC,sideD,windowWidth,windowHeight,orientation,area)\n    #print(prediction)\n\n    myPredictions = []\n    for p in prediction:\n        fValue = float(p)\n        if fValue < 0.0:\n            fValue = 0.0\n            myPredictions.append(fValue)\n        else:\n            myPredictions.append(fValue)\n    \n\n    print(orientation)\n\n    return myPredictions\n\nif __name__ == \"__main__\":\n    app.run()\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}