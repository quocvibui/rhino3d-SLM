{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/gh_compo_io/assmbly_create_heterogeneous_material.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/gh_compo_io/assmbly_create_heterogeneous_material.py",
  "instruction": "GHCompo Interface: HBPH - Create Heterogeneous Material.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"GHCompo Interface: HBPH - Create Heterogeneous Material.\"\"\"\n\ntry:\n    from typing import Any, List, Optional, Sequence, Tuple\nexcept ImportError:\n    pass  # IronPython 2.7\n\ntry:\n    from Rhino.Geometry import Brep  # type: ignore\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import Rhino:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_energy.material import opaque\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_energy:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph_rhino import gh_io\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_energy_ph.properties.materials.opaque import (\n        CellPositionError,\n        EnergyMaterialPhProperties,\n        PhDivisionGrid,\n    )\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_energy_ph:\\n\\t{}\".format(e))\n\ntry:\n    from ph_units.converter import convert\n    from ph_units.parser import parse_input\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ph_units:\\n\\t{}\".format(e))\n\n\ndef generate_preview(_IGH, _column_widths, _row_heights):\n    # type: (gh_io.IGH, Sequence[float], Sequence[float]) -> List[Brep]\n    \"\"\"Generate a Rhino geometry preview of the grid material\"\"\"\n    print(\"- \" * 25)\n    print(\"Generating Preview of the Heterogeneous Material Cells...\")\n\n    total_width = sum(_column_widths)\n    total_height = sum(_row_heights)\n\n    # -- Create the Vertical Edges\n    left_edge = _IGH.ghc.LineSDL(_IGH.ghc.ConstructPoint(0, 0, 0), _IGH.ghc.UnitY(1), total_height)\n    vertical_edges = [left_edge]\n    vertical_move_dist = 0.0\n    for width in _column_widths:\n        vertical_move_dist += width\n        vertical_edges.append(_IGH.ghc.Move(left_edge, _IGH.ghc.UnitX(vertical_move_dist)).geometry)\n\n    # --- Crete the Horizontal Edges\n    bottom_edge = _IGH.ghc.LineSDL(_IGH.ghc.ConstructPoint(0, 0, 0), _IGH.ghc.UnitX(1), total_width)\n\n    horizontal_edges = [bottom_edge]\n    horizontal_move_dist = 0.0\n    for height in _row_heights[::-1]:  # Reverse since we're now building 'up', not 'down'\n        horizontal_move_dist += height\n        horizontal_edges.append(_IGH.ghc.Move(bottom_edge, _IGH.ghc.UnitY(horizontal_move_dist)).geometry)\n\n    # --- Create the Cell Surface Breps\n    boundary = _IGH.ghc.BoundarySurfaces(\n        _IGH.ghc.Rectangle2Pt(\n            plane=_IGH.ghc.ConstructPlane(\n                _IGH.ghc.ConstructPoint(0, 0, 0),\n                _IGH.ghc.UnitX(1),\n                _IGH.ghc.UnitY(1),\n            ),\n            point_a=_IGH.ghc.ConstructPoint(0, 0, 0),\n            point_b=_IGH.ghc.ConstructPoint(total_width, total_height, 0),\n            radius=0,\n        ).rectangle\n    )\n\n    surfaces = _IGH.ghc.SurfaceSplit(boundary, vertical_edges + horizontal_edges)\n\n    return surfaces\n\n\nclass GHCompo_CreateHeterogeneousMaterial(object):\n    def __init__(self, IGH, _base_material, _additional_materials, _column_widths, _row_heights):\n        # type: (gh_io.IGH, Optional[opaque.EnergyMaterial], Sequence[opaque.EnergyMaterial], Sequence[float], Sequence[float]) -> None\n        self.IGH = IGH\n        self.base_material = _base_material\n        self.additional_materials = _additional_materials\n        self.column_widths = _column_widths\n        self.row_heights = _row_heights\n\n    @property\n    def all_materials(self):\n        # type: () -> List[opaque.EnergyMaterial]\n        \"\"\"Get all the materials including the base and additional materials.\"\"\"\n        mats = []\n        for mat in self.additional_materials:\n            if mat is not None:\n                mats.append(mat)\n        if self.base_material is not None:\n            mats.insert(0, self.base_material)\n        return mats\n\n    def ready(self):\n        # type: () -> bool\n        \"\"\"Check if all the inputs are ready, perform some cleanup on the inputs.\"\"\"\n\n        if not self.base_material:\n            return False\n\n        if not self.additional_materials:\n            return False\n\n        if not self.column_widths and not self.row_heights:\n            return False\n\n        if (not self.column_widths) and self.row_heights:\n            self.column_widths = [1.0]\n\n        if (not self.row_heights) and self.column_widths:\n            self.row_heights = [1.0]\n\n        self.check_materials_for_user_data()\n        self.column_widths = self.convert_column_widths(self.column_widths, \"M\")\n        self.row_heights = self.convert_row_heights(self.row_heights, \"M\")\n        return True\n\n    def check_materials_for_user_data(self):\n        # type: () -> None\n        \"\"\"Check to make sure all the additional materials have user_data attributes.\"\"\"\n        for mat in self.additional_materials:\n            if not hasattr(mat.properties, \"ph\"):\n                raise ValueError(\"Error: Material '{}' does not have a PH properties?\".format(mat.display_name))\n            if not hasattr(mat.properties.ph, \"user_data\"):  # type: ignore\n                raise ValueError(\"Error: Material '{}' does not have user_data?\".format(mat.display_name))\n\n    def convert_column_widths(self, _column_widths, _unit=\"M\"):\n        # type: (Sequence[str | float], str) -> List[float]\n        \"\"\"Convert the column-width inputs to meters.\"\"\"\n        column_widths_ = []\n        for col_width in _column_widths:\n            input_val, input_unit = parse_input(col_width)\n            converted_value = convert(input_val, input_unit or \"M\", _unit)\n            column_widths_.append(converted_value)\n            print(\"Converting {}-{} to {:.3f}-{}\".format(input_val, input_unit or \"M\", converted_value, _unit))\n        return column_widths_\n\n    def convert_row_heights(self, _row_heights, _unit=\"M\"):\n        # type: (Sequence[str | float], str) -> List[float]\n        \"\"\"Convert the row-height inputs to meters.\"\"\"\n        row_heights_ = []\n        for row_height in _row_heights:\n            input_val, input_unit = parse_input(row_height)\n            converted_value = convert(input_val, input_unit or \"M\", _unit)\n            row_heights_.append(converted_value)\n            print(\"Converting {}-{} to {:.3f}-{}\".format(input_val, input_unit or \"M\", converted_value, _unit))\n        return row_heights_\n\n    def check_material_thicknesses(self, material, _tol=0.001):\n        # type: (opaque.EnergyMaterial, float) -> None\n        \"\"\"Check the thickness of the material and the division grid.\"\"\"\n        base_thickness = material.thickness\n        for addnl_material in self.additional_materials:\n            if abs(addnl_material.thickness - base_thickness) > _tol:\n                msg = (\n                    \"WARNING: Material '{}' has a different thickness from the base material '{}'. \"\n                    \"The base-material thickness of {:.2f} will be used when creating the heterogeneous-material.\".format(\n                        material.display_name, addnl_material.display_name, material.thickness\n                    )\n                )\n                print(msg)\n                self.IGH.warning(msg)\n                break\n\n    def check_material_conductivities(self, material):\n        # type: (opaque.EnergyMaterial) -> None\n        for addnl_mat in self.additional_materials:\n            if addnl_mat.conductivity > 10.0:\n                msg = (\n                    \"WARNING: Material '{}' has a very high conductivity value of {:.2f} W/m-K. \"\n                    \"Note that metal elements like steel studs and metal fasteners may NOT be \"\n                    \"used as part of heterogeneous assemblies (as per ISO 6946).\".format(\n                        addnl_mat.display_name, addnl_mat.conductivity\n                    )\n                )\n                print(msg)\n                self.IGH.error(msg)\n                break\n\n    def set_cell_material(self, _division_grid, _column, _row, _material):\n        # type: (PhDivisionGrid, int, int, opaque.EnergyMaterial) -> None\n        print(\n            \"Setting Material at: Column-{} | Row-{} to '{}' [id={}]\".format(\n                _column, _row, _material.display_name, id(_material)\n            )\n        )\n        try:\n            _division_grid.set_cell_material(_column, _row, _material)\n        except CellPositionError as e:\n            print(\"- \" * 25)\n            print(\"WARNING: Check the '_column_widths' and '_row_heights' inputs.\\n\")\n            raise e\n\n    def run(self):\n        # type: () -> Tuple[Optional[opaque.EnergyMaterial], Optional[Any]]\n        if not self.ready() or not self.base_material:\n            return (self.base_material, None)\n\n        # --------------------------------------------------------------------------------------------------------------\n        # -- Setup the Division Grid\n        division_grid = PhDivisionGrid()\n        division_grid.set_column_widths(self.column_widths)\n        division_grid.set_row_heights(self.row_heights)\n\n        for row in range(division_grid.row_count):\n            for col in range(division_grid.column_count):\n                division_grid.set_cell_material(col, row, self.base_material)\n\n        for material in self.additional_materials:\n            hbph_mat_props = getattr(material.properties, \"ph\")  # type: EnergyMaterialPhProperties\n            col = hbph_mat_props.user_data.get(\"column_position\", 0)\n            row = hbph_mat_props.user_data.get(\"row_position\", 0)\n            self.set_cell_material(division_grid, col, row, material)\n\n        # --------------------------------------------------------------------------------------------------------------\n        # -- Create a new Hybrid Material\n        base_material = division_grid.get_base_material()\n        if not base_material:\n            return (None, None)\n        new_material_ = base_material.duplicate()\n        nm = \"+\".join([_.display_name for _ in self.all_materials])\n        new_material_.display_name = nm\n        new_material_.identifier = nm\n        new_material_.conductivity = division_grid.get_equivalent_conductivity()\n        hbph_props = getattr(new_material_.properties, \"ph\")  # type: EnergyMaterialPhProperties\n        hbph_props.divisions = division_grid\n\n        # --------------------------------------------------------------------------------------------------------------\n        self.check_material_thicknesses(new_material_)\n        self.check_material_conductivities(new_material_)\n\n        preview_ = generate_preview(\n            self.IGH,\n            self.convert_column_widths(self.column_widths, self.IGH.get_rhino_unit_system_name()),\n            self.convert_row_heights(self.row_heights, self.IGH.get_rhino_unit_system_name()),\n        )\n\n        return new_material_, preview_\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}