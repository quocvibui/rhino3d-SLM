{
  "source_url": "https://github.com/Hand-and-Machine/TRAvel_Slicer/blob/9e76041ef572288b290e12512c7bc7dfbcb0bbe4/src/TRAvel_Slicer.py",
  "repo": "Hand-and-Machine/TRAvel_Slicer",
  "repo_stars": 6,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/TRAvel_Slicer.py",
  "instruction": "Travel slicer",
  "code": "import math\nimport time\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport extruder_turtle  \nimport turtle_utilities as tu\nfrom extruder_turtle import *\n\nimport outer_travel_utils\nfrom outer_travel_utils import *\n\nimport geometry_utils\nfrom geometry_utils import *\n\nimport contour_utils\nfrom contour_utils import *\n\nmax_z = 0\n\ndef draw_points(t, points, start_idx=0, bboxes=[], move_up=True, spiral_seam=False, outer_wall=False):\n    global max_z\n\n    travel = []\n    if len(points) > 1:\n        pos = t.get_position()\n        speed = float(t.get_speed())\n        layer_height = float(t.get_layer_height())\n        nozzle_width = float(t.get_nozzle_width())\n        extrude_width = float(t.get_extrude_width())\n\n        # retract if travel is greater than 2mm\n        short_dist = 1\n        retract_dist = 6.5\n        retract_min_dist_requirement = 2\n        if rs.Distance(pos, points[start_idx]) > retract_min_dist_requirement:\n            t.pen_up()\n\n        if t.get_printer()=='ender':\n            t.pen_up()\n            t.set_speed(speed*3/2)\n\n            if rs.Distance(pos, points[start_idx]) > retract_min_dist_requirement:\n                t.extrude(-retract_dist)\n            elif rs.Distance(pos, points[start_idx]) > max(extrude_width*3, 2*layer_height):\n                t.extrude(-short_dist)\n\n            t.set_speed(9000)\n\n        if move_up and rs.Distance(pos, points[start_idx]) > max(extrude_width, max(nozzle_width, 3*layer_height)):\n            z_lift = 2*layer_height\n            higher_z = max(pos.Z, points[start_idx].Z)+z_lift\n            # go up layer_height*2, go to start position of next start + layer_height*2\n            points1 = [rs.CreatePoint(pos.X, pos.Y, pos.Z+z_lift), rs.CreatePoint(points[start_idx].X, points[start_idx].Y, points[start_idx].Z+z_lift)]\n            # go up to higher z between current and next position, move parallel to x-y plane to next start point\n            points2 = [rs.CreatePoint(pos.X, pos.Y, higher_z), rs.CreatePoint(points[start_idx].X, points[start_idx].Y, higher_z), points[start_idx]]\n            # go up to maximum height, move parallel to x-y plane\n            points3 = [rs.CreatePoint(pos.X, pos.Y, max_z+z_lift), rs.CreatePoint(points[start_idx].X, points[start_idx].Y, max_z+z_lift), points[start_idx]]\n\n            if check_path_intersection(t, points1, bboxes):\n                travel_points = points1\n            elif check_path_intersection(t, points2, bboxes):\n                travel_points = points2\n            else:\n                travel_points = points3\n            \n            for t_pnt in travel_points:\n                t.set_position(t_pnt.X, t_pnt.Y, t_pnt.Z)\n\n            travel.append(rs.AddPolyline([pos]+travel_points))\n        else:\n            t.set_position(points[start_idx].X, points[start_idx].Y, points[start_idx].Z)\n            travel.append(rs.AddPolyline([pos, points[start_idx]]))\n\n        if t.get_printer()=='ender':\n            t.set_speed(speed*3/2)\n            if rs.Distance(pos, points[start_idx]) > retract_min_dist_requirement:\n                t.extrude(retract_dist)\n            elif rs.Distance(pos, points[start_idx]) > max(extrude_width*3, 2*layer_height):\n                t.extrude(short_dist)\n\n            box = rs.BoundingBox(points)\n            side = get_longest_side(box)\n            if side<5.0:\n                t.set_speed(float(speed*0.5))\n            elif side<=20.0:\n                t.set_speed(float(speed*(0.05*side)))\n            else:\n                t.set_speed(speed)\n\n        t.pen_down()\n\n        indices = range(start_idx, len(points)) + range(0, start_idx)\n        for p in indices:\n            t.set_position(points[p].X, points[p].Y, points[p].Z)\n            if points[p].Z > max_z: max_z = points[p].Z\n\n        if spiral_seam: t.set_position(points[start_idx].X, points[start_idx].Y, points[start_idx].Z)\n\n        t.set_speed(speed)\n\n    return travel\n\n\ndef get_transition_movements(t, node_path, start_point):\n    boxes = []\n    seam_points = []\n    transitions = []\n\n    for s in range(len(node_path)):\n        if node_path[s].data.height!=node_path[s-1].data.height:\n            # only compare to boxes within nozzle height chunk\n            boxes = []\n        if node_path[s].data.box!=None: boxes.append(node_path[s].data.box)\n\n        for node in node_path[s].data.sub_nodes:\n            curves = node.data\n            for crvs in curves:\n                dist = 100000000000\n                s_pnt = None\n                for crv in crvs:\n                    pnt = rs.EvaluateCurve(crv, rs.CurveClosestPoint(crv, start_point))\n                    d = rs.Distance(start_point, pnt)\n                    if d < dist:\n                        dist = d\n                        s_pnt = pnt\n                start_point = s_pnt\n                seam_points.append(start_point)\n\n    return seam_points, transitions\n\n\ndef check_path_intersection(t, path, boxes):\n    nozzle_width = t.get_nozzle_width()\n    nozzle_height = t.get_nozzle_height()\n\n    # create a geometry that represents the nozzle along the path\n    direct = rs.CreatePoint(path[1].X, path[1].Y, 0.0) - rs.CreatePoint(path[0].X, path[0].Y, 0.0)\n\n    vecCW = rs.VectorScale(rs.VectorUnitize(rs.VectorRotate(direct, -90, [0,0,1])), nozzle_width/2)\n    vecCCW = rs.VectorScale(rs.VectorUnitize(rs.VectorRotate(direct, 90, [0,0,1])), nozzle_width/2)\n\n    vol_crv = rs.AddPolyline([path[0]+vecCCW, path[1]+vecCCW, path[1]+vecCW, path[0]+vecCW, path[0]+vecCCW])\n    path_vol = rs.ExtrudeCurveStraight(vol_crv, (0, 0, 0), (0, 0, nozzle_height*2))\n    rs.CapPlanarHoles(path_vol)\n\n    intersect1 = []\n    for b in (range(len(boxes)-2, -1, -1)):\n        int1 = rs.IntersectBreps(path_vol, boxes[b])\n        if int1 != None:\n            intersect1.append(int1)\n            break\n    if len(intersect1) == 0:\n        return True\n    return False\n\n\ndef get_corner(outer_curve, inner_curve, offset):\n    prec = 100\n    outer_points = rs.DivideCurve(outer_curve, prec)\n    center = get_area_center(inner_curve)\n\n    closest = {\"point\": rs.CurveStartPoint(outer_curve), \"distance\": 1000000}\n\n    for p in range(len(outer_points)):\n        pnt = outer_points[p]\n        prev_pnt = outer_points[(p-1) % len(outer_points)]\n        next_pnt = outer_points[(p+1) % len(outer_points)]\n        v1 = rs.VectorUnitize(rs.VectorSubtract(prev_pnt, pnt))\n        v2 = rs.VectorUnitize(rs.VectorSubtract(next_pnt, pnt))\n        dot = rs.VectorDotProduct(v1, v2)\n        add = rs.VectorAdd(v1, v2)\n\n        if not (add.X == 0 and add.Y == 0 and add.Z == 0):\n            # acos has a domain of [-1, 1], sometimes rhinoscript\n            # returns close to 1 due to a precision error\n            angle = math.acos(min(max(dot, -1), 1)) * (180 / math.pi)\n\n            if angle < 160 and angle > 20:\n                dist = rs.Distance(pnt, center)\n                # check that the corner isn't \"inverted\"\n                inside = rs.PointInPlanarClosedCurve(rs.VectorAdd(pnt, rs.VectorScale(rs.VectorUnitize(add), offset/4)), outer_curve)\n                if dist < closest[\"distance\"] and inside:\n                    closest[\"distance\"] = dist\n                    closest[\"point\"] = pnt\n\n    return closest[\"point\"]\n\n\ndef spiral_contours(t, isocontours, start_index=0):\n    if len(isocontours) == 0:\n        print(\"Error: no isocontours passed in\")\n        return\n    # a single spirallable region\n    # connect each isocontour with the one succeeding it\n    spiral = []\n    offset = float(t.get_extrude_width())\n    num_pnts = get_num_points(isocontours[0], offset)\n    points = rs.DivideCurve(isocontours[0], num_pnts)\n\n    # spiral region\n    start_point = None\n    spiral_contour_indices = []\n    for i in range(len(isocontours)):\n        start_point = points[start_index]\n\n        # get break point on isocontour for connecting spiral\n        marching_order = range(start_index, -1, -1) + range(len(points)-1, start_index, -1)\n        closest = {\"point\": None, \"length\":1000000, \"distance\": 1000000}\n\n        for j in marching_order:\n            if j != start_index:\n                dist = abs(0.75*offset - rs.Distance(start_point, points[j]))\n                if dist < closest[\"distance\"]:\n                    indices1 = []\n                    indices2 = []\n                    if j > start_index:\n                        indices1 = range(j, len(points)) + range(0, start_index+1)\n                        indices2 = range(j, start_index-1, -1)\n                    elif j < start_index:\n                        indices1 = range(j, start_index+1)\n                        indices2 = range(j, -1, -1) + range(len(points)-1, start_index-1, -1)\n\n                    length1 = len(indices1)\n                    length2 = len(indices2)\n                    if length2 > length1 and length2 < closest[\"length\"]:\n                        closest[\"distance\"] = dist\n                        closest[\"length\"] = length2\n                        closest[\"point\"] = j\n        break_index = closest[\"point\"]\n        if break_index == None:\n            print(\"Unable to find break_index on isocontour \"+str(i+1)+\" out of \"+str(len(isocontours)))\n            break\n        break_point = points[break_index]\n\n        # append the points from the isocontour from start_point\n        # to break_point to the spiral\n        indices = []\n        if start_index > break_index:\n            indices = range(start_index, len(points))+range(0, break_index+1)\n        elif start_index < break_index:\n            indices =  range(start_index, break_index+1)\n        else:\n            print(\"Error: start and break index should not be the same\")\n\n        spiral = spiral + [points[j] for j in indices]\n        spiral_contour_indices.append(len(spiral)-1)\n\n        # find closest point in next contour to the break point\n        # if we are not at the centermost contour\n        if i < len(isocontours) - 1:\n            next_points = rs.DivideCurve(isocontours[i+1], get_num_points(isocontours[i+1], offset))\n            closest = {\"point\": None, \"distance\": 1000000}\n            for j in range(len(next_points)):\n                dist = rs.Distance(break_point, next_points[j])\n                if dist < closest[\"distance\"]:\n                    closest[\"distance\"] = dist\n                    closest[\"point\"] = j\n\n            # set next start index and next points\n            start_index = closest[\"point\"]\n            points = next_points\n\n    # return spiral and corresponding contour index\n    return spiral, spiral_contour_indices\n\n\ndef fermat_spiral(contours, start_pnt, offset):\n    isocontours = [crv for crv in contours]\n\n    offset = float(offset)*0.8\n\n    start_param = rs.CurveClosestPoint(isocontours[0], start_pnt)\n    start = rs.EvaluateCurve(isocontours[0], start_param)\n    split_circ = rs.AddCircle(start, offset)\n    intersection = rs.CurveCurveIntersection(isocontours[0], split_circ)\n\n    l = intersection[0][5]\n    l_pnt = intersection[0][1]\n    for i in range(len(intersection)):\n        inter = intersection[i]\n        if inter[0] == 1:\n            trim_crv = rs.TrimCurve(isocontours[0], [start_param, inter[5]], delete_input=False)\n            crv_length = rs.CurveLength(trim_crv)\n            if crv_length<offset*2:\n                l = inter[5]\n                l_pnt = inter[1]\n\n    trims = [[l, start_param]]\n    joining_curves = []\n    for i in range(len(isocontours)-1):\n        split_circ = rs.AddCircle(l_pnt, offset)\n        intersection = rs.CurveCurveIntersection(isocontours[i], split_circ)\n\n        ll = intersection[0][5]\n        ll_pnt = intersection[0][1]\n        for inter in intersection:\n            trim_crv = rs.TrimCurve(isocontours[i], [l, inter[5]], delete_input=False)\n            crv_length = rs.CurveLength(trim_crv)\n            if crv_length<offset*2 and rs.Distance(l_pnt, inter[1])>offset/2:\n                ll = inter[5]\n                ll_pnt = inter[1]\n\n        trims[i] = [ll, start_param]\n\n        # find connecting points on next contour\n        up = rs.VectorSubtract(rs.CreatePoint(l_pnt.X, l_pnt.Y, l_pnt.Z+1.0), l_pnt)\n        l_prime = rs.CurveClosestPoint(isocontours[i+1], l_pnt+rs.VectorCrossProduct(up, rs.VectorSubtract(l_pnt, start)))\n        l_prime_pnt = rs.EvaluateCurve(isocontours[i+1], l_prime)\n\n        ll_prime = rs.CurveClosestPoint(isocontours[i+1], ll_pnt+rs.VectorSubtract(l_prime_pnt, l_pnt))\n        ll_prime_pnt = rs.EvaluateCurve(isocontours[i+1], ll_prime)\n\n        joining_curves.append(rs.AddCurve([l_pnt, l_prime_pnt]))\n        joining_curves.append(rs.AddCurve([ll_pnt, ll_prime_pnt]))\n\n        start = l_prime_pnt\n        start_param = l_prime\n\n        l_pnt = ll_prime_pnt\n        l = ll_prime\n\n        trims.append([l, start_param])\n\n    for i in range(len(isocontours)):\n        if trims[i][0] < 0.0000001: trims[i][0] = 0.0\n        if trims[i][1] < 0.0000001: trims[i][1] = 0.0\n        isocontours[i] = rs.TrimCurve(isocontours[i], trims[i], delete_input=False)\n\n    spiraled_curve = rs.JoinCurves(isocontours+joining_curves, tolerance=offset/2.)\n    if len(spiraled_curve) > 1:\n        print(rs.CurveStartPoint(spiraled_curve[0]).Z)\n        for sp_crv in spiraled_curve:\n            print(rs.CurveLength(sp_crv))\n        spiraled_curve = [sp_crv for sp_crv in spiraled_curve if rs.CurveLength(sp_crv)>offset]\n        print(spiraled_curve)\n\n    try:\n        return rs.DivideCurve(spiraled_curve, get_num_points(spiraled_curve, offset))\n    except:\n        print(\"Error dividing curve: \", spiraled_curve)\n        crv = sorted(spiraled_curve, key=lambda x: rs.CurveLength(x))[-1]\n        return rs.DivideCurve(crv, get_num_points(crv, offset))\n\n\ndef segment_tree(root):\n    region_root = Node(\"0\")\n    fill_region(region_root, root, 0)\n    return region_root\n\n\ndef fill_region(region_node, node, idx):\n    if(len(node.children) == 0):\n        # if the number of children is zero, append to curves\n        region_node.sub_nodes.append(node.data)\n    elif len(node.children) == 1:\n        # if the number of children is one, proceed to the next node\n        # in the tree and add curve to the region\n        region_node.sub_nodes.append(node.data)\n        fill_region(region_node, node.children[0], 0)\n    elif len(node.children) > 1:\n        # if the number of children is greater than one,\n        # we have found a split and need to add a new node\n        # add new region node and curve to the new region\n        new_node = region_node\n        if len(region_node.sub_nodes) > 0:\n            new_node = region_node.add_child(region_node.data+\"_\"+str(idx))\n\n        new_node.sub_nodes.append(node.data)\n\n        idx = 0\n        for child in node.children:\n            if len(child.children) > 1:\n                fill_region(new_node, child, idx)\n                idx = idx + 1\n            else:\n                # add new region node\n                new_new_node = new_node.add_child(new_node.data+\"_\"+str(idx))\n                fill_region(new_new_node, child, 0)\n                idx = idx + 1\n\n\ndef connect_spiralled_nodes(root, offset):\n    find_connections(root, offset)\n    all_nodes = root.get_all_nodes([])\n    all_nodes = {node.data: node for node in all_nodes}\n\n    path = connect_path(root, offset, all_nodes, 0, [])\n    spiral = []\n    for p in range(len(path)):\n        node = all_nodes[path[p][0]]\n        indices = get_marching_indices(node, path[p][1], path[p][2], path[p][3])\n        if indices != None:\n            spiral = spiral + [node.fermat_spiral[idx] for idx in indices]\n\n    return spiral\n\n\ndef connect_path(node, offset, all_nodes, start_idx, spiral):\n    final_idx = len(node.fermat_spiral)-1\n    if node.parent:\n        final_idx = next(idx for idx in node.connection[node.parent.data] if idx != start_idx)\n\n    marching_order, reverse = get_marching_order(node, start_idx, final_idx)\n\n    if not node.reverse:\n        node.reverse = reverse\n\n    if len(node.children)>0:\n        everything_sorted = sorted([(k, n) for n in node.connection for k in node.connection[n].keys()], key=lambda x: marching_order.index(x[0]))\n        sorted_children = []\n        for c in everything_sorted:\n            include = True\n            for child in sorted_children:\n                if child[1] == c[1]:\n                    include = False\n                    break\n            if include and c[0] != start_idx: sorted_children.append(c)\n\n        for c in sorted_children:\n            if len(c[1]) > len(node.data):\n                child = all_nodes[c[1]]\n                end_idx = c[0]\n\n                # add path from node to child index to spiral\n                spiral.append((node.data, start_idx, end_idx, reverse))\n\n                # recursively call connect_path on child\n                child_start_idx = node.connection[child.data][end_idx]\n                spiral = connect_path(child, offset, all_nodes, child_start_idx, spiral)\n\n                # find next start index for node\n                other_idx = next(idx for idx in child.connection[node.data] if idx != child_start_idx)\n                start_idx = child.connection[node.data][other_idx]\n\n    # close off spiral with remaining portion of node's fermat spiral\n    spiral.append((node.data, start_idx, final_idx, reverse))\n\n    return spiral\n\n\ndef get_marching_order(node, start, end):\n    points = node.fermat_spiral\n\n    other_idx = len(node.fermat_spiral)-1\n    if node.parent:\n        other_idx = next(idx for idx in node.connection[node.parent.data] if idx != start)\n\n    marching_order = []\n    reverse_marching_order = []\n    if start > other_idx:\n        marching_order = range(start, len(points)) + range(0, other_idx+1)\n        reverse_marching_order = range(start, other_idx-1, -1)\n    elif start < other_idx:\n        marching_order = range(start, other_idx+1)\n        reverse_marching_order = range(start, -1, -1) + range(len(points)-1, other_idx-1, -1)\n    else:\n        print(\"get_marching_order error: start and end indices should not be the same\")\n\n    if len(marching_order) < len(reverse_marching_order):\n        return get_marching_indices(node, start, end, True), True\n    else:\n        return get_marching_indices(node, start, end, False), False\n\n\ndef get_marching_indices(node, start, end, reverse):\n    points = node.fermat_spiral\n\n    if reverse:\n        if start > end:\n            return range(start, end-1, -1)\n        elif start < end:\n            return range(start, -1, -1) + range(len(points)-1, end-1, -1)\n        else:\n            print(\"get_marching_indices error: start and end indices should not be the same\")\n    else:\n        if start > end:\n            return range(start, len(points)) + range(0, end+1)\n        elif start < end:\n            return range(start, end+1)\n        else:\n            print(\"get_marching_indices error: start and end indices should not be the same\")\n\n\ndef find_connections(node, offset):\n    for child in node.children:\n        find_connections(child, offset)\n\n    parent = node.parent\n    if parent!=None and parent.fermat_spiral!=None:\n        connect_node_to_parent(node, parent, offset)\n\n\ndef connect_node_to_parent(node, parent, offset):\n    #offset = float(t.get_extrude_width())\n\n    node_start, node_end = get_connection_indices(node, offset)\n\n    points = node.fermat_spiral\n    start_pnt = points[node_start]\n    end_pnt = points[node_end]\n\n    if node_start == node_end or rs.Distance(start_pnt, end_pnt) == 0:\n        print(\"Error: could not find suitable connection indices\", node_start, node_end)\n        return\n\n    direction = 90\n    vec = rs.VectorSubtract(end_pnt, start_pnt)\n    vec = rs.VectorScale(rs.VectorUnitize(rs.VectorRotate(vec, direction, [0, 0, 1])), offset)\n    pnt1 = rs.VectorAdd(start_pnt, vec)\n    pnt2 = rs.VectorAdd(end_pnt, vec)\n\n    if (rs.PointInPlanarClosedCurve(pnt1, node.sub_nodes[0]) or rs.PointInPlanarClosedCurve(pnt2, node.sub_nodes[0])):\n        # collision occurred, switching directions\n        vec = rs.VectorSubtract(end_pnt, start_pnt)\n        vec = rs.VectorScale(rs.VectorUnitize(rs.VectorRotate(vec, -direction, [0, 0, 1])), offset)\n        pnt1 = rs.VectorAdd(start_pnt, vec)\n        pnt2 = rs.VectorAdd(end_pnt, vec)\n\n    # search parent node points for points\n    # closest to computed intersection\n    closest = {\"start\": {\"point\": None, \"distance\": 1000000}, \"end\": {\"point\": None, \"distance\": 1000000}}\n    points = parent.fermat_spiral\n    for p in range(len(points)):\n        dist = rs.Distance(points[p], pnt1)\n        if dist < closest[\"start\"][\"distance\"]:\n            closest[\"start\"][\"distance\"] = dist\n            closest[\"start\"][\"point\"] = p\n\n    for p in range(len(points)):\n        dist1 = rs.Distance(points[p], pnt2)\n        dist2 = rs.Distance(points[p], pnt1) - offset*0.75\n        if (p != closest[\"start\"][\"point\"]\n            and abs(dist2) <= offset*0.75\n            and dist1 < closest[\"end\"][\"distance\"]):\n            closest[\"end\"][\"distance\"] = dist1\n            closest[\"end\"][\"point\"] = p\n\n    parent_start = closest[\"start\"][\"point\"]\n    parent_end = closest[\"end\"][\"point\"]\n\n    if parent_start == None or parent_end == None:\n        print(\"Did not find suitable connection to outer contour\", node_start, node_end, parent_start, parent_end)\n        return\n\n    parent.connection[node.data] = { parent_start: node_start, parent_end: node_end }\n    node.connection[parent.data] = { node_start: parent_start, node_end: parent_end }\n\n\ndef get_connection_indices(node, offset):\n    #offset = float(t.get_extrude_width())\n\n    start_index = 0\n    end_index = len(node.fermat_spiral) - 1\n\n    if node.type == 2 or len(node.sub_nodes) == 1:\n        points = node.fermat_spiral\n        # verify that we haven't already tried to connect to a node\n        # at those indices, otherwise move along curve to a new spot\n        available_indices = range(len(points))\n        connections = node.connection\n        if connections:\n            connection = [connections[n].keys() for n in connections]\n            for c in connection:\n                connect_indices = get_shortest_indices(c[0], c[1], points)\n                available_indices = [x for x in available_indices if not x in connect_indices]\n\n            # set start index\n            start_index = available_indices[0]\n\n        start_pnt = points[start_index]\n        # find end index\n        closest = {\"point\": None, \"distance\": 1000000}\n        for i in available_indices:\n            dist = rs.Distance(points[i], start_pnt) - 0.75*offset\n            if abs(dist) < closest[\"distance\"]:\n                closest[\"distance\"] = abs(dist)\n                closest[\"point\"] = i\n\n        end_index = closest[\"point\"]\n    \n    return start_index, end_index\n\n\ndef fill_curve_with_fermat_spiral(t, curve, bboxes=[], move_up=True, start_pnt=None, wall_mode=False, walls=3, wall_first=False, spiral_seam=False, separate_wall=True):\n    extrude_width = float(t.get_extrude_width())\n\n    # slice the shape\n    # Generate isocontours\n    root, isocontours, contour_time = get_contours(curve, extrude_width, walls=walls, wall_mode=wall_mode, separate_wall=separate_wall)\n\n    st_time = time.time()\n\n    final_spiral = []\n    outer_travel_paths = []\n    inner_travel_paths = []\n\n    start_point = start_pnt\n\n    # Spiralling Regions\n    if separate_wall:\n        # if generating the first isocontour resulted in multiple\n        # regions, we have to handle them separately\n        for node in root.children:\n            # there may be multiple inner regions within the outermost wall due to initial_offset\n            inner_regions = []\n            for child in node.children:\n                region_tree = segment_tree(child)\n                all_nodes = region_tree.get_all_nodes([])\n                for n in all_nodes:\n                    start_point = rs.EvaluateCurve(n.sub_nodes[0], rs.CurveClosestPoint(n.sub_nodes[0], start_pnt))\n                    if len(n.sub_nodes) > 1:\n                        num_pnts = get_num_points(n.sub_nodes[0], extrude_width)\n                        if n.type == 1:\n                            if n.parent:\n                                start_point = get_corner(n.sub_nodes[0], n.sub_nodes[-1], extrude_width)\n                                #start_point = rs.CurveClosestObject(n.sub_nodes[0], n.sub_nodes[-1])[1]\n                            n.fermat_spiral = fermat_spiral(n.sub_nodes, start_point, extrude_width)\n                        elif n.type == 2:\n                            n.fermat_spiral = rs.DivideCurve(n.sub_nodes[0], num_pnts)\n                    elif len(n.sub_nodes) == 1:\n                        num_pnts = get_num_points(n.sub_nodes[0], extrude_width)\n                        n.fermat_spiral = rs.DivideCurve(trim_curve(n.sub_nodes[0], extrude_width*0.25, start_point), num_pnts)\n                        #n.fermat_spiral = rs.DivideCurve(n.sub_nodes[0], num_pnts)\n                    else:\n                        print(\"Error: node with no curves in it at all\", n)\n\n                if len(all_nodes) > 1:\n                    inner_regions.append(connect_spiralled_nodes(region_tree, extrude_width))\n                elif len(all_nodes) == 1:\n                    inner_regions.append(all_nodes[0].fermat_spiral)\n\n            #amt = 1.0\n            #if t.get_printer() == 'ender': amt = 3.0\n\n            start_point = rs.EvaluateCurve(curve, rs.CurveClosestPoint(curve, start_pnt))\n            outer_wall = trim_curve(node.data, extrude_width*0.5, start_point)\n\n            outer_points = rs.PolylineVertices(rs.ConvertCurveToPolyline(outer_wall, min_edge_length=t.get_resolution()))\n\n            if wall_first:\n                outer_travel_paths = outer_travel_paths + draw_points(t, outer_points, 0, bboxes=bboxes, move_up=move_up, spiral_seam=spiral_seam)\n                final_spiral = final_spiral + outer_points\n            for region in inner_regions:\n                region_curve = rs.AddCurve(region)\n                region_points = rs.PolylineVertices(rs.ConvertCurveToPolyline(region_curve, min_edge_length=t.get_resolution()))\n                if region_points==None: region_points = region\n                travel_paths = draw_points(t, region_points, 0, bboxes=bboxes, move_up=move_up, spiral_seam=False)\n                if wall_first:\n                    inner_travel_paths = inner_travel_paths + travel_paths\n                else:\n                    outer_travel_paths = outer_travel_paths + travel_paths\n                final_spiral = final_spiral + region_points\n            if not wall_first:\n                travel_paths = draw_points(t, outer_points, 0, bboxes=bboxes, move_up=move_up, spiral_seam=spiral_seam)\n                if len(inner_regions) > 0:\n                    inner_travel_paths = inner_travel_paths + travel_paths\n                else:\n                    outer_travel_paths = outer_travel_paths + travel_paths\n                final_spiral = final_spiral + outer_points\n    else:\n        region_tree = segment_tree(root)\n        all_nodes = region_tree.get_all_nodes([])\n        for n in all_nodes:\n            start_point = rs.EvaluateCurve(n.sub_nodes[0], rs.CurveClosestPoint(n.sub_nodes[0], start_pnt))\n            if len(n.sub_nodes) > 1:\n                num_pnts = get_num_points(n.sub_nodes[0], extrude_width)\n                if n.type == 1:\n                    if n.parent:\n                        start_point = get_corner(n.sub_nodes[0], n.sub_nodes[-1], extrude_width)\n                    n.fermat_spiral = fermat_spiral(n.sub_nodes, start_point, extrude_width)\n                elif n.type == 2:\n                    n.fermat_spiral = rs.DivideCurve(n.sub_nodes[0], num_pnts)\n            elif len(n.sub_nodes) == 1:\n                num_pnts = get_num_points(n.sub_nodes[0], extrude_width)\n                n.fermat_spiral = rs.DivideCurve(trim_curve(n.sub_nodes[0], extrude_width*0.25, start_point), num_pnts)\n            else:\n                print(\"Error: node with no curves in it at all\", n)\n\n        if len(all_nodes) > 1:\n            region = connect_spiralled_nodes(region_tree, extrude_width)\n        elif len(all_nodes) == 1:\n            region = all_nodes[0].fermat_spiral\n        \n        region_curve = rs.AddCurve(region)\n        region_points = rs.PolylineVertices(rs.ConvertCurveToPolyline(region_curve, min_edge_length=t.get_resolution()))\n        if region_points==None: region_points = region\n        outer_travel_paths = draw_points(t, region_points, 0, bboxes=bboxes, move_up=move_up, spiral_seam=False)\n        final_spiral = final_spiral + region_points\n\n    fermat_time = time.time() - st_time\n\n    return outer_travel_paths, inner_travel_paths, start_point, contour_time, fermat_time\n\n\ndef fill_curve_with_spiral(t, curve, start_pnt=None, wall_first=False):\n    extrude_width = float(t.get_extrude_width())\n\n    # slice the shape\n    # Generate isocontours\n    root, isocontours, contour_time = get_contours(curve, extrude_width)\n\n    travel_paths = []\n\n    for node in root.children:\n        outer_wall = node.data\n        outer_points = rs.DivideCurve(outer_wall, int(rs.CurveLength(outer_wall)/t.get_resolution()))\n        if outer_points == None:\n            outer_points = rs.DivideCurve(outer_wall, get_num_points(outer_wall, extrude_width))\n\n        if wall_first:\n            start_idx = 0\n            if start_pnt: start_idx, d = closest_point(start_pnt, outer_points)\n            travel_paths = travel_paths + draw_points(t, outer_points, start_idx)\n\n        for child in node.children:\n            region_tree = segment_tree(child)\n            all_nodes = region_tree.get_all_nodes([])\n\n            # Spiral Regions\n            for node in all_nodes:\n                if len(node.sub_nodes) > 0:\n                    num_pnts = get_num_points(node.sub_nodes[0], float(t.get_extrude_width()))\n                    if node.type == 1:\n                        start_idx = 0\n                        if start_pnt:\n                            start_idx, d = closest_point(start_pnt, rs.DivideCurve(node.sub_nodes[0], num_pnts))\n                        spiral, indices = spiral_contours(t, node.sub_nodes, start_idx)\n                        travel_paths = travel_paths + draw_points(t, spiral, start_idx=start_idx)\n                    elif node.type == 2:\n                        points = rs.DivideCurve(node.sub_nodes[0], num_pnts)\n                        travel_paths = travel_paths + draw_points(t, points, start_idx=start_idx)\n        \n        if not wall_first:\n            start_idx = 0\n            if start_pnt: start_idx, d = closest_point(start_pnt, outer_points)\n            travel_paths = travel_paths + draw_points(t, outer_points, start_idx)\n\n    return travel_paths\n\n\ndef fill_curve_with_contours(t, curve, start_pnt=None, wall_mode=False, walls=3):\n    extrude_width = float(t.get_extrude_width())\n\n    # slice the shape\n    # Generate isocontours\n    root, isocontours, contour_time = get_contours(curve, extrude_width, walls=walls, wall_mode=wall_mode)\n\n    return isocontours\n\n    #isocontours = [rs.DivideCurve(i, int(rs.CurveLength(i)/t.get_resolution())) for i in isocontours]\n\n    #travel_paths = []\n    #start_idx = 0\n    #for i in range(len(isocontours)):\n    #    points = isocontours[i]\n    #    start_idx, d = closest_point(start_pnt, points)\n    #    if start_idx == None: start_idx = 0\n\n    #    travel_paths = travel_paths + [rs.AddCurve([t.get_position(), points[start_idx]])]\n    #    t.pen_up()\n    #    t.set_position(points[start_idx].X, points[start_idx].Y, t.get_position().Z)\n    #    t.set_position(points[start_idx].X, points[start_idx].Y, points[start_idx].Z)\n    #    t.pen_down()\n\n    #    for p in (range(start_idx+1, len(points)) + range(0, start_idx)):\n    #        t.set_position(points[p].X, points[p].Y, points[p].Z)\n    #    t.set_position(points[start_idx].X, points[start_idx].Y, points[start_idx].Z)\n\n    #return travel_paths\n\n\ndef slice_fermat_fill(t, shape, start_pnt=None, start=0, end=None, wall_mode=False, walls=3, fill_bottom=False, bottom_layers=3, initial_offset=0.5):\n    travel_paths = []\n    layers = int(math.floor(get_shape_height(shape) / t.get_layer_height())) + 1\n\n    print(\"Number of layers: \"+str(layers-1))\n\n    if end is None: end = layers\n\n    extrude_width = float(t.get_extrude_width())\n    gap = 0.2*extrude_width\n\n    for l in range(start, min(layers, end)):\n        get_group_curves_start = time.time()\n        curve_groups = get_curves(shape, l*t.get_layer_height())\n        curves = connect_curve_groups(curve_groups, gap, initial_offset=initial_offset*extrude_width)\n        print(\"Time to get and group curves: \"+str(round(time.time()-get_group_curves_start, 3))+\" seconds\")\n\n        for crv in curves:\n            if start_pnt == None: start_pnt = t.get_position()\n            if not wall_mode or (wall_mode and fill_bottom and l<bottom_layers):\n                travel_paths = travel_paths + fill_curve_with_fermat_spiral(t, crv, start_pnt=start_pnt)[0]\n            else:\n                travel_paths = travel_paths + fill_curve_with_fermat_spiral(t, crv, start_pnt=start_pnt, wall_mode=wall_mode, walls=walls)[0]\n\n    return travel_paths\n\n\ndef slice_spiral_fill(t, shape, start_pnt=None, start=0, end=None, wall_mode=False, walls=3, fill_bottom=False, bottom_layers=3, initial_offset=0.5):\n    travel_paths = []\n    layers = int(math.floor(get_shape_height(shape) / t.get_layer_height())) + 1\n\n    print(\"Number of layers: \"+str(layers-1))\n\n    if end is None: end = layers\n\n    extrude_width = float(t.get_extrude_width())\n    gap = 0.2*extrude_width\n\n    for l in range(start, min(layers, end)):\n        curve_groups = get_curves(shape, l*t.get_layer_height())\n        curves = connect_curve_groups(curve_groups, gap, initial_offset=initial_offset*extrude_width)\n\n        for crv in curves:\n            if start_pnt == None: start_pnt = t.get_position()\n            if not wall_mode or (wall_mode and fill_bottom and l<bottom_layers):\n                travel_paths = travel_paths + fill_curve_with_spiral(t, crv, start_pnt=start_pnt)\n            else:\n                travel_paths = travel_paths + fill_curve_with_spiral(t, crv, start_pnt=start_pnt, wall_mode=wall_mode, walls=walls)\n\n    return travel_paths\n\n\ndef slice_contour_fill(t, shape, start=0, end=None, wall_mode=False, walls=3, fill_bottom=False, bottom_layers=3, initial_offset=0.5):\n    travel_paths = []\n    layers = int(math.floor(get_shape_height(shape) / t.get_layer_height())) + 1\n\n    print(\"Number of layers: \"+str(layers-1))\n\n    if end is None: end = layers\n\n    extrude_width = float(t.get_extrude_width())\n    gap = 0.2*extrude_width\n\n    for l in range(start, min(layers, end)):\n        curve_groups = get_curves(shape, l*t.get_layer_height())\n        curves = connect_curve_groups(curve_groups, gap, initial_offset=initial_offset*extrude_width)\n\n        for crv in curves:\n            if not wall_mode or (wall_mode and fill_bottom and l<bottom_layers):\n                travel_paths = travel_paths + fill_curve_with_contours(t, crv, start_pnt=t.get_position())\n            else:\n                travel_paths = travel_paths + fill_curve_with_contours(t, crv, start_pnt=t.get_position(), wall_mode=wall_mode, walls=walls)\n\n    return travel_paths\n\n\ndef TRAvel_Slice(t, shape, all_curves, wall_mode=False, walls=3, fill_bottom=False, bottom_layers=3, initial_offset=0.5, spiral_seam=False, separate_wall=True, debug=False):\n    overall_start_time = time.time()\n\n    inner_travel_paths = []\n    outer_travel_paths = []\n\n    #node_path, path = outer_travel_reduction(t, shape, all_curves, initial_offset=initial_offset)\n    tree, node_path, path, edges = outer_travel_reduction(t, shape, all_curves, initial_offset=initial_offset, debug=debug)\n\n    contour_time = 0\n    fermat_time = 0\n\n    start_point = t.get_position()\n    extrude_width = float(t.get_extrude_width())\n    gap = 0.2*extrude_width\n    boxes = []\n    move_up = False\n    for s in range(len(node_path)):\n        if node_path[s].data.height!=node_path[s-1].data.height:\n            # only compare to boxes within nozzle height chunk\n            boxes = []\n        if node_path[s].data.box!=None: boxes.append(node_path[s].data.box)\n\n        for node in node_path[s].data.sub_nodes:\n            start_point = t.get_position()\n            curves = connect_curve_groups(node.data, gap, initial_offset=initial_offset*extrude_width)\n            for curve in curves:\n                if not wall_mode or (wall_mode and fill_bottom and node.height<bottom_layers):\n                    outer_travel, inner_travel, start_point, c_time, f_time = fill_curve_with_fermat_spiral(t, curve, bboxes=boxes, move_up=move_up, start_pnt=start_point, spiral_seam=spiral_seam, separate_wall=separate_wall)\n                    outer_travel_paths = outer_travel_paths + outer_travel\n                    inner_travel_paths = inner_travel_paths + inner_travel\n                    contour_time = contour_time + c_time\n                    fermat_time = fermat_time + f_time\n                else:\n                    outer_travel, inner_travel, start_point, c_time, f_time = fill_curve_with_fermat_spiral(t, curve, bboxes=boxes, move_up=move_up, start_pnt=start_point, wall_mode=wall_mode, walls=walls, spiral_seam=spiral_seam, separate_wall=separate_wall)\n                    outer_travel_paths = outer_travel_paths + outer_travel\n                    inner_travel_paths = inner_travel_paths + inner_travel\n                    contour_time = contour_time + c_time\n                    fermat_time = fermat_time + f_time\n            move_up = False\n        move_up = True\n\n    if debug:\n        print(\"Contour generation time: \"+str(round(contour_time, 3))+\" seconds\")\n        print(\"Fermat Spiraling time: \"+str(round(fermat_time, 3))+\" seconds\")\n        print(\"Full path generation: \"+str(round(time.time()-overall_start_time, 3))+\" seconds\")\n\n    return outer_travel_paths, inner_travel_paths, tree, node_path, path, edges\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}