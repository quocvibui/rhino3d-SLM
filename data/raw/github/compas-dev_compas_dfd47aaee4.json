{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas/topology/orientation.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas/topology/orientation.py",
  "instruction": "Orientation",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom compas.geometry import centroid_points\nfrom compas.itertools import pairwise\nfrom compas.topology import breadth_first_traverse\n\n\ndef _closest_faces(vertices, faces, nmax, max_distance):\n    points = [centroid_points([vertices[index] for index in face]) for face in faces]\n\n    k = len(faces) if nmax is None else min(len(faces), nmax)\n\n    # determine the k closest faces for each face\n    # each item in \"closest\" is\n    # [0] the coordinates of the face centroid\n    # [1] the index of the face in the list of face centroids\n    # [2] the distance between the test point and the face centroid\n\n    try:\n        import numpy as np\n        from scipy.spatial import cKDTree\n\n        tree = cKDTree(points)\n        distances, closest = tree.query(points, k=k, workers=-1)\n        if max_distance is None:\n            return closest\n\n        closest_within_distance = []\n        for i, closest_row in enumerate(closest):\n            idx = np.where(distances[i] < max_distance)[0]\n            closest_within_distance.append(closest_row[idx].tolist())\n        return closest_within_distance\n\n    except Exception:\n        try:\n            from Rhino.Geometry import Point3d  # type: ignore\n            from Rhino.Geometry import RTree  # type: ignore\n            from Rhino.Geometry import Sphere  # type: ignore\n\n            tree = RTree()\n\n            for i, point in enumerate(points):\n                tree.Insert(Point3d(*point), i)\n\n            def callback(sender, e):\n                data = e.Tag\n                data.append(e.Id)\n\n            closest = []\n            for i, point in enumerate(points):\n                sphere = Sphere(Point3d(*point), max_distance)\n                data = []\n                tree.Search(sphere, callback, data)\n                closest.append(data)\n            return closest\n\n        except Exception:\n            from compas.geometry import KDTree\n\n            tree = KDTree(points)\n            closest = [tree.nearest_neighbors(point, k) for point in points]\n            if max_distance is None:\n                return closest\n            return [[index for xyz, index, d in nnbrs if d < max_distance] for nnbrs in closest]\n\n\ndef _face_adjacency(vertices, faces, nmax=None, max_distance=None):\n    if nmax is None and max_distance is None:\n        raise ValueError(\"Either nmax or max_distance should be specified.\")\n    closest = _closest_faces(vertices, faces, nmax=nmax, max_distance=max_distance)\n\n    adjacency = {}\n\n    for index, face in enumerate(faces):\n        nbrs = []\n        found = set()\n        nnbrs = set(closest[index])\n\n        for u, v in pairwise(face + face[0:1]):\n            for nbr in nnbrs:\n                if nbr == index:\n                    continue\n                if nbr in found:\n                    continue\n\n                for a, b in pairwise(faces[nbr] + faces[nbr][0:1]):\n                    if v == a and u == b:\n                        nbrs.append(nbr)\n                        found.add(nbr)\n                        break\n\n                for a, b in pairwise(faces[nbr] + faces[nbr][0:1]):\n                    if u == a and v == b:\n                        nbrs.append(nbr)\n                        found.add(nbr)\n                        break\n\n        adjacency[index] = nbrs\n\n    return adjacency\n\n\ndef face_adjacency(points, faces, nmax=None, max_distance=None):\n    \"\"\"Build a face adjacency dict.\n\n    Parameters\n    ----------\n    points : list[point]\n        The vertex locations of the faces.\n    faces : list[list[int]]\n        The faces defined as list of indices in the points list.\n    nmax : int, optional\n        The maximum number of neighboring faces to consider. If neither nmax nor max_distance is specified, all faces will be considered.\n    max_distance : float, optional\n        The max_distance of the search sphere for neighboring faces. If neither nmax nor max_distance is specified, all faces will be considered.\n\n    Returns\n    -------\n    dict[int, list[int]]\n        A dictionary mapping face identifiers (keys) to lists of neighboring faces.\n\n    Notes\n    -----\n    This algorithm is used primarily to unify the cycle directions of the faces representing a mesh.\n    The premise is that the faces don't have unified cycle directions yet,\n    and therefore cannot be used to construct the adjacency structure. The algorithm is thus\n    purely geometrical, but uses a spatial indexing tree to speed up the search.\n\n    \"\"\"\n    if nmax or max_distance:\n        return _face_adjacency(points, faces, nmax=nmax, max_distance=max_distance)\n\n    adjacency = {}\n\n    for i, vertices in enumerate(faces):\n        nbrs = []\n        found = set()\n\n        for u, v in pairwise(vertices + vertices[0:1]):\n            for j, _ in enumerate(faces):\n                if i == j:\n                    continue\n                if j in found:\n                    continue\n\n                for a, b in pairwise(faces[j] + faces[j][0:1]):\n                    if v == a and u == b:\n                        nbrs.append(j)\n                        found.add(j)\n                        break\n\n                for a, b in pairwise(faces[j] + faces[j][0:1]):\n                    if u == a and v == b:\n                        nbrs.append(j)\n                        found.add(j)\n                        break\n\n        adjacency[i] = nbrs\n\n    return adjacency\n\n\ndef unify_cycles(vertices, faces, root=None, nmax=None, max_distance=None):\n    \"\"\"Unify the cycle directions of all faces.\n\n    Unified cycle directions is a necessary condition for the data structure to\n    work properly. When in doubt, run this function on your mesh.\n\n    Parameters\n    ----------\n    vertices : list[[float, float, float]]\n        The vertex coordinates of the mesh.\n    faces : list[list[int]]\n        The faces of the mesh defined as lists of vertex indices.\n    root : int, optional\n        The key of the root face.\n    nmax : int, optional\n        The maximum number of neighboring faces to consider. If neither nmax nor max_distance is specified, all faces will be considered.\n    max_distance : float, optional\n        The max_distance of the search sphere for neighboring faces. If neither nmax nor max_distance is specified, all faces will be considered.\n\n    Returns\n    -------\n    dict\n        A halfedge dictionary linking pairs of vertices to faces.\n\n    Raises\n    ------\n    Exception\n        If no all faces are included in the unnification process.\n\n    Notes\n    -----\n    The cycles of the faces will be aligned with the cycle direction of the root face.\n    If no root face is specified, the first face in the list will be used.\n\n    \"\"\"\n\n    def unify(node, nbr):\n        # find the common edge\n        for u, v in pairwise(faces[nbr] + faces[nbr][0:1]):\n            if u in faces[node] and v in faces[node]:\n                # node and nbr have edge u-v in common\n                i = faces[node].index(u)\n                j = faces[node].index(v)\n                if i == j - 1 or (j == 0 and u == faces[node][-1]):\n                    # if the traversal of a neighboring halfedge\n                    # is in the same direction\n                    # flip the neighbor\n                    faces[nbr][:] = faces[nbr][::-1]\n                    return\n\n    if root is None:\n        # root = random.choice(list(range(len(faces))))\n        root = 0\n\n    adj = face_adjacency(vertices, faces, nmax=nmax, max_distance=max_distance)  # this is the only place where the vertex coordinates are used\n\n    visited = breadth_first_traverse(adj, root, unify)\n\n    if len(list(visited)) != len(faces):\n        raise Exception(\"Not all faces were visited.\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}