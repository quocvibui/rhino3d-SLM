{
  "source_url": "https://github.com/Albertomartinezlopez/ACD-e24-A4-agent-based-modeling_Alberto-Martinez/blob/6bb44bde72c5b4a703ecd878193e7bb079cd5763/milling_program.py",
  "repo": "Albertomartinezlopez/ACD-e24-A4-agent-based-modeling_Alberto-Martinez",
  "repo_stars": 0,
  "repo_description": "advancedcomputationaldesign-e24-assignment-4-agent-based-modeling-Asignment4_Template-2 created by GitHub Classroom",
  "license": "unknown",
  "filepath": "milling_program.py",
  "instruction": "Assignment 4: Agent-Based Model for Structural Tessellation Generation",
  "code": "\"\"\"\nAssignment 4: Agent-Based Model for Structural Tessellation Generation\n\nAuthor: Alberto Martinez\n\nDescription:\n\nThis script simulates a milling process using a toolpath and a milling tool, applying a series of boolean difference operations to a block geometry. \nThe milling tool is represented as a cylinder with a specified radius and height, and the tool moves along a given curve. \nBy dividing the toolpath into discrete points, the script progressively subtracts material from the block at each point along the path, resulting in a new, milled geometry. \nThis method provides a way to visualize the effect of the milling process, allowing exploration of how varying tool parameters and toolpath shapes influence the final form.\n\nNote: This script is intended to be used within Grasshopper's Python scripting component or as a standalone Python script.\n\"\"\"\n\nimport Rhino.Geometry as rg\n\n# Define the Agent class to represent the milling tool\nclass Agent:\n    def __init__(self, tool_radius, tool_height):\n        # Initialize the agent with tool radius and height\n        self.tool_radius = tool_radius\n        self.tool_height = tool_height\n        self.tool = rg.Cylinder(rg.Circle(self.tool_radius), self.tool_height)  # Create the milling tool\n\n    def move_to(self, point):\n        # Move the agent (tool) to a new position (point)\n        translation_vector = rg.Vector3d(point.X, point.Y, point.Z)\n        tool_move = rg.Transform.Translation(translation_vector)\n        \n        moved_tool = self.tool.ToBrep(True, True)  # Create the Brep and cap the cylinder ends\n        moved_tool.Transform(tool_move)  # Move the tool to the new position\n        return moved_tool\n\n# Inputs:\n# block_geometry (BRep): The original block geometry to be milled\n# toolpath_curve (Curve): The toolpath curve along which the tool moves\n# tool_radius_value (float): The radius of the milling tool (cylinder radius)\n# tool_height_value (float): The height (depth) of the milling tool (cylinder height)\n\n# The input variables from Grasshopper will be used here:\nblock = block_geometry  # BRep geometry of the block to be milled\ntoolpath = toolpath_curve  # The toolpath curve where the tool moves\ntool_radius = tool_radius_value  # Radius of the milling tool (cylinder radius)\ntool_height = tool_height_value  # Height of the milling tool (cylinder height)\n\n# Create the milling agent (tool)\nagent = Agent(tool_radius, tool_height)\n\n# Create a list of points along the toolpath\n# Divide the toolpath curve into a number of points (e.g., divide into 100 segments)\ntoolpath_points = [toolpath.PointAt(t) for t in range(0, 101)]\n\n# Set the initial block as the result block\nresult_block = block\n\n# Loop over the points along the toolpath and subtract material\nfor point in toolpath_points:\n    # Move the agent (tool) to the current point\n    moved_tool = agent.move_to(point)  # Get the moved tool at the current point\n    \n    # Perform the boolean difference (subtract the tool from the block)\n    result_block = rg.Brep.CreateBooleanDifference([result_block] + [moved_tool])[0]\n\n# Output the resulting block after milling\nresulting_block = result_block  # The new BRep after the milling operation\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}