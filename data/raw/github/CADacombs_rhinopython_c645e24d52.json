{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsCrv_removeMultipleKnots.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsCrv_removeMultipleKnots.py",
  "instruction": "This script is an alternative to _RemoveMultiKnots on wire curves.\r\n\r\nLike _RemoveMultiKnots, no multiplicity is reduced to 0.\r\nUnlike _RemoveMultiKnots, it calculates various curves and chooses the...",
  "code": "\"\"\"\r\nThis script is an alternative to _RemoveMultiKnots on wire curves.\r\n\r\nLike _RemoveMultiKnots, no multiplicity is reduced to 0.\r\nUnlike _RemoveMultiKnots, it calculates various curves and chooses the one,\r\nwithin deviation tolerance, if enabled, and with the least number of knots.\r\n\r\n\r\nNurbsCurveKnotList.RemoveMultipleKnots' minimumMultiplicity and maximumMultiplicity are,\r\nrespectively,\r\nthe minimum and maximum allowed (not to remove) knot multiplicities.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n210603: Created starting from a split from another script.\r\n220327: Modified main routine for finding curve to return.  Modified options.  Refactored.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Enum\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bReduceIfRemoveFail'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iPreserveEnd'; keys.append(key)\r\n    values[key] = 1\r\n    listValues[key] = Enum.GetNames(rg.NurbsCurve.NurbsCurveEndConditionType)[1:]\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLimitDev'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue == 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = Rhino.RhinoMath.ZeroTolerance\r\n            elif cls.riOpts[key].CurrentValue <= 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n        else:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            elif key in cls.listValues:\r\n                cls.values[key] = idxList\r\n            else:\r\n                return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve with optional input.\r\n    \"\"\"\r\n\r\n    # Get curves with optional input.\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select wire curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bReduceIfRemoveFail')\r\n        addOption('iPreserveEnd')\r\n        addOption('bLimitDev')\r\n        if Opts.values['bLimitDev']:\r\n            addOption('fDevTol')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            if Opts.values['bLimitDev']:\r\n                key = 'fDevTol'\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=None):\r\n    if iPrecision is None: iPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef knotMultiplicityList(knots):\r\n    \"\"\"Returns a list.\"\"\"\r\n    i = 0\r\n    iMulties = []\r\n    fKnotTs_Unique = []\r\n    while True:\r\n        knot = knots[i]\r\n        fKnotTs_Unique.append(knot)\r\n        iMulti = knots.KnotMultiplicity(index=i)\r\n        iMulties.append(iMulti)\r\n        #print(\"{} at {:.4f}\".format(iMulti, knot),\r\n        i += iMulti\r\n        if i >= knots.Count:\r\n            break\r\n    return iMulties\r\n\r\n\r\ndef filterTargetInput(rgCrv):\r\n    \"\"\"\r\n    Returns on non-target curve: None, str\r\n    Returns on target curve: rg.NurbsCurve, None\r\n    \"\"\"\r\n\r\n    if isinstance(rgCrv, rg.NurbsCurve):\r\n        nc_In = rgCrv\r\n    elif isinstance(rgCrv, rg.PolyCurve):\r\n        nc_In = rgCrv.ToNurbsCurve()\r\n    else:\r\n        return None, \"{} skipped.\".format(rgCrv.GetType().Name)\r\n\r\n    knots = nc_In.Knots\r\n    degree = nc_In.Degree\r\n\r\n    # Test whether any knots can be removed by RemoveMultipleKnots.\r\n    if nc_In.IsPeriodic:\r\n        if knots.Count == 2*degree + degree -1:\r\n            return None, \"Curve has no interior knots that can be removed by NurbsCurveKnotList.RemoveMultipleKnots.\"\r\n    elif knots.Count == 2 * degree:\r\n        return None, \"Curve has no interior knots that can be removed by NurbsCurveKnotList.RemoveMultipleKnots.\"\r\n\r\n    iKnot = degree\r\n    iKnot_Stop = knots.Count - degree\r\n\r\n    while iKnot < iKnot_Stop:\r\n        iMult = knots.KnotMultiplicity(iKnot)\r\n\r\n        if iMult > 1:\r\n            return nc_In, None\r\n\r\n        iKnot += 1 # or iMult.\r\n\r\n    return None, \"Curve has no interior knots that can be removed by NurbsCurveKnotList.RemoveMultipleKnots.\"\r\n\r\n\r\ndef getDistancesBetweenCurves(crvA, crvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    if not rc[0]:\r\n        return None\r\n\r\n    return rc[1]\r\n\r\n\r\ndef processCurve(rgCrv, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgCrv\r\n        fDevTol:\r\n            None for no deviation limit,\r\n            Positive value for limit,\r\n            Negative value for removing as many knots as possible within absolute value.\r\n        bDebug\r\n        \r\n    Initial tests show that removing all knots produces the same result as an\r\n    iterative approach, e.g., remove knots starting at full multiplicity.\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bReduceIfRemoveFail = getOpt('bReduceIfRemoveFail')\r\n    iPreserveEnd = getOpt('iPreserveEnd')\r\n    fDevTol = getOpt('fDevTol') if getOpt('bLimitDev') else None\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rc = filterTargetInput(rgCrv)\r\n    if rc[0] is None:\r\n        return rc\r\n\r\n    nc_In = rc[0]\r\n\r\n    degree = nc_In.Degree\r\n\r\n    #iMinMultiplicity = 1 # Remove all polyknots.\r\n\r\n\r\n    def preserveEndCondition(nc):\r\n        if iPreserveEnd == 1:\r\n            bSuccess = nc.SetEndCondition(\r\n                bSetEnd=False,\r\n                continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n                point=nc.PointAtStart,\r\n                tangent=nc_In.TangentAtStart)\r\n            if not bSuccess:\r\n                print(\"SetEndCondition failed.\")\r\n            bSuccess = nc.SetEndCondition(\r\n                bSetEnd=True,\r\n                continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n                point=nc.PointAtEnd,\r\n                tangent=nc_In.TangentAtEnd)\r\n            if not bSuccess:\r\n                print(\"SetEndCondition failed.\")\r\n        elif iPreserveEnd == 2:\r\n            bSuccess = nc.SetEndCondition(\r\n                bSetEnd=False,\r\n                continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Curvature,\r\n                point=nc.PointAtStart,\r\n                tangent=nc_In.TangentAtStart,\r\n                curvature=nc_In.CurvatureAt(nc_In.Domain.T0))\r\n            if not bSuccess:\r\n                print(\"SetEndCondition failed.\")\r\n            bSuccess = nc.SetEndCondition(\r\n                bSetEnd=True,\r\n                continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Curvature,\r\n                point=nc.PointAtEnd,\r\n                tangent=nc_In.TangentAtEnd,\r\n                curvature=nc_In.CurvatureAt(nc_In.Domain.T1))\r\n            if not bSuccess:\r\n                print(\"SetEndCondition failed.\")\r\n\r\n\r\n    # Not setting tolerance parameter to other than Rhino.RhinoMath.UnsetValue\r\n    # due to bugs in RC 6.x - 7.6 (+):\r\n    #   In pre-7.6: Float value is ignored.\r\n    #   In 7.6: Return value does not reflect actual number of knots removed.\r\n    #     https://discourse.mcneel.com/t/nurbscurveknotlist-removemultipleknots-return-value-bug/125314\r\n    # For V6 compatibility, deviation results will be checked instead.\r\n\r\n\r\n    # RemoveMultipleKnots parameters:\r\n    #   minimumMultiplicity is the lowest value not to change.\r\n    #   maximumMultiplicity is the highest value not to change.\r\n\r\n    # Setting minimumMultiplicity to a value less than 1 is the same as setting it to 1.\r\n\r\n\r\n\r\n    if fDevTol is None:\r\n        nc_WIP = nc_In.DuplicateCurve()\r\n\r\n        iCt_KnotsRemoved = nc_WIP.Knots.RemoveMultipleKnots(\r\n            minimumMultiplicity=1,\r\n            maximumMultiplicity=degree+1,\r\n            tolerance=Rhino.RhinoMath.UnsetValue)\r\n\r\n        preserveEndCondition(nc_WIP)\r\n\r\n        fDev = getDistancesBetweenCurves(nc_In, nc_WIP)\r\n\r\n        if fDev is None:\r\n            return (nc_WIP, None), \"GetDistancesBetweenCurves failed.\"\r\n\r\n        return (nc_WIP, fDev), None\r\n\r\n\r\n    if not bReduceIfRemoveFail:\r\n        nc_WIP = nc_In.DuplicateCurve()\r\n\r\n        iCt_KnotsRemoved = nc_WIP.Knots.RemoveMultipleKnots(\r\n            minimumMultiplicity=1,\r\n            maximumMultiplicity=degree+1,\r\n            tolerance=Rhino.RhinoMath.UnsetValue)\r\n\r\n        preserveEndCondition(nc_WIP)\r\n\r\n        fDev = getDistancesBetweenCurves(nc_In, nc_WIP)\r\n\r\n        if fDev is None:\r\n            nc_WIP.Dispose()\r\n            return None, \"GetDistancesBetweenCurves failed.\"\r\n\r\n        if fDev > fDevTol:\r\n            nc_WIP.Dispose()\r\n            return (None, fDev), None\r\n\r\n        return (nc_WIP, fDev), None\r\n\r\n\r\n\r\n    ncs_Pass = []\r\n    fDevs = []\r\n    iCts_Knots = []\r\n\r\n\r\n    for minimumMultiplicity in range(1, degree):\r\n        for maximumMultiplicity in range(degree+1, minimumMultiplicity+1, -1):\r\n\r\n            nc_WIP = nc_In.DuplicateCurve()\r\n\r\n            if bDebug:\r\n                sEval='minimumMultiplicity'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval='maximumMultiplicity'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            iCt_KnotsRemoved = nc_WIP.Knots.RemoveMultipleKnots(\r\n                minimumMultiplicity,\r\n                maximumMultiplicity,\r\n                tolerance=Rhino.RhinoMath.UnsetValue)\r\n\r\n\r\n            if bDebug: sEval='iCt_KnotsRemoved'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            if iCt_KnotsRemoved == 0:\r\n                nc_WIP.Dispose()\r\n                if bDebug: print(\"No knots were removed.\")\r\n                continue\r\n\r\n            preserveEndCondition(nc_WIP)\r\n\r\n            fDev = getDistancesBetweenCurves(nc_In, nc_WIP)\r\n\r\n            if bDebug: sEval='fDev'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            if fDev is None:\r\n                if bDebug: print(\"GetDistancesBetweenCurves failed.\")\r\n                nc_WIP.Dispose()\r\n                continue\r\n\r\n\r\n            if fDev > fDevTol:\r\n                nc_WIP.Dispose()\r\n                continue\r\n\r\n            ncs_Pass.append(nc_WIP)\r\n            fDevs.append(fDev)\r\n            iCts_Knots.append(nc_WIP.Knots.Count)\r\n\r\n            if bDebug:\r\n                print(\r\n                    \"  Dev:{}\".format(formatDistance(fDev)),\r\n                    \"  KnotCt:{}\".format(nc_WIP.Knots.Count),\r\n                    \"  Multies:({})\".format(\r\n                        \",\".join(str(i) for i in knotMultiplicityList(nc_WIP.Knots)))\r\n                    )\r\n\r\n    if bDebug: print(iCts_Knots)\r\n\r\n    if not ncs_Pass:\r\n        return None, \"Curve could not be modified within tolerance.\"\r\n\r\n    idx_Winner = iCts_Knots.index(min(iCts_Knots))\r\n\r\n    for i, nc in enumerate(ncs_Pass):\r\n        if i == idx_Winner:\r\n            nc_Out = nc\r\n            continue # for loop.\r\n        nc.Dispose()\r\n\r\n\r\n    sOut = None\r\n\r\n\r\n    if nc_In.IsPeriodic and not nc_Out.IsPeriodic:\r\n        sOut = \"Periodic curve was converted to non-periodic.\" \\\r\n              \"  This is a limitation of NurbsCurveKnotList.RemoveMultipleKnots.\"\r\n\r\n\r\n    return (nc_Out, fDevs[idx_Winner]), sOut\r\n\r\n\r\ndef processCurveObjects(objrefs_In, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bReduceIfRemoveFail = getOpt('bReduceIfRemoveFail')\r\n    iPreserveEnd = getOpt('iPreserveEnd')\r\n    fDevTol = getOpt('fDevTol') if getOpt('bLimitDev') else None\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    gCrvs_Out = []\r\n    fDevs = []\r\n    sLogs = []\r\n\r\n    for objref_In in objrefs_In:\r\n        rdCrv = objref_In.Object()\r\n        rgCrv_In = rdCrv.CurveGeometry\r\n        nc_ToMod = rgCrv_In.ToNurbsCurve()\r\n\r\n        #if not isinstance(rgCrv_In, rg.NurbsCurve):\r\n        #    print(\"{} skipped.\".format(rgCrv_In.GetType().Name)\r\n        #    continue\r\n\r\n        rc = processCurve(\r\n            rgCrv=nc_ToMod,\r\n            bReduceIfRemoveFail=bReduceIfRemoveFail,\r\n            iPreserveEnd=iPreserveEnd,\r\n            fDevTol=fDevTol,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if rc[0] is None:\r\n            sLogs.append(rc[1])\r\n            continue\r\n\r\n        nc_Ret, fDev = rc[0]\r\n\r\n        fDevs.append(fDev)\r\n\r\n        if bReplace:\r\n            if sc.doc.Objects.Replace(objectId=rdCrv.Id, curve=nc_Ret):\r\n                gCrvs_Out.append(rdCrv.Id)\r\n                sLogs.append(\"Curve was replaced.\")\r\n            else:\r\n                sLogs.append(\"Curve could not be replaced.\")\r\n                continue\r\n        else:\r\n            gC_Out = sc.doc.Objects.AddCurve(nc_Ret)\r\n            if gC_Out == gC_Out.Empty:\r\n                sLogs.append(\"CurveObject could not be added.\")\r\n                continue\r\n            gCrvs_Out.append(gC_Out)\r\n            sLogs.append(\"Curve was added.\")\r\n\r\n    if bEcho:\r\n        if len(gCrvs_Out) == 1:\r\n            print(sLogs[0])\r\n            s = \"KnotMultiplicities:({})->({})\".format(\r\n                \",\".join(str(i) for i in knotMultiplicityList(nc_ToMod.Knots)),\r\n                \",\".join(str(i) for i in knotMultiplicityList(nc_Ret.Knots)))\r\n            s += \"  Deviation:{}\".format(formatDistance(fDev))\r\n            print(s)\r\n        elif len(sLogs) == 1:\r\n            print(sLogs[0])\r\n        else:\r\n            for sLog in set(sLogs):\r\n                print(\"Ct:{} {}\".format(sLogs.count(sLog), sLog))\r\n            if fDevs:\r\n                print(\"Devs:[{},{}]\".format(\r\n                    formatDistance(min(fDevs)),\r\n                    formatDistance(max(fDevs))))\r\n\r\n    return gCrvs_Out\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script is supported only in Rhino V6 and above.\")\r\n        return\r\n\r\n    objrefs_In = getInput()\r\n    if objrefs_In is None: return\r\n\r\n    bReduceIfRemoveFail = Opts.values['bReduceIfRemoveFail']\r\n    iPreserveEnd = Opts.values['iPreserveEnd']\r\n    fDevTol = Opts.values['fDevTol'] if Opts.values['bLimitDev'] else None\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    gC_Res = processCurveObjects(\r\n        objrefs_In=objrefs_In,\r\n        bReduceIfRemoveFail=bReduceIfRemoveFail,\r\n        iPreserveEnd=iPreserveEnd,\r\n        fDevTol=fDevTol,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n    if gC_Res is None:\r\n        return\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}