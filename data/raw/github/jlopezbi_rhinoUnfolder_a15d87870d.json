{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/flatEdge.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/flatEdge.py",
  "instruction": "Flat edge",
  "code": "import scriptcontext\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport math \nimport rhino_helpers\nimport visualization as vis\nimport creaseGeom\nimport joineryGeom\n\nreload(vis)\nreload(creaseGeom)\nreload(rhino_helpers)\n\ndef create_cut_edge_from_base(flatEdge,is_leader,otherEdgeIdx=None):\n    newEdge = CutEdge(fromFace = flatEdge.fromFace,\n                      indexInFace = flatEdge.indexInFace,\n                      meshEdgeIdx = flatEdge.meshEdgeIdx,\n                      angle = flatEdge.angle,\n                      has_outer_joinery = is_leader,\n                      sibling = otherEdgeIdx)\n    return newEdge\n\ndef create_fold_edge_from_base(flatEdge):\n    return FoldEdge(fromFace = flatEdge.fromFace, \n                    indexInFace=flatEdge.indexInFace,\n                    meshEdgeIdx = flatEdge.meshEdgeIdx,\n                    angle = flatEdge.angle)\n\ndef create_naked_edge_from_base(flatEdge):\n    return NakedEdge(fromFace=flatEdge.fromFace,\n                     indexInFace=flatEdge.indexInFace,\n                     meshEdgeIdx = flatEdge.meshEdgeIdx,\n                     angle = flatEdge.angle)\n\nedge_colors = {'blue': (0,0,0,255),\n               'red':(0,255,0,0),\n               'green':(0,0,255,0)}\n\nclass FlatEdge(object):\n    def __init__(self,fromFace,indexInFace,meshEdgeIdx=None,angle=None,**kwargs):\n        self.fromFace = fromFace  #fromFace is \"homeFace\"\n        self.indexInFace = indexInFace # which edge of the from face\n        self.meshEdgeIdx = meshEdgeIdx #corresponding edge in mesh\n        self.angle = angle #dihedral angle of corresponding mesh edge\n        self.toFace = None\n        self.color = (0,0,0,0)\n        self.index_color = (0,103,118,198)\n        self.group_name = rs.AddGroup()\n        self.line = None\n        self.line_id = None\n        self.geom = []\n        self.post_initialize(kwargs)\n\n    def rgb_color(self):\n         return self.color[1:]\n\n    def post_initialize(self,kwargs):\n        pass\n\n    def get_geom(self):\n        ''' note that show should be called before this function\n        '''\n        return rs.ObjectsByGroup(self.group_name)\n\n    def show(self,island):\n        '''\n        General Function for edges to show geometry, meant to be overwritten for each subclass\n        '''\n        self.show_specialized(island)\n        rs.AddObjectsToGroup(self.get_geom(),island.group_name)\n\n    def show_specialized(self,island):\n        ''' template function to be overwritten by specialized flatEdge types'''\n        pass\n    \n    def clear(self):\n        ''' removes all geometry for this object'''\n        rs.DeleteObjects(self.get_geom())\n\n    def show_index(self,index,island):\n        '''for displaying this edge in the island '''\n        center = self.getMidPoint(island)\n        dot_guid = rs.AddTextDot(str(index),center)\n        rs.ObjectColor(dot_guid,self.index_color)\n        rs.AddObjectToGroup(dot_guid,self.group_name)\n\n    def show_line(self,island):\n        points = self.get_coordinates(island)\n        if self.line_id is not None:\n            scriptcontext.doc.Objects.Delete(self.line_id, True)\n        line_id, line = vis.show_line_from_points(points, color=self.color, arrowType='none')\n        self.line_id = line_id\n        self.line = line\n        rs.AddObjectToGroup(line_id,self.group_name)\n        return line_id\n\n    def type(self):\n        #TODO: find better way\n        return 'FlatEdge'\n\n    def reset(self, oldVert, newVert):\n        if self.vertAidx == oldVert:\n            self.vertAidx = newVert\n        elif self.vertBidx == oldVert:\n            self.vertBidx = newVert\n        else:\n            assert(False == True), \"error, flatEdge does not have oldVert\"\n\n    def _getFlatVerts(self, flatVerts):\n        #DEPRICATED\n        flatVertI = flatVerts[self.vertAidx]\n        flatVertJ = flatVerts[self.vertBidx]\n        return (flatVertI, flatVertJ)\n\n    def getFlatFace(self, flatFaces):\n        return flatFaces[self.fromFace]\n\n    def getEdgeLine(self, flatVerts):\n        pntI, pntJ = self.get_coordinates(island)\n        return Rhino.Geometry.Line(pntI, pntJ)\n    \n    def get_coordinates(self,island):\n        ''' faces in island, verts in island '''\n        vertA,vertB = self.get_verts(island)\n        pointA,pointB = island.flatVerts[vertA].point, island.flatVerts[vertB].point\n        return pointA,pointB\n\n    def get_verts(self,island):\n        '''\n        always gets verts in order acording to this edges\n        fromFace\n        '''\n        face = island.flatFaces[self.fromFace]\n        verts = face.vertices\n        vertA = verts[self.indexInFace]\n        vertB = verts[(self.indexInFace + 1)%len(verts)]\n        return vertA,vertB\n    \n    def get_reversed_verts(self,island):\n        vertA,vertB = self.get_verts(island)\n        return [vertB,vertA]\n\n    def getTVerts(self, mesh):\n        return getTVertsForEdge(mesh, self.meshEdgeIdx)\n\n    def get_angle_in_mesh(self, myMesh):\n        '''get dihedral angle of the corresponding mesh edge'''\n        if self.angle is None:\n            self.angle = myMesh.getEdgeAngle(self.meshEdgeIdx)\n            return self.angle\n        else:\n            return self.angle\n\n    def get_other_face_center(self, myMesh, currFace, xForm):\n        # NOTE appears to be failing for orthogonal geom\n        # NOTE perhaps should be a method only CutEdge implements?\n        '''\n        This function works in the context of layout, where xForms are being\n        created\n        '''\n        otherFace = myMesh.getOtherFaceIdx(self.meshEdgeIdx, currFace)\n        if otherFace is not None and otherFace != -1:\n            faceCenter = myMesh.mesh.Faces.GetFaceCenter(otherFace)\n            faceCenter.Transform(xForm)\n            faceCenter.Z = 0.0  # this results in small error, TODO: change to more robust method\n            self.tabFaceCenter = faceCenter\n        if self.tabFaceCenter is None:\n            return False\n        else:\n            return True\n\n    def drawEdgeLine(self, flatVerts, angleThresh, myMesh):\n        # DEPRICATED Legacy code\n        if self.type is not None:\n            if self.type == 'fold':\n                if self.getMeshAngle(myMesh) >= angleThresh:\n                    color = (0, 49, 224, 61)  # green\n                else:\n                    # bluegreyish for no crease lines\n                    color = (0, 161, 176, 181)\n            elif self.type == 'cut':\n                color = (0, 237, 43, 120)  # red\n                if self.hasTab:\n                    color = (0, 255, 0, 255)  # magenta\n                    self.drawTab(flatVerts)\n            elif self.type == 'naked':\n                color = (0, 55, 156, 196)  # blue\n            points = self.get_coordinates(island)\n            if self.line_id is not None:\n                scriptcontext.doc.Objects.Delete(self.line_id, True)\n            # EndArrowhead StartArrowhead\n            line_id, line = drawLine(points, color, 'None')\n            self.line_id = line_id\n            self.line = line\n        return line_id\n\n    def get_edge_vec(self,island):\n        pntA,pntB = self.get_coordinates(island)\n        return rhino_helpers.getVectorForPoints(pntA,pntB)\n\n    def getEdgeVec_depricated(self, flatVerts):\n        pointI = flatVerts[self.vertAidx].point\n        pointJ = flatVerts[self.vertBidx].point\n        return Rhino.Geometry.Vector3d(pointJ - pointI)\n\n    def resetFromFace(self, face):\n        if self.fromFace == face:\n            self.fromFace = self.toFace\n            self.toFace = face\n            \n    def getOtherFace(self,face):\n        if self.fromFace == face:\n            return self.toFace\n        elif self.toFace == face:\n            return self.fromFace\n        else:\n            return None\n\n    def getConnectToFace(self, flatFaces, mesh):\n        return flatFaces[getOtherFaceIdx(self.meshEdgeIdx, self.fromFace, mesh)]\n\n    def getMidPoint(self, island):\n        coordinates = self.get_coordinates(island)\n        pntA = coordinates[0]\n        pntB = coordinates[1]\n        x = (pntA.X + pntB.X) / 2.0\n        y = (pntA.Y + pntB.Y) / 2.0\n        z = (pntA.Z + pntB.Z) / 2.0\n        return geom.Point3f(x, y, z)\n\n    def getFaceFromPoint(self,flatFaces,flatVerts,point):\n        \"\"\"\n        the given point is assumed to be on one side of the edge or another.\n        If colinear return None\n        Otherwise return the face that is on the same side as the point\n        \"\"\"\n        pntI,pntJ = self.get_coordinates(island)\n        selfVec = self.get_edge_vec(flatVerts)\n        pntVec = Rhino.Geometry.Vector3d(point - pntI)\n        faceA = flatFaces[self.fromFace]\n        faceB = flatFaces[self.toFace]\n        faceCenterA = faceA.getCenterPoint(flatVerts)\n        faceCenterB = faceB.getCenterPoint(flatVerts)\n        faceVecA = Rhino.Geometry.Vector3d(faceCenterA-pntI)\n        faceVecB = Rhino.Geometry.Vector3d(faceCenterB-pntI)\n        selfxPnt = Rhino.Geometry.Vector3d.CrossProduct(selfVec,pntVec) \n        if selfxPnt.IsZero:\n            print \"Point was coincident with flatEdge\"\n            return None\n        selfxFaceA = Rhino.Geometry.Vector3d.CrossProduct(selfVec,faceVecA)\n        selfxFaceB = Rhino.Geometry.Vector3d.CrossProduct(selfVec,faceVecB)\n        def sign(x): return x/math.fabs(x)\n        if sign(selfxFaceA.Z) == sign(selfxFaceB.Z):\n            print \"both faces on same side of edge, or both have centers coincident with edge\"\n            return None\n        if sign(selfxPnt.Z) == sign(selfxFaceA.Z):\n            return self.fromFace\n        elif sign(selfxPnt.Z):\n            return self.toFace\n        else:\n            \"some unforseen problem in FlatEdge.getFaceFromPoint\"\n            return None\n\n    def testFacesIsLeft(self, net, face):\n        '''find which side the face is on relative to this edge\n        ouput: 1 for left, -1 for right, 0 for error\n        '''\n\n        testPoint = net.flatVerts[self.getNeighborFlatVert(net, face)].point\n        if not testPoint:\n            return -1\n        return self.testPointIsLeft(testPoint, net.flatVerts)\n\n    def testPointIsLeft(self, testPoint, flatVerts):\n        '''\n        use cross product to see if testPoint is to the left of\n        the edgLine\n        returns False if co-linear. HOwever, if the mesh is triangulated\n        and has no zero-area faces this should not occur.\n        '''\n        pntA, pntB = self.get_coordinates(island)\n        vecLine = getVectorForPoints(pntA, pntB)\n        vecTest = getVectorForPoints(pntA, testPoint)  # this may be too skewed\n        cross = Rhino.Geometry.Vector3d.CrossProduct(vecLine, vecTest)\n        z = cross.Z  # (pos and neg)\n        return z > 0\n\n    def getNeighborFlatVert(self, net, face=None):\n        '''\n        gets one of the flatVerts associated with the given\n        face, but that is not a part of this flatEdge.\n        if face==None uses the fromFace associated with this edge\n        '''\n\n        if face is None:\n            face = self.fromFace\n        tVertsEdge = set([self.vertAidx, self.vertBidx])\n        flatFace = net.flatFaces[face]\n        tVertsFace = set(flatFace.vertices)\n        neighbors = list(tVertsFace - tVertsEdge)\n        return neighbors[0]  # arbitrarily return first tVert\n\n    def getFacePoint(self, flatVerts, flatFaces):\n        return flatFaces[self.fromFace].getCenterPoint(flatVerts)\n\n    def getFacePolyline(self, net):\n        polylineCurve = net.flatFaces[\n            self.fromFace].getPolylineCurve(\n            net.flatVerts)\n        return polylineCurve\n\n    def inFace(self, net, point):\n        polylineCurve = self.getFacePolyline(net)\n        relationship = polylineCurve.Contains(point)\n        if Rhino.Geometry.PointContainment.Unset == relationship:\n            print \"curve was not closed, relationship meaningless\"\n            return\n        elif Rhino.Geometry.PointContainment.Inside == relationship:\n            return True\n        elif Rhino.Geometry.PointContainment.Outside == relationship:\n            return False\n        else:\n            # coincident, still leads to bad condition for holes\n            return False\n\n    '''\n    TRANSLATION STUFF\n    '''\n    def translateGeom(self, movedNetVerts, flatVerts, xForm):\n        # self.translateEdgeLine(xForm)\n        self.translateNetVerts(movedNetVerts, flatVerts, xForm)\n        if self.geom:\n            for element in self.geom:\n                element.Transform(xForm)\n\n#NOTE: this function should be removed! Want to translate the actual structure (i.e. the vertices) not its\n# reprsentation\n    def translateEdgeLine(self, xForm):\n        if self.line is not None:\n            self.line.Transform(xForm)\n            scriptcontext.doc.Objects.Replace(self.line_id, self.line)\n\n    def translateNetVerts(self, movedNetVerts, flatVerts, xForm):\n        netVertI, netVertJ = self.getFlatVerts(flatVerts)\n        if netVertI not in movedNetVerts:\n            netVertI.translate(xForm)\n            movedNetVerts.append(netVertI)\n        if netVertJ not in movedNetVerts:\n            netVertJ.translate(xForm)\n            movedNetVerts.append(netVertJ)\n\n    def clearAllGeom(self):\n        '''\n        note: clear self.geom and self.line_id ?\n        '''\n        if self.line_id is not None:\n            scriptcontext.doc.Objects.Delete(self.line_id, True)\n            self.line_id = None\n\n        if self.geom:\n            for guid in self.geom:\n                scriptcontext.doc.Objects.Delete(guid, True)\n\nclass FoldEdge(FlatEdge):\n    \n    def post_initialize(self,kwargs):\n        self.color = edge_colors['green']\n        self.angle_threshold = math.radians(3.5) \n    \n    def show_specialized(self,island):\n        if self.angle > self.angle_threshold:\n            self.show_line(island)\n            #self._show_crease(island)\n\n    def _show_crease(self,island):\n        pntA,pntB = self.get_coordinates(island)\n        offset = .1\n        width = .084\n        curve = creaseGeom.pill_shape(pntA,pntB,offset,width,self.rgb_color())\n        rs.AddObjectToGroup(curve,self.group_name)\n        \n    def type(self):\n        # TODO: find better way\n        return 'FoldEdge'\n\nclass CutEdge(FlatEdge):\n\n    def post_initialize(self,kwargs):\n        self.has_outer_joinery = kwargs.get('has_outer_joinery',True)\n        self.sibling = kwargs['sibling'] #sibling not currently used\n        self.color = edge_colors['red']\n        self.tabWidth = .5\n        self.tabOnLeft = False\n        self.tabAngles = [45,45]\n\n    def show_specialized(self,island):\n        curve_id = self.show_line(island)\n        island.cut_edge_lines.append(curve_id)\n        if self.has_outer_joinery:\n            curves = island.joinerySystem.outer_joinery(curve_id,left_side=False)\n            rs.AddObjectsToGroup(curves,self.group_name)\n        else:\n            rs.ReverseCurve(curve_id) #necessary to reverse direction so edges match\n            curves = island.joinerySystem.inner_joinery(curve_id,left_side=False)\n            rs.AddObjectsToGroup(curves,self.group_name)\n\n    def type(self):\n        # TODO: find better way\n        return 'CutEdge'\n\n    def setTabSide(self, facePoint, flatVerts):\n        '''\n        occurs affter complete layout\n        '''\n        if self.tabOnLeft is None:\n            #testPoint = net.flatVerts[self.getNeighborFlatVert(net)].point\n            if self.testPointIsLeft(facePoint, flatVerts):\n                self.tabOnLeft = False\n            else:\n                self.tabOnLeft = True\n            return self.tabOnLeft\n        else:\n            return self.tabOnLeft\n\n    def drawTab(self,island):\n        '''outputs guid for polyline'''\n        flatVerts = island.flatVerts\n        if len(self.geom) > 0:\n            for guid in self.geom:\n                scriptcontext.doc.Objects.Delete(guid, True)\n        if len(self.tabAngles) < 1:\n            return self.drawTruncatedTab(flatVerts)\n        else:\n            print \"quadtab\"\n            return self.drawQuadTab(flatVerts)\n\n    def drawQuadTab(self,island):\n        pntA, pntD = self.get_coordinates(island)\n        vecA = geom.Vector3d(pntA)\n        vecD = geom.Vector3d(pntD)\n\n        alpha = self.tabAngles[0]\n        beta = self.tabAngles[1]\n\n        lenI = self.tabWidth / math.sin(alpha * math.pi / 180.0)\n        lenJ = self.tabWidth / math.sin(beta * math.pi / 180.0)\n\n        if not self.tabOnLeft:\n            alpha = -1 * alpha\n            beta = -1 * beta\n\n        vec = vecD.Subtract(vecD, vecA)\n        vecUnit = rs.VectorUnitize(vec)\n        vecI = rs.VectorScale(vecUnit, lenI)\n        vecJ = rs.VectorScale(vecUnit, -lenJ)\n\n        vecI = rs.VectorRotate(vecI, alpha, [0, 0, 1])\n        vecJ = rs.VectorRotate(vecJ, -beta, [0, 0, 1])\n        vecB = vecA + vecI\n        vecC = vecD + vecJ\n\n        pntB = geom.Point3d(vecB)\n        pntC = geom.Point3d(vecC)\n\n        points = [pntA, pntB, pntC, pntD]\n        polyGuid = rs.AddPolyline(points)\n\n        self.geom.append(polyGuid)\n        return polyGuid\n\n    def drawTruncatedTab(self,island):\n        flatVerts = island.flatVerts\n        tabLen = self.tabWidth\n        I, J = self.get_coordinates(island)\n        K = self.tabFaceCenter\n        if self.tabFaceCenter is None:  # this is ahack: TODO: if a new cut edge is created, give it a tabFaceCenter\n            return\n        diagA = Rhino.Geometry.Line(I, K)\n        diagB = Rhino.Geometry.Line(J, K)\n        offsetLine, vecA = getOffset((I, J), K, tabLen, True)\n\n        resultI, aI, bI = Rhino.Geometry.Intersect.Intersection.LineLine(\n            offsetLine, diagA)\n        resultJ, aJ, bJ = Rhino.Geometry.Intersect.Intersection.LineLine(\n            offsetLine, diagB)\n        if resultI and resultJ:\n            intersectPntI = offsetLine.PointAt(aI)\n            intersectPntJ = offsetLine.PointAt(aJ)\n\n            shorterThanTab = self.checkIfShortTab(flatVerts)\n            if shorterThanTab == 1:\n                # flip order to avoid self-intersction\n                points = [I, K, J]\n            elif shorterThanTab == 0:\n                points = [I, K, J]\n            elif shorterThanTab == -1:\n                points = [\n                    I,\n                    intersectPntI,\n                    intersectPntJ,\n                    J]  # order is as expected\n        else:\n            points = [I, K, J]\n\n        polyGuid = rs.AddPolyline(points)\n        self.geom.append(polyGuid)\n\n        return polyGuid\n\n    def checkIfShortTab(self, flatVerts):\n        center = self.tabFaceCenter\n        edgeLine = self.getEdgeLine(flatVerts)\n        closestPnt = edgeLine.ClosestPoint(center, True)\n        vec = Rhino.Geometry.Point3d.Subtract(center, closestPnt)\n        lenVec = vec.Length\n        if lenVec < self.tabWidth:\n            return 1\n        if lenVec == self.tabWidth:\n            return 0\n        else:\n            return -1\n\n    def drawTriTab(self, net):\n        holeRadius = net.holeRadius\n        mesh = net.mesh\n        flatVerts = net.flatVerts\n        flatFaces = net.flatFaces\n\n        minArea = (holeRadius**2.0) * math.pi * 30\n        # print \"minArea: \" + str(minArea)\n\n        flatFace = self.getConnectToFace(flatFaces, mesh)\n        area = flatFace.getArea(flatVerts)\n\n        pntA, pntC = self.get_coordinates(island)\n        pntB = self.tabFaceCenter\n\n        points = [pntA, pntB, pntC]\n        polyline = Rhino.Geometry.PolylineCurve([pntA, pntB, pntC, pntA])\n        props = Rhino.Geometry.AreaMassProperties.Compute(polyline)\n        if area > minArea:\n            centerPnt = props.Centroid\n        else:\n            rs.AddTextDot(\"o\", pntB)\n            centerPnt = flatFaces[\n                self.fromFace].getCenterPoint(\n                flatVerts, True)\n        hole = rs.AddCircle(centerPnt, holeRadius)\n        polyGuid = rs.AddPolyline(points)\n        self.geom.append(polyGuid)\n        self.geom.append(hole)\n        return polyGuid\n\n    def getTabAngles(self, mesh, currFaceIdx, xForm):\n        # WORKING AWAY FROM THIS: data is implicit in tabFace center\n        edge = self.meshEdgeIdx\n        otherFace = getOtherFaceIdx(edge, currFaceIdx, mesh)\n\n        if otherFace is not None:\n            faceCenter = mesh.Faces.GetFaceCenter(otherFace)  # Point3d\n            if getDistanceToEdge(mesh, edge, faceCenter) <= self.tabWidth:\n                faceCenter.Transform(xForm)\n                self.tabFaceCenter = faceCenter\n            else:\n                posVecCenter = Rhino.Geometry.Vector3d(faceCenter)\n\n                pntI, pntJ = getPointsForEdge(mesh, edge)  # Point3d\n                vecEdge = getEdgeVector(mesh, edge)  # Vector3d\n                posVecI = Rhino.Geometry.Vector3d(pntI)\n                posVecJ = Rhino.Geometry.Vector3d(pntJ)\n\n                vecI = Rhino.Geometry.Vector3d.Subtract(posVecCenter, posVecI)\n                vecJ = Rhino.Geometry.Vector3d.Subtract(posVecJ, posVecCenter)\n\n                angleI = rs.VectorAngle(vecI, vecEdge)\n                angleJ = rs.VectorAngle(vecJ, vecEdge)\n\n                self.tabAngles = [angleI, angleJ]\n\n                \"\"\"\n        color = (0,0,0,0)\n        drawVector(vecI,posVecI,color)\n        drawVector(vecJ,posVecCenter,color)\n        strI = str(angleI)\n        strJ = str(angleJ)\n        rs.AddTextDot(strI,posVecI)\n        rs.AddTextDot(strJ,posVecJ)\n        print #wtf: for some reason needed this line to print below\n        print( 'angleI: %.2f, angleJ: %.2f' %(angleI,angleJ) )\n        \"\"\"\n        elif otherFace == -1:\n            print \"was nakedEdge\"\n        else:\n            print \"otherFace: \",\n            print otherFace\n\n    def drawFaceHole(self, flatVerts,flatFaces, holeRadius):\n        pntA, pntC = self.get_coordinates(island)\n        pntB = flatFaces[self.fromFace].getCenterPoint(flatVerts, True)\n        pnts = [pntA, pntB, pntC, pntA]\n        polyline = Rhino.Geometry.PolylineCurve(pnts)\n        props = Rhino.Geometry.AreaMassProperties.Compute(polyline)\n        centerPnt = props.Centroid\n        hole = rs.AddCircle(centerPnt, holeRadius)\n        self.geom.append(hole)\n\n    def drawHoles(self, net, connectorDist, safetyRadius, holeRadius):\n        self.assignHoleDists(net, connectorDist, safetyRadius)\n        points = self.getHolePoints(net.flatVerts)\n        safeR = holeRadius + (safetyRadius - holeRadius) / 2.0\n        geom = [[0, 0], [0, 0]]\n        for i, point in enumerate(points):\n            if point is not None:\n                geom[i][0] = Rhino.Geometry.Circle(point, holeRadius)\n                circleSafe = Rhino.Geometry.Circle(point, safeR)\n                geom[i][1] = Rhino.Geometry.ArcCurve(circleSafe)\n        if geom[0][0] != 0 and geom[1][0] != 0:\n            tolerance = .001\n            plane = Rhino.Geometry.Plane(\n                Rhino.Geometry.Point3d(\n                    0, 0, 0), Rhino.Geometry.Vector3d(\n                    0, 0, 1))\n\n            # check if the circles are inside there parent face\n\n            # check if the circles are intersectin each other\n            relation = Rhino.Geometry.Curve.PlanarClosedCurveRelationship(\n                geom[0][1], geom[1][1], plane, tolerance)\n            if relation == Rhino.Geometry.RegionContainment.Disjoint:\n                guidI = scriptcontext.doc.Objects.AddCircle(geom[0][0])\n                guidJ = scriptcontext.doc.Objects.AddCircle(geom[1][0])\n\n                # draw lines for debugging\n                centerPnt = geom[0][0].Center\n                rs.AddLine(centerPnt, self.line.ClosestPoint(centerPnt, True))\n\n                centerPnt = geom[1][0].Center\n                rs.AddLine(centerPnt, self.line.ClosestPoint(centerPnt, True))\n\n                self.geom.extend((guidI, guidJ))\n            elif relation == Rhino.Geometry.RegionContainment.MutualIntersection:\n                # only add I circle\n                guid = scriptcontext.doc.Objects.AddCircle(geom[0][0])\n                self.geom.append(guid)\n        elif geom[0][0] != 0:\n            guid = scriptcontext.doc.Objects.AddCircle(geom[0][0])\n            self.geom.append(guid)\n        elif geom[1][0] != 0:\n            guid = scriptcontext.doc.Objects.AddCircle(geom[1][0])\n            self.geom.append(guid)\n\n    def getHolePoints(self, flatVerts):\n        # TODO: replace this with less redundant version (iterate trhough\n        # points)\n        pointI, pointJ = (None, None)\n        if self.distI != -1:\n            vecI = self.get_edge_vec(flatVerts)\n            vecI.Unitize()\n            vecI = vecI * self.distI\n            pointI = (flatVerts[self.vertAidx].point + vecI)\n            pointI = pointI + self.holeVec\n        if self.distJ != -1:\n            vecJ = -1 * self.get_edge_vec(flatVerts)\n            vecJ.Unitize()\n            vecJ = vecJ * self.distJ\n            pointJ = (flatVerts[self.vertBidx].point + vecJ)\n            pointJ = pointJ + self.holeVec\n        return (pointI, pointJ)\n\n    def assignHoleDists(self, net, connectorDist, safetyRadius):\n        if self.distI is None and self.distJ is None:\n            pair = net.flatEdges[self.pair]\n            distsA = pair.getHoleDistances(net, connectorDist, safetyRadius)\n            distsB = self.getHoleDistances(net, connectorDist, safetyRadius)\n            distI = max(distsA[0], distsB[0])\n            distJ = max(distsA[1], distsB[1])\n\n            pair.distI = distI\n            pair.distJ = distJ\n            pair.holeVec = distsA[2]\n            self.distI = distI\n            self.distJ = distJ\n            self.holeVec = distsB[2]\n\n    def assignHoleDistsRatio(self, flatVerts, ratio):\n        edgeVec = self.get_edge_vec(flatVerts)\n        length = edgeVec.Length\n        distI = length * ratio\n        distJ = length * ratio\n        return (distI, distJ, vec)\n\n    def getHoleDistancesSimple(self, net, connectorDist, ratioEdgeLen):\n        edgeVec = self.get_edge_vec(net.flatVerts)\n\n    def getHoleDistances(self, net, connectorDist, safetyRadius):\n        '''\n        get the two distances for a given edge by interescting the offset lines\n        from the edge line and the two lines formed from the edgePoints to faceCenter\n        '''\n        flatVerts = net.flatVerts\n        flatFaces = net.flatFaces\n        # assumes laying-out in xy plane\n        axis = Rhino.Geometry.Vector3d(0.0, 0.0, 1.0)\n        K = self.getFacePoint(flatVerts, flatFaces)  # CenterPoint\n        # rs.AddPoint(K)\n        I, J = self.get_coordinates(island)\n        offsetLineA, vecA = getOffset(\n            (I, J), K, connectorDist, True)  # EdgeOffset\n        offsetLineB, vecB = getOffset((I, K), J, safetyRadius, True)\n        offsetLineC, vecC = getOffset((J, K), I, safetyRadius, True)\n\n        rcI, aI, bI = Rhino.Geometry.Intersect.Intersection.LineLine(\n            offsetLineA, offsetLineB)\n        if not rcI:\n            print \"No Intersection found for first chordB\"\n            return Rhino.Commands.Result.Nothing\n        rcJ, aJ, bJ = Rhino.Geometry.Intersect.Intersection.LineLine(\n            offsetLineA, offsetLineC)\n        if not rcJ:\n            print \"No Intersection found for second chordC\"\n            return Rhino.Commands.Result.Nothing\n        pointI = offsetLineA.PointAt(aI)\n        pointJ = offsetLineA.PointAt(aJ)\n        # CHECK IF POINTS ARE WITHIN THAT FACE\n        if self.line is None:\n            self.line = Rhino.Geometry.Line(I, J)\n\n        if not self.inFace(net, pointI):\n            print \"assining -1\"\n            distI = -1\n        else:\n            pntOnEdgeI = self.line.ClosestPoint(pointI, True)\n            distI = pntOnEdgeI.DistanceTo(I)\n\n        if not self.inFace(net, pointJ):\n            distJ = -1\n        else:\n            pntOnEdgeJ = self.line.ClosestPoint(pointJ, True)\n            distJ = pntOnEdgeJ.DistanceTo(J)\n        # rs.AddPoint(pntOnEdgeI)\n        # rs.AddPoint(pntOnEdgeJ)\n        return (distI, distJ, vecA)  # vecA will be used to place actually hole\n\nclass NakedEdge(FlatEdge):\n\n    def post_initialize(self,kwargs):\n        #self.color = edge_colors['blue']\n        self.color = edge_colors ['red']\n            \n    def show_specialized(self,island):\n        self.show_line(island)\n\nclass _FlatEdge():\n    \"\"\"\n    DEPRICATED\n    A FlatEdge is an edge of the net.\n    It knows what kind of edge it is,\n    who its vertices are and where those vertices are\n\n    EVERY single flat edge shall knowith its from face and two face!\n    \"\"\"\n\n    def __init__(self, edgeIdx, vertI, vertJ,fromFace,toFace=None):\n        self.meshEdgeIdx = edgeIdx\n        self.vertAidx = vertI\n        self.vertBidx = vertJ\n\n        self.line = None\n        self.line_id = None\n        self.geom = []\n        self.type = None\n        # faces have direct mapping (this is netFace and meshFace)\n        self.fromFace = fromFace\n        self.toFace = toFace\n        self.angle = None\n\n        '''JOINERY'''\n        self.tabOnLeft = None  # important for general joinery drawing\n\n        '''Tabs'''\n        self.hasTab = False\n        self.tabFaceCenter = None  # point3d\n        self.tabAngles = []\n        self.tabWidth = .5  # could be standard, or based on face area\n\n        '''Holes'''\n        self.distI = None\n        self.distJ = None\n\n    \n    '''DRAWING'''\n\n    \n    '''JOINERY'''\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}