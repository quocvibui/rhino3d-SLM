{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_continuityBetween2.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_continuityBetween2.py",
  "instruction": "Spb crv continuity between2",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190708: Created.\r\n...\r\n200304: Bug fix in printed output for G0 continuity.\r\n200515: Modified some option defaults.\r\n200814: Bug fix in recognizing G2 and C1 continuities.\r\n200816,17: Bug fix in acknowledging that a colinear joint is G2.\r\n200901: Parameterization is no longer normalized to try for C continuity matches.\r\n200916: Bug fix.\r\n201120,22: Now supports reporting continuities up through C11 and G3 (More if C > 3).\r\n201204: Bug fixes.\r\n210202: Bug fix: Now, when both G3 components are tiny, G3 is returned.\r\n210302: Now G0 continuity check is used for C0 continuity check.\r\n210712: Added more debug printed feedback.\r\n220117: Bug fix when checking for G2.\r\n220121: Bug fix.\r\n220425: Modified printed output.\r\n220705: Modified length tolerance used in C continuity check.\r\n\r\nTODO: Add percent tolerance for G2 continuity.  http://catiadoc.free.fr/online/cfyugfss_C2/cfyugfssut_implicitmode_0311.htm\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fDistTol'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'fAngleTol_Vector_Deg'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAngleToleranceDegrees\r\n    names[key] = 'VectAngleTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAlignCrvDirs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDistTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n        if key == 'fAngleTol_Vector_Deg':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve and parameter with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select 2 curves near their ends to evaluate\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.OneByOnePostSelect = True\r\n    go.DisablePreSelect()\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        idxs_Opt['DocTols'] = go.AddOption('DocTols')\r\n        idxs_Opt['TightTols'] = go.AddOption('TightTols')\r\n        addOption('fDistTol')\r\n        addOption('fAngleTol_Vector_Deg')\r\n        addOption('bAlignCrvDirs')\r\n        addOption('bAddDot')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=2)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if go.Option().Index == idxs_Opt['DocTols']:\r\n            Opts.riOpts['fDistTol'].CurrentValue =  Opts.riOpts['fDistTol'].InitialValue\r\n            Opts.riOpts['fAngleTol_Vector_Deg'].CurrentValue =  Opts.riOpts['fAngleTol_Vector_Deg'].InitialValue\r\n        elif go.Option().Index == idxs_Opt['TightTols']:\r\n            Opts.riOpts['fDistTol'].CurrentValue =  1e-12\r\n            Opts.riOpts['fAngleTol_Vector_Deg'].CurrentValue =  1e-6\r\n        elif Opts.riOpts['fDistTol'].CurrentValue < 0.0:\r\n            Opts.riOpts['fDistTol'].CurrentValue = Opts.riOpts['fDistTol'].InitialValue\r\n        elif Opts.riOpts['fAngleTol_Vector_Deg'].CurrentValue < 0.0:\r\n            Opts.riOpts['fAngleTol_Vector_Deg'].CurrentValue = Opts.riOpts['fAngleTol_Vector_Deg'].InitialValue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef testWithControlPointLocations():\r\n\r\n    fDist_Cps_TanToPos_A = (\r\n            rgCrv_SingleSpan_A.Points[idxCp_Tan_A].Location.DistanceTo(\r\n                    rgCrv_SingleSpan_A.Points[idxCp_Pos_A].Location))\r\n\r\n    fDist_Cps_TanToPos_B = (\r\n            rgCrv_SingleSpan_B.Points[idxCp_Tan_B].Location.DistanceTo(\r\n                    rgCrv_SingleSpan_B.Points[idxCp_Pos_B].Location))\r\n\r\n    #    sEval='fDist_Cps_TanToPos_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #    sEval='fDist_Cps_TanToPos_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #    sEval='fDist_Cps_TanToPos_B/fDist_Cps_TanToPos_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    pt_CrvOppTan_A = rg.Point3d(\r\n            rgCrv_SingleSpan_A.Points[idxCp_Tan_A].Location -\r\n            (   rgCrv_SingleSpan_A.Points[idxCp_Crv_A].Location -\r\n                rgCrv_SingleSpan_A.Points[idxCp_Tan_A].Location)\r\n    )\r\n    #sc.doc.Objects.AddPoint(pt_CrvOppTan_A)\r\n    \r\n    pt_CrvOppTan_B = rg.Point3d(\r\n            rgCrv_SingleSpan_B.Points[idxCp_Tan_B].Location -\r\n            (   rgCrv_SingleSpan_B.Points[idxCp_Crv_B].Location -\r\n                rgCrv_SingleSpan_B.Points[idxCp_Tan_B].Location)\r\n    )\r\n    #sc.doc.Objects.AddPoint(pt_CrvOppTan_B)\r\n\r\n    fDist_Cps_CrvToTan_A = (\r\n            rgCrv_SingleSpan_A.Points[idxCp_Crv_A].Location.DistanceTo(\r\n                    rgCrv_SingleSpan_A.Points[idxCp_Tan_A].Location))\r\n\r\n    fDist_Cps_CrvToTan_B = (\r\n            rgCrv_SingleSpan_B.Points[idxCp_Crv_B].Location.DistanceTo(\r\n                    rgCrv_SingleSpan_B.Points[idxCp_Tan_B].Location))\r\n\r\n    sEval='pt_CrvOppTan_A.DistanceTo(pt_CrvOppTan_B)'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    if (\r\n            pt_CrvOppTan_A.DistanceTo(pt_CrvOppTan_B) <= fDistTol\r\n            and\r\n            abs(1.0 - rgCrv_SingleSpan_A.Domain.Length) <= fDistTol\r\n            and\r\n            abs(1.0 - rgCrv_SingleSpan_B.Domain.Length) <= fDistTol\r\n    ):\r\n        sContinuity_MaxFound = \"C2\"\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None:\r\n        return \"(No deviation provided)\"\r\n    elif fDistance < 1e-6:\r\n        return \"0\"\r\n    elif fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-2)):\r\n        return \"{:.1e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef continuityVectorsAt(nc, t, side=rg.CurveEvaluationSide.Default):\r\n    \"\"\"\r\n    Returns: Tuple of these 4 items:\r\n        3D point as a vector,\r\n        Unit tangent vector,\r\n        Curvature vector,\r\n        Vector for comparing G3 continuity, not the G3 vector itself\r\n        \r\n        None for any of aforementioned vectors on fail.\r\n    \"\"\"\r\n\r\n    if not isinstance(nc, rg.NurbsCurve): return\r\n\r\n    vs = nc.DerivativeAt(\r\n        t,\r\n        derivativeCount=3,\r\n        side=side)\r\n\r\n    # Not using rg.Curve.TangentAt since it doesn't take into account CurveEvaluationSide.\r\n    vTangency = vs[1]/vs[1].Length\r\n    \r\n    cross = rg.Vector3d.CrossProduct\r\n\r\n    # For R3\r\n    vCurvature = (\r\n        cross(cross(vs[1], vs[2]), vs[1])\r\n        /\r\n        vs[1].Length**4\r\n        )\r\n\r\n    #sEval='vCurvature_A_Formula'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sc.doc.Objects.AddLine(rg.Line(start=rg.Point3d(vs[0]), span=vCurvature_A_Formula))\r\n\r\n    # For R2\r\n    #vCurvature_A = (\r\n    #            cross(vs[1], vs[2]) /\r\n    #            vs[1].Length**3)\r\n\r\n\r\n    # From Eq. 3.5 in CAN A CUBIC SPLINE CURVE BE G3\r\n    # in Journal of Computational Mathematics:\r\n    vTorsion = (\r\n        (\r\n        -3.0*(vs[1] * vs[2])*(cross(vs[1], vs[2]))\r\n        /\r\n        (vs[1] * vs[1])**3.0\r\n        )\r\n        +\r\n        cross(vs[1], vs[3]) / (vs[1] * vs[1])**2.0\r\n    )\r\n\r\n\r\n    return vs[0], vTangency, vCurvature, vTorsion\r\n\r\n\r\ndef getContinuity_C(ncA, tA, crvEvalSide_A, ncB, tB, crvEvalSide_B):\r\n    \"\"\"\r\n    Returns:\r\n        int(C continuity)\r\n        or\r\n        None\r\n    \"\"\"\r\n\r\n    ncA_WIP = ncA.DuplicateCurve()\r\n    ncB_WIP = ncB.DuplicateCurve()\r\n\r\n    if ncA_WIP.Degree < ncB_WIP.Degree:\r\n        ncA_WIP.IncreaseDegree(ncB.Degree)\r\n    elif ncA_WIP.Degree > ncB_WIP.Degree:\r\n        ncB_WIP.IncreaseDegree(ncA.Degree)\r\n\r\n    degree_Max = ncA_WIP.Degree\r\n\r\n\r\n    vsDerivs_A = ncA_WIP.DerivativeAt(\r\n        tA,\r\n        derivativeCount=degree_Max,\r\n        side=crvEvalSide_A)\r\n\r\n    if vsDerivs_A[1].IsTiny():\r\n        ncA_WIP.Dispose()\r\n        ncB_WIP.Dispose()\r\n        return\r\n\r\n\r\n    vsDerivs_B = ncB_WIP.DerivativeAt(\r\n        tB,\r\n        derivativeCount=degree_Max,\r\n        side=crvEvalSide_B)\r\n\r\n    if vsDerivs_B[1].IsTiny():\r\n        ncA_WIP.Dispose()\r\n        ncB_WIP.Dispose()\r\n        return\r\n\r\n    ncA_WIP.Dispose()\r\n    ncB_WIP.Dispose()\r\n\r\n    length_tol = (2**(-52))**0.5 # Rhino.RhinoMath.ZeroTolerance**0.5\r\n\r\n    for i in range(len(vsDerivs_A)):\r\n        vA = vsDerivs_A[i]\r\n        vB = vsDerivs_B[i]\r\n\r\n        if vA.IsTiny() and vB.IsTiny():\r\n            if i == degree_Max:\r\n                return float('inf')\r\n            continue\r\n        elif vA.IsTiny() or vB.IsTiny():\r\n            return i - 1\r\n\r\n        vDelta = vA - vB\r\n        # Don't use Vector3d.IsTiny since its epsilon is too small for this check.\r\n\r\n        length = vDelta.Length\r\n\r\n        if length > length_tol:\r\n            return i - 1\r\n\r\n    #    if not vDelta.IsTiny():\r\n    #        return i - 1\r\n\r\n    return float('inf')\r\n\r\n\r\ndef processCurves(rgCrv0_A, rgCrv0_B, bEvalT1End_A, bEvalT1End_B, fDistTol, fAngleTol_Vector_Deg, bAlignCrvDirs=True, bDebug=False):\r\n    \"\"\"\r\n    Returns tuple of string, string: (strShortContinuityDescription, strLongContinuityDescription)\r\n    \"\"\"\r\n\r\n    nc_A = rgCrv0_A.ToNurbsCurve()\r\n    nc_B = rgCrv0_B.ToNurbsCurve()\r\n\r\n    degA = nc_A.Degree\r\n    degB = nc_B.Degree\r\n\r\n    if bAlignCrvDirs and bEvalT1End_A == bEvalT1End_B:\r\n        if nc_B.Reverse():\r\n            bEvalT1End_B = not bEvalT1End_B\r\n            if bDebug:\r\n                print(\"Curve B direction was reversed to match Curve A.\")\r\n\r\n    if bEvalT1End_A:\r\n        idxSpan_A = nc_A.SpanCount - 1\r\n        domainSpan_A = nc_A.SpanDomain(idxSpan_A)\r\n        nc_SingleSpan_A = nc_A.Trim(domainSpan_A)\r\n        t_A = nc_SingleSpan_A.Domain.T1\r\n        crvEvalSide_A = rg.CurveEvaluationSide.Below\r\n        idxCp_Pos_A = nc_SingleSpan_A.Points.Count - 1\r\n        idxCp_Tan_A = nc_SingleSpan_A.Points.Count - 2\r\n        idxCp_Crv_A = nc_SingleSpan_A.Points.Count - 3\r\n    else:\r\n        idxSpan_A = 0\r\n        domainSpan_A = nc_A.SpanDomain(idxSpan_A)\r\n        nc_SingleSpan_A = nc_A.Trim(domainSpan_A)\r\n        t_A = nc_SingleSpan_A.Domain.T0\r\n        crvEvalSide_A = rg.CurveEvaluationSide.Above\r\n        idxCp_Pos_A = 0\r\n        idxCp_Tan_A = 1\r\n        idxCp_Crv_A = 2\r\n\r\n    if bEvalT1End_B:\r\n        # Point is closer to end of curve.\r\n        bEvalT1End_B = True\r\n        idxSpan_B = nc_B.SpanCount - 1\r\n        domainSpan_B = nc_B.SpanDomain(idxSpan_B)\r\n        nc_SingleSpan_B = nc_B.Trim(domainSpan_B)\r\n        t_B = nc_SingleSpan_B.Domain.T1\r\n        crvEvalSide_B = rg.CurveEvaluationSide.Below\r\n        idxCp_Pos_B = nc_SingleSpan_B.Points.Count - 1\r\n        idxCp_Tan_B = nc_SingleSpan_B.Points.Count - 2\r\n        idxCp_Crv_B = nc_SingleSpan_B.Points.Count - 3\r\n    else:\r\n        idxSpan_B = 0\r\n        domainSpan_B = nc_B.SpanDomain(idxSpan_B)\r\n        nc_SingleSpan_B = nc_B.Trim(domainSpan_B)\r\n        t_B = nc_SingleSpan_B.Domain.T0\r\n        crvEvalSide_B = rg.CurveEvaluationSide.Above\r\n        idxCp_Pos_B = 0\r\n        idxCp_Tan_B = 1\r\n        idxCp_Crv_B = 2\r\n\r\n    # All data required for continuity evaluation have been obtained from the NurbsCurves.\r\n    nc_A.Dispose()\r\n    nc_B.Dispose()\r\n\r\n\r\n    vsDerivs_A = nc_SingleSpan_A.DerivativeAt(\r\n        t_A,\r\n        derivativeCount=max(3, degA, degB),\r\n        side=crvEvalSide_A)\r\n\r\n    if vsDerivs_A[1].IsTiny():\r\n        s  = \"Cannot evaluated curve.\"\r\n        s += \"  Check for stacked control points at end of A.\"\r\n        return None, None, s\r\n\r\n\r\n    vsDerivs_B = nc_SingleSpan_B.DerivativeAt(\r\n        t_B,\r\n        derivativeCount=max(3, degA, degB),\r\n        side=crvEvalSide_B)\r\n\r\n    if vsDerivs_B[1].IsTiny():\r\n        s  = \"Cannot evaluated curve.\"\r\n        s += \"  Check for stacked control points at end of B.\"\r\n        return None, None, s\r\n\r\n\r\n    fZeroDistTol = 1e-9\r\n\r\n\r\n    if bDebug:\r\n        sEval='fZeroDistTol'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        for i in range(max(degA, degB)+1):\r\n            print('-'*40)\r\n            sEval='vsDerivs_A[{}]'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_B[{}]'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_A[{}].Length'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_B[{}].Length'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_A[{0}] / vsDerivs_A[{0}].Length'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_B[{0}] / vsDerivs_B[{0}].Length'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vsDerivs_A[{0}] - vsDerivs_B[{0}]'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='(vsDerivs_A[{0}] - vsDerivs_B[{0}]).Length'.format(i); print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    # 1st derivative.\r\n\r\n    vectTanB_toCompareWithA = vsDerivs_B[1]\r\n    if bAlignCrvDirs and bEvalT1End_A == bEvalT1End_B:\r\n        # Flip direction of B because curve directions do not match.\r\n        bReversedTanForA = vectTanB_toCompareWithA.Reverse()\r\n\r\n    fAngle_BetweenDerivs_1st_Deg = Rhino.RhinoMath.ToDegrees(\r\n        rg.Vector3d.VectorAngle(vsDerivs_A[1], vectTanB_toCompareWithA))\r\n\r\n    fLengthDiff_d1 = abs(vsDerivs_A[1].Length - vsDerivs_B[1].Length)\r\n\r\n\r\n    # 2nd derivative.\r\n\r\n    # Curve direction doesn't affect 2nd derivatives.\r\n    pass\r\n\r\n    fAngle_BetweenDerivs_2nd_Deg = rg.Vector3d.VectorAngle(\r\n            vsDerivs_A[2], vsDerivs_B[2])\r\n\r\n    if vsDerivs_A[2].IsTiny() or vsDerivs_B[2].IsTiny():\r\n        fLengthDiff_d2 = None\r\n        fLengthRatioDiff_d2 = None\r\n    else:\r\n        \r\n        # Use the following to normalize parameters.  Any practical purpose?\r\n        #multiWith_B_d2 = (rgCrv_SingleSpan_B.Domain.Length**2 /\r\n        #                  rgCrv_SingleSpan_A.Domain.Length**2)\r\n        #sEval='multiWith_B_d2'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        #fLengthDiff_d2 = abs(vsDerivs_A[2].Length -\r\n        #                     vsDerivs_B[2].Length * multiWith_B_d2)\r\n        \r\n        \r\n        fLengthDiff_d2 = abs(vsDerivs_A[2].Length - vsDerivs_B[2].Length)\r\n\r\n\r\n    # 3rd derivative.\r\n\r\n    fAngle_BetweenDerivs_3rd_Deg = rg.Vector3d.VectorAngle(\r\n            vsDerivs_A[3], vsDerivs_B[3])\r\n\r\n    if vsDerivs_A[3].IsTiny() or vsDerivs_B[3].IsTiny():\r\n        fLengthDiff_d3 = None\r\n        fLengthRatioDiff_d3 = None\r\n    else:\r\n        fLengthDiff_d3 = abs(vsDerivs_A[3].Length - vsDerivs_B[3].Length)\r\n\r\n\r\n    # Not using TangentAt and CurvatureAt since they do not take evaluation side\r\n    # into consideration.\r\n\r\n\r\n    (\r\n        vPt_A,\r\n        vUnitTan_A,\r\n        vCurvature_A,\r\n        vTorsion_A\r\n        ) = continuityVectorsAt(\r\n            nc_SingleSpan_A,\r\n            t_A,\r\n            crvEvalSide_A)\r\n\r\n    #sEval='vUnitTan_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sc.doc.Objects.AddLine(rg.Line(start=rg.Point3d(vsDerivs_A[0]), span=vUnitTan_A))\r\n\r\n    #sEval='vCurvature_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sc.doc.Objects.AddLine(rg.Line(start=rg.Point3d(vG0_A), span=vCurvature_A))\r\n\r\n    (\r\n        vPt_B,\r\n        vUnitTan_B,\r\n        vCurvature_B,\r\n        vTorsion_B\r\n        ) = continuityVectorsAt(\r\n            nc_SingleSpan_B,\r\n            t_B,\r\n            crvEvalSide_B)\r\n\r\n\r\n    if bDebug:\r\n        print('-'*40)\r\n        sEval='vPt_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vPt_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        print('-'*40)\r\n        sEval='vUnitTan_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vUnitTan_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        print('-'*40)\r\n        sEval='vCurvature_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vCurvature_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vCurvature_A.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vCurvature_B.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if vCurvature_A.Length > 0.0:\r\n            sEval='1.0/vCurvature_A.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if vCurvature_B.Length > 0.0:\r\n            sEval='1.0/vCurvature_B.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        print('-'*40)\r\n        sEval='vTorsion_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vTorsion_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vTorsion_A.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='vTorsion_B.Length'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    #sc.doc.Objects.AddLine(rg.Line(start=rg.Point3d(vG0_B), span=vCurvature_B))\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n    fAngle_BetweenTans_Deg = Rhino.RhinoMath.ToDegrees(\r\n        rg.Vector3d.VectorAngle(vUnitTan_A, vUnitTan_B))\r\n\r\n    fCurvature_A = vCurvature_A.Length\r\n    fCurvature_B = vCurvature_B.Length\r\n    fAngle_BetweenCurvatures_Deg = Rhino.RhinoMath.ToDegrees(\r\n        rg.Vector3d.VectorAngle(vCurvature_A, vCurvature_B))\r\n\r\n    fAngle_BetweenTorsions_Deg = Rhino.RhinoMath.ToDegrees(\r\n        rg.Vector3d.VectorAngle(vTorsion_A, vTorsion_B))\r\n\r\n    if bDebug:\r\n        print('-'*40)\r\n        sEval='fAngle_BetweenTans_Deg'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='fAngle_BetweenDerivs_1st_Deg'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='fAngle_BetweenDerivs_2nd_Deg'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='fCurvature_A'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='fCurvature_B'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if fCurvature_A > 0.0 and fCurvature_B > 0.0:\r\n            sEval='abs(fCurvature_A-fCurvature_B)/max(fCurvature_A, fCurvature_B)'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval='fAngle_BetweenCurvatures_Deg'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        #return\r\n    \r\n    ptEval_A = rg.Point3d(vsDerivs_A[0])\r\n    ptEval_B = rg.Point3d(vsDerivs_B[0])\r\n    fDist_BetweenEvalEndPts = ptEval_A.DistanceTo(ptEval_B)\r\n\r\n\r\n    def getContinuityG():\r\n        \"\"\"\r\n        Checks up through G3.\r\n        Returns: int(G continuity) or None or not G0\r\n        \"\"\"\r\n\r\n        if fDist_BetweenEvalEndPts > fDistTol:\r\n            # Not G0.\r\n            return\r\n\r\n        if vUnitTan_A.Length == 0.0 or vUnitTan_A.Length == 0.0:\r\n            # Stacked-control points?\r\n            return\r\n\r\n        if fAngle_BetweenTans_Deg > fAngleTol_Vector_Deg:\r\n            # Not G1.\r\n            return 0\r\n\r\n        #        iIsParallelTo_Tan = vUnitTan_A.IsParallelTo(\r\n        #            vUnitTan_B, fAngleTol_Vector_Deg)\r\n        #\r\n        #        if not iIsParallelTo_Tan:\r\n        #            return 0\r\n\r\n        #        # When both sides are linear, continuity is G1.\r\n        #        if vCurvature_A.IsTiny():\r\n        #            if vCurvature_B.IsTiny():\r\n        #                return 1\r\n\r\n\r\n        #if vCurvature_A.Length == 0.0 or vCurvature_B.Length == 0.0:\r\n        #    return 1\r\n        if vCurvature_A.IsTiny() and vCurvature_B.IsTiny():\r\n            # Colinear.\r\n            return 3\r\n\r\n        if vCurvature_A.IsTiny() or vCurvature_B.IsTiny():\r\n            # Not G2.\r\n            return 1\r\n\r\n\r\n        fDelta_Radii = abs(1.0/vCurvature_A.Length - 1.0/vCurvature_B.Length)\r\n        if fDelta_Radii > fDistTol:\r\n            # Not G2.\r\n            return 1\r\n\r\n        if fAngle_BetweenCurvatures_Deg > fAngleTol_Vector_Deg:\r\n            # Not G2.\r\n            return 1\r\n\r\n\r\n        if vTorsion_A.IsTiny() and vTorsion_B.IsTiny():\r\n            # Co-?.\r\n            return 3\r\n        \r\n        if vTorsion_A.IsTiny() or vTorsion_B.IsTiny():\r\n            # Not G3.\r\n            return 2\r\n\r\n        vDelta = vTorsion_A - vTorsion_B\r\n\r\n        if not vDelta.IsTiny():\r\n            # Not G3.\r\n            return 2\r\n\r\n        # This routine does not test for continuities above G3.\r\n        return 3\r\n\r\n\r\n    iCont_G_MaxFound = getContinuityG()\r\n\r\n    iCont_C_MaxFound = getContinuity_C(\r\n        nc_SingleSpan_A,\r\n        t_A,\r\n        crvEvalSide_A,\r\n        nc_SingleSpan_B,\r\n        t_B,\r\n        crvEvalSide_B,\r\n        )\r\n\r\n    nc_SingleSpan_A.Dispose()\r\n    nc_SingleSpan_B.Dispose()\r\n\r\n    if iCont_G_MaxFound == 3 and iCont_C_MaxFound > iCont_G_MaxFound:\r\n        iCont_G_MaxFound = iCont_C_MaxFound\r\n\r\n    sModelUnitSystem = sc.doc.ModelUnitSystem.ToString().lower()\r\n    \r\n    # This is the output format more similar to _GCon.\r\n    #s = \"Curve end difference = {:.{}f} {}\".format(\r\n    #        fDist_BetweenEvalEndPts,\r\n    #        sc.doc.ModelDistanceDisplayPrecision,\r\n    #        sModelUnitSystem)\r\n    #s += \"\\nRadius of curvature difference = {:.{}f} {}\".format(\r\n    #        abs(1.0/fCurvature_A - 1.0/fCurvature_B),\r\n    #        sc.doc.ModelDistanceDisplayPrecision,\r\n    #        sModelUnitSystem)\r\n    #s += \"\\nCurvature direction difference in degrees = {:.{}f}\".format(\r\n    #        fAngle_BetweenCurvatures_Deg,\r\n    #        sc.doc.ModelDistanceDisplayPrecision)\r\n    #s += \"\\nTangent difference in degrees = {:.{}f}\".format(\r\n    #        fAngle_BetweenDerivs_1st_Deg,\r\n    #        sc.doc.ModelDistanceDisplayPrecision)\r\n    #if iCont_G_MaxFound:\r\n    #    s += \"\\nCurves are G{}.\".format(iCont_G_MaxFound)\r\n    #else:\r\n    #    s += \"\\nCurve ends are out of tolerance.\"\r\n    #print(s\r\n\r\n\r\n\r\n    # My take.\r\n    s  = \"Torsion difference: \"\r\n\r\n    if (\r\n        vTorsion_A.Length <= fZeroDistTol and\r\n        vTorsion_B.Length <= fZeroDistTol\r\n    ):\r\n        s += \"(Both curves have no change in curvature at evaluated ends.)\"\r\n    elif (\r\n        vTorsion_A.Length <= fZeroDistTol or\r\n        vTorsion_B.Length <= fZeroDistTol\r\n    ):\r\n        s += \"(One curve has no change in curvature at evaluated end.)\"\r\n    else:\r\n        s += \"{:.{}f} degrees\".format(\r\n                fAngle_BetweenTorsions_Deg,\r\n                sc.doc.ModelDistanceDisplayPrecision)\r\n        s += \", {:.{}f} magnitude\".format(\r\n                abs(vTorsion_A.Length - vTorsion_B.Length),\r\n                sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n        s += \"\\n  3rd derivative vector differences:\"\r\n    \r\n        s += \" {:.{}f} degrees\".format(\r\n                fAngle_BetweenDerivs_3rd_Deg,\r\n                sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n    if fLengthDiff_d3:\r\n        s += \", {} magnitude\".format(\r\n            formatDistance(fLengthDiff_d3))\r\n\r\n\r\n    s += \"\\nCurvature difference: \"\r\n\r\n    if (\r\n        fCurvature_A <= fZeroDistTol and\r\n        fCurvature_B <= fZeroDistTol\r\n    ):\r\n        s += \"(Both curves are linear at evaluated ends.)\"\r\n    elif (\r\n        fCurvature_A <= fZeroDistTol or\r\n        fCurvature_B <= fZeroDistTol\r\n    ):\r\n        s += \"(One curve is linear at evaluated end.)\"\r\n    else:\r\n        s += \"{:.{}f} degrees\".format(\r\n                fAngle_BetweenCurvatures_Deg,\r\n                sc.doc.ModelDistanceDisplayPrecision)\r\n        s += \", R{:.{}f} {}\".format(\r\n                abs(1.0/fCurvature_A - 1.0/fCurvature_B),\r\n                sc.doc.ModelDistanceDisplayPrecision,\r\n                sModelUnitSystem)\r\n        s += \"\\n  2nd derivative vector differences:\"\r\n    \r\n        s += \" {:.{}f} degrees\".format(\r\n                fAngle_BetweenDerivs_2nd_Deg,\r\n                sc.doc.ModelDistanceDisplayPrecision)\r\n    \r\n    if fLengthDiff_d2:\r\n        s += \", {} magnitude\".format(\r\n            formatDistance(fLengthDiff_d2))\r\n\r\n\r\n    s += \"\\nTangent difference: {:.{}f} degrees\".format(\r\n            fAngle_BetweenDerivs_1st_Deg,\r\n            sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n    s += \"\\n  1st derivative vector differences:\"\r\n\r\n    s += \" {:.{}f} degrees\".format(\r\n            fAngle_BetweenDerivs_1st_Deg,\r\n            sc.doc.ModelDistanceDisplayPrecision)\r\n    s += \", {} magnitude\".format(\r\n        formatDistance(fLengthDiff_d1))\r\n\r\n    s += \"\\nCurve end difference = {:.{}f} {}\".format(\r\n            fDist_BetweenEvalEndPts,\r\n            sc.doc.ModelDistanceDisplayPrecision,\r\n            sModelUnitSystem)\r\n\r\n    if iCont_G_MaxFound is not None:\r\n        s += \"\\nContinuities at curves' ends are G{} and C{}.\".format(\r\n            iCont_G_MaxFound, iCont_C_MaxFound)\r\n    else:\r\n        s += \"\\nNo continuity between the curves.\"\r\n\r\n    return (\r\n            iCont_G_MaxFound,\r\n            iCont_C_MaxFound,\r\n            s,\r\n    )\r\n\r\n\r\ndef processCurveObjects(objrefs, fDistTol, fAngleTol_Vector_Deg, bAlignCrvDirs, bAddDot, bEcho, bDebug):\r\n    \"\"\"\r\n    \"\"\"\r\n    rgCrv0_A = objrefs[0].Curve()\r\n\r\n    bSuccess, tA = rgCrv0_A.ClosestPoint(objrefs[0].SelectionPoint())\r\n    if not bSuccess:\r\n        rgCrv0_A.Dispose()\r\n        return\r\n    \r\n    rgCrv0_B = objrefs[1].Curve()\r\n    if isinstance(rgCrv0_B, rg.NurbsCurve):\r\n        rgNurbsCrv_B = rgCrv0_B.Duplicate()\r\n    else:\r\n        rgNurbsCrv_B = rgCrv0_B.ToNurbsCurve()\r\n\r\n    bSuccess, tB = rgCrv0_B.ClosestPoint(objrefs[1].SelectionPoint())\r\n    if not bSuccess:\r\n        rgCrv0_B.Dispose()\r\n        return\r\n    \r\n    bEvalT1End_A = tA >= rgCrv0_A.Domain.Mid\r\n    bEvalT1End_B = tB >= rgCrv0_B.Domain.Mid\r\n\r\n    rc = processCurves(\r\n            rgCrv0_A,\r\n            rgCrv0_B,\r\n            bEvalT1End_A,\r\n            bEvalT1End_B,\r\n            fDistTol,\r\n            fAngleTol_Vector_Deg,\r\n            bAlignCrvDirs,\r\n            bDebug,\r\n    )\r\n    if rc is None:\r\n        rgCrv0_A.Dispose()\r\n        rgCrv0_B.Dispose()\r\n        return\r\n\r\n    (\r\n        iCont_G_MaxFound,\r\n        iCont_C_MaxFound,\r\n        sContinuityDescr,\r\n    ) = rc\r\n\r\n    print(sContinuityDescr)\r\n\r\n    if bAddDot and iCont_G_MaxFound:\r\n        rgDot = rg.TextDot(\r\n                text=\"G{}/C{}\".format(iCont_G_MaxFound, iCont_C_MaxFound),\r\n                location=rgCrv0_A.PointAt(t_A))\r\n        rgDot.FontHeight = 11\r\n        sc.doc.Objects.AddTextDot(rgDot)\r\n        sc.doc.Views.Redraw()\r\n\r\n    rgCrv0_A.Dispose()\r\n    rgCrv0_B.Dispose()\r\n\r\n    if iCont_G_MaxFound:\r\n        return iCont_G_MaxFound, iCont_C_MaxFound\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fDistTol = Opts.values['fDistTol']\r\n    fAngleTol_Vector_Deg = Opts.values['fAngleTol_Vector_Deg']\r\n    bAlignCrvDirs = Opts.values['bAlignCrvDirs']\r\n    bAddDot = Opts.values['bAddDot']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    processCurveObjects(\r\n        objrefs,\r\n        Opts.values['fDistTol'],\r\n        Opts.values['fAngleTol_Vector_Deg'],\r\n        Opts.values['bAlignCrvDirs'],\r\n        Opts.values['bAddDot'],\r\n        Opts.values['bEcho'],\r\n        Opts.values['bDebug'],\r\n        )\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}