{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_mep_penetration_generator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_mep_penetration_generator.py",
  "instruction": "MEP Penetration Generator for Grasshopper.",
  "code": "# File: scripts/gh_mep_penetration_generator.py\n\"\"\"MEP Penetration Generator for Grasshopper.\n\nConverts MEP routes to penetration specifications with code compliance validation.\nThis component bridges the OAHS routing output to existing penetration rules,\nproducing validated penetration specs with code compliance and reinforcement flags.\n\nKey Features:\n1. Route-to-Penetration Conversion\n   - Parses routes_json from MEP Router\n   - Intersects routes with framing elements\n   - Generates penetration specifications\n\n2. Code Compliance Validation\n   - Checks penetration size vs member depth\n   - Flags blocked penetrations exceeding limits\n   - Identifies penetrations requiring reinforcement\n\n3. Visual Status Feedback\n   - Allowed penetrations (green points)\n   - Blocked penetrations (red points)\n   - Reinforcement required (orange points)\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry creation (via RhinoCommonFactory)\n    - Grasshopper: DataTree and component framework\n    - json: Parsing route and framing data\n    - timber_framing_generator: RhinoCommonFactory for assembly-safe geometry\n    - penetration_integration: Route-to-penetration logic with code compliance\n\nPerformance Considerations:\n    - Linear scaling with number of routes and framing elements\n    - Geometry creation via factory adds minimal overhead\n    - For >100 routes, ensure framing_json is well-structured\n\nUsage:\n    1. Connect routes_json from MEP Router component\n    2. Connect framing_json from Framing Generator component\n    3. Optionally adjust clearance (default 0.0208 ft = 1/4\")\n    4. Set run=True to execute penetration analysis\n    5. Connect point outputs to Preview with appropriate colors\n\nInput Requirements:\n    Routes JSON (routes_json) - str:\n        JSON string containing computed routes from OAHS router.\n        Must have \"routes\" array with route objects containing\n        \"segments\" (with start/end coords) and system_type.\n        Required: Yes\n        Access: Item\n\n    Framing JSON (framing_json) - str:\n        JSON string containing framing elements from Framing Generator.\n        Elements need centerlines and profile information for\n        penetration validation.\n        Required: Yes\n        Access: Item\n\n    Clearance (clearance) - float:\n        Pipe clearance in feet added around penetrations.\n        Required: No (defaults to 0.0208 = 1/4\")\n        Access: Item\n\n    Run (run) - bool:\n        Trigger to execute penetration analysis. Set True to process.\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Penetrations JSON (penetrations_json) - str:\n        Full penetration specifications as JSON string with\n        location, size, is_allowed, reinforcement_required flags.\n\n    Allowed Points (allowed_pts) - List[Point3d]:\n        Point3d for allowed penetrations (display green).\n        No code violations.\n\n    Blocked Points (blocked_pts) - List[Point3d]:\n        Point3d for blocked penetrations (display red).\n        Exceed code limits - require rerouting.\n\n    Reinforce Points (reinforce_pts) - List[Point3d]:\n        Point3d needing reinforcement (display orange).\n        Allowed but require structural reinforcement.\n\n    Info (info) - str:\n        Diagnostic summary string with processing statistics.\n\nTechnical Details:\n    - Uses RhinoCommonFactory for all geometry creation\n    - Code limits based on IRC/building code penetration rules\n    - Penetration ratio checked against member depth\n    - JSON output compatible with downstream components\n\nError Handling:\n    - Invalid JSON logs warning and returns empty outputs\n    - Missing fields in route/framing data are skipped with warning\n    - Geometry creation failures logged but don't halt processing\n    - run=False returns immediately with \"Disabled\" info message\n\nAuthor: Fernando Maytorena\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\nfrom System import Array\nfrom System.Collections.Generic import List\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"MEP Penetration Generator\"\nCOMPONENT_NICKNAME = \"MEP-Pen\"\nCOMPONENT_MESSAGE = \"v1.0.0\"\nCOMPONENT_CATEGORY = \"TimberFraming\"\nCOMPONENT_SUBCATEGORY = \"MEP\"\n\nDEFAULT_CLEARANCE = 0.0208  # 1/4\" in feet\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    # Always print to console (captured by 'out' parameter and log files)\n    print(f\"[{level.upper()}] {message}\")\n\n    # Add to GH component UI for warnings and errors\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    This function handles:\n    1. Setting component metadata (name, category, etc.)\n    2. Configuring input parameter names, descriptions, and access\n    3. Configuring output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: In GHPython, the NickName becomes the Python variable name!\n    # Format: (DisplayName, variable_name, Description, Access)\n    # - Name: Human-readable display name (shown in tooltips)\n    # - NickName: MUST be valid Python identifier - this IS the variable name in code\n    # - Access: item, list, or tree\n    #\n    # NOTE: Type Hints must be set via GH UI (right-click -> Type hint)\n    # They cannot be set programmatically from within the script.\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        # (DisplayName, variable_name, Description, Access)\n        (\"Routes JSON\", \"routes_json\", \"JSON string with computed routes from OAHS router\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Framing JSON\", \"framing_json\", \"JSON string with framing elements from Framing Generator\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Clearance\", \"clearance\", \"Pipe clearance in feet (default 0.0208 = 1/4\\\")\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    # IMPORTANT: NickName becomes the Python variable name - must match code!\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        # (DisplayName, variable_name, Description) - indices start at 1\n        (\"Penetrations JSON\", \"penetrations_json\", \"Full penetration specs as JSON string\"),\n        (\"Allowed Points\", \"allowed_pts\", \"Point3d for allowed penetrations (green)\"),\n        (\"Blocked Points\", \"blocked_pts\", \"Point3d for blocked penetrations (red)\"),\n        (\"Reinforce Points\", \"reinforce_pts\", \"Point3d needing reinforcement (orange)\"),\n        (\"Info\", \"info\", \"Diagnostic summary string\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef get_factory():\n    \"\"\"Get RhinoCommonFactory instance for geometry creation.\n\n    Returns:\n        RhinoCommonFactory instance\n\n    Raises:\n        ImportError: If timber_framing_generator is not installed\n    \"\"\"\n    from src.timber_framing_generator.utils.geometry_factory import get_factory as _get_factory\n    return _get_factory()\n\n\ndef validate_inputs(routes_json_input, framing_json_input, run_input):\n    \"\"\"Validate component inputs.\n\n    Args:\n        routes_json_input: Routes JSON string to validate\n        framing_json_input: Framing JSON string to validate\n        run_input: Run boolean input\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run_input:\n        return False, \"Set run=True to execute penetration analysis\"\n\n    if not routes_json_input:\n        return False, \"Missing routes_json input\"\n\n    if not framing_json_input:\n        return False, \"Missing framing_json input\"\n\n    # Validate routes JSON parsing\n    try:\n        data = json.loads(routes_json_input)\n        if not isinstance(data, dict):\n            return False, \"routes_json must be a JSON object\"\n        if \"routes\" not in data:\n            return False, \"routes_json missing 'routes' key\"\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid routes_json: {e}\"\n\n    # Validate framing JSON parsing\n    try:\n        framing_data = json.loads(framing_json_input)\n        # Framing JSON can be a list or dict - just check it parses\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid framing_json: {e}\"\n\n    return True, None\n\n\ndef create_status_points(penetrations, factory):\n    \"\"\"Create Point3d geometry grouped by penetration status.\n\n    Args:\n        penetrations: List of penetration specification dictionaries\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        tuple: (allowed_points, blocked_points, reinforcement_points)\n    \"\"\"\n    from src.timber_framing_generator.mep.routing.penetration_integration import (\n        extract_penetration_points,\n    )\n\n    # Get coordinate tuples grouped by status\n    allowed_coords, blocked_coords, reinforce_coords = extract_penetration_points(penetrations)\n\n    # Convert to Point3d using factory\n    allowed_pts = []\n    for coord in allowed_coords:\n        try:\n            pt = factory.create_point3d(\n                float(coord[0]),\n                float(coord[1]),\n                float(coord[2])\n            )\n            if pt is not None:\n                allowed_pts.append(pt)\n        except Exception as e:\n            log_debug(f\"Error creating allowed point: {e}\")\n\n    blocked_pts = []\n    for coord in blocked_coords:\n        try:\n            pt = factory.create_point3d(\n                float(coord[0]),\n                float(coord[1]),\n                float(coord[2])\n            )\n            if pt is not None:\n                blocked_pts.append(pt)\n        except Exception as e:\n            log_debug(f\"Error creating blocked point: {e}\")\n\n    reinforce_pts = []\n    for coord in reinforce_coords:\n        try:\n            pt = factory.create_point3d(\n                float(coord[0]),\n                float(coord[1]),\n                float(coord[2])\n            )\n            if pt is not None:\n                reinforce_pts.append(pt)\n        except Exception as e:\n            log_debug(f\"Error creating reinforcement point: {e}\")\n\n    return allowed_pts, blocked_pts, reinforce_pts\n\n\ndef process_penetrations(routes_json_str, framing_json_str, clearance_value):\n    \"\"\"Process route data and generate penetration specifications.\n\n    Args:\n        routes_json_str: JSON string with routes data\n        framing_json_str: JSON string with framing data\n        clearance_value: Pipe clearance in feet\n\n    Returns:\n        tuple: (penetrations_json, allowed_pts, blocked_pts, reinforce_pts, info_string)\n    \"\"\"\n    log_info(\"Starting penetration analysis\")\n\n    # Import penetration integration functions\n    try:\n        from src.timber_framing_generator.mep.routing.penetration_integration import (\n            integrate_routes_to_penetrations,\n            penetrations_to_json,\n            get_penetration_info_string,\n        )\n    except ImportError as e:\n        log_error(f\"Could not import penetration_integration: {e}\")\n        return \"\", [], [], [], f\"Import error: {e}\"\n\n    # Get geometry factory\n    try:\n        factory = get_factory()\n    except ImportError as e:\n        log_error(f\"Could not import geometry factory: {e}\")\n        return \"\", [], [], [], f\"Import error: {e}\"\n\n    # Run penetration integration\n    try:\n        result = integrate_routes_to_penetrations(\n            routes_json=routes_json_str,\n            framing_json=framing_json_str,\n            clearance=clearance_value,\n        )\n    except ValueError as e:\n        log_error(f\"Penetration analysis failed: {e}\")\n        return \"\", [], [], [], f\"Analysis error: {e}\"\n    except Exception as e:\n        log_error(f\"Unexpected error in penetration analysis: {e}\")\n        log_debug(traceback.format_exc())\n        return \"\", [], [], [], f\"Unexpected error: {e}\"\n\n    # Convert result to JSON\n    penetrations_json_out = penetrations_to_json(result)\n\n    # Get info string\n    info_string = get_penetration_info_string(result)\n\n    # Extract penetrations for point creation\n    penetrations = result.get(\"penetrations\", [])\n\n    # Create status-grouped points\n    allowed_pts, blocked_pts, reinforce_pts = create_status_points(penetrations, factory)\n\n    log_info(f\"Penetration analysis complete: {len(allowed_pts)} allowed, {len(blocked_pts)} blocked, {len(reinforce_pts)} need reinforcement\")\n\n    return penetrations_json_out, allowed_pts, blocked_pts, reinforce_pts, info_string\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Coordinates the overall workflow:\n    1. Setup component metadata\n    2. Validate inputs\n    3. Process penetration analysis\n    4. Return results\n\n    Returns:\n        tuple: (penetrations_json, allowed_pts, blocked_pts, reinforce_pts, info)\n               or empty outputs on failure\n    \"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize empty outputs\n    empty_json = \"\"\n    empty_pts = []\n\n    try:\n        # Get inputs (these come from GH component inputs)\n        # Use globals() to check if variables are defined\n        routes_json_input = routes_json if 'routes_json' in dir() else None\n        framing_json_input = framing_json if 'framing_json' in dir() else None\n        clearance_input = clearance if 'clearance' in dir() else None\n        run_input = run if 'run' in dir() else False\n\n        # Handle None/unset clearance with default\n        if clearance_input is None:\n            clearance_input = DEFAULT_CLEARANCE\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(routes_json_input, framing_json_input, run_input)\n        if not is_valid:\n            if error_msg and \"run=True\" not in error_msg:\n                log_warning(error_msg)\n            return empty_json, empty_pts, empty_pts, empty_pts, error_msg or \"Disabled\"\n\n        # Process penetrations\n        penetrations_json_out, allowed_pts, blocked_pts, reinforce_pts, info_string = process_penetrations(\n            routes_json_input,\n            framing_json_input,\n            clearance_input\n        )\n\n        return penetrations_json_out, allowed_pts, blocked_pts, reinforce_pts, info_string\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_debug(traceback.format_exc())\n        return empty_json, empty_pts, empty_pts, empty_pts, f\"Error: {str(e)}\"\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Execute main and assign to output variables\n    # These variable names must match your GH component outputs\n    penetrations_json, allowed_pts, blocked_pts, reinforce_pts, info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}