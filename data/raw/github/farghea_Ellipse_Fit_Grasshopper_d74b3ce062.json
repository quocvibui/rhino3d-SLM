{
  "source_url": "https://github.com/farghea/Ellipse_Fit_Grasshopper/blob/4c13ec87f743e37c9d789bc4265a2736138295b3/rhino_GH_files/Grasshopper_ellipse_fit_code.py",
  "repo": "farghea/Ellipse_Fit_Grasshopper",
  "repo_stars": 2,
  "repo_description": null,
  "license": "unknown",
  "filepath": "rhino_GH_files/Grasshopper_ellipse_fit_code.py",
  "instruction": "Grasshopper ellipse fit code",
  "code": "import copy \r\nimport math \r\nimport ghpythonlib.components as ghc\r\n\r\n\r\nclass MatrixOperations:\r\n    \"\"\"\r\n    A class for matrix operations: In grasshopper you can't install \r\n    numpy and other libraries easily, so I had to write this class \r\n    and half of the linear algebra for this!\r\n    \"\"\"\r\n\r\n    @staticmethod\r\n    def zeros(m, n):\r\n        \"\"\"\r\n        Generates a matrix of size m x n filled with zeros.\r\n        \"\"\"\r\n        return [[0.0] * n for _ in range(m)]\r\n\r\n    @staticmethod\r\n    def ones(m, n):\r\n        \"\"\"\r\n        Creates a matrix of size m x n filled with ones.\r\n        \"\"\"\r\n        return [[1.0] * n for _ in range(m)]\r\n\r\n    @staticmethod\r\n    def eye(m, n):\r\n        \"\"\"\r\n        Produces an m x n identity matrix (1's on the diagonal and 0's elsewhere).\r\n        \"\"\"\r\n        result = MatrixOperations.zeros(m, n)\r\n        min_index = min(m, n)\r\n        for i in range(min_index):\r\n            result[i][i] = 1.0\r\n        return result\r\n\r\n    @staticmethod\r\n    def size(matrix):\r\n        \"\"\"\r\n        Returns the size of the given matrix as a tuple (rows, columns).\r\n        \"\"\"\r\n        return len(matrix), len(matrix[0])\r\n\r\n    @staticmethod\r\n    def add(mat_a, mat_b):\r\n        \"\"\"\r\n        Adds two matrices mat_a and mat_b of the same size.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(mat_a)\r\n        result = MatrixOperations.zeros(m, n)\r\n        for i in range(m):\r\n            for j in range(n):\r\n                result[i][j] = mat_a[i][j] + mat_b[i][j]\r\n        return result\r\n\r\n    @staticmethod\r\n    def transpose(matrix):\r\n        \"\"\"\r\n        Transposes the given matrix (flips rows and columns).\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        return [[matrix[j][i] for j in range(m)] for i in range(n)]\r\n\r\n    @staticmethod\r\n    def multiply(mat_a, mat_b):\r\n        \"\"\"\r\n        Multiplies two matrices mat_a and mat_b.\r\n        \"\"\"\r\n        mA, nA = MatrixOperations.size(mat_a)\r\n        mB, nB = MatrixOperations.size(mat_b)\r\n        result = MatrixOperations.zeros(mA, nB)\r\n        for i in range(mA):\r\n            for j in range(nB):\r\n                for k in range(nA):\r\n                    result[i][j] += mat_a[i][k] * mat_b[k][j]\r\n        return result\r\n\r\n    @staticmethod\r\n    def scalar_multiply(matrix, num):\r\n        \"\"\"\r\n        Multiplies every element in matrix by num.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        result = MatrixOperations.ones(m, n)\r\n        for i in range(m):\r\n            for j in range(n):\r\n                result[i][j] *= matrix[i][j] * num\r\n        return result\r\n\r\n    @staticmethod\r\n    def sum(matrix):\r\n        \"\"\"\r\n        Sums up all elements in matrix, returning a matrix of sums for each row.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        result = MatrixOperations.zeros(m, 1)\r\n        for i in range(m):\r\n            for j in range(n):\r\n                result[i][0] += matrix[i][j]\r\n        return result\r\n\r\n    @staticmethod\r\n    def max(matrix):\r\n        \"\"\"\r\n        Finds the maximum value in matrix along with its position.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        max_value = matrix[0][0]\r\n        max_index = [0, 0]\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if matrix[i][j] > max_value:\r\n                    max_value = matrix[i][j]\r\n                    max_index = [i, j]\r\n        return max_value, max_index\r\n\r\n    @staticmethod\r\n    def abs(matrix):\r\n        \"\"\"\r\n        Applies the absolute value function to each element in matrix.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        result = MatrixOperations.zeros(m, n)\r\n        for i in range(m):\r\n            for j in range(n):\r\n                result[i][j] = abs(matrix[i][j])\r\n        return result\r\n\r\n    @staticmethod\r\n    def pinv(matrix):\r\n        \"\"\"\r\n        Computes the pseudo-inverse of matrix.\r\n        - I used an iterative method\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        A_i_1 = MatrixOperations.transpose(copy.deepcopy(matrix))\r\n        A_i_1 = MatrixOperations.scalar_multiply(A_i_1, 1e-10)\r\n        for _ in range(3000):\r\n            term1 = MatrixOperations.scalar_multiply(A_i_1, 2.0)\r\n            term2 = MatrixOperations.multiply(matrix, A_i_1)\r\n            term3 = MatrixOperations.multiply(A_i_1, term2)\r\n            term4 = MatrixOperations.scalar_multiply(term3, -1.0)\r\n            A_i = MatrixOperations.add(term1, term4)\r\n            A_i_1 = A_i\r\n\r\n            B = MatrixOperations.multiply(matrix, A_i)\r\n            my_eye = MatrixOperations.scalar_multiply(MatrixOperations.eye(m, m), -1.0)\r\n            B = MatrixOperations.add(B, my_eye)\r\n            B = MatrixOperations.abs(B)\r\n            max_val, _ = MatrixOperations.max(B)\r\n            if max_val < 1e-10:\r\n                break\r\n        return A_i\r\n\r\n    @staticmethod\r\n    def mean(matrix):\r\n        \"\"\"\r\n        Calculates the mean of each column in matrix.\r\n        \"\"\"\r\n        m, n = MatrixOperations.size(matrix)\r\n        my_mean = MatrixOperations.transpose(MatrixOperations.sum(MatrixOperations.transpose(matrix)))\r\n        return MatrixOperations.scalar_multiply(my_mean, 1 / m)\r\n\r\n    @staticmethod\r\n    def cross(a, b):\r\n        \"\"\"\r\n        Calculate the cross product of two 3D vectors.\r\n\r\n        Args:\r\n            a (list): The first vector, a 3-element list.\r\n            b (list): The second vector, a 3-element list.\r\n\r\n        Returns:\r\n            list: The cross product of vectors a and b.\r\n        \"\"\"\r\n        result = MatrixOperations.zeros(3, 1)\r\n        result[0][0] = a[1][0] * b[2][0] - a[2][0] * b[1][0]\r\n        result[1][0] = -(a[0][0] * b[2][0] - a[2][0] * b[0][0])\r\n        result[2][0] = a[0][0] * b[1][0] - a[1][0] * b[0][0]\r\n        return result\r\n    \r\n\r\n\r\n# - - - - - - - - - - - - \r\nclass EllipseFitter:\r\n    \"\"\"\r\n    A class for fitting an ellipse to a set of 3D points.\r\n    \"\"\"\r\n\r\n    def __init__(self, points):\r\n        \"\"\"\r\n        Initialize the EllipseFitter with a set of points.\r\n\r\n        Args:\r\n            points (list): A list of 3D points.\r\n        \"\"\"\r\n        self.points = points\r\n\r\n    def fit_ellipse(self):\r\n        \"\"\"\r\n        Fits an ellipse to the provided 3D points.\r\n\r\n        Returns:\r\n            dict: A dictionary containing ellipse parameters and fitted points.\r\n        \"\"\"\r\n        mo = MatrixOperations\r\n\r\n        # Compute pseudo-inverse of the poin`ts\r\n        pseudo_inv = mo.pinv(self.points)\r\n\r\n        # Compute coefficients of the plane\r\n        _, no_of_rows = mo.size(pseudo_inv)\r\n        coef_plane = mo.multiply(pseudo_inv, mo.ones(no_of_rows, 1))\r\n        center = mo.mean(self.points)\r\n\r\n        # Orthonormal coordinate system\r\n        e3 = coef_plane\r\n        norm_e3 = math.sqrt(mo.multiply(mo.transpose(e3), e3)[0][0])\r\n        e3 = mo.scalar_multiply(e3, 1 / norm_e3)\r\n\r\n        e1 = mo.zeros(3, 1)\r\n        for i in range(3):\r\n            e1[i][0] = self.points[0][i] - center[0][i]\r\n        norm_e1 = math.sqrt(mo.multiply(mo.transpose(e1), e1)[0][0])\r\n        e1 = mo.scalar_multiply(e1, 1 / norm_e1)\r\n\r\n        e2 = mo.cross(e3, e1)\r\n\r\n        # Transformation matrix\r\n        trans = mo.zeros(3, 3)\r\n        for i in range(3):\r\n            trans[i][0] = e1[i][0]\r\n            trans[i][1] = e2[i][0]\r\n            trans[i][2] = e3[i][0]\r\n\r\n        self._transformation_matrix = trans\r\n        # Projection in the new coordinate system\r\n        local_proj = mo.multiply(self.points, trans)\r\n        self.local_proj = local_proj\r\n\r\n        # Ellipse fitting\r\n        ellipse_params = self._fit_ellipse_to_projection(local_proj)\r\n\r\n        return ellipse_params\r\n\r\n    def _fit_ellipse_to_projection(self, proj):\r\n        \"\"\"\r\n        Fit an ellipse to the projected points.\r\n\r\n        Args:\r\n            proj (list): Projected points.\r\n\r\n        Returns:\r\n            dict: Parameters of the fitted ellipse.\r\n        \"\"\"\r\n        mo = MatrixOperations\r\n        m = len(proj)\r\n        x, y = self._extract_coordinates(proj, m)\r\n        mean_xyz = mo.mean(proj)\r\n        x, y = self._center_coordinates(x, y, mean_xyz)\r\n\r\n        my_data = self._form_ellipse_equation_data(x, y, m)\r\n        term1 = mo.transpose(mo.sum(mo.transpose(my_data)))\r\n        term2 = mo.multiply(mo.transpose(my_data), my_data)\r\n        term3 = mo.pinv(term2)\r\n\r\n        coef_ellipse = mo.multiply(term1, term3)\r\n        ellipse_params = self._compute_ellipse_parameters(coef_ellipse, mean_xyz, proj)\r\n\r\n        return ellipse_params\r\n    \r\n    def _extract_coordinates(self, proj, m):\r\n        \"\"\"Extracts x and y coordinates from the projected points.\"\"\"\r\n        x = MatrixOperations.zeros(m, 1)\r\n        y = MatrixOperations.zeros(m, 1)\r\n        for i in range(m):\r\n            x[i][0] = proj[i][0]\r\n            y[i][0] = proj[i][1]\r\n        return x, y\r\n\r\n    def _center_coordinates(self, x, y, mean_xyz):\r\n        \"\"\"Centers the x and y coordinates by subtracting their mean.\"\"\"\r\n        m = len(x)\r\n        mean_x = mean_xyz[0][0]\r\n        mean_y = mean_xyz[0][1]\r\n        for i in range(m):\r\n            x[i][0] -= mean_x\r\n            y[i][0] -= mean_y\r\n        return x, y\r\n\r\n    def _form_ellipse_equation_data(self, x, y, m):\r\n        \"\"\"Forms the data matrix for the ellipse equation.\"\"\"\r\n        my_data = MatrixOperations.zeros(m, 5)\r\n        for i in range(m):\r\n            my_data[i][0] = x[i][0] * x[i][0]\r\n            my_data[i][1] = x[i][0] * y[i][0]\r\n            my_data[i][2] = y[i][0] * y[i][0]\r\n            my_data[i][3] = x[i][0]\r\n            my_data[i][4] = y[i][0]\r\n        return my_data\r\n\r\n    def _compute_ellipse_parameters(self, coef_ellipse, mean_xyz, local_proj):\r\n        \"\"\"Computes the parameters of the ellipse from its coefficients.\"\"\"\r\n        # Extracting coefficients\r\n        a0, b0, c0, d0, e0 = coef_ellipse[0]\r\n        mean_x0 = mean_xyz[0][0]\r\n        mean_y0 = mean_xyz[0][1]\r\n\r\n        a = copy.deepcopy(a0)\r\n        b = copy.deepcopy(b0)\r\n        c = copy.deepcopy(c0)\r\n        d = copy.deepcopy(d0)\r\n        e = copy.deepcopy(e0)\r\n        \r\n        if min(abs(b/a), abs(b/c)) > 0.001:\r\n            orientation_rad = 0.5 * math.atan(b/(c-a))\r\n            cos_phi = math.cos( orientation_rad )\r\n            sin_phi = math.sin( orientation_rad )\r\n\r\n            a = a0*cos_phi**2 - b0*cos_phi*sin_phi + c0*sin_phi**2\r\n            b = 0\r\n            c = a0*sin_phi**2 + b0*cos_phi*sin_phi + c0*cos_phi**2\r\n            d = d0*cos_phi - e0*sin_phi\r\n            e = d0*sin_phi + e0*cos_phi\r\n\r\n            mean_x = cos_phi*mean_x0 - sin_phi*mean_y0\r\n            mean_y = sin_phi*mean_x0 + cos_phi*mean_y0\r\n        else:\r\n            orientation_rad = 0\r\n            cos_phi = math.cos( orientation_rad )\r\n            sin_phi = math.sin( orientation_rad )\r\n        \r\n        if (a < 0):\r\n            a = -a\r\n            c = -c\r\n            d = -d\r\n            e = -e\r\n\r\n        # Center in the ellipse coordiante system (within the local coordinate system)\r\n        X0 = mean_x - d/2/a\r\n        Y0 = mean_y - e/2/c\r\n        F = 1 + (d*d)/(4*a) + (e*e)/(4*c)\r\n        # Maximum dimeter\r\n        a = ( F/a )**0.5\r\n        # Minimum dimeter\r\n        b = ( F/c )**0.5\r\n        \r\n        long_axis   = 2*max(a,b)\r\n        short_axis  = 2*min(a,b)\r\n\r\n        Z0 = local_proj[0][2]\r\n\r\n        center0 = self._rotate_center_and_ellipse(orientation_rad, X0, Y0, Z0, a, b, 25)\r\n        \r\n        return {\r\n            \"center\": center0,\r\n            \"axes\": [long_axis, short_axis],\r\n            \"orientation\": orientation_rad\r\n        }\r\n    \r\n    def _rotate_center_and_ellipse(self, orientation_rad, X0, Y0, Z0, a, b, n = 25):\r\n        \"\"\"\r\n        Constructs ellipse points and rotates them back to the original coordinate system.\r\n\r\n        Args:\r\n            orientation_rad (float): orientation of ellipse in radian\r\n            X0, Y0 (float, float): center of ellipse\r\n\r\n        Returns:\r\n            list: center of ellipse in local coordinate \r\n        \"\"\"\r\n        mo = MatrixOperations\r\n        cos_phi = math.cos(orientation_rad)\r\n        sin_phi = math.sin(orientation_rad)\r\n\r\n        # Rotation matrix for the local coordinate axis\r\n        myrotation_matrix = mo.zeros(2, 2)\r\n        myrotation_matrix[0][0], myrotation_matrix[0][1] = cos_phi, sin_phi\r\n        myrotation_matrix[1][0], myrotation_matrix[1][1] = -sin_phi, cos_phi\r\n\r\n        # Center of the ellipse in the local coordinate system\r\n        temp = mo.zeros(2, 1)\r\n        temp[0][0] = X0\r\n        temp[1][0] = Y0\r\n        \r\n        p_in = mo.multiply(myrotation_matrix, temp)\r\n        \r\n        # Constructing ellipse \r\n        theta_degree_list = [360 * i / (n - 1) for i in range(n)]\r\n\r\n        ellipse0 = mo.zeros(n, 2)\r\n        for i, theta_deg in enumerate(theta_degree_list):\r\n            theta = theta_deg*math.pi/180\r\n            x = a*math.cos(theta)\r\n            y = b*math.sin(theta)\r\n            ellipse0[i][0] = x\r\n            ellipse0[i][1] = y\r\n\r\n        ellipse0 = mo.transpose(mo.multiply(myrotation_matrix, mo.transpose(ellipse0)))\r\n        # Transformed ellipse in the local coordiante yet in 3D\r\n        ellipse_local_coordinate = mo.zeros(n, 3)\r\n        for i in range(n):\r\n            ellipse_local_coordinate[i][0] = ellipse0[i][0] + p_in[0][0]\r\n            ellipse_local_coordinate[i][1] = ellipse0[i][1] + p_in[1][0]\r\n            ellipse_local_coordinate[i][2] = Z0\r\n\r\n        # transforming the points in local coordinate system into the global one\r\n        ellipse_global_coordinate = copy.deepcopy(ellipse_local_coordinate)\r\n        inverse_transformation = mo.pinv(self._transformation_matrix)\r\n        ellipse_global_coordinate = mo.multiply(ellipse_global_coordinate, inverse_transformation)\r\n        \r\n        self.ellipse_local_coordinate = ellipse_local_coordinate\r\n        self.ellipse_global_coordinate = ellipse_global_coordinate\r\n\r\n        return p_in\r\n\r\n\r\n# processing input points to MO proper input\r\npoints = MatrixOperations.zeros(len(input_points), 3)\r\nfor i, pnt in enumerate(input_points):\r\n    for j in range(3):\r\n        points[i][j] = pnt[j]\r\n\r\n# fitting the ellipse\r\nellipse_fitter = EllipseFitter(points)\r\nellipse_params = ellipse_fitter.fit_ellipse()\r\n\r\n# Assigning max/min diameters\r\nmax_diameter, min_diameter = ellipse_params['axes']\r\n\r\n# Getting points of the fitted ellipse\r\nellipse_points = []\r\nfor pnt in ellipse_fitter.ellipse_global_coordinate:\r\n    gh_pnt = ghc.ConstructPoint(pnt[0], pnt[1], pnt[2])\r\n    ellipse_points.append(gh_pnt)\r\n\r\n# Get ellipse curve\r\nellipse_crv = ghc.Interpolate(ellipse_points, 3, True, 0)['curve']\r\n\r\n",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": false
}