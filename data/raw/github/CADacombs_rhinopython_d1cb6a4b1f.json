{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_Ellipse_Approximate_with_arcs.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_Ellipse_Approximate_with_arcs.py",
  "instruction": "The script creates a 4-arc or 8-arc approximation of an ellipse. This is useful when an\r\nellipse or its NURBS equivalent are not wanted or allowed, as is the case of\r\nsome CAM software.\r\n\r\nThe...",
  "code": "\"\"\"\r\nThe script creates a 4-arc or 8-arc approximation of an ellipse. This is useful when an\r\nellipse or its NURBS equivalent are not wanted or allowed, as is the case of\r\nsome CAM software.\r\n\r\nThe construction geometry for the 4-arc method is based on Section 3 of https://www.researchgate.net/publication/241719740_Approximating_an_ellipse_with_four_circular_arcs\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250728-0803: Created.\r\n\r\nTODO:\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport math\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fTol_IsEllipse'; keys.append(key)\r\n    values[key] = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    names[key] = 'IsEllipseTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True,\r\n        limit=Rhino.RhinoMath.ZeroTolerance)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'b8Arcs_not4'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'NumOfArcsInEntireEllipse'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], '4', '8')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    #key = 'iNumPtsToCheck'; keys.append(key)\r\n    #values[key] = 31\r\n    #riOpts[key] = ri.Custom.OptionInteger(values[key], lowerLimit=1, upperLimit=255)\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPolyCrvOutput_notArcs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'OutputCrv'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Arcs', 'Poly')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddEllipticalDeg2NurbsIfInputIsNot'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fSearchTol':\r\n        #    if cls.riOpts[key].CurrentValue < 0.0:\r\n        #        cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n        #        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n        #        return\r\n\r\n        #    sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n        #    return\r\n\r\n        if key == 'fTol_IsEllipse':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < cls.riOpts[key].InitialValue:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getInput(bDebug=False):\r\n    \"\"\"\r\n    Get curves or ellipse diameters.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select elliptical-shaped curves\")\r\n    \r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    #go.GeometryAttributeFilter = (\r\n    #    ri.Custom.GeometryAttributeFilter.\r\n\r\n    #go.AcceptNumber(True, acceptZero=False)\r\n    go.EnableClearObjectsOnEntry(False) # If not set to False, faces will be unselected when result == ri.GetResult.Object \r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fTol_IsEllipse')\r\n        addOption('b8Arcs_not4')\r\n        #addOption('iNumPtsToCheck')\r\n        addOption('bPolyCrvOutput_notArcs')\r\n        addOption('bReplace')\r\n        addOption('bAddEllipticalDeg2NurbsIfInputIsNot')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTol_IsEllipse'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _formatDistance(fDistance, fPrecision=None):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    if fDistance == Rhino.RhinoMath.UnsetValue:\r\n        return \"(Infinite)\"\r\n    if fPrecision is None:\r\n        fPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    if fDistance < 10.0**(-(fPrecision-1)):\r\n        # For example, if fDistance is 1e-5 and fPrecision == 5,\r\n        # the end of this script would display only one digit.\r\n        # Instead, this return displays 2 digits.\r\n        return \"{:.2e}\".format(fDistance)\r\n\r\n    return \"{:.{}f}\".format(fDistance, fPrecision)\r\n\r\n\r\ndef _is_iterable(obj):\r\n    try:\r\n        iter(obj)\r\n        return True\r\n    except TypeError:\r\n        return False\r\n\r\n\r\ndef _joinCrvs(curves_In):\r\n    rv = rg.Curve.JoinCurves(curves_In)\r\n    if len(rv) != 1:\r\n        #for c in rv: sc.doc.Objects.AddCurve(c)\r\n        raise Exception(\"JoinCurves produced {} curves.\".format(len(rv)))\r\n    return rv[0]\r\n\r\n\r\ndef _getMaxDev(curvesA, curveB):\r\n\r\n    if _is_iterable(curvesA):\r\n        crv_WIP = _joinCrvs(curvesA)\r\n    else:\r\n        crv_WIP = curvesA.DuplicateCurve()\r\n\r\n    if not isinstance(curveB, rg.Curve):\r\n        curveB = curveB.ToNurbsCurve()\r\n\r\n    rv = rg.Curve.GetDistancesBetweenCurves(crv_WIP, curveB, tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    crv_WIP.Dispose()\r\n\r\n    if not rv[0]:\r\n        raise Exception(\"GetDistancesBetweenCurves failed.\")\r\n\r\n    return rv[1]\r\n\r\n\r\n    devs = []\r\n\r\n    for curveA in curvesA:\r\n        rv = rg.Curve.GetDistancesBetweenCurves(curveA, curveB, tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n        if not rv[0]:\r\n            for c in curvesA: sc.doc.Objects.AddCurve(c)\r\n            raise Exception(\"GetDistancesBetweenCurves failed.\")\r\n        devs.append(rv[1])\r\n\r\n    return max(devs)\r\n\r\n\r\ndef create4ArcApproximation(a, b, iNumPtsToCheck=31, bDebug=False):\r\n\r\n    if a > b:\r\n        bFlippedAB = False\r\n    else:\r\n        a, b = b, a\r\n        bFlippedAB = True\r\n\r\n    ellipse_Ref = rg.Ellipse(rg.Plane.WorldXY, radius1=a, radius2=b)\r\n    nc_ellipse_Ref = ellipse_Ref.ToNurbsCurve()\r\n    nc_EllipticalArc_Ref = nc_ellipse_Ref.Trim(nc_ellipse_Ref.Domain.T0, nc_ellipse_Ref.Domain.Mid/2.0)\r\n    nc_ellipse_Ref.Dispose()\r\n    if bDebug: sc.doc.Objects.AddCurve(nc_EllipticalArc_Ref)\r\n\r\n    C = rg.Point3d(\r\n        x= (a-b)/2.0,\r\n        y=-(a-b)/2.0,\r\n        z=0.0)\r\n\r\n    if bDebug: sEval = \"C\"; print(sEval,'=',eval(sEval))\r\n\r\n    incircle = rg.Circle(center=C, radius=(a-b)/2.0)\r\n\r\n    arc_in = rg.Arc(\r\n        circle=incircle,\r\n        angleIntervalRadians=rg.Interval(\r\n            t0=Rhino.RhinoMath.ToRadians(-90.0),\r\n            t1=0.0))\r\n\r\n    arcCrv_in = rg.ArcCurve(arc_in)\r\n    if bDebug: sc.doc.Objects.AddCurve(arcCrv_in)\r\n\r\n    A = rg.Point3d(a, 0.0, 0.0)\r\n    B = rg.Point3d(0.0, b, 0.0)\r\n    E = rg.Point3d(a, b, 0.0)\r\n\r\n    radius_conArc = (A - C).Length\r\n\r\n    if bDebug: sEval = \"radius_conArc\"; print(sEval,'=',eval(sEval))\r\n    if bDebug: sEval = \"type(radius_conArc)\"; print(sEval,'=',eval(sEval))\r\n\r\n    concentriccircle = rg.Circle(center=C, radius=radius_conArc)\r\n\r\n    lineBE = rg.Line(B, E)\r\n    #if bDebug: sc.doc.Objects.AddLine(lineBE)\r\n\r\n    # Alternative method to determine D.\r\n    #rvs = rg.Intersect.Intersection.LineCircle(lineBE, concentriccircle)\r\n    #D = rvs[4]\r\n\r\n    D = rg.Point3d(a-b, b, 0.0)\r\n\r\n    if bDebug: sEval = \"D\"; print(sEval,'=',eval(sEval))\r\n\r\n    angleIntervalRadians = rg.Interval(\r\n       math.atan2(A.Y - C.Y, A.X - C.X),\r\n       math.atan2(D.Y - C.Y, D.X - C.X))\r\n\r\n    if bDebug: sEval = \"angleIntervalRadians\"; print(sEval,'=',eval(sEval))\r\n\r\n    arc_con = rg.Arc(\r\n        circle=concentriccircle,\r\n        angleIntervalRadians=angleIntervalRadians)\r\n    #sc.doc.Objects.AddArc(arc_con)\r\n\r\n    domainLength = arc_con.AngleDomain.Length\r\n    domainStart = arc_con.AngleDomain.T0\r\n    domainEnd = arc_con.AngleDomain.T1\r\n\r\n\r\n    def getArcsAtT(T):\r\n        bSuccess, t = arcCrv_in.GetLocalTangentPoint(\r\n            testPoint=T,\r\n            seedParmameter=arcCrv_in.Domain.Mid)\r\n\r\n        if bDebug: sEval = \"t\"; print(sEval,'=',eval(sEval))\r\n\r\n        line_tan = rg.Line(T, arcCrv_in.PointAt(t))\r\n        if bDebug: sEval = \"line_tan\"; print(sEval,'=',eval(sEval))\r\n        if bDebug: sc.doc.Objects.AddLine(line_tan)\r\n\r\n        lineOA = rg.Line(rg.Point3d.Origin, A)\r\n        #if bDebug: sc.doc.Objects.AddLine(lineOA)\r\n        lineOB = rg.Line(rg.Point3d.Origin, B)\r\n        #if bDebug: sc.doc.Objects.AddLine(lineOB)\r\n\r\n        bSuccess, tOA, t_tan = rg.Intersect.Intersection.LineLine(lineOA, line_tan)\r\n        if not bSuccess:\r\n            raise Exception(\"Intersection.LineLine failed.\")\r\n\r\n        C1 = lineOA.PointAt(tOA)\r\n        if bDebug: sEval = \"C1\"; print(sEval,'=',eval(sEval))\r\n        if bDebug: sc.doc.Objects.AddPoint(C1)\r\n\r\n        bSuccess, tOB, t_tan = rg.Intersect.Intersection.LineLine(lineOB, line_tan)\r\n        if not bSuccess:\r\n            raise Exception(\"Intersection.LineLine failed.\")\r\n\r\n        C2 = lineOB.PointAt(tOB)\r\n        if bDebug: sEval = \"C2\"; print(sEval,'=',eval(sEval))\r\n        if bDebug: sc.doc.Objects.AddPoint(C2)\r\n\r\n        circle_AT = rg.Circle(center=C1, radius=(A-C1).Length)\r\n        if bDebug: sc.doc.Objects.AddCircle(circle_AT)\r\n\r\n        angle = math.atan2(T.Y - C1.Y, T.X - C1.X)\r\n\r\n        angleIntervalRadians = rg.Interval(-angle, angle)\r\n\r\n        arc_AT = rg.Arc(\r\n            circle=circle_AT,\r\n            angleIntervalRadians=angleIntervalRadians)\r\n        #sc.doc.Objects.AddArc(arc_AT)\r\n\r\n        arcCrv_AT = rg.ArcCurve(arc_AT)\r\n\r\n        circle_BT = rg.Circle(center=C2, radius=(B-C2).Length)\r\n        if bDebug: sc.doc.Objects.AddCircle(circle_BT)\r\n\r\n        angle = math.atan2(T.Y - C2.Y, T.X - C2.X)\r\n\r\n        angleIntervalRadians = rg.Interval(angle, math.pi-angle)\r\n        #sEval = \"angleIntervalRadians\"; print(sEval,'=',eval(sEval))\r\n\r\n        arc_BT = rg.Arc(\r\n            circle=circle_BT,\r\n            angleIntervalRadians=angleIntervalRadians)\r\n        #sc.doc.Objects.AddArc(arc_BT)\r\n\r\n        arcCrv_BT = rg.ArcCurve(arc_BT)\r\n\r\n        return arcCrv_AT, arcCrv_BT\r\n\r\n\r\n    ##\r\n\r\n    # Equally-spaced method\r\n    Ts = []\r\n    devs = []\r\n    arcCrvs_AT = []\r\n    arcCrvs_BT = []\r\n\r\n\r\n    def checkAllEquallySpacedPts():\r\n\r\n        for i in range(1, (iNumPtsToCheck+1)):\r\n            sc.escape_test()\r\n\r\n            tangle = (float(i)/float(iNumPtsToCheck+1))*domainLength + domainStart\r\n            T = arc_con.PointAt(tangle)\r\n            #sc.doc.Objects.AddPoint(T)\r\n\r\n            arcCrv_AT, arcCrv_BT = getArcsAtT(T)\r\n            dev = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n\r\n\r\n            Ts.append(T)\r\n            devs.append(dev)\r\n            arcCrvs_AT.append(arcCrv_AT)\r\n            arcCrvs_BT.append(arcCrv_BT)\r\n\r\n            # Graph deviations.\r\n            #sc.doc.Objects.AddLine(\r\n            #    rg.Point3d(float(i), 0.0, 0.0),\r\n            #    rg.Point3d(float(i), dev, 0.0))\r\n\r\n        idxWinner = devs.index(min(devs))\r\n\r\n        print(\"Index {} of {} pts\".format(idxWinner, len(Ts)))\r\n        print(\"Max. dev. from ellipse: {}\".format(_formatDistance(devs[idxWinner])))\r\n\r\n        T = Ts[idxWinner]\r\n        arcCrv_AT = arcCrvs_AT[idxWinner]\r\n        arcCrv_BT = arcCrvs_BT[idxWinner]\r\n\r\n        return arcCrv_AT, arcCrv_BT\r\n\r\n\r\n    #arcCrv_AT, arcCrv_BT = checkAllEquallySpacedPts()\r\n\r\n    ##\r\n\r\n\r\n    ##\r\n\r\n    # Quarter search method\r\n\r\n    arcCrv_con = rg.ArcCurve(arc_con)\r\n    if bDebug: sc.doc.Objects.AddCurve(arcCrv_con)\r\n\r\n    #sEval = \"arc_con.AngleDomain\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"arcCrv_con.Domain\"; print(sEval,'=',eval(sEval))\r\n\r\n    ts_arcCrv = arcCrv_con.DivideByLength(10.0*sc.doc.ModelAbsoluteTolerance, includeEnds=False)\r\n\r\n    T_H = arcCrv_con.PointAt(ts_arcCrv[-1])\r\n    t_H = arc_con.ClosestParameter(T_H)\r\n    arcCrv_AT, arcCrv_BT = getArcsAtT(T_H)\r\n    #sc.doc.Objects.AddCurve(arcCrv_AT)\r\n    #sc.doc.Objects.AddCurve(arcCrv_BT)\r\n    dev_H = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n\r\n    T_L = arcCrv_con.PointAt(ts_arcCrv[0])\r\n    t_L = arc_con.ClosestParameter(T_L)\r\n    arcCrv_AT, arcCrv_BT = getArcsAtT(T_L)\r\n    dev_L = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n\r\n    #sc.doc.Objects.AddPoint(T_L)\r\n\r\n    i = 0\r\n\r\n    while T_H.DistanceTo(T_L) > (0.1 * sc.doc.ModelAbsoluteTolerance):\r\n        sc.escape_test()\r\n\r\n        i += 1\r\n\r\n        #print('-'*20)\r\n        #sEval = \"dev_H\"; print(sEval,'=',eval(sEval))\r\n\r\n        t_MH = 0.75*t_H + 0.25*t_L\r\n        T_MH = arc_con.PointAt(t_MH)\r\n        arcCrv_AT, arcCrv_BT = getArcsAtT(T_MH)\r\n        dev_MH = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n        #sEval = \"dev_MH\"; print(sEval,'=',eval(sEval))\r\n\r\n        t_MM = 0.5*t_H + 0.5*t_L\r\n        T_MM = arc_con.PointAt(t_MM)\r\n        arcCrv_AT, arcCrv_BT = getArcsAtT(T_MM)\r\n        dev_MM = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n        #sEval = \"dev_MM\"; print(sEval,'=',eval(sEval))\r\n\r\n        t_ML = 0.25*t_H + 0.75*t_L\r\n        T_ML = arc_con.PointAt(t_ML)\r\n        arcCrv_AT, arcCrv_BT = getArcsAtT(T_ML)\r\n        dev_ML = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n        #sEval = \"dev_ML\"; print(sEval,'=',eval(sEval))\r\n\r\n        #sEval = \"dev_L\"; print(sEval,'=',eval(sEval))\r\n\r\n        bChanged = False\r\n\r\n        if dev_MM < dev_MH < dev_H:\r\n            T_H = T_MH\r\n            t_H = t_MH\r\n            dev_H = dev_MH\r\n            bChanged = True\r\n\r\n        if dev_MM < dev_ML < dev_L:\r\n            T_L = T_ML\r\n            t_L = t_ML\r\n            dev_L = dev_ML\r\n            bChanged = True\r\n\r\n        if not bChanged:\r\n            raise Exception(\"No change.\")\r\n\r\n    #print(\"Search took {} iterations.\".format(i))\r\n\r\n    #print('-'*20)\r\n    t_MM = 0.5*t_H + 0.5*t_L\r\n    T_MM = arc_con.PointAt(t_MM)\r\n    arcCrv_AT, arcCrv_BT = getArcsAtT(T_MM)\r\n\r\n    dev_MM = _getMaxDev((arcCrv_AT, arcCrv_BT), nc_EllipticalArc_Ref)\r\n    #sEval = \"dev_MM\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n    if bFlippedAB:\r\n        xform = rg.Transform.Mirror(\r\n            mirrorPlane=rg.Plane(\r\n                origin=rg.Point3d.Origin,\r\n                normal=rg.Vector3d(-1.0, 1.0, 0.0)))\r\n\r\n        arcCrv_AT.Transform(xform)\r\n        arcCrv_BT.Transform(xform)\r\n\r\n    xform = rg.Transform.Rotation(\r\n        angleRadians=math.pi,\r\n        rotationCenter=rg.Point3d.Origin)\r\n\r\n    arcCrv_AT_Dup = rg.ArcCurve(arcCrv_AT)\r\n\r\n    bSuccess = arcCrv_AT_Dup.Transform(xform)\r\n\r\n    #sc.doc.Objects.AddCurve(arcCrv_AT)\r\n    #sc.doc.Objects.AddCurve(arcCrv_AT_Dup)\r\n\r\n    arcCrv_BT_Dup = rg.ArcCurve(arcCrv_BT)\r\n\r\n    bSuccess = arcCrv_BT_Dup.Transform(xform)\r\n\r\n    #sc.doc.Objects.AddCurve(arcCrv_BT)\r\n    #sc.doc.Objects.AddCurve(arcCrv_BT_Dup)\r\n\r\n    if bFlippedAB:\r\n        return (arcCrv_BT, arcCrv_AT, arcCrv_BT_Dup, arcCrv_AT_Dup), dev_MM\r\n    else:\r\n        return (arcCrv_AT, arcCrv_BT, arcCrv_AT_Dup, arcCrv_BT_Dup), dev_MM\r\n\r\n\r\ndef create8ArcApproximation(a, b, bDebug=False):\r\n\r\n    if abs(a - b) < sc.doc.ModelAbsoluteTolerance:\r\n        return\r\n\r\n    if a > b:\r\n        bFlippedAB = False\r\n    else:\r\n        a, b = b, a\r\n        bFlippedAB = True\r\n\r\n    ellipse_Ref = rg.Ellipse(rg.Plane.WorldXY, radius1=a, radius2=b)\r\n    nc_ellipse_Ref = ellipse_Ref.ToNurbsCurve()\r\n    nc_EllipticalArc_Ref = nc_ellipse_Ref.Trim(nc_ellipse_Ref.Domain.T0, nc_ellipse_Ref.Domain.Mid/2.0)\r\n    nc_ellipse_Ref.Dispose()\r\n    if bDebug: sc.doc.Objects.AddCurve(nc_EllipticalArc_Ref)\r\n\r\n    rA = (b**2)/a\r\n    rB = (a**2)/b\r\n\r\n    if min((rA, rB)) < 10.0*sc.doc.ModelAbsoluteTolerance:\r\n        print(\"One arc radius is {}.\".format(\r\n            _formatDistance(min((rA, rB)))),\r\n              \"(The ellipse's eccentricity is {}.)\".format(ellipse_Ref.FocalDistance / a),\r\n              \"The ellipse is not supported by this script.\")\r\n        return\r\n\r\n    if bDebug: sEval = \"rA\"; print(sEval,'=',eval(sEval))\r\n    if bDebug: sEval = \"rB\"; print(sEval,'=',eval(sEval))\r\n\r\n    rF = 0.5*(rA + rB)\r\n\r\n    CA = rg.Point3d(a-rA, 0.0, 0.0)\r\n    circle_A = rg.Circle(center=CA, radius=rA)\r\n    if bDebug: sc.doc.Objects.AddCircle(circle_A)\r\n\r\n    arc_A = rg.Arc(\r\n        circle=circle_A,\r\n        angleIntervalRadians=rg.Interval(\r\n            t0=0.0,\r\n            t1=math.pi/2.0))\r\n    if bDebug: sc.doc.Objects.AddArc(arc_A)\r\n    arcCrv_A = rg.ArcCurve(arc_A)\r\n    if bDebug: sc.doc.Objects.AddCurve(arcCrv_A)\r\n\r\n    CB = rg.Point3d(0.0, b-rB, 0.0)\r\n    circle_B = rg.Circle(center=CB, radius=rB)\r\n    if bDebug: sc.doc.Objects.AddCircle(circle_B)\r\n\r\n    arc_B = rg.Arc(\r\n        circle=circle_B,\r\n        angleIntervalRadians=rg.Interval(\r\n            t0=0.0,\r\n            t1=math.pi/2))\r\n    if bDebug: sc.doc.Objects.AddArc(arc_B)\r\n    arcCrv_B = rg.ArcCurve(arc_B)\r\n\r\n    if arcCrv_B.PointAtStart.X > a:\r\n        bSuccess, t = arcCrv_B.ClosestPoint(arc_A.Center)\r\n        if not bSuccess:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n        arcCrv_B = arcCrv_B.Trim(t, arcCrv_B.Domain.T1)\r\n\r\n    if bDebug: sc.doc.Objects.AddCurve(arcCrv_B)\r\n\r\n    #arc_F = rg.Curve.CreateFillet(\r\n    #    curve0=arcCrv_A,\r\n    #    curve1=arcCrv_B,\r\n    #    radius=rF,\r\n    #    t0Base=arcCrv_A.Domain.Mid,\r\n    #    t1Base=arcCrv_B.Domain.Mid)\r\n    #sc.doc.Objects.AddArc(arc_F)\r\n\r\n    A = rg.Point3d(a, 0.0, 0.0)\r\n    B = rg.Point3d(0.0, b, 0.0)\r\n\r\n\r\n    def createFilletCurves(radius):\r\n        for point0 in arcCrv_A.PointAtMid, arcCrv_A.PointAtStart, arcCrv_A.PointAtEnd:\r\n            for point1 in arcCrv_B.PointAtMid, arcCrv_B.PointAtEnd, arcCrv_B.PointAtStart:\r\n                rv = rg.Curve.CreateFilletCurves(\r\n                    curve0=arcCrv_A,\r\n                    point0=point0,\r\n                    curve1=arcCrv_B,\r\n                    point1=point1,\r\n                    radius=radius,\r\n                    join=False,\r\n                    trim=True,\r\n                    arcExtension=True,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance,\r\n                    angleTolerance=0.1*sc.doc.ModelAngleToleranceRadians)\r\n                if len(rv) == 0:\r\n                    raise Exception(\"No curves.\")\r\n                for c in rv:\r\n                    if not c.IsValid:\r\n                        raise Exception(\"Curve from CreateFilletCurves is invalid.\")\r\n                for c in rv:\r\n                    if c.AngleDegrees > 90.0:\r\n                        #print(\"Curve of {} degrees found in CreateFilletCurves with radius of {} and point0 at {} and point1 at {}.\".format(\r\n                        #    c.AngleDegrees, radius, point0, point1))\r\n                        for c in rv:\r\n                            c.Dispose()\r\n                        break\r\n                else:\r\n                    # Success.\r\n                    return rv\r\n\r\n        raise Exception(\"CreateFilletCurves failed to provide all good curves < 90 degrees.\")\r\n\r\n\r\n    if bDebug: sEval = \"rv\"; print(sEval,'=',eval(sEval))\r\n\r\n    if bDebug: sc.doc.Objects.AddCurve(rv[2])\r\n\r\n    r_H = (a**2 + a*b) / (2*b)\r\n    r_L = (b**2 + a*b) / (2*a)\r\n\r\n    crvs_H = createFilletCurves(r_H)\r\n    dev_H = _getMaxDev(crvs_H, nc_EllipticalArc_Ref)\r\n\r\n    crvs_L = createFilletCurves(r_L)\r\n    dev_L = _getMaxDev(crvs_L, nc_EllipticalArc_Ref)\r\n\r\n    i = 0\r\n\r\n    while (r_H - r_L) > 0.1 * sc.doc.ModelAbsoluteTolerance:\r\n        sc.escape_test()\r\n\r\n        i += 1\r\n\r\n        r_MH = 0.75*r_H + 0.25*r_L\r\n        crvs_MH = createFilletCurves(r_MH)\r\n        dev_MH = _getMaxDev(crvs_MH, nc_EllipticalArc_Ref)\r\n\r\n        r_MM = 0.5*r_H + 0.5*r_L\r\n        crvs_MM = createFilletCurves(r_MM)\r\n        dev_MM = _getMaxDev(crvs_MM, nc_EllipticalArc_Ref)\r\n\r\n        r_ML = 0.25*r_H + 0.75*r_L\r\n        crvs_ML = createFilletCurves(r_ML)\r\n        dev_ML = _getMaxDev(crvs_ML, nc_EllipticalArc_Ref)\r\n\r\n        bChanged = False\r\n\r\n        if dev_MM < dev_MH < dev_H:\r\n            r_H = r_MH\r\n            dev_H = dev_MH\r\n            for c in crvs_H: c.Dispose()\r\n            crvs_H = crvs_MH\r\n            bChanged = True\r\n        elif dev_MM < dev_H and dev_MM < dev_MH:\r\n            r_H = r_MH\r\n            dev_H = dev_MH\r\n            for c in crvs_H: c.Dispose()\r\n            crvs_H = crvs_MH\r\n            bChanged = True\r\n\r\n        if dev_MM < dev_L and dev_MM < dev_ML:\r\n            r_L = r_ML\r\n            dev_L = dev_ML\r\n            for c in crvs_L: c.Dispose()\r\n            crvs_L = crvs_ML\r\n            bChanged = True\r\n\r\n        if not bChanged:\r\n            if dev_ML < dev_MH:\r\n                r_H = r_MH\r\n                dev_H = dev_MH\r\n                for c in crvs_H: c.Dispose()\r\n                crvs_H = crvs_MH\r\n                bChanged = True\r\n            elif dev_MH < dev_ML:\r\n                r_L = r_ML\r\n                dev_L = dev_ML\r\n                for c in crvs_L: c.Dispose()\r\n                crvs_L = crvs_ML\r\n                bChanged = True\r\n\r\n            if not bChanged:\r\n                sEval = \"dev_H\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"dev_MH\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"dev_MM\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"dev_ML\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"dev_L\"; print(sEval,'=',eval(sEval))\r\n                \r\n                #for c in crvs_H: sc.doc.Objects.AddCurve(c)\r\n                \r\n                print(\"Iterations: {}\".format(i))\r\n                \r\n                print(\"Eccentricy of ellipse may be too large for this script.\")\r\n                return\r\n\r\n        for c in crvs_MH: c.Dispose()\r\n        for c in crvs_MM: c.Dispose()\r\n        for c in crvs_ML: c.Dispose()\r\n\r\n\r\n    print(\"Search took {} iterations.\".format(i))\r\n\r\n    r_MM = 0.5*r_H + 0.5*r_L\r\n\r\n    #sc.doc.Objects.AddCurve(arcCrv_A)\r\n    #sc.doc.Objects.AddCurve(arcCrv_B)\r\n    #return\r\n\r\n    rv = createFilletCurves(r_MM)\r\n\r\n    if len(rv) != 3:\r\n        raise Exception(\"len(rv) : \".format(len(rv)))\r\n\r\n    dev_MM = _getMaxDev(rv, nc_EllipticalArc_Ref)\r\n\r\n\r\n    #for c in rv:\r\n    #    sc.doc.Objects.AddCurve(c)\r\n\r\n    arcCrv_A, arcCrv_B, arcCrv_F = rv\r\n\r\n    if bFlippedAB:\r\n        xform = rg.Transform.Mirror(\r\n            mirrorPlane=rg.Plane(\r\n                origin=rg.Point3d.Origin,\r\n                normal=rg.Vector3d(-1.0, 1.0, 0.0)))\r\n\r\n        arcCrv_A.Transform(xform)\r\n        arcCrv_B.Transform(xform)\r\n        arcCrv_F.Transform(xform)\r\n\r\n\r\n\r\n    arc_A = arcCrv_A.Arc\r\n    arc_B = arcCrv_B.Arc\r\n\r\n    #for c in rv:\r\n    #    sc.doc.Objects.AddCurve(c)\r\n    #return\r\n\r\n    arc_A.StartAngle = -arc_A.EndAngle\r\n    arcCrv_A = rg.ArcCurve(arc_A)\r\n    #sc.doc.Objects.AddCurve(arcCrv_A)\r\n\r\n    arc_B.EndAngle = math.pi - arc_B.StartAngle\r\n    arcCrv_B = rg.ArcCurve(arc_B)\r\n    #sc.doc.Objects.AddCurve(arcCrv_B)\r\n\r\n    arcCrv_A_Dup = rg.ArcCurve(arcCrv_A)\r\n    arcCrv_B_Dup = rg.ArcCurve(arcCrv_B)\r\n    arcCrv_F_Dup1 = rg.ArcCurve(arcCrv_F)\r\n\r\n    xform = rg.Transform.Mirror(\r\n        mirrorPlane=rg.Plane(\r\n            origin=rg.Point3d.Origin,\r\n            normal=rg.Vector3d(0.0, 1.0, 0.0)))\r\n\r\n    bSuccess = arcCrv_B_Dup.Transform(xform)\r\n    bSuccess = arcCrv_F_Dup1.Transform(xform)\r\n\r\n    arcCrv_F_Dup2 = rg.ArcCurve(arcCrv_F)\r\n    arcCrv_F_Dup3 = rg.ArcCurve(arcCrv_F_Dup1)\r\n\r\n    xform = rg.Transform.Mirror(\r\n        mirrorPlane=rg.Plane(\r\n            origin=rg.Point3d.Origin,\r\n            normal=rg.Vector3d(1.0, 0.0, 0.0)))\r\n\r\n    bSuccess = arcCrv_A_Dup.Transform(xform)\r\n    bSuccess = arcCrv_F_Dup2.Transform(xform)\r\n    bSuccess = arcCrv_F_Dup3.Transform(xform)\r\n\r\n    return ((\r\n        arcCrv_A,\r\n        arcCrv_F,\r\n        arcCrv_B,\r\n        arcCrv_F_Dup2,\r\n        arcCrv_A_Dup,\r\n        arcCrv_F_Dup3,\r\n        arcCrv_B_Dup,\r\n        arcCrv_F_Dup1\r\n        ),\r\n            dev_MM\r\n            )\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fTol_IsEllipse = Opts.values['fTol_IsEllipse']\r\n    b8Arcs_not4 = Opts.values['b8Arcs_not4']\r\n    #iNumPtsToCheck = Opts.values['iNumPtsToCheck']\r\n    bPolyCrvOutput_notArcs = Opts.values['bPolyCrvOutput_notArcs']\r\n    bAddEllipticalDeg2NurbsIfInputIsNot = Opts.values['bAddEllipticalDeg2NurbsIfInputIsNot']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    fDevs = []\r\n    gAdded = []\r\n    gReplaced = []\r\n\r\n    for objref in objrefs:\r\n        rgC_In = objref.Curve()\r\n        if rgC_In is None:\r\n            raise Exception(\"Curve not found!\")\r\n            continue\r\n\r\n        if isinstance(rgC_In, rg.ArcCurve):\r\n            if bEcho and len(objrefs) == 1:\r\n                print(\"Skipped ArcCurve.\")\r\n                return\r\n            continue\r\n\r\n        if rgC_In.IsArc():\r\n            if bEcho and len(objrefs) == 1:\r\n                print(\"Skipped arc-shaped curve.\")\r\n                return\r\n            continue\r\n\r\n        bSuccess, ellipse = rgC_In.TryGetEllipse()\r\n        if bSuccess:\r\n            bInputIsAccurateEllipse = True\r\n        else:\r\n            bSuccess, ellipse = rgC_In.TryGetEllipse(tolerance=fTol_IsEllipse)\r\n            if not bSuccess:\r\n                continue\r\n            bInputIsAccurateEllipse = False\r\n\r\n        if isinstance(rgC_In, rg.BrepEdge):\r\n            bIsEdge = True\r\n            rgC_In_NotProxy = rgC_In.DuplicateCurve()\r\n        else:\r\n            bIsEdge = False\r\n            rgC_In_NotProxy = rgC_In\r\n\r\n        bIsNurbsCrv = isinstance(rgC_In_NotProxy, rg.NurbsCurve)\r\n\r\n        #radius = arc.Radius\r\n        #radii.append(radius)\r\n\r\n        a = ellipse.Radius1\r\n        b = ellipse.Radius2\r\n\r\n        if b8Arcs_not4:\r\n            rv = create8ArcApproximation(a, b, bDebug=bDebug)\r\n        else:\r\n            rv = create4ArcApproximation(a, b, bDebug=bDebug)\r\n\r\n        if rv is None:\r\n            continue\r\n\r\n        arcCrvs_Res, fDev = rv\r\n        fDevs.append(fDev)\r\n\r\n        xform = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, ellipse.Plane)\r\n\r\n        if bPolyCrvOutput_notArcs:\r\n            polycrv = rg.Curve.JoinCurves(arcCrvs_Res)[0]\r\n            polycrv.Transform(xform)\r\n            if bReplace and not bIsEdge:\r\n                if sc.doc.Objects.Replace(objref, curve=polycrv):\r\n                    gReplaced.append(objref.ObjectId)\r\n                else:\r\n                    print(\"Could not replace curve, {}.\".format(objref.ObjectId))\r\n            else:\r\n                gOut = sc.doc.Objects.AddCurve(polycrv)\r\n                if gOut != gOut.Empty:\r\n                    gAdded.append(gOut)\r\n                else:\r\n                    print(\"Could not add curve approximation of {}.\".format(objref.ObjectId))\r\n        else:\r\n            bFailedToAddSomeArcs = False\r\n            for c in arcCrvs_Res:\r\n                c.Transform(xform)\r\n                gOut = sc.doc.Objects.AddCurve(c)\r\n                if gOut != gOut.Empty:\r\n                    gAdded.append(gOut)\r\n                else:\r\n                    bFailedToAddSomeArcs = True\r\n                    print(\"Could not add ArcCurve for approximation of {}.\".format(objref.ObjectId))\r\n                if bReplace and not bIsEdge:\r\n                    if not bFailedToAddSomeArcs:\r\n                        if sc.doc.Objects.Delete(objref, quiet=False):\r\n                            gReplaced.append(objref.ObjectId)\r\n\r\n        if bAddEllipticalDeg2NurbsIfInputIsNot:\r\n            if not (bInputIsAccurateEllipse and bIsNurbsCrv and rgC_In_NotProxy.Degree == 2):\r\n                gOut = sc.doc.Objects.AddEllipse(ellipse)\r\n                if gOut != gOut.Empty:\r\n                    gAdded.append(gOut)\r\n\r\n    if bEcho:\r\n        ss = []\r\n        if gAdded:\r\n            ss.append(\"Added {} curves.\".format(len(gAdded)))\r\n        if gReplaced:\r\n            ss.append(\"Replaced {} curves.\".format(len(gReplaced)))\r\n        if fDevs:\r\n            ss.append(\"{} maximum deviation.\".format(_formatDistance(max(fDevs))))\r\n\r\n        print(*ss)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}