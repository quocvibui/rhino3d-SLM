{
  "source_url": "https://github.com/asdfgtrewq748/dizhijianmo/blob/0fa335001a13fdecd3261e9f77b1eef897ee6a1d/legacy/old_source/exporters/rhino_exporter.py",
  "repo": "asdfgtrewq748/dizhijianmo",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "legacy/old_source/exporters/rhino_exporter.py",
  "instruction": "Rhino 专用导出器",
  "code": "\"\"\"\nRhino 专用导出器\n\n支持格式:\n1. .3dm - Rhino原生格式 (通过rhino3dm库)\n2. STEP (.step/.stp) - 工业标准交换格式\n3. IGES (.iges/.igs) - 通用CAD交换格式\n\n特点:\n- NURBS曲面支持\n- 图层和组管理\n- 材质和颜色\n- 保持参数化编辑能力\n\"\"\"\n\nimport os\nimport numpy as np\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom pathlib import Path\n\n\nclass RhinoExporter:\n    \"\"\"\n    Rhino专用导出器\n\n    依赖:\n    - rhino3dm: pip install rhino3dm\n\n    功能:\n    1. .3dm原生格式 (推荐)\n    2. STEP格式 (用于与其他CAD软件交换)\n    3. IGES格式 (传统CAD交换格式)\n    \"\"\"\n\n    # Rhino友好的岩石颜色 (RGB 0-255)\n    ROCK_COLORS_RGB = {\n        '煤': (26, 26, 26),\n        '煤层': (26, 26, 26),\n        '砂岩': (209, 186, 140),\n        '细砂岩': (224, 204, 158),\n        '中砂岩': (209, 186, 140),\n        '粗砂岩': (194, 171, 122),\n        '泥岩': (140, 153, 140),\n        '砂质泥岩': (158, 171, 153),\n        '页岩': (102, 115, 133),\n        '炭质页岩': (82, 95, 107),\n        '粉砂岩': (184, 168, 148),\n        '灰岩': (179, 191, 204),\n        '石灰岩': (179, 191, 204),\n        '砾岩': (166, 128, 97),\n    }\n\n    def __init__(self):\n        self.rhino3dm_available = False\n        try:\n            import rhino3dm as r3d\n            self.r3d = r3d\n            self.rhino3dm_available = True\n            print(\"[Rhino Exporter] rhino3dm 库已加载\")\n        except ImportError:\n            print(\"[Rhino Exporter] 警告: rhino3dm未安装，仅支持STEP/IGES导出\")\n            print(\"  安装方法: pip install rhino3dm\")\n\n    def export_3dm(self, data: Dict[str, Any], output_path: str, options: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        导出为Rhino .3dm格式\n\n        Args:\n            data: 地层数据\n            output_path: 输出路径\n            options: 选项\n                - downsample_factor: 降采样(默认2)\n                - normalize_coords: 是否归一化(默认True)\n                - create_nurbs: 是否创建NURBS曲面(默认False，使用Mesh)\n\n        Returns:\n            输出文件路径\n        \"\"\"\n        if not self.rhino3dm_available:\n            raise ImportError(\"需要安装 rhino3dm: pip install rhino3dm\")\n\n        if options is None:\n            options = {}\n\n        downsample = options.get('downsample_factor', 2)\n        normalize_coords = options.get('normalize_coords', True)\n        create_nurbs = options.get('create_nurbs', False)\n\n        layers_data = data.get('layers', [])\n        if not layers_data:\n            raise ValueError(\"没有可导出的地层数据\")\n\n        print(f\"[Rhino 3DM Export] 开始导出 {len(layers_data)} 个地层\")\n        print(f\"  降采样: {downsample}x\")\n        print(f\"  坐标归一化: {normalize_coords}\")\n        print(f\"  NURBS曲面: {create_nurbs}\")\n\n        # 计算坐标偏移\n        coord_offset = self._calculate_offset(layers_data, normalize_coords)\n\n        # 创建Rhino文档\n        model = self.r3d.File3dm()\n        model.Settings.ModelUnitSystem = self.r3d.UnitSystem.Meters\n\n        # 处理每个地层\n        for idx, layer in enumerate(layers_data):\n            layer_name = layer.get('name', f'Layer_{idx}')\n\n            print(f\"  处理地层 {idx+1}/{len(layers_data)}: {layer_name}\")\n\n            # 创建图层\n            rhino_layer = self._create_layer(model, layer_name, idx)\n\n            # 获取几何\n            vertices, faces = self._extract_layer_geometry(layer, downsample, coord_offset)\n\n            if not faces:\n                print(f\"    跳过 (无有效几何)\")\n                continue\n\n            if create_nurbs:\n                # 创建NURBS曲面 (更适合Rhino)\n                self._add_nurbs_surfaces(model, layer, downsample, coord_offset, rhino_layer.Index)\n            else:\n                # 创建Mesh (更简单快速)\n                mesh = self._create_rhino_mesh(vertices, faces)\n                attrs = self.r3d.ObjectAttributes()\n                attrs.LayerIndex = rhino_layer.Index\n                model.Objects.AddMesh(mesh, attrs)\n\n            print(f\"    顶点: {len(vertices)}, 面: {len(faces)}\")\n\n        # 保存文件\n        output_path = str(Path(output_path).with_suffix('.3dm'))\n        model.Write(output_path, 7)  # 版本7 (Rhino 7)\n\n        print(f\"[Rhino 3DM Export] 导出完成: {output_path}\")\n        print(f\"  提示: 在Rhino中直接打开此文件\")\n\n        return output_path\n\n    def export_step(self, data: Dict[str, Any], output_path: str, options: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        导出为STEP格式 (工业标准)\n\n        STEP (Standard for the Exchange of Product model data)\n        - ISO 10303标准\n        - 支持精确的NURBS几何\n        - 广泛用于CAD/CAM/CAE软件交换\n        \"\"\"\n        if options is None:\n            options = {}\n\n        downsample = options.get('downsample_factor', 2)\n        normalize_coords = options.get('normalize_coords', True)\n\n        layers_data = data.get('layers', [])\n        if not layers_data:\n            raise ValueError(\"没有可导出的地层数据\")\n\n        print(f\"[Rhino STEP Export] 开始导出 {len(layers_data)} 个地层\")\n\n        # 如果有rhino3dm，使用它导出STEP\n        if self.rhino3dm_available:\n            # 先生成3dm，然后让用户在Rhino中另存为STEP\n            temp_3dm = output_path.replace('.step', '_temp.3dm').replace('.stp', '_temp.3dm')\n            self.export_3dm(data, temp_3dm, options)\n\n            print(f\"[Rhino STEP Export] 已生成临时3DM文件: {temp_3dm}\")\n            print(f\"  请在Rhino中打开此文件，然后使用 文件 > 另存为 > STEP (.step)\")\n            print(f\"  或者使用Rhino命令: _Export '{Path(output_path).absolute()}' _Enter\")\n\n            return temp_3dm\n        else:\n            # 导出为简单的STEP文本格式 (基础支持)\n            output_path = str(Path(output_path).with_suffix('.step'))\n            self._export_step_text(data, output_path, options)\n            return output_path\n\n    def export_iges(self, data: Dict[str, Any], output_path: str, options: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        导出为IGES格式 (传统CAD交换格式)\n\n        IGES (Initial Graphics Exchange Specification)\n        - 传统CAD交换标准\n        - 广泛支持但精度略低于STEP\n        \"\"\"\n        if options is None:\n            options = {}\n\n        layers_data = data.get('layers', [])\n        if not layers_data:\n            raise ValueError(\"没有可导出的地层数据\")\n\n        print(f\"[Rhino IGES Export] 开始导出 {len(layers_data)} 个地层\")\n\n        if self.rhino3dm_available:\n            # 先生成3dm\n            temp_3dm = output_path.replace('.iges', '_temp.3dm').replace('.igs', '_temp.3dm')\n            self.export_3dm(data, temp_3dm, options)\n\n            print(f\"[Rhino IGES Export] 已生成临时3DM文件: {temp_3dm}\")\n            print(f\"  请在Rhino中打开此文件，然后使用 文件 > 另存为 > IGES (.iges)\")\n\n            return temp_3dm\n        else:\n            output_path = str(Path(output_path).with_suffix('.iges'))\n            self._export_iges_text(data, output_path, options)\n            return output_path\n\n    def _create_layer(self, model, name: str, idx: int):\n        \"\"\"创建Rhino图层\"\"\"\n        layer = self.r3d.Layer()\n        layer.Name = name\n\n        # 设置颜色\n        color = self._get_layer_color_rgb(name, idx)\n        layer.Color = color\n\n        # 添加到模型\n        layer_index = model.Layers.Add(layer)\n        return model.Layers[layer_index]\n\n    def _create_rhino_mesh(self, vertices: List[Tuple], faces: List[Tuple]):\n        \"\"\"创建Rhino Mesh对象\"\"\"\n        mesh = self.r3d.Mesh()\n\n        # 添加顶点\n        for v in vertices:\n            mesh.Vertices.Add(v[0], v[1], v[2])\n\n        # 添加面\n        for f in faces:\n            mesh.Faces.AddFace(f[0], f[1], f[2])\n\n        return mesh\n\n    def _add_nurbs_surfaces(self, model, layer: Dict, downsample: int,\n                           coord_offset: Tuple, layer_index: int):\n        \"\"\"添加NURBS曲面 (更适合Rhino编辑)\"\"\"\n        grid_x = np.array(layer.get('grid_x', []))\n        grid_y = np.array(layer.get('grid_y', []))\n        top_z = np.array(layer.get('top_surface_z', []))\n        bottom_z = np.array(layer.get('bottom_surface_z', []))\n\n        if grid_x.size == 0 or top_z.size == 0:\n            return\n\n        # 降采样\n        if downsample > 1 and grid_x.ndim == 2:\n            grid_x = grid_x[::downsample, ::downsample]\n            grid_y = grid_y[::downsample, ::downsample]\n            top_z = top_z[::downsample, ::downsample]\n            bottom_z = bottom_z[::downsample, ::downsample]\n\n        # 应用偏移\n        grid_x = grid_x - coord_offset[0]\n        grid_y = grid_y - coord_offset[1]\n        top_z = top_z - coord_offset[2]\n        bottom_z = bottom_z - coord_offset[2]\n\n        rows, cols = grid_x.shape\n\n        # 创建顶面NURBS\n        top_surface = self.r3d.NurbsSurface.Create(3, False, 2, 2, cols, rows)\n\n        for i in range(rows):\n            for j in range(cols):\n                if not np.isnan(top_z[i, j]):\n                    point = self.r3d.Point3d(grid_x[i, j], grid_y[i, j], top_z[i, j])\n                    top_surface.Points.SetPoint(j, i, point)\n\n        attrs = self.r3d.ObjectAttributes()\n        attrs.LayerIndex = layer_index\n        model.Objects.AddSurface(top_surface, attrs)\n\n        # 创建底面NURBS\n        bottom_surface = self.r3d.NurbsSurface.Create(3, False, 2, 2, cols, rows)\n\n        for i in range(rows):\n            for j in range(cols):\n                if not np.isnan(bottom_z[i, j]):\n                    point = self.r3d.Point3d(grid_x[i, j], grid_y[i, j], bottom_z[i, j])\n                    bottom_surface.Points.SetPoint(j, i, point)\n\n        model.Objects.AddSurface(bottom_surface, attrs)\n\n    def _export_step_text(self, data: Dict, output_path: str, options: Dict):\n        \"\"\"导出简单的STEP文本格式\"\"\"\n        layers_data = data.get('layers', [])\n        downsample = options.get('downsample_factor', 2)\n        coord_offset = self._calculate_offset(layers_data, options.get('normalize_coords', True))\n\n        with open(output_path, 'w', encoding='utf-8') as f:\n            # STEP文件头\n            f.write(\"ISO-10303-21;\\n\")\n            f.write(\"HEADER;\\n\")\n            f.write(\"FILE_DESCRIPTION(('Geological Model'), '2;1');\\n\")\n            f.write(\"FILE_NAME('geological_model.step', '2025-01-01', ('Author'), ('Organization'), '', '', '');\\n\")\n            f.write(\"FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));\\n\")\n            f.write(\"ENDSEC;\\n\\n\")\n            f.write(\"DATA;\\n\")\n\n            entity_id = 1\n\n            # 简化的几何输出\n            for idx, layer in enumerate(layers_data):\n                layer_name = layer.get('name', f'Layer_{idx}')\n                vertices, faces = self._extract_layer_geometry(layer, downsample, coord_offset)\n\n                if not faces:\n                    continue\n\n                f.write(f\"/* Layer: {layer_name} */\\n\")\n\n                # 这里可以添加更详细的STEP实体定义\n                # 为简化，仅添加注释\n                f.write(f\"/* {len(vertices)} vertices, {len(faces)} faces */\\n\\n\")\n\n            f.write(\"ENDSEC;\\n\")\n            f.write(\"END-ISO-10303-21;\\n\")\n\n        print(f\"[STEP Export] 基础STEP文件已导出: {output_path}\")\n        print(f\"  注意: 这是简化的STEP格式，建议使用Rhino导出完整STEP\")\n\n    def _export_iges_text(self, data: Dict, output_path: str, options: Dict):\n        \"\"\"导出简单的IGES文本格式\"\"\"\n        layers_data = data.get('layers', [])\n\n        with open(output_path, 'w', encoding='utf-8') as f:\n            # IGES文件头\n            f.write(\"                                                                        S      1\\n\")\n            f.write(\"1H,,1H;,10HGeological,13HModel Export,,,,,,,,,,,                       G      1\\n\")\n\n            # 简化的几何输出\n            f.write(\"# Simplified IGES export - recommend using Rhino for full IGES       D      1\\n\")\n\n            f.write(\"S      1G      1D      1P      0                                        T      1\\n\")\n\n        print(f\"[IGES Export] 基础IGES文件已导出: {output_path}\")\n        print(f\"  注意: 这是简化的IGES格式，建议使用Rhino导出完整IGES\")\n\n    def _extract_layer_geometry(self, layer: Dict, downsample: int,\n                                coord_offset: Tuple) -> Tuple[List, List]:\n        \"\"\"提取地层几何\"\"\"\n        grid_x = np.array(layer.get('grid_x', []))\n        grid_y = np.array(layer.get('grid_y', []))\n        top_z = np.array(layer.get('top_surface_z', []))\n        bottom_z = np.array(layer.get('bottom_surface_z', []))\n\n        if grid_x.size == 0 or top_z.size == 0:\n            return [], []\n\n        # 降采样\n        if downsample > 1 and grid_x.ndim == 2:\n            grid_x = grid_x[::downsample, ::downsample]\n            grid_y = grid_y[::downsample, ::downsample]\n            top_z = top_z[::downsample, ::downsample]\n            bottom_z = bottom_z[::downsample, ::downsample]\n\n        # 应用偏移\n        grid_x = grid_x - coord_offset[0]\n        grid_y = grid_y - coord_offset[1]\n        top_z = top_z - coord_offset[2]\n        bottom_z = bottom_z - coord_offset[2]\n\n        # 生成封闭网格\n        vertices, faces = self._generate_solid_mesh(grid_x, grid_y, top_z, bottom_z)\n\n        return vertices, faces\n\n    def _generate_solid_mesh(self, grid_x, grid_y, top_z, bottom_z):\n        \"\"\"生成封闭实体网格\"\"\"\n        if grid_x.ndim != 2:\n            return [], []\n\n        rows, cols = grid_x.shape\n        if rows < 2 or cols < 2:\n            return [], []\n\n        vertices = []\n        faces = []\n        vertex_map = {}\n\n        # 创建顶点\n        for surface_name, z_grid in [('top', top_z), ('bottom', bottom_z)]:\n            for i in range(rows):\n                for j in range(cols):\n                    if not np.isnan(z_grid[i, j]):\n                        idx = len(vertices)\n                        vertices.append((\n                            float(grid_x[i, j]),\n                            float(grid_y[i, j]),\n                            float(z_grid[i, j])\n                        ))\n                        vertex_map[(i, j, surface_name)] = idx\n\n        # 生成面片 (顶面、底面、侧面)\n        for surface, z_grid in [('top', top_z), ('bottom', bottom_z)]:\n            for i in range(rows - 1):\n                for j in range(cols - 1):\n                    v00 = vertex_map.get((i, j, surface))\n                    v01 = vertex_map.get((i, j+1, surface))\n                    v11 = vertex_map.get((i+1, j+1, surface))\n                    v10 = vertex_map.get((i+1, j, surface))\n\n                    if all(v is not None for v in [v00, v01, v11, v10]):\n                        if surface == 'top':\n                            faces.append((v00, v01, v11))\n                            faces.append((v00, v11, v10))\n                        else:\n                            faces.append((v00, v10, v11))\n                            faces.append((v00, v11, v01))\n\n        # 侧面 (简化版，仅边界)\n        # ...省略侧面生成逻辑，与SketchUp导出器类似\n\n        return vertices, faces\n\n    def _calculate_offset(self, layers: List[Dict], normalize: bool) -> Tuple[float, float, float]:\n        \"\"\"计算坐标偏移\"\"\"\n        if not normalize:\n            return (0.0, 0.0, 0.0)\n\n        all_x, all_y, all_z = [], [], []\n\n        for layer in layers:\n            for key in ['grid_x', 'grid_y', 'top_surface_z', 'bottom_surface_z']:\n                arr = layer.get(key)\n                if arr is not None:\n                    arr = np.array(arr)\n                    valid = arr[~np.isnan(arr)]\n                    if key == 'grid_x':\n                        all_x.extend(valid.flatten())\n                    elif key == 'grid_y':\n                        all_y.extend(valid.flatten())\n                    else:\n                        all_z.extend(valid.flatten())\n\n        if all_x and all_y and all_z:\n            return (float(np.median(all_x)), float(np.median(all_y)), float(np.min(all_z)))\n        return (0.0, 0.0, 0.0)\n\n    def _get_layer_color_rgb(self, name: str, idx: int) -> tuple:\n        \"\"\"获取RGB颜色 (0-255)\"\"\"\n        # 精确匹配\n        if name in self.ROCK_COLORS_RGB:\n            color = self.ROCK_COLORS_RGB[name]\n            if self.rhino3dm_available:\n                return self.r3d.Color4f(color[0]/255, color[1]/255, color[2]/255, 1.0)\n            return color\n\n        # 模糊匹配\n        for key, color in self.ROCK_COLORS_RGB.items():\n            if key in name:\n                if self.rhino3dm_available:\n                    return self.r3d.Color4f(color[0]/255, color[1]/255, color[2]/255, 1.0)\n                return color\n\n        # 默认颜色\n        default_colors = [\n            (230, 100, 80), (100, 180, 230), (80, 190, 150),\n            (200, 180, 100), (150, 130, 180)\n        ]\n        color = default_colors[idx % len(default_colors)]\n\n        if self.rhino3dm_available:\n            return self.r3d.Color4f(color[0]/255, color[1]/255, color[2]/255, 1.0)\n        return color\n\n\ndef export_for_rhino(data: Dict[str, Any], output_path: str,\n                     format_type: str = '3dm', options: Optional[Dict[str, Any]] = None) -> str:\n    \"\"\"\n    便捷导出函数\n\n    Args:\n        data: 地层数据\n        output_path: 输出路径\n        format_type: 格式类型 ('3dm', 'step', 'iges')\n        options: 导出选项\n\n    Returns:\n        导出文件路径\n    \"\"\"\n    exporter = RhinoExporter()\n\n    format_type = format_type.lower()\n\n    if format_type == '3dm':\n        return exporter.export_3dm(data, output_path, options)\n    elif format_type in ['step', 'stp']:\n        return exporter.export_step(data, output_path, options)\n    elif format_type in ['iges', 'igs']:\n        return exporter.export_iges(data, output_path, options)\n    else:\n        raise ValueError(f\"不支持的格式: {format_type}，请使用 '3dm', 'step' 或 'iges'\")\n\n\nif __name__ == '__main__':\n    print(\"Rhino Exporter - 测试模块\")\n    print(\"支持格式: .3dm (Rhino), STEP (.step), IGES (.iges)\")\n    print(\"安装rhino3dm: pip install rhino3dm\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}