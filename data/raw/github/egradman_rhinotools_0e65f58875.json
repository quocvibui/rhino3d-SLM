{
  "source_url": "https://github.com/egradman/rhinotools/blob/db6e79170674b887c00ad096eba3ba834382a98d/dogbone.py",
  "repo": "egradman/rhinotools",
  "repo_stars": 23,
  "repo_description": null,
  "license": "unknown",
  "filepath": "dogbone.py",
  "instruction": "Dogbone",
  "code": "import rhinoscriptsyntax as rs\nfrom collections import defaultdict\nfrom collections import Iterable\nimport Rhino\nimport getsubsurface\nimport math\n\ninner_curves = None\nouter_curves = None\ncurve_coords = None\n\ndef main():\n  global inner_curves, outer_curves, curve_coords\n\n  # save for later\n  orig_hidden_objects = rs.HiddenObjects()\n\n  # we put reference points in the dogbone-ref layer, so create it if it doesn't exist\n  rs.AddLayer(\"dogbone-ref\")\n\n  panel, face = getsubsurface.GetSubSurface(\"select dogbone face\")\n\n  diameter = rs.GetReal(\"enter cutter diameter\", number=0.25)\n  diameter = diameter*1.1\n\n  rs.EnableRedraw(False)\n\n  # compute the plane\n  normal = rs.VectorUnitize(rs.SurfaceNormal(face, (0.5,0.5)))\n  plane = rs.PlaneFromNormal(rs.EvaluateSurface(face, 0.5, 0.5), normal)\n\n  rs.ViewCPlane(plane=plane)\n  rs.ProjectOsnaps(True)\n\n  outer_curves = rs.DuplicateSurfaceBorder(face, 1)\n  inner_curves = rs.DuplicateSurfaceBorder(face, 2)\n\n  # make a dict mapping each curve to the coords in that curve\n  curve_coords = dict()\n  for curve in outer_curves + inner_curves:\n    coords = rs.CurvePoints(curve)[:-1]\n    curve_coords[curve] = coords\n\n  # make a dict mapping each curve to the z component of its cross product at each index\n  curve_cross_zs = dict()\n  for curve, coords in curve_coords.items():\n    proj_coords = [rs.SurfaceClosestPoint(face, coord) for coord in coords]\n    cross_zs = []\n    for idx in range(len(proj_coords)):\n      triplet = [\n        proj_coords[(idx+1)%len(proj_coords)],\n        proj_coords[idx                ],\n        proj_coords[(idx-1)%len(proj_coords)]\n      ]\n\n      v0 = (triplet[1][0]-triplet[0][0], triplet[1][1]-triplet[0][1], 0)\n      v1 = (triplet[2][0]-triplet[1][0], triplet[2][1]-triplet[1][1], 0)\n      cross_z = rs.VectorCrossProduct(v0, v1)[2]\n      cross_zs.append(cross_z)\n    curve_cross_zs[curve] = cross_zs\n\n  points = []\n  bones = []\n  temp_points = []\n  rs.EnableRedraw(True)\n  while True:\n    coord = rs.GetPoint(\"select corner\")\n    if coord is None:\n      break\n    try:\n      curve, idx = get_curve_and_idx_for_coord(coord)\n      point = rs.AddPoint(coord)\n      rs.ObjectColor(point, (255, 0, 0))\n      temp_points.append(point)\n      bones.append((curve, idx))\n    except ValueError:\n      print \"invalid curve point\"\n      continue\n  rs.EnableRedraw(False)\n  rs.DeleteObjects(temp_points)\n\n  # try to automatically identify dogbone points if user selected none\n  if len(bones) == 0:\n    for curve, coords in curve_coords.items():\n      proj_coords = [rs.SurfaceClosestPoint(face, coord) for coord in coords]\n      for idx in range(len(proj_coords)):\n        triplet = [\n          proj_coords[(idx+1)%len(proj_coords)],\n          proj_coords[idx                ],\n          proj_coords[(idx-1)%len(proj_coords)]\n        ]\n        if curve_cross_zs[curve][idx] > 0:\n          bones.append((curve, idx))\n\n  # make the bones\n  extrusions = []\n  for bone in bones:\n    curve, idx = bone\n\n    coords = curve_coords[curve]\n\n    point = rs.AddPoint(coords[idx])\n    rs.ObjectLayer(point, \"dogbone-ref\")\n\n    triplet = [\n      coords[(idx+1)%len(coords)],\n      coords[idx                ],\n      coords[(idx-1)%len(coords)],\n    ]\n\n    angle = rs.Angle2(\n        (triplet[1], triplet[0]),\n        (triplet[1], triplet[2]),\n    )\n    angle = angle[0]\n\n    # This is a hacky method to determine the handedness of the curve\n    # the cross product SHOULD have worked here, but for some reason\n    # it did not.\n    v0 = triplet[2][0]-triplet[1][0], triplet[2][1]-triplet[1][1], 0\n    v1 = triplet[1][0]-triplet[0][0], triplet[1][1]-triplet[0][1], 0\n    _angle = math.degrees(math.atan2(v0[1], v0[0]) - math.atan2(v1[1], v1[0]))\n    while _angle > 180: _angle -= 360\n    while _angle < -180: _angle += 360\n    if math.copysign(1, angle) != math.copysign(1, _angle):\n      angle -= 180\n\n    point = rs.VectorAdd(\n      triplet[1], \n      rs.VectorRotate(0.5*diameter*rs.VectorUnitize(rs.VectorSubtract(triplet[2], triplet[1])), angle/2, (0,0,1))\n    )\n\n    circle = rs.AddCircle((point.X, point.Y, -10), diameter/2.0)\n    circle_srf = rs.AddPlanarSrf(circle)\n    p0 = (point.X, point.Y, -10)\n    p1 = (point.X, point.Y,  10)\n    line = rs.AddLine(p0, p1)\n\n    extrusion = rs.ExtrudeSurface(circle_srf, line)\n    extrusions.append(extrusion)\n    rs.DeleteObjects([circle, circle_srf, line])\n\n  rs.BooleanDifference([panel], extrusions, delete_input=True)\n\n  rs.DeleteObject(panel)\n  rs.DeleteObjects(extrusions)\n  rs.DeleteObjects(points)\n  rs.DeleteObjects(inner_curves)\n  rs.DeleteObjects(outer_curves)\n  rs.DeleteObject(face)\n  rs.ShowObject(rs.AllObjects())\n  rs.HideObjects(orig_hidden_objects)\n\n  rs.EnableRedraw(True)\n\ndef get_curve_and_idx_for_coord(coord):\n  coord = round(coord[0],4), round(coord[1],4)\n  for curve, coords in curve_coords.items():\n    coords = [(round(c.X,4), round(c.Y,4)) for c in coords]\n    #for c in coords: print coord, c\n    if coord in coords:\n      return curve, coords.index(coord)\n  raise ValueError\n\nif __name__ == '__main__':\n  main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}