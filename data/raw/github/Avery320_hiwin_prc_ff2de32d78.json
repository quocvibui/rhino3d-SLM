{
  "source_url": "https://github.com/Avery320/hiwin_prc/blob/9353bee9d53d95b96bf354c28c79c89620e39885/prc/moveJ_movement.py",
  "repo": "Avery320/hiwin_prc",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-3-Clause",
  "filepath": "prc/moveJ_movement.py",
  "instruction": "Move j movement",
  "code": "import math\nimport json\nfrom collections import OrderedDict\n\ntry:\n    import Rhino.Geometry as rg\nexcept Exception:\n    rg = None\n\n\ndef _compute_rpy_from_axes(x_axis, y_axis, z_axis):\n    \"\"\"Compute roll, pitch, yaw (deg) from right-handed axes using ZYX convention.\n\n    R = Rz(yaw) * Ry(pitch) * Rx(roll)\n    Columns of rotation matrix are the axis unit vectors in world coordinates.\n    \"\"\"\n    r11 = x_axis.X\n    r12 = y_axis.X\n    r13 = z_axis.X\n    r21 = x_axis.Y\n    r22 = y_axis.Y\n    r23 = z_axis.Y\n    r31 = x_axis.Z\n    r32 = y_axis.Z\n    r33 = z_axis.Z\n\n    sy = math.sqrt(r11 * r11 + r21 * r21)\n    singular = sy < 1e-9\n\n    if not singular:\n        yaw = math.degrees(math.atan2(r21, r11))\n        pitch = math.degrees(math.atan2(-r31, sy))\n        roll = math.degrees(math.atan2(r32, r33))\n    else:\n        # Gimbal lock\n        yaw = math.degrees(math.atan2(-r12, r22))\n        pitch = math.degrees(math.atan2(-r31, sy))\n        roll = 0.0\n\n    return roll, pitch, yaw\n\n\ndef _build_axes_from_z(z_axis):\n    \"\"\"Given a Z axis (Vector3d), build a stable right-handed frame (X, Y, Z).\n\n    Uses world X as reference; if nearly parallel, switches to world Y.\n    X = Z x refX; Y = Z x X.\n    \"\"\"\n    z = rg.Vector3d(z_axis)\n    if not z.Unitize():\n        raise ValueError(\"Z axis vector cannot be zero-length\")\n\n    ref_x = rg.Vector3d(1.0, 0.0, 0.0)\n    if abs(rg.Vector3d.Multiply(z, ref_x)) > 0.99:  # nearly parallel\n        ref_x = rg.Vector3d(0.0, 1.0, 0.0)\n\n    x = rg.Vector3d.CrossProduct(z, ref_x)\n    _ = x.Unitize()\n    y = rg.Vector3d.CrossProduct(z, x)\n    _ = y.Unitize()\n\n    return x, y, z\n\n\ndef plane_to_movej(plane):\n    \"\"\"Convert a Rhino Plane to moveJ dict with meters and ZYX Euler angles (deg).\n\n    - Position: mm -> m\n    - Orientation: use Plane.XAxis/YAxis/ZAxis directly (deconstruct plane), then RPY (deg)\n    - motion_type is always \"moveJ\"\n    \"\"\"\n    if rg is None:\n        raise RuntimeError(\"Rhino.Geometry not available. This script is intended for Rhino/Grasshopper.\")\n\n    origin = plane.Origin\n    x_m = origin.X / 1000.0\n    y_m = origin.Y / 1000.0\n    z_m = origin.Z / 1000.0\n\n    # Deconstruct Plane: use plane's axes to preserve its rotation\n    x_axis = rg.Vector3d(plane.XAxis); x_axis.Unitize()\n    y_axis = rg.Vector3d(plane.YAxis); y_axis.Unitize()\n    z_axis = rg.Vector3d(plane.ZAxis); z_axis.Unitize()\n    roll_deg, pitch_deg, yaw_deg = _compute_rpy_from_axes(x_axis, y_axis, z_axis)\n\n    result = OrderedDict([\n        (\"motion_type\", \"moveJ\"),\n        (\"x\", round(x_m, 3)),\n        (\"y\", round(y_m, 3)),\n        (\"z\", round(z_m, 3)),\n        (\"roll\", round(roll_deg, 3)),\n        (\"pitch\", round(pitch_deg, 3)),\n        (\"yaw\", round(yaw_deg, 3)),\n    ])\n    return result\n\n\n# Grasshopper convenience: if a variable named `plane` exists in the scope,\n# compute outputs `result` and `movej_command` for direct wiring.\ntry:  # noqa: SIM105\n    plane  # type: ignore[name-defined]\n    if plane is not None and rg is not None:\n        result = plane_to_movej(plane)  # type: ignore[name-defined]\n        movej_command = json.dumps(result, sort_keys=False)\nexcept NameError:\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}