{
  "source_url": "https://github.com/BrunoBFerreira/ContextOriented/blob/5d51e5b1c350621f94ae3607c277b2b48a341b18/Python/khepri/rhino.py",
  "repo": "BrunoBFerreira/ContextOriented",
  "repo_stars": 0,
  "repo_description": "Generative Design with Context-Oriented Programming",
  "license": "unknown",
  "filepath": "Python/khepri/rhino.py",
  "instruction": "coding=utf8",
  "code": "#coding=utf8\nfrom __future__ import division\nimport sys\nfrom os import path\nsys.path.append(path.dirname(path.dirname(path.abspath(__file__))))\n\nfrom math import *\n\n\nfrom khepri.shape import *\nfrom khepri.util import *\nfrom khepri.coords import *\nimport numbers\nimport math\nimport Rhino\nimport scriptcontext\nimport rhinoscriptsyntax as rh\nimport System.Guid\n\n#mport clr\n#clr.AddReference(\"PresentationCore\")\n#from System.Windows.Media.Media3D import Point3D, Vector3D, Matrix3D\n\n#initialization\nrender_backend_dir('Rhinoceros')\n\n\n\ndb = scriptcontext.doc.Objects\nvs = scriptcontext.doc.Views\ngeo = Rhino.Geometry\n\ndef rawxyz(x, y, z):\n    return geo.Point3d(x, y, z)\n\nrawu0 = rawxyz(0, 0, 0)\n\ndef Pt(p):\n    p = p.raw_in_world\n    return geo.Point3d(p.x, p.y, p.z)\n\ndef fromPt(p):\n    return xyz(p[0], p[1], p[2])\n\ndef Vt(v):\n    v = v.raw_in_world\n    return geo.Vector3d(v.x, v.y, v.z)\n\ndef fromVt(p):\n    return vxyz(p[0], p[1], p[2])\n\ndef Pl(p):\n    t = p.world_transformation\n    pl = geo.Plane(geo.Point3d(t[3,0], t[3,1], t[3,2]), \n                   geo.Vector3d(t[0,0], t[0,1], t[0,2]),\n                   geo.Vector3d(t[1,0], t[1,1], t[1,2]))\n    return pl\n\ndef fromPlane(pl):\n    return u0(cs_from_o_vx_vy_vz(fromPt(pl.Origin),\n                                 fromVt(pl.XAxis),\n                                 fromVt(pl.YAxis),\n                                 fromVt(pl.ZAxis)))\n\ndef _surface_from_curves(curves):\n    return db.AddBrep(singleton(geo.Brep.CreatePlanarBreps(curves)))\n\ndef _geometry_from_id(id):\n    return db.Find(id).Geometry\n\ndef _surface_from_id(id):\n    curve = _geometry_from_id(id)\n    r = db.AddBrep(singleton(geo.Brep.CreatePlanarBreps([curve])))\n    return r\n\ndef _brep_from_id(id):\n    geom = _geometry_from_id(id)\n    if isinstance(geom, geo.Brep): return geom\n    if isinstance(geom, geo.Extrusion): return geom.ToBrep(True)\n    raise ValueError(\"unable to convert %s into Brep geometry\"%id)\n\ndef _point_in_surface(id):\n    v = rh.BrepClosestPoint(id, rawu0)\n    if v:\n        return fromPt(v[0])\n    else:\n        u, v = rh.SurfaceDomain(id, 0), rh.SurfaceDomain(id, 1)\n        return rh.EvaluateSurface(id, u[0], v[0])\n\ndef is_point_in_surface(id, p):\n    return rh.IsPointInSurface(id, Pt(p))\n\ndef is_point_on_surface(id, p):\n    return rh.IsPointOnSurface(id, Pt(p))\n\ndef is_point_on(r, c):\n    try:\n        return is_point_in_surface(r, c)\n    except:\n        return is_point_on_surface(r, c)\n\n#The Rhino shape\nclass shape(base_shape):\n    def validate(self, guid):\n        if isinstance(guid, System.Guid):\n            if guid == System.Guid.Empty:\n                raise RuntimeError(\"The operation failed!\")\n            else:\n                vs.Redraw()\n                return native_ref(guid)\n        elif isinstance(guid, (tuple, list)):\n            if len(guid) == []:\n                raise RuntimeError(\"The operation failed!\")\n            elif len(guid) == 1:\n                return self.validate(guid[0])\n            else:\n                return union_ref([self.validate(g) for g in guid])\n        elif (is_empty_ref(guid) or \n              is_universal_ref(guid) or\n              isinstance(guid, (native_ref, multiple_ref))):\n            return guid\n        else:\n            raise ValueError(\"Unexpected guid: {0}\".format(guid))\n\n    def delete(self):\n        #Perhaps optimize this in case the shape was not yet realized\n        self.realize().do(lambda r: self.destroy(r))\n\n    def destroy(self, guid):\n        db.Delete(guid, True)\n    \n    def copy_ref(self, guid):\n        return rh.CopyObject(guid)\n\n    def intersect_ref(self, r0, r1):\n        brep0 = _brep_from_id(r0)\n        brep1 = _brep_from_id(r1)\n        for e in range(5,2,-1):\n            tol = pow(10,-e)\n            newbreps = geo.Brep.CreateBooleanIntersection([brep0], [brep1], tol)\n            if newbreps:\n                db.Delete(r0, True)\n                db.Delete(r1, True)\n                return single_ref_or_union([db.AddBrep(brep) for brep in newbreps])\n        c1 = _point_in_surface(r1)\n        if is_point_on(r0, c1):\n            db.Delete(r0, True)\n            return native_ref(r1)\n        else:\n            c0 = _point_in_surface(r0)\n            if is_point_on(r1, c0):\n                db.Delete(r1, True)\n                return native_ref(r0)\n            else:\n                db.Delete(r0, True)\n                db.Delete(r1, True)\n                return empty_ref()\n\n    def subtract_ref(self, r0, r1):\n        brep0 = _brep_from_id(r0)\n        brep1 = _brep_from_id(r1)\n        for e in range(5,2,-1):\n            tol = pow(10,-e)\n            newbreps = geo.Brep.CreateBooleanDifference([brep0], [brep1], tol)\n            if newbreps:\n                db.Delete(r0, True)\n                db.Delete(r1, True)\n                return single_ref_or_union([db.AddBrep(brep) for brep in newbreps])\n        c1 = _point_in_surface(r1)\n        if is_point_on(r0, c1):\n            return subtraction_ref([native_ref(r0), native_ref(r1)])\n        else:\n            c0 = _point_in_surface(r0)\n            if is_point_on(r1, c0):\n                db.Delete(r0, True)\n                db.Delete(r1, True)\n                return empty_ref()\n            else:\n                db.Delete(r1, True)\n                return native_ref(r0)\n\n    def slice_ref(self, r, p, n):\n        cutter = rh.AddCutPlane([r], Pt(p), Pt(p + vx(1, p.cs)), Pt(vy(1, p.cs)))\n        rs = rh.SplitBrep(r, cutter, True)\n        rs = rs or [r]\n        for e in rs:\n            rh.CapPlanarHoles(e)\n        keep, clear = partition(rs, lambda r: (fromPt(rh.SurfaceVolumeCentroid(r)[0]) - p).dot(n) < 0)\n        rh.DeleteObjects(clear)\n        rh.DeleteObject(cutter)\n        if keep == []:\n            return empty_ref()\n        else:\n            return single_ref_or_union(keep)\n\n\n# The actual shapes\n@shape_constructor(shape)\ndef point(position=u0()):\n    return db.AddPoint(Pt(position))\n\nclass curve(shape):\n    pass\n\nclass closed_curve(curve):\n    pass\n\nclass surface(shape):\n    pass\n\nclass solid(shape):\n    pass\n\ndef is_curve(s):\n    return isinstance(s, curve)\ndef is_surface(s):\n    return isinstance(s, surface)\ndef is_solid(s):\n    return isinstance(s, solid)\n\n@shape_constructor(closed_curve)\ndef circle(center=u0(), radius=1):\n    return db.AddCircle(geo.Circle(Pl(center), radius))\n\n@shape_constructor(surface)\ndef surface_circle(center=u0(), radius=1):\n    return _surface_from_curves([geo.Circle(Pl(center), radius).ToNurbsCurve()])\n\n@shape_constructor(curve)\ndef arc(center=u0(), radius=1, start_angle=0, amplitude=pi):\n    if radius == 0:\n        return db.AddPoint(Pt(center))\n    elif amplitude == 0:\n        return db.AddPoint(Pt(add_pol(center, radius, start_angle)))\n    elif abs(amplitude) >= 2*pi:\n        return db.AddCircle(geo.Circle(Pl(center), radius))\n    else:\n        return db.AddArc(geo.Arc(Pl(center) if start_angle == 0\n                                 else Pl(loc_from_o_phi(center, start_angle)),\n                                 radius,\n                                 coterminal(amplitude)))\n\n@shape_constructor(surface)\ndef surface_arc(center=u0(), radius=1, start_angle=0, amplitude=pi):\n    if radius == 0:\n        return db.AddPoint(Pt(center))\n    elif amplitude == 0:\n        return db.AddPoint(Pt(addPol(center, radius, start_angle)))\n    elif abs(amplitude) >= 2*pi:\n        return db.AddCircle(geo.Circle(Pl(center), radius))\n    else:\n        curves = [geo.Arc(Pl(center) if start_angle == 0\n                          else Pl(loc_from_o_phi(center, start_angle)),\n                          radius,\n                          coterminal(amplitude)).ToNurbsCurve(),\n                  geo.Polyline([Pt(center), \n                                Pt(add_pol(center, radius, start_angle))]).ToNurbsCurve(),\n                  geo.Polyline([Pt(center), \n                                Pt(add_pol(center, radius, start_angle + amplitude))]).ToNurbsCurve()]\n        return _surface_from_curves(curves)\n        \n@shape_constructor(closed_curve)\ndef ellipse(center=u0(), radius_x=1, radius_y=1):\n    return db.AddEllipse(geo.Ellipse(Pl(center), radius_x, radius_y))\n\n@shape_constructor(surface)\ndef surface_ellipse(center=u0(), radius_x=1, radius_y=1):\n    return _surface_from_curves([geo.Ellipse(Pl(center), radius_x, radius_y).ToNurbsCurve()])\n\n@shape_constructor(curve)\ndef line(*vertices):\n    vs = unvarargs(vertices)\n    return db.AddPolyline(geo.Polyline([Pt(v) for v in vs]))\n\n@shape_constructor(curve)\ndef spline(*positions):\n    ps = unvarargs(positions)\n    return rh.AddInterpCurve([Pt(p) for p in ps], 3, 1)\n\n@shape_constructor(spline)\ndef spline_tangents(positions, start_tangent, end_tangent):\n    return rh.AddInterpCurve([Pt(p) for p in positions], 3, 1, \n                             Vt(start_tangent),\n                             Vt(end_tangent))\n\n@shape_constructor(closed_curve)\ndef closed_spline(*positions):\n    ps = unvarargs(positions)\n    return rh.AddInterpCurve([Pt(p) for p in ps]+[Pt(ps[0])], 3, 4)\n    \n\n@shape_constructor(closed_curve)\ndef rectangle(corner=u0(), dx=1, dy=None):\n    dy = dy or dx\n    dz = 0\n    c = corner\n    if isinstance(dx, xyz):\n        v = loc_in_cs(dx, c.cs) - c\n        dx, dy, dz = v.coords\n    assert dz == 0, \"The rectangle is not planar\"\n    return db.AddPolyline([Pt(c), \n                           Pt(add_x(c, dx)),\n                           Pt(add_xy(c, dx, dy)),\n                           Pt(add_y(c, dy)),\n                           Pt(c)])\n        \n@shape_constructor(surface)\ndef surface_rectangle(corner=u0(), dx=1, dy=None):\n    r = rectangle(corner, dx, dy)\n    s = rh.AddPlanarSrf(r.realize()._ref)\n    r.delete()\n    return s\n    \n@shape_constructor(closed_curve)\ndef polygon(*vertices):\n    vs = unvarargs(vertices)\n    return db.AddPolyline(geo.Polyline([Pt(v) for v in vs]+[Pt(vs[0])]))\n    \n@shape_constructor(surface)\ndef surface_polygon(*vertices):\n    vs = unvarargs(vertices)\n    return _surface_from_curves([geo.Polyline([Pt(v) for v in vs]+[Pt(vs[0])]).ToNurbsCurve()])\n    \n@shape_constructor(polygon)\ndef regular_polygon(edges=3, center=u0(), radius=1, angle=0, inscribed=False):\n    pts = map(Pt, regular_polygon_vertices(edges, center, radius, angle, inscribed))\n    return rh.AddPolyline(pts + [pts[0]])\n\n@shape_constructor(surface_polygon)\ndef surface_regular_polygon(edges=3, center=u0(), radius=1, angle=0, inscribed=False):\n    pts = map(Pt, regular_polygon_vertices(edges, center, radius, angle, inscribed))\n    border = rh.AddPolyline(pts + [pts[0]])\n    srf = rh.AddPlanarSrf([border])\n    db.Delete(border, True)\n    return srf\n\n@shape_constructor(surface)\ndef surface_from(*curves):\n    cs = unvarargs(curves)\n    refs = shapes_refs(cs)\n    if is_singleton(refs):\n        ref = refs[0]\n        if isinstance(ref, geo.Point):\n            id = ref\n        else:\n            ids = rh.AddPlanarSrf(refs)\n            if ids:\n                id = singleton(ids)\n            else:\n                id = rh.AddPatch(refs, 3, 3)\n    elif len(refs) < 0: #Temporary fix for Funda's problem# 5:\n        id = rh.AddEdgeSrf(refs)\n    else:\n        id = rh.AddPlanarSrf(refs)\n    delete_shapes(cs)\n    return id\n\n@shape_constructor(solid)\ndef box(corner=u0(), dx=1, dy=None, dz=None):\n    dy = dy or dx\n    dz = dz or dy\n    c = corner\n    if isinstance(dx, xyz):\n        v = loc_in_cs(dx, c.cs) - c\n        dx, dy, dz = v.coords\n    return rh.AddBox(map(Pt, \n                         [c,\n                          add_x(c, dx),\n                          add_xy(c, dx, dy),\n                          add_y(c, dy),\n                          add_z(c, dz),\n                          add_xz(c, dx, dz),\n                          add_xyz(c, dx, dy, dz),\n                          add_yz(c, dy, dz)]))\n\n@shape_constructor(solid)\ndef cuboid(b0=None, b1=None, b2=None, b3=None, t0=None, t1=None, t2=None, t3=None):\n    b0 = b0 or u0()\n    b1 = b1 or add_x(b0, 1)\n    b2 = b2 or add_y(b1, 1)\n    b3 = b3 or add_y(b0, 1)\n    t0 = t0 or add_z(b0, 1)\n    t1 = t1 or add_x(t0, 1)\n    t2 = t2 or add_y(t1, 1)\n    t3 = t3 or add_y(t0, 1)\n    return rh.AddBox(map(Pt, [b0, b1, b2, b3, t0, t1, t2, t3]))\n\n\n@shape_constructor(solid)\ndef cylinder(base=u0(), radius=1, height=1, top=None):\n    base, height = base_and_height(base, top or height)\n    return db.AddBrep(\n        geo.Cylinder(\n            geo.Circle(Pl(base), radius), height).ToBrep(True, True))\n\n@shape_constructor(solid)\ndef cone(base=u0(), radius=1, height=1, top=None):\n    base, height = inverted_base_and_height(base, top or height)\n    return db.AddBrep(geo.Brep.CreateFromCone(geo.Cone(Pl(base), height, radius), True))\n\n@shape_constructor(solid)\ndef cone_frustum(base=u0(), base_radius=1, height=1, top_radius=1, top=None):\n    base, height = base_and_height(base, top or height)\n    top = top or add_z(base, height)\n    bottomCircle = geo.Circle(Pl(base), base_radius)\n    topCircle = geo.Circle(Pl(top), top_radius)\n    shapeCurve = geo.LineCurve(bottomCircle.PointAt(0), topCircle.PointAt(0))\n    axis = geo.Line(bottomCircle.Center, topCircle.Center)\n    revsrf = geo.RevSurface.Create(shapeCurve, axis)\n    return db.AddBrep(geo.Brep.CreateFromRevSurface(revsrf, True, True))\n\ndef _irregular_pyramid(pts0, pt1):\n    pts0, pt1 = map(Pt, pts0), Pt(pt1)\n    id = rh.JoinSurfaces([rh.AddSrfPt((pt00, pt01, pt1)) \n                          for pt00, pt01 in zip(pts0, pts0[1:] + [pts0[0]])])\n    rh.CapPlanarHoles(id)\n    return id\n\ndef _irregular_pyramid_frustum(pts0, pts1):\n    pts0, pts1 = map(Pt, pts0), map(Pt, pts1)\n    id = rh.JoinSurfaces([rh.AddSrfPt((pt00, pt01, pt11, pt10))\n                          for pt00, pt01, pt10, pt11\n                          in zip(pts0, pts0[1:] + [pts0[0]], pts1, pts1[1:] + [pts1[0]])])\n    rh.CapPlanarHoles(id)\n    return id\n\n@shape_constructor(solid)\ndef regular_pyramid_frustum(edges=4, base=u0(), base_radius=1, angle=0, height=1, top_radius=1, inscribed=False, top=None):\n    base, height = base_and_height(base, top or height)\n    top = top or add_z(base, height)\n    return _irregular_pyramid_frustum(\n        regular_polygon_vertices(edges, base, base_radius, angle, inscribed),\n        regular_polygon_vertices(edges, top, top_radius, angle, inscribed))\n    \n@shape_constructor(solid)\ndef regular_pyramid(edges=4, base=u0(), radius=1, angle=0, height=1, inscribed=False, top=None):\n    base, height = base_and_height(base, top or height)\n    top = top or add_z(base, height)\n    return _irregular_pyramid(\n        regular_polygon_vertices(edges, base, radius, angle, inscribed),\n        top)\n\n@shape_constructor(solid)\ndef regular_prism(edges=4, base=u0(), radius=1, angle=0, height=1, inscribed=False, top=None):\n    base, height = base_and_height(base, top or height)\n    top = top or add_z(base, height)\n    return _irregular_pyramid_frustum(\n        regular_polygon_vertices(edges, base, radius, angle, inscribed),\n        regular_polygon_vertices(edges, top, radius, angle, inscribed))\n\n@shape_constructor(solid)\ndef irregular_prism(base_vertices=None, direction=1):\n    base_vertices = base_vertices or [ux(), uy(), uxy()]\n    dir = vz(direction, base_vertices[0].cs) if is_number(dir) else dir\n    return rh.IrregularPyramidFrustum(cbs, map((lambda p: p + dir), cbs))\n    \n@shape_constructor(solid)\ndef irregular_pyramid(base_vertices=None, top=None):\n    base_vertices = base_vertices or [ux(), uy(), uxy()]\n    top = top or uz()\n    return _irregular_pyramid(base_vertices, top)\n\n@shape_constructor(solid)\ndef right_cuboid(base=u0(), width=1, height=1, length=1, top=None):\n    base, dz = base_and_height(base, top or length)\n    c, dx, dy = add_xy(base, width/-2, height/-2), width, height\n    return rh.AddBox(map(Pt, [c,\n                              add_x(c, dx),\n                              add_xy(c, dx, dy),\n                              add_y(c, dy),\n                              add_z(c, dz),\n                              add_xz(c, dx, dz),\n                              add_xyz(c, dx, dy, dz),\n                              add_yz(c, dy, dz)]))\n\n@shape_constructor(solid)\ndef sphere(center=u0(), radius=1):\n    return db.AddSphere(geo.Sphere(Pt(center), radius))\n\n\n@shape_constructor(shape)\ndef text(str=\"\", corner=u0(), height=1):\n    return rh.AddText(str, Pl(corner), height)\n    \ndef text_length(str=\"\", height=1):\n    return len(str)*height*0.9\n\n@shape_constructor(shape)\ndef text_centered(str=\"\", corner=u0(), height=1):\n    return rh.AddText(str, Pl(add_xy(corner, text_length(str, height)/-2, height/-2)), height)\n\n@shape_constructor(shape)\ndef torus(center=u0(), major_radius=1, minor_radius=1/2):\n    return rh.AddTorus(Pl(center), major_radius, minor_radius)\n\n@shape_constructor(shape)\ndef union(*shapes):\n    shapes = filter(lambda s: not is_empty_shape(s),\n                    unvarargs(shapes))\n    if len(shapes) == 0:\n        return empty_ref()\n    elif len(shapes) == 1:\n        return shapes[0].realize()\n    elif any(is_universal_shape(s) for s in shapes):\n        return universal_ref()\n    else:\n        rs = [s.realize() for s in shapes]\n        for r in rs:\n            assert isinstance(r,(native_ref, multiple_ref)), \"BRONCA\"\n        unions, rs = partition(rs, is_union_ref)\n        subtractions, rs = partition(rs, is_subtraction_ref)\n        united = rs + [r0 for union in unions for r0 in union._refs] #Avoid this direct reference\n        return native_ref_or_union(united + subtractions)\n\n@shape_constructor(shape)\ndef intersection(*shapes):\n    shapes = unvarargs(shapes)\n    def create_ref(self, shapes):\n        shapes = filter(lambda s: not is_universal_shape(s), shapes)\n        if len(shapes) == 0:\n            return universal_ref()\n        elif len(shapes) == 1:\n            return shapes[0].realize()\n        elif any(is_empty_shape(s) for s in shapes):\n            return empty_ref()\n        else:\n            return intersect_refs(list(s.realize() for s in shapes), self)    \n    return maybe_delete_shapes(shapes, create_ref(shapes[0], shapes))\n\n\n@shape_constructor(shape)\ndef subtraction(*shapes):\n    shapes = unvarargs(shapes)\n    if len(shapes) == 0:\n        raise RuntimeError(\"No shapes to subtract\")\n    else:\n        s = shapes[0]\n        ss = filter(lambda s: not is_empty_shape(s), shapes[1:])\n        if len(ss) == 0:\n            return s.realize()\n        elif is_empty_shape(s) or any(is_universal_shape(o) or (o is s)\n                                      for o in ss):\n            return maybe_delete_shapes(ss, empty_ref())\n        else:\n            r = s.realize()\n            rs = [s0.realize() for s0 in ss]\n            return subtract_refs(r, rs, s)\n\n@shape_constructor(solid)\ndef slice(shape, p=u0(), n=None):\n    n = n or vz(1, p.cs)\n    p = loc_from_o_vz(p, n)\n    res = shape.realize().slice(p, n, shape)\n    shape.mark_deleted()\n    return res\n\n@shape_constructor(shape)\ndef extrusion(profile, dir=1):\n    dir = dir if isinstance(dir, vxyz) else vz(dir)\n    vec = Vt(dir)\n    def extrude(r):\n        if rh.IsCurve(r):\n            return db.AddSurface(geo.Surface.CreateExtrusion(db.Find(r).Geometry, vec))\n        else:\n            c = rh.SurfaceAreaCentroid(r)[0]\n            curve = rh.AddLine(c, c + vec)\n            brep = _brep_from_id(r)\n            c = db.Find(curve).Geometry\n            r = single_ref_or_union([db.AddBrep(face.CreateExtrusion(c, True))\n                                     for face in brep.Faces])\n            rh.DeleteObject(curve)\n            return r\n    return and_delete(profile.realize().map(extrude), profile)\n\ndef revolve_border(border, axis, start, end):\n    res = rh.AddRevSrf(border, axis, start, end)\n    rh.CapPlanarHoles(res)\n    rh.DeleteObject(border)\n    return res\n\ndef revolve_borders(profile, axis, start, end, out):\n    return [revolve_border(border, axis, start, end)\n            for border in rh.DuplicateSurfaceBorder(profile, 1 if out else 2)]\n\n@shape_constructor(shape)\ndef revolve(shape, c=u0(), v=vz(1), start_angle=0, amplitude=2*pi):\n    if isinstance(v, loc): #HACK Should we keep this?\n        v = v - c\n    axis = [Pt(c), Pt(c + v)]\n    start = degrees(start_angle)\n    end = degrees(start_angle + amplitude)\n    def revol(r):\n        if rh.IsCurve(r):\n            return native_ref(rh.AddRevSrf(r, axis, start, end))\n        elif rh.IsSurface(r) or rh.IsPolysurface(r):\n            out_refs = revolve_borders(r, axis, start, end, True)\n            in_refs = revolve_borders(r, axis, start, end, False)\n            return subtract_refs(single_ref_or_union(out_refs),\n                                 [native_ref(r) for r in in_refs],\n                                 shape)\n        else:\n            raise RuntimeError(\"Can't revolve the shape\")\n    return and_delete(shape.realize().map(revol), shape)\n\ndef sweep_path_curve(path, profile, rotation, scale):\n    def transf_t(t, r, s):\n        plane = rh.CurvePerpFrame(path, rh.CurveParameter(path, t))\n        xform = rh.XformChangeBasis(plane, geo.Plane.WorldXY)\n        xform = rh.XformMultiply(xform, rh.XformScale(s))\n        xform = rh.XformMultiply(xform, geo.Transform.Rotation(r, geo.Vector3d(0, 0, 1), rawu0))\n        return rh.TransformObject(profile, xform, True)\n    if rotation == 0 and scale == 1:\n        profiles = [transf_t(0.0, 0, 1)]\n    else:\n        n = 10\n        profiles = [transf_t(t, r, s) \n                    for t, r, s in zip(division(0, 1, n),\n                                       division(0, rotation, n),\n                                       division(1, scale, n))]\n    r = rh.AddSweep1(path, profiles)\n    rh.DeleteObjects(profiles)\n    return r\n\ndef solid_sweep_path_curve(path, profile, rotation, scale):\n    r = sweep_path_curve(path, profile, rotation, scale)\n    rh.CapPlanarHoles(r)\n    rh.DeleteObject(profile)\n    return r\n\ndef sweep_path_profile(path, profile, rotation, scale):\n    if rh.IsCurve(profile):\n        return single_ref_or_union(sweep_path_curve(path, profile, rotation, scale))\n    elif rh.IsSurface(profile):\n        o_refs, i_refs = ([solid_sweep_path_curve(path, border, rotation, scale)\n                           for border in rh.DuplicateSurfaceBorder(profile, i)]\n                          for i in (1, 2))\n        if i_refs == []:\n            return single_ref_or_union(o_refs)\n        else:\n            return subtract_refs(single_ref_or_union(o_refs),\n                                 single_ref_or_union(i_refs))\n    else:\n        raise RuntimeError('Continue this')\n\ndef delete_all_shapes():\n    for id in db.GetObjectList(Rhino.DocObjects.ObjectEnumeratorSettings()):\n        db.Delete(id, True)\n    vs.Redraw()\n\n@shape_constructor(shape)\ndef sweep(path, profile, rotation=0, scale=1):\n    path_ref = path.realize()\n    prof_ref = profile.realize()\n    return and_delete(\n        path_ref.map(lambda pa:\n                     prof_ref.map(lambda pr:\n                                  sweep_path_profile(pa, \n                                                     pr,\n                                                     rotation,\n                                                     scale))),\n        path,\n        profile)\n\n@shape_constructor(curve)\ndef surface_boundary(surface):\n    return and_delete(surface.realize().map(\n        lambda r: single_ref_or_subtraction(rh.DuplicateSurfaceBorder(r))),\n                      surface)\n\n# This is not correct. Must fix this ref mess\ndef adequate_ref(arg):\n    if isinstance(arg, (native_ref, multiple_ref)):\n        return arg\n    elif isinstance(arg, (tuple, list)):\n        return single_ref_or_union(arg)\n    else:\n        return native_ref(arg)\n\ndef loft_curve_point(curve, point):\n    p = rh.PointCoordinates(point.realize()._ref)\n    curve_ref = curve.realize()\n    return and_delete(adequate_ref(curve_ref.map(lambda c: rh.ExtrudeCurvePoint(c, p))),\n                      curve,\n                      point)\n\ndef loft_surface_point(surface, point):\n    boundary = surface_boundary(surface)\n    rs = loft_curve_point(boundary, point)\n    rs.do(rh.CapPlanarHoles)\n    return adequate_ref(rs)\n\ndef loft_profiles_aux(profiles, rails, is_ruled, is_closed):\n    profiles_refs = list([profile.realize()._ref\n                          for profile in profiles])\n    rails_refs = list([rail.realize()._ref\n                       for rail in rails])\n    if len(rails_refs) == 0:\n        return singleton(rh.AddLoftSrf(profiles_refs, None, None, \n                          2 if is_ruled else 0, 0, 0, is_closed))\n    elif len(rails_refs) == 1:\n        return singleton(rh.AddSweep1(rails_refs[0], profiles_refs))\n    elif len(rails_refs) == 2:\n        return singleton(rh.AddSweep2(rails_refs, profiles_refs))\n    elif len(rails_refs) > 2:\n        print('Warning: Rhino only supports two rails but were passed {0}'.format(len(rails)))\n        return singleton(rh.AddSweep2(rails_refs[:2], profiles_refs))\n    else: #Remove?\n        raise RuntimeError('Rhino only supports two rails but were passed {0}'.format(len(rails)))\n\ndef loft_profiles(profiles, rails, is_solid, is_ruled, is_closed):\n    r = loft_profiles_aux(profiles, rails, is_ruled, is_closed)\n    if is_solid:\n        rh.CapPlanarHoles(r)\n    return and_delete(r, *(profiles + rails))\n\ndef loft_curves(profiles, rails, is_ruled=False, is_closed=False):\n    return loft_profiles(profiles, rails, False, is_ruled, is_closed)\n\ndef loft_surfaces(profiles, rails, is_ruled=False, is_closed=False):\n    return loft_profiles(map(surface_boundary, profiles), rails, True, is_ruled, is_closed)\n\n@shape_constructor(shape)\ndef lofted(profiles, rails=[], is_ruled=False, is_closed=False):\n    if all(map(is_curve, profiles)):\n        return loft_curves(profiles, rails, is_ruled, is_closed)\n    elif all(map(is_surface, profiles)):\n        return loft_surfaces(profiles, rails, is_ruled, is_closed)\n    elif len(profiles) == 2:\n        assert(rails == [])\n        p, s = profiles[0], profiles[1]\n        if is_point(p):\n            pass\n        elif is_point(s):\n            p, s = s, p\n        else:\n            raise RuntimeError(\"{0}: cross sections are not either points or curves or surfaces {1}\".format('loft_shapes', profiles))\n        if is_curve(s):\n            return loft_curve_point(s, p)\n        elif is_surface(s):\n            return loft_surface_point(s, p)\n        else:\n            raise RuntimeError(\"{0}: can't loft the shapes {1}\".format('loft_shapes', profiles))\n    else:\n        raise RuntimeError(\"{0}: cross sections are neither points nor curves nor surfaces  {1}\".format('loft_shapes', profiles))\n\ndef loft(profiles, rails=[], is_ruled=False, is_closed=False):\n    if len(profiles) == 1:\n        raise RuntimeError(quote(loft), 'just one cross section')\n    elif all(map(is_point, profiles)):\n        assert(rails == [])\n        func = ((polygon if is_closed else line) \n                if is_ruled \n                else (closed_spline if is_closed else spline))\n        polygon if is_closed else line if is_ruled else closed_spline if is_closed else spline\n        return and_delete(func([p.position for p in profiles]),\n                          *profiles)\n    else:\n        return lofted(profiles, rails, is_ruled, is_closed)\n\ndef loft_ruled(profiles):\n    return loft(profiles, [], True)\n\n@shape_constructor(shape)\ndef move(shape, translation=vx()):\n    v = Vt(translation)\n    ref = shape.realize()\n    ref.do(lambda r: rh.MoveObject(r, v))\n    shape.mark_deleted()\n    return ref\n\n@shape_constructor(shape)\ndef rotate(shape, rotation_angle=pi/2, axis_center=u0(), axis_vector=vz()):\n    if isinstance(axis_vector, loc):\n        axis_vector = axis_vector - axis_center\n    p = Pt(axis_center)\n    v = Vt(axis_vector)\n    xform = geo.Transform.Rotation(rotation_angle, v, p)\n    ref = shape.realize()\n    ref.do(lambda r: db.Transform(r, xform, True))\n    shape.mark_deleted()\n    return ref\n\n@shape_constructor(shape)\ndef scale(shape, scale=1.0, center=u0()):\n    p = Pt(center)\n    s = [scale, scale, scale]\n    ref = shape.realize()\n    ref.do(lambda r: rh.ScaleObject(r, p, s, False))\n    shape.mark_deleted()\n    return ref\n\n@shape_constructor(shape)\ndef mirror(shape, plane_position=u0(), plane_normal=vz(), copy=True):\n    p = Pt(plane_position)\n    v = Vt(plane_normal)\n    xform = rh.XformMirror(p, v)\n    ref = shape.realize()\n    new_ref = ref.map(lambda r: native_ref(rh.TransformObject(r, xform, copy)))\n    if not copy:\n        shape.mark_deleted()\n    return new_ref\n\ndef union_mirror(shape, plane_position=u0(), plane_normal=vz()):\n    return union(shape, mirror(shape, plane_position, plane_normal, True))\n\n@shape_constructor(surface)\ndef surface_grid(ptss, closed_u=False, closed_v=False):\n    if closed_v:\n        ptss = [pts + [pts[0]] for pts in ptss]\n    if closed_u:\n        ptss = ptss + [ptss[0]]\n    if len(ptss) == 2 and len(ptss[0]) == 2:\n        return rh.AddSrfPt(ptss[0] + ptss[1])\n    else:\n        if len(ptss) == 2:\n            ptss = [ptss[0], map(intermediate_loc, ptss[0], ptss[1]), ptss[1]]\n        elif len(ptss[0]) == 2:\n            ptss = map(lambda cs: [cs[0], intermediate_loc(cs[0], cs[1]), cs[1]], ptss)\n        ps = [Pt(pt) for pts in ptss for pt in pts]\n        nu = len(ptss)\n        nv = len(ptss[0])\n        return rh.AddSrfPtGrid((nu, nv),\n                               ps,\n                               (max(2*int(nu/10)+1,2), max(2*int(nv/10)+1,2)),\n                               (closed_u, closed_v))\n\n@shape_constructor(solid)\ndef thicken(surf, h=1):\n    s = rh.OffsetSurface(surf.realize()._ref, h, None, True, True)\n    if not s:\n        rh.UnselectAllObjects()\n        rh.SelectObjects(surf.refs())\n        rh.Command(\"OffsetSrf BothSides=Yes Solid=Yes {0} _Enter\".format(h))\n        s = single_ref_or_union(rh.LastCreatedObjects())\n    surf.delete()\n    return s\n\n\n\ndef map_surface_division(f, surface, nu, nv, include_last_u=True, include_last_v=True):\n    id = surface.realize()._ref\n    domain_u = rh.SurfaceDomain(id, 0)\n    domain_v = rh.SurfaceDomain(id, 1)\n    start_u = domain_u[0]\n    end_u = domain_u[1]\n    start_v = domain_v[0]\n    end_v = domain_v[1]\n    def surf_f(u, v):\n        plane = rh.SurfaceFrame(id, (u, v))\n        if rh.IsPointOnSurface(id, plane.Origin):\n            return f(fromPlane(plane))\n        else:\n            return False\n    return map_division(surf_f,\n                        start_u, end_u, nu, include_last_u,\n                        start_v, end_v, nv, include_last_v)\n\n# All shape constructors are defined. Transfer selectors and recognizers to this module\n\nglobals().update(shape_ops)\n\n\ndef delete_shapes(shapes):\n    for shape in shapes:\n        shape.delete()\n    vs.Redraw()\n\ndef delete_shape(shape):\n    shape.delete()\n    vs.Redraw()\n\ndef delete_all_shapes():\n    for id in db.GetObjectList(Rhino.DocObjects.ObjectEnumeratorSettings()):\n        db.Delete(id, True)\n    vs.Redraw()\n\ndef view(camera=False, target=False, lens=False):\n    if camera and target and lens:\n        if not rh.IsViewMaximized(\"Perspective\"):\n            rh.MaximizeRestoreView(\"Perspective\")\n        rh.ViewProjection(\"Perspective\", 2)\n        rh.ViewCameraLens(\"Perspective\", lens)\n        rh.ViewCameraTarget(\"Perspective\", Pt(camera), Pt(target))\n        rh.ViewDisplayMode(\"Perspective\", \"Shaded\")\n        vs.Redraw()\n        return (camera, target, lens)\n    else:\n        rh.CurrentView(\"Perspective\")\n        camera, target, lens = rh.ViewCamera(), rh.ViewTarget(), rh.ViewCameraLens()\n        return (fromPt(camera), fromPt(target), lens)\n\ndef view_top():\n    if not rh.IsViewMaximized(\"Top\"):\n        rh.MaximizeRestoreView(\"Top\")\n    rh.ViewProjection(\"Top\", 1)\n    rh.ViewDisplayMode(\"Top\", \"Wireframe\")\n    vs.Redraw()\n\ndef zoom_extents():\n    rh.ZoomExtents(None, True)\n\ndef render_view(str):\n    rh.RenderResolution([render_width(), render_height()])\n    rh.Command(\"_-Render\", False)\n    rh.Command('_-SaveRenderWindowAs \"{0}\"'.format(ensure_dir(render_pathname(str))), False)\n    rh.Command(\"_-CloseRenderWindow\", False)\n\ndef render_stereo_view(str):\n    pass\n\ndef save_film_frame(obj=None):\n    with render_kind_dir('Film'):\n        render_view(frame_filename(film_filename(), film_frame()))\n        film_frame(film_frame() + 1)\n        return obj\n\ndef random_integer_range(*args):\n    return random_range(*args)\n\ndef prompt_point(str=\"Select point\"):\n    return rh.GetPoint(str)\n\ndef prompt_integer(str=\"Integer?\"):\n    return rh.GetInteger(str)\n\ndef prompt_real(str=\"Real?\"):\n    return rh.GetReal(str)\n\ndef prompt_shape(str=\"Select shape\"):\n    sh = rh.GetObject(str)\n    if sh:\n        return shape_from_ref(sh)\n    else:\n        return empty_shape()\n\ndef get_shape_named(name):\n    return shape_from_ref(rh.ObjectsByName(name, False, False, False)[0])\n\ndef bounding_box(s):\n    return [fromPt(p) for p in rh.BoundingBox([s.refs()])]\n\ndef rhino_rgb_from_rgb(c):\n    return ((c.red << 0) +\n            (c.green << 8) +\n            (c.blue << 16))\n\ndef rgb_from_rhino_rgb(rc):\n    return rgb(rh.ColorRedValue(rc),\n               rh.ColorGreenValue(rc),\n               rh.ColorBlueValue(rc))\n\ndef shape_color(sh, color=None):\n    if color:\n        color = rhino_rgb_from_rgb(color)\n        sh.realize().do(lambda r: rh.ObjectColor(r, color))\n        return sh\n    else:\n        return rh.ObjectColor(sh.ref())\n\n# layers\ncreate_layer = rh.AddLayer\n\nclass current_layer(object):\n    def __init__(self, layer):\n        self.layer = layer\n        self.previous_layer = None\n\n    def __enter__(self):\n        self.previous_layer = rh.CurrentLayer(self.layer)\n        return self.layer\n\n    def __exit__(self, type, value, traceback):\n        rh.CurrentLayer(self.previous_layer)\n\ndef shape_layer(shape, layer=None):\n    if layer:\n        shape.realize().do(lambda r: rh.ObjectLayer(r, layer))\n    else:\n        return rh.ObjectLayer(shape.realize()._ref)\n\ndef shape_from_ref(r):\n    with parameter(immediate_mode, False):\n        obj = _geometry_from_id(r)\n        ref = native_ref(r)\n        if isinstance(obj, geo.Point):\n            return point.new_ref(ref, fromPt(obj.Location))\n        elif isinstance(obj, geo.Curve):\n            if rh.IsLine(r) or rh.IsPolyline(r):\n                if rh.IsCurveClosed(r):\n                    return polygon.new_ref(ref, [fromPt(p) for p in rh.CurvePoints(r)[:-1]])\n                else:\n                    return line.new_ref(ref, [fromPt(p) for p in rh.CurvePoints(r)])\n            elif obj.IsCircle(Rhino.RhinoMath.ZeroTolerance):\n                return circle.new_ref(ref, fromPt(rh.CircleCenterPoint(r)), rh.CircleRadius(r))\n            elif rh.IsCurveClosed(r):\n                return closed_spline.new_ref(ref, [fromPt(p) for p in rh.CurvePoints(r)])\n            else:\n                return spline.new_ref(ref, [fromPt(p) for p in rh.CurvePoints(r)])\n        elif rh.IsObject(r) and rh.IsObjectSolid(r):\n            return solid(native_ref(r))\n        elif rh.IsSurface(r) or rh.IsPolysurface(r):\n            return surface(native_ref(r))\n        else:\n            raise RuntimeError(\"{0}: Unknown Rhino object {1}\".format('shape_from_ref', r))\n\ndef all_shapes():\n    return [shape_from_ref(r) for r in rh.AllObjects()]\n\n# For testing\ngenerate_mode(False)\n\nclass model(meta_model('meta_model', (object,), {})):\n    def setup(self):\n        delete_all_shapes()\n        view_top()\n    def wait(self):\n        if not prompt_point(\"Click to advance, ESC to cancel\"):\n            raise RuntimeError(\"Stopped!\")\n\nclass film(meta_model('meta_model', (object,), {})):\n    def setup(self):\n        delete_all_shapes()\n        view_top()\n    def wait(self):\n        if not prompt_point(\"Click to advance, ESC to cancel\"):\n            raise RuntimeError(\"Stopped!\")\n\ngenerate_mode(True)\nstep_mode(True)\n########TESTS#######\n\n#import time\n#t = time.clock()\n#cidadeEspacial(u0(), 8)\n#print time.clock() - t\n\n\nif( __name__ == '__main__' ):\n    print(\"The Khepri library is not intended to be executed, just imported\")\n\n\ndef zoom_2d_top():\n    view_top()\n    zoom_extents()\n\ndef reset():\n    pass\n\ndef view_with_background(camera, target, lens):\n    return view(camera, target, lens)\n\ngenerate_mode(True)\nstep_mode(False)\nimmediate_mode(True)\n\n\ndef brep_subbreps(object_id):\n    brep = _brep_from_id(object_id)\n    ids = []\n    for face in brep.Faces:\n        newbrep = face.DuplicateFace(True)\n        id = scriptcontext.doc.Objects.AddBrep(newbrep)\n        ids.append(id)\n    return ids\n\ndef shape_surfaces(shape):\n    ref = shape.realize()\n    return ref.map(lambda r: map(shape_from_ref, brep_subbreps(r)))\n\ndef shape_edges(shape):\n    ref = shape.realize()\n    return ref.map(lambda r: map(shape_from_ref, rh.DuplicateEdgeCurves(r)))\n\ndef shape_vertices(shape):\n    pts = []\n    for edge in shape_edges(shape):\n        r = edge.ref()\n        pt = rh.CurveStartPoint(r)\n        if pt not in pts:\n            pts.append(pt)\n        pt = rh.CurveEndPoint(r)\n        if pt not in pts:\n            pts.append(pt)\n    return map(fromPt, pts)\n\ndef show_vertices(shape):\n    map(lambda p: sphere(p, 0.05), shape_vertices(shape))\n\n#delete_all_shapes()\n#show_vertices(sphere())\n\n\n# BIM stuff\n\ndef load_beam_family(path, *args):\n    return False\n\ndef load_column_family(path, *args):\n    return False\n\ndef level(h):\n    return h\n\ndef level_height(h):\n    return h\n\ncurrent_level = make_parameter(level(0))\ndefault_level_to_level_height = make_parameter(3)\n\ndef upper_level(lvl=None, height=None):\n    lvl = lvl or current_level();\n    height = height or default_level_to_level_height()\n    return level(level_height(lvl) + height)\n\n\n\nimport collections\ndef Record(typename, **fields_dict):\n    T = collections.namedtuple(typename, ' '.join(fields_dict.keys()))\n    T.__new__.__defaults__ = tuple(fields_dict.values())\n    return T\n\nBeam_Family = Record('Beam_Family', path='', map={}, layer=False, width=0.1, height=0.1, profile=False, material=False)\ndefault_beam_family = make_parameter(Beam_Family())\n\nColumn_Family = Record('Column_Family', path='', map={}, layer=False, width=0.1, depth=False, is_section_circular=False)\ndefault_column_family = make_parameter(Column_Family())\n\nSlab_Family = Record('Slab_Family', path='', map={}, layer=False, thickness=0.3, coating_thickness=0)\ndefault_slab_family = make_parameter(Slab_Family())\n\nRoof_Family = Record('Roof_Family', path='', map={}, layer=False, thickness=0.3, coating_thickness=0)\ndefault_roof_family = make_parameter(Roof_Family())\n\nWall_Family = Record('Wall_Family', path='', map={}, layer=False, thickness=0.3)\ndefault_wall_family = make_parameter(Wall_Family())\n\nPanel_Family = Record('Panel_Family', path='', map={}, layer=False, thickness=0.01, material='Glass')\ndefault_panel_family = make_parameter(Panel_Family())\n\ndef is_vertical(p0, p1):\n    return (p0-p1).cyl_rho < 1e-10\n\ncreate_bim_layers = make_parameter(True)\n\ndef bim_shape_layer(shape, layer = None):\n    if layer:\n        if create_bim_layers():\n            return shape_layer(shape, layer)\n    else:\n        return shape_layer(shape)\n\ndef shape_reference(s):\n    return s.realize()._ref\n\n@shape_constructor(solid)\ndef beam(p0, p1, angle=0, family=None):\n    family = family or default_beam_family()\n    h, w = family.height, family.width\n    if is_vertical(p0, p1):\n        s = right_cuboid(p0, w, h, p1, angle)\n    else:\n        cb, dz = base_and_height(p0, p1)\n        s = right_cuboid(loc_in_world(cb + vy(-(h/2))),\n                         family.width,\n                         h,\n                         loc_in_world(cb + vyz(-(h/2), dz)),\n                         angle)\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n    \n@shape_constructor(solid)\ndef column(center, bottom_level=None, top_level=None, family=None):\n    bottom_level = bottom_level or current_level()\n    top_level = top_level or upper_level(bottom_level)\n    family = family or default_column_family()\n    width = family.width\n    s = box(center + vxyz(-(width/2), -(width/2), level_height(bottom_level)),\n            width,\n            width,\n            level_height(top_level) - level_height(bottom_level))\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n\n@shape_constructor(solid)\ndef slab(vertices, level=None, family=None):\n    level = level or current_level()\n    family = family or default_slab_family()\n    if is_list(vertices) and is_loc(vertices[0]):\n        v = vz(level_height(level) - \n               family.thickness +\n               family.coating_thickness)\n        s = irregular_prism(map(lambda p: p + v, vertices),\n                            family.thickness)\n        bim_shape_layer(s, family.layer)\n        return shape_reference(s)\n    else:\n        path = vertices if is_list(vertices) else [vertices]\n        def loop(p):\n            if p == []:\n                return []\n            else:\n                e = p[0]\n                if not len(p) == 1:\n                    raise RuntimeError('Unfinished')\n                if is_line(e):\n                    raise RuntimeError('Unfinished')\n                elif is_polygon(e):\n                    vertices = polygon_vertices(e)\n                    v = vz(level_height(level) -\n                           family.thickness +\n                           family.coating_thickness)\n                    s = irregular_prism(map(lambda p: p + v, vertices),\n                                        family.thickness)\n                    bim_shape_layer(s, family.layer)\n                    return shape_reference(s)\n                elif is_arc(e):\n                    raise RuntimeError('Unfinished')\n                elif is_circle(e):\n                    s = extrusion(surface_circle(circle_center(e) +\n                                                 vz(-circle_center(e).z) +\n                                                 vz(level_height(level)),\n                                                 circle_radius(e)),\n                                  vz(family.coating_thickness - family.thickness))\n                    bim_shape_layer(s, family.layer)\n                    return shape_reference(s)\n                else:\n                    raise RuntimeError('Unknown path component', e)\n        return loop(path)\n\n@shape_constructor(solid)\ndef slab_opening(slab_id, path):\n    layer = bim_shape_layer(slab_id)\n    s = subtraction(slab_id, slab(path, slab_level(slab_id), slab_family(slab_id)))\n    bim_shape_layer(s, layer)\n    return shape_reference(s)\n\n@shape_constructor(solid)\ndef roof(vertices, level=None, family=None):\n    level = level or current_level()\n    family = family or default_roof_family()\n    v = vz(level_height(level) - family.thickness + family.coating_thickness)\n    s = irregular_prism(map(lambda p: p + v, vertices), family.thickness)\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n\n@shape_constructor(solid)\ndef wall(p0, p1, bottom_level=None, top_level=None, family=None):\n    bottom_level = bottom_level or current_level()\n    top_level = top_level or upper_level(bottom_level)\n    family = family or default_wall_family()\n    base_height = level_height(bottom_level)\n    h = level_height(top_level) - base_height\n    z = base_height + h/2\n    s = right_cuboid(p0 + vz(z), family.thickness, h, p1 + vz(z))\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n  \n@shape_constructor(solid)\ndef walls(vertices, bottom_level=None, top_level=None, family=None):\n    bottom_level = bottom_level or current_level()\n    top_level = top_level or upper_level(bottom_level)\n    family = family or default_wall_family()\n    v = vz(level_height(bottom_level))\n    s = thicken(extrusion(line(map(lambda p: p + v, vertices)),\n                          level_height(top_level) - level_height(bottom_level)),\n                family.thickness)\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n\n@shape_constructor(solid)\ndef door(wall, loc, family=None):\n    family = family or default_door_family()\n    wall_e = walls_family(wall).thickness\n    wall_level = walls_bottom_level(wall)\n    return shape_reference(\n        subtraction(wall, box(loc + vz(level_height(wall_level)),\n                              family.width,\n                              wall_e, family.height)))\n\n@shape_constructor(solid)\ndef panel(vertices, level=None, family=None):\n    level = level or current_level()\n    family = family or default_panel_family()\n    p0, p1, p2 = vertices[1], vertices[0], vertices[2]\n    n = vz(family.thickness/2, cs_from_o_vx_vy(p0, p1 - p0, p2 - p0))\n    s = irregular_prism(map(lambda v: loc_in_world(v - n), vertices), vec_in_world(n*2))\n    bim_shape_layer(s, family.layer)\n    return shape_reference(s)\n\n\ndef slab_rectangle(p, len, width, level=None, family=None):\n    level = level or current_level()\n    family = family or default_slab_family()\n    return slab([p, p + vx(len), p + vxy(len, width), p + vy(width)], level, family)\n  \ndef roof_rectangle(p, len, width, level=None, family=None):\n    level = level or current_level()\n    family = family or default_roof_family()\n    return roof([p, p + vx(len), p + vxy(len, width), p + vy(width)], level, family)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}