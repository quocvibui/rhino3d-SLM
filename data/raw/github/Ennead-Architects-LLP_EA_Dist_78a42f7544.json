{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/lib/DumpScripts/headless_rhino.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/lib/DumpScripts/headless_rhino.py",
  "instruction": "Rhino.Inside.Cpython Generation Functions Collection\r\n15 Interesting and Fun Generation Functions for Parametric Design and Computational Geometry\r\n\r\nThis script demonstrates various capabilities of...",
  "code": "\"\"\"\r\nRhino.Inside.Cpython Generation Functions Collection\r\n15 Interesting and Fun Generation Functions for Parametric Design and Computational Geometry\r\n\r\nThis script demonstrates various capabilities of Rhino.Inside.Cpython for:\r\n- Parametric modeling\r\n- Generative art\r\n- Computational geometry\r\n- Nature-inspired forms\r\n- Mathematical visualizations\r\n- Architectural elements\r\n\"\"\"\r\n\r\nimport rhinoinside\r\nrhinoinside.load()\r\n\r\nimport System\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport math\r\nimport random\r\nimport os\r\n\r\n# Initialize Rhino document\r\ndoc = Rhino.RhinoDoc.CreateHeadless(None)\r\n\r\ndef clear_document():\r\n    \"\"\"Clear all objects from the document\"\"\"\r\n    doc.Objects.Clear()\r\n\r\ndef save_and_open_file(filename):\r\n    \"\"\"Save the current document and add to files to open\"\"\"\r\n    desktop_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\r\n    rhino_auto_folder = os.path.join(desktop_path, \"RhinoAuto\")\r\n    \r\n    # Create RhinoAuto folder if it doesn't exist\r\n    if not os.path.exists(rhino_auto_folder):\r\n        os.makedirs(rhino_auto_folder)\r\n    \r\n    file_path = os.path.join(rhino_auto_folder, f\"{filename}.3dm\")\r\n    \r\n    try:\r\n        # Write the current document directly\r\n        doc.WriteFile(file_path, None)\r\n        return file_path\r\n    except:\r\n        # Alternative approach - create simple 3dm file with object data\r\n        try:\r\n            import Rhino.FileIO as rf\r\n            file3dm = rf.File3dm()\r\n            \r\n            # Add all objects to the file\r\n            for obj in doc.Objects:\r\n                if obj.Geometry:\r\n                    # Create object attributes\r\n                    attrs = Rhino.DocObjects.ObjectAttributes()\r\n                    # Add based on geometry type\r\n                    if isinstance(obj.Geometry, rg.Brep):\r\n                        file3dm.Objects.AddBrep(obj.Geometry, attrs)\r\n                    elif isinstance(obj.Geometry, rg.Mesh):\r\n                        file3dm.Objects.AddMesh(obj.Geometry, attrs)\r\n                    elif isinstance(obj.Geometry, rg.Curve):\r\n                        file3dm.Objects.AddCurve(obj.Geometry, attrs)\r\n                    elif isinstance(obj.Geometry, rg.NurbsCurve):\r\n                        file3dm.Objects.AddCurve(obj.Geometry, attrs)\r\n            \r\n            # Write the file\r\n            file3dm.Write(file_path, 7)  # Write as Rhino 7 format\r\n            return file_path\r\n        except Exception as e:\r\n            print(f\"     Warning: Could not save {filename}: {str(e)}\")\r\n            return None\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 1: FIBONACCI SPIRAL TOWER\r\n# =====================================================================\r\ndef generate_fibonacci_spiral_tower():\r\n    \"\"\"Generate a tower based on Fibonacci spiral with varying radii\"\"\"\r\n    clear_document()\r\n    \r\n    fibonacci_numbers = [1, 1]\r\n    for i in range(2, 20):\r\n        fibonacci_numbers.append(fibonacci_numbers[i-1] + fibonacci_numbers[i-2])\r\n    \r\n    center = rg.Point3d(0, 0, 0)\r\n    \r\n    for i, fib_num in enumerate(fibonacci_numbers):\r\n        angle = i * 137.5 * math.pi / 180  # Golden angle\r\n        radius = fib_num * 0.5\r\n        height = i * 2\r\n        \r\n        x = radius * math.cos(angle)\r\n        y = radius * math.sin(angle)\r\n        circle_center = rg.Point3d(x, y, height)\r\n        \r\n        circle = rg.Circle(circle_center, fib_num * 0.3)\r\n        cylinder = rg.Cylinder(circle, 1.5)\r\n        brep = cylinder.ToBrep(True, True)\r\n        \r\n        doc.Objects.AddBrep(brep)\r\n    \r\n    print(\"Generated Fibonacci Spiral Tower!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 2: VORONOI CITYSCAPE\r\n# =====================================================================\r\ndef generate_voronoi_cityscape():\r\n    \"\"\"Generate a cityscape using Voronoi patterns for building placement\"\"\"\r\n    clear_document()\r\n    \r\n    # Generate random seed points\r\n    seed_points = []\r\n    for i in range(50):\r\n        x = random.uniform(-50, 50)\r\n        y = random.uniform(-50, 50)\r\n        seed_points.append(rg.Point3d(x, y, 0))\r\n    \r\n    # Create buildings at each seed point\r\n    for point in seed_points:\r\n        width = random.uniform(2, 8)\r\n        depth = random.uniform(2, 8)\r\n        height = random.uniform(5, 30)\r\n        \r\n        # Create building base\r\n        corner1 = rg.Point3d(point.X - width/2, point.Y - depth/2, 0)\r\n        corner2 = rg.Point3d(point.X + width/2, point.Y + depth/2, height)\r\n        \r\n        box = rg.Box(rg.BoundingBox(corner1, corner2))\r\n        building = box.ToBrep()\r\n        \r\n        doc.Objects.AddBrep(building)\r\n    \r\n    print(\"Generated Voronoi Cityscape!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 3: PARAMETRIC WAVE SURFACE\r\n# =====================================================================\r\ndef generate_parametric_wave_surface():\r\n    \"\"\"Generate a complex wave surface using mathematical functions\"\"\"\r\n    clear_document()\r\n    \r\n    # Create mesh instead of NURBS surface for better compatibility\r\n    mesh = rg.Mesh()\r\n    \r\n    # Generate vertices\r\n    for u in range(0, 51, 2):\r\n        for v in range(0, 51, 2):\r\n            x = u * 0.5\r\n            y = v * 0.5\r\n            z = 5 * math.sin(x * 0.2) * math.cos(y * 0.2) + 2 * math.sin(x * 0.5) * math.sin(y * 0.3)\r\n            mesh.Vertices.Add(rg.Point3d(x, y, z))\r\n    \r\n    # Create faces\r\n    cols = 26  # (51//2 + 1)\r\n    rows = 26\r\n    \r\n    for i in range(rows - 1):\r\n        for j in range(cols - 1):\r\n            v0 = i * cols + j\r\n            v1 = i * cols + (j + 1)\r\n            v2 = (i + 1) * cols + (j + 1)\r\n            v3 = (i + 1) * cols + j\r\n            \r\n            mesh.Faces.AddFace(v0, v1, v2, v3)\r\n    \r\n    mesh.Normals.ComputeNormals()\r\n    mesh.Compact()\r\n    \r\n    doc.Objects.AddMesh(mesh)\r\n    \r\n    print(\"Generated Parametric Wave Surface!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 4: FRACTAL TREE GENERATOR\r\n# =====================================================================\r\ndef generate_fractal_tree():\r\n    \"\"\"Generate a 3D fractal tree using recursive branching\"\"\"\r\n    clear_document()\r\n    \r\n    def create_branch(start_point, direction, length, depth, angle_variation):\r\n        if depth <= 0 or length < 0.5:\r\n            return\r\n        \r\n        # Calculate end point\r\n        end_point = start_point + direction * length\r\n        \r\n        # Create branch cylinder\r\n        branch_radius = length * 0.05\r\n        circle = rg.Circle(start_point, branch_radius)\r\n        \r\n        # Create cylinder with proper height vector\r\n        height_vector = rg.Vector3d(end_point - start_point)\r\n        cylinder = rg.Cylinder(circle, height_vector.Length)\r\n        \r\n        # Transform cylinder to correct orientation\r\n        brep = cylinder.ToBrep(True, True)\r\n        \r\n        # Create transformation to align cylinder\r\n        if height_vector.Length > 0:\r\n            height_vector.Unitize()\r\n            z_axis = rg.Vector3d.ZAxis\r\n            rotation = rg.Transform.Rotation(z_axis, height_vector, start_point)\r\n            brep.Transform(rotation)\r\n        \r\n        doc.Objects.AddBrep(brep)\r\n        \r\n        # Create child branches\r\n        num_branches = random.randint(2, 4)\r\n        for i in range(num_branches):\r\n            # Random rotation around Z axis\r\n            rotation_angle = random.uniform(-angle_variation, angle_variation)\r\n            bend_angle = random.uniform(-30, 30) * math.pi / 180\r\n            \r\n            # Create new direction\r\n            new_direction = rg.Vector3d(direction)\r\n            new_direction.Rotate(rotation_angle * math.pi / 180, rg.Vector3d.ZAxis)\r\n            \r\n            # Cross product for bend rotation\r\n            cross = rg.Vector3d.CrossProduct(new_direction, rg.Vector3d.ZAxis)\r\n            if cross.Length > 0:\r\n                cross.Unitize()\r\n                new_direction.Rotate(bend_angle, cross)\r\n            \r\n            # Recursive call\r\n            new_length = length * random.uniform(0.6, 0.8)\r\n            create_branch(end_point, new_direction, new_length, depth - 1, angle_variation * 1.2)\r\n    \r\n    # Start the tree\r\n    start_point = rg.Point3d(0, 0, 0)\r\n    initial_direction = rg.Vector3d(0, 0, 1)\r\n    create_branch(start_point, initial_direction, 10, 6, 45)\r\n    \r\n    print(\"Generated Fractal Tree!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 5: GEODESIC DOME VARIATIONS\r\n# =====================================================================\r\ndef generate_geodesic_dome_variations():\r\n    \"\"\"Generate multiple geodesic dome variations\"\"\"\r\n    clear_document()\r\n    \r\n    def create_geodesic_dome(center, radius, frequency):\r\n        # Create icosahedron base\r\n        phi = (1 + math.sqrt(5)) / 2  # Golden ratio\r\n        \r\n        vertices = [\r\n            rg.Point3d(-1, phi, 0), rg.Point3d(1, phi, 0), rg.Point3d(-1, -phi, 0), rg.Point3d(1, -phi, 0),\r\n            rg.Point3d(0, -1, phi), rg.Point3d(0, 1, phi), rg.Point3d(0, -1, -phi), rg.Point3d(0, 1, -phi),\r\n            rg.Point3d(phi, 0, -1), rg.Point3d(phi, 0, 1), rg.Point3d(-phi, 0, -1), rg.Point3d(-phi, 0, 1)\r\n        ]\r\n        \r\n        # Normalize and scale vertices\r\n        normalized_vertices = []\r\n        for v in vertices:\r\n            # Calculate vector from origin\r\n            vector = rg.Vector3d(v.X, v.Y, v.Z)\r\n            vector.Unitize()\r\n            normalized_point = center + vector * radius\r\n            normalized_vertices.append(normalized_point)\r\n        \r\n        # Create sphere at each vertex\r\n        for vertex in normalized_vertices:\r\n            sphere = rg.Sphere(vertex, radius * 0.05)\r\n            brep = sphere.ToBrep()\r\n            doc.Objects.AddBrep(brep)\r\n    \r\n    # Create multiple domes\r\n    positions = [\r\n        rg.Point3d(0, 0, 0),\r\n        rg.Point3d(25, 0, 0),\r\n        rg.Point3d(-25, 0, 0),\r\n        rg.Point3d(0, 25, 0),\r\n        rg.Point3d(0, -25, 0)\r\n    ]\r\n    \r\n    for i, pos in enumerate(positions):\r\n        create_geodesic_dome(pos, 8 + i * 2, i + 1)\r\n    \r\n    print(\"Generated Geodesic Dome Variations!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 6: LISSAJOUS CURVES IN 3D\r\n# =====================================================================\r\ndef generate_lissajous_curves_3d():\r\n    \"\"\"Generate 3D Lissajous curves with varying parameters\"\"\"\r\n    clear_document()\r\n    \r\n    def create_lissajous_curve(a, b, c, delta_x, delta_y, delta_z, scale, offset):\r\n        points = []\r\n        for t in range(0, 1000):\r\n            t_rad = t * 2 * math.pi / 100\r\n            \r\n            x = scale * math.sin(a * t_rad + delta_x) + offset.X\r\n            y = scale * math.sin(b * t_rad + delta_y) + offset.Y\r\n            z = scale * math.sin(c * t_rad + delta_z) + offset.Z\r\n            \r\n            points.append(rg.Point3d(x, y, z))\r\n        \r\n        # Create NURBS curve \r\n        if len(points) > 1:\r\n            # Convert to Point3d array\r\n            point_array = System.Array[rg.Point3d](points)\r\n            curve = rg.Curve.CreateInterpolatedCurve(point_array, 3)\r\n            if curve:\r\n                doc.Objects.AddCurve(curve)\r\n    \r\n    # Generate multiple Lissajous curves\r\n    configurations = [\r\n        (3, 2, 1, 0, math.pi/2, 0, 10, rg.Point3d(0, 0, 0)),\r\n        (5, 3, 2, math.pi/4, 0, math.pi/3, 8, rg.Point3d(30, 0, 0)),\r\n        (4, 3, 5, 0, math.pi/3, math.pi/6, 6, rg.Point3d(-30, 0, 0)),\r\n        (7, 5, 3, math.pi/6, math.pi/4, math.pi/2, 4, rg.Point3d(0, 30, 0)),\r\n    ]\r\n    \r\n    for config in configurations:\r\n        create_lissajous_curve(*config)\r\n    \r\n    print(\"Generated 3D Lissajous Curves!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 7: CELLULAR AUTOMATA STRUCTURES\r\n# =====================================================================\r\ndef generate_cellular_automata_structures():\r\n    \"\"\"Generate 3D structures based on cellular automata rules\"\"\"\r\n    clear_document()\r\n    \r\n    def apply_rule(neighbors):\r\n        \"\"\"Simple rule: cell survives if it has 2-3 neighbors\"\"\"\r\n        alive_count = sum(neighbors)\r\n        return 1 if alive_count in [2, 3] else 0\r\n    \r\n    # Initialize 3D grid\r\n    size = 20\r\n    grid = [[[random.randint(0, 1) for _ in range(size)] for _ in range(size)] for _ in range(size)]\r\n    \r\n    # Apply cellular automata rules for a few iterations\r\n    for iteration in range(3):\r\n        new_grid = [[[0 for _ in range(size)] for _ in range(size)] for _ in range(size)]\r\n        \r\n        for x in range(1, size-1):\r\n            for y in range(1, size-1):\r\n                for z in range(1, size-1):\r\n                    # Count neighbors\r\n                    neighbors = []\r\n                    for dx in [-1, 0, 1]:\r\n                        for dy in [-1, 0, 1]:\r\n                            for dz in [-1, 0, 1]:\r\n                                if dx == 0 and dy == 0 and dz == 0:\r\n                                    continue\r\n                                neighbors.append(grid[x+dx][y+dy][z+dz])\r\n                    \r\n                    new_grid[x][y][z] = apply_rule(neighbors)\r\n        \r\n        grid = new_grid\r\n    \r\n    # Create geometry for alive cells\r\n    for x in range(size):\r\n        for y in range(size):\r\n            for z in range(size):\r\n                if grid[x][y][z] == 1:\r\n                    center = rg.Point3d(x, y, z)\r\n                    sphere = rg.Sphere(center, 0.4)\r\n                    brep = sphere.ToBrep()\r\n                    doc.Objects.AddBrep(brep)\r\n    \r\n    print(\"Generated Cellular Automata Structures!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 8: TWISTED SPIRE COLLECTION\r\n# =====================================================================\r\ndef generate_twisted_spire_collection():\r\n    \"\"\"Generate a collection of twisted spires with varying parameters\"\"\"\r\n    clear_document()\r\n    \r\n    def create_twisted_spire(base_center, base_radius, height, twist_angle, sides):\r\n        # Create base profile\r\n        points = []\r\n        for i in range(sides):\r\n            angle = 2 * math.pi * i / sides\r\n            x = base_center.X + base_radius * math.cos(angle)\r\n            y = base_center.Y + base_radius * math.sin(angle)\r\n            points.append(rg.Point3d(x, y, base_center.Z))\r\n        \r\n        points.append(points[0])  # Close the curve\r\n        point_array = System.Array[rg.Point3d](points)\r\n        base_curve = rg.Curve.CreateInterpolatedCurve(point_array, 3)\r\n        \r\n        # Create top profile (smaller and twisted)\r\n        top_points = []\r\n        top_radius = base_radius * 0.1\r\n        for i in range(sides):\r\n            angle = 2 * math.pi * i / sides + twist_angle\r\n            x = base_center.X + top_radius * math.cos(angle)\r\n            y = base_center.Y + top_radius * math.sin(angle)\r\n            top_points.append(rg.Point3d(x, y, base_center.Z + height))\r\n        \r\n        top_points.append(top_points[0])\r\n        top_point_array = System.Array[rg.Point3d](top_points)\r\n        top_curve = rg.Curve.CreateInterpolatedCurve(top_point_array, 3)\r\n        \r\n        # Create loft\r\n        curve_array = System.Array[rg.Curve]([base_curve, top_curve])\r\n        loft = rg.Brep.CreateFromLoft(curve_array, rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False)\r\n        \r\n        if loft and len(loft) > 0:\r\n            doc.Objects.AddBrep(loft[0])\r\n    \r\n    # Generate multiple spires\r\n    positions = [\r\n        (rg.Point3d(0, 0, 0), 4, 20, math.pi, 6),\r\n        (rg.Point3d(15, 0, 0), 3, 25, math.pi * 1.5, 8),\r\n        (rg.Point3d(-15, 0, 0), 5, 18, math.pi * 0.5, 5),\r\n        (rg.Point3d(0, 15, 0), 2.5, 30, math.pi * 2, 12),\r\n        (rg.Point3d(0, -15, 0), 3.5, 22, math.pi * 0.75, 7),\r\n    ]\r\n    \r\n    for pos, radius, height, twist, sides in positions:\r\n        create_twisted_spire(pos, radius, height, twist, sides)\r\n    \r\n    print(\"Generated Twisted Spire Collection!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 9: PARAMETRIC CORAL REEF\r\n# =====================================================================\r\ndef generate_parametric_coral_reef():\r\n    \"\"\"Generate organic coral-like structures\"\"\"\r\n    clear_document()\r\n    \r\n    def create_coral_branch(start_point, direction, radius, length, depth):\r\n        if depth <= 0 or radius < 0.2:\r\n            return\r\n        \r\n        # Create main branch\r\n        end_point = start_point + direction * length\r\n        \r\n        # Create varying radius along the branch\r\n        sections = 10\r\n        for i in range(sections):\r\n            t = i / float(sections - 1)\r\n            current_radius = radius * (1 - t * 0.3)  # Taper\r\n            section_point = start_point + direction * (length * t)\r\n            \r\n            sphere = rg.Sphere(section_point, current_radius)\r\n            brep = sphere.ToBrep()\r\n            doc.Objects.AddBrep(brep)\r\n        \r\n        # Create sub-branches\r\n        num_branches = random.randint(2, 5)\r\n        for i in range(num_branches):\r\n            branch_start = start_point + direction * (length * random.uniform(0.3, 0.8))\r\n            \r\n            # Random direction with some upward bias\r\n            angle_xy = random.uniform(0, 2 * math.pi)\r\n            angle_z = random.uniform(-math.pi/6, math.pi/3)\r\n            \r\n            new_direction = rg.Vector3d(\r\n                math.cos(angle_xy) * math.cos(angle_z),\r\n                math.sin(angle_xy) * math.cos(angle_z),\r\n                math.sin(angle_z)\r\n            )\r\n            \r\n            new_radius = radius * random.uniform(0.5, 0.8)\r\n            new_length = length * random.uniform(0.6, 0.9)\r\n            \r\n            create_coral_branch(branch_start, new_direction, new_radius, new_length, depth - 1)\r\n    \r\n    # Create multiple coral colonies\r\n    base_points = [\r\n        rg.Point3d(0, 0, 0),\r\n        rg.Point3d(15, 5, 0),\r\n        rg.Point3d(-10, 8, 0),\r\n        rg.Point3d(8, -12, 0),\r\n        rg.Point3d(-15, -5, 0),\r\n    ]\r\n    \r\n    for base_point in base_points:\r\n        initial_direction = rg.Vector3d(0, 0, 1)\r\n        create_coral_branch(base_point, initial_direction, 2, 8, 4)\r\n    \r\n    print(\"Generated Parametric Coral Reef!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 10: HYPERBOLIC PARABOLOID PAVILION\r\n# =====================================================================\r\ndef generate_hyperbolic_paraboloid_pavilion():\r\n    \"\"\"Generate architectural pavilion using hyperbolic paraboloid surfaces\"\"\"\r\n    clear_document()\r\n    \r\n    def create_hypar_surface(corner1, corner2, corner3, corner4):\r\n        # Create control points for hyperbolic paraboloid using mesh\r\n        mesh = rg.Mesh()\r\n        \r\n        # Add vertices\r\n        mesh.Vertices.Add(corner1)\r\n        mesh.Vertices.Add(corner2)\r\n        mesh.Vertices.Add(corner3)\r\n        mesh.Vertices.Add(corner4)\r\n        \r\n        # Create face\r\n        mesh.Faces.AddFace(0, 1, 3, 2)\r\n        \r\n        mesh.Normals.ComputeNormals()\r\n        doc.Objects.AddMesh(mesh)\r\n    \r\n    # Create multiple connected hypar surfaces\r\n    base_size = 15\r\n    height_variation = 8\r\n    \r\n    # Grid of hypar surfaces\r\n    for i in range(3):\r\n        for j in range(3):\r\n            x_base = i * base_size\r\n            y_base = j * base_size\r\n            \r\n            # Corner heights with some variation\r\n            h1 = random.uniform(0, height_variation)\r\n            h2 = random.uniform(0, height_variation)\r\n            h3 = random.uniform(0, height_variation)\r\n            h4 = random.uniform(0, height_variation)\r\n            \r\n            corner1 = rg.Point3d(x_base, y_base, h1)\r\n            corner2 = rg.Point3d(x_base + base_size, y_base, h2)\r\n            corner3 = rg.Point3d(x_base, y_base + base_size, h3)\r\n            corner4 = rg.Point3d(x_base + base_size, y_base + base_size, h4)\r\n            \r\n            create_hypar_surface(corner1, corner2, corner3, corner4)\r\n    \r\n    print(\"Generated Hyperbolic Paraboloid Pavilion!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 11: PARTICLE SYSTEM CONSTELLATION\r\n# =====================================================================\r\ndef generate_particle_system_constellation():\r\n    \"\"\"Generate a 3D constellation using particle system simulation\"\"\"\r\n    clear_document()\r\n    \r\n    class Particle:\r\n        def __init__(self, position, velocity, size):\r\n            self.position = position\r\n            self.velocity = velocity\r\n            self.size = size\r\n            self.trail = [rg.Point3d(position)]\r\n    \r\n    # Initialize particles\r\n    particles = []\r\n    for i in range(100):\r\n        pos = rg.Point3d(\r\n            random.uniform(-20, 20),\r\n            random.uniform(-20, 20),\r\n            random.uniform(-20, 20)\r\n        )\r\n        vel = rg.Vector3d(\r\n            random.uniform(-0.5, 0.5),\r\n            random.uniform(-0.5, 0.5),\r\n            random.uniform(-0.5, 0.5)\r\n        )\r\n        size = random.uniform(0.1, 0.5)\r\n        particles.append(Particle(pos, vel, size))\r\n    \r\n    # Simulate particle movement\r\n    for step in range(50):\r\n        for particle in particles:\r\n            # Update position\r\n            particle.position = particle.position + particle.velocity\r\n            particle.trail.append(rg.Point3d(particle.position))\r\n            \r\n            # Add some gravitational effect toward center\r\n            center_force = rg.Vector3d(0, 0, 0) - rg.Vector3d(particle.position)\r\n            center_force.Unitize()\r\n            center_force = center_force * 0.01\r\n            particle.velocity = particle.velocity + center_force\r\n            \r\n            # Limit trail length\r\n            if len(particle.trail) > 20:\r\n                particle.trail.pop(0)\r\n    \r\n    # Create geometry\r\n    for particle in particles:\r\n        # Create sphere at final position\r\n        sphere = rg.Sphere(particle.position, particle.size)\r\n        brep = sphere.ToBrep()\r\n        doc.Objects.AddBrep(brep)\r\n        \r\n        # Create trail curve\r\n        if len(particle.trail) > 2:\r\n            trail_array = System.Array[rg.Point3d](particle.trail)\r\n            trail_curve = rg.Curve.CreateInterpolatedCurve(trail_array, 3)\r\n            if trail_curve:\r\n                doc.Objects.AddCurve(trail_curve)\r\n    \r\n    print(\"Generated Particle System Constellation!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 12: TENSEGRITY STRUCTURE NETWORK\r\n# =====================================================================\r\ndef generate_tensegrity_structure_network():\r\n    \"\"\"Generate tensegrity-inspired structural networks\"\"\"\r\n    clear_document()\r\n    \r\n    def create_tensegrity_unit(center, size):\r\n        # Create compression members (solid rods)\r\n        vertices = [\r\n            center + rg.Vector3d(size, 0, 0),\r\n            center + rg.Vector3d(-size/2, size*0.866, 0),\r\n            center + rg.Vector3d(-size/2, -size*0.866, 0),\r\n            center + rg.Vector3d(0, 0, size*1.5)\r\n        ]\r\n        \r\n        # Compression members - using simple line representations\r\n        for i in range(3):\r\n            start = vertices[i]\r\n            end = vertices[3]\r\n            \r\n            # Create line\r\n            line = rg.Line(start, end)\r\n            doc.Objects.AddCurve(line.ToNurbsCurve())\r\n        \r\n        # Tension members (cables - represented as lines)\r\n        for i in range(3):\r\n            for j in range(i+1, 3):\r\n                line = rg.Line(vertices[i], vertices[j])\r\n                doc.Objects.AddCurve(line.ToNurbsCurve())\r\n    \r\n    # Create network of tensegrity units\r\n    spacing = 8\r\n    for x in range(-2, 3):\r\n        for y in range(-2, 3):\r\n            for z in range(0, 3):\r\n                center = rg.Point3d(x * spacing, y * spacing, z * spacing)\r\n                size = 2 + z * 0.5\r\n                create_tensegrity_unit(center, size)\r\n    \r\n    print(\"Generated Tensegrity Structure Network!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 13: ALGORITHMIC FLOWER GARDEN\r\n# =====================================================================\r\ndef generate_algorithmic_flower_garden():\r\n    \"\"\"Generate a garden of algorithmic flowers using mathematical patterns\"\"\"\r\n    clear_document()\r\n    \r\n    def create_flower(center, petal_count, petal_size, stem_height):\r\n        # Create stem as a line\r\n        stem_start = center\r\n        stem_end = center + rg.Vector3d(0, 0, stem_height)\r\n        stem_line = rg.Line(stem_start, stem_end)\r\n        doc.Objects.AddCurve(stem_line.ToNurbsCurve())\r\n        \r\n        # Create petals as circles\r\n        flower_center = stem_end\r\n        for i in range(petal_count):\r\n            angle = 2 * math.pi * i / petal_count\r\n            \r\n            # Petal position\r\n            petal_center = flower_center + rg.Vector3d(\r\n                petal_size * 0.5 * math.cos(angle),\r\n                petal_size * 0.5 * math.sin(angle),\r\n                0\r\n            )\r\n            \r\n            # Create petal as circle\r\n            circle = rg.Circle(petal_center, petal_size * 0.3)\r\n            doc.Objects.AddCurve(circle.ToNurbsCurve())\r\n        \r\n        # Create flower center\r\n        center_sphere = rg.Sphere(flower_center, petal_size * 0.2)\r\n        center_brep = center_sphere.ToBrep()\r\n        doc.Objects.AddBrep(center_brep)\r\n    \r\n    # Create garden layout\r\n    flower_positions = []\r\n    for i in range(25):\r\n        x = random.uniform(-20, 20)\r\n        y = random.uniform(-20, 20)\r\n        flower_positions.append(rg.Point3d(x, y, 0))\r\n    \r\n    # Generate flowers\r\n    for pos in flower_positions:\r\n        petal_count = random.randint(5, 12)\r\n        petal_size = random.uniform(1, 3)\r\n        stem_height = random.uniform(3, 8)\r\n        create_flower(pos, petal_count, petal_size, stem_height)\r\n    \r\n    print(\"Generated Algorithmic Flower Garden!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 14: MORPHING MESH LANDSCAPE\r\n# =====================================================================\r\ndef generate_morphing_mesh_landscape():\r\n    \"\"\"Generate a complex landscape using mesh morphing techniques\"\"\"\r\n    clear_document()\r\n    \r\n    # Create base mesh grid\r\n    width, height = 50, 50\r\n    resolution = 2\r\n    \r\n    vertices = []\r\n    faces = []\r\n    \r\n    # Generate vertices with procedural height\r\n    for i in range(0, width + 1, resolution):\r\n        for j in range(0, height + 1, resolution):\r\n            x = i - width / 2\r\n            y = j - height / 2\r\n            \r\n            # Complex height function combining multiple sine waves\r\n            z = (5 * math.sin(x * 0.2) * math.cos(y * 0.15) +\r\n                 3 * math.sin(x * 0.4) * math.sin(y * 0.3) +\r\n                 2 * math.sin(x * 0.8) * math.cos(y * 0.6) +\r\n                 math.sin(x * 1.2) * math.sin(y * 1.1))\r\n            \r\n            vertices.append(rg.Point3d(x, y, z))\r\n    \r\n    # Create faces\r\n    rows = (width // resolution) + 1\r\n    cols = (height // resolution) + 1\r\n    \r\n    for i in range(rows - 1):\r\n        for j in range(cols - 1):\r\n            # Current quad vertices\r\n            v0 = i * cols + j\r\n            v1 = i * cols + (j + 1)\r\n            v2 = (i + 1) * cols + (j + 1)\r\n            v3 = (i + 1) * cols + j\r\n            \r\n            # Create two triangular faces\r\n            faces.append(rg.MeshFace(v0, v1, v2))\r\n            faces.append(rg.MeshFace(v0, v2, v3))\r\n    \r\n    # Create mesh\r\n    mesh = rg.Mesh()\r\n    for vertex in vertices:\r\n        mesh.Vertices.Add(vertex)\r\n    for face in faces:\r\n        mesh.Faces.AddFace(face)\r\n    \r\n    mesh.Normals.ComputeNormals()\r\n    mesh.Compact()\r\n    \r\n    doc.Objects.AddMesh(mesh)\r\n    \r\n    print(\"Generated Morphing Mesh Landscape!\")\r\n\r\n# =====================================================================\r\n# GENERATION FUNCTION 15: PARAMETRIC SPACE FRAME\r\n# =====================================================================\r\ndef generate_parametric_space_frame():\r\n    \"\"\"Generate a complex space frame structure with parametric joints\"\"\"\r\n    clear_document()\r\n    \r\n    def create_space_frame_node(position, connections):\r\n        # Create node sphere\r\n        node_sphere = rg.Sphere(position, 0.3)\r\n        node_brep = node_sphere.ToBrep()\r\n        doc.Objects.AddBrep(node_brep)\r\n        \r\n        # Create connecting members as lines\r\n        for connection in connections:\r\n            line = rg.Line(position, connection)\r\n            doc.Objects.AddCurve(line.ToNurbsCurve())\r\n    \r\n    # Define space frame grid\r\n    grid_size = 6\r\n    spacing = 4\r\n    nodes = {}\r\n    \r\n    # Create 3D grid of nodes\r\n    for x in range(grid_size):\r\n        for y in range(grid_size):\r\n            for z in range(grid_size):\r\n                # Add some randomness to create interesting geometry\r\n                offset_x = random.uniform(-0.5, 0.5)\r\n                offset_y = random.uniform(-0.5, 0.5)\r\n                offset_z = random.uniform(-0.2, 0.2)\r\n                \r\n                position = rg.Point3d(\r\n                    x * spacing + offset_x,\r\n                    y * spacing + offset_y,\r\n                    z * spacing + offset_z\r\n                )\r\n                nodes[(x, y, z)] = position\r\n    \r\n    # Create connections and build structure\r\n    for (x, y, z), position in nodes.items():\r\n        connections = []\r\n        \r\n        # Connect to adjacent nodes\r\n        directions = [\r\n            (1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1),\r\n            (1, 1, 0), (1, -1, 0), (-1, 1, 0), (-1, -1, 0),\r\n            (1, 0, 1), (1, 0, -1), (-1, 0, 1), (-1, 0, -1),\r\n            (0, 1, 1), (0, 1, -1), (0, -1, 1), (0, -1, -1)\r\n        ]\r\n        \r\n        for dx, dy, dz in directions:\r\n            neighbor_key = (x + dx, y + dy, z + dz)\r\n            if neighbor_key in nodes:\r\n                connections.append(nodes[neighbor_key])\r\n        \r\n        # Only create connections for some nodes to avoid overcrowding\r\n        if len(connections) > 3 and random.random() > 0.3:\r\n            create_space_frame_node(position, connections[:6])  # Limit connections\r\n    \r\n    print(\"Generated Parametric Space Frame!\")\r\n\r\n# =====================================================================\r\n# MAIN EXECUTION\r\n# =====================================================================\r\ndef main():\r\n    \"\"\"Execute all generation functions automatically\"\"\"\r\n    print(\"Rhino.Inside.Cpython Generation Functions Collection\")\r\n    print(\"=\" * 60)\r\n    print(\"Generating all 15 functions automatically...\")\r\n    print(\"Each will be saved as a separate Rhino file in Desktop/RhinoAuto/\")\r\n    print()\r\n    \r\n    functions = [\r\n        (\"01_Fibonacci_Spiral_Tower\", generate_fibonacci_spiral_tower),\r\n        (\"02_Voronoi_Cityscape\", generate_voronoi_cityscape),\r\n        (\"03_Parametric_Wave_Surface\", generate_parametric_wave_surface),\r\n        (\"04_Fractal_Tree\", generate_fractal_tree),\r\n        (\"05_Geodesic_Dome_Variations\", generate_geodesic_dome_variations),\r\n        (\"06_3D_Lissajous_Curves\", generate_lissajous_curves_3d),\r\n        (\"07_Cellular_Automata_Structures\", generate_cellular_automata_structures),\r\n        (\"08_Twisted_Spire_Collection\", generate_twisted_spire_collection),\r\n        (\"09_Parametric_Coral_Reef\", generate_parametric_coral_reef),\r\n        (\"10_Hyperbolic_Paraboloid_Pavilion\", generate_hyperbolic_paraboloid_pavilion),\r\n        (\"11_Particle_System_Constellation\", generate_particle_system_constellation),\r\n        (\"12_Tensegrity_Structure_Network\", generate_tensegrity_structure_network),\r\n        (\"13_Algorithmic_Flower_Garden\", generate_algorithmic_flower_garden),\r\n        (\"14_Morphing_Mesh_Landscape\", generate_morphing_mesh_landscape),\r\n        (\"15_Parametric_Space_Frame\", generate_parametric_space_frame)\r\n    ]\r\n    \r\n    generated_files = []\r\n    \r\n    for i, (filename, func) in enumerate(functions, 1):\r\n        try:\r\n            print(f\"{i:2}/15 Generating {filename.replace('_', ' ')}...\")\r\n            func()\r\n            file_path = save_and_open_file(filename)\r\n            if file_path:\r\n                generated_files.append(file_path)\r\n                print(f\"     ✓ Saved: {filename}.3dm\")\r\n            else:\r\n                print(f\"     ✗ Failed to save: {filename}.3dm\")\r\n        except Exception as e:\r\n            print(f\"     ✗ Error generating {filename}: {str(e)}\")\r\n            continue\r\n    \r\n    print(\"\\n\" + \"=\" * 60)\r\n    print(f\"Generation completed! {len(generated_files)} files created.\")\r\n    print(\"\\nOpening all Rhino files...\")\r\n    \r\n    # Open all generated files\r\n    for file_path in generated_files:\r\n        try:\r\n            os.startfile(file_path)\r\n            print(f\"Opened: {os.path.basename(file_path)}\")\r\n        except Exception as e:\r\n            print(f\"Error opening {os.path.basename(file_path)}: {str(e)}\")\r\n    \r\n    print(f\"\\nAll files saved in: {os.path.join(os.path.expanduser('~'), 'Desktop', 'RhinoAuto')}\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}