{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/02_Rhino_Commands/PHPPexport%20%7B82540871-2420-4c7f-8efa-78b7d078cbfe%7D/dev/PHPP_SetSurfaceNames_cmd.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "02_Rhino_Commands/PHPPexport {82540871-2420-4c7f-8efa-78b7d078cbfe}/dev/PHPP_SetSurfaceNames_cmd.py",
  "instruction": "This is a helper tool to autoname any objects in Rhino. It will take a set of\r\nselected objects and name them 1..2..3..4.. etc... from left-->right. It figures\r\nout left--->right based on the surface...",
  "code": "#\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the\r\n# Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\n# \r\n# This component is part of IDF2PHPP.\r\n# \r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# For a copy of the GNU General Public License\r\n# see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n#\r\n\"\"\"\r\nThis is a helper tool to autoname any objects in Rhino. It will take a set of\r\nselected objects and name them 1..2..3..4.. etc... from left-->right. It figures\r\nout left--->right based on the surface normals and U/V directions of the surfaces. \r\nThat means before using it, be sure to evaluate and standardize ALL the normals\r\nand UV directions of your surfaces! Be sure they are pointing 'out' and that the\r\nV is up, U is to the right. Otherwise it'll name things backwards or in an\r\nunexpected way. Use the native Rhino 'Show Object Direction' tool to review all\r\nthe UV and directions.\r\n-\r\nEM Jul. 24 2020\r\n\"\"\"\r\n\r\nimport rhinoscriptsyntax as rs\r\nimport Eto\r\nimport json\r\nimport Rhino\r\nimport scriptcontext as sc\r\nfrom Rhino.Geometry import *\r\nfrom collections import defaultdict\r\n\r\n__commandname__ = \"PHPP_SetSurfaceNames\"\r\n\r\nclass Model:\r\n    def __init__(self, selObjs):\r\n        self.selectedObjects = selObjs\r\n    \r\n    def _findWindowPlane(self, _srfcs):\r\n        \"\"\"\r\n        Takes in a set of surfaces, returns a list of their Centroids in 'order'\r\n        \r\n        Assess the surface normal of the group of surfaces and attempts to \r\n        figuere out the 'order' of the srfcs when viewed from 'outside' (according\r\n        to the surface normal) and orders the centroids from left--->right\r\n        \"\"\"\r\n        setXs = []\r\n        setYs = []\r\n        setZs = []\r\n        Centroids = []\r\n        CentroidsX = []\r\n        \r\n        for srfc in _srfcs:\r\n            windowBrep = rs.coercebrep(srfc)\r\n            surfaceList =  windowBrep.Surfaces\r\n            for eachSurface in surfaceList:\r\n                srfcCentroid = rs.SurfaceAreaCentroid(eachSurface)[0]\r\n                b, u, v = eachSurface.ClosestPoint(srfcCentroid)\r\n                srfcNormal = eachSurface.NormalAt(u, v)\r\n                setXs.append( srfcNormal.X )\r\n                setYs.append( srfcNormal.Y )\r\n                setZs.append( srfcNormal.Z )\r\n                Centroids.append( srfcCentroid )\r\n                CentroidsX.append(srfcCentroid.X)\r\n        \r\n        # Find the average Normal Vector of the set\r\n        px = sum(setXs) / len(setXs)\r\n        py = sum(setYs) / len(setYs)\r\n        pz = sum(setZs) / len(setZs)\r\n        avgNormalVec = Rhino.Geometry.Point3d(px, py, pz)\r\n        \r\n        # Find a line through all the points and its midpoint\r\n        fitLine = rs.LineFitFromPoints(Centroids)\r\n        newLine = Rhino.Geometry.Line(fitLine.From, fitLine.To)\r\n        \r\n        # Find the Midpoint of the Line\r\n        midX = (fitLine.From.X + fitLine.To.X) / 2\r\n        midY = (fitLine.From.Y + fitLine.To.Y) / 2\r\n        midZ = (fitLine.From.Z + fitLine.To.Z) / 2\r\n        lineMidpoint = Rhino.Geometry.Point3d(midX, midY, midZ)\r\n        \r\n        # Rotate new Plane to match the window avg\r\n        newAvgWindowPlane = rs.CreatePlane(lineMidpoint, avgNormalVec, [0,0,1] )\r\n        finalPlane = rs.RotatePlane(newAvgWindowPlane, 90, [0,0,1])\r\n        \r\n        # Plot the window Centroids onto the selection Set Plane\r\n        centroidsReMaped = []\r\n        for eachCent in Centroids:\r\n            centroidsReMaped.append( finalPlane.RemapToPlaneSpace(eachCent) )\r\n        \r\n        # Return a list of the new Centroids remapped onto the Set's Plane\r\n        return centroidsReMaped\r\n    \r\n    def getStickyValues(self):\r\n        prefix = sc.sticky.get('winName_prefix', '')\r\n        suffix = sc.sticky.get('winName_suffix', '')\r\n        \r\n        return {'Prefix':prefix, 'Suffix':suffix}\r\n    \r\n    def setStickyValues(self, _dialogVals):\r\n        sc.sticky['winName_prefix'] = _dialogVals.get('prefix')\r\n        sc.sticky['winName_suffix'] = _dialogVals.get('suffix')\r\n    \r\n    def _orderSurfaces(self, _srfcs):\r\n        # Sort the surfaces 'Left to Right'\r\n        # when viewed from the 'outside'\r\n        \r\n        if len(_srfcs)>1:\r\n            centroidSet = self._findWindowPlane(_srfcs)\r\n            orderedSrfcs = [x for _,x in sorted(zip(centroidSet, _srfcs))]\r\n        else:\r\n            orderedSrfcs = _srfcs\r\n        \r\n        return orderedSrfcs\r\n    \r\n    def _filterOutNonSurfaces(self, _srfcs):\r\n        return [s for s in _srfcs if rs.IsSurface(s)]\r\n    \r\n    def setObjAttrs(self, _dialogVals):\r\n        self.setStickyValues(_dialogVals)\r\n        \r\n        surfacesToOrder = self._filterOutNonSurfaces(self.selectedObjects)\r\n        srfcsInOrder = self._orderSurfaces(surfacesToOrder)\r\n        \r\n        # Now that the Surfaces are in order, Set all the names\r\n        for i, srfc in enumerate(srfcsInOrder):\r\n            newName = \"{}{}{}\".format(_dialogVals.get('prefix'), i+1, _dialogVals.get('suffix'))\r\n            rs.ObjectName(srfc, newName)\r\n\r\nclass View(Eto.Forms.Dialog):\r\n    \r\n    def __init__(self, controller):\r\n        self.controller = controller\r\n        self.controller.model.getStickyValues()\r\n        self.groupContent = self.createContent()\r\n        self._setWindowParams()\r\n        self._addContentToWindow()\r\n        self._addOKCancelButtons()\r\n    \r\n    def createContent(self):\r\n        _prefix = self.controller.model.getStickyValues().get('Prefix', '')\r\n        _suffix = self.controller.model.getStickyValues().get('Suffix', '')\r\n        note = \"Only works for 'Surfaces', no Meshes or Curves.\\n\"\\\r\n               \"Be sure the surface normals on all windows\\nare pointed 'out'.\"\r\n        \r\n        \r\n        groupContent = [\r\n            {'groupName': 'Input Name Prefix and Suffix to use (if any)',\r\n            'content':[\r\n                {'name': 'prefix', 'label':'Name Prefix:', 'input':Eto.Forms.TextBox( Text = str(_prefix))},\r\n                {'name': 'suffix', 'label':'Name Suffix:', 'input':Eto.Forms.TextBox( Text = str(_suffix))}\r\n                ]\r\n            },\r\n                {'groupName': '',\r\n                'content':[\r\n                    {'name': 'note', 'label':'Note:', 'input':Eto.Forms.Label(Text = note)}\r\n                    ]\r\n            }]\r\n        \r\n        return groupContent\r\n    \r\n    def _setWindowParams(self):\r\n        self.Title = \"Set Names for Selected Surface(s)\"\r\n        self.Padding = Eto.Drawing.Padding(15) # The outside edge of the frame\r\n        self.Resizable = True\r\n    \r\n    def _addContentToWindow(self):\r\n        self.layout = Eto.Forms.DynamicLayout()\r\n        self.layout.Spacing = Eto.Drawing.Size(10,10)\r\n        self.layout = Eto.Forms.DynamicLayout()\r\n        \r\n        for group in self.groupContent:\r\n            groupObj = Eto.Forms.GroupBox(Text = group.get('groupName', ''))\r\n            groupLayout = Eto.Forms.TableLayout()\r\n            groupLayout.Padding = Eto.Drawing.Padding(5) # Offfset from the outside of the Group Edge\r\n            groupLayout.Spacing = Eto.Drawing.Size(10,5) # Spacing between elements\r\n            \r\n            for tableRow in group.get('content', ''):\r\n                groupLayout.Rows.Add(Eto.Forms.TableRow(\r\n                        Eto.Forms.TableCell(Eto.Forms.Label(Text = tableRow.get('label', 'Label Missing'))), \r\n                        Eto.Forms.TableCell(tableRow.get('input'), None)    \r\n                        ))\r\n            \r\n            groupObj.Content = groupLayout\r\n            self.layout.Add(groupObj)\r\n        \r\n        self.Content = self.layout\r\n    \r\n    def _addOKCancelButtons(self):\r\n        # Create the OK / Cancel Button\r\n        self.Button_OK = Eto.Forms.Button(Text = 'OK')\r\n        self.Button_OK.Click += self.controller.OnOKButtonClick\r\n        self.Button_Cancel = Eto.Forms.Button(Text = 'Cancel')\r\n        self.Button_Cancel.Click += self.controller.OnCancelButtonClick\r\n        \r\n        # Add the Buttons at the bottom\r\n        self.vert = self.layout.BeginVertical()\r\n        self.vert.Padding = Eto.Drawing.Padding(10)\r\n        self.vert.Spacing = Eto.Drawing.Size(15,0)\r\n        self.layout.AddRow(None, self.Button_Cancel, self.Button_OK, None)\r\n        self.layout.EndVertical()\r\n    \r\n    def getDialogValues(self):\r\n        dialogValues = defaultdict()\r\n        for eachEntry in self.groupContent[0]['content']:\r\n            dialogValues[eachEntry['name']] = eachEntry['input'].Text\r\n        \r\n        return dialogValues\r\n    \r\n    def showWindow(self):\r\n        self.ShowModal(Rhino.UI.RhinoEtoApp.MainWindow)\r\n\r\nclass Controller:\r\n    def __init__(self, selObjs):\r\n        self.model = Model(selObjs)\r\n        self.view = View(self)\r\n    \r\n    def main(self):\r\n        self.view.showWindow()\r\n    \r\n    def OnOKButtonClick(self, sender, e):\r\n        print('Applying the New Properites to Selected')\r\n        self.Update = True\r\n        dialogValues = self.view.getDialogValues()\r\n        self.model.setObjAttrs(dialogValues)\r\n        self.view.Close()\r\n    \r\n    def OnCancelButtonClick(self, sender, e):\r\n        print('Canceled...')\r\n        self.Update = False\r\n        self.view.Close()\r\n\r\ndef RunCommand( is_interactive ):\r\n    print \"Setting the name(s) for the selected object(s)\"\r\n    \r\n    dialog = Controller(rs.SelectedObjects())\r\n    dialog.main()\r\n\r\n# Use for debuging in editor\r\n#RunCommand(True)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}