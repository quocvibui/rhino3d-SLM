{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/mmmesh/mmmesh.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "mmmesh/mmmesh.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 14.01.2017\n\n@author: kathrind\n'''\n\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\nfrom System.Collections.Generic import IEnumerable, List\n\n\nclass MMMesh: \n    \n    #===========================================================================\n    # MM Mesh\n    #===========================================================================\n    def __init__(self):\n        ''' generation geometry of a mesh mould mesh '''\n   \n        # maybe later replace with u and v     \n        self.rows = 0 # is the division in the discrete direction # horizontal division along the motion path #rows\n        self.cols = 0 # is the division in the continuous direction * 2 for subdivision # vertical division #cols\n        \n        # deriving from the init mesehs we generate rebuilt meshes that are rebuilt from the intersection curves/points       \n        self.rgmesh_fab_srf1 = rg.Mesh()\n        self.rgmesh_fab_srf2 = rg.Mesh()\n        \n        # cutting planes\n        self.cutting_planes = [] # these planes are also for the wrist direction of the robot arm of each layer \n    \n    #===========================================================================\n    # setting the fab meshes with number of rows, cols and cutting planes\n    #===========================================================================\n    def set_rgmeshes_fab(self, rgmesh_fab_srf1, rgmesh_fab_srf2, cutting_planes, rows, cols):\n        \n        # rhino mesh constructed with cutting planes\n        self.rgmesh_fab_srf1 = rgmesh_fab_srf1\n        self.rgmesh_fab_srf2 = rgmesh_fab_srf2\n        \n        # cutting planes\n        self.cutting_planes = cutting_planes # these planes are also for the wrist direction of the robot arm of each layer\n        \n        # number of rows and cols\n        self.rows = rows # is the division in the discrete direction # horizontal division along the motion path #rows\n        self.cols = cols # is the division in the continuous direction * 2 for subdivision # vertical division #cols\n\n    #===========================================================================\n    # functions for generating the regular quadmesh based on init meshes and the cutting planes\n    #===========================================================================     \n    def generate_rgmeshes_fab(self, init_rgmesh_srf1, init_rgmesh_srf2, crv_for_cutting_planes, cell_width, cell_length, min_intersection_crv_len = 2800, split_plane = None):\n        ''' generate the rhino fab meshes from  init meshes and cutting planes '''\n        \n        self.init_rgmesh_srf1 = init_rgmesh_srf1\n        self.init_rgmesh_srf2 = init_rgmesh_srf2\n        \n        # cutting planes for surface\n        self.init_cutting_planes = self.get_init_cutting_planes_from_crv(crv_for_cutting_planes, cell_width) # these planes are also for the wrist direction of the robot arm of each layer\n        \n        # division between discrete elements of the mesh\n        self.cell_length = cell_length\n        \n        # create the intersection planes from the surfaces with the cutting planes\n        self.create_intersection_curves_from_init_meshes(min_intersection_crv_len = min_intersection_crv_len, split_plane = split_plane)\n        \n        # create the division points from the intersection lines\n        self.generate_intersection_pts_in_layers(self.cell_length)\n        \n        self.rgmesh_fab_srf1 = self.generate_rgmesh_from_pts_in_rows(self.intersection_pts_in_layers_srf1)\n        self.rgmesh_fab_srf2 = self.generate_rgmesh_from_pts_in_rows(self.intersection_pts_in_layers_srf2)\n    \n    def get_init_cutting_planes_from_crv(self, crv_for_cutting_planes, cell_width):\n        # get intersection curves of the srfs with the perpendicular plane to the mean curve       \n        div_num = self.get_crv_div_num(crv_for_cutting_planes, cell_width*1.01)\n        cutting_planes = ghcomp.PerpFrames(crv_for_cutting_planes, div_num)[0]\n        [p.Rotate(m.radians(90), p.ZAxis, p.Origin) for p in cutting_planes]\n        \n        return cutting_planes\n    \n    def generate_intersection_pts_in_layers(self, cell_length):\n        ''' create a grid of points deriving from the intersection curves, the division distance is depending on the desired cell length times 3 '''        \n        \n        divnum = self.get_crv_div_num(self.intersection_crvs_srf1[0], cell_length) * 2\n        \n        self.intersection_pts_in_layers_srf1 = self.get_divpts_from_crvs_in_layers(self.intersection_crvs_srf1, divnum + 1)\n        self.intersection_pts_in_layers_srf2 = self.get_divpts_from_crvs_in_layers(self.intersection_crvs_srf2, divnum + 1)\n        \n        self.rows = len(self.intersection_pts_in_layers_srf1) #rows\n        self.cols = len(self.intersection_pts_in_layers_srf1[0]) #cols\n\n    def create_intersection_curves_from_init_meshes(self, min_intersection_crv_len = 2800, split_plane = None):   \n        ''' the two surfaces are cut by a list of cutting planes, which result in a list of intersection curves '''\n\n        self.intersection_crvs_srf1 = []\n        self.intersection_crvs_srf2 = []\n        self.cutting_planes = []\n\n        for cplane in self.init_cutting_planes:\n            crv_srf1 = self.create_intersect_curve_mesh_with_plane(self.init_rgmesh_srf1, cplane, min_intersection_crv_len = min_intersection_crv_len, return_nurbs_curves = True)\n            crv_srf2 = self.create_intersect_curve_mesh_with_plane(self.init_rgmesh_srf2, cplane, min_intersection_crv_len = min_intersection_crv_len, return_nurbs_curves = True)\n\n            if crv_srf1 and crv_srf2:\n                \n                if split_plane:\n                    ie_srf1 = rg.Intersect.Intersection.CurvePlane(crv_srf1, split_plane, 0.1)[0]\n                    ie_srf2 = rg.Intersect.Intersection.CurvePlane(crv_srf2, split_plane, 0.1)[0]\n                    \n                    split_crv_srf1 = crv_srf1.Split(ie_srf1.ParameterA)[1]\n                    split_crv_srf2 = crv_srf2.Split(ie_srf2.ParameterA)[1]\n                    \n                    crv_srf1 = split_crv_srf1\n                    crv_srf2 = split_crv_srf2\n                    \n                self.intersection_crvs_srf1.append(crv_srf1)\n                self.intersection_crvs_srf2.append(crv_srf2)\n                \n                self.cutting_planes.append(cplane) # these are also the wrist planes for the robot\n            \n    def get_intersection_pts_flat(self, srf = \"srf1\"):     \n        if srf == \"srf1\":\n            return [x for sublist in self.intersection_pts_in_layers_srf1 for x in sublist]\n        else:\n            return [x for sublist in self.intersection_pts_in_layers_srf2 for x in sublist]\n\n    def get_pt_in_row_intersection_pts(self, row, col, srf = \"srf1\"):\n        '''return the point of the point grid given column and row and surface 1 or surface 2'''    \n        return self.intersection_pts_in_layers_srf1[row][col] if srf == \"srf1\" else self.intersection_pts_in_layers_srf2[row][col]\n\n    def get_crv_div_num(self, crv, div_len):\n        ''' returns the number of divisions for a curve given a length '''\n        length = ghcomp.Length(crv) #length = polyline.Length\n        div_num = int((length / div_len))\n        return div_num\n\n    def get_min_dist_crv_to_plane(self, plane, crvs):\n        ''' returns a curve out of a list of curves which midpoint is closest to a given plane '''\n        min_dist = 10000000\n        min_crv = None\n        for crv in crvs:\n            midpt = crv.PointAt(0.5)\n            dist = plane.Origin.DistanceTo(midpt)\n            if dist < min_dist:\n                min_dist = dist\n                min_crv = crv            \n        return min_crv\n    \n    def get_plane_from_srf(self, pt, srf):\n        '''get the srf plane closest tot the input point'''\n        \n        s = self.srf1_rebuilt if srf == 1 else self.srf2_rebuilt\n        \n        srf_param = s.ClosestPoint(pt)\n        srf_plane = s.FrameAt(srf_param[1], srf_param[2])[1]\n        \n        return srf_plane\n    \n    def create_intersect_curve_mesh_with_plane(self, mesh, cutting_plane, min_intersection_crv_len = 2300, return_nurbs_curves = True):   \n        ''' a mesh is cut by plane, the function returns the curve closest to the cutting plane, threshold for min length must be given '''\n      \n        intersection_crvs = rg.Intersect.Intersection.MeshPlane(mesh, cutting_plane)\n        #print intersection_crvs\n        if intersection_crvs:\n            if len(intersection_crvs) == 1:         \n                crv = intersection_crvs[0]       \n            elif len(intersection_crvs) > 1:            \n                crv = self.get_min_dist_crv_to_plane(cutting_plane, intersection_crvs)                   \n            if crv.Length > min_intersection_crv_len:           \n                if return_nurbs_curves: crv = crv.ToNurbsCurve()\n                if crv.PointAtStart.Z > crv.PointAtEnd.Z:\n                    crv.Reverse()            \n                return crv\n            else:\n                return None\n        else:\n            return None\n            \n    def get_loft_srf_rebuilt_from_crvs(self, crvs, resolution = 50):\n        ''' return srf rebuilt from crvs''' \n                \n        ielist_crvs = List[rg.Curve]()\n        [ielist_crvs.Add(crv) for crv in crvs]\n    \n        # create a new loft with the curves\n        srf_rebuilt = rg.Brep.CreateFromLoftRebuild(ielist_crvs, rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False, resolution)[0]    \n        return srf_rebuilt.Faces[0].ToNurbsSurface()\n    \n    def get_loft_srf_from_crvs(self, crvs):\n        ''' return srf rebuilt from crvs''' \n                \n        ielist_crvs = List[rg.Curve]()\n        [ielist_crvs.Add(crv) for crv in crvs]\n    \n        # create a new loft with the curves\n        srf_rebuilt = rg.Brep.CreateFromLoft(ielist_crvs, rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False)[0]    \n        return srf_rebuilt.Faces[0].ToNurbsSurface()\n    \n    def generate_rgmesh_from_pts(self, pts, rows, cols):\n        ''' generate a rhino mesh out of pts and numbers of division in both direction '''\n        \n        rgmesh = rg.Mesh()\n        \n        # adding the mesh vertices\n        [rgmesh.Vertices.Add(pt) for pt in pts]\n        \n        # adding the mesh faces\n        for j in range(rows):\n            for i in range(cols):\n                current_idx = j * cols + i\n                current_idx_row_before = current_idx - cols\n                if j > 0 and i < cols-1:\n                    rgmesh.Faces.AddFace(current_idx, current_idx+1, current_idx_row_before+1, current_idx_row_before)              \n        return rgmesh\n    \n    def get_flat_list_from_2dlist(self, nested):\n        ''' returns a flat list from a 2d nested list'''     \n        return [x for sublist in nested for x in sublist]\n    \n    def generate_rgmesh_from_pts_in_rows(self, pts_in_rows):\n        ''' generate a rhino mesh out of pts and numbers of division in both direction '''\n        rows = len(pts_in_rows)\n        cols = len(pts_in_rows[0])\n        \n        return self.generate_rgmesh_from_pts(self.get_flat_list_from_2dlist(pts_in_rows), rows, cols)\n    \n    def get_divpts_from_crv(self, crv, divnum):\n        ''' return points deriving from the division of a curve'''\n        params = crv.DivideByCount(divnum, True)\n        return [crv.PointAt(p) for p in params]   \n    \n    def get_divpts_from_crvs_in_layers(self, crvs, divnum):\n        ''' return division points in layers from crvs'''\n        layers = []\n        for crv in crvs:\n            layers.append(self.get_divpts_from_crv(crv, divnum))\n        return layers\n    \n    def get_vertices_in_row_rgmesh_fab(self, row, srf=\"srf1\"):\n        return self.get_vertices_in_row_rgmesh(self.rgmesh_fab_srf1, row, self.cols) if srf==\"srf1\" else self.get_vertices_in_row_rgmesh(self.rgmesh_fab_srf2, row, self.cols)\n    \n    def get_vertices_in_col_rgmesh_fab(self, col, srf=\"srf1\"):\n        return self.get_vertices_in_col_rgmesh(self.rgmesh_fab_srf1, col, self.rows, self.cols) if srf==\"srf1\" else self.get_vertices_in_col_rgmesh(self.rgmesh_fab_srf2, col, self.rows, self.cols)\n\n    def get_pts_in_row_rgmesh_fab(self, row, srf=\"srf1\"):\n        return self.get_pts_in_row_rgmesh(self.rgmesh_fab_srf1, row, self.cols) if srf==\"srf1\" else self.get_pts_in_row_rgmesh(self.rgmesh_fab_srf2, row, self.cols)\n    \n    def get_pts_in_col_rgmesh_fab(self, col, srf=\"srf1\"):\n        return self.get_pts_in_col_rgmesh(self.rgmesh_fab_srf1, col, self.rows, self.cols) if srf==\"srf1\" else self.get_pts_in_col_rgmesh(self.rgmesh_fab_srf2, col, self.rows, self.cols)\n    \n    def get_pt_row_col_rgmesh_fab(self, row, col, srf = \"srf1\"):\n        return self.get_pt_row_col_rgmesh(self.rgmesh_fab_srf1, row, col, self.cols) if srf==\"srf1\" else self.get_pt_row_col_rgmesh(self.rgmesh_fab_srf2, row, col, self.cols)\n\n    def get_edge_lines_in_row_rgmesh_fab(self, row, srf = \"srf1\"):\n        return self.get_edge_lines_in_row_rgmesh(self.rgmesh_fab_srf1, row, self.cols) if srf==\"srf1\" else self.get_edge_lines_in_row_rgmesh(self.rgmesh_fab_srf2, row, self.cols)\n    \n    def get_edge_lines_in_col_rgmesh_fab(self, col, srf = \"srf1\"):\n        return self.get_edge_lines_in_col_rgmesh(self.rgmesh_fab_srf1, col, self.rows, self.cols) if srf==\"srf1\" else self.get_edge_lines_in_col_rgmesh(self.rgmesh_fab_srf2, col, self.rows, self.cols)\n    \n    def get_edge_lines_col_rgmesh_fab(self, srf = \"srf1\"):\n        return self.get_edge_lines_col_rgmesh(self.rgmesh_fab_srf1, self.rows, self.cols) if srf==\"srf1\" else self.get_edge_lines_col_rgmesh(self.rgmesh_fab_srf2, self.rows, self.cols)\n    \n    def get_edge_lines_row_rgmesh_fab(self, srf = \"srf1\"):\n        return self.get_edge_lines_row_rgmesh(self.rgmesh_fab_srf1, self.rows, self.cols) if srf==\"srf1\" else self.get_edge_lines_row_rgmesh(self.rgmesh_fab_srf2, self.rows, self.cols)\n\n    \n    #===========================================================================\n    # general rg mesh functions for a quadmesh with regular grid\n    #===========================================================================\n    def get_idx_row_col(self, row, col, cols):\n        ''' return idx in row col from a regular grid'''\n        return row * cols + col\n    \n    def get_vertex_row_col_rgmesh(self, rgmesh, row, col, cols):\n        ''' return vertex in row col from a regular grid'''\n        return rgmesh.Vertices[self.get_idx_row_col(row, col, cols)]\n    \n    def get_pt_row_col_rgmesh(self, rgmesh, row, col, cols):\n        ''' return pt in row col from a regular grid'''\n        #print row, col, cols\n        return rg.Point3d(rgmesh.Vertices[self.get_idx_row_col(row, col, cols)])\n    \n    def get_idcs_in_row(self, row, cols):\n        ''' return idcs in row from a regular grid'''\n        from_idx = row * cols\n        to_idx = (row + 1) * cols\n        return range(from_idx, to_idx)\n    \n    def get_idcs_in_col(self, col, rows, cols):\n        ''' return idcs in col from a regular grid'''\n        return [(i * cols) + col for i in range(rows)]\n    \n    def get_vertices_in_row_rgmesh(self, rgmesh, row, cols):\n        ''' return vertices in row from a rhino geometry quad mesh'''   \n        return [rgmesh.Vertices[idx] for idx in self.get_idcs_in_row(row, cols)]\n                \n    def get_vertices_in_col_rgmesh(self, rgmesh, col, rows, cols):\n        ''' return vertices in col from a rhino geometry quad mesh'''   \n        return [rgmesh.Vertices[idx] for idx in self.get_idcs_in_col(col, rows, cols)]\n        \n    def get_pts_in_row_rgmesh(self, rgmesh, row, cols):\n        ''' return pts in row from a rhino geometry quad mesh'''  \n        return [rg.Point3d(rgmesh.Vertices[idx]) for idx in self.get_idcs_in_row(row, cols)]\n    \n    def get_pts_in_col_rgmesh(self, rgmesh, col, rows, cols):\n        ''' return pts in col from a rhino geometry quad mesh'''  \n        return [rg.Point3d(rgmesh.Vertices[idx]) for idx in self.get_idcs_in_col(col, rows, cols)]\n        \n    def get_edge_lines_in_row_rgmesh(self, rgmesh, row, cols):\n    \n        idcs_vertices = self.get_idcs_in_row(row, cols)\n        lines = []\n        \n        for i, idx in enumerate(idcs_vertices):\n            if i>0:\n                idx_start = idcs_vertices[i-1]\n                idx_end = idcs_vertices[i]\n                line = rg.Line(rgmesh.Vertices[idx_start],rgmesh.Vertices[idx_end]) \n                lines.append(line)\n        \n        return lines\n    \n    def get_edge_lines_in_col_rgmesh(self, rgmesh, col, rows, cols):\n        \n        idcs_vertices = self.get_idcs_in_col(col, rows, cols)\n        lines = []\n        #print idcs_vertices\n        \n        for i, idx in enumerate(idcs_vertices):\n            if i>0:\n                idx_start = idcs_vertices[i-1]\n                idx_end = idcs_vertices[i]            \n                line = rg.Line(rgmesh.Vertices[idx_start],rgmesh.Vertices[idx_end]) \n                lines.append(line)\n        return lines\n\n    def get_edge_lines_col_rgmesh(self, rgmesh, rows, cols):\n        lines = []\n        for col in range(cols):\n            lines += self.get_edge_lines_in_col_rgmesh(rgmesh, col, rows, cols)\n        return lines\n    \n    def get_edge_lines_row_rgmesh(self, rgmesh, rows, cols):\n        lines = []\n        for row in range(rows):\n            lines += self.get_edge_lines_in_row_rgmesh(rgmesh, row, cols)\n        return lines\n    \n    def get_length_of_longest_row_rgmesh(self, rgmesh, rows, cols):\n        max_len = 0\n        for row in range(rows):\n            lines = self.get_edge_lines_in_row_rgmesh(rgmesh, row, cols)\n            total_len = sum([l.Length for l in lines])\n            if total_len > max_len:\n                max_len = total_len\n        return max_len\n        \n    def get_min_max_line_length(self, lines):\n        lengths = [l.Length for l in lines]\n        return (min(lengths), max(lengths))\n    \n    def get_min_max_lines(self, lines):\n        lengths = [l.Length for l in lines]\n        minv, maxv = self.get_min_max_line_length(lines)\n        #print minv, maxv\n        return (lines[lengths.index(minv)], lines[lengths.index(maxv)])\n    \n    def get_lines_outside_lengths_thresh(self, lines, min_len, max_len):\n        return [l for l in lines if l.Length<min_len or l.Length>max_len]\n        \"\"\"\n        lines = self.get_edge_lines_col_rgmesh(rgmesh, rows, cols)\n        lengths = [l.Length for l in lines]\n        return sum(lengths)\"\"\"\n    \n    def get_sum_of_edge_lengths_col_with_excess_length_rgmesh(self, rgmesh, rows, cols, elength=30):\n        lines = self.get_edge_lines_col_rgmesh(rgmesh, rows, cols)\n        lengths = [l.Length+elength for i, l in enumerate(lines) if i%2==0]\n        return sum(lengths)\n    \n    def get_sum_of_edge_lengths_row_with_excess_length_rgmesh(self, rgmesh, rows, cols, elength=600):\n        # for each row add 500mm on the bottom and 100mm on top\n        lines = self.get_edge_lines_row_rgmesh(rgmesh, rows, cols)\n        lengths = [l.Length for l in lines]\n        add_length = rows * 600\n        return sum(lengths) + add_length\n    \n    def get_rgmesh_from_subdomain(self, uv_subdomain):\n        row_from, row_to, col_from, col_to = (int(uv_subdomain.U0), int(uv_subdomain.U1), int(uv_subdomain.V0), int(uv_subdomain.V1))\n        \n        row_to = min(self.rows, row_to)\n        col_to = min(self.cols, col_to)\n        \n        cutting_planes = self.cutting_planes[row_from:row_to]\n        \n        pts_in_rows_srf1 = [self.get_pts_in_row_rgmesh_fab(row, srf=\"srf1\")[col_from:col_to] for row in range(row_from, row_to)]\n        pts_in_rows_srf2 = [self.get_pts_in_row_rgmesh_fab(row, srf=\"srf2\")[col_from:col_to] for row in range(row_from, row_to)]\n        \n        rgmesh_fab_srf1 = self.generate_rgmesh_from_pts_in_rows(pts_in_rows_srf1)\n        rgmesh_fab_srf2 = self.generate_rgmesh_from_pts_in_rows(pts_in_rows_srf2)\n        \n        return (cutting_planes, (rgmesh_fab_srf1, rgmesh_fab_srf2), len(range(row_from,row_to)), len(range(col_from,col_to)))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}