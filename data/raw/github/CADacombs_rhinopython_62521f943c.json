{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsCrv_maximizeMinimumRadius.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsCrv_maximizeMinimumRadius.py",
  "instruction": "200112-14: Created from another script.\r\n200128: Import-related update.\r\n200422: Modified pre- and post-object selection behavior.\r\n200504-05: Added function to adjust weight of degree 2 Bezier...",
  "code": "\"\"\"\r\n200112-14: Created from another script.\r\n200128: Import-related update.\r\n200422: Modified pre- and post-object selection behavior.\r\n200504-05: Added function to adjust weight of degree 2 Bezier curves.  Refactored various code.\r\n        Added bSetMinTargetRad, fRadius_AcceptableMin, and bAdjWeightInDeg2Bezier.\r\n210317: Bug fix.\r\n210725-27: Improvements in Degree 2 Bezier weight adjustment routine.\r\n210814-16: Improvements in tangent control point routines.\r\n210908,12: Major improvements in tangent control point routines for single spanned curves.\r\n221122: Import-related update.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Diagnostics import Stopwatch\r\n\r\nimport spb_Crv_inflections\r\n\r\nif Rhino.RhinoApp.ExeVersion < 7:\r\n    import spb_Crv_radiusMinima\r\n\r\n\r\nstopwatch = Stopwatch() # One instance will be used for all tests.\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bSetMinTargetRad'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'SetMinTargetRadius'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fRadius_AcceptableMin'; keys.append(key)\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n        values[key] = 0.15\r\n    else:\r\n        values[key] = 4.0 * Rhino.RhinoMath.UnitScale(\r\n            Rhino.UnitSystem.Millimeters, to=sc.doc.ModelUnitSystem)\r\n    names[key] = 'Radius'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bLimitCrvDev'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'Dev'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAdjWeightInDeg2Bezier'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve and parameter with optional input.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n    \r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    \r\n    #go.DisablePreSelect()\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        Opts.riAddOpts['bSetMinTargetRad'](go)\r\n        if Opts.values['bSetMinTargetRad']: Opts.riAddOpts['fRadius_AcceptableMin'](go)\r\n        Opts.riAddOpts['bLimitCrvDev'](go)\r\n        if Opts.values['bLimitCrvDev']: Opts.riAddOpts['fDevTol'](go)\r\n        Opts.riAddOpts['bAdjWeightInDeg2Bezier'](go)\r\n        Opts.riAddOpts['bReplace'](go)\r\n        Opts.riAddOpts['bEcho'](go)\r\n        Opts.riAddOpts['bDebug'](go)\r\n        \r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        else:\r\n            # An option was selected or a number was entered.\r\n\r\n            if res == ri.GetResult.Number:\r\n                Opts.riOpts['fDevTol'].CurrentValue = go.Number()\r\n\r\n            if Opts.riOpts['bLimitCrvDev'].CurrentValue:\r\n                key = 'fDevTol'\r\n                if Opts.riOpts[key].CurrentValue < 0.0:\r\n                    Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n\r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            go.ClearCommandOptions()\r\n\r\n\r\ndef getMaximumDeviation(rgCrvA, rgCrvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            rgCrvA,\r\n            rgCrvB,\r\n            tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n    if rc[0]:\r\n        return rc[1]\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None: \r\n        return \"(No deviation provided)\"\r\n    if fDistance == 0.0:\r\n        return 0.0\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef createNcsWithAdjTanCpSpreadForMaxMinRad_OLD(nc0, bT1WorkEnd, fDevTol=None, nc_forDevComp=None, bDebug=False):\r\n    \"\"\"\r\n    returns list of new NurbsCurves with minimum radii larger than the original.\r\n    \"\"\"\r\n\r\n    idxCp_Pos_A = (nc0.Points.Count - 1) if bT1WorkEnd else 0\r\n    idxCp_Tan_A = (nc0.Points.Count - 2) if bT1WorkEnd else 1\r\n\r\n    fRadius_Min_In = getMinimumRadius(nc0)\r\n\r\n    if fRadius_Min_In is None: return\r\n    if bDebug: sEval='fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n\r\n    ncs_WithLargerMinRadii = []\r\n    \r\n    # Try longer and shorter tangent control point spreads.\r\n    for scaleIncr in 0.1, -0.1:\r\n        nc_A_Pre = nc0.Duplicate()\r\n        scale = 1.0 + scaleIncr\r\n\r\n        fRadius_MaxMin_ThisScaleDir = None\r\n\r\n        while True:\r\n            sc.escape_test()\r\n            nc_WIP = nc0.Duplicate()\r\n            if bDebug: sEval='scale'; print sEval+': ',eval(sEval),\r\n            xform = rg.Transform.Scale(\r\n                    anchor=nc_WIP.Points[idxCp_Pos_A].Location,\r\n                    scaleFactor=scale)\r\n            pt_Target = nc_WIP.Points[idxCp_Tan_A].Location\r\n            pt_Target.Transform(xform)\r\n            nc_WIP.Points[idxCp_Tan_A] = pt_Target\r\n            fRadius_Min_WIP = getMinimumRadius(nc_WIP)\r\n            if bDebug: sEval='fRadius_Min_WIP'; print sEval+': ',eval(sEval),\r\n            if fRadius_Min_WIP <= fRadius_Min_In:\r\n                if bDebug: sEval='fRadius_Min_WIP <= fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n                # Minimum radius is not increasing,\r\n                # so stop and capture the previous curve.\r\n                break\r\n\r\n            if fRadius_MaxMin_ThisScaleDir is not None and fRadius_Min_WIP <= fRadius_MaxMin_ThisScaleDir:\r\n                if bDebug: sEval='fRadius_Min_WIP <= fRadius_MaxMin_ThisScaleDir'; print sEval+': ',eval(sEval)\r\n                # Minimum radius is now decreasing from best found in this scale direction,\r\n                # so stop and capture the previous curve.\r\n                break\r\n\r\n            if fDevTol is not None and nc_forDevComp is not None:\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP)\r\n                if bDebug:\r\n                    sEval='dev'; print sEval+': ',eval(sEval),\r\n                    sEval='dev > fDevTol'; print sEval+': ',eval(sEval),\r\n                if dev > fDevTol:\r\n                    # Deviation is out of tolerance,\r\n                    # so capture the previous curve.\r\n                    break\r\n            elif bDebug: print\r\n\r\n            nc_A_Pre.Dispose()\r\n            nc_A_Pre = nc_WIP\r\n            scale += scaleIncr\r\n            fRadius_MaxMin_ThisScaleDir = fRadius_Min_WIP\r\n\r\n        nc_WIP.Dispose()\r\n\r\n        if scale != 1.0 + scaleIncr:\r\n            # Scale is of nc_A_Pre.\r\n            ncs_WithLargerMinRadii.append(nc_A_Pre)\r\n        else:\r\n            # Fail had occurred at first scale in this direction.\r\n            nc_A_Pre.Dispose()\r\n    \r\n    return ncs_WithLargerMinRadii\r\n\r\n\r\ndef getMinimumRadius(nc, epsilon=1e-6, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        float(maximum minimum radius)\r\n        None for no minimum or for unacceptable curve shapes.\r\n    \"\"\"\r\n\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 7:\r\n        return spb_Crv_radiusMinima.getMinimumRadius(nc_In)\r\n\r\n\r\n    pts = nc.MaxCurvaturePoints() # \"An array of points if successful, null if not successful or on error.\" from https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_MaxCurvaturePoints.htm\r\n    if pts is None or len(pts) == 0:\r\n        bIsArc, arc = nc.TryGetArc(tolerance=epsilon)\r\n        if bIsArc:\r\n            return arc.Radius\r\n        #sc.doc.Objects.AddCurve(nc)\r\n        raise ValueError(\"Why?\")\r\n    #        for pt in pts:\r\n    #            sc.doc.Objects.AddPoint(pt)\r\n\r\n    #if len(pts) > 1 and nc.Degree == 2 and nc.SpanCount==1:\r\n    #    if bDebug:\r\n    #        print \"More than 1 minimum point for Degree 2 Bezier.  Curve may be near linear.\"\r\n    #        #sc.doc.Objects.AddCurve(nc)\r\n    #        [sc.doc.Objects.AddPoint(pt) for pt in pts]\r\n    #        sc.doc.Views.Redraw(); 1/0\r\n    #    return None\r\n\r\n    ts = [nc.ClosestPoint(pt)[1] for pt in pts]\r\n\r\n    min_rad = None\r\n    t_min_rad = None\r\n\r\n    for t in ts:\r\n        curvature = nc.CurvatureAt(t).Length\r\n        if curvature <= Rhino.RhinoMath.ZeroTolerance:\r\n            raise Exception(\"curvature <= Rhino.RhinoMath.ZeroTolerance\")\r\n            return None\r\n\r\n        rad = 1.0 / nc.CurvatureAt(t).Length\r\n        \r\n        if min_rad is None or rad < min_rad:\r\n            min_rad = rad\r\n            t_min_rad = t\r\n\r\n    return min_rad\r\n\r\n\r\ndef getMinimaRadii_V7(nc, epsilon=1e-8, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        list(float(maximum minimum radius))\r\n        None for unacceptable curve shapes.\r\n    \"\"\"\r\n    pts = nc.MaxCurvaturePoints() # \"An array of points if successful, null if not successful or on error.\" from https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_MaxCurvaturePoints.htm\r\n    if pts is None or len(pts) == 0:\r\n        bIsArc, arc = nc.TryGetArc(tolerance=epsilon)\r\n        if bIsArc:\r\n            return arc.Radius\r\n        #sc.doc.Objects.AddCurve(nc)\r\n        raise ValueError(\"Why?\")\r\n    #        for pt in pts:\r\n    #            sc.doc.Objects.AddPoint(pt)\r\n\r\n    if len(pts) > 1 and nc.Degree == 2 and nc.SpanCount==1:\r\n        if bDebug:\r\n            print \"More than 1 minimum point for Degree 2 Bezier.  Curve may be near linear.\"\r\n            #sc.doc.Objects.AddCurve(nc)\r\n            [sc.doc.Objects.AddPoint(pt) for pt in pts]\r\n            sc.doc.Views.Redraw(); 1/0\r\n        return None, None\r\n\r\n    ts = [nc.ClosestPoint(pt)[1] for pt in pts]\r\n\r\n    rads = []\r\n\r\n    for t in ts:\r\n        curvature = nc.CurvatureAt(t).Length\r\n        if curvature <= Rhino.RhinoMath.ZeroTolerance:\r\n            raise Exception(\"curvature <= Rhino.RhinoMath.ZeroTolerance\")\r\n\r\n        rad = 1.0 / nc.CurvatureAt(t).Length\r\n\r\n        rads.append(rad)\r\n\r\n    return rads\r\n\r\n\r\ndef adjustWeight(nc_In, fRadius_AcceptableMin=None, fDevTol=None, nc_forDevComp=None, epsilon=1e-8, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Success: (rg.NurbsCurve(New), float(minRadius), float(deviation)), None\r\n        Fail: None, sLog\r\n    \"\"\"\r\n\r\n    if nc_In.Degree != 2 or nc_In.Points.Count > 3:\r\n        return None, \"Not a degree 2 Bezier.\"\r\n    \r\n    if nc_In.IsArc(tolerance=epsilon):\r\n        return (\r\n            None,\r\n            \"NurbsCurve is already arc-shaped (within {}),\" \\\r\n                \" and thus has a maximum minimum radius.\".format(epsilon))\r\n\r\n    idxCp_Pos_A = 0\r\n    idxCp_Tan_A = 1\r\n\r\n    fRadius_Min_In = getMinimumRadius(nc_In)\r\n\r\n    if fRadius_Min_In is None: return None, \"Minimum radius could not be obtained.\"\r\n    if bDebug: sEval='fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n    \r\n    if fRadius_AcceptableMin and fRadius_Min_In >= fRadius_AcceptableMin:\r\n        return None, \"Curve's minimum radius is already >= {}.\".format(\r\n            fRadius_AcceptableMin)\r\n\r\n    ncs_Winner_perScaleDir = [None, None]\r\n    fRadii_MaxMin_perScaleDir = [None, None]\r\n    fDev_perScaleDir = [None, None]\r\n    dev = None\r\n\r\n\r\n    def setWeight(nc, weight):\r\n        \"\"\"\r\n        This modifies input NurbsCurve.\r\n        Do not use NurbsCurvePointList.SetWeight instead since it relocates the point in R3.\r\n        https://discourse.mcneel.com/t/nurbs-definition/13114\r\n        \"\"\"\r\n        nc.Points[1] = rg.ControlPoint(nc.Points[1].Location, weight)\r\n        if nc.Points[1].Weight != weight:\r\n            raise ValueError(\"Weight was not set!\")\r\n\r\n\r\n    def doesCurveHaveMaximumMinimumRadius(nc):\r\n\r\n        if getMinimumRadius(nc) is None:\r\n            return False\r\n\r\n        nc_WIP_L = nc.Duplicate()\r\n        nc_WIP_M = nc.Duplicate()\r\n        nc_WIP_R = nc.Duplicate()\r\n\r\n        weight_toTry_L = None # This line keeps the variables in a particular order in the Rhino Python Debugger.\r\n        weight_toTry_M = nc.Points[1].Weight\r\n\r\n        weight_delta = 1e-6 #Rhino.RhinoMath.ZeroTolerance\r\n        \r\n        while True:\r\n            sc.escape_test()\r\n            weight_toTry_L = weight_toTry_M - weight_delta\r\n            weight_toTry_R = weight_toTry_M + weight_delta\r\n\r\n            # \r\n            nc_WIP_L.Points[1] = rg.ControlPoint(nc_WIP_L.Points[1].Location, weight=weight_toTry_L)\r\n            nc_WIP_M.Points[1] = rg.ControlPoint(nc_WIP_M.Points[1].Location, weight=weight_toTry_M)\r\n            nc_WIP_R.Points[1] = rg.ControlPoint(nc_WIP_R.Points[1].Location, weight=weight_toTry_R)\r\n\r\n            fRad_Min_WIP_L = getMinimumRadius(nc_WIP_L)\r\n            fRad_Min_WIP_M = getMinimumRadius(nc_WIP_M)\r\n            fRad_Min_WIP_R = getMinimumRadius(nc_WIP_R)\r\n\r\n            if bDebug:\r\n                print \"Weight delta: {}\".format(weight_delta)\r\n                print \"W:\", weight_toTry_L, weight_toTry_M, weight_toTry_R\r\n                print \"R:\", fRad_Min_WIP_L, fRad_Min_WIP_M, fRad_Min_WIP_R\r\n\r\n            if (\r\n                (fRad_Min_WIP_L is not None and fRad_Min_WIP_L < fRad_Min_WIP_M) and\r\n                (fRad_Min_WIP_R is not None and fRad_Min_WIP_R < fRad_Min_WIP_M)\r\n            ):\r\n                return True\r\n\r\n            if (\r\n                fRad_Min_WIP_L is not None and fRad_Min_WIP_M is not None and\r\n                not abs(fRad_Min_WIP_L - fRad_Min_WIP_M) <= epsilon\r\n            ):\r\n                return False\r\n\r\n            if (fRad_Min_WIP_R is not None and fRad_Min_WIP_M is not None and\r\n                not abs(fRad_Min_WIP_R - fRad_Min_WIP_M) <= epsilon\r\n            ):\r\n                return False\r\n\r\n            weight_delta *= 10.0\r\n\r\n\r\n    if doesCurveHaveMaximumMinimumRadius(nc_In):\r\n        return None, \"Weight is already set for maximum minimum radius.\"\r\n\r\n\r\n    def doEitherEndHaveRadius(nc, radius):\r\n        if areAbsEqual(radius, 1.0 / nc.CurvatureAt(nc.Domain.T0).Length):\r\n            return True\r\n        if areAbsEqual(radius, 1.0 / nc.CurvatureAt(nc.Domain.T1).Length):\r\n            return True\r\n        return False\r\n\r\n\r\n    def find_left_edge_weight(nc, starting_weight):\r\n        \"\"\"\r\n        wL will be first weight resulting in 2 minima radii.\r\n        \"\"\"\r\n\r\n        nc_WIP = nc.DuplicateCurve()\r\n\r\n        wL = 10.0\r\n        while True:\r\n            sc.escape_test()\r\n            if wL <= 0.1:\r\n                wL = 0.1\r\n                break\r\n            setWeight(nc_WIP, wL)\r\n            if len(getMinimaRadii_V7(nc_WIP)) > 1:\r\n                break\r\n            wL /= 2.0\r\n\r\n        wR = starting_weight\r\n\r\n        while True:\r\n            sc.escape_test()\r\n            wM = 0.5*wL + 0.5*wR\r\n            if areRelEqual(wM, wL):\r\n                setWeight(nc_WIP, wL)\r\n                rL = getMinimumRadius(nc_WIP)\r\n                if bDebug: print wL, rL\r\n                #if rL is not None:\r\n                #    raise Exception(\"rL should be None!\")\r\n\r\n                setWeight(nc_WIP, wM)\r\n                rM = getMinimumRadius(nc_WIP)\r\n                if bDebug: print wM, rM\r\n                if rM is not None:\r\n                    return wM\r\n                wR = wM\r\n                while True:\r\n                    sc.escape_test()\r\n                    wR += epsilon\r\n                    setWeight(nc_WIP, wR)\r\n                    rR = getMinimumRadius(nc_WIP)\r\n                    if bDebug: print wR, rR\r\n                    if rR is not None:\r\n                        nc_WIP.Dispose()\r\n                        return wR\r\n\r\n            setWeight(nc_WIP, wM)\r\n            if getMinimumRadius(nc_WIP) is None:\r\n                wL = wM\r\n            else:\r\n                wR = wM\r\n\r\n\r\n    def binarySearch(nc):\r\n\r\n        # Determine direction from current weight to search.\r\n\r\n        nc_WIP_L = nc.Duplicate()\r\n        nc_WIP_M = nc.Duplicate()\r\n        nc_WIP_R = nc.Duplicate()\r\n\r\n        good_weights = []\r\n        good_rads = []\r\n\r\n        rad = getMinimumRadius(nc)\r\n\r\n        if rad is not None:\r\n            good_weights.append(nc.Points[1].Weight)\r\n            good_rads.append(rad)\r\n\r\n        for p in range(-3,7):\r\n            weight_toTry_M = 10.0**p\r\n            nc_WIP_M.Points[1] = rg.ControlPoint(nc_WIP_M.Points[1].Location, weight=weight_toTry_M)\r\n            rad = getMinimumRadius(nc_WIP_M)\r\n            if rad is not None and rad >= sc.doc.ModelAbsoluteTolerance:\r\n                good_weights.append(weight_toTry_M)\r\n                good_rads.append(rad)\r\n\r\n        fRad_Min_WIP_M = max(good_rads)\r\n        weight_toTry_M = good_weights[good_rads.index(max(good_rads))]\r\n\r\n        weight_toTry_L = find_left_edge_weight(nc, starting_weight=weight_toTry_M)\r\n\r\n        weight_toTry_R = 10.0\r\n\r\n\r\n        setWeight(nc_WIP_L, weight_toTry_L)\r\n        fRad_Min_WIP_L = getMinimumRadius(nc_WIP_L)\r\n\r\n        setWeight(nc_WIP_R, weight_toTry_R)\r\n        fRad_Min_WIP_R = getMinimumRadius(nc_WIP_R)\r\n\r\n        if fRad_Min_WIP_L > fRad_Min_WIP_M:\r\n            weight_toTry_M = weight_toTry_L + epsilon\r\n            setWeight(nc_WIP_M, weight_toTry_M)\r\n            fRad_Min_WIP_M = getMinimumRadius(nc_WIP_M)\r\n            dev = getMaximumDeviation(nc_forDevComp, nc_WIP_L)\r\n            if fRad_Min_WIP_L > fRad_Min_WIP_M:\r\n                return (nc_WIP_L, fRad_Min_WIP_L, dev), None\r\n            weight_toTry_M = 0.5*weight_toTry_L + 0.5*weight_toTry_R\r\n\r\n        if fRad_Min_WIP_R > fRad_Min_WIP_M:\r\n            raise ValueError(\"R radius should not be greater than M.\")\r\n\r\n\r\n        i = 0\r\n\r\n        while True:\r\n            sc.escape_test()\r\n            \r\n            # Do not use SetWeight.  https://discourse.mcneel.com/t/nurbs-definition/13114\r\n            nc_WIP_L.Points[1] = rg.ControlPoint(nc_WIP_L.Points[1].Location, weight=weight_toTry_L)\r\n            nc_WIP_M.Points[1] = rg.ControlPoint(nc_WIP_M.Points[1].Location, weight=weight_toTry_M)\r\n            nc_WIP_R.Points[1] = rg.ControlPoint(nc_WIP_R.Points[1].Location, weight=weight_toTry_R)\r\n\r\n\r\n            fRad_Min_WIP_L = getMinimumRadius(nc_WIP_L)\r\n            fRad_Min_WIP_M = getMinimumRadius(nc_WIP_M)\r\n            fRad_Min_WIP_R = getMinimumRadius(nc_WIP_R)\r\n\r\n            if bDebug:\r\n                print \"i{} W:\".format(i), weight_toTry_L, weight_toTry_M, weight_toTry_R\r\n                print \"i{} R:\".format(i), fRad_Min_WIP_L, fRad_Min_WIP_M, fRad_Min_WIP_R\r\n\r\n            if areRelEqual(weight_toTry_L, weight_toTry_R):\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP_M)\r\n                nc_WIP_L.Dispose()\r\n                nc_WIP_R.Dispose()\r\n                return (nc_WIP_M, fRad_Min_WIP_M, dev), None\r\n\r\n            if fRad_Min_WIP_L is not None:\r\n                if areAbsEqual(fRad_Min_WIP_L, fRad_Min_WIP_R):\r\n                    if areAbsEqual(fRad_Min_WIP_M, fRad_Min_WIP_R):\r\n                        dev = getMaximumDeviation(nc_forDevComp, nc_WIP_M)\r\n                        nc_WIP_L.Dispose()\r\n                        nc_WIP_R.Dispose()\r\n                        return (nc_WIP_M, fRad_Min_WIP_M, dev), None\r\n            \r\n            if fRad_Min_WIP_M > fRad_Min_WIP_L and fRad_Min_WIP_M > fRad_Min_WIP_R:\r\n                if fRad_Min_WIP_L > fRad_Min_WIP_R:\r\n                    weight_toTry_R = 0.75*weight_toTry_R + 0.25*weight_toTry_M\r\n                elif fRad_Min_WIP_L < fRad_Min_WIP_R:\r\n                    weight_toTry_L = 0.75*weight_toTry_L + 0.25*weight_toTry_M\r\n                else:\r\n                    raise ValueError(\"asdf\")\r\n                #weight_toTry_L = 0.75*weight_toTry_L + 0.25*weight_toTry_M\r\n                #weight_toTry_R = 0.75*weight_toTry_R + 0.25*weight_toTry_M\r\n            elif fRad_Min_WIP_L > fRad_Min_WIP_R and fRad_Min_WIP_M > fRad_Min_WIP_R:\r\n                weight_toTry_R = weight_toTry_M\r\n            elif fRad_Min_WIP_R > fRad_Min_WIP_L and fRad_Min_WIP_M > fRad_Min_WIP_L:\r\n                weight_toTry_L = weight_toTry_M\r\n            else:\r\n                print \"Is this possible?:\"\r\n                sEval='fRadius_Min_WIP_L'; print '  '+sEval+': ',eval(sEval)\r\n                sEval='fRadius_Min_WIP_C'; print '  '+sEval+': ',eval(sEval)\r\n                sEval='fRadius_Min_WIP_R'; print '  '+sEval+': ',eval(sEval)\r\n            weight_toTry_M = 0.5*weight_toTry_L + 0.5*weight_toTry_R\r\n            \r\n            i += 1\r\n\r\n\r\n    rc = binarySearch(nc_In)\r\n\r\n    if rc[0] is None:\r\n        return rc\r\n\r\n    if fRadius_AcceptableMin is None and fDevTol is None:\r\n        return rc\r\n\r\n    nc_Ret, fRadius_Min_Res, fDev_Res = rc[0]\r\n\r\n    if fRadius_AcceptableMin is None and fDevTol is not None:\r\n        if fDev_Res <= fDevTol:\r\n            return rc\r\n\r\n        # Will try code below.\r\n\r\n    elif fRadius_AcceptableMin is not None and fDevTol is None:\r\n        if fRadius_Min_Res >= fRadius_AcceptableMin:\r\n            return rc\r\n        else:\r\n            return None, \"Minimum radius cannot be achieved.\"\r\n\r\n    elif fRadius_AcceptableMin is not None and fDevTol is not None:\r\n        sLogs = []\r\n        if fRadius_Min_Res < fRadius_AcceptableMin:\r\n            return None, \"Minimum radius cannot be achieved.\"\r\n        if fDev_Res <= fDevTol:\r\n            return rc\r\n\r\n        # Will try code below.\r\n\r\n\r\n    # TODO: Rewrite the following code by testing weights between\r\n    # starting weight of nc_In and weight of nc_Ret.\r\n\r\n    # Try weights less than and greater than starting weight.\r\n    for iDir, weightDelta in enumerate((-0.01, 0.01)):\r\n        weight_toTry = nc_In.Points[1].Weight + weightDelta\r\n\r\n        while True:\r\n            sc.escape_test()\r\n            nc_WIP = nc_In.Duplicate()\r\n\r\n            if bDebug:\r\n                sEval='weight_toTry'; print sEval+': ',eval(sEval)\r\n\r\n            nc_WIP.Points[1] = rg.ControlPoint(nc_WIP.Points[1].Location, weight=weight_toTry)\r\n\r\n            if bDebug: stopwatch.Restart()\r\n            fRadius_Min_WIP = getMinimumRadius(nc_WIP)\r\n            if bDebug:\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                s += \"getMinimumRadius\"\r\n                print s\r\n                sEval='fRadius_Min_WIP'; print '  '+sEval+': ',eval(sEval),\r\n\r\n            if fRadius_Min_WIP <= fRadius_Min_In:\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP <= fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n                    print \"  Minimum radius is not increasing,\" \\\r\n                          \" so break.\"\r\n                break\r\n\r\n            if fDevTol is not None and nc_forDevComp is not None:\r\n                if bDebug: stopwatch.Restart()\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP)\r\n                if bDebug:\r\n                    stopwatch.Stop()\r\n                    timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                    s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                    s += \"getMaximumDeviation\"\r\n                    print s\r\n                    sEval='dev'; print sEval+': ',eval(sEval),\r\n                    sEval='dev > fDevTol'; print sEval+': ',eval(sEval)\r\n                if dev > fDevTol:\r\n                    if bDebug:\r\n                        print \"  Deviation is out of tolerance, so break.\"\r\n                    break\r\n\r\n            if fRadius_AcceptableMin and fRadius_Min_WIP >= fRadius_AcceptableMin:\r\n                print \"Curve's minimum radius, {} is >= {}.\".format(\r\n                    fRadius_Min_WIP, fRadius_AcceptableMin)\r\n                return (nc_WIP, fRadius_Min_WIP, fDevTol), None\r\n        \r\n            if bDebug:\r\n                print \"Curve minimum radius is larger than that of the starting curve.\"\r\n\r\n            if ncs_Winner_perScaleDir[iDir] is None:\r\n                ncs_Winner_perScaleDir[iDir] = nc_WIP\r\n                fRadii_MaxMin_perScaleDir[iDir] = fRadius_Min_WIP\r\n                fDev_perScaleDir[iDir] = dev\r\n                \r\n                weight_toTry += weightDelta\r\n                continue\r\n\r\n            if fRadius_Min_WIP > fRadii_MaxMin_perScaleDir[iDir]:\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP > fRadii_MaxMin_perScaleDir[iDir]'; print sEval+': ',eval(sEval)\r\n                    print \"Minimum radius is increasing.\"\r\n                ncs_Winner_perScaleDir[iDir].Dispose()\r\n                \r\n                ncs_Winner_perScaleDir[iDir] = nc_WIP\r\n                fRadii_MaxMin_perScaleDir[iDir] = fRadius_Min_WIP\r\n                fDev_perScaleDir[iDir] = dev\r\n                \r\n                weight_toTry += weightDelta\r\n                continue\r\n\r\n\r\n            if bDebug:\r\n                print \"Curve minimum radius is no longer increasing, so break\"\r\n\r\n            nc_WIP.Dispose()\r\n\r\n            break\r\n\r\n    if not (ncs_Winner_perScaleDir[0] or ncs_Winner_perScaleDir[1]):\r\n        return None, \"No curves with increased minimum radius found at given parameters.\"\r\n\r\n    if ncs_Winner_perScaleDir[0] and ncs_Winner_perScaleDir[1]:\r\n        iDir_Winner = fRadii_MaxMin_perScaleDir.index(max(fRadii_MaxMin_perScaleDir))\r\n    else:\r\n        iDir_Winner = 0 if ncs_Winner_perScaleDir[0] else 1\r\n\r\n    return (\r\n        (\r\n            ncs_Winner_perScaleDir[iDir_Winner],\r\n            fRadii_MaxMin_perScaleDir[iDir_Winner],\r\n            fDev_perScaleDir[iDir_Winner]\r\n        ),\r\n        None)\r\n\r\n\r\ndef adjustTanCpSpread_OneEndOnly(nc_In, bT1WorkEnd, fRadius_AcceptableMin=None, fDevTol=None, nc_forDevComp=None, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Success: rg.NurbsCurve(New), float(minRadius), float(deviation)\r\n        Fail: None, str(Feedback)\r\n    \r\n    This is not the latest function.\r\n    \"\"\"\r\n\r\n    idxCp_Pos_A = (nc_In.Points.Count - 1) if bT1WorkEnd else 0\r\n    idxCp_Tan_A = (nc_In.Points.Count - 2) if bT1WorkEnd else 1\r\n\r\n    fRadius_Min_In = getMinimumRadius(nc_In)\r\n\r\n    if fRadius_Min_In is None:\r\n        return None, \"Minimum radius could not be obtained.\"\r\n    if bDebug: sEval='fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n    \r\n    if fRadius_AcceptableMin and fRadius_Min_In >= fRadius_AcceptableMin:\r\n        return None, \"Curve's minimum radius is already >= {}.\".format(\r\n            fRadius_AcceptableMin)\r\n\r\n    ncs_Winner_perScaleDir = [None, None]\r\n    fRadii_MaxMin_perScaleDir = [None, None]\r\n    fDev_perScaleDir = [None, None]\r\n    dev = None\r\n    \r\n    vTan = nc_In.Points[idxCp_Tan_A].Location - nc_In.Points[idxCp_Pos_A].Location\r\n    vTan.Unitize()\r\n\r\n    radius_epsilon = (1e-3) * sc.doc.ModelAbsoluteTolerance\r\n\r\n    # Try longer and shorter tangent control point spreads.\r\n    for iDir, scaleDelta in enumerate((-0.01, 0.01)):\r\n        #scale = 1.0 + scaleDelta\r\n\r\n        i = 1\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            nc_WIP = nc_In.Duplicate()\r\n\r\n            #if bDebug: sEval='scale'; print sEval+': ',eval(sEval),\r\n\r\n            #xform = rg.Transform.Scale(\r\n            #        anchor=nc_WIP.Points[idxCp_Pos_A].Location,\r\n            #        scaleFactor=scale)\r\n            #pt_Target = nc_WIP.Points[idxCp_Tan_A].Location\r\n            #pt_Target.Transform(xform)\r\n\r\n            vTrans = float(i) * sc.doc.ModelAbsoluteTolerance * vTan\r\n            if iDir == 0:\r\n                vTrans = rg.Vector3d.Negate(vTrans)\r\n\r\n            xform = rg.Transform.Translation(vTrans)\r\n            pt_Target = nc_In.Points[idxCp_Tan_A].Location\r\n            pt_Target.Transform(xform)\r\n\r\n            nc_WIP.Points[idxCp_Tan_A] = pt_Target\r\n            if bDebug: stopwatch.Restart()\r\n            fRadius_Min_WIP = getMinimumRadius(nc_WIP)\r\n            if bDebug:\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                s += \"getMinimumRadius\"\r\n                print s\r\n                sEval='fRadius_Min_WIP'; print '  '+sEval+': ',eval(sEval),\r\n\r\n            if (fRadius_Min_WIP - radius_epsilon) <= fRadius_Min_In:\r\n                #sc.doc.Objects.AddCurve(nc_WIP)#;1/0\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP <= fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n                    print \"  Minimum radius is not increasing,\" \\\r\n                          \" so break.\"\r\n                break\r\n\r\n            if fDevTol is not None and nc_forDevComp is not None:\r\n                if bDebug: stopwatch.Restart()\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP)\r\n                if bDebug:\r\n                    stopwatch.Stop()\r\n                    timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                    s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                    s += \"getMaximumDeviation\"\r\n                    print s\r\n                    sEval='dev'; print sEval+': ',eval(sEval),\r\n                    sEval='dev > fDevTol'; print sEval+': ',eval(sEval)\r\n                if dev > fDevTol:\r\n                    if bDebug:\r\n                        print \"  Deviation is out of tolerance, so break.\"\r\n                    break\r\n\r\n            if fRadius_AcceptableMin:\r\n                if (fRadius_Min_WIP + radius_epsilon) >= fRadius_AcceptableMin:\r\n                    print \"Curve's minimum radius, {} is >= {}.\".format(\r\n                        fRadius_Min_WIP, fRadius_AcceptableMin)\r\n                    return (nc_WIP, fRadius_Min_WIP, fDevTo), None\r\n\r\n            if bDebug:\r\n                print \"Curve minimum radius is larger than that of the starting curve.\"\r\n\r\n            if ncs_Winner_perScaleDir[iDir] is None:\r\n                ncs_Winner_perScaleDir[iDir] = nc_WIP\r\n                fRadii_MaxMin_perScaleDir[iDir] = fRadius_Min_WIP\r\n                fDev_perScaleDir[iDir] = dev\r\n\r\n                #scale += scaleDelta\r\n                i += 1\r\n                continue\r\n\r\n            if (fRadius_Min_WIP - radius_epsilon) > fRadii_MaxMin_perScaleDir[iDir]:\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP > fRadii_MaxMin_perScaleDir[iDir]'; print sEval+': ',eval(sEval)\r\n                    print \"Minimum radius is increasing.\"\r\n                ncs_Winner_perScaleDir[iDir].Dispose()\r\n                \r\n                ncs_Winner_perScaleDir[iDir] = nc_WIP\r\n                fRadii_MaxMin_perScaleDir[iDir] = fRadius_Min_WIP\r\n                fDev_perScaleDir[iDir] = dev\r\n\r\n                #scale += scaleDelta\r\n                i += 1\r\n                continue\r\n\r\n\r\n            if bDebug:\r\n                print \"Curve minimum radius is no longer increasing, so break\"\r\n\r\n            nc_WIP.Dispose()\r\n\r\n            break\r\n\r\n    if not (ncs_Winner_perScaleDir[0] or ncs_Winner_perScaleDir[1]):\r\n        return None, \"No winner.\"\r\n\r\n    if ncs_Winner_perScaleDir[0] and ncs_Winner_perScaleDir[1]:\r\n        iDir_Winner = fRadii_MaxMin_perScaleDir.index(max(fRadii_MaxMin_perScaleDir))\r\n    else:\r\n        iDir_Winner = 0 if ncs_Winner_perScaleDir[0] else 1\r\n\r\n    return (\r\n        (\r\n            ncs_Winner_perScaleDir[iDir_Winner],\r\n            fRadii_MaxMin_perScaleDir[iDir_Winner],\r\n            fDev_perScaleDir[iDir_Winner]\r\n        ),\r\n        None)\r\n\r\n\r\ndef adjustTanCpSpread_BothEndsSimultaneously(nc_In, fRadius_AcceptableMin=None, fDevTol=None, nc_forDevComp=None, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Success: rg.NurbsCurve(New), float(minRadius), float(deviation)\r\n        Fail: None, str(Feedback)\r\n    \r\n    210908: New.\r\n    \"\"\"\r\n\r\n    idx_G0_T0 = 0\r\n    idx_G1_T0 = 1\r\n    idx_G0_T1 = nc_In.Points.Count - 1\r\n    idx_G1_T1 = nc_In.Points.Count - 2\r\n\r\n\r\n    fRadius_Min_In = getMinimumRadius(nc_In)\r\n\r\n    if fRadius_Min_In is None:\r\n        return None, \"Minimum radius could not be obtained.\"\r\n    if bDebug: sEval='fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n    \r\n    if fRadius_AcceptableMin and fRadius_Min_In >= fRadius_AcceptableMin:\r\n        return None, \"Curve's minimum radius is already >= {}.\".format(\r\n            fRadius_AcceptableMin)\r\n\r\n    ncs_Winner_perScaleDir = []\r\n    fRadii_MaxMin_perScaleDir = []\r\n    fDev_perScaleDir = []\r\n    dev = None\r\n\r\n    vTan_T0 = nc_In.Points[idx_G1_T0].Location - nc_In.Points[idx_G0_T0].Location\r\n    vTan_T0.Unitize()\r\n\r\n    vTan_T1 = nc_In.Points[idx_G0_T1].Location - nc_In.Points[idx_G1_T1].Location\r\n    vTan_T1.Unitize()\r\n\r\n    radius_epsilon = (1e-3) * sc.doc.ModelAbsoluteTolerance\r\n\r\n    # Try longer and shorter tangent control point spreads.\r\n    for iDir_T0, iDir_T1 in zip((0,0,1,1),(0,1,0,1)):\r\n        sc.escape_test()\r\n\r\n        ncs_Winner_thisScaleDir = None\r\n        fRadii_MaxMin_thisScaleDir = None\r\n        fDev_thisScaleDir = None\r\n\r\n        i = 1\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            if bDebug: sEval='i'; print sEval+': ',eval(sEval)\r\n\r\n            nc_WIP = nc_In.Duplicate()\r\n\r\n            vTrans_T0 = float(i) * sc.doc.ModelAbsoluteTolerance * vTan_T0\r\n            vTrans_T1 = float(i) * sc.doc.ModelAbsoluteTolerance * vTan_T1\r\n\r\n            if iDir_T0 == 0:\r\n                vTrans_T0 = rg.Vector3d.Negate(vTrans_T0)\r\n            if iDir_T1 == 0:\r\n                vTrans_T1 = rg.Vector3d.Negate(vTrans_T1)\r\n\r\n            xform_G1_T0 = rg.Transform.Translation(vTrans_T0)\r\n            pt_Target = nc_In.Points[idx_G1_T0].Location\r\n            pt_Target.Transform(xform_G1_T0)\r\n\r\n            nc_WIP.Points[idx_G1_T0] = pt_Target\r\n\r\n            xform_G1_T1 = rg.Transform.Translation(vTrans_T1)\r\n            pt_Target = nc_In.Points[idx_G1_T1].Location\r\n            pt_Target.Transform(xform_G1_T1)\r\n\r\n            nc_WIP.Points[idx_G1_T1] = pt_Target\r\n\r\n\r\n            fRadius_Min_WIP = getMinimumRadius(nc_WIP)\r\n            if bDebug:\r\n                sEval='fRadius_Min_WIP'; print '  '+sEval+': ',eval(sEval),\r\n\r\n            if (fRadius_Min_WIP - radius_epsilon) <= fRadius_Min_In:\r\n                #sc.doc.Objects.AddCurve(nc_WIP)#;1/0\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP <= fRadius_Min_In'; print sEval+': ',eval(sEval)\r\n                    print \"  Minimum radius is not increasing,\" \\\r\n                          \" so break.\"\r\n                break\r\n\r\n            if fDevTol is not None and nc_forDevComp is not None:\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP)\r\n                if bDebug:\r\n                    sEval='dev'; print sEval+': ',eval(sEval),\r\n                    sEval='dev > fDevTol'; print sEval+': ',eval(sEval)\r\n                if dev > fDevTol:\r\n                    if bDebug:\r\n                        print \"  Deviation is out of tolerance, so break.\"\r\n                    break\r\n\r\n            if fRadius_AcceptableMin:\r\n                if (fRadius_Min_WIP + radius_epsilon) >= fRadius_AcceptableMin:\r\n                    print \"Curve's minimum radius, {} is >= {}.\".format(\r\n                        fRadius_Min_WIP, fRadius_AcceptableMin)\r\n                    return (nc_WIP, fRadius_Min_WIP, fDevTo), None\r\n\r\n            if bDebug:\r\n                print \"Curve minimum radius is larger than that of the starting curve.\"\r\n\r\n            if ncs_Winner_thisScaleDir is None:\r\n                ncs_Winner_thisScaleDir = nc_WIP\r\n                fRadii_MaxMin_thisScaleDir = fRadius_Min_WIP\r\n                fDev_thisScaleDir = dev\r\n\r\n                i += 1\r\n                continue\r\n\r\n            if (fRadius_Min_WIP - radius_epsilon) > fRadii_MaxMin_thisScaleDir:\r\n                if bDebug:\r\n                    sEval='fRadius_Min_WIP > fRadii_MaxMin_thisScaleDir'; print sEval+': ',eval(sEval)\r\n                    print \"Minimum radius is increasing.\"\r\n                ncs_Winner_thisScaleDir.Dispose()\r\n                \r\n                ncs_Winner_thisScaleDir = nc_WIP\r\n                fRadii_MaxMin_thisScaleDir = fRadius_Min_WIP\r\n                fDev_thisScaleDir = dev\r\n\r\n                i += 1\r\n                continue\r\n\r\n\r\n            if bDebug:\r\n                print \"Curve minimum radius is no longer increasing, so break\"\r\n\r\n            nc_WIP.Dispose()\r\n\r\n            break\r\n\r\n\r\n    if ncs_Winner_thisScaleDir is not None:\r\n        ncs_Winner_perScaleDir.append(ncs_Winner_thisScaleDir)\r\n        fRadii_MaxMin_perScaleDir.append(fRadii_MaxMin_thisScaleDir)\r\n        fDev_perScaleDir.append(fDev_thisScaleDir)\r\n\r\n\r\n    if len(ncs_Winner_perScaleDir) == 0:\r\n        return None, \"No winner.\"\r\n\r\n\r\n    if len(ncs_Winner_perScaleDir) == 1:\r\n        return (\r\n            (\r\n                ncs_Winner_perScaleDir[0],\r\n                fRadii_MaxMin_perScaleDir[0],\r\n                fDev_perScaleDir[0]\r\n            ),\r\n            None)\r\n\r\n\r\n    idx_Winner = fRadii_MaxMin_perScaleDir.index(max(fRadii_MaxMin_perScaleDir))\r\n\r\n    return (\r\n        (\r\n            ncs_Winner_perScaleDir[idx_Winner],\r\n            fRadii_MaxMin_perScaleDir[idx_Winner],\r\n            fDev_perScaleDir[idx_Winner]\r\n        ),\r\n        None)\r\n\r\n\r\ndef areAbsEqual(a, b, decimal_tolerance=None):\r\n    if decimal_tolerance is None: decimal_tolerance = 1e-6\r\n    return abs(a-b) <= decimal_tolerance\r\n\r\n\r\ndef areRelEqual(a, b, decimal_tolerance=None):\r\n    if decimal_tolerance is None: decimal_tolerance = 1e-6\r\n    return abs(a-b)/max(a,b) <= decimal_tolerance\r\n\r\n\r\ndef adjustTanCpSpread_IsolatedEnd(nc_In, bT1WorkEnd, fRadius_AcceptableMin=None, fDevTol=None, nc_forDevComp=None, epsilon=1e-8, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Success: tuple(rg.NurbsCurve(New), float(minRadius), float(deviation)), None\r\n        Fail: None, str(Feedback)\r\n    \r\n    Recreated using epsilon and binary search and trimming curve to study only the working end.\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 7:\r\n        raise Exception(\"Unsupported routine for Rhino < 7.\")\r\n\r\n    fRads_Min_In_Whole = getMinimaRadii_V7(nc_In, bDebug=bDebug)\r\n\r\n    if fRads_Min_In_Whole is None:\r\n        return None, \"Minimum radii could not be obtained.\"\r\n    if bDebug: sEval='fRads_Min_In_Whole'; print sEval+': ',eval(sEval)\r\n    \r\n    if fRadius_AcceptableMin and fRads_Min_In_Whole >= fRadius_AcceptableMin:\r\n        return None, \"Curve's minimum radius is already >= {}.\".format(\r\n            fRadius_AcceptableMin)\r\n\r\n    if nc_In.SpanCount == 1:\r\n        print \"Single-spanned curve.\"\r\n        t_Trim_T0 = t_Trim_T1 = None\r\n    else:\r\n        if bT1WorkEnd:\r\n            m = nc_In.Knots.KnotMultiplicity(nc_In.Knots.Count - nc_In.Degree - 1)\r\n            if m > 1:\r\n                # Last segment.\r\n                t_Trim_T0 = nc_In.Knots[nc_In.Knots.Count - nc_In.Degree - 1]\r\n                t_Trim_T1 = nc_In.Domain.T1\r\n            else:\r\n                # m == 1\r\n                if nc_In.SpanCount == 2:\r\n                    t_Trim_T0 = t_Trim_T1 = None\r\n                else:\r\n                    # Last 2 segments.\r\n                    t_Trim_T0 = nc_In.Knots[nc_In.Knots.Count - nc_In.Degree - 2]\r\n                    t_Trim_T1 = nc_In.Domain.T1\r\n        else:\r\n            m = nc_In.Knots.KnotMultiplicity(nc_In.Degree)\r\n            if m > 1:\r\n                # First segment.\r\n                t_Trim_T0 = nc_In.Domain.T0\r\n                t_Trim_T1 = nc_In.Knots[nc_In.Degree]\r\n            else:\r\n                # m == 1\r\n                if nc_In.SpanCount == 2:\r\n                    t_Trim_T0 = t_Trim_T1 = None\r\n                else:\r\n                    # First 2 segments.\r\n                    t_Trim_T0 = nc_In.Domain.T0\r\n                    t_Trim_T1 = nc_In.Knots[nc_In.Degree + 1]\r\n\r\n    if bT1WorkEnd:\r\n        idxCp_G0 = nc_In.Points.Count - 1\r\n        idxCp_G1 = nc_In.Points.Count - 2\r\n        idxCp_G2 = nc_In.Points.Count - 3\r\n        vPosToTan = -nc_In.TangentAtEnd\r\n    else:\r\n        idxCp_G0 = 0\r\n        idxCp_G1 = 1\r\n        idxCp_G2 = 2\r\n        vPosToTan = nc_In.TangentAtStart\r\n\r\n\r\n    ncs_Winner_perScaleDir = [None, None]\r\n    fRadii_MaxMin_perScaleDir = [None, None]\r\n    fDev_perScaleDir = [None, None]\r\n    dev = None\r\n\r\n    epsilon_pt_loc = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    # New code.  TODO: Describe this.\r\n    def createEvalCurve(nc):\r\n        if t_Trim_T0 is None:\r\n            return nc.DuplicateCurve()\r\n        return nc.Trim(t0=t_Trim_T0, t1=t_Trim_T1)\r\n\r\n\r\n    nc_In_Eval = createEvalCurve(nc_In)\r\n    #sc.doc.Objects.AddCurve(nc_In_Eval); #sc.doc.Views.Redraw(); 1/0\r\n\r\n    fRads_Mins_In_Eval = getMinimaRadii_V7(nc_In_Eval, bDebug=bDebug)\r\n\r\n    if nc_In.SpanCount == 1 and len(fRads_Mins_In_Eval) == 2:\r\n        #print abs(fRads_Mins_In_Eval[0] - fRads_Mins_In_Eval[1])\r\n        if areAbsEqual(fRads_Mins_In_Eval[0], fRads_Mins_In_Eval[1]):\r\n            return None, \"Single-spanned curve already contains 2 equal minima radius.\" \\\r\n                \"  TODO: Simultaneously modify 2nd control points on both ends.\"\r\n\r\n\r\n    def largerRadiusDirection(nc):\r\n        \"\"\"\r\n        Returns: -1 for shorter, +1 for longer, 0 for no change.\r\n        \"\"\"\r\n\r\n        nc_0_Eval = createEvalCurve(nc)\r\n\r\n        fRads_0_Eval = getMinimaRadii_V7(nc_0_Eval, bDebug=bDebug)\r\n\r\n        nc_Longer = nc.DuplicateCurve()\r\n        nc_Longer.Points[idxCp_G1] = rg.Point3d(\r\n            nc.Points[idxCp_G1].Location + epsilon_pt_loc*vPosToTan)\r\n        #sc.doc.Objects.AddCurve(nc_Longer)\r\n\r\n        nc_Longer_Eval = createEvalCurve(nc_Longer)\r\n        #sc.doc.Objects.AddCurve(nc_Longer_Eval); #sc.doc.Views.Redraw(); 1/0\r\n\r\n        fRads_Longer_Eval = getMinimaRadii_V7(nc_Longer_Eval, bDebug=bDebug)\r\n\r\n        nc_Shorter = nc.DuplicateCurve()\r\n        nc_Shorter.Points[idxCp_G1] = rg.Point3d(\r\n            nc.Points[idxCp_G1].Location - epsilon_pt_loc*vPosToTan)\r\n        #sc.doc.Objects.AddCurve(nc_Shorter); sc.doc.Views.Redraw(); 1/0\r\n\r\n        nc_Shorter_Eval = createEvalCurve(nc_Shorter)\r\n        #sc.doc.Objects.AddCurve(nc_Shorter_Eval); sc.doc.Views.Redraw(); 1/0\r\n\r\n        fRads_Shorter_Eval = getMinimaRadii_V7(nc_Shorter_Eval, bDebug=bDebug)\r\n\r\n        #sEval='fRads_Shorter_Eval'; print sEval+': ',eval(sEval)\r\n        #sEval='fRads_0_Eval'; print sEval+': ',eval(sEval)\r\n        #sEval='fRads_Longer_Eval'; print sEval+': ',eval(sEval)\r\n\r\n        fRad_Min_0_Eval = min(fRads_0_Eval)\r\n        fRad_Min_Shorter_Eval = min(fRads_Shorter_Eval)\r\n        fRad_Min_Longer_Eval = min(fRads_Longer_Eval)\r\n\r\n        if (\r\n            areAbsEqual(fRad_Min_0_Eval, fRad_Min_Longer_Eval) and\r\n            areAbsEqual(fRad_Min_0_Eval, fRad_Min_Shorter_Eval)\r\n        ):\r\n            return 0\r\n        elif fRad_Min_Longer_Eval > fRad_Min_0_Eval and fRad_Min_Shorter_Eval > fRad_Min_0_Eval:\r\n            raise Exception(\"How can both modifications result in larger minimum radius?\")\r\n        else:\r\n            if fRad_Min_Longer_Eval > fRad_Min_0_Eval:\r\n                return 1\r\n            elif fRad_Min_Shorter_Eval > fRad_Min_0_Eval:\r\n                return -1\r\n            else:\r\n                return 0\r\n                sEval='fRad_Min_Shorter_Eval'; print sEval+': ',eval(sEval)\r\n                sEval='fRad_Min_0_Eval'; print sEval+': ',eval(sEval)\r\n                sEval='fRad_Min_Longer_Eval'; print sEval+': ',eval(sEval)\r\n                raise Exception(\"What happened?\")\r\n\r\n    iDir = largerRadiusDirection(nc_In)\r\n\r\n\r\n    if iDir == 0:\r\n        return None, \"Minimum radius is already at its maximum.\"\r\n\r\n    dist_G0_to_G1 = nc_In.Points[idxCp_G0].Location.DistanceTo(nc_In.Points[idxCp_G1].Location)\r\n    dist_G0_to_G2 = nc_In.Points[idxCp_G0].Location.DistanceTo(nc_In.Points[idxCp_G2].Location)\r\n\r\n    if iDir == 1:\r\n        dist_L = dist_G0_to_G1\r\n        # TODO: Is there something better than 0.99?\r\n        dist_H = 0.99 * dist_G0_to_G2\r\n    elif iDir == -1:\r\n        # TODO: Is there something better than 0.01?\r\n        dist_L = 0.01 * dist_G0_to_G2\r\n        dist_H = dist_G0_to_G1\r\n\r\n\r\n\r\n    while not areAbsEqual(dist_L, dist_H):\r\n        if sc.escape_test(throw_exception=False):\r\n            sc.doc.Objects.AddCurve(nc_WIP_M); sc.doc.Views.Redraw()\r\n            raise Exception(\"Escape key pressed.  Current WIP curve was added.\")\r\n\r\n        nc_WIP_L = nc_In.DuplicateCurve()\r\n        nc_WIP_L.Points[idxCp_G1] = rg.Point3d(nc_In.Points[idxCp_G0].Location + dist_L*vPosToTan)\r\n        fRad_Min_L = getMinimumRadius(createEvalCurve(nc_WIP_L))\r\n\r\n        nc_WIP_H = nc_In.DuplicateCurve()\r\n        nc_WIP_H.Points[idxCp_G1] = rg.Point3d(nc_In.Points[idxCp_G0].Location + dist_H*vPosToTan)\r\n        fRad_Min_H = getMinimumRadius(createEvalCurve(nc_WIP_H))\r\n\r\n        dist_M = 0.5*(dist_L + dist_H)\r\n\r\n        nc_WIP_M = nc_In.DuplicateCurve()\r\n        nc_WIP_M.Points[idxCp_G1] = rg.Point3d(nc_In.Points[idxCp_G0].Location + dist_M*vPosToTan)\r\n        fRad_Min_M = getMinimumRadius(createEvalCurve(nc_WIP_M))\r\n\r\n        if bDebug:\r\n            print '-'*20\r\n            sEval='dist_L'; print sEval+': ',eval(sEval)\r\n            sEval='  fRad_Min_L'; print sEval+': ',eval(sEval)\r\n            sEval='dist_M'; print sEval+': ',eval(sEval)\r\n            sEval='  fRad_Min_M'; print sEval+': ',eval(sEval)\r\n            sEval='dist_H'; print sEval+': ',eval(sEval)\r\n            sEval='  fRad_Min_H'; print sEval+': ',eval(sEval)\r\n\r\n        if areAbsEqual(fRad_Min_L, fRad_Min_H):\r\n            if bDebug:\r\n                sEval='dist_L'; print sEval+': ',eval(sEval)\r\n                sEval='dist_H'; print sEval+': ',eval(sEval)\r\n\r\n            return (nc_WIP_M, fRad_Min_M, None), None\r\n\r\n\r\n        if fRad_Min_M > fRad_Min_H > fRad_Min_L:\r\n            if bDebug: print \"M > H > L\"\r\n            dist_L = dist_M\r\n\r\n        elif fRad_Min_M > fRad_Min_L > fRad_Min_H:\r\n            if bDebug: print \"M > L > H\"\r\n            dist_L = dist_M\r\n\r\n        elif fRad_Min_M > fRad_Min_L and fRad_Min_M > fRad_Min_H:\r\n            if bDebug: print \"Mid has largest radius.\"\r\n\r\n            iDir = largerRadiusDirection(nc_WIP_M)\r\n\r\n            if iDir == 0:\r\n                raise Exception(\"No change in radius.\")\r\n            if iDir == 1:\r\n                dist_L = dist_M\r\n            elif iDir == -1:\r\n                dist_H = dist_M\r\n\r\n        elif fRad_Min_H > fRad_Min_M > fRad_Min_L:\r\n            if bDebug: print \"H > M > L\"\r\n            dist_L = dist_M\r\n\r\n        elif fRad_Min_L > fRad_Min_M > fRad_Min_H:\r\n            if bDebug: print \"L > M > H\"\r\n            dist_H = dist_M\r\n\r\n\r\n    return (nc_WIP_M, fRad_Min_M, None), None\r\n\r\n\r\n\r\n    if not (ncs_Winner_perScaleDir[0] or ncs_Winner_perScaleDir[1]):\r\n        return None, \"No winner.\"\r\n\r\n    if ncs_Winner_perScaleDir[0] and ncs_Winner_perScaleDir[1]:\r\n        iDir_Winner = fRadii_MaxMin_perScaleDir.index(max(fRadii_MaxMin_perScaleDir))\r\n    else:\r\n        iDir_Winner = 0 if ncs_Winner_perScaleDir[0] else 1\r\n\r\n    return (\r\n        (\r\n            ncs_Winner_perScaleDir[iDir_Winner],\r\n            fRadii_MaxMin_perScaleDir[iDir_Winner],\r\n            fDev_perScaleDir[iDir_Winner]\r\n        ),\r\n        None)\r\n\r\n\r\ndef createNcsWithAdjTanCpSpreadForMaxMinRad_ANY_WIP(nc0, bT1WorkEnd, fDevTol=None, nc_forDevComp=None, bDebug=False):\r\n    \"\"\"\r\n    returns list of new NurbsCurves with ANY minimum radii larger than the original.\r\n    \"\"\"\r\n\r\n    idxCp_Pos_A = (nc0.Points.Count - 1) if bT1WorkEnd else 0\r\n    idxCp_Tan_A = (nc0.Points.Count - 2) if bT1WorkEnd else 1\r\n\r\n    fRadii_Min_0 = getMinimumRadii(nc0)\r\n    if fRadii_Min_0 is None: return\r\n    if bDebug: sEval='fRadii_Min_0'; print sEval+': ',eval(sEval)\r\n\r\n    ncs_WithLargerMinRadii = []\r\n    \r\n    # Try longer and shorter tangent control point spreads.\r\n    for scaleIncr in 0.1, -0.05:\r\n        nc_A_Pre = nc0.Duplicate()\r\n        scale = 1.0 + scaleIncr\r\n\r\n        fRadii_Minima_ThisScaleDir = None\r\n\r\n        while True:\r\n            sc.escape_test()\r\n            nc_WIP = nc0.Duplicate()\r\n            if bDebug: sEval='scale'; print sEval+': ',eval(sEval),\r\n            xform = rg.Transform.Scale(\r\n                    anchor=nc_WIP.Points[idxCp_Pos_A].Location,\r\n                    scaleFactor=scale)\r\n            pt_Target = nc_WIP.Points[idxCp_Tan_A].Location\r\n            pt_Target.Transform(xform)\r\n            nc_WIP.Points[idxCp_Tan_A] = pt_Target\r\n            if bDebug: stopwatch.Restart()\r\n            fRadius_Min_WIP = getMinimumRadius(nc_WIP)\r\n            fRadii_Min_WIP = getMinimumRadii(nc_WIP)\r\n            if bDebug: sEval='fRadii_Min_WIP'; print sEval+': ',eval(sEval),\r\n\r\n            def hasAnyMinRadiusDecreased(fRadii_WIP, fRadii_CompareWith):\r\n                for iR in range(len(fRadii_WIP)):\r\n                    if fRadii_WIP[iR] <= fRadii_CompareWith[iR]:\r\n                        return True\r\n                    if bDebug: sEval='fRadii_WIP[iR] <= fRadii_CompareWith[iR]'; print sEval+': ',eval(sEval)\r\n                return False\r\n\r\n            if hasAnyMinRadiusDecreased(fRadii_Min_WIP, fRadii_Min_0):\r\n                # Minimum radius is not increasing,\r\n                # so stop and capture the previous curve.\r\n                break\r\n\r\n            if fRadii_Minima_ThisScaleDir is not None:\r\n                if hasAnyMinRadiusDecreased(fRadii_Min_WIP, fRadii_MaxMin_ThisScaleDir):\r\n                    # Minimum radius is now decreasing from best found in this scale direction,\r\n                    # so stop and capture the previous curve.\r\n                    break\r\n\r\n            if fDevTol is not None and nc_forDevComp is not None:\r\n                dev = getMaximumDeviation(nc_forDevComp, nc_WIP)\r\n                if bDebug:\r\n                    sEval='dev'; print sEval+': ',eval(sEval),\r\n                    sEval='dev > fDevTol'; print sEval+': ',eval(sEval),\r\n                if dev > fDevTol:\r\n                    # Deviation is out of tolerance,\r\n                    # so capture the previous curve.\r\n                    break\r\n            elif bDebug: print\r\n\r\n            nc_A_Pre.Dispose()\r\n            nc_A_Pre = nc_WIP\r\n            scale += scaleIncr\r\n            fRadii_MaxMin_ThisScaleDir = fRadii_Min_WIP\r\n\r\n        nc_WIP.Dispose()\r\n\r\n        if scale != 1.0 + scaleIncr:\r\n            ncs_WithLargerMinRadii.append(nc_A_Pre)\r\n        else:\r\n            nc_A_Pre.Dispose()\r\n    \r\n    return ncs_WithLargerMinRadii\r\n\r\n\r\ndef createNurbsCurve(nc_In, fRadius_AcceptableMin=None, fDevTol=None, bAdjWeightInDeg2Bezier=True, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Success: tuple(rgNurbsCurve, fMinRadius, fDeviation), None\r\n        Fail: None, sLog\r\n    \"\"\"\r\n    \r\n    if not isinstance(nc_In, rg.NurbsCurve):\r\n        return None, \"Not a NurbsCurve.\"\r\n\r\n\r\n\r\n    def adjustCpLocs_WithWhileLoop():\r\n        nc_Result = None\r\n        radius_Winner = None\r\n        dev_Winner = None\r\n    \r\n        nc_WIP = nc_In.DuplicateCurve()\r\n    \r\n        while True:\r\n            sc.escape_test()\r\n\r\n            if bDebug: stopwatch.Restart()\r\n            \r\n            fRadius_Min_StartOfWhile = getMinimumRadius(nc_WIP)\r\n\r\n\r\n            if bDebug:\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                s += \"getMinimumRadius\"\r\n                print s\r\n            \r\n            if fRadius_AcceptableMin and fRadius_Min_StartOfWhile >= fRadius_AcceptableMin:\r\n                return None, \"Curve's minimum radius is already >= {}.\".format(\r\n                    fRadius_AcceptableMin)\r\n    \r\n            for bT1WorkEnd in False, True:\r\n                rc = adjustTanCpSpread_OneEndOnly(\r\n                    nc_WIP,\r\n                    bT1WorkEnd,\r\n                    fRadius_AcceptableMin,\r\n                    fDevTol,\r\n                    nc_In,\r\n                    bDebug=bDebug,\r\n                    )\r\n\r\n                if rc[0] is not None:\r\n                    if bDebug: print \"Some improvement was made.\"\r\n                    nc_Result, radius_Winner, dev_Winner = rc[0]\r\n                    nc_WIP.Dispose()\r\n                    nc_WIP = nc_Result\r\n\r\n            if bDebug: stopwatch.Restart()\r\n            \r\n            rc = adjustTanCpSpread_BothEndsSimultaneously(\r\n                nc_WIP,\r\n                fRadius_AcceptableMin,\r\n                fDevTol,\r\n                nc_In,\r\n                bDebug=bDebug,\r\n                )\r\n\r\n            if rc[0] is not None:\r\n                if bDebug: print \"Some improvement was made.\"\r\n                nc_Result, radius_Winner, dev_Winner = rc[0]\r\n                nc_WIP.Dispose()\r\n                nc_WIP = nc_Result\r\n\r\n            if not nc_Result:\r\n                nc_WIP.Dispose()\r\n                return None, \"Curve already has maximized minimum radius.\"\r\n            \r\n            fRadius_Min_EndOfWhile = getMinimumRadius(nc_WIP)\r\n            \r\n            \r\n            if bDebug:\r\n                stopwatch.Stop()\r\n                timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n                s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n                s += \"getMinimumRadius\"\r\n                print s\r\n    \r\n            if bDebug: print fRadius_Min_StartOfWhile, fRadius_Min_EndOfWhile\r\n    \r\n            if abs(fRadius_Min_StartOfWhile - fRadius_Min_EndOfWhile) <= 0.1*sc.doc.ModelAbsoluteTolerance:\r\n                break # out of while loop.\r\n\r\n        return (nc_Result, radius_Winner, dev_Winner), None\r\n\r\n\r\n    def adjustCpLocs_NoWhileLoop():\r\n        nc_Result = None\r\n        radius_Winner = None\r\n        dev_Winner = None\r\n    \r\n        nc_WIP = nc_In.DuplicateCurve()\r\n\r\n        if bDebug: stopwatch.Restart()\r\n\r\n        fRadius_Min_StartOfWhile = getMinimumRadius(nc_WIP)\r\n\r\n        #print getMinimaRadii_V7(nc_WIP); 1/0\r\n\r\n\r\n        if bDebug:\r\n            stopwatch.Stop()\r\n            timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n            s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n            s += \"getMinimumRadius\"\r\n            print s\r\n            \r\n        if fRadius_AcceptableMin and fRadius_Min_StartOfWhile >= fRadius_AcceptableMin:\r\n            return None, \"Curve's minimum radius is already >= {}.\".format(\r\n                fRadius_AcceptableMin)\r\n    \r\n        for bT1WorkEnd in False, True:\r\n            #rc = adjustTanCpSpread(\r\n            #    nc_WIP,\r\n            #    bT1WorkEnd,\r\n            #    fRadius_AcceptableMin,\r\n            #    fDevTol,\r\n            #    nc0,\r\n            #    bDebug=bDebug,\r\n            #    )\r\n\r\n            rc = adjustTanCpSpread_IsolatedEnd(\r\n                nc_WIP,\r\n                bT1WorkEnd,\r\n                fRadius_AcceptableMin,\r\n                fDevTol,\r\n                nc_In,\r\n                bDebug=bDebug,\r\n                )\r\n\r\n            if rc[0] is not None:\r\n                if bDebug: print \"Some improvement was made.\"\r\n                nc_Result, radius_Winner, dev_Winner = rc[0]\r\n                #if bT1WorkEnd:\r\n                #    sc.doc.Objects.AddCurve(nc_Result); sc.doc.Views.Redraw(); 1/0\r\n                nc_WIP.Dispose()\r\n                nc_WIP = nc_Result\r\n    \r\n        if bDebug: stopwatch.Restart()\r\n            \r\n        if not nc_Result:\r\n            nc_WIP.Dispose()\r\n            return None, \"Curve already has minimum radius.\"\r\n            \r\n        fRadius_Min_EndOfWhile = getMinimumRadius(nc_WIP)\r\n            \r\n            \r\n        if bDebug:\r\n            stopwatch.Stop()\r\n            timeElapsed = stopwatch.Elapsed.TotalSeconds\r\n            s  = \"{:.2f} seconds for \".format(timeElapsed)\r\n            s += \"getMinimumRadius\"\r\n            print s\r\n    \r\n        if bDebug: print fRadius_Min_StartOfWhile, fRadius_Min_EndOfWhile\r\n    \r\n        return (nc_Result, radius_Winner, dev_Winner), None\r\n\r\n\r\n    nc_In = nc_In.ToNurbsCurve()\r\n\r\n    if nc_In.Degree == 2 and nc_In.SpanCount == 1:\r\n        if bAdjWeightInDeg2Bezier:\r\n            rc = adjustWeight(\r\n                nc_In,\r\n                fRadius_AcceptableMin=fRadius_AcceptableMin,\r\n                fDevTol=fDevTol,\r\n                nc_forDevComp=nc_In,\r\n                bDebug=bDebug)\r\n        else:\r\n            nc_In.Dispose()\r\n            return None, \"Curve doesn't have enough control points to be modified.\"\r\n\r\n    else:\r\n        fRads_Mins_In = getMinimaRadii_V7(nc_In, bDebug=bDebug)\r\n\r\n        if nc_In.SpanCount == 1: # and len(fRads_Mins_In) == 2:\r\n            #print abs(fRads_Mins_In_Eval[0] - fRads_Mins_In_Eval[1])\r\n            rc = adjustCpLocs_WithWhileLoop()\r\n\r\n            #if areAbsEqual(fRads_Mins_In[0], fRads_Mins_In[1]):\r\n                #return None, \"Single-spanned curve\" \\\r\n                #    \" already contains 2 equal minima radii.\" \\\r\n                #    \"  TODO: Simultaneously modify 2nd control points on both ends.\"\r\n\r\n\r\n        elif nc_In.SpanCount == 2 and nc_In.Knots.KnotMultiplicity(nc_In.Degree) == 1:\r\n            rc = adjustCpLocs_WithWhileLoop()\r\n            #if areAbsEqual(fRads_Mins_In[0], fRads_Mins_In[1]):\r\n                #return None, \"Double-spanned curve with simple knot between\" \\\r\n                #    \" already contains 2 equal minima radii.\" \\\r\n                #    \"  TODO: Simultaneously modify 2nd control points on both ends.\"\r\n\r\n        else:\r\n            rc = adjustCpLocs_NoWhileLoop()\r\n\r\n    if not rc[0]:\r\n        nc_In.Dispose()\r\n        return None, rc[1]\r\n\r\n    (nc_Result, radius_Winner, dev_Winner), sLog = rc\r\n\r\n    if nc_Result.EpsilonEquals(nc_In, 1e-8):\r\n        nc_In.Dispose()\r\n        nc_Result.Dispose()\r\n        return None, \"New curve is within 1e-8 of old and will not be modified.\"\r\n\r\n    nc_In.Dispose()\r\n\r\n    return (nc_Result, radius_Winner, dev_Winner), sLog\r\n\r\n\r\ndef processCurveObjects(objrefs, fRadius_AcceptableMin=None, fDevTol=None, bAdjWeightInDeg2Bezier=True, bReplace=True, bEcho=True, bDebug=False):\r\n\r\n    gs1 = []\r\n    sLogs = []\r\n\r\n    for objref in objrefs:\r\n\r\n        gCrv0_A = objref.ObjectId\r\n        nc_In = objref.Curve()\r\n\r\n        rc = createNurbsCurve(\r\n                nc_In=nc_In,\r\n                fRadius_AcceptableMin=fRadius_AcceptableMin,\r\n                fDevTol=fDevTol,\r\n                bAdjWeightInDeg2Bezier=bAdjWeightInDeg2Bezier,\r\n                bDebug=bDebug,\r\n        )\r\n        if rc[0] is None:\r\n            sLogs.append(rc[1])\r\n            continue\r\n\r\n\r\n        def processResults(gCrv0_ToMod, rgCrv0_ToMod, winningResults):\r\n\r\n            rgNurbsCrv1, fRadius_Min_New, fDev = winningResults\r\n\r\n            g1 = None\r\n\r\n            if bReplace:\r\n                if sc.doc.Objects.Replace(gCrv0_ToMod, rgNurbsCrv1):\r\n                    if bEcho: print \"Curve was replaced.\"\r\n                    g1 = gCrv0_ToMod\r\n                else:\r\n                    g1 = None\r\n            else:\r\n                g1 = sc.doc.Objects.AddCurve(rgNurbsCrv1)\r\n                if g1 == g1.Empty:\r\n                    g1 = None \r\n                else:\r\n                    if bEcho: print \"Curve was added.\"\r\n\r\n            sc.doc.Views.Redraw()\r\n\r\n            s = \"\"\r\n\r\n            rc = spb_Crv_inflections.getInflectionParameters(rgCrv0_ToMod)\r\n            i_Infl_Ct_Pre = len(rc) if rc else None\r\n            rc = spb_Crv_inflections.getInflectionParameters(rgNurbsCrv1)\r\n            i_Infl_Ct_Post = len(rc) if rc else None\r\n            s = \"InflectionCount:{}->{}\".format(i_Infl_Ct_Pre, i_Infl_Ct_Post)\r\n\r\n            rc = getMinimumRadius(rgCrv0_ToMod)\r\n            fRadius_Min_Original = rc if rc is not None else None\r\n            sRadius_Min_Original = '{:.{}f}'.format(fRadius_Min_Original, sc.doc.ModelDistanceDisplayPrecision)\r\n            sRadius_Min_New = '{:.{}f}'.format(fRadius_Min_New, sc.doc.ModelDistanceDisplayPrecision)\r\n            if s: s += \"  \"\r\n            s += \"  MinimumRadius:{}->{}\".format(sRadius_Min_Original, sRadius_Min_New)\r\n\r\n            if fDev is None:\r\n                fDev = getMaximumDeviation(rgCrv0_ToMod, rgNurbsCrv1)\r\n            s += \"  Deviation:{}\".format(formatDistance(fDev))\r\n            print s\r\n            \r\n            return g1\r\n\r\n\r\n        winningResults = rc[0]\r\n\r\n        g1 = processResults(gCrv0_A, nc_In, winningResults)\r\n        if g1: gs1.append(g1)\r\n        winningResults[0].Dispose()\r\n\r\n\r\n        nc_In.Dispose()\r\n\r\n    return gs1, sLogs\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        objrefs,\r\n        bSetMinTargetRad,\r\n        fRadius_AcceptableMin,\r\n        bLimitCrvDev,\r\n        fDevTol,\r\n        bAdjWeightInDeg2Bezier,\r\n        bReplace,\r\n        bEcho,\r\n        bDebug,\r\n    ) = rc\r\n\r\n    if not bDebug:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    gCs_Modified, sLogs = processCurveObjects(\r\n        objrefs,\r\n        fRadius_AcceptableMin if bSetMinTargetRad else None,\r\n        fDevTol=fDevTol if bLimitCrvDev else None,\r\n        bAdjWeightInDeg2Bezier=bAdjWeightInDeg2Bezier,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n    )\r\n\r\n    for sLog in set(sLogs):\r\n        print \"[{}] {}\".format(sLogs.count(sLog), sLog)\r\n\r\n    for gC in gCs_Modified:\r\n        sc.doc.Objects.Select(gC)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}