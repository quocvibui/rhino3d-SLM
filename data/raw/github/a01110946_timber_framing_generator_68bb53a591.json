{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/utils/geometry_factory.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/utils/geometry_factory.py",
  "instruction": "RhinoCommon Geometry Factory for Grasshopper Integration.",
  "code": "# File: src/timber_framing_generator/utils/geometry_factory.py\n\"\"\"\nRhinoCommon Geometry Factory for Grasshopper Integration.\n\nThis module provides a factory class that creates RhinoCommon geometry\nvia CLR reflection, bypassing the rhino3dm package which creates\nincompatible Rhino3dmIO geometry.\n\nThe Problem:\n    - rhino3dm Python package creates geometry from \"Rhino3dmIO\" assembly\n    - Grasshopper expects geometry from \"RhinoCommon\" assembly\n    - Despite identical type names, CLR treats them as incompatible\n    - Results in \"Data conversion failed from Goo to Brep\" errors\n\nThe Solution:\n    - Use CLR reflection to find the RhinoCommon assembly\n    - Create geometry directly using Activator.CreateInstance\n    - Extract coordinates as Python floats to \"launder\" through assembly boundary\n\nUsage in GHPython:\n    from src.timber_framing_generator.utils.geometry_factory import get_factory\n\n    factory = get_factory()\n    point = factory.create_point3d(1.0, 2.0, 3.0)\n    brep = factory.create_box_brep_from_centerline(start, direction, length, width, depth)\n\nSee Also:\n    - docs/ai/ai-geometry-assembly-solution.md\n    - docs/ai/ai-grasshopper-rhino-patterns.md\n\"\"\"\n\nfrom typing import Tuple, List, Optional, Any, Union\n\n# Type aliases for clarity\nPoint3DLike = Union[Tuple[float, float, float], Any]\nVector3DLike = Union[Tuple[float, float, float], Any]\n\n\nclass RhinoCommonFactory:\n    \"\"\"\n    Factory for creating RhinoCommon geometry directly via CLR reflection.\n\n    This bypasses the rhino3dm package which creates Rhino3dmIO geometry\n    that Grasshopper cannot use. All geometry created through this factory\n    is guaranteed to be from the RhinoCommon assembly.\n\n    Singleton Pattern:\n        Only one instance is created per process. Use get_factory() to obtain.\n\n    Example:\n        factory = RhinoCommonFactory()\n        pt = factory.create_point3d(0, 0, 0)\n        brep = factory.create_box_brep_from_centerline((0,0,0), (0,0,1), 8.0, 0.125, 0.292)\n    \"\"\"\n\n    _instance = None\n    _rc_assembly = None\n    _types_cache = {}\n\n    def __new__(cls):\n        \"\"\"Singleton pattern - reuse the same factory instance.\"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        \"\"\"Initialize the factory by finding RhinoCommon assembly.\"\"\"\n        if self._initialized:\n            return\n\n        from System import AppDomain\n\n        # Find RhinoCommon assembly\n        for asm in AppDomain.CurrentDomain.GetAssemblies():\n            name = asm.GetName().Name\n            if name == \"RhinoCommon\":\n                self._rc_assembly = asm\n                break\n\n        if self._rc_assembly is None:\n            raise RuntimeError(\"RhinoCommon assembly not found in AppDomain\")\n\n        # Pre-cache commonly used types\n        self._cache_types()\n        self._initialized = True\n\n    def _cache_types(self):\n        \"\"\"Pre-cache commonly used RhinoCommon types.\"\"\"\n        type_names = [\n            \"Rhino.Geometry.Point3d\",\n            \"Rhino.Geometry.Vector3d\",\n            \"Rhino.Geometry.Plane\",\n            \"Rhino.Geometry.Line\",\n            \"Rhino.Geometry.LineCurve\",\n            \"Rhino.Geometry.PolylineCurve\",\n            \"Rhino.Geometry.Polyline\",\n            \"Rhino.Geometry.Circle\",\n            \"Rhino.Geometry.Arc\",\n            \"Rhino.Geometry.BoundingBox\",\n            \"Rhino.Geometry.Box\",\n            \"Rhino.Geometry.Interval\",\n            \"Rhino.Geometry.Rectangle3d\",\n            \"Rhino.Geometry.Extrusion\",\n            \"Rhino.Geometry.Brep\",\n            \"Rhino.Geometry.NurbsCurve\",\n            \"Rhino.Geometry.NurbsSurface\",\n            \"Rhino.Geometry.Curve\",\n        ]\n\n        for full_name in type_names:\n            short_name = full_name.split(\".\")[-1]\n            self._types_cache[short_name] = self._rc_assembly.GetType(full_name)\n\n    def _get_type(self, type_name: str):\n        \"\"\"Get a RhinoCommon type by short name.\"\"\"\n        if type_name not in self._types_cache:\n            full_name = f\"Rhino.Geometry.{type_name}\"\n            self._types_cache[type_name] = self._rc_assembly.GetType(full_name)\n        return self._types_cache[type_name]\n\n    def _create_instance(self, type_name: str, *args):\n        \"\"\"Create an instance of a RhinoCommon type.\"\"\"\n        from System import Activator, Array\n\n        rc_type = self._get_type(type_name)\n        if rc_type is None:\n            raise TypeError(f\"Could not find type: {type_name}\")\n\n        if len(args) == 0:\n            return Activator.CreateInstance(rc_type)\n        else:\n            return Activator.CreateInstance(rc_type, Array[object](list(args)))\n\n    # =========================================================================\n    # Basic Geometry Creation Methods\n    # =========================================================================\n\n    def create_point3d(self, x: float, y: float, z: float):\n        \"\"\"Create a RhinoCommon Point3d from coordinates.\"\"\"\n        return self._create_instance(\"Point3d\", float(x), float(y), float(z))\n\n    def create_vector3d(self, x: float, y: float, z: float):\n        \"\"\"Create a RhinoCommon Vector3d from components.\"\"\"\n        return self._create_instance(\"Vector3d\", float(x), float(y), float(z))\n\n    def create_plane(self, origin: Point3DLike, x_axis: Vector3DLike, y_axis: Vector3DLike):\n        \"\"\"\n        Create a RhinoCommon Plane.\n\n        Args:\n            origin: Point3d or (x, y, z) tuple\n            x_axis: Vector3d or (x, y, z) tuple\n            y_axis: Vector3d or (x, y, z) tuple\n        \"\"\"\n        # Convert origin if needed\n        if isinstance(origin, (tuple, list)):\n            origin = self.create_point3d(*origin)\n        elif hasattr(origin, 'X'):\n            origin = self.create_point3d(float(origin.X), float(origin.Y), float(origin.Z))\n\n        # Convert x_axis if needed\n        if isinstance(x_axis, (tuple, list)):\n            x_axis = self.create_vector3d(*x_axis)\n        elif hasattr(x_axis, 'X'):\n            x_axis = self.create_vector3d(float(x_axis.X), float(x_axis.Y), float(x_axis.Z))\n\n        # Convert y_axis if needed\n        if isinstance(y_axis, (tuple, list)):\n            y_axis = self.create_vector3d(*y_axis)\n        elif hasattr(y_axis, 'X'):\n            y_axis = self.create_vector3d(float(y_axis.X), float(y_axis.Y), float(y_axis.Z))\n\n        return self._create_instance(\"Plane\", origin, x_axis, y_axis)\n\n    def create_line(self, start_point: Point3DLike, end_point: Point3DLike):\n        \"\"\"\n        Create a RhinoCommon Line.\n\n        Args:\n            start_point: Point3d or (x, y, z) tuple\n            end_point: Point3d or (x, y, z) tuple\n        \"\"\"\n        if isinstance(start_point, (tuple, list)):\n            start_point = self.create_point3d(*start_point)\n        elif hasattr(start_point, 'X'):\n            start_point = self.create_point3d(\n                float(start_point.X), float(start_point.Y), float(start_point.Z)\n            )\n\n        if isinstance(end_point, (tuple, list)):\n            end_point = self.create_point3d(*end_point)\n        elif hasattr(end_point, 'X'):\n            end_point = self.create_point3d(\n                float(end_point.X), float(end_point.Y), float(end_point.Z)\n            )\n\n        return self._create_instance(\"Line\", start_point, end_point)\n\n    def create_line_curve(self, start_point: Point3DLike, end_point: Point3DLike):\n        \"\"\"\n        Create a RhinoCommon LineCurve.\n\n        Args:\n            start_point: Point3d or (x, y, z) tuple\n            end_point: Point3d or (x, y, z) tuple\n        \"\"\"\n        line = self.create_line(start_point, end_point)\n        return self._create_instance(\"LineCurve\", line)\n\n    def create_polyline_curve(self, points: List[Point3DLike]):\n        \"\"\"\n        Create a RhinoCommon PolylineCurve from a list of points.\n\n        Args:\n            points: List of Point3d or (x, y, z) tuples\n\n        Returns:\n            PolylineCurve from RhinoCommon assembly\n        \"\"\"\n        if not points or len(points) < 2:\n            return None\n\n        # Convert all points to RhinoCommon Point3d\n        rc_points = []\n        for pt in points:\n            if isinstance(pt, (tuple, list)):\n                rc_points.append(self.create_point3d(*pt))\n            elif hasattr(pt, 'X'):\n                rc_points.append(self.create_point3d(\n                    float(pt.X), float(pt.Y), float(pt.Z)\n                ))\n            else:\n                rc_points.append(pt)\n\n        # Create Polyline by adding points one at a time\n        # (avoids constructor overload issues with Activator.CreateInstance)\n        polyline = self._create_instance(\"Polyline\")\n        for pt in rc_points:\n            polyline.Add(pt)\n\n        # Create PolylineCurve from Polyline\n        return self._create_instance(\"PolylineCurve\", polyline)\n\n    def create_circle(\n        self,\n        center: Point3DLike,\n        radius: float,\n        normal: Vector3DLike = (0, 0, 1)\n    ):\n        \"\"\"\n        Create a RhinoCommon Circle as a NurbsCurve.\n\n        Args:\n            center: Center point as Point3d or (x, y, z) tuple\n            radius: Circle radius\n            normal: Normal vector for circle plane (default: Z-up)\n\n        Returns:\n            NurbsCurve representing the circle from RhinoCommon assembly\n        \"\"\"\n        from System.Reflection import BindingFlags\n\n        # Convert center to Point3d\n        if isinstance(center, (tuple, list)):\n            center_pt = self.create_point3d(*center)\n        elif hasattr(center, 'X'):\n            center_pt = self.create_point3d(\n                float(center.X), float(center.Y), float(center.Z)\n            )\n        else:\n            center_pt = center\n\n        # Convert normal to Vector3d\n        if isinstance(normal, (tuple, list)):\n            normal_vec = self.create_vector3d(*normal)\n        elif hasattr(normal, 'X'):\n            normal_vec = self.create_vector3d(\n                float(normal.X), float(normal.Y), float(normal.Z)\n            )\n        else:\n            normal_vec = normal\n\n        # Create plane from center and normal\n        # Use Plane(origin, normal) constructor\n        plane = self._create_instance(\"Plane\", center_pt, normal_vec)\n\n        # Get Circle type and create circle\n        Circle_Type = self._get_type(\"Circle\")\n        if Circle_Type is None:\n            # Fallback: cache it\n            self._types_cache[\"Circle\"] = self._rc_assembly.GetType(\"Rhino.Geometry.Circle\")\n            Circle_Type = self._types_cache[\"Circle\"]\n\n        # Create Circle(plane, radius)\n        circle = self._create_instance(\"Circle\", plane, float(radius))\n\n        # Convert to NurbsCurve for output\n        try:\n            return circle.ToNurbsCurve()\n        except Exception as e:\n            print(f\"create_circle error converting to NurbsCurve: {e}\")\n            return None\n\n    def create_interval(self, t0: float, t1: float):\n        \"\"\"Create a RhinoCommon Interval.\"\"\"\n        return self._create_instance(\"Interval\", float(t0), float(t1))\n\n    def create_rectangle3d(self, plane, width: float, height: float):\n        \"\"\"\n        Create a RhinoCommon Rectangle3d centered on a plane.\n\n        Args:\n            plane: Plane or origin point (will use XY axes if point)\n            width: Width of rectangle\n            height: Height of rectangle\n        \"\"\"\n        # Convert plane if it's a point\n        if isinstance(plane, (tuple, list)):\n            origin = self.create_point3d(*plane)\n            x_axis = self.create_vector3d(1.0, 0.0, 0.0)\n            y_axis = self.create_vector3d(0.0, 1.0, 0.0)\n            plane = self._create_instance(\"Plane\", origin, x_axis, y_axis)\n        elif hasattr(plane, 'Origin') and hasattr(plane, 'XAxis'):\n            # Existing plane - convert it\n            origin = self.create_point3d(\n                float(plane.Origin.X), float(plane.Origin.Y), float(plane.Origin.Z)\n            )\n            x_axis = self.create_vector3d(\n                float(plane.XAxis.X), float(plane.XAxis.Y), float(plane.XAxis.Z)\n            )\n            y_axis = self.create_vector3d(\n                float(plane.YAxis.X), float(plane.YAxis.Y), float(plane.YAxis.Z)\n            )\n            plane = self._create_instance(\"Plane\", origin, x_axis, y_axis)\n\n        # Create intervals for width and height (centered)\n        x_interval = self.create_interval(-float(width) / 2.0, float(width) / 2.0)\n        y_interval = self.create_interval(-float(height) / 2.0, float(height) / 2.0)\n\n        return self._create_instance(\"Rectangle3d\", plane, x_interval, y_interval)\n\n    def create_bounding_box(self, min_point: Point3DLike, max_point: Point3DLike):\n        \"\"\"\n        Create a RhinoCommon BoundingBox.\n\n        Args:\n            min_point: Point3d or (x, y, z) tuple for min corner\n            max_point: Point3d or (x, y, z) tuple for max corner\n        \"\"\"\n        if isinstance(min_point, (tuple, list)):\n            min_point = self.create_point3d(*min_point)\n        elif hasattr(min_point, 'X'):\n            min_point = self.create_point3d(\n                float(min_point.X), float(min_point.Y), float(min_point.Z)\n            )\n\n        if isinstance(max_point, (tuple, list)):\n            max_point = self.create_point3d(*max_point)\n        elif hasattr(max_point, 'X'):\n            max_point = self.create_point3d(\n                float(max_point.X), float(max_point.Y), float(max_point.Z)\n            )\n\n        return self._create_instance(\"BoundingBox\", min_point, max_point)\n\n    def create_box(self, bounding_box):\n        \"\"\"Create a RhinoCommon Box from a BoundingBox.\"\"\"\n        return self._create_instance(\"Box\", bounding_box)\n\n    # =========================================================================\n    # Surface and Curve Methods\n    # =========================================================================\n\n    def create_surface_from_corners(self, p1, p2, p3, p4):\n        \"\"\"\n        Create a RhinoCommon NurbsSurface from 4 corner points.\n\n        Uses NurbsSurface.CreateFromCorners static method via reflection.\n\n        Args:\n            p1, p2, p3, p4: Corner points as Point3d or (x, y, z) tuples\n\n        Returns:\n            NurbsSurface from RhinoCommon assembly, or None if creation fails\n        \"\"\"\n        from System.Reflection import BindingFlags\n\n        # Convert all points to RhinoCommon Point3d\n        corners = []\n        for pt in [p1, p2, p3, p4]:\n            if isinstance(pt, (tuple, list)):\n                corners.append(self.create_point3d(*pt))\n            elif hasattr(pt, 'X'):\n                corners.append(self.create_point3d(\n                    float(pt.X), float(pt.Y), float(pt.Z)\n                ))\n            else:\n                corners.append(pt)\n\n        # Get NurbsSurface type and invoke static method\n        RC_NurbsSurface = self._get_type(\"NurbsSurface\")\n        if RC_NurbsSurface is None:\n            return None\n\n        try:\n            # Use reflection to invoke the static CreateFromCorners method\n            method_info = RC_NurbsSurface.GetMethod(\n                \"CreateFromCorners\",\n                BindingFlags.Public | BindingFlags.Static,\n                None,\n                [self._get_type(\"Point3d\")] * 4,\n                None\n            )\n\n            if method_info is not None:\n                result = method_info.Invoke(None, corners)\n                return result\n            else:\n                # Try direct call (works in some environments)\n                return RC_NurbsSurface.CreateFromCorners(\n                    corners[0], corners[1], corners[2], corners[3]\n                )\n        except Exception as e:\n            print(f\"create_surface_from_corners error: {e}\")\n            return None\n\n    def get_boundary_curves_from_surface(self, surface):\n        \"\"\"\n        Extract boundary curves from a surface.\n\n        Args:\n            surface: NurbsSurface from RhinoCommon\n\n        Returns:\n            Joined boundary curve, or None\n        \"\"\"\n        if surface is None:\n            return None\n\n        try:\n            brep = surface.ToBrep()\n            if brep is not None:\n                edges = brep.Edges\n                if edges is not None and edges.Count > 0:\n                    edge_curves = []\n                    for i in range(edges.Count):\n                        edge = edges[i]\n                        if edge is not None:\n                            crv = edge.DuplicateCurve()\n                            if crv is not None:\n                                edge_curves.append(crv)\n\n                    if edge_curves:\n                        # Try to join\n                        RC_Curve = self._get_type(\"Curve\")\n                        if RC_Curve is not None and len(edge_curves) > 1:\n                            from System import Array\n                            from System.Reflection import BindingFlags\n\n                            curve_array = Array.CreateInstance(RC_Curve, len(edge_curves))\n                            for i, crv in enumerate(edge_curves):\n                                curve_array[i] = crv\n\n                            join_methods = RC_Curve.GetMethods(\n                                BindingFlags.Public | BindingFlags.Static\n                            )\n                            for method in join_methods:\n                                if method.Name == \"JoinCurves\":\n                                    params = method.GetParameters()\n                                    try:\n                                        if len(params) >= 1:\n                                            joined = method.Invoke(None, [curve_array])\n                                            if joined is not None and len(joined) > 0:\n                                                return joined[0]\n                                    except:\n                                        continue\n\n                        return edge_curves[0] if edge_curves else None\n\n        except Exception as e:\n            print(f\"get_boundary_curves_from_surface error: {e}\")\n\n        return None\n\n    # =========================================================================\n    # Sheathing/Surface Geometry Creation\n    # =========================================================================\n\n    def create_planar_brep_from_corners(\n        self,\n        corners: List[Point3DLike]\n    ) -> Optional[Any]:\n        \"\"\"\n        Create a planar Brep from 4 corner points.\n\n        Args:\n            corners: List of 4 (x, y, z) tuples in order (counter-clockwise)\n\n        Returns:\n            RhinoCommon Brep or None if creation fails\n        \"\"\"\n        if len(corners) != 4:\n            return None\n\n        # Create NurbsSurface from corners\n        surface = self.create_surface_from_corners(\n            corners[0], corners[1], corners[2], corners[3]\n        )\n\n        if surface is None:\n            return None\n\n        # Convert to Brep\n        try:\n            return surface.ToBrep()\n        except Exception as e:\n            print(f\"create_planar_brep_from_corners error: {e}\")\n            return None\n\n    def extrude_brep(\n        self,\n        brep: Any,\n        direction: Tuple[float, float, float]\n    ) -> Optional[Any]:\n        \"\"\"\n        Extrude a planar Brep along a direction vector to create a solid.\n\n        Args:\n            brep: RhinoCommon Brep (planar surface)\n            direction: (x, y, z) extrusion vector\n\n        Returns:\n            RhinoCommon Brep (solid) or None if extrusion fails\n        \"\"\"\n        if brep is None:\n            return None\n\n        from System.Reflection import BindingFlags\n\n        try:\n            # Get first face of brep\n            if not hasattr(brep, 'Faces') or brep.Faces.Count == 0:\n                return None\n\n            face = brep.Faces[0]\n\n            # Create direction vector\n            vec = self.create_vector3d(*direction)\n\n            # Try to create extrusion from face\n            # Use Surface.CreateExtrusion(direction, capped)\n            RC_Brep = self._get_type(\"Brep\")\n\n            # Get the underlying surface\n            srf = face.UnderlyingSurface()\n            if srf is None:\n                return None\n\n            # Use Brep.CreateFromSurface and then extrusion approach\n            # Alternative: Create box from bounding box of extruded corners\n\n            # Get corner points of face\n            corners = []\n            edge_curves = []\n            for i in range(brep.Edges.Count):\n                edge = brep.Edges[i]\n                start_pt = edge.PointAtStart\n                corners.append((float(start_pt.X), float(start_pt.Y), float(start_pt.Z)))\n\n            if len(corners) < 4:\n                return None\n\n            # Create extruded corners\n            dx, dy, dz = direction\n            extruded_corners = []\n            for cx, cy, cz in corners[:4]:\n                extruded_corners.append((cx + dx, cy + dy, cz + dz))\n\n            # Create solid from 8 corners using bounding box approach\n            all_corners = corners[:4] + extruded_corners\n            min_x = min(c[0] for c in all_corners)\n            min_y = min(c[1] for c in all_corners)\n            min_z = min(c[2] for c in all_corners)\n            max_x = max(c[0] for c in all_corners)\n            max_y = max(c[1] for c in all_corners)\n            max_z = max(c[2] for c in all_corners)\n\n            # This is a simplified approach - creates axis-aligned box\n            # For angled extrusions, we'd need more complex logic\n            bbox = self.create_bounding_box(\n                (min_x, min_y, min_z),\n                (max_x, max_y, max_z)\n            )\n            box = self.create_box(bbox)\n            return box.ToBrep()\n\n        except Exception as e:\n            print(f\"extrude_brep error: {e}\")\n            return None\n\n    def create_box_from_corners_and_thickness(\n        self,\n        corners: List[Tuple[float, float, float]],\n        extrusion_vector: Tuple[float, float, float]\n    ) -> Optional[Any]:\n        \"\"\"\n        Create a box Brep from 4 corner points and an extrusion vector.\n\n        This is more reliable than extrude_brep for creating sheathing panels.\n\n        Args:\n            corners: 4 corner points of the base face\n            extrusion_vector: Vector defining thickness direction and magnitude\n\n        Returns:\n            RhinoCommon Brep or None\n        \"\"\"\n        if len(corners) != 4:\n            return None\n\n        dx, dy, dz = extrusion_vector\n\n        # Create all 8 corners\n        all_corners = list(corners)\n        for cx, cy, cz in corners:\n            all_corners.append((cx + dx, cy + dy, cz + dz))\n\n        # Find bounding box\n        min_x = min(c[0] for c in all_corners)\n        min_y = min(c[1] for c in all_corners)\n        min_z = min(c[2] for c in all_corners)\n        max_x = max(c[0] for c in all_corners)\n        max_y = max(c[1] for c in all_corners)\n        max_z = max(c[2] for c in all_corners)\n\n        bbox = self.create_bounding_box(\n            (min_x, min_y, min_z),\n            (max_x, max_y, max_z)\n        )\n        box = self.create_box(bbox)\n        return box.ToBrep()\n\n    def boolean_difference(\n        self,\n        brep_a: Any,\n        brep_b: Any,\n        tolerance: float = 0.001\n    ) -> Optional[Any]:\n        \"\"\"\n        Boolean difference: brep_a - brep_b.\n\n        Args:\n            brep_a: Base Brep\n            brep_b: Brep to subtract\n            tolerance: Boolean operation tolerance\n\n        Returns:\n            Result Brep or None if operation fails\n        \"\"\"\n        if brep_a is None or brep_b is None:\n            return brep_a\n\n        from System.Reflection import BindingFlags\n        from System import Array\n\n        try:\n            RC_Brep = self._get_type(\"Brep\")\n            if RC_Brep is None:\n                return brep_a\n\n            # Get static CreateBooleanDifference method\n            # Signature: CreateBooleanDifference(Brep, Brep, double)\n            methods = RC_Brep.GetMethods(BindingFlags.Public | BindingFlags.Static)\n\n            for method in methods:\n                if method.Name == \"CreateBooleanDifference\":\n                    params = method.GetParameters()\n                    # Looking for (Brep, Brep, double) overload\n                    if len(params) == 3:\n                        param_types = [p.ParameterType.Name for p in params]\n                        if param_types == [\"Brep\", \"Brep\", \"Double\"]:\n                            results = method.Invoke(None, [brep_a, brep_b, float(tolerance)])\n                            if results is not None and len(results) > 0:\n                                return results[0]\n                            break\n\n            # If method not found or failed, return original\n            return brep_a\n\n        except Exception as e:\n            print(f\"boolean_difference error: {e}\")\n            return brep_a\n\n    def boolean_difference_multiple(\n        self,\n        brep_base: Any,\n        breps_to_subtract: List[Any],\n        tolerance: float = 0.001\n    ) -> Optional[Any]:\n        \"\"\"\n        Boolean difference with multiple subtraction breps.\n\n        Args:\n            brep_base: Base Brep\n            breps_to_subtract: List of Breps to subtract\n            tolerance: Boolean operation tolerance\n\n        Returns:\n            Result Brep or original if operation fails\n        \"\"\"\n        result = brep_base\n\n        for brep_sub in breps_to_subtract:\n            if brep_sub is None:\n                continue\n            new_result = self.boolean_difference(result, brep_sub, tolerance)\n            if new_result is not None:\n                result = new_result\n\n        return result\n\n    # =========================================================================\n    # Framing-Specific Geometry Creation\n    # =========================================================================\n\n    def create_box_brep_from_centerline(\n        self,\n        start_point: Point3DLike,\n        direction: Vector3DLike,\n        length: float,\n        width: float,\n        depth: float,\n        wall_x_axis: Optional[Tuple[float, float, float]] = None,\n        wall_z_axis: Optional[Tuple[float, float, float]] = None,\n    ):\n        \"\"\"\n        Create a box Brep from centerline parameters.\n\n        This is the primary method for creating timber/CFS framing elements\n        as simple boxes aligned with the centerline.\n\n        Args:\n            start_point: Start point of centerline\n            direction: Direction vector (will be normalized)\n            length: Length along direction\n            width: Width perpendicular to direction (W direction in UVW)\n            depth: Depth perpendicular to direction and width (U direction)\n            wall_x_axis: Optional wall X-axis direction (along wall length)\n            wall_z_axis: Optional wall Z-axis direction (wall normal, into wall)\n\n        Returns:\n            Brep geometry from RhinoCommon assembly\n\n        Note:\n            For horizontal elements (plates, headers, sills), width and depth\n            are swapped internally because profile dimensions are defined for\n            vertical orientation but horizontal members are \"laid flat\".\n        \"\"\"\n        # Convert inputs to floats\n        if isinstance(start_point, (tuple, list)):\n            sx, sy, sz = start_point\n        else:\n            sx, sy, sz = float(start_point.X), float(start_point.Y), float(start_point.Z)\n\n        if isinstance(direction, (tuple, list)):\n            dx, dy, dz = direction\n        else:\n            dx, dy, dz = float(direction.X), float(direction.Y), float(direction.Z)\n\n        # Normalize direction\n        mag = (dx*dx + dy*dy + dz*dz) ** 0.5\n        if mag > 0:\n            dx, dy, dz = dx/mag, dy/mag, dz/mag\n\n        # Calculate end point\n        ex = sx + dx * length\n        ey = sy + dy * length\n        ez = sz + dz * length\n\n        # Calculate perpendicular vectors for width and depth\n        # For vertical elements (studs): perp1=along wall (X-axis), perp2=into wall (Z-axis/normal)\n        # For horizontal elements (plates): perp1=into wall (normal), perp2=vertical\n        is_vertical = abs(dz) > 0.9\n\n        if is_vertical:\n            # Vertical members: use wall direction if available, else fall back to World axes\n            if wall_x_axis and wall_z_axis:\n                # Use wall-relative axes:\n                # Profile width (1.5\") = along wall face = wall X-axis\n                # Profile depth (3.5\") = through-wall thickness = wall Z-axis (normal)\n                perp1 = wall_x_axis  # width direction = along wall (U)\n                perp2 = wall_z_axis  # depth direction = wall normal (W)\n            else:\n                # Fall back to hardcoded World axes (legacy behavior)\n                perp1 = (1.0, 0.0, 0.0)  # Width perpendicular in X\n                perp2 = (0.0, 1.0, 0.0)  # Depth perpendicular in Y\n        else:\n            # Horizontal members: perp1 = wall normal (in XY plane), perp2 = vertical\n            p1x = -dy\n            p1y = dx\n            p1z = 0.0\n            p1_mag = (p1x*p1x + p1y*p1y) ** 0.5\n            if p1_mag > 0:\n                p1x, p1y = p1x/p1_mag, p1y/p1_mag\n            perp1 = (p1x, p1y, p1z)\n\n            # For horizontal elements, perp2 should be vertical (Z direction)\n            # Cross direction with perp1 to get perp2\n            p2x = dy * p1z - dz * p1y\n            p2y = dz * p1x - dx * p1z\n            p2z = dx * p1y - dy * p1x\n            perp2 = (p2x, p2y, p2z)\n\n        # Profile dimensions for vertical elements (studs, king studs, trimmers, cripples):\n        #   - width = 1.5\" = visible edge along wall face (what you see from exterior)\n        #   - depth = 3.5\" = through wall thickness (wall depth)\n        #\n        # This matches standard framing: stud narrow edge faces out, wide face = wall thickness\n        # perp1 = wall_x_axis (along wall face), perp2 = wall_z_axis (wall normal/through wall)\n        if is_vertical:\n            half_w = width / 2.0  # 1.5\"/2 along wall face (visible edge)\n            half_d = depth / 2.0  # 3.5\"/2 through wall (wall thickness)\n        else:\n            # Horizontal elements: depth into wall, width vertical\n            half_w = depth / 2.0  # depth (3.5\") goes into wall\n            half_d = width / 2.0  # width (1.5\") goes vertical\n\n        corners = []\n        for start_end in [(sx, sy, sz), (ex, ey, ez)]:\n            px, py, pz = start_end\n            for w_sign in [-1, 1]:\n                for d_sign in [-1, 1]:\n                    cx = px + perp1[0] * half_w * w_sign + perp2[0] * half_d * d_sign\n                    cy = py + perp1[1] * half_w * w_sign + perp2[1] * half_d * d_sign\n                    cz = pz + perp1[2] * half_w * w_sign + perp2[2] * half_d * d_sign\n                    corners.append((cx, cy, cz))\n\n        # Find min/max from corners\n        min_x = min(c[0] for c in corners)\n        min_y = min(c[1] for c in corners)\n        min_z = min(c[2] for c in corners)\n        max_x = max(c[0] for c in corners)\n        max_y = max(c[1] for c in corners)\n        max_z = max(c[2] for c in corners)\n\n        # Create bounding box and box\n        bbox = self.create_bounding_box((min_x, min_y, min_z), (max_x, max_y, max_z))\n        box = self.create_box(bbox)\n\n        return box.ToBrep()\n\n    def create_brep_from_element_data(self, element_data) -> Optional[Any]:\n        \"\"\"\n        Create a Brep from FramingElementData.\n\n        Args:\n            element_data: FramingElementData object with centerline and profile info\n\n        Returns:\n            Brep geometry from RhinoCommon assembly\n        \"\"\"\n        start = element_data.centerline_start\n        end = element_data.centerline_end\n\n        # Calculate direction and length\n        dx = end.x - start.x\n        dy = end.y - start.y\n        dz = end.z - start.z\n        length = (dx*dx + dy*dy + dz*dz) ** 0.5\n\n        if length < 0.001:\n            return None\n\n        direction = (dx/length, dy/length, dz/length)\n\n        return self.create_box_brep_from_centerline(\n            start_point=(start.x, start.y, start.z),\n            direction=direction,\n            length=length,\n            width=element_data.profile.width,\n            depth=element_data.profile.depth,\n        )\n\n    def convert_geometry_from_rhino3dm(self, geom) -> Optional[Any]:\n        \"\"\"\n        Convert geometry from Rhino3dmIO assembly to RhinoCommon assembly.\n\n        Extracts the bounding box and recreates as RhinoCommon box.\n        While this loses exact shape, it works for box-like framing elements.\n\n        Args:\n            geom: Geometry object (likely from Rhino3dmIO)\n\n        Returns:\n            Brep from RhinoCommon assembly, or None if conversion fails\n        \"\"\"\n        if geom is None:\n            return None\n\n        try:\n            bbox = geom.GetBoundingBox(True)\n            if not bbox.IsValid:\n                return None\n\n            min_pt = (float(bbox.Min.X), float(bbox.Min.Y), float(bbox.Min.Z))\n            max_pt = (float(bbox.Max.X), float(bbox.Max.Y), float(bbox.Max.Z))\n\n            rc_bbox = self.create_bounding_box(min_pt, max_pt)\n            rc_box = self.create_box(rc_bbox)\n\n            return rc_box.ToBrep()\n        except Exception as e:\n            print(f\"convert_geometry_from_rhino3dm error: {e}\")\n            return None\n\n\n# =============================================================================\n# Module-level convenience functions\n# =============================================================================\n\n_factory_instance: Optional[RhinoCommonFactory] = None\n\n\ndef get_factory() -> RhinoCommonFactory:\n    \"\"\"\n    Get the singleton RhinoCommonFactory instance.\n\n    Returns:\n        RhinoCommonFactory instance\n\n    Raises:\n        RuntimeError: If RhinoCommon assembly is not available\n    \"\"\"\n    global _factory_instance\n    if _factory_instance is None:\n        _factory_instance = RhinoCommonFactory()\n    return _factory_instance\n\n\ndef is_factory_available() -> bool:\n    \"\"\"\n    Check if the RhinoCommonFactory can be initialized.\n\n    Returns:\n        True if factory is available, False otherwise\n    \"\"\"\n    try:\n        get_factory()\n        return True\n    except:\n        return False\n\n\ndef create_point3d(x: float, y: float, z: float):\n    \"\"\"Convenience function to create a Point3d.\"\"\"\n    return get_factory().create_point3d(x, y, z)\n\n\ndef create_vector3d(x: float, y: float, z: float):\n    \"\"\"Convenience function to create a Vector3d.\"\"\"\n    return get_factory().create_vector3d(x, y, z)\n\n\ndef create_box_brep(\n    start_point: Point3DLike,\n    direction: Vector3DLike,\n    length: float,\n    width: float,\n    depth: float,\n    wall_x_axis: Optional[Tuple[float, float, float]] = None,\n    wall_z_axis: Optional[Tuple[float, float, float]] = None,\n):\n    \"\"\"Convenience function to create a box Brep from centerline.\"\"\"\n    return get_factory().create_box_brep_from_centerline(\n        start_point, direction, length, width, depth, wall_x_axis, wall_z_axis\n    )\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon",
    "rhino3dm"
  ],
  "has_docstring": true
}