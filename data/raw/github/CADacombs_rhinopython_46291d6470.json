{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrepFace_removeTrim.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrepFace_removeTrim.py",
  "instruction": "160518-20: Created.\r\n160521: Now supports singular trims.\r\n160523: Bug fix for joined curves.\r\n160531-0601: Code modularizations.\r\n160822: Added more Dispose().  Replaced rhinoscriptsyntax functions...",
  "code": "\"\"\"\r\n160518-20: Created.\r\n160521: Now supports singular trims.\r\n160523: Bug fix for joined curves.\r\n160531-0601: Code modularizations.\r\n160822: Added more Dispose().  Replaced rhinoscriptsyntax functions with RC.\r\n        Name changed from UntrimWithRemoveEdge to DetachLocalTrim.\r\n160826: Updated alias-related code.\r\n        Name changed from DetachLocalTrim to UntrimLocal.\r\n160831: Added removeTrim().  removeTrim() now processes only one face at a time.\r\n171020: Renamed from untrimLocal.py to untrim.py.  Removed alias maker.\r\n180530: Fixed bug that indexed beyond end of list.\r\n180630: Fixed minor bug that only created the curves of one brep when multiple were selected.\r\n190505: Moved some functions from library modules.  Updated imports.\r\n190513-14: Refactored.  Import-related updates.\r\n190620: Corrected printed output of curves added.\r\n200109-10: Import-related update.  Printed feedback change.\r\n        Added Brep.Repair as a temporary fix for some cases where invalid breps are created.\r\n200415: Corrected GeometryAttributeFilter in getInput.\r\n200701: Import-related update.\r\n\r\nTODO: \r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrepLoop\r\nimport xBrepObject\r\nimport xBrepTrim\r\nimport xSurface\r\n\r\nbDebugAdd2dCrvs = False\r\nbDebugAdd3dCrvs = False\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get brep trims.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edge to remove\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.EdgeFilter\r\n\r\n    go.GeometryAttributeFilter = (\r\n        ~\r\n        ri.Custom.GeometryAttributeFilter.SeamEdge\r\n        )\r\n\r\n    while True:\r\n        Opts.riAddOpts['bEcho'](go)\r\n        Opts.riAddOpts['bDebug'](go)\r\n    \r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        if res == ri.GetResult.Object:\r\n            break\r\n        else:\r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n    \r\n    gBreps0 = []\r\n    idx_rgTrims = []\r\n    \r\n    for idx_Obj in range(go.ObjectCount):\r\n        objRef = go.Object(idx_Obj)\r\n        idx_rgTrim = objRef.GeometryComponentIndex.Index\r\n        gBrep0 = objRef.ObjectId\r\n    \r\n        if not gBrep0 in gBreps0:\r\n            gBreps0.append(gBrep0)\r\n            idx_rgTrims.append([idx_rgTrim])\r\n        else:\r\n            idx_rgTrims[gBreps0.index(gBrep0)].append(idx_rgTrim)\r\n    \r\n    go.Dispose()\r\n    \r\n    return tuple(\r\n            [gBreps0] +\r\n            [idx_rgTrims] +\r\n            [Opts.values[key] for key in Opts.keys]\r\n    )\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef removeTrim(rgBrep0, idx_rgFace, idx_rgLoops, idx_rgTrims_ToRemove, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep0\r\n        idx_rgFaces (of idx_rgTrims_ToRemove)\r\n        idx_rgLoops (of idx_rgTrims_ToRemove)\r\n        idx_rgTrims_ToRemove\r\n    Returns:\r\n        Success: rgBreps1, rgCrvs1_Joined\r\n        Fail: None\r\n    \"\"\"\r\n\r\n\r\n    def indicesOfTrimsNotToRemove(rgLoop, idx_rgTrims_ToRemove):\r\n        # Create list of trims of natural, not natural keep, and sublists of not natural remove.\r\n        idx_rgTs_Alpha = [] # Natural indices in main list; not natural indices in sublists.\r\n        for t, rgT in enumerate(rgLoop.Trims):\r\n            if xBrepTrim.isSenw(rgT):\r\n                idx_rgTs_Alpha.append(rgT.TrimIndex)\r\n            else: # Place indices of contiguous not natural trims to remove in sublists.\r\n                if t == 0:\r\n                    idx_rgTs_Alpha.append([rgT.TrimIndex])\r\n                elif type(idx_rgTs_Alpha[-1]) is not list:\r\n                    idx_rgTs_Alpha.append([rgT.TrimIndex])\r\n                elif xBrepTrim.isStartPointOnSenw(rgT):\r\n                    idx_rgTs_Alpha.append([rgT.TrimIndex])\r\n                else:\r\n                    idx_rgTs_Alpha[-1].append(rgT.TrimIndex)\r\n        \r\n        \"\"\" If not natural trim sublist starts at end of list and continues to\r\n        beginning, add beginning sublist to the end of the end sublist.\"\"\"\r\n        if type(idx_rgTs_Alpha[0]) is list and type(idx_rgTs_Alpha[-1]) is list:\r\n            if not xBrepTrim.isStartPointOnSenw(\r\n                    rgLoop.Brep.Trims[idx_rgTs_Alpha[0][0]]):\r\n                idx_rgTs_Alpha = (idx_rgTs_Alpha[1:-1] + [idx_rgTs_Alpha[-1] +\r\n                        idx_rgTs_Alpha[0]])\r\n        \r\n        \"\"\" Flatten not natural trims to keep.\"\"\"\r\n        idx_rgTs_Omega = [] # Natural and not natural but keep indices in main list; not natural, remove indices in sublists.\r\n        numToKeep = 0\r\n        \r\n        for s in idx_rgTs_Alpha:\r\n            if type(s) is int: idx_rgTs_Omega.append(s)\r\n            else: # s is sublist of not natural trims.\r\n                if any(idx in s for idx in idx_rgTrims_ToRemove):\r\n                    idx_rgTs_Omega.append(s) # To remove\r\n                else: # To keep\r\n                    idx_rgTs_Omega.extend(s)\r\n                    numToKeep += 1\r\n        \r\n        if numToKeep == 0 and not xBrepLoop.hasMultipleTrimsOnAnyNaturalEdges(rgLoop): return\r\n        \r\n        \"\"\"\r\n        1. Find first trim point that doesn't change (between trims to keep).\r\n            If it doesn't exist, return None to use simple loop creator.\r\n        2. Rotate the list so that this trim is at index 0.\r\n            lines = lines[breakPtIdxs[0]:] + lines[:breakPtIdxs[0]]\r\n        \"\"\"\r\n        \r\n        if not (type(idx_rgTs_Omega[0]) is int and type(idx_rgTs_Omega[-1]) is int):\r\n            iLen = len(idx_rgTs_Omega)\r\n            for i in range(iLen):\r\n                iPlus1 = (i+1) % iLen\r\n                if (type(idx_rgTs_Omega[i]) is int\r\n                        and type(idx_rgTs_Omega[iPlus1]) is int):\r\n                    idx_rgTs_Omega = idx_rgTs_Omega[iPlus1:] + idx_rgTs_Omega[:iPlus1]\r\n                    break\r\n            else: return # Because no connecting trims to keep found.\r\n        \r\n        # Remove subLists.\r\n        return [s for s in idx_rgTs_Omega if type(s) is int]\r\n\r\n\r\n    def indexOfExistingVertexPerLocation(pt3d_ToTest, rgBrep, tol=1.e-6):\r\n        for rgVertex in rgBrep.Vertices:\r\n            if pt3d_ToTest.EpsilonEquals(rgVertex.Location, tol):\r\n                return rgVertex.VertexIndex\r\n\r\n\r\n    def tryExistingEdgeMatchingCurve(rgCrv, rgBrep):\r\n        \"\"\"\r\n        Returns: rgEdge if vertex indices match and curves have distance deviation within a tolerance.\r\n        \"\"\"\r\n    \r\n        # First, get existing vertices that match or return None if either don't exist.\r\n        idx_rgV_rgCrvStart = indexOfExistingVertexPerLocation(\r\n                rgCrv.PointAtStart, rgBrep)\r\n        if idx_rgV_rgCrvStart is None: return\r\n        idx_rgV_rgCrvEnd = indexOfExistingVertexPerLocation(\r\n                rgCrv.PointAtEnd, rgBrep)\r\n        if idx_rgV_rgCrvEnd is None: return\r\n    \r\n        for rgE in rgBrep.Edges:\r\n            # First, check whether vertex indices at both ends match.\r\n            if not ((idx_rgV_rgCrvStart == rgE.StartVertex.VertexIndex and\r\n                    idx_rgV_rgCrvEnd == rgE.EndVertex.VertexIndex)\r\n                    or\r\n                    (idx_rgV_rgCrvStart == rgE.EndVertex.VertexIndex and\r\n                    idx_rgV_rgCrvEnd == rgE.StartVertex.VertexIndex)):\r\n                continue\r\n        \r\n            # Now, check whether curves overlap, and if so, their maximum deviation.\r\n            rc = rg.Curve.GetDistancesBetweenCurves(\r\n                    rgCrv, rgE, sc.doc.ModelAbsoluteTolerance)\r\n            if not rc[0] or rc[1] > Rhino.RhinoMath.ZeroTolerance:\r\n                continue\r\n        \r\n            # Now, compare lengths.\r\n            if Rhino.RhinoMath.EpsilonEquals(rgCrv.GetLength(), rgE.GetLength(), 1.0e-7):\r\n                return rgE\r\n\r\n\r\n    def addEdgeTrimToLoopAsDuplicateFromOtherBrep(rgL_B1, rgT_B0, bDebug=False):\r\n    \r\n        if bDebug: print '_\\n' + 'addEdgeTrimToLoopAsDuplicateFromOtherBrep()' + '-'*10 + 'Start'\r\n    \r\n        rgB1 = rgL_B1.Brep\r\n        rgTrims_L_B0 = rgT_B0.Brep.Loops[rgT_B0.Loop.LoopIndex].Trims\r\n    \r\n        fTol = 0.0\r\n    \r\n        rgEdge_B0 = rgT_B0.Edge\r\n        rgCrv3d = rgEdge_B0.Duplicate()\r\n    \r\n        # Search and use existing or add a new edge.\r\n        rgEdge_B1 = tryExistingEdgeMatchingCurve(rgCrv3d, rgB1) # Try all trims in case a previous boundary becomes a seam.\r\n        if rgEdge_B1 is not None:\r\n            bRevCrv3d = True # Because the previously made edge was already aligned with its Trim.\r\n        else: # Trim's edge has not been created.\r\n            rgEdge_B0_Tol = rgEdge_B0.Tolerance\r\n            if rgT_B0.IsReversed(): rgCrv3d.Reverse()\r\n            bRevCrv3d = False\r\n        \r\n            # If this is the 1st trim, add vertex for first trim of brep.\r\n            if rgL_B1.Trims.Count == 0:\r\n                rgVertex_EStart = rgB1.Vertices.Add(\r\n                        rgCrv3d.PointAtStart, fTol)\r\n                if bDebugAdd3dCrvs: rs.AddTextDot('V0', rgVertex_EStart.Location)\r\n            else: # Use vertex matching the end of the last trim in loop.\r\n                rgVertex_EStart = xBrepLoop.endVertexOfLastTrim(rgL_B1)\r\n                if rgVertex_EStart is None:\r\n                    idxVs_NoEdges = indicesOfVerticesWithoutEdges(rgB1)\r\n                    if len(idxVs_NoEdges) > 0:\r\n                        rgVertex_EStart = rgB1.Vertices[idxVs_NoEdges[-1]]\r\n                    else:\r\n                        print 'No existing vertex found for edge!'\r\n                        return\r\n        \r\n            # Search and use existing or add a new vertex at end of curve for edge.\r\n            idx_rgVertex_End = indexOfExistingVertexPerLocation(rgCrv3d.PointAtEnd, rgB1)\r\n            if idx_rgVertex_End is None:\r\n                rgVertex_EEnd = rgB1.Vertices.Add(rgCrv3d.PointAtEnd, fTol)\r\n                idx_rgVertex_End = rgVertex_EEnd.VertexIndex\r\n                if bDebugAdd3dCrvs:\r\n                    rs.AddTextDot('V' + str(idx_rgVertex_End),\r\n                            rgVertex_EEnd.Location)\r\n            else:\r\n                rgVertex_EEnd = rgB1.Vertices[idx_rgVertex_End]\r\n        \r\n            #\r\n            # Add Crv3d to brep\r\n            idx_Crv3d = rgB1.AddEdgeCurve(rgCrv3d)\r\n        \r\n            #\r\n            # Add brep edge\r\n            rgEdge_B1 = rgB1.Edges.Add(\r\n                    rgVertex_EStart.VertexIndex,\r\n                    rgVertex_EEnd.VertexIndex,\r\n                    idx_Crv3d, rgEdge_B0_Tol)\r\n        \r\n            if bDebugAdd3dCrvs:\r\n                sc.doc.Objects.AddCurve(rgEdge_B1)\r\n                rs.AddTextDot('E' + str(rgB1.Edges[rgB1.Edges.Count - 1].EdgeIndex),\r\n                        rgEdge_B1.PointAt(rgEdge_B1.DivideByCount(2, False)[0]))\r\n    \r\n        #\r\n        # Add brep trim.\r\n        rgCrv2d = rgT_B0.ToNurbsCurve()\r\n    \r\n        idx_Crv2d = rgB1.AddTrimCurve(rgCrv2d)\r\n    \r\n        rgTrim_B1 = rgB1.Trims.Add(rgEdge_B1, bRevCrv3d, rgL_B1, idx_Crv2d)\r\n        rgTrim_B1.SetTolerances(fTol, fTol)\r\n        rgTrim_B1.IsoStatus = rgTrim_B1.Face.IsIsoparametric(rgCrv2d)\r\n    \r\n        if bDebugAdd2dCrvs:\r\n            sc.doc.Objects.AddCurve(rgCrv2d)\r\n            rs.AddTextDot('T' + str(rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex),\r\n                    rgCrv2d.PointAt(rgCrv2d.DivideByCount(2, False)[0]))\r\n        if bDebug:\r\n            sEval='rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex'; print sEval+':',eval(sEval)\r\n            print '-'*50 + 'End'\r\n    \r\n        return rgB1\r\n\r\n\r\n    def isParamPtAlphaBeforeParamPtBetaPerIsoStatusPerLoopDir(rgSrf, isoStatus, pt3d_0, pt3d_1):\r\n        if isoStatus == rg.IsoStatus.South:\r\n            return pt3d_0.X < pt3d_1.X\r\n        elif isoStatus == rg.IsoStatus.East:\r\n            return pt3d_0.Y < pt3d_1.Y\r\n        elif isoStatus == rg.IsoStatus.North:\r\n            return pt3d_0.X > pt3d_1.X\r\n        elif isoStatus == rg.IsoStatus.West:\r\n            return pt3d_0.Y > pt3d_1.Y\r\n\r\n\r\n    def paramPt3dAtStartOfIsoStatusPerLoopDir(rgSrf, isoStatus):\r\n        if isoStatus == rg.IsoStatus.South:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Min, rgSrf.Domain(1).Min, 0.0)\r\n        elif isoStatus == rg.IsoStatus.East:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Max, rgSrf.Domain(1).Min, 0.0)\r\n        elif isoStatus == rg.IsoStatus.North:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Max, rgSrf.Domain(1).Max, 0.0)\r\n        elif isoStatus == rg.IsoStatus.West:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Min, rgSrf.Domain(1).Max, 0.0)\r\n\r\n\r\n    def paramPt3dAtEndOfIsoStatusPerLoopDir(rgSrf, isoStatus):\r\n        if isoStatus == rg.IsoStatus.South:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Max, rgSrf.Domain(1).Min, 0.0)\r\n        elif isoStatus == rg.IsoStatus.East:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Max, rgSrf.Domain(1).Max, 0.0)\r\n        elif isoStatus == rg.IsoStatus.North:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Min, rgSrf.Domain(1).Max, 0.0)\r\n        elif isoStatus == rg.IsoStatus.West:\r\n            return rg.Point3d(\r\n                    rgSrf.Domain(0).Min, rgSrf.Domain(1).Min, 0.0)\r\n\r\n\r\n    def addSingularTrimToLoop(rgL_B1, isoStatus, ptT_Start=None, ptT_End=None, bDebug=False):\r\n        if bDebug: print '_\\n' + 'addSingularTrimToLoop()' + '-'*10 + 'Start'\r\n        \r\n        rgB1 = rgL_B1.Brep\r\n        \r\n        fTol = 0.0\r\n        \r\n        if ptT_Start is None:\r\n            ptT_Start = paramPt3dAtStartOfIsoStatusPerLoopDir(rgL_B1.Face, isoStatus)\r\n        \r\n        if ptT_End is None:\r\n            ptT_End = paramPt3dAtEndOfIsoStatusPerLoopDir(rgL_B1.Face, isoStatus)\r\n        \r\n        pt_V = rgL_B1.Face.PointAt(ptT_Start.X, ptT_Start.Y)\r\n        \r\n        idx_rgV = indexOfExistingVertexPerLocation(pt_V, rgB1)\r\n        if idx_rgV is None:\r\n            rgV = rgB1.Vertices.Add(pt_V, fTol)\r\n            idx_rgV = rgV.VertexIndex\r\n        else:\r\n            rgV = rgB1.Vertices[idx_rgV]\r\n        \r\n        rgCrv2d = rg.LineCurve(ptT_Start, ptT_End)\r\n        \r\n        idx_Crv2d = rgB1.AddTrimCurve(rgCrv2d)\r\n        isoStatus = rgB1.Faces[0].IsIsoparametric(rgCrv2d)\r\n        rgB1.Trims.AddSingularTrim(\r\n                rgV, rgL_B1, isoStatus, idx_Crv2d)\r\n        pt_End = rgV.Location\r\n        \r\n        if bDebugAdd2dCrvs:\r\n            sc.doc.Objects.AddCurve(rgCrv2d)\r\n            rs.AddTextDot('T' + str(rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex),\r\n                    rgCrv2d.PointAt(rgCrv2d.DivideByCount(2, False)[0]))\r\n        if bDebug:\r\n            sEval='rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex'; print sEval+':',eval(sEval)\r\n            print '-'*50 + 'End'\r\n        \r\n        return rgB1\r\n\r\n\r\n    def greaterOf2ContiguousIsoStatuses(isoStatuses):\r\n        if isoStatuses[0] is None or isoStatuses[1] is None: return\r\n        south = rg.IsoStatus.South\r\n        east = rg.IsoStatus.East\r\n        north = rg.IsoStatus.North\r\n        west = rg.IsoStatus.West\r\n        senw = (rg.IsoStatus.South, rg.IsoStatus.East,\r\n                rg.IsoStatus.North, rg.IsoStatus.West)\r\n        if (senw.index(isoStatuses[0]) - senw.index(isoStatuses[1]) == 1 or\r\n                senw.index(isoStatuses[0]) - senw.index(isoStatuses[1]) == -3):\r\n            return isoStatuses[0]\r\n        return isoStatuses[1]\r\n\r\n\r\n    def nextIsoStatus(isoStatus):\r\n        return eval('rg.IsoStatus.' + (\r\n                'West', 'South', 'East', 'North')[(isoStatus.value__ - 3 + 1) % 4])\r\n\r\n\r\n    def addSenwEdgeTrimToLoop(rgL_B1, isoStatus, ptT_Start=None, ptT_End=None, bDebug=False):\r\n        \"\"\"\r\n        Parameters:\r\n        \r\n        Returns:\r\n        \r\n        \"\"\"\r\n        if bDebug: print '_\\n' + 'addSenwEdgeTrimToLoop()' + '-'*10 + 'Start'\r\n    \r\n        rgB1 = rgL_B1.Brep\r\n    \r\n        fTol = 0.0\r\n    \r\n        if ptT_Start is None:\r\n            ptT_Start = paramPt3dAtStartOfIsoStatusPerLoopDir(rgL_B1.Face, isoStatus)\r\n    \r\n        if ptT_End is None:\r\n            ptT_End = paramPt3dAtEndOfIsoStatusPerLoopDir(rgL_B1.Face, isoStatus)\r\n    \r\n        # Create rgCrv3d.\r\n        rgCrv3d_0 = xSurface.senwCurvePerSide(rgL_B1.Face, isoStatus)\r\n    \r\n        if isoStatus == rg.IsoStatus.South:\r\n            intrvl = rg.Interval(ptT_Start.X, ptT_End.X)\r\n        elif isoStatus == rg.IsoStatus.North:\r\n            intrvl = rg.Interval(ptT_End.X, ptT_Start.X)\r\n        elif isoStatus == rg.IsoStatus.West:\r\n            intrvl = rg.Interval(ptT_End.Y, ptT_Start.Y)\r\n        elif isoStatus == rg.IsoStatus.East:\r\n            intrvl = rg.Interval(ptT_Start.Y, ptT_End.Y)\r\n        else: return\r\n    \r\n        # Trim rgCrv3d to interval.\r\n        rgCrv3d_1 = rgCrv3d_0.Trim(intrvl)\r\n        if rgCrv3d_1 is None:\r\n            if bDebug:\r\n                sEval='rgCrv3d_1'; print sEval+':',eval(sEval)\r\n            intrvl.Swap()\r\n            rgCrv3d_1 = rgCrv3d_0.Trim(intrvl)\r\n            if bDebug:\r\n                sEval='rgCrv3d_1'; print sEval+':',eval(sEval)\r\n                sEval='formatDistance(intrvl.T1 - intrvl.T0)'; print sEval+':',eval(sEval)\r\n            if rgCrv3d_1 is None:\r\n                if bDebug: print \"intrvl may be too short.\"\r\n                return\r\n    \r\n        # If trim is at North or West, reverse rgCrv3d's direction to match that of loop.\r\n        if (isoStatus == rg.IsoStatus.North or\r\n                isoStatus == rg.IsoStatus.West):\r\n            rgCrv3d_1.Reverse()\r\n    \r\n        #\r\n        # Get / add existing edge.\r\n        if xSurface.isIsoStatusAtSeam(rgL_B1.Face, isoStatus):\r\n            rgEdge_B1 = tryExistingEdgeMatchingCurve(rgCrv3d_1, rgB1)\r\n        else: rgEdge_B1 = None\r\n        if rgEdge_B1 is not None:\r\n            bRevCrv3d = True # Because curve for previous edge was aligned with the shared trim.\r\n        else: # Trim's edge has not been created.\r\n            bRevCrv3d = False # Because rgCrv3d was made as an extraction from the surface and already aligned with trim.\r\n        \r\n            # If this is the 1st trim, add vertex for first trim of brep.\r\n            if rgL_B1.Trims.Count == 0:\r\n                rgVertex_EStart = rgB1.Vertices.Add(rgCrv3d_1.PointAtStart, fTol)\r\n                if bDebugAdd3dCrvs: rs.AddTextDot('V0', rgVertex_EStart.Location)\r\n            else: # Get existing vertex.\r\n                rgVertex_EStart = xBrepLoop.endVertexOfLastTrim(rgL_B1)\r\n                if rgVertex_EStart is None:\r\n                    idxVs_NoEdges = indicesOfVerticesWithoutEdges(rgB1)\r\n                    if len(idxVs_NoEdges) > 0:\r\n                        rgVertex_EStart = rgB1.Vertices[idxVs_NoEdges[-1]]\r\n                    else:\r\n                        print 'No existing vertex found for edge!'\r\n                        return\r\n        \r\n            # Get / add end vertex.\r\n            idx_rgVertex_End = indexOfExistingVertexPerLocation(rgCrv3d_1.PointAtEnd, rgB1)\r\n            if idx_rgVertex_End is None:\r\n                rgVertex_EEnd = rgB1.Vertices.Add(rgCrv3d_1.PointAtEnd, fTol)\r\n                idx_rgVertex_End = rgVertex_EEnd.VertexIndex\r\n                if bDebugAdd3dCrvs:\r\n                    rs.AddTextDot('V' + str(idx_rgVertex_End),\r\n                            rgVertex_EEnd.Location)\r\n            else:\r\n                rgVertex_EEnd = rgB1.Vertices[idx_rgVertex_End]\r\n        \r\n            #\r\n            # Add rgCrv3d to brep.\r\n            idx_Crv3d_B1 = rgB1.AddEdgeCurve(rgCrv3d_1)\r\n        \r\n            #\r\n            # Add brep edge\r\n            rgEdge_B1 = rgB1.Edges.Add(\r\n                    rgVertex_EStart.VertexIndex,\r\n                    rgVertex_EEnd.VertexIndex,\r\n                    idx_Crv3d_B1, fTol)\r\n        \r\n            if bDebugAdd3dCrvs:\r\n                sc.doc.Objects.AddCurve(rgEdge_B1)\r\n                rs.AddTextDot('E' + str(rgB1.Edges[rgB1.Edges.Count - 1].EdgeIndex),\r\n                        rgEdge_B1.PointAt(rgEdge_B1.DivideByCount(2, False)[0]))\r\n    \r\n        #\r\n        # Add brep trim.\r\n        rgCrv2d = rg.LineCurve(ptT_Start, ptT_End)\r\n    \r\n        idx_Crv2d = rgB1.AddTrimCurve(rgCrv2d)\r\n    \r\n        rgTrim_B1 = rgB1.Trims.Add(rgEdge_B1, bRevCrv3d,\r\n                rgL_B1, idx_Crv2d)\r\n        rgTrim_B1.SetTolerances(fTol, fTol)\r\n        rgTrim_B1.IsoStatus = rgTrim_B1.Face.IsIsoparametric(rgCrv2d)\r\n    \r\n        if bDebugAdd2dCrvs:\r\n            sc.doc.Objects.AddCurve(rgTrim_B1.ToNurbsCurve())\r\n            rs.AddTextDot('T' + str(rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex),\r\n                    rgCrv2d.PointAt(rgCrv2d.DivideByCount(2, False)[0]))\r\n        if bDebug:\r\n            sEval='rgB1.Trims[rgB1.Trims.Count - 1].TrimIndex'; print sEval+':',eval(sEval)\r\n            print '-'*50 + 'End'\r\n    \r\n        return rgB1\r\n\r\n\r\n    def addSenwTrimToLoop(rgL_B1, isoStatus, ptT_Start=None, ptT_End=None, bDebug=False):\r\n        if xSurface.isSrfSideSingularPerIsoStatus(rgL_B1.Face, isoStatus):\r\n            return addSingularTrimToLoop(\r\n                    rgL_B1,\r\n                    isoStatus,\r\n                    ptT_Start,\r\n                    ptT_End,\r\n                    bDebug=bDebug)\r\n        else:\r\n            return addSenwEdgeTrimToLoop(\r\n                    rgL_B1,\r\n                    isoStatus,\r\n                    ptT_Start,\r\n                    ptT_End,\r\n                    bDebug=bDebug)\r\n\r\n\r\n    def addOuterLoop(rgB1, rgLoop_B0, idx_rgTrims_ToRemove, bDebug=False):\r\n        \"\"\"\r\n        Parameters:\r\n            rgB1\r\n            rgLoop_B0\r\n            idx_rgTrims_ToRemove\r\n            bDebug\r\n        Returns:\r\n            \r\n        \"\"\"\r\n        \r\n        \r\n        idx_rgTs_B0_NotRemoved = indicesOfTrimsNotToRemove(rgLoop_B0, idx_rgTrims_ToRemove)\r\n        if bDebug: sEval='idx_rgTs_B0_NotRemoved'; print sEval+':',eval(sEval)\r\n        if idx_rgTs_B0_NotRemoved is None:\r\n            rgB1.Loops.AddOuterLoop(0)\r\n            return rgB1\r\n        \r\n        fTrimEndPtTol = 1.e-6\r\n        \r\n        #\r\n        # Add loop to Brep1.\r\n        rgL_B1 = rgB1.Loops.Add(\r\n                rg.BrepLoopType.Outer, rgB1.Faces[0])\r\n        \r\n        #\r\n        # Create vertices, edges, trims.\r\n        \r\n        #    for iT_L_B0, rgT_B0 in enumerate(rgTrims_L_B0):\r\n        for i, idx_rgT_B0_Reduced in enumerate(idx_rgTs_B0_NotRemoved):\r\n            if bDebug:\r\n                print '_'*20\r\n                print 'Trim construction stage:', i\r\n                sEval='idx_rgT_B0_Reduced'; print sEval+':',eval(sEval)\r\n            \r\n            rgT_B0 = rgLoop_B0.Brep.Trims[idx_rgT_B0_Reduced]\r\n            #sEval='rgT_B0.TrimIndex'; print sEval+':',eval(sEval)\r\n            \r\n            rgT_B0_Prev_Keep = rgLoop_B0.Brep.Trims[idx_rgTs_B0_NotRemoved[(i-1) % len(idx_rgTs_B0_NotRemoved)]]\r\n            if i != 0:\r\n                rgT_B1_LastAdded = rgL_B1.Trims[rgL_B1.Trims.Count-1] # Get new one.\r\n                if not rgT_B0.PointAtStart.EpsilonEquals(rgT_B1_LastAdded.PointAtEnd, fTrimEndPtTol):\r\n                    if bDebug: print \"This trim has already been added.\"\r\n                    continue\r\n            \r\n            rgT_B0_Next_Keep = rgLoop_B0.Brep.Trims[idx_rgTs_B0_NotRemoved[(i+1) % len(idx_rgTs_B0_NotRemoved)]]\r\n            \r\n            \"\"\" Check whether end point of current trim is equivalent to the\r\n            start point of the following one to keep.  This will also support\r\n            loops that connect at the current trim end point with only one vertex.\"\"\"\r\n            if rgT_B0.PointAtEnd.EpsilonEquals(\r\n                    rgT_B0_Next_Keep.PointAtStart, fTrimEndPtTol):\r\n                if rgT_B0.TrimType == rg.BrepTrimType.Singular:\r\n                    rgB1 = addSingularTrimToLoop(rgL_B1, rgT_B0.IsoStatus,\r\n                    rgT_B0.PointAtStart, rgT_B0.PointAtEnd, bDebug)\r\n                else:\r\n                    rgB1 = addEdgeTrimToLoopAsDuplicateFromOtherBrep(rgL_B1, rgT_B0, bDebug)\r\n            else: # Trim(s) to remove follow current trim.\r\n                if xBrepTrim.isSenw(rgT_B0):\r\n                    if (rgT_B0_Next_Keep.IsoStatus == rgT_B0.IsoStatus and\r\n                            isParamPtAlphaBeforeParamPtBetaPerIsoStatusPerLoopDir(\r\n                            rgL_B1.Face, rgT_B0.IsoStatus, rgT_B0.PointAtEnd,\r\n                            rgT_B0_Next_Keep.PointAtStart)): # IsoStatus of current and next trim are the same and in that order, so merge.\r\n                        if rgT_B0.TrimType == rg.BrepTrimType.Seam:\r\n                            rgB1 = addSenwTrimToLoop(\r\n                                    rgL_B1,\r\n                                    rgT_B0.IsoStatus,\r\n                                    rgT_B0.PointAtStart,\r\n                                    rgT_B0.PointAtEnd,\r\n                                    bDebug=bDebug)\r\n                        else:\r\n                            rgB1 = addSenwTrimToLoop(\r\n                                    rgL_B1,\r\n                                    rgT_B0.IsoStatus,\r\n                                    rgT_B0.PointAtStart,\r\n                                    rgT_B0_Next_Keep.PointAtEnd,\r\n                                    bDebug=bDebug)\r\n                            continue # Because latest trim added connects with next trim to keep.\r\n                    else: # Next trim to keep is not SENW.\r\n                        isoStats_rgT_B0_Next_Keep_StartPt = xBrepTrim.senwIsoStatusIntersectingTrimPointAtStart(\r\n                                rgT_B0_Next_Keep)\r\n                        \r\n                        # TODO: Fix bug here\r\n                        \r\n                        if len(isoStats_rgT_B0_Next_Keep_StartPt) == 2:\r\n                            isoStat_rgT_B0_Next_Keep_StartPt = greaterOf2ContiguousIsoStatuses(isoStats_rgT_B0_Next_Keep_StartPt)\r\n                        else:\r\n                            isoStat_rgT_B0_Next_Keep_StartPt = isoStats_rgT_B0_Next_Keep_StartPt[0]\r\n                        \r\n                        if (isoStat_rgT_B0_Next_Keep_StartPt is not None and\r\n                                rgT_B0.IsoStatus == isoStat_rgT_B0_Next_Keep_StartPt and\r\n                                isParamPtAlphaBeforeParamPtBetaPerIsoStatusPerLoopDir(\r\n                                rgL_B1.Face, rgT_B0.IsoStatus, rgT_B0.PointAtEnd,\r\n                                rgT_B0_Next_Keep.PointAtStart)):\r\n                            # End trim to next keep trim start point.\r\n                            rgB1 = addSenwTrimToLoop(\r\n                                    rgL_B1,\r\n                                    rgT_B0.IsoStatus,\r\n                                    rgT_B0.PointAtStart,\r\n                                    rgT_B0_Next_Keep.PointAtStart,\r\n                                    bDebug=bDebug)\r\n                            continue # Because latest trim added connects with next trim to keep.\r\n                        else: # Add trim to next surface corner.\r\n                            rgPt3d_T_corner = paramPt3dAtEndOfIsoStatusPerLoopDir(\r\n                                    rgL_B1.Face, rgT_B0.IsoStatus)\r\n                            rgB1 = addSenwTrimToLoop(\r\n                                    rgL_B1,\r\n                                    rgT_B0.IsoStatus,\r\n                                    rgT_B0.PointAtStart,\r\n                                    rgPt3d_T_corner,\r\n                                    bDebug=bDebug)\r\n                else: # Trim is not SENW.\r\n                    if rgT_B0.TrimType == rg.BrepTrimType.Singular:\r\n                        rgB1 = addSingularTrimToLoop(\r\n                                rgL_B1,\r\n                                rgT_B0.IsoStatus,\r\n                                rgT_B0.PointAtStart,\r\n                                rgT_B0.PointAtEnd,\r\n                                bDebug=bDebug)\r\n                    else:\r\n                        rgB1 = addEdgeTrimToLoopAsDuplicateFromOtherBrep(\r\n                                rgL_B1,\r\n                                rgT_B0,\r\n                                bDebug=bDebug)\r\n                \r\n                rgT_B1_LastAdded = rgL_B1.Trims[rgL_B1.Trims.Count-1] # Get trim last added.\r\n                \r\n                if rgT_B1_LastAdded.PointAtEnd.EpsilonEquals(\r\n                        rgT_B0_Next_Keep.PointAtStart, fTrimEndPtTol):\r\n                    continue\r\n                \r\n                #print \"Add full length natural trims that removed trims span over.\"\r\n                \r\n                isoStats_rgT_B1_LastAdded_End = xBrepTrim.senwIsoStatusIntersectingTrimPointAtEnd(rgT_B1_LastAdded)\r\n                if isoStats_rgT_B1_LastAdded_End is None: return\r\n                if len(isoStats_rgT_B1_LastAdded_End) == 2:\r\n                    isoStat_rgT_B1_LastAdded_EndPt = greaterOf2ContiguousIsoStatuses(isoStats_rgT_B1_LastAdded_End)\r\n                else:\r\n                    isoStat_rgT_B1_LastAdded_EndPt = isoStats_rgT_B1_LastAdded_End[0]\r\n                \r\n                \"\"\" First connect any missing trims if last trim endpoint is on the\r\n                same IsoStatus as the next trim to keep start point.\"\"\"\r\n                if (rgT_B0_Next_Keep.IsoStatus == isoStat_rgT_B1_LastAdded_EndPt):\r\n                    #print \"Merge to end of next trim to keep.\"\r\n                    if xSurface.isIsoStatusAtSeam(rgL_B1.Face, rgT_B0_Next_Keep.IsoStatus):\r\n                        rgB1 = addSenwTrimToLoop(\r\n                                rgL_B1,\r\n                                rgT_B0_Next_Keep.IsoStatus,\r\n                                rgT_B1_LastAdded.PointAtEnd,\r\n                                rgT_B0_Next_Keep.PointAtStart,\r\n                                bDebug=bDebug)\r\n                    else:\r\n                        rgB1 = addSenwTrimToLoop(\r\n                                rgL_B1,\r\n                                rgT_B0_Next_Keep.IsoStatus,\r\n                                rgT_B1_LastAdded.PointAtEnd,\r\n                                rgT_B0_Next_Keep.PointAtEnd,\r\n                                bDebug=bDebug)\r\n                        continue # Because latest trim added connects with next trim to keep.\r\n                else:\r\n                    isoStats_rgT_B0_Next_Keep_StartPt = xBrepTrim.senwIsoStatusIntersectingTrimPointAtStart(\r\n                            rgT_B0_Next_Keep)\r\n                    if len(isoStats_rgT_B0_Next_Keep_StartPt) == 2:\r\n                        isoStat_rgT_B0_Next_Keep_StartPt = greaterOf2ContiguousIsoStatuses(isoStats_rgT_B0_Next_Keep_StartPt)\r\n                    else:\r\n                        isoStat_rgT_B0_Next_Keep_StartPt = isoStats_rgT_B0_Next_Keep_StartPt[0]\r\n                    \r\n                    if (isoStat_rgT_B0_Next_Keep_StartPt\r\n                            == isoStat_rgT_B1_LastAdded_EndPt):\r\n                        # Extend to start of next trim to keep.\r\n                        rgB1 = addSenwTrimToLoop(\r\n                                rgL_B1,\r\n                                isoStat_rgT_B0_Next_Keep_StartPt,\r\n                                rgT_B1_LastAdded.PointAtEnd,\r\n                                rgT_B0_Next_Keep.PointAtStart,\r\n                                bDebug=bDebug)\r\n                        continue # Because latest trim added connects with next trim to keep.\r\n                    else:\r\n                        rgPt3d_T_corner = paramPt3dAtEndOfIsoStatusPerLoopDir(\r\n                                rgL_B1.Face, isoStat_rgT_B1_LastAdded_EndPt)\r\n                        rgB1 = addSenwTrimToLoop(\r\n                                rgL_B1,\r\n                                isoStat_rgT_B1_LastAdded_EndPt,\r\n                                rgT_B1_LastAdded.PointAtEnd,\r\n                                rgPt3d_T_corner,\r\n                                bDebug=bDebug)\r\n                \r\n                rgT_B1_LastAdded = rgL_B1.Trims[rgL_B1.Trims.Count-1] # Get trim last added.\r\n                \r\n                #print \"If end point of last trim added matches the start point of the next trim to keep, continue to next trim.\"\r\n                if rgT_B1_LastAdded.PointAtEnd.EpsilonEquals(\r\n                        rgT_B0_Next_Keep.PointAtStart, fTrimEndPtTol): continue\r\n                \r\n                #print \"Using greater because if at corner, the previous point comparison should have been True.\"\r\n                isoStats_rgT_B0_Next_Keep_StartPt = xBrepTrim.senwIsoStatusIntersectingTrimPointAtStart(\r\n                        rgT_B0_Next_Keep)\r\n                if len(isoStats_rgT_B0_Next_Keep_StartPt) == 2:\r\n                    isoStat_rgT_B0_Next_Keep_StartPt = greaterOf2ContiguousIsoStatuses(isoStats_rgT_B0_Next_Keep_StartPt)\r\n                else:\r\n                    isoStat_rgT_B0_Next_Keep_StartPt = isoStats_rgT_B0_Next_Keep_StartPt[0]\r\n                \r\n                while (nextIsoStatus(rgT_B1_LastAdded.IsoStatus) !=\r\n                        isoStat_rgT_B0_Next_Keep_StartPt):\r\n                    sc.escape_test()\r\n                    \r\n                    rgT_B1_LastAdded = rgL_B1.Trims[rgL_B1.Trims.Count-1]\r\n                    rgB1 = addSenwTrimToLoop(rgL_B1,\r\n                            nextIsoStatus(rgT_B1_LastAdded.IsoStatus),\r\n                            None,\r\n                            None,\r\n                            bDebug=bDebug)\r\n                    \r\n                    rgT_B1_LastAdded = rgL_B1.Trims[rgL_B1.Trims.Count-1] # Get new one.\r\n                \r\n                #print \"Add trim connecting corner of natural border to next trim.\"\r\n                if xBrepTrim.isSenw(rgT_B0_Next_Keep):\r\n                    \r\n                    rgB1 = addSenwTrimToLoop(\r\n                            rgL_B1,\r\n                            rgT_B0_Next_Keep.IsoStatus,\r\n                            rgT_B1_LastAdded.PointAtEnd,\r\n                            rgT_B0_Next_Keep.PointAtEnd,\r\n                            bDebug=bDebug)\r\n                else:\r\n                    isoStats_rgT_B0_Next_Keep_StartPt = xBrepTrim.senwIsoStatusIntersectingTrimPointAtStart(\r\n                            rgT_B0_Next_Keep)\r\n                    if len(isoStats_rgT_B0_Next_Keep_StartPt) == 2:\r\n                        isoStat_rgT_B0_Next_Keep_StartPt = greaterOf2ContiguousIsoStatuses(isoStats_rgT_B0_Next_Keep_StartPt)\r\n                    else:\r\n                        isoStat_rgT_B0_Next_Keep_StartPt = isoStats_rgT_B0_Next_Keep_StartPt[0]\r\n                    \r\n                    rgB1 = addSenwTrimToLoop(\r\n                            rgL_B1,\r\n                            isoStat_rgT_B0_Next_Keep_StartPt,\r\n                            rgT_B1_LastAdded.PointAtEnd,\r\n                            rgT_B0_Next_Keep.PointAtStart,\r\n                            bDebug=bDebug)\r\n                \r\n        return rgB1\r\n\r\n\r\n    def indicesOfNotSenwTrimsInSublists(rgLoop):\r\n        \"\"\"\r\n        Returns:\r\n            idx_rgTrims_Natural: Flat list of trim indices of natural edges\r\n            idx_rgTrims_NotSenw_SubLoops: List of lists of trim indices of not natural edges\r\n        \"\"\"\r\n        idx_rgTrims_Natural = []\r\n        idx_rgTrims_NotSenw_SubLoops = []\r\n        \r\n        bLastTrimWasOfNaturalEdge = False\r\n        \r\n        for t, rgTrim in enumerate(rgLoop.Trims):\r\n            if xBrepTrim.isSenw(rgTrim):\r\n                bLastTrimWasOfNaturalEdge = True\r\n            else:\r\n                if (len(idx_rgTrims_NotSenw_SubLoops) == 0 or\r\n                        bLastTrimWasOfNaturalEdge or\r\n                        xBrepTrim.isStartPointOnSenw(rgTrim)):\r\n                    idx_rgTrims_NotSenw_SubLoops.append([]) # Start new NotNaturalEdge sublist.\r\n                idx_rgTrims_NotSenw_SubLoops[-1].append(rgTrim.TrimIndex)\r\n                bLastTrimWasOfNaturalEdge = False\r\n        \r\n        if (len(idx_rgTrims_NotSenw_SubLoops) > 1 and not xBrepTrim.isStartPointOnSenw(\r\n                rgLoop.Brep.Trims[idx_rgTrims_NotSenw_SubLoops[0][0]])):\r\n            idx_rgTrims_NotSenw_SubLoops = (\r\n                    idx_rgTrims_NotSenw_SubLoops[1:-1] +\r\n                    [idx_rgTrims_NotSenw_SubLoops[-1] +\r\n                    idx_rgTrims_NotSenw_SubLoops[0]])\r\n        \r\n        return idx_rgTrims_NotSenw_SubLoops\r\n\r\n\r\n    def separateSublistsOfAWhetherAnyItemInListB(listA, listB):\r\n        listTrue = []; listFalse = []\r\n        for sublistInA in listA:\r\n            if any(itemInA in sublistInA for\r\n                    itemInA in listB):\r\n                listTrue.append(sublistInA)\r\n            else:\r\n                listFalse.append(sublistInA)\r\n        return listTrue, listFalse\r\n\r\n\r\n\r\n    fTol = 0.0\r\n    \r\n    rgFace0 = rgBrep0.Faces[idx_rgFace]\r\n\r\n    # Create brep for new face.\r\n    rgB1 = rg.Brep()\r\n    rgSrf = rgFace0.UnderlyingSurface()\r\n    idx_Srf = rgB1.AddSurface(rgSrf)\r\n    rgFace1 = rgB1.Faces.Add(idx_Srf)\r\n    \r\n    \"\"\" Loop through each loop of selected trims to\r\n            Create modified outer loop, if outer loop was selected.\r\n            Aquire loop's non-selected edges.\"\"\"\r\n    for iL, idx_rgLoop in enumerate(idx_rgLoops):\r\n        rgLoop_B0 = rgBrep0.Loops[idx_rgLoop]\r\n        \r\n        \"\"\" If any of its trims are part of idx_rgTrims_ToRemove,\r\n        custom create outer loop. \"\"\"\r\n        if rgLoop_B0.LoopType == (rg.BrepLoopType.Outer):\r\n            rgB1 = addOuterLoop(\r\n                    rgB1,\r\n                    rgLoop_B0,\r\n                    idx_rgTrims_ToRemove[iL],\r\n                    bDebug=bDebug)\r\n            \r\n            idx_rgTrims_NotSenw_SubLoops = (\r\n                    indicesOfNotSenwTrimsInSublists(rgLoop_B0))\r\n            \r\n            idx_rgTs_NotSenw_Remove_SubLoops, idx_rgTs_NotSenw_Keep_SubLoops = (\r\n                    separateSublistsOfAWhetherAnyItemInListB(\r\n                    idx_rgTrims_NotSenw_SubLoops, idx_rgTrims_ToRemove[iL]))\r\n            \r\n            idx_rgTs_B0_Senw_Keep = [i for sub in idx_rgTs_NotSenw_Keep_SubLoops for i in sub]\r\n            \r\n            rgEdges_InLoopsWithSel = [\r\n                    rgTrim.Edge for rgTrim in rgLoop_B0.Trims if (\r\n                    rgTrim.TrimIndex not in idx_rgTrims_ToRemove[iL]\r\n                    and\r\n                    rgTrim.TrimType != rg.BrepTrimType.Seam\r\n                    and\r\n                    not xBrepTrim.isSenw(rgTrim)\r\n                    and\r\n                    rgTrim.TrimIndex not in idx_rgTs_B0_Senw_Keep\r\n                    )]\r\n        else:\r\n            \"\"\" For 3D curve creation, create list of edges\r\n            not selected in loops with selected edges. \"\"\"\r\n            rgEdges_InLoopsWithSel = [\r\n                    rgTrim.Edge for rgTrim in rgLoop_B0.Trims if (\r\n                    rgTrim.TrimIndex not in idx_rgTrims_ToRemove[iL]\r\n                    and\r\n                    rgTrim.TrimType != rg.BrepTrimType.Seam\r\n                    and\r\n                    not xBrepTrim.isSenw(rgTrim)\r\n                    )]\r\n        # Uncomment to create unjoined curves:\r\n        #map(sc.doc.Objects.AddCurve, rgEdges_InLoopsWithSel)\r\n        \r\n    \"\"\" Duplicate Loops with edges not part of selection from rgBrep0 to\r\n        rgB1.\"\"\"\r\n    \r\n    # Create list of loops that have none of the selected trims.\r\n    idx_rgLoops_B0_NotSel = [i.LoopIndex for\r\n            i in rgBrep0.Faces[idx_rgFace].Loops if\r\n            i.LoopIndex not in idx_rgLoops]\r\n    \r\n    # Create loops and subtopology.\r\n    for idxL_B0_NotSel in idx_rgLoops_B0_NotSel:\r\n        \r\n        # Add loop.\r\n        rgL_B1 = rgB1.Loops.Add(\r\n                rgBrep0.Loops[idxL_B0_NotSel].LoopType, rgFace1)\r\n        \r\n        # Create vertices, edges, trims.\r\n        rgTrims_L_B0 = rgBrep0.Loops[idxL_B0_NotSel].Trims\r\n        \r\n        for rgT_B0 in rgTrims_L_B0:\r\n            if rgT_B0.TrimType == rg.BrepTrimType.Singular:\r\n                rgB1 = addSingularTrimToLoop(\r\n                        rgL_B1,\r\n                        rgT_B0.IsoStatus,\r\n                        rgT_B0.PointAtStart,\r\n                        rgT_B0.PointAtEnd,\r\n                        bDebug=bDebug)\r\n            else: # Trim is not singular.\r\n                rgB1 = addEdgeTrimToLoopAsDuplicateFromOtherBrep(\r\n                        rgL_B1,\r\n                        rgT_B0,\r\n                        bDebug=bDebug)\r\n            # End of Trim loop\r\n        # End of Loop loop\r\n\r\n    if rgB1 and not rgB1.IsValid:\r\n        bRepaired = rgB1.Repair(tolerance=sc.doc.ModelAbsoluteTolerance)\r\n        if bDebug:\r\n            sEval='bRepaired'; print sEval+':',eval(sEval)\r\n            # True from Brep.Repair doesn't mean that the Brep is valid.\r\n            sEval='rgB1.IsValid'; print sEval+':',eval(sEval)\r\n        \r\n        if rgB1.IsValid:\r\n            print \"Invalid brep was repaired.\" \\\r\n                \"  **  Possible bug in xBrepFace_removeTrim\"\r\n        else:\r\n            bBrep1IsValid, sLog = rgB1.IsValidWithLog()\r\n            print sLog\r\n            print '-'*40\r\n\r\n            #bBrep1IsValid, sLog = rgB1.IsValidTopology()\r\n            #print sLog\r\n            \r\n            rgB1.Dispose()\r\n            return\r\n\r\n\r\n    if bDebug:\r\n        if rgB1 is None:\r\n            print \"rgB1 is None.\"\r\n        else:\r\n            sEval='rgB1.Loops.Count'; print sEval+':',eval(sEval)\r\n            sEval='rgB1.Trims.Count'; print sEval+':',eval(sEval)\r\n            sEval='rgB1.Edges.Count'; print sEval+':',eval(sEval)\r\n            sEval='rgB1.Vertices.Count'; print sEval+':',eval(sEval)\r\n            #            for t in rgB1.Loops[0].Trims:\r\n            #                print t.Edge.StartVertex.VertexIndex, t.Edge.EndVertex.VertexIndex\r\n            sEval='rgB1.IsValid'; print sEval+':',eval(sEval)\r\n    \r\n    return rgB1, rgEdges_InLoopsWithSel\r\n\r\n\r\ndef processBrepObjects(gBreps0, idx_rgTs_ToRemove_PerBs0, bEcho=True, bDebug=False):\r\n    \r\n    gBreps1_1F_withRemovedTrim_All = []\r\n    gs_CrvsAdded_All = []\r\n\r\n\r\n\r\n    def processBrepObject(gBrep0, idx_rgTs_ToRemove, bEcho=True, bDebug=False):\r\n        #rgBreps1 = [[] for i in range(len(gBreps0))]\r\n        rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(idBrep0)\r\n        rgBrep0 = rdBrep0.BrepGeometry\r\n    \r\n    \r\n        def createOrderedLists_FacesLoopsTrims(rgBrep0, idx_rgTrims):\r\n            \"\"\"\r\n            Per provided trim indices per brep,\r\n            create ordered lists of their face, loop, and trim indices.\r\n            \"\"\"\r\n        \r\n            idx_rgFaces = []\r\n            idx_rgLoops = []\r\n            idx_rgTrims_ToRemove = []\r\n        \r\n            for idx_rgTrim in idx_rgTrims:\r\n                rgTrim = rgBrep0.Trims[idx_rgTrim]\r\n                idx_rgFace = rgTrim.Face.FaceIndex\r\n                idx_rgLoop = rgTrim.Loop.LoopIndex\r\n            \r\n                if not idx_rgFace in idx_rgFaces:\r\n                    idx_rgFaces.append(idx_rgFace)\r\n                    idx_rgLoops.append([idx_rgLoop])\r\n                    idx_rgTrims_ToRemove.append([[idx_rgTrim]])\r\n                else:\r\n                    iF = idx_rgFaces.index(idx_rgFace)\r\n                    if not idx_rgLoop in idx_rgLoops[iF]:\r\n                        idx_rgLoops[iF].append(idx_rgLoop)\r\n                        idx_rgTrims_ToRemove[iF].append([idx_rgTrim])\r\n                    else:\r\n                        iL = idx_rgLoops[iF].index(idx_rgLoop)\r\n                        idx_rgTrims_ToRemove[iF][iL].append(idx_rgTrim)\r\n        \r\n            return idx_rgFaces, idx_rgLoops, idx_rgTrims_ToRemove\r\n    \r\n    \r\n        rc = createOrderedLists_FacesLoopsTrims(rgBrep0, idx_rgTs_ToRemove)\r\n        idx_rgFaces_B0, idx_rgLoops_2Nest, idx_rgTrims_ToRemove_3Nest = rc\r\n    \r\n        attr = rdBrep0.Attributes.Duplicate()\r\n    \r\n        rgBs1_1F = []\r\n        rgCrvs1_Joined = []\r\n\r\n        # Get new face and curves of each face of selected trims.\r\n        for iF in xrange(len(idx_rgFaces_B0)):\r\n\r\n            rc = removeTrim(\r\n                    rgBrep0,\r\n                    idx_rgFaces_B0[iF],\r\n                    idx_rgLoops_2Nest[iF],\r\n                    idx_rgTrims_ToRemove_3Nest[iF],\r\n                    bDebug=bDebug)\r\n            if rc is None: continue\r\n\r\n            rgB1_1F, rgEdges_InLoopsWithSel = rc\r\n            if not rgB1_1F: continue\r\n\r\n            rgBs1_1F.append(rgB1_1F)\r\n\r\n            # For joined curves.\r\n            if len(rgEdges_InLoopsWithSel) > 0:\r\n                rgCrvs1_Joined.extend(rg.Curve.JoinCurves(\r\n                        rgEdges_InLoopsWithSel))\r\n\r\n        if len(rgBs1_1F) != len(idx_rgFaces_B0):\r\n            print \"Some of the new brep geometry is missing.\"\r\n            return\r\n\r\n\r\n        # Modify brep.\r\n\r\n        gBreps1_1F_withRemovedTrim = []\r\n    \r\n        for iB in range(len(rgBs1_1F)):\r\n            if not rgBs1_1F[iB].IsValid:\r\n\r\n                    continue # to next Face.\r\n\r\n            # Brep is valid.\r\n\r\n            # Add single-face breps and create list of faces to remove from main brep.\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBs1_1F[iB], attr)\r\n            if gBrep1 != Guid.Empty:\r\n                gBreps1_1F_withRemovedTrim.append(gBrep1)\r\n            else:\r\n                print \"Could not add a face with removed trim for {}.\".format(gBrep0)\r\n                continue # to next Face.\r\n\r\n            # No breaks (fails), so remove faces from polyface brep.\r\n            gBreps1_B0WithFacesRemoved = xBrepObject.removeFaces(\r\n                    gBrep0,\r\n                    idx_rgFaces_B0)\r\n            if gBreps1_B0WithFacesRemoved is None:\r\n                print \"Faces could not be removed from {}.\".format(gBrep0)\r\n                return\r\n\r\n\r\n        # Add curves.\r\n        gCrvs1_Added = []\r\n        if len(rgCrvs1_Joined) == 0:\r\n            print \"No curves added.\"\r\n        else:\r\n            for rgCrv1_Joined in rgCrvs1_Joined:\r\n                gCrv1_Added = sc.doc.Objects.AddCurve(rgCrv1_Joined)\r\n                if gCrv1_Added != Guid.Empty:\r\n                    gCrvs1_Added.append(gCrv1_Added)\r\n            s  = \"{}\".format(len(gCrvs1_Added))\r\n            s += \" curve{} added.\".format('s' if len(gCrvs1_Added) != 1 else '')\r\n            if len(rgCrvs1_Joined) != len(gCrvs1_Added):\r\n                s += \"  {} curves failed to be added.\".format(\r\n                        len(rgCrvs1_Joined) - len(gCrvs1_Added))\r\n            print s\r\n\r\n        return gBreps1_1F_withRemovedTrim, gCrvs1_Added\r\n\r\n\r\n\r\n    # Iterate through list of breps.\r\n    for iB0, (gBrep0, idx_rgTs_ToRemove) in enumerate(zip(gBreps0, idx_rgTs_ToRemove_PerBs0)):\r\n        rc = processBrepObject(\r\n                gBrep0=gBrep0,\r\n                idx_rgTs_ToRemove=idx_rgTs_ToRemove,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n        if bDebug: print rc\r\n        if rc is None: continue\r\n        gBreps1_1F_withRemovedTrim, gCrvs1_Added = rc\r\n        \r\n        gBreps1_1F_withRemovedTrim_All.append(gBreps1_1F_withRemovedTrim)\r\n        gs_CrvsAdded_All.append(gCrvs1_Added)\r\n    \r\n    return gBreps1_1F_withRemovedTrim_All, gs_CrvsAdded_All\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        gBreps0,\r\n        idx_rgTs_ToRemove_PerBs0,\r\n        bEcho,\r\n        bDebug,\r\n    ) = rc\r\n    \r\n    if bDebug:\r\n        print \"Running with Debug mode on.\"\r\n        import sys\r\n        for sModule in list(sys.modules):\r\n            if sModule[0] == 'x':\r\n                try:\r\n                    reload(sys.modules[sModule])\r\n                    print \"{} reloaded.\".format(sModule)\r\n                except:\r\n                    s  = \"{} NOT reloaded.\".format(sModule)\r\n                    s += \"  Does the module contain a bug\"\r\n                    s += \" or was its name changed?\"\r\n                    print s\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    rc = processBrepObjects(\r\n        gBreps0=gBreps0,\r\n        idx_rgTs_ToRemove_PerBs0=idx_rgTs_ToRemove_PerBs0,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    gBreps1_1F_withRemovedTrim_All, gs_CrvsAdded_All = rc\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}