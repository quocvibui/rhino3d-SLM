{
  "source_url": "https://github.com/Tcadart/pyLatticeDSO/blob/6c2b0d65ee9d9c52bfc170b0b7df6a8ec2f622ca/extras/grasshopper/pyLattice_gh_design.py",
  "repo": "Tcadart/pyLatticeDSO",
  "repo_stars": 8,
  "repo_description": "pyLatticeDSO - Framework for Design, Simulation and Optimization of truss lattice structures",
  "license": "MIT",
  "filepath": "extras/grasshopper/pyLattice_gh_design.py",
  "instruction": "Script to be used in Grasshopper with GHPython component.\nUse save_JSON_to_Grasshopper from pyLatticeDesign.utils to export lattice from pyLatticeDesign to Grasshopper.\nSee documentation for more...",
  "code": "\"\"\"\nScript to be used in Grasshopper with GHPython component.\nUse save_JSON_to_Grasshopper from pyLatticeDesign.utils to export lattice from pyLatticeDesign to Grasshopper.\nSee documentation for more information.\n\"\"\"\n\n__author__ = \"tcadart\"\n__version__ = \"2025.01.16\"\n\nimport json\nimport csv\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport ghpythonlib.treehelpers as th\n\n# Lenght and center definition\ncenter = rg.Point3d(0.5, 0.5, 0.5)\nsize_outer = 2\nsize_inner = 1\n\n\n# Two cube generation\nhalf_size = size_outer / 2\nmin_corner = rg.Point3d(center.X - half_size, center.Y - half_size, center.Z - half_size)\nmax_corner = rg.Point3d(center.X + half_size, center.Y + half_size, center.Z + half_size)\ncube_outer = rg.Box(rg.BoundingBox(min_corner, max_corner)).ToBrep()\n\nhalf_size = size_inner / 2\nmin_corner = rg.Point3d(center.X - half_size, center.Y - half_size, center.Z - half_size)\nmax_corner = rg.Point3d(center.X + half_size, center.Y + half_size, center.Z + size_inner)\ncube_inner = rg.Box(rg.BoundingBox(min_corner, max_corner)).ToBrep()\n\nmin_corner = rg.Point3d(center.X - half_size, center.Y - half_size, center.Z + half_size)\nmax_corner = rg.Point3d(center.X + half_size, center.Y + half_size, center.Z + size_inner)\ncube_surface_up = rg.Box(rg.BoundingBox(min_corner, max_corner)).ToBrep()\n# Solid Difference\nresult = rg.Brep.CreateBooleanDifference([cube_outer], [cube_inner], 0.01)\nfinal_result = rg.Brep.CreateBooleanUnion([result[0], cube_surface_up], 0.01)\n\nvolume_data = []\n# List of path to look after JSON file\nfile_path_list = []\n\nif len(file_path_list) == 0:\n    raise ValueError(\"No path given, add path before running\")\n\nprint(nameLattice)\n\n\nlattice = None\nfor base in file_path_list:\n    try:\n        filePathAll = \"{}{}.json\".format(base, nameLattice)\n        with open(filePathAll, \"r\") as f:\n            lattice = json.load(f)\n            break\n    except Exception as e:\n        print(\"Impossible to load from {} : {}\".format(base, e))\nif lattice is None:\n    raise IOError(\"No file found '{}' in given path.\".format(nameLattice))\n\n\nX = lattice[\"nodesX\"]\nY = lattice[\"nodesY\"]\nZ = lattice[\"nodesZ\"]\nRadius = lattice[\"radii\"]\n\n# Point generation\npoints = [rg.Point3d(x, y, z) for x, y, z in zip(X, Y, Z)]\n\n# Generation True/False pattern\nPattern = [i % 2 == 0 for i in range(len(points))]\n\n# Separation point list\nlist_A = [pt for pt, flag in zip(points, Pattern) if flag]\nlist_B = [pt for pt, flag in zip(points, Pattern) if not flag]\n\n# Line generation between points\nlines = [rg.Line(a, b) for a, b in zip(list_A, list_B)]\n\n# Volume parameters for Dendro\nmin_radius = min(Radius) if Radius else 0.01\nmax_radius = max(Radius) if Radius else 0.1\n\nvoxel_size = max(min_radius / 2.0, 0.002)  # More small for small structures\niso_value = max(min_radius / 3.0, 0.0005)  # Relatif threshold for small radius\n\nvolume_settings = ghcomp.DendroGH.CreateSettings(voxel_size, 1, 0, iso_value)\n\n\n# Generating volume from lines\nvolume = ghcomp.DendroGH.CurveToVolume(lines, Radius, volume_settings)\n\n# Conversion to mesh\nmesh = ghcomp.DendroGH.VolumetoMesh(volume, volume_settings)\n\nif cutCell:\n    mesh_cube = rg.Mesh()\n    meshes = rg.Mesh.CreateFromBrep(final_result[0], rg.MeshingParameters.Default)\n    if meshes:\n        for m in meshes:\n            mesh_cube.Append(m)\n\n    # Mesh Boolean Difference\n    mesh_difference = rg.Mesh.CreateBooleanDifference([mesh], [mesh_cube])\n    mesh = mesh_difference[0]\n\nvol = rg.Mesh.Volume(mesh)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}