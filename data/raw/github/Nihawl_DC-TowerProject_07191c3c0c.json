{
  "source_url": "https://github.com/Nihawl/DC-TowerProject/blob/c7c313efa7c772023ea11650ad3fe5b7f14b282c/Tower-Project-Module07.py",
  "repo": "Nihawl/DC-TowerProject",
  "repo_stars": 0,
  "repo_description": "Tower Skin 3D Model in Python - Part of \"Design Computing\" Course in Coursera ",
  "license": "MIT",
  "filepath": "Tower-Project-Module07.py",
  "instruction": "3D SURFACE MATRIX import modules",
  "code": "#3D SURFACE MATRIX\r\n#import modules\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\ndef SurfacePoints(STRSRF, INTU, INTV):\r\n    #create empty dictionary\r\n    ptMTX = {}\r\n    srfNorm01 = {}\r\n    srfNorm02 = {}\r\n    \r\n    #find surface domain\r\n    Udomain = rs.SurfaceDomain(STRSRF,0)\r\n    Vdomain = rs.SurfaceDomain(STRSRF,1)\r\n    \r\n    #find step size\r\n    UStep = (Udomain[1] - Udomain[0])/ INTU\r\n    VStep = (Vdomain[1] - Vdomain[0])/ INTV\r\n    \r\n    #find exponential step value\r\n    expStep = DivideExponentially((Udomain[1]-Udomain[0]), INTU)\r\n    \r\n    #PLOT POINTS ON SURFACE\r\n    for i in range(INTU+1):\r\n        for j in range(INTV+1):\r\n            #define u and v in terms of i and j\r\n            #u = Udomain[0] + UStep*i\r\n            u = expStep[i]\r\n            v = Vdomain[0] + VStep*j\r\n            \r\n            #evaluate surface\r\n            point = rs.EvaluateSurface(STRSRF, u,v)\r\n            #print point\r\n            ptMTX[(i,j)] = point\r\n            \r\n            #find surface normals\r\n            vecNorm = rs.SurfaceNormal(STRSRF, (u,v))\r\n            print vecNorm\r\n            #unitize vector for scaling\r\n            vecNorm = rs.VectorUnitize(vecNorm)\r\n            #make scale a factor of distance from plane\r\n            plane = rs.WorldXYPlane()\r\n            distance = rs.DistanceToPlane(plane, point)\r\n            vecNorm = rs.VectorScale(vecNorm, 1)\r\n            #add to srfNorm01\r\n            srfNorm01[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            #unitize and scale vector\r\n            vecNorm= rs.VectorUnitize(vecNorm)\r\n            vecNorm = rs.VectorScale(vecNorm, 1)\r\n            #add to srfNorm02\r\n            srfNorm02[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            \r\n    #call function to generate geometry\r\n    GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV)\r\n\r\ndef   GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV):\r\n    #LOOP TO GENERATE GEOMETRY\r\n        for i in range(INTU + 1):\r\n            for j in range(INTV + 1):\r\n                if i > 0 and  j > 0 :\r\n                    #set parameter \r\n                    tBack = 0.75 - (i*0.01)\r\n                    ### CREATE BACK CURVE ###\r\n                    #create back points\r\n                    #create lines\r\n                    crv01 = rs.AddCurve((ptMTX[(i-1,j-1)],ptMTX[(i,j-1)],ptMTX[(i,j)]),1)\r\n                    crv02 = rs.AddCurve((ptMTX[(i-1,j-1)],ptMTX[(i-1,j)],ptMTX[(i,j)]),1)\r\n                    t01 = rs.CurveParameter(crv01, tBack)\r\n                    t02 = rs.CurveParameter(crv02, tBack)\r\n                    pt01 = rs.EvaluateCurve(crv01,t01)\r\n                    pt02 = rs.EvaluateCurve(crv02,t02)\r\n                    #create curve\r\n                    backCrv = rs.AddCurve((ptMTX[(i,j-1)],ptMTX[(i-1,j-1)],ptMTX[(i-1,j)]),1)\r\n                    \r\n                    ### CREATE FRONT CURVE ###\r\n                    #create front points\r\n                    tFront = (tBack - 0.1) - (i*0.01)\r\n                    crv03 = rs.AddCurve((srfNorm01[(i-1,j-1)],srfNorm01[(i,j)]))\r\n                    t03 = rs.CurveParameter(crv03, tFront)\r\n                    pt03 = rs.EvaluateCurve(crv03,t03)\r\n                    frontCrv = rs.AddCurve((pt01,pt03,pt02),2)\r\n                    #loft\r\n                    module = rs.AddLoftSrf((backCrv,frontCrv),None, None,1,0)\r\n                    \r\n                    #delete \r\n                    rs.DeleteObjects((crv03,frontCrv,backCrv,crv01,crv02))\r\n\r\n\r\n\r\n\r\ndef MidPt(PT01, PT02):\r\n    \r\n    point = None\r\n    point = [(PT01[0] + PT02[0])/2,(PT01[1] + PT02[1])/2,(PT01[2] + PT02[2])/2]\r\n    return point\r\n\r\ndef DivideExponentially(maxLength, Divisions):\r\n    #set-up lists\r\n    point = []\r\n    yVal = []\r\n    \r\n    #create point where x is .72 of Vdomain and y and z are 0 (point[0])\r\n    pt = ([(maxLength*.72), 0, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where x and y are .12 of model curve length and z is 0 (point[1])\r\n    pt = ([(maxLength*.12), (maxLength*.12), 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where y is model curve length and x and z are 0 (point[2])\r\n    pt = ([0, maxLength, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #draw a curve between the three points (GRAPHcrvGUID)\r\n    GRAPHcrvGUID = rs.AddCurve(point)\r\n    \r\n    #divide (GRAPHcrvGUID)\r\n    GRAPHpoints = rs.DivideCurve(GRAPHcrvGUID, Divisions, False, True)\r\n    \r\n    #delete curve\r\n    rs.DeleteObject(GRAPHcrvGUID)\r\n    \r\n    #collect y values in a list\r\n    for i in range(len(GRAPHpoints)):\r\n        yVal.append(GRAPHpoints[i][1])\r\n        \r\n    return yVal\r\n                  \r\ndef main():\r\n    #collect data\r\n    #strSRF = rs.GetObject('select surface', rs.filter.surface)\r\n    strSRFs = rs.GetObjects('select surfaces', rs.filter.surface)\r\n    intU = rs.GetInteger('how many U intervals?', 8)\r\n    intV = rs.GetInteger('how many V intervals?', 2)\r\n    #    rs.HideObject(strSRF)\r\n    #    #call function\r\n    #    rs.EnableRedraw(False)\r\n    #    SurfacePoints(strSRF, intU, intV)\r\n    #    rs.EnableRedraw(True)\r\n    \r\n    #call function with multiple surfaces\r\n    rs.EnableRedraw(False)\r\n    for strSRF in strSRFs:\r\n        #rs.HideObject(strSRF)\r\n        #call function\r\n        SurfacePoints(strSRF, intU, intV)\r\n    rs.EnableRedraw(True)\r\n\r\nmain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}