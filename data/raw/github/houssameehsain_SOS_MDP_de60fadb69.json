{
  "source_url": "https://github.com/houssameehsain/SOS_MDP/blob/9c874d89094f8c3ce6d06aec133679907c4d2245/RhGh_envs/BR_fullObs_noHS_env.py",
  "repo": "houssameehsain/SOS_MDP",
  "repo_stars": 2,
  "repo_description": "Deep reinforcement learning to solve self-organized settlement growth modeled as Markov decision processes. ",
  "license": "MIT",
  "filepath": "RhGh_envs/BR_fullObs_noHS_env.py",
  "instruction": "Br full obs no hs env",
  "code": "import random\nfrom math import floor\nimport socket\nimport struct\nimport pickle\nimport scriptcontext as sc\nimport ghpythonlib.components as ghcomp\nimport ghpythonlib.treehelpers as th\n\n\nclass Connection:\n    def __init__(self, s):\n        self._socket = s\n        self._buffer = \"\"\n\n    def receive_object(self):\n        while len(self._buffer) < 4 or len(self._buffer) < struct.unpack(\"<L\", self._buffer[:4])[0] + 4:\n            new_bytes = self._socket.recv(16)\n            if len(new_bytes) == 0:\n                return None\n            self._buffer += new_bytes\n        length = struct.unpack(\"<L\", self._buffer[:4])[0]\n        header, body = self._buffer[:4], self._buffer[4:length + 4]\n        obj = pickle.loads(body)\n        self._buffer = self._buffer[length + 4:]\n        return obj\n\n    def send_object(self, d):\n        body = pickle.dumps(d)\n        header = struct.pack(\"<L\", len(body))\n        msg = header + body\n        self._socket.send(msg)\n\nclass BeadyRing_env:\n    def __init__(self):\n        self._carrier_color = 127.5\n        self._house_color = 0\n        self._street_color = 255\n        self._cell_size = 3\n        self._max_row_len = 41\n        self._3d = False\n        self.iter = 0\n        \n        # grid world\n        xy_plane = ghcomp.XYPlane(ghcomp.ConstructPoint(0, 0, 0))\n        cell, _ = ghcomp.Rectangle(xy_plane, self._cell_size, self._cell_size, 0)\n        \n        r_max = self._cell_size * self._max_row_len\n        move_range = [i for i in range(0, r_max, self._cell_size)]\n        \n        y_vec = ghcomp.UnitY(move_range)\n        cell_col, _ = ghcomp.Move(cell, y_vec)\n        \n        x_vec = ghcomp.UnitX(move_range)\n        grid_world = []\n        for c in cell_col:\n            cell_row, _ = ghcomp.Move(c, x_vec)\n            grid_world.append(cell_row)\n        \n        self.grid_world = ghcomp.ReverseList(grid_world)\n        \n        # initial location\n        self.R = int(floor(self._max_row_len/2))\n        self.C = int(floor(self._max_row_len/2))\n        \n        R_space = [r for r in range(0, self._max_row_len)]\n        C_space = [c for c in range(0, self._max_row_len)]\n        self.RC_space = [[[r, c] for c in C_space] for r in R_space]\n        \n        self.cell = [self.R, self.C]\n        self.adjacent_cells = [[self.R, self.C]]\n        self.adj_cells = [[self.R, self.C]]\n        \n        # initial state\n        self.state = [[self._carrier_color for _ in range(self._max_row_len)] \n                        for _ in range(self._max_row_len)]\n\n    def step(self, _cell_state):\n        self.iter += 1\n        # update state step\n        self.state[self.R][self.C] = 255*_cell_state\n        \n        for i, a in enumerate(self.adj_cells):\n            if a == self.cell:\n                del self.adj_cells[i]\n        \n        adjacent = self.get_adjacent()\n        \n        # reward\n        reward = 0\n        adj_street_count = 0\n        \n        for a in adjacent:\n            if int(self.state[a[0]][a[1]]) == 255:\n                adj_street_count += 1\n        \n        if _cell_state == 1:\n            if adj_street_count >= 3:\n                reward -= 1\n            elif adj_street_count == 0:\n                reward -= 1\n            elif 0 < adj_street_count < 3:\n                reward += 1\n        elif _cell_state == 0:\n            # density metric\n            reward += 1/(self._max_row_len**2)\n            if adj_street_count == 0:\n                reward -= 1\n            elif adj_street_count >= 3:\n                reward -= 1\n            elif 0 < adj_street_count < 3:\n                reward += 2\n        \n        for item in adjacent:\n            if item not in self.adjacent_cells:\n                self.adjacent_cells.append(item)\n                self.adj_cells.append(item)\n        \n        # done\n        done = False\n        if len(self.adj_cells) == 0:\n            done = True\n        elif len(self.adj_cells) > 0:\n            # next action location selection\n            self.cell = random.choice(self.adj_cells)\n            self.R = self.cell[0]\n            self.C = self.cell[1]\n        \n        return self.state, reward, done, {}\n\n    def reset(self):\n        # initial state\n        self.state = [[self._carrier_color for _ in range(self._max_row_len)] \n                        for _ in range(self._max_row_len)]\n        \n        # reset step counter\n        self.iter = 0\n        \n        # initial location\n        self.R = int(floor(self._max_row_len/2))\n        self.C = int(floor(self._max_row_len/2))\n        \n        self.cell = [self.R, self.C]\n        self.adjacent_cells = [[self.R, self.C]]\n        self.adj_cells = [[self.R, self.C]]\n        \n        return self.state\n\n    def render(self):\n        # state visualization\n        color_state = [ghcomp.ColourRGB(255, self.state[i], self.state[i], \n                        self.state[i]) for i in range(self._max_row_len)]\n        return color_state\n\n    def get_adjacent(self):\n        adjacent = []\n        if self.R < len(self.RC_space) - 1:\n            adjacent.append(self.RC_space[self.R+1][self.C])\n        if self.C > 0:\n            adjacent.append(self.RC_space[self.R][self.C-1])\n        if self.R > 0:\n            adjacent.append(self.RC_space[self.R-1][self.C])\n        if self.C < len(self.RC_space[self.R]) - 1:\n            adjacent.append(self.RC_space[self.R][self.C+1])\n        return adjacent\n\n    def get_house_cells(self):\n        ## house cells\n        house_cells_ = []\n        for i in range(self._max_row_len):\n            for j in range(self._max_row_len):\n                if self.state[i][j] == 0:\n                    house_cells_.append(self.grid_world[i][j])\n        return house_cells_\n\nif loop:\n    # Create environment instance\n    if 'env' not in globals():\n        env = BeadyRing_env()\n        sc.sticky['env'] = env\n\n    # establish connection with RL agent\n    if 'agent_conn' not in globals():\n        addr = (\"127.0.0.1\", 50710)\n        agent_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        agent_socket.connect(addr)\n        agent_conn = Connection(agent_socket)\n\n    enabled = True\n    iter = 0\n\n    while enabled:\n\n        # Connection\n        if iter == 0:\n            # Reset\n            msg_in = agent_conn.receive_object()\n            if msg_in == \"reset\":\n                sc.sticky['state'] = env.reset()\n                sc.sticky['reward'] = None\n                sc.sticky['done'] = False\n                sc.sticky['info'] = {}\n            else:\n                raise RuntimeError(\"First message must be 'reset'\")\n        else:\n            # Send message\n            msg_out = {\"state\": sc.sticky['state'],\n                    \"reward\": sc.sticky['reward'],\n                    \"done\": sc.sticky['done'],\n                    \"info\": sc.sticky['info']}\n            agent_conn.send_object(msg_out)\n            # Receive message\n            msg_in = agent_conn.receive_object()\n            if msg_in == \"reset\":\n                sc.sticky['state'] = env.reset()\n                sc.sticky['reward'] = None\n                sc.sticky['done'] = False\n                sc.sticky['info'] = {}\n            elif msg_in == \"close\":\n                env.reset()\n                agent_socket.close()\n                enabled = False\n            else:\n                action = msg_in\n                sc.sticky['state'], sc.sticky['reward'], sc.sticky['done'], sc.sticky['info'] = env.step(action)\n\n            if render:\n                grid_world_ = th.list_to_tree(sc.sticky['env'].grid_world, source=[0,0])\n                color_state = sc.sticky['env'].render()\n                color_state_ = th.list_to_tree(color_state, source=[0,0])\n                if sc.sticky['env']._3d:\n                    house_cells = sc.sticky['env'].get_house_cells()\n                    house_cells_ = th.list_to_tree(house_cells, source=[0,0])\n        \n        iter += 1",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}