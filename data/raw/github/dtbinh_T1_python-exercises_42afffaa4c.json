{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/src/compas_rhino/geometry/curve.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/src/compas_rhino/geometry/curve.py",
  "instruction": null,
  "code": "from compas_rhino.exceptions import RhinoCurveError\n\ntry:\n    from Rhino.Geometry import Point3d\n\n    import rhinoscriptsyntax as rs\n    import scriptcontext as sc\n\n    find_object = sc.doc.Objects.Find\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\nclass RhinoCurve(object):\n    \"\"\"\"\"\"\n\n    def __init__(self, guid):\n        self.guid = guid\n        self.curve = find_object(guid)\n        self.geometry = self.curve.Geometry\n        self.attributes = self.curve.Attributes\n        self.otype = self.geometry.ObjectType\n\n    def hide(self):\n        return rs.HideObject(self.guid)\n\n    def show(self):\n        return rs.ShowObject(self.guid)\n\n    def select(self):\n        return rs.SelectObject(self.guid)\n\n    def unselect(self):\n        return rs.UnselectObject(self.guid)\n\n    def is_line(self):\n        return (rs.IsLine(self.guid) and\n                rs.CurveDegree(self.guid) == 1 and\n                len(rs.CurvePoints(self.guid)) == 2)\n\n    def is_polyline(self):\n        return (rs.IsPolyline(self.guid) and\n                rs.CurveDegree(self.guid) == 1 and\n                len(rs.CurvePoints(self.guid)) > 2)\n\n    def space(self, density):\n        space = []\n        density = int(density)\n        if rs.IsCurve(self.guid):\n            domain = rs.CurveDomain(self.guid)\n            u = (domain[1] - domain[0]) / (density - 1)\n            for i in range(density):\n                space.append(domain[0] + u * i)\n        elif rs.IsPolyCurve(self.guid):\n            rs.EnableRedraw(False)\n            segments = rs.ExplodeCurves(self.guid)\n            for segment in segments:\n                domain = rs.CurveDomain(segment)\n                u = (domain[1] - domain[0]) / (density - 1)\n                for i in range(density):\n                    space.append(domain[0] + u * i)\n            rs.DeleteObjects(segments)\n            rs.EnableRedraw(True)\n        else:\n            raise RhinoCurveError('object is not a curve')\n        return space\n\n    def heightfield(self, density):\n        heightfield = []\n        space = self.space(density)\n        if space:\n            xyz = [rs.EvaluateCurve(self.guid, param) for param in space]\n            heightfield = map(list, xyz)\n        return heightfield\n\n    def curvature(self):\n        raise NotImplementedError\n\n    def tangents(self, points):\n        tangents = []\n        if rs.IsPolyCurve(self.guid):\n            pass\n        elif rs.IsCurve(self.guid):\n            for point in points:\n                param = rs.CurveClosestPoint(self.guid, point)\n                vector = list(rs.CurveTangent(self.guid, param))\n                tangents.append((point, vector))\n        else:\n            raise RhinoCurveError('object is not a curve')\n        return tangents\n\n    def descent(self, points):\n        tangents = self.tangents(points)\n        tangents = [\n            (point, vector) if vector[2] < 0 else (point, [-v for v in vector])\n            for point, vector in tangents\n        ]\n        return tangents\n\n    def divide(self, number_of_segments, over_space=False):\n        points = []\n        rs.EnableRedraw(False)\n        if over_space:\n            space = self.space(number_of_segments + 1)\n            if space:\n                points = [list(rs.EvaluateCurve(self.guid, param)) for param in space]\n        else:\n            points = rs.DivideCurve(self.guid, number_of_segments, create_points=False, return_points=True)\n            points[:] = map(list, points)\n        rs.EnableRedraw(True)\n        return points\n\n    def divide_length(self, length_of_segments):\n        rs.EnableRedraw(False)\n        points = rs.DivideCurveLength(self.guid, length_of_segments, create_points=False, return_points=True)\n        points[:] = map(list, points)\n        rs.EnableRedraw(True)\n        return points\n\n    def closest_point(self, point, maxdist=None):\n        maxdist = maxdist or 0.0\n        rc, t = self.geometry.ClosestPoint(Point3d(*point), maxdist)\n        return list(self.geometry.PointAt(t))\n\n    def closest_points(self, points, maxdist=None):\n        return [self.closest_point(point, maxdist) for point in points]\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == '__main__':\n\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}