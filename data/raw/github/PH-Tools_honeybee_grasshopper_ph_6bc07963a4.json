{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/gh_compo_io/visualize_win_frames.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/gh_compo_io/visualize_win_frames.py",
  "instruction": "GHCompo Interface: HBPH - Visualize Window Frames.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"GHCompo Interface: HBPH - Visualize Window Frames.\"\"\"\n\nimport math\n\ntry:\n    from typing import Iterable, List, Sequence, Tuple\nexcept ImportError:\n    pass\n\ntry:\n    from itertools import izip  # type: ignore\nexcept ImportError:\n    izip = zip  # Python 3\n\ntry:\n    from Grasshopper import DataTree  # type: ignore\n    from Grasshopper.Kernel.Data import GH_Path  # type: ignore\n    from Rhino.Geometry import LineCurve  # type: ignore\n    from Rhino.Geometry import Brep, Interval, Plane, Point3d, Vector3d  # type: ignore\n    from System import Object  # type: ignore\nexcept ImportError:\n    pass  # Outside Rhino\n\ntry:\n    from ladybug_rhino.fromgeometry import from_face3d, from_linesegment3d, from_plane\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug_rhino:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee.aperture import Aperture\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_energy.properties.aperture import ApertureEnergyProperties\n    from honeybee_energy.properties.extension import WindowConstructionProperties\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_energy:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_energy_ph.construction.window import PhWindowFrameElement\n    from honeybee_energy_ph.properties.construction.window import WindowConstructionPhProperties\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_energy_ph:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph_rhino import gh_io\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\ntry:\n    from ph_units.converter import convert\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ph_units:\\n\\t{}\".format(e))\n\n\nclass GHCompo_VisualizeWindowFrameElements(object):\n    def __init__(self, _IGH, _apertures):\n        # type: (gh_io.IGH, List[Aperture]) -> None\n        self.IGH = _IGH\n        self.apertures = _apertures\n        self.tolerance = _IGH.sc.doc.ModelAbsoluteTolerance\n\n    def get_edge_midpoint(self, _edge):\n        # type: (LineCurve) -> Point3d\n        \"\"\"Return the midpoint of a Rhino.Geometry.LineCurve.\"\"\"\n        new_domain = Interval(0, 1)\n        _edge.Domain = new_domain\n        return _edge.PointAt(0.5)\n\n    def calc_edge_angle_about_origin(self, _edge, _center_pt, _pl, _tol=0.0001):\n        # type: (LineCurve, Point3d, Plane, float) -> float\n        \"\"\"Return the angle of an edge's midpoint about the origin of its parent plane.\"\"\"\n        # -- Find the vector from the edge's midpoint to the center\n        edge_midpoint = self.get_edge_midpoint(_edge)\n        vector_from_mid_to_center = Point3d.Subtract(edge_midpoint, _center_pt)\n\n        # -- Find the angle between the edge vector and the parent plane's local-Y axis\n        angle = math.degrees(Vector3d.VectorAngle(_pl.YAxis, vector_from_mid_to_center, _pl))\n        angle = round(angle, 2)\n        # -- Ensure no floating-point errors\n        if abs(angle - 360.0) <= _tol:\n            angle = 0.0\n\n        return angle\n\n    def sort_aperture_edges(self, _ap_edges, _ap_center_point, _ap_local_plane):\n        # type: (Sequence[LineCurve], Point3d, Plane) -> List[LineCurve]\n        \"\"\"Sort the edges of the aperture based on their angle about the aperture's center point.\n\n        Note: the native Honeybee .get_left_right_edges methods don't seem to work properly?\n        See: https://discourse.ladybug.tools/t/trouble-getting-left-and-right-aperture-edges/\n        So using this 'calc_edge_angle_about_origin' custom implementation instead.\n        \"\"\"\n        edges_sorted = sorted(\n            _ap_edges,\n            reverse=True,\n            key=lambda e: self.calc_edge_angle_about_origin(e, _ap_center_point, _ap_local_plane),\n        )\n        # This sorting yields the edges in an order like: [270, 180, 90, 0] (clockwise starting from the RIGHT edge)\n        #\n        #      0\n        #      |\n        #      |\n        # 90-------270\n        #      |\n        #      |\n        #     180\n        #\n        # We need to shift this so that the first edge is the top\n        edges_sorted = edges_sorted[-1:] + edges_sorted[:-1]\n        return edges_sorted\n\n    def create_frame_surface(self, _ap_edges, _ap_frame_elements, ap_ctr_pt):\n        # type: (Iterable[LineCurve], Iterable, Point3d) -> List[Brep]\n        \"\"\"Create the frame surfaces for the aperture.\"\"\"\n        frame_surfaces = []\n        for edge, frame in izip(_ap_edges, _ap_frame_elements):\n\n            # -- Get the width in the Rhino-document's units\n            # -- From AirTable, and in Honeybee, width will ALWAYS be in meters.\n            doc_unit_type = self.IGH.get_rhino_unit_system_name()\n            width_in_doc_units = convert(frame.width, \"M\", doc_unit_type)\n\n            crv_mid_pt = self.get_edge_midpoint(edge)\n            extrusion_vector = self.IGH.ghc.Vector2Pt(crv_mid_pt, ap_ctr_pt, True).vector\n            extrusion_vector = self.IGH.ghc.Amplitude(extrusion_vector, width_in_doc_units)\n            ext = self.IGH.ghc.Extrude(base=edge, direction=extrusion_vector)\n            frame_surfaces.append(ext)\n\n        return frame_surfaces\n\n    def create_glazing_surface(self, _frame_surfaces, _ap_surface, _ap_ctr_pt):\n        # type: (List[Brep], Brep, Point3d) -> Brep\n        \"\"\"Create the glazing surface for the aperture.\"\"\"\n        joined_frames = self.IGH.ghc.BrepJoin(_frame_surfaces).breps\n        edges = self.IGH.ghc.DeconstructBrep(joined_frames).edges\n        win_surfaces = self.IGH.ghc.SurfaceSplit(_ap_surface, edges)\n\n        # -- Figure out which of the split surfaces is the glazing surface\n        # -- by choosing the surface with the closest point to the aperture's center point\n        ct_pt_distances = []\n        for test_surface in win_surfaces:\n            ct_pt_distances.append(self.IGH.ghc.SurfaceClosestPoint(_ap_ctr_pt, test_surface).distance)\n        glazing_surface = win_surfaces[ct_pt_distances.index(min(ct_pt_distances))]\n\n        return glazing_surface\n\n    def get_aperture_ph_frame_elements(self, _aperture):\n        # type: (Aperture) -> Tuple[List[PhWindowFrameElement], List[str]]\n        \"\"\"Get the Passive House PhWindowFrameElements for of the aperture;s PH-Frame.\"\"\"\n        ap_prop_energy = getattr(_aperture.properties, \"energy\")  # type: ApertureEnergyProperties\n        ap_const = ap_prop_energy.construction\n\n        # -------------------------------------------------------------------------------\n        # -- Find the actual Window Construction\n        if hasattr(ap_const, \"window_construction\"):\n            \"\"\"\n            If it's a Honeybee Energy WindowConstructionShade the actual HB-\n            construction will be inside the 'window_construction' attribute\n            \"\"\"\n            ap_const = getattr(ap_const, \"window_construction\")\n\n        # -------------------------------------------------------------------------------\n        # -- Find the PH-Properties for the Window Construction\n        if not hasattr(ap_const, \"properties\"):\n            msg = \"Error: The Aperture {} does not have a Window Construction?, skipping...\".format(\n                _aperture.display_name\n            )\n            self.IGH.warning(msg)\n            return [], []\n\n        ap_const_prop = getattr(ap_const, \"properties\", None)  # type: WindowConstructionProperties | None\n        ap_prop_ph = getattr(ap_const_prop, \"ph\", None)  # type: WindowConstructionPhProperties | None\n\n        if not ap_prop_ph:\n            msg = \"Error: The Aperture '{}' does not have a Passive House window construction?, skipping...\".format(\n                _aperture.display_name\n            )\n            self.IGH.warning(msg)\n            return [], []\n\n        # -------------------------------------------------------------------------------\n        # -- Try and get the PH-Frame from the Window Construction\n        ap_ph_frame = ap_prop_ph.ph_frame\n        if not ap_ph_frame:\n            msg = \"Error: The Aperture {} does not have a Passive House window frame?, skipping...\".format(\n                _aperture.display_name\n            )\n            self.IGH.warning(msg)\n            return [], []\n\n        el_names = [el.display_name for el in ap_ph_frame.elements]\n        return ap_ph_frame.elements, el_names\n\n    def get_aperture_geometry(self, _aperture):\n        # type: (Aperture) -> tuple[Brep, Point3d, Plane, List[LineCurve]]\n        \"\"\"Get the geometric elements of the Honeybee-Aperture as Rhino Geometry.\"\"\"\n        ap_surface = from_face3d(_aperture.geometry)  # type: Brep # type: ignore\n        ap_ctr_pt = self.IGH.ghc.Area(ap_surface).centroid\n        ap_local_plane = from_plane(_aperture.geometry.plane)\n        ap_edges = [from_linesegment3d(s) for s in _aperture.geometry.boundary_segments]\n        ap_edges_sorted = self.sort_aperture_edges(ap_edges, ap_ctr_pt, ap_local_plane)\n        return ap_surface, ap_ctr_pt, ap_local_plane, ap_edges_sorted\n\n    def run(self):\n        # type: () -> tuple[DataTree[Object], DataTree[Object], DataTree[Object], DataTree[str], DataTree[str], DataTree[str]]\n        \"\"\"Run the component.\"\"\"\n        aperture_surfaces_ = DataTree[Object]()\n        frame_surfaces_ = DataTree[Object]()\n        glazing_surfaces_ = DataTree[Object]()\n        frame_element_type_names_ = DataTree[str]()\n        edges_ = DataTree[LineCurve]()\n        planes_ = DataTree[Plane]()\n\n        for i, ap in enumerate(self.apertures):\n            # -----------------------------------------------------------------------\n            # -- Pull out all the relevant Aperture data that is needed throughout\n            # -- Convert to from Ladybug to Rhino geometry for all the later operations.\n            surface, ctr_pt, local_plane, edges = self.get_aperture_geometry(ap)\n            hbph_frame_elements, element_names = self.get_aperture_ph_frame_elements(ap)\n\n            if not hbph_frame_elements:\n                continue\n\n            # -----------------------------------------------------------------------\n            # -- Collect the Aperture Geometry for Export\n            aperture_surfaces_.Add(surface, GH_Path(i))\n\n            # -----------------------------------------------------------------------\n            # -- Create all the Frame-Element Geometry\n            frame_surfaces = self.create_frame_surface(edges, hbph_frame_elements, ctr_pt)\n            frame_surfaces_.AddRange(frame_surfaces, GH_Path(i))\n\n            # -----------------------------------------------------------------------\n            # -- Create the Glazing Geometry\n            glazing_surface = self.create_glazing_surface(frame_surfaces, surface, ctr_pt)\n            glazing_surfaces_.Add(glazing_surface, GH_Path(i))\n\n            # -----------------------------------------------------------------------\n            # -- Get the other bits for debugging\n            frame_element_type_names_.AddRange(element_names, GH_Path(i))\n            edges_.AddRange(edges, GH_Path(i))\n            planes_.Add(local_plane, GH_Path(i))\n\n        return (\n            aperture_surfaces_,\n            frame_surfaces_,\n            glazing_surfaces_,\n            frame_element_type_names_,\n            edges_,\n            planes_,\n        )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}