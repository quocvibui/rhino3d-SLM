{
  "source_url": "https://github.com/beyondepic/EPiC_Grasshopper/blob/dbd60529a190cebf1d0af4d6c2e0ec91e110e388/epic/epic.py",
  "repo": "beyondepic/EPiC_Grasshopper",
  "repo_stars": 18,
  "repo_description": "EPiC Grasshopper plug-in",
  "license": "GPL-3.0",
  "filepath": "epic/epic.py",
  "instruction": null,
  "code": "# -*- coding: UTF-8 -*-\r\n\r\nimport copy\r\nimport datetime\r\nimport os.path\r\nfrom collections import OrderedDict\r\nfrom math import sqrt, floor, ceil, log10, isnan\r\nfrom scriptcontext import sticky as st\r\nimport Grasshopper.Kernel as ghKernel\r\nimport cPickle\r\nimport ghpythonlib.components as ghcomponents\r\nimport rhinoscriptsyntax as rs\r\nfrom Grasshopper import DataTree\r\nfrom Rhino import Display\r\nfrom Rhino import Geometry\r\nfrom System import Drawing\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\nimport os\r\nimport random\r\n\r\n__author__ = \"André Stephan & Fabian Prideaux\"\r\n__version__ = \"1.02\"\r\n__date__ = 'May, 2024'\r\n__message__ = 'EPiC Plugin ' + __version__ + '\\n' + __date__\r\nepic_version = 'AU2024'\r\nEPIC_DATABASE_WEBSITE = 'http://www.msd.unimelb.edu.au/epic'\r\nREPORT_A_BUG = 'https://bit.ly/EPiCGrasshopperBugs'\r\nDISCLAIMER = \"\"\" \r\nThe default service life and wastage coefficients are indicative only and can vary substantially. \r\n\r\nThe authors disclaim any liability, in whole or in part, arising from information contained in this plugin.\r\nThey do not take any responsibility for any action taken, decision-made, or result associated with use of this plugin\r\n\r\nFurther information about the EPiC Database and EPiC Grasshopper can be found at <http://www.epicdatabase.com.au/>\r\nTo download a full copy of the database, goto <http://doi.org/10.26188/5dc228ef98c5a>\r\n\"\"\"\r\n\r\n# Colour scheme used for EPiC Grasshopper / EPiC Database\r\nCOLOURS = {\r\n    'light_teal': Color.FromArgb(124, 189, 206),\r\n    'teal': Color.FromArgb(63, 167, 196),\r\n    'light_orange': Color.FromArgb(255, 164, 120),\r\n    'orange': Color.FromArgb(231, 112, 82),\r\n    'light_yellow': Color.FromArgb(255, 220, 162),\r\n    'yellow': Color.FromArgb(236, 174, 101),\r\n    'light_green': Color.FromArgb(152, 214, 195),\r\n    'green': Color.FromArgb(89, 177, 127),\r\n    'grey': Color.FromArgb(153, 162, 170),\r\n    'dark_grey': Color.FromArgb(100, 100, 100),\r\n    'light_blue': Color.FromArgb(173, 205, 240),\r\n    'blue': Color.FromArgb(64, 116, 178),\r\n    'light_purple': Color.FromArgb(176, 188, 225),\r\n    'purple': Color.FromArgb(114, 131, 191),\r\n    'light_pink': Color.FromArgb(255, 189, 204),\r\n    'pink': Color.FromArgb(238, 136, 137)\r\n}\r\n\r\n# Generic variables used throughout\r\nDEFINED_FLOWS = OrderedDict()\r\nDEFINED_FLOWS['energy'] = {'code_name': 'energy', 'print_name': 'Energy', 'unit': 'MJ',\r\n                           'colour': COLOURS['orange'], 'secondary_colour': COLOURS['light_orange']}\r\nDEFINED_FLOWS['water'] = {'code_name': 'water', 'print_name': 'Water', 'unit': 'L',\r\n                          'colour': COLOURS['teal'], 'secondary_colour': COLOURS['light_teal']}\r\nDEFINED_FLOWS['ghg'] = {'code_name': 'ghg', 'print_name': 'Greenhouse Gas Emissions', 'unit': 'kgCO₂e',\r\n                        'colour': COLOURS['yellow'], 'secondary_colour': COLOURS['light_yellow']}\r\n\r\nHYBRID_VALUE_BREAKDOWN_DICT = {flow: {'process': None, 'io': None} for flow in DEFINED_FLOWS.keys()}\r\n\r\n# Generic epic categories\r\nEPIC_CATEGORIES = [\r\n    \"0: Concrete and plaster products\",\r\n    \"1: Glass\",\r\n    \"2: Insulation\",\r\n    \"3: Metals\",\r\n    \"4: Miscellaneous\",\r\n    \"5: Plastics\",\r\n    \"6: Sand, stone and ceramics\",\r\n    \"7: Timber products\"]\r\n\r\nPICKLE_DB = \"EPiC_Database_2024.pkl\"\r\n\r\n\r\ndef remove_commas_and_flatten_list_for_csv_export(text_inputs, list_separator=' | ',\r\n                                                  remove_spaces=False, limit_characters=False):\r\n    \"\"\"\r\n    Remove any commas from text provided. Flatten if provided as a list of multiple strings.\r\n    :param text_inputs: a string, or list of strings\r\n    :param list_separator: separator (string) to use if a list is provided\r\n    :param remove_spaces: change spaces to underscores\r\n    :param limit_characters: limit string to 50 characters\r\n    :return: string\r\n    \"\"\"\r\n    if isinstance(text_inputs, list):\r\n        flat_text = list_separator.join(text_inputs).replace(\",\", \" \")\r\n    elif isinstance(text_inputs, str):\r\n        flat_text = text_inputs.replace(\",\", \" \")\r\n    else:\r\n        return text_inputs\r\n\r\n    if remove_spaces:\r\n        flat_text = flat_text.replace(' ', '_')\r\n\r\n    if limit_characters:\r\n        flat_text = flat_text[:50]\r\n\r\n    return flat_text\r\n\r\n\r\ndef version_mismatch(component_version):\r\n    \"\"\"\r\n    Display error message if grasshopper component is a different version to epic.py\r\n    :param component_version: Grasshopper component version\r\n    :return: Error message as string\r\n    \"\"\"\r\n    error = '*** WARNING VERSION MISMATCH, PLEASE UPDATE YOUR USER OBJECTS ***\\n' \\\r\n            'DOWNLOAD NEW USER OBJECTS AND COPY + PASTE THE NEW CODE INTO THIS COMPONENT\\n' \\\r\n            'EPiC Plugin version: {}\\n' \\\r\n            'Component version: {}'.format(__version__, component_version)\r\n    return error\r\n\r\n\r\ndef check_functional_unit_and_return_formatted_version(functional_unit):\r\n    \"\"\"\r\n    Check the functional unit and return correctly formatted funcational unit.\r\n    Will generate warning if incorrect input is used\r\n    :param functional_unit: Functional unit for EPiC/Custom Material\r\n    :return: warning message (or None), and formatted functional unit string\r\n    \"\"\"\r\n    warning = None\r\n    if functional_unit and isinstance(functional_unit, str):\r\n        functional_unit = str(functional_unit).lower()\r\n        if functional_unit in ('m', 'm²', 'm³', 'no.', 'm2', 'm3'):\r\n            if functional_unit == 'm2':\r\n                functional_unit = 'm²'\r\n            elif functional_unit == 'm3':\r\n                functional_unit = 'm³'\r\n            else:\r\n                pass\r\n    else:\r\n        warning = 'The functional unit can only be \"m\", \"m²\", \"m³\", \"kg\" or \"no.\" ' \\\r\n                  '(\"m2\" or \"m3\" are accepted and will be corrected).'\r\n    return warning, functional_unit\r\n\r\n\r\ndef make_value_list_input_component(input_node, valuelist_values, ghenv, nickname=None, valuelist_names=None,\r\n                                    xloc=0, yloc=0):\r\n    # type: (int, list, object, str, list, int, int) -> str\r\n    \"\"\"\r\n    Instantiate a new valuelist element in Grasshopper (dropdown list).\r\n    This new valuelist will be connected to the specified component, with preset list of values\r\n    :param input_node: Specify the input node number (in integers)\r\n    :param valuelist_values: List of values to be used in the dropdown list\r\n    :param ghenv: The current grasshopper running environment\r\n    :param nickname: Nickname for the new component\r\n    :param valuelist_names: List of names to be used in the dropdown list\r\n    :param xloc: Move component to the left (negative value) / right (positive value)\r\n    :param xloc: Move component up (negative value) / down (positive value)\r\n    :return: new valuelist Instance Guid\r\n    \"\"\"\r\n    # Ensure that the component expires, so that values load correctly\r\n    # ghenv.Component.ExpireSolution(True)\r\n\r\n    # Check if component already has input\r\n    if ghenv.Component.Params.Input[input_node].SourceCount == 0:\r\n\r\n        # Instantiate new value list\r\n        new_component = ghKernel.Special.GH_ValueList()\r\n\r\n        # Set up default values for the new component\r\n        new_component.CreateAttributes()\r\n\r\n        # Clear any existing list items\r\n        new_component.ListItems.Clear()\r\n        if nickname is not None:\r\n            new_component.NickName = nickname\r\n\r\n        if not xloc:\r\n            xloc = max([len(x) for x in valuelist_values]) * -5 - 100\r\n\r\n        # If no valuelist_names, or the list size is different, then use the values as a default\r\n        if not valuelist_names or len(valuelist_names) != len(valuelist_values):\r\n            valuelist_names = valuelist_values\r\n\r\n        #  Populate the new valuelist with items from the selected category\r\n        for num, vals in enumerate(valuelist_values):\r\n            new_component.ListItems.Add(ghKernel.Special.GH_ValueListItem(str(valuelist_names[num]), '\"'\r\n                                                                          + str(valuelist_values[num]) + '\"'))\r\n\r\n        new_component.Attributes.Pivot = Drawing.PointF(ghenv.Component.Params.Input[input_node].Attributes.Bounds.X\r\n                                                        + xloc - new_component.Attributes.Bounds.Width,\r\n                                                        ghenv.Component.Params.Input[input_node].Attributes.Bounds.Y\r\n                                                        + yloc)\r\n\r\n        # Add valuelist to canvas\r\n        ghdoc = ghenv.Component.OnPingDocument()\r\n        ghdoc.AddObject(new_component, False)\r\n\r\n        # Connect valuelist to component\r\n        ghenv.Component.Params.Input[input_node].AddSource(new_component)\r\n        ghenv.Component.Params.OnParametersChanged()\r\n\r\n        def expire_solution():\r\n            ghenv.Component.ExpireSolution(False)\r\n\r\n        ghdoc.ScheduleSolution(5, expire_solution())\r\n\r\n        return str(new_component.InstanceGuid)\r\n\r\n\r\ndef sum_numerical_dictionary_values(dict_1, dict_2):\r\n    \"\"\"\r\n    Sum together 2 dictionaries (if values are int / float).\r\n    :param dict_1: First dictionary (this will be used as the base dictionary).\r\n    :param dict_2: Second dictionary to merge\r\n    :return: New dictionary with summed values\r\n    \"\"\"\r\n    dict_3 = copy.deepcopy(dict_1)\r\n    for key, value in dict_2.items():\r\n        if isinstance(value, (int, float)):\r\n            dict_3[key] += value\r\n        elif isinstance(value, (dict)):\r\n            dict_3[key] = sum_numerical_dictionary_values(dict_3[key], dict_2[key])\r\n    return dict_3\r\n\r\n\r\ndef list_to_datatree(nestedlist):\r\n    \"\"\" Convert a nested python iterable to a datatree\r\n    Adapted from code by Anders Deluran (2017)\r\n    from https://discourse.mcneel.com/t/outputting-a-nested-python-list-as-tree/48188\r\n    \"\"\"\r\n\r\n    dt = DataTree[object]()\r\n\r\n    # Convert dictionary to list if needed\r\n    if isinstance(nestedlist, dict):\r\n        nestedList = nestedlist.values()\r\n\r\n    if nestedlist:\r\n        for i, l in enumerate(nestedlist):\r\n            dt.AddRange(l, ghKernel.Data.GH_Path(i))\r\n    else:\r\n        return None\r\n    return dt\r\n\r\n\r\ndef _flatten_list(list_of_lists):\r\n    \"\"\"\r\n    Recursive function to iterate through list of lists and return a flattened list of objects\r\n    :param list_of_lists: A list containing nested lists\r\n    :return: A flattened list (no nested lists)\r\n    \"\"\"\r\n    list_vals = []\r\n    for list_item in list_of_lists:\r\n        if isinstance(list_item, list):\r\n            list_vals += _flatten_list(list_item)\r\n        else:\r\n            list_vals.append(list_item)\r\n    return list_vals\r\n\r\n\r\ndef _get_accumulated_number_of_instances(period_of_analysis, service_life, include_initial=True):\r\n    \"\"\"\r\n    Generates a list representing the number of replacements of a material or assembly to date. The length of that list is\r\n    equal to period of built_assets\r\n    :param period_of_analysis: the period of built_assets in years\r\n    :param service_life: the service of the material or assembly\r\n    :param include_initial: boolean flag that specifies if the initial installation should be included\r\n    :return: a list of integers representing the accumulated number of material/assembly in the building at a given year\r\n    \"\"\"\r\n\r\n    if include_initial:\r\n        acc_num_instances = [1] * period_of_analysis\r\n    else:\r\n        acc_num_instances = [0] * period_of_analysis\r\n\r\n    num_replacements = _get_num_replacements(period_of_analysis=period_of_analysis, service_life=service_life)\r\n\r\n    if num_replacements == 0:\r\n        pass\r\n    else:\r\n        for replacement in range(1, num_replacements + 1):\r\n            acc_num_instances[replacement * service_life:] = [num_instances + 1 for num_instances in\r\n                                                              acc_num_instances[replacement * service_life:]]\r\n\r\n    return acc_num_instances\r\n\r\n\r\ndef _get_num_replacements(period_of_analysis, service_life):\r\n    \"\"\"\r\n    Calculates the number of material replacements\r\n    :param period_of_analysis: the period of built_assets in years\r\n    :param service_life: the service_life in years\r\n    :return: an integer, representing the number of replacements\r\n    \"\"\"\r\n    if service_life >= period_of_analysis:\r\n        return 0\r\n    else:\r\n        if period_of_analysis % service_life == 0:\r\n            return period_of_analysis // service_life - 1\r\n        else:\r\n            return period_of_analysis // service_life\r\n\r\n\r\ndef print_csv(report_name, folder_location, period_of_analysis, analysis, epic_assemblies):\r\n    \"\"\"\r\n    Print a csv report based on an EPiCAnalysis component\r\n    :param report_name: Name of report to generate\r\n    :param folder_location: Folder location pathway\r\n    :param period_of_analysis: The period of built_assets for the life cycle assessment report\r\n    :param analysis: EPiCAnalysis objects that are used for the csv report\r\n    :param epic_assemblies: EPiCAssembly objects that are used for the csv report\r\n    \"\"\"\r\n\r\n    message = \"FAILED TO WRITE CSV. Folder location:\" + folder_location\r\n    report_name = remove_commas_and_flatten_list_for_csv_export(report_name, list_separator='_',\r\n                                                                remove_spaces=True) \\\r\n        if report_name else 'EPiC Assembly'\r\n    if not folder_location:\r\n        raise ValueError('No folder location provided')\r\n\r\n    counter = 1\r\n\r\n    filepath = os.path.join(folder_location, report_name + '.csv')\r\n\r\n    # Check if the file already exists. If so, rename. Maximum of 50 versions\r\n    if os.path.exists(filepath):\r\n        while os.path.exists(filepath) and counter < 50:\r\n            counter += 1\r\n            filepath = os.path.join(folder_location, report_name + '_' + str(counter) + '.csv')\r\n\r\n    # Separate epic assemblies and built assets\r\n    epic_built_assets = [x for x in epic_assemblies if x and x.component_type == 'EPiCBuiltAsset'\r\n                         or x.component_type == 'EPiCAnalysis']\r\n    epic_assemblies = [x for x in epic_assemblies if x and x.component_type == 'EPiCAssembly']\r\n\r\n    with open(filepath, 'wb') as csv:\r\n        _write_report_details_to_csv(csv, period_of_analysis, report_name)\r\n        _write_flow_values_to_csv(analysis, csv)\r\n\r\n        if len(epic_built_assets) > 0:\r\n            _write_built_asset_flow_values_to_csv(epic_built_assets, csv)\r\n\r\n        if len(epic_assemblies) > 0:\r\n            _write_assembly_flow_info_to_csv(csv)\r\n            _write_assembly_flows_to_csv(epic_assemblies, csv)\r\n\r\n        _write_boq_to_csv(csv, analysis)\r\n        message = \"Successfully printed to .csv file: \" + filepath\r\n    return message\r\n\r\n\r\ndef _write_report_details_to_csv(csv, period_of_analysis, report_name):\r\n    \"\"\"\r\n    Write report details to .csv file.\r\n    :param csv: The csv file to write to\r\n    :param period_of_analysis: Period of analysis for the report in years\r\n    :param report_name: Name of the report (EPiCAnalysis name)\r\n    \"\"\"\r\n    # csv.write('                                                 @@@@                          \\n')\r\n    # csv.write(' /////////////////      ///////////////         @@@@@@          ////////////   \\n')\r\n    # csv.write(' /////////////////      //////////////////       @@@@        ///////////////// \\n')\r\n    # csv.write(' /////                  /////         /////                 /////              \\n')\r\n    # csv.write(' /////                  /////          ////     /////      /////               \\n')\r\n    # csv.write(' /////                  /////         /////     /////     /////                \\n')\r\n    # csv.write(' ///////////////        /////     ////////      /////     /////                \\n')\r\n    # csv.write(' /////                  ////////////////        /////     //////               \\n')\r\n    # csv.write(' /////                  /////                   /////      /////               \\n')\r\n    # csv.write(' /////                  /////                   /////       /////              \\n')\r\n    # csv.write(' /////////////////      /////                   /////        ///////////////// \\n')\r\n    # csv.write(' /////////////////      /////                   /////           ////////////   \\n')\r\n    # csv.write('\\n')\r\n    csv.write(\r\n        'This is a report generated by EPiC Grasshopper: A plugin for analysing hybrid embodied environmental flows')\r\n    csv.write('\\nReport date: ' + datetime.datetime.now().strftime(\"%d %B %Y\"))\r\n    csv.write('\\nTime: ' + datetime.datetime.now().strftime(\"%H:%M\"))\r\n    csv.write('\\n\\nPlugin Version: ' + __version__)\r\n    csv.write('\\nEPiC Database Version: ' + epic_version)\r\n    csv.write('\\nThe authors disclaim any liability - in whole or in part - arising from information contained '\r\n              'in this report.'\r\n              '\\nThey do not take any responsibility for any action taken - decision-made - or result '\r\n              'associated with use of this plugin'\r\n              '\\n*Default service life and wastage coefficients are indicative only and can vary substantially.'\r\n              '\\nFurther information about the EPiC Database and EPiC Grasshopper can be found at: '\r\n              '<http://www.epicdatabase.com.au/> '\r\n              '\\nTo download a full copy of the database - goto <http://doi.org/10.26188/5dc228ef98c5a>'\r\n              '\\n_______________________________________________________________________________________')\r\n    csv.write('\\n\\n' + report_name)\r\n    csv.write('\\nPeriod of Analysis: {} years \\n'.format(period_of_analysis))\r\n    csv.write('\\n')\r\n\r\n\r\ndef _write_flow_values_to_csv(analysis, csv):\r\n    \"\"\"\r\n    Write to a .csv file. Include the total flow values for the analysis object, all assemblies and built asset objects\r\n    :param analysis: EPiCAnalysis class object for calculations\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n\r\n    # Life Cycle Total = lc\r\n    lc_energy = analysis.flows['life_cycle']['energy']\r\n    lc_water = analysis.flows['life_cycle']['water']\r\n    lc_ghg = analysis.flows['life_cycle']['ghg']\r\n\r\n    # Total Initial (excl. wastage) = i\r\n    i_energy = analysis.flows['initial']['energy'] - analysis.flows['initial_wastage']['energy']\r\n    i_water = analysis.flows['initial']['water'] - analysis.flows['initial_wastage']['water']\r\n    i_ghg = analysis.flows['initial']['ghg'] - analysis.flows['initial_wastage']['ghg']\r\n\r\n    # Initial Wastage = iw\r\n    iw_energy = analysis.flows['initial_wastage']['energy']\r\n    iw_water = analysis.flows['initial_wastage']['water']\r\n    iw_ghg = analysis.flows['initial_wastage']['ghg']\r\n\r\n    # Total Recurrent (excl. wastage) = r\r\n    r_energy = analysis.flows['recurrent']['energy'] - analysis.flows['recurrent_wastage']['energy']\r\n    r_water = analysis.flows['recurrent']['water'] - analysis.flows['recurrent_wastage']['water']\r\n    r_ghg = analysis.flows['recurrent']['ghg'] - analysis.flows['recurrent_wastage']['ghg']\r\n\r\n    # Total Recurrent Wastage = rw\r\n    rw_energy = analysis.flows['recurrent_wastage']['energy']\r\n    rw_water = analysis.flows['recurrent_wastage']['water']\r\n    rw_ghg = analysis.flows['recurrent_wastage']['ghg']\r\n\r\n    # Write Values to csv\r\n    csv.write('{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)'))\r\n    csv.write('{},{},{},{},{}\\n'.format('Life Cycle Total', lc_energy, lc_water, lc_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>> Total Initial (excl. wastage)', i_energy, i_water, i_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>>>> Total Initial Wastage', iw_energy, iw_water, iw_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>> Total Recurrent (excl. wastage)', r_energy, r_water, r_ghg, ''))\r\n    csv.write('{},{},{},{},{}\\n'.format('>>>> Total Recurrent Wastage', rw_energy, rw_water, rw_ghg, ''))\r\n    csv.write('\\n\\n')\r\n\r\n\r\ndef _write_built_asset_flow_values_to_csv(built_assets, csv):\r\n    \"\"\"\r\n    Write to a .csv file. For each build asset object, write a new section listing all of the flow values.\r\n    :param built_assets: EPiCBuiltAsset items to include in the analysis\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    csv.write('*** BREAKDOWN BY BUILT ASSET ***\\n\\n')\r\n    csv.write('{},{},{},{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)',\r\n                                              'Qty', 'Functional Unit', 'Comments'))\r\n\r\n    for built_asset in built_assets:\r\n        built_asset_name = '<<-' + built_asset.name.replace(\",\", \".\") + '->>'\r\n        csv.write('\\n')\r\n        if built_asset.comments:\r\n            csv.write('{},{},{},{},{},{},{}\\n'.format(built_asset_name, '', '', '', '',\r\n                                                      '', built_asset.comments.replace(\",\", \".\")))\r\n        else:\r\n            csv.write(built_asset_name)\r\n\r\n        csv.write('\\n')\r\n        _write_assembly_flows_to_csv(built_asset.epic_assemblies, csv)\r\n\r\n\r\ndef _write_assembly_flow_info_to_csv(csv):\r\n    \"\"\"\r\n    Write to a .csv file. The title for the assembly section, and all column headings.\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    csv.write('*** BREAKDOWN BY ASSEMBLIES ***\\n\\n')\r\n    csv.write('{},{},{},{},{},{},{}\\n'.format('', 'Total Energy (MJ)', 'Total Water (L)', 'Total GHG (kgCO2e)',\r\n                                              'Qty', 'Functional Unit', 'Comments'))\r\n\r\n\r\ndef _write_assembly_flows_to_csv(assemblies, csv):\r\n    \"\"\"\r\n    Write to a .csv file. For each assembly item, write a new section listing all of the flow values, by material.\r\n    :param assemblies: EPiCAssembly items to include in the analysis\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    for assembly in assemblies:\r\n        if not assembly.comments:\r\n            assembly.comments = ' '\r\n        if len(assembly.selected_geometry) > 0 and assembly.total_units > 0:\r\n            if assembly.category == assembly.name: # no category has been defined\r\n                built_asset_name = \"<{} ({} {})>\".format(assembly.name.replace(\",\", \".\"),\r\n                                                                      str(assembly.total_units),\r\n                                                                      str(assembly.assembly_units))\r\n            else:\r\n                built_asset_name = \"<{} | Category: {} ({} {})>\".format(assembly.name.replace(\",\", \".\"),\r\n                                                                      assembly.category.replace(\",\", \".\"),\r\n                                                                      str(assembly.total_units),\r\n                                                                      str(assembly.assembly_units))\r\n\r\n            csv.write('{},{},{},{},{},{},{}\\n'.format(built_asset_name, '', '', '', '', '',\r\n                                                      assembly.comments.replace(\",\", \".\")))\r\n            for mat in assembly.recalculated_flows['by_material'].values():\r\n                csv.write('{},{},{},{},{},{},{}\\n'.format(mat['material_name'].replace(\",\", \".\").encode('utf-8'),\r\n                                                          '', '', '', (mat['quantity'] * assembly.total_units),\r\n                                                          mat['material_object'].functional_unit,\r\n                                                          mat['material_object'].comments))\r\n                csv.write('{},{},{},{},{}\\n'.format('>> Initial (excl. wastage)', mat['initial']['energy']\r\n                                                    - mat['initial_wastage']['energy'], mat['initial']['water']\r\n                                                    - mat['initial_wastage']['water'], mat['initial']['ghg']\r\n                                                    - mat['initial_wastage']['ghg'], ''))\r\n\r\n                if mat['initial_wastage']['energy'] > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>>>> Initial Wastage (' + str(\r\n                        (mat['initial_wastage']['energy'] * 100) / mat['initial']['energy']) + '%)',\r\n                                                        mat['initial_wastage']['energy'],\r\n                                                        mat['initial_wastage']['water'],\r\n                                                        mat['initial_wastage']['ghg'],\r\n                                                        ''))\r\n\r\n                if (mat['recurrent']['energy']) > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>> Recurrent (excl. wastage)',\r\n                                                        mat['recurrent']['energy']\r\n                                                        - mat['recurrent_wastage']['energy'],\r\n                                                        mat['recurrent']['water']\r\n                                                        - mat['recurrent_wastage']['water'],\r\n                                                        mat['recurrent']['ghg']\r\n                                                        - mat['recurrent_wastage']['ghg'], ''))\r\n\r\n                if (mat['recurrent_wastage']['energy']) > 0:\r\n                    csv.write('{},{},{},{},{}\\n'.format('>>>> Recurrent Wastage',\r\n                                                        mat['recurrent_wastage']['energy'],\r\n                                                        mat['recurrent_wastage']['water'],\r\n                                                        mat['recurrent_wastage']['ghg'], ''))\r\n            csv.write('\\n')\r\n\r\n\r\ndef _write_boq_to_csv(csv, analysis):\r\n    \"\"\"\r\n    Write to a .csv file. Sum the total quantity for each material in all of the assemblies and built assets,\r\n    :param analysis: :param analysis: EPiCAnalysis class object for calculations\r\n    :param csv: The csv file to write to\r\n    \"\"\"\r\n    boq = {}\r\n    for mat in analysis.epic_materials:\r\n        if str(mat[0].name) not in boq:\r\n            boq[mat[0].name] = {'units': mat[0].functional_unit,\r\n                                'total_units': mat[1]}\r\n        else:\r\n            boq[mat[0].name]['total_units'] += mat[1]\r\n\r\n    csv.write('*** MATERIAL BOQ *** \\n\\n')\r\n    csv.write('Material Name, Qty, Units \\n')\r\n    for x in boq:\r\n        csv.write(\r\n            '{}, {}, {} \\n'.format(x.replace(\",\", \".\").encode('utf-8'), boq[x]['total_units'],\r\n                                   boq[x]['units']))\r\n\r\n\r\nclass EPiCVisualisations:\r\n    \"\"\"\r\n    Custom geometry to be visualised in Grasshopper. This class stores all visualisation classes.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    class GraphSegmentGeometry(ghKernel.Types.GH_GeometricGoo[Geometry.Rectangle3d],\r\n                               ghKernel.IGH_BakeAwareData, ghKernel.IGH_PreviewData):\r\n        def __init__(self, rect, fill_colour=COLOURS['light_teal'], outline_colour=COLOURS['dark_grey'],\r\n                     outline_thickness=1, show_hatch=False):\r\n            \"\"\"\r\n            A custom coloured rectangle that represents a graph segment within EPiCGraphColumn.\r\n            This class overrides DrawViewportWires and DrawViewportMeshes\r\n            :param rect: A Rhino 3D Rectangle Object to be used as a base object\r\n            \"\"\"\r\n\r\n            # Set the initial attributes\r\n            self.m_value = rect\r\n            self.fill_colour = fill_colour\r\n            self.outline_colour = outline_colour\r\n            self.outline_thickness = outline_thickness\r\n            self.show_hatch = show_hatch\r\n\r\n            # Create a fill and outline for the rectangle\r\n            self.poly_line = self.m_value.ToPolyline()\r\n            self.fill = Geometry.Hatch.Create(self.poly_line.ToPolylineCurve(), 0, 0, 0, 0)\r\n            self.fill = self.fill[0]\r\n\r\n        # region properties for grasshopper.\r\n        def get_TypeName(self):\r\n            return \"Graph Segment\"\r\n\r\n        def get_TypeDescription(self):\r\n            return \"Graph Segment\"\r\n\r\n        def ToString(self):\r\n            if self.m_value is None: return \"<null>\"\r\n            return 'Graph Segment'\r\n\r\n        def get_Boundingbox(self):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            return self.m_value.BoundingBox\r\n\r\n        def GetBoundingBox(self, xform):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            box = self.m_value.BoundingBox\r\n            corners = xform.TransformList(box.GetCorners())\r\n            return Geometry.BoundingBox(corners)\r\n\r\n        # region methods for grasshopper.\r\n        def DuplicateGeometry(self):\r\n            new_geometry = EPiCVisualisations.GraphSegmentGeometry(self.m_value)\r\n            new_geometry.fill_colour = self.fill_colour\r\n            new_geometry.outline_colour = self.outline_colour\r\n            new_geometry.outline_thickness = self.outline_thickness\r\n            new_geometry.show_hatch = self.show_hatch\r\n            return new_geometry\r\n\r\n        def Transform(self, xform):\r\n            rect = self.m_value\r\n            if rect is None: return EPiCVisualisations.GraphSegmentGeometry(None)\r\n\r\n            plane = rect.Plane\r\n            point = plane.PointAt(1, 1)\r\n\r\n            plane.Transform(xform)\r\n            point.Transform(xform)\r\n            dd = point.DistanceTo(plane.Origin)\r\n\r\n            new_geometry = EPiCVisualisations.GraphSegmentGeometry(\r\n                Geometry.Rectangle3d(plane, rect.Width * dd / sqrt(2), rect.Height * dd / sqrt(2)))\r\n            new_geometry.fill_colour = self.fill_colour\r\n            new_geometry.outline_colour = self.outline_colour\r\n            new_geometry.outline_thickness = self.outline_thickness\r\n            new_geometry.show_hatch = self.show_hatch\r\n            return new_geometry\r\n\r\n        def Morph(self, xmorph):\r\n            return self.DuplicateGeometry()\r\n\r\n        # region preview properties for grasshopper.\r\n        def get_ClippingBox(self):\r\n            return self.get_Boundingbox()\r\n\r\n        def DrawViewportWires(self, args):\r\n            args.Pipeline.DrawBox(self.m_value.BoundingBox, self.outline_colour, self.outline_thickness)\r\n            if self.show_hatch:\r\n                corners = self.m_value.BoundingBox.GetCorners()\r\n                args.Pipeline.DrawLine(Geometry.Line(Geometry.Point3d(corners[0]), Geometry.Point3d(corners[2])),\r\n                                       self.outline_colour)\r\n                args.Pipeline.DrawLine(Geometry.Line(Geometry.Point3d(corners[1]), Geometry.Point3d(corners[3])),\r\n                                       self.outline_colour)\r\n\r\n        def DrawViewportMeshes(self, args):\r\n            args.Pipeline.DrawHatch(self.fill, self.fill_colour, Color.Transparent)\r\n\r\n        # region baking for grasshopper.\r\n        def BakeGeometry(self, doc, att, id):\r\n            id = Guid.Empty\r\n            if self.m_value is None:\r\n                return False, id\r\n\r\n            if att is None:\r\n                att = doc.CreateDefaultAttributes()\r\n            att.ObjectColor = self.fill_colour\r\n            doc.Objects.AddRectangle(self.m_value, att)\r\n            hatch_att = doc.CreateDefaultAttributes()\r\n            hatch_att.ObjectColor = self.fill_colour\r\n            doc.Objects.AddHatch(self.fill, hatch_att)\r\n            id = doc.Objects\r\n\r\n            return True, id\r\n\r\n    @staticmethod\r\n    def bakeable_text_from_str(text, text_size=1.0, text_location=(0, 0, 0), bold=False, italic=False, font='Arial',\r\n                               text_rotation=0,\r\n                               align_right=False, align_top=False):\r\n        \"\"\"\r\n        Create bakeable text objects from string inputs\r\n        :param text: Input string\r\n        :param text_size: Size of the text, measured in Rhino units\r\n        :param text_location: Location for the text. Defaults to (0,0,0)\r\n        :param bold: If True, then the text will be bold\r\n        :param italic: If True, then the text will be italic\r\n        :param font: Font to use (default is Arial)\r\n        :param text_rotation: Rotation angle for the text (in degrees)\r\n        :param align_right: If True, then the text will be aligned to the right\r\n        :param align_top: If True, then the text will be aligned to the top\r\n        :return: EPiCText class object that can be visualised and baked from grasshopper\r\n        \"\"\"\r\n\r\n        # Create a base plane for the text\r\n        point = rs.AddPoint(*text_location)\r\n        point2 = rs.AddPoint(10, 0, 0)\r\n        point3 = rs.AddPoint(0, 10, 0)\r\n        plane = rs.CreatePlane(point, point2, point3)\r\n\r\n        # Rotate the text\r\n        if text_rotation:\r\n            plane = rs.RotatePlane(plane, text_rotation, plane.ZAxis)\r\n\r\n        # Check if text input is a string, and convert to a Text3D object\r\n        if isinstance(text, str):\r\n            text = Display.Text3d(text, plane, text_size)\r\n        elif isinstance(text, Display.Text3d):\r\n            pass\r\n        else:\r\n            raise TypeError(\"bakeable_text_from_str: text input must be string or Text3D\")\r\n\r\n        if align_right:\r\n            text_bounds_length = EPiCVisualisations.EPiCText(text).get_Boundingbox().GetEdges()[0].Length\r\n            plane = rs.MovePlane(plane, (text_location[0] - text_bounds_length, text_location[1], text_location[2]))\r\n            text = Display.Text3d(text.Text, plane, text_size)\r\n\r\n        if align_top:\r\n            text_bounds_length = EPiCVisualisations.EPiCText(text).get_Boundingbox().GetEdges()[1].Length\r\n            plane = rs.MovePlane(plane, (text_location[0], text_location[1] - text_bounds_length, text_location[2]))\r\n            text = Display.Text3d(text.Text, plane, text_size)\r\n\r\n        text.Bold = bold\r\n        text.Italic = italic\r\n        text.FontFace = font\r\n\r\n        return EPiCVisualisations.EPiCText(text)\r\n\r\n    class EPiCText(ghKernel.Types.GH_GeometricGoo[Display.Text3d],\r\n                   ghKernel.IGH_BakeAwareData,\r\n                   ghKernel.IGH_PreviewData):\r\n\r\n        \"\"\"A Text object that can be baked and transformed in Grasshopper.\r\n        The majority of the code for this class was taken from David Rutten and Giulio Piacentino's\r\n        script described here:\r\n        https://discourse.mcneel.com/t/creating-text-objects-and-outputting-them-as-normal-rhino-geometry/47834/7\"\"\"\r\n\r\n        # region construction\r\n        def __init__(self, text):\r\n            self.m_value = text\r\n\r\n        @staticmethod\r\n        def DuplicateText3d(original):\r\n            if original is None: return None\r\n            text = Display.Text3d(original.Text, original.TextPlane, original.Height)\r\n            text.Bold = original.Bold\r\n            text.Italic = original.Italic\r\n            text.FontFace = original.FontFace\r\n            return text\r\n\r\n        def DuplicateGeometry(self):\r\n            return EPiCVisualisations.EPiCText(EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value))\r\n\r\n        # region properties\r\n        def get_TypeName(self):\r\n            return \"3D Text\"\r\n\r\n        def get_TypeDescription(self):\r\n            return \"3D Text\"\r\n\r\n        def ToString(self):\r\n            if self.m_value is None: return \"<null>\"\r\n            return self.m_value.Text\r\n\r\n        def get_Boundingbox(self):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty;\r\n            return self.m_value.BoundingBox;\r\n\r\n        def GetBoundingBox(self, xform):\r\n            if self.m_value is None:\r\n                return Geometry.BoundingBox.Empty\r\n            box = self.m_value.BoundingBox\r\n            corners = xform.TransformList(box.GetCorners())\r\n            return Geometry.BoundingBox(corners)\r\n\r\n        # region methods\r\n        def Transform(self, xform):\r\n            text = EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value)\r\n            text = EPiCVisualisations.EPiCText.DuplicateText3d(self.m_value)\r\n            if text is None: return EPiCVisualisations.EPiCText(None)\r\n            plane = text.TextPlane\r\n            point = plane.PointAt(1, 1)\r\n\r\n            plane.Transform(xform)\r\n            point.Transform(xform)\r\n            dd = point.DistanceTo(plane.Origin)\r\n\r\n            text.TextPlane = plane\r\n            text.Height *= dd / sqrt(2)\r\n            return EPiCVisualisations.EPiCText(text)\r\n\r\n        def Morph(self, xmorph):\r\n            return self.DuplicateGeometry()\r\n\r\n        # region preview\r\n        def get_ClippingBox(self):\r\n            return self.get_Boundingbox()\r\n\r\n        def DrawViewportWires(self, args):\r\n            if self.m_value is None: return\r\n            args.Pipeline.Draw3dText(self.m_value, args.Color)\r\n\r\n        def DrawViewportMeshes(self, args):\r\n            # Do not draw in meshing layer.\r\n            pass\r\n\r\n        # region baking\r\n        def BakeGeometry(self, doc, att, id):\r\n            id = Guid.Empty\r\n\r\n            if self.m_value is None:\r\n                return False, id\r\n\r\n            if att is None:\r\n                att = doc.CreateDefaultAttributes()\r\n\r\n            id = doc.Objects.AddText(self.m_value, att)\r\n\r\n            return True, id\r\n\r\n\r\nclass EPiCMaterial:\r\n    \"\"\"\r\n    A class object that represents a single material from the EPiC Database\r\n    \"\"\"\r\n    FUNCTIONAL_UNIT_SEP = '|'\r\n\r\n    def __init__(self, name=str, energy=float, water=float, ghg=float, functional_unit=str, doi=str, category=str,\r\n                 material_id=str, wastage=float, service_life=float, comments=str, density=float, process_shares=dict):\r\n        \"\"\"\r\n        A material class object that can be passed to EPiCAssemblies and EPiCBuiltAssets\r\n        :param name: Name of the material\r\n        :param energy: Energy coefficient in MJ/Functional Unit\r\n        :param water: Water coefficient in L/Functional Unit\r\n        :param ghg: Greenhouse gas emissions coefficient in kgCO₂e/Functional Unit\r\n        :param functional_unit: Functional unit for the material (e.g. kg, no., m, m², m³)\r\n        :param doi: A link to the material information sheet in the EPiC Database\r\n        :param category: Material category\r\n        :param material_id: EPiCDatabase id for the material\r\n        :param wastage: Estimated wastage percentage (%) for the material.\r\n        :param service_life: Estimated service life for the material.\r\n        :param comments: Material comments - these will be displayed in any reports\r\n        :param density: Material density\r\n        :param process_shares: A dictionary with flows as keys and the process data share of the hybrid coefficient as a value\r\n        \"\"\"\r\n\r\n        self.component_type = 'EPiCMaterial'\r\n\r\n        try:\r\n            self.name = name\r\n            self.functional_unit = functional_unit\r\n            self.category = category\r\n            self.doi = doi\r\n            self.energy = energy\r\n            self.water = water\r\n            self.ghg = ghg\r\n            self.density = density\r\n            self.wastage = wastage / 100 if wastage else 0\r\n            self.service_life = service_life\r\n            self.process_shares = process_shares\r\n            self.id = random.getrandbits(128)\r\n            self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n            self.material_id = material_id\r\n\r\n        except TypeError:\r\n            raise TypeError(\"Couldn't load material attributes...\")\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_to_str=True)\r\n\r\n    @staticmethod\r\n    def remove_func_unit_from_mat_name(mat_name_and_func_unit):\r\n        \"\"\"\r\n        Remove the functional unit between \"()\" after the | sign, and the space beforehand\r\n        :param mat_name_and_func_unit: the concatenated material name and its functional unit\r\n        :return: the material name cleaned up\r\n        \"\"\"\r\n        return mat_name_and_func_unit[:(mat_name_and_func_unit.index('|') - 1)]\r\n\r\n    @staticmethod\r\n    def _concatenate_mat_name_func_unit(mat_name, functional_unit):\r\n        \"\"\"\r\n        Adds the funtional unit to a material name\r\n        :param mat_name: a string represent an EPiC material name\r\n        :param functional_unit: a string representing the functional unit of the material\r\n        :return: a concatenated material_name and string\r\n        \"\"\"\r\n        return mat_name + ' ' + '|' + ' (' + functional_unit + ')'\r\n\r\n    def generate_breakdown_dict(self):\r\n        \"\"\"\r\n        Generates a dictionary that will be provided to EPiCBreakdown, as per the HYBRID_VALUE_BREAKDOWN_DICT template\r\n        :return: as dictionary representing the process and input-output shares of the hybrid value\r\n        \"\"\"\r\n        breakdown_dict = copy.deepcopy(HYBRID_VALUE_BREAKDOWN_DICT)\r\n\r\n        for flow in breakdown_dict.keys():\r\n            breakdown_dict[flow]['process'] = self.process_shares[flow]\r\n            breakdown_dict[flow]['io'] = 1 - self.process_shares[flow]\r\n\r\n        return breakdown_dict\r\n\r\n    @staticmethod\r\n    def generate_material_and_category_dropdown_list(component_object, ghenv, epic_db,\r\n                                                     category=\"Concrete and plaster products\"):\r\n        \"\"\"\r\n        Generate a material and category list for the EPiC_Material grasshopper component\r\n        :param component_object: Component object to modify\r\n        :param ghenv: The current grasshopper environment\r\n        :param epic_db: EPiCDatabase object to query\r\n        :param category: Default category to be used for initialising the valuelist\r\n        \"\"\"\r\n\r\n        # Check if input[1] has a value list connected, if not, create one\r\n        if component_object.Params.Input[1].SourceCount == 0:\r\n            make_value_list_input_component(1, EPIC_CATEGORIES, ghenv, xloc=-230, yloc=0)\r\n\r\n        # Check if input[2] has a value list connected, if not, create one, but only if input[1] is connected.\r\n        if component_object.Params.Input[1].SourceCount == 1 and component_object.Params.Input[2].SourceCount == 0:\r\n\r\n            list_of_mat_values, list_of_mat_names = (zip(*sorted(epic_db.dict_of_categories[category].items())))\r\n\r\n            # Use the category created above (input[1]) to generate material list. Set the category to concrete.\r\n            make_value_list_input_component(2, list_of_mat_values, ghenv,\r\n                                            valuelist_names = list_of_mat_names, xloc=-365, yloc=0)\r\n            ghenv.Component.OnPingDocument().ScheduleSolution(5, ghenv.Component.ExpireSolution(True))\r\n\r\n    @staticmethod\r\n    def generate_slider_input(component_object, ghenv, slider_value, input_node, slider_min = 0, slider_max = 100):\r\n        \"\"\"\r\n        Generate a slider input attached to the current component object\r\n        :param component_object: Component object to modify\r\n        :param ghenv: The current grasshopper environment (not used)\r\n        :param slider_value: value to set for the slider\r\n        :param input_node: node number that the slider should be instantiated on\r\n        :param slider_min: minimum value for the slider\r\n        :param slider_max: maximum value for the slider\r\n        \"\"\"\r\n\r\n        # Check if input has a slider connected\r\n        if component_object.Params.Input[input_node].SourceCount == 0:\r\n\r\n            num_slider = EPiCMaterial.create_slider(component_object, input_node, slider_max, slider_min, slider_value)\r\n\r\n            # Connect slider to component\r\n            component_object.Params.Input[input_node].AddSource(num_slider)\r\n\r\n            # Expire the solution outside of current loop to refresh values\r\n            component_object.OnPingDocument().ScheduleSolution(1, component_object.ExpireSolution(False))\r\n\r\n            return str(num_slider.InstanceGuid)\r\n        else:\r\n            pass\r\n\r\n    @staticmethod\r\n    def create_slider(component_object, input_node, slider_max, slider_min, slider_value):\r\n        ghdoc = component_object.OnPingDocument()\r\n        num_slider = ghKernel.Special.GH_NumberSlider()\r\n        num_slider.Slider.Minimum = slider_min\r\n        # Check if the proposed slider value is more than the slider max value. If so, increase the max value.\r\n        if slider_value > slider_max:\r\n            num_slider.Slider.Maximum = slider_value\r\n        else:\r\n            num_slider.Slider.Maximum = slider_max\r\n        num_slider.Slider.DecimalPlaces = 0\r\n        num_slider.SetSliderValue(slider_value)\r\n        num_slider.CreateAttributes()\r\n        num_slider.Attributes.Pivot = Drawing.PointF(component_object.Params.Input[input_node].Attributes.Bounds.X\r\n                                                     - num_slider.Attributes.Bounds.Width * 2,\r\n                                                     component_object.Params.Input[input_node].Attributes.Bounds.Y)\r\n        ghdoc.AddObject(num_slider, False)\r\n        return num_slider\r\n\r\n    @staticmethod\r\n    def recreate_material_list(epic_db, ghObject, material_category, component, set_material=None):\r\n        \"\"\"\r\n        Recreate the material list based on the currently selected material category\r\n        :param epic_db: EPiCDatabase object\r\n        :param ghObject: Grasshopper component\r\n        :param material_category: Currently selected material category\r\n        :param Params: The component parameters, this is needed to recreate the input values\r\n        :pamam set_material: Specify the chosen material for the new list\r\n        \"\"\"\r\n\r\n        # Create a sticky that makes sure itemlist won't continuously load\r\n        if not \"is_running\" in st.keys():\r\n            st[\"is_running\"] = False\r\n\r\n        # Check if the sticky is 0 (and therefore the list isn't in the middle of initialising)\r\n        if st[\"is_running\"] == False:\r\n            try:\r\n                # set the running to true at the start of the function, indicating that it is in progress\r\n                st[\"is_running\"] = True\r\n                new_list = zip(*sorted(epic_db.dict_of_categories[material_category].items()))\r\n                ghObject.ListItems.Clear()\r\n                selected_material = 0\r\n                list_number = 0\r\n                for id, name in zip(new_list[0], new_list[1]):\r\n                    _ = ghObject.ListItems.Add(ghKernel.Special.GH_ValueListItem(str(name), '\"' + str(id) + '\"'))\r\n                    if set_material and set_material == id:\r\n                        selected_material = list_number\r\n                    list_number += 1\r\n\r\n                # Select the chosen material\r\n                if selected_material:\r\n                    ghObject.SelectItem(selected_material)\r\n\r\n                # Expire the current solution\r\n                component.OnPingDocument().ScheduleSolution(5, ghObject.ExpireSolution(True))\r\n                st[\"is_running\"] = False\r\n            except:\r\n                # If the list loading fails, global running value will be reset\r\n                st[\"is_running\"] = False\r\n\r\n\r\n    def print_report(self, print_to_str=False, custom_material=False):\r\n        \"\"\"\r\n        Print a report, based on the material coefficient values and material attributes\r\n        :param print_to_str: Print to string should be marked as true when outputting as a string, otherwise a list\r\n        :param custom_material: switch to true to omit printing the DOI as a custom material won't have one\r\n        :return: string(print_to_str=True) or list\r\n        \"\"\"\r\n\r\n        results = []\r\n        results.append('<< {} >>'.format(self.name))\r\n        results.append('Category: {}'.format(self.category))\r\n        results.append('Functional Unit: {}'.format(self.functional_unit))\r\n        results.append('')\r\n        results.append('Embodied Energy Coefficient: {} MJ/{}'.format(self.energy, self.functional_unit))\r\n        results.append('Embodied Water Coefficient: {} L/{}'.format(self.water, self.functional_unit))\r\n        results.append('Embodied GHG Coefficient: {} kgCO₂e/{}'.format(self.ghg, self.functional_unit))\r\n\r\n        # Only include wastage / service life in the report if values exist\r\n        if self.wastage > 0 or self.service_life > 0:\r\n            results.append('')\r\n            if self.wastage > 0:\r\n                results.append('Wastage: {}%'.format(self.wastage * 100))\r\n            if self.service_life > 0:\r\n                results.append('Service Life: {} years'.format(self.service_life))\r\n\r\n        results.append('')\r\n        if not custom_material:\r\n            results.append('DOI: {}'.format(self.doi))\r\n            results.append('')\r\n            results.append('Process-based data proportion of hybrid value')\r\n            for flow_properties in DEFINED_FLOWS.values():\r\n                results.append(flow_properties['print_name'] + ': {:.0%}'.format(\r\n                    self.process_shares[flow_properties['code_name']]))\r\n\r\n        return results if not print_to_str else '\\n'.join(results)\r\n\r\n\r\nclass CustomMaterial(EPiCMaterial):\r\n    \"\"\"\r\n    A class object that represents a single custom material, based on the EPiCMaterial template\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        EPiCMaterial.__init__(self, *args, **kwargs)\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_to_str=True, custom_material=True)\r\n\r\n\r\nclass EPiCGraph:\r\n    \"\"\"\r\n    Enables the visualisation of EPiC_Analysis, using data from associated EPiC_Assembly & EPiC_Material classes\r\n    \"\"\"\r\n\r\n    seg_pref_template = OrderedDict([\r\n        ('initial', {'flow_type': ['initial', 'initial_wastage'], 'colour': 'colour',\r\n                     'label': 'Initial', 'hatch_type': 0, 'hatch_scale': 0.5,\r\n                     'hatch_angle': 45}),\r\n        ('initial_wastage', {'flow_type': 'initial_wastage', 'colour': 'colour',\r\n                             'label': 'Initial wastage', 'hatch_type': 1, 'hatch_scale': 1,\r\n                             'hatch_angle': 135}),\r\n        ('recurrent', {'flow_type': ['recurrent', 'recurrent_wastage'],\r\n                       'colour': 'secondary_colour', 'label': 'Recurrent', 'hatch_type': 0,\r\n                       'hatch_scale': 0.5, 'hatch_angle': 45}),\r\n        ('recurrent_wastage', {'flow_type': 'recurrent_wastage',\r\n                               'colour': 'secondary_colour', 'label': 'Recurrent wastage',\r\n                               'hatch_type': 1, 'hatch_scale': 1, 'hatch_angle': 135}),\r\n        ('life_cycle', {'flow_type': ['life_cycle', 'life_cycle_wastage'],\r\n                        'colour': 'colour', 'label': 'Life cycle', 'hatch_type': 0,\r\n                        'hatch_scale': 0.5, 'hatch_angle': 45}),\r\n        ('life_cycle_wastage', {'flow_type': 'life_cycle_wastage', 'colour': 'colour',\r\n                                'label': 'Life cycle wastage', 'hatch_type': 1,\r\n                                'hatch_scale': 1, 'hatch_angle': 135})])\r\n\r\n    def __init__(self, data, graph_origin=(0, 0, 0), graph_height=10., graph_spacing=1., graph_width=1.,\r\n                 graph_padding=6, analysis_type='by_material', graph_subset_2=None, show_recurrent=True,\r\n                 flows=('energy', 'water', 'ghg'), sort_graph=True, graph_scale=1, column_width=0.7,\r\n                 column_padding=0.2, space_between_graphs=5, hide_null_columns=True, minimum_spacing_for_graph=3,\r\n                 text_size=0.3, heading_text_size=0.8, axis_label_text_size=0.65, tick_size=0.2, text_padding=0.3,\r\n                 legend_box_size=0.5):\r\n\r\n        # Set all instance attributes based on inputs\r\n        vars = locals()  # dict of local names\r\n        self.__dict__.update(vars)  # __dict__ holds and object's attributes\r\n        del self.__dict__[\"self\"]  # don't need `self`\r\n\r\n        # Make sure origin is either a tuple or Rhino Point3d object.\r\n        # If origin is a tuple, convert to Point3d Object.\r\n        if isinstance(graph_origin, tuple):\r\n            self.origin = Geometry.Point3d(graph_origin[0], graph_origin[1], graph_origin[2])\r\n        elif isinstance(graph_origin, (Geometry.Point, Geometry.Point3d)):\r\n            self.origin = graph_origin\r\n        else:\r\n            TypeError('The origin_point should be a tuple, eg (0,0,0) or a 3dPoint value')\r\n\r\n        # only allow 'by_material' and 'analysis_type' as input for analysis_type.\r\n        # All other values will default to 'total' (analysis_type = None)\r\n        if 'by_material' not in analysis_type and 'by_assembly' not in analysis_type:\r\n            analysis_type = None\r\n        self.analysis_type = analysis_type\r\n\r\n        # Make sure data input is in list format\r\n        if not isinstance(data, list):\r\n            data = [data]\r\n        self.data = data\r\n\r\n        # Number of comparison values for the graph\r\n        self.num_comparisons = len(data)\r\n\r\n        # Cycle through all of the materials to branch_count the number of unique materials\r\n        _all_materials = _flatten_list([y.epic_materials for x in self.data for y in x.epic_assemblies])\r\n        self.number_of_materials = len(set([x for x in _all_materials if not isinstance(x, (float, int))]))\r\n\r\n        # Cycle through all of the assemblies to branch_count the number of unique assembly categories\r\n        self.number_assembly_cats = len(set(_flatten_list([x.epic_assemblies for x in self.data])))\r\n\r\n        # Set additional instance attributes\r\n        self.graph_subset_2_colours = {}\r\n\r\n        # Generate graphs\r\n        self.graph_data = self._create_bar_graph_for_each_flow(self.data, analysis_type=analysis_type,\r\n                                                               show_recurrent=show_recurrent)\r\n\r\n    @property\r\n    def elements_to_render(self):\r\n        \"\"\"\r\n        A list of graph elements (legend, text, columns) to visualise\r\n        :return: List of graph elements\r\n        \"\"\"\r\n        graph_elements = _flatten_list([graph.elements_to_render for graph in self.graph_data])\r\n\r\n\r\n        # Print error message if no values are found\r\n        if not graph_elements:\r\n            # Specific an offset value for the error message text.\r\n            graph_offset = (1, 5, 0)\r\n            text_origin = tuple(sum(x) for x in zip(self.graph_origin, graph_offset))\r\n            error_msg = \"No bar chart can be displayed.\\nIt is likely that all embodied flows have zero values.\"\\\r\n                        \"\\nOR there has been a calculation error.\\nCheck your assembly quantities.\"\r\n            graph_elements = EPiCVisualisations.bakeable_text_from_str(error_msg,\r\n                                                      text_size=self.heading_text_size,\r\n                                                      text_location=text_origin)\r\n\r\n        if self.graph_scale != 1:\r\n            graph_elements = self._scale_graph_elements(graph_elements)\r\n\r\n        return graph_elements\r\n\r\n    def _scale_graph_elements(self, graph_elements):\r\n        \"\"\"\r\n        Scale graph elements\r\n        :param graph_elements: Graph elements to scale\r\n        :return: Scaled graph elements\r\n        :rtype: list\r\n        \"\"\"\r\n        self.graph_scale = [self.graph_scale, self.graph_scale, 0]\r\n        scaled_elements = []\r\n        for graph_element in graph_elements:\r\n            if isinstance(graph_element, Geometry.Line):\r\n                transform = False\r\n                try:\r\n                    transform = graph_element.Transform(rs.XformScale(self.graph_scale, self.origin))\r\n                except:\r\n                    pass\r\n                if transform:\r\n                    scaled_elements.append(graph_element)\r\n\r\n            elif isinstance(graph_element, (EPiCVisualisations.EPiCText, EPiCVisualisations.GraphSegmentGeometry)):\r\n                try:\r\n                    scaled_elements.append(graph_element.Transform(rs.XformScale(self.graph_scale, self.origin)))\r\n                except:\r\n                    pass\r\n        return scaled_elements\r\n\r\n    def _create_bar_graph_for_each_flow(self, data, analysis_type=None, show_recurrent=True):\r\n        \"\"\"\r\n        Create a separate bar graph for each flow (energy, water and ghg)\r\n        :param data: Graph data\r\n        :param analysis_type: The type of built_assets to use for each graph (e.g. by_material, by_assembly, total)\r\n        :param show_recurrent: Show breakdown of recurrent values\r\n        :return: A list of epic.BarGraph object instances, one for each flow.\r\n        \"\"\"\r\n\r\n        list_of_graphs = []\r\n        graph_cumulative_width = 0\r\n        sub_group_data = None\r\n        graph_origin_point = Geometry.Point3d(self.origin.X, self.origin.Y, self.origin.Z)\r\n\r\n        # Change graph visualisation style depending if breakdown of recurrent values is shown\r\n        if show_recurrent:\r\n            list_of_keys = ['initial', 'initial_wastage', 'recurrent', 'recurrent_wastage']\r\n        else:\r\n            list_of_keys = ['life_cycle', 'life_cycle_wastage']\r\n\r\n        # Create a list of the stacked bar segments to be shown\r\n        self.segment_properties = OrderedDict((key, copy.deepcopy(value)) for (key, value)\r\n                                              in self.seg_pref_template.items() if key in list_of_keys)\r\n\r\n        # Multiple graph values can be included for comparison\r\n        for num, d in enumerate(data):\r\n            pass\r\n\r\n        # if the analysis_type is 'by_material' or 'by_assembly'\r\n        if analysis_type == 'by_material' or analysis_type == 'by_assembly':\r\n            if isinstance(data, list):\r\n                data = [d.flows[analysis_type] if analysis_type in d.flows else {d.name: d.flows} for d in data]\r\n\r\n        # if the analysis_type is 'by_assembly_and_material'\r\n\r\n        elif analysis_type == 'by_assembly_and_material':\r\n            if isinstance(data, list):\r\n                if len(data) > 1:\r\n                    sub_group_data = [\r\n                        (d.flows['by_assembly'], d.name) if 'by_assembly' in d.flows else {d.name: d.flows}\r\n                        for d in data]\r\n                data = [d.flows['by_assembly'] if 'by_assembly' in d.flows else {d.name: d.flows} for d in data]\r\n\r\n        # if the analysis_type is 'total'\r\n        else:\r\n            if isinstance(data, list):\r\n                data = [{'total': data.flows} for data in data]\r\n\r\n        # For each flow, create a new graph_origin point (based on the graph width + spacing)\r\n        for flow_num, flow in enumerate(self.flows):\r\n            # Set the graph_origin point\r\n            graph_origin_point.X += graph_cumulative_width\r\n\r\n            # Create a graph for each flow\r\n            epic_graph = EPiCGraph.BarGraph(data,\r\n                                            sub_group_data=sub_group_data,\r\n                                            graph_preferences=self,\r\n                                            origin=graph_origin_point,\r\n                                            name=flow,\r\n                                            flow=flow,\r\n                                            flow_units=DEFINED_FLOWS[flow]['unit'],\r\n                                            title=DEFINED_FLOWS[flow]['print_name'])\r\n            list_of_graphs.append(epic_graph)\r\n\r\n            # Move the graph_origin point for the next flow\r\n            graph_cumulative_width = self.graph_width\r\n\r\n        return list_of_graphs\r\n\r\n    class BarGraph:\r\n        def __init__(self, data, sub_group_data=None, graph_preferences=None, origin=Geometry.Point3d(0, 0, 0), name='',\r\n                     flow='', title='', flow_units=''):\r\n            \"\"\"\r\n            A bar graph based on an EPiCAnalysis class object\r\n            :param data: Flow data for each EPiCAnalysis input, if multiple inputs, these will be used as a comparison\r\n            :param graph_preferences: Graph preferences inherited from the EPiCGraph class instance\r\n            :param origin: Origin point for the bar graph\r\n            :param name: Name of the bar graph (environmental flow abbreviation)\r\n            :param flow: Enironmental flow type\r\n            :param title: Title of the bar graph (environmental flow)\r\n            :param flow_units: Flow units used for the bar graph\r\n            \"\"\"\r\n\r\n            self.data = data\r\n            self.sub_group_data = sub_group_data\r\n            self.graph_preferences = graph_preferences\r\n            self.origin = origin\r\n            self.name = name\r\n            self.flow = flow\r\n            self.title = title\r\n            self.flow_units = flow_units\r\n\r\n            # Set the graph origin plane based on the graph origin\r\n            if isinstance(origin, tuple):\r\n                self.origin = Geometry.Point3d(origin[0], origin[1], origin[2])\r\n            elif isinstance(origin, (Geometry.Point, Geometry.Point3d)):\r\n                self.origin = Geometry.Point3d(origin.X, origin.Y, origin.Z)\r\n            else:\r\n                TypeError('The origin_point should be a tuple, eg (0,0,0) or a 3dPoint value')\r\n            self.origin_plane = rs.MovePlane(rs.WorldXYPlane(), self.origin)\r\n\r\n            # Attributes used in graph creation process\r\n            self.max_data_value = 0\r\n            self.legend = None\r\n            self.columns = []\r\n            self.column_group_names = OrderedDict()\r\n            self.cumulative_column_spacing = 0\r\n\r\n            # Build the bar graph\r\n            self.build_graph()\r\n\r\n            # Create a list of all visualisation elements for the graph\r\n            self.elements_to_render = self._render_elements()\r\n\r\n        def _render_elements(self):\r\n            \"\"\"\r\n            Create a list of all visualisation elements for the graph.\r\n            These are taken from the individual graph segments and graph legend\r\n            :return: a flattened list of elements to render\r\n            :rtype: list\r\n            \"\"\"\r\n            _items_to_render = {'graph': [], 'legend': {}}\r\n            if self.legend:\r\n                _items_to_render['legend'] = [y for y in [x for x in self.legend.elements_to_render.values()]]\r\n            if self.segments:\r\n                _items_to_render['graph'] = [seg.elements_to_render for seg in self.segments]\r\n            return _flatten_list(_items_to_render['legend'] + _items_to_render['graph'])\r\n\r\n        @property\r\n        def segments(self):\r\n            \"\"\"\r\n            A list of segment items for the graph\r\n            :rtype: list\r\n            \"\"\"\r\n            segs = []\r\n            if self.columns:\r\n                for col in self.columns:\r\n                    segs += col.segments\r\n            return segs\r\n\r\n        def _get_max_values(self):\r\n            \"\"\"\r\n            Get the maximum life_cycle value for this flow.\r\n            This can be used to set the maximum y axis value for the graph\r\n            :return: Maximum life cycle value\r\n            :rtype: float\r\n            \"\"\"\r\n            for _data in self.data:\r\n                for _mat in _data.values():\r\n                    if 'life_cycle' in _mat:\r\n                        max_data_value = max([_mat['life_cycle'][self.flow]])\r\n                        self.max_data_value = max(max_data_value, self.max_data_value)\r\n            return self.max_data_value\r\n\r\n        def build_graph(self):\r\n            \"\"\"\r\n            Generate a new graph.\r\n            This will override graphs already created in this class instance\r\n            \"\"\"\r\n\r\n            self.cumulative_column_spacing = 0\r\n            column_origin_plane = self.origin_plane.Clone()\r\n\r\n            # Delete previous class instances\r\n            for _col in self.columns:\r\n                del _col\r\n            self.columns = []\r\n\r\n            # Get the unique names of each column (in both the original graph + comparison graphs)\r\n            # If the graph has more than one column, the following code will run\r\n            if self.graph_preferences.analysis_type:\r\n\r\n                all_keys = list(set([key for d in self.data for key in d.keys()]))\r\n                self.max_data_value = self._get_max_values()\r\n\r\n                # Populate dictionary with life cycle flow values, based on column keys\r\n                # Then rank the columns from highest life cycle value to lowest.\r\n                dictionary_of_column_flow_values = self._get_life_cycle_flow_values_for_column_keys(all_keys)\r\n                self.column_group_names = self._sort_dictionary_highest_to_lowest_value(\r\n                    dictionary_of_column_flow_values)\r\n\r\n            else:\r\n                if isinstance(self.data, list):\r\n                    for _ in self.data:\r\n                        self.column_group_names = {'Total': {'group_label_origin': None}}\r\n                        self.max_data_value = self._get_max_values()\r\n\r\n            # Create the column groups. Each group might multiple columns (comparison values)\r\n            for num, key in enumerate(self.column_group_names.keys()):\r\n                self._create_column_group(self.data, column_origin_plane, key, num, sub_group=self.sub_group_data)\r\n\r\n            # Delete previous class instances\r\n            del self.legend\r\n\r\n            # Create a legend for the graph\r\n            self.legend = EPiCGraph.BarGraphLegend(self, graph_preferences=self.graph_preferences)\r\n\r\n        def _create_column_group(self, group_data, column_origin_plane, column_group_name, column_number_in_group,\r\n                                 sub_group=False, show_group_name=True):\r\n            \"\"\"\r\n            Create a bar graph column group (can contain subgroups and multiple bars)\r\n            :param group_data: data used to create the group of columns\r\n            :param column_origin_plane: Origin plane for the column\r\n            :param column_group_name: Name of the column group (this group might contain multiple columns)\r\n            :param column_number_in_group: The order number in the column group. 0=First\r\n            :param sub_group: data used to create a sub_group\r\n            :param show_group_name: toggle for group name labels\r\n            \"\"\"\r\n\r\n            # Condition for displaying the group column name\r\n            if len(group_data) == 1 and self.graph_preferences.analysis_type != 'by_assembly_and_material':\r\n                show_group_name = False\r\n\r\n            # Condition for displaying sub-graphs\r\n            if sub_group:\r\n                group_data = sub_group\r\n\r\n            # Create a column for each data point\r\n            for column_number, data in enumerate(group_data):\r\n                count = 0\r\n\r\n                column_name = self._set_column_name(column_group_name, column_number, group_data)\r\n                column_data, sub_group_name = self._extract_column_data(column_group_name, data, sub_group)\r\n\r\n                # If hide_null_columns set to True, only show column if flow data > 0\r\n\r\n                if self.graph_preferences.hide_null_columns:\r\n                    if not column_data or column_data['life_cycle'][self.flow] == 0:\r\n                        continue\r\n\r\n                if self.graph_preferences.analysis_type == \"by_assembly_and_material\":\r\n                    if column_data:\r\n                        if self.graph_preferences.hide_null_columns:\r\n                            columns = {key: mat for key, mat in column_data['by_material'].items()\r\n                                       if mat['life_cycle'][self.flow] != 0}\r\n                        else:\r\n                            columns = column_data['by_material']\r\n                        for key, mat in columns.items():\r\n\r\n                            # Create location values for the legend labels.\r\n                            # These are only needed when creating group labels\r\n                            if show_group_name:\r\n                                self._create_legend_attributes(column_group_name, column_number_in_group,\r\n                                                               column_origin_plane, sub_group_name=sub_group_name)\r\n\r\n                            # Create a BarGraphColumn object\r\n                            self._create_column(mat, column_number_in_group, column_origin_plane,\r\n                                                column_name=key, show_group_name=show_group_name, sub_group_count=count)\r\n\r\n                else:\r\n                    if column_data:\r\n\r\n                        # Create location values for the legend labels.\r\n                        # These are only needed when creating group labels\r\n                        if show_group_name:\r\n                            self._create_legend_attributes(column_group_name, column_number_in_group,\r\n                                                           column_origin_plane, sub_group_name=sub_group_name)\r\n\r\n                        # Create a BarGraphColumn object\r\n                        self._create_column(column_data, column_number_in_group, column_origin_plane,\r\n                                            column_name=column_name, show_group_name=show_group_name)\r\n\r\n        def _set_column_name(self, column_group_name, column_number, group_data):\r\n            \"\"\"\r\n            Set the column name, according to the number of data inputs and analysis type selected\r\n            :param column_group_name: The name of the column group\r\n            :param column_number: The column number, in the current column group\r\n            :param group_data: The column group data\r\n            :return: Name of the column\r\n            :rtype: str\r\n            \"\"\"\r\n            column_name = str(self.graph_preferences.data[column_number].name)\r\n\r\n            # Condition where there are no comparison bars\r\n            if len(group_data) == 1:\r\n                if self.graph_preferences.analysis_type == 'by_material':\r\n                    column_name = column_group_name\r\n\r\n                elif self.graph_preferences.analysis_type == 'by_assembly':\r\n                    column_name = column_group_name\r\n\r\n                elif not self.graph_preferences.analysis_type:\r\n                    column_name = 'Total'\r\n\r\n            return column_name\r\n\r\n        def _extract_column_data(self, column_group_name, data, sub_group):\r\n            \"\"\"\r\n            Extract the column data, depending on the analysis type\r\n            :param column_group_name: The name of the column group\r\n            :param data: Data to extract the column data from\r\n            :param sub_group: Data used to create a sub_group\r\n            :return: The column data and subgroup name (if used, otherwise None)\r\n            \"\"\"\r\n\r\n            sub_group_name = None\r\n\r\n            if sub_group:\r\n                if column_group_name in data[0]:\r\n                    column_data = data[0][column_group_name]\r\n                    sub_group_name = data[1]\r\n                else:\r\n                    column_data = None\r\n                    sub_group_name = None\r\n\r\n            elif self.graph_preferences.analysis_type in ['by_material', 'by_assembly', 'by_assembly_and_material']:\r\n                if column_group_name in data:\r\n                    column_data = data[column_group_name]\r\n                else:\r\n                    column_data = None\r\n\r\n            else:\r\n                if 'life_cycle' not in data:  # When 'total' value is used to generate graph\r\n                    _temp_val = data[list(data.keys())[0]]\r\n                    if 'life_cycle' in _temp_val:\r\n                        column_data = _temp_val\r\n                    else:\r\n                        column_data = None\r\n                else:\r\n                    column_data = data\r\n            return column_data, sub_group_name\r\n\r\n        def _create_column(self, column_data, column_number_in_group, column_origin_plane,\r\n                           column_name='', show_group_name=True, sub_group_count=0):\r\n            \"\"\"\r\n            Create a BarGraphColumn that represents a column in EPiCGraph\r\n            :param column_data: Data used to generate the column\r\n            :param column_number_in_group: The column number - based on the current column group\r\n            :param column_origin_plane: Origin plane for the column\r\n            :param column_name: Name of the column\r\n            :param show_group_name: Show group name if True\r\n            :param sub_group_count:\r\n            \"\"\"\r\n            graph_spacing = self.graph_preferences.graph_spacing\r\n\r\n            # Move the column origin plane, based on the column number, graph spacing and sub-group count\r\n            column_origin_plane = self._move_column_origin_plane(column_number_in_group, column_origin_plane,\r\n                                                                 graph_spacing, sub_group_count)\r\n\r\n            # If needed, increase the graph_width to make sure it fits all of the data\r\n            self.graph_preferences.graph_width = max(self.graph_preferences.graph_width,\r\n                                                     ((graph_spacing * column_number_in_group)\r\n                                                      + self.cumulative_column_spacing\r\n                                                      + self.graph_preferences.space_between_graphs))\r\n            # Generate Column\r\n            graph_column = EPiCGraph.BarGraphColumn(column_data,\r\n                                                    graph_preferences=self.graph_preferences,\r\n                                                    name=column_name,\r\n                                                    column_group_name=column_number_in_group,\r\n                                                    origin_plane=column_origin_plane,\r\n                                                    flow=self.flow,\r\n                                                    max_data_value=self.max_data_value,\r\n                                                    show_group_name=show_group_name\r\n                                                    )\r\n            self.columns.append(graph_column)\r\n\r\n        def _create_legend_attributes(self, column_group_name, column_number_in_group, column_origin_plane,\r\n                                      sub_group_name=False):\r\n            \"\"\"\r\n            Based on the column group - create attributes used to generate the graph legend.\r\n            This includes location of break line (above group column name) for graph visualisation\r\n            :param column_group_name: Column group name\r\n            :param column_number_in_group: The column number, in the current column group 0=First\r\n            :param column_origin_plane: Column origin plane\r\n            \"\"\"\r\n\r\n            # Attributes are stored in the self.column_group_names dictionary\r\n            attributes = self.column_group_names[column_group_name]\r\n\r\n            if sub_group_name:\r\n                # Populate the group attributes\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n\r\n                # Populate the sub-group attributes\r\n                _att = self.column_group_names[column_group_name]\r\n                if 'sub_group' not in _att:\r\n                    _att['sub_group'] = {}\r\n                if sub_group_name not in _att['sub_group']:\r\n                    _att['sub_group'][sub_group_name] = {}\r\n                attributes = _att['sub_group'][sub_group_name]\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n            else:\r\n                self._populate_attributes(attributes, column_number_in_group, column_origin_plane)\r\n\r\n        def _populate_attributes(self, attributes, column_number_in_group, column_origin_plane):\r\n            \"\"\"\r\n            Populate the column attributes - these are used to calculate the location of the text for the legend\r\n            :param attributes: Attributes dictionary to populate\r\n            :param column_number_in_group: The column number, in the current column group 0=First\r\n            :param column_origin_plane: Column origin plane\r\n            \"\"\"\r\n\r\n            # Retrieve preferences from parent EPiCGraph class\r\n            prefs = self.graph_preferences\r\n            graph_spacing = prefs.graph_spacing\r\n\r\n            # If label hasn't been created, generate the base attributes\r\n            if 'group_label_origin_x_line_start' not in attributes:\r\n                x_axis_value_for_column_group_line_start = self.origin.X + (graph_spacing * column_number_in_group) \\\r\n                                                           + self.cumulative_column_spacing + graph_spacing\r\n                attributes['group_label_origin_x_line_start'] = x_axis_value_for_column_group_line_start\r\n                attributes['group_label_origin_y'] = column_origin_plane.OriginY\r\n                attributes['group_label_origin_z'] = column_origin_plane.OriginZ\r\n                attributes['number_of_columns_in_group'] = 1\r\n\r\n            # If label already exists, increase the 'number of columns' counter\r\n            else:\r\n                attributes['number_of_columns_in_group'] += 1\r\n            centre_text = (prefs.column_padding * 2) + ((prefs.column_width + prefs.column_padding) / 2\r\n                                                        * (attributes['number_of_columns_in_group'] - 1))\r\n            end_text = (prefs.column_padding * 3) + ((prefs.column_width + prefs.column_padding)\r\n                                                     * (attributes['number_of_columns_in_group'] - 1))\r\n            attributes['group_label_origin_x_line_end'] = attributes['group_label_origin_x_line_start'] + end_text\r\n            attributes['group_label_origin_x'] = attributes['group_label_origin_x_line_start'] + centre_text\r\n\r\n        @staticmethod\r\n        def _sort_dictionary_highest_to_lowest_value(dictionary_to_rank):\r\n            \"\"\"\r\n            Sort dictionary based on it's values.\r\n            Rank from highest to lowest.\r\n            :param dictionary_to_rank: dictionary to rank, with float for value\r\n            :return: New sorted dictionary\r\n            :rtype: OrderedDict\r\n            \"\"\"\r\n\r\n            ranked_dictionary = OrderedDict()\r\n            while len(dictionary_to_rank) > 0:\r\n                max_key = max(dictionary_to_rank, key=dictionary_to_rank.get)\r\n                ranked_dictionary[max_key] = {'max_value': dictionary_to_rank.pop(max_key), 'group_label_origin': None}\r\n            return ranked_dictionary\r\n\r\n        def _get_life_cycle_flow_values_for_column_keys(self, column_keys):\r\n            \"\"\"\r\n            Get life cycle flow values based on column keys. Values are collected from self.data\r\n            Values must be above 0.\r\n            :param column_keys: List of column keys\r\n            :return: Dictionary with keys based on input list, and associated life cycle flow values\r\n            :rtype: dict\r\n            \"\"\"\r\n\r\n            column_values = {}\r\n            for column_key in column_keys:\r\n                column_values[column_key] = 0\r\n                for d in self.data:\r\n                    try:\r\n                        if d[column_key]['life_cycle'][self.flow] > column_values[column_key]:\r\n                            column_values[column_key] = d[column_key]['life_cycle'][self.flow]\r\n                    except KeyError:  # Condition when comparison graph has different column names.\r\n                        pass\r\n            return column_values\r\n\r\n        def _move_column_origin_plane(self, column_number_in_column_group, column_origin_plane, graph_spacing,\r\n                                      sub_group_count=0):\r\n            \"\"\"\r\n            Move the column origin plane based on the column number (in the column group) and graph spacing\r\n            :param column_number_in_column_group: Column number in the column group (0=First column of the group)\r\n            :param column_origin_plane: Previous column origin plane\r\n            :param graph_spacing: Graph spacing\r\n            :return: Origin plane, moved to the new location\r\n            \"\"\"\r\n\r\n            self.cumulative_column_spacing += \\\r\n                (self.graph_preferences.column_padding + self.graph_preferences.column_width)\r\n            x_axis_origin = self.origin.X + (graph_spacing * column_number_in_column_group) \\\r\n                            + (sub_group_count * column_number_in_column_group) + self.cumulative_column_spacing\r\n            column_origin_plane.OriginX = x_axis_origin\r\n            return column_origin_plane\r\n\r\n    class BarGraphColumn:\r\n        def __init__(self, data, graph_preferences=None, name='', origin_plane=rs.WorldXYPlane(), flow='',\r\n                     max_data_value=0, column_group_name='', show_group_name=False):\r\n            \"\"\"\r\n            A bar graph column element (inside BarGraph())\r\n            :param data: Bar graph data\r\n            :param graph_preferences: Graph preferences inherited from the EPiCGraph class instance\r\n            :param name: Name of the column\r\n            :param origin_plane: Origin plane for the column\r\n            :param flow: Enironmental flow type\r\n            :param max_data_value: the highest life cycle data value in the flow (sets the y-axis)\r\n            :param column_group_name: Name of the column group\r\n            \"\"\"\r\n\r\n            self.data = data\r\n            self.graph_preferences = graph_preferences\r\n            self.name = name\r\n            self.origin_plane = origin_plane\r\n            self.flow = flow\r\n            self.max_data_value = max_data_value\r\n            self.column_group_name = column_group_name\r\n            self.show_group_name = show_group_name\r\n\r\n            # Set the column attributes\r\n            self.segments = []\r\n            self.origin = Geometry.Point3d(origin_plane.OriginX, origin_plane.OriginY, origin_plane.OriginZ)\r\n\r\n            if max_data_value == 0:\r\n                self.elements_to_render = None\r\n\r\n            else:\r\n                self.max_data_value = max_data_value\r\n                if self.data:\r\n                    self.build_segments()\r\n                self.elements_to_render = None\r\n\r\n        def _build_segment(self, data, segment_type, segment_origin_plane, flow_type, colour=None):\r\n            \"\"\"\r\n            Create a stacked bar segment for the current EPiCGraph column\r\n            :param data: Data used to create the segment\r\n            :param segment_type: The flow type that the segment represents (e.g initial, recurrent, initial wastage)\r\n            :param segment_origin_plane: Origin plane for the segment\r\n            :param flow_type: The flow type (e.g. Energy, Water, GHG)\r\n            :param colour: segment colour\r\n            :param subset:\r\n            :return:\r\n            \"\"\"\r\n\r\n            segment = segment_type\r\n\r\n            # If no value provided, use the default colour based on the flow + segment type\r\n            colour = DEFINED_FLOWS[self.flow][segment['colour']] if not colour else colour\r\n\r\n            # Get the flow values to create the segment\r\n            if isinstance(segment['flow_type'], list):\r\n                if data[segment['flow_type'][1]][self.flow] > 0 and self.max_data_value > 0:\r\n                    normalised_graph_value = ((data[segment['flow_type'][0]][self.flow]\r\n                                               - data[segment['flow_type'][1]][self.flow])\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                elif data[segment['flow_type'][0]][self.flow] > 0 and self.max_data_value > 0:\r\n                    normalised_graph_value = (data[segment['flow_type'][0]][self.flow]\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                else:\r\n                    normalised_graph_value = 0\r\n\r\n            # The other flows can be taken directly. Values are normalised for the graph height\r\n            else:\r\n                if data[segment['flow_type']][self.flow] > 0:\r\n                    normalised_graph_value = (data[segment['flow_type']][self.flow]\r\n                                              / self.max_data_value) * self.graph_preferences.graph_height\r\n                else:\r\n                    normalised_graph_value = 0\r\n\r\n            # Only create a segment is the value is more than 0\r\n            if normalised_graph_value > 0:\r\n                self.segments.append(\r\n                    EPiCGraph.BarGraphSegment(graph_preferences=self.graph_preferences,\r\n                                              origin_plane=segment_origin_plane,\r\n                                              height=normalised_graph_value,\r\n                                              origin_point=(segment_origin_plane.OriginX,\r\n                                                            segment_origin_plane.OriginY,\r\n                                                            segment_origin_plane.OriginZ),\r\n                                              colour=colour,\r\n                                              show_hatch='wastage' in segment['label'],\r\n                                              segment_type=segment['label'],\r\n                                              label=flow_type\r\n                                              ))\r\n            return normalised_graph_value\r\n\r\n        @staticmethod\r\n        def make_tint(colour_tuple, tint_factor):\r\n            \"\"\"\r\n            Create a tint value for a a specified colour\r\n            :param colour_tuple: an aRBG colour tuple with values of 0-255 (A,R,G,B) A = alpha\r\n            :param tint_factor: A tint factor from 0 to 1, 0 being a lighter value\r\n            :return: (A,R,G,B) tuple\r\n            :rtype: tuple\r\n            \"\"\"\r\n            alpha = colour_tuple[0]\r\n            newR = min([255, colour_tuple[1] + (255 - colour_tuple[1]) * tint_factor])\r\n            newG = min([255, colour_tuple[2] + (255 - colour_tuple[2]) * tint_factor])\r\n            newB = min([255, colour_tuple[3] + (255 - colour_tuple[3]) * tint_factor])\r\n            return (alpha, newR, newG, newB)\r\n\r\n        def build_segments(self):\r\n            segment_origin_plane = rs.MovePlane(rs.WorldXYPlane(), self.origin)\r\n\r\n            for key, segment in self.graph_preferences.segment_properties.items():\r\n                normalised_graph_value = self._build_segment(self.data, segment, segment_origin_plane, key)\r\n                segment_origin_plane = rs.MovePlane(segment_origin_plane, rs.AddPoint(\r\n                    segment_origin_plane.OriginX,\r\n                    segment_origin_plane.OriginY + normalised_graph_value,\r\n                    segment_origin_plane.OriginZ))\r\n\r\n    class BarGraphSegment:\r\n        def __init__(self, graph_preferences=None, origin_plane=rs.WorldXYPlane(), height=0, colour=None,\r\n                     segment_type='', origin_point=(0, 0, 0), label='', show_hatch=False):\r\n            \"\"\"\r\n            A stacked bar segment for the current EPiCGraph column\r\n            :param graph_preferences: Graph preference inherited from EPiCGraph\r\n            :param origin_plane: The segment origin plane\r\n            :param height: Height of the segment\r\n            :param colour: Colour of the segment\r\n            :param segment_type: The type of flow that the segment represents\r\n            :param origin_point: Origin point for the segment\r\n            :param label: The flow type for the segment\r\n            :param show_hatch: Show hatch if True\r\n            \"\"\"\r\n\r\n            self.graph_preferences = graph_preferences\r\n            self.origin_plane = origin_plane\r\n            self.origin = origin_point\r\n            self.colour = colour\r\n            self.show_hatch = show_hatch\r\n            self.name = segment_type\r\n            self.label = label\r\n\r\n            # Create segment\r\n            segment = EPiCVisualisations.GraphSegmentGeometry(Geometry.Rectangle3d(origin_plane,\r\n                                                                                   self.graph_preferences.column_width,\r\n                                                                                   height))\r\n            segment.fill_colour = colour\r\n            segment.show_hatch = show_hatch\r\n            self.elements_to_render = segment\r\n\r\n    class BarGraphLegend:\r\n\r\n        def __init__(self, graph, graph_preferences=None):\r\n            \"\"\"\r\n            Creates a legend for each graph component. This includes titles, labels, axis lines & legends.\r\n            :param graph: BarGraph class object. Used to extract legend values.\r\n            :param graph_preferences: Graph preference inherited from EPiCGraph\r\n            \"\"\"\r\n\r\n            self.graph_preferences = graph_preferences\r\n            self.graph = graph\r\n\r\n            # Load the individual graph preferences\r\n            self.column_spacing = graph_preferences.column_width + graph_preferences.text_padding\r\n            self.legend_box_size = graph_preferences.legend_box_size\r\n            self.text_size = graph_preferences.text_size\r\n            self.heading_text_size = graph_preferences.heading_text_size\r\n            self.tick_size = graph_preferences.tick_size\r\n            self.text_padding = graph_preferences.text_padding\r\n            self.axis_label_text = graph_preferences.axis_label_text_size\r\n\r\n            # Create a dictionary for all geometry and text that needs to be visualised\r\n            elements = {\r\n                'legend_boxes': [],\r\n                'legend_text': [],\r\n                'column_names': None,\r\n                'axis_lines': [],\r\n                'axis': [],\r\n                'y_axis_label': str}\r\n            prefs = []\r\n\r\n            # Extract preferences (the flow_types used in the graph) from each segment\r\n            if self.graph and isinstance(self.graph, EPiCGraph.BarGraph):\r\n                for column in self.graph.columns:\r\n                    prefs += [seg.label for seg in column.segments if seg]\r\n                self.segment_preferences = set(prefs)\r\n                if len(self.segment_preferences) == 0:\r\n                    self.segment_preferences = None\r\n            else:\r\n                self.segment_preferences = None\r\n\r\n            # Build a legend for the graph, including all axis lines and labels.\r\n            self.elements_to_render = {}\r\n            self.create_legend(elements)\r\n\r\n        def create_legend(self, elements):\r\n            \"\"\"\r\n            Create a legend for the current EPiCBarGraph element\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            # Create a legend for each of the flow types\r\n            if self.segment_preferences:\r\n                legend_top_y_axis = self._create_legend(elements)\r\n                self._create_column_labels(elements)\r\n                if len(self.graph.column_group_names) > 0:  # Only used when multiple column values\r\n                    self._create_column_group_labels(elements)\r\n                self._create_axis_lines(elements)\r\n                self._create_ticks(elements)\r\n                self._create_graph_title(elements, legend_top_y_axis)\r\n                self._create_y_axis_labels(elements)\r\n\r\n                # Create a dictionary entry for each geometry / text that needs to be rendered\r\n                self.elements_to_render = elements\r\n\r\n        def _create_y_axis_labels(self, elements):\r\n            \"\"\"\r\n            Create the y-axis labels\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            # find the minimum x origin value for the bounding boxes for the tick_text\r\n            tick_text_x_limit = min(text.get_Boundingbox().GetCorners()[0].X for text in elements['tick_text'])\r\n            # Create a label for the y-axis based on flow units\r\n            elements['y_axis_label'] = EPiCVisualisations.bakeable_text_from_str(\r\n                self.graph.flow_units,\r\n                text_size=(self.axis_label_text),\r\n                text_location=(tick_text_x_limit - 0.5,\r\n                               self.graph.origin.Y + self.graph_preferences.graph_height / 2,\r\n                               self.graph.origin.Z),\r\n                text_rotation=90)\r\n\r\n        def _create_graph_title(self, elements, legend_top_y_axis):\r\n            \"\"\"\r\n            Create a graph title\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :param legend_top_y_axis: location of the top y-axis element (legend)\r\n            \"\"\"\r\n\r\n            elements['heading'] = EPiCVisualisations.bakeable_text_from_str(self.graph.title,\r\n                                                                            text_size=self.heading_text_size,\r\n                                                                            text_location=(self.graph.origin.X,\r\n                                                                                           legend_top_y_axis\r\n                                                                                           + self.column_spacing,\r\n                                                                                           self.graph.origin.Z))\r\n\r\n        def _create_legend(self, elements):\r\n            \"\"\"\r\n            Create a legend for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :return: The y-axis location of the legend, needed to calculate the Title location\r\n            \"\"\"\r\n\r\n            for num, legend in enumerate(self.segment_preferences):\r\n                legend = self.graph_preferences.seg_pref_template[legend]\r\n                x_axis = self.graph.origin.X\r\n                y_axis = self.graph.origin.Y + self.graph_preferences.graph_height \\\r\n                         + self.graph_preferences.graph_spacing \\\r\n                         + (self.column_spacing * num)\r\n                z_axis = self.graph.origin.Z\r\n                legend_origin = rs.MovePlane(rs.WorldXYPlane(),\r\n                                             Geometry.Point3d(x_axis, y_axis, z_axis))\r\n                legend_colour = DEFINED_FLOWS[self.graph.flow][legend['colour']]\r\n                show_hatch = 'wastage' in legend['label']\r\n                legend_box = EPiCVisualisations.GraphSegmentGeometry(\r\n                    Geometry.Rectangle3d(legend_origin, self.legend_box_size, self.legend_box_size))\r\n                legend_box.show_hatch = show_hatch\r\n                legend_box.fill_colour = legend_colour\r\n\r\n                elements['legend_boxes'].append(legend_box)\r\n                elements['legend_text'].append(\r\n                    EPiCVisualisations.bakeable_text_from_str(legend['label'],\r\n                                                              text_size=self.text_size,\r\n                                                              text_location=(\r\n                                                                  (legend_origin.OriginX + self.column_spacing),\r\n                                                                  legend_origin.OriginY,\r\n                                                                  legend_origin.OriginZ)))\r\n            return y_axis\r\n\r\n        def _create_ticks(self, elements):\r\n            \"\"\"\r\n            Create the y-axis ticks and tick text for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            # Create list of ticks\r\n            tick_values = (self.create_list_of_ticks([0, self.graph.max_data_value],\r\n                                                     normalised_y_axis_height=self.graph_preferences.graph_height))\r\n            tick_values_not_normalised = (self.create_list_of_ticks([0, self.graph.max_data_value]))\r\n\r\n            # Create ticks\r\n            elements['axis'] += [Geometry.Line(self.graph.origin.X, self.graph.origin.Y + tick, self.graph.origin.Z,\r\n                                               self.graph.origin.X - self.tick_size, self.graph.origin.Y + tick,\r\n                                               self.graph.origin.Z) for tick in tick_values]\r\n            # Tick values\r\n            elements['tick_text'] = [EPiCVisualisations.bakeable_text_from_str(str(int(tick)),\r\n                                                                               text_size=self.text_size,\r\n                                                                               align_right=True,\r\n                                                                               text_location=((\r\n                                                                                                      self.graph.origin.X - self.tick_size - self.text_padding),\r\n                                                                                              self.graph.origin.Y + tick_normalised - (\r\n                                                                                                      self.text_size / 2),\r\n                                                                                              self.graph.origin.Z)) for\r\n                                     tick_normalised, tick in\r\n                                     zip(tick_values, tick_values_not_normalised)]\r\n\r\n        def _create_axis_lines(self, elements):\r\n            \"\"\"\r\n            Create the axis lines for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            elements['axis_lines'] = [Geometry.Line(self.graph.origin.X, self.graph.origin.Y, self.graph.origin.Z,\r\n                                                    self.graph.origin.X,\r\n                                                    self.graph.origin.Y + self.graph_preferences.graph_height,\r\n                                                    self.graph.origin.Z),\r\n                                      Geometry.Line(self.graph.origin.X, self.graph.origin.Y, self.graph.origin.Z,\r\n                                                    self.graph.origin.X + self.graph_preferences.graph_width\r\n                                                    - self.graph_preferences.space_between_graphs, self.graph.origin.Y,\r\n                                                    self.graph.origin.Z)]\r\n\r\n        def _create_column_group_labels(self, elements):\r\n            \"\"\"\r\n            Create the column group names (and sub-group names) for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n            if 'sub_group' in [y for x in self.graph.column_group_names.values() for y in x.keys()]:\r\n                for subgroup in self.graph.column_group_names.values():\r\n                    if 'sub_group' in subgroup:\r\n                        new_text_box_y_extent = self._generate_group_labels(elements, subgroup['sub_group'])\r\n                self._generate_group_labels(elements, self.graph.column_group_names, new_text_box_y_extent)\r\n            else:\r\n                self._generate_group_labels(elements, self.graph.column_group_names)\r\n\r\n        def _generate_group_labels(self, elements, labels, text_box_y_extent=False):\r\n            \"\"\"\r\n            Generate a group label, or sub-group label for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            :param labels: A list of labels and label locations\r\n            :param text_box_y_extent: y_axis location of the nearest test (above)\r\n            :return: text_box_y_extent needed to generate sub-label locations\r\n            \"\"\"\r\n\r\n            if not text_box_y_extent:\r\n                text_box_y_extent = min(text.get_Boundingbox().GetCorners()[0].Y for text in elements['column_names'])\r\n\r\n            for key, value in labels.items():\r\n                if 'group_label_origin_x' in value:\r\n                    if 'column_section_names' not in elements:\r\n                        elements['column_section_names'] = []\r\n                    if 'column_section_lines' not in elements:\r\n                        elements['column_section_lines'] = []\r\n                    elements['column_section_names'].append(EPiCVisualisations.bakeable_text_from_str(key,\r\n                                                                                                      text_size=self.text_size,\r\n                                                                                                      bold=True,\r\n                                                                                                      text_rotation=90,\r\n                                                                                                      align_top=True,\r\n                                                                                                      text_location=(\r\n                                                                                                          value[\r\n                                                                                                              'group_label_origin_x'],\r\n                                                                                                          text_box_y_extent\r\n                                                                                                          - (\r\n                                                                                                              self.graph_preferences.graph_spacing),\r\n                                                                                                          (value[\r\n                                                                                                              'group_label_origin_z'])\r\n                                                                                                      )))\r\n\r\n                    elements['column_section_lines'].append(Geometry.Line(value['group_label_origin_x_line_start'],\r\n                                                                          text_box_y_extent - (\r\n                                                                                  self.graph_preferences.graph_spacing / 3),\r\n                                                                          self.graph.origin.Z,\r\n                                                                          value['group_label_origin_x_line_end'],\r\n                                                                          text_box_y_extent\r\n                                                                          - (self.graph_preferences.graph_spacing / 3),\r\n                                                                          self.graph.origin.Z))\r\n            if 'column_section_names' in elements:\r\n                text_box_y_extent = min(text.get_Boundingbox().GetCorners()[0].Y for text\r\n                                        in elements['column_section_names'])\r\n            return text_box_y_extent\r\n\r\n        def _create_column_labels(self, elements):\r\n            \"\"\"\r\n            Create column labels for the graph\r\n            :param elements: A dictionary of visualisation elements to be populated\r\n            \"\"\"\r\n\r\n            elements['column_names'] = [EPiCVisualisations.bakeable_text_from_str(column.name,\r\n                                                                                  text_size=self.text_size,\r\n                                                                                  text_rotation=90,\r\n                                                                                  align_top=True,\r\n                                                                                  text_location=(\r\n                                                                                      column.origin.X + self.column_spacing / 2,\r\n                                                                                      column.origin.Y -\r\n                                                                                      (self.column_spacing / 2),\r\n                                                                                      column.origin.Z)) for num, column\r\n                                        in\r\n                                        enumerate(self.graph.columns)]\r\n\r\n        @staticmethod\r\n        def create_list_of_ticks(data_list, zero_val=0, max_ticks=10, normalised_y_axis_height=False):\r\n            \"\"\"\r\n            A tool that calculates optimal tick sizes based on list values\r\n            Adapted from code by Shaobo Guan (2017)\r\n            https://stackoverflow.com/questions/4947682/intelligently-calculating-chart-tick-positions\r\n\r\n            :param data_list: a list to evaluate\r\n            :param max_ticks: max number of ticks, an interger, defaults to 10\r\n            :param zero_val: y-axis zero value for the graph, defaults to 0\r\n            :return: tick size\r\n            \"\"\"\r\n\r\n            data_span = max(data_list) - zero_val\r\n\r\n            # scale data by the order of 10\r\n            scale = 10.0 ** floor(log10(data_span))\r\n\r\n            # possible tick sizes in range [1, 10]\r\n            standard_tick_size = [5.0, 2.0, 1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01]\r\n\r\n            # initial tick size for normalised data\r\n            initial_tick_size = 1.0\r\n\r\n            # every loop reduces tick size\r\n            for i in range(len(standard_tick_size)):\r\n\r\n                # number of ticks for the current tick size\r\n                num_tick = data_span / scale / standard_tick_size[i]\r\n\r\n                # break loop when tick limit reached\r\n                if num_tick > max_ticks:\r\n                    initial_tick_size = standard_tick_size[i - 1]\r\n                    break\r\n\r\n            # resize to original data\r\n            tick_size = initial_tick_size * scale\r\n            ticks = ceil(tick_size)\r\n\r\n            # Normalise the y-axis height\r\n            if normalised_y_axis_height:\r\n                return [((ticks * num) / max(data_list)) * normalised_y_axis_height for num in range(10) if\r\n                        ticks * num < max(data_list)]\r\n            else:\r\n                return [ticks * num for num in range(10) if ticks * num < max(data_list)]\r\n\r\n\r\nclass EPiCAssembly:\r\n    \"\"\"\r\n    An EPiC Assembly, enabling the combination of various EPiC materials and the calculation of associated embodied\r\n    environmental flows\r\n    \"\"\"\r\n\r\n    template_flows = OrderedDict([('initial', dict()),\r\n                                  ('initial_wastage', dict()),\r\n                                  ('recurrent', dict()),\r\n                                  ('recurrent_wastage', dict()),\r\n                                  ('life_cycle', dict()),\r\n                                  ('life_cycle_wastage', dict()),\r\n                                  ])\r\n\r\n    unit_calculation = {'no.': None,\r\n                        'm': ghcomponents.Length,\r\n                        'm²': ghcomponents.Area,\r\n                        'm³': ghcomponents.Volume}\r\n\r\n    def __str__(self):\r\n        return self.print_report(print_as_str=True)\r\n\r\n    def __init__(self, selected_geometry, name, service_life, wastage, comments,\r\n                 epic_materials, assembly_units, category=None):\r\n        \"\"\"\r\n        :param selected_geometry: a list of rhino geometries\r\n        :param name: the name of the assembly (str)\r\n        :param service_life: the service_life of the assembly, overriding the service_span of all nested materials (int)\r\n        :param wastage: wastage coefficient of the assembly in %, overriding the wastage coeffs of nested mats (float)\r\n        :param comments: a custom comment (str)\r\n        :param epic_materials: a list of tuples, item 0 the epic mat instance and item 1 being the quantity of material\r\n        :param assembly_units: the functional unit of the assembly (str), e.g. m²\r\n        :param category: the assembly category, used in graph comparisons e.g. Interior Walls, Exterior Walls\r\n        \"\"\"\r\n\r\n        self.output_geometry = []\r\n        self.component_type = 'EPiCAssembly'\r\n        self.name = remove_commas_and_flatten_list_for_csv_export(name) if name else 'EPiC Assembly'\r\n        self.category = self.name if not category else remove_commas_and_flatten_list_for_csv_export(category)\r\n        self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n        self.service_life = abs(service_life) if service_life else None\r\n        self.assembly_units = assembly_units\r\n\r\n        # A zero value will override the EPiCDB wastage coefficient\r\n        if wastage:\r\n            self.wastage_override = abs(wastage) / 100\r\n        elif wastage == 0:\r\n            self.wastage_override = 0.\r\n        else:\r\n            self.wastage_override = None\r\n\r\n        self.total_units, self.individual_units = \\\r\n            self.verify_input_and_calculate_geometry_units(selected_geometry, assembly_units)\r\n\r\n        self.selected_geometry = selected_geometry\r\n        # create attribute to store inputted geometry\r\n\r\n        # list of lists of EPiC materials, sublists contain an instance of an EPiC material\r\n        # in index 0 and the quantity in 1\r\n        self.epic_materials = [[y[0][0], abs(y[1])] for y in epic_materials]\r\n\r\n        # run calculations\r\n        self.flows = self.calculate_flows()\r\n        self.recalculated_flows = self.calculate_flows()\r\n\r\n    def verify_input_and_calculate_geometry_units(self, selected_geometry, assembly_units):\r\n        \"\"\"\r\n        Verify input geometry based on the FU of the selected assembly. Calculate unit values for each item\r\n        :param selected_geometry: a list of geometry inputs and numerical input values\r\n        :param assembly_units: functional unit used for the selected geometry\r\n        :return: total_units, individual_units\r\n        \"\"\"\r\n\r\n        individual_units = []\r\n        total_units = 0\r\n\r\n        for num, geometry in enumerate(selected_geometry):\r\n            if geometry:\r\n                # Allow numerical input\r\n                if isinstance(geometry, (int, float)):\r\n                    _value = geometry\r\n\r\n                # Count each geometry item\r\n                elif assembly_units == 'no.':\r\n                    _value = 1\r\n\r\n                elif assembly_units == 'm':\r\n                    # Test if geometry is a line, curve or polyline\r\n                    if not isinstance(geometry, (Geometry.ArcCurve,\r\n                                                 Geometry.BezierCurve,\r\n                                                 Geometry.BrepEdge,\r\n                                                 Geometry.BrepLoop,\r\n                                                 Geometry.Curve,\r\n                                                 Geometry.Line,\r\n                                                 Geometry.LineCurve,\r\n                                                 Geometry.NurbsCurve,\r\n                                                 Geometry.Polyline,\r\n                                                 Geometry.PolyCurve,\r\n                                                 Geometry.PolylineCurve)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)\r\n\r\n                elif assembly_units == 'm²':\r\n                    # Test if this is a surface\r\n                    # Create surface from polyline inputs\r\n                    if isinstance(geometry, (Geometry.PolylineCurve, Geometry.Polyline)):\r\n                        if geometry.IsClosed and geometry.IsPlanar():\r\n                            geometry = Geometry.Brep.CreatePlanarBreps(geometry)[0]\r\n                        else:\r\n                            raise TypeError()\r\n                    # Allow Brep - but only if it is not a solid\r\n                    elif isinstance(geometry, Geometry.Brep):\r\n                        if geometry.IsSolid:\r\n                            raise TypeError()\r\n                    elif not isinstance(geometry, (Geometry.BezierSurface,\r\n                                                   Geometry.BrepFace,\r\n                                                   Geometry.Surface,\r\n                                                   Geometry.Rectangle3d,\r\n                                                   Geometry.Mesh,\r\n                                                   Geometry.MeshNgon,\r\n                                                   Geometry.NurbsSurface,\r\n                                                   Geometry.PlaneSurface,\r\n                                                   Geometry.SubD,\r\n                                                   Geometry.SubDFace)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)[0]\r\n\r\n                elif assembly_units == 'm³':\r\n                    # Test if this is a Brep, line or surface\r\n                    if not isinstance(geometry, (Geometry.Brep,\r\n                                                 Geometry.Extrusion)):\r\n                        raise TypeError()\r\n                    _value = self.unit_calculation[assembly_units](geometry)[0]\r\n\r\n                else:\r\n                    raise ValueError('No functional unit found for assembly')\r\n\r\n                total_units += _value\r\n                individual_units.append(_value)\r\n                if not isinstance(geometry, (int, float)):\r\n                    self.output_geometry.append(geometry)\r\n        return abs(total_units), individual_units\r\n\r\n    def _calculate_flows(self, materials_list, flow, wastage_only=False, period_of_analysis=None, quantity=None):\r\n        \"\"\"\r\n        Calculates embodied environmental flows\r\n        :param materials_list: the list of EPiC materials for which to run the calculations\r\n        :param flow: an embodied environmental flow, e.g. energy\r\n        :param period_of_analysis: period of analysis for calculating the flows\r\n        :param wastage_only: specify if we only want to calculate wastage\r\n        :param quantity: the quantity of assembly to use, specify when we want results by geometry\r\n        :return:\r\n        \"\"\"\r\n\r\n        if wastage_only:\r\n            base_quantity = 0.\r\n        else:\r\n            base_quantity = 1.\r\n\r\n        if quantity is None:\r\n            quantity = self.total_units\r\n\r\n        if self.wastage_override:\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * (base_quantity + self.wastage_override) for m\r\n                      in materials_list]\r\n\r\n        elif self.wastage_override == 0:  # Forcing wastage to be zero\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * base_quantity for m in materials_list]\r\n        else:\r\n            result = [quantity * abs(m[1]) * getattr(m[0], flow) * (base_quantity + getattr(m[0], 'wastage'))\r\n                      for m in\r\n                      materials_list]\r\n\r\n        if period_of_analysis is None:\r\n            pass\r\n        elif period_of_analysis == 0:  # we are forcing recurrent env flows to be zero\r\n            result = [0.]\r\n        elif period_of_analysis > 0 and self.service_life:  # we calculate only the recurrent embodied flows\r\n\r\n            replacements = _get_num_replacements(period_of_analysis, self.service_life)\r\n            result = [ef * replacements for ef in result]\r\n        elif period_of_analysis > 0 and not self.service_life:\r\n            recurrent_results = []\r\n            for embodied_flow, material in zip(result, materials_list):\r\n                try:\r\n                    recurrent_results.append(\r\n                        embodied_flow * _get_num_replacements(period_of_analysis, getattr(material[0], 'service_life')))\r\n                except (ZeroDivisionError, TypeError):  # if the material service life is 0 or None\r\n                    recurrent_results.append(0.)  # no replacement\r\n            result = recurrent_results\r\n\r\n        return sum(result)\r\n\r\n    def _fill_flows_dict(self, period_of_analysis=None, materials_list=None, quantity=None):\r\n        \"\"\"\r\n        Calculates the initial embodied environmental flows for a list of materials\r\n        :param period_of_analysis: the period of analysis in years (int)\r\n        :param materials_list: a list of EPiC materials (list of tuples)\r\n        :param quantity: the quantity of assembly to run the calculation for, use only when calculating by geometry\r\n        \"\"\"\r\n\r\n        if materials_list is None:\r\n            materials_list = self.epic_materials\r\n\r\n        results = copy.deepcopy(self.template_flows)\r\n        for flow_type in results.keys():\r\n            for env_flow in DEFINED_FLOWS.keys():\r\n                setup = {'materials_list': materials_list, 'flow': env_flow, 'quantity': quantity}\r\n                if 'wastage' in flow_type:\r\n                    setup['wastage_only'] = True\r\n                if 'recurrent' in flow_type:\r\n                    if period_of_analysis is None:\r\n                        # set the period of built_assets to zero to force zero recurrent flows\r\n                        setup['period_of_analysis'] = 0\r\n                    else:\r\n                        setup['period_of_analysis'] = period_of_analysis\r\n\r\n                if 'life' not in flow_type:\r\n                    results[flow_type][env_flow] = self._calculate_flows(**setup)\r\n                else:\r\n                    if 'wastage' in flow_type:\r\n                        initial = results['initial_wastage'][env_flow]\r\n                        recurrent = results['recurrent_wastage'][env_flow]\r\n                    else:\r\n                        initial = results['initial'][env_flow]\r\n                        recurrent = results['recurrent'][env_flow]\r\n\r\n                    results[flow_type][env_flow] = initial + recurrent\r\n        return results\r\n\r\n    def calculate_flows(self, period_of_analysis=None):\r\n        \"\"\"\r\n        Calculates all flows, at the assembly level, as well as by material and by geometry\r\n        :param period_of_analysis: The period of built_assets used for the calculation of environmental flows\r\n        :return: a dictionary, that follows the template dictionary\r\n        \"\"\"\r\n        result = self._fill_flows_dict(period_of_analysis)\r\n\r\n        # calculate the same by material\r\n        result['by_material'] = {}\r\n        for material, quantity in self.epic_materials:\r\n            mat_name = material.name\r\n            by_material = self._fill_flows_dict(period_of_analysis, materials_list=[[material, quantity]])\r\n            if mat_name not in result['by_material']:\r\n                by_material.update([('quantity', quantity), ('material_object', material), ('material_name', mat_name)])\r\n            else:\r\n                # Merge together any materials that have the same name\r\n                by_material = sum_numerical_dictionary_values(result['by_material'][mat_name], by_material)\r\n                by_material['quantity'] += quantity\r\n                if by_material['material_object'].material_id == material.material_id:\r\n                    pass\r\n                else:\r\n                    raise ValueError(\"Mismatched material name in 'by_material' calculation\")\r\n            result['by_material'][mat_name] = by_material\r\n        return result\r\n\r\n    def print_report(self, initial_flow=True, assembly_part_details=True, print_as_str=False):\r\n        \"\"\"\r\n        Print a report for the Assembly with all of the flow and material values & metadata\r\n        :param initial_flow: Specify if this is the initial flow\r\n        :param assembly_part_details: Provide details on the different geometry in the assembly\r\n        :param print_as_str: returns the results as a string\r\n        :return: string (if print_as_str=True), otherwise a list\r\n        \"\"\"\r\n\r\n        assembly_units_dict = {\r\n            'm³': ['Total volume: ', 'Number of volumes (parts): ', 'Volume: '],\r\n            'm²': ['Total area: ', 'Number of surfaces (parts): ', 'Area: '],\r\n            'm': ['Total linear meters: ', 'Number of lines/curves (parts): ', 'Linear meters: '],\r\n            'no.': ['Total number of units: ', 'Number of units (parts): ', 'Units: '],\r\n        }\r\n\r\n        mat_attributes = []\r\n        assembly_attributes = []\r\n        assembly_attributes.append('<< {} >>'.format(self.name))\r\n        selected_geometry_count = str(len(self.selected_geometry))\r\n        unit = self.assembly_units\r\n\r\n        assembly_attributes.append(assembly_units_dict[unit][0] + str(self.total_units) + unit)\r\n        if unit != 'no.':\r\n            assembly_attributes.append(assembly_units_dict[unit][1] + selected_geometry_count)\r\n\r\n        if self.wastage_override:\r\n            assembly_attributes.append('Wastage override: {}%'.format(str(self.wastage_override * 100)))\r\n\r\n        if self.service_life:\r\n            assembly_attributes.append('Service Life override: {} years'.format(str(self.service_life)))\r\n\r\n        if self.comments:\r\n            assembly_attributes.append('Comments: {}'.format(str(self.comments)))\r\n        assembly_attributes.append('')\r\n\r\n        if initial_flow is True:\r\n            results_dict = self.flows\r\n        else:\r\n            results_dict = self.recalculated_flows\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            if results_dict['recurrent'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '{}: {}'.format(\r\n                        'Life cycle embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow][\r\n                            'unit'] + ')',\r\n                        results_dict['life_cycle'][flow]))\r\n                if results_dict['life_cycle_wastage'][flow] > 0:\r\n                    assembly_attributes.append(\r\n                        '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                            results_dict['life_cycle_wastage'][flow]))\r\n\r\n            assembly_attributes.append(\r\n                '{}: {}'.format(\r\n                    'Initial embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow]['unit'] + ')',\r\n                    results_dict['initial'][flow]))\r\n\r\n            if results_dict['initial_wastage'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                        results_dict['initial_wastage'][flow]))\r\n\r\n            if results_dict['recurrent'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    'Recurrent embodied ' + DEFINED_FLOWS[flow]['print_name'] + ' (' + DEFINED_FLOWS[flow][\r\n                        'unit'] + '): {}'.format(results_dict['recurrent'][flow]))\r\n            if results_dict['recurrent_wastage'][flow] > 0:\r\n                assembly_attributes.append(\r\n                    '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                        results_dict['recurrent_wastage'][flow]))\r\n            assembly_attributes.append('')\r\n\r\n        assembly_attributes.append('Materials in assembly: {}'.format(str(len(self.epic_materials))))\r\n\r\n        for mat_num, mat in enumerate(self.epic_materials):\r\n            assembly_attributes.append('Material {}: {}'.format(mat_num + 1, mat[0].name))\r\n            assembly_attributes.append(\r\n                '--- Qty: {}{} / {}'.format(mat[1], mat[0].functional_unit, self.assembly_units))\r\n            assembly_attributes.append(\r\n                '--- Total: {}{}'.format(mat[1] * self.total_units, mat[0].functional_unit))\r\n\r\n        mat_attributes.append(assembly_attributes)\r\n\r\n        if assembly_part_details is True:\r\n            if self.assembly_units != 'no.':\r\n                for num, geom in enumerate(self.selected_geometry):\r\n                    part_attributes = list()\r\n                    part_attributes.append('')\r\n                    part_attributes.append(\r\n                        'Assembly Part {} of {}'.format(str(num + 1), selected_geometry_count))\r\n                    if isinstance(geom, (int, float)):\r\n                        part_units = geom\r\n                    else:\r\n                        if self.assembly_units == 'm²':\r\n                            part_units = ghcomponents.Area(geom)[0]\r\n                        elif self.assembly_units == 'm³':\r\n                            part_units = ghcomponents.Volume(geom)[0]\r\n                        elif self.assembly_units == 'm':\r\n                            part_units = ghcomponents.Length(geom)\r\n\r\n                    part_attributes.append(assembly_units_dict[unit][2] + str(part_units) + self.assembly_units)\r\n                    mat_attributes.append(part_attributes)\r\n\r\n        if print_as_str:\r\n            print_str = []\r\n            for mat in mat_attributes:\r\n                print_str.append('\\n'.join(mat))\r\n            print_str = '\\n'.join(print_str)\r\n            return print_str\r\n\r\n        return mat_attributes\r\n\r\n    @staticmethod\r\n    def create_list_of_input_materials_and_qty(component, units, args):\r\n        \"\"\"\r\n        Create a list of input materials and their quantity. Only create an extry when there is valid data for both.\r\n        :param component: Base component to modify\r\n        :param units: Functional unit used for component\r\n        :param args: Arguments to iterate through\r\n        :return: A nested list containing each material and quantity [[mat, qty], [mat, qty]]\r\n        \"\"\"\r\n        material_list = []\r\n        for num, arg in enumerate(args):  # Make a list of all the valid materials and material quantities\r\n\r\n            # Handle list values passed from component. Only use first list item\r\n            #todo develop cleaner way to deal with list items, rather than using try except\r\n            try:\r\n                arg = arg[0]\r\n            except:\r\n                pass\r\n\r\n            # todo changing the NickName with Rhino 8 will break the component. Future fix.\r\n            if (num + 2) % 2 == 0:\r\n                if arg and 'functional_unit' in dir(arg):  # Check if material has the attribute (functional unit). Will return False for a number or string\r\n                    material = [arg]\r\n                    component.Params.Input[7+num].NickName = component.Params.Input[7+num].Name \\\r\n                        = \"Material: \" + str(arg.name)\r\n                    component.Params.Input[8+num].NickName = component.Params.Input[8+num].Name \\\r\n                        = \"({0} / {1})\".format(arg.functional_unit, units)\r\n                else:\r\n                    material = None\r\n                    component.Params.Input[7 + num].NickName = \"Material \" + str(num/2 + 1)\r\n                    component.Params.Input[8 + num].NickName = \"Material \" + str(num/2 + 1) + \\\r\n                                                               \": Quantity (FU / {0})\".format(units)\r\n            else:\r\n                if arg and material:\r\n                    material_list.append([material, arg])\r\n        return material_list\r\n\r\nclass EPiCAnalysis:\r\n    \"\"\"\r\n        A component that visualises life cycle assessment results and generates CSV reports.\r\n        Uses EPiCAssembly and EPiCBuiltAssets items to generate assessment report.\r\n        \"\"\"\r\n\r\n    def __str__(self):\r\n        return self.print_report()\r\n\r\n    def __init__(self, name='EPiCAnalysis', epic_assemblies=None, period_of_analysis=100,\r\n                 graph_origin=(0, 0, 0), analysis_type='total', sort_graph=True, graph_scale=1, generate_graph=True,\r\n                 comments=''):\r\n        \"\"\"\r\n        :param name: Name of the built_assets\r\n        :param epic_assemblies: A single, or multiple EPiCAssembly items. These are used to calculate the assessment.\r\n        :param period_of_analysis: The period of time (in years) used for the life cycle assessment\r\n        :param graph_origin: Origin point for the graph visualisation element. defaults to (0, 0, 0)\r\n        :param analysis_type: Type of built_assets to conduct ('total', 'by_smaterial' OR 'by assembly')\r\n        :param sort_graph: Specifies if the graph should be sorted from highest value to lowest. True/False.\r\n        :param graph_scale: Scale of the graph visualisation. 1=normal size 0.5=half size 2=double size\r\n        :param generate_graph: Specifies if a graph visualisation should be generated. True/False.\r\n        :param comments: Comments will be shown the in report .csv.\r\n        \"\"\"\r\n\r\n        # Set attributes and variables\r\n        self.component_type = 'EPiCAnalysis'\r\n        self.name = remove_commas_and_flatten_list_for_csv_export(name) if name else 'EPiCAnalysis'\r\n        self.comments = remove_commas_and_flatten_list_for_csv_export(comments) if comments else ''\r\n        self.period_of_analysis = period_of_analysis\r\n\r\n        list_of_assembly_names = []\r\n\r\n        # Code to enable built_assets for built_assets / comparison of multiple assemblies.\r\n        built_asset_objects = [x for x in epic_assemblies if x.component_type == 'EPiCBuiltAsset'\r\n                               or x.component_type == 'EPiCAnalysis']\r\n\r\n        epic_assemblies = [x for x in epic_assemblies if x.component_type == 'EPiCAssembly']\r\n\r\n        if built_asset_objects:\r\n            for asset in built_asset_objects:\r\n                epic_assemblies += asset.epic_assemblies\r\n\r\n        self.epic_assemblies = epic_assemblies\r\n\r\n        # Create a list of all of the materials (and qty) in the Analysis component\r\n        self.epic_materials = [(y[0], y[1] * x.total_units) for x in epic_assemblies for y in x.epic_materials if x]\r\n\r\n        # Recalculate the flows, based on the period of analysis\r\n        for assembly in epic_assemblies:\r\n            assembly.recalculated_flows = assembly.calculate_flows(period_of_analysis)\r\n\r\n        for assembly in epic_assemblies:\r\n            list_of_assembly_names.append(assembly.name)\r\n\r\n        self.flows = self.sum_by_assembly_and_material()\r\n\r\n        # Generate a graph element if this is set to true.\r\n        if generate_graph:\r\n            if built_asset_objects:\r\n                self.graph_visualisations = EPiCGraph(built_asset_objects, graph_origin=graph_origin,\r\n                                                      analysis_type=analysis_type,\r\n                                                      sort_graph=sort_graph, graph_scale=graph_scale)\r\n            else:\r\n                self.graph_visualisations = EPiCGraph(self, graph_origin=graph_origin, analysis_type=analysis_type,\r\n                                                      sort_graph=sort_graph, graph_scale=graph_scale)\r\n            self.elements_to_render = self.graph_visualisations.elements_to_render\r\n        else:\r\n            self.graph_visualisations = None\r\n            self.elements_to_render = None\r\n\r\n    @staticmethod\r\n    def process_inputs(epic_inputs, analysis_type='total', graph_origin=(0, 0, 0), graph_scale=1,\r\n                       period_of_analysis=None, report_name='EPiC Analysis',\r\n                       epic_assemblies_name='Assembly Collection'):\r\n        \"\"\"\r\n        :param epic_inputs: Inputs - either EPiC_Assembly and/or EPiC_Built_Asset components\r\n        :param analysis_type: Type of built_assets to be used for graph visualisations. 'total', 'by_material',\r\n        'by_assembly', or 'by_assembly_and_material'\r\n        :param graph_origin: Origin point for the graph. Defaults to (0, 0, 0)\r\n        :param graph_scale: Graph scale. 1=Default scale\r\n        :param period_of_analysis: The period of built_assets to be used for calculations.\r\n        Default value of None - indicating that no recurrent calculations will be made.\r\n        :param report_name: Name for the Analysis Report\r\n        :param epic_assemblies_name: Default name for a group of EPiCAssembly inputs\r\n        :return:\r\n        epic_analysis - an EPiCAnalysis class instance\r\n        epic_inputs - sorted list of inputs\r\n        \"\"\"\r\n\r\n        # Set default values for the variables\r\n        graph_origin = (0, 0, 0) if not graph_origin else graph_origin\r\n        graph_scale = 1 if not graph_scale else graph_scale\r\n        analysis_type = 'total' if not analysis_type else analysis_type\r\n\r\n        # Initialise variables\r\n        epic_analysis = None\r\n        _epic_analyses = []\r\n\r\n        # Remove null values from input list\r\n        epic_inputs = [x for x in epic_inputs if x]\r\n\r\n        # Clean the epic_inputs list, and separate EPiCAssembly and EPiCBuiltAsset items for built_assets\r\n        epic_inputs = [x for x in epic_inputs if x.component_type == 'EPiCAssembly'\r\n                       or x.component_type == 'EPiCBuiltAsset']\r\n        epic_assemblies = [x for x in epic_inputs if x.component_type == 'EPiCAssembly']\r\n        built_assets = [x for x in epic_inputs if x.component_type == 'EPiCBuiltAsset']\r\n\r\n        if built_assets:\r\n            for built_asset in built_assets:\r\n                _epic_analyses.append(EPiCAnalysis(built_asset.name,\r\n                                                   [built_asset],\r\n                                                   period_of_analysis, graph_origin=graph_origin,\r\n                                                   analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                                   generate_graph=False))\r\n        if epic_assemblies:\r\n            _epic_analyses.append(EPiCAnalysis(epic_assemblies_name,\r\n                                               epic_assemblies,\r\n                                               period_of_analysis, graph_origin=graph_origin,\r\n                                               analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                               generate_graph=False))\r\n        if _epic_analyses:\r\n            epic_analysis = EPiCAnalysis(report_name,\r\n                                         _epic_analyses,\r\n                                         period_of_analysis, graph_origin=graph_origin,\r\n                                         analysis_type=analysis_type, graph_scale=graph_scale,\r\n                                         generate_graph=True)\r\n        return epic_analysis, epic_inputs\r\n\r\n    # Region baking\r\n    # TODO: Fix colouring for baked objects\r\n    def BakeGeometry(self, doc, att, id):\r\n        id = Guid.Empty\r\n        if self.elements_to_render is None:\r\n            return False, id\r\n\r\n        if att is None:\r\n            att = doc.CreateDefaultAttributes()\r\n\r\n        if self.elements_to_render:\r\n            for graph_element in self.elements_to_render:\r\n\r\n                # Bake legend lines\r\n                if isinstance(graph_element, Geometry.Line):\r\n                    doc.Objects.AddLine(graph_element, att)\r\n\r\n                # Bake graph text\r\n                elif isinstance(graph_element, EPiCVisualisations.EPiCText):\r\n                    if graph_element.m_value is None:\r\n                        pass\r\n                    else:\r\n                        doc.Objects.AddText(graph_element.m_value, att)\r\n\r\n                # Bake graph columns\r\n                elif isinstance(graph_element, EPiCVisualisations.GraphSegmentGeometry):\r\n                    doc.Objects.AddRectangle(graph_element.m_value, att)\r\n                    att.ObjectColor = graph_element.fill_colour\r\n                    doc.Objects.AddHatch(graph_element.fill, att)\r\n\r\n        id = doc.Objects\r\n        return True, id\r\n\r\n    def sum_by_assembly_and_material(self):\r\n        \"\"\"\r\n        Sums all flows by assembly and material\r\n        :return:a dictionary, containing the same keys as the flows dictionary in an assembly and materials\r\n        \"\"\"\r\n        result = OrderedDict()\r\n\r\n        for assembly in self.epic_assemblies:\r\n            self._sum_by_assembly_and_material(result, assembly.recalculated_flows,\r\n                                               by_material=True,\r\n                                               assembly=assembly)\r\n\r\n            # create the 'by_assembly' dictionary. This will contain a nested 'by_material' dict\r\n            if 'by_assembly' not in result:\r\n                result['by_assembly'] = dict()\r\n            if assembly.category not in result['by_assembly']:\r\n                result['by_assembly'][assembly.category] = dict()\r\n            self._sum_by_assembly_and_material(result['by_assembly'][assembly.category], assembly.recalculated_flows,\r\n                                               by_material=True)\r\n\r\n        return result\r\n\r\n    def fetch_geometry_as_list(self):\r\n        \"\"\"\r\n        Compiles a list of all geometries contained within each EPiC Assembly and EPiC Built Assets\r\n        :return: a list of geometries\r\n        \"\"\"\r\n\r\n        # Exclude numbers from geometry output and change to datatree structure\r\n        return list_to_datatree([[x for x in assembly.output_geometry if not isinstance(x, (float, int))]\r\n                                 for assembly in self.epic_assemblies])\r\n\r\n    def _sum_by_assembly_and_material(self, final_dict_result, iterative_dict_result,\r\n                                      by_material=False, assembly=False):\r\n        \"\"\"\r\n        Recursive method to move within nested dicts and calculate the sum\r\n        :param final_dict_result: The final dictionary result\r\n        :param iterative_dict_result: The iterative dictionary result\r\n        :param by_material: if True, iterate through the by_material dictionary\r\n        :param assembly: An EPiCAssembly item to get materials from\r\n        \"\"\"\r\n        for k, v in iterative_dict_result.items():\r\n\r\n            if isinstance(v, dict) or isinstance(v, OrderedDict):\r\n                if k == 'by_material':\r\n                    if by_material:\r\n                        self._sum_by_assembly_and_material(final_dict_result.setdefault(k, dict()), v,\r\n                                                           by_material=True, assembly=assembly)\r\n                else:\r\n                    # Create a new 'by_assembly' dictionary nested within each material dictionary and populate\r\n                    self._sum_by_assembly_and_material(final_dict_result.setdefault(k, dict()), v)\r\n                    if assembly and by_material:\r\n                        if len(assembly.epic_materials) > 0:\r\n                            if k in [mat[0].name for mat in assembly.epic_materials]:\r\n                                if 'by_assembly' not in final_dict_result[k]:\r\n                                    final_dict_result[k]['by_assembly'] = dict()\r\n                                if assembly.name not in final_dict_result[k]['by_assembly']:\r\n                                    final_dict_result[k]['by_assembly'][assembly.name] = dict()\r\n                                self._sum_by_assembly_and_material(\r\n                                    final_dict_result[k]['by_assembly'][assembly.name], v)\r\n\r\n\r\n            elif isinstance(v, float):\r\n                final_dict_result[k] = final_dict_result.get(k, 0) + v\r\n\r\n            elif isinstance(v, str):  # for material column_group_name\r\n                if k in final_dict_result:\r\n                    if not final_dict_result[k] == v:\r\n                        final_dict_result[k] = final_dict_result.get(k, '') + '/' + v\r\n                else:\r\n                    final_dict_result[k] = v\r\n            else:  # for EPiCMaterial object file\r\n                final_dict_result[k] = v\r\n\r\n    def generate_analysis_breakdown_for_outputs(self, analysis_type='total'):\r\n        \"\"\"\r\n        Generate outputs for the EPiCAnalysis component based on the built_assets type\r\n        :param analysis_type: Type of built_assets used ('total,'by_material' OR 'by_assembly')\r\n        :return: list of outputs for the EPiCAnalysis component\r\n        \"\"\"\r\n        results_list = []\r\n        output_keys = []\r\n\r\n        if not analysis_type:\r\n            analysis_type = 'total'\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            results_list.append(None)\r\n            for flow_type in self.flows.keys():\r\n                if flow_type != 'by_material' and flow_type != 'by_assembly':\r\n                    if analysis_type == 'by_assembly_and_material':\r\n                        _mats = set([y for x in self.flows['by_assembly'].values() for y in x['by_material'].keys()])\r\n                        _assemblies = self.flows['by_assembly'].keys()\r\n                        nested_list = []\r\n                        output_keys = []\r\n                        for key, assembly in self.flows['by_assembly'].items():\r\n                            _assembly_container = []\r\n                            mat_keys = []\r\n                            for mat in _mats:\r\n                                mat_keys.append(str(key) + ': ' + mat)\r\n                                if mat in assembly['by_material']:\r\n                                    _assembly_container.append(assembly['by_material'][mat][flow_type][flow])\r\n                                else:\r\n                                    _assembly_container.append(0)\r\n                            nested_list.append(_assembly_container)\r\n                            output_keys.append(mat_keys)\r\n                        results_list.append(list_to_datatree(nested_list))\r\n                        output_keys = list_to_datatree(output_keys)\r\n                    elif analysis_type == 'by_assembly':\r\n                        results_list.append([x[flow_type][flow] for x in self.flows['by_assembly'].values()])\r\n                        output_keys = self.flows['by_assembly'].keys()\r\n                    elif analysis_type == 'by_material':\r\n                        results_list.append([x[flow_type][flow] for x in self.flows['by_material'].values()])\r\n                        output_keys = self.flows['by_material'].keys()\r\n                    elif analysis_type == 'total':\r\n                        results_list.append(self.flows[flow_type][flow])\r\n                        output_keys = 'total'\r\n\r\n        return [self, self.elements_to_render, output_keys] + results_list + [None] + [self.fetch_geometry_as_list()]\r\n\r\n    def print_report(self):\r\n        \"\"\"\r\n        Print all EPiCAssembly inputs/outputs and results of the life cycle assessment calculation\r\n        :return: A string with all of the report results\r\n        \"\"\"\r\n\r\n        report_writer = []\r\n        temp_report = []\r\n        for assembly in self.epic_assemblies:\r\n            if self.period_of_analysis:\r\n                pass\r\n            else:\r\n                self.period_of_analysis = None\r\n            assembly.recalculated_flows = assembly.calculate_flows(self.period_of_analysis)\r\n        temp_report.append('<<<' + str(self.name) + '>>>')\r\n        if isinstance(self, EPiCBuiltAsset):\r\n            temp_report.append('Built Asset')\r\n        else:\r\n            temp_report.append('Assessment duration: {} years'.format(self.period_of_analysis))\r\n        temp_report.append('Number of Assemblies: {}'.format(len(self.epic_assemblies)))\r\n\r\n        for flow in DEFINED_FLOWS.keys():\r\n            temp_report.append('Total embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['life_cycle'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['life_cycle_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n            temp_report.append('Initial embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['initial'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['initial_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n            temp_report.append('Recurrent embodied ' + flow + ' (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                sum([x.recalculated_flows['recurrent'][flow] for x in self.epic_assemblies])))\r\n            temp_report.append(\r\n                '--- of which wastage (' + DEFINED_FLOWS[flow]['unit'] + '): {}'.format(\r\n                    sum([x.recalculated_flows['recurrent_wastage'][flow] for x in self.epic_assemblies])))\r\n\r\n        report_writer.append(temp_report)\r\n\r\n        for num, assembly in enumerate(self.epic_assemblies):\r\n            temp_report = assembly.print_report(assembly_part_details=False, initial_flow=False)[0]\r\n            report_writer.append(temp_report)\r\n\r\n        # Return string value\r\n        print_str = []\r\n        for report in report_writer:\r\n            print_str.append('\\n'.join(report))\r\n        return '\\n'.join(print_str)\r\n\r\n\r\nclass EPiCBuiltAsset(EPiCAnalysis):\r\n    \"\"\"\r\n    A single built asset containing multiple EPiCAssembly items\r\n    \"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        EPiCAnalysis.__init__(self, *args, **kwargs)\r\n        self.period_of_analysis = 0\r\n        self.component_type = 'EPiCBuiltAsset'\r\n\r\n\r\nclass EPiCBreakdown:\r\n    \"\"\"\r\n    Enables breaking down embodied environmental flows into their shares of process data and input-output data.\r\n    Works on EPiC Material, EPiC Assembly, EPiC Built Asset and EPiC Analysis - (only on the total).\r\n    \"\"\"\r\n\r\n    def __init__(self, epic_entity):\r\n        if isinstance(epic_entity, (EPiCMaterial, EPiCAssembly, EPiCBuiltAsset, EPiCAnalysis)):\r\n            self.epic_entity = epic_entity\r\n            self.breakdown_dict = copy.deepcopy(HYBRID_VALUE_BREAKDOWN_DICT)\r\n        else:\r\n            raise TypeError(\r\n                'You can only breakdown the embodied environmental flows of an EPiCMaterial, EPiCAssembly, EPiCBuiltAsset and EPiCAnalysis')\r\n\r\n    def breakdown_embodied_flows(self):\r\n        \"\"\"\r\n        Breaks down the embodied environmental flows of the EPiC entity into its process and input-output components\r\n        :return: the populated breakdown dict\r\n        \"\"\"\r\n        return self.epic_entity.generate_breakdown_dict()\r\n\r\n\r\nclass EPiCDatabase:\r\n    \"\"\"\r\n    Provides access to the EPiCDatabase through the use of queries. Data is held as a class attribute (database)\r\n    \"\"\"\r\n\r\n    database = {}\r\n\r\n    def __init__(self, local_directory=None):\r\n        self.component_type = 'EPiCDatabase'\r\n        self.custom_database = None\r\n\r\n        if not self.database:\r\n            if local_directory:\r\n                with open(local_directory + os.sep + r'EPiC Grasshopper' + os.sep + PICKLE_DB, 'rb') as f:\r\n                    self.database = cPickle.load(f)\r\n\r\n        # Load set of categories in the database\r\n\r\n        self.categories = EPiCDatabase.get_categories(self.database)\r\n        self.dict_of_categories = EPiCDatabase.get_dict_of_categories(self.database)\r\n        self.dict_of_ids_and_names = {key: self.database[key]['name'] for key in self.database.keys()}\r\n        self.dict_of_legacy_names = {key: self.database[key]['Legacy_names'] for key in self.database.keys()}\r\n\r\n    @staticmethod\r\n    def get_categories(database):\r\n        \"\"\"\r\n        Returns a set containing all categories in the database\r\n        \"\"\"\r\n        return {x['Category'] for x in database.values() if x['Latest_Version']}\r\n\r\n    @staticmethod\r\n    def get_dict_of_categories(database):\r\n        \"\"\"\r\n        Returns a dictionary of categories, which contains a list of mat ids [(mat_id, mat_name), (... , ...)]\r\n        \"\"\"\r\n        # if the class instance already has a set of categories, use that, otherwise create a set\r\n\r\n        if hasattr(database, 'categories'):\r\n            categories = database.categories\r\n\r\n        else:\r\n            categories = EPiCDatabase.get_categories(database)\r\n\r\n        return {category: dict([(id, EPiCMaterial._concatenate_mat_name_func_unit(mat['name'], mat['Functional Unit']))\r\n                for id, mat in database.items() if mat['Category'] == category]) for category in categories}\r\n\r\n    def load_custom_database(self, file_path, file_name):\r\n        \"\"\"\r\n        Load a custom database file\r\n        :param file_path: The full file path directory\r\n        :param file_name: Name of database file\r\n        \"\"\"\r\n\r\n        if file_path and file_name:\r\n            try:\r\n                with open(file_path + r'//' + file_name, 'rb') as f:\r\n                    self.custom_database = cPickle.load(f)\r\n\r\n                    # Overwrite categories\r\n                    self.categories = EPiCDatabase.get_categories(self.custom_database)\r\n                    self.dict_of_categories = EPiCDatabase.get_dict_of_categories(\r\n                        self.custom_database)\r\n                    self.dict_of_ids_and_names = {key: self.custom_database[key]['name']\r\n                                                for key in self.custom_database.keys()}\r\n                    self.dict_of_legacy_names = self.dict_of_ids_and_names\r\n            except:\r\n                self.custom_database = 'Error'\r\n                raise (RuntimeError(\"Couldn't load database from: \" + file_path + r'//' + file_name))\r\n\r\n    def _query_for_name_or_old_mat_id(self, lookup_item):\r\n        \"\"\"\r\n        Lookup material based on name, or legacy name.\r\n        :param lookup_item: Name of the material to lookup\r\n        :return: material ID as string\r\n        \"\"\"\r\n        lookup_item = str(lookup_item)\r\n\r\n        # Remove decoration from material name (if it exists)\r\n        if '|' in lookup_item:\r\n            lookup_item = EPiCMaterial.remove_func_unit_from_mat_name(lookup_item)\r\n\r\n        # Search in the list of material names followed by a search of legacy names\r\n        if lookup_item in self.dict_of_ids_and_names.values():\r\n            return [key for key, value in self.dict_of_ids_and_names.items() if lookup_item == value][0]\r\n        elif lookup_item in self.dict_of_legacy_names.values():\r\n            return [key for key, value in self.dict_of_legacy_names.items() if lookup_item == value][0]\r\n        return None\r\n\r\n    def query(self, material_id, material_attributes=None):\r\n        \"\"\"\r\n        Query the EPiC Database using a material name & optional attribute\r\n        :param material_id: ID of the material S-String, I-Integer Region(SS)Year(IIII)Cat(SS)Material(III)Variation(II)\r\n        :param material_attributes: Name of the attribute to return (e.g DOI, Functional Unit), or list of attributes\r\n        :return: material dictionary OR material attribute (if specified)\r\n        \"\"\"\r\n        query = None\r\n        # Use the default database unless a custom database has been provided\r\n        database = self.database if not self.custom_database else self.custom_database\r\n\r\n        try:\r\n            _ = database[material_id]\r\n        except KeyError:\r\n            material_id = self._query_for_name_or_old_mat_id(material_id)\r\n\r\n        if material_attributes is None:\r\n            try:\r\n                query = database[material_id]\r\n            except KeyError:\r\n                raise TypeError('Material not found')\r\n\r\n        else:\r\n            try:\r\n                if isinstance(material_attributes, list):\r\n                    # if an attribute doesn't exist, return None for that list item\r\n                    query = [database[material_id][attribute] if attribute in database[material_id]\r\n                             else 'None'\r\n                             for attribute in material_attributes]\r\n                else:\r\n                    query = database[material_id][material_attributes]\r\n            except KeyError:\r\n                raise TypeError('Material or material attribute not found')\r\n\r\n        # Return None if there are no results\r\n        if not isinstance(query, list):\r\n            if isnan(query):\r\n                return None\r\n            else:\r\n                return query\r\n        else:\r\n            # Remove nan values from the results and return\r\n            return [x if not isnan(x) else None for x in query]\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}