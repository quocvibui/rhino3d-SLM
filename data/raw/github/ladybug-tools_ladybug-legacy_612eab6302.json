{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_SolarEnvelopeBasic.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_SolarEnvelopeBasic.py",
  "instruction": "Use this component to generate a solar envelope for a closed boundary curve with minimum inputs. This component predefines monthly and hourly ranges in order to simplify the creation of useful...",
  "code": "#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Saeran Vasanthakumar <saeranv@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate a solar envelope for a closed boundary curve with minimum inputs. This component predefines monthly and hourly ranges in order to simplify the creation of useful envelope geometry.  \nThe solar envelope is used to ensure that its adjacent neighbors (defined as anything outside of the chosen boundary curve) will receive a specified minimum hours of direct solar access for each day in a specified month range of the year.\nAny geometry built within the solar envelope boundaries will therefore not cast any shadow on adjacent property for the given hour and month range.\n \nThe start and end dates that determine the month range for solar access can be chosen from the following options:\n0) Mar 21 - Jun 21\n1) Mar 21 - Sep 21\n2) Mar 21 - Dec 21\n3) Jun 21 - Sep 21\n4) Jun 21 - Dec 21\n5) Sep 21 - Dec 21\nThe default set to 4) June 21 to December 21.\n\nReference: Niemasz, J., Sargent, J., Reinhart D.F., \"Solar Zoning and Energy in \nDetached Residential Dwellings,\" Proceedings of SIMAUD 2011, Boston, April 2011.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _boundary: A closed boundary curve representing a piece of land (such as a property to be developed) for which solar access of the surrounding land is desired.\n        _location: The output from the importEPW or constructLocation component.  This is essentially a list of text summarizing a location on the earth.\n        _requiredHours: The number of hours of direct solar access that the property surrounding the boundary curve should receive during the _monthRange. For example an input of 4 will define the hour range roughly between 10AM and 2PM. The component will compute the hour range that will maximize the envelope volume.        \n        north_: Input a vector to be used as a true North direction or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n        _monthRange: An optional interger value to change the month range for which solar access is being considered. The default month range is Jun 21 - Dec 21.\n            Integers input here must be between 0 - 5 and correspond to the following :\n            ---\n            0 = Mar 21 - Jun 21\n            1 = Mar 21 - Sep 21\n            2 = Mar 21 - Dec 21\n            3 = Jun 21 - Sep 21\n            4 = Jun 21 - Dec 21\n            5 = Sep 21 - Dec 21\n            ---\n            Where, in the North/South Hemispheres, these dates repsectively signify: \n                Mar 21 = Vernal/Autumnal Equinox\n                Jun 21 = Summer/Winter Solstice\n                Sep 21 = Autumnal/Vernal Equinox\n                Dec 21 = Winter/Summer Solstice\n \n    Returns:\n        solarEnvelope: A Brep representing a solar envelope.  This volume should be built within in order to ensure that the surrounding property is not shaded for the given number of hours.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_SolarEnvelopeBasic\"\nghenv.Component.NickName = 'SolarEnvelopeBasic'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\n\nimport math\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport Rhino.Geometry as rc\nimport scriptcontext as sc\nimport datetime\nimport Grasshopper.Kernel as gh\n\nclass SunCalculation:\n    \"\"\" \n    Modified from: http://michelanders.blogspot.ca/2010/12/calulating-sunrise-and-sunset-in-python.html\n    Calculate sunrise and sunset based on equations from NOAA\n    http://www.srrb.noaa.gov/highlights/sunrise/calcdetails.html\n    \"\"\"\n    def __init__(self,lat,long): # default Amsterdam\n        self.lat=lat\n        self.long=long\n  \n    def sunrise(self,when):\n        \"\"\"\n        return the time of sunrise as a datetime.time object\n        when is a datetime.datetime object. If none is given\n        a local time zone is assumed (including daylight saving\n        if present)\n        \"\"\"\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.sunrise_t)\n  \n    def sunset(self,when):\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.sunset_t)\n  \n    def solarnoon(self,when):\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.solarnoon_t)\n  \n    @staticmethod\n    def __timefromdecimalday(day):\n        \"\"\"\n        returns a datetime.time object.\n  \n        day is a decimal day between 0.0 and 1.0, e.g. noon = 0.5\n        \"\"\"\n        hours  = 24.0*day\n        h = int(hours)\n        minutes = (hours-h)*60\n        m = int(minutes)\n        seconds = (minutes-m)*60\n        s = int(seconds)\n        return datetime.time(hour=h,minute=m,second=s)\n\n    def __preptime(self,when):\n        \"\"\"\n        Extract information in a suitable format from when, \n        a datetime.datetime object.\n        \"\"\"\n        # datetime days are numbered in the Gregorian calendar\n        # while the calculations from NOAA are distibuted as\n        # OpenOffice spreadsheets with days numbered from\n        # 1/1/1900. The difference are those numbers taken for \n        # 18/12/2010\n        self.day = when.toordinal()-(734124-40529)\n        t=when.time()\n        self.time= (t.hour + t.minute/60.0 + t.second/3600.0)/24.0\n  \n        self.timezone=0\n        offset=when.utcoffset()\n        if not offset is None:\n            self.timezone=offset.seconds/3600.0 + (offset.days * 24)\n  \n    def __calc(self):\n        \"\"\"\n        Perform the actual calculations for sunrise, sunset and\n        a number of related quantities.\n  \n        The results are stored in the instance variables\n        sunrise_t, sunset_t and solarnoon_t\n        \"\"\"\n        timezone = self.timezone # in hours, east is positive\n        longitude= self.long     # in decimal degrees, east is positive\n        latitude = self.lat      # in decimal degrees, north is positive\n\n        time = self.time # percentage past midnight, i.e. noon  is 0.5\n        day = self.day     # daynumber 1=1/1/1900\n \n        Jday = day+2415018.5+time-timezone/24 # Julian day\n        Jcent =(Jday-2451545)/36525 # Julian century\n\n        Manom = 357.52911+Jcent*(35999.05029-0.0001537*Jcent)\n        Mlong = 280.46646+Jcent*(36000.76983+Jcent*0.0003032)%360\n        Eccent = 0.016708634-Jcent*(0.000042037+0.0001537*Jcent)\n        Mobliq = 23+(26+((21.448-Jcent*(46.815+Jcent*(0.00059-Jcent*0.001813))))/60)/60\n        obliq = Mobliq+0.00256*math.cos(math.radians(125.04-1934.136*Jcent))\n        vary = math.tan(math.radians(obliq/2))*math.tan(math.radians(obliq/2))\n        Seqcent = math.sin(math.radians(Manom))*(1.914602-Jcent*(0.004817+0.000014*Jcent))+math.sin(math.radians(2*Manom))*(0.019993-0.000101*Jcent)+math.sin(math.radians(3*Manom))*0.000289\n        Struelong = Mlong+Seqcent\n        Sapplong = Struelong-0.00569-0.00478*math.sin(math.radians(125.04-1934.136*Jcent))\n        declination = math.degrees(math.asin(math.sin(math.radians(obliq))*math.sin(math.radians(Sapplong))))\n  \n        eqtime = 4*math.degrees(vary*math.sin(2*math.radians(Mlong))-2*Eccent*math.sin(math.radians(Manom))+4*Eccent*vary*math.sin(math.radians(Manom))*math.cos(2*math.radians(Mlong))-0.5*vary*vary*math.sin(4*math.radians(Mlong))-1.25*Eccent*Eccent*math.sin(2*math.radians(Manom)))\n\n        #hourangle= math.degrees(math.acos(math.cos(math.radians(90.833))/(math.cos(math.radians(latitude))*math.cos(math.radians(declination)))-math.tan(math.radians(latitude))*math.tan(math.radians(declination))))\n\n        self.solarnoon_t=(720-4*longitude-eqtime+timezone*60)/1440\n        #self.sunrise_t  =self.solarnoon_t-hourangle*4/1440\n        #self.sunset_t   =self.solarnoon_t+hourangle*4/1440\n\n# -----------------------------------------------------------\n\ndef clean_curve(b):\n    \"\"\"Clean curve geometry\n        1. Checks if guid or object\n        2. Simplifiebs\n        3. Reverse curve dirn\n        4. Closes curve if not already closed\n    \"\"\"\n    if type(b) == type(rs.AddPoint(0,0,0)): # already guid\n        pass\n    else:\n        b = sc.doc.Objects.AddCurve(b)\n    rs.SimplifyCurve(b)\n    # reverse curve direction\n    boundarybrep = rs.coercecurve(b)\n    Rhino.Geometry.Curve.Reverse(boundarybrep)\n    sc.doc.Objects.Replace(b,boundarybrep)\n    if rs.IsCurveClosed(b):\n        return b\n    else:\n        return rs.CloseCurve(b)\n\ndef get_max_side(b_):\n    \"\"\"\n    get_max: curve -> float\n    Consumes boundary curve, and returns maximum \n    bounding curve dimension\n    \"\"\"\n    bbpts = rs.BoundingBox(b_)[:4]\n    bbpt1 = bbpts.pop(0)\n    max = 0\n    for bbpt in bbpts:\n        dist = rs.Distance(bbpt1,bbpt)\n        if max < dist: max = dist\n    return max\n\ndef extrude_solid(pt,cp,b):\n    # int_solid: (listof pt) pt curve -> (listof solid)\n    lo_solid = []\n    ptlst = rs.CurvePoints(b)\n    srf = rs.AddPlanarSrf(rs.AddCurve(ptlst,1))\n    # make curve and extrude\n    line = rs.AddCurve([cp,pt],1)\n\n    max = get_max_side(b)\n    curve = rs.ExtendCurveLength(line,0,1,max*2)\n    #extrude surface\n    brep = rs.coercebrep(srf, True)\n    curve = rs.coercecurve(curve, -1, True)\n    newbrep = brep.Faces[0].CreateExtrusion(curve, True)\n    if newbrep:\n        rc = sc.doc.Objects.AddBrep(newbrep)\n        sc.doc.Views.Redraw()\n        return rc\n\ndef bool_solids(los):\n    env = los.pop(0)\n    for s in los:\n        e = rs.BooleanIntersection(env,s,True)\n        env = e\n    return env\n\ndef make_zone(pts, bound):\n    # make_zone: (listof pt), curve -> (listof solid) \n    los = []\n    # get centroid from boundary curve\n    center_pt = rs.CurveAreaCentroid(bound)[0]\n    # extrude solids from sun path\n    for p in pts:\n        line = rs.AddCurve([center_pt,p],1)\n        extruded = extrude_solid(p,center_pt,bound)\n        los.append(extruded)\n    # boolean interesect all\n    los_ = map(lambda g: rs.coercegeometry(g),los)\n    return bool_solids(los)\n\ndef get_solar_noon(month,year,tz,d,lat,lon):\n    \"\"\"get_solarnoon: month -> solarnoon \"\"\" \n    date = datetime.datetime(year,month,d)\n    SC = SunCalculation(lat,lon)\n    snoon = SC.solarnoon(date)\n    #print 'solar noon', snoon.hour + tz + snoon.minute/60.0\n    return snoon.hour + tz + snoon.minute/60.0\n\ndef readLocation(location):\n    \"\"\"From Ladybug\"\"\"\n    locationStr = location.split('\\n')\n    newLocStr = \"\"\n    #clean the idf file\n    for line in locationStr:\n        if '!' in line:\n            line = line.split('!')[0]\n            newLocStr  = newLocStr + line.replace(\" \", \"\")\n        else:\n            newLocStr  = newLocStr + line\n    newLocStr = newLocStr.replace(';', \"\")\n    site, locationName, latitude, longitude, timeZone, elevation = newLocStr.split(',')\n    return float(latitude), float(longitude), float(timeZone), float(elevation)\n\ndef get_sunpt(lb_sunpath,lb_preparation,lat,cpt,month,day,hourlst,north_=0,lon=0,tZ=0,scale_=100):\n    \"\"\"modifed from Ladybug\"\"\"\n    sunpt_lst = []\n    for hour in hourlst:\n        centerPt = rs.coerce3dpoint(cpt)\n        northAngle_, northVector = lb_preparation.angle2north(north_)\n        lb_sunpath.initTheClass(lat,northAngle=northAngle_,cenPt=centerPt,\\\n        scale=scale_,longtitude=lon, timeZone=tZ )\n        lb_sunpath.solInitOutput(month,day,hour)\n        sunpt_lst.append(lb_sunpath.sunPosPt()[2]) # basePoint.Location\n        #return sunSphereMesh, sunVector, basePoint.Location\n    return sunpt_lst\n# -----------------------------------------------------------\n\ndef main(north,boundary,timeperiod,monthRange,location):\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this component.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_sp = sc.sticky[\"ladybug_SunPath\"]()\n        lb_prep = sc.sticky[\"ladybug_Preparation\"]()\n        \n        # setting solar noon variables\n        latitude,longitude,timeZone,elevation = readLocation(_location)\n        year = datetime.datetime.now().year\n        day = 21\n        \n        \"\"\"\n        MONTH_DICT = {0:range(3,7), 1:range(3,10), 2:range(3,13),\\\n              3:range(6,10), 4:range(6,13),\\\n              5:range(9,13)}\n        \"\"\"\n        \n        mth_lst = MONTH_DICT[monthRange]\n        \n        t = timeperiod/2.0\n        centerPt = rs.CurveAreaCentroid(boundary)[0]\n        # do geometry operations\n        boundary = clean_curve(boundary)\n        brep_lst = []\n        for mth in mth_lst:\n            solar_noon = get_solar_noon(mth,year,timeZone,day,latitude,longitude)\n            hourlst = [solar_noon-t,solar_noon+t]\n            #print mth\n            #print 'month: ',mth,'th;', 'hours: ', hourlst\n            sun_pts = get_sunpt(lb_sp,lb_prep,latitude,centerPt,mth,day,hourlst,north_=north,lon=longitude,tZ=timeZone,scale_=100)\n            brep = rs.coercebrep(make_zone(sun_pts,boundary))\n            brep_lst.append(brep)\n        \n        SE = None\n        TOL = sc.doc.ModelAbsoluteTolerance\n        for i in range(len(brep_lst)-1):\n            brep = brep_lst[i]\n            brep_ = brep_lst[i+1]\n            if not SE and rs.IsBrep(brep):\n                SE_ = brep\n            else:\n                SE_ = SE\n            if rs.IsBrep(brep_):\n                SE = rc.Brep.CreateBooleanIntersection(SE_,brep_,TOL)[0]\n            else:\n                SE = SE_\n        return SE\n        \n    else:\n        print \"You should first let the Ladybug fly...\"\n        ghenv.Component.AddRuntimeMessage(ERROR_W, \"You should first let the Ladybug fly...\")\n\n\nMONTH_DICT = {0:range(3,7), 1:range(3,10), 2:range(3,13),\\\n              3:range(6,10), 4:range(6,13),\\\n              5:range(9,13)}\n              \nERROR_W = gh.GH_RuntimeMessageLevel.Warning\ndebug = []\n\n\n\"\"\"\nGet monthrange based on month references.\nDefault is Jun 21 - Dec 21.\n---\n0 = Mar 21 - Jun 21\n1 = Mar 21 - Sep 21\n2 = Mar 21 - Dec 21\n3 = Jun 21 - Sep 21\n4 = Jun 21 - Dec 21\n5 = Sep 21 - Dec 21\n\"\"\"\nif not _monthRange:\n    _monthRange = 4\nif not north_:\n    north_ = 0\nif _boundary and _requiredHours and _location:\n    solarEnvelope = main(north_,_boundary,_requiredHours,int(_monthRange),_location)\nelse:\n    print \"At least one of the inputs is missing!\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}