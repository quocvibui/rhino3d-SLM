{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_mep_pipe_creator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_mep_pipe_creator.py",
  "instruction": "MEP Pipe Creator for Grasshopper.",
  "code": "# File: scripts/gh_mep_pipe_creator.py\n\"\"\"MEP Pipe Creator for Grasshopper.\n\nConverts MEP route JSON from the OAHS routing algorithm into pipe and conduit\nspecifications for Revit creation via Rhino.Inside.Revit. This component bridges\nthe routing results to Revit element creation, generating both pipe segments\nand fitting specifications.\n\nKey Features:\n1. Route to Pipe Conversion\n   - Converts route segments to pipe specifications\n   - Maps system types to Revit pipe/conduit types\n   - Includes nominal size and diameter information\n\n2. Fitting Detection\n   - Detects direction changes for elbow fittings\n   - Identifies 90-degree and 45-degree bends\n   - Generates fitting specifications with angles\n\n3. Type Override Support\n   - Custom pipe type mappings via JSON input\n   - Override default Revit type assignments\n   - Per-system-type configuration\n\n4. Visual Output\n   - LineCurve geometry for pipe path visualization\n   - Point3d markers at fitting locations\n   - DataTree output for per-route organization\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry creation (via RhinoCommonFactory)\n    - Grasshopper: DataTree and component framework\n    - json: Parsing route and override data\n    - timber_framing_generator: RhinoCommonFactory and revit_pipe_mapper module\n\nPerformance Considerations:\n    - Linear scaling with number of routes and segments\n    - Fitting detection adds minimal overhead per route\n    - For >100 routes, consider filtering by system type first\n\nUsage:\n    1. Connect routes_json from MEP Router component\n    2. Optionally provide type_overrides_json for custom mappings\n    3. Toggle create_fittings to enable/disable fitting detection\n    4. Set run=True to execute pipe creation\n    5. Connect pipe_specs_json to Revit creation component\n\nInput Requirements:\n    Routes JSON (routes_json) - str:\n        JSON string containing computed routes from OAHS router.\n        Must have \"routes\" array with route objects containing\n        \"segments\" (with start/end coords) and \"system_type\".\n        Required: Yes\n        Access: Item\n\n    Type Overrides JSON (type_overrides_json) - str:\n        Optional JSON string with custom pipe type mappings.\n        Format: {\"system_type\": {\"pipe_type\": \"...\", ...}}\n        Required: No (empty string uses defaults)\n        Access: Item\n\n    Create Fittings (create_fittings) - bool:\n        Enable fitting detection at direction changes.\n        Required: No (defaults to True)\n        Access: Item\n\n    Run (run) - bool:\n        Trigger to execute pipe creation. Set True to process.\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Pipe Specs JSON (pipe_specs_json) - str:\n        JSON string with pipe specifications for Revit creation.\n        Contains array of pipe objects with endpoints, diameter,\n        system type, and Revit configuration.\n\n    Fitting Specs JSON (fitting_specs_json) - str:\n        JSON string with fitting specifications.\n        Contains array of fitting objects with type, location,\n        angle, and connected pipe IDs.\n\n    Curves (curves) - DataTree[Curve]:\n        LineCurve visualization of pipe paths.\n        One branch per route for selection/filtering.\n\n    Fitting Points (fitting_pts) - List[Point3d]:\n        Point3d markers at fitting locations.\n        Use for visualization of direction changes.\n\n    Info (info) - str:\n        Diagnostic summary string with pipe/fitting counts.\n\nTechnical Details:\n    - Uses RhinoCommonFactory for all geometry creation\n    - Pipe specs include Revit type mapping from revit_pipe_mapper\n    - Fittings detected by angle calculation at vertices\n    - Empty/invalid JSON returns empty outputs gracefully\n\nError Handling:\n    - Invalid routes_json logs warning and returns empty outputs\n    - Invalid type_overrides_json uses defaults with warning\n    - Missing fields in route data are skipped with warning\n    - run=False returns immediately with \"Disabled\" info message\n\nAuthor: Fernando Maytorena\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\nfrom System import Array\nfrom System.Collections.Generic import List\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"MEP Pipe Creator\"\nCOMPONENT_NICKNAME = \"MEP-Pipes\"\nCOMPONENT_MESSAGE = \"v1.0.0\"\nCOMPONENT_CATEGORY = \"TimberFraming\"\nCOMPONENT_SUBCATEGORY = \"MEP\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    # Always print to console (captured by 'out' parameter and log files)\n    print(f\"[{level.upper()}] {message}\")\n\n    # Add to GH component UI for warnings and errors\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    This function handles:\n    1. Setting component metadata (name, category, etc.)\n    2. Configuring input parameter names, descriptions, and access\n    3. Configuring output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: In GHPython, the NickName becomes the Python variable name!\n    # Format: (DisplayName, variable_name, Description, Access)\n    # - Name: Human-readable display name (shown in tooltips)\n    # - NickName: MUST be valid Python identifier - this IS the variable name in code\n    # - Access: item, list, or tree\n    #\n    # NOTE: Type Hints must be set via GH UI (right-click -> Type hint)\n    # They cannot be set programmatically from within the script.\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        # (DisplayName, variable_name, Description, Access)\n        (\"Routes JSON\", \"routes_json\", \"JSON string with computed routes from OAHS router\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Type Overrides JSON\", \"type_overrides_json\", \"Optional JSON with custom pipe type mappings\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Create Fittings\", \"create_fittings\", \"Enable fitting detection at direction changes (default True)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    # IMPORTANT: NickName becomes the Python variable name - must match code!\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        # (DisplayName, variable_name, Description) - indices start at 1\n        (\"Pipe Specs JSON\", \"pipe_specs_json\", \"JSON string with pipe specifications for Revit\"),\n        (\"Fitting Specs JSON\", \"fitting_specs_json\", \"JSON string with fitting specifications\"),\n        (\"Curves\", \"curves\", \"LineCurve visualization of pipe paths (DataTree, one branch per route)\"),\n        (\"Fitting Points\", \"fitting_pts\", \"Point3d markers at fitting locations\"),\n        (\"Info\", \"info\", \"Diagnostic summary string\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef get_factory():\n    \"\"\"Get RhinoCommonFactory instance for geometry creation.\n\n    Returns:\n        RhinoCommonFactory instance\n\n    Raises:\n        ImportError: If timber_framing_generator is not installed\n    \"\"\"\n    from src.timber_framing_generator.utils.geometry_factory import get_factory as _get_factory\n    return _get_factory()\n\n\ndef validate_inputs(routes_json_input, run_input):\n    \"\"\"Validate component inputs.\n\n    Args:\n        routes_json_input: Routes JSON string to validate\n        run_input: Run boolean input\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run_input:\n        return False, \"Set run=True to execute pipe creation\"\n\n    if not routes_json_input:\n        return False, \"Missing routes_json input\"\n\n    # Validate JSON parsing\n    try:\n        data = json.loads(routes_json_input)\n        if not isinstance(data, dict):\n            return False, \"routes_json must be a JSON object\"\n        if \"routes\" not in data:\n            return False, \"routes_json missing 'routes' key\"\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid routes_json: {e}\"\n\n    return True, None\n\n\ndef create_pipe_curves(pipe_result, factory):\n    \"\"\"Create LineCurve geometry for pipe segments.\n\n    Args:\n        pipe_result: PipeCreatorResult with pipes list\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        tuple: (DataTree of curves organized by route, route_to_index mapping)\n    \"\"\"\n    curves_tree = DataTree[object]()\n    route_indices = {}  # route_id -> branch index\n\n    for pipe in pipe_result.pipes:\n        route_id = pipe.route_id\n\n        # Get or create branch index for this route\n        if route_id not in route_indices:\n            route_indices[route_id] = len(route_indices)\n        branch_idx = route_indices[route_id]\n        path = GH_Path(branch_idx)\n\n        # Create LineCurve from pipe endpoints\n        try:\n            start = pipe.start_point\n            end = pipe.end_point\n\n            line_curve = factory.create_line_curve(\n                (float(start[0]), float(start[1]), float(start[2])),\n                (float(end[0]), float(end[1]), float(end[2]))\n            )\n            if line_curve is not None:\n                curves_tree.Add(line_curve, path)\n        except Exception as e:\n            log_debug(f\"Error creating pipe curve for {pipe.id}: {e}\")\n            continue\n\n    return curves_tree, route_indices\n\n\ndef create_fitting_points(pipe_result, factory):\n    \"\"\"Create Point3d geometry for fitting locations.\n\n    Args:\n        pipe_result: PipeCreatorResult with fittings list\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        List of Point3d objects at fitting locations\n    \"\"\"\n    points = []\n\n    for fitting in pipe_result.fittings:\n        try:\n            loc = fitting.location\n            pt = factory.create_point3d(\n                float(loc[0]),\n                float(loc[1]),\n                float(loc[2])\n            )\n            if pt is not None:\n                points.append(pt)\n        except Exception as e:\n            log_debug(f\"Error creating fitting point for {fitting.id}: {e}\")\n            continue\n\n    return points\n\n\ndef process_routes(routes_json_str, type_overrides_str, create_fittings_flag):\n    \"\"\"Process route data and generate pipe/fitting specifications.\n\n    Args:\n        routes_json_str: JSON string with routes data\n        type_overrides_str: Optional JSON string with type overrides\n        create_fittings_flag: Boolean to enable fitting detection\n\n    Returns:\n        tuple: (pipe_specs_json, fitting_specs_json, curves_tree, fitting_pts, info_string)\n    \"\"\"\n    log_info(\"Starting pipe creation processing\")\n\n    # Import the revit_pipe_mapper module\n    try:\n        from src.timber_framing_generator.mep.routing.revit_pipe_mapper import (\n            process_routes_to_pipes,\n            detect_junctions,\n        )\n    except ImportError as e:\n        log_error(f\"Could not import revit_pipe_mapper: {e}\")\n        return \"\", \"\", DataTree[object](), [], f\"Import error: {e}\"\n\n    # Get geometry factory\n    try:\n        factory = get_factory()\n    except ImportError as e:\n        log_error(f\"Could not import geometry factory: {e}\")\n        return \"\", \"\", DataTree[object](), [], f\"Import error: {e}\"\n\n    # Process routes to pipe specifications\n    pipe_result = process_routes_to_pipes(\n        routes_json_str,\n        type_overrides_str if type_overrides_str else None,\n        create_fittings_flag\n    )\n\n    log_info(f\"Generated {len(pipe_result.pipes)} pipes, {len(pipe_result.fittings)} fittings\")\n\n    # Create output JSON strings\n    pipe_specs_dict = {\n        \"pipes\": [p.to_dict() for p in pipe_result.pipes],\n        \"summary\": {\n            \"total_pipes\": len(pipe_result.pipes),\n        }\n    }\n    pipe_specs_json = json.dumps(pipe_specs_dict, indent=2)\n\n    fitting_specs_dict = {\n        \"fittings\": [f.to_dict() for f in pipe_result.fittings],\n        \"summary\": {\n            \"total_fittings\": len(pipe_result.fittings),\n        }\n    }\n    fitting_specs_json = json.dumps(fitting_specs_dict, indent=2)\n\n    # Create visualization geometry\n    curves_tree, route_indices = create_pipe_curves(pipe_result, factory)\n    fitting_pts = create_fitting_points(pipe_result, factory)\n\n    # Detect inter-route junctions\n    junctions = detect_junctions(routes_json_str)\n\n    # Build info string\n    info_lines = [\n        f\"Pipes generated: {len(pipe_result.pipes)}\",\n        f\"Fittings detected: {len(pipe_result.fittings)}\",\n        f\"Inter-route junctions: {len(junctions)}\",\n        f\"Routes processed: {len(route_indices)}\",\n    ]\n\n    if pipe_result.warnings:\n        info_lines.append(f\"Warnings: {len(pipe_result.warnings)}\")\n        for warning in pipe_result.warnings[:5]:  # Show first 5 warnings\n            info_lines.append(f\"  - {warning}\")\n        if len(pipe_result.warnings) > 5:\n            info_lines.append(f\"  ... and {len(pipe_result.warnings) - 5} more\")\n\n    info_string = \"\\n\".join(info_lines)\n    log_info(f\"Pipe creation complete: {len(pipe_result.pipes)} pipes, {len(pipe_result.fittings)} fittings\")\n\n    return pipe_specs_json, fitting_specs_json, curves_tree, fitting_pts, info_string\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Coordinates the overall workflow:\n    1. Setup component metadata\n    2. Validate inputs\n    3. Process route data\n    4. Return pipe specifications and visualization geometry\n\n    Returns:\n        tuple: (pipe_specs_json, fitting_specs_json, curves, fitting_pts, info) or empty outputs on failure\n    \"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize empty outputs\n    empty_curves = DataTree[object]()\n    empty_points = []\n\n    try:\n        # Get inputs (these come from GH component inputs)\n        # Use globals() to check if variables are defined\n        routes_json_input = routes_json if 'routes_json' in dir() else None\n        type_overrides_input = type_overrides_json if 'type_overrides_json' in dir() else \"\"\n        create_fittings_input = create_fittings if 'create_fittings' in dir() else True\n        run_input = run if 'run' in dir() else False\n\n        # Handle None/unset boolean inputs with defaults\n        if create_fittings_input is None:\n            create_fittings_input = True\n\n        # Handle None type overrides as empty string\n        if type_overrides_input is None:\n            type_overrides_input = \"\"\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(routes_json_input, run_input)\n        if not is_valid:\n            if error_msg and \"run=True\" not in error_msg:\n                log_warning(error_msg)\n            return \"\", \"\", empty_curves, empty_points, error_msg or \"Disabled\"\n\n        # Process routes\n        pipe_specs_json, fitting_specs_json, curves_tree, fitting_pts, info_string = process_routes(\n            routes_json_input,\n            type_overrides_input,\n            create_fittings_input\n        )\n\n        return pipe_specs_json, fitting_specs_json, curves_tree, fitting_pts, info_string\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_debug(traceback.format_exc())\n        return \"\", \"\", empty_curves, empty_points, f\"Error: {str(e)}\"\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Execute main and assign to output variables\n    # These variable names must match your GH component outputs\n    pipe_specs_json, fitting_specs_json, curves, fitting_pts, info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}