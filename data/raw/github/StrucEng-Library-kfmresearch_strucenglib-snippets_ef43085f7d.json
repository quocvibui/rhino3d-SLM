{
  "source_url": "https://github.com/StrucEng-Library-kfmresearch/strucenglib-snippets/blob/2e4b498eaa5b2928c1766e9ed99bf6493e5fe056/strucenglib/prepost_functions/Old/Normalspurbahnverkehr_load_generator%20copy.py",
  "repo": "StrucEng-Library-kfmresearch/strucenglib-snippets",
  "repo_stars": 1,
  "repo_description": "StrucEng Library (snippets) for Rhinoceros",
  "license": "unknown",
  "filepath": "strucenglib/prepost_functions/Old/Normalspurbahnverkehr_load_generator copy.py",
  "instruction": "Normalspurbahnverkehr load generator copy",
  "code": " \nimport rhinoscriptsyntax as rs\nfrom compas_fea.structure import Structure\nfrom compas_fea.cad import rhino\nfrom compas.geometry import scale_vector\nfrom compas.geometry import add_vectors\nimport Rhino\nimport scriptcontext\nimport System.Guid, System.Drawing.Color\nimport math\n\n\ndef Normalspurbahnverkehr_load_generator(name=None, origin=[None,None,None], l_Pl=None, h_Pl=None, s=None, beta=None, q_Gl=4.8, b_Bs=2500, h_Strich=None, Q_k=225*1000, pos_bahnlast_1=None, a=None):\n    \n\n    # Winkeldefinition\n    beta_rad=math.radians(beta)\n            \n    plane = rs.WorldXYPlane()\n    if beta_rad >= math.pi/2:\n        alfa_rec=beta_rad-math.pi/2            \n    elif beta_rad < math.pi/2:\n        alfa_rec=beta_rad \n\n    \n    # Generierung der Mittelachse aus s und beta falls Gleis_1 Layer nicht schon vorhanden\n    #-------------------------------------------------------\n    #-------------------------------------------------------\n    #-------------------------------------------------------\n\n    \n    if rs.IsLayer(name): \n        rs.PurgeLayer(name)\n        scriptcontext.doc.Layers.Add(name, System.Drawing.Color.Red)\n        rs.CurrentLayer(name)\n    else:\n        scriptcontext.doc.Layers.Add(name, System.Drawing.Color.Red)\n        rs.CurrentLayer(name)\n    \n    # Berechnung der Gleismittelachse\n    # ---------------------------------------------------------------------------------    \n    point_start_x=origin[0]+s\n    if beta_rad >= math.pi/2:\n        point_end_x=l_Pl/(math.tan(math.pi-beta_rad))\n        rs.AddCurve([(point_start_x,origin[1],origin[2]),(point_start_x-point_end_x,origin[1]+l_Pl,origin[2])])\n    elif beta_rad < math.pi/2:\n        point_end_x=l_Pl/(math.tan(beta_rad))        \n        rs.AddCurve([(point_start_x,origin[1],origin[2]),(point_start_x+point_end_x,origin[1]+l_Pl,origin[2])])\n        \n    selectcurve = rs.ObjectsByLayer(name)\n    \n    # Calculate End and Startpoints\n    point_start = rs.CurveStartPoint(selectcurve)\n    point_end = rs.CurveEndPoint(selectcurve)\n\n    \n    # check in welcher Ebene (xy, xz oder yz) - ONLY SUPPORTED FOR XY PLANES\n    if point_start[0] == point_end[0]:\n        raise NotImplementedError\n    elif point_start[1] == point_end[1]:\n        raise NotImplementedError\n    elif point_start[2] == point_end[2]:\n\n        # Lastgenerator fur Gleise/Schwellen Lasten\n        #-------------------------------------------------------\n        #-------------------------------------------------------\n        #------------------------------------------------------- \n        \n        # Create layername with load area\n        area_load_layer_Schwellen_Gleis_Last=name+'_Schwellen_Gleis_Last'\n\n        # Definition eines neues Layers fur alle belasteten Elementmittelpunkte \n        if rs.IsLayer(area_load_layer_Schwellen_Gleis_Last):\n            rs.PurgeLayer(area_load_layer_Schwellen_Gleis_Last)\n            scriptcontext.doc.Layers.Add(area_load_layer_Schwellen_Gleis_Last, System.Drawing.Color.Green)\n        else:\n            scriptcontext.doc.Layers.Add(area_load_layer_Schwellen_Gleis_Last, System.Drawing.Color.Green)\n\n        # Geometrische Berechnung der Lastflachen\n        # ---------------------------------------------------------------------------------\n        # Berechnung b_Gl\n        b_Gl=(b_Bs/2+h_Strich/4+h_Pl/2)*2\n\n        # Berechnung b_strich_Gl\n        b_Strich_Gl=b_Gl/math.sin(beta_rad)\n\n        # Berechnung der vier Eckpunkte der Lastflache\n        # ---------------------------------------------------------------------------------\n        # x Koordinanten\n        P_A_x=(point_start[0]-b_Strich_Gl/2)\n        P_B_x=(point_start[0]+b_Strich_Gl/2)\n        P_C_x=(point_end[0]+b_Strich_Gl/2)\n        P_D_x=(point_end[0]-b_Strich_Gl/2)\n\n        # y Koordinanten\n        P_A_y=(point_start[1])\n        P_B_y=(point_start[1])\n        P_C_y=(point_end[1])\n        P_D_y=(point_end[1])\n\n        # z Koordinanten\n        P_A_z=(point_start[2])\n        P_B_z=(point_start[2])\n        P_C_z=(point_end[2])\n        P_D_z=(point_end[2])\n\n        # Berechnung der vier Eckpunkte der Lastflache und Kurvne in Rhino Layer ploten\n        # ---------------------------------------------------------------------------------\n        rs.CurrentLayer(area_load_layer_Schwellen_Gleis_Last)\n        rs.AddPolyline([(P_A_x,P_A_y,P_A_z),(P_B_x,P_B_y,P_B_z),(P_C_x,P_C_y,P_C_z),(P_D_x,P_D_y,P_D_z),(P_A_x,P_A_y,P_A_z)])\n\n        # Berechnung der Belastung q_k_Gl der Gleise\n        q_k_Gl=q_Gl/b_Gl\n                        \n        \n        \n        \n        # Lastgenerator fur Bahnverkehrslasten Nr. 1 Lastzug A\n        #-------------------------------------------------------\n        #-------------------------------------------------------\n        #-------------------------------------------------------\n        \n        # Lastausbreitung in Langsrichtung\n        l_Bl=(h_Strich/4+h_Pl/2)*2\n\n        \n        # Setzen der angegeben Last 1 und der Lasten 1A, 1B, 1C\n        #-------------------------------------------------------\n        y_load_1=pos_bahnlast_1\n        \n\n        # Create layername with load area\n        load_name_1=name+'_Bahnlast_1'\n        load_name_1A=name+'_Bahnlast_1A'\n        load_name_1B=name+'_Bahnlast_1B'\n        load_name_1C=name+'_Bahnlast_1C'\n        load_name_1A_rect=name+'_Bahnlast_1A_rect'\n        load_name_1B_rect=name+'_Bahnlast_1B_rect'\n        load_name_1C_rect=name+'_Bahnlast_1C_rect'\n\n        # Definition eines neues Layers fur Bahnlast 1\n        if rs.IsLayer(load_name_1):\n            rs.PurgeLayer(load_name_1)\n            scriptcontext.doc.Layers.Add(load_name_1, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1)\n        \n        # Position Last 1 \n        if beta_rad >= math.pi/2:\n            delta_x_load_1=y_load_1/(math.tan(math.pi-beta_rad))\n            x_load_1=point_start[0]-delta_x_load_1\n            rs.AddPoint((x_load_1,y_load_1))\n        elif beta_rad < math.pi/2:\n            delta_x_load_1=y_load_1/(math.tan(beta_rad))\n            x_load_1=point_start[0]+delta_x_load_1\n            rs.AddPoint((x_load_1,y_load_1))\n\n\n        # Definition eines neues Layers fur Bahnlast 1A\n        if rs.IsLayer(load_name_1A):\n            rs.PurgeLayer(load_name_1A)\n            scriptcontext.doc.Layers.Add(load_name_1A, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1A, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1A)\n        \n        # Position Last 1A\n        if beta_rad >= math.pi/2:\n            delta_x_load_1A=a*math.cos(math.pi-beta_rad)\n            delta_y_load_1A=a*math.sin(math.pi-beta_rad)\n            x_load_1A=x_load_1+delta_x_load_1A\n            y_load_1A=y_load_1-delta_y_load_1A\n            rs.AddPoint((x_load_1A,y_load_1A))\n        elif beta_rad < math.pi/2:\n            delta_x_load_1A=a*math.cos(beta_rad)\n            delta_y_load_1A=a*math.sin(beta_rad)\n            x_load_1A=x_load_1-delta_x_load_1A\n            y_load_1A=y_load_1-delta_y_load_1A\n            rs.AddPoint((x_load_1A,y_load_1A))\n\n\n\n\n        # Definition eines neues Layers fur Bahnlast 1B\n        if rs.IsLayer(load_name_1B):\n            rs.PurgeLayer(load_name_1B)\n            scriptcontext.doc.Layers.Add(load_name_1B, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1B, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1B)\n        \n        # Position Last 1B = Position Last 1\n        x_load_1B=x_load_1\n        y_load_1B=y_load_1\n        rs.AddPoint((x_load_1B,y_load_1B))\n           \n\n\n\n        # Definition eines neues Layers fur Bahnlast 1C\n        if rs.IsLayer(load_name_1C):\n            rs.PurgeLayer(load_name_1C)\n            scriptcontext.doc.Layers.Add(load_name_1C, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1C, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1C)\n               \n        # Position Last 1C\n        if beta_rad >= math.pi/2:\n            delta_x_load_1C=a*math.cos(math.pi-beta_rad)\n            delta_y_load_1C=a*math.sin(math.pi-beta_rad)\n            x_load_1C=x_load_1-delta_x_load_1C\n            y_load_1C=y_load_1+delta_y_load_1C\n            rs.AddPoint((x_load_1C,y_load_1C))\n        elif beta_rad < math.pi/2:\n            delta_x_load_1C=a*math.cos(beta_rad)\n            delta_y_load_1C=a*math.sin(beta_rad)\n            x_load_1C=x_load_1+delta_x_load_1C\n            y_load_1C=y_load_1+delta_y_load_1C\n            rs.AddPoint((x_load_1C,y_load_1C))     \n\n        \n\n        # Definition eines neues Layers fur Rectnalge 1A\n        if rs.IsLayer(load_name_1A_rect):\n            rs.PurgeLayer(load_name_1A_rect)\n            scriptcontext.doc.Layers.Add(load_name_1A_rect, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1A_rect, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1A_rect)\n\n        # Build rectangle fro load Area 1A\n        plane1A = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n        rs.AddRectangle( plane1A, l_Bl, b_Gl )\n        selectrect_1A = rs.ObjectsByLayer(load_name_1A_rect)\n        rect_1A_corner_points=rs.CurvePoints(selectrect_1A)\n        mid_point_rect_1A_x=(rect_1A_corner_points[0][0]+rect_1A_corner_points[2][0])/2\n        mid_point_rect_1A_y=(rect_1A_corner_points[0][1]+rect_1A_corner_points[2][1])/2\n        translation_start_rect=[mid_point_rect_1A_x, mid_point_rect_1A_y, 0]\n        translation_end_rect=[x_load_1A,y_load_1A,0]\n        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n        rs.MoveObject(selectrect_1A, translation_rect)\n        \n\n\n\n        # Definition eines neues Layers fur Rectnalge 1B\n        if rs.IsLayer(load_name_1B_rect):\n            rs.PurgeLayer(load_name_1B_rect)\n            scriptcontext.doc.Layers.Add(load_name_1B_rect, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1B_rect, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1B_rect)\n\n        # Build rectangle fro load Area 1B\n        plane1B = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n        rs.AddRectangle( plane1B, l_Bl, b_Gl )\n        selectrect_1B = rs.ObjectsByLayer(load_name_1B_rect)\n        rect_1B_corner_points=rs.CurvePoints(selectrect_1B)\n        mid_point_rect_1B_x=(rect_1B_corner_points[0][0]+rect_1B_corner_points[2][0])/2\n        mid_point_rect_1B_y=(rect_1B_corner_points[0][1]+rect_1B_corner_points[2][1])/2\n        translation_start_rect=[mid_point_rect_1B_x, mid_point_rect_1B_y, 0]\n        translation_end_rect=[x_load_1B,y_load_1B,0]\n        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n        rs.MoveObject(selectrect_1B, translation_rect)\n\n\n\n\n        # Definition eines neues Layers fur Rectnalge 1C\n        if rs.IsLayer(load_name_1C_rect):\n            rs.PurgeLayer(load_name_1C_rect)\n            scriptcontext.doc.Layers.Add(load_name_1C_rect, System.Drawing.Color.Red)\n        else:\n            scriptcontext.doc.Layers.Add(load_name_1C_rect, System.Drawing.Color.Red)\n        \n        rs.CurrentLayer(load_name_1C_rect)\n\n        # Build rectangle fro load Area 1C\n        plane1C = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n        rs.AddRectangle( plane1C, l_Bl, b_Gl )\n        selectrect_1C = rs.ObjectsByLayer(load_name_1C_rect)\n        rect_1C_corner_points=rs.CurvePoints(selectrect_1C)\n        mid_point_rect_1C_x=(rect_1C_corner_points[0][0]+rect_1C_corner_points[2][0])/2\n        mid_point_rect_1C_y=(rect_1C_corner_points[0][1]+rect_1C_corner_points[2][1])/2\n        translation_start_rect=[mid_point_rect_1C_x, mid_point_rect_1C_y, 0]\n        translation_end_rect=[x_load_1C,y_load_1C,0]\n        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n        rs.MoveObject(selectrect_1C, translation_rect)\n        \n        # Berechnung der Flachenlasten fur A\n        area_1A=rs.Area(selectrect_1A)\n        q_k_Bl_A=(Q_k/4)/area_1A\n\n        # Berechnung der Flachenlasten fur B\n        area_1B=rs.Area(selectrect_1B)\n        q_k_Bl_B=(Q_k/2)/area_1B\n\n        # Berechnung der Flachenlasten fur C\n        area_1C=rs.Area(selectrect_1C)\n        q_k_Bl_C=(Q_k/4)/area_1C\n\n\n        # Lastgenerator fur Bahnverkehrslasten >= Nr.2  Lastzug A\n        #--------------------------------------------------------\n        #--------------------------------------------------------\n        #--------------------------------------------------------\n        \n        \n        for lg in range(0,4): # Lastgruppen 2 (lg=0), 3(lg=1),... bis unendlich\n            \n            # Relative Distance\n            delta_distance_load_lg_to_load_1=[]    \n            delta_distance_load_lg_to_load_1.append(1800)\n            delta_distance_load_lg_to_load_1.append((1800+4500))\n            delta_distance_load_lg_to_load_1.append((1800+4500+1800))\n            delta_distance_load_lg_to_load_1.append((1800+4500+1800+3000))\n            delta_distance_load_lg_to_load_1.append((1800+4500+1800+3000+1800))\n            delta_distance_load_lg_to_load_1.append((1800+4500+1800+3000+1800+4500))\n            delta_distance_load_lg_to_load_1.append((1800+4500+1800+3000+1800+4500+1800))\n            # Hier entsprechend erweitern fur beliebig viele lg\n                        \n            #  SCHLEIFE uber Einzallasten i (d.h. A (i=0), B (i=1), C(i=2)) in Lastgruppe lg\n            for i in range(0,3):\n\n                # Bestimmen neuer Layers\n                if i==0:\n                    load_name_i_rect=name+'_Bahnlast_'+str(lg+2)+'A'\n                if i==1:\n                    load_name_i_rect=name+'_Bahnlast_'+str(lg+2)+'B'\n                if i==2:\n                    load_name_i_rect=name+'_Bahnlast_'+str(lg+2)+'C'\n                            \n                if rs.IsLayer(load_name_i_rect):\n                    rs.PurgeLayer(load_name_i_rect)\n                    scriptcontext.doc.Layers.Add(load_name_i_rect, System.Drawing.Color.Red)\n                else:\n                    scriptcontext.doc.Layers.Add(load_name_i_rect, System.Drawing.Color.Red)\n                \n\n                \n            \n                # Calcualte relativ position and absolute positions x,y for iA, iB, iC zum Punkt 1A, 1B, 1C (iA to 1A = iB to 1B = iC to 1C) and copy rectangle\n                if beta_rad >= math.pi/2:\n                    delta_x_load_i_to_1=delta_distance_load_lg_to_load_1[lg]*math.cos(math.pi-beta_rad)\n                    delta_y_load_i_to_1=delta_distance_load_lg_to_load_1[lg]*math.sin(math.pi-beta_rad)\n                    if i==0: # d.h. iA\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iA=x_load_1A+delta_x_load_i_to_1\n                        y_load_iA=y_load_1A-delta_y_load_i_to_1\n                        planeiA = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiA, l_Bl, b_Gl )\n                        selectrect_iA = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iA_corner_points=rs.CurvePoints(selectrect_iA)\n                        mid_point_rect_iA_x=(rect_iA_corner_points[0][0]+rect_iA_corner_points[2][0])/2\n                        mid_point_rect_iA_y=(rect_iA_corner_points[0][1]+rect_iA_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iA_x, mid_point_rect_iA_y, 0]\n                        translation_end_rect=[x_load_iA,y_load_iA,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iA, translation_rect)\n                        q_k_Bl_A\n                    elif i==1: # d.h. iB\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iB=x_load_1B+delta_x_load_i_to_1\n                        y_load_iB=y_load_1B-delta_y_load_i_to_1     \n                        planeiB = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiB, l_Bl, b_Gl )\n                        selectrect_iB = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iB_corner_points=rs.CurvePoints(selectrect_iB)\n                        mid_point_rect_iB_x=(rect_iB_corner_points[0][0]+rect_iB_corner_points[2][0])/2\n                        mid_point_rect_iB_y=(rect_iB_corner_points[0][1]+rect_iB_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iB_x, mid_point_rect_iB_y, 0]\n                        translation_end_rect=[x_load_iB,y_load_iB,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iB, translation_rect)\n\n                    elif i==2: # d.h. iC\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iC=x_load_1C+delta_x_load_i_to_1\n                        y_load_iC=y_load_1C-delta_y_load_i_to_1                     \n                        planeiC = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiC, l_Bl, b_Gl )\n                        selectrect_iC = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iC_corner_points=rs.CurvePoints(selectrect_iC)\n                        mid_point_rect_iC_x=(rect_iC_corner_points[0][0]+rect_iC_corner_points[2][0])/2\n                        mid_point_rect_iC_y=(rect_iC_corner_points[0][1]+rect_iC_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iC_x, mid_point_rect_iC_y, 0]\n                        translation_end_rect=[x_load_iC,y_load_iC,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iC, translation_rect)\n\n                elif beta_rad < math.pi/2:\n                    delta_x_load_i_to_1=delta_distance_load_lg_to_load_1[lg]*math.cos(beta_rad)\n                    delta_y_load_i_to_1=delta_distance_load_lg_to_load_1[lg]*math.sin(beta_rad)\n                    print(delta_distance_load_lg_to_load_1[lg])\n                    if i==0: # d.h. iA\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iA=x_load_1A-delta_x_load_i_to_1\n                        y_load_iA=y_load_1A-delta_y_load_i_to_1\n                        planeiA = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiA, l_Bl, b_Gl )\n                        selectrect_iA = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iA_corner_points=rs.CurvePoints(selectrect_iA)\n                        mid_point_rect_iA_x=(rect_iA_corner_points[0][0]+rect_iA_corner_points[2][0])/2\n                        mid_point_rect_iA_y=(rect_iA_corner_points[0][1]+rect_iA_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iA_x, mid_point_rect_iA_y, 0]\n                        translation_end_rect=[x_load_iA,y_load_iA,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iA, translation_rect)\n\n                    elif i==1: # d.h. iB\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iB=x_load_1B-delta_x_load_i_to_1\n                        y_load_iB=y_load_1B-delta_y_load_i_to_1   \n                        planeiB = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiB, l_Bl, b_Gl )\n                        selectrect_iB = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iB_corner_points=rs.CurvePoints(selectrect_iB)\n                        mid_point_rect_iB_x=(rect_iB_corner_points[0][0]+rect_iB_corner_points[2][0])/2\n                        mid_point_rect_iB_y=(rect_iB_corner_points[0][1]+rect_iB_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iB_x, mid_point_rect_iB_y, 0]\n                        translation_end_rect=[x_load_iB,y_load_iB,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iB, translation_rect)\n\n                    elif i==2: # d.h. iC\n                        rs.CurrentLayer(load_name_i_rect)\n                        x_load_iC=x_load_1C-delta_x_load_i_to_1\n                        y_load_iC=y_load_1C-delta_y_load_i_to_1    \n                        planeiC = rs.RotatePlane(plane, math.degrees(alfa_rec), [0,0,1])\n                        rs.AddRectangle( planeiC, l_Bl, b_Gl )\n                        selectrect_iC = rs.ObjectsByLayer(load_name_i_rect)\n                        rect_iC_corner_points=rs.CurvePoints(selectrect_iC)\n                        mid_point_rect_iC_x=(rect_iC_corner_points[0][0]+rect_iC_corner_points[2][0])/2\n                        mid_point_rect_iC_y=(rect_iC_corner_points[0][1]+rect_iC_corner_points[2][1])/2\n                        translation_start_rect=[mid_point_rect_iC_x, mid_point_rect_iC_y, 0]\n                        translation_end_rect=[x_load_iC,y_load_iC,0]\n                        translation_rect=[translation_end_rect[0]-translation_start_rect[0],translation_end_rect[1]-translation_start_rect[1],translation_end_rect[2]-translation_start_rect[2]]\n                        rs.MoveObject(selectrect_iC, translation_rect)\n        \n\n\n\n \n\n    else:\n        raise NotImplementedError  \n        \n           \n    \n    return q_k_Gl, area_load_layer_Schwellen_Gleis_Last, q_k_Bl_A, load_name_1A_rect, q_k_Bl_B, load_name_1B_rect, q_k_Bl_C, load_name_1C_rect\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}