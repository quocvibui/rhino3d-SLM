{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_insertKnotsUniformly.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_insertKnotsUniformly.py",
  "instruction": "Insert knots uniformly within existing spans.\r\nTherefore, when the starting surface is uniform, uniformity will be maintained.",
  "code": "\"\"\"\r\nInsert knots uniformly within existing spans.\r\nTherefore, when the starting surface is uniform, uniformity will be maintained.\r\n\"\"\"\r\n\"\"\"\r\n210802: Created.\r\n211105: Now modifies a single face.\r\n        Added direction option after the face is picked.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Drawing\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'iQtyToAddInEachSpan'; keys.append(key)\r\n    values[key] = 2\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=1)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print \"Add option for {} failed.\".format(key)\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fScale':\r\n        #    if cls.riOpts[key].CurrentValue <= 1e-9:\r\n        #        print \"Invalid input for scale value.\"\r\n        #        cls.riOpts[key].CurrentValue = cls.values[key]\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\nclass DrawUVArrowsConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self, ns):\r\n        self.locs_U = []\r\n        self.dirs_U = []\r\n        self.locs_V = []\r\n        self.dirs_V = []\r\n        for u in ns.Domain(0).Min, ns.Domain(0).Mid, ns.Domain(0).Max:\r\n            for v in ns.Domain(1).Min, ns.Domain(1).Mid, ns.Domain(1).Max:\r\n                location = ns.PointAt(u, v)\r\n                isocurve = ns.IsoCurve(direction=0, constantParameter=v)\r\n                direction = isocurve.TangentAt(u)\r\n                self.locs_U.append(location)\r\n                self.dirs_U.append(direction)\r\n                isocurve = ns.IsoCurve(direction=1, constantParameter=u)\r\n                direction = isocurve.TangentAt(v)\r\n                self.locs_V.append(location)\r\n                self.dirs_V.append(direction)\r\n\r\n    def DrawForeground(self, e):\r\n        rhRed = Drawing.Color.FromArgb(red=200, green=0, blue=0)\r\n        rhGreen = Drawing.Color.FromArgb(red=0, green=127, blue=0)\r\n        zipped = zip(self.locs_U, self.dirs_U, self.dirs_V)\r\n        for location, direction_U, direction_V in zipped:\r\n            e.Display.DrawDirectionArrow(\r\n                location,\r\n                direction=direction_U,\r\n                color=rhRed)\r\n            e.Display.DrawDirectionArrow(\r\n                location,\r\n                direction=direction_V,\r\n                color=rhGreen)\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get face with optional input.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select brep face\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n\r\n    res = go.Get()\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        go.Dispose()\r\n        return\r\n\r\n    objref = go.Object(0)\r\n\r\n    go.Dispose()\r\n\r\n    srf = objref.Face().UnderlyingSurface()\r\n            \r\n    if not isinstance(srf, rg.NurbsSurface):\r\n        s = \"Underlying surface is a {}\".format(srf.GetType().Name)\r\n        s += \" and will be converted to a NurbsSurface.\"\r\n        print s\r\n\r\n        ns = srf.ToNurbsSurface()\r\n    else:\r\n        ns = srf\r\n\r\n    print \"U direction: Degree:{}, SpanCt:{}\".format(\r\n        ns.Degree(0), ns.SpanCount(0))\r\n    print \"V direction: Degree:{}, SpanCt:{}\".format(\r\n        ns.Degree(1), ns.SpanCount(1))\r\n\r\n    conduit = DrawUVArrowsConduit(ns)\r\n\r\n    go = ri.Custom.GetOption()\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AcceptNumber(True, acceptZero=False)\r\n\r\n    go.SetCommandPrompt(\"Direction\")\r\n\r\n    sDirs = 'U', 'V', 'Both'\r\n\r\n    key = 'iDirection'\r\n    stickyKey = '{}({})'.format(key, __file__)\r\n    if stickyKey in sc.sticky:\r\n        idxDir_Default = sc.sticky[stickyKey]\r\n    else:\r\n        idxDir_Default = 0\r\n\r\n    go.SetCommandPromptDefault(sDirs[idxDir_Default])\r\n\r\n    idxs_Opt = {}\r\n\r\n    conduit.Enabled = True\r\n    sc.doc.Views.Redraw()\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        for sDir in sDirs:\r\n            idxs_Opt[sDir] = go.AddOption(sDir)\r\n\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('iQtyToAddInEachSpan')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.Get()\r\n\r\n        conduit.Enabled = False\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            sDir = sDirs[idxDir_Default]\r\n            break\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iQtyToAddInEachSpan'\r\n            if int(go.Number()) < 1:\r\n                continue\r\n            Opts.riOpts[key].CurrentValue = int(go.Number())\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        idx_Opt = go.Option().Index\r\n        if idx_Opt in (1,2,3):\r\n            idx_Dir = go.Option().Index - 1 # Notice the '-1'.\r\n            sDir = sDirs[idx_Dir] \r\n            sc.sticky[stickyKey] = idx_Dir\r\n            go.Dispose()\r\n            break # out of while loop.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break # out of for look back to while loop.\r\n\r\n\r\n    return (\r\n        objref,\r\n        sDir,\r\n        Opts.values['iQtyToAddInEachSpan'],\r\n        Opts.values['bReplace'],\r\n        Opts.values['bEcho'],\r\n        Opts.values['bDebug'],\r\n        )\r\n\r\n\r\ndef createSurface(ns_In, sDir, iQtyToAddInEachSpan, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        ns_In: rg.NurbsSurface,\r\n        sDir: str('U', 'V', or 'Both')\r\n        iQtyToAddInEachSpan: int\r\n        bDebug: bool\r\n\r\n    Returns: rg.NurbsSurface\r\n    \"\"\"\r\n\r\n    if not isinstance(ns_In, rg.NurbsSurface):\r\n        return\r\n\r\n    if sDir not in ('U', 'V', 'Both'):\r\n        return\r\n\r\n    if iQtyToAddInEachSpan < 1:\r\n        return\r\n\r\n    ns_Out = ns_In.Duplicate()\r\n\r\n    # Add knots from Domain end to beginning.\r\n\r\n    if sDir in ('U', 'Both'):\r\n        for iK in range(ns_In.KnotsU.Count-1, 0, -1):\r\n\r\n            k_R = ns_In.KnotsU[iK]\r\n            k_L = ns_In.KnotsU[iK-1]\r\n\r\n            for i in range(iQtyToAddInEachSpan):\r\n                fraction_from_R = float(i+1) / float(iQtyToAddInEachSpan+1)\r\n                k_M = fraction_from_R*k_R + (1.0-fraction_from_R)*k_L\r\n                ns_Out.KnotsU.InsertKnot(k_M)\r\n\r\n    if sDir in ('V', 'Both'):\r\n        for iK in range(ns_In.KnotsV.Count-1, 0, -1):\r\n\r\n            k_R = ns_In.KnotsV[iK]\r\n            k_L = ns_In.KnotsV[iK-1]\r\n\r\n            for i in range(iQtyToAddInEachSpan):\r\n                fraction_from_R = float(i+1) / float(iQtyToAddInEachSpan+1)\r\n                k_M = fraction_from_R*k_R + (1.0-fraction_from_R)*k_L\r\n                ns_Out.KnotsV.InsertKnot(k_M)\r\n\r\n    return ns_Out\r\n\r\n\r\ndef processBrepObject(objref, sDir, iQtyToAddInEachSpan=1, bReplace=True, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    objref: rd.ObjRef of BrepFace.\r\n    \"\"\"\r\n\r\n    face = rs.coercesurface(objref, raise_if_missing=False)\r\n    if isinstance(face, rg.BrepFace):\r\n        srf = face.UnderlyingSurface()\r\n    else:\r\n        print \"{} skipped.\".format(rs.coercerhinoobject(objref).ObjectType)\r\n        return\r\n\r\n    ns_Res = createSurface(\r\n        srf.ToNurbsSurface(),\r\n        sDir,\r\n        iQtyToAddInEachSpan,\r\n        bDebug)\r\n\r\n    if ns_Res is None:\r\n        return\r\n\r\n    if bReplace:\r\n        gB_In = rs.coerceguid(objref)\r\n\r\n\r\n        if face.Brep.Faces.Count == 1:\r\n            if sc.doc.Objects.Replace(\r\n                objectId=gB_In,\r\n                surface=ns_Res\r\n            ):\r\n                return gB_In\r\n\r\n        # Polyfaced brep.\r\n        face.Brep.AddSurface(ns_Res)\r\n        face.ChangeSurface(surfaceIndex=face.Brep.Surfaces.Count-1)\r\n        face.Brep.Compact()\r\n        if sc.doc.Objects.Replace(\r\n            objectId=gB_In,\r\n            brep=face.Brep\r\n        ):\r\n            return gB_In\r\n\r\n\r\n    # Add new face.\r\n    gB_Out = sc.doc.Objects.AddSurface(ns_Res)\r\n    if gB_Out != gB_Out.Empty:\r\n        return gB_Out\r\n    else:\r\n        print \"Could not add surface.\"\r\n\r\n\r\ndef main():\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        objref,\r\n        sDir,\r\n        iQtyToAddInEachSpan,\r\n        bReplace,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    gBs_Res = processBrepObject(\r\n        objref,\r\n        sDir,\r\n        iQtyToAddInEachSpan,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}