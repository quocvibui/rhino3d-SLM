{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/working_file_joe/skin_testing/pt_variations.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "working_file_joe/skin_testing/pt_variations.py",
  "instruction": "Pt variations",
  "code": "import Rhino.Geometry as rg\nimport random as r\nimport ghpythonlib as ghc\nfrom ghpythonlib import treehelpers as th\nfrom copy import deepcopy\nimport math\n\n\ndef OrientPlane(plane, guide):\n    yPt = plane.Origin + rg.Vector3d(0, 0, 1)\n    project = rg.Transform.ProjectAlong(plane, plane.ZAxis)\n    yPt.Transform(project)\n    yAxis = rg.Vector3d(yPt-plane.Origin)\n\n    zAxis = plane.ZAxis\n    if zAxis*guide < 0:\n        zAxis = -zAxis\n\n    outPlane = rg.Plane(\n        plane.Origin, -rg.Vector3d.CrossProduct(zAxis, yAxis), yAxis)\n    return outPlane\n\n\ndef Remap(old_value, old_min, old_max, new_min, new_max):\n    # print('x')\n    # print (old_value)\n    new_value = (old_value - old_min) * (new_max - new_min) / \\\n        (old_max - old_min) + new_min\n    # else\n    # print('y')\n    # print (new_value)\n    return new_value\n\n\ndef get_pts(crvs):\n\n    #Make into loop for list of curves\n    all_pts = []\n\n    crv = curve.ToNurbsCurve(curve.Domain)\n    # params = crv.DivideByCount(divide_number, True)\n\n    params = crv.DivideByCount(10, True)\n    # print(len(params))\n\n    for i in params:\n        pt = crv.PointAt(i)\n        all_pts.append(pt)\n\n    return all_pts\n\n\ndef make_planes(pts):\n\n    pts_planes = []\n    \n    #Make into loop for list of curves\n\n    for k, pt in enumerate(pts):\n        point, uv_pt, distance = ghc.components.SurfaceClosestPoint(pt, srf)\n        pnt, normal, u, v, f = ghc.components.EvaluateSurface(srf, uv_pt)\n        plane = rg.Plane(pt, rg.Vector3d(u), rg.Vector3d(v))\n        rg.Plane.Rotate(plane, math.radians(-90), plane.ZAxis, plane.Origin)\n\n        # halfLength = len(pts)/2\n        # rotation2 = rg.Transform.Rotation((((abs(halfLength-k))/halfLength)*-math.pi*0.5), plane.Normal, plane.Origin)\n        # rotation2 = rg.Transform.Rotation(((len(pts)-k)*math.pi/len(pts) + -math.pi*0.5), plane.Normal, plane.Origin)\n        # plane.Transform(rotation2)\n        pts_planes.append(plane)\n    return pts_planes\n\n#TODO  \n\ndef move_planes(plns, pt, min_layer_height, max_layer_height):\n\n    min_dist = 1000000\n    max_dist = 0\n\n    for pln in plns:\n        if pt.DistanceTo(pln.Origin) < min_dist:\n            min_dist = pt.DistanceTo(pln.Origin)\n        if pt.DistanceTo(pln.Origin) > max_dist:\n            max_dist = pt.DistanceTo(pln.Origin)\n\n    heights = []\n\n    for pln in plns:\n        print(pt.DistanceTo(pln.Origin))\n        temp = Remap(pt.DistanceTo(pln.Origin), max_dist,\n                     min_dist, min_layer_height, max_layer_height)\n        heights.append(temp)\n\n    print(max_dist)\n\n    moved_plns = []\n\n    for k, value in enumerate(heights):\n        origin = plns[k].Clone()\n        trans1 = rg.Transform.Translation(\n            rg.Vector3d(plns[k].Normal*heights[k]))\n        origin.Transform(trans1)\n        moved_plns.append(origin)\n\n    # print (max_layer_height)\n\n    return moved_plns\n\n\ndef make_layered_planes(plns):\n\n    if flip_vect:\n        for i in range(len(plns)):\n            plns[i] = rg.Plane(\n                plns[i].Origin, -plns[i].XAxis, plns[i].YAxis)\n        # print (new_layer_height)\n        # new_layer_height = -new_layer_height\n        # print (new_layer_height)\n    layered_planes = [plns]\n\n    for l in range(layer_nbr):\n        temp = []\n        for i, p in enumerate(layered_planes[l]):\n            layer_1 = deepcopy(p)\n            trans2 = rg.Transform.Translation(\n                rg.Vector3d(p.Normal*layer_height))\n            layer_1.Transform(trans2)\n            temp.append(layer_1)\n\n        temp.reverse()\n        layered_planes.append(temp)\n\n    return layered_planes\n\n\n# print(layer_height)\npts_divisions = (get_pts(curve))\n\n\n# ////////////////////////////////////////\npts_planes = make_planes(pts_divisions)\n# print (pts_planes)\nmoved_planes = move_planes(pts_planes, plns_move_pt,\n                           min_layer_height, max_layer_height)\n# layered_planes = th.list_to_tree(make_layered_planes(pts_planes))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}