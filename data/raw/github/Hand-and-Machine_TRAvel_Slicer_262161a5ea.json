{
  "source_url": "https://github.com/Hand-and-Machine/TRAvel_Slicer/blob/9e76041ef572288b290e12512c7bc7dfbcb0bbe4/src/contour_utils.py",
  "repo": "Hand-and-Machine/TRAvel_Slicer",
  "repo_stars": 6,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/contour_utils.py",
  "instruction": "Contour utils",
  "code": "import math\n\nimport Grid\nfrom Grid import *\n\nimport Graph\nfrom Graph import *\n\nimport Node\nfrom Node import *\n\nimport geometry_utils\nfrom geometry_utils import *\n\ndef get_contours(curve, offset, walls=3, wall_mode=False, separate_wall=True):\n    all_contours_time = time.time()\n\n    first_contours = [curve]\n\n    root = Node(\"root\")\n    root.depth = -1\n    isocontours = []\n\n    if not separate_wall:\n        root.data = curve\n\n    if first_contours != None:\n        for crv in first_contours:\n            node = root.add_child(crv)\n            node.is_wall = True\n            isocontours = isocontours + [crv]\n            new_curves = get_isocontours(crv, offset, node, walls=walls, wall_mode=wall_mode)\n            if new_curves:\n                for crv in new_curves:\n                    size = get_size(crv)\n                    if size>offset:\n                        isocontours.append(crv)\n\n    contour_time = time.time()-all_contours_time\n\n    return root, isocontours, contour_time\n\n\ndef get_isocontours(curve, offset, parent, wall_mode=False, walls=3):\n    new_curves = get_isocontour(curve, offset)\n    if not new_curves:\n        return []\n    else:\n        curves = [] + new_curves\n        new_depth = parent.depth+1\n        if (not wall_mode or (wall_mode and new_depth < walls)):\n            for c in new_curves:\n                node = parent.add_child(c)\n                new_new_curves = get_isocontours(c, offset, node, wall_mode=wall_mode, walls=walls)\n                for nc in new_new_curves:\n                    curves.append(nc)\n        return curves\n\n\ndef get_isocontour(curve, offset, reverse=False, fine_precision=False):\n    if not curve:\n        print(\"Error: get_isocontours not called with a curve\", curve)\n        return None\n    elif not rs.IsCurveClosed(curve):\n        if rs.IsCurveClosable(curve, offset*1.5):\n            curve = rs.CloseCurve(curve, offset*1.5)\n        else:\n            print(\"Error: get_isocontours called with an unclosable curve: \", curve)\n            return None\n\n    # get points and tangent vectors\n    if fine_precision: dist = get_segment_distance(offset/3)\n    else: dist = get_segment_distance(offset)\n    equi_pnts = [pnt for pnt in rs.DivideCurveEquidistant(curve, dist, True)]\n    if len(equi_pnts) < 4:\n        return None\n\n    points = [(equi_pnts[p], rs.VectorSubtract(equi_pnts[(p+1) % len(equi_pnts)], equi_pnts[(p-1) % len(equi_pnts)])) for p in range(len(equi_pnts))]\n    points = points + [(pnt, rs.CurveTangent(curve, rs.CurveClosestPoint(curve, pnt))) for pnt in get_corners(curve)]\n    points = sorted(points, key=lambda x: rs.CurveClosestPoint(curve, x[0]))\n\n    grid = Grid([pnt[0] for pnt in points], offset*1.5)\n\n    # determine each new p' at distance offset away from p\n    new_points_exist = False\n    discarded_points_exist = False\n\n    orientation = rs.ClosedCurveOrientation(curve)\n\n    new_points = [None]*len(points)\n    discarded_points = [None]*len(points)\n\n    # get \"up\" vector\n    up = rs.CreateVector(0, 0, 1)\n    for i in range(len(points)):\n        tangent = points[i][1]\n\n        if round(tangent.X, 3)==0 and round(tangent.Y, 3)==0 and round(tangent.Z, 3)==0:\n            tangent = rs.CurveTangent(curve, rs.CurveClosestPoint(curve, points[i][0]))\n        if round(tangent.X, 3)==0 and round(tangent.Y, 3)==0 and round(tangent.Z, 3)==0:\n            tangent = rs.VectorSubtract(points[(i+1) % len(equi_pnts)][0], points[(i-1) % len(equi_pnts)][0])\n\n        if round(tangent.X, 3)==0 and round(tangent.Y, 3)==0 and round(tangent.Z, 3)==0:\n            print(\"Unable to create tangent\", tangent)\n\n        # get vector orthogonal to tangent vector\n        if orientation == 1:\n            if reverse: ortho = rs.VectorCrossProduct(tangent, up)\n            else: ortho = rs.VectorCrossProduct(up, tangent)\n        elif orientation == -1:\n            if reverse: ortho = rs.VectorCrossProduct(up, tangent)\n            else: ortho = rs.VectorCrossProduct(tangent, up)\n        # normalize and scale orthogonal vector\n        ortho = rs.VectorScale(ortho, offset/rs.VectorLength(ortho))\n\n        # compute new point\n        new_point = rs.VectorAdd(points[i][0], ortho)\n\n        # make sure point is actually inside curve\n        include = True\n        # check that distance from all neighboring points is >= offset\n        neighbor_points = grid.get_neighbors(new_point)\n\n        for npoint in neighbor_points:\n            if not npoint == points[i][0] and rs.Distance(npoint, new_point) < offset:\n                include = False\n                break\n        if include:\n            new_points[i] = new_point\n            new_points_exist = True\n        else:\n            discarded_points[i] = new_point\n            discarded_points_exist = True\n\n    # if there are new points\n    if new_points_exist:\n        # if any points have been discarded\n        if discarded_points_exist:\n            # get list of lists of all sequential indices\n            init_sequences = [[]]\n            start_index = next((index for index, value in enumerate(new_points) if value != None and new_points[index-1] == None), -1)\n            if start_index !=- 1:\n                indices = range(start_index, len(new_points)) + range(0, start_index)\n                for i in indices:\n                    next_i = (i+1)%len(new_points)\n                    if new_points[i] != None:\n                        init_sequences[-1].append(i)\n                    elif new_points[next_i] != None and next_i != start_index:\n                        init_sequences.append([])\n\n            # verify that broken pieces of curve are inside or outside of parent contour\n            sequences = []\n            for seq in init_sequences:\n                if len(seq) > 1 and ((reverse and rs.CurveCurveIntersection(rs.AddCurve([new_points[idx] for idx in seq]), curve)==None and rs.PointInPlanarClosedCurve(new_points[seq[0]], curve)==0) or (not reverse and rs.PlanarClosedCurveContainment(rs.AddCurve([new_points[idx] for idx in seq+seq[-2:0:-1]+[seq[0]]]), curve)==2)):\n                    sequences.append(seq)\n                elif len(seq) == 1 and ((reverse and rs.PointInPlanarClosedCurve(new_points[seq[0]], curve)==0) or (not reverse and rs.PointInPlanarClosedCurve(new_points[seq[0]], curve)==1)):\n                    sequences.append(seq)\n\n            if len(sequences) == 0:\n                return None\n\n            # get start and end points of all sequences\n            start = [seq[0] for seq in sequences]\n            end = [seq[-1] for seq in sequences]\n\n            starts_grid = Grid([new_points[s] for s in start], offset*1.5)\n            all_starts = [new_points[k] for k in start]\n            # get connections between sequences\n            # prime connections dictionary with None index and large initial minimum distance\n            connections = {j: (None, 100000) for j in end}\n            # find shortest connection provided the line does not intersect the outer curve\n            for j in end:\n                neighbors = starts_grid.get_neighbors(new_points[j])\n                if len(neighbors)<=3: neighbors = starts_grid.get_neighbors(new_points[j], 3)\n                if len(neighbors)<=3: neighbors = all_starts\n                for n_pnt in neighbors:\n                    if n_pnt != new_points[j]:\n                        dist = rs.Distance(new_points[j], n_pnt)\n                        if dist < connections[j][1]:\n                            connections[j] = (new_points.index(n_pnt), dist)\n\n            # get rid of distances now that connections have been made\n            connections = {j: connections[j][0] for j in connections}\n\n            # get sequence grouping indices of connections\n            nodes = [[i] for i in range(len(sequences))]\n\n            # check through groupings until no more connections are found between sequences\n            connections_found = True\n            while connections_found:\n                connections_found = False\n                for node in nodes:\n                    idx = nodes.index(node)\n                    seq = sequences[node[-1]]\n                    connect = connections[seq[-1]]\n                    for node2 in nodes:\n                        seq2 = sequences[node2[0]]\n                        idx2 = nodes.index(node2)\n                        if idx != idx2 and connect in seq2:\n                            nodes[idx] = nodes[idx] + nodes[idx2]\n                            nodes.remove(node2)\n                            connections_found = True\n                            break\n                    if connections_found: break\n\n            # construct curves from groupings of indices\n            curves = []\n            for node in nodes:\n                curves.append([])\n                for idx in node:\n                    curves[-1] = curves[-1] + [new_points[i] for i in sequences[idx]]\n\n            # make sure curve is closed; add start point to the end\n            curves = [c+[c[0]] for c in curves]\n\n            # Transform point lists into curves\n            curves = [rs.AddCurve(c) for c in curves if len(c) > 2]\n            curves = [crv for crv in curves if ((reverse and rs.CurveCurveIntersection(crv, curve)==None) or (not reverse and rs.PlanarClosedCurveContainment(crv, curve)==2))]\n            return curves\n        else:\n            curves = [rs.AddCurve(new_points + [new_points[0]])]\n            curves = [crv for crv in curves if ((reverse and rs.CurveCurveIntersection(crv, curve)==None) or (not reverse and rs.PlanarClosedCurveContainment(crv, curve)==2))]\n            return curves\n    else:\n        return None\n\n\ndef trim_curve(curve, offset, start_pnt):\n    start_param = rs.CurveClosestPoint(curve, start_pnt)\n    start = rs.EvaluateCurve(curve, start_param)\n    split_circ = rs.AddCircle(start, offset)\n    intersection = rs.CurveCurveIntersection(curve, split_circ)\n\n    if intersection==None:\n        return curve\n\n    param = intersection[0][5]\n    for i in range(len(intersection)):\n        inter = intersection[i]\n        if inter[0] == 1:\n            trim_crv = rs.TrimCurve(curve, [start_param, inter[5]], delete_input=False)\n            crv_length = rs.CurveLength(trim_crv)\n            if crv_length<offset*2:\n                param = inter[5]\n    \n    return rs.TrimCurve(curve, [param, start_param], delete_input=False)\n\n\ndef connect_curve_groups(curve_groups, gap, initial_offset=0.0):\n    connected_curves = []\n    for crvs in curve_groups:\n        outer = []\n        if initial_offset > 0:\n            outer = get_isocontour(crvs[0], initial_offset)\n            if outer == None or len(outer) == 0:\n                # retry with higher precision\n                print(\"Retrying with higher precision.\")\n                outer = get_isocontour(crvs[0], initial_offset, fine_precision=True)\n        else:\n            outer = [crvs[0]]\n\n        holes = []\n        for c in range(1, len(crvs)):\n            if initial_offset > 0:\n                iso = get_isocontour(crvs[c], initial_offset, reverse=True)\n                holes = holes + iso\n            else:\n                holes.append(crvs[c])\n\n        inside = []\n        for h in range(len(holes)):\n            for o in range(len(outer)):\n                if rs.PlanarClosedCurveContainment(holes[h], outer[o])==2:\n                    inside.append(True)\n                    break\n                inside.append(False)\n\n        if all(inside) or len(holes)==0:\n            # All expanded hole curves are inside the contracted outer curve(s).\n            connected_curves.append(connect_curves(outer+holes, gap))\n        else:\n            # Expanded hole curves are not all inside the contracted outer curve(s).\n            print(\"Expanded hole curves are not all inside the contracted outer curve(s).\")\n            inside2 = []\n            for h in range(1, len(crvs)):\n                for o in range(len(outer)):\n                    if rs.PlanarClosedCurveContainment(crvs[h], outer[o])==2:\n                        inside2.append(True)\n                        break\n                    inside2.append(False)\n\n            if all(inside2):\n                # All original hole curves are inside the contracted outer curve(s).\n                connected_curves.append(connect_curves(outer+crvs[1:], gap))\n            else:\n                # Original hole curves are not all inside the contracted outer curve(s).\n                connected_curves.append(connect_curves(crvs, gap))\n    length1 = 0\n    for crv in crvs:\n        if crv is not None and rs.IsCurve(crv):\n            length1 = length1 + rs.CurveLength(crv)\n        else:\n            print(\"Not a curve\", crv)\n    return connected_curves\n\n\ndef connect_curves(curves, offset):\n    if len(curves) == 1:\n        return curves[0]\n\n    # construct a fully connected graph where each curve\n    # represents a single node in the graph, and edges\n    # are the minimum distance between each curve\n    graph = Graph()\n    for c in range(len(curves)):\n        node = Graph_Node(curves[c])\n        node.name = 'c' + str(c)\n        graph.add_node(node)\n\n    # find closest points between all curves and add edges\n    closest = {}\n    for c1 in range(len(curves)):\n        curve1 = curves[c1]\n        for c2 in range(c1+1, len(curves)):\n            curve2 = curves[c2]\n            id, pnt1, pnt2 = rs.CurveClosestObject(curve1, curve2)\n            weight = rs.Distance(pnt1, pnt2)\n\n            node1 = graph.get_node(curve1)\n            node2 = graph.get_node(curve2)\n            graph.add_edge(Graph_Edge(node1, node2, weight))\n            graph.add_edge(Graph_Edge(node2, node1, weight))\n\n            if closest.get(node1) == None: closest[node1] = {}\n            if closest.get(node2) == None: closest[node2] = {}\n            closest[node1][node2] = (pnt2, pnt1, weight)\n\n    # trim graph by ordering edges from most weighted to least\n    ordered_edges = get_edge_tuples(graph)\n\n    # remove edges, starting with most weighted and determine\n    # if nodes are still reachable from the start node\n    start_node = graph.get_node(curves[0])\n    for edge in ordered_edges:\n        node1 = edge[0]\n        node2 = edge[1]\n        weight = edge[2]\n        graph.remove_edge(node1, node2)\n        graph.remove_edge(node2, node1)\n\n        for node in graph.nodes:\n            if node != start_node:\n                if not graph.check_for_path(start_node, node)[0]:\n                    # add edge back if unable to reach all nodes\n                    # in graph from the start node (outermost curve)\n                    graph.add_edge(Graph_Edge(node1, node2, weight))\n                    graph.add_edge(Graph_Edge(node2, node1, weight))\n                    break\n\n    # split curves at shortest connection points to other curves\n    final_curve = None\n    min_edges = get_edge_tuples(graph)\n    for edge in min_edges:\n        node1 = edge[0]\n        node2 = edge[1]\n        split_point1 = get_connect_point(closest, node1, node2)[0]\n        split_curves1, split_ends1 = split_curve(node1.data, split_point1, tolerance=offset)\n        split_point2 = get_connect_point(closest, node2, node1)[0]\n        split_curves2, split_ends2 = split_curve(node2.data, split_point2, tolerance=offset)\n\n        pnt1_1 = split_ends1[0]\n        pnt1_2 = split_ends1[1]\n        pnt2_1 = split_ends2[0]\n        pnt2_2 = split_ends2[1]\n\n        all_curves = split_curves1 + split_curves2\n\n        crv1 = rs.AddCurve([pnt1_1, pnt2_1])\n        crv2 = rs.AddCurve([pnt1_2, pnt2_2])\n        intersect = rs.PlanarCurveCollision(crv1, crv2)\n\n        if not intersect:\n            all_curves.append(crv1)\n            all_curves.append(crv2)\n        else:\n            all_curves.append(rs.AddCurve([pnt1_1, pnt2_2]))\n            all_curves.append(rs.AddCurve([pnt1_2, pnt2_1]))\n        \n        final_curve = rs.JoinCurves(all_curves)[0]\n        node1.data = final_curve\n        node2.data = final_curve\n\n    #length1 = 0\n    #print(curves)\n    #for crv in curves:\n        #print(\"Object\", crv)\n        #print(\"Object type\", rs.ObjectType(rs.coerceguid(crv)))\n        #length1 = length1 + rs.CurveLength(crv)\n\n    #print(\"Difference in length between connected curves: \"+str(rs.CurveLength(final_curve)-length1))\n\n    return final_curve\n\n\ndef get_connect_point(closest, node1, node2):\n    split_point = None\n    connection = closest[node1].get(node2)\n    if connection:\n        split_point = connection[0]\n    else:\n        connection = closest[node2].get(node1)\n        split_point = connection[1]\n\n    weight = connection[2]\n    return split_point, weight\n\n\ndef get_edge_tuples(graph):\n    ordered_edges = []\n    for node1 in graph.edges:\n        for node2 in graph.edges[node1]:\n            weight = graph.edges[node1][node2]\n            if (node1, node2, weight) not in ordered_edges and (node2, node1, weight) not in ordered_edges:\n                ordered_edges.append((node1, node2, weight))\n\n    return sorted(ordered_edges, key=lambda x: x[2], reverse=True)\n\n\ndef split_curve_at(curve, points, tolerance=0):\n    curves = [curve]\n    split_ends = []\n\n    for point in points:\n        for crv in curves:\n            closest_pnt = rs.EvaluateCurve(crv, rs.CurveClosestPoint(crv, point))\n            if rs.Distance(closest_pnt, point) < tolerance:\n                curves.remove(crv)\n                split_curves, ends = split_curve(crv, point, tolerance)\n                split_ends = split_ends + ends\n                curves = curves + split_curves\n                break\n    \n    return curves, split_ends\n\n\ndef split_curve(curve, split_point, tolerance):\n    split_circ = rs.AddCircle(split_point, tolerance/2)\n    intersections = rs.CurveCurveIntersection(curve, split_circ)\n\n    split_curves = [curve]\n    if intersections!=None and len(intersections)>1:\n        split_curves = rs.TrimCurve(curve, [intersections[1][5], intersections[0][5]])\n        if type(split_curves) != list:\n            split_curves = [split_curves]\n    else:\n        print(\"Error: Unable to split curve at point.\")\n    \n    return split_curves, [intersections[0][1], intersections[1][1]]\n\n\ndef get_corners(curve, resolution=None):\n    corners = []\n    if rs.IsPolyline(curve):\n        poly = curve\n    elif resolution!=None and resolution>0:\n        poly = rs.ConvertCurveToPolyline(curve, min_edge_length=resolution/4)\n    else: poly = rs.ConvertCurveToPolyline(curve)\n\n    for pnt in rs.PolylineVertices(poly):\n        curv = rs.CurveCurvature(curve, rs.CurveClosestPoint(curve, pnt))\n        if curv!=None and curv[3]<0.5:\n            corners.append(pnt)\n\n    return corners",
  "language": "python",
  "imports": [],
  "has_docstring": false
}