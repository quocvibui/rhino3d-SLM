{
  "source_url": "https://github.com/ibois-epfl/Manis-timber-plate-joinery-solver/blob/9b0d22db181d4f55f01816440a5c0a31cda502bc/Gh%20compilation%20files/seqtree.py",
  "repo": "ibois-epfl/Manis-timber-plate-joinery-solver",
  "repo_stars": 12,
  "repo_description": "A grasshopper plugin to create joints between timber panels and export CNC toolpath and robot trajectories for fully automated workflow from design to fabrication to assembly.",
  "license": "MIT",
  "filepath": "Gh compilation files/seqtree.py",
  "instruction": "Convert a sequence (as text) to a datatree, or a datatree to a sequence. An optional list of data can also be sorted synchroneously.",
  "code": "\"\"\"Convert a sequence (as text) to a datatree, or a datatree to a sequence. An optional list of data can also be sorted synchroneously.\"\"\"\r\n\r\nfrom ghpythonlib.componentbase import dotnetcompiledcomponent as component\r\nimport Grasshopper, GhPython\r\nimport System\r\nimport copy\r\nimport ast\r\nfrom Grasshopper import DataTree\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\n\r\n__author__ = \"Nicolas Rogeau\"\r\n__laboratory__ = \"IBOIS, Laboratory for Timber Construction\" \r\n__university__ = \"EPFL, Ecole Polytechnique Federale de Lausanne\"\r\n__funding__ = \"NCCR Digital Fabrication, ETH Zurich\"\r\n__version__ = \"2021.09\"\r\n\r\nclass MyComponent(component):\r\n    def __new__(cls):\r\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\r\n            \"Sequence Tree Converter\", \"Seq and Tree\", \"\"\"Convert a sequence (as text) to a datatree, or a datatree to a sequence. An optional list of data can also be sorted synchroneously.\"\"\", \"Manis\", \"Utility\")\r\n        return instance\r\n    \r\n    def get_ComponentGuid(self):\r\n        return System.Guid(\"c25b2168-ece8-4318-b659-8106b6847c34\")\r\n    \r\n    def SetUpParam(self, p, name, nickname, description):\r\n        p.Name = name\r\n        p.NickName = nickname\r\n        p.Description = description\r\n        p.Optional = True\r\n    \r\n    def RegisterInputParams(self, pManager):\r\n        p = Grasshopper.Kernel.Parameters.Param_String()\r\n        self.SetUpParam(p, \"sequence\", \"sequence\", \"Sequence to convert to datatree.\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_Integer()\r\n        self.SetUpParam(p, \"datatree\", \"datatree\", \"Datatree to convert to sequence.\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.tree\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = GhPython.Assemblies.MarshalParam()\r\n        self.SetUpParam(p, \"data\", \"data\", \"List of data to organize according to the sequence (if a datatree is provided, the newly generated sequence will be used).\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\r\n        self.Params.Input.Add(p)\r\n        \r\n    \r\n    def RegisterOutputParams(self, pManager):\r\n        p = Grasshopper.Kernel.Parameters.Param_Integer()\r\n        self.SetUpParam(p, \"datatree\", \"datatree\", \"Generated datatree from sequence.\")\r\n        self.Params.Output.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_String()\r\n        self.SetUpParam(p, \"sequence\", \"sequence\", \"Generated sequence from datatree.\")\r\n        self.Params.Output.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\r\n        self.SetUpParam(p, \"match\", \"match\", \"Organized list matching sequence.\")\r\n        self.Params.Output.Add(p)\r\n        \r\n    \r\n    def SolveInstance(self, DA):\r\n        p0 = self.marshal.GetInput(DA, 0)\r\n        p1 = self.marshal.GetInput(DA, 1)\r\n        p2 = self.marshal.GetInput(DA, 2)\r\n        result = self.RunScript(p0, p1, p2)\r\n\r\n        if result is not None:\r\n            if not hasattr(result, '__getitem__'):\r\n                self.marshal.SetOutput(result, DA, 0, True)\r\n            else:\r\n                self.marshal.SetOutput(result[0], DA, 0, True)\r\n                self.marshal.SetOutput(result[1], DA, 1, True)\r\n                self.marshal.SetOutput(result[2], DA, 2, True)\r\n        \r\n    def get_Internal_Icon_24x24(self):\r\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAADkSURBVEhLtY/REYMwDEPpSp2pMzFTZ+pPGuVQznFkQwvo7kFkOTYspZRbaY/nuhaifIbv9b434U28Z81e9EQz0vCoVzX6NIy84tQC1lSdRDPSUBFlly0AKj+1YM+rGn0a+hrxGYhmdGMve5/he72Xl64Ej1s1bbya9vi8X4XYEFT1jOcol55FGwDhIe+poZe5XUDBTI1QPeP1qNhs6K2gpwlntYDyl7mAstnwEZa+gAUhO2grDX/QhEwxLSBOduAwHL0Z4QJi1AcDFNiTsbsAGP00HBxaADbxD2SP4vAC8N+CsnwB5cS2jP4jXZUAAAAASUVORK5CYII=\"\r\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\r\n\r\n    \r\n    def RunScript(self, sequence, datatree, data):\r\n\r\n        seq = sequence\r\n        tree = datatree\r\n\r\n        def flatten_integer_list(l):\r\n            \"\"\"Flatten a nested list of integers\"\"\"\r\n            if type(l) is list:\r\n                new_l=[]\r\n                num = None\r\n                for i in range(len(str(l))):\r\n                    char = str(l)[i]\r\n                    if char != '[' and char != ']' and char!= ' ' and char != ',':\r\n                        if num == None: num = char\r\n                        else: num += char\r\n                    elif num != None: \r\n                        new_l.append(int(num))\r\n                        num = None\r\n                return(new_l)\r\n            else: return l\r\n       \r\n        def seq_to_steps(seq):\r\n            step=[]\r\n            steps=[]\r\n            for i in range(len(str(seq))):\r\n                char = str(seq)[i]\r\n                if char == '[':\r\n                    index = 0\r\n                    step.append(index)\r\n                elif char == ']':\r\n                    del step[-1]\r\n                    index = 0\r\n                elif char == ' ':\r\n                    pass\r\n                elif char == ',':\r\n                    step[-1] += 1\r\n                if char == ',' or  char == '[':\r\n                    steps.append(copy.deepcopy(step))\r\n            return(steps)\r\n        \r\n        def deepest_steps(seq):\r\n            step=[]\r\n            steps=[]\r\n            for i in range(len(str(seq))):\r\n                char = str(seq)[i]\r\n                if char == '[':\r\n                    index = 0\r\n                    step.append(index)\r\n                elif char == ']':\r\n                    del step[-1]\r\n                    index = 0\r\n                elif char == ' ':\r\n                    pass\r\n                elif char == ',':\r\n                    step[-1] += 1\r\n                else:\r\n                    steps.append(copy.deepcopy(step))\r\n            return(steps)\r\n        \r\n        def get_item_from_path(l, path):\r\n            l = copy.deepcopy(l)\r\n            if type(path) == list:\r\n                for i in range(len(path)):\r\n                    l = l[path[i]]\r\n                return l\r\n\r\n        def seq_to_tree(text):\r\n            #sequence as text\r\n            seq = ast.literal_eval(text)\r\n            steps = seq_to_steps(seq)\r\n            deep = deepest_steps(seq)\r\n            tree = DataTree[object]()\r\n            for i in range(len(deep)):\r\n                path = deep[i]\r\n                item = get_item_from_path(seq, path)\r\n                temp = [item]\r\n                tree.Add(item, GH_Path(*path))\r\n            return tree\r\n\r\n        def tree_to_seq(tree):\r\n\r\n            # get tree paths as list of int\r\n            paths = []\r\n            parents = []\r\n            all_parents = []\r\n            for i in range(tree.BranchCount):\r\n                path_string = tree.Path(i).ToString()\r\n                path = []\r\n                num = None\r\n                for char in path_string:\r\n                    if char == '{' or char == ';' or char == '}':\r\n                        if num != None :\r\n                            path.append(num)\r\n                            num = None\r\n                    else : \r\n                        if num == None: num = int(char)\r\n                        else: num = int(str(num) + char)\r\n                paths.append(path)\r\n                #parents\r\n                all_par=[]\r\n                if len(path) == 1 : \r\n                    parents.append('M')\r\n                else: \r\n                    parents.append(path[0:len(path)-1])\r\n                    for j in range(len(path)-1):\r\n                        all_par.append(path[0:len(path)-1-j])\r\n                all_par.append('M')\r\n                all_parents.append(all_par)\r\n\r\n            # create sequence from paths\r\n            seq_as_string = ''\r\n            for i in range(len(paths)):\r\n                path = paths[i]\r\n                #add coma\r\n                if i != 0 : seq_as_string += ','\r\n                #if parent doesn't exists before, add opening parenthesis\r\n                if (parents[i] in parents[0:i]) is False:\r\n                    #add one parenthesis for each zero in path.\r\n                    last_zeros = 0\r\n                    for j in range(len(path)):\r\n                        if path[j] == 0: last_zeros += 1\r\n                        else: last_zeros = 0\r\n                    seq_as_string += '[' * last_zeros \r\n                #add number\r\n                seq_as_string += str(tree.AllData()[i])\r\n                #if parent doesn't exist after, add closing parenthesis\r\n                if (parents[i] in parents[i+1:len(parents)]) is False:\r\n                    #last parenthesis of the sequence\r\n                    if i+1 == len(paths):\r\n                        seq_as_string += ']' * len(path)\r\n                    else:\r\n                        count = 0\r\n                        search = True\r\n                        for j in range(len(all_parents[i])):\r\n                            if search == True:\r\n                                for k in range(len(all_parents[i+1])):\r\n                                    if search == True:\r\n                                        if all_parents[i][j] == all_parents[i+1][k]:\r\n                                            count = j\r\n                                            search = False\r\n                        seq_as_string += ']' * count\r\n            \r\n            return seq_as_string\r\n\r\n        def test_seq(seq):\r\n            flag = False\r\n            if (type(seq) is str):\r\n                if len(seq) > 2:\r\n                    if seq[0] == '[' and seq[-1] == ']':\r\n                        comas=0\r\n                        ophook=0\r\n                        clhook=0\r\n                        numbers=[]\r\n                        num = ''\r\n                        flag = True\r\n                        for i in range(len(seq)):\r\n                            if seq[i] == '[' : ophook += 1\r\n                            elif seq[i] == ']' : clhook += 1\r\n                            elif seq[i] == ',' : comas += 1\r\n                            elif seq[i] == ' ': pass\r\n                            elif seq[i] in ['0','1','2','3','4','5','6','7','8','9'] :\r\n                                num += seq[i]\r\n                                if seq[i+1] not in ['0','1','2','3','4','5','6','7','8','9']: \r\n                                    numbers.append(int(num))\r\n                                    num = ''\r\n                            else: raise Exception( 'Invalid character in sequence.')\r\n                        if ophook != clhook : raise Exception( 'Missing hook(s) in sequence.')\r\n                        if comas != len(numbers)-1 : raise Exception( 'Missing coma(s) in sequence.')\r\n                    else: raise Exception( 'Sequence should start and end with hooks.')\r\n            else: raise Exception( 'Sequence should be expressed as a string.')\r\n            if flag == False: raise Exception( 'Error is sequence input.')\r\n            return flag\r\n\r\n        def list_to_datatree(raggedList):\r\n            \"\"\"Python to Grasshopper\"\"\"\r\n            rl = raggedList\r\n            result = DataTree[object]()\r\n            for i in range(len(rl)):\r\n                temp = []\r\n                for j in range(len(rl[i])):\r\n                    temp.append(rl[i][j])\r\n                path = GH_Path(i)\r\n                result.AddRange(temp, path)\r\n            return result\r\n\r\n        if seq != None: \r\n            test_seq(seq)\r\n            tree = seq_to_tree(seq)\r\n        if tree != None: seq = tree_to_seq(tree) \r\n        \r\n        dt= []\r\n        count = 0\r\n        sequence = copy.deepcopy(seq)\r\n        if sequence and data: \r\n            sequence = ast.literal_eval(sequence)\r\n            for i in range(len(sequence)):\r\n                if type(sequence[i]) is list:\r\n                    intlist = flatten_integer_list(sequence[i])\r\n                else: intlist = [sequence[i]]\r\n                sub = []\r\n                for j in range(len(intlist)):\r\n                    sub.append(data[count])\r\n                    count += 1\r\n                dt.append(sub)\r\n            dt = list_to_datatree(dt)\r\n        match = dt\r\n        return (tree, seq, match)\r\n\r\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\r\n    def get_AssemblyName(self):\r\n        return \"Sequence Tree Converter\"\r\n    \r\n    def get_AssemblyDescription(self):\r\n        return \"\"\"\"\"\"\r\n\r\n    def get_AssemblyVersion(self):\r\n        return \"0.1\"\r\n\r\n    def get_AuthorName(self):\r\n        return \"Nicolas Rogeau\"\r\n    \r\n    def get_Id(self):\r\n        return System.Guid(\"15a9cdcb-1504-48fb-a114-4a7956733e65\")",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": true
}