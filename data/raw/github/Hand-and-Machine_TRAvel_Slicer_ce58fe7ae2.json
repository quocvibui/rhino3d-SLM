{
  "source_url": "https://github.com/Hand-and-Machine/TRAvel_Slicer/blob/9e76041ef572288b290e12512c7bc7dfbcb0bbe4/src/geometry_utils.py",
  "repo": "Hand-and-Machine/TRAvel_Slicer",
  "repo_stars": 6,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/geometry_utils.py",
  "instruction": "Geometry utils",
  "code": "import Rhino\nimport rhinoscriptsyntax as rs\n\nimport Graph\nfrom Graph import *\n\ndef get_area(curve):\n    try:\n        areaMass = Rhino.Geometry.AreaMassProperties.Compute(curve)\n        area = areaMass.Area\n        return area, True\n    except:\n        try:\n            area = rs.CurveAreaCentroid(rs.coercecurve(curve))\n            return area[1], True\n        except Exception as err:\n            print(err)\n            length = rs.CurveLength(curve)\n            print(\"Could not get area of curve. Curve is closed: \"+str(curve.IsClosed)+\". Curve length: \"+str(length), curve)\n            return 0, False\n\n\ndef get_area_center(curve):\n    try:\n        areaMass = curve.AreaMassProperties.Compute()\n        center = areaMass.Centroid\n        return center\n    except:\n        try:\n            return rs.CurveAreaCentroid(rs.coercecurve(curve))[0]\n        except:\n            try:\n                bbox = rs.BoundingBox(curve)\n                center = bbox[0] + 0.5*(bbox[2]-bbox[0])\n                return center\n            except Exception as err:\n                print(err)\n                length = rs.CurveLength(curve)\n                print(\"Could not get centroid of curve. Curve is closed: \"+str(curve.IsClosed)+\". Curve length: \"+str(length), curve)\n                return rs.CreatePoint(0, 0, rs.CurveStartPoint(curve).Z)\n\n\ndef get_size(shape):\n    # bounding box of shape\n    bb = rs.BoundingBox(shape)\n    size = rs.Distance(bb[0], bb[2])\n    return size\n\n\ndef get_shape_height(shape, xy_plane=True):\n    # bounding box of shape\n    bb = rs.BoundingBox(shape)\n    if xy_plane:\n        return rs.Distance([bb[0].X, bb[0].Y, 0], bb[4])\n    else:\n        return rs.Distance(bb[0], bb[4])\n\n\ndef get_longest_side(bb):\n    size = max(rs.Distance(bb[0], bb[1]), rs.Distance(bb[1], bb[2]))\n    return size\n\n\ndef xy_bbox_overlap(crv1, crv2, width=0):\n    w = float(width)/2\n    # do bounding boxes of shape overlap in XY plane\n    bb1 = rs.BoundingBox(crv1)\n    minX1 = bb1[0].X - w\n    minY1 = bb1[0].Y - w\n    maxX1 = bb1[2].X + w\n    maxY1 = bb1[2].Y + w\n    bb2 = rs.BoundingBox(crv2)\n    minX2 = bb2[0].X\n    minY2 = bb2[0].Y\n    maxX2 = bb2[2].X\n    maxY2 = bb2[2].Y\n    return minX1 < maxX2 and maxX1 > minX2 and minY1 < maxY2 and maxY1 > minY2\n\n\ndef get_plane(z):\n    return rs.PlaneFromNormal([0, 0, z], [0, 0, 1])\n\n\ndef get_surface(curve, z):\n    size = get_size(curve)*2\n\n    points = []\n    points.append(rs.CreatePoint(-size,-size,z))\n    points.append(rs.CreatePoint(-size,size,z))\n    points.append(rs.CreatePoint(size,size,z))\n    points.append(rs.CreatePoint(size,-size,z))\n    surface = rs.AddSrfPt(points)\n    return surface\n\n\ndef get_num_points(curve, tolerance):\n    dist = get_segment_distance(tolerance)\n    return max(int(rs.CurveLength(curve)/dist), 4)\n\n\ndef get_segment_distance(tolerance):\n    # we justify a coefficient of 1/2, the points\n    # overlap by half the extrusion width\n    k = 0.75\n    return float(tolerance)*k\n\n\ndef closest_point(point, points):\n    idx = None\n    min_dist = 1000000\n    for p in range(len(points)):\n        dist = rs.Distance(point, points[p])\n        if dist < min_dist:\n            min_dist = dist\n            idx = p\n    \n    return idx, min_dist\n\n\ndef get_shortest_indices(start, end, points):\n    indices = []\n\n    indices1 = []\n    indices2 = []\n\n    if start > end:\n        indices1 = range(start, len(points)) + range(0, end+1)\n        indices2 = range(start, end-1, -1)\n    elif start < end:\n        indices1 = range(start, end+1)\n        indices2 = range(start, -1, -1) + range(len(points)-1, end-1, -1)\n\n    points1 = [points[x] for x in indices1]\n    points2 = [points[x] for x in indices2]\n\n    curve_length_1 = 0\n    if len(points1) > 0: curve_length_1 = rs.CurveLength(rs.AddCurve(points1))\n    curve_length_2 = 0\n    if len(points2) > 0: curve_length_2 = rs.CurveLength(rs.AddCurve(points2))\n\n    if curve_length_1 < curve_length_2: indices = indices1\n    else: indices = indices2\n\n    return indices\n\n\ndef get_curves(shape, z, retry=0, initial_curves=None):\n    if initial_curves==None:\n        print(\"Slice shape at height \"+str(z))\n        if z == 0:\n            z = 0.1\n        plane = get_plane(float(z))\n        initial_curves = rs.AddSrfContourCrvs(shape, plane)\n\n    curves = repair_curves(initial_curves)\n\n    if initial_curves > 0 and len(curves) == 0 and retry==0:\n        print(\"Slicing shape at height \"+str(z)+\" was unsuccessful. Retrying at \"+str(round(float(z)+0.01, 3))+\".\")\n        return get_curves(shape, float(z)+0.01, retry=retry+1, initial_curves=None)\n    elif initial_curves > 0 and len(curves) == 0 and retry==1:\n        print(\"Slicing shape at height \"+str(z)+\" was unsuccessful. Retrying at \"+str(round(float(z)-0.02, 3))+\".\")\n        return get_curves(shape, float(z)-0.02, retry=retry+1, initial_curves=None)\n\n    try:\n        curve_groups = get_curve_groupings(curves)\n        if retry>0: print(\"Success after retry at height \"+str(z))\n        return curve_groups\n    except Exception as err:\n        print(\"Could not group curves at height \"+str(z), err)\n        return [curves]\n\n\ndef repair_curves(initial_curves):\n    if len(initial_curves) > 1:\n        initial_curves = rs.JoinCurves(initial_curves)\n\n    curves = []\n    for curve in initial_curves:\n        if curve is not None:\n            if not rs.IsCurve(curve):\n                print(\"Slice: contour is not curve\", curve)\n            elif not rs.IsCurveClosed(curve):\n                if rs.IsCurveClosable(curve):\n                    curves.append(rs.CloseCurve(curve))\n                else:\n                    print(\"Slice: curve is not closed and is not closable at height \"+str(rs.CurveStartPoint(curve).Z))\n            else:\n                curves.append(curve)\n\n    return curves\n\n\ndef get_curve_groupings(curves):\n    # find curve groupings from intersection of shape with plane\n    # curves can represent the inside of a surface or potentially\n    # a nested curve within another set of curves defining a surface\n    inside = {c:{} for c in range(len(curves))}\n    for c in range(len(curves)):\n        for c2 in range(c+1, len(curves)):\n            if xy_bbox_overlap(curves[c], curves[c2]):\n                containment = rs.PlanarClosedCurveContainment(curves[c], curves[c2])\n                if containment == 2:\n                    inside[c][c2] = True\n                    inside[c2][c] = False\n                elif containment == 3:\n                    inside[c][c2] = False\n                    inside[c2][c] = True\n                elif containment == 0:\n                    inside[c][c2] = False\n                    inside[c2][c] = False\n                else:\n                    print(\"Regions should not be intersecting: \", containment, curves[c], curves[c2])\n            else:\n                inside[c][c2] = False\n                inside[c2][c] = False\n\n    outer_curves = [c for c in range(len(curves)) if not any([inside[c][k] for k in inside[c]])]\n    inner_curves = [c for c in range(len(curves)) if c not in outer_curves]\n\n    iteration = 0\n    curve_groupings = {c:[] for c in outer_curves}\n    while len(inner_curves) > 0:\n        if iteration > 30: break\n        iteration = iteration+1\n        next_group = []\n        inner_copy = [c for c in inner_curves]\n        for c in outer_curves:\n            for c2 in inner_copy:\n                if inside[c2][c] and all([inside[c2][c3] == inside[c][c3] for c3 in inside[c2] if c3 != c]):\n                    curve_groupings[c].append(c2)\n                    next_group.append(c2)\n                    inner_curves.remove(c2)\n\n        outer_curves = []\n        inner_copy = [c for c in inner_curves]\n        for c in next_group:\n            for c2 in inner_copy:\n                if inside[c2][c] and all([inside[c2][c3] == inside[c][c3] for c3 in inside[c2] if c3 != c]):\n                    outer_curves.append(c2)\n                    curve_groupings[c2] = []\n                    inner_curves.remove(c2)\n\n    groups = [[c]+curve_groupings[c] for c in curve_groupings]\n    curve_groups = [[curves[c] for c in g] for g in groups]\n    return curve_groups\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}