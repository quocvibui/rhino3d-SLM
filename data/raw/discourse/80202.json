{
  "source_url": "https://discourse.mcneel.com/t/possible-define-an-image-and-assign-to-a-material/80202",
  "topic_id": 80202,
  "title": "Possible define an image and assign to a material?",
  "question": "Hi guys,\n\nis it possible for me to define an image (from scratch, pixle by pixle) and assign that as a texture to a material?\n\n\nI was thinking in the same way an image file can be embedded into Rhino that maybe we could have “virtual” image files too.\n\n\nI would need this to make a “terrain shader” and I would prefer not to generate a png/bmp/jpeg and save it next to the Rhino file.\n\n\nThanks!",
  "code_blocks": [
    {
      "code": "using System;\nusing System.Runtime.InteropServices;\nusing Rhino.Render;\nusing Rhino.Geometry;\nusing Rhino.UI;\nusing Rhino.DocObjects;\nusing Rhino.Commands;\nusing Rhino;\nusing System.Drawing;\nusing Rhino.Display;",
      "language": "csharp",
      "author": "nathanletwory",
      "post_number": 2,
      "is_solution": false
    },
    {
      "code": "using System;\nusing System.Runtime.InteropServices;\nusing Rhino.Render;\nusing Rhino.Geometry;\nusing Rhino.UI;\nusing Rhino.DocObjects;\nusing Rhino.Commands;\nusing Rhino;\nusing System.Drawing;\nusing Rhino.Display;\n\nnamespace Commands.Commands.Developer\n{\n\n\tpublic static class NathanData\n\t{\n\t\tpublic static Bitmap CreateMemoryBitmap()\n\t\t{\n\t\t\tvar width = 10;\n\t\t\tvar height = width;\n\t\t\tvar rnd = new Random();\n\t\t\tBitmap m_testBmp = new Bitmap(width, height);\n\t\t\tfor(var x = 0; x< width; x++)\n\t\t\t\tfor(var y = 0; y< height; y++)\n\t\t\t\t\tm_testBmp.SetPixel(x, y, Color.FromArgb(rnd.Next(255), rnd.Next(255), rnd.Next(255)));\n\t\t\treturn m_testBmp;\n\t\t}\n\n\t\tpublic static double Fraction(this double nr)\n\t\t{\n\t\t\tif(nr >= 0.0) return nr - Math.Floor(nr);\n\t\t\treturn nr - Math.Ceiling(nr);\n\t\t\t\n\t\t}\n\t\tpublic static double Floor(this double nr)\n\t\t{\n\t\t\treturn Math.Floor(nr);\n\t\t}\n\n\t}\n\t[CommandStyle(Style.Hidden)]\n\tpublic class TestNathanMemoryTexture : Command\n\t{\n\t\tpublic override string EnglishName { get { return \"TestNathanMemoryTexture\"; } }\n\n\t\tprotected override Result RunCommand(RhinoDoc doc, RunMode mode)\n\t\t{\n\t\t\tif (Result.Success == Rhino.Input.RhinoGet.GetOneObject(\"Select object\", false, ObjectType.Brep, out ObjRef obj))\n\t\t\t{\n\t\t\t\tvar rtex = new MemoryBitmapTexture() { BitmapTexture = NathanData.CreateMemoryBitmap() };\n\t\t\t\tvar mat = new Material();\n\t\t\t\tmat.Name = \"Testing MemoryBitmapTexture\";\n\t\t\t\tvar rm = RenderMaterial.CreateBasicMaterial(mat);\n\t\t\t\trm.SetChild(rtex, \"bitmap-texture\");\n\t\t\t\trm.SetChildSlotOn(\"bitmap-texture\", true, RenderContent.ChangeContexts.Ignore);\n\t\t\t\trm.SetChildSlotAmount(\"bitmap-texture\", 100.0, RenderContent.ChangeContexts.Ignore);\n\t\t\t\tvar t = rm.GetTextureFromUsage(RenderMaterial.StandardChildSlots.Diffuse);\n\n\t\t\t\trm.DocumentAssoc = doc;\n\n\t\t\t\tvar hash1 = rm.RenderHash;\n\n\t\t\t\tdoc.RenderMaterials.Add(rm);\n\t\t\t\trtex.BeginChange(RenderContent.ChangeContexts.Ignore);\n\t\t\t\trtex.SetProjectionMode(TextureProjectionMode.WcsBox, RenderContent.ChangeContexts.Ignore);\n\t\t\t\trtex.SetRepeat(new Vector3d(1.0, 1.0, 0.0), RenderContent.ChangeContexts.Ignore);\n\t\t\t\trtex.EndChange();\n\n\t\t\t\tvar hash2 = rm.RenderHash;\n\n\t\t\t\tvar o = obj.Object();\n\n\t\t\t\to.RenderMaterial = rm;\n\t\t\t\to.CommitChanges();\n\n\t\t\t\treturn Result.Success;\n\t\t\t}\n\n\t\t\treturn Result.Failure;\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Evaluator used by MemoryBitmapEvaluator.\n\t/// </summary>\n\tinternal class MemoryBitmapEvaluator : TextureEvaluator\n\t{\n\t\tprivate static readonly object locker = new object();\n\t\tpublic Bitmap BitmapTexture { get; set; }\n\t\tpublic MemoryBitmapEvaluator(RenderTexture.TextureEvaluatorFlags evaluatorFlags) : base(evaluatorFlags)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the color specified at uvw. Currently duvwdx and duvwdy aren't used (but probably should).\n\t\t/// </summary>\n\t\t/// <param name=\"uvw\"></param>\n\t\t/// <param name=\"duvwdx\"></param>\n\t\t/// <param name=\"duvwdy\"></param>\n\t\t/// <returns>The color for the given uvw coordinate.</returns>\n\t\tpublic override Color4f GetColor(Point3d uvw, Vector3d duvwdx, Vector3d duvwdy)\n\t\t{\n\t\t\tColor c = Color.AliceBlue;\n\t\t\tlock (locker)\n\t\t\t{\n\t\t\t\tvar x = Math.Max(0, Math.Min((int)(uvw.X.Fraction() * BitmapTexture.Width), BitmapTexture.Width));\n\t\t\t\tvar y = Math.Max(0, Math.Min((int)(uvw.Y.Fraction() * BitmapTexture.Height), BitmapTexture.Height));\n\t\t\t\tc = BitmapTexture.GetPixel(x, y);\n\t\t\t}\n\t\t\tvar cl = new Color4f(c);\n\n\t\t\treturn cl;\n\t\t}\n\t}\n\n\n\t/// <summary>\n\t/// A texture that provides a way to use an in-memory Bitmap as data.\n\t/// </summary>\n\t[Guid(\"34D9AC50-B958-476B-82D4-50F4DA1A5511\")]\n\t[CustomRenderContent(Category = \"image-based\", IsElevated = false, IsBuiltIn = true, ImageBased = true, IsPrivate = true)]\n\tpublic class MemoryBitmapTexture : RenderTexture\n\t{\n\t\t/// <summary>\n\t\t/// Set or get the Bitmap for this texture.\n\t\t/// </summary>\n\t\tpublic Bitmap BitmapTexture { get; set; }\n\n\t\t/// <summary>\n\t\t/// Create a new MemoryBitmapTexture instance.\n\t\t/// </summary>\n\t\tpublic MemoryBitmapTexture()\n\t\t{\n\t\t\tModifyRenderContentStyles(RenderContentStyles.LocalTextureMapping, RenderContentStyles.TextureSummary | RenderContentStyles.ModalEditing | RenderContentStyles.GraphDisplay);\n\n\t\t\tSetProjectionMode(TextureProjectionMode.WcsBox, ChangeContexts.Ignore);\n\n\t\t\tSetRepeat(new Vector3d(1.0, 1.0, 1.0), ChangeContexts.Ignore);\n\t\t\tSetRotation(new Vector3d(0.0, 0.0, 0.0), ChangeContexts.Ignore);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the TextureEvaluator for this texture.\n\t\t/// </summary>\n\t\t/// <param name=\"evaluatorFlags\">currently not used</param>\n\t\t/// <returns>A TextureEvaluator, or null if no Bitmap was set to BitmapTexture.</returns>\n\t\tpublic override TextureEvaluator CreateEvaluator(TextureEvaluatorFlags evaluatorFlags)\n\t\t{\n\t\t\tvar bm = BitmapTexture;\n\t\t\tif (bm == null) return null;\n\t\t\tvar eval = new MemoryBitmapEvaluator(evaluatorFlags) { BitmapTexture = bm };\n\t\t\treturn eval;\n\t\t}\n\n\t\tpublic override string TypeName\n\t\t{\n\t\t\tget { return Localization.LocalizeString(\"MemoryBitmap texture\", 1402); }\n\t\t}\n\n\t\tpublic override string TypeDescription\n\t\t{\n\t\t\tget { return Localization.LocalizeString(\"MemoryBitmap texture that is able to read from in-memory Bitmap objects\", 1403); }\n\t\t}\n\t}\n\n}",
      "language": "csharp",
      "author": "nathanletwory",
      "post_number": 2,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "materials",
    "rhinocommon"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 32,
  "views": 2516
}