{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_extractFacesByColor.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_extractFacesByColor.py",
  "instruction": "Spb brep extract faces by color",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n210324: Created.\r\n210511: Now breps are processed whose faces are all the same color.\r\n230915: Modified an option default value.\r\n250514: Added command prompts during processing.\r\n250604: Modified some command prompts and print frequencies of some command prompts.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\nfrom System.Drawing import Color\r\n\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n    key = 'bSingleColorByPick'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Extract'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'AllColors', 'PickedFaceColor')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTransferFaceColorToObject'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fPairMatchingDistTol':\r\n        #    if cls.riOpts[key].CurrentValue < 0:\r\n        #        cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n        #    elif cls.riOpts[key].CurrentValue < 1e-9:\r\n        #        cls.riOpts[key].CurrentValue = 1e-9\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select reference breps\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    idxs_Opt = {}\r\n\r\n    colorPicked = None\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bSingleColorByPick')\r\n        addOption('bTransferFaceColorToObject')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        if Opts.values['bSingleColorByPick']:\r\n            go.DisablePreSelect()\r\n            go.GeometryFilter = rd.ObjectType.Surface\r\n            go.SubObjectSelect = True\r\n            go.SetCommandPrompt(\"Select face\")\r\n\r\n            res = go.Get()\r\n            sc.escape_test()\r\n\r\n            if res == ri.GetResult.Object:\r\n                objref = go.Object(0)\r\n                rgFace = objref.Face()\r\n                if rgFace:\r\n                    colorPicked = rgFace.PerFaceColor\r\n                    rdBrep = objref.Object()\r\n                    go.Dispose()\r\n                    return (\r\n                        [rdBrep.Id],\r\n                        colorPicked,\r\n                        Opts.values['bTransferFaceColorToObject'],\r\n                        Opts.values['bEcho'],\r\n                        Opts.values['bDebug'],\r\n                        )\r\n\r\n                else:\r\n                    print(\"Face not picked!\")\r\n                    print(sc.doc.Objects.UnselectAll())\r\n        else:\r\n            go.GeometryFilter = rd.ObjectType.Brep\r\n            go.GeometryAttributeFilter = (\r\n                ri.Custom.GeometryAttributeFilter.ClosedPolysrf |\r\n                ri.Custom.GeometryAttributeFilter.OpenPolysrf\r\n                )\r\n            go.SubObjectSelect = False\r\n            go.SetCommandPrompt(\"Select breps\")\r\n\r\n            res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n            if res == ri.GetResult.Object:\r\n                objrefs = go.Objects()\r\n                go.Dispose()\r\n\r\n                gBreps = [o.ObjectId for o in objrefs]\r\n\r\n                return (\r\n                    gBreps,\r\n                    None,\r\n                    Opts.values['bTransferFaceColorToObject'],\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef setObjectColor(gObj, color):\r\n    rdObj = sc.doc.Objects.FindId(gObj)\r\n    rdObj.Attributes.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    rdObj.Attributes.ObjectColor = color\r\n    return rdObj.CommitChanges()\r\n\r\n\r\ndef removeAllFaceColors(gBrep):\r\n    rdB = sc.doc.Objects.FindId(gBrep)\r\n    rgB_Out = rdB.Geometry.Duplicate()\r\n    for f in rgB_Out.Faces:\r\n        f.PerFaceColor = Color.Empty\r\n    return sc.doc.Objects.Replace(objectId=gBrep, brep=rgB_Out)\r\n\r\n\r\ndef collectFaceColors(rgBrep):\r\n    colors_InBrep = []\r\n    idxFs_perColor = []\r\n\r\n    sCP_Base = Rhino.RhinoApp.CommandPrompt\r\n\r\n    iDivision = 20\r\n    if rgBrep.Faces.Count >= iDivision:\r\n        iFs_atDivision = [int(round((1.0/iDivision)*i*rgBrep.Faces.Count,0)) for i in range(iDivision)]\r\n\r\n    for iF, f in enumerate(rgBrep.Faces):\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Search canceled by user.\")\r\n\r\n        if rgBrep.Faces.Count == 1:\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\r\n                \"{}  Processing face...\".format(sCP_Base))\r\n        elif rgBrep.Faces.Count < iDivision:\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\r\n                \"{}  Processing face {} of {} ({}% complete)...\".format(\r\n                    sCP_Base,\r\n                    iF+1,\r\n                    rgBrep.Faces.Count,\r\n                    int(100*(iF+1)/rgBrep.Faces.Count),\r\n                    ))\r\n        elif iF in iFs_atDivision:\r\n            Rhino.RhinoApp.SetCommandPromptMessage(\r\n                \"{}  Processing face {} of {} ({}% complete)...\".format(\r\n                    sCP_Base,\r\n                    iF+1,\r\n                    rgBrep.Faces.Count,\r\n                    int(100*(iF+1)/rgBrep.Faces.Count),\r\n                    ))\r\n\r\n        #Rhino.RhinoApp.CommandPrompt = \"{}  Face {} of {}\".format(\r\n        #    sCP_Base,\r\n        #    iF + 1,\r\n        #    rgBrep.Faces.Count)\r\n\r\n        if f.PerFaceColor not in colors_InBrep:\r\n            colors_InBrep.append(f.PerFaceColor)\r\n            idxFs_perColor.append([f.FaceIndex])\r\n        else:\r\n            idxFs_perColor[colors_InBrep.index(f.PerFaceColor)].append(f.FaceIndex)\r\n\r\n    Rhino.RhinoApp.SetCommandPromptMessage(sCP_Base)\r\n\r\n    return colors_InBrep, idxFs_perColor\r\n\r\n\r\ndef processBrepObjects(gBreps_In, colors_toExtract=None, bXferFaceColorToObj=False, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    gBs_Out_AllBs = []\r\n\r\n    for iB, gB_In in enumerate(gBreps_In):\r\n\r\n        if len(gBreps_In) == 1:\r\n            sCP_Base = \"Analyzing 1 brep\"\r\n        else:\r\n            sCP_Base = \"Analysis at {:d}% of {} breps\".format(\r\n                int(100.0 * (iB+1) / len(gBreps_In)), len(gBreps_In))\r\n\r\n        if colors_toExtract is not None and len(colors_toExtract) == 1:\r\n            colorFind = colors_toExtract[0]\r\n            sCP_Base += \" for ARGB[{},{},{},{}]\".format(\r\n                colorFind.A,\r\n                colorFind.R,\r\n                colorFind.G,\r\n                colorFind.G,\r\n                )\r\n\r\n        Rhino.RhinoApp.SetCommandPromptMessage(sCP_Base)\r\n\r\n        rdB_In = sc.doc.Objects.FindId(gB_In)\r\n        rgB_In = rdB_In.Geometry\r\n\r\n        colors_InBrep, idxFs_perColor = collectFaceColors(rgB_In)\r\n\r\n\r\n        if len(colors_InBrep) == 1:\r\n            if colors_InBrep[0] == Color.Empty:\r\n                print(\"No PerFaceColor in brep.\")\r\n                continue\r\n\r\n            if bDebug:\r\n                print(\"All faces are the same PerFaceColor in brep.\")\r\n\r\n            if bXferFaceColorToObj:\r\n                if setObjectColor(gB_In, colors_InBrep[0]):\r\n                    removeAllFaceColors(gB_In)\r\n                    gBs_Out_AllBs.append(gB_In)\r\n\r\n            continue\r\n\r\n\r\n        # More than 1 PerFaceColor in brep.\r\n\r\n        sCP_Base = \"{} face colors found in brep.\".format(\r\n            len(colors_InBrep))\r\n        Rhino.RhinoApp.SetCommandPromptMessage(sCP_Base)\r\n\r\n        gBs_Out_ThisB = []\r\n\r\n        if colors_toExtract is None:\r\n            # Extract all colors.\r\n            for iColor, (color, idxFs) in enumerate(zip(colors_InBrep, idxFs_perColor)):\r\n                rc = xBrepObject.addFromSubsetOfFaces(\r\n                    gB_In,\r\n                    idxFs,\r\n                    bAddOnlyMonofaces=False,\r\n                    bRetainLayer=True,\r\n                    bRetainColor=True,\r\n                    bDebug=False)\r\n                if rc is not None:\r\n                    gBs_Out_ThisB.extend(rc)\r\n                    if bXferFaceColorToObj and color != Color.Empty:\r\n                        for gB_Out in rc:\r\n                            if setObjectColor(gB_Out, color):\r\n                                removeAllFaceColors(gB_Out)\r\n\r\n            if rgB_In.Faces.Count != sum(sc.doc.Objects.FindId(g).Geometry.Faces.Count for g in gBs_Out_ThisB):\r\n                print(\"Before and after faces counts do not match.  Original brep was not deleted.\")\r\n            else:\r\n                if sc.doc.Objects.Delete(objectId=gB_In, quiet=False):\r\n                    print(\"Original brep was replaced by {} breps of {} colors.\".format(\r\n                        len(gBs_Out_ThisB), len(colors_InBrep)))\r\n        else:\r\n            # Extract only colors in colors_InBrep.\r\n            idxs_Fs_NotTargetColor = []\r\n            iColor_toExtract = None\r\n            for iColor, color in enumerate(colors_InBrep):\r\n                sc.escape_test()\r\n                Rhino.RhinoApp.Wait()\r\n\r\n                if color in colors_toExtract:\r\n\r\n                    if len(colors_toExtract) == 1:\r\n                        Rhino.RhinoApp.SetCommandPromptMessage(\r\n                            \"Extracting {} faces...\".format(color))\r\n                    else:\r\n                        if iColor_toExtract is None:\r\n                            iColor_toExtract = 0\r\n                        else:\r\n                            iColor_toExtract += 1\r\n\r\n                        Rhino.RhinoApp.SetCommandPromptMessage(\r\n                            \"Extracting faces of color {} of {} ({}% complete)...\".format(\r\n                                iColor_toExtract+1,\r\n                                len(colors_toExtract),\r\n                                int(100*(iColor_toExtract+1)/len(colors_toExtract)),\r\n                                ))\r\n\r\n                    idxFs = idxFs_perColor[iColor]\r\n                    rc = xBrepObject.addFromSubsetOfFaces(\r\n                        rhBrep=gB_In,\r\n                        idxFaces=idxFs,\r\n                        bAddOnlyMonofaces=False,\r\n                        bRetainLayer=True,\r\n                        bRetainColor=True,\r\n                        bDebug=False)\r\n                    if rc is not None:\r\n                        gBs_Out_ThisB.extend(rc)\r\n                        if bXferFaceColorToObj:\r\n                            for gB_Out in rc:\r\n                                if setObjectColor(gB_Out, color):\r\n                                    removeAllFaceColors(gB_Out)\r\n                else:\r\n                    idxs_Fs_NotTargetColor.extend(idxFs_perColor[iColor])\r\n\r\n            rc = xBrepObject.addFromSubsetOfFaces(\r\n                rhBrep=gB_In,\r\n                idxFaces=idxs_Fs_NotTargetColor,\r\n                bAddOnlyMonofaces=False,\r\n                bRetainLayer=True,\r\n                bRetainColor=True,\r\n                bDebug=False)\r\n            if rc is not None:\r\n                gBs_Out_ThisB.extend(rc)\r\n\r\n            if rgB_In.Faces.Count != sum(sc.doc.Objects.FindId(g).Geometry.Faces.Count for g in gBs_Out_ThisB):\r\n                print(\"Before and after faces counts do not match.  Original brep was not deleted.\")\r\n            else:\r\n                if sc.doc.Objects.Delete(objectId=gB_In, quiet=False):\r\n                    print(\"Original brep was replaced by {} breps of {} colors.\".format(\r\n                        len(gBs_Out_ThisB), len(colors_InBrep)))\r\n\r\n\r\n        gBs_Out_AllBs.extend(gBs_Out_ThisB)\r\n\r\n    return gBs_Out_AllBs\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 7:\r\n        print(\"This script requires Rhino Version 7 or higher.\")\r\n        return\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        gBreps,\r\n        color_Picked,\r\n        bTransferFaceColorToObject,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n    \r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n    \r\n    processBrepObjects(\r\n        gBreps_In=gBreps,\r\n        colors_toExtract=[color_Picked],\r\n        bXferFaceColorToObj=bTransferFaceColorToObject,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug\r\n        )\r\n    \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}