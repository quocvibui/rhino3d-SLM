{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_2PDF_EnvelopeAreas.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_2PDF_EnvelopeAreas.py",
  "instruction": "Takes in a list of Honeybee zones and outputs print-ready (floor plan) objects for the Treated Floor Area (TFA). Will pull out any 'PHPP Room' information from the zones and create surfaces, color...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nTakes in a list of Honeybee zones and outputs print-ready (floor plan) objects for the Treated Floor Area (TFA). Will pull out any 'PHPP Room' information from the zones and create surfaces, color them by TFA factor, and create room-tags based on the data. Be sure you've used the 'Create PHPP Rooms' to assign parameters to the zones and geometry correctly before trying to use this.\r\r\n-    \r\r\n    Args:\r\r\n        _HBZones: A list of the Honeybee zone objects which are being analyzed in the model.\r\r\n        surfaceColor_: (Color) To color the Surface mesh / hatch for printing\r\r\n        outlineColor_: (Color) To color the Surface outline for printing\r\r\n        outlineWeight_: (float) Default 0.5 - print weight for the surface outlines\r\r\n    Returns:\r\r\n        filenames_: A list of autogenerated Filenames for use if you want.\r\r\n        geom_: A Tree of the geometry including the surfaces as colored meshes, and the surface outlines. Each unique assembly / construciton is one branch of the tree.\r\r\n        geomAttributes_: Rhino.DocObjects.ObjectAttributes for all the geometry\r\r\n        pageLabels_: Some text info that can be printed on the Layout page if you want.\r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_2PDF_EnvelopeAreas\"\r\r\nghenv.Component.NickName = \"2PDF | Envelope\"\r\r\nghenv.Component.Message = 'JUN_07_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"03 | PDF\"\r\r\n\r\r\nimport scriptcontext as sc\r\r\nfrom collections import defaultdict\r\r\nimport ghpythonlib.components as ghc\r\r\nfrom System import Object\r\r\nfrom Grasshopper import DataTree\r\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\r\nimport Rhino\r\r\nimport rhinoscriptsyntax as rs\r\r\n\r\r\nhb_hive = sc.sticky[\"honeybee_Hive\"]()\r\r\nHBZoneObjects = hb_hive.callFromHoneybeeHive(_HBZones)\r\r\n\r\r\ndef getGeometryFromHive(_HBZoneObjs, _srfcColor):\r\r\n    \"\"\"Used to sort the HB Hive zone Geometry by Construction Type \r\r\n    \r\r\n    Arguments:\r\r\n        _HBZoneObjs: The Honeybee Zones from the Hive\r\r\n        _color: The color for the returned Mesh\r\r\n    Returns:\r\r\n        geomByConstruction: Dictionary of all the Envelope Geometry (as colored Mesh) by Construction Name\r\r\n    \r\r\n    Ommits all interior surface types ('Interior Wall', etc..)\r\r\n    \"\"\"\r\r\n    geomByConstruction = defaultdict()\r\r\n    areasByConstruction = defaultdict()\r\r\n    wireframe = []\r\r\n    srfcColor = _srfcColor if _srfcColor != None else ghc.ColourRGB(255,255,168,230)\r\r\n    \r\r\n    for zone in _HBZoneObjs:\r\r\n        for surface in zone.surfaces:\r\r\n            # Clean up Surface Name\r\r\n            srfcName = surface.EPConstruction\r\r\n            srfcName = srfcName.replace('PHPP_CONST_', '')\r\r\n            srfcName = srfcName.replace('__Int__', '')\r\r\n            srfcName = srfcName.replace('_', ' ')\r\r\n            \r\r\n            # Geom to Mesh\r\r\n            geom = ghc.MeshColours(surface.geometry, srfcColor)\r\r\n            srfcArea =  ghc.Area(geom).area\r\r\n            \r\r\n            # Get the outer Edges for Boundary\r\r\n            boundaryEdges = ghc.MeshEdges(geom).naked_edges\r\r\n            boundary = ghc.JoinCurves(boundaryEdges, preserve=False)\r\r\n            \r\r\n            # Remove the EP Interior Elements\r\r\n            if srfcName == 'Interior Floor':\r\r\n                continue\r\r\n            if srfcName == 'Interior Wall':\r\r\n                continue\r\r\n            if srfcName == 'Interior Ceiling':\r\r\n                continue\r\r\n            \r\r\n            # Add Geom to dict\r\r\n            if srfcName in geomByConstruction.keys():\r\r\n                geomByConstruction[srfcName].append(geom)\r\r\n                geomByConstruction[srfcName].append(boundary)\r\r\n            else:\r\r\n                geomByConstruction[srfcName] = [geom, boundary]\r\r\n            \r\r\n            # Add Area to dict\r\r\n            if srfcName in areasByConstruction.keys():\r\r\n                areasByConstruction[srfcName] += srfcArea\r\r\n            else:\r\r\n                areasByConstruction[srfcName] = srfcArea\r\r\n    \r\r\n    return geomByConstruction, areasByConstruction\r\r\n\r\r\ngeom_ = DataTree[Object]()\r\r\npageLabels_ = DataTree[Object]()\r\r\ngeomAttributes_ = DataTree[Object]()\r\r\nfilenames_ = []\r\r\n\r\r\n# Setup the attributes to pass\r\r\nsurfaceAttributes = Rhino.DocObjects.ObjectAttributes()\r\r\nsurfaceAttributes.ObjectColor = surfaceColor_ if surfaceColor_ != None else ghc.ColourRGB(255,255,168,230)\r\r\nsurfaceAttributes.PlotWeight = float(outlineWeight_) if outlineWeight_ != None else 0.5\r\r\nsurfaceAttributes.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\r\r\nsurfaceAttributes.PlotColorSource = Rhino.DocObjects.ObjectPlotColorSource.PlotColorFromObject\r\r\nsurfaceAttributes.PlotWeightSource = Rhino.DocObjects.ObjectPlotWeightSource.PlotWeightFromObject\r\r\nsurfaceAttributes.DisplayOrder = -1 # 1 = Front, -1 = Back\r\r\n\r\r\ncurveAttributes = Rhino.DocObjects.ObjectAttributes()\r\r\ncurveAttributes.ObjectColor = outlineColor_ if outlineColor_ != None else ghc.ColourRGB(255,255,0,183)\r\r\ncurveAttributes.PlotWeight = float(outlineWeight_) if outlineWeight_ != None else 0.5\r\r\ncurveAttributes.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\r\r\ncurveAttributes.PlotColorSource = Rhino.DocObjects.ObjectPlotColorSource.PlotColorFromObject\r\r\ncurveAttributes.PlotWeightSource = Rhino.DocObjects.ObjectPlotWeightSource.PlotWeightFromObject\r\r\ncurveAttributes.DisplayOrder = 1 # 1 = Front, -1 = Back\r\r\n\r\r\nif len(HBZoneObjects) > 0:\r\r\n    geomDict, areasDict = getGeometryFromHive(HBZoneObjects, surfaceColor_)\r\r\n    \r\r\n    path = 0\r\r\n    for k, v in geomDict.items():\r\r\n        # Attributes\r\r\n        for item in v:\r\r\n            if rs.IsMesh(item):\r\r\n                geomAttributes_.Add(surfaceAttributes, GH_Path(path))\r\r\n            else:\r\r\n                geomAttributes_.Add(curveAttributes, GH_Path(path))\r\r\n        \r\r\n        # Rest of the outputs\r\r\n        geom_.AddRange(v, GH_Path(path))\r\r\n        pageLabels_.AddRange([k, '{:.1f} m2'.format(areasDict.get(k, 0.0))], GH_Path(path))\r\r\n        filenames_.append('Surfaces-{}'.format(k))\r\r\n        path += 1\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}