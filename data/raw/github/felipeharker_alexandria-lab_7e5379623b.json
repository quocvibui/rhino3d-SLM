{
  "source_url": "https://github.com/felipeharker/alexandria-lab/blob/1d3696f4b28ecc45579b5fbe5809a7e00699fa08/alexandria-application-files/alexandria-scripts/ghpython/image_sampler.py",
  "repo": "felipeharker/alexandria-lab",
  "repo_stars": 1,
  "repo_description": "a repo of documents, links, visual assets, drawings, videos, articles, etc. I find interesting. Brain dump, catch-all repo with limited structure. ",
  "license": "unknown",
  "filepath": "alexandria-application-files/alexandria-scripts/ghpython/image_sampler.py",
  "instruction": "Image Sampler via File Path (UV in 0..1)\nAuthor: FHarker + ChatGPT (2025.10)",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - ImagePath (GH: Path) | str | Image file path\n# - UVPts (GH: UV) | list[Rhino.Geometry.Point2d] | UV sample coordinates (0..1)\n# - Mode (GH: Mode) | str | Clamp/Repeat/Mirror mode\n# - FlipV (GH: FlipV) | bool | Flip V direction\n# Outputs:\n# - Colors (GH: C) | list[System.Drawing.Color] | Sampled colors\n# - Gray01 (GH: G) | list[float] | Luminance values 0..1\n# - Size (GH: Size) | str | Image pixel size text\n# - Report (GH: Report) | str | Execution summary\n\n\"\"\"Image Sampler via File Path (UV in 0..1)\nAuthor: FHarker + ChatGPT (2025.10)\n\"\"\"\n\nimport System\nimport os, math\nimport scriptcontext  # âœ… must be imported first\nfrom System.Drawing import Bitmap, Color\nfrom Rhino.Geometry import Point2d\n\n# ---------- helpers ----------\ndef _mirror_wrap(t):\n    ti = math.floor(t)\n    frac = t - ti\n    if int(ti) % 2 != 0:\n        frac = 1.0 - frac\n    return frac\n\ndef wrap01(x, mode):\n    if mode == 0:  # Clamp\n        return max(0.0, min(1.0, x))\n    elif mode == 1:  # Repeat\n        return x - math.floor(x)\n    else:  # Mirror\n        return _mirror_wrap(x)\n\ndef bilinear_sample(bmp, x, y):\n    \"\"\"x,y in pixel space (float). Returns Color via bilinear filtering.\"\"\"\n    w, h = bmp.Width, bmp.Height\n    x = max(0.0, min(w - 1.0, x))\n    y = max(0.0, min(h - 1.0, y))\n\n    x0 = int(math.floor(x))\n    y0 = int(math.floor(y))\n    x1 = min(x0 + 1, w - 1)\n    y1 = min(y0 + 1, h - 1)\n\n    fx = x - x0\n    fy = y - y0\n\n    c00 = bmp.GetPixel(x0, y0)\n    c10 = bmp.GetPixel(x1, y0)\n    c01 = bmp.GetPixel(x0, y1)\n    c11 = bmp.GetPixel(x1, y1)\n\n    def lerp(a, b, t): return a + (b - a) * t\n\n    a0 = lerp(c00.A, c10.A, fx); a1 = lerp(c01.A, c11.A, fx); a = int(lerp(a0, a1, fy))\n    r0 = lerp(c00.R, c10.R, fx); r1 = lerp(c01.R, c11.R, fx); r = int(lerp(r0, r1, fy))\n    g0 = lerp(c00.G, c10.G, fx); g1 = lerp(c01.G, c11.G, fx); g = int(lerp(g0, g1, fy))\n    b0 = lerp(c00.B, c10.B, fx); b1 = lerp(c01.B, c11.B, fx); b = int(lerp(b0, b1, fy))\n\n    return Color.FromArgb(a, r, g, b)\n\ndef to_gray01(col):\n    return (0.2126*col.R + 0.7152*col.G + 0.0722*col.B) / 255.0\n\ndef as_uv2(pt):\n    return float(pt.X), float(pt.Y)\n\n# ---------- sticky cache ----------\nkey = \"img_cache_v1\"\ncache = scriptcontext.sticky.get(key, {})\n\ndef get_bitmap(path):\n    if not path or not os.path.isfile(path):\n        return None, \"No file at path.\"\n    try:\n        mtime = os.path.getmtime(path)\n    except:\n        mtime = None\n    entry = cache.get(path)\n    if entry and entry.get(\"mtime\") == mtime:\n        return entry[\"bmp\"], \"Cached\"\n    try:\n        bmp = Bitmap(path)\n        cache[path] = {\"bmp\": bmp, \"mtime\": mtime}\n        scriptcontext.sticky[key] = cache\n        return bmp, \"Loaded\"\n    except Exception as e:\n        return None, \"Load error: %s\" % e\n\n# ---------- main ----------\nmode_map = {\"clamp\": 0, \"repeat\": 1, \"mirror\": 2}\nm = mode_map.get((Mode or \"Clamp\").strip().lower(), 0)\n\nbmp, status = get_bitmap(Path)\nC, G = [], []\n\nif bmp is None:\n    Size = \"0x0\"\n    Report = \"Image not available. \" + status\nelse:\n    w, h = bmp.Width, bmp.Height\n    Size = \"{}x{}\".format(w, h)\n    for p in UV:\n        u, v = as_uv2(p)\n        u = wrap01(u, m)\n        v = wrap01(v, m)\n        if FlipV:\n            v = 1.0 - v\n        x = u * (w - 1)\n        y = v * (h - 1)\n        col = bilinear_sample(bmp, x, y)\n        C.append(col)\n        G.append(to_gray01(col))\n    Report = \"OK ({})\".format(status)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}