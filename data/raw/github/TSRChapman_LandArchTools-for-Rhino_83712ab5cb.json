{
  "source_url": "https://github.com/TSRChapman/LandArchTools-for-Rhino/blob/43036cbbcab2bf756216f6a752f65e83aac3fccb/CalcGrade.py",
  "repo": "TSRChapman/LandArchTools-for-Rhino",
  "repo_stars": 5,
  "repo_description": "Custom Tools for Rhino made for Landscape Architects",
  "license": "BSD-3-Clause",
  "filepath": "CalcGrade.py",
  "instruction": "Copyright <2022> <Thomas Chapman>\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A...",
  "code": "\"\"\"\r\n\r\nCopyright <2022> <Thomas Chapman>\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\"\"\"\r\n\r\n# Calculate grade between two given points\r\n# By Thomas Chapman on 11/01/2021\r\n# Update Thomas Chapman on 31/07/2021\r\n\r\nimport rhinoscriptsyntax as rs\r\nimport math as m\r\nimport scriptcontext as sc\r\nimport System\r\nimport Rhino as r\r\nimport Rhino.Input as ri\r\nimport Rhino.Commands as rc\r\nimport Rhino.Geometry as rg\r\n\r\n\r\n# Determine Unit system and scale m input to unit system scale and close if not mm, cm, m\r\n\r\n\r\ndef CalcGrade():\r\n\r\n    try:\r\n        scale, imperial = scaling()\r\n\r\n        # Colours\r\n        pinkColour = System.Drawing.Color.FromArgb(255, 0, 133)\r\n        blueColour = System.Drawing.Color.FromArgb(82, 187, 209)\r\n        greyColour = System.Drawing.Color.FromArgb(216, 220, 219)\r\n        blackColour = System.Drawing.Color.FromArgb(0, 0, 0)\r\n\r\n        def GetPointDynamicDrawFunc(sender, args):\r\n            # draw a line from the first picked point to the current mouse point\r\n            currentPoint = args.CurrentPoint\r\n\r\n            if currentPoint.Z == 0:\r\n                projectedPoint = rg.Point3d(currentPoint.X, currentPoint.Y, pt1.Z)\r\n                line01 = rg.Line(pt1, currentPoint)\r\n                line02 = rg.Line(currentPoint, projectedPoint)\r\n                line03 = rg.Line(projectedPoint, pt1)\r\n                midPoint01 = line01.PointAt(0.5)\r\n                circle = rg.Circle(pt1, line03.Length)\r\n                args.Display.DrawCircle(circle, blackColour, 2)\r\n                args.Display.DrawLine(line01, blueColour, 4)\r\n                args.Display.DrawDot(midPoint01, \"No Grade\", greyColour, blackColour)\r\n\r\n            else:\r\n                projectedPoint = rg.Point3d(currentPoint.X, currentPoint.Y, pt1.Z)\r\n                line01 = rg.Line(pt1, currentPoint)\r\n                line02 = rg.Line(currentPoint, projectedPoint)\r\n                line03 = rg.Line(projectedPoint, pt1)\r\n                midPoint01 = line01.PointAt(0.5)\r\n                circle = rg.Circle(pt1, line03.Length)\r\n\r\n                # Calculate grade\r\n                hypotenuse = rs.Distance(pt1, currentPoint)\r\n\r\n                # Find the rise of given points in any order\r\n                if pt1.Z > currentPoint.Z:  # this is the negative direction\r\n                    rise = pt1.Z - currentPoint.Z\r\n                elif pt1.Z < currentPoint.Z:\r\n                    rise = currentPoint.Z - pt1.Z  # this is the positive direction\r\n\r\n                # Find the run of given points\r\n                run = m.sqrt(hypotenuse**2 - rise**2)\r\n\r\n                # Detect model units and scale to mm, if mm do nothing\r\n                rise = rise * scale\r\n                run = run * scale\r\n\r\n                grade = run / rise\r\n                if imperial == True:\r\n                    grade = (1 / grade) * 100\r\n                    gradeText = str(abs(round(grade, 2))) + \"%\"\r\n                else:\r\n                    gradeText = \"1:\" + str(abs(round(grade, 2)))\r\n                rs.EnableRedraw(True)\r\n\r\n                args.Display.DrawCircle(circle, blackColour, 2)\r\n                args.Display.DrawLine(line01, pinkColour, 4)\r\n                args.Display.DrawLine(line02, blueColour, 5)\r\n                args.Display.DrawLine(line03, blueColour, 4)\r\n                args.Display.DrawDot(midPoint01, gradeText, greyColour, blackColour)\r\n\r\n        # Get first point\r\n        gp = ri.Custom.GetPoint()\r\n        gp.Get()\r\n        if gp.CommandResult() == rc.Result.Success:\r\n            pt1 = gp.Point()\r\n            gp.DynamicDraw += GetPointDynamicDrawFunc\r\n            gp.Get()\r\n            if gp.CommandResult() == rc.Result.Success:\r\n                pt2 = gp.Point()\r\n            else:\r\n                print(\"Failed to get Second Point\")\r\n                return False\r\n        else:\r\n            print(\"Failed to get First Point\")\r\n            return False\r\n\r\n        if pt1:\r\n            if pt2:\r\n                rs.EnableRedraw(False)\r\n                hypotenuse = rs.Distance(pt1, pt2)\r\n\r\n                # Find the rise of given points in any order\r\n                if pt1.Z == pt2.Z:\r\n                    rs.EnableRedraw(True)\r\n                    print(\"No Grade Found\")\r\n                    return\r\n                if pt1.Z > pt2.Z:\r\n                    rise = pt1.Z - pt2.Z\r\n                elif pt1.Z < pt2.Z:\r\n                    rise = pt2.Z - pt1.Z\r\n\r\n                # Find the run of given points\r\n                run = m.sqrt(hypotenuse**2 - rise**2)\r\n\r\n                # Detect model units and scale to mm, if mm do nothing\r\n                rise = rise * scale\r\n                run = run * scale\r\n                # Calculate grade based on rise and run\r\n                try:\r\n                    grade = run / rise\r\n\r\n                except ZeroDivisionError:\r\n                    print(\"No Grade Found\")\r\n                    rs.EnableRedraw(True)\r\n                    exit()\r\n\r\n                # Print text dot to screen\r\n                curve = rg.Line(pt1, pt2)\r\n                midpoint = curve.PointAt(0.5)\r\n                if imperial == True:\r\n                    grade = (1 / grade) * 100\r\n                    rs.AddTextDot(str(abs(round(grade, 2))) + \"%\", midpoint)\r\n                else:\r\n                    rs.AddTextDot(\"1:\" + str(abs(round(grade, 2))), midpoint)\r\n                rs.EnableRedraw(True)\r\n\r\n    except:\r\n        print(\"Failed to execute\")\r\n        rs.EnableRedraw(True)\r\n        return\r\n\r\ndef scaling():\r\n    try:\r\n        unitNum = int(sc.doc.ModelUnitSystem)\r\n        # check to see if using metric\r\n        if (\r\n            unitNum != 1\r\n            and unitNum != 2\r\n            and unitNum != 3\r\n            and unitNum != 4\r\n            and unitNum != 5\r\n        ):\r\n            imperial = True\r\n        else:\r\n            imperial = False\r\n        # struct unit system for current file\r\n        unitSystem = System.Enum.ToObject(r.UnitSystem, unitNum)\r\n        # struct unitsystem obj for script use, using mm (2)\r\n        internalSystem = System.Enum.ToObject(r.UnitSystem, 2)\r\n        # Scale units to model units\r\n        scale = r.RhinoMath.UnitScale(internalSystem, unitSystem)\r\n        if scale:\r\n            return scale, imperial\r\n    except:\r\n        print(\"Failed to find system scale\")\r\n        rs.EnableRedraw(True)\r\n        return\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    CalcGrade()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}