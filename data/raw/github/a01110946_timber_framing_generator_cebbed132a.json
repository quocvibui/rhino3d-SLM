{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/cell_decomposition/cell_segmentation.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/cell_decomposition/cell_segmentation.py",
  "instruction": "File: timber_framing_generator/cell_decomposition/cell_segmentation.py",
  "code": "# File: timber_framing_generator/cell_decomposition/cell_segmentation.py\n\nfrom typing import List, Dict, Union, Optional, Tuple\nimport Rhino.Geometry as rg\nfrom src.timber_framing_generator.cell_decomposition.cell_types import (\n    create_wall_boundary_cell_data,\n    create_opening_cell_data,\n    create_stud_cell_data,\n    create_sill_cripple_cell_data,\n    create_header_cripple_cell_data,\n    CellDataDict,  # Import the type hint\n)\n\n\n# =============================================================================\n# Panel-Aware Helper Functions (JSON-compatible)\n# =============================================================================\n\ndef get_openings_in_range(\n    openings: List[Dict],\n    u_start: float,\n    u_end: float,\n    tolerance: float = 1e-6\n) -> List[Dict]:\n    \"\"\"Filter openings that fall within (or overlap with) a U-coordinate range.\n\n    Openings that partially overlap with the range are included and can be\n    clipped using clip_opening_to_range().\n\n    Args:\n        openings: List of opening dictionaries with u_start/u_end keys\n        u_start: Start of the U-range to filter by\n        u_end: End of the U-range to filter by\n        tolerance: Numeric tolerance for boundary checks\n\n    Returns:\n        List of opening dictionaries that overlap with the range\n    \"\"\"\n    result = []\n    for opening in openings:\n        o_u_start = opening.get('u_start', 0)\n        o_u_end = opening.get('u_end', 0)\n\n        # Check for overlap: opening overlaps if not completely before or after range\n        if o_u_end > u_start + tolerance and o_u_start < u_end - tolerance:\n            result.append(opening)\n\n    return result\n\n\ndef clip_opening_to_range(\n    opening: Dict,\n    u_start: float,\n    u_end: float\n) -> Optional[Dict]:\n    \"\"\"Clip an opening to fit within a U-coordinate range.\n\n    If the opening is completely outside the range, returns None.\n    If partially inside, returns a modified copy with adjusted u_start/u_end.\n\n    Args:\n        opening: Opening dictionary with u_start/u_end keys\n        u_start: Start of the U-range to clip to\n        u_end: End of the U-range to clip to\n\n    Returns:\n        Clipped opening dictionary, or None if completely outside range\n    \"\"\"\n    o_u_start = opening.get('u_start', 0)\n    o_u_end = opening.get('u_end', 0)\n\n    # Check if completely outside\n    if o_u_end <= u_start or o_u_start >= u_end:\n        return None\n\n    # Clip to range\n    clipped = dict(opening)  # Make a copy\n    clipped['u_start'] = max(o_u_start, u_start)\n    clipped['u_end'] = min(o_u_end, u_end)\n\n    return clipped\n\n\ndef check_opening_spans_panel_joint(\n    opening: Dict,\n    joint_u_coord: float,\n    tolerance: float = 1e-6\n) -> bool:\n    \"\"\"Check if an opening spans across a panel joint location.\n\n    This is typically an error condition - openings should not cross panel joints.\n\n    Args:\n        opening: Opening dictionary with u_start/u_end keys\n        joint_u_coord: U-coordinate of the panel joint\n        tolerance: Numeric tolerance for boundary checks\n\n    Returns:\n        True if the opening spans the joint, False otherwise\n    \"\"\"\n    o_u_start = opening.get('u_start', 0)\n    o_u_end = opening.get('u_end', 0)\n\n    return o_u_start + tolerance < joint_u_coord < o_u_end - tolerance\n\n\ndef get_panel_id_prefix(wall_id: str, panel_index: int) -> str:\n    \"\"\"Generate a panel ID prefix for cell IDs.\n\n    Args:\n        wall_id: The wall's ID\n        panel_index: Index of the panel within the wall\n\n    Returns:\n        Panel ID string (e.g., \"wall_1_panel_0\")\n    \"\"\"\n    return f\"{wall_id}_panel_{panel_index}\"\n\n\ndef generate_panel_cell_id(\n    wall_id: str,\n    panel_index: int,\n    cell_type: str,\n    cell_index: int\n) -> str:\n    \"\"\"Generate a cell ID that includes panel information.\n\n    Args:\n        wall_id: The wall's ID\n        panel_index: Index of the panel within the wall\n        cell_type: Cell type code (SC, OC, HCC, SCC)\n        cell_index: Index of the cell within the panel\n\n    Returns:\n        Cell ID string (e.g., \"wall_1_panel_0_SC_0\")\n    \"\"\"\n    panel_prefix = get_panel_id_prefix(wall_id, panel_index)\n    return f\"{panel_prefix}_{cell_type}_{cell_index}\"\n\n\ndef _calculate_corner_points(\n    u_start: float, u_end: float, v_start: float, v_end: float, base_plane\n) -> List:\n    \"\"\"\n    Calculates corner points for a cell data dictionary based on u and v ranges\n    using the provided base_plane. The method uses base_plane.PointAt(u, v) so that\n    the points are correctly placed in the plane's coordinate system.\n\n    If u_start > u_end or v_start > v_end, the values are swapped so that the lower value comes first.\n    \"\"\"\n    # Ensure that u_start is less than u_end, and v_start less than v_end.\n    if u_start > u_end:\n        u_start, u_end = u_end, u_start\n    if v_start > v_end:\n        v_start, v_end = v_end, v_start\n\n    # Use the plane's local coordinate system. In RhinoCommon, Plane.PointAt(u, v) returns:\n    #   base_plane.Origin + (base_plane.XAxis * u) + (base_plane.YAxis * v)\n    pt1 = base_plane.PointAt(u_start, v_start)\n    pt2 = base_plane.PointAt(u_end, v_start)\n    pt3 = base_plane.PointAt(u_end, v_end)\n    pt4 = base_plane.PointAt(u_start, v_end)\n\n    return [pt1, pt2, pt3, pt4]\n\n\ndef decompose_wall_to_cells(\n    wall_length: float,\n    wall_height: float,\n    opening_data_list: List[Dict[str, Union[str, float]]],\n    base_plane: rg.Plane,\n) -> Dict[str, Union[CellDataDict, List[CellDataDict]]]:\n    \"\"\"\n    Decomposes a wall into cells (dictionaries) based on openings and a base plane.\n\n    Args:\n        wall_length: The length of the wall.\n        wall_height: The height of the wall.\n        opening_data_list: A list of dictionaries, each representing an opening.\n        base_plane: The Rhino.Geometry.Plane representing the wall's base plane.\n\n    Returns:\n        A dictionary containing the different cell types and their data dictionaries,\n        including corner points in world coordinates (computed using base_plane).\n    \"\"\"\n    try:\n        # 1. Create the wall boundary cell (covers the entire wall)\n        wall_boundary_cell_data = create_wall_boundary_cell_data(\n            u_range=[0.0, wall_length], v_range=[0.0, wall_height]\n        )\n\n        # 2. For each opening, create an opening cell\n        opening_cells_data = []\n        for opening_data in opening_data_list:\n            oc_data = create_opening_cell_data(\n                u_range=[\n                    opening_data[\"start_u_coordinate\"],\n                    opening_data[\"start_u_coordinate\"] + opening_data[\"rough_width\"],\n                ],\n                v_range=[\n                    opening_data[\"base_elevation_relative_to_wall_base\"],\n                    opening_data[\"base_elevation_relative_to_wall_base\"]\n                    + opening_data[\"rough_height\"],\n                ],\n                opening_type=opening_data[\"opening_type\"],\n            )\n            opening_cells_data.append(oc_data)\n\n        # 3. Create stud cells in the gaps between openings.\n        stud_cells_data = []\n        current_u = 0.0\n        # Sort the opening cells by their starting u-coordinate.\n        sorted_opening_cells_data = sorted(\n            opening_cells_data, key=lambda cell_data: cell_data[\"u_start\"]\n        )\n        for opening_cell_data in sorted_opening_cells_data:\n            if opening_cell_data[\"u_start\"] > current_u:\n                stud_cells_data.append(\n                    create_stud_cell_data(\n                        u_range=[current_u, opening_cell_data[\"u_start\"]],\n                        v_range=[0.0, wall_height],\n                    )\n                )\n            current_u = max(current_u, opening_cell_data[\"u_end\"])\n        if current_u < wall_length:\n            stud_cells_data.append(\n                create_stud_cell_data(\n                    u_range=[current_u, wall_length], v_range=[0.0, wall_height]\n                )\n            )\n\n        # 4. For each opening cell, create sill and header cripple cells with validation.\n        sill_cripple_cells_data = []\n        header_cripple_cells_data = []\n        tol = 1e-6  # Tolerance for valid dimensions.\n        for opening_cell_data in opening_cells_data:\n            u_start = opening_cell_data[\"u_start\"]\n            u_end = opening_cell_data[\"u_end\"]\n            v_start = opening_cell_data[\"v_start\"]\n            # For a sill cripple cell, require that the horizontal extent is positive\n            # and that the opening's bottom is above the wall's base.\n            if (u_end - u_start) > tol and (v_start > tol):\n                sill_cell = create_sill_cripple_cell_data(\n                    u_range=[u_start, u_end], v_range=[0.0, v_start]\n                )\n                sill_cripple_cells_data.append(sill_cell)\n            else:\n                print(\n                    \"Skipping sill cripple cell: u_range=({},{}) or insufficient v_range (v_start={})\".format(\n                        u_start, u_end, v_start\n                    )\n                )\n\n            # For a header cripple cell, require that the horizontal extent is positive\n            # and that there is vertical space between the opening's top and the wall's top.\n            if (u_end - u_start) > tol and (\n                (wall_height - opening_cell_data[\"v_end\"]) > tol\n            ):\n                header_cell = create_header_cripple_cell_data(\n                    u_range=[u_start, u_end],\n                    v_range=[opening_cell_data[\"v_end\"], wall_height],\n                )\n                header_cripple_cells_data.append(header_cell)\n            else:\n                print(\n                    \"Skipping header cripple cell: insufficient vertical space (v_end={}, wall_height={})\".format(\n                        opening_cell_data.get(\"v_end\"), wall_height\n                    )\n                )\n\n        # 5. Build a dictionary grouping the different cell types.\n        cell_data_dict = {\n            \"wall_boundary_cell\": wall_boundary_cell_data,\n            \"opening_cells\": opening_cells_data,\n            \"stud_cells\": stud_cells_data,\n            \"sill_cripple_cells\": sill_cripple_cells_data,\n            \"header_cripple_cells\": header_cripple_cells_data,\n        }\n\n        # 6. For each cell in the dictionary, compute its corner points.\n        # Assume that _calculate_corner_points is available (imported or defined in this module)\n        for key, cell_group in cell_data_dict.items():\n            if isinstance(cell_group, list):\n                for cell in cell_group:\n                    u_s = cell.get(\"u_start\")\n                    u_e = cell.get(\"u_end\")\n                    v_s = cell.get(\"v_start\")\n                    v_e = cell.get(\"v_end\")\n                    # Only compute corner points if all four values are present.\n                    if None not in [u_s, u_e, v_s, v_e]:\n                        cell[\"corner_points\"] = _calculate_corner_points(\n                            u_s, u_e, v_s, v_e, base_plane\n                        )\n            elif isinstance(cell_group, dict):\n                u_s = cell_group.get(\"u_start\")\n                u_e = cell_group.get(\"u_end\")\n                v_s = cell_group.get(\"v_start\")\n                v_e = cell_group.get(\"v_end\")\n                if None not in [u_s, u_e, v_s, v_e]:\n                    cell_group[\"corner_points\"] = _calculate_corner_points(\n                        u_s, u_e, v_s, v_e, base_plane\n                    )\n\n        return cell_data_dict\n    except Exception as e:\n        import traceback\n        print(f\"Error in decompose_wall_to_cells: {str(e)}\")\n        print(traceback.format_exc())\n        raise\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}