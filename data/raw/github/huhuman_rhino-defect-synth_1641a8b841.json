{
  "source_url": "https://github.com/huhuman/rhino-defect-synth/blob/aec9f34c7273f7dcfcfdce7893e8ad91d8771c06/utils_loc/outputs.py",
  "repo": "huhuman/rhino-defect-synth",
  "repo_stars": 0,
  "repo_description": "Rhino Python scripts for parametric synthetic defect image generation",
  "license": "unknown",
  "filepath": "utils_loc/outputs.py",
  "instruction": "Rendering outputs for color, depth, normal, and masks.",
  "code": "\"\"\"Rendering outputs for color, depth, normal, and masks.\"\"\"\nimport os\nimport struct\n\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport System.Drawing as Drawing\nimport System.Drawing.Imaging as Imaging\n\n\ndef _ensure_out_dir(path):\n    out_dir = os.path.dirname(path) or \".\"\n    os.makedirs(out_dir, exist_ok=True)\n\n\ndef _validate_dimension(value, name):\n    parsed = int(value)\n    if parsed <= 0:\n        raise ValueError(f\"{name} must be a positive integer.\")\n    return parsed\n\n\ndef _resolve_capture_size(rhino_view, width=None, height=None, max_length=None):\n    \"\"\"\n    Resolve capture size.\n    If max_length is provided (without explicit width/height), preserve viewport aspect ratio\n    and set the longest side to max_length.\n    \"\"\"\n    size = rhino_view.ActiveViewport.Size\n    default_width = max(1, int(size.Width))\n    default_height = max(1, int(size.Height))\n\n    if max_length is not None and width is None and height is None:\n        target = _validate_dimension(max_length, \"max_length\")\n        if default_width >= default_height:\n            out_width = target\n            out_height = max(1, int(round(target * float(default_height) / float(default_width))))\n        else:\n            out_height = target\n            out_width = max(1, int(round(target * float(default_width) / float(default_height))))\n        return out_width, out_height\n\n    out_width = _validate_dimension(width, \"width\") if width is not None else default_width\n    out_height = _validate_dimension(height, \"height\") if height is not None else default_height\n    return out_width, out_height\n\n\ndef _capture_bitmap(rhino_view, width=None, height=None, max_length=None, transparent=False):\n    \"\"\"Capture the given view to a bitmap with optional size override.\"\"\"\n    resolved_width, resolved_height = _resolve_capture_size(\n        rhino_view=rhino_view,\n        width=width,\n        height=height,\n        max_length=max_length,\n    )\n    capture = Rhino.Display.ViewCapture()\n    capture.Width = resolved_width\n    capture.Height = resolved_height\n    capture.ScaleScreenItems = False\n    capture.DrawAxes = False\n    capture.DrawGrid = False\n    capture.DrawGridAxes = False\n    capture.TransparentBackground = bool(transparent)\n\n    # Ensure the viewport has drawn the latest state before capture.\n    rhino_view.Redraw()\n    rs.Sleep(50)\n\n    # CaptureToBitmap expects a RhinoView instance.\n    bitmap = capture.CaptureToBitmap(rhino_view)\n    if bitmap is None:\n        raise RuntimeError(\"View capture failed to produce a bitmap.\")\n    return bitmap\n\n\ndef _try_set_attr(target, name, value):\n    \"\"\"Best-effort setter for RhinoCommon attributes across Rhino versions.\"\"\"\n    if not hasattr(target, name):\n        return\n    try:\n        setattr(target, name, value)\n    except Exception:\n        pass\n\n\ndef _clone_display_attributes(attrs):\n    \"\"\"Create a mutable copy of display attributes with compatibility fallbacks.\"\"\"\n    if attrs is None:\n        return Rhino.Display.DisplayPipelineAttributes()\n\n    try:\n        return Rhino.Display.DisplayPipelineAttributes(attrs)\n    except Exception:\n        pass\n\n    if hasattr(attrs, \"Duplicate\"):\n        try:\n            return attrs.Duplicate()\n        except Exception:\n            pass\n\n    cloned = Rhino.Display.DisplayPipelineAttributes()\n    if hasattr(cloned, \"CopyContentsFrom\"):\n        try:\n            cloned.CopyContentsFrom(attrs)\n            return cloned\n        except Exception:\n            pass\n    return cloned\n\n\ndef _mask_display_mode():\n    return (\n        Rhino.Display.DisplayModeDescription.FindByName(\"Flat Shade\")\n        or Rhino.Display.DisplayModeDescription.FindByName(\"Base Color\")\n    )\n\n\ndef _build_mask_display_attributes(viewport):\n    \"\"\"\n    Build display attributes for segmentation-like masks:\n    no shadows/edges/transparency/post effects; preserve object/layer display colors.\n    \"\"\"\n    mode = _mask_display_mode()\n    base_mode = mode or viewport.DisplayMode\n    attrs = _clone_display_attributes(getattr(base_mode, \"DisplayAttributes\", None))\n\n    bool_overrides = {\n        \"CastShadows\": False,\n        \"DisableTransparency\": True,\n        \"FlatShade\": True,\n        \"IgnoreHighlights\": True,\n        \"PostProcessFrameBuffer\": False,\n        \"ShadowsOn\": False,\n        \"ShowAnnotations\": False,\n        \"ShowClippingPlanes\": False,\n        \"ShowConduits\": False,\n        \"ShowCurves\": False,\n        \"ShowIsocurves\": False,\n        \"ShowLights\": False,\n        \"ShowMeshEdges\": False,\n        \"ShowMeshNakedEdges\": False,\n        \"ShowMeshWires\": False,\n        \"ShowPoints\": False,\n        \"ShowSurfaceEdges\": False,\n        \"ShowText\": False,\n        \"UseAssignedObjectMaterial\": False,\n        \"UseCustomObjectColor\": False,\n        \"UseCustomObjectColorBackfaces\": False,\n        \"UseCustomObjectMaterial\": False,\n        \"UseCustomObjectMaterialBackfaces\": False,\n        \"UseObjectMaterial\": False,\n        \"UseObjectMaterialBackfaces\": False,\n        \"UseSingleObjectColor\": False,\n    }\n    for name, value in bool_overrides.items():\n        _try_set_attr(attrs, name, value)\n\n    _try_set_attr(attrs, \"ShadowEdgeBlur\", 0)\n\n    if hasattr(attrs, \"SetFill\"):\n        try:\n            attrs.SetFill(Drawing.Color.Black)\n        except Exception:\n            pass\n\n    return attrs\n\n\ndef _capture_mask_bitmap(rhino_view, width=None, height=None, max_length=None):\n    \"\"\"Capture mask bitmap with dedicated display attributes and AA disabled.\"\"\"\n    resolved_width, resolved_height = _resolve_capture_size(\n        rhino_view=rhino_view,\n        width=width,\n        height=height,\n        max_length=max_length,\n    )\n    out_size = Drawing.Size(resolved_width, resolved_height)\n    viewport = rhino_view.ActiveViewport\n    attrs = _build_mask_display_attributes(viewport)\n\n    prev_aa = None\n    aa_changed = False\n    try:\n        ogl = Rhino.ApplicationSettings.OpenGLSettings\n        prev_aa = ogl.AntialiasLevel\n        if prev_aa != 0:\n            ogl.AntialiasLevel = 0\n            aa_changed = True\n    except Exception:\n        prev_aa = None\n\n    try:\n        rhino_view.Redraw()\n        rs.Sleep(50)\n        bitmap = None\n        try:\n            bitmap = rhino_view.CaptureToBitmap(out_size, attrs)\n        except Exception:\n            try:\n                bitmap = rhino_view.CaptureToBitmap(attrs)\n            except Exception:\n                bitmap = None\n\n        if bitmap is None:\n            raise RuntimeError(\"RhinoView.CaptureToBitmap returned no bitmap for mask output.\")\n        return bitmap\n    finally:\n        if aa_changed and prev_aa is not None:\n            try:\n                Rhino.ApplicationSettings.OpenGLSettings.AntialiasLevel = prev_aa\n                rhino_view.Redraw()\n            except Exception:\n                pass\n\n\ndef _force_visible_objects_color_by_layer():\n    \"\"\"\n    Temporarily force visible objects to use layer color source.\n    Returns list of (obj_id, previous_source) for restoration.\n    \"\"\"\n    changed = []\n    for obj_id in rs.VisibleObjects() or []:\n        try:\n            prev_source = rs.ObjectColorSource(obj_id)\n            if prev_source is None or prev_source == 0:\n                continue\n            if rs.ObjectColorSource(obj_id, 0) is not None:\n                changed.append((obj_id, prev_source))\n        except Exception:\n            continue\n    return changed\n\n\ndef _restore_object_color_sources(changed_items):\n    for obj_id, source in changed_items:\n        try:\n            if rs.IsObject(obj_id):\n                rs.ObjectColorSource(obj_id, source)\n        except Exception:\n            continue\n\n\ndef _save_bitmap(bitmap, out_path):\n    \"\"\"Save a bitmap to disk as PNG.\"\"\"\n    if not out_path:\n        raise ValueError(\"An output path is required to save a capture.\")\n    _ensure_out_dir(out_path)\n    bitmap.Save(out_path, Imaging.ImageFormat.Png)\n    return out_path\n\n\ndef _write_pfm(out_path, width, height, channel_count, data):\n    \"\"\"\n    Minimal PFM (Portable Float Map) writer for float32 channel data.\n    Stores values in little-endian, row order from top to bottom.\n    \"\"\"\n    _ensure_out_dir(out_path)\n    scale = -1.0  # negative for little-endian\n    header = f\"PF\\n{width} {height}\\n{scale}\\n\" if channel_count == 3 else f\"Pf\\n{width} {height}\\n{scale}\\n\"\n    with open(out_path, \"wb\") as f:\n        f.write(header.encode(\"ascii\"))\n        packed = struct.pack(f\"<{len(data)}f\", *list(data))\n        f.write(packed)\n    return out_path\n\n\ndef _capture_render_channels_to_files(rhino_view, depth_path, normal_path, width=None, height=None, renderer_id=None):\n    \"\"\"\n    Use the CaptureRenderChannels Rhino command (from the C# plugin) to write PFM files.\n    \"\"\"\n    if not depth_path or not normal_path:\n        raise ValueError(\"depth_path and normal_path are required.\")\n    view_name = rhino_view.ActiveViewport.Name\n    width_value = int(width) if width else 0\n    height_value = int(height) if height else 0\n\n    # Force the same active view used by color capture and let the command\n    # consume active view with Enter to avoid accidental lookup mismatch.\n    rs.CurrentView(view_name)\n    rhino_view.Redraw()\n    rs.Sleep(50)\n\n    cmd_parts = [\n        \"-CaptureRenderChannels\",\n        f'\"{depth_path}\"',\n        f'\"{normal_path}\"',\n        \"_Enter\",\n        str(width_value),\n        str(height_value),\n    ]\n    if renderer_id:\n        cmd_parts.append(f'\"{renderer_id}\"')\n    else:\n        cmd_parts.append(\"_Enter\")\n\n    ok = rs.Command(\" \".join(cmd_parts), echo=False)\n    if not ok:\n        raise RuntimeError(\"CaptureRenderChannels command failed. Is the plugin loaded?\")\n\n\ndef render_image(rhino_view, out_path=None, preset=None, width=None, height=None, max_length=None):\n    \"\"\"\n    Render the active/named view to an image file.\n\n    Args:\n        rhino_view: Rhino view object.\n        out_path: filepath for the color render.\n        preset: render preset name (display mode name).\n        width: optional override width.\n        height: optional override height.\n        max_length: optional longest-side resolution that preserves aspect ratio.\n    \"\"\"\n    rs.CurrentView(rhino_view.ActiveViewport.Name)\n    prev_mode = rhino_view.ActiveViewport.DisplayMode\n\n    try:\n        if preset:\n            mode = Rhino.Display.DisplayModeDescription.FindByName(preset)\n            if mode:\n                rhino_view.ActiveViewport.DisplayMode = mode\n        bitmap = _capture_bitmap(rhino_view, width=width, height=height, max_length=max_length)\n        return _save_bitmap(bitmap, out_path)\n    finally:\n        rhino_view.ActiveViewport.DisplayMode = prev_mode\n        rhino_view.Redraw()\n\n\ndef render_depth(rhino_view, out_path=None, width=None, height=None, max_length=None):\n    \"\"\"Render a depth pass for the view using Rhino's ZBuffer preview.\"\"\"\n    rs.CurrentView(rhino_view.ActiveViewport.Name)\n    prev_mode = rhino_view.ActiveViewport.DisplayMode\n\n    try:\n        rs.Command(\"-ShowZBuffer _Enter\", echo=False)\n        bitmap = _capture_bitmap(rhino_view, width=width, height=height, max_length=max_length)\n        return _save_bitmap(bitmap, out_path)\n    finally:\n        # Toggle back to the previous display and restore the original mode.\n        rs.Command(\"-ShowZBuffer _Enter\", echo=False)\n        rhino_view.ActiveViewport.DisplayMode = prev_mode\n        rhino_view.Redraw()\n\n\ndef render_normal(rhino_view, out_path=None, width=None, height=None, max_length=None):\n    \"\"\"Render a normal pass for the view using the test normal map preview.\"\"\"\n    rs.CurrentView(rhino_view.ActiveViewport.Name)\n    prev_mode = rhino_view.ActiveViewport.DisplayMode\n\n    try:\n        rs.Command(\"-TestShowNormalMap _Enter\", echo=False)\n        bitmap = _capture_bitmap(rhino_view, width=width, height=height, max_length=max_length)\n        return _save_bitmap(bitmap, out_path)\n    finally:\n        rs.Command(\"-TestShowNormalMap _Enter\", echo=False)\n        rhino_view.ActiveViewport.DisplayMode = prev_mode\n        rhino_view.Redraw()\n\n\ndef render_mask(rhino_view, out_path=None, width=None, height=None, max_length=None):\n    \"\"\"\n    Render an object mask pass using explicit display attributes for crisp layer colors.\n    \"\"\"\n    rs.CurrentView(rhino_view.ActiveViewport.Name)\n    viewport = rhino_view.ActiveViewport\n    prev_mode = viewport.DisplayMode\n    prev_grid = getattr(viewport, \"ConstructionGridVisible\", None)\n    prev_cplane = getattr(viewport, \"ConstructionPlaneVisible\", None)\n\n    if prev_grid is not None:\n        viewport.ConstructionGridVisible = False\n    if prev_cplane is not None:\n        viewport.ConstructionPlaneVisible = False\n    changed_sources = _force_visible_objects_color_by_layer()\n    try:\n        try:\n            bitmap = _capture_mask_bitmap(rhino_view, width=width, height=height, max_length=max_length)\n        except Exception:\n            # Compatibility fallback to previous behavior if custom capture fails.\n            flat_mode = _mask_display_mode()\n            if flat_mode:\n                viewport.DisplayMode = flat_mode\n            rhino_view.Redraw()\n            bitmap = _capture_bitmap(\n                rhino_view,\n                width=width,\n                height=height,\n                max_length=max_length,\n                transparent=False,\n            )\n        return _save_bitmap(bitmap, out_path)\n    finally:\n        _restore_object_color_sources(changed_sources)\n        viewport.DisplayMode = prev_mode\n        rhino_view.Redraw()\n\n\ndef render_all_outputs(view=None, out_dir=None, basename=\"frame\", width=None, height=None, max_length=None):\n    \"\"\"\n    Convenience helper to render color, depth, normal, and mask in one call.\n    \"\"\"\n    if not out_dir:\n        raise ValueError(\"out_dir is required to save renders.\")\n\n    outputs = {\n        \"color\": os.path.abspath(os.path.join(out_dir, f\"color/{basename}.png\")),\n        \"depth\": os.path.abspath(os.path.join(out_dir, f\"depth/{basename}.png\")),\n        \"normal\": os.path.abspath(os.path.join(out_dir, f\"normal/{basename}.png\")),\n        \"depth_linear\": os.path.abspath(os.path.join(out_dir, f\"depth_buffer/{basename}.pfm\")),\n        \"normal_linear\": os.path.abspath(os.path.join(out_dir, f\"normal_buffer/{basename}.pfm\")),\n        \"mask\": os.path.abspath(os.path.join(out_dir, f\"mask/{basename}.png\")),\n    }\n    for path in outputs.values():\n        _ensure_out_dir(path)\n\n    render_view = sc.doc.Views.ActiveView if view is None else sc.doc.Views.Find(view, False)\n    mode = Rhino.Display.DisplayModeDescription.FindByName(\"Rendered\")\n    render_view.ActiveViewport.DisplayMode = mode\n    for layer in sc.doc.Layers:\n        if layer.Name:\n            if \"CS\" in layer.Name:\n                layer.IsVisible = False\n            else:\n                layer.IsVisible = True\n\n    prev_wallpaper_file = render_view.ActiveViewport.WallpaperFilename\n    render_view.Redraw()\n\n    capture_width, capture_height = _resolve_capture_size(\n        rhino_view=render_view,\n        width=width,\n        height=height,\n        max_length=max_length,\n    )\n    view_size = render_view.ActiveViewport.Size\n    view_ratio = float(view_size.Width) / float(max(1, view_size.Height))\n    out_ratio = float(capture_width) / float(max(1, capture_height))\n    if abs(view_ratio - out_ratio) > 1e-6:\n        print(\n            \"Warning: viewport/output aspect mismatch may cause buffer FOV mismatch \"\n            f\"(view={view_size.Width}x{view_size.Height}, out={capture_width}x{capture_height}).\"\n        )\n\n    render_image(rhino_view=render_view, out_path=outputs[\"color\"], width=capture_width, height=capture_height)\n    # Capture linear channels in the same camera/display/layer state as color.\n    _capture_render_channels_to_files(\n        render_view,\n        depth_path=outputs[\"depth_linear\"],\n        normal_path=outputs[\"normal_linear\"],\n        width=capture_width,\n        height=capture_height,\n    )\n\n    render_depth(rhino_view=render_view, out_path=outputs[\"depth\"], width=capture_width, height=capture_height)\n\n    render_view.ActiveViewport.SetWallpaper(\"\", False)\n\n    render_normal(rhino_view=render_view, out_path=outputs[\"normal\"], width=capture_width, height=capture_height)\n\n    for layer in sc.doc.Layers:\n        if layer.Name == \"crack_extrusion\":\n            layer.IsVisible = False\n        else:\n            layer.IsVisible = True\n    render_view.Redraw()\n\n    render_mask(rhino_view=render_view, out_path=outputs[\"mask\"], width=capture_width, height=capture_height)\n\n    render_view.ActiveViewport.SetWallpaper(prev_wallpaper_file, False)\n\n    return outputs \n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}