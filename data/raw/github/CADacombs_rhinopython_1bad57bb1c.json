{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_clearance.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_clearance.py",
  "instruction": "Spb clearance",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160718-22: Created.\r\n...\r\n230927: Added option to disable reflection loop.  Previously, reflection count had to be set to 1.\r\n231013-14: Refactored.  Relabeled command options.\r\n        Replaced V5-era library functions to obtain geometry within blocks with RhinoCommon 6+ methods.\r\n        Reversed the order of using picked objects in main routine to be more intuitive.\r\n231030: Added a option to add a point at intersection for trimming curves.\r\n250427: Modified some option default values.\r\n\r\nTODO: Fix functionality of post pick point for non-Brep/BrepFaces.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bFaceForA'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'FaceFilter'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPostPickPtOnA'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'StartPt'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'ReusePicked', 'PickNew')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bFaceForB'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'FaceFilter'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPostPickPtOnB'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'StartPt'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'ReusePicked', 'PickNew')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLoopToMin'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'LoopToLocalMin'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iIters_Max'; keys.append(key)\r\n    values[key] = 1000\r\n    names[key] = 'MaxLoopIters'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fMinPtDelta'; keys.append(key)\r\n    values[key] = max((2.0*sc.doc.ModelAbsoluteTolerance, 1e-6))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAddMarks'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddLine'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Line'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddPt'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Pt'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Dot'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotDecPlaces'; keys.append(key)\r\n    values[key] = 3 if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches else sc.doc.DistanceDisplayPrecision - 2\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iDotFontHt'; keys.append(key)\r\n    values[key] = 11\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'iIters_Max':\r\n            if cls.riOpts[key].CurrentValue <= 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef areLayerAndAllAncestorsVisible(idx_rdLayer_Child):\r\n    \r\n    rdLayer_Child = sc.doc.Layers[idx_rdLayer_Child]\r\n    if not rdLayer_Child.IsVisible: return False\r\n    \r\n    idLayer_Parent = rdLayer_Child.ParentLayerId\r\n    if idLayer_Parent == idLayer_Parent.Empty: return True\r\n    else:\r\n        idx_rdLayer_Parent = sc.doc.Layers.Find(idLayer_Parent, True)\r\n        return areLayerAndAllAncestorsVisible(idx_rdLayer_Parent)\r\n\r\n\r\ndef _addTextDot(pt, text='', iDotFontHt=11):\r\n    rgDot = rg.TextDot(text, pt)\r\n    rgDot.FontHeight = iDotFontHt\r\n    sc.doc.Objects.AddTextDot(rgDot)\r\n\r\n\r\ndef _xformedRgObjOfBlock_WireframePick(rdInstRef, pt, xform=rg.Transform.Identity):\r\n    \r\n    xform *= rdInstRef.InstanceXform\r\n    rdInstDef = rdInstRef.InstanceDefinition\r\n    rdObjs = rdInstDef.GetObjects()\r\n    rgObj_BreporEdge = None\r\n    \r\n    for rdObj in rdObjs:\r\n        if not areLayerAndAllAncestorsVisible(rdObj.Attributes.LayerIndex):\r\n            continue\r\n        if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n            rgObj = _xformedRgObjOfBlock_WireframePick(rdObj, pt, xform)\r\n            if rgObj is not None: return rgObj\r\n        else: # Object is not a block instance\r\n            rgObj = rdObj.Geometry\r\n            rgObj.Transform(xform)\r\n            \r\n            # Points and curves have precedence over breps and extrusions.\r\n            if rgObj.ObjectType == rd.ObjectType.Point:\r\n                ptOn = rgObj.Location\r\n                if pt.EpsilonEquals(ptOn, .01*sc.doc.ModelAbsoluteTolerance):\r\n                    return rgObj\r\n                continue\r\n            if rgObj.ObjectType == rd.ObjectType.Curve:\r\n                bPt, t = rgObj.ClosestPoint(pt)\r\n                ptOn = rgObj.PointAt(t)\r\n                if pt.EpsilonEquals(ptOn, .01*sc.doc.ModelAbsoluteTolerance):\r\n                    return rgObj\r\n                continue\r\n            \r\n            # Not point or curve\r\n            if rgObj.ObjectType == rd.ObjectType.Brep:\r\n                ptOn = rgObj.ClosestPoint(pt)\r\n            elif rgObj.ObjectType == rd.ObjectType.Extrusion:\r\n                bPt, u, v = rgObj.ClosestPoint(pt)\r\n                ptOn = rgObj.PointAt(u, v)\r\n            else: # Unsupported object\r\n                rgObj.Dispose()\r\n                continue\r\n            \r\n            # Check for point on brep or extrusion.\r\n            if pt.EpsilonEquals(ptOn, .001*sc.doc.ModelAbsoluteTolerance):\r\n                rgObj_BreporEdge = rgObj\r\n    \r\n    if rgObj_BreporEdge is not None: return rgObj_BreporEdge\r\n\r\n\r\ndef getInput():\r\n\r\n    # Set object type filters for face vs. other object selection.\r\n    #objTypeForFaceFilter = (rd.ObjectType.InstanceReference |\r\n    #                        rd.ObjectType.Surface)\r\n    objTypeForFaceFilter = rd.ObjectType.Surface\r\n    objTypeForNotFaceFilter = ( rd.ObjectType.InstanceReference |\r\n                                rd.ObjectType.Point |\r\n                                rd.ObjectType.Curve |\r\n                                rd.ObjectType.Brep |\r\n                                rd.ObjectType.Extrusion)\r\n    objTypeForNotFaceFilter = ( rd.ObjectType.Point |\r\n                                rd.ObjectType.Curve |\r\n                                rd.ObjectType.Brep |\r\n                                rd.ObjectType.Extrusion)\r\n\r\n\r\n    def getObj(obj_A, bAcceptPreselection=False):\r\n        # Get object with optional input.\r\n\r\n        go = ri.Custom.GetObject()\r\n\r\n        go.AcceptNumber(True, acceptZero=True)\r\n        go.EnableHighlight(False)\r\n\r\n        idxs_Opt = {} # To be reused.\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        while True:\r\n            go.ClearCommandOptions()\r\n\r\n            idxs_Opt.clear()\r\n\r\n            if obj_A is None:\r\n                addOption('bFaceForA')\r\n                addOption('bPostPickPtOnA')\r\n                if Opts.values['bFaceForA']:\r\n                    go.SetCommandPrompt(\"Select face of 1st object\")\r\n                    go.GeometryFilter = objTypeForFaceFilter\r\n                else:\r\n                    go.SetCommandPrompt(\"Select 1st object\")\r\n                    go.GeometryFilter = objTypeForNotFaceFilter\r\n            else:\r\n                addOption('bFaceForB')\r\n                addOption('bPostPickPtOnB')\r\n                if Opts.values['bFaceForB']:\r\n                    go.SetCommandPrompt(\"Select face of 2nd object\")\r\n                    go.GeometryFilter = objTypeForFaceFilter\r\n                else:\r\n                    go.SetCommandPrompt(\"Select 2nd object\")\r\n                    go.GeometryFilter = objTypeForNotFaceFilter\r\n\r\n            addOption('bLoopToMin')\r\n            if Opts.values['bLoopToMin']:\r\n                addOption('iIters_Max')\r\n                addOption('fMinPtDelta')\r\n            addOption('bAddMarks')\r\n            if Opts.values['bAddMarks']:\r\n                addOption('bAddLine')\r\n                addOption('bAddPt')\r\n                addOption('bAddDot')\r\n                if Opts.values['bAddDot']:\r\n                    addOption('iDotDecPlaces')\r\n                    addOption('iDotFontHt')\r\n            addOption('bEcho')\r\n            addOption('bDebug')\r\n\r\n            res = go.Get()\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                go.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Object:\r\n                objref = go.Object(0)\r\n                if Opts.values['bDebug']:\r\n                    sEval = \"objref.Object()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.Geometry()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.InstanceDefinitionPart()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    # Avoid using objref.Brep(), because once it is, the result of objref.Face() will become None.\r\n                    rgF = objref.Face()\r\n                    if rgF is None:\r\n                        sEval = \"objref.Brep()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    else:\r\n                        sEval = \"rgF.Brep.Faces.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.Face()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.Surface()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.Curve()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"objref.Point()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                go.Dispose()\r\n                return objref\r\n\r\n                # Prepare for repeat of go.Get().\r\n                #sc.doc.Objects.UnselectAll()\r\n                #sc.doc.Views.Redraw()\r\n                #continue\r\n\r\n            # An option was selected or a number was entered.\r\n            if res == ri.GetResult.Number:\r\n                if not Opts.values['bLoopToMin']:\r\n                    continue\r\n                key = 'iIters_Max'\r\n                Opts.riOpts[key].CurrentValue = int(go.Number())\r\n                Opts.setValue(key)\r\n                continue\r\n                #optI_iIters_Max.CurrentValue = go.Number()\r\n\r\n            for key in idxs_Opt:\r\n                if go.Option().Index == idxs_Opt[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n    objref_A = getObj(obj_A=None, bAcceptPreselection=True)\r\n    if not objref_A: return\r\n    rgObjA = objref_A.Geometry()\r\n    if isinstance(rgObjA, rg.BrepFace):\r\n        rgObjA = rgObjA.DuplicateFace(duplicateMeshes=False)\r\n\r\n    if not Opts.values['bPostPickPtOnA']:\r\n        sc.doc.Views.Redraw()\r\n        ptA = objref_A.SelectionPoint()\r\n    else:\r\n        #if not isinstance(objref_A.Geometry(), rg.BrepFace):\r\n        #    print(\r\n        gp = ri.Custom.GetPoint()\r\n        gp.SetCommandPrompt(\"Select analysis start point on 1st object\")\r\n        gp.Constrain(brep=rgObjA, wireDensity=-1, faceIndex=-1, allowPickingPointOffObject=False)\r\n        gp.Get()\r\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\r\n            return\r\n        else:\r\n            ptA = gp.Point()\r\n\r\n    sc.doc.Objects.UnselectAll(); sc.doc.Views.Redraw()\r\n\r\n\r\n    objref_B = getObj(obj_A=rgObjA, bAcceptPreselection=False)\r\n    if not objref_B: return\r\n    rgObjB = objref_B.Geometry()\r\n    if isinstance(rgObjB, rg.BrepFace):\r\n        rgObjB = rgObjB.DuplicateFace(duplicateMeshes=False)\r\n\r\n    if not Opts.values['bPostPickPtOnB']:\r\n        sc.doc.Views.Redraw()\r\n        ptB = objref_B.SelectionPoint()\r\n    else:\r\n        gp = ri.Custom.GetPoint()\r\n        gp.SetCommandPrompt(\"Select analysis start point on 2nd object\")\r\n        gp.Constrain(brep=rgObjB, wireDensity=-1, faceIndex=-1, allowPickingPointOffObject=False)\r\n        gp.Get()\r\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\r\n            return\r\n        else:\r\n            ptB = gp.Point()\r\n\r\n    return (\r\n        rgObjA,\r\n        ptA,\r\n        rgObjB,\r\n        ptB,\r\n        )\r\n\r\n\r\ndef _closestPoint(rgObj, testpoint):\r\n    if isinstance(rgObj, rg.Point):\r\n        return rgObj.Location\r\n\r\n    if isinstance(rgObj, rg.Curve):\r\n        b, t = rgObj.ClosestPoint(testpoint)\r\n        if not b:\r\n            raise Exception(\"Closest point not found for curve.\")\r\n        return rgObj.PointAt(t)\r\n\r\n    if isinstance(rgObj, rg.Brep):\r\n        return rgObj.ClosestPoint(testpoint)\r\n\r\n    raise Exception(\"{} passed to _closestPoint.\".format(rgObj.GetType().Name))\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        rgObjA,\r\n        ptA,\r\n        rgObjB,\r\n        ptB,\r\n    ) = rc\r\n\r\n\r\n    bLoopToMin = Opts.values['bLoopToMin']\r\n    iIters_Max = Opts.values['iIters_Max']\r\n    fMinPtDelta = Opts.values['fMinPtDelta']\r\n    bAddMarks = Opts.values['bAddMarks']\r\n    bAddLine = Opts.values['bAddLine']\r\n    bAddPt = Opts.values['bAddPt']\r\n    bAddDot = Opts.values['bAddDot']\r\n    iDotDecPlaces = Opts.values['iDotDecPlaces']\r\n    iDotFontHt = Opts.values['iDotFontHt']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    ptB_Prev = ptB\r\n    ptB = _closestPoint(rgObjB, ptA)\r\n\r\n    if bLoopToMin:\r\n        # Loop until difference between old and new B points are within a specific distance.\r\n\r\n        if (    rgObjA.ObjectType == rd.ObjectType.Brep or \r\n                rgObjB.ObjectType == rd.ObjectType.Brep):\r\n            tol = fMinPtDelta\r\n        else:\r\n            tol = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        if bDebug: sEval = \"tol\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        distB_Delta = ptB.DistanceTo(ptB_Prev)\r\n\r\n        iIters = 1\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            ptA_Prev = ptA\r\n            ptA = _closestPoint(rgObjA, ptB)\r\n            if bDebug: sc.doc.Objects.AddPoint(ptA)\r\n\r\n            iIters += 1\r\n\r\n            if iIters == iIters_Max:\r\n                break\r\n\r\n            distA_Delta = ptA.DistanceTo(ptA_Prev)\r\n            if distA_Delta < tol:\r\n                if distB_Delta < tol:\r\n                    break\r\n\r\n            ptB_Prev = ptB\r\n            ptB = _closestPoint(rgObjB, ptA)\r\n            if bDebug: sc.doc.Objects.AddPoint(ptB)\r\n\r\n            iIters += 1\r\n\r\n            if iIters == iIters_Max:\r\n                break\r\n\r\n            distB_Delta = ptB.DistanceTo(ptB_Prev)\r\n            if distB_Delta < tol:\r\n                if distA_Delta < tol:\r\n                    break\r\n\r\n    dist = ptB.DistanceTo(ptA)\r\n    if dist <= sc.doc.ModelAbsoluteTolerance:\r\n        sPrint = [\"Objects intersect.\"]\r\n        \r\n        if bAddMarks:\r\n            if bAddDot:\r\n                _addTextDot(\r\n                    (ptA+ptB)/2.0,\r\n                    \"X\",\r\n                    iDotFontHt=iDotFontHt)\r\n            if bAddPt:\r\n                gPt = sc.doc.Objects.AddPoint((ptA+ptB)/2.0)\r\n                if gPt != gPt.Empty:\r\n                    if sc.doc.Objects.Select(gPt):\r\n                        sPrint.append(\"Point at intersection was created and is selected.\")\r\n        \r\n        print(\"  \".join(sPrint))\r\n        \r\n        sc.doc.Views.Redraw()\r\n        return\r\n\r\n    s = \"Clearance: {:.{}f} {}\".format(\r\n        dist,\r\n        sc.doc.ModelDistanceDisplayPrecision,\r\n        str(sc.doc.ModelUnitSystem).lower())\r\n\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n        s += \" [{:.{}f} millimeters]\".format(\r\n            dist*25.4,\r\n            sc.doc.ModelDistanceDisplayPrecision-2)\r\n    elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n        s += \" [{:.{}f} inches]\".format(\r\n            dist/25.4,\r\n            sc.doc.ModelDistanceDisplayPrecision+2)\r\n\r\n    if bLoopToMin:\r\n        s += \" found in {} iterations.\".format(iIters)\r\n\r\n    print(s)\r\n\r\n    if bAddMarks:\r\n        if bAddLine:\r\n            sc.doc.Objects.AddLine(ptA, ptB)\r\n        if bAddDot:\r\n            _addTextDot(\r\n                (ptA+ptB)/2.0,\r\n                '{0:.{1}f}'.format(dist, iDotDecPlaces),\r\n                iDotFontHt=iDotFontHt)\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}