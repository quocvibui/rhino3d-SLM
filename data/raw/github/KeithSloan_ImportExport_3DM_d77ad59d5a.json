{
  "source_url": "https://github.com/KeithSloan/ImportExport_3DM/blob/c63ae55e24aeeef6c1ff31316977cae779b9a6ce/freecad/importExport3DM/export3DM.py",
  "repo": "KeithSloan/ImportExport_3DM",
  "repo_stars": 3,
  "repo_description": null,
  "license": "NOASSERTION",
  "filepath": "freecad/importExport3DM/export3DM.py",
  "instruction": "Mon Sep 19 10:36:46 AM PDT 2022 ************************************************************************** *                                                                        * *   Copyright (c) 2022 Keith Sloan <keith@sloan-home.co.uk>              * *                                                                        * *   This program is free software; you can redistribute it and/or modify * *   it under the terms of the GNU Lesser General Public License (LGPL)   * *   as published by the Free Software Foundation; either version 2 of    * *   the License, or (at your option) any later version.                  * *   for detail see the LICENCE text file.                                * *                                                                        * *   This program is distributed in the hope that it will be useful,      * *   but WITHOUT ANY WARRANTY; without even the implied warranty of       * *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        * *   GNU Library General Public License for more details.                 * *                                                                        * *   You should have received a copy of the GNU Library General Public    * *   License along with this program; if not, write to the Free Software  * *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 * *   USA                                                                  * *                                                                        * **************************************************************************",
  "code": "# Mon Sep 19 10:36:46 AM PDT 2022\n# **************************************************************************\n# *                                                                        *\n# *   Copyright (c) 2022 Keith Sloan <keith@sloan-home.co.uk>              *\n# *                                                                        *\n# *   This program is free software; you can redistribute it and/or modify *\n# *   it under the terms of the GNU Lesser General Public License (LGPL)   *\n# *   as published by the Free Software Foundation; either version 2 of    *\n# *   the License, or (at your option) any later version.                  *\n# *   for detail see the LICENCE text file.                                *\n# *                                                                        *\n# *   This program is distributed in the hope that it will be useful,      *\n# *   but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *\n# *   GNU Library General Public License for more details.                 *\n# *                                                                        *\n# *   You should have received a copy of the GNU Library General Public    *\n# *   License along with this program; if not, write to the Free Software  *\n# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 *\n# *   USA                                                                  *\n# *                                                                        *\n# **************************************************************************\n__title__ = \"FreeCAD - Import / Export 3DM Version\"\n__author__ = \"Keith Sloan <keith@sloan-home.co.uk>\"\n__url__ = [\"https://github.com/KeithSloan/ImportExport_3DM\"]\n\nimport FreeCAD, os, Part\nfrom FreeCAD import Units\nimport rhino3dm as r3\n\n\n#################################\n# Switch functions\n################################\n\n\nclass switch(object):\n    value = None\n\n    def __new__(class_, value):\n        class_.value = value\n        return True\n\ndef case(*args):\n    return any((arg == switch.value for arg in args))\n\n\n\nclass rhinoModel():\n    #import rhino3dm as r3\n    #import rhino3dm\n    def __init__(self):\n        import rhino3dm\n        print(\"Init Model\")\n        self.model = r3.File3dm()\n        self.model.ApplicationName = \"ImportExport_3DM\"\n        self.model.ApplicationUrl = \"https://github.com/KeithSloan/ImportExport_3DM\"\n        # Variables\n        self.ControlPoints = []\n        self.layer = r3.Layer()\n        self.layer.Name = \"FC Layer\"\n        self.model.Layers.Add(self.layer)\n        # create box brep\n        pln = r3.Plane.WorldXY\n        #box = r3.Box( pln, rhino3dm.Interval(0,1000), \\\n        #                rhino3dm.Interval(0,800), \\\n        #                rhino3dm.Interval(0,500) )\n        boundBox = r3.BoundingBox(0,0,0, 1000, 800, 500)\n        box = r3.Box(boundBox)\n        brp = boundBox.ToBrep()\n\n        # add brep to model\n        #self.model.Objects.AddBrep(brp)\n\n    def addControlPoint(self, x, y, z):\n        import rhino3dm\n        cp = r3.Point3d(x,y,z)\n        #cp = rhino3dm.Point3d(x,y,z)\n        self.ControlPoints.append(cp)\n\n    def createNurbsCurve(self, degree, poles):\n        polesList = []\n        print(f\"Poles {poles}\")\n        for p in poles:\n            polesList.append(r3.Point3d(p[0], p[1], p[2]))\n        print(f\"PolesList {polesList}\")\n        NurbsCurve = r3.NurbsCurve(degree, len(poles))\n        nc = NurbsCurve.Create(False, degree, polesList)\n        return nc\n\n    def addNurbsCurve(self, degree, knots, mults,  poles):\n        #\n        # Number of Knots = Number of Control Points + Degree + 1\n        #\n        #knotList = r3.NurbsCurveKnotList\n        #print(len(knots))\n        #for i in range(len(knots)):\n        #    if knotList.InsertKnot(float(knots[i]), int(mults[i])) == False:\n        #        print(f\"Insert Knot {i} Failed\")\n            \n        #NurbsCurve = r3.NurbsCurve(degree, len(self.ControlPoints))\n        polesList = []\n        print(f\"Poles {poles}\")\n        for p in poles:\n            polesList.append(r3.Point3d(p[0], p[1], p[2]))\n        print(f\"PolesList {polesList}\")\n        NurbsCurve = r3.NurbsCurve(degree, len(poles))\n        nc = NurbsCurve.Create(False, degree, polesList)\n        print(f\"NurbsCurve {nc}\")\n        self.model.Objects.AddCurve(nc)\n        #self.model.Objects.AddCurve(NurbsCurve)\n        #self.ControlPoints = []         # reset control points\n\n    def processNurbEdges(self, nurbs):\n        # B-Spline \n        # Control Points P0-Pn = n + 1\n        # Knots u0 - um = m+1\n        # Degree = p = m - n - 1\n        # Degree = (nKn - 1)-(nCP - 1) - 1\n        # Degree = nKn - nCP - 1\n        print(f\">>>>>>>>>>  Process Nurb Edges Len {len(nurbs.Edges)}\")\n        valid = False\n        self.curves = []\n        for e in nurbs.Edges:\n            print(f\"TypeId {e.TypeId} Number of Vertex {len(e.Vertexes)}\")\n            #print(dir(e))\n            if len(e.Vertexes) > 1:         # Avoid error degenerate edge\n                if hasattr(e, 'Curve'):\n                    #print(dir(e.Curve))\n                    print(f\"=====  B-Spline {len(e.Vertexes)}\")\n                    print(f\"FirstParameter {e.Curve.FirstParameter}\")\n                    #print(dir(e))\n                    print(f\"Max Degrees {e.Curve.MaxDegree}\")\n                    degree = e.Curve.Degree\n                    print(f\"Degree {degree}\")\n                    print(f\"Number Knots {e.Curve.NbKnots}\")\n                    print(f\"Knot Sequence {e.Curve.KnotSequence}\")\n                    knots = e.Curve.getKnots()\n                    print(f\"Knots {knots}\")\n                    mults = e.Curve.getMultiplicities()\n                    print(f\"Mults {mults}\")\n                    print(f\"Number Poles {e.Curve.NbPoles}\")\n                    poles = e.Curve.getPoles()\n                    print(f\"Poles {poles}\")\n                    print(f\"Poles and Weight {e.Curve.getPolesAndWeights()}\")\n                    self.curves.append(self.addNurbsCurve(degree, knots, mults, poles))\n\n\n                print(f\"Vertexes Knots?\")\n                for v in e.Vertexes:\n                    print(f\" x {v.X} y {v.Y} z {v.Z}\")\n                    #self.addControlPoint(v.X, v.Y, v.Z)\n                valid = True\n\n            else:\n                print(f\"Line\")\n\n        #if valid: self.addNurbsCurve(3)        # degree 3\n        #degree =  e.Curve.NbKnots - e.Curve.NbPoles - 1\n        #print(f\"Degree = {degree}\")\n        #if valid: self.addNurbsCurve(degree)\n\n\n    def processNurbSurfaces(self, nurbs):\n        print(f\"    Process Nurb Surfaces ToDo\")\n\n\n    def processNurbs(self, nurbs):\n        print(f\"Process Nurbs {nurbs}\")\n        if hasattr(nurbs, \"Edges\"):\n            if len(nurbs.Edges) > 0:\n                self.processNurbEdges(nurbs)\n        if hasattr(nurbs, \"Faces\"):\n            if len(nurbs.Faces) > 0:\n                self.processNurbSurfaces(nurbs)\n\n\n    def curvesToNurbs(self, obj):\n        if hasattr(obj, \"Shape\"):\n            if hasattr(obj.Shape, \"toNurbs\"):\n                nurbs = obj.Shape.toNurbs()\n                self.processNurbs(nurbs)\n\n    def checkShapeForCurves(self, obj):\n        print(f\"Check Shape for Curves ToDp !!!!\")\n        # return True for Now\n        return False\n\n    def checkShapeForSurface(self, obj):\n        # Just check and return True or False\n        print(f\"Check Shape for Surface\")\n        if hasattr(obj, \"Surface\"):\n            print(f\"Has Surface\")\n            return True\n        return False\n\n    def processSurfaceUV(self, surface):\n        print(f\"=========== Process Surface UV\")\n        print(dir(surface))\n        UDegree = surface.UDegree\n        UOrder = UDegree + 1\n        VDegree = surface.VDegree\n        VOrder =VDegree + 1\n        UPoles = surface.NbUPoles\n        VPoles = surface.NbVPoles\n        poles = surface.getPoles()\n        print(f\"UPoles {UPoles} VPoles {VPoles}\")\n        print(f\"Poles {len(poles[0])} x {len(poles[1])}\")\n        #print(f\"Poles {poles}\")\n        print(f\"Surface UDegree {UDegree} VDegree {VDegree}\")\n        VKnots = surface.getVKnots()\n        UKnots = surface.getUKnots()\n        VMults = surface.getVMultiplicities()\n        UMults = surface.getUMultiplicities()\n        #Ucurve = self.createNurbsCurve(UDegree, UKnots)\n        Ucurve = self.createNurbsCurve(UDegree, poles[0])\n        #Vcurve = self.createNurbsCurve(VDegree, VKnots)\n        Vcurve = self.createNurbsCurve(VDegree, poles[1])\n        nurbSurf = r3.NurbsSurface.Create(3, False, UOrder, VOrder, UPoles, VPoles) \n        #for c in range(0, len(self.curves)-1, 2):\n        #    nurbSurf.CreateRuledSurface(self.curves[c], self.curves[c+1])\n        #    self.model.Objects.AddSurface(nurbSurf)\n        #ns =  nurbSurf.CreateRuledSurface(self.curves[0], self.curves[2])\n        attr = r3.ObjectAttributes()\n        ns =  nurbSurf.CreateRuledSurface(Ucurve, Vcurve)\n        if ns is not None:\n            self.model.Objects.AddSurface(ns, attr)\n        else:\n            print(f\"Invalid Ruled Surface\")    \n\n\n    def processSurfaceUV3(self, surface):\n        print(f\"=========== Process Surface UV\")\n        plane = r3.Plane.WorldXY\n        planeSurf = r3.PlaneSurface(plane, 10, 5)\n        print(dir(planeSurf))\n        ns = planeSurface.ToNurbsSurface()\n        u_interval = r3.Interval(0.0, 15.0)\n        v_interval = r3.Interval(0.0, 7.5)\n        u_degree = 2\n        v_degree = 2\n        u_points = 10\n        v_points = 10\n        print(dir(r3.NurbsSurface))\n        srf = r3.NurbsSurface.CreateFromPlane(plane, u_interval, v_interval, u_degree, v_degree, u_points, v_points)\n        if srf and srf.IsValid:\n            return srf\n        return None\n\n\n    def processSurfaceUV2(self, surface):\n        print(f\"=========== Process Surface UV\")\n        plane = r3.Plane.WorldXY\n        u_interval = r3.Interval(0.0, 15.0)\n        v_interval = r3.Interval(0.0, 7.5)\n        u_degree = 2\n        v_degree = 2\n        u_points = 10\n        v_points = 10\n        print(dir(r3.NurbsSurface))\n        srf = r3.NurbsSurface.CreateFromPlane(plane, u_interval, v_interval, u_degree, v_degree, u_points, v_points)\n        if srf and srf.IsValid:\n            return srf\n        return None\n\n\n    def createSpline(self, knots):\n        print(f\"createSpline knots {knots}\")\n        print(dir(knots))\n        spline = r3.Curve\n        #spline.CreateControlPointCurve(\n\n\n    def checkForSurfaceUV(self, face):\n        if hasattr(face, \"Surface\"):\n            print(dir(face.Surface))\n            print(f\"UDegree {face.Surface.UDegree} VDegree {face.Surface.VDegree}\")\n            print(f\"UKnots {face.Surface.NbUKnots} VKnots {face.Surface.NbVKnots}\")\n            if hasattr(face.Surface, \"UDegree\") and \\\n               hasattr(face.Surface, \"VDegree\"):\n               #USpline = self.createSpline(face.Surface.NbUKnots)\n               #USpline = self.createSpline(face.Surface.getUKnots())\n               #VSpline = self.createSpline(face.Surface.NbVKnots)\n               #VSpline = self.createSpline(face.Surface.getVKnots())\n               return True\n\n    \n    def processBSplineSurface(self, obj):\n        #print(f\"======== Process BSplineSurface ToDo\")\n        if self.checkForSurfaceUV(obj):\n            self.processSurfaceUV(obj.Surface)\n\n\n    def processSurfacePlane(self, obj):\n        print(f\"======== Process Surface Plane ToDo\")\n        print(dir(obj))\n       \n    def processSurface(self, obj):\n        print(f\"Surface {obj.Surface}  TypeId {obj.TypeId} Typ e{type(obj.Surface)}\")\n        surfType = str(obj.Surface)\n        #if surfType == \"Part.BSplineSurface object\":\n        #    self.processBSplineSurface(obj)\n        #    return\n        #elif surfType == \"Part.Plane object\":\n        #    self.processSurfacePlane(obj)\n        #    return\n        if isinstance(obj.Surface, Part.BSplineSurface):\n            self.processBSplineSurface(obj)\n            return\n        elif isinstance(obj.Surface, Part.Plane):\n            self.processSurfacePlane(obj)\n            return\n        print(\"===== >>>>> NOT YET HANDLED in processSurface\")\n        raise TypeError(\"Not Yet Handled\")\n    \n        #if hasattr(obj, \"UPeriod\") and hasattr(obj, \"VPeriod\"):\n        #    print(f\"UPeriod {obj.UPeriod} VPeriod {obj.VPeriod}\")\n        #    self.checkForSurfaceUV(f)\n        #else:\n        #    print(f\"Face TypeId {obj.TypeId} ShapeType {obj.ShapeType}\")\n        #    print(dir(obj))\n\n    def processFaces(self, obj):\n        print(obj.Shape.Faces)\n        print(f\"processFaces {len(obj.Shape.Faces)}\")\n        for f in obj.Shape.Faces:\n            if self.checkShapeForSurface(f):\n                self.processSurface(f) \n               \n\n    def checkShape(self, obj):\n        print(f\"    CheckShape {obj.TypeId} {obj.Name}\")\n        if hasattr(obj, \"Shape\") == None:\n            return\n        ##### ?????? or in processFacees\n        if self.checkShapeForSurface(obj):\n            self.processSurface(obj)\n            return\n        if self.checkShapeForCurves(obj):\n            self.curvesToNurbs(obj)\n            return\n        #print(dir(obj))    \n        #print(dir(obj.Shape))\n        print(\"======= >>>>> Not yet handled - process Faces\")     \n        self.processFaces(obj)\n\n    def addObjToModel(self, obj):\n        #print(f\"{obj.TypeId}\")\n        while switch(obj.TypeId):\n            if case(\"App::Part\"):\n                print(f\"App Part : {obj.Label}\")\n                break\n\n            if case(\"Part::FeaturePython\"):\n                print(f\"Part::FeaturePython\")\n                self.checkShape(obj)\n                break\n\n            if case(\"Part::Feature\"):\n                print(f\"Part::Feature\")\n                self.checkShape(obj)\n                break\n\n            if case(\"Part::Sphere\"):\n                print(f\"sphere : Radius {obj.Radius}\")\n                break\n\n            if case(\"Part::Box\"):\n                print(f\"box : ({obj.Length},{obj.Width},{obj.Height})\")\n                #pln = r3.Plane.WorldXY\n                #box = r3.Box(pln,\n                box = r3.Box(r3.BoundingBox\n                    (\n                    0,\n                    length(obj.Length),\n                    0,\n                    length(obj.Width),\n                    0,\n                    length(obj.Height)\n                    ))\n                brp = r3.Brep.CreateFromBox(box)\n                self.model.Objects.AddBrep(brp)\n                break\n\n            if case(\"Part::Cylinder\"):\n                print(f\"cylinder : Height {obj.Height} Radius {obj.Radius}\")\n                break\n\n            if case(\"Part::Cone\"):\n                print(f\"cone : Height {obj.Height} Radius1 {obj.Radius1} Radius2 {obj.Radius2}\")\n                break\n\n            if case(\"Part::Torus\"):\n                print(f\"torus {obj.Radius1} {obj.Radius2}\")\n                break\n\n            if case(\"Part::Prism\"):\n                print(\"Prism\")\n                break\n\n            if case(\"Part::RegularPolygon\"):\n                print(\"RegularPolygon\")\n                break\n\n            if case(\"Part::Extrusion\"):\n                print(\"Extrusion\")\n                break\n            \n            if case(\"Mesh::Feature\"):\n                print(\"Mesh\")\n                # print dir(obj.Mesh)\n                break\n\n            #print(\"Other\")\n            #print(obj.TypeId)\n            break\n\n    def write(self, filepath):\n        self.model.Write(filepath, 0)\n\n\ndef exportDoc3DM(filepath, fileExt):\n    rModel = rhinoModel()\n    for obj in FreeCAD.ActiveDocument.Objects:\n        addObjToModel(obj)\n    rModel.Write(filepath, 0)\n\ndef export3DM(first, filepath, fileExt):\n\n    print(\"====> Start Export 3DM 0.1\")\n    print(\"File extension : \" + fileExt)\n    rModel = rhinoModel()\n    rModel.addObjToModel(first)\n    if hasattr(first, \"OutList\"):\n        for obj in first.OutList:\n            rModel.addObjToModel(obj)\n    ret = rModel.write(filepath)\n    print(f\"File {filepath} exported rc {ret}\")\n\n\ndef length(lenQuantity):\n    print(f\"Len Value {Units.Quantity(lenQuantity).Value}\")\n    return Units.Quantity(lenQuantity).Value\n    #return r3.Interval(0, Units.Quantity(lenQuantity).Value)\n\n\ndef export(exportList, filepath):\n    \"called when FreeCAD exports a file\"\n    import os\n\n    first = exportList[0]\n    print(f\"Export Object: {first.Label}\")\n\n    path, fileExt = os.path.splitext(filepath)\n    print(\"filepath : \" + path)\n    print(\"file extension : \" + fileExt)\n    if fileExt.lower() == \".3dm\":\n        export3DM(first, filepath, fileExt)\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}