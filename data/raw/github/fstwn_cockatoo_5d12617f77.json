{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/modules/cockatoo/utilities.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "modules/cockatoo/utilities.py",
  "instruction": ".. currentmodule:: cockatoo.utilities",
  "code": "\"\"\"\n.. currentmodule:: cockatoo.utilities\n\n.. autosummary::\n    :nosignatures:\n\n    blend_colors\n    break_polyline\n    map_values_as_colors\n    tween_planes\n    is_ccw_xy\n    resolve_order_by_backtracking\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import deque\nfrom itertools import tee\nfrom math import cos\nfrom math import pi\nfrom math import sqrt\n\n# DUNDER ----------------------------------------------------------------------\n__all__ = [\n    \"blend_colors\",\n    \"break_polyline\",\n    \"map_values_as_colors\",\n    \"tween_planes\",\n    \"is_ccw_xy\",\n    \"resolve_order_by_backtracking\",\n    \"pairwise\"\n]\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\nfrom cockatoo.environment import RHINOINSIDE\nfrom cockatoo.exception import SystemNotPresentError\n\n# RHINO IMPORTS ---------------------------------------------------------------\nif RHINOINSIDE:\n    import rhinoinside\n    rhinoinside.load()\n    from Rhino.Display import ColorHSL as RhinoColorHSL\n    from Rhino.Geometry import Polyline as RhinoPolyline\n    from Rhino.Geometry import Quaternion as RhinoQuaternion\n    from Rhino.Geometry import Vector3d as RhinoVector3d\nelse:\n    from Rhino.Display import ColorHSL as RhinoColorHSL\n    from Rhino.Geometry import Polyline as RhinoPolyline\n    from Rhino.Geometry import Quaternion as RhinoQuaternion\n    from Rhino.Geometry import Vector3d as RhinoVector3d\n\n# RHINO GEOMETRY --------------------------------------------------------------\n\n\ndef break_polyline(polyline, break_angle, as_crv=False):\n    \"\"\"\n    Breaks a polyline at kinks based on a specified angle. Will move the seam\n    of closed polylines to the first kink discovered.\n\n    Parameters\n    ----------\n    polyline : :obj:`Rhino.Geometry.Polyline`\n        Polyline to break apart at angles.\n\n    break_angle : float\n        The angle at which to break apart the polyline (in radians).\n\n    as_crv : bool, optional\n        If ``True``, will return a :obj:`Rhino.Geometry.PolylineCurve` object.\n\n        Defaults to ``False``.\n\n    Returns\n    -------\n    polyline_segments : list of :obj:`Rhino.Geometry.Polyline`\n        A list of the broken segments as Polylines if ``as_crv`` is\n        ``False``.\n    polyline_segments: list of :obj:`Rhino.Geometry.PolylineCurve`\n        A list of the broken segments as PolylineCurves if ``as_crv`` is\n        ``True``.\n\n    \"\"\"\n\n    # get all the polyline segments\n    segments = deque(polyline.GetSegments())\n\n    # check if polyline in closed\n    if polyline.IsClosed:\n        closedSeamAtKink = False\n    else:\n        closedSeamAtKink = True\n\n    # initialize containers\n    plcs = []\n    pl = RhinoPolyline()\n\n    # process all segments\n    while len(segments) > 0:\n        # if there is only one segment left, add the endpoint to the new pl\n        if len(segments) == 1:\n            ln = segments.popleft()\n            pl.Add(ln.To)\n            plcs.append(pl)\n            break\n\n        # get unitized directions of this and next segment\n        thisdir = segments[0].Direction\n        nextdir = segments[1].Direction\n        thisdir.Unitize()\n        nextdir.Unitize()\n\n        # compute angle\n        vdp = thisdir * nextdir\n        angle = cos(vdp / (thisdir.Length * nextdir.Length))\n        angle = RhinoVector3d.VectorAngle(thisdir, nextdir)\n\n        # check angles and execute breaks\n        if angle >= break_angle:\n            if not closedSeamAtKink:\n                segments.rotate(-1)\n                pl.Add(segments.popleft().From)\n                closedSeamAtKink = True\n            elif closedSeamAtKink:\n                ln = segments.popleft()\n                pl.Add(ln.From)\n                pl.Add(ln.To)\n                plcs.append(pl)\n                pl = RhinoPolyline()\n        else:\n            if not closedSeamAtKink:\n                segments.rotate(-1)\n            else:\n                pl.Add(segments.popleft().From)\n\n    if as_crv:\n        return [pline.ToPolylineCurve() for pline in plcs]\n    else:\n        return plcs\n\n\ndef tween_planes(pa, pb, t):\n    \"\"\"\n    Tweens between two planes using quaternion rotation.\n    Based on code by Chris Hanley. [19]_\n\n    Parameters\n    ----------\n    pa : :obj:`Rhino.Geometry.Plane`\n        The start plane for the tween.\n\n    pb : :obj:`Rhino.Geometry.Plane`\n        The end plane for the tween.\n\n    t : float\n        The parameter for the tweened plane. 0.5 will result in the average\n        between the two input planes.\n\n    Returns\n    -------\n    tweened_plane : :obj:`Rhino.Geometry.Plane`\n        The plane between ``pa`` and ``pb`` at parameter ``t``.\n\n    Raises\n    ------\n    SystemNotPresentError\n        If the ``System`` module cannot be imported.\n\n    References\n    ----------\n    .. [19] *Average between two planes*\n\n            See: `Thread on discourse.mcneel.com <https://discourse.mcneel.com/\n            t/average-between-two-planes/71363/10>`_\n    \"\"\"\n\n    # handle dotnet dependency in a nice way\n    try:\n        from clr import Reference\n        from System import Double\n    except ImportError:\n        errMsg = \"Could not import System. This function cannot execute!\"\n        raise SystemNotPresentError(errMsg)\n\n    # create the quternion rotation between the two input planes\n    Q = RhinoQuaternion.Rotation(pa, pb)\n\n    # prepare out parameters\n    qAngle = Reference[Double]()\n    qAxis = Reference[RhinoVector3d]()\n\n    # get the rotation of the quaternion\n    Q.GetRotation(qAngle, qAxis)\n\n    axis = RhinoVector3d(qAxis.X, qAxis.Y, qAxis.Z)\n    angle = float(qAngle) - 2 * pi if float(qAngle) > pi else float(qAngle)\n\n    out_plane = pa.Clone()\n    out_plane.Rotate(t * angle, axis, out_plane.Origin)\n    translation = RhinoVector3d(pb.Origin - pa.Origin)\n    out_plane.Translate(translation * t)\n\n    return out_plane\n\n# RHINO DISPLAY ---------------------------------------------------------------\n\n\ndef blend_colors(col_a, col_b, t=0.5):\n    \"\"\"\n    Blend between two colors using the square root of photon flux. For more\n    info see *Algorithm for additive color mixing for RGB values* [18]_.\n\n    Parameters\n    ----------\n    col_a : sequence of :obj:`int`\n        Sequence of (R, G, B) that defines the color value.\n\n    col_b : sequence of :obj:`int`\n        Sequence of (R, G, B) that defines the color value.\n\n    t : float, optional\n        Parameter to define the blend location between the two colors.\n\n        Defaults to ``0.5``.\n\n    Returns\n    -------\n    color : tuple\n        3-tuple of (R, G, B) that defines the new color.\n\n    References\n    ----------\n    .. [18] *Algorithm for additive color mixing for RGB values*\n\n            See: `Thread on stackoverflow <https://stackoverflow.com/a/\n            29321264>`_\n    \"\"\"\n\n    # sanitize the blending parameter\n    if t < 0:\n        t = 0\n    elif t > 1:\n        t = 1\n\n    # unpack colors in r, g, b values\n    a_r, a_g, a_b = col_a\n    b_r, b_g, b_b = col_b\n\n    # compute the new rgb values for the blended color\n    new_r = sqrt((1 - t) * a_r ** 2 + t * b_r ** 2)\n    new_g = sqrt((1 - t) * a_g ** 2 + t * b_g ** 2)\n    new_b = sqrt((1 - t) * a_b ** 2 + t * b_b ** 2)\n\n    # return the new color tuple\n    return (new_r, new_g, new_b)\n\n\ndef map_values_as_colors(values, src_min, src_max,\n                         target_min=0.0, target_max=0.7):\n    \"\"\"\n    Make a list of HSL colors where the values are mapped onto a\n    targetMin-targetMax hue domain. Meaning that low values will be red, medium\n    values green and large values blue if target_min is ``0.0`` and target_max\n    is ``0.7``.\n\n    Parameters\n    ----------\n    values : list\n        List of values to map as colors.\n\n    src_min : float\n        Lower bounds of the value domain.\n\n    src_max : float\n        Upper bounds of the value domain.\n\n    target_min : float, optional\n        Lower bounds of the target (color) domain.\n\n        Defaults to ``0``.\n\n    target_max : float, optional\n        Upper bounds of the target (color) domain.\n\n        Defaults to ``0.7`` .\n\n    Returns\n    -------\n    colors : list\n        List of RGB colors corresponding to the input values.\n\n    Notes\n    -----\n    Based on code by Anders Holden Deleuran. Code was only changed in regards\n    of defaults and names.\n    For more info see *mapValuesAsColors.py* [10]_ .\n\n    References\n    ----------\n    .. [10] Deleuran, Anders Holden *mapValuesAsColors.py*\n\n            See: `mapValuesAsColors.py gist <https://gist.github.com/\n            AndersDeleuran/82fa2a8a69ec10ac68176e1b848fdeea>`_\n    \"\"\"\n\n    # remap numbers into new numeric domain\n    remapped_values = []\n    for v in values:\n        if src_max - src_min > 0:\n            rv = ((v - src_min) / (src_max - src_min)) \\\n                 * (target_max - target_min) \\\n                 + target_min\n        else:\n            rv = (target_min + target_max) / 2\n        remapped_values.append(rv)\n\n    # make rgb colors and return\n    colors = []\n    for v in remapped_values:\n        c = RhinoColorHSL(v, 1.0, 0.5).ToArgbColor()\n        colors.append(c)\n\n    return colors\n\n# FUNCTIONAL GRAPH UTILITIES --------------------------------------------------\n\n\ndef _backtrack_node(G, node, pos, ordered_stack):\n    \"\"\"\n    Backtracks a node until no new predecessors are found and\n    inserts the node and all dependencies in order into the\n    ordered stack list.\n    \"\"\"\n\n    # check the node for dependencies\n    dependencies = [pred for pred in G.predecessors_iter(node)\n                    if pred not in ordered_stack]\n\n    # if node has no dependencies that are not already in the stack,\n    # insert into the ordered stack of nodes and increment the pointer\n    if not dependencies:\n        if node not in ordered_stack:\n            ordered_stack.insert(pos, node)\n            pos += 1\n            return pos, ordered_stack\n    else:\n        # if node has dependencies, build a local stack of dependencies\n        dependencies = deque(dependencies)\n\n        # backtrack all dependencies\n        while len(dependencies) > 0:\n            dependency = dependencies.pop()\n            pos, ordered_stack = _backtrack_node(G,\n                                                 dependency,\n                                                 pos,\n                                                 ordered_stack)\n\n            # after all its dependencies are solved, insert the\n            # dependent node at the current pointer position\n            if dependency not in ordered_stack:\n                ordered_stack.insert(pos, dependency)\n                pos += 1\n\n        # after dependencies and sub-dependencies are solved, insert the node\n        ordered_stack.insert(pos, node)\n        pos += 1\n\n    # return the current pos and the filled ordered stack\n    return pos, ordered_stack\n\n\ndef resolve_order_by_backtracking(G):\n    \"\"\"\n    Resolve topological order of a networkx DiGraph through backtracking of\n    all nodes in the graph. Nodes are only inserted into the output list if\n    all their dependencies (predecessor nodes) are already inside the output\n    list, otherwise the algorithm will first resolve all open dependencies.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        The graph on which to perform topological sorting.\n\n    Returns\n    -------\n    ordered_nodes : list\n        List of hashable node identifiers.\n\n    Raises\n    ------\n    ValueError\n        If the input graph is not directed.\n\n    Warning\n    -------\n    For this to work, the input gaph must be a DAG (directed acyclic graph).\n    For more info,see [11]_ and [12]_.\n\n    References\n    ----------\n    .. [11] Directed acyclic graph on Wikipedia.\n\n            See: `Directed acyclic graph <https://en.wikipedia.org/wiki/\n            Directed_acyclic_graph>`_\n    .. [12] Topological sorting on Wikipedia.\n\n            See: `Topological sorting <https://en.wikipedia.org/wiki/\n            Topological_sorting>`_\n    \"\"\"\n\n    # raise if graph is not directed\n    if not G.is_directed():\n        raise ValueError(\"This works only on directed graphs!\")\n\n    # stack is every node that has not been inserted yet\n    stack = deque(G.nodes())\n    # pos is the current pointer for insertion\n    pos = 0\n    # ordered stack is the target list for insertion\n    ordered_stack = []\n    # backtrack the whole stack\n    while len(stack) > 0:\n        # pop an arbitrary node from the stack\n        current_node = stack.pop()\n        # backtrack that node and resolve all its dependencies\n        pos, ordered_stack = _backtrack_node(G,\n                                             current_node,\n                                             pos,\n                                             ordered_stack)\n    # return the ordered stack\n    return ordered_stack\n\n# PURE PYTHON GEOMETRY --------------------------------------------------------\n\n\ndef is_ccw_xy(a, b, c, colinear=False):\n    \"\"\"\n    Determine if c is on the left of ab when looking from a to b,\n    and assuming that all points lie in the XY plane.\n\n    Parameters\n    ----------\n    a : sequence of float\n        XY(Z) coordinates of the base point.\n    b : sequence of float\n        XY(Z) coordinates of the first end point.\n    c : sequence of float\n        XY(Z) coordinates of the second end point.\n    colinear : bool, optional\n        Allow points to be colinear.\n        Default is ``False``.\n\n    Returns\n    -------\n    bool\n        ``True`` if ccw.\n        ``False`` otherwise.\n\n    Notes\n    -----\n    Based on an implementation inside the COMPAS framework.\n    For more info, see [14]_ and [15]_.\n\n    References\n    ----------\n    .. [14] Van Mele, Tom et al. *COMPAS: A framework for computational\n           research in architecture and structures*.\n\n           See: `is_ccw_xy() inside COMPAS <https://github.com/compas-dev/\n           compas/blob/e313502995b0dd86d460f86e622cafc0e29d1b75/src/compas/\n           geometry/_core/queries.py#L61>`_\n    .. [15] Marsh, C. *Computational Geometry in Python: From Theory to\n           Application*.\n\n           See: `Computational Geometry in Python <https://www.toptal.com/\n           python/\n           computational-geometry-in-python-from-theory-to-implementation>`_\n\n    Examples\n    --------\n    >>> print(is_ccw_xy([0,0,0], [0,1,0], [-1, 0, 0]))\n    True\n    >>> print(is_ccw_xy([0,0,0], [0,1,0], [+1, 0, 0]))\n    False\n    >>> print(is_ccw_xy([0,0,0], [1,0,0], [2,0,0]))\n    False\n    >>> print(is_ccw_xy([0,0,0], [1,0,0], [2,0,0], True))\n    True\n    \"\"\"\n\n    ab_x = b[0] - a[0]\n    ab_y = b[1] - a[1]\n    ac_x = c[0] - a[0]\n    ac_y = c[1] - a[1]\n\n    if colinear:\n        return ab_x * ac_y - ab_y * ac_x >= 0\n    return ab_x * ac_y - ab_y * ac_x > 0\n\n# PYTHON HELPERS AND UTILITIES ------------------------------------------------\n\n\ndef pairwise(iterable):\n    \"\"\"\n    Returns the data of iterable in pairs (2-tuples).\n\n    Parameters\n    ----------\n    iterable : iterable\n        An iterable sequence of items.\n\n    Yields\n    ------\n    tuple\n        Two items per iteration, if there are at least two items in the\n        iterable.\n\n    Examples\n    --------\n    >>> print(pairwise(range(4))):\n    ...\n    [(0, 1), (1, 2), (2, 3)]\n\n    Notes\n    -----\n    For more info see [16]_ .\n\n    References\n    ----------\n    .. [16] Python itertools Recipes\n\n           See: `Python itertools Recipes <https://docs.python.org/2.7/\n           library/itertools.html#recipes>`_\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}