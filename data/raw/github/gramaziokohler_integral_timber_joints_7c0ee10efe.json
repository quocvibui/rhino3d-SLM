{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/assembly.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/assembly.py",
  "instruction": "Assembly",
  "code": "import Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext\nimport re\nfrom collections import Counter\n\nfrom compas.geometry import Frame, Vector, Point, Line, bounding_box, dot_vectors, cross_vectors, length_vector, subtract_vectors, close\nfrom compas.geometry import Transformation\nfrom compas_rhino.geometry import RhinoCurve, RhinoSurface\nfrom compas_rhino.ui import CommandMenu\nfrom compas_rhino.utilities.objects import get_object_name, get_object_names\nimport compas_rhino\n\nfrom integral_timber_joints.assembly import Assembly, BeamAssemblyMethod\nfrom integral_timber_joints.geometry.beam import Beam\nfrom integral_timber_joints.geometry import JointHalfLap, JointNonPlanarLap\nfrom integral_timber_joints.process import RobotClampAssemblyProcess\nfrom integral_timber_joints.process.compute_process_action_movement import recompute_initial_state\nfrom integral_timber_joints.geometry import Screw_SL, Joint\nfrom integral_timber_joints.rhino.load import get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.rhino.utility import get_existing_beams_filter, purge_objects, recompute_dependent_solutions\ntry:\n    from typing import Dict, Iterator, List, Optional, Tuple, Any\nexcept:\n    pass\n\n\ndef _create_joints_for_new_beam(process, new_beam):\n    # type: (RobotClampAssemblyProcess, Beam) -> tuple[list(Joint), list(str)]\n    assembly = process.assembly\n    new_joints = []  # type: list[Joint]\n    affected_neighbours = []  # type: list[str]\n    beam_move = new_beam\n    for existing_beam in assembly.beams():\n        beam_stay = existing_beam\n        if beam_stay == beam_move:\n            continue\n        # * Check for intersections. JointHalfLap first and JointNonPlanarLap next\n        # print('Checking for Planar Joint : %s-%s' % (beam_id, existing_beam.name))\n        j_s, j_m, screw_line = JointHalfLap.from_beam_beam_intersection(beam_stay, beam_move)\n        if j_m is None or j_s is None:\n            # print('Checking for Non-Planar Joint : %s-%s' % (beam_id, existing_beam.name))\n            j_s, j_m, screw_line = JointNonPlanarLap.from_beam_beam_intersection(beam_stay, beam_move)\n\n        if j_m is not None and j_s is not None:\n            print('- New Joint (%s) : %s-%s added to assembly' % (j_m.__class__.__name__, new_beam.name, existing_beam.name))\n            assembly.add_joint_pair(j_s, j_m, beam_stay.name, beam_move.name)\n            new_joints.append(j_m)\n            affected_neighbours.append(beam_stay.name)\n\n    # * Check if the new joints all agreed to the same beam face direction\n    moving_beam_face_ids = set([joint.face_id for joint in new_joints])\n    if len(moving_beam_face_ids) > 1:\n        # Recreate the joints using the majority face_id on the moving beam\n        moving_beam_face_ids_majority = Counter([joint.face_id for joint in new_joints]).most_common(1)[0][0]\n        if all([isinstance(joint, JointNonPlanarLap) for joint in new_joints]):\n            new_joints = []\n            for nbr_id in affected_neighbours:\n                beam_stay = assembly.beam(nbr_id)\n                j_s, j_m, screw_line = JointNonPlanarLap.from_beam_beam_intersection(beam_stay, beam_move, joint_face_id_move=moving_beam_face_ids_majority)\n                assembly.add_joint_pair(j_s, j_m, beam_stay.name, beam_move.name)\n                new_joints.append(j_m)\n\n    return new_joints, affected_neighbours\n\n\ndef _add_beams_to_assembly(process, beams, auto_joints=True):\n    # type: (RobotClampAssemblyProcess, list[Beam], bool) -> None\n    \"\"\"Shared function to add newly created Beams to Assembly\n\n    - Auto assign Assembly Method\n    - Compute Joint Screw\n    - create Joints and redraw changes in Rhino\n\n    This function can probably be refactered into Assembly class.\n    \"\"\"\n    assembly = process.assembly\n    new_beam_ids = []\n    affected_neighbours = []\n\n    # * Check for new Joints\n    for beam in beams:\n        beam_id = assembly.get_new_beam_id()\n        beam.name = beam_id\n        print('New Beam: %s' % beam_id)\n        new_beam_ids.append(beam_id)\n\n        # Add to assembly\n        assembly.add_beam(beam)\n\n        # * Check for joints (Joint_Halflap and JointNonPlanarLap)\n        if auto_joints:\n            new_joints, affected_neighbours = _create_joints_for_new_beam(process, beam)\n            affected_neighbours.extend(affected_neighbours)\n\n        # * Automatically assign Assembly Method\n        if not auto_joints:\n            assembly.set_beam_attribute(beam_id, 'assembly_method', BeamAssemblyMethod.MANUAL_ASSEMBLY)\n            print(\"- Automatically assigned Assembly method: MANUAL_ASSEMBLY\")\n        elif len(new_joints) == 0:\n            assembly.set_beam_attribute(beam_id, 'assembly_method', BeamAssemblyMethod.GROUND_CONTACT)\n            print(\"- Automatically assigned Assembly method: GROUND_CONTACT\")\n        elif any([isinstance(joint, JointNonPlanarLap) for joint in new_joints]):\n            assembly.set_beam_attribute(beam_id, 'assembly_method', BeamAssemblyMethod.SCREWED_WITH_GRIPPER)\n            print(\"- Automatically assigned Assembly method: SCREWED_WITH_GRIPPER\")\n        else:\n            assembly.set_beam_attribute(beam_id, 'assembly_method', BeamAssemblyMethod.CLAMPED)\n            print(\"- Automatically assigned Assembly method: CLAMPED\")\n\n        # * Initial state changed since we add a new beam\n        process.dependency.add_beam(beam_id)\n\n    # *Recompute dependent solutions for new beams and affected neighbours\n    recompute_initial_state(process)\n    for beam_id in set(affected_neighbours + new_beam_ids):\n        recompute_dependent_solutions(process, beam_id)\n\n    # * Draw newly added beams and neighbours affected by new joint\n    artist = get_process_artist()\n    for beam_id in set(affected_neighbours + new_beam_ids):\n        artist.redraw_interactive_beam(beam_id, force_update=True)\n    show_assembly_color(process, set(affected_neighbours + new_beam_ids), redraw=True)\n\n    print('%i Beams added to the assembly.' % len(new_beam_ids))\n\n\ndef _beam_order_comparator(x, y):\n    # type: (Beam, Beam) -> int\n    \"\"\"Creating a order based on `rhino_name` and `rhino_select_order` attribute.\n    Objects with names go first.\n    Otherwise, objects are listed based on selection order.\n    \"\"\"\n\n    x_rhino_name = x.rhino_name if hasattr(x, 'rhino_name') else None\n    y_rhino_name = y.rhino_name if hasattr(y, 'rhino_name') else None\n    x_rhino_select_order = x.rhino_select_order if hasattr(x, 'rhino_select_order') else None\n    y_rhino_select_order = y.rhino_select_order if hasattr(y, 'rhino_select_order') else None\n\n    def atoi(text):\n        # type: (str) -> Any\n        return int(text) if text.isdigit() else text\n\n    def natural_keys(text):\n        # type: (str) -> Any\n        '''\n        alist.sort(key=natural_keys) sorts in human order\n        http://nedbatchelder.com/blog/200712/human_sorting.html\n        (See Toothy's implementation in the comments)\n        '''\n        return [atoi(c) for c in re.split(r'(\\d+)', text)]\n\n    # Beams with both names will be compared.\n    if x_rhino_name is not None and y_rhino_name is not None:\n        return natural_keys(x_rhino_name) > natural_keys(y_rhino_name)\n    # Beams with no names go to the back of the sort.\n    if x_rhino_name is None and y_rhino_name is not None:\n        return 1\n    if y_rhino_name is None and x_rhino_name is not None:\n        return -1\n\n    if x_rhino_select_order is None and y_rhino_select_order is not None:\n        return -1\n    if y_rhino_select_order is None and x_rhino_select_order is not None:\n        return 1\n    return x_rhino_name > y_rhino_name\n\n\ndef ui_add_beam_from_lines(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    ''' Ask user for line(s) to create new beams.\n    '''\n    # ask user to pick lines\n    # guids = select_lines(\"Select Lines (no curve or polyline)\")\n    guids = rs.GetObjects(\"Select Lines (not curve or polyline)\", filter=rs.filter.curve)\n\n    if guids is None:\n        return\n\n    print(guids)\n    width = 100\n    height = 100\n\n    # Create Beams form lines\n    assembly = process.assembly  # type: Assembly\n    new_beams = []\n\n    # * Ask user for guide vector\n    guide_vector_rhino = rs.GetLine(mode=1, message1=\"Pick beam Y Direction Pt 1 (ESC to auto detect)\", message2=\"Pick beam Y Direction (ESC to auto detect)\")\n    if guide_vector_rhino is not None:\n        guide_vector = Vector.from_start_end(guide_vector_rhino[0], guide_vector_rhino[1])\n\n    for rhino_select_order, guid in enumerate(guids):\n        rhinocurve = compas_rhino.find_object(guid)\n        centerline = Line(rhinocurve.Geometry.PointAtStart, rhinocurve.Geometry.PointAtEnd)\n\n        if guide_vector_rhino is None:\n            # * Auto detect guide vector: For vertical lines, guide vector points to world X\n            # * Otherwise, guide vector points to Z,\n            centerline_vector = Vector.from_start_end(centerline.start, centerline.end)\n            dot_result = centerline_vector.unitized().dot(Vector(0, 0, 1))\n            if 1 - abs(dot_result) < 1e-5:\n                guide_vector = Vector(1, 0, 0)\n            else:\n                guide_vector = Vector(0, 0, 1)\n\n        # Create Beam object\n        beam = Beam.from_centerline(centerline, guide_vector, width, height)\n        # Find out the name in Rhino Properities for sorting\n        beam.rhino_name = rs.ObjectName(guid)\n        beam.rhino_select_order = rhino_select_order\n\n        new_beams.append(beam)\n\n    # Sorting by human sorting natural keys\n    new_beams.sort(cmp=_beam_order_comparator)\n    # Add to assembly\n    _add_beams_to_assembly(process, new_beams)\n\n\ndef beam_frame_from_points_and_vectors(points, edge_vectors, face_normals):\n    # type: (list[Point], list[Vector], list[Vector]) -> Frame\n\n    def caliper(vector, _points):\n        values = [dot_vectors(vector, point) for point in _points]\n        return (max(values) - min(values))\n\n    def best_aligned_vector(vectors, guide_vector):\n        alignment = [dot_vectors(guide_vector, v) for v in vectors]\n        return vectors[alignment.index(max(alignment))]\n\n    def unitize_vectors(vectors, non_zero=1e-7):\n        results = []\n        for vector in vectors:\n            length = length_vector(vector)\n            if length > non_zero:\n                results.append([value / length for value in vector])\n        return results\n\n    edge_vectors = unitize_vectors(edge_vectors)\n    face_normals = unitize_vectors(face_normals)\n\n    # * Compute caliper size for vector_z candidates\n    bounding_widths = [caliper(vector, points) for vector in face_normals]\n    beam_z_size = min(bounding_widths)\n    # * Sort out the vector(s) that have the smallest caliper size\n    vector_z_candidates = [vector for vector, widths in zip(face_normals, bounding_widths) if close(widths, beam_z_size)]\n    # * To break tie, an alignment vector is used\n    vector_z = best_aligned_vector(vector_z_candidates, [0.01, 0.1, 1])\n\n    # * Prepare vector_y candidates\n    vector_y_candidates = [cross_vectors(vector_z, vector) for vector in face_normals + edge_vectors]\n    vector_y_candidates = unitize_vectors(vector_y_candidates)  # Unitize\n    # * Compute caliper size and pick smallest one\n    bounding_widths = [caliper(vector, points) for vector in vector_y_candidates]\n    beam_y_size = min(bounding_widths)\n    vector_y_candidates = [vector for vector, widths in zip(vector_y_candidates, bounding_widths) if close(widths, beam_y_size)]\n    vector_y = best_aligned_vector(vector_y_candidates, [0, 1, 0])\n\n    vector_x = cross_vectors(vector_y, vector_z)\n    origin_x = min([dot_vectors(vector_x, point) for point in points])\n    origin_y = min([dot_vectors(vector_x, point) for point in points])\n    origin_z = min([dot_vectors(vector_x, point) for point in points])\n\n    frame = Frame([0, 0, 0], vector_x, vector_y)\n    return frame\n\n\ndef ui_create_beam_from_brep_box(process, multi_select=True):\n    # type: (RobotClampAssemblyProcess, bool) -> None\n    ''' Ask user for Brep(s) to create new beams.\n    Returns the newly created beams. Note that this is not added to Assembly.\n    '''\n    assembly = process.assembly  # type: Assembly\n    # ask user to pick boxes\n    print(\"Object names in Rhino can be used to srot beams.\")\n    if multi_select:\n        guids = rs.GetObjects(\"Select Brep (uncut 6 sided box only)\", filter=rs.filter.polysurface)\n    else:\n        guids = rs.GetObjects(\"Select Brep (uncut 6 sided box only)\", filter=rs.filter.polysurface, maximum_count=1)\n\n    if guids is None:\n        return\n\n    new_beams = []\n    for rhino_select_order, guid in enumerate(guids):\n        # Extract the vertices and face_normals from the Brep\n        # The normal at the (u,v) middle of the faces are used\n        brep = rs.coercebrep(guid)  # type: Rhino.Geometry.Brep\n        vertices = [[coor for coor in vertex.Location] for vertex in brep.Vertices]\n        edge_vectors = [subtract_vectors([_ for _ in edge.PointAtStart], [_ for _ in edge.PointAtEnd]) for edge in brep.Edges]\n        face_normals = [[_ for _ in face.NormalAt(face.Domain(0).Mid, face.Domain(1).Mid)] for face in brep.Faces]\n\n        # * Find the frame of the beam (no origin yet)\n        beam_frame = beam_frame_from_points_and_vectors(vertices, edge_vectors, face_normals)\n\n        # * Origin of the beam frame at minima\n        aligned_corners = [beam_frame.to_local_coordinates(point) for point in vertices]\n        bb = bounding_box(aligned_corners)\n        bounds_in_wcf = [beam_frame.to_world_coordinates(point) for point in bb]\n        beam_frame.point = bounds_in_wcf[0]  # min_corner\n\n        # * Size of the beam from the bounding box.\n        bb_size = Vector.from_start_end(bb[0], bb[6])\n        length = bb_size.x\n        height = bb_size.y\n        width = bb_size.z\n\n        # * Construct beam object\n        beam = Beam(frame=beam_frame, length=length, width=width, height=height)\n        # Find out the name in Rhino Properities for sorting\n        beam.rhino_name = rs.ObjectName(guid)\n        beam.rhino_select_order = rhino_select_order\n\n        new_beams.append(beam)\n\n    # Sorting by human sorting natural keys\n    new_beams.sort(cmp=_beam_order_comparator)\n\n    return new_beams\n\n\ndef ui_add_beam_from_brep_box(process, auto_joints=True,  multi_select=True):\n    ''' Ask user for Brep(s) to create new beams and add it to Assembly.\n    Returns the newly added beams which will contain the newly assigned `beam_id` in `beam.name`\n    '''\n    new_beams = ui_create_beam_from_brep_box(process, multi_select)\n\n    # Add to assembly\n    _add_beams_to_assembly(process, new_beams, auto_joints=auto_joints)\n    return new_beams\n\n\ndef ui_add_scaffold(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    \"\"\"Currently this is implemented as a beam with no joints.\"\"\"\n    return ui_add_beam_from_brep_box(process, auto_joints=False)\n\n\ndef ui_replace_scaffold_geometry(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    \"\"\"Ask user to select an existing \"Manual Placement\" beam for replacement.\"\"\"\n\n    while (True):\n        # Ask user to select which scaffolding to change\n        guid = rs.GetObject('Select scaffolding pieces to change geometry:', custom_filter=get_existing_beams_filter(process))\n        if guid is None:\n            print(\"No Beam Selected.\")\n            return\n        beam_id = get_object_name(guid)\n        existing_scaffold_beam = process.assembly.beam(beam_id)\n\n        # Ask user for new geometry\n        print(\"Select new geometry for scaffolding: %s\" % beam_id)\n        new_beams = ui_create_beam_from_brep_box(process, multi_select=False)\n        if new_beams is None:\n            print(\"No valid Brep Selected.\")\n            return\n        new_beam = new_beams[0]\n        new_beam.name = beam_id\n\n        # Copy geometry over\n        existing_scaffold_beam.data = new_beam.data\n        recompute_initial_state(process)\n        get_process_artist().redraw_interactive_beam(beam_id)\n\n        print(\"New geometry updated for scaffolding: %s\" % beam_id)\n\n\ndef ui_delete_beams(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    '''Ask User to select beams for deleting.\n    Deleting them from Process.Assembly.\n    '''\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    # Ask user for input\n    guids = rs.GetObjects('Select beams to delete:', custom_filter=get_existing_beams_filter(process))\n    if not guids:\n        return\n    beam_ids = get_object_names(guids)\n\n    # Figure out neighbours\n    neighbors = []\n    for beam_id in beam_ids:\n        neighbors += assembly.neighbors(beam_id)\n    neighbors = set(neighbors) - set(beam_ids)\n    print('Neighbour Beam Affected: %s' % neighbors)\n\n    rs.EnableRedraw(False)\n\n    # Delete Beams and their joints\n    for beam_id in beam_ids:\n        artist.delete_interactive_beam_visualization(beam_id)\n        # Maybe need to delete grippers and other things\n        assembly.remove_beam(beam_id)\n        # Delete from Process Dependency\n        process.dependency.delete_beam(beam_id)\n        print('Beam Removed: %s' % beam_id)\n\n    # Redraw neighbour beams since joints maybe gone.\n    show_assembly_color(process, neighbors, delete_old=True, redraw=False)\n    rs.EnableRedraw(True)\n\n\ndef ui_flip_beams(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    '''Ask User to select a beam for flipping the joints' direction\n    Only joints to earlier beams are flipped.\n\n    Beams with non planar joints cannot be flipped.\n\n    THis functions repeats until users press Enter without selecting beam.\n    '''\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n\n    while(True):\n        # Ask user for input\n        guids = rs.GetObject('Select beams to flip:', custom_filter=get_existing_beams_filter(process))\n        if not guids:\n            # Quit when user press Enter without selection\n            return\n        beam_id = get_object_name(guids)\n\n        # * Check if any of its joints to previous beams are non planar.\n        non_planar_exist = False\n        for joint_id in process.assembly.get_joints_of_beam_connected_to_already_built(beam_id):\n            if isinstance(process.assembly.joint(joint_id), JointNonPlanarLap):\n                print(\"Sorry. Cannot flip beams with non planar joints. Offending joint: %s-%s\" % joint_id)\n                non_planar_exist = True\n        if non_planar_exist:\n            continue\n\n        # * Loop though alread_built_neighbors and swap joint\n        earlier_neighbors = assembly.get_already_built_neighbors(beam_id)\n        for neighbour_id in earlier_neighbors:\n            joint_id = (beam_id, neighbour_id)\n            assembly.flip_lap_joint(joint_id)\n\n        # * Update drownstream computation\n        assembly.set_beam_attribute(beam_id, 'assembly_wcf_final', None)\n        recompute_dependent_solutions(process, beam_id)\n\n        # * Update visualization of flipped beam and neighbors\n        for beam_id in earlier_neighbors + [beam_id]:\n            artist.redraw_interactive_beam(beam_id, force_update=True)\n        show_assembly_color(process, earlier_neighbors + [beam_id], redraw=True)\n\n        print('Beam flipped: %s (Neighbours: %s)' % (beam_id, earlier_neighbors))\n\n\ndef show_assembly_method_color(process):\n    # Color Visualization\n    artist = get_process_artist()\n    rs.EnableRedraw(False)\n    print(\"Assembly Method Colour Legend:\")\n    print(\"- Red:       Undefined\")\n    print(\"- Black:     Ground\")\n    print(\"- Green:     Clamped\")\n    print(\"- LightBlue: ScrewedWithGripper\")\n    print(\"- DarkBlue:  ScrewedWithoutGripper\")\n    print(\"- Orange:  ManaulAssembly\")\n    for beam_id in process.assembly.sequence:\n        assembly_method = process.assembly.get_assembly_method(beam_id)\n        if assembly_method == BeamAssemblyMethod.GROUND_CONTACT:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_ground')\n        elif assembly_method == BeamAssemblyMethod.CLAMPED:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_clamped')\n        elif assembly_method == BeamAssemblyMethod.SCREWED_WITH_GRIPPER:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_screwed_w_gripper')\n        elif assembly_method == BeamAssemblyMethod.SCREWED_WITHOUT_GRIPPER:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_screwed_wo_gripper')\n        elif assembly_method == BeamAssemblyMethod.MANUAL_ASSEMBLY:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_manual_assembly')\n        else:\n            artist.change_interactive_beam_colour(beam_id, 'assembly_method_undefined')\n    rs.EnableRedraw(True)\n\n\ndef ui_change_assembly_method(process, preselection=[]):\n    # type: (RobotClampAssemblyProcess, Optional[list[str]]) -> None\n    '''Visualize beams assembly method in different colour.\n    Options for user to change assembly method.\n    Ask User to select beams.\n\n    Preselection (beam_ids) can be supplied and allow user to only select the Assembly Method.\n    '''\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n\n    show_assembly_method_color(process)\n\n    # Ask user if they want to change anything\n    while(True):\n        new_assembly_method = rs.GetString(\"Change Assembly Method to:\", \"Back\", list(BeamAssemblyMethod.names_to_value_dict.keys()) + [\"Back\"])\n        if new_assembly_method is not None and not new_assembly_method.startswith(\"Back\"):\n            new_assembly_method = BeamAssemblyMethod.names_to_value_dict[new_assembly_method]\n\n            # Ask user to select which to change\n            beam_ids = preselection\n            if len(beam_ids) == 0:\n                guids = rs.GetObjects('Select beams to change to %s :' % new_assembly_method, custom_filter=get_existing_beams_filter(process))\n                if guids is not None:\n                    beam_ids = get_object_names(guids)\n\n            # Make change to all selected beams\n            beams_to_redraw = []\n            if len(beam_ids) > 0:\n                for beam_id in beam_ids:\n                    old_assembly_method = assembly.get_assembly_method(beam_id)\n                    if new_assembly_method != old_assembly_method:\n                        # Changing assembly method\n                        process.assembly.set_beam_attribute(beam_id, 'assembly_method', new_assembly_method)\n                        beams_to_redraw.append(beam_id)\n                        # print ('Beam(%s) change from %s to %s' % (beam_id, old_assembly_method, new_assembly_method))\n\n                        # Change of Screw Hole situation will require a recomputation and mesh update\n                        if (new_assembly_method in BeamAssemblyMethod.screw_methods) != (old_assembly_method in BeamAssemblyMethod.screw_methods):\n                            for neighbour_beam_id in process.assembly.get_already_built_neighbors(beam_id):\n                                # Redraw Neighbour Beams because joint screw changed\n                                beams_to_redraw.append(neighbour_beam_id)\n\n                        process.dependency.invalidate(beam_id, process.assign_tool_type_to_joints)\n                        process.dependency.invalidate(beam_id, process.assign_gripper_to_beam)\n\n            [artist.redraw_interactive_beam(beam_id, force_update=True, redraw=False) for beam_id in beams_to_redraw]\n            show_assembly_method_color(process)\n\n            # Exit function if there are preselection\n            if len(preselection) > 0:\n                return\n        else:\n            show_assembly_color(process)\n            return\n\n\ndef ui_change_assembly_vector(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    '''Ask User to select beams for redefining the beam's assembly vector.\n    This only works for beams with no clamps'''\n    artist = get_process_artist()\n    # Ask user for input\n    beams_to_exclude = [beam_id for beam_id in process.assembly.sequence if len(process.assembly.get_joint_ids_with_tools_for_beam(beam_id)) > 0]\n    guids = rs.GetObjects('Select beams (with no clamps) for changing assembly vector:', custom_filter=get_existing_beams_filter(process, beams_to_exclude))\n    if guids is None:\n        # Quit when user press Enter without selection\n        print(\"No Beam selected.\")\n        return\n    beam_ids = get_object_names(guids)\n\n    # Ask user for two points for the assembly vector.\n    start = rs.GetPoint(\"Pick 2 points to define assembly vector. Start Point (vector.start)\")\n    end = rs.GetPoint(\"Pick 2 points to define assembly vector. End Point (vector.end)\")\n    if start is None or end is None:\n        print(\"No Point selected.\")\n        return\n    vector = Vector.from_start_end(start, end)\n\n    for beam_id in beam_ids:\n        process.assembly.compute_beam_assembly_direction_from_joints_and_sequence(beam_id, vector)\n        process.dependency.invalidate(beam_id, process.compute_gripper_grasp_pose)\n        process.dependency.compute_all(beam_id, attempt_all_parents_even_failure=True)\n        artist.delete_beam_all_positions(beam_id)\n        artist.delete_gripper_all_positions(beam_id)\n        for joint_id in process.assembly.get_joint_ids_of_beam(beam_id):\n            artist.delete_asstool_all_positions(joint_id, redraw=False)\n\n\ndef ui_orient_assembly(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    '''Allow users to transform the assembly using UI similar to Rhino Orient3Pt\n    '''\n    # Draw text dots for user to see what they have picked easier.\n    text_dots = []\n\n    # Source frame\n    # Ask for origin\n    origin = rs.GetPoint(\"Sorce Frame - Pick point at frame origin\")\n    if origin is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"So\", origin))\n    # Ask for X axis and Y Axis\n    x_point = rs.GetPoint(\"Sorce Frame - Pick point on X direction.\")\n    if x_point is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"Sx\", x_point))\n    y_point = rs.GetPoint(\"Sorce Frame - Pick point on Y direction.\")\n    if y_point is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"Sy\", y_point))\n\n    source_frame = Frame(origin, x_point - origin, y_point - origin)\n\n    # Target frame\n    # Ask for origin\n    origin = rs.GetPoint(\"Target Frame - Pick point at frame origin\")\n    if origin is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"To\", origin))\n    # Ask for X axis and Y Axis\n    x_point = rs.GetPoint(\"Target Frame - Pick point on X direction.\")\n    if x_point is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"Tx\", x_point))\n    y_point = rs.GetPoint(\"Target Frame - Pick point on Y direction.\")\n    if y_point is None:\n        purge_objects(text_dots)\n        return\n    text_dots.append(rs.AddTextDot(\"Ty\", y_point))\n\n    target_frame = Frame(origin, x_point - origin, y_point - origin)\n    print(\"Please wait, transforming assembly from %s to %s\" % (source_frame, target_frame))\n\n    # Delete the helpful text dot\n    rs.EnableRedraw(False)\n    purge_objects(text_dots)\n\n    T = Transformation.from_frame_to_frame(source_frame, target_frame)\n    assembly = process.assembly\n    artist = get_process_artist()\n\n    # Artist clear everything\n    for beam_id in assembly.sequence:\n        artist.delete_beam_all_positions(beam_id, redraw=False)\n        artist.delete_gripper_all_positions(beam_id, redraw=False)\n        artist.delete_interactive_beam_visualization(beam_id, redraw=False)\n        for joint_id in process.assembly.get_joint_ids_of_beam(beam_id):\n            artist.delete_asstool_all_positions(joint_id, redraw=False)\n\n    assembly.transform(T)\n    # Clear Actions and Movements because they are no longer valid.\n    # It would be nice if there exist a function to update their frames, but sadly, no.\n    process.dependency.invalidate(beam_id, process.compute_pickup_frame)\n\n    print(\"Assembly transformation complete, redrawing beams\")\n\n    # Prompt artist to redraw almost everything\n    for beam_id in assembly.sequence:\n        artist.redraw_interactive_beam(beam_id, force_update=True, redraw=False)\n    rs.EnableRedraw(True)\n\n    print(\"Assembly transformation redraw complete.\")\n\n\ndef something(process):\n    #\n    print('something')\n\n\ndef show_assembly_color(process, beam_ids=None, delete_old=False, redraw=True):\n    \"\"\"Activate assembly menu colour code.\n    Problematic beams that cannot be assembled are highlighted\n    \"\"\"\n    if beam_ids == None:\n        beam_ids = process.assembly.sequence\n    artist = get_process_artist()\n    rs.EnableRedraw(False)\n    for beam_id in beam_ids:\n        if delete_old:\n            artist.redraw_interactive_beam(beam_id, redraw=False)\n        if process.assembly.beam_problems(beam_id):\n            artist.change_interactive_beam_colour(beam_id, 'warning')\n        else:\n            artist.change_interactive_beam_colour(beam_id, 'active')\n    if redraw:\n        rs.EnableRedraw(True)\n\n\ndef hide_assembly_color(process, beam_ids=None):\n    \"\"\"Deactivate assembly menu colour code.\n    \"\"\"\n    if beam_ids == None:\n        beam_ids = process.assembly.sequence\n    artist = get_process_artist()\n    rs.EnableRedraw(False)\n    for beam_id in beam_ids:\n        artist.change_interactive_beam_colour(beam_id, 'normal')\n    rs.EnableRedraw(True)\n\n\ndef show_menu(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n\n    # Activate assembly menu colour code:\n    show_assembly_color(process)\n\n    while (True):\n        # Create Menu\n        config = {\n            'message': 'Assembly contains %i Beams %i Joints:' % (len(list(assembly.beams())), len(list(assembly.joints())) / 2),\n            'options': [\n                {'name': 'Finish', 'action': 'Exit'\n                 },\n                {'name': 'AddBeam', 'message': 'Add Beams ...', 'options': [\n                    {'name': 'Back', 'action': 'Back'},\n                    {'name': 'FromLines', 'action': ui_add_beam_from_lines},\n                    {'name': 'FromBrepBox', 'action': ui_add_beam_from_brep_box},\n                ]},\n                {'name': 'AddScaffold', 'action': ui_add_scaffold},\n                {'name': 'ReplaceScaffoldGeo', 'action': ui_replace_scaffold_geometry},\n                {'name': 'DeleteBeam', 'action': ui_delete_beams},\n                {'name': 'MoveAssembly', 'action': ui_orient_assembly},\n                {'name': 'FlipBeamAssemblyDirection', 'action': ui_flip_beams},\n                {'name': 'AssemblyMethod', 'action': ui_change_assembly_method},\n                {'name': 'RedefineAssemblyVector', 'action': ui_change_assembly_vector},\n            ]\n\n        }\n\n        result = CommandMenu(config).select_action()\n        # User cancel command by Escape\n        if result is None or 'action' not in result:\n            print('Exit Function')\n            hide_assembly_color(process)\n            return Rhino.Commands.Result.Cancel\n\n        action = result['action']\n        # print(action)\n        # User click Exit Button\n        if action == 'Exit':\n            print('Exit Function')\n            hide_assembly_color(process)\n            return Rhino.Commands.Result.Cancel\n\n        # If user clicked \"back\" do nothing.\n        if action == 'Back':\n            continue\n        # Run the action\n        else:\n            action(process)\n\n######################\n# Rhino Entry Point\n######################\n# Below is the functions that get evoked when user press UI Button\n# Put this in the Rhino button ! _-RunPythonScript 'integral_timber_joints.rhino.load.py'\n\n\nif __name__ == '__main__':\n    process = get_process()\n    if process_is_none(process):\n        print(\"Load json first\")\n    else:\n        show_menu(process)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}