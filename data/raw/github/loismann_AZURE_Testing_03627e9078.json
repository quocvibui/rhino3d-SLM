{
  "source_url": "https://github.com/loismann/AZURE_Testing/blob/283dc1bdc050ffb21bbedfc1c37d458d47694ea8/HKS_ScriptFileTransfer.py",
  "repo": "loismann/AZURE_Testing",
  "repo_stars": 0,
  "repo_description": "Testing Azure Simulation",
  "license": "unknown",
  "filepath": "HKS_ScriptFileTransfer.py",
  "instruction": "Hks script file transfer",
  "code": "import os\nimport scriptcontext as sc\nparamiko = sc.sticky['paramiko']\nimport time\nscp = sc.sticky['scp']\nimport subprocess\n\n\n\n# Pull the sticky value for the number of VMs\nif sc.sticky.has_key(\"Global_VM_Count\"):\n    VM_Count = sc.sticky[\"Global_VM_Count\"]\nelse:\n    print(\"VM Count Not Detected\")\n\n\n############################################## SUPPORTING RESOURCE SETUP ###############################################\n\n#This gets all Active Directory credentials\ndef get_credentials():\n    credentials = sc.sticky['azure.common.credentials'].ServicePrincipalCredentials(\n        client_id=sc.sticky['Login_Info'].APPLICATION_ID,\n        secret=sc.sticky['Login_Info'].AUTHENTICATION_KEY,\n        tenant=sc.sticky['Login_Info'].DIRECTORY_ID,\n    )\n\n    return credentials\n\n#Instantiate all the management clients:\ndef instantiateMgmtClient():\n    # Run the credentials function\n    credentials = get_credentials()\n\n    # Initialize Management Clients\n    resource_group_client = sc.sticky['azure.mgmt.resource'].ResourceManagementClient(\n        credentials,\n        sc.sticky['Login_Info'].SUBSCRIPTION_ID\n    )\n\n    network_client = sc.sticky['azure.mgmt.network'].NetworkManagementClient(\n        credentials,\n        sc.sticky['Login_Info'].SUBSCRIPTION_ID\n    )\n\n    compute_client = sc.sticky['azure.mgmt.compute'].ComputeManagementClient(\n        credentials,\n        sc.sticky['Login_Info'].SUBSCRIPTION_ID\n    )\n    return [resource_group_client,network_client,compute_client]\n\n# This will find the private (internal HKS) IP address for a VM\ndef getPrivateIpAddress(network_client, Instance):\n    nic = network_client.network_interfaces.get(sc.sticky['Login_Info'].GROUP_NAME,\n                                                sc.sticky['Login_Info'].GROUP_NAME + '_myNic_' + str(Instance), )\n    #https://docs.microsoft.com/en-us/python/api/azure-mgmt-network/azure.mgmt.network.v2018_08_01.models.networkinterfaceipconfiguration?view=azure-python\n    #https://github.com/Azure/azure-sdk-for-python/issues/695#issuecomment-236024219\n    # This will dissassocate the public ip address from the VM:\n    privateIP = nic.ip_configurations[0].private_ip_address\n    # This updates the network interface that currently exists with the properties of the variable \"nic\" assigned above\n    network_client.network_interfaces.create_or_update(sc.sticky['Login_Info'].GROUP_NAME,\n                                                       sc.sticky['Login_Info'].GROUP_NAME + '_myNic_' + str(Instance),\n                                                       nic)\n    return privateIP\n\n# This translates the bat files in the study folder into bash files\ndef bat_to_sh(file_path):\n    \"\"\"Convert a honeybee .bat file to .sh file.\n\n    WARNING: This is a very simple function and doesn't handle any edge cases.\n    \"\"\"\n    sh_file = file_path[:-4] + '.sh'\n    with open(file_path, 'rb') as inf, open(sh_file, 'wb') as outf:\n        # print inf\n        outf.write('#!/usr/bin/env bash\\n\\n')\n        row = inf.readlines()\n        # print row\n        for line in row:\n            # pass the path lines, etc to get to the commands\n            if line.strip():\n                continue\n            else:\n                break\n\n        for line in row:\n            # print line\n            if line.startswith('echo'):\n                continue\n            # replace c:\\radiance\\bin and also chanege \\\\ to /\n            modified_line = line.replace('c:\\\\radiance\\\\bin\\\\', '').replace('\\\\', '/')\n            outf.write(modified_line)\n\n    # print('bash file is created at:\\n\\t%s' % sh_file)\n    return sh_file\n\n# Not sure the difference between this and \"runBatchFiles\"\ndef executeBatchFiles(self, batchFileNames, maxPRuns=None, shell=True, waitingTime=0.5):\n    \"\"\"Run a number of batch files in parallel and\n        wait to end of the analysis.\n\n        Args:\n            batchFileNames: List of batch files\n            maxPRuns: max number of files to be ran in parallel (default = 0)\n            shell: set to True if you do NOT want to see the cmd window while the analysis is runnig\n    \"\"\"\n\n    if not maxPRuns: maxPRuns = 1\n    maxPRuns = int(maxPRuns)\n    total = len(batchFileNames)\n\n    if maxPRuns < 1: maxPRuns = 1\n    if maxPRuns > total: maxPRuns = total\n\n    running = 0\n    done = False\n    jobs = []\n    pid = 0\n\n    try:\n        while not done:\n            if running < maxPRuns and pid < total:\n                # execute the files\n                jobs.append(subprocess.Popen(batchFileNames[pid].replace(\"\\\\\", \"/\"), shell=shell))\n                pid += 1\n                time.sleep(waitingTime)\n\n            # count how many jobs are running and how many are done\n            running = 0\n            finished = 0\n            for job in jobs:\n                if job.poll() is None:\n                    # one job is still running\n                    running += 1\n                else:\n                    finished += 1\n\n            if running == maxPRuns:\n                # wait for half a second\n                # print \"waiting...\"\n                time.sleep(waitingTime)\n\n            if finished == total:\n                done = True\n\n    except Exception as e:\n        print(\"Something went wrong: %s\" % str(e))\n\n# Not sure the difference between this and \"excecuteBatchFiles\"\ndef runBatchFiles(self, initBatchFileName, batchFileNames, fileNames, \\\n                  pcompBatchFile, waitingTime, runInBackground=False):\n    self.executeBatchFiles([initBatchFileName], maxPRuns=1, shell=runInBackground, waitingTime=waitingTime)\n    self.executeBatchFiles(batchFileNames, maxPRuns=len(batchFileNames), shell=runInBackground, waitingTime=waitingTime)\n\n    if pcompBatchFile != \"\":\n        os.system(pcompBatchFile)  # put all the files together\n\n# Does this need to be here?  It's referencing recipes from grasshopper.  Should this be in a separate \"results\" button?\ndef collectResults(self, subWorkingDir, radFileName, numOfCPUs, analysisRecipe, expectedResultFiles):\n    if analysisRecipe.type == 2:\n        # annual simulation\n        runAnnualGlare = analysisRecipe.DSParameters.runAnnualGlare\n        onlyAnnualGlare = analysisRecipe.DSParameters.onlyAnnualGlare\n        numOfIllFiles = analysisRecipe.DSParameters.numOfIll\n        annualGlareViews = analysisRecipe.DSParameters.RhinoViewsName\n        DSResultFilesAddress = []\n\n        if not (runAnnualGlare and onlyAnnualGlare):\n            # read the number of .ill files\n            # and the number of .dc files\n            if subWorkingDir[-1] == os.sep: subWorkingDir = subWorkingDir[:-1]\n            startTime = time.time()\n\n            # check if the results are available\n            files = os.listdir(subWorkingDir)\n            numIll = 0\n            numDc = 0\n            for file in files:\n                if file.EndsWith('ill'):\n                    DSResultFilesAddress.append(os.path.join(subWorkingDir, file))\n                    numIll += 1\n                elif file.EndsWith('dc'):\n                    numDc += 1\n            # /2 in case of conceptual dynamic blinds in Daysim\n            if numIll != numOfCPUs * numOfIllFiles or not \\\n                    (numDc == numOfCPUs * numOfIllFiles or \\\n                     numDc == numOfCPUs * numOfIllFiles / 2):\n                print\n                \"Can't find the results for the study\"\n                DSResultFilesAddress = []\n\n        # check for results of annual glare analysis if any\n        annualGlareResults = {}\n        for view in annualGlareViews:\n            if view not in annualGlareResults.keys():\n                annualGlareResults[view] = []\n\n        dgpFile = os.path.join(subWorkingDir, radFileName + '_0.dgp')\n\n        if runAnnualGlare and os.path.isfile(dgpFile):\n            with open(dgpFile, \"r\") as dgpRes:\n                for line in dgpRes:\n                    try:\n                        hourlyRes = line.split(\" \")[4:]\n                        # for each view there should be a number\n                        for view, res in zip(annualGlareViews, hourlyRes):\n                            annualGlareResults[view].append(res.strip())\n                    except:\n                        pass\n\n        return DSResultFilesAddress, annualGlareResults\n\n    elif analysisRecipe.type == 0:\n        # image-based analysis\n        return expectedResultFiles\n\n    else:\n        RADResultFilesAddress = expectedResultFiles\n        # grid-based analysis\n        numRes = 0\n        files = os.listdir(subWorkingDir)\n        for file in files:\n            if file.EndsWith('res'): numRes += 1\n        if numRes != numOfCPUs:\n            print\n            \"Cannot find the results of the study\"\n            RADResultFilesAddress = []\n        time.sleep(1)\n        return RADResultFilesAddress\n\n# Copy the files over from the local computer to a remote computer\ndef copyfilesSCP(IP_Address, port, username, password, source, destination):\n    ssh_client = paramiko.SSHClient()\n    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh_client.connect(IP_Address, port=port, username=username, password=password)\n    tr = ssh_client.get_transport()\n    tr.default_max_packet_size = 1000000000\n    tr.default_window_size = 1000000000\n    scp_run = scp.SCPClient(tr)\n    scp_run.put(source,destination)\n    scp_run.close()\n    tr.close()\n\n# This was originally in here to try and fix the file copy problem - not sure if this is still needed\ndef fixfile(filename):\n    windows_line_ending = '\\r\\n'\n    linux_line_ending = '\\n'\n    with open(filename, 'rb') as f:\n        content = f.read()\n        content = content.replace(windows_line_ending, linux_line_ending)\n    with open(filename, 'wb') as f:\n        f.write(content)\n\n\n\n\n\n\n###########################################  RUN CODE ####################################################\n\n\nif Run:\n    # Main: Get the IP addresses of the machines currently in use\n    # Sub: Instantiate the Azure clients\n\n    #Main Folder Location:\n    study_folder = input(\"Paste Folder Location of .bat files for conversion:\")\n\n    resource_group_client = instantiateMgmtClient()[0]\n    network_client = instantiateMgmtClient()[1]\n    compute_client = instantiateMgmtClient()[2]\n\n    # Sub: Find the resource group that the user created\n    myresource_group = None\n    for item in resource_group_client.resource_groups.list():\n        if \"AUTOBUNTU\" in str(item):\n            myresource_group = item.name\n\n    # Main: List of IP addresses\n    privateIpAddresses = []\n    for i in range(VM_Count):\n        privateIP = getPrivateIpAddress(network_client, i)\n        privateIpAddresses.append(privateIP)\n    print(privateIpAddresses)\n\n    # Main: Find the directory where all the batch files are written\n    # Sub: Go through all the folders and files in the simulation folder\n    for root, dirs, files in os.walk(os.path.abspath(study_folder)):\n        for file in files:\n            file_path = os.path.join(root, file)\n            if file_path.endswith(\".bat\"):\n                # print file_path\n                bat_to_sh(file_path)\n\n    # For the Glare analysis, figure out how many simulation folders need to go to each machine\n    # This will be the total number of hours being run divided by the total number of VM instances\n\n    # Connect to virtual machine and Copy over Base Project files\n    for i in range(VM_Count):\n        for root, dirs, files in os.walk(os.path.abspath(study_folder)):\n            for file in files:\n                # print file\n                original_file_path = os.path.join(root, file)\n                if not original_file_path.endswith(\".bat\"):\n                    # print original_file_path\n                    destination_file_path = \"/home/pferrer/\" + file\n                    # print destination_file_path\n                    fixfile(original_file_path)\n                    copyfilesSCP(privateIpAddresses[i],\n                                  22,\n                                  sc.sticky['Login_Info'].ADMIN_NAME,\n                                  sc.sticky['Login_Info'].ADMIN_PSWD,\n                                  original_file_path,\n                                  destination_file_path,\n                                  )\n    print(\"Files Copied\")",
  "language": "python",
  "imports": [
    "scriptcontext"
  ],
  "has_docstring": false
}