{
  "source_url": "https://github.com/TSRChapman/LandArchTools-for-Rhino/blob/43036cbbcab2bf756216f6a752f65e83aac3fccb/ScatterBlocks.py",
  "repo": "TSRChapman/LandArchTools-for-Rhino",
  "repo_stars": 5,
  "repo_description": "Custom Tools for Rhino made for Landscape Architects",
  "license": "BSD-3-Clause",
  "filepath": "ScatterBlocks.py",
  "instruction": "Copyright <2022> <Thomas Chapman>",
  "code": "'''\n\nCopyright <2022> <Thomas Chapman>\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'''\n\n# SCATTER BLOCKS\n\nimport rhinoscriptsyntax as rs\nimport random\nimport math\nimport Rhino\nimport scriptcontext as sc\n\n# r1 = vector 01 of triangle from origin (this will be randomised between 0,1)\n# r2 = vector 02 of triangle from origin (this will be randomised between 0,1)\n# a = origin corner of triangle (this should be picked as largest radius)\n# b, c = other corners of triangle\n\n\ndef ScatterBlocks():\n    try:\n        ################################################################################\n        #                             GET OBJECTS AND VARIABLE                         #\n        ################################################################################\n\n        obj = rs.GetObject(message=\"Select surface to scatter on\", filter=8 | 16 |\n                           32, preselect=False, select=False, custom_filter=None, subobjects=False)\n        if not obj:\n            return\n        blocks = rs.GetObjects(message=\"Select blocks to scatter\", filter=4096, group=True, preselect=False,\n                               select=False, objects=None, minimum_count=1, maximum_count=0, custom_filter=None)\n        if not blocks:\n            return\n        scatterNum = rs.GetInteger(\n            message=\"Enter scatter amount\", number=100, minimum=1, maximum=10000)\n        if not scatterNum:\n            return\n        userScale = rs.GetReal(\n            \"enter scale multiplyer (0 for no scaling)\", number=0, minimum=None, maximum=None)\n\n        userRotation = rs.GetBoolean(\n            \"random rotation of blocks?\", (\"Rotation\", \"No\", \"Yes\"), (True))\n        if not userRotation:\n            return\n\n        isMesh = rs.IsMesh(obj)\n        ptBucket = 0\n        pointList = []\n        blockList = []\n        worldZVector = (rs.WorldXYPlane()).ZAxis\n\n        rs.EnableRedraw(False)\n\n        def MeshBrep(brep_id, params):\n            brep = rs.coercebrep(brep_id)\n            if brep:\n                mesh = Rhino.Geometry.Mesh()\n                mesh_parts = Rhino.Geometry.Mesh.CreateFromBrep(brep, params)\n                for mesh_part in mesh_parts:\n                    mesh.Append(mesh_part)\n                mesh.Compact()\n                return mesh\n\n        def TestMeshBrep():\n            mesh_params = Rhino.Geometry.MeshingParameters.Coarse\n            mesh_brep = MeshBrep(obj, mesh_params)\n            if mesh_brep:\n                mesh = sc.doc.Objects.AddMesh(mesh_brep)\n            return mesh\n\n        def chunks(lst, n):  # list split generator\n            for i in xrange(0, len(lst), n):\n                yield lst[i:i + n]\n\n        if isMesh == False:\n            mesh = TestMeshBrep()\n        else:\n            mesh = obj\n\n        # Get and format vertex points in mesh, format from point3d object to float list\n        meshVerts = rs.MeshFaces(mesh, face_type=False)\n        totalArea = rs.MeshArea(mesh)\n        meshFaceCount = rs.MeshFaceCount(mesh)\n\n        PT01 = meshVerts[0::3]\n        PT01S = []\n        for i in PT01:\n            i = (i.X, i.Y, i.Z)\n            PT01S.append(i)\n\n        PT02 = meshVerts[1::3]\n        PT02S = []\n        for i in PT02:\n            i = (i.X, i.Y, i.Z)\n            PT02S.append(i)\n\n        PT03 = meshVerts[2::3]\n        PT03S = []\n        for i in PT03:\n            i = (i.X, i.Y, i.Z)\n            PT03S.append(i)\n\n        # format list together in order to loop through\n        triangleList = zip(PT01S, PT02S, PT03S)\n\n        ################################################################################\n        #                             POINT SCATTER LOOP                               #\n        ################################################################################\n\n        # loop through the three vertexes forming individual triangles\n        for i in triangleList:\n            a = i[0]  # triangle vert 1\n            b = i[1]  # triangle vert 2\n            c = i[2]  # triangle vert 3\n\n        # Find area of triangle\n            dist01 = rs.Distance(a, b)\n            dist02 = rs.Distance(a, c)\n            dist03 = rs.Distance(b, c)\n            # Herons formula to find area of triangle by sides\n            s = (dist01 + dist02 + dist03) / 2\n            tArea = math.sqrt(s*(s-dist01)*(s-dist02)*(s-dist03))\n\n        # assign portion of points base on area of triangle, if assignment of points is lower then one, add that to the next assignment\n            numPtsPerUnit = totalArea[1] / scatterNum\n            ptAllocation = tArea / numPtsPerUnit\n            ptBucket = ptBucket + ptAllocation\n\n            if ptBucket < 1:\n                continue\n            else:\n                pointShare = int(math.floor(ptBucket))\n                ptBucket = 0\n\n        # Vectors from origin to either corner of triangle\n            ac = rs.VectorCreate(c, a)\n            ab = rs.VectorCreate(b, a)\n            originVector = rs.VectorCreate(a, (0, 0, 0))\n\n        # Generate random numbers between 0,1. Random scatter onto triangle\n            for i in range(pointShare):\n                r1 = random.random()\n                r2 = random.random()\n                if r1 + r2 < 1:\n                    p = r1 * ac + r2 * ab\n                else:\n                    p = (1 - r1) * ac + (1 - r2) * ab\n\n                points = rs.AddPoint(p)\n                pointList.append(points)\n                rs.MoveObjects(points, originVector)\n\n        ################################################################################\n        #                 MOVE BLOCKS TO POINTS WITH ROTATION / SCALE                  #\n        ################################################################################\n\n        # shuffle point list then split list by the number of blocks to scatter. Copy blocks to split lists\n        random.shuffle(pointList)\n        ptDivision = int(len(pointList) / len(blocks))\n        genList = chunks(pointList, ptDivision)\n        blockIndex = 0\n\n        for pts in genList:  # looping through split point list and blocks and copying blocks to scatter\n            blockPt = rs.BlockInstanceInsertPoint(blocks[blockIndex])\n            for pt in pts:\n                vector = rs.VectorCreate(pt, blockPt)\n                newBlock = rs.CopyObject(blocks[blockIndex], vector)\n                # create list of blocks for later modification\n                blockList.append(newBlock)\n            if blockIndex < (len(blocks) - 1):\n                blockIndex += 1\n\n        # apply random scaling and rotation to blocks\n        if userRotation[0] == True:\n            for block in blockList:\n                centerPt = rs.BlockInstanceInsertPoint(block)\n                angle = random.randint(0, 360)\n                rs.RotateObject(block, centerPt, angle, worldZVector)\n\n        for block in blockList:\n            centerPt = rs.BlockInstanceInsertPoint(block)\n            scale = random.uniform((userScale/4), userScale)\n            rs.ScaleObject(block, centerPt, (scale, scale, scale))\n\n        # If a mesh was created, delete it, general cleanup\n        if isMesh == False:\n            rs.DeleteObject(mesh)\n        rs.DeleteObjects(pointList)\n\n        rs.EnableRedraw(True)\n\n    except:\n        print(\"Failed to execute\")\n        rs.EnableRedraw(True)\n        return\n\n\nif __name__ == \"__main__\":\n    ScatterBlocks()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}