{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/otherThing/wallDefinition2.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/otherThing/wallDefinition2.py",
  "instruction": "Wall definition2",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Area, SurfaceClosestPoint, EvaluateSurface, SurfaceSplit, Extrude, OffsetCurve, BoundarySurfaces, TrimwithRegions, JoinCurves, RegionDifference, AlignPlane, EvaluateLength, LineSDL, Project, RegionUnion\nimport ghpythonlib.treehelpers as th\nimport math\nfrom copy import copy, deepcopy\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport System.Array as array\nfrom itertools import chain\nimport random\nfrom collections import Counter\n\n\nclass CompoundMaterial:\n    def __init__(self, materialList):\n        self.materialList = materialList\n        self.new_materialList = self.readMaterial(self.materialList)\n        self.thicknessList = self.calculateThickness(self.new_materialList)\n\n    \n    def readMaterial(self, materialList):\n        new_materialList = []\n        for mat in materialList:\n            if hasattr(mat, 'boardData'):\n                new_materialList.append(mat.boardData)\n            elif hasattr(mat, 'substructInfillData'):\n                new_materialList.append(mat.substructInfillData)\n            elif hasattr(mat, 'substructData'):\n                new_materialList.append(mat.substructData)\n            elif hasattr(mat, 'paintData'):\n                new_materialList.append(mat.paintData)\n            elif hasattr(mat, 'claddingData'):\n                new_materialList.append(mat.claddingData)\n        return new_materialList\n\n    \n    def calculateThickness(self, materialList):\n        thicknessList = []\n        for mat in materialList:\n            thicknessList.append(mat.thickness)\n        return thicknessList\n\n\nclass innerMaterialGenerate:\n    def __init__(self, surfaceList, materialList, thicknessList, moduleDistance, wallFrame):\n        self.surfaceList = surfaceList\n        self.materialList = materialList\n        self.thicknessList = thicknessList\n        self.moduleDistance = moduleDistance\n        self.wallFrame = wallFrame\n\n        basePlane = [self.wallFrame]\n        boardGeoList = []\n        substructInfillGeoList = []\n        paintGeoList = []\n        substructGeoList = []\n        claddingGeoList = []\n        self.materialInfoDict = {}\n        layerTree = DataTree[object]()\n        layerTreeModule = DataTree[object]()\n\n        self.checkGeo = []\n\n        for self.id, (srfList, matList) in enumerate(zip(self.surfaceList, self.materialList)):\n            mat = matList\n            srfList = [srfList]\n            \n            allTypeGeo = []\n            for entireSrf_id, entireSrf in enumerate(srfList):\n                workPlane = basePlane[entireSrf_id]\n                matType = mat.materialType\n                srfList = self.create_module(entireSrf, workPlane, self.moduleDistance)\n                self.checkGeo.append(srfList)\n\n                if self.id not in self.materialInfoDict:\n                    self.materialInfoDict[self.id] = {}\n\n\n                for self.module_id, srf in enumerate(srfList):\n                    if self.module_id not in self.materialInfoDict[self.id]:\n                        self.materialInfoDict[self.id][self.module_id] = {}\n\n                    allTypeGeoModule = []\n                    if matType == \"board\":\n                        boardGeo = self.create_board(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n                        boardGeoList.append(boardGeo)\n                        allTypeGeo.append(boardGeo)\n                        allTypeGeoModule.append(boardGeo)\n                        \n                    elif matType == \"substructInfill\":\n                        panelGeo, beamGeo = self.create_substructInfill(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n                        substructInfillGeoList.append(beamGeo)\n                        substructInfillGeoList.append(panelGeo)\n                        allTypeGeo.append(beamGeo)\n                        allTypeGeo.append(panelGeo)\n                        li = []\n                        li.extend(beamGeo)\n                        li.extend(panelGeo)\n                        allTypeGeoModule.append(li)\n\n                    elif matType == \"paint\":\n                        paintGeo = self.create_paint(srf, workPlane, mat.thickness)\n                        paintGeoList.append([paintGeo])\n                        allTypeGeo.append([paintGeo])\n                        allTypeGeoModule.append([paintGeo])\n                        \n                    elif matType == \"substruct\":\n                        substructGeo = self.create_substruct(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n                        substructGeoList.append(substructGeo)\n                        allTypeGeo.append(substructGeo)\n                        allTypeGeoModule.append(substructGeo)\n\n                    elif matType == \"cladding\":\n                        claddingGeo = self.create_cladding(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n                        claddingGeoList.append(claddingGeo)\n                        allTypeGeo.append(claddingGeo)\n                        allTypeGeoModule.append(claddingGeo)\n                    \n                    path_module = GH_Path(array[int]([self.id, self.module_id]))\n                    layerTreeModule.AddRange(allTypeGeoModule, path_module)\n                    \n                \n            path = GH_Path(array[int]([0,0,self.id]))\n            layerTree.AddRange(allTypeGeo, path)\n                \n        self.allTypeMaterial = layerTree\n        self.allTypeMaterialModule = layerTreeModule\n        \n\n\n    def create_module(self, surface, base_plane, distance):\n        def sortSurface(srfList, sortPlane):\n            # Calculate the center point of each surface's bounding box\n            centers = [srf.GetBoundingBox(True).Center for srf in srfList]\n            \n            # Project these center points onto the sortPlane's Y-axis and calculate distance from the plane's origin\n            distances = [sortPlane.YAxis * (center - sortPlane.Origin) for center in centers]\n            \n            # Sort the surfaces based on these distances\n            sortedSurfaces = [srf for _, srf in sorted(zip(distances, srfList))]\n            \n            return sortedSurfaces\n\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        curves, _ = self.create_contours(surface, base_plane, distance)\n        surfaceList = SurfaceSplit(surface, curves)\n        surfaceList = sortSurface(surfaceList, base_plane)\n\n        return surfaceList\n\n\n    def create_contours(self, surface, base_plane, interval):\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.XAxis, base_plane.Origin)\n        base_plane.Rotate(math.pi/10, base_plane.ZAxis, base_plane.Origin)\n        contours = []\n        # trimmed_contours = []\n\n        # Get the bounding box of the surface in the plane's coordinate system\n        bbox = surface.GetBoundingBox(base_plane)\n\n        # Start and end values for contouring in the direction of the plane's normal\n        start = bbox.Min.Z\n        end = bbox.Max.Z\n        \n        # Generate contours\n        # z = start\n        # while z <= end:\n        #     # Create a plane parallel to the base plane at height z\n        #     contour_plane = rg.Plane(base_plane)\n        #     contour_plane.Translate(base_plane.Normal * z)\n\n        #     # Generate the contour\n        #     contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n        #     contours.extend(contour_curves)\n            \n        #     z += interval\n        \n        # =====================\n        z = end\n        while z >= start:\n            # Create a plane parallel to the base plane at height z\n            contour_plane = rg.Plane(base_plane)\n            contour_plane.Translate(base_plane.Normal * z)\n\n            # Generate the contour\n            contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n            contours.extend(contour_curves)\n            \n            z -= interval\n\n\n\n        total_length = 0\n        for crv in contours:\n            total_length += crv.GetLength()\n            # print(crv.GetLength())\n\n        return (contours, int(total_length))\n\n\n    def create_beam(self, curve, base_plane, width, height):\n        start_point = curve.PointAtStart\n\n        # Create a plane at the start point with the same orientation as the provided plane\n        section_plane = rg.Plane(start_point, base_plane.YAxis, base_plane.ZAxis)\n        matrix = rg.Transform.Translation(-base_plane.YAxis*width/2)\n        section_plane.Transform(matrix)\n\n        # Create a rectangle in this plane\n        rectangle = rg.Rectangle3d(section_plane, width, height)\n\n        # Create a sweep\n        sweep = rg.SweepOneRail()\n        sweep.AngleToleranceRadians = 0.01\n        sweep.ClosedSweep = True\n        sweep.SweepTolerance = 0.01\n\n        # Perform the sweep\n        swept_breps = sweep.PerformSweep(curve, rectangle.ToNurbsCurve())\n\n        # Assuming we want the first Brep if there are multiple\n        return swept_breps[0]\n        \n\n    def create_board(self, surface, base_plane, length, width, thickness, direction):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n        crvLength, _ = self.create_contours(surface, firDirPlane, length)\n        crvWidth, _ = self.create_contours(surface, secDirPlane, width)\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n\n\n        panelGeoList = SurfaceSplit(surface, crvCombine)\n\n        # create panel geometry\n        panelOffsetList = []\n        boardSeam = 2\n        for panel in panelGeoList:\n            panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n\n        # Record Material using information.\n        boardArea = length*width\n        cuttedPiece = 0\n        for panel in panelGeoList:\n            area_properties = rg.AreaMassProperties.Compute(panel)\n            if area_properties is not None:\n                panelArea = area_properties.Area\n                if (boardArea - panelArea) > 100:\n                    cuttedPiece += 1\n\n        usedPiece = len(panelGeoList)\n        self.materialInfoDict[self.id][self.module_id][\"typeName\"] = \"board\"\n        self.materialInfoDict[self.id][self.module_id][\"usedPiece\"] = usedPiece\n        self.materialInfoDict[self.id][self.module_id][\"cuttedPiece\"] = cuttedPiece\n        self.materialInfoDict[self.id][self.module_id][\"completedPiece\"] = usedPiece - cuttedPiece\n        \n        return panelOffsetList\n\n\n    def create_substructInfill(self, surface, base_plane, width, thickness, distance, direction):\n        def offset_surface_inner(surface, plane, distance, tolerance=0.01):\n            inner_distance = -abs(distance)\n            \n            # Offset the surface\n            print(type(surface))\n            offset_surface = surface.Offset(1000, tolerance)\n            \n            if offset_surface:\n                # Convert the offset surface to Brep\n                return offset_surface\n            else:\n                print(\"Offset operation failed.\")\n                return None\n\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv, substructureLength = self.create_contours(surface, workPlane, distance)\n\n        panelGeoList = SurfaceSplit(surface, substructCrv)\n\n        if isinstance(panelGeoList, list):\n            pass\n        else:\n            panelGeoList = [panelGeoList]\n   \n        # create panel geometry\n        panelOffsetList = []\n        totalArea = 0\n        for panel in panelGeoList:\n            # Assuming 'brep' is your Brep object and it's essentially a single surface\n            if panel.Faces.Count == 1:\n                surface = panel.Faces[0]\n            else:\n                print(\"The Brep contains multiple faces. Please specify which face to offset.\")\n                # For this example, let's proceed with the first face\n                surface = panel.Faces[0]\n            \n            # panelOffsetSrf = offset_surface_inner(surface, base_plane, width/2)\n            panelOffsetSrf = panel\n\n            panelOffsetList.append(Extrude(panelOffsetSrf, base_plane.ZAxis*thickness*0.8))\n\n            area_properties = rg.AreaMassProperties.Compute(panelOffsetSrf)\n            if area_properties is not None:\n                panelArea = area_properties.Area\n                totalArea += panelArea\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n        \n        # self.materialInfoList.append((self.module_id, \"substructInfill\", substructureLength))\n        self.materialInfoDict[self.id][self.module_id][\"typeName\"] = \"substructInfill\"\n        self.materialInfoDict[self.id][self.module_id][\"usedLength\"] = substructureLength\n        self.materialInfoDict[self.id][self.module_id][\"usedArea\"] = int(totalArea)\n\n        return (panelOffsetList, beamGeo)\n\n\n    def create_paint(self, surface, base_plane, thickness):\n        area_properties = rg.AreaMassProperties.Compute(surface)\n        if area_properties is not None:\n            panelArea = area_properties.Area\n\n        self.materialInfoDict[self.id][self.module_id][\"typeName\"] = \"paint\"\n        self.materialInfoDict[self.id][self.module_id][\"usedArea\"] = None\n        self.materialInfoDict[self.id][self.module_id][\"usedArea\"] = int(panelArea)\n\n\n        return Extrude(surface, base_plane.ZAxis*thickness)\n\n\n    def create_substruct(self, surface, base_plane, width, thickness, distance, direction):\n        if direction:\n            workPlane = copy(base_plane)\n\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            workPlane = copy(base_plane)\n        \n        substructCrv, substructureLength = self.create_contours(surface, workPlane, distance)\n\n        # create beam\n        beamGeo = []\n        for crv in substructCrv:\n            beamGeo.append(self.create_beam(crv, base_plane, width, thickness))\n        \n        # self.materialInfoList.append((self.module_id, \"substruct\", substructureLength))\n        self.materialInfoDict[self.id][self.module_id][\"typeName\"] = \"substruct\"\n        self.materialInfoDict[self.id][self.module_id][\"usedLength\"] = substructureLength\n\n        return beamGeo\n\n\n    def create_cladding(self, surface, base_plane, length, width, thickness, direction):\n        if direction:\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        else:\n            base_plane = copy(base_plane)\n            base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n            firDirPlane = copy(base_plane)\n            secDirPlane = copy(base_plane)\n            secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n        crvLength = self.create_contours(surface, firDirPlane, length)\n        crvWidth = self.create_contours(surface, secDirPlane, width)\n\n        crvCombine = []\n        crvCombine.extend(crvLength)\n        crvCombine.extend(crvWidth)\n\n        panelGeoList = SurfaceSplit(surface, crvCombine)\n\n            # create panel geometry\n        panelOffsetList = []\n        boardSeam = 2\n        for panel in panelGeoList:\n            panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n        \n        return panelOffsetList\n\n\nclass generateCladding:\n    \"\"\"\n    A class to generate cladding layouts based on various parameters such as window and wall geometries,\n    cladding dimensions, and overlap specifications.\n\n    Attributes:\n        windowDB: Database of window.\n        claddingDB: Database of cladding.\n        wallGeo: Geometry of the wall to be clad.\n        windowGeo: Geometry of the windows in the wall.\n        claddingWidth: The width of the cladding material that users input.\n        claddingLength: The length of the cladding material that users input.\n        kindNum: How many cldding type users want.\n        wWeight: Weight parameter for width consideration.\n        lWeight: Weight parameter for length consideration.\n        horizontalOverlap: Overlap between claddings horizontally.\n        verticalOverlap: Overlap between claddings vertically.\n        horizontalAngle: The angle of the cladding orientation horizontally.\n        verticalAngle: The angle of the cladding orientation vertically.\n    \"\"\"\n\n    def __init__(self, windowDB, doorDB, claddingDB, wallGeo, windowGeo, doorGeo, claddingWidth=299, claddingLength=399, kindNum=4, wWeight=5, lWeight=4, claddingDirection=False, horizontalOverlap=0, verticalOverlap=0, horizontalAngle=0, verticalAngle=0, substructWidth=40, substructThickness=20, offsetDist=0,**kwargs):\n        \"\"\"\n        Initializes the GenerateCladding class with all the necessary attributes for cladding generation.\n        \"\"\"\n        global initial_data\n        self.windowDB = windowDB\n        self.doorDB = doorDB\n        self.claddingDB = claddingDB\n        self.wallGeo = wallGeo\n        self.windowGeo = windowGeo\n        self.doorGeo = doorGeo\n        self.claddingWidth = claddingWidth\n        self.claddingLength = claddingLength\n        self.kindNum = kindNum\n        self.wWeight = wWeight\n        self.lWeight = lWeight\n        self.claddingDirection = claddingDirection\n        self.horizontalOverlap = horizontalOverlap\n        self.verticalOverlap = verticalOverlap\n        self.horizontalAngle = horizontalAngle\n        self.verticalAngle = verticalAngle\n        self.substructWidth = substructWidth\n        self.substructThickness = substructThickness\n        self.offsetDist = offsetDist + self.substructThickness\n        self.tileDimension = kwargs.get('tileDimension', None)\n        \n        # Find user's tile based on input criteria\n        if self.tileDimension == None:\n            b1 = self.compare(\"claddingWidth\", self.claddingWidth)\n            b2 = self.compare(\"claddingLength\", self.claddingLength)\n            b3 = self.compare(\"kindNum\", self.kindNum)\n            b4 = self.compare(\"wWeight\", self.wWeight)\n            b5 = self.compare(\"lWeight\", self.lWeight)\n            if  b1 or b2 or b3 or b4 or b5:\n                print(\"find tile!!\")\n                id, width, length, quantity, self.longList = self.findCladding(self.claddingDB, self.claddingWidth, self.claddingLength, self.kindNum, self.wWeight, self.lWeight)\n                initial_data[\"longList\"] = self.longList\n                initial_data[\"width\"] = width\n                initial_data[\"length\"] = length\n            else:\n                print(\"don't find again\")\n                width = initial_data[\"width\"]\n                length = initial_data[\"length\"]\n                self.longList = initial_data[\"longList\"]\n\n        else:\n            print(\"start customize tile process\")\n            width, length, self.longList = self.customizedCladding(self.tileDimension)\n\n\n        # build mapping for width and length\n        self.number_mapping = {}\n        for w, l in zip(width, length):\n            self.number_mapping[l] = w\n\n        # Decide grid distance based on the minimum width of the tile\n        paired_list = zip(length, width)\n        sorted_list = sorted(paired_list, key=lambda x: x[1])\n        self.minTileWidth = sorted_list[0][1]\n        self.minTileLength = sorted_list[0][0]\n        self.gridDist = self.minTileWidth - self.horizontalOverlap\n        #print(self.minTileWidth)\n        #print(self.minTileLength)\n\n        self.claddingGeo = self.offset_brep(self.wallGeo, [self.offsetDist])[0]\n\n        # Generate the column line, wall frame, and cut direction for the cladding\n        self.columnLine, self.wallFrame, self.cutDirect = self.generateTileColumn(self.claddingGeo, self.gridDist)\n\n        # Get window indices and geometries from DB that match users' dimension of geometry for window.\n        chosenWindowId, self.chosenWindowGeo = self.findWindow(self.windowDB, self.windowGeo, self.gridDist, self.horizontalOverlap)\n        chosenDoorId, self.chosenDoorGeo = self.findDoor(self.doorDB, self.doorGeo, self.gridDist, self.horizontalOverlap)\n\n        # Orient window and door onto grid system\n        self.orientedWindowGeoList, self.finalWindowPlaneList, self.windowForFinalList = self.orientWindow(self.columnLine, self.windowGeo, self.chosenWindowGeo, self.claddingGeo)\n        self.orientedDoorGeoList, self.finalDoorPlaneList, self.doorForFinalList = self.orientDoor(self.columnLine, self.doorGeo, self.chosenDoorGeo, self.claddingGeo)\n\n        self.midCurve = self.getMidCurve(self.columnLine)\n\n\n        # Generate basic wall geometry for inner material\n        self.wallForInnerGeo = self.calculateInnerGeo(self.windowForFinalList, self.doorForFinalList)\n\n        # Find the target lines for cladding searching algorithm.\n        self.targetLines, self.targetLinesLength = self.trimWithRegion(self.midCurve, self.orientedWindowGeoList, self.orientedDoorGeoList, self.wallFrame)\n\n        # compare if target lines are changed, if yes, calculate it again.\n        targetsLengthflatten = [int(t) for t in list(chain.from_iterable(self.targetLinesLength))]\n        sourceLength = [int(s) for s in self.longList]\n\n        # Sometimes, when I moved opening, it happens error due to the crack of evaluate length in self.generateCladdingByTarget. Thus, I use \"try\" here to initialize everything again.\n        toler = (self.minTileLength+self.verticalOverlap)*0.4\n        try:\n            if self.compare(\"targetsLengthflatten\", targetsLengthflatten) or self.compare(\"sourceLength\", sourceLength) or \"combinationGraph\" not in initial_data:\n                # Use cladding sarching algorithm.\n                self.combinationGraph = self.calculateTarget(self.longList, self.targetLinesLength, toler)\n                initial_data[\"combinationGraph\"] = self.combinationGraph\n            else:\n                self.combinationGraph = initial_data[\"combinationGraph\"]\n\n            # put tile onto the line according to result of calculation.\n            self.tileLocation = self.generateCladdingByTarget(self.targetLines, self.originalCoGraft, self.combinationGraph)\n\n            self.substructureGeo = self.addSubstructure(self.substructureList, self.substructWidth, self.substructThickness)\n        except:\n            print(\"happpen errrorrrr!!!!\")\n            initial_data = {}\n            if self.compare(\"targetsLengthflatten\", targetsLengthflatten) or self.compare(\"sourceLength\", sourceLength) or \"combinationGraph\" not in initial_data:\n                # Use cladding sarching algorithm.\n                self.combinationGraph = self.calculateTarget(self.longList, self.targetLinesLength, toler)\n                initial_data[\"combinationGraph\"] = self.combinationGraph\n            else:\n                self.combinationGraph = initial_data[\"combinationGraph\"]\n\n            # put tile onto the line according to result of calculation.\n            self.tileLocation = self.generateCladdingByTarget(self.targetLines, self.originalCoGraft, self.combinationGraph)\n\n            self.substructureGeo = self.addSubstructure(self.substructureList, self.substructWidth, self.substructThickness)\n\n        \n    def compare(self, name, data):\n        if not isinstance(data, list):\n            data = [data]\n\n        if name not in initial_data:\n            initial_data[name] = data\n            return True\n        else:\n            if Counter(initial_data[name]) == Counter(data):\n                return False\n            else:\n                initial_data[name] = data\n                return True\n\n\n    def alignToZ(self, targetPlane):\n        finalPlane = copy(targetPlane)\n        finalPlane = AlignPlane(finalPlane, rg.Vector3d.ZAxis)[0]\n        finalPlane.Rotate(-math.pi/2, finalPlane.ZAxis, finalPlane.Origin)\n\n        return finalPlane\n\n\n    def offset_brep(self, brep, distances, tolerance=0.01):\n        if isinstance(brep, list):\n            brep = brep[0]\n        all_offset_breps = []\n        for distance in distances:\n            offset_breps = rg.Brep.CreateOffsetBrep(brep, distance, solid=False, extend=False, tolerance=tolerance)\n            if offset_breps:\n                all_offset_breps.append(offset_breps[0][0])\n            else:\n                print(\"Offset operation failed for distance .\")\n                all_offset_breps.append(None)\n        return all_offset_breps\n\n\n    def replace_with_zeros(self, nested_list):\n        # Check if the current element is a list\n        if isinstance(nested_list, list):\n            # If it is, recursively apply the function to each element of the list\n            return [self.replace_with_zeros(item) for item in nested_list]\n        else:\n            # If the current element is not a list, replace it with zero\n            return []\n\n\n    def customizedCladding(self, tile_list):\n        width = []\n        length = []\n        longList = []\n        for tileClass in tile_list:\n            w, l, q = tileClass.tileData.width, tileClass.tileData.height, int(tileClass.tileData.quantity)\n            width.append(w)\n            length.append(l)\n            longList.extend([l]*q)\n        \n        return (width, length, longList)\n\n\n    def findWindow(self, windowDB, userWindowGeoList, gridWidth, tolerance):\n        \"\"\"\n        Identifies the best matching window dimensions from a database based on user-specified geometries,\n        considering a given tolerance and grid width.\n\n        Parameters:\n            windowDB: A database or list of window objects with width and height attributes.\n            userWindowGeoList: A list of user-specified window geometries to match against the database.\n            gridWidth: The width of the grid to consider for matching.\n            tolerance: The tolerance within which a match is considered acceptable.\n\n        Returns:\n            A list of indices corresponding to the chosen windows from the database.\n            A list of geometries of window.\n        \"\"\"\n\n        def _sortPoints(points, surf):\n            \"\"\"\n            Sorts points based on their spatial relation to a reference surface, categorizing them into quadrants\n            relative to the surface's frame and returning them in a specific order along with the surface frame.\n\n            Parameters:\n                points: A list of points to sort.\n                surf: The reference surface or brep for sorting points.\n\n            Returns:\n                A tuple containing the sorted points in specific quadrants and the updated surface frame.\n            \"\"\"\n\n            if isinstance(surf, rg.Surface) or isinstance(surf, rg.Brep):\n                # Ensure surf is a Surface for the operations (if Brep, use its faces)\n                if isinstance(surf, rg.Brep):\n                    surf = surf.Faces[0]\n\n                # 1. Calculate the Area Centroid of the Surface\n                area_properties = rg.AreaMassProperties.Compute(surf)\n                if area_properties is not None:\n                    centroid = area_properties.Centroid\n\n                    # 2. Find the Closest Point on the Surface to the Centroid\n                    success, uvPU, uvPV = surf.ClosestPoint(centroid)\n                    if success:\n                        # 3. Evaluate the Surface at the UV Parameters\n                        success, surf_Frame = surf.FrameAt(uvPU, uvPV)\n                        # if success:\n                            # surf_Frame now contains the frame (plane) at the closest point\n                            # Do something with surf_Frame, e.g., access its origin or its normal\n                            # frame_origin = surf_Frame.Origin\n                            # frame_normal = surf_Frame.Normal\n                            # You can now use frame_origin and frame_normal as needed\n                        # else:\n                        #     print(\"Failed to evaluate the surface frame.\")\n                    else:\n                        print(\"Failed to find the closest point on the surface.\")\n                else:\n                    print(\"Failed to compute area properties.\")\n            else:\n                print(\"The input 'surf' is not a valid surface or brep.\")\n\n\n            rTo = rg.Transform.ChangeBasis(rg.Plane.WorldXY, surf_Frame)\n            rFro = rg.Transform.ChangeBasis(surf_Frame, rg.Plane.WorldXY)\n            \n            for pt in points:\n                pt.Transform(rTo)\n                if pt.X>0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighFirst = pt\n                elif pt.X<0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighSecond = pt\n                elif pt.X>0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowFirst = pt\n                elif pt.X<0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowSecond = pt\n            surf_Frame.Rotate(math.pi/2, surf_Frame.ZAxis)\n            return (pointLowSecond, pointHighSecond, pointLowFirst, pointHighFirst, surf_Frame)\n        \n        DBwidthList = [win.Width for win in windowDB]\n        DBheightList = [win.Height for win in windowDB]\n        uList = []\n        vList = []\n        for windowGeo in userWindowGeoList:\n            ptList = [vertex.Location for vertex in windowGeo.Vertices]\n            ptList = _sortPoints(ptList, windowGeo)\n            width = ptList[0].DistanceTo(ptList[1])\n            height = ptList[0].DistanceTo(ptList[2])\n            u, v = height, width\n            uList.append(u)\n            vList.append(v)\n\n        chosenId = []\n        chosenWindowGeo = []\n        for u,v in zip(uList, vList):\n            minId = None\n            minDist = float('inf')\n            for id, (width, height) in enumerate(zip(DBwidthList, DBheightList)):\n                euclideanDist = (width-u)**2 + (height-v)**2 + ((width+tolerance)%gridWidth)**3\n                if euclideanDist < minDist:\n                    minId = id\n                    minDist = euclideanDist\n            chosenId.append(minId)\n            chosenWindowGeo.append(windowDB[minId])\n        \n        return (chosenId, chosenWindowGeo)\n\n\n    def findDoor(self, doorDB, userDoorGeoList, gridWidth, tolerance):\n        \"\"\"\n        Identifies the best matching window dimensions from a database based on user-specified geometries,\n        considering a given tolerance and grid width.\n\n        Parameters:\n            windowDB: A database or list of window objects with width and height attributes.\n            userWindowGeoList: A list of user-specified window geometries to match against the database.\n            gridWidth: The width of the grid to consider for matching.\n            tolerance: The tolerance within which a match is considered acceptable.\n\n        Returns:\n            A list of indices corresponding to the chosen windows from the database.\n            A list of geometries of window.\n        \"\"\"\n\n        def _sortPoints(points, surf):\n            \"\"\"\n            Sorts points based on their spatial relation to a reference surface, categorizing them into quadrants\n            relative to the surface's frame and returning them in a specific order along with the surface frame.\n\n            Parameters:\n                points: A list of points to sort.\n                surf: The reference surface or brep for sorting points.\n\n            Returns:\n                A tuple containing the sorted points in specific quadrants and the updated surface frame.\n            \"\"\"\n\n            if isinstance(surf, rg.Surface) or isinstance(surf, rg.Brep):\n                # Ensure surf is a Surface for the operations (if Brep, use its faces)\n                if isinstance(surf, rg.Brep):\n                    surf = surf.Faces[0]\n\n                # 1. Calculate the Area Centroid of the Surface\n                area_properties = rg.AreaMassProperties.Compute(surf)\n                if area_properties is not None:\n                    centroid = area_properties.Centroid\n\n                    # 2. Find the Closest Point on the Surface to the Centroid\n                    success, uvPU, uvPV = surf.ClosestPoint(centroid)\n                    if success:\n                        # 3. Evaluate the Surface at the UV Parameters\n                        success, surf_Frame = surf.FrameAt(uvPU, uvPV)\n                        # if success:\n                            # surf_Frame now contains the frame (plane) at the closest point\n                            # Do something with surf_Frame, e.g., access its origin or its normal\n                            # frame_origin = surf_Frame.Origin\n                            # frame_normal = surf_Frame.Normal\n                            # You can now use frame_origin and frame_normal as needed\n                        # else:\n                        #     print(\"Failed to evaluate the surface frame.\")\n                    else:\n                        print(\"Failed to find the closest point on the surface.\")\n                else:\n                    print(\"Failed to compute area properties.\")\n            else:\n                print(\"The input 'surf' is not a valid surface or brep.\")\n\n\n            rTo = rg.Transform.ChangeBasis(rg.Plane.WorldXY, surf_Frame)\n            rFro = rg.Transform.ChangeBasis(surf_Frame, rg.Plane.WorldXY)\n            \n            for pt in points:\n                pt.Transform(rTo)\n                if pt.X>0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighFirst = pt\n                elif pt.X<0 and pt.Y>0:\n                    pt.Transform(rFro)\n                    pointHighSecond = pt\n                elif pt.X>0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowFirst = pt\n                elif pt.X<0 and pt.Y<0:\n                    pt.Transform(rFro)\n                    pointLowSecond = pt\n            surf_Frame.Rotate(math.pi/2, surf_Frame.ZAxis)\n            return (pointLowSecond, pointHighSecond, pointLowFirst, pointHighFirst, surf_Frame)\n        \n        DBwidthList = [door.Width for door in doorDB]\n        DBheightList = [door.Height for door in doorDB]\n        uList = []\n        vList = []\n        for doorGeo in userDoorGeoList:\n            ptList = [vertex.Location for vertex in doorGeo.Vertices]\n            ptList = _sortPoints(ptList, doorGeo)\n            width = ptList[0].DistanceTo(ptList[1])\n            height = ptList[0].DistanceTo(ptList[2])\n            u, v = height, width\n            uList.append(u)\n            vList.append(v)\n\n        chosenId = []\n        chosenDoorGeo = []\n        for u,v in zip(uList, vList):\n            minId = None\n            minDist = float('inf')\n            for id, (width, height) in enumerate(zip(DBwidthList, DBheightList)):\n                euclideanDist = (width-u)**2 + (height-v)**2 + ((width+tolerance)%gridWidth)**3\n                if euclideanDist < minDist:\n                    minId = id\n                    minDist = euclideanDist\n            chosenId.append(minId)\n            chosenDoorGeo.append(doorDB[minId])\n        \n        return (chosenId, chosenDoorGeo)\n\n\n    def findCladding(self, claddingDB, searchWidth, searchLength, kindNum, wWeight, lWeight):\n        print(\"searching cladding now...\")\n        widthDB = []\n        lengthDB = []\n        quantityDB = []\n        for cladding in claddingDB.Branches:\n            w, l = cladding[0].Width, cladding[0].Height\n            widthDB.append(w)\n            lengthDB.append(l)\n            quantityDB.append(cladding[1])\n\n        tileList = []\n        for id, (w, l, q) in enumerate(zip(widthDB, lengthDB, quantityDB)):\n            idName = \"tile_\" + str(id)\n            tileList.append((w,l,q,idName))\n\n        euclideanDistList = []\n        for w, l, q, id in tileList:\n            euclideanDist = abs((searchWidth-w)**wWeight) + abs((searchLength-l)**lWeight)\n            euclideanDistList.append(euclideanDist)\n\n        # Pair each element of first_list with the corresponding element in second_list\n        paired_list = zip(tileList, euclideanDistList)\n\n        # Sort the pairs based on the elements of second_list\n        sorted_pairs = sorted(paired_list, key=lambda x: x[1])\n\n        # Extract the sorted elements of first_list\n        sorted_list = [element for element, _ in sorted_pairs]\n\n        tileData = sorted_list[:kindNum]\n\n        id = []\n        width = []\n        length = []\n        quantity = []\n        longList = [] # This one will be input to algorithm ============================\n\n        for w, l, q, i in tileData:\n            width.append(w)\n            length.append(l)\n            quantity.append(q)\n            id.append(i)\n            longList.extend([l]*q)\n\n        return (id, width, length, quantity, longList)\n\n\n    def _create_contours(self, surface, base_point, direct, interval):\n        if isinstance(surface, rg.BrepFace):\n            surface = surface.ToBrep()\n\n        base_plane = rg.Plane(base_point, direct)\n        \n        contours = []\n\n        # Get the bounding box of the surface in the plane's coordinate system\n        bbox = surface.GetBoundingBox(base_plane)\n\n        # Start and end values for contouring in the direction of the plane's normal\n        start = bbox.Min.Z\n        end = bbox.Max.Z\n\n        # Generate contours\n        z = start\n        while z <= end:\n            # Create a plane parallel to the base plane at height z\n            contour_plane = rg.Plane(base_plane)\n            contour_plane.Translate(base_plane.Normal * z)\n\n            # Generate the contour\n            contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n            contours.extend(contour_curves)\n\n            z += interval\n\n\n        return contours\n\n\n    def generateTileColumn(self, wallGeo, gridDist):\n        colBasePt = wallGeo.Vertices[0].Location\n        if isinstance(wallGeo, rg.Brep):\n            wallGeo = wallGeo.Faces[0]\n        area_properties = rg.AreaMassProperties.Compute(wallGeo)\n        if area_properties is not None:\n            centroid = area_properties.Centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(centroid)\n            if success:\n                # 3. Evaluate the Surface at the UV Parameters\n                success, wallGeo_Frame = wallGeo.FrameAt(uvPU, uvPV)\n                if success:\n                    frame_origin = wallGeo_Frame.Origin\n                    frame_normal = wallGeo_Frame.Normal\n                else:\n                    print(\"Failed to evaluate the surface frame.\")\n            else:\n                print(\"Failed to find the closest point on the surface.\")\n        else:\n            print(\"Failed to compute area properties.\")\n        \n        # # Align wallFrame's YAxis to global ZAxis\n        # global_z_axis = rg.Vector3d.ZAxis\n        # angle = rg.Vector3d.VectorAngle(wallGeo_Frame.YAxis, global_z_axis)\n        \n        # # Determine the direction of rotation (clockwise or counter-clockwise)\n        # cross_product = rg.Vector3d.CrossProduct(wallGeo_Frame.YAxis, global_z_axis)\n        # if cross_product * wallGeo_Frame.ZAxis < 0:  # If cross product is in opposite direction to frame's Z-axis\n        #     angle = -angle\n        \n        # # Rotate the frame around its Z-axis\n        # wallGeo_Frame.Rotate(angle, wallGeo_Frame.ZAxis, wallGeo_Frame.Origin)\n        \n        wallGeo_Frame = self.alignToZ(wallGeo_Frame)\n        \n        \n        if wallGeo_Frame is not None:\n            cutDirect = -AlignPlane(wallGeo_Frame, rg.Vector3d.ZAxis)[0].YAxis\n\n            columnLine = self._create_contours(wallGeo, colBasePt, cutDirect, gridDist)\n            return (columnLine, wallGeo_Frame, cutDirect)\n        else:\n            print(\"Failed to contour.\")\n\n\n    def orientWindow(self, claddingLine, userWindowGeo, chosenWindowGeo, wallGeo):\n        def find_closest_point_on_lines(point, lines):\n            closest_point = None\n            min_distance = float('inf')  # Initialize with a very large number\n\n            for curve in lines:\n                success, t = curve.ClosestPoint(point)\n                if success:\n                    # Use the parameter 't' to get the actual closest point on the curve\n                    temp_closest_point = curve.PointAt(t)\n                    \n                    # Now calculate the distance from 'point' to 'temp_closest_point'\n                    distance = point.DistanceTo(temp_closest_point)\n\n                    # Update the closest point if this curve is closer than previous ones\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_point = temp_closest_point\n\n            return closest_point\n\n\n        orientedWindowGeoList = []\n        finalWindowPlaneList = []\n        windowForFinalList = []\n        for windowGeo, chosenGeo in zip(userWindowGeo, chosenWindowGeo):\n            if isinstance(windowGeo, rg.Brep):\n                windowGeo = windowGeo.Faces[0]\n            \n            if isinstance(wallGeo, rg.Brep):\n                wallGeo = wallGeo.Faces[0]\n            \n            if isinstance(chosenGeo, rg.Rectangle3d):\n                geo_curve = chosenGeo.ToNurbsCurve()\n                planar_surf = rg.Brep.CreatePlanarBreps(geo_curve)\n                chosenGeo = planar_surf[0]\n\n            # Get user's geometry's centroid and frame\n            area_properties = rg.AreaMassProperties.Compute(windowGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n            success, uvPU, uvPV = windowGeo.ClosestPoint(centroid)\n            if success:\n                success, windowFrame = windowGeo.FrameAt(uvPU, uvPV)\n                windowFrame = self.alignToZ(windowFrame)\n                windowFrameOrigin = windowFrame.Origin\n            \n            # Get frame that closest to user's geometry's centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(windowFrameOrigin)\n            if success:\n                success, windowFrameOnWall = wallGeo.FrameAt(uvPU, uvPV)\n                windowFrameOnWall = self.alignToZ(windowFrameOnWall)\n            \n            area_properties = rg.AreaMassProperties.Compute(chosenGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n                orientPlane = rg.Plane(centroid, rg.Vector3d.ZAxis)\n\n\n            # Orient chosenWindow from DB default plane to user's geometry central plane\n            trans1 = rg.Transform.PlaneToPlane(orientPlane, windowFrame)\n            chosenGeoOnUserGeo = copy(chosenGeo)\n            chosenGeoOnUserGeo.Transform(trans1)\n\n            # Orient chosenGeoOnUserGeo from user's geometry central plane to wall\n            trans2 = rg.Transform.PlaneToPlane(windowFrame, windowFrameOnWall)\n            chosenGeoOnWallGeo = copy(chosenGeoOnUserGeo)\n            chosenGeoOnWallGeo.Transform(trans2)\n\n            # Orient XYPlane, which is DB default plane, onto the wall and align to grid\n            XYPlaneOnUserGeo = copy(rg.Plane.WorldXY)\n            XYPlaneOnUserGeo.Transform(trans1)\n            XYPlaneOnWallGeo = copy(XYPlaneOnUserGeo)\n            XYPlaneOnWallGeo.Transform(trans2)\n            closestPoint = find_closest_point_on_lines(XYPlaneOnWallGeo.Origin, claddingLine)\n            finalWindowPlane = rg.Plane(closestPoint, XYPlaneOnWallGeo.XAxis, XYPlaneOnWallGeo.YAxis)\n\n            # Orient chosenWindowGeo to final position\n            finalWindowGeo = copy(chosenGeoOnWallGeo)\n            trans3 = rg.Transform.PlaneToPlane(XYPlaneOnWallGeo, finalWindowPlane)\n            finalWindowGeo.Transform(trans3)\n\n            trans4 = rg.Transform.Translation(self.wallFrame.XAxis*self.horizontalOverlap)\n            windowForFinal = copy(finalWindowGeo)\n            windowForFinal.Transform(trans4)\n\n\n            orientedWindowGeoList.append(finalWindowGeo)\n            finalWindowPlaneList.append(finalWindowPlane)\n            windowForFinalList.append(windowForFinal)\n\n        return (orientedWindowGeoList, finalWindowPlaneList, windowForFinalList)\n\n\n    def orientDoor(self, claddingLine, userDoorGeo, chosenDoorGeo, wallGeo):\n        def find_closest_point_on_lines(point, lines):\n            closest_point = None\n            closest_st_point = None\n            closest_end_point = None\n            min_distance = float('inf')  # Initialize with a very large number\n\n            for curve in lines:\n                success, t = curve.ClosestPoint(point)\n                if success:\n                    # Use the parameter 't' to get the actual closest point on the curve\n                    temp_closest_point = curve.PointAt(t)\n                    temp_closest_st_point, temp_closest_end_point = curve.PointAtStart, curve.PointAtEnd\n                    \n                    # Now calculate the distance from 'point' to 'temp_closest_point'\n                    distance = point.DistanceTo(temp_closest_point)\n\n                    # Update the closest point if this curve is closer than previous ones\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_point = temp_closest_point\n                        closest_st_point = temp_closest_st_point\n                        closest_end_point = temp_closest_end_point\n            \n            if closest_st_point.Z < closest_end_point:\n                closest_point = closest_st_point\n            else:\n                closest_point = closest_end_point\n            \n            # Make door position slightly lower\n            trans = rg.Transform.Translation(-self.wallFrame.YAxis)\n            closest_point.Transform(trans)\n\n            return closest_point\n\n\n        orientedDoorGeoList = []\n        finalDoorPlaneList = []\n        doorForFinalList = []\n        for doorGeo, chosenGeo in zip(userDoorGeo, chosenDoorGeo):\n            if isinstance(doorGeo, rg.Brep):\n                doorGeo = doorGeo.Faces[0]\n            \n            if isinstance(wallGeo, rg.Brep):\n                wallGeo = wallGeo.Faces[0]\n            \n            if isinstance(chosenGeo, rg.Rectangle3d):\n                geo_curve = chosenGeo.ToNurbsCurve()\n                planar_surf = rg.Brep.CreatePlanarBreps(geo_curve)\n                chosenGeo = planar_surf[0]\n\n            # Get user's geometry's centroid and frame\n            area_properties = rg.AreaMassProperties.Compute(doorGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n            success, uvPU, uvPV = doorGeo.ClosestPoint(centroid)\n            if success:\n                success, doorFrame = doorGeo.FrameAt(uvPU, uvPV)\n                doorFrame = self.alignToZ(doorFrame)\n                doorFrameOrigin = doorFrame.Origin\n            \n            # Get frame that closest to user's geometry's centroid\n            success, uvPU, uvPV = wallGeo.ClosestPoint(doorFrameOrigin)\n            if success:\n                success, doorFrameOnWall = wallGeo.FrameAt(uvPU, uvPV)\n                doorFrameOnWall = self.alignToZ(doorFrameOnWall)\n            \n            area_properties = rg.AreaMassProperties.Compute(chosenGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n                orientPlane = rg.Plane(centroid, rg.Vector3d.ZAxis)\n\n\n            # Orient chosenWindow from DB default plane to user's geometry central plane\n            trans1 = rg.Transform.PlaneToPlane(orientPlane, doorFrame)\n            chosenGeoOnUserGeo = copy(chosenGeo)\n            chosenGeoOnUserGeo.Transform(trans1)\n\n            # Orient chosenGeoOnUserGeo from user's geometry central plane to wall\n            trans2 = rg.Transform.PlaneToPlane(doorFrame, doorFrameOnWall)\n            chosenGeoOnWallGeo = copy(chosenGeoOnUserGeo)\n            chosenGeoOnWallGeo.Transform(trans2)\n\n            # Orient XYPlane, which is DB default plane, onto the wall and align to grid\n            XYPlaneOnUserGeo = copy(rg.Plane.WorldXY)\n            XYPlaneOnUserGeo.Transform(trans1)\n            XYPlaneOnWallGeo = copy(XYPlaneOnUserGeo)\n            XYPlaneOnWallGeo.Transform(trans2)\n            closestPoint = find_closest_point_on_lines(XYPlaneOnWallGeo.Origin, claddingLine)\n            finalDoorPlane = rg.Plane(closestPoint, XYPlaneOnWallGeo.XAxis, XYPlaneOnWallGeo.YAxis)\n\n            # Orient chosenWindowGeo to final position\n            finalDoorGeo = copy(chosenGeoOnWallGeo)\n            trans3 = rg.Transform.PlaneToPlane(XYPlaneOnWallGeo, finalDoorPlane)\n            finalDoorGeo.Transform(trans3)\n\n            trans4 = rg.Transform.Translation(self.wallFrame.XAxis*self.horizontalOverlap)\n            doorForFinal = copy(finalDoorGeo)\n            doorForFinal.Transform(trans4)\n\n\n            orientedDoorGeoList.append(finalDoorGeo)\n            finalDoorPlaneList.append(finalDoorPlane)\n            doorForFinalList.append(doorForFinal)\n\n        return (orientedDoorGeoList, finalDoorPlaneList, doorForFinalList)\n     \n\n    def getMidCurve(self, claddingLine):\n        firstCurves = claddingLine[:-1]\n        secondCurves = claddingLine[1:]\n        pairedCurves = zip(firstCurves, secondCurves)\n\n        midLine = []\n        for pair in pairedCurves:\n            fir, sec = pair\n            firStartPt = fir.PointAtStart\n            firEndPt = fir.PointAtEnd\n            secStartPt = sec.PointAtStart\n            secEndPt = sec.PointAtEnd\n            midStartPt = (firStartPt + secStartPt)/2\n            midEndPt = (firEndPt + secEndPt)/2\n            midLine.append(rg.Line(midStartPt, midEndPt))\n\n        return midLine\n\n\n    def calculateInnerGeo(self, windowList, doorList):\n        # Generate basic wall geometry for inner material\n        allGeo = []\n        allGeo.extend(windowList)\n        allGeo.extend(doorList)\n        reAllGeo = RegionUnion(allGeo, self.wallFrame)\n        innerGeo = RegionDifference(self.claddingGeo, reAllGeo, self.wallFrame)\n        wallForInnerGeo = self.offset_brep(BoundarySurfaces(innerGeo), [-self.offsetDist])[0]\n\n        return wallForInnerGeo\n\n\n    def trimWithRegion(self, midCurves, windowGeo, doorGeo, basePlane):\n        def move_largest_x_points(points, plane, distance):\n            # Transform points to the plane's coordinate system\n            transformed_points = [plane.RemapToPlaneSpace(point)[1] for point in points]\n            \n            # Find indices of the two points with the largest x-coordinates\n            largest_x_indices = sorted(range(len(transformed_points)), key=lambda i: transformed_points[i].X)[-2:]\n            \n            # Initialize a list to hold the final positions of all points\n            final_points = points[:]\n            \n            # Move the identified points along the plane's x-axis\n            for index in largest_x_indices:\n                # Calculate the new position in the plane's coordinate system\n                moved_point_plane_space = rg.Point3d(transformed_points[index].X + distance, transformed_points[index].Y, transformed_points[index].Z)\n                \n                # Transform the moved point back to the world coordinate system\n                moved_point_world_space = plane.PointAt(moved_point_plane_space.X, moved_point_plane_space.Y, moved_point_plane_space.Z)\n                \n                # Update the point in the final list\n                final_points[index] = moved_point_world_space\n            \n            return final_points\n        \n        # def split_curve_by_points(curve, points):\n        #     print(type(curve))\n        #     curve = curve.ToNurbsCurve()\n        #     # List to store parameters on the curve corresponding to the points\n        #     parameters = []\n\n        #     # Convert each point to a parameter on the curve\n        #     for point in points:\n        #         rc, t = curve.ClosestPoint(point, 20)\n        #         if rc:  # If the closest point was successfully found\n        #             parameters.append(t)\n\n        #     # Split the curve at the collected parameters\n        #     split_curves = curve.Split(parameters)\n\n        #     return split_curves\n\n        def split_curve_by_points(curves, points, height):\n            ptNum = len(points)\n            tileTotalHeigth = self.minTileLength * (ptNum-1)\n\n            # check if cutting point overlap with the below window\n            changeBool = False\n            for curve in curves:\n                firPt = points[0]\n                rc, t = curve.ClosestPoint(firPt, 1)\n                if abs(curve.GetLength()-self.minTileLength)<10 and rc:\n                    changeBool = True\n                    print(\"overlap, ver 1\")\n                    temp_pt = curve.PointAt(t)\n                    ptAtStart = curve.PointAtStart\n                    dist = temp_pt.DistanceTo(ptAtStart)\n                    trans = rg.Transform.Translation(self.wallFrame.YAxis*dist)\n            if changeBool:\n                newPoints = []\n                for pt in points:\n                    n_pt = deepcopy(pt)\n                    n_pt.Transform(trans)\n                    newPoints.append(n_pt)\n                if tileTotalHeigth + dist - height > self.minTileLength:\n                    newPoints = newPoints[:-1]\n            else:\n                newPoints = deepcopy(points)\n            \n\n            # check if cutting point too approach to the bottom tile position\n            changeBool2 = False\n            for curve in curves:\n                firPt = newPoints[0]\n                rc, t = curve.ClosestPoint(firPt, 1)\n                ptAtEnd = curve.PointAtEnd\n                if rc:\n                    temp_pt = curve.PointAt(t)\n                    dist2 = temp_pt.DistanceTo(ptAtEnd)\n                    if dist2 < self.minTileLength and dist2>0.1:\n                        print(\"too closed, ver2\")\n                        changeBool2 = True\n                        trans2 = rg.Transform.Translation(-self.wallFrame.YAxis*dist2)\n            \n            if changeBool2:\n                newPoints2 = []\n                for pt in newPoints:\n                    n_pt = deepcopy(pt)\n                    n_pt.Transform(trans2)\n                    newPoints2.append(n_pt)\n                n_pt = deepcopy(newPoints2[-1])\n                trans3 = rg.Transform.Translation(self.wallFrame.YAxis*self.minTileLength)\n                dist3 = self.minTileLength\n                \n                if tileTotalHeigth - dist2 + dist3 - height  < self.minTileLength + self.verticalOverlap:\n                    print(\"too closed, and delete the last\")\n                    n_pt.Transform(trans3)\n                    newPoints2.append(n_pt)\n            else:\n                newPoints2 = deepcopy(newPoints)\n\n\n            all_split_curves = []  # List to store lists of split curves for each input curve\n            for curve in curves:\n                curve = curve.ToNurbsCurve()\n                parameters = []  # List to store parameters on the curve corresponding to the points\n                # Convert each point to a parameter on the curve\n                for point in newPoints2:\n                    rc, t = curve.ClosestPoint(point, 10)\n                    if rc:  # If the closest point was successfully found\n                        parameters.append(t)\n\n                # Split the curve at the collected parameters\n                split_curves = curve.Split(parameters)\n                if split_curves:  # Check if any curves were actually split\n                    all_split_curves.extend(list(split_curves))\n                else:\n                    all_split_curves.extend([curve])  # Append an empty list if no splits were made\n\n            return all_split_curves\n\n\n        def sort_geometry(polylines, plane):\n            def to_plane_coordinates(point, plane):\n                # Create a transformation from World XY to the target plane\n                xform = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, plane)\n                \n                # Create a copy of the point to avoid modifying the original\n                transformed_point = rg.Point3d(point)\n                \n                # Apply the transformation\n                transformed_point.Transform(xform)\n                \n                return transformed_point\n\n            # Function to get the minimum Z value of a polyline's control points in the plane's coordinates\n            def min_Y_in_plane(polyline, plane):\n                transformed_points = [to_plane_coordinates(pt, plane) for pt in polyline]\n                min_Y = max(pt.Y for pt in transformed_points)\n                return min_Y\n            \n            def polyline_height(polyline, plane):\n                transformed_points = [to_plane_coordinates(pt, plane) for pt in polyline]\n                min_Y = min(pt.Y for pt in transformed_points)\n                max_Y = max(pt.Y for pt in transformed_points)\n                # Calculate height as the difference between max and min Y values\n                height = max_Y - min_Y\n                return height\n\n            # Sort the polylines by the minimum Z value of their control points in the plane's coordinates\n            sorted_polylines = sorted(polylines, key=lambda pl: min_Y_in_plane(pl, plane), reverse=True)\n            # Calculate height for each polyline and pair it with the polyline\n            polylines_with_height = [polyline_height(pl, plane) for pl in sorted_polylines]\n\n            return (sorted_polylines, polylines_with_height)\n\n\n        # In condition that wall doesn't have opening.\n        if len(windowGeo) == 0 and len(doorGeo) == 0:\n            self.Co = [crv.ToNurbsCurve() for crv in midCurves]\n\n            \n            self.originalCo = deepcopy(self.Co)\n            self.CoGraft = [[c] for c in self.originalCo]\n            self.originalCoGraft = [[c] for c in self.originalCo]\n\n            extendCo = deepcopy(self.Co)\n            for index, crv in enumerate(self.Co):\n                extendCo[index] = extendCo[index].Extend(rg.CurveEnd.Start, self.verticalOverlap, 0)\n                extendCo[index] = [extendCo[index].Extend(rg.CurveEnd.End, self.verticalOverlap, 0)]\n                # Here self.Co format is changed into nest structure.\n    \n            extendCoLength = deepcopy(extendCo)\n            for gId, group in enumerate(extendCo):\n                for cId, crv in enumerate(group):\n                    extendCoLength[gId][cId] = crv.GetLength()\n\n            return (extendCo, extendCoLength)\n        \n        else:\n            # Search the tile column adjoin the right side of window.\n            # Calculate the compenstion for openings\n            self.compensatedWindowGeo = []\n            self.compensatedWindowGeoNext = []\n            self.compensatedDoorGeo = []\n            self.compensatedDoorGeoNext = []\n            for winb in windowGeo:\n                winVerticesPt = [vertex.Location for vertex in winb.Vertices]\n                winVerticesPt = move_largest_x_points(winVerticesPt, basePlane, self.horizontalOverlap/2)\n                winVerticesPtforNext = move_largest_x_points(winVerticesPt, basePlane, self.gridDist)\n                winVerticesPt.append(winVerticesPt[0])\n                winVerticesPtforNext.append(winVerticesPtforNext[0])\n                \n                self.compensatedWindowGeo.append(rg.Polyline(winVerticesPt))\n                self.compensatedWindowGeoNext.append(rg.Polyline(winVerticesPtforNext))\n\n            for doorb in doorGeo:\n                doorVerticesPt = [vertex.Location for vertex in doorb.Vertices]\n                doorVerticesPt = move_largest_x_points(doorVerticesPt, basePlane, self.horizontalOverlap/2)\n                doorVerticesPtforNext = move_largest_x_points(doorVerticesPt, basePlane, self.gridDist)\n                doorVerticesPt.append(doorVerticesPt[0])\n                doorVerticesPtforNext.append(doorVerticesPtforNext[0])\n                \n                self.compensatedDoorGeo.append(rg.Polyline(doorVerticesPt))\n                self.compensatedDoorGeoNext.append(rg.Polyline(doorVerticesPtforNext))\n                \n            self.compensatedCombineGeo = self.compensatedWindowGeo\n            self.compensatedCombineGeo.extend(self.compensatedDoorGeo)\n\n\n            self.Co = []\n            for midCrv in midCurves:\n                oneCrvCi, oneCrvCo = TrimwithRegions(midCrv, self.compensatedCombineGeo, basePlane)\n                # when trimming with opening\n                if oneCrvCi != None:\n                    # when trimming with window, it will output list\n                    if isinstance(oneCrvCo, list):\n                        self.Co.extend(oneCrvCo)\n                    # when triming with door, it will output one obj\n                    else:\n                        self.Co.append(oneCrvCo)\n                # when trimming with nothing, add original curve\n                else:\n                    self.Co.extend([oneCrvCo])\n            \n            self.originalCo = deepcopy(self.Co)\n            self.CoGraft = [[c] for c in self.originalCo]\n            self.originalCoGraft = [[c] for c in self.originalCo]\n\n            trimedCo = [] # Store shorten Crv\n            # print(self.Co)\n            for crv in self.Co:\n                tForTouch = 10\n                crv = crv.Trim(rg.CurveEnd.Start, tForTouch)\n                crv = crv.Trim(rg.CurveEnd.End, tForTouch)\n                trimedCo.append(crv)\n\n\n            # Manage window side curve\n            self.compensatedOpeningGeoNext = []\n            self.compensatedOpeningGeoNext.extend(self.compensatedWindowGeoNext)\n            self.compensatedOpeningGeoNext.extend(self.compensatedDoorGeoNext)\n\n            self.compensatedOpeningGeoNext, heightList = sort_geometry(self.compensatedOpeningGeoNext, self.wallFrame)\n\n            self.checkCutting = []\n            sideId = []\n\n            for i, (trim_crv, crv) in enumerate(zip(trimedCo, self.Co)):\n                for openCrv_next, height in zip(self.compensatedOpeningGeoNext, heightList):\n                    openCrv_next_Geo = BoundarySurfaces(openCrv_next)\n                    crvProject = Project(crv, openCrv_next_Geo, self.wallFrame.ZAxis)\n                    if crvProject != None:\n                        dist = crvProject.GetLength()\n                        sideTileNum = math.ceil((dist + self.verticalOverlap)/self.minTileLength)\n                        stPt = crvProject.PointAtStart\n                        endPt = crvProject.PointAtEnd\n\n                        temp_closest_pt_st = openCrv_next.ClosestPoint(stPt)\n                        dist_st = temp_closest_pt_st.DistanceTo(stPt)\n\n                        temp_closest_pt_end = openCrv_next.ClosestPoint(endPt)\n                        dist_end = temp_closest_pt_end.DistanceTo(endPt)\n\n                        if dist_st < dist_end or abs(dist_st-dist_end)<10:\n                            vec = stPt - endPt\n                            vec.Unitize()\n                            seriesStartPt = endPt\n\n                        else:\n                            vec = endPt - stPt\n                            vec.Unitize()\n                            seriesStartPt = stPt\n\n                        \n                        moveSeries = [rg.Transform.Translation(vec*self.minTileLength*k) for k in range(int(sideTileNum+1))]\n\n                        ptSeries = []\n                        for trans in moveSeries:\n                            pt = copy(seriesStartPt)\n                            pt.Transform(trans)\n                            ptSeries.append(pt)\n                        \n                        \n\n                        print(\"ptSeries\", len(ptSeries))\n                        splittedCrv = split_curve_by_points(self.CoGraft[i], ptSeries, height)\n                        self.checkCutting.append((self.CoGraft[i], ptSeries))\n                        # print(splittedCrv[0])\n                        # splittedCrv[0] = splittedCrv[0].Extend(rg.CurveEnd.Start, self.verticalOverlap*2, 0)\n                        # splittedCrv[-1] = splittedCrv[-1].Extend(rg.CurveEnd.End, self.verticalOverlap*2, 0)\n\n                        sideId.append(i)\n\n                        self.CoGraft[i] = list(splittedCrv)\n\n            \n            sideId = list(set(sideId))\n            print(sideId)\n            extendCo = deepcopy(self.CoGraft)\n            for g_index, crvList in enumerate(self.CoGraft):\n                if g_index in sideId:\n                    temp_list = []\n                    for crvId, crv in enumerate(crvList):\n                        if abs(crv.GetLength() - self.minTileLength) < 1:\n                            pass\n                        elif crvId == 0:\n                            crv = crv.Extend(rg.CurveEnd.Start, self.verticalOverlap, 0)\n                        else:\n                            crv = crv.Extend(rg.CurveEnd.End, self.verticalOverlap, 0)\n                        temp_list.append(crv)\n                else:\n                    temp_list = []\n                    for crv in crvList:\n                        \n                        crv = crv.Extend(rg.CurveEnd.Start, self.verticalOverlap, 0)\n                        crv = crv.Extend(rg.CurveEnd.End, self.verticalOverlap, 0)\n                        temp_list.append(crv)\n                \n                extendCo[g_index] = temp_list\n\n\n            extendCoLength = deepcopy(extendCo)\n            for gId, group in enumerate(extendCo):\n                for cId, crv in enumerate(group):\n                    extendCoLength[gId][cId] = crv.GetLength()\n            \n            self.trimedCo = trimedCo\n            return (extendCo, extendCoLength)\n\n\n    def calculateTarget(self, sourceLength, targetsLength, tolerance):\n        def find_combinations(nums, targets):\n            def knapsack(items, capacity):\n                dp = [0] * (capacity + 1) #[0,0,0,...,0,0,0] it has capacity number of 0\n                item_included = [[] for _ in range(capacity + 1)] #[[],[],[],...,[],[],[]] it has capacity number of []\n                \n                for item in items:\n                    for i in range(capacity, item - 1, -1):\n                        if dp[i - item] + item > dp[i]:\n                            dp[i] = dp[i - item] + item\n                            item_included[i] = item_included[i - item] + [item]\n\n                return item_included[capacity]\n\n            def find_closest_number(remaining_nums, target):\n                # Find the smallest number in remaining_nums that makes the sum >= target\n                for num in sorted(remaining_nums):\n                    if num + sum(remaining_nums) >= target:\n                        return num\n                return None\n\n            all_combinations = []\n            for target in targets:\n                combination = knapsack(nums, target)\n                combination_sum = sum(combination)\n\n                if combination_sum < target and (target-combination_sum)>tolerance:\n                    remaining_nums = Counter(nums) - Counter(combination)\n                    additional_num = find_closest_number(list(remaining_nums.elements()), target - combination_sum)\n                    if additional_num is not None:\n                        combination.append(additional_num)\n\n                remaining_nums = Counter(nums) - Counter(combination)\n                nums = list(remaining_nums.elements())\n                random.shuffle(nums)\n\n                random.shuffle(combination)\n                all_combinations.append(combination)\n\n            return all_combinations\n        \n        targetsLengthflatten = [int(math.ceil(t)) for t in list(chain.from_iterable(targetsLength))]\n        sourceLength = [int(s) for s in sourceLength]\n        random.shuffle(sourceLength)\n\n        pair = [(t_id, t) for t_id, t in enumerate(targetsLengthflatten)]\n        pair.sort(key=lambda pair: pair[1])\n        id_sort = [p[0] for p in pair]\n        targetsLengthflattenSorted = [p[1] for p in pair]\n        combinations = find_combinations(sourceLength, targetsLengthflattenSorted)\n        combinations = [originComb for _, originComb in sorted(zip(id_sort, combinations))]\n\n        for target, combination in zip(targetsLengthflatten, combinations):\n            print(\"Target \"+ str(target) + \" constructed by: \"+ str(combination) + \" ,the sum is: \" + str(sum(combination)))\n\n\n        def fill_structure_from_flat(flat_list, structure_template):\n            flat_iter = iter(flat_list)  # Create an iterator for the flat list\n\n            def fill_structure(structure):\n                for i, item in enumerate(structure):\n                    if isinstance(item, list):  # If the current item is a list, recurse\n                        fill_structure(item)\n                    else:\n                        structure[i] = next(flat_iter)  # Replace the item with the next flat list item\n\n            fill_structure(structure_template)\n            return structure_template\n        \n        combinationsGraft = fill_structure_from_flat(combinations, targetsLength)\n        \n        return combinationsGraft\n\n\n    def generateCladdingByTarget(self, extendCo, originalCo, combinations):\n        def massAddition(inputList):\n            sumUpList = [0]\n            sumNum = 0\n            for num in inputList:\n                sumNum += num\n                sumUpList.append(sumNum)\n            return sumUpList[:-1]\n        \n        def remap_points(original_points, new_points, series_points):\n            pt1, pt2 = original_points\n            pt3, pt4 = new_points\n\n            # Calculate the vector representing the original and new intervals\n            original_vector = pt2 - pt1\n            new_vector = pt4 - pt3\n\n            # Function to remap a single point\n            def remap_point(point):\n                # Calculate the vector from pt1 to the current point\n                point_vector = point - pt1\n\n                # Calculate the ratio of the point_vector's length to the original_vector's length\n                ratio = point_vector.Length / original_vector.Length\n\n                # Scale the new_vector by this ratio and add to pt3\n                return pt3 + new_vector * ratio\n\n            # Remap each point in the series\n            return [remap_point(point) for point in series_points]\n\n        \n        substructureList = self.replace_with_zeros(originalCo)\n        originalCoPtList = self.replace_with_zeros(extendCo)\n        originalCoTileGeo = self.replace_with_zeros(extendCo)\n        for i, (eachColextendCo, eachColOriginalCo, eachColNums) in enumerate(zip(extendCo, originalCo, combinations)):\n            originalCurve = eachColOriginalCo[0]\n            originalPts = [originalCurve.PointAtStart, originalCurve.PointAtEnd]\n            extendCoJoinedCrv = JoinCurves(eachColextendCo, False)\n            extendPts = [extendCoJoinedCrv.PointAtStart, extendCoJoinedCrv.PointAtEnd]\n\n            # transform substructure\n            tt = rg.Transform.Translation(self.wallFrame.XAxis*self.gridDist/2 + self.wallFrame.XAxis*self.horizontalOverlap)\n            substructure = deepcopy(originalCurve)\n            substructure.Transform(tt)\n            substructureList[i] = substructure\n            \n            for j, (oneLineExtendCo, oneLineNums) in enumerate(zip(eachColextendCo, eachColNums)):\n                sumUpResult = massAddition(oneLineNums)\n\n                lengPtList = []\n                for le in sumUpResult:\n                    pt, _, _ = EvaluateLength(oneLineExtendCo, le, False)\n                    lengPtList.append(pt)\n                lengPtList = remap_points(extendPts, originalPts, lengPtList)\n                trans = rg.Transform.Translation(self.wallFrame.XAxis*self.gridDist/2)\n                _ = [pt.Transform(trans) for pt in lengPtList]\n\n                # Generate Tile's base line\n                oneLineTileBase = []\n                for pt, tileDist in zip(lengPtList, oneLineNums):\n                    tileLine = LineSDL(pt, -self.wallFrame.YAxis, tileDist)\n                    oneLineTileBase.append(tileLine)\n                \n                # Switch length to width\n                oneLineWidthList = [self.number_mapping[number] if number in self.number_mapping else number for number in oneLineNums]\n\n                # Generate Tile Geometry\n                oneLineTileGeo = []\n                for baseline, tiledist in zip(oneLineTileBase, oneLineWidthList):\n                    baseline = baseline.ToNurbsCurve()\n                    d = -self.wallFrame.XAxis * tiledist\n                    extrudeGeo = Extrude(baseline, d)\n                    transHorRot = rg.Transform.Rotation(math.radians(self.horizontalAngle), self.wallFrame.YAxis, baseline.PointAtStart)\n                    transVerRot = rg.Transform.Rotation(-math.radians(self.verticalAngle), self.wallFrame.XAxis, baseline.PointAtStart)\n                    transHorOverlap = rg.Transform.Translation(self.wallFrame.XAxis*self.horizontalOverlap)\n                    extrudeGeo.Transform(transHorRot)\n                    extrudeGeo.Transform(transVerRot)\n                    extrudeGeo.Transform(transHorOverlap)\n\n                    oneLineTileGeo.append(extrudeGeo)\n\n\n                originalCoPtList[i][j].extend(lengPtList)\n                originalCoTileGeo[i][j].extend(oneLineTileGeo)\n        \n\n        self.originalCoTileGeo = originalCoTileGeo\n        self.substructureList = substructureList\n\n        return originalCoPtList\n\n\n    def addSubstructure(self, curveForSubstructure, width, length):\n        def create_beam(curve, base_plane, width, height):\n            start_point = curve.PointAtStart\n\n            # Create a plane at the start point with the same orientation as the provided plane\n            section_plane = rg.Plane(start_point, base_plane.XAxis, base_plane.ZAxis)\n            matrix = rg.Transform.Translation(-section_plane.XAxis*width/2 - section_plane.YAxis*height)\n            section_plane.Transform(matrix)\n\n            # Create a rectangle in this plane\n            rectangle = rg.Rectangle3d(section_plane, width, height)\n\n            # Create a sweep\n            sweep = rg.SweepOneRail()\n            sweep.AngleToleranceRadians = 0.01\n            sweep.ClosedSweep = True\n            sweep.SweepTolerance = 0.01\n\n            # Perform the sweep\n            swept_breps = sweep.PerformSweep(curve, rectangle.ToNurbsCurve())\n\n            # Assuming we want the first Brep if there are multiple\n            return swept_breps[0]\n        \n        beamGeoList = []\n        for crv in curveForSubstructure:\n            beamGeoList.append(create_beam(crv, self.wallFrame, width, length))\n        \n        return beamGeoList\n\n\n\n\ndef initialize_globals():\n    global initial_data\n    initial_data = initial_data if 'initial_data' in globals() else {}\n\ndef offset_brep(brep, distances, tolerance=0.01):\n    all_offset_breps = []\n    for distance in distances:\n        offset_breps = rg.Brep.CreateOffsetBrep(brep, distance, solid=False, extend=False, tolerance=tolerance)\n        if offset_breps:\n            all_offset_breps.append(offset_breps[0][0])\n        else:\n            print(\"Offset operation failed for distance .\")\n            all_offset_breps.append(None)\n    return all_offset_breps\n\ndef changePath(dataModified, dataSource):\n    pathList = dataSource.Paths\n\n    layerTree = DataTree[object]()\n    dataList = dataModified.Branches\n\n    for data, path in zip(dataList, pathList):\n        layerTree.AddRange(data, path)\n    return layerTree\n\n\ncompoundMaterialObj = CompoundMaterial(material_collection)\nmaterialList = compoundMaterialObj.new_materialList\nmaterial_thickness = compoundMaterialObj.thicknessList\n\noffsetList = []\ntotal = 0\nfor num in material_thickness:\n    total += num\n    offsetList.append(total)\n\noffsetCladdingDist = sum(material_thickness)\noffsetList = offsetList[:-1]\noffsetList.insert(0,0)\n\n\nif init:\n    initial_data = {}\nelse:\n    initialize_globals()\n\n    db_dict = DB.all_DB\n    windowData = db_dict[\"windowDB\"]\n    doorData = db_dict[\"doorDB\"]\n    claddingData = db_dict[\"tileDB\"]\n\n\n    if customizeTile:\n        test = generateCladding(windowDB=windowData, doorDB=doorData, claddingDB=claddingData, wallGeo=wallGeo, windowGeo=windowGeo, doorGeo=doorGeo, horizontalOverlap=horiOverlap, verticalOverlap=vertiOverlap, horizontalAngle=horiAngle, verticalAngle=vertiAngle, substructWidth=substructWidth, substructThickness=substructThickness, offsetDist=offsetCladdingDist, tileDimension = customizeTile)\n        \n    else:\n        tileSetting = searchTile.searchTileData\n        claddingWidth = tileSetting[\"claddingWidth\"]\n        claddingLength = tileSetting[\"claddingLength\"]\n        kindNum = tileSetting[\"kindNum\"]\n        wWeight = tileSetting[\"wWeight\"]\n        lWeight = tileSetting[\"lWeight\"]\n\n        claddingObj = generateCladding(windowDB=windowData, doorDB=doorData, claddingDB=claddingData, wallGeo=wallGeo, windowGeo=windowGeo, doorGeo=doorGeo, claddingWidth=claddingWidth, claddingLength=claddingLength, kindNum=kindNum, wWeight=wWeight, lWeight=lWeight, horizontalOverlap=horiOverlap, verticalOverlap=vertiOverlap, horizontalAngle=horiAngle, verticalAngle=vertiAngle, substructWidth=substructWidth, substructThickness=substructThickness, offsetDist=offsetCladdingDist)\n\n\n    Co = claddingObj.Co\n    CoGraft = claddingObj.CoGraft\n    checkCutting = claddingObj.checkCutting\n    targetLines = claddingObj.targetLines\n    # Output claddingObj\n    wallFrame = claddingObj.wallFrame\n    comb = th.list_to_tree(claddingObj.combinationGraph)\n    originalCoTileGeo = th.list_to_tree(claddingObj.originalCoTileGeo)\n    substructureGeo = claddingObj.substructureGeo\n    wallForInnerMaterial = claddingObj.wallForInnerGeo\n    windowForFinalList = claddingObj.windowForFinalList\n    doorForFinalList = claddingObj.doorForFinalList\n    orientedDoorGeoList = claddingObj.orientedDoorGeoList\n    originalCo = claddingObj.originalCo\n    compensatedCombineGeo = claddingObj.compensatedCombineGeo\n    compensatedOpeningGeoNext = claddingObj.compensatedOpeningGeoNext\n    trimedCo = claddingObj.trimedCo\n\n    # Calculate innerMaterial Part\n    offsetted_surface = offset_brep(wallForInnerMaterial, offsetList)\n\n    wallObj = innerMaterialGenerate(offsetted_surface, materialList, material_thickness, moduleDistance, wallFrame)\n    allTypeMaterial = wallObj.allTypeMaterial\n    checkGeo = wallObj.checkGeo\n    allTypeMaterialModule = wallObj.allTypeMaterialModule\n\n    for key in wallObj.materialInfoDict:\n        print(key)\n        print(wallObj.materialInfoDict[key])\n\n    \n    data = th.list_to_tree(allTypeMaterialModule.Branches)\n    allTypeMaterialModule = changePath(data, allTypeMaterialModule)\n\n    \n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}