{
  "source_url": "https://github.com/jongarrison/splint_geo_processor/blob/b4a410b94aa8ddd9dad7ee8d35d452964254ef41/generators/src/FeatureIdentification.py",
  "repo": "jongarrison/splint_geo_processor",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "generators/src/FeatureIdentification.py",
  "instruction": "FeatureIdentification.py\nFunctions for identifying and extracting geometric features from breps.",
  "code": "\"\"\"\nFeatureIdentification.py\nFunctions for identifying and extracting geometric features from breps.\n\"\"\"\n\nimport Rhino.Geometry as rg\nfrom splintcommon import log\n\n\nclass FeatureIdentificationError(Exception):\n    \"\"\"Raised when feature identification fails.\"\"\"\n    pass\n\n\ndef box_center_slice(target_brep, bbox_plane, choose_side_vector):\n    \"\"\"\n    Create a planar surface at the center of an oriented bounding box,\n    oriented to face in a specified direction.\n    \n    Args:\n        target_brep: A solid Brep to create the bounding box around\n        bbox_plane: Plane used to orient the bounding box\n        choose_side_vector: Vector3d indicating which side of the bbox to select\n        \n    Returns:\n        Brep: A planar surface (intersection_shape) positioned at the bbox center\n        \n    Raises:\n        FeatureIdentificationError: If operation fails\n    \"\"\"\n    if target_brep is None:\n        raise FeatureIdentificationError(\"target_brep is None\")\n    if not target_brep.IsValid:\n        raise FeatureIdentificationError(\"target_brep is not valid\")\n    if bbox_plane is None:\n        raise FeatureIdentificationError(\"bbox_plane is None\")\n    if choose_side_vector is None:\n        raise FeatureIdentificationError(\"choose_side_vector is None\")\n    \n    # Ensure choose_side_vector is a unit vector\n    side_direction = rg.Vector3d(choose_side_vector)\n    side_direction.Unitize()\n    \n    log(\"FeatureIdentification.box_center_slice: Starting\")\n    log(\"  bbox_plane origin: ({:.2f}, {:.2f}, {:.2f})\".format(\n        bbox_plane.Origin.X, bbox_plane.Origin.Y, bbox_plane.Origin.Z))\n    log(\"  choose_side_vector: ({:.3f}, {:.3f}, {:.3f})\".format(\n        side_direction.X, side_direction.Y, side_direction.Z))\n    \n    # Step 1: Create oriented bounding box around target_brep\n    # GetBoundingBox with a plane returns a world-aligned box of the transformed geometry\n    # We need to use a different approach for true oriented bbox\n    \n    # Transform brep to bbox_plane coordinates, get bbox, then transform back\n    world_to_plane = rg.Transform.ChangeBasis(rg.Plane.WorldXY, bbox_plane)\n    plane_to_world = rg.Transform.ChangeBasis(bbox_plane, rg.Plane.WorldXY)\n    \n    # Get bounding box in the plane's coordinate system\n    temp_brep = target_brep.DuplicateBrep()\n    temp_brep.Transform(world_to_plane)\n    local_bbox = temp_brep.GetBoundingBox(True)\n    \n    if not local_bbox.IsValid:\n        raise FeatureIdentificationError(\"Failed to create bounding box\")\n    \n    # Create a Box from the local bounding box\n    local_box = rg.Box(local_bbox)\n    \n    # Transform the box back to world coordinates\n    world_box = rg.Box(local_box)\n    world_box.Transform(plane_to_world)\n    \n    # Get the center of the bounding box in world coordinates\n    bbox_center = world_box.Center\n    log(\"  bbox center: ({:.2f}, {:.2f}, {:.2f})\".format(\n        bbox_center.X, bbox_center.Y, bbox_center.Z))\n    \n    # Step 2: Get the 6 faces of the box as Breps\n    box_brep = world_box.ToBrep()\n    if box_brep is None or not box_brep.IsValid:\n        raise FeatureIdentificationError(\"Failed to convert box to brep\")\n    \n    # The box brep has 6 faces\n    if box_brep.Faces.Count != 6:\n        raise FeatureIdentificationError(\"Box brep does not have 6 faces\")\n    \n    log(\"  Box has {} faces\".format(box_brep.Faces.Count))\n    \n    # Step 3: Find the face most aligned with choose_side_vector\n    # For each face, compute its centroid and the vector from bbox_center to face_centroid\n    # The face with the highest dot product with choose_side_vector wins\n    \n    best_face = None\n    best_face_index = -1\n    best_dot = -float('inf')\n    \n    for i in range(box_brep.Faces.Count):\n        face = box_brep.Faces[i]\n        \n        # Get face centroid using area mass properties\n        face_brep = face.DuplicateFace(False)\n        amp = rg.AreaMassProperties.Compute(face_brep)\n        \n        if amp is None:\n            continue\n        \n        face_centroid = amp.Centroid\n        \n        # Vector from bbox center to face centroid\n        to_face = face_centroid - bbox_center\n        to_face.Unitize()\n        \n        # Dot product with choose_side_vector\n        dot = rg.Vector3d.Multiply(to_face, side_direction)\n        \n        log(\"  Face {}: centroid ({:.2f}, {:.2f}, {:.2f}), dot={:.3f}\".format(\n            i, face_centroid.X, face_centroid.Y, face_centroid.Z, dot))\n        \n        if dot > best_dot:\n            best_dot = dot\n            best_face = face_brep\n            best_face_index = i\n    \n    if best_face is None:\n        raise FeatureIdentificationError(\"Could not find a suitable face\")\n    \n    log(\"  Selected face {} with dot={:.3f}\".format(best_face_index, best_dot))\n    \n    # Step 4: Move intersection_shape so its centroid is at bbox_center\n    amp = rg.AreaMassProperties.Compute(best_face)\n    if amp is None:\n        raise FeatureIdentificationError(\"Could not compute centroid of selected face\")\n    \n    face_centroid = amp.Centroid\n    move_vector = bbox_center - face_centroid\n    \n    intersection_shape = best_face.DuplicateBrep()\n    intersection_shape.Translate(move_vector)\n    \n    log(\"  Moved intersection_shape by ({:.2f}, {:.2f}, {:.2f})\".format(\n        move_vector.X, move_vector.Y, move_vector.Z))\n    \n    # Verify final position\n    amp_final = rg.AreaMassProperties.Compute(intersection_shape)\n    if amp_final:\n        final_centroid = amp_final.Centroid\n        log(\"  Final intersection_shape centroid: ({:.2f}, {:.2f}, {:.2f})\".format(\n            final_centroid.X, final_centroid.Y, final_centroid.Z))\n    \n    log(\"FeatureIdentification.box_center_slice: Complete\")\n    return intersection_shape\n\n\ndef get_ordered_vertices(surface_brep, view_direction, up_vector=None):\n    \"\"\"\n    Get the 4 corners of a planar rectangular surface in clockwise order\n    when viewed from the specified direction.\n    \n    Args:\n        surface_brep: A planar Brep surface (should have 4 corners)\n        view_direction: Vector3d - the direction you're looking TOWARD\n                        (e.g., +Y means viewer is on -Y side looking toward +Y)\n        up_vector: Vector3d - what's \"up\" in that view (default: +Z)\n        \n    Returns:\n        list of 4 Point3d in clockwise order: [top-left, top-right, bottom-right, bottom-left]\n        \n    Raises:\n        FeatureIdentificationError: If surface doesn't have 4 vertices\n    \"\"\"\n    if up_vector is None:\n        up_vector = rg.Vector3d.ZAxis\n    \n    # Normalize vectors\n    view_dir = rg.Vector3d(view_direction)\n    view_dir.Unitize()\n    up_vec = rg.Vector3d(up_vector)\n    up_vec.Unitize()\n    \n    # Make up_vector perpendicular to view_direction\n    # Project up onto plane perpendicular to view\n    dot = rg.Vector3d.Multiply(up_vec, view_dir)\n    up_vec = up_vec - view_dir * dot\n    up_vec.Unitize()\n    \n    # Right vector: view x up (right-hand rule)\n    right_vec = rg.Vector3d.CrossProduct(view_dir, up_vec)\n    right_vec.Unitize()\n    \n    log(\"get_ordered_vertices: view=({:.2f},{:.2f},{:.2f}), up=({:.2f},{:.2f},{:.2f}), right=({:.2f},{:.2f},{:.2f})\".format(\n        view_dir.X, view_dir.Y, view_dir.Z,\n        up_vec.X, up_vec.Y, up_vec.Z,\n        right_vec.X, right_vec.Y, right_vec.Z))\n    \n    # Get vertices from the surface/brep\n    # Handle both Brep and Surface types\n    vertices = []\n    \n    if hasattr(surface_brep, 'Vertices'):\n        # It's a Brep - get vertices directly\n        for v in surface_brep.Vertices:\n            vertices.append(v.Location)\n    elif hasattr(surface_brep, 'Domain'):\n        # It's a Surface - get 4 corners from domain\n        u_domain = surface_brep.Domain(0)\n        v_domain = surface_brep.Domain(1)\n        \n        # Get the 4 corner points\n        vertices.append(surface_brep.PointAt(u_domain.Min, v_domain.Min))\n        vertices.append(surface_brep.PointAt(u_domain.Max, v_domain.Min))\n        vertices.append(surface_brep.PointAt(u_domain.Max, v_domain.Max))\n        vertices.append(surface_brep.PointAt(u_domain.Min, v_domain.Max))\n        \n        log(\"  Got corners from surface domain: u=[{:.2f},{:.2f}], v=[{:.2f},{:.2f}]\".format(\n            u_domain.Min, u_domain.Max, v_domain.Min, v_domain.Max))\n    else:\n        raise FeatureIdentificationError(\n            \"surface_brep must be a Brep or Surface, got {}\".format(type(surface_brep).__name__))\n    \n    if len(vertices) != 4:\n        raise FeatureIdentificationError(\n            \"Expected 4 vertices, got {}\".format(len(vertices)))\n    \n    # Project each vertex onto up/right axes\n    # Use the centroid as origin for projection\n    amp = rg.AreaMassProperties.Compute(surface_brep)\n    if amp is None:\n        raise FeatureIdentificationError(\"Could not compute surface centroid\")\n    centroid = amp.Centroid\n    \n    vertex_data = []\n    for v in vertices:\n        offset = v - centroid\n        up_component = rg.Vector3d.Multiply(rg.Vector3d(offset), up_vec)\n        right_component = rg.Vector3d.Multiply(rg.Vector3d(offset), right_vec)\n        vertex_data.append((v, up_component, right_component))\n        log(\"  vertex ({:.2f},{:.2f},{:.2f}): up={:.2f}, right={:.2f}\".format(\n            v.X, v.Y, v.Z, up_component, right_component))\n    \n    # Sort to find corners:\n    # Top-left: max up, min right\n    # Top-right: max up, max right\n    # Bottom-right: min up, max right\n    # Bottom-left: min up, min right\n    \n    # Find top two (highest up values)\n    sorted_by_up = sorted(vertex_data, key=lambda x: x[1], reverse=True)\n    top_two = sorted_by_up[:2]\n    bottom_two = sorted_by_up[2:]\n    \n    # Top-left has smaller right value, top-right has larger\n    top_two_sorted = sorted(top_two, key=lambda x: x[2])\n    top_left = top_two_sorted[0][0]\n    top_right = top_two_sorted[1][0]\n    \n    # Bottom-right has larger right value, bottom-left has smaller\n    bottom_two_sorted = sorted(bottom_two, key=lambda x: x[2])\n    bottom_left = bottom_two_sorted[0][0]\n    bottom_right = bottom_two_sorted[1][0]\n    \n    ordered = [top_left, top_right, bottom_right, bottom_left]\n    log(\"  Ordered vertices (clockwise from TL):\")\n    for i, pt in enumerate(ordered):\n        labels = [\"TL\", \"TR\", \"BR\", \"BL\"]\n        log(\"    {}: ({:.2f}, {:.2f}, {:.2f})\".format(labels[i], pt.X, pt.Y, pt.Z))\n    \n    return ordered\n\n\ndef intersect_with_reference(target_brep, slice_surface, view_direction, up_vector=None):\n    \"\"\"\n    Intersect a brep with a surface and return curves plus reference points\n    corresponding to the surface vertices.\n    \n    Args:\n        target_brep: The solid Brep to intersect\n        slice_surface: A planar surface Brep to intersect with\n        view_direction: Vector3d - direction looking TOWARD (for vertex ordering)\n                        (e.g., +Y means viewer is on -Y side looking toward +Y)\n        up_vector: Vector3d - what's \"up\" in that view (default: +Z)\n        \n    Returns:\n        tuple: (result_curves, result_points)\n            - result_curves: list of Curve from intersection\n            - result_points: list of 4 Point3d (closest point on curves for each \n                            vertex, in clockwise order: TL, TR, BR, BL)\n                            None if no curve exists or no close point found\n                            \n    Raises:\n        FeatureIdentificationError: If intersection fails\n    \"\"\"\n    if target_brep is None:\n        raise FeatureIdentificationError(\"target_brep is None\")\n    if slice_surface is None:\n        raise FeatureIdentificationError(\"slice_surface is None\")\n    if view_direction is None:\n        raise FeatureIdentificationError(\"view_direction is None\")\n    \n    log(\"FeatureIdentification.intersect_with_reference: Starting\")\n    \n    # Step 1: Get ordered vertices of slice_surface\n    ordered_vertices = get_ordered_vertices(slice_surface, view_direction, up_vector)\n    \n    # Step 2: Perform intersection\n    # Handle both Brep and Surface types for slice_surface\n    tolerance = 0.001  # Standard Rhino tolerance\n    \n    if hasattr(slice_surface, 'Faces'):\n        # slice_surface is a Brep\n        success, intersection_curves, intersection_points = rg.Intersect.Intersection.BrepBrep(\n            target_brep, slice_surface, tolerance)\n    else:\n        # slice_surface is a Surface - use BrepSurface intersection\n        success, intersection_curves, intersection_points = rg.Intersect.Intersection.BrepSurface(\n            target_brep, slice_surface, tolerance)\n    \n    if not success:\n        raise FeatureIdentificationError(\"Brep-Brep intersection failed\")\n    \n    # Convert to list\n    result_curves = list(intersection_curves) if intersection_curves else []\n    \n    log(\"  Found {} intersection curves\".format(len(result_curves)))\n    \n    # If no curves, return empty results\n    if len(result_curves) == 0:\n        log(\"  No intersection curves found\")\n        return ([], [None, None, None, None])\n    \n    # Step 3: For each vertex, find closest point on any curve\n    result_points = []\n    \n    for i, vertex in enumerate(ordered_vertices):\n        labels = [\"TL\", \"TR\", \"BR\", \"BL\"]\n        \n        best_point = None\n        best_distance = float('inf')\n        \n        for curve in result_curves:\n            success, t = curve.ClosestPoint(vertex)\n            if success:\n                pt = curve.PointAt(t)\n                dist = vertex.DistanceTo(pt)\n                if dist < best_distance:\n                    best_distance = dist\n                    best_point = pt\n        \n        result_points.append(best_point)\n        \n        if best_point is not None:\n            log(\"  {}: vertex ({:.2f},{:.2f},{:.2f}) -> curve point ({:.2f},{:.2f},{:.2f}), dist={:.2f}\".format(\n                labels[i], vertex.X, vertex.Y, vertex.Z,\n                best_point.X, best_point.Y, best_point.Z, best_distance))\n        else:\n            log(\"  {}: vertex ({:.2f},{:.2f},{:.2f}) -> no curve point found\".format(\n                labels[i], vertex.X, vertex.Y, vertex.Z))\n    \n    log(\"FeatureIdentification.intersect_with_reference: Complete\")\n    return (result_curves, result_points)\n\n\ndef rect2plane(rectangle):\n    \"\"\"\n    Create a plane from a rectangular surface or brep.\n    \n    The plane origin is at the rectangle's centroid, with X and Y axes \n    aligned to the rectangle's edges.\n    \n    Args:\n        rectangle: A planar rectangular Brep or Surface with 4 corners\n        \n    Returns:\n        Plane: A plane positioned at the rectangle's centroid\n        \n    Raises:\n        FeatureIdentificationError: If rectangle is invalid or not planar\n    \"\"\"\n    if rectangle is None:\n        raise FeatureIdentificationError(\"rectangle is None\")\n    \n    log(\"FeatureIdentification.rect2plane: Starting\")\n    \n    # Get vertices from the rectangle\n    vertices = []\n    \n    if hasattr(rectangle, 'Vertices'):\n        # It's a Brep\n        for v in rectangle.Vertices:\n            vertices.append(v.Location)\n    elif hasattr(rectangle, 'Domain'):\n        # It's a Surface - get 4 corners from domain\n        u_domain = rectangle.Domain(0)\n        v_domain = rectangle.Domain(1)\n        vertices.append(rectangle.PointAt(u_domain.Min, v_domain.Min))\n        vertices.append(rectangle.PointAt(u_domain.Max, v_domain.Min))\n        vertices.append(rectangle.PointAt(u_domain.Max, v_domain.Max))\n        vertices.append(rectangle.PointAt(u_domain.Min, v_domain.Max))\n    else:\n        raise FeatureIdentificationError(\n            \"rectangle must be a Brep or Surface, got {}\".format(type(rectangle).__name__))\n    \n    if len(vertices) != 4:\n        raise FeatureIdentificationError(\n            \"Expected 4 vertices for rectangle, got {}\".format(len(vertices)))\n    \n    # Compute centroid\n    centroid = rg.Point3d(0, 0, 0)\n    for v in vertices:\n        centroid += rg.Point3d(v.X / 4.0, v.Y / 4.0, v.Z / 4.0)\n    \n    log(\"  Centroid: ({:.2f}, {:.2f}, {:.2f})\".format(\n        centroid.X, centroid.Y, centroid.Z))\n    \n    # Create X axis from first edge (v0 to v1)\n    x_axis = vertices[1] - vertices[0]\n    x_axis.Unitize()\n    \n    # Create Y axis from second edge (v0 to v3 or v1 to v2)\n    y_axis = vertices[3] - vertices[0]\n    y_axis.Unitize()\n    \n    # Ensure orthogonality by computing normal then re-deriving Y\n    normal = rg.Vector3d.CrossProduct(x_axis, y_axis)\n    normal.Unitize()\n    y_axis = rg.Vector3d.CrossProduct(normal, x_axis)\n    y_axis.Unitize()\n    \n    # Create plane\n    plane = rg.Plane(centroid, x_axis, y_axis)\n    \n    log(\"  Plane X: ({:.3f}, {:.3f}, {:.3f})\".format(\n        plane.XAxis.X, plane.XAxis.Y, plane.XAxis.Z))\n    log(\"  Plane Y: ({:.3f}, {:.3f}, {:.3f})\".format(\n        plane.YAxis.X, plane.YAxis.Y, plane.YAxis.Z))\n    log(\"  Plane Normal: ({:.3f}, {:.3f}, {:.3f})\".format(\n        plane.Normal.X, plane.Normal.Y, plane.Normal.Z))\n    \n    log(\"FeatureIdentification.rect2plane: Complete\")\n    return plane\n\n\ndef trim_surface_with_direction(trim_surfaces, input_surface, keep_direction):\n    \"\"\"\n    Split a surface/brep with one or more cutting surfaces, keeping the portion\n    on the specified side each time.\n    \n    Applies each trim surface iteratively - the result of one split becomes\n    the input to the next.\n    \n    Args:\n        trim_surfaces: Single Brep/Surface or list of them used to cut input_surface\n        input_surface: Brep (preferred) or Surface to split.\n                       Must be passed as Brep to preserve trim curves.\n        keep_direction: Vector3d pointing toward the side to keep\n        \n    Returns:\n        tuple: (result_brep, input_brep) where input_brep is the initial converted input\n        \n    Raises:\n        FeatureIdentificationError: If splitting fails or no valid piece found\n    \"\"\"\n    if trim_surfaces is None:\n        raise FeatureIdentificationError(\"trim_surfaces is None\")\n    if input_surface is None:\n        raise FeatureIdentificationError(\"input_surface is None\")\n    if keep_direction is None:\n        raise FeatureIdentificationError(\"keep_direction is None\")\n    \n    # Normalize to list (accept single surface or list)\n    if not hasattr(trim_surfaces, '__iter__'):\n        trim_surfaces = [trim_surfaces]\n    else:\n        trim_surfaces = list(trim_surfaces)\n    \n    log(\"FeatureIdentification.trim_surface_with_direction: Starting ({} trim surface(s))\".format(len(trim_surfaces)))\n    \n    # Normalize keep direction\n    keep_dir = rg.Vector3d(keep_direction)\n    keep_dir.Unitize()\n    \n    log(\"  keep_direction: ({:.3f}, {:.3f}, {:.3f})\".format(\n        keep_dir.X, keep_dir.Y, keep_dir.Z))\n    \n    tolerance = 0.001\n    \n    # Convert input_surface to Brep\n    log(\"  Input type: {}, isinstance Brep: {}, isinstance BrepFace: {}, isinstance Surface: {}\".format(\n        type(input_surface).__name__,\n        isinstance(input_surface, rg.Brep),\n        isinstance(input_surface, rg.BrepFace),\n        isinstance(input_surface, rg.Surface)))\n    \n    if isinstance(input_surface, rg.Brep):\n        input_brep = input_surface\n    elif isinstance(input_surface, rg.BrepFace):\n        input_brep = input_surface.DuplicateFace(False)\n        log(\"  Used DuplicateFace to preserve trims\")\n    elif isinstance(input_surface, rg.Surface):\n        input_brep = input_surface.ToBrep()\n        log(\"  WARNING: Used ToBrep on raw Surface - trim curves are lost!\")\n    else:\n        raise FeatureIdentificationError(\n            \"input_surface must be a Brep, BrepFace, or Surface, got {}\".format(type(input_surface).__name__))\n    \n    if input_brep is None or not input_brep.IsValid:\n        raise FeatureIdentificationError(\"input_brep is invalid\")\n    \n    # Log trim loop diagnostics\n    for fi in range(input_brep.Faces.Count):\n        face = input_brep.Faces[fi]\n        log(\"  Input face {}: {} trim loop(s)\".format(fi, face.Loops.Count))\n    \n    input_amp = rg.AreaMassProperties.Compute(input_brep)\n    if input_amp:\n        log(\"  Input centroid: ({:.2f}, {:.2f}, {:.2f}), area: {:.2f}\".format(\n            input_amp.Centroid.X, input_amp.Centroid.Y, input_amp.Centroid.Z, input_amp.Area))\n    \n    # Save original for debug return\n    original_input_brep = input_brep\n    current = input_brep\n    \n    # Apply each trim surface iteratively\n    for ti, trim_surface in enumerate(trim_surfaces):\n        log(\"  --- Trim pass {}/{} ---\".format(ti + 1, len(trim_surfaces)))\n        \n        # Convert trim_surface to Brep\n        if isinstance(trim_surface, rg.Brep):\n            trim_brep = trim_surface.DuplicateBrep()\n        elif isinstance(trim_surface, rg.BrepFace):\n            trim_brep = trim_surface.DuplicateFace(False)\n        elif isinstance(trim_surface, rg.Surface):\n            trim_brep = trim_surface.ToBrep()\n        else:\n            raise FeatureIdentificationError(\n                \"trim_surface must be a Brep, BrepFace, or Surface, got {}\".format(type(trim_surface).__name__))\n        \n        if trim_brep is None or not trim_brep.IsValid:\n            raise FeatureIdentificationError(\"trim_brep {} is invalid\".format(ti))\n        \n        # Split current with trim surface\n        split_results = current.Split(trim_brep, tolerance)\n        \n        if split_results is None or len(split_results) == 0:\n            log(\"    Split returned no results, trying with larger tolerance\")\n            split_results = current.Split(trim_brep, tolerance * 10)\n        \n        if split_results is None or len(split_results) == 0:\n            log(\"    Split {} returned no results\".format(ti))\n            raise FeatureIdentificationError(\"Split {} produced no pieces\".format(ti))\n        \n        log(\"    Split produced {} piece(s)\".format(len(split_results)))\n        \n        # Pick the piece most in keep_direction from the trim surface\n        trim_amp = rg.AreaMassProperties.Compute(trim_brep)\n        ref_point = trim_amp.Centroid if trim_amp else rg.Point3d.Origin\n        \n        best_piece = None\n        best_dot = -float('inf')\n        for i, piece in enumerate(split_results):\n            amp = rg.AreaMassProperties.Compute(piece)\n            if amp:\n                to_piece = amp.Centroid - ref_point\n                dot = rg.Vector3d.Multiply(to_piece, keep_dir)\n                log(\"    Piece {}: centroid ({:.2f}, {:.2f}, {:.2f}), area: {:.2f}, dot: {:.3f}\".format(\n                    i, amp.Centroid.X, amp.Centroid.Y, amp.Centroid.Z, amp.Area, dot))\n                if dot > best_dot:\n                    best_dot = dot\n                    best_piece = piece\n        \n        current = best_piece if best_piece else split_results[0]\n    \n    log(\"FeatureIdentification.trim_surface_with_direction: Complete\")\n    return current\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}