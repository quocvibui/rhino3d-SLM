{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/api/utils/rhino_integration.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "api/utils/rhino_integration.py",
  "instruction": "Rhino integration",
  "code": "import os\nimport sys\nfrom typing import Dict, Any, Optional, Tuple\nimport json\nimport tempfile\n\n# Function to check if Rhino/Revit is available\ndef is_rhino_available():\n    \"\"\"Check if Rhino environment is available.\"\"\"\n    try:\n        import rhinoinside\n        return True\n    except ImportError:\n        return False\n\ndef initialize_rhino():\n    \"\"\"\n    Initialize Rhino.Inside if available.\n    \"\"\"\n    if not is_rhino_available():\n        return False\n    \n    try:\n        import rhinoinside\n        rhinoinside.load()\n        import Rhino  # type: ignore\n        return True\n    except Exception as e:\n        print(f\"Error initializing Rhino: {e}\")\n        return False\n\ndef process_wall_with_rhino(wall_data: Dict[str, Any]) -> Tuple[bool, Dict[str, Any]]:\n    \"\"\"\n    Process wall data using Rhino.\n    \n    Args:\n        wall_data: Wall data in API format\n        \n    Returns:\n        Tuple of (success, result)\n        Where result is either the processed data or error information\n    \"\"\"\n    if not initialize_rhino():\n        return False, {\"error\": \"Rhino environment not available\"}\n    \n    try:\n        # At this point, Rhino is initialized and available\n        import Rhino.Geometry as rg  # type: ignore\n        import sys\n        \n        # Add your project root to sys.path if needed\n        project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../..\"))\n        if project_root not in sys.path:\n            sys.path.append(project_root)\n        \n        # Import your existing functionality\n        from src.timber_framing_generator.framing_elements import FramingGenerator\n        from api.utils.serialization import serialize_point3d, serialize_plane\n        \n        # Convert API data model to your internal data structure\n        # This is a placeholder - you'll need to implement the actual conversion\n        internal_wall_data = convert_api_to_internal_wall_data(wall_data)\n        \n        # Use your existing functionality\n        generator = FramingGenerator(\n            wall_data=internal_wall_data,\n            framing_config={\n                \"representation_type\": \"schematic\",\n                \"bottom_plate_layers\": 1,\n                \"top_plate_layers\": 2\n            }\n        )\n        \n        # Generate framing\n        framing_result = generator.generate_framing()\n        \n        # Convert the result back to API format\n        api_result = convert_internal_to_api_result(framing_result)\n        \n        return True, api_result\n        \n    except Exception as e:\n        import traceback\n        return False, {\n            \"error\": str(e),\n            \"traceback\": traceback.format_exc()\n        }\n\ndef convert_api_to_internal_wall_data(api_wall_data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Convert API wall data format to internal format used by your generator.\n    \n    This is where you'll handle the conversion between your API models\n    and the internal data structures expected by your existing code.\n    \"\"\"\n    # TODO: Implement the actual conversion\n    # This is a placeholder\n    \n    internal_data = {\n        \"wall_type\": api_wall_data[\"wall_type\"],\n        \"wall_base_elevation\": api_wall_data[\"wall_base_elevation\"],\n        \"wall_top_elevation\": api_wall_data[\"wall_top_elevation\"],\n        \"wall_length\": api_wall_data[\"wall_length\"],\n        \"wall_height\": api_wall_data[\"wall_height\"],\n        \"is_exterior_wall\": api_wall_data[\"is_exterior_wall\"],\n        \"openings\": [],\n    }\n    \n    # Convert openings\n    for opening in api_wall_data.get(\"openings\", []):\n        internal_data[\"openings\"].append({\n            \"opening_type\": opening[\"opening_type\"],\n            \"start_u_coordinate\": opening[\"start_u_coordinate\"],\n            \"rough_width\": opening[\"rough_width\"],\n            \"rough_height\": opening[\"rough_height\"],\n            \"base_elevation_relative_to_wall_base\": opening[\"base_elevation_relative_to_wall_base\"]\n        })\n    \n    # TODO: Create base_plane and other required fields\n    \n    return internal_data\n\ndef convert_internal_to_api_result(internal_result: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Convert internal result format to API format.\n    \n    This handles the conversion of your internal data structures\n    to the serializable format expected by your API.\n    \"\"\"\n    # TODO: Implement the actual conversion\n    # This is a placeholder\n    \n    api_result = {\n        \"bottom_plates\": [],\n        \"top_plates\": [],\n        \"king_studs\": [],\n        \"headers\": [],\n        \"sills\": [],\n        \"cells\": []\n    }\n    \n    # TODO: Convert each geometry type to API format\n    \n    return api_result",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}