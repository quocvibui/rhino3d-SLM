{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/brickSlicer.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/brickSlicer.py",
  "instruction": "Brick slicer",
  "code": "import Rhino.Geometry as rg\n# import ghpythonlib.components as gh\nimport math\nfrom generalFunctions import *\nfrom simpleStartStop import *\nfrom copy import deepcopy as dc\n# import Rhino.DocObjects as rd\n\nclass Brick(object):\n\n    def __init__(self, shell = None, pins = None, patterns = None, l_type = None, p_type = None):\n\n        if shell == None:\n\n            self.has_shell = False\n\n        else:\n\n            self.has_shell = True\n            \n            self.shell_obj = shell\n\n        if pins == None:\n\n            self.has_pins = False\n\n        else:\n\n            self.has_pins = False\n\n            self.pin_objs = pins\n\n        if patterns == None:\n\n            self.has_patterns = False\n\n        else:\n\n            self.has_patterns = True\n\n            self.patterns = patterns\n\n        if l_type == None:\n\n            self.l_type = LinkType()\n\n        else:\n\n            self.l_type = l_type\n\n        if p_type == None:\n\n            self.p_type = PrintSettings()\n\n        else:\n\n            self.p_type = p_type\n\n        if not(self.has_pins or self.has_shell):\n\n            print(\"can't have no pins or no shell\")\n            print(\"I'll operated under the assumption,\")\n            print(\"you wanted to do a simple circular column\")\n\n            self.has_shell = True\n\n            tmp_circle = rg.Circle(\n                rg.Point3d(0.0,0.0,0.0),\n                35.0\n            ).ToNurbsCurve()\n\n            self.shell_obj = Shell(geo = tmp_circle)\n\n    def createLayers(self, layer_height, body_height, total_height, start_height = 0.0):\n\n        height = start_height\n\n        self.brickLayers = []\n\n        while height < total_height:\n\n            if height < body_height:\n\n                self.brickLayers.append(self.createLayer(height, True))\n\n            height += layer_height\n\n    def createLayer(self, height, shell = True):\n\n        if self.has_shell and shell:\n\n            shell_crv = self.__shellPart(height)\n        \n        if self.has_pins and shell:\n\n            pin_crvs = self.__pinSet(height, False)\n\n        elif self.has_pins and not(shell):\n\n            pin_crvs = self.__pinSet(height, True)\n\n    def __shellPart(self, height):\n\n        return self.shell_obj.createSlice(height)\n\n    def __pinSet(self, height, inside = False):\n\n        return [pin.createSlice(height) for pin in self.pin_objs]\n\n\nclass OrganisedCurve(object):\n\n    def __init__(self, base_crv, linked_obj, direction = True):\n\n        self.base_crv = curveRotator(base_crv)\n\n    def split(self, object):\n\n        pass\n\n    def applyPattern(self, pattern, logic = None, periodic = False):\n\n        pass\n\n    def join(self):\n\n        pass\n\n    def alignSeams(self, ref_pt = None):\n\n        if ref_pt == None:\n\n            pass\n            # means it's the first layer\n\n        else:\n\n            pass\n\n    def organiseSplits(self, ref_pts = None):\n\n        pass\n\n\nclass BrickLayer(object):\n\n    def __init__(self, brick, height):\n\n        pass\n\n\nclass Shell(object):\n\n    def __init__(self, geo, offset_count = 1, l_type = None):\n\n        self.geo_type = rhinoGeometryObjectType(geo)\n        self.geo = geo\n\n    def moveToPoint(self, pt = None):\n\n        if pt == None:\n\n            placingInPlace(self.geo)\n\n        else:\n\n            placingInPlace(self.geo, pt)\n\n    def createSlice(self, height):\n\n        if self.geo_type == \"crv\":\n\n            return self.__ifCrv(height)\n\n        elif (self.geo_type == 'brep') or (self.geo_type == 'mesh'):\n\n            return self.__ifMeshBrep(height)\n\n    def __ifCrv(self, height, other = None):\n\n        if other == None:\n\n            slice_crv = dc(self.geo)\n\n        else:\n\n            slice_crv = other\n\n        placingInPlace(slice_crv, z_val=height)\n\n        return slice_crv\n\n    def __ifMeshBrep(self, height):\n\n        try:\n\n            h_pl = rg.Plane(rg.Point3d(0,0,height), rg.Vector3d(0,0,1))\n\n            if self.geo_type == 'brep':\n\n                contour_crv = rg.Brep.CreateContourCurves(geometry, h_pl)[0]\n\n            elif self.geo_type == 'mesh':\n\n                contour_crv = rg.Mesh.CreateContourCurves(geometry, h_pl)[0]\n\n            self.previous_crv = contour_crv\n\n        except:\n\n            contour_crv = self.__ifCrv(height, self.previous_crv)\n\n            self.previous_crv = contour_crv\n\n        return contour_crv\n\n\nclass Pin(object):\n\n    def __init__(self, b_pt, height, bot_rad, top_rad, resolution = 0, l_type = None, p_type = None):\n\n        self.b_pt = b_pt\n        self.h = height\n        self.bot_r = bot_rad\n        self.top_r = top_rad\n\n        self.delta_r = top_rad - bot_rad\n\n        self.res = int(resolution)\n\n        if self.res > 0:\n\n            self.res_delta = 6.2831852 / self.res\n\n        self.l_type = l_type\n        self.p_type = p_type\n\n    def createGeometry(self):\n\n        bot_c = rg.Circle(self.b_pt, self.bot_r).ToNurbsCurve()\n        top_c = rg.Circle(self.b_pt + rg.Point3d(0,0,self.h), self.top_r).ToNurbsCurve()\n\n        return rg.Brep.CreateFromLoft(\n            [bot_c, top_c],\n            rg.Point3d.Unset,\n            rg.Point3d.Unset,\n            rg.LoftType.Loose,\n            False\n        )[0]\n\n    def bPt(self, height):\n\n        return rg.Point3d(self.b_pt.X, self.b_pt.Y, height)\n\n    def radius(self, height):\n\n        rel_height = (height - self.b_pt.Z) / self.h\n        r = self.bot_r + rel_height * self.delta_r\n\n        return r\n\n    def helixPoint(self, alfa, height):\n\n        r = self.radius(height)\n\n        return rg.Point3d(\n            r * math.cos(alfa) + self.b_pt.X,\n            r * math.sin(alfa) + self.b_pt.Y,\n            height\n        )\n        \n    def createSlice(self, height):\n\n        circle = rg.Circle(\n            self.bPt(height),\n            self.radius(height)\n        )\n\n        if self.res == 0:\n        \n            return circle\n\n        else:\n\n            pt_set = [circle.PointAt(self.res_delta * i) for i in range(self.res)]\n\n            return rg.Polyline(pt_set + [pt_set[0]])\n\n    def helix(self, start_h = 150.0, end_h = 260.0, start_pt = None, layer_h = 2.5, start_alfa = 0.0):\n\n        alpha_delta = math.pi * 2.0 / self.res\n        h_delta = layer_h / self.res\n\n        if not(start_pt == None):\n\n            start_h = start_pt.Z + layer_h * .5\n\n            start_alfa = vectorAngle(start_pt)\n\n        height = start_h\n        alfa = start_alfa\n\n        pt_list = []\n\n        while height < end_h:\n\n            pt_list.append(self.helixPoint(alfa, height))\n\n            height += h_delta\n            alfa += alpha_delta\n\n        return pt_list\n\n\ndef slicing(geometry, heights):\n\n    object_height = heights[-1]\n\n    geo_type = rhinoGeometryObjectType(geometry)\n\n    geo_height = placingInPlace(geometry)\n\n    contour_set = []\n\n    if (geo_type == 'brep') or (geo_type == 'mesh'):\n        # types that need to be contoured\n        \n        for crv_i, loc_h in enumerate(heights):\n\n            if loc_h > geo_height:\n\n                mv_up = rg.Transform.Translation(rg.Vector3d(0,0,loc_h - heights[crv_i - 1]))\n\n                crv = dc(crv)\n                crv.Transform(mv_up)\n\n                contour_set.append(crv)\n\n            else:\n\n                mv_up = rg.Transform.Translation(rg.Vector3d(0,0,loc_h))\n\n                h_pl = rg.Plane(rg.Point3d(0,0,loc_h), rg.Vector3d(0,0,1))\n\n                if geo_type == 'brep':\n\n                    crv = rg.Brep.CreateContourCurves(geometry, h_pl)[0]\n\n                elif geo_type == 'mesh':\n\n                    crv = rg.Mesh.CreateContourCurves(geometry, h_pl)[0]\n                \n                contour_set.append(crv)\n\n\n    elif geo_type == 'crv':\n\n        for loc_h in heights:\n\n            mv_up = rg.Transform.Translation(rg.Vector3d(0,0,loc_h))\n            \n            crv = dc(geometry)\n            crv.Transform(mv_up)\n\n            contour_set.append(crv)\n\n    else:\n\n        print(\"%s is not supported\" % geo_type)\n\n    return contour_set\n\n\ndef layerIntersect(contour_crv, center_axis, slicing_object = None):\n\n    # in case no slicing object is given\n\n    if slicing_object == None:\n\n        slicing_object = center_axis\n\n    # two halves\n\n    # c_pt = center_axis.PointAt(.5)\n    # rot = rg.Transform.Rotation(math.pi * .5, c_pt)\n\n    split_axis = dc(center_axis)\n    # split_axis.Transform(rot)\n\n    split_axis = moveToSameHeight(contour_crv, split_axis)\n\n    # doing the intersections\n\n    _, t_vals = crvIntersector(contour_crv, split_axis)\n\n    contour_crv.ChangeClosedCurveSeam(t_vals[0])\n\n    pts, _ = crvIntersector(contour_crv, slicing_object)\n\n    # sorting based on distance from the split axis\n\n    pts = extremePtsOfAxis(pts, split_axis)\n\n    return layer2ptIntersect(contour_crv, pts)\n\n\ndef curveSetSorter(crv_set):\n\n    # sorts a set of two curves based on which one is stacked on top of the other\n\n    pt_0 = crv_set[0][0].PointAt(.5)\n    pt_1 = crv_set[0][1].PointAt(.5)\n\n    pt_set_a = [pt_0]\n    pt_set_b = [pt_1]\n\n    for crv_i in range(1, len(crv_set), 1):\n\n        pt_0_crv_0, dis_0, _ = closestPointOnCurve(crv_set[crv_i][0], pt_0)\n        pt_0_crv_1, dis_1, _ = closestPointOnCurve(crv_set[crv_i][1], pt_0)\n\n        if dis_0 < dis_1:\n\n            pt_0 = pt_0_crv_0\n\n        else:\n\n            pt_0 = pt_0_crv_1\n\n            # switching the curve location over\n\n            tmp_crv_1 = dc(crv_set[crv_i][0])\n            crv_set[crv_i][0] = crv_set[crv_i][1]\n            crv_set[crv_i][1] = tmp_crv_1\n\n        # also know pt_1_crv_1\n\n        pt_1, _, _ = closestPointOnCurve(crv_set[crv_i][1], pt_1)\n\n        pt_set_a.append(pt_0)\n        pt_set_b.append(pt_1)\n\n    return crv_set, pt_set_a, pt_set_b\n\ndef splitter(contour_set, slicing_object = None, split_type = \"longest\"):\n\n    # types of splitting:\n    # along it's >longest< direction - only one that requires no object\n    # using an >object<\n    # using an object but only >first layer< - only one that can work with curves\n\n    geo_type = rhinoGeometryObjectType(slicing_object)\n\n    # checking invalidities\n    if geo_type == 'other' and not(split_type == \"longest\"):\n\n        split_type = \"longest\"\n        print(\"you have given a none usuable geometry to split with, so I/n\")\n        print(\"reverted to the longitudinal splitting!/n\")\n\n    elif geo_type == 'crv' and split_type == \"object\":\n\n        split_type = \"first layer\"\n        print(\"you have given a crv which you can only use to split the first/n\")\n        print(\"layer with, so I reverted to first layer splitting!/n\")\n\n    split_contour_set = []\n\n    center_axis = crvOrienter(contour_set[0])\n\n    if split_type == \"object\":\n\n        for crv in contour_set:\n\n            crv_set, _ = layerIntersect(crv, center_axis, slicing_object)\n\n            split_contour_set.append(crv_set)\n    \n    else:\n\n        # first layer\n        \n        if split_type == \"first_layer\":\n\n            crv_set, pts = layerIntersect(contour_set[0], center_axis, slicing_object)\n\n        else:\n\n            # means it's a longest type split\n\n            crv_set, pts = layerIntersect(contour_set[0], center_axis, slicing_object = None)\n\n        split_contour_set.append(crv_set)\n\n        for i in range(1, len(contour_set), 1):\n\n            crv_set, pts = layer2ptIntersect(contour_set[i], pts)\n\n            split_contour_set.append(crv_set)\n\n    # setting domain from 0 to 1\n\n    for crv_set in split_contour_set:\n\n        for crv in crv_set:\n\n            crv.Domain = rg.Interval(0.0, 1.0)\n\n    crv_sets, pts_a, pts_b = curveSetSorter(split_contour_set)\n\n    split_contour_vis_set_a = [crv_set[0] for crv_set in crv_sets]\n    split_contour_vis_set_b = [crv_set[1] for crv_set in crv_sets]\n\n    return crv_sets, split_contour_vis_set_a, split_contour_vis_set_b, [pts_a, pts_b]",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}