{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_removeAllMicroEdges.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_removeAllMicroEdges.py",
  "instruction": "Alternative to _RemoveAllNakedMicroEdges, this script will remove all micro-edges,\r\nboth naked and interior, with no limiation of that the edges\r\n\"fold or loop back on themselves and have no matching...",
  "code": "\"\"\"\r\nAlternative to _RemoveAllNakedMicroEdges, this script will remove all micro-edges,\r\nboth naked and interior, with no limiation of that the edges\r\n\"fold or loop back on themselves and have no matching edge to which they can be joined\"\r\nas stated in https://docs.mcneel.com/rhino/7/help/en-us/index.htm#commands/removeallnakedmicroedges.htm\r\n\r\nBoth naked and interior micro-BrepEdges, as defined by the MaxEdgeLengthToRemove\r\noption, will be removed along with the relative BrepTrims.\r\nFor each edge removed, both end vertices are replaced with a single vertex at\r\nthe average location.\r\n\r\nIf this script fails, do the following and rerun the after each step until success:\r\n1. _RemoveAllNakedMicroEdges on the target breps then this script.\r\n2. _MergeAllEdges on the target breps then this script.\r\n3. _Extract faces with micro-edges.\r\n4. _MergeAllEdges on the extracted faces.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums ( https://discourse.mcneel.com/ ).\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n221114-22: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fMaxMicroLength'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'MaxEdgeLengthToRemove'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bDupEdgesRemoved'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMaxMicroLength':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal breps when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AcceptNothing(True)\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fMaxMicroLength')\r\n        addOption('bDupEdgesRemoved')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            rdBrepObjs = [o.Object() for o in go.Objects()]\r\n            go.Dispose()\r\n            return rdBrepObjs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            oes = rd.ObjectEnumeratorSettings()\r\n            oes.NormalObjects = True\r\n            oes.LockedObjects = False\r\n            oes.IncludeLights = False\r\n            oes.IncludeGrips = False\r\n            oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n            rdBrepObjs = list(sc.doc.Objects.GetObjectList(oes))\r\n            go.Dispose()\r\n            if len(rdBrepObjs) == 0: return\r\n            return rdBrepObjs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMaxMicroLength'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getTrimEndDeviation(rgLoop, idxLT):\r\n    return rgLoop.Trims[idxLT].PointAtEnd.DistanceTo(\r\n        rgLoop.Trims[(idxLT + 1) % rgLoop.Trims.Count].PointAtStart)\r\n\r\n\r\ndef _maxTrimEndDeviation(rgLoop, bDebug):\r\n    fMax = 0.0\r\n    iT_A_Max = None\r\n    iT_B_Max = None\r\n    for iT_A in range(rgLoop.Trims.Count):\r\n        dev = _getTrimEndDeviation(rgLoop, iT_A)\r\n        if dev > fMax:\r\n            fMax = dev\r\n            iT_A_Max = iT_A\r\n            iT_B_Max = iT_A + 1\r\n    if bDebug and (fMax > 0.0): print(iT_A_Max, iT_B_Max)\r\n    return fMax\r\n\r\n\r\ndef _getEdgeChain(rgB, idxE_Start, idxsEs):\r\n    if idxE_Start not in idxsEs:\r\n        raise Exception(\"Edge[] not in [{}]\".format(idxE_Start, *idxsEs))\r\n\r\n    if len(idxsEs) == 1:\r\n        return (\r\n            [idxE_Start],\r\n            [\r\n                rgB.Edges[idxsEs[0]].StartVertex.VertexIndex,\r\n                rgB.Edges[idxsEs[0]].EndVertex.VertexIndex])\r\n\r\n    idxEs_Chain = [idxE_Start]\r\n    idxVs_Chain = []\r\n\r\n\r\n    # Determine edges and vertices in one direction.\r\n\r\n    idxE_Now = idxE_Start\r\n    idxV_Now = rgB.Edges[idxE_Start].StartVertex.VertexIndex\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        idxVs_Chain.insert(0, idxV_Now)\r\n\r\n        idxEs_at_V_Now = rgB.Vertices[idxV_Now].EdgeIndices()\r\n\r\n        if len(idxEs_at_V_Now) == 1:\r\n            sc.doc.Objects.AddTextDot(rg.TextDot(\"\", rgB.Vertices[idxV_Now].Location))\r\n            sc.doc.Views.Redraw()\r\n            raise Exception(\"Only 1 edge at vertex[{}]\".format(idxV_Now))\r\n\r\n        if len(idxEs_at_V_Now) > 2:\r\n            break\r\n\r\n        idxE_Next = idxEs_at_V_Now[0] if idxEs_at_V_Now[0] != idxE_Now else idxEs_at_V_Now[1]\r\n\r\n        if idxE_Next not in idxsEs:\r\n            break\r\n\r\n        idxEs_Chain.insert(0, idxE_Next)\r\n\r\n        if rgB.Vertices[idxV_Now].VertexIndex == rgB.Edges[idxE_Next].StartVertex.VertexIndex:\r\n            idxV_Now = rgB.Edges[idxE_Next].EndVertex.VertexIndex\r\n        elif rgB.Vertices[idxV_Now].VertexIndex == rgB.Edges[idxE_Next].EndVertex.VertexIndex:\r\n            idxV_Now = rgB.Edges[idxE_Next].StartVertex.VertexIndex\r\n        else:\r\n            raise Exception(\"What happened?\")\r\n\r\n        idxE_Now = idxE_Next\r\n\r\n\r\n    # Determine edges and vertices in other direction.\r\n\r\n    idxE_Now = idxE_Start\r\n    idxV_Now = rgB.Edges[idxE_Start].EndVertex.VertexIndex\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        idxVs_Chain.append(idxV_Now)\r\n\r\n        idxEs_at_V_Now = rgB.Vertices[idxV_Now].EdgeIndices()\r\n\r\n        if len(idxEs_at_V_Now) == 1:\r\n            sc.doc.Objects.AddTextDot(rg.TextDot(\"\", rgB.Vertices[idxV_Now].Location))\r\n            sc.doc.Views.Redraw()\r\n            raise Exception(\"Only 1 edge at vertex[{}]\".format(idxV_Now))\r\n\r\n        if len(idxEs_at_V_Now) > 2:\r\n            break\r\n\r\n        idxE_Next = idxEs_at_V_Now[0] if idxEs_at_V_Now[0] != idxE_Now else idxEs_at_V_Now[1]\r\n\r\n        if idxE_Next not in idxsEs:\r\n            break\r\n\r\n        idxEs_Chain.append(idxE_Next)\r\n\r\n        if rgB.Vertices[idxV_Now].VertexIndex == rgB.Edges[idxE_Next].StartVertex.VertexIndex:\r\n            idxV_Now = rgB.Edges[idxE_Next].EndVertex.VertexIndex\r\n        elif rgB.Vertices[idxV_Now].VertexIndex == rgB.Edges[idxE_Next].EndVertex.VertexIndex:\r\n            idxV_Now = rgB.Edges[idxE_Next].StartVertex.VertexIndex\r\n        else:\r\n            raise Exception(\"What happened?\")\r\n\r\n        idxE_Now = idxE_Next\r\n\r\n    return idxEs_Chain, idxVs_Chain\r\n\r\n\r\ndef _copyUserDictionaryAndStrings(obj_From, obj_To):\r\n    obj_To.UserDictionary.AddContentsFrom(obj_From.UserDictionary)\r\n    nameValues = obj_From.GetUserStrings()\r\n    for sKey in nameValues.AllKeys:\r\n        obj_To.SetUserString(sKey, nameValues[sKey])\r\n\r\n\r\ndef createBrep_RemoveEdges(rgBrep_In, idxEdges_In, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep_In\r\n        idxEdges_In: list(int)\r\n        bDebug: bool\r\n\r\n    Returns on success:\r\n        Brep\r\n        None\r\n\r\n    Returns on fail:\r\n        None\r\n        str(\"Explanation of fail or that brep doesn't contain micro-edges.\")\r\n    \"\"\"\r\n\r\n\r\n    rgB_In = rgBrep_In\r\n    idxEs_In_ToRemove = idxEdges_In\r\n\r\n    rgB_Out = rg.Brep()\r\n    _copyUserDictionaryAndStrings(rgB_In, rgB_Out)\r\n\r\n\r\n    idxTs_In_ToRemove = []\r\n\r\n    idxVs_In_Involved = []\r\n    idxVs_Out_Per_idxVs_In_Involved = []\r\n\r\n    idxEs_In_FindChains = idxEs_In_ToRemove[:]\r\n\r\n    # Using 'Left' and 'Right' to designate each end of the chain.\r\n\r\n    while len(idxEs_In_FindChains) > 0:\r\n        sc.escape_test()\r\n\r\n        # No chaining for debugging.\r\n        #idxEs_Chain = [idxEs_In_FindChains[0]]\r\n        #idxVs_Chain = [\r\n        #    rgB_In.Edges[0].StartVertex.VertexIndex,\r\n        #    rgB_In.Edges[0].endVertex.VertexIndex,\r\n\r\n        idxEs_Chain, idxVs_Chain = _getEdgeChain(\r\n            rgB_In,\r\n            idxEs_In_FindChains[0],\r\n            idxEs_In_FindChains)\r\n\r\n        if bDebug:\r\n            print(\"Edges:{}\".format(idxEs_Chain), \"Vertices:{}\".format(idxVs_Chain))\r\n\r\n\r\n        for idxE_In in idxEs_Chain:\r\n            rgE_In = rgB_In.Edges[idxE_In]\r\n\r\n            idxTs_In_ToRemove.extend(rgE_In.TrimIndices())\r\n\r\n        # None of the inner vertices of the chain will be added to the new brep.\r\n        if len(idxVs_Chain) > 2:\r\n            for idxV_In in idxVs_Chain[1:-1]:\r\n                idxVs_In_Involved.append(idxV_In)\r\n                idxVs_Out_Per_idxVs_In_Involved.append(None)\r\n\r\n        idxV_In_Left = idxVs_Chain[0]\r\n        idxV_In_Right = idxVs_Chain[-1]\r\n\r\n        rgV_In_Left = rgB_In.Vertices[idxV_In_Left]\r\n        rgV_In_Right = rgB_In.Vertices[idxV_In_Right]\r\n\r\n        idxEs_at_V_In_Left = rgV_In_Left.EdgeIndices()\r\n        idxEs_at_V_In_Right = rgV_In_Right.EdgeIndices()\r\n\r\n\r\n        if len(idxEs_at_V_In_Left) == len(idxEs_at_V_In_Right):\r\n            pt = 0.5*(rgV_In_Left.Location + rgV_In_Right.Location)\r\n            rgV_Out = rgB_Out.Vertices.Add(\r\n                point=pt,\r\n                vertexTolerance=sc.doc.ModelAbsoluteTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n            idxV_Out = rgV_Out.VertexIndex\r\n\r\n            # No UserData, etc. will be transfered to this vertex since it is\r\n            # derived from multiple others.\r\n\r\n            if idxV_In_Left not in idxVs_In_Involved:\r\n                idxVs_In_Involved.append(idxV_In_Left)\r\n                idxVs_Out_Per_idxVs_In_Involved.append(idxV_Out)\r\n\r\n            if idxV_In_Right not in idxVs_In_Involved:\r\n                idxVs_In_Involved.append(idxV_In_Right)\r\n                idxVs_Out_Per_idxVs_In_Involved.append(idxV_Out)\r\n        elif len(idxEs_at_V_In_Left) > len(idxEs_at_V_In_Right):\r\n            if idxV_In_Left in idxVs_In_Involved:\r\n                idxV_Out = idxVs_Out_Per_idxVs_In_Involved[idxVs_In_Involved.index(idxV_In_Left)]\r\n            else:\r\n                idxVs_In_Involved.append(idxV_In_Left)\r\n                rgV_Out = rgB_Out.Vertices.Add(\r\n                    point=rgV_In_Left.Location,\r\n                    vertexTolerance=sc.doc.ModelAbsoluteTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n                idxV_Out = rgV_Out.VertexIndex\r\n                idxVs_Out_Per_idxVs_In_Involved.append(idxV_Out)\r\n                _copyUserDictionaryAndStrings(rgV_In_Left, rgV_Out)\r\n            if idxV_In_Right not in idxVs_In_Involved:\r\n                idxVs_In_Involved.append(idxV_In_Right)\r\n                idxVs_Out_Per_idxVs_In_Involved.append(idxV_Out)\r\n        else: # len(idxEs_at_V_In_S) < len(idxEs_at_V_In_E)\r\n            if idxV_In_Right in idxVs_In_Involved:\r\n                idxV_Out = idxVs_Out_Per_idxVs_In_Involved[idxVs_In_Involved.index(idxV_In_Right)]\r\n            else:\r\n                idxVs_In_Involved.append(idxV_In_Right)\r\n                rgV_Out = rgB_Out.Vertices.Add(\r\n                    point=rgV_In_Right.Location,\r\n                    vertexTolerance=sc.doc.ModelAbsoluteTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n                idxV_Out = rgV_Out.VertexIndex\r\n                idxVs_Out_Per_idxVs_In_Involved.append(rgV_Out.VertexIndex)\r\n                _copyUserDictionaryAndStrings(rgV_In_Right, rgV_Out)\r\n            if idxV_In_Left not in idxVs_In_Involved:\r\n                idxVs_In_Involved.append(idxV_In_Left)\r\n                idxVs_Out_Per_idxVs_In_Involved.append(idxV_Out)\r\n\r\n        idxEs_In_FindChains = list(set(idxEs_In_FindChains).difference(set(idxEs_Chain)))\r\n\r\n\r\n    if bDebug:\r\n        sEval = \"idxEs_In_ToRemove\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"idxTs_In_ToRemove\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    # Add surfaces.\r\n    for idxS_In, srf_In in enumerate(rgB_In.Surfaces):\r\n        srf_Out = srf_In.Duplicate() # This also copies UserDictionary and UserStrings.\r\n        idxS_Out = rgB_Out.AddSurface(srf_Out)\r\n\r\n\r\n    # Add edge curves (Curve3D).\r\n    idxC3s_In = []\r\n    idxC3s_Out_Per_idxC3s_In = []\r\n    for idxE_In, rgE_In in enumerate(rgB_In.Edges):\r\n        if rgE_In.EdgeIndex in idxEs_In_ToRemove:\r\n            continue\r\n        rgC3_In = rgE_In.EdgeCurve\r\n        rgC3_Out = rgC3_In.Duplicate() # This also copies UserDictionary and UserStrings.\r\n        idxC3_Out = rgB_Out.AddEdgeCurve(rgC3_Out)\r\n        idxC3s_Out_Per_idxC3s_In.append(idxC3_Out)\r\n        idxC3s_In.append(rgE_In.EdgeCurveIndex)\r\n\r\n\r\n    # Add trim curves (Curve2D).\r\n    idxC2s_In = []\r\n    idxC2s_Out_Per_idxC2s_In = []\r\n    for idxT_In, rgT_In in enumerate(rgB_In.Trims):\r\n        if rgT_In.TrimIndex in idxTs_In_ToRemove:\r\n            continue\r\n        rgC2_In = rgT_In.TrimCurve\r\n        rgC2_Out = rgC2_In.Duplicate() # This also copies UserDictionary and UserStrings.\r\n        idxC2_Out = rgB_Out.AddTrimCurve(rgC2_Out)\r\n        idxC2s_Out_Per_idxC2s_In.append(idxC2_Out)\r\n        idxC2s_In.append(rgT_In.TrimCurveIndex)\r\n\r\n\r\n    # Add faces.\r\n    for idxF_In, rgF_In in enumerate(rgB_In.Faces):\r\n        rgF_Out = rgB_Out.Faces.Add(rgF_In.SurfaceIndex)\r\n        rgF_Out.OrientationIsReversed = rgF_In.OrientationIsReversed\r\n        rgF_Out.PerFaceColor = rgF_In.PerFaceColor\r\n        rgF_Out.Id = rgF_In.Id\r\n        _copyUserDictionaryAndStrings(rgF_In, rgF_Out)\r\n\r\n\r\n    # Add kept vertices.  New ones were already added.\r\n    idxVs_Out_Kept = []\r\n    idxVs_In_Per_idxVs_Out_Kept = []\r\n    for idxV_In, rgV_In in enumerate(rgB_In.Vertices):\r\n        if idxV_In in idxVs_In_Involved:\r\n            continue\r\n\r\n        rgV_Out = rgB_Out.Vertices.Add(\r\n            point=rgV_In.Location,\r\n            vertexTolerance=sc.doc.ModelAbsoluteTolerance)  # SetTolerancesBoxesAndFlags below should correct this.\r\n        idxVs_Out_Kept.append(rgV_Out.VertexIndex)\r\n        idxVs_In_Per_idxVs_Out_Kept.append(idxV_In)\r\n        _copyUserDictionaryAndStrings(rgV_In, rgV_Out)\r\n\r\n\r\n    # Add loops.\r\n    for idxL_In, rgL_In in enumerate(rgB_In.Loops):\r\n        rgL_Out = rgB_Out.Loops.Add(\r\n            loopType=rgL_In.LoopType,\r\n            face=rgB_Out.Faces[rgL_In.Face.FaceIndex])\r\n        _copyUserDictionaryAndStrings(rgL_In, rgL_Out)\r\n\r\n\r\n    # Add edges.\r\n    idxTs_In_ToKeep = []\r\n    idxEs_Out_Per_idxTs_In_ToKeep = []\r\n\r\n    for idxE_In, rgE_In in enumerate(rgB_In.Edges):\r\n        if idxE_In in idxEs_In_ToRemove:\r\n            continue\r\n\r\n        idxV_In = rgE_In.StartVertex.VertexIndex\r\n        if idxV_In in idxVs_In_Involved:\r\n            idxV_S = idxVs_Out_Per_idxVs_In_Involved[idxVs_In_Involved.index(idxV_In)]\r\n        else:\r\n            idxV_S = idxVs_Out_Kept[idxVs_In_Per_idxVs_Out_Kept.index(idxV_In)]\r\n\r\n        idxV_In = rgE_In.EndVertex.VertexIndex\r\n        if idxV_In in idxVs_In_Involved:\r\n            idxV_E = idxVs_Out_Per_idxVs_In_Involved[idxVs_In_Involved.index(idxV_In)]\r\n        else:\r\n            idxV_E = idxVs_Out_Kept[idxVs_In_Per_idxVs_Out_Kept.index(idxV_In)]\r\n\r\n        idxC3_Out = idxC3s_Out_Per_idxC3s_In[idxC3s_In.index(rgE_In.EdgeCurveIndex)]\r\n        rgC3_Out = rgB_Out.Curves3D[idxC3_Out]\r\n\r\n        b_rgE_and_rgC3_domains_match = (\r\n            rgE_In.Domain.T0 == rgC3_Out.Domain.T0 and\r\n            rgE_In.Domain.T1 == rgC3_Out.Domain.T1)\r\n\r\n        if idxV_S == idxV_E:\r\n            if not rgC3_Out.IsClosed:\r\n                rgC3_Out.MakeClosed(sc.doc.ModelAbsoluteTolerance)\r\n            b_rgE_and_rgC3_domains_match = True\r\n\r\n        if b_rgE_and_rgC3_domains_match:\r\n            rgE_Out = rgB_Out.Edges.Add(\r\n                startVertexIndex=idxV_S,\r\n                endVertexIndex=idxV_E,\r\n                curve3dIndex=idxC3_Out,\r\n                edgeTolerance=sc.doc.ModelAbsoluteTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n        else:\r\n            rgE_Out = rgB_Out.Edges.Add(\r\n                startVertexIndex=idxV_S,\r\n                endVertexIndex=idxV_E,\r\n                curve3dIndex=idxC3_Out,\r\n                subDomain=rgE_In.Domain,\r\n                edgeTolerance=sc.doc.ModelAbsoluteTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n\r\n        _copyUserDictionaryAndStrings(rgE_In, rgE_Out)\r\n\r\n        if idxV_S == idxV_E:\r\n            if not rgE_Out.IsClosed:\r\n                rgE_Out.MakeClosed(sc.doc.ModelAbsoluteTolerance)\r\n\r\n\r\n        #if idxV_S == idxV_E:\r\n        #    print(rgE_Out.IsClosed, rgE_Out.EdgeIndex)\r\n\r\n        #if rgE_Out.EdgeIndex == 741:\r\n        #    sc.doc.Objects.AddCurve(rgE_Out); sc.doc.Views.Redraw()\r\n        #    print(rgE_Out.IsClosed, rgE_Out.IsClosable(sc.doc.ModelAbsoluteTolerance), rgE_Out.EdgeIndex, idxV_S, idxV_E)\r\n\r\n        idxE_Out = rgE_Out.EdgeIndex\r\n        for idxT_In in rgE_In.TrimIndices():\r\n            idxTs_In_ToKeep.append(idxT_In)\r\n            idxEs_Out_Per_idxTs_In_ToKeep.append(idxE_Out)\r\n\r\n\r\n    # Add trims per loop.\r\n    for idxL_In, rgL_In in enumerate(rgB_In.Loops):\r\n        rgL_Out = rgB_Out.Loops[idxL_In]\r\n\r\n        for idxTL_In, rgT_In in enumerate(rgL_In.Trims):\r\n            idxT_In = rgT_In.TrimIndex\r\n            if idxT_In in idxTs_In_ToRemove:\r\n                continue\r\n\r\n            idxC2_Out = idxC2s_Out_Per_idxC2s_In[idxC2s_In.index(rgT_In.TrimCurveIndex)]\r\n\r\n\r\n            if rgT_In.TrimType == rg.BrepTrimType.Singular:\r\n\r\n                idxV_In = rgT_In.StartVertex.VertexIndex\r\n\r\n                if idxV_In in idxVs_In_Involved:\r\n                    idxV_Out = idxVs_Out_Per_idxVs_In_Involved[idxVs_In_Involved.index(idxV_In)]\r\n                else:\r\n                    idxV_Out = idxVs_Out_Kept[idxVs_In_Per_idxVs_Out_Kept.index(idxV_In)]\r\n\r\n                rgT_Out = rgB_Out.Trims.AddSingularTrim(\r\n                    vertex=rgB_Out.Vertices[idxV_Out],\r\n                    loop=rgL_Out,\r\n                    iso=rgT_In.IsoStatus,\r\n                    curve2dIndex=idxC2_Out)\r\n            else:\r\n                idxE_Out = idxEs_Out_Per_idxTs_In_ToKeep[idxTs_In_ToKeep.index(idxT_In)]\r\n\r\n                rgT_Out = rgB_Out.Trims.Add(\r\n                    edge=rgB_Out.Edges[idxE_Out],\r\n                    rev3d=rgT_In.IsReversed(),\r\n                    loop=rgL_Out,\r\n                    curve2dIndex=idxC2_Out)\r\n\r\n                rgT_Out.IsoStatus = rgT_In.IsoStatus\r\n\r\n            rgT_Out.SetTolerances(\r\n                toleranceU=Rhino.RhinoMath.ZeroTolerance,\r\n                toleranceV=Rhino.RhinoMath.ZeroTolerance) # SetTolerancesBoxesAndFlags below should correct this.\r\n\r\n            _copyUserDictionaryAndStrings(rgT_In, rgT_Out)\r\n\r\n        #bMatchedTrimEnds_Loop = rgL_Out.Trims.MatchEnds(rgL_Out)\r\n        #if not bMatchedTrimEnds_Loop:\r\n        #    print(\"l[{}]: Trims.MathEnds failed.\".format(idxL_In))\r\n        #    for rgT in rgL_Out.Trims:\r\n        #        sc.doc.Objects.AddCurve(rgT)\r\n        #        sc.doc.Objects.AddCurve(rgT.Edge)\r\n        #    sc.doc.Views.Redraw()\r\n        #    1/0\r\n\r\n    bMatchedTrimEnds_All = rgB_Out.Trims.MatchEnds()\r\n\r\n    if bDebug:\r\n        sEval = \"rgB_In.Faces.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_Out.Faces.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_In.Loops.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_Out.Loops.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_In.Edges.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_Out.Edges.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_In.Vertices.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_Out.Vertices.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_In.Trims.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"rgB_Out.Trims.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"bMatchedTrimEnds_All\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    bIsValid, sLog = rgB_Out.IsValidWithLog()\r\n\r\n    if bIsValid:\r\n        if bDebug: print(\"rgB_Out is initially valid.\")\r\n\r\n        rgB_Out.SetTolerancesBoxesAndFlags(\r\n            bLazy=False,\r\n            bSetVertexTolerances=True,\r\n            bSetEdgeTolerances=True,\r\n            bSetTrimTolerances=True,\r\n            bSetTrimIsoFlags=True,\r\n            bSetTrimTypeFlags=True,\r\n            bSetLoopTypeFlags=True,\r\n            bSetTrimBoxes=True)\r\n\r\n        return rgB_Out, None\r\n\r\n\r\n    if bDebug: print(\"Initial brep:\", sLog)\r\n\r\n\r\n    rgB_Out.Repair(sc.doc.ModelAbsoluteTolerance)\r\n\r\n    bIsValid, sLog = rgB_Out.IsValidWithLog()\r\n\r\n    if not bIsValid:\r\n        print(sLog)\r\n        #sc.doc.Objects.AddCurve(rgB_Out.Trims[715].Edge)\r\n        #sc.doc.Objects.AddCurve(rgB_Out.Trims[716].Edge)\r\n        #sc.doc.Views.Redraw(); 1/0\r\n        rgB_Out.Dispose()\r\n        return None, \"After Brep.Repair brep: {}\".format(sLog)\r\n\r\n    if bDebug: print(\"Brep.Repair was successful.\")\r\n\r\n    rgB_Out.SetTolerancesBoxesAndFlags(\r\n        bLazy=False,\r\n        bSetVertexTolerances=True,\r\n        bSetEdgeTolerances=True,\r\n        bSetTrimTolerances=True,\r\n        bSetTrimIsoFlags=True,\r\n        bSetTrimTypeFlags=True,\r\n        bSetLoopTypeFlags=True,\r\n        bSetTrimBoxes=True)\r\n\r\n\r\n    return rgB_Out, None\r\n\r\n\r\ndef createBrep_RemoveMicroEdges(rgBrep_In, fMaxMicroLength, bDupEdgesRemoved=False, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep_In\r\n        fMaxMicroLength: float\r\n        bDebug: bool\r\n\r\n    Returns on success:\r\n        Brep\r\n        None\r\n\r\n    Returns on fail:\r\n        None\r\n        str(\"Explanation of fail or that brep doesn't contain micro-edges.\")\r\n    \"\"\"\r\n\r\n\r\n    rgB_In = rgBrep_In\r\n\r\n\r\n    def getMicroEdges(rgB):\r\n        idxEs_Micro = []\r\n        for rgE_In in rgB.Edges:\r\n            if rgE_In.GetLength() <= fMaxMicroLength:\r\n                idxEs_Micro.append(rgE_In.EdgeIndex)\r\n        return idxEs_Micro\r\n\r\n\r\n    idxEs_Micro_In = idxEs_Micro = getMicroEdges(rgB_In)\r\n\r\n\r\n    if not idxEs_Micro:\r\n        return None, \"Brep does not have any micro-edges.\"\r\n\r\n    #print(\"{} micro-edges found.\".format(len(idxEs_Micro)))\r\n\r\n\r\n    # For debugging\r\n    #if bDebug:\r\n    #    rgB_Res, sLog = createBrep_RemoveEdges(\r\n    #        rgB_In,\r\n    #        [idxEs_Micro[0]],\r\n    #        bDebug=True)\r\n    #    if rgB_Res:\r\n    #        idxEs_Micro_End = getMicroEdges(rgB_Res)\r\n\r\n    #        sLog = \"Micro-edge count change: {} -> {}\".format(\r\n    #            len(idxEs_Micro_In), len(idxEs_Micro_End))\r\n    #        #if bEcho: print(sLog)\r\n    #        return rgB_Res, sLog\r\n\r\n    #    return None, sLog\r\n\r\n\r\n\r\n    # Try to create brep with all micro-edges removed.\r\n\r\n    rgB_Res, sLog = createBrep_RemoveEdges(\r\n        rgB_In,\r\n        idxEs_Micro,\r\n        bDebug=bDebug)\r\n\r\n    if rgB_Res:\r\n        if bDupEdgesRemoved:\r\n            for idxE in idxEs_Micro_In:\r\n                sc.doc.Objects.AddCurve(rgB_In.Edges[idxE])\r\n\r\n        idxEs_Micro_End = getMicroEdges(rgB_Res)\r\n\r\n        sLog = \"Micro-edge count change: {} -> {}\".format(\r\n            len(idxEs_Micro_In), len(idxEs_Micro_End))\r\n        #if bEcho: print(sLog)\r\n        return rgB_Res, sLog\r\n\r\n\r\n    if bEcho:\r\n        print(\"Removing all micro-edges at once failed because {}\".format(sLog))\r\n\r\n    if len(idxEs_Micro_In) == 1:\r\n        return None, sLog\r\n\r\n\r\n    print(\"Now, attempting to remove one at a time ...\")\r\n\r\n    rgB_LastGood = rgB_In.DuplicateBrep()\r\n\r\n    i = 0\r\n\r\n    while i < len(idxEs_Micro):\r\n        sc.escape_test()\r\n\r\n        rgB_Res, sLog = createBrep_RemoveEdges(\r\n            rgB_LastGood,\r\n            [idxEs_Micro[i]],\r\n            bDebug=bDebug)\r\n\r\n        if rgB_Res:\r\n            rgB_LastGood.Dispose()\r\n            rgB_LastGood = rgB_Res\r\n            idxEs_Micro = getMicroEdges(rgB_LastGood)\r\n            print(\"Removed edge {} of {} remaining.\".format(\r\n                i+1, len(idxEs_Micro)))\r\n            if bDupEdgesRemoved:\r\n                sc.doc.Objects.AddCurve(rgB_LastGood.Edges[idxEs_Micro[i]])\r\n            i = 0\r\n        else:\r\n            print(\"Failed to remove edge {} of {} remaining because {}\".format(\r\n                i+1, len(idxEs_Micro), sLog))\r\n            i += 1\r\n\r\n    idxEs_Micro_End = getMicroEdges(rgB_LastGood)\r\n\r\n    if len(idxEs_Micro_End) < len(idxEs_Micro_In):\r\n        sLog = \"Micro-edge count change: {} -> {}\".format(\r\n            len(idxEs_Micro_In), len(idxEs_Micro_End))\r\n        #if bEcho: print(sLog)\r\n        return rgB_LastGood, sLog\r\n\r\n    rgB_LastGood.Dispose()\r\n\r\n    return None, sLog\r\n\r\n\r\ndef processBrepObjects(rdBs_In, fMaxMicroLength, bDupEdgesRemoved=False, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rdBs_In: list(DocObjects.BrepObject)\r\n    \"\"\"\r\n\r\n    gBs_Modified = []\r\n\r\n    sLogs = []\r\n\r\n    for iB, rdB in enumerate(rdBs_In):\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\r\n                prompt=\"Processing brep {} of {} ...\".format(iB+1, len(rdBs_In)))\r\n\r\n        rgB_Res, sLog = createBrep_RemoveMicroEdges(\r\n            rdB.Geometry,\r\n            fMaxMicroLength=fMaxMicroLength,\r\n            bDupEdgesRemoved=bDupEdgesRemoved,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if sLog is not None:\r\n            sLogs.append(sLog)\r\n\r\n        if not rgB_Res:\r\n            continue\r\n\r\n        if sc.doc.Objects.Replace(rdB.Id, brep=rgB_Res):\r\n            gBs_Modified.append(rdB.Id)\r\n            sLogs.append(\"Brep was modified.\".format(rdB.Id))\r\n\r\n    if len(rdBs_In) == 1:\r\n        print(sLogs[0])\r\n    else:\r\n        for sLog in sorted(set(sLogs)):\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n    if not gBs_Modified:\r\n        print(\"No breps were modified.\")\r\n\r\n\r\n    return gBs_Modified\r\n\r\n\r\ndef main():\r\n\r\n    rdBs_In = getInput()\r\n    if rdBs_In is None: return\r\n\r\n    fMaxMicroLength = Opts.values['fMaxMicroLength']\r\n    bDupEdgesRemoved = Opts.values['bDupEdgesRemoved']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processBrepObjects(\r\n        rdBs_In,\r\n        fMaxMicroLength=fMaxMicroLength,\r\n        bDupEdgesRemoved=bDupEdgesRemoved,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}