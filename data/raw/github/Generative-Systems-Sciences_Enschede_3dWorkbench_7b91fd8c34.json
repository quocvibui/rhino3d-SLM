{
  "source_url": "https://github.com/Generative-Systems-Sciences/Enschede_3dWorkbench/blob/3f403a8ee277291103bee7df5379804c7e4231fb/Rhino8Python3/BrepVoxelizationGHPy3.py",
  "repo": "Generative-Systems-Sciences/Enschede_3dWorkbench",
  "repo_stars": 4,
  "repo_description": "An open 3D geospatial twinning and spatial analysis workbench",
  "license": "NOASSERTION",
  "filepath": "Rhino8Python3/BrepVoxelizationGHPy3.py",
  "instruction": "Grasshopper Script",
  "code": "\"\"\"Grasshopper Script\"\"\"\na = \"Hello Python 3 in Grasshopper!\"\nprint(a)\nimport Rhino.Geometry as rg\nimport math\nimport Grasshopper as gh\nprint(type(solid))\n\nRBBox=solid.GetBoundingBox(rg.Plane.WorldXY)#https://developer.rhino3d.com/api/rhinocommon/rhino.geometry.geometrybase/getboundingbox\n\nprint(RBBox.Min)\nprint(RBBox.Max)\n(u,v,w)=(size.X,size.Y,size.Z)\ndiagonalR3=RBBox.Max-RBBox.Min\nprint(diagonalR3)\ndiagonalN3=(round(diagonalR3.X/size.X),round(diagonalR3.Y/size.Y),round(diagonalR3.Z/size.Z))\n# here we make the minimimum corner in Z3\n#creating a minimum corner voxel point in R3 so that the point (0,0,0) in R3 is mapped to (0,0,0) in Z3\nminZ3=RBBox.Min\nminZ3.X=round(minZ3.X/u)\nminZ3.Y=round(minZ3.Y/v)\nminZ3.Z=round(minZ3.Z/w)\nminVoxel=rg.Point3d()\nminVoxel.X=minZ3.X*u\nminVoxel.Y=minZ3.Y*v\nminVoxel.Z=minZ3.Z*w\n\n(m,n,o)=diagonalN3\ntol=10E-3\nprint(m,n,o)\nprint(type(m))\nvoxelPoints=[]\nN3Voxels=[]\ndistances=[]\nfor i in range(m+1):\n    for j in range(n+1):\n        for k in range(o+1):\n            voxelPoint=minVoxel+rg.Point3d(i*u,j*v,k*w)\n            voxelPoints.append(voxelPoint)\n            N3Voxels.append((i,j,k))\n            cPoint=solid.ClosestPoint(voxelPoint)\n            distance=cPoint.DistanceTo(voxelPoint)\n            if (solid.IsPointInside(voxelPoint, tol, True)):\n                distance=-distance\n            distances.append(distance)\na=voxelPoints\nd=distances\n\ndef HeatColourANum(num):\n    grad=gh.GUI.Gradient.GH_Gradient.Heat()\n    grad.Linear=True\n    return grad.ColourAt(num)\n\ndef boxelAVoxel(voxelPoint, voxelSize):\n    '''\n    v7_____________v6  \n    |\\             |\\  \n    | \\            | \\  \n    |  \\ _____________\\  \n    |   v4         |   v5  \n    |   |          |   |  \n    |   |          |   |  \n    v3--|----------v2  |  \n     \\  |           \\  |  \n      \\ |            \\ |  \n       \\|             \\|  \n        v0_____________v1\n    '''\n    u=voxelSize.X/2\n    v=voxelSize.Y/2\n    w=voxelSize.Z/2\n    v0=voxelPoint+rg.Vector3d(-u,-v,-w)\n    v1=voxelPoint+rg.Vector3d(+u,-v,-w)\n    v2=voxelPoint+rg.Vector3d(+u,+v,-w)\n    v3=voxelPoint+rg.Vector3d(-u,+v,-w)\n    v4=voxelPoint+rg.Vector3d(-u,-v,+w)\n    v5=voxelPoint+rg.Vector3d(+u,-v,+w)\n    v6=voxelPoint+rg.Vector3d(+u,+v,+w)\n    v7=voxelPoint+rg.Vector3d(-u,+v,+w)\n    vertices=[v0,v1,v2,v3,v4,v5,v6,v7]\n    box=rg.Mesh.CreateFromBox(vertices,1,1,1)\n    return box\ndef cboxelAVoxel(voxelPoint, voxelSize, colour):\n    '''\n    v7_____________v6  \n    |\\             |\\  \n    | \\            | \\  \n    |  \\ _____________\\  \n    |   v4         |   v5  \n    |   |          |   |  \n    |   |          |   |  \n    v3--|----------v2  |  \n     \\  |           \\  |  \n      \\ |            \\ |  \n       \\|             \\|  \n        v0_____________v1\n    '''\n    u=voxelSize.X/2\n    v=voxelSize.Y/2\n    w=voxelSize.Z/2\n    v0=voxelPoint+rg.Vector3d(-u,-v,-w)\n    v1=voxelPoint+rg.Vector3d(+u,-v,-w)\n    v2=voxelPoint+rg.Vector3d(+u,+v,-w)\n    v3=voxelPoint+rg.Vector3d(-u,+v,-w)\n    v4=voxelPoint+rg.Vector3d(-u,-v,+w)\n    v5=voxelPoint+rg.Vector3d(+u,-v,+w)\n    v6=voxelPoint+rg.Vector3d(+u,+v,+w)\n    v7=voxelPoint+rg.Vector3d(-u,+v,+w)\n    vertices=[v0,v1,v2,v3,v4,v5,v6,v7]\n    box=rg.Mesh.CreateFromBox(vertices,1,1,1)\n    box.VertexColors.CreateMonotoneMesh(colour)\n    return box\ndef remapNumbers(nums):\n    #remaps numbers into a range starting from the minimum and ending with the maximum of the list\n    remappedNs=[]\n    maxN=max(nums)\n    minN=min(nums)\n    for num in nums:\n        remappedN=(num-minN)/(maxN-minN)\n        remappedNs.append(remappedN)\n    return remappedNs\nremappedDists=remapNumbers(distances)\ncolours=[]\nfor remappedDist in remappedDists:\n    colour=HeatColourANum(remappedDist)\n    colours.append(colour)\nr=remappedDists#\ncolouredBoxes=[]\nfor i in range(len(distances)):\n    colouredBox=cboxelAVoxel(voxelPoints[i],size,HeatColourANum(remappedDists[i]))\n    colouredBoxes.append(colouredBox)\nc=colouredBoxes\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}