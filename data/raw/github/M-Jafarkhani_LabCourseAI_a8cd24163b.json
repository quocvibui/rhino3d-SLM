{
  "source_url": "https://github.com/M-Jafarkhani/LabCourseAI/blob/7dfca840b9f213e2ac7e31bc7893f11236b11560/FinalProject/SyntheticDataset/graph_builder.py",
  "repo": "M-Jafarkhani/LabCourseAI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "FinalProject/SyntheticDataset/graph_builder.py",
  "instruction": "Graph builder",
  "code": "import Rhino.Geometry as rg\nimport math\nimport json\n\nfrom rdflib import Graph, Namespace, RDF, URIRef, Literal\nfrom rdflib.namespace import XSD, RDFS\n\nBOT = Namespace(\"https://w3id.org/bot#\")\nGEO = Namespace(\"http://example.org/geo#\")\n\nclass GraphBuilder:\n    def __init__(self, building, base_uri=\"http://example.org/building/\"):\n        self.building = building\n        self.base_uri = base_uri\n        self.graph = Graph()\n        self.graph.bind(\"bot\", BOT)\n        self.graph.bind(\"geo\", GEO)\n        self.boxes = []\n\n    def build(self):\n        self._add_building()\n        self._add_site()\n        self._add_storeys()\n        self._add_slabs()\n        self._add_walls()\n        self._add_columns()\n\n    def _make_uri(self, fragment):\n        return URIRef(self.base_uri + fragment)\n\n    def _add_building(self):\n        building_uri = self._make_uri(\"building\")\n        volume = getattr(self.building, \"volume\", None)\n        self.graph.add((building_uri, RDF.type, BOT.Building))\n        self.graph.add((building_uri, RDFS.label, Literal(\"Building\")))\n        if volume is not None:\n            self._serialize_geometry(building_uri, volume)\n\n    def _add_site(self):\n        if not self.building.site:\n            return\n        site_uri = self._make_uri(\"site\")\n        self.graph.add((site_uri, RDF.type, BOT.Site))\n        self.graph.add((self._make_uri(\"building\"), BOT.hasSite, site_uri))\n\n    def _add_storeys(self):\n        if not hasattr(self.building, \"storeys\"):\n            return\n        for idx, storey in enumerate(self.building.storeys):\n            storey_uri = self._make_uri(f\"storey_{idx+1}\")\n            self.graph.add((storey_uri, RDF.type, BOT.Storey))\n            self.graph.add((storey_uri, RDFS.label, Literal(f\"Storey {idx+1}\")))\n            self._serialize_geometry(storey_uri, storey)\n            self.graph.add((self._make_uri(\"building\"), BOT.hasStorey, storey_uri))\n\n    def _add_slabs(self):\n        if not hasattr(self.building, \"slabs\"):\n            return\n\n        num_storeys = len(getattr(self.building, \"storeys\", []))\n\n        # Floor slab\n        floor_slab = getattr(self.building, \"floor_slab\", None)\n        if floor_slab is not None:\n            slab_uri = self._make_uri(\"floor_slab\")\n            self.graph.add((slab_uri, RDF.type, BOT.Element))\n            self.graph.add((slab_uri, RDFS.label, Literal(\"Floor Slab\")))\n            self._serialize_geometry(slab_uri, floor_slab)\n            # Contained in first storey\n            storey_uri = self._make_uri(\"storey_1\")\n            self.graph.add((storey_uri, BOT.containsElement, slab_uri))\n\n        # Intermediate slabs (contained in next storey, adjacent to previous)\n        for idx, slab in enumerate(self.building.slabs):\n            slab_uri = self._make_uri(f\"slab_{idx+1}\")\n            self.graph.add((slab_uri, RDF.type, BOT.Element))\n            self.graph.add((slab_uri, RDFS.label, Literal(f\"Slab {idx+1}\")))\n            self._serialize_geometry(slab_uri, slab)\n            # Contained in the next storey (storey_{idx+2}), if exists\n            storey_contain_idx = idx + 2\n            if storey_contain_idx <= num_storeys:\n                storey_uri = self._make_uri(f\"storey_{storey_contain_idx}\")\n                self.graph.add((storey_uri, BOT.containsElement, slab_uri))\n            # Adjacent to previous storey (storey_{idx+1})\n            if idx + 1 <= num_storeys:\n                prev_storey_uri = self._make_uri(f\"storey_{idx+1}\")\n                self.graph.add((slab_uri, BOT.adjacentElement, prev_storey_uri))\n\n        # Roof slab\n        roof_slab = getattr(self.building, \"roof_slab\", None)\n        if roof_slab is not None:\n            slab_uri = self._make_uri(\"roof_slab\")\n            self.graph.add((slab_uri, RDF.type, BOT.Element))\n            self.graph.add((slab_uri, RDFS.label, Literal(\"Roof Slab\")))\n            self._serialize_geometry(slab_uri, roof_slab)\n            # Adjacent to the last storey\n            if num_storeys > 0:\n                last_storey_uri = self._make_uri(f\"storey_{num_storeys}\")\n                self.graph.add((slab_uri, BOT.adjacentElement, last_storey_uri))\n\n    def _add_walls(self):\n        if not hasattr(self.building, \"walls\"):\n            return\n        num_storeys = len(getattr(self.building, \"storeys\", []))\n        for storey_idx, walls_in_storey in enumerate(self.building.walls):\n            storey_uri = self._make_uri(f\"storey_{storey_idx+1}\")\n            # Identify relevant slabs for adjacency\n            # Slab below: floor_slab for first storey, slab_{storey_idx} for others\n            if storey_idx == 0:\n                slab_below_uri = self._make_uri(\"floor_slab\")\n            else:\n                slab_below_uri = self._make_uri(f\"slab_{storey_idx}\")\n            # Slab above: slab_{storey_idx+1}, unless last storey then roof_slab\n            if storey_idx + 1 < num_storeys:\n                slab_above_uri = self._make_uri(f\"slab_{storey_idx+1}\")\n            else:\n                slab_above_uri = self._make_uri(\"roof_slab\")\n            for wall_idx, wall in enumerate(walls_in_storey):\n                wall_uri = self._make_uri(f\"storey_{storey_idx+1}_wall_{wall_idx+1}\")\n                self.graph.add((wall_uri, RDF.type, BOT.Element))\n                self.graph.add((wall_uri, RDFS.label, Literal(\"Wall\")))\n                self._serialize_geometry(wall_uri, wall)\n                self.graph.add((storey_uri, BOT.containsElement, wall_uri))\n                # Add adjacency to slabs\n                self.graph.add((wall_uri, BOT.adjacentElement, slab_below_uri))\n                self.graph.add((wall_uri, BOT.adjacentElement, slab_above_uri))\n\n    def _add_columns(self):\n        if not hasattr(self.building, \"columns\"):\n            return\n        num_storeys = len(getattr(self.building, \"storeys\", []))\n        for storey_idx, columns_in_storey in enumerate(self.building.columns):\n            storey_uri = self._make_uri(f\"storey_{storey_idx+1}\")\n            # Identify relevant slabs for adjacency\n            # Slab below: floor_slab for first storey, slab_{storey_idx} for others\n            if storey_idx == 0:\n                slab_below_uri = self._make_uri(\"floor_slab\")\n            else:\n                slab_below_uri = self._make_uri(f\"slab_{storey_idx}\")\n            # Slab above: slab_{storey_idx+1}, unless last storey then roof_slab\n            if storey_idx + 1 < num_storeys:\n                slab_above_uri = self._make_uri(f\"slab_{storey_idx+1}\")\n            else:\n                slab_above_uri = self._make_uri(\"roof_slab\")\n            for column_idx, column in enumerate(columns_in_storey):\n                column_uri = self._make_uri(f\"storey_{storey_idx+1}_column_{column_idx+1}\")\n                self.graph.add((column_uri, RDF.type, BOT.Element))\n                self.graph.add((column_uri, RDFS.label, Literal(\"Column\")))\n                self._serialize_geometry(column_uri, column)\n                self.graph.add((storey_uri, BOT.containsElement, column_uri))\n                # Add adjacency to slabs\n                self.graph.add((column_uri, BOT.adjacentElement, slab_below_uri))\n                self.graph.add((column_uri, BOT.adjacentElement, slab_above_uri))\n\n    def _serialize_geometry(self, element_uri, geometry):\n\n        def minimal_volume_bbox(geometry, angle_step=0.1, angle_max=2*math.pi):\n            \"\"\"\n            Finds the rotation around world Z that yields the minimal bounding box volume for geometry.\n            Uses plane rotation, not geometry rotation.\n            Returns: (location: rg.Point3d, angle: float, size: rg.Vector3d)\n            \"\"\"\n            min_volume = float(\"inf\")\n            min_angle = 0.0\n            min_box = None\n\n            geometry = rg.Mesh.CreateFromBrep(geometry, rg.MeshingParameters.Default)[0]\n\n            for i in range(int(angle_max / angle_step)):\n                angle = i * angle_step\n                # Create a rotated plane around world Z at origin\n                plane = rg.Plane.WorldXY\n                xform = rg.Transform.Rotation(angle, rg.Vector3d.ZAxis, rg.Point3d(0, 0, 0))\n                plane_rot = plane\n                plane_rot.Transform(xform)\n                # Get the oriented bounding box in world coordinates\n                oriented_box = geometry.GetBoundingBox(plane_rot)\n                # oriented_box is a Rhino.Geometry.Box\n                # Compute size vector\n                volume = oriented_box.Volume\n                if volume < min_volume:\n                    min_volume = volume\n                    min_angle = angle\n                    min_box = oriented_box\n\n            if min_box is None:\n                # fallback to axis-aligned\n                bbox = geometry.GetBoundingBox(True)\n                location = bbox.Min\n                size = bbox.Max - bbox.Min\n                return location, 0.0, size\n\n            # Use box's corner (origin) as location\n            location = min_box.PointAt(0,0,0)\n            size = min_box.Diagonal\n\n            plane = rg.Plane.WorldXY\n            plane.Rotate(min_angle, rg.Vector3d.ZAxis)    \n            self.boxes.append(rg.Box(plane, min_box))\n\n            return location, min_angle, size\n\n        location, angle, size = minimal_volume_bbox(geometry)\n        self.graph.add((element_uri, GEO.hasLocation, Literal(f\"{location.X},{location.Y},{location.Z}\", datatype=XSD.string)))\n        self.graph.add((element_uri, GEO.hasRotation, Literal(angle, datatype=XSD.double)))\n        self.graph.add((element_uri, GEO.hasSize, Literal(f\"{size.X},{size.Y},{size.Z}\", datatype=XSD.string)))\n\n    def export_json(self):\n        \"\"\"\n        Export building elements (except site) to a JSON structure with IRI, label, and serialization.\n        \"\"\"\n        result = []\n        # Gather all nodes except site\n        site_uri = self._make_uri(\"site\")\n\n        # Find all relevant nodes\n        for subj in set(self.graph.subjects()):\n            if subj == site_uri:\n                continue\n            # Only include nodes that have geometry serialization or a label (not blank nodes)\n            # Get IRI\n            iri = str(subj)\n            # Get label (if exists)\n            label = None\n            for l in self.graph.objects(subj, RDFS.label):\n                label = str(l)\n                break\n            # Get serialization (geometry)\n            location = None\n            for loc in self.graph.objects(subj, GEO.hasLocation):\n                location = str(loc)\n                break\n            rotation = None\n            for rot in self.graph.objects(subj, GEO.hasRotation):\n                rotation = float(rot)\n                break\n            size = None\n            for sz in self.graph.objects(subj, GEO.hasSize):\n                size = str(sz)\n                break\n            serialization = {\n                \"rotation\": rotation,\n                \"location\": location,\n                \"size\": size\n            } if location or rotation or size else None\n\n            # Only add if there is geometry serialization\n            if serialization and (serialization[\"location\"] or serialization[\"rotation\"] or serialization[\"size\"]):\n                entry = {\n                    \"iri\": iri,\n                    \"label\": label,\n                    \"serialization\": serialization\n                }\n                result.append(entry)\n\n        return json.dumps(result, indent=2)\n\n    def export(self, format=\"turtle\"):\n        ttl = self.graph.serialize(format=format)\n        if isinstance(ttl, bytes):\n            ttl = ttl.decode(\"utf-8\")\n        return ttl\n\n\nGraph = GraphBuilder(building)\nGraph.build()\nttl = str(Graph.export())\njson = str(Graph.export_json())\ngeo = Graph.boxes\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}