{
  "source_url": "https://github.com/evdanil/cn-tool/blob/d83b0c68efb5aaf10f09f1b77ddd5c992157f4af/utils/email_helper.py",
  "repo": "evdanil/cn-tool",
  "repo_stars": 1,
  "repo_description": "Utility allowing to receive information from Infoblox API",
  "license": "unknown",
  "filepath": "utils/email_helper.py",
  "instruction": "Email helper",
  "code": "from __future__ import annotations\nimport smtplib\nimport logging\nfrom pathlib import Path\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.mime.base import MIMEBase\nfrom email import encoders\nfrom typing import Any, Optional\n\nfrom core.base import ScriptContext\n\n\ndef send_report_email(\n    logger: logging.Logger,\n    smtp_server: str,\n    smtp_port: int,\n    sender_email: str,\n    receiver_email: str,\n    subject: str,\n    body: str,\n    attachment_path: Path,\n    use_tls: bool = False,\n    use_ssl: bool = False,\n    use_auth: bool = False,\n    username: str = \"\",\n    password: str = \"\",\n) -> bool:\n    \"\"\"\n    Connects to an SMTP server and sends an email with an attachment,\n    with optional authentication.\n    \"\"\"\n    # Attachment logic is unchanged...\n    if not attachment_path.is_file():\n        logger.error(f\"EMAIL: Attachment file not found at {attachment_path}\")\n        return False\n    msg = MIMEMultipart()\n    msg['From'] = sender_email\n    msg['To'] = receiver_email\n    msg['Subject'] = subject\n    msg.attach(MIMEText(body, 'plain'))\n    try:\n        with open(attachment_path, \"rb\") as attachment:\n            part = MIMEBase(\"application\", \"octet-stream\")\n            part.set_payload(attachment.read())\n        encoders.encode_base64(part)\n        part.add_header(\"Content-Disposition\", f\"attachment; filename= {attachment_path.name}\")\n        msg.attach(part)\n    except Exception as e:\n        logger.error(f\"EMAIL: Error attaching file: {e}\")\n        return False\n\n    # --- Send the email ---\n    server = None\n    try:\n        logger.info(f\"EMAIL: Connecting to SMTP server {smtp_server}:{smtp_port}...\")\n        if use_ssl:\n            server = smtplib.SMTP_SSL(smtp_server, smtp_port)\n            logger.info(\"EMAIL: Connected using SSL.\")\n        else:\n            server = smtplib.SMTP(smtp_server, smtp_port)\n            logger.info(\"EMAIL: Connected.\")\n            if use_tls:\n                logger.info(\"EMAIL: Starting TLS...\")\n                server.starttls()\n                logger.info(\"EMAIL: TLS started.\")\n\n        # <<< NEW LOGIN LOGIC >>>\n        if use_auth:\n            if username and password:\n                logger.info(\"EMAIL: Logging in with provided credentials...\")\n                server.login(username, password)\n                logger.info(\"EMAIL: Login successful.\")\n            else:\n                logger.warning(\"EMAIL: 'use_auth' is true, but username or password is missing. Attempting unauthenticated.\")\n        else:\n            logger.info(\"EMAIL: Proceeding without login (as configured).\")\n\n        # The rest of the sending logic\n        text = msg.as_string()\n        server.sendmail(sender_email, receiver_email, text)\n        logger.info(f\"EMAIL: Email successfully sent to {receiver_email}!\")\n        return True\n\n    except smtplib.SMTPAuthenticationError:\n        logger.error(\"EMAIL: SMTP Authentication Error. Check username/password and server settings (e.g., App Passwords).\")\n    except smtplib.SMTPConnectError:\n        logger.error(f\"EMAIL: SMTP Connect Error. Failed to connect to {smtp_server}:{smtp_port}.\")\n    except Exception as e:\n        logger.error(f\"EMAIL: An unexpected error occurred: {e}\")\n    finally:\n        if server:\n            logger.info(\"EMAIL: Closing SMTP connection.\")\n            server.quit()\n\n    return False\n\n\ndef interpret_bool(value: Any) -> bool:\n    \"\"\"Return True when a string or primitive represents a truthy value.\"\"\"\n    if isinstance(value, str):\n        return value.strip().lower() in {\"true\", \"1\", \"t\", \"y\", \"yes\", \"on\"}\n    return bool(value)\n\n\ndef send_configured_report(\n    ctx: ScriptContext,\n    report_path: Any,\n    receiver: Optional[str],\n    *,\n    prefix: str = \"EMAIL\",\n    success_message: Optional[str] = None,\n    failure_message: Optional[str] = None,\n) -> bool:\n    \"\"\"Send the configured report and perform optional post-send cleanup.\"\"\"\n    logger = ctx.logger\n    console = getattr(ctx, \"console\", None)\n\n    def _console_print(message: str) -> None:\n        if console:\n            console.print(message)\n\n    if not receiver:\n        logger.warning(\"%s: No recipient configured; skipping email.\", prefix)\n        _console_print(\"[red]Error: Email recipient is not configured. Please set 'to' in the [email] section of your config.[/red]\")\n        return False\n\n    if isinstance(report_path, str):\n        report_path = Path(report_path).expanduser()\n    if not isinstance(report_path, Path) or not report_path.is_file():\n        logger.warning(\"%s: Report file not found at '%s'. Cannot send email.\", prefix, report_path)\n        _console_print(f\"[red]Error: Report file not found at '{report_path}'. Please generate a report first.[/red]\")\n        return False\n\n    success = send_report_email(\n        logger=logger,\n        smtp_server=ctx.cfg.get(\"email_server\", \"\"),\n        smtp_port=int(ctx.cfg.get(\"email_port\", 25)),\n        sender_email=ctx.cfg.get(\"email_from\", \"\"),\n        receiver_email=receiver,\n        subject=ctx.cfg.get(\"email_subject\", \"\"),\n        body=ctx.cfg.get(\"email_body\", \"\"),\n        attachment_path=report_path,\n        use_tls=interpret_bool(ctx.cfg.get(\"email_use_tls\", False)),\n        use_ssl=interpret_bool(ctx.cfg.get(\"email_use_ssl\", False)),\n        use_auth=interpret_bool(ctx.cfg.get(\"email_use_auth\", False)),\n        username=ctx.cfg.get(\"email_user\", \"\"),\n        password=ctx.cfg.get(\"email_password\", \"\"),\n    )\n\n    if success:\n        if success_message:\n            _console_print(success_message)\n        delete_after = interpret_bool(ctx.cfg.get(\"email_delete_after_send\", False))\n        logger.info(\"%s: delete_after_send flag evaluated to %s\", prefix, delete_after)\n        if delete_after:\n            try:\n                if report_path.exists():\n                    report_path.unlink()\n                    _console_print(\"[green]Report deleted after successful email delivery.[/green]\")\n                    logger.info(\"%s: Report deleted after successful delivery.\", prefix)\n                else:\n                    logger.info(\"%s: Report already removed or missing; nothing to delete.\", prefix)\n            except OSError as exc:\n                logger.warning(\"%s: Failed to delete report after emailing: %s\", prefix, exc)\n                _console_print(\"[yellow]Report email sent, but the report could not be deleted.[/yellow]\")\n    else:\n        if failure_message:\n            _console_print(failure_message)\n\n    return success\n\n",
  "language": "python",
  "imports": [],
  "has_docstring": false
}