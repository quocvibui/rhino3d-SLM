{
  "source_url": "https://github.com/gbjun7333/P_max_calculator/blob/8844e2d7a8f3bd7c387827d6a834114aa901129d/grasshopper/parking/matcher.py",
  "repo": "gbjun7333/P_max_calculator",
  "repo_stars": 0,
  "repo_description": "parking capacity calculation system",
  "license": "MIT",
  "filepath": "grasshopper/parking/matcher.py",
  "instruction": "도로-필지 매칭 모듈",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"\n도로-필지 매칭 모듈\n\n지적 데이터(Lot, Road)와 건축물대장(GeoDataFrame)을 연결하여\n주차대수 계산에 필요한 정보를 조합합니다.\n\"\"\"\nfrom __future__ import annotations\n\nimport importlib\nfrom typing import Dict, List, Optional, Tuple\n\nimport geopandas as gpd\nimport pandas as pd\nimport Rhino.Geometry as geo\n\nimport utils\nfrom units import Lot, Road\n\nimportlib.reload(utils)\n\n\nclass RoadMatcher:\n    \"\"\"도로-필지 매칭 클래스\n\n    PNU 기반으로 Lot과 Building을 조인하고,\n    공간 인접성을 이용하여 각 필지에 접한 도로를 찾습니다.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def match_buildings_to_lots(\n        self,\n        lots: List[Lot],\n        buildings_gdf: gpd.GeoDataFrame\n    ) -> List[Dict]:\n        \"\"\"건축물대장과 지적 필지를 PNU 기준으로 조인\n\n        Args:\n            lots: Lot 객체 리스트 (지적)\n            buildings_gdf: 건축물대장 GeoDataFrame\n\n        Returns:\n            matched_data: 매칭된 데이터 리스트\n                [{'lot': Lot, 'building_info': dict}, ...]\n        \"\"\"\n        print(f\"[RoadMatcher] 필지-건물 매칭 시작...\")\n        print(f\"[RoadMatcher]   필지 수: {len(lots)}\")\n        print(f\"[RoadMatcher]   건물 수: {len(buildings_gdf)}\")\n\n        # PNU 기준 딕셔너리 생성\n        lot_dict = {lot.pnu: lot for lot in lots if lot.pnu}\n\n        matched_data = []\n        unmatched_count = 0\n\n        for idx, building_row in buildings_gdf.iterrows():\n            building_pnu = str(building_row.get('pnu', ''))\n\n            if not building_pnu or building_pnu not in lot_dict:\n                unmatched_count += 1\n                continue\n\n            lot = lot_dict[building_pnu]\n\n            # Building row를 dict로 변환\n            building_info = building_row.to_dict()\n\n            matched_data.append({\n                'lot': lot,\n                'building_info': building_info\n            })\n\n        print(f\"[RoadMatcher] 매칭 완료: {len(matched_data)}개\")\n        print(f\"[RoadMatcher] 미매칭: {unmatched_count}개\")\n\n        return matched_data\n\n    def find_adjacent_roads(\n        self,\n        lot: Lot,\n        roads: List[Road],\n        threshold: float = 0.1\n    ) -> List[Road]:\n        \"\"\"필지에 인접한 도로 찾기\n\n        Args:\n            lot: 대지 Lot 객체\n            roads: Road 객체 리스트\n            threshold: 인접 판정 거리 (m)\n\n        Returns:\n            adjacent_roads: 인접한 도로 리스트\n        \"\"\"\n        adjacent_roads = []\n\n        for road in roads:\n            # 두 영역이 교차하거나 매우 가까이 있는지 확인\n            if utils.has_region_intersection(lot.region, road.region):\n                adjacent_roads.append(road)\n            else:\n                # 거리 체크\n                distance = utils.get_distance_between_curves(lot.region, road.region)\n                if distance <= threshold:\n                    adjacent_roads.append(road)\n\n        return adjacent_roads\n\n    def calculate_road_width(self, road: Road) -> float:\n        \"\"\"도로 폭 계산\n\n        도로 polygon의 면적을 둘레로 나눈 근사값 사용\n        (실제로는 더 정교한 계산 필요하지만, 간단한 추정)\n\n        Args:\n            road: Road 객체\n\n        Returns:\n            width: 도로 폭 (m)\n        \"\"\"\n        try:\n            area = utils.get_area(road.region)\n            perimeter = road.region.GetLength()\n\n            if perimeter <= 0:\n                return 6.0  # 기본값\n\n            # 면적 / (둘레/2) ≈ 평균 폭\n            width = (2.0 * area) / perimeter\n\n            # 현실적인 범위로 제한\n            width = max(2.0, min(width, 50.0))\n\n            return round(width, 2)\n\n        except Exception:\n            return 6.0  # 오류 시 기본값\n\n    def get_primary_road_width(\n        self,\n        lot: Lot,\n        roads: List[Road]\n    ) -> float:\n        \"\"\"필지의 주 도로 폭 결정\n\n        여러 도로가 인접한 경우, 가장 넓은 도로를 선택\n\n        Args:\n            lot: 대지 Lot 객체\n            roads: 전체 Road 리스트\n\n        Returns:\n            road_width: 주 도로 폭 (m)\n        \"\"\"\n        adjacent_roads = self.find_adjacent_roads(lot, roads)\n\n        if not adjacent_roads:\n            print(f\"[RoadMatcher] 경고: {lot.pnu} - 인접 도로 없음, 기본값 6.0m 사용\")\n            return 6.0\n\n        # 각 도로 폭 계산 후 최대값 선택\n        road_widths = [self.calculate_road_width(road) for road in adjacent_roads]\n        max_width = max(road_widths)\n\n        return max_width\n\n    def enrich_matched_data(\n        self,\n        matched_data: List[Dict],\n        roads: List[Road]\n    ) -> List[Dict]:\n        \"\"\"매칭된 데이터에 도로 정보 추가\n\n        Args:\n            matched_data: match_buildings_to_lots() 결과\n            roads: Road 객체 리스트\n\n        Returns:\n            enriched_data: 도로 정보가 추가된 데이터\n        \"\"\"\n        print(f\"[RoadMatcher] 도로 정보 추가 중...\")\n\n        for data in matched_data:\n            lot = data['lot']\n            road_width = self.get_primary_road_width(lot, roads)\n            data['road_width'] = road_width\n\n        print(f\"[RoadMatcher] 도로 정보 추가 완료\")\n\n        return matched_data\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}