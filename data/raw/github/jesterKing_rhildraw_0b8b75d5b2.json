{
  "source_url": "https://github.com/jesterKing/rhildraw/blob/e49381144a18379a01596972a2431e7ef828f180/src/rhildraw.py",
  "repo": "jesterKing/rhildraw",
  "repo_stars": 1,
  "repo_description": "LDraw importer for Rhino 3D. Literate Programming",
  "license": "MIT",
  "filepath": "src/rhildraw.py",
  "instruction": "DO NOT EDIT THIS FILE DIRECTLY. This is generated from a literate program of this script with the help of the Literate Programming extension for Visual Studio Code written by Nathan Letwory. If you want to contribute install the Literate Programming extension for Visual Studio Code from https://marketplace.visualstudio.com/items?itemName=jesterking.literate and edit the .literate files in this repository instead. The source code repository is at https://github.com/jesterKing/rhildraw The code, literate and generated, is licensed under MIT license. See https://github.com/jesterKing/rhildraw/LICENSE for more details. Or you can read the HTML rendered documentation at https://jesterking.github.io/rhildraw",
  "code": "#! python3\n\n# DO NOT EDIT THIS FILE DIRECTLY. This is generated from a literate program of\n# this script with the help of the Literate Programming extension for Visual\n# Studio Code written by Nathan Letwory.\n#\n# If you want to contribute install the Literate Programming extension for\n# Visual Studio Code from\n# https://marketplace.visualstudio.com/items?itemName=jesterking.literate and\n# edit the .literate files in this repository instead.\n#\n# The source code repository is at https://github.com/jesterKing/rhildraw\n#\n# The code, literate and generated, is licensed under MIT license. See\n# https://github.com/jesterKing/rhildraw/LICENSE for more details.\n#\n# Or you can read the HTML rendered documentation at\n# https://jesterking.github.io/rhildraw\n#\n\nimport traceback\nimport sys\nimport scriptcontext as sc\nimport math\n\nfrom typing import Mapping, List\n\nimport Rhino\n\nfrom Rhino.Geometry import Transform, Mesh, Vector3f, Point3f, MeshFace\nfrom Rhino.Display import Color4f\nfrom Rhino.DocObjects import ObjectAttributes, ObjectMaterialSource\nfrom Rhino.DocObjects import InstanceDefinition\nfrom Rhino.Render import ChildSlotNames, ContentUuids, RenderContentType\n\nPbrNames = ChildSlotNames.PhysicallyBased\nrhmath = Rhino.RhinoMath\n\nfrom System.IO import DirectoryInfo, Directory, File, FileInfo\nfrom System.IO import EnumerationOptions, SearchOption\n\nfrom pathlib import Path\nfrom enum import Enum\n\nclass Winding(Enum):\n    CW = 1\n    CCW = 2\n\n    def is_ccw(self):\n        return self == Winding.CCW\n        #return self.value == 2\n\n    def is_cw(self):\n        return self == Winding.CW\n        # return self.value == 1\n\n    def flip(self):\n        return Winding.CW if self == Winding.CCW else Winding.CCW\n\nclass LDrawFile:\n    def __init__(self, path : Path, data : List[str] = []):\n        self.commands = data\n        self.path = path\n        self.name = path.name\n        self.suffix = path.suffix\n        self.pname = f\"{path.parent.name}\\\\{self.name}\"\n        self.ppname = f\"{path.parent.parent.name}\\\\{path.parent.name}\\\\{self.name}\"\n    def get_commands(self):\n        if len(self.commands)==0 and not self.is_3dm():\n            with self.path.open(encoding=\"utf-8\") as f:\n                cmds = [l.strip() for l in f.readlines()]\n                cmds = [c for c in cmds if len(c) > 0]\n                self.commands = cmds\n    \n        return self.commands\n\n    def __repr__(self):\n        if self.is_3dm():\n            return f\"LDrawFile '{self.name}', a Rhino 3d file.\"\n        else:\n            return f\"LDrawFile '{self.name}', {len(self.get_commands())} commands.\"\n\n    def is_ccw_winding(self):\n        if self.is_3dm():\n            return\n        cmds = self.get_commands()\n        for cmd in cmds:\n            if cmd.startswith('0') and 'BFC' in cmd and 'CCW' in cmd:\n                return True\n\n        return False\n\n    def is_3dm(self):\n        return self.suffix == '.3dm'\nclass LDrawMaterial:\n    def __init__(self, props):\n        self.properties = props\n        self.name = props[\"COLOUR\"]\n        self.render_material = None\n\n    def _get_color4f(self, colstr):\n        colstr = colstr[1:]\n        r = int(colstr[0:2], 16) / 255.0\n        g = int(colstr[2:4], 16) / 255.0\n        b = int(colstr[4:6], 16) / 255.0\n        return Color4f(r, g, b, 1.0)\n\n    def _alpha(self, alphastr):\n        alpha = 1.0 - (float(alphastr) / 255.0)\n        return alpha\n\n    def get_render_material(self):\n        if self.render_material == None:\n\n            raise Exception(f\"Material non-existant: {self.name}\")\n        return self.render_material\n\n    def create_render_material(self):\n        for rm in sc.doc.RenderMaterials:\n            if rm.Name == self.name:\n                self.render_material = rm\n                return\n        pbr_rm = RenderContentType.NewContentFromTypeId(pbr_guid)\n\n        _basecolor = self._get_color4f(self.properties[\"VALUE\"])\n\n        _roughness = 0.2\n        _metallic = 0.0\n        _opacity = 1.0\n\n        if \"ALPHA\" in self.properties:\n            _opacity = self._alpha(self.properties[\"ALPHA\"])\n            _roughness = 0.03\n\n        if \"METAL\" in self.properties or \"CHROME\" in self.properties:\n            _metallic = 1.0\n            _roughness = 0.03\n        if \"MATTE_METALLIC\" in self.properties:\n            _metallic = 1.0\n            _roughness = 0.3\n\n        pbr_rm.SetParameter(PbrNames.BaseColor, _basecolor)\n        pbr_rm.SetParameter(PbrNames.Opacity, _opacity)\n        pbr_rm.SetParameter(PbrNames.Metallic, _metallic)\n        pbr_rm.SetParameter(PbrNames.Roughness, _roughness)\n\n        pbr_rm.Name = self.name\n        self.render_material = pbr_rm\n        sc.doc.RenderMaterials.Add(pbr_rm)\n\n\n\n# Globals\nvfiles: Mapping[str, LDrawFile]= dict()\nidefs : Mapping[str, InstanceDefinition]= dict()\nmaterials : Mapping[str, LDrawMaterial]= dict()\nvertidx = 0\npbr_guid = ContentUuids.PhysicallyBasedMaterialType\n\ndef refresh():\n    sc.doc.Views.Redraw()\n    Rhino.RhinoApp.Wait()\n\nclass LegoXform:\n    def __init__(self, data : str):\n        data = data.strip()\n        if len(data) > 0:\n            try:\n                d = [float(f) for f in data.split()[2:14]]\n                self.x = d[0]\n                self.y = d[1]\n                self.z = d[2]\n                self.a = d[3]\n                self.b = d[4]\n                self.c = d[5]\n                self.d = d[6]\n                self.e = d[7]\n                self.f = d[8]\n                self.g = d[9]\n                self.h = d[10]\n                self.i = d[11]\n                xform : Transform = Transform.Identity\n                xform.M00 = self.a\n                xform.M01 = self.b\n                xform.M02 = self.c\n                xform.M03 = self.x\n                xform.M10 = self.d\n                xform.M11 = self.e\n                xform.M12 = self.f\n                xform.M13 = self.y\n                xform.M20 = self.g\n                xform.M21 = self.h\n                xform.M22 = self.i\n                xform.M23 = self.z\n                self.xform = xform\n            except Exception as e:\n                self.xform = Transform.Identity\n        else:\n            self.xform = Transform.Identity\n\n    def set_xform(self, xform):\n        self.xform = xform\n\n    def transform_point(self, u : float, v : float, w : float):\n        p = Point3f(u, v, w)\n        p.Transform(self.xform)\n        return [p.X, p.Y, p.Z]\n\n    def get_xform(self):\n        return self.xform\n\n\nrhino_orient = LegoXform(\"\")\nrhino_orient.set_xform(\n    Transform.Rotation(\n        rhmath.ToRadians(-90.0),\n        Vector3f.XAxis,\n        Point3f.Origin\n    )\n)\nid_xform = LegoXform(\"\")\n\ndef clean_name(part_name):\n    part_name = part_name.removesuffix(\".dat\")\n    part_name = part_name.removesuffix(\".DAT\")\n    part_name = part_name.removesuffix(\".ldr\")\n    part_name = part_name.removesuffix(\".LDR\")\n    return part_name\n\ndef prepare_parts_dictionary():\n    global lib_path, vfiles\n    library_path : Path = Path(lib_path)\n    library_path_net : DirectoryInfo = DirectoryInfo(lib_path)\n    all_parts_net = library_path_net.EnumerateFiles(\"*\", SearchOption.AllDirectories)\n    for p in all_parts_net:\n        fn = Path(p.FullName)\n        if fn.suffix.lower() in ('.txt', '.zip', '.exe', '.DS_Store'):\n            continue\n\n        if len(fn.suffix) > 0 and fn.suffix.lower() in ('.3dm'):\n            print(f'Adding {fn}')\n\n        ldrawfile = LDrawFile(fn)\n        vfiles[ldrawfile.name] = ldrawfile\n        vfiles[ldrawfile.pname] = ldrawfile\n\n        if ldrawfile.is_3dm():\n            print(f'\\t{ldrawfile} .. [{ldrawfile.name}] :: {vfiles[ldrawfile.name]}')\n\ndef prepare_idefs_dictionary():\n    for idef in sc.doc.InstanceDefinitions:\n        idefs[idef.Name] = idef\n\ndef update_idefs_dictionary(part_name):\n    idef_part_name = clean_name(part_name)\n    idef = sc.doc.InstanceDefinitions.Find(idef_part_name)\n    if idef:\n        idefs[idef_part_name] = idef\n        return idef\n    return None\n\ndef apply_transforms(v, xforms):\n    for xform in xforms:\n        v = xform.transform_point(*v)\n    return v\n\ndef collate_transforms(xforms):\n   xform = Transform.Identity\n   for _xform in xforms:\n       xform = xform * _xform.get_xform()\n\n   return xform\n\ndef add_poly(m : Mesh, cmd : str, xforms : list, from_winding = Winding.CCW, winding = Winding.CCW):\n    global vertidx\n    stride = 3\n    start = 2\n    vertices = int(cmd[0])\n    elements = vertices * stride\n    to = start + vertices * stride\n    d = cmd.split()[start:to]\n    try:\n        d = [float(f) for f in d]\n    except Exception:\n        return\n    #print(f\"Add poly with {vertices} vertices with from_winding {from_winding} -> winding {winding}\")\n    vidxs = list()\n    for i in range(0, elements, stride):\n        V = apply_transforms(d[i:i+stride], xforms)\n        m.Vertices.Add(*V)\n        vidxs.append(vertidx)\n        vertidx += 1\n    \n    if len(vidxs) == 4 and from_winding == winding:\n        #print(f\"A: {vidxs}\")\n        rev = vidxs[1:]\n        rev.reverse()\n        vidxs = [vidxs[0]] + rev\n        #print(f\"B: {vidxs}\")\n    \n    if vertices == 4:\n        mf = MeshFace(vidxs[0], vidxs[1], vidxs[2], vidxs[3])\n    elif vertices == 3:\n        mf = MeshFace(vidxs[0], vidxs[1], vidxs[2])\n    if from_winding != winding and False:\n        #print(f\"\\tFlipping {mf.ToString()}\")\n        mf = mf.Flip()\n        #print(f\"\\t\\tFlipped {mf.ToString()}\")\n    m.Faces.AddFace(mf)\n    \n\nfirst_time = True\ndef get_ldraw_file(part_name : str) -> LDrawFile:\n    global vfiles, first_time\n\n    part_name = part_name.replace('/', '\\\\')\n\n    part_3dm = Path(part_name).with_suffix('.3dm').name\n\n    print(f\"...searching for [{part_3dm}]\")\n\n    if \"springMesh\" in part_3dm:\n        pass\n\n    if part_3dm in vfiles.keys():\n        print(f\"\\t found {part_3dm}\")\n        return vfiles[part_3dm]\n\n    if part_name in vfiles.keys():\n        return vfiles[part_name]\n\n    raise Exception(f\"Part file not found: {part_name}\")\n\n\ndef load_part(part : LDrawFile, m : Mesh, xforms : list, override_invert_faces = False):\n    cmds = part.get_commands()\n    invert_faces = False\n    direction = Winding.CCW if part.is_ccw_winding() else Winding.CW\n    if part.is_ccw_winding() and not override_invert_faces:\n        invert_faces = True\n    elif part.is_ccw_winding() and override_invert_faces:\n        invert_faces = False\n    elif override_invert_faces and not part.is_ccw_winding():\n        invert_faces = True\n\n    #print(f\"load_part {part.ppname}, {direction}, {override_invert_faces}. {invert_faces}\")\n\n    invert_next = False\n    for cmd in cmds:\n        if is_invert_cmd(cmd):\n            #print(f\"\\tInverting next cmd\")\n            invert_next = True\n            continue\n        if cmd.startswith('1'):\n            d = cmd.split()\n            xform = LegoXform(cmd)\n            prt = ' '.join(d[14:])\n            _xforms = [xform] + xforms[:]\n            try:\n                part_file = get_ldraw_file(prt)\n            except Exception:\n                print(f\"\\tERR: Failed getting part {prt}, skipping\")\n                continue\n            load_part(part_file, m, _xforms, invert_next)\n        elif cmd.startswith('3') or cmd.startswith('4'):\n            direction_to_use = direction\n            if override_invert_faces:\n                direction_to_use = direction.flip()\n            add_poly(m, cmd, xforms, direction, direction.flip() if override_invert_faces else direction) # DEBUG, not invert_faces if invert_next else invert_faces)\n        invert_next = False\n\ndef get_part_idef(prt):\n    p = Path(prt)\n    pname = clean_name(p.name)\n    if pname in idefs:\n        return idefs[pname]\n\n    return None\n\ndef is_invert_cmd(cmd):\n    return cmd.startswith('0') and 'BFC' in cmd and 'INVERTNEXT' in cmd\n\ndef contains_poly_commands(cmds):\n    for cmd in cmds:\n        if len(cmd) == 0: continue\n        if cmd[0] in (\"2\", \"3\", \"4\", \"5\"):\n            return True\n\n    return False\n\ndef blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces=False):\n    idef = get_part_idef(prt)\n    xform = collate_transforms(_xforms)\n    if idef == None:\n        add_part(prt, override_invert_faces)\n        idef = update_idefs_dictionary(prt)\n    if idef != None:\n        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)\n    else:\n        print(f\"Failed to add part {prt}\")\n\ndef load_model_part(part : LDrawFile, xforms : list, override_invert_faces = False):\n    cmds = []\n    cmds = part.get_commands()\n\n    direction = Winding.CW\n    flipped = False\n\n    cmds = [l for l in cmds if len(l)>0]\n    if part.is_ccw_winding():\n        #print(f\"BFC CCW detected\")\n        direction = Winding.CCW\n\n    for cmd in cmds:\n\n        if is_invert_cmd(cmd):\n            #print(f\"BFC INVERTNEXT detected setting direction {direction} to {not direction}\")\n            direction = not direction\n            override_invert_faces = True\n            flipped = True\n            continue\n        if cmd.startswith('1'):\n            d = cmd.split()\n            color_code = d[1]\n            materials[color_code].create_render_material()\n            rm = materials[color_code].render_material\n            xform = LegoXform(cmd)\n            prt = ' '.join(d[14:])\n            _xforms = xforms[:] + [xform]\n\n            obattr = ObjectAttributes()\n            obattr.Name = clean_name(prt)\n            obattr.Visible = True\n            obattr.MaterialSource = ObjectMaterialSource.MaterialFromObject\n            obattr.RenderMaterial = rm\n\n            if prt.lower().endswith(\".ldr\"):\n                ldr_file = get_ldraw_file(prt)\n                if contains_poly_commands(ldr_file.get_commands()):\n                    add_part(prt, override_invert_faces)\n                    idef = update_idefs_dictionary(prt)\n                    if idef != None:\n                        xform = collate_transforms(_xforms)\n                        sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)\n                    else:\n                        print(f\"Couldn't add part {prt}\")\n                elif ldr_file.is_3dm():\n                    blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces)\n                else:\n                    load_model_part(ldr_file, _xforms, override_invert_faces)\n            else:\n                blockinstance_for_idef(prt, _xforms, obattr, override_invert_faces)\n                \"\"\"\n                idef = get_part_idef(prt)\n                xform = collate_transforms(_xforms)\n                if idef == None:\n                    add_part(prt, override_invert_faces)\n                    idef = update_idefs_dictionary(prt)\n                if idef != None:\n                    sc.doc.Objects.AddInstanceObject(idef.Index, xform, obattr)\n                else:\n                    print(f\"Failed to add part {prt}\")\n                \"\"\"\n\n            # flip reset\n            if flipped:\n                #print(f\"BFC INVERTNEXT done, setting direction {direction} to {not direction}\")\n                direction = not direction\n                flipped = False\n            refresh()\n\ndef add_virtual_file(model : Path, filename : str, data : List[str]):\n    global vfiles\n    virtual_file_path = model.parent / 'virtual' / filename\n    virtual_file = LDrawFile(virtual_file_path, data)\n    vfiles[virtual_file.name] = virtual_file\n    vfiles[virtual_file.pname] = virtual_file\n\n\ndef load_model(model : LDrawFile):\n    lines = model.get_commands()\n\n    FILE_START = '0 FILE '\n    first_file = ''\n    if model.suffix.lower() == '.mpd':\n        # parse file into virtual, read files\n        cur_file = ''\n        file_data = []\n        for l in lines:\n            if l.startswith(FILE_START):\n                if cur_file != '':\n                    add_virtual_file(model.path, cur_file, file_data)\n                if cur_file == '':\n                    first_file = l[len(FILE_START):]\n                cur_file = l[len(FILE_START):]\n                file_data = [l]\n            else:\n                file_data.append(l)\n        add_virtual_file(model.path, cur_file, file_data) # last file\n    elif model.suffix.lower() == '.ldr':\n        first_file = model.name\n    start_part = get_ldraw_file(first_file)\n\n    load_model_part(start_part, [rhino_orient])\n\n\ndef add_part(part_name : str, invert_faces = False):\n    global vertidx\n    vertidx = 0\n    name = clean_name(part_name)\n\n    print(f\"adding part {part_name} ({name})\")\n\n    existing_idef = sc.doc.InstanceDefinitions.Find(name)\n    if existing_idef:\n        print(f\"\\tSkipping {part_name}, instance already created\")\n        return\n    else:\n        pass #print(f\"\\tLoading [{part_name}]\")\n\n    ldraw_file = get_ldraw_file(part_name)\n\n    if ldraw_file.is_3dm():\n        print(f\"... reading 3dm file {ldraw_file.path}\")\n        f3dm = Rhino.FileIO.File3dm.Read(f'{ldraw_file.path}')\n        obs_to_add = list()\n        attrs_to_add = list()\n        for ob in f3dm.Objects:\n            if ob.Geometry.ObjectType == Rhino.DocObjects.ObjectType.InstanceReference:\n                continue\n            obs_to_add.append(ob.Geometry)\n            attrs_to_add.append(ob.Attributes)\n\n        obattr = ObjectAttributes()\n        obattr.Name = name\n        obattr.Visible = True\n        obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent\n        print(sc.doc.InstanceDefinitions.Add(\n            f'{name}',\n            f'High-definition Rhino version of {name}.',\n            Rhino.Geometry.Point3d.Origin,\n            obs_to_add,\n            attrs_to_add\n        ))\n        f3dm.Dispose()\n    else:\n        mesh = Mesh()\n        obattr = ObjectAttributes()\n\n        obattr.Name = name\n        obattr.Visible = True\n        obattr.MaterialSource = ObjectMaterialSource.MaterialFromParent\n\n        load_part(ldraw_file, mesh, [id_xform], invert_faces)\n        mesh.Weld(math.radians(50))\n        mesh.Normals.ComputeNormals()\n        mesh.Compact()\n\n        if mesh.Vertices.Count > 0 and mesh.Faces.Count > 0:\n            sc.doc.InstanceDefinitions.Add(obattr.Name, \"\", Point3f.Origin, mesh, obattr)\n\ndef load_colors():\n    colorldr = get_ldraw_file(\"LDConfig.ldr\")\n    cmds = colorldr.get_commands()\n    COLOR_CMD = \"0 !COLOUR \"\n    TO_REMOVE = \"0 !\"\n    for cmd in cmds:\n        if cmd.startswith(COLOR_CMD):\n            properties = dict()\n            cmd = cmd[len(TO_REMOVE):]\n            cmd_split = cmd.split()\n            if len(cmd_split) % 2 == 1:\n                cmd_split.append('dummy')\n            keyvalue_count = len(cmd_split) // 2\n            for i in range(0, keyvalue_count*2, 2):\n                properties[cmd_split[i]] = cmd_split[i+1]\n            ldraw_material = LDrawMaterial(properties)\n            materials[properties[\"CODE\"]] = ldraw_material\n    print(\"Colors read\")\n\n#sc.doc.Views.EnableRedraw(False, False, False)\n\n###########################################\n## Set path to where your LDraw library and\n## model files are. They should be under\n## the same main folder\n## Use always forward slashes, also for\n## folders on Windows\n###########################################\nlib_path = \"/Users/jesterking/Documents/brickdat/ldraw\"\n#lib_path = \"e:/dev/brickdat/ldraw\"\n\nprepare_parts_dictionary()\nprepare_idefs_dictionary()\nload_colors()\n\n\n#fl : Path = vfiles[\"885-1.mpd\"]\n#fl : Path = vfiles[\"8836-1.mpd\"]\n#fl : Path = vfiles[\"10019-1.mpd\"]\n#fl : Path = vfiles[\"10030-1.mpd\"]\n#fl : Path = vfiles[\"10143-1.mpd\"]\n#fl : Path = vfiles[\"75969-1.mpd\"]\n#fl : Path = vfiles[\"31048-1.mpd\"]\n#fl : Path = vfiles[\"3063-1.mpd\"]\nfl : Path = vfiles[\"42064-1.mpd\"]\n\n\n###########################################\n## Specify what model to load. Use just the\n## file name (including extension)\n###########################################\n#fl : Path = vfiles[\"tester.mpd\"]\n#fl : Path = vfiles[\"pyramid.ldr\"]\n#fl : Path = vfiles[\"10019-1.mpd\"]\nfl : Path = vfiles[\"8836-1.mpd\"]\n#fl : Path = vfiles[\"885-1.mpd\"]\n\nload_model(fl)\n\nrefresh()\n\nsc.doc.Views.EnableRedraw(True, True, True)\n\nRhino.RhinoApp.RunScript(\"ZEA\", False)\n\nprint(\"Done\")\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}