{
  "source_url": "https://github.com/THINkSHELL/Kroto/blob/2599fe8763055955f43fb79a7b924bcac4337c05/releases/1.0.1/Libraries/Kroto/meshminimize.py",
  "repo": "THINkSHELL/Kroto",
  "repo_stars": 0,
  "repo_description": "Tools implementing the surface density method in Rhinoceros3D, with Grasshopper integration. Python version",
  "license": "AGPL-3.0",
  "filepath": "releases/1.0.1/Libraries/Kroto/meshminimize.py",
  "instruction": "Implements the Stress Density Method as a Rhino mesh solver\nTakes a problem defined as a triangular mesh (working with quadrangular\nmeshes as well would take a lot of rewrite), edges conditions and...",
  "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  Kroto Membrane Form-finding.\n#  Copyright Â© 2015, Thinkshell & Laboratoire Navier, ENPC.\n#\n#  This file is part of Kroto.\n#\n#  Kroto is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Affero General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  Kroto is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n#  GNU Affero General Public License for more details.\n#\n#  You should have received a copy of the GNU Affero General Public License\n#  along with Kroto. If not, see http://www.gnu.org/licenses/.\n#\n\n\"\"\"Implements the Stress Density Method as a Rhino mesh solver\nTakes a problem defined as a triangular mesh (working with quadrangular\nmeshes as well would take a lot of rewrite), edges conditions and solver\noptions.\n\nReturns a mesh close to a minimal surface. The result is a true minimal\nsurface if the edges are fixed, pressure null and the method iterated\nuntil density coefficients yield a uniform stress field.\n\"\"\"\n\nfrom vectorworks import *  # noqa\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport copy\nimport rhinoscriptsyntax as rs\nimport meshminimizehelpers as mmh\n\n# Define default options for the solver\n# DEBUG = verbose option\n# GRAPHIC = build every iteration mesh in Rhino (stand-alone script)\n# SHOW_RESULT = build the resulting mesh in Rhino (stand-alone script)\n# SAVE_RESULTS = save the values of all the forces at each iteration\n# MAX_DISP = maximum displacement for the break criterion of the\n#           convergence algorithm\n# MAX_ITER = maximum number of iterations in the fixed-qs convergence\n#            algorithm\n# MAX_ITER_QS = maximum number of iterations for the qs convergence\n#               algorithm\n# MAX_DEV_SIGMA = maximum deviation around mean-value for the surface\n#                 stresses\n# SPEED = displacement speed at each iteration (necessary for stability\n#         of the gradient method)\n# METHOD = 'fixed-point', 'seidel' or 'gradient'\n# FIXED_CABLE_ENDS = cables ends are considered fixed\nDEBUG = False\nGRAPHIC = False\nSHOW_RESULT = False\nSAVE_RESULTS = False\nMAX_DISP = 0.01\nMAX_ITER = 10\nMAX_ITER_QS = 2\nMAX_DEV_SIGMA = 1\nSPEED = 1\nMETHOD = 'seidel'\nFIXED_CABLE_ENDS = True\n\n\ndef iterate_vertex(i, vertices, vertices_faces_nodes, vertex_faces, naked, qs,\n                   ql, n_cable, p6, g6, res, iter_qs, iter, out):\n    \"\"\"Updates the position of a node in the mesh\n\n    Arguments:\n      i = the node number in the mesh\n      vertices = the list of the mesh nodes\n      vertices_faces_nodes = list of lists of list of nodes constituting\n            the faces connected to a vertex, from orient_mesh_faces(mesh)\n      vertex_faces = the list of faces adjacent to the node\n      naked = True if the vertex is on a naked edge\n      qs = the stress density for all faces in the mesh\n      ql = the cable force density\n      n_cable = the list of list of cable segments from each vertex\n      p6 = pressure / 6\n      g6 = surface weight density / 6\n      res = the current maximum displacement in the iteration\n      iter_qs = current iteration in the qs loop\n      iter = current iteration in the stresses loop\n      out = dictionary of lists saving the forces acting on each\n            vertex (q_mix2, q_lix2 and p_x2x3)\n    Returns\n      res = the updated maximum displacement\n      new_vertex = the updated position of the node\n      out = results saved with new vertex\n    \"\"\"\n\n    # All numberings (usually indexed by j) are relative to the current\n    # vertex, i.\n\n    # .  = vector dot-product ( [n,1] . [n,1] -> [1,1] )\n    # /\\ = vector cross-product ( [n,1] /\\ [n,1] -> [n,1] )\n    # x  = vector Kronecker product ( [n,1] x [n,1] -> [n,n] )\n    # *  = classical multiplication of scalars, vectors or matrices\n\n    # m_i = faces around the vertex i\n    # n_i = cables around the vertex i\n    # x_2j, x_3j = points 2 and 3 of the face #j around the vertex i,\n    #              [3x1] vector\n    # x_2j3j = x_3j - x_2j = vector from 2j to 3j, [3x1] vector\n\n    # M_(i,j) = (x_2j3j . x_2j3j)*Id - (x_2j3j x x_2j3j)\n    #           [3,3] matrix representing the dependant faces areas around\n    #           the vertex i\n\n    # qs_j  = face number j surface stress density coefficient\n    # ql_j  = cable segment number j force density coefficient (for points\n    #         in the middle of a cable, count each side once)\n    # p6    = pressure / 6 (uniform scalar at the moment)\n    # g6    = surface weight density / 6 (uniform scalar at the moment)\n\n    # q_mi   = sum(j = [1, m_i]; qs_j * M_(i,j))\n    #       = local stiffness matrix, [3x3] matrix\n    # q_mix2 = sum(j = [1, m_i]; qs_j * M_(i,j) * x_2j)\n    #       = local membrane forces on the vertex, [3x1] vector\n    # ql2i  = sum(j = [1, m_i]; qs_j * l_ij**2)\n    #       = local membrane stiffness coefficient, scalar\n    # qli   = sum(j = [1, n_i]; ql_j)\n    #       = local cable stiffness coefficient, scalar\n    # q_lix2 = sum(j = [1, n_i]; ql_j * M_(i,j) * x_2j)\n    #       = local cable forces on the vertex, [3x1] vector\n    # p_x2x3 = sum(j = [1, m_i]; p/6 * (x_2j/\\x_3j + x_2j3j/\\x_i))\n    #       = pressure membrane forces around the vertex, [3x1] vector\n    # g3    = sum(j = [1, m_i]; norm(x_12j/\\x_13j))\n    #       = u3 term / g6 of the gravity forces around the vertex, scalar\n    # f_g    = [0, 0, - g3 * g6] = gravity forces, [3x1] vector\n\n    # First we initialize the intermediate vectors for calculation\n    q_mi = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    q_mix2 = [0, 0, 0]\n    ql2i = 0\n    if ql:\n        qli = sum(ql[i])\n    else:\n        qli = 0\n    q_lix2 = [0, 0, 0]\n    p_x2x3 = [0, 0, 0]\n    g3 = 0\n\n    j = 0\n\n    if DEBUG:\n        print '####'\n    if DEBUG:\n        print vertices[i]\n\n    # Iterate for faces j around current vertex i\n    while vertices_faces_nodes.get((i, j), 0):  # Face is in vertex_faces table\n        x2 = vertices[vertices_faces_nodes[(i, j)][1]]  # = x_2j,3D point,[3x1]\n        x3 = vertices[vertices_faces_nodes[(i, j)][2]]  # = x_3j,3D point,[3x1]\n        x23 = vecminus3(x3, x2)  # = vector x_2j3j, [3x1] vector\n        if g6:\n            x12 = vecminus3(x2, vertices[i])\n            x13 = vecminus3(x3, vertices[i])\n        qij = qs[vertex_faces[j]]  # = qs_j = Surface stress density coef\n\n        # q_mij = qs_j * M_(i,j)\n        # M_(i,j) = (x_2j3j . x_2j3j)*Id - (x_2j3j x x_2j3j)\n        q_mij = scalmatmul3(\n            qij,\n            matminus3(\n                diag3(dotproduct3(x23, x23)),\n                veckronproduct3(x23, x23)\n            )\n        )\n\n        # update q_mi and q_mix2 running sums\n        q_mi = matplus3(q_mi, q_mij)\n        q_mix2 = vecplus3(q_mix2, matvecmul3(q_mij, x2))\n\n        # ql2i = sum(j = [1, m_i]; qs_j * l_ij**2), running sum update, scalar\n        ql2i += qij * dotproduct3(x23, x23)\n\n        # p_x2x3 = sum(j = [1, m_i]; p/6 * (x_2j/\\x_3j + x_2j3j/\\x_i),\n        # running sum update, [3,1] vector\n        if p6:\n            p_x2x3 = vecplus3(\n                p_x2x3,\n                scalvecmul3(p6, crossproduct3(x2, x3))\n            )\n            # The contour term is non-zero only for edge nodes\n            if naked:\n                p_x2x3 = vecplus3(\n                    p_x2x3,\n                    scalvecmul3(p6, crossproduct3(x23, vertices[i]))\n                )\n\n        # g3 = sum(j = [1, m_i]; norm(x_12j/\\x_13j)),\n        # running sum update, scalar\n        if g6:\n            g3 += norm3(crossproduct3(x12, x13))\n\n        if DEBUG:\n            print '\\n'.join([\n                str((i, j)), str(x2), str(x3), str(x23), str(ql),\n                str(q_mij), matvecmul3(q_mij, x2), str(ql2i), '---'\n            ])\n        j += 1\n        # END while\n\n    if DEBUG:\n        print '\\n'.join([q_mi, q_mix2, p_x2x3])\n\n    # Iterate for cables segments j around vertex i\n    if n_cable:\n        for j, v in enumerate(n_cable[i]):\n            # q_lix2 = q_lix2 = sum( j = [1, n_i]; ql_j * M_(i,j) * x_2j ),\n            # Running sum update, [3x1] vector.\n            q_lix2 = vecplus3(q_lix2, scalvecmul3(ql[i][j], vertices[v]))\n\n    # Build the gravity forces vector\n    # f_g = [0, 0, - g3 * g6]\n    f_g = [0, 0, - g3 * g6]\n\n    # Do the actual work here, both methods\n    # x_i(t+1) = x_i(t) + SPEED * ((q_mi + qli)**-1 *\n    #                        (q_mix2 + q_lix2 + p_x2x3 + f_g) - x_i(t))\n    if METHOD == 'gradient':\n        new_vertex = vecplus3(\n            vertices[i],\n            scalvecmul3(\n                SPEED,\n                vecminus3(\n                    matvecmul3(\n                        inverse3(matplus3(q_mi, diag3(qli))),\n                        vecplus34(q_mix2, q_lix2, p_x2x3, f_g)\n                    ),\n                    vertices[i]\n                )\n            )\n        )\n    # x_i(t+1) = x_i(t)\n    #            + SPEED / (ql2i + qli)\n    #              * (q_mix2 + q_lix2 + p_x2x3 - (q_mi + qli).x_i(t))\n    elif METHOD == 'seidel' or METHOD == 'fixed-point':\n        new_vertex = vecplus3(\n            vertices[i],\n            scalvecmul3(\n                SPEED / (ql2i + qli),\n                vecminus3(\n                    vecplus34(q_mix2, q_lix2, p_x2x3, f_g),\n                    matvecmul3(\n                        matplus3(q_mi, diag3(qli)),\n                        vertices[i]\n                    )\n                )\n            )\n        )\n\n    # Update displacement criterion, if needed.\n    temp = dist3(new_vertex, vertices[i])\n    if temp > res:\n        res = temp\n\n    if SAVE_RESULTS:\n        # Branch the lists of lists to a proper GH output\n        M = scalvecmul3(1 / (qli + ql2i),  # noqa\n                        vecminus3(q_mix2, matvecmul3(q_mi, vertices[i])))\n        C = scalvecmul3(1 / (qli + ql2i),  # noqa\n                        vecminus3(q_lix2, scalvecmul3(qli, vertices[i])))\n        P = scalvecmul3(1 / (qli + ql2i), p_x2x3)  # noqa\n        G = scalvecmul3(1 / (qli + ql2i), f_g)  # noqa\n        out['M'].Add('{%f,%f,%f}' % tuple(M), GH_Path(0, iter_qs, iter))\n        out['C'].Add('{%f,%f,%f}' % tuple(C), GH_Path(0, iter_qs, iter))\n        out['P'].Add('{%f,%f,%f}' % tuple(P), GH_Path(0, iter_qs, iter))\n        out['G'].Add('{%f,%f,%f}' % tuple(G), GH_Path(0, iter_qs, iter))\n\n    return res, new_vertex, out\n\n\ndef iterate_one_step(vertices, vertices_faces_nodes, vertices_faces, naked,\n                     fixed, qs, ql, n_cable, p6, g6, iter_qs, iter, out):\n    \"\"\"Updates all nodes on the mesh once\n\n    Arguments:\n      vertices = list of mesh vertices, from rs.MeshVertices(mesh)\n      vertices_faces_nodes = list of lists of list of nodes constituting\n            the faces connected to a vertex, from orient_mesh_faces(mesh)\n      vertices_faces = list of list of faces adjacent to a node, from\n            rs.meshVertexFaces(mesh, i)\n      naked = list of boolean, True if vertex is on a naked edge\n      fixed = list of boolean, True if vertex is fixed\n      qs = list of surface stress density coefficients for each face\n      ql = list of cable force density, for each cable segment\n      n_cable = list of list of cables segments connected to a vertex\n      p6 = pressure / 6\n      g6 = surface weight density / 6\n      iter_qs = current iteration in the qs loop\n      iter = current iteration number\n      out = dictionary of lists saving the forces acting on each\n            vertex (q_mix2, q_lix2 and p_x2x3)\n    Returns:\n      iter = updated iteration number\n      res = maximum squared displacement for this iteration\n      vertices = updated positions of vertices\n      out = results updated to current iteration\n    \"\"\"\n\n    if METHOD == 'seidel':\n        # Update the mesh in-place as we loop over each vertex\n        new_vertices = vertices\n    else:\n        # Copy vertices to a new list, so that we do not overwrite it\n        new_vertices = copy.deepcopy(vertices)\n    iter += 1\n    res = 0\n\n    for i in xrange(len(vertices)):\n        if not fixed[i]:\n            res, new_vertices[i], out = iterate_vertex(\n                i, vertices, vertices_faces_nodes, vertices_faces[i],\n                naked[i], qs, ql, n_cable, p6, g6, res, iter_qs, iter, out\n            )\n        elif SAVE_RESULTS:\n            out['M'].Add('{0.0,0.0,0.0}', GH_Path(0, iter_qs, iter))\n            out['C'].Add('{0.0,0.0,0.0}', GH_Path(0, iter_qs, iter))\n            out['P'].Add('{0.0,0.0,0.0}', GH_Path(0, iter_qs, iter))\n            out['G'].Add('{0.0,0.0,0.0}', GH_Path(0, iter_qs, iter))\n    if METHOD == 'seidel':\n        vertices == new_vertices\n    else:\n        vertices = copy.deepcopy(new_vertices)\n\n    return iter, res, vertices, out\n\n\ndef iterate_fixed_qs(vertices, vertices_faces_nodes, vertices_faces, connec,\n                     naked, fixed, qs, ql, n_cable, p, g, iter_qs, out,\n                     meshi=None):\n    \"\"\"Iterates the problem with qs fixed, until a pseudo-minimal\n    surface is found.\n    Arguments:\n      vertices = list of mesh vertices, from rs.MeshVertices(mesh)\n      vertices_faces_nodes = list of lists of list of nodes constituting\n            the faces connected to a vertex, from orient_mesh_faces(mesh)\n      vertices_faces = list of list of faces adjacent to a node, from\n            rs.meshVertexFaces(mesh, i)\n      connec = connectivity matrix in the mesh, from\n               rs.MeshFaceVertices(mesh)\n      naked = list of boolean, True if vertex is on a naked edge\n      fixed = list of boolean, True if vertex is fixed\n      qs = list of surface stress density coefficients for each face\n      ql = list of cable force density, for each cable segment\n      n_cable = list of list of cable segments attached to each vertex\n      p = pressure\n      g = weight density per surface area (i.e. volumetric density * thickness)\n      iter_qs = current iteration in the qs loop\n      out = dictionary of lists saving the forces acting on each\n            vertex (q_mix2, q_lix2 and p_x2x3)\n      meshi = save-state for graphical display\n    Returns:\n      res_list = list of maximum squared displacement for each iteration\n      vertices = updated positions of vertices\n      out = results updated to current iteration\n    \"\"\"\n\n    # Initialize loop\n    iter = 0\n    res = 2 * MAX_DISP + 1\n    res_list = []\n\n    # Loop while we can, get some display if wanted\n    while (iter < MAX_ITER) & (res > MAX_DISP):\n        iter, res, vertices, out = iterate_one_step(\n            vertices, vertices_faces_nodes, vertices_faces, naked, fixed, qs,\n            ql, n_cable, p / 6, g / 6, iter_qs, iter, out\n        )\n        res_list.append(res)\n\n        if GRAPHIC:\n            rs.HideObject(meshi)\n            meshi = rs.AddMesh(vertices, connec)\n            print (u\"Iteration number {},\"\n                   u\"\\nMaximum displacement since \"\n                   u\"previous iteration : {} mm\").format(iter, res)\n        else:\n            print res\n        if SAVE_RESULTS:\n            out['A'].Add(rs.MeshArea(rs.AddMesh(vertices, connec))[1],\n                         GH_Path(0, iter_qs))\n\n    return res_list, vertices, out\n\n\ndef minimize_mesh(mesh, cables=None, fixed=None, qs=None, q_cables=None,\n                  reference=None, ql=None, n_cable=None, p=0, g=0):\n    \"\"\"Iterates a mesh until it is close to a minimal surface.\n\n    Arguments:\n      mesh = mesh to calculate, Rhino GUID\n      cables = polylines representing the cables\n      fixed = list of boolean, True if vertex is fixed\n      qs = list of surface stress density coefficients for each face\n      q_cables = list of force density coefficients for each cable\n      reference = reference mesh for comparisons, unused\n      ql = list of cable force density, for each cable segment\n      n_cable = list of list of cable segments connected to a vertex\n      p = pressure\n      g = weight density per surface area (i.e. volumetric density * thickness)\n    Returns:\n      vertices = vertices at new position\n      out = dictionary of lists saving the forces acting on each\n            vertex ('M' = q_mix2, 'C' = q_lix2 and 'p' = p_x2x3),\n            also 'S' = faces stress and 'convergence' = convergence\n            criterion for each iteration.\n    \"\"\"\n\n    # INITIALIZE\n    # qs defaults to 1 everywhere\n    if not qs:\n        qs = [1 for i in range(rs.MeshFaceCount(mesh))]\n    elif type(qs) != list:\n        qs = [qs for i in range(rs.MeshFaceCount(mesh))]\n        print qs\n\n    # meshi remembers current mesh if we need to hide it in Rhino\n    if GRAPHIC or SHOW_RESULT:\n        meshi = mesh\n    old_vertices = rs.MeshVertices(mesh)\n\n    # vertices strips RhinoCommon's 3D points to a bare 3-vector\n    vertices = [[old_vertices[i][0], old_vertices[i][1], old_vertices[i][2]]\n                for i in range(len(old_vertices))]\n\n    # reference defaults to the initial mesh\n    if not reference:\n        reference = vertices\n\n    # vertices_faces is taken from rs.MeshVertexFaces(mesh, i)\n    vertices_faces = [rs.MeshVertexFaces(mesh, i)\n                      for i in range(rs.MeshVertexCount(mesh))]\n\n    # vertices_faces_nodes is reordered from Rhino's mesh\n    vertices_faces_nodes = mmh.orient_mesh_faces(mesh)\n\n    # naked is extracted from Rhino\n    naked = rs.MeshNakedEdgePoints(mesh)\n    connec = rs.MeshFaceVertices(mesh)\n\n    # fixed defaults to naked if edges are fixed, otherwise defined in\n    #                   mmh.define_cables\n    if not fixed:\n        if not cables:\n            fixed = naked\n        else:\n            fixed = [False for i in vertices]\n\n    # q_cables defaults to 1\n    if cables:\n        if not q_cables:\n            q_cables = [1 for i in cables]\n        if not (ql and n_cable and fixed):\n            ql, n_cable, fixed = mmh.define_cables(cables, q_cables,\n                                                   old_vertices, naked, fixed)\n\n    # out is just empty GH trees at first\n    out = {'M': DataTree[object](),\n           'C': DataTree[object](),\n           'P': DataTree[object](),\n           'G': DataTree[object](),\n           'A': DataTree[object](),\n           'S': [0 for i in range(rs.MeshFaceCount(mesh))],\n           'convergence': DataTree[object](),\n           }\n\n    # Initialize loop\n    iter_qs = 0\n    dev_sigma = 2 * MAX_DEV_SIGMA + 1\n\n    # Loop while qs needs to be updated\n    while (iter_qs < MAX_ITER_QS) & (dev_sigma > MAX_DEV_SIGMA):\n        res_list, vertices, out = iterate_fixed_qs(\n            vertices, vertices_faces_nodes, vertices_faces, connec, naked,\n            fixed, qs, ql, n_cable, p, g, iter_qs, out\n        )\n        # Branch the list of lists to a proper GH output\n        for i, res in enumerate(res_list):\n            out['convergence'].Add(res, GH_Path(0, iter_qs))\n        iter_qs += 1\n        if iter_qs < MAX_ITER_QS:\n            dev_sigma, qs, out['S'] = mmh.update_qs(mesh, vertices, qs)\n        else:\n            out['S'] = mmh.update_qs(mesh, vertices, copy.deepcopy(qs))[2]\n        if DEBUG:\n            print qs\n        print '-' * 20\n\n    if SHOW_RESULT:\n        rs.HideObject(meshi)\n        rs.AddMesh(vertices, connec)\n\n    return vertices, out\n",
  "language": "python",
  "imports": [
    "RhinoCommon",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}