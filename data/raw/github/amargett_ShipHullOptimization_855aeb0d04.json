{
  "source_url": "https://github.com/amargett/ShipHullOptimization/blob/9337f2af02f96737801be5c4ff7b5f830c569e04/3dshiphull.py",
  "repo": "amargett/ShipHullOptimization",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "3dshiphull.py",
  "instruction": "3dshiphull",
  "code": "import rhinoscriptsyntax as rs \nimport Rhino\nimport math\n\n###parameters\nbd = 0.7\nsdy = 1.2\nsdx = 0.6\nypiv1 = -1.2\nypiv2 = 1.3\ndraft = 3\ndepth = 1\ndeadrise = False #False when deadrise is zero, True otherwise\nlb = 4\nlm = 5\nls = 3\nbs = 2\nbwl = 5\ntopy_dis_1 = 1.3\ntopy_dis_2 = 0.9\ntoppd = 0.5 # pivot distance\nfrontpd = 1.2 # pivot distance\n\nlwl = lb + lm + ls\n\n\n##top view\n# set pivot points with given dimensions\npt1 = (0,0,draft)\npt2 = (lb, bwl*1/2, draft)\npt3 = (lb + lm, bwl*1/2, draft)\npt4 = (lb+lm+ls, bs/2, draft)\npt5 = (lb + lm+ ls, 0, draft)\n\n# curve 1\nx = (pt1[0] + pt2[0])/2\ny = topy_dis_1\nnew_pt = (x, y, draft)\npivot = (pt2[0]-toppd, pt2[1], draft)\nrs.AddCurve([pt1, new_pt, pivot, pt2])\n\n# curve 2\nrs.AddLine(pt2, pt3)\n\n# curve 3\nx = (pt3[0] + pt4[0])/2\ny = pt4[1] + topy_dis_2\nnew_pt = (x, y, draft)\npivot = (pt3[0]+toppd, pt3[1], draft)\nrs.AddCurve([pt3, pivot, new_pt, pt4])\n\n# curve 4\nif pt4[1] != pt5[1]:\n    rs.AddLine(pt4, pt5)\n\n\n\n\n\n\n## parallel midbody\ni =lb\ncurves = []\nwhile i <= lb+lm:\n    # points along deck\n    pt1 = [i, bwl/2, draft]\n    pt2 = [i, 0, draft]\n\n    # intersection point percentages\n    isp = (0.95, 0.75) # y percentage, z percentage\n    beta = 17 # deadrise angle, in degrees\n    is_pt = (i, isp[0]*bwl/2, draft*isp[1]) # intersection point\n    R_c = 1 # radius at chine\n    R_k = 2.5 # radius at keel\n\n    # finding point at keel\n    h = is_pt[2] - depth \n    L = h/math.tan(beta)\n    keel_pt = (i, is_pt[1]-L, depth)\n\n    # finding reference curves\n    l1 = rs.AddLine(pt1, is_pt)\n    l2 = rs.AddLine(keel_pt, is_pt)\n    ref_circle  = rs.AddCircle3Pt((i,0,0), keel_pt, (i, R_k*2, 0))\n    cc = rs.CircleCenterPoint(ref_circle) # circle center for equation\n    rs.ObjectColor([l1,l2, ref_circle], (0, 0, 225))\n\n    # trimming circle\n    ccx = rs.CurveCurveIntersection(ref_circle, l2)\n    trim_t = ccx[0][5]\n    interval = [0, trim_t]\n    c1 = rs.TrimCurve(ref_circle, interval)\n\n    # trimming top fillet \n    fillet = rs.AddFilletCurve(l1, l2, R_c) \n    rs.ObjectColor([fillet], (0,0,225))\n    inter1 = rs.LineLineIntersection(fillet, l1)\n    inter2 = rs.LineLineIntersection(fillet, l2)\n    d1 = rs.Distance(inter1[0], is_pt)\n    d2 = rs.Distance(inter2[0], is_pt)\n    domain1 = rs.CurveDomain(l1)\n    domain2 = rs.CurveDomain(l2)\n    c2 = rs.TrimCurve(l1, [domain1[1],domain1[1]-d1])\n    c3 = rs.TrimCurve(l2, [domain2[1], domain2[1]-d2])\n    #curve = rs.JoinCurves([fillet, c1, c2, c3], True)\n    #curves.append(curve)\n    i+= lm/5\n    \n#rs.AddLoftSrf(curves)\n\ndef bezier_eqn(ctrl_pts):\n    \"\"\"\n    input: a list of control points along a bezier curve\n    output: a string representing the function of the curve.\n    \"\"\"\n    k = length(ctrl_pts) # number of points\n    n = num_pts-1 # degree of curve\n    \n\nprint('keel equation:'+ '(x-'+str(cc[0])+')^2 + (y-' + str(cc[1]) + ')^2 = ' + str(R_k**2))\n    \n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}