{
  "source_url": "https://github.com/contextmachine/mmodel/blob/0545e5c2a11c641fc54e91f603e709d3dea549f3/panels_gh/for_stats/frame_optional_elems.py",
  "repo": "contextmachine/mmodel",
  "repo_stars": 0,
  "repo_description": "Deployment branch",
  "license": "Apache-2.0",
  "filepath": "panels_gh/for_stats/frame_optional_elems.py",
  "instruction": "Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable",
  "code": "\"\"\"Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable\"\"\"\n\n__author__ = \"sofyadobycina\"\n\nimport copy\n\ntry:\n    rs = __import__(\"rhinoscriptsyntax\")\nexcept:\n    import rhinoscript as rs\n#  Copyright (c) 2022. Computational Geometry, Digital Engineering and Optimizing your construction processe\"\n\nimport imp\nimport os\n\nimport sys\n\nif os.getenv(\"USER\") == \"sofyadobycina\":\n    PWD = os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\"\n    sys.path.extend([os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\",\n                     os.getenv(\"HOME\") + \"Documents/GitHub/mmodel/panels_gh/cogs\"])\nelse:\n    os.environ[\"MMODEL_DIR\"] = \"/Users/andrewastakhov/PycharmProjects/mmodel\"\n    PWD = os.getenv(\"MMODEL_DIR\") + \"/panels_gh\"\n    sys.path.extend(\n        [os.getenv(\"MMODEL_DIR\") + \"/panels_gh\", os.getenv(\"MMODEL_DIR\") + \"/panels_gh/cogs\",\n         os.getenv(\"MMODEL_DIR\") + \"/panels_gh/tagging\"])\n\ncogsfile, cogsfilename, (cogssuffix, cogsmode, cogstype) = imp.find_module(\"cogs\", path=[PWD])\ncogs = imp.load_module(\"cogs\", cogsfile, PWD, (cogssuffix, cogsmode, cogstype))\n# sys.path.extend([\"/Users/sofyadobycina/Documents/GitHub/mmodel/panels_gh\"])\nimport cogs\n\nreload(cogs)\n\n# taggingfile, taggingfilename, (taggingsuffix, taggingmode, taggingtype) = imp.find_module(\"tagging\", path=[PWD+\"/panels_gh\"])\n# tagging = imp.load_module(\"tagging\", taggingfile, PWD, (taggingsuffix, taggingmode, taggingtype))\n# import tagging\n# reload(tagging)\n# %start gh-py template\n\n\n# %start script\n\nimport Rhino.Geometry as rh\n\nimport rhinoscriptsyntax as rs\n\nimport math\nimport ghpythonlib.treehelpers as th\n\n\ndef offset(crv, ofs_dist, extend=None):\n    c = rh.Curve.Offset(crv, rh.Plane.WorldXY, ofs_dist, 0.01, rh.CurveOffsetCornerStyle.Sharp)[0]\n    if extend is not None:\n        c = rh.Curve.Extend(c, rh.Interval(extend[0], extend[1]))\n    return c\n\n\ndef bound_rec(crv):\n    join = rh.Curve.JoinCurves(crv)[0]\n    bound_rec = rh.PolyCurve.GetBoundingBox(join, rh.Plane.WorldXY)\n    return bound_rec\n\n\ndef intersect(values):\n    res = []\n    for i, v in enumerate(values):\n        param = []\n        for ind, val in enumerate(values):\n            if i != ind:\n                inters = rs.CurveCurveIntersection(v, val)\n                if inters is not None:\n                    param.append(inters[0][5])\n        param = sorted(param)\n        if len(param) != 1 and i != 0:\n            trimed = rh.Curve.Trim(v, param[0], param[1])\n        elif i == len(values) - 1:\n            trimed = rh.Curve.Trim(v, v.Domain[0], param[0])\n        elif i == 0 and len(param) != 1:\n            trimed = rh.Curve.Trim(v, param[1], v.Domain[1])\n        else:\n            trimed = rh.Curve.Trim(v, param[0], v.Domain[1])\n        res.append(trimed)\n    return res\n\n\nclass FramePanel:\n    bottom = 45\n    top = 35\n    diag = 20\n\n    bottom_rec = 30\n    side_rec = 30\n\n    p_niche = p_niche\n    n_niche = n_niche\n    b_niche = b_niche\n\n    rect = rh.Rectangle3d(rh.Plane.WorldXY, rh.Point3d(-2.5, -2, 0), rh.Point3d(2.5, 12, 0)).ToNurbsCurve()\n\n    @property\n    def frame_offset(self):\n        fr_one = self.frame_inner()[0]\n        p_o = self.bound_frame.ClosestPoint(fr_one.PointAtStart)[1]\n        p_t = self.bound_frame.ClosestPoint(fr_one.PointAtEnd)[1]\n        inters = self.bound_frame.Trim(p_o, p_t)\n        self._frame_offset = rh.Curve.JoinCurves([inters, fr_one])[0]\n        return self._frame_offset\n\n    @property\n    def frame_all(self):\n        self._frame_all = rh.Curve.JoinCurves(self.all_offset())\n        return self._frame_all\n\n    @property\n    def bound_frame(self):\n        rec = bound_rec(self.frame_all)\n        min_transl = rh.Point3d(rec.Min[0] - self.side_rec, rec.Min[1] - self.bottom_rec, 0)\n        bound_frame = rh.Rectangle3d(rh.Plane.WorldXY, min_transl, rec.Max)\n        self._bound_frame = bound_frame.ToNurbsCurve()\n        return self._bound_frame\n\n    @property\n    def bound_frame_r(self):\n        rec = bound_rec(self.frame_all)\n        min_transl = rh.Point3d(rec.Min[0] - self.side_rec, rec.Min[1] - self.bottom_rec, 0)\n\n        return rh.Rectangle3d(rh.Plane.WorldXY, min_transl, rec.Max)\n\n    @property\n    def rec(self):\n        rec = bound_rec(self.frame_all)\n        return rec\n\n    '''@property\n    def region(self):\n        if self.panel.__class__.__name__ != 'BackNiche':\n            if self.cogs is True:\n                elems = self.cogs_points(2) + self.simple_points(0)\n            else:\n                elems = self.simple_points(2, niche=1) + self.simple_points(0)\n        else:\n            elems = self.simple_points(1, niche=1) + self.simple_points(0)\n\n        elems.append(self.frame_offset)\n        elems.append(self.panel.cut[0])\n        new = list(rh.Curve.CreateBooleanUnion(elems, 0.1))\n        new.extend(self.panel.cut[1:])\n        return new'''\n\n    @property\n    def all_elems(self):\n\n        #a = [self.region, self.panel.fres]\n        a = [self.frame_offset, self.panel.cut[0], rh.Curve.JoinCurves(self.panel.fres)[0]]\n        '''try:\n            g = []\n            for i in self.panel.grav[0]:\n                for j in i:\n                    g.append(j)\n            try:\n                g.append(self.panel.grav[1])\n            except:\n                pass\n            a.append(g)\n\n        except AttributeError:\n            pass'''\n\n        return a\n\n    def __init__(self, panel, nich_ofs):\n        self.niche = nich_ofs\n        self.panel = panel\n\n        try:\n            self.cogs = self.panel.cogs_bend\n            self.type = self.panel.type\n\n            self.p_niche = self.panel.fres[1]\n\n            if self.type == 1:\n                self.p_bottom = self.panel.fres[2]\n            else:\n                self.p_bottom = self.panel.fres[0]\n\n        except AttributeError:\n            self.p_niche = self.panel.bottom.fres\n            self.p_bottom = self.panel.fres[0]\n\n    @property\n    def unroll_dict_f(self):\n        return {\n            \"data\": copy.deepcopy(self.panel.unroll_dict),\n            \"frame\": self.bound_frame.ToNurbsCurve()\n\n        }\n\n    def tr_rect(self, p, ind, spec=None):\n        crv = self.all_offset()[ind]\n        frame = crv.FrameAt(crv.ClosestPoint(p)[1])[1]\n        if frame.YAxis[0] < 0 and spec is None:\n            frame = rh.Plane(frame.Origin, frame.XAxis, -frame.YAxis)\n        else:\n            frame = rh.Plane(frame.Origin, frame.XAxis, frame.YAxis)\n        tr = rh.Transform.PlaneToPlane(rh.Plane.WorldXY, frame)\n        rect = self.rect.DuplicateCurve()\n        rect.Transform(tr)\n        return rect\n\n    def cogs_points(self, side):\n        rectang = []\n        for i in self.panel.cut[2:-1:8]:\n            b = i.TryGetCircle(0.1)[1].Center\n            rect = self.tr_rect(b, side)\n            rectang.append(rect)\n\n        b = self.panel.cut[-1].TryGetCircle(0.1)[1].Center\n        rect = self.tr_rect(b, side)\n        rectang.append(rect)\n        return rectang\n\n    def simple_points(self, side, niche=None):\n        if self.panel.__class__.__name__ != 'BackNiche':\n            if niche is not None:\n                crv = self.panel.top_parts[1]\n            elif self.type == 0:\n                crv = self.panel.top_parts[0]\n            else:\n                crv = self.panel.top_parts[2]\n        else:\n            if niche is not None:\n                crv = self.panel.bottom.fres\n            else:\n                crv = self.panel.top_parts\n\n        st = crv.ClosestPoint(crv.PointAtLength(7.5))[1]\n        end = crv.ClosestPoint(crv.PointAtLength(crv.GetLength() - 7.5))[1]\n        n_crv = crv.Trim(st, end)\n\n        num = math.ceil(n_crv.GetLength() / 100)\n        param = n_crv.DivideByCount(num, True)\n        points = [n_crv.PointAt(i) for i in param]\n\n        if self.panel.__class__.__name__ != 'BackNiche':\n            if self.type == 1 and niche is None:\n                rectang = [self.tr_rect(i, side, spec=True) for i in points]\n            else:\n                rectang = [self.tr_rect(i, side) for i in points]\n        else:\n            rectang = [self.tr_rect(i, side) for i in points]\n        return rectang\n\n    def all_offset(self):\n        niche = offset(self.p_niche, self.niche,\n                       extend=[self.p_niche.Domain[0] + 200, self.p_niche.Domain[1] - 200])\n        if niche is None:\n            niche = offset(self.p_niche, self.niche,\n                           extend=[self.p_niche.Domain[0] - 200, self.p_niche.Domain[1] + 200])\n\n        bottom = offset(self.p_bottom, self.bottom,\n                        extend=[self.p_bottom.Domain[0] - 200, self.p_bottom.Domain[1]])\n        top_s = self.top_side()\n        top = offset(self.top_side(), self.top, extend=[top_s.Domain[0], top_s.Domain[1] + 200])\n\n        try:\n            diag = offset(self.diag_side(), self.diag)\n            all_offset = [bottom, diag, niche, top]\n        except AttributeError:\n            all_offset = [bottom, niche, top]\n\n        all_offset = intersect(all_offset)\n        return all_offset\n\n    def top_side(self):\n        if self.panel.__class__.__name__ != 'BackNiche':\n            bound = bound_rec(self.panel.fres)\n        else:\n            l = self.panel.fres\n            l.append(self.p_niche)\n            bound = bound_rec(l)\n\n        top_side = bound.GetEdges()[2]\n        return top_side.ToNurbsCurve()\n\n    def diag_side(self):\n\n        if self.type == 0:\n            st = self.panel.top_parts[1].PointAtEnd\n            en = self.panel.top_parts[0].PointAtStart\n            p = self.p_niche.PointAtEnd\n        else:\n            st = self.panel.top_parts[1].PointAtEnd\n            en = self.panel.top_parts[2].PointAtStart\n            p = self.p_niche.PointAtEnd\n\n        crv = rh.Line.ToNurbsCurve(rh.Line(st, en))\n\n        crv_d = crv.PointAtLength(rh.Curve.DivideByCount(crv, 2, False)[0])\n        self.diag = rh.Point3d.DistanceTo(p, crv_d) + 10\n        return crv\n\n    def frame_inner(self):\n        offset = rh.Curve.JoinCurves(self.all_offset()[0:-1])[0]\n        crv = rh.Line(offset.PointAtEnd, rh.Point3d(offset.PointAtEnd[0], offset.PointAtEnd[1] - self.bottom + 15,\n                                                    offset.PointAtEnd[2])).ToNurbsCurve()\n        frame_offset = rh.Curve.JoinCurves([offset, crv])\n        return frame_offset\n\n\nclass MarkerDict:\n    def __init__(self, input_dict):\n        self.__dict__.update(input_dict)\n\n    def GetString(self):\n        return self.__dict__.__str__()\n\n\n\nframe = FramePanel",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}