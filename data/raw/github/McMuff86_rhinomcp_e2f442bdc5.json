{
  "source_url": "https://github.com/McMuff86/rhinomcp/blob/65db89d55c0a08af4dc19cd946bec19429db10cc/rhino_mcp_server/static/curve.py",
  "repo": "McMuff86/rhinomcp",
  "repo_stars": 0,
  "repo_description": null,
  "license": "Apache-2.0",
  "filepath": "rhino_mcp_server/static/curve.py",
  "instruction": null,
  "code": "import math\n\nimport System\n\nimport Rhino\n\nimport scriptcontext\n\nimport rhinocompat as compat\nfrom rhinoscript import utility as rhutil\n\n\ndef AddArc(plane, radius, angle_degrees):\n    \"\"\"Adds an arc curve to the document\n    Parameters:\n      plane (str): plane on which the arc will lie. The origin of the plane will be\n        the center point of the arc. x-axis of the plane defines the 0 angle\n        direction.\n      radius(number): radius of the arc\n      angle_degrees (number): interval of arc in degrees\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as  rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane,  45.0, [0,0,1])\n      rs.AddArc( plane, 5.0, 45.0  )\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    radians = math.radians(angle_degrees)\n    arc = Rhino.Geometry.Arc(plane, radius, radians)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArc3Pt(start, end, point_on_arc):\n    \"\"\"Adds a 3-point arc curve to the document\n    Parameters:\n      start, end (point|guid): endpoints of the arc\n      point_on_arc (point|guid): a point on the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of arc\")\n      if start is not None:\n          end = rs.GetPoint(\"End of arc\")\n          if end is not None:\n              pton = rs.GetPoint(\"Point on arc\")\n              if pton is not None:\n                  rs.AddArc3Pt(start, end, pton)\n    See Also:\n      AddArc\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    pton = rhutil.coerce3dpoint(point_on_arc, True)\n    arc = Rhino.Geometry.Arc(start, pton, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddArcPtTanPt(start, direction, end):\n    \"\"\"Adds an arc curve, created from a start point, a start direction, and an\n    end point, to the document\n    Parameters:\n      start (point): the starting point of the arc\n      direction (vector): the arc direction at start\n      end (point): the ending point of the arc\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      pick = rs.GetCurveObject(\"Select curve to extend\")\n      point = rs.GetPoint(\"End of extension\")\n      domain = rs.CurveDomain(pick[0])\n      if abs(pick[4]-domain[0]) < abs(pick[4]-domain[1]):\n          origin = rs.CurveStartPoint(pick[0])\n          tangent = rs.VectorReverse(rs.CurveTangent(pick[0], domain[0]))\n      else:\n          origin = rs.CurveEndPoint(pick[0])\n          tangent = rs.CurveTangent(pick[0], domain[1])\n      rs.AddArcPtTanPt(origin, tangent, point)\n    See Also:\n      AddArc\n      AddArc3Pt\n      IsArc\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    direction = rhutil.coerce3dvector(direction, True)\n    end = rhutil.coerce3dpoint(end, True)\n    arc = Rhino.Geometry.Arc(start, direction, end)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add arc to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddBlendCurve(curves, parameters, reverses, continuities):\n    \"\"\"Makes a curve blend between two curves\n    Parameters:\n      curves ([guid|curve, guid|curve]): list of two curves\n      parameters ([number, number]): list of two curve parameters defining the blend end points\n      reverses ([bool, bool]): list of two boolean values specifying to use the natural or opposite direction of the curve\n      continuities ([number, number]): list of two numbers specifying continuity at end points\n                                            0 = position\n                                            1 = tangency\n                                            2 = curvature\n    Returns:\n      guid: identifier of new curve on success\n    Example:\n        import rhinoscriptsyntax as rs\n        curve0 = rs.AddLine((0,0,0), (0,9,0))\n        curve1 = rs.AddLine((1,10,0), (10,10,0))\n        curves = curve0, curve1\n        domain_crv0 = rs.CurveDomain(curve0)\n        domain_crv1 = rs.CurveDomain(curve1)\n        params = domain_crv0[1], domain_crv1[0]\n        revs = False, True\n        cont = 2,2\n        rs.AddBlendCurve( curves, params, revs, cont )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    crv0 = rhutil.coercecurve(curves[0], -1, True)\n    crv1 = rhutil.coercecurve(curves[1], -1, True)\n    c0 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[0])\n    c1 = System.Enum.ToObject(Rhino.Geometry.BlendContinuity, continuities[1])\n    curve = Rhino.Geometry.Curve.CreateBlendCurve(crv0, parameters[0], reverses[0], c0, crv1, parameters[1], reverses[1], c1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle(plane_or_center, radius):\n    \"\"\"Adds a circle curve to the document\n    Parameters:\n      plane_or_center (point|plane): plane on which the circle will lie. If a point is\n        passed, this will be the center of the circle on the active\n        construction plane\n      radius (number): the radius of the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddCircle( plane, 5.0 )\n    See Also:\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    rc = None\n    plane = rhutil.coerceplane(plane_or_center, False)\n    if plane:\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    else:\n        center = rhutil.coerce3dpoint(plane_or_center, True)\n        view = scriptcontext.doc.Views.ActiveView\n        plane = view.ActiveViewport.ConstructionPlane()\n        plane.Origin = center\n        circle = Rhino.Geometry.Circle(plane, radius)\n        rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCircle3Pt(first, second, third):\n    \"\"\"Adds a 3-point circle curve to the document\n    Parameters:\n      first, second, third (point|guid): points on the circle\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      point1 = rs.GetPoint(\"First point on circle\")\n      if point1:\n          point2 = rs.GetPoint(\"Second point on circle\")\n          if point2:\n              point3 = rs.GetPoint(\"Third point on circle\")\n              if point3:\n                  rs.AddCircle3Pt(point1, point2, point3)\n    See Also:\n      AddCircle\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    start = rhutil.coerce3dpoint(first, True)\n    end = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    circle = Rhino.Geometry.Circle(start, end, third)\n    rc = scriptcontext.doc.Objects.AddCircle(circle)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add circle to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddCurve(points, degree=3):\n    \"\"\"Adds a control points curve object to the document\n    Parameters:\n      points ([point|guid, ...]) a list of points\n      degree (number): degree of the curve\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True, message1=\"Pick curve point\")\n      if points: rs.AddCurve(points)\n    See Also:\n      AddInterpCurve\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    curve = Rhino.Geometry.Curve.CreateControlPointCurve(points, degree)\n    if not curve: raise Exception(\"unable to create control point curve from given points\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse(plane, radiusX, radiusY):\n    \"\"\"Adds an elliptical curve to the document\n    Parameters:\n      plane (plane) the plane on which the ellipse will lie. The origin of\n              the plane will be the center of the ellipse\n      radiusX, radiusY (number): radius in the X and Y axis directions\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      rs.AddEllipse( plane, 5.0, 10.0 )\n    See Also:\n      AddEllipse3Pt\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    ellipse = Rhino.Geometry.Ellipse(plane, radiusX, radiusY)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddEllipse3Pt(center, second, third):\n    \"\"\"Adds a 3-point elliptical curve to the document\n    Parameters:\n      center (point|guid): center point of the ellipse\n      second (point|guid): end point of the x axis\n      third  (point|guid): end point of the y axis\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      center = (0,0,0)\n      second = (5,0,0)\n      third = (0,10,0)\n      rs.AddEllipse3Pt( center, second, third )\n    See Also:\n      AddEllipse\n      IsEllipse\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    center = rhutil.coerce3dpoint(center, True)\n    second = rhutil.coerce3dpoint(second, True)\n    third = rhutil.coerce3dpoint(third, True)\n    ellipse = Rhino.Geometry.Ellipse(center, second, third)\n    rc = scriptcontext.doc.Objects.AddEllipse(ellipse)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddFilletCurve(curve0id, curve1id, radius=1.0, base_point0=None, base_point1=None):\n    \"\"\"Adds a fillet curve between two curve objects\n    Parameters:\n      curve0id (guid): identifier of the first curve object\n      curve1id (guid): identifier of the second curve object\n      radius (number, optional): fillet radius\n      base_point0 (point|guid, optional): base point of the first curve. If omitted,\n                          starting point of the curve is used\n      base_point1 (point|guid, optional): base point of the second curve. If omitted,\n                          starting point of the curve is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      rs.AddFilletCurve( curve0, curve1 )\n    See Also:\n      CurveFilletPoints\n    \"\"\"\n    if base_point0: base_point0 = rhutil.coerce3dpoint(base_point0, True)\n    else: base_point0 = Rhino.Geometry.Point3d.Unset\n    if base_point1: base_point1 = rhutil.coerce3dpoint(base_point1, True)\n    else: base_point1 = Rhino.Geometry.Point3d.Unset\n    curve0 = rhutil.coercecurve(curve0id, -1, True)\n    curve1 = rhutil.coercecurve(curve1id, -1, True)\n    crv0_t = 0.0\n    if base_point0==Rhino.Geometry.Point3d.Unset:\n        crv0_t = curve0.Domain.Min\n    else:\n        rc, t = curve0.ClosestPoint(base_point0, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv0_t = t\n    crv1_t = 0.0\n    if base_point1==Rhino.Geometry.Point3d.Unset:\n        crv1_t = curve1.Domain.Min\n    else:\n        rc, t = curve1.ClosestPoint(base_point1, 0.0)\n        if not rc: raise Exception(\"ClosestPoint failed\")\n        crv1_t = t\n    arc = Rhino.Geometry.Curve.CreateFillet(curve0, curve1, radius, crv0_t, crv1_t)\n    rc = scriptcontext.doc.Objects.AddArc(arc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrf(surface_id, points):\n    \"\"\"Adds an interpolated curve object that lies on a specified\n    surface.  Note, this function will not create periodic curves,\n    but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([point|guid, point|guid, ...])list of 3D points that lie on the specified surface.\n               The list must contain at least 2 points\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          point1 = rs.GetPointOnSurface( surface_id, \"First point on surface\")\n          if point1:\n              point2 = rs.GetPointOnSurface( surface_id, \"Second point on surface\")\n              if point2:\n                  rs.AddInterpCrvOnSrf( surface_id, [point1, point2])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrfUV\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce3dpointlist(points, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurface(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurface\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCrvOnSrfUV(surface_id, points):\n    \"\"\"Adds an interpolated curve object based on surface parameters,\n    that lies on a specified surface. Note, this function will not\n    create periodic curves, but it will create closed curves.\n    Parameters:\n      surface_id (guid): identifier of the surface to create the curve on\n      points ([[number, number}, [number,number], ...]): a list of 2D surface parameters. The list must contain\n                                                         at least 2 sets of parameters\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      surface_id = rs.GetObject(\"Select surface to draw curve on\", rs.filter.surface)\n      if surface_id:\n          domainU = rs.SurfaceDomain( surface_id, 0)\n          u0 = domainU[0]/2\n          u1 = domainU[1]/2\n          domainV = rs.SurfaceDomain( surface_id, 1)\n          v0 = domainV[0]/2\n          v1 = domainV[1]/2\n          rs.AddInterpCrvOnSrfUV( surface_id, [[u0,v0],[u1,v1]])\n    See Also:\n      AddCurve\n      AddInterpCurve\n      AddInterpCrvOnSrf\n    \"\"\"\n    surface = rhutil.coercesurface(surface_id, True)\n    points = rhutil.coerce2dpointlist(points)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)\n    if not curve: raise Exception(\"unable to create InterpolatedCurveOnSurfaceUV\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddInterpCurve(points, degree=3, knotstyle=0, start_tangent=None, end_tangent=None):\n    \"\"\"Adds an interpolated curve object to the document. Options exist to make\n    a periodic curve or to specify the tangent at the endpoints. The resulting\n    curve is a non-rational NURBS curve of the specified degree.\n    Parameters:\n      points (point|guid, point|guid, ...]): a list containing 3D points to interpolate. For periodic curves,\n          if the final point is a duplicate of the initial point, it is\n          ignored. The number of control points must be >= (degree+1).\n      degree (number, optional): The degree of the curve (must be >=1).\n          Periodic curves must have a degree >= 2. For knotstyle = 1 or 2,\n          the degree must be 3. For knotstyle = 4 or 5, the degree must be odd\n      knotstyle(opt):\n          0 Uniform knots.  Parameter spacing between consecutive knots is 1.0.\n          1 Chord length spacing.  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          2 Sqrt (chord length).  Requires degree = 3 with arrCV1 and arrCVn1 specified.\n          3 Periodic with uniform spacing.\n          4 Periodic with chord length spacing.  Requires an odd degree value.\n          5 Periodic with sqrt (chord length) spacing.  Requires an odd degree value.\n      start_tangent (vector, optional): a vector that specifies a tangency condition at the\n          beginning of the curve. If the curve is periodic, this argument must be omitted.\n      end_tangent (vector, optional): 3d vector that specifies a tangency condition at the\n          end of the curve. If the curve is periodic, this argument must be omitted.\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = (0,0,0), (1,1,0), (2,0,0), (3,1,0), (4,0,0), (5,1,0)\n      rs.AddInterpCurve(points)\n    See Also:\n      AddCurve\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if not start_tangent: start_tangent = Rhino.Geometry.Vector3d.Unset\n    start_tangent = rhutil.coerce3dvector(start_tangent, True)\n    if not end_tangent: end_tangent = Rhino.Geometry.Vector3d.Unset\n    end_tangent = rhutil.coerce3dvector(end_tangent, True)\n    knotstyle = System.Enum.ToObject(Rhino.Geometry.CurveKnotStyle, knotstyle)\n    curve = Rhino.Geometry.Curve.CreateInterpolatedCurve(points, degree, knotstyle, start_tangent, end_tangent)\n    if not curve: raise Exception(\"unable to CreateInterpolatedCurve\")\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddLine(start, end):\n    \"\"\"Adds a line curve to the current model.\n    Parameters:\n      start, end (point|guid) end points of the line\n    Returns:\n      guid: id of the new curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      start = rs.GetPoint(\"Start of line\")\n      if start:\n          end = rs.GetPoint(\"End of line\")\n          if end: rs.AddLine(start, end)\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsLine\n    \"\"\"\n    start = rhutil.coerce3dpoint(start, True)\n    end = rhutil.coerce3dpoint(end, True)\n    rc = scriptcontext.doc.Objects.AddLine(start, end)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add line to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddNurbsCurve(points, knots, degree, weights=None):\n    \"\"\"Adds a NURBS curve object to the document\n    Parameters:\n      points ([guid|point, guid|point, ...]): a list containing 3D control points\n      knots ([number, number, ...]): Knot values for the curve. The number of elements in knots must\n          equal the number of elements in points plus degree minus 1\n      degree (number): degree of the curve. must be greater than of equal to 1\n      weights([number, number, ...], optional) weight values for the curve. Number of elements should\n          equal the number of elements in points. Values must be greater than 0\n    Returns:\n      guid: the identifier of the new object if successful, otherwise None\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_id = rs.GetObject(\"Pick a curve\", rs.filter.curve)\n      if curve_id:\n          points = rs.CurvePoints(curve_id)\n          knots = rs.CurveKnots(curve_id)\n          degree = rs.CurveDegree(curve_id)\n          newcurve = rs.AddNurbsCurve( points, knots, degree)\n          if newcurve: rs.SelectObject(newcurve)\n    See Also:\n      CurveDegree\n      CurveKnots\n      CurvePoints\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    cvcount = len(points)\n    knotcount = cvcount + degree - 1\n    if len(knots)!=knotcount:\n        raise Exception(\"Number of elements in knots must equal the number of elements in points plus degree minus 1\")\n    if weights and len(weights)!=cvcount:\n        raise Exception(\"Number of elements in weights should equal the number of elements in points\")\n    rational = (weights!=None)\n    \n    nc = Rhino.Geometry.NurbsCurve(3,rational,degree+1,cvcount)\n    if rational: \n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i], weights[i])\n    else:\n        for i in compat.RANGE(cvcount):\n            nc.Points.SetPoint(i, points[i])\n    for i in compat.RANGE(knotcount): nc.Knots[i] = knots[i]\n    rc = scriptcontext.doc.Objects.AddCurve(nc)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPolyline(points, replace_id=None):\n    \"\"\"Adds a polyline curve to the current model\n    Parameters:\n      points ([guid|point, guid|point, ...]): list of 3D points. Duplicate, consecutive points will be\n               removed. The list must contain at least two points. If the\n               list contains less than four points, then the first point and\n               last point must be different.\n      replace_id (guid, optional): If set to the id of an existing object, the object\n               will be replaced by this polyline\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints(True)\n      if points: rs.AddPolyline(points)\n    See Also:\n      IsPolyline\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    if replace_id: replace_id = rhutil.coerceguid(replace_id, True)\n    rc = System.Guid.Empty\n    pl = Rhino.Geometry.Polyline(points)\n    pl.DeleteShortSegments(scriptcontext.doc.ModelAbsoluteTolerance)\n    if replace_id:\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = scriptcontext.doc.Objects.AddPolyline(pl)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddRectangle(plane, width, height):\n    \"\"\"Add a rectangular curve to the document\n    Parameters:\n      plane (plane) plane on which the rectangle will lie\n      width, height (number): width and height of rectangle as measured along the plane's\n        x and y axes\n    Returns:\n      guid: id of new rectangle\n    Example:\n      import rhinoscriptsyntax as rs\n      plane = rs.WorldXYPlane()\n      plane = rs.RotatePlane(plane, 45.0, [0,0,1])\n      rs.AddRectangle( plane, 5.0, 15.0 )\n    See Also:\n      \n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    rect = Rhino.Geometry.Rectangle3d(plane, width, height)\n    poly = rect.ToPolyline()\n    rc = scriptcontext.doc.Objects.AddPolyline(poly)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSpiral(point0, point1, pitch, turns, radius0, radius1=None):\n    \"\"\"Adds a spiral or helical curve to the document\n    Parameters:\n      point0 (point|guid): helix axis start point or center of spiral\n      point1 (point|guid): helix axis end point or point normal on spiral plane\n      pitch (number): distance between turns. If 0, then a spiral. If > 0 then the\n              distance between helix \"threads\"\n      turns (number): number of turns\n      radius0 (number): starting radius of spiral\n      radius1 (number, optional): ending radius of spiral. If omitted, the starting radius is used for the complete spiral.\n    Returns:\n      guid: id of new curve on success\n    Example:\n      import rhinoscriptsyntax as rs\n      point0 = (0,0,0)\n      point1 = (0,0,10)\n      pitch = 1\n      turns = 10\n      radius0 = 5.0\n      radius1 = 8.0\n      rs.AddSpiral(point0, point1, pitch, turns, radius0, radius1)\n    See Also:\n      \n    \"\"\"\n    if radius1 is None: radius1 = radius0\n    point0 = rhutil.coerce3dpoint(point0, True)\n    point1 = rhutil.coerce3dpoint(point1, True)\n    dir = point1 - point0\n    plane = Rhino.Geometry.Plane(point0, dir)\n    point2 = point0 + plane.XAxis\n    curve = Rhino.Geometry.NurbsCurve.CreateSpiral(point0, dir, point2, pitch, turns, radius0, radius1)\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddSubCrv(curve_id, param0, param1):\n    \"\"\"Add a curve object based on a portion, or interval of an existing curve\n    object. Similar in operation to Rhino's SubCrv command\n    Parameters:\n      curve_id (guid): identifier of a closed planar curve object\n      param0, param1 (number): first and second parameters on the source curve\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      getresult = rs.GetCurveObject()\n      if getresult:\n          curve_id = getresult[0]\n          point0 = rs.GetPointOnCurve( curve_id )\n          if point0:\n              point1 = rs.GetPointOnCurve( curve_id )\n              if point1:\n                  t0 = rs.CurveClosestPoint( curve_id, point0)\n                  t1 = rs.CurveClosestPoint( curve_id, point1)\n                  rs.AddSubCrv( curve_id, t0, t1 )\n    See Also:\n      CurveClosestPoint\n      GetCurveObject\n      GetPointOnCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    trimcurve = curve.Trim(param0, param1)\n    if not trimcurve: raise Exception(\"unable to trim curve\")\n    rc = scriptcontext.doc.Objects.AddCurve(trimcurve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ArcAngle(curve_id, segment_index=-1):\n    \"\"\"Returns the angle of an arc curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): identifies the curve segment if\n      curve_id (guid): identifies a polycurve\n    Returns:\n      number: The angle in degrees if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          angle = rs.ArcAngle(id)\n          print(\"Arc angle: {}\".format(angle))\n    See Also:\n      AddArc3Pt\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.AngleDegrees\n\n\ndef ArcCenterPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the center point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D center point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n      point = rs.ArcCenterPoint(id)\n      rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcMidPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Center\n\n\ndef ArcMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D mid point of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          point = rs.ArcMidPoint(id)\n          rs.AddPoint(point)\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcRadius\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.MidPoint\n\n\ndef ArcRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of an arc curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the arc if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select arc\")\n      if rs.IsArc(id):\n          radius = rs.ArcRadius(id)\n          print(\"Arc radius: {}\".format(radius))\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      IsArc\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, arc = curve.TryGetArc( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not arc\")\n    return arc.Radius\n\n\ndef CircleCenterPoint(curve_id, segment_index=-1, return_plane=False):\n    \"\"\"Returns the center point of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      return_plane (bool, optional): if True, the circle's plane is returned. If omitted the plane is not returned.\n    Returns:\n      point: The 3D center point of the circle if successful.\n      plane: The plane of the circle if return_plane is True\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          point = rs.CircleCenterPoint(id)\n          rs.AddPoint( point )\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCircumference\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle(Rhino.RhinoMath.ZeroTolerance)\n    if not rc: raise Exception(\"curve is not circle\")\n    if return_plane: return circle.Plane\n    return circle.Center\n\n\ndef CircleCircumference(curve_id, segment_index=-1):\n    \"\"\"Returns the circumference of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The circumference of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          circumference = rs.CircleCircumference(id)\n          print(\"Circle circumference: {}\".format(circumference))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleRadius\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Circumference\n\n\ndef CircleRadius(curve_id, segment_index=-1):\n    \"\"\"Returns the radius of a circle curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The radius of the circle if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select circle\")\n      if rs.IsCircle(id):\n          radius = rs.CircleRadius(id)\n          print(\"Circle radius: {}\".format(radius))\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      IsCircle\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, circle = curve.TryGetCircle( Rhino.RhinoMath.ZeroTolerance )\n    if not rc: raise Exception(\"curve is not circle\")\n    return circle.Radius\n\n\ndef CloseCurve(curve_id, tolerance=-1.0):\n    \"\"\"Closes an open curve object by making adjustments to the end points so\n    they meet at a point\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      tolerance (number, optional): maximum allowable distance between start and end\n                                    point. If omitted, the current absolute tolerance is used\n    Returns:\n      guid: id of the new curve object if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(obj) and rs.IsCurveClosable(obj):\n          rs.CloseCurve( obj )\n    See Also:\n      IsCurveClosable\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.IsClosed: return curve_id\n    if tolerance<0.0: tolerance = Rhino.RhinoMath.ZeroTolerance\n    if not curve.MakeClosed(tolerance): return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(curve)\n    if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ClosedCurveOrientation(curve_id, direction=(0,0,1)):\n    \"\"\"Determine the orientation (counter-clockwise or clockwise) of a closed,\n    planar curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      direction (vector, optional): 3d vector that identifies up, or Z axs, direction of\n                                    the plane to test against\n    Returns:\n      number: 1 if the curve's orientation is counter-clockwise\n             -1 if the curve's orientation is clockwise\n              0 if unable to compute the curve's orientation\n    Example:\n    See Also:\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1 ,True)\n    direction = rhutil.coerce3dvector(direction, True)\n    if not curve.IsClosed: return 0\n    orientation = curve.ClosedCurveOrientation(direction)\n    return int(orientation)\n\n\ndef ConvertCurveToPolyline(curve_id, angle_tolerance=5.0, tolerance=0.01, delete_input=False, min_edge_length=0, max_edge_length=0):\n    \"\"\"Convert curve to a polyline curve\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      angle_tolerance (number, optional): The maximum angle between curve tangents at line endpoints.\n                                          If omitted, the angle tolerance is set to 5.0.\n      tolerance(number, optional): The distance tolerance at segment midpoints. If omitted, the tolerance is set to 0.01.\n      delete_input(bool, optional): Delete the curve object specified by curve_id. If omitted, curve_id will not be deleted.\n      min_edge_length (number, optional): Minimum segment length\n      max_edge_length (number, optonal): Maximum segment length\n    Returns:\n      guid: The new curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          polyline = rs.ConvertCurveToPolyline(obj)\n          if polyline: rs.SelectObject(polyline)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if angle_tolerance<=0: angle_tolerance = 5.0\n    angle_tolerance = Rhino.RhinoMath.ToRadians(angle_tolerance)\n    if tolerance<=0.0: tolerance = 0.01;\n    polyline_curve = curve.ToPolyline( 0, 0, angle_tolerance, 0.0, 0.0, tolerance, min_edge_length, max_edge_length, True)\n    if not polyline_curve: return scriptcontext.errorhandler()\n    id = System.Guid.Empty\n    if delete_input:\n        if scriptcontext.doc.Objects.Replace( curve_id, polyline_curve): id = curve_id\n    else:\n        id = scriptcontext.doc.Objects.AddCurve( polyline_curve )\n    if System.Guid.Empty==id: return scriptcontext.errorhandler()\n    return id\n\n  \ndef CurveArcLengthPoint(curve_id, length, from_start=True):\n    \"\"\"Returns the point on the curve that is a specified arc length\n    from the start of the curve.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      length (number): The arc length from the start of the curve to evaluate.\n      from_start (bool, optional): If not specified or True, then the arc length point is\n          calculated from the start of the curve. If False, the arc length\n          point is calculated from the end of the curve.\n    Returns:\n      point: on curve if successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj)\n          point = rs.CurveArcLengthPoint(obj, length/3.0)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      CurveStartPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    curve_length = curve.GetLength()\n    if curve_length>=length:\n        s = 0.0\n        if length==0.0: s = 0.0\n        elif length==curve_length: s = 1.0\n        else: s = length / curve_length\n        dupe = curve.Duplicate()\n        if dupe:\n            if from_start==False: dupe.Reverse()\n            rc, t = dupe.NormalizedLengthParameter(s)\n            if rc: return dupe.PointAt(t)\n            dupe.Dispose()\n\n\ndef CurveArea(curve_id):\n    \"\"\"Returns area of closed planar curves. The results are based on the\n    current drawing units.\n    Parameters:\n      curve_id (guid): The identifier of a closed, planar curve object.\n    Returns:\n      list[number, number]: List of area information. The list will contain the following information:\n        Element  Description\n        [0]      The area. If more than one curve was specified, the\n                   value will be the cumulative area.\n        [1]      The absolute (+/-) error bound for the area.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveArea(id)\n          if props:\n              print(\"The curve area is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Area, mp.AreaError\n\n\ndef CurveAreaCentroid(curve_id):\n    \"\"\"Returns area centroid of closed, planar curves. The results are based\n    on the current drawing units.\n    Parameters:\n      curve_id (guid)The identifier of a closed, planar curve object.\n    Returns:\n      tuple(point, vector): of area centroid information containing the following information:\n        Element  Description\n        [0]        The 3d centroid point. If more than one curve was specified,\n                 the value will be the cumulative area.\n        [1]        A 3d vector with the absolute (+/-) error bound for the area\n                 centroid.\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if id:\n          props = rs.CurveAreaCentroid(id)\n          if props:\n              print(\"The curve area centroid is: {}\".format(props[0]))\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    mp = Rhino.Geometry.AreaMassProperties.Compute(curve, tol)\n    if mp == None: return None\n    return mp.Centroid, mp.CentroidError\n\n\ndef CurveArrows(curve_id, arrow_style=None):\n    \"\"\"Enables or disables a curve object's annotation arrows\n    Parameters:\n      curve_id (guid): identifier of a curve\n      arrow_style (number, optional): the style of annotation arrow to be displayed. If omitted the current type is returned.\n        0 = no arrows\n        1 = display arrow at start of curve\n        2 = display arrow at end of curve\n        3 = display arrow at both start and end of curve\n      Returns:\n        number: if arrow_style is not specified, the current annotation arrow style\n        number: if arrow_style is specified, the previous arrow style\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.CurveArrows(obj)!=3: rs.CurveArrows(obj, 3)\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rhobj = rhutil.coercerhinoobject(curve_id, True, True)\n    attr = rhobj.Attributes\n    rc = attr.ObjectDecoration\n    none_obj_decor = compat.ENUM_NONE(Rhino.DocObjects.ObjectDecoration)\n    if arrow_style is not None:\n        if arrow_style==0:\n            attr.ObjectDecoration = none_obj_decor\n        elif arrow_style==1:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.StartArrowhead\n        elif arrow_style==2:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.EndArrowhead\n        elif arrow_style==3:\n            attr.ObjectDecoration = Rhino.DocObjects.ObjectDecoration.BothArrowhead\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.ModifyAttributes(id, attr, True)\n        scriptcontext.doc.Views.Redraw()\n    if rc==none_obj_decor: return 0\n    if rc==Rhino.DocObjects.ObjectDecoration.StartArrowhead: return 1\n    if rc==Rhino.DocObjects.ObjectDecoration.EndArrowhead: return 2\n    if rc==Rhino.DocObjects.ObjectDecoration.BothArrowhead: return 3\n\n\ndef CurveBooleanDifference(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the difference between two closed, planar curves and\n    adds the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.CurveBooleanDifference(curveA, curveB)\n      if arrResult:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanIntersection\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanDifference(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanIntersection(curve_id_0, curve_id_1, tolerance=None):\n    \"\"\"Calculates the intersection of two closed, planar curves and adds\n    the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      result = rs.CurveBooleanIntersection(curveA, curveB)\n      if result:\n          rs.DeleteObject( curveA )\n          rs.DeleteObject( curveB )\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanUnion\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanIntersection(curve0, curve1, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n    scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBooleanUnion(curve_id, tolerance=None):\n    \"\"\"Calculate the union of two or more closed, planar curves and\n    add the results to the document. Note, curves must be coplanar.\n    Parameters:\n      curve_id ([guid, guid, ...])list of two or more close planar curves identifiers\n      tolerance (float, optional): a positive tolerance value, or None for the doc default.\n    Returns:\n      list(guid, ...): The identifiers of the new objects.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve_ids = rs.GetObjects(\"Select curves to union\", rs.filter.curve)\n      if curve_ids and len(curve_ids)>1:\n          result = rs.CurveBooleanUnion(curve_ids)\n          if result: rs.DeleteObjects(curve_ids)\n    See Also:\n      CurveBooleanDifference\n      CurveBooleanIntersection\n    \"\"\"\n    in_curves = [rhutil.coercecurve(id,-1,True) for id in curve_id]\n    if len(in_curves)<2: raise ValueException(\"curve_id must have at least 2 curves\")\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    out_curves = Rhino.Geometry.Curve.CreateBooleanUnion(in_curves, tolerance)\n    curves = []\n    if out_curves:\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n                curve.Dispose()\n                if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n                curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n\n\ndef CurveBrepIntersect(curve_id, brep_id, tolerance=None):\n    \"\"\"Intersects a curve object with a brep object. Note, unlike the\n    CurveSurfaceIntersection function, this function works on trimmed surfaces.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      brep_id (guid): identifier of a brep object\n      tolerance (number, optional): distance tolerance at segment midpoints.\n                        If omitted, the current absolute tolerance is used.\n    Returns:\n      list(guid, ...): identifiers for the newly created intersection objects if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if curve:\n          brep = rs.GetObject(\"Select a brep\", rs.filter.surface + rs.filter.polysurface)\n          if brep: rs.CurveBrepIntersect( curve, brep )\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    brep = rhutil.coercebrep(brep_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, out_curves, out_points = Rhino.Geometry.Intersect.Intersection.CurveBrep(curve, brep, tolerance)\n    if not rc: return scriptcontext.errorhandler()\n    \n    curves = []\n    points = []\n    for curve in out_curves:\n        if curve and curve.IsValid:\n            rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n    for point in out_points:\n        if point and point.IsValid:\n            rc = scriptcontext.doc.Objects.AddPoint(point)\n            points.append(rc)\n    if not curves and not points: return None\n    scriptcontext.doc.Views.Redraw()\n    return curves, points\n\n\ndef CurveClosestObject(curve_id, object_ids):\n    \"\"\"Returns the 3D point locations on two objects where they are closest to\n    each other. Note, this function provides similar functionality to that of\n    Rhino's ClosestPt command.\n    Parameters:\n      curve_id (guid):identifier of the curve object to test\n      object_ids ([guid, ...]) list of identifiers of point cloud, curve, surface, or\n        polysurface to test against\n    Returns:\n      tuple[guid, point, point]: containing the results of the closest point calculation.\n      The elements are as follows:\n        [0]    The identifier of the closest object.\n        [1]    The 3-D point that is closest to the closest object.\n        [2]    The 3-D point that is closest to the test curve.\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.pointcloud | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select target objects for closest point\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve\")\n          if curve:\n              results = rs.CurveClosestObject(curve, objects)\n              if results:\n                  print(\"Curve id: {}\".format(results[0]))\n                  rs.AddPoint( results[1] )\n                  rs.AddPoint( results[2] )\n    See Also:\n      CurveClosestPoint\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id,-1,True)\n    geometry = []\n    id = rhutil.coerceguid(object_ids, False)\n    if id: object_ids = [id]\n    for object_id in object_ids:\n        rhobj = rhutil.coercerhinoobject(object_id, True, True)\n        geometry.append( rhobj.Geometry )\n    if not geometry: raise ValueError(\"object_ids must contain at least one item\")\n    success, curve_point, geom_point, which_geom = curve.ClosestPoints(geometry, 0.0)\n    if success: return object_ids[which_geom], geom_point, curve_point\n\n    \ndef CurveClosestPoint(curve_id, test_point, segment_index=-1 ):\n    \"\"\"Returns parameter of the point on a curve that is closest to a test point.\n    Parameters:\n      curve_id (guid): identifier of a curve object\n      point (point): sampling point\n      segment_index (number, optional): curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The parameter of the closest point on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if id:\n          point = rs.GetPointOnCurve(id, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(id, point)\n              print(\"Curve parameter: {}\".format(param))\n    See Also:\n      EvaluateCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: raise Exception(\"ClosestPoint failed\")\n    return t\n\n\ndef CurveContourPoints(curve_id, start_point, end_point, interval=None):\n    \"\"\"Returns the 3D point locations calculated by contouring a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      start_point (point): 3D starting point of a center line.\n      end_point (point): 3D ending point of a center line.\n      interval (number, optional): The distance between contour curves. If omitted,\n      the interval will be equal to the diagonal distance of the object's\n      bounding box divided by 50.\n    Returns:\n      list(point, ....): A list of 3D points, one for each contour\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\", rs.filter.curve)\n      start_point = rs.GetPoint(\"Base point of center line\")\n      end_point = rs.GetPoint(\"Endpoint of center line\", start_point)\n      contour = rs.CurveContourPoints(obj, start_point, end_point)\n      if contour: rs.AddPoints(contour)\n    See Also:\n      AddSrfContourCrvs\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    start_point = rhutil.coerce3dpoint(start_point, True)\n    end_point = rhutil.coerce3dpoint(end_point, True)\n    if start_point.DistanceTo(end_point)<Rhino.RhinoMath.ZeroTolerance:\n        raise Exception(\"start and end point are too close to define a line\")\n    if not interval:\n        bbox = curve.GetBoundingBox(True)\n        diagonal = bbox.Max - bbox.Min\n        interval = diagonal.Length / 50.0\n    rc = curve.DivideAsContour( start_point, end_point, interval )\n    return list(rc)\n\n\ndef CurveCurvature(curve_id, parameter):\n    \"\"\"Returns the curvature of a curve at a parameter. See the Rhino help for\n    details on curve curvature\n    Parameters:\n      curve_id (guid): identifier of the curve\n      parameter (number): parameter to evaluate\n    Returns:\n      tuple[point, vector, point, number, vector]: of curvature information on success\n        [0] = point at specified parameter\n        [1] = tangent vector\n        [2] = center of radius of curvature\n        [3] = radius of curvature\n        [4] = curvature vector\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              if param:\n                  data = rs.CurveCurvature(obj, param)\n                  if data:\n                      print(\"Curve curvature evaluation at parameter {}\".format(param, \":\"))\n                      print(\" 3-D Point: {}\".format(data[0]))\n                      print(\" 3-D Tangent: {}\".format(data[1]))\n                      print(\" Center of radius of curvature: {}\".format(data[2]))\n                      print(\" Radius of curvature: {}\".format(data[3]))\n                      print(\" 3-D Curvature: {}\".format(data[4]))\n    See Also:\n      SurfaceCurvature\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = curve.PointAt(parameter)\n    tangent = curve.TangentAt(parameter)\n    if tangent.IsTiny(0): return scriptcontext.errorhandler()\n    cv = curve.CurvatureAt(parameter)\n    k = cv.Length\n    if k<Rhino.RhinoMath.SqrtEpsilon: return scriptcontext.errorhandler()\n    rv = cv / (k*k)\n    circle = Rhino.Geometry.Circle(point, tangent, point + 2.0*rv)\n    center = point + rv\n    radius = circle.Radius\n    return point, tangent, center, radius, cv\n\n\ndef CurveCurveIntersection(curveA, curveB=None, tolerance=-1):\n    \"\"\"Calculates intersection of two curve objects.\n    Parameters:\n      curveA (guid): identifier of the first curve object.\n      curveB  (guid, optional): identifier of the second curve object. If omitted, then a\n               self-intersection test will be performed on curveA.\n      tolerance (number, optional): absolute tolerance in drawing units. If omitted,\n                        the document's current absolute tolerance is used.\n    Returns:\n      list of tuples: containing intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point (1) or Overlap (2).\n        [n][1]  Point3d  If the event type is Point (1), then the intersection point \n                         on the first curve. If the event type is Overlap (2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point (1), then the intersection point\n                         on the first curve. If the event type is Overlap (2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point (1), then the intersection point \n                         on the second curve. If the event type is Overlap (2), then\n                         intersection start point on the second curve.\n        [n][4]  Point3d  If the event type is Point (1), then the intersection point\n                         on the second curve. If the event type is Overlap (2), then\n                         intersection end point on the second curve.\n        [n][5]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point (1), then the first curve parameter.\n                         If the event type is Overlap (2), then the end value of the\n                         first curve parameter range.\n        [n][7]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the start value of the\n                         second curve parameter range.\n        [n][8]  Number   If the event type is Point (1), then the second curve parameter.\n                         If the event type is Overlap (2), then the end value of the \n                         second curve parameter range.\n    Example:\n      import rhinoscriptsyntax as rs\n      def ccx():\n          curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve)\n          if curve1 is None: return\n          curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve)\n          if curve2 is None: return\n          intersection_list = rs.CurveCurveIntersection(curve1, curve2)\n          if intersection_list is None:\n              print(\"Selected curves do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0] == 1:\n                  print(\"Point\")\n                  print(\"Intersection point on first curve:  {}\".format(intersection[1]))\n                  print(\"Intersection point on second curve:  {}\".format(intersection[3]))\n                  print(\"First curve parameter:  {}\".format(intersection[5]))\n                  print(\"Second curve parameter:  {}\".format(intersection[7]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on first curve: {}\".format(intersection[1]))\n                  print(\"Intersection end point on first curve: {}\".format(intersection[2]))\n                  print(\"Intersection start point on second curve: {}\".format(intersection[3]))\n                  print(\"Intersection end point on second curve: {}\".format(intersection[4]))\n                  print(\"First curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Second curve parameter range: {} to {}\".format(intersection[7], intersection[8]))\n      ccx()\n    See Also:\n      CurveSurfaceIntersection\n    \"\"\"\n    curveA = rhutil.coercecurve(curveA, -1, True)\n    if curveB: curveB = rhutil.coercecurve(curveB, -1, True)\n    if tolerance is None or tolerance<0.0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if curveB:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA, curveB, tolerance, 0.0)\n    else:\n        rc = Rhino.Geometry.Intersect.Intersection.CurveSelf(curveA, tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 1\n            if( rc[i].IsOverlap ): event_type = 2\n            oa = rc[i].OverlapA\n            ob = rc[i].OverlapB\n            element = (event_type, rc[i].PointA, rc[i].PointA2, rc[i].PointB, rc[i].PointB2, oa[0], oa[1], ob[0], ob[1])\n            events.append(element)\n        return events\n\n\ndef CurveDegree(curve_id, segment_index=-1):\n    \"\"\"Returns the degree of a curve object.\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      number: The degree of the curve if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          degree = rs.CurveDegree(obj)\n          print(\"Curve degree:{}\".format(degree))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Degree\n\n\ndef CurveDeviation(curve_a, curve_b):\n    \"\"\"Returns the minimum and maximum deviation between two curve objects\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two curves\n    Returns:\n      tuple[number, number, number, number, number, number]: of deviation information on success\n        [0] = curve_a parameter at maximum overlap distance point\n        [1] = curve_b parameter at maximum overlap distance point\n        [2] = maximum overlap distance\n        [3] = curve_a parameter at minimum overlap distance point\n        [4] = curve_b parameter at minimum overlap distance point\n        [5] = minimum distance between curves\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve to test\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve to test\", rs.filter.curve)\n      deviation = rs.CurveDeviation(curveA, curveB)\n      if deviation:\n          print(\"Minimum deviation = {}\".format(deviation[5]))\n          print(\"Maximum deviation = {}\".format(deviation[2]))\n    See Also:\n      CurveArea\n      CurveAreaCentroid\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc = Rhino.Geometry.Curve.GetDistancesBetweenCurves(curve_a, curve_b, tol)\n    if not rc[0]: return scriptcontext.errorhandler()\n    maxa = rc[2]\n    maxb = rc[3]\n    maxd = rc[1]\n    mina = rc[5]\n    minb = rc[6]\n    mind = rc[4]\n    return maxa, maxb, maxd, mina, minb, mind\n\n\ndef CurveDim(curve_id, segment_index=-1):\n    \"\"\"Returns the dimension of a curve object\n    Parameters:\n      curve_id (guid): identifier of a curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The dimension of the curve if successful. None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(curve):\n          print(\"Curve dimension = {}\".format(rs.CurveDim(curve)))\n    See Also:\n      CurveDegree\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Dimension\n\n\ndef CurveDirectionsMatch(curve_id_0, curve_id_1):\n    \"\"\"Tests if two curve objects are generally in the same direction or if they\n    would be more in the same direction if one of them were flipped. When testing\n    curve directions, both curves must be either open or closed - you cannot test\n    one open curve and one closed curve.\n    Parameters:\n      curve_id_0 (guid): identifier of first curve object\n      curve_id_1 (guid): identifier of second curve object\n    Returns:\n      bool: True if the curve directions match, otherwise False.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve to compare\", rs.filter.curve)\n      curve2 = rs.GetObject(\"Select second curve to compare\", rs.filter.curve)\n      if rs.CurveDirectionsMatch(curve1, curve2):\n          print(\"Curves are in the same direction\")\n      else:\n          print(\"Curve are not in the same direction\")\n    See Also:\n      ReverseCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    return Rhino.Geometry.Curve.DoDirectionsMatch(curve0, curve1)\n\n\ndef CurveDiscontinuity(curve_id, style):   \n    \"\"\"Search for a derivatitive, tangent, or curvature discontinuity in\n    a curve object.\n    Parameters:\n      curve_id (guid): identifier of curve object\n      style (number): The type of continuity to test for. The types of\n          continuity are as follows:\n          Value    Description\n          1        C0 - Continuous function\n          2        C1 - Continuous first derivative\n          3        C2 - Continuous first and second derivative\n          4        G1 - Continuous unit tangent\n          5        G2 - Continuous unit tangent and curvature\n    Returns:\n      list(point, ...): 3D points where the curve is discontinuous\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          points = rs.CurveDiscontinuity(curve, 2)\n          if points: rs.AddPoints( points )\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    dom = curve.Domain\n    t0 = dom.Min\n    t1 = dom.Max\n    points = []\n    get_next = True\n    while get_next:\n        get_next, t = curve.GetNextDiscontinuity(System.Enum.ToObject(Rhino.Geometry.Continuity, style), t0, t1)\n        if get_next:\n            points.append(curve.PointAt(t))\n            t0 = t # Advance to the next parameter\n    return points\n\n\ndef CurveDomain(curve_id, segment_index=-1):\n    \"\"\"Returns the domain of a curve object\n    as an indexable object with two elements.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, number): the domain of the curve if successful.\n         [0] Domain minimum\n         [1] Domain maximum\n      None: on error\n\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          print(\"Curve domain: {} to {}\".format(domain[0], domain[1]))\n    See Also:\n      CurveDegree\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.Domain\n\n\ndef CurveEditPoints(curve_id, return_parameters=False, segment_index=-1):\n    \"\"\"Returns the edit, or Greville, points of a curve object. \n    For each curve control point, there is a corresponding edit point.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      return_parameters (bool, optional): if True, return as a list of curve parameters.\n                                          If False, return as a list of 3d points\n      segment_index (number, optional): the curve segment index is `curve_id` identifies a polycurve\n    Returns:\n      list(point, ....): curve edit points on success\n      None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurveEditPoints(obj)\n          if points: rs.AddPointCloud( points )\n    See Also:\n      IsCurve\n      CurvePointCount\n      CurvePoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    if return_parameters: return nc.GrevilleParameters()\n    return list(nc.GrevillePoints())\n\n\ndef CurveEndPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the end point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3d endpoint of the curve if successful.\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveEndPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveMidPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAtEnd\n\n\ndef CurveFilletPoints(curve_id_0, curve_id_1, radius=1.0, base_point_0=None, base_point_1=None, return_points=True):\n    \"\"\"Find points at which to cut a pair of curves so that a fillet of a\n    specified radius fits. A fillet point is a pair of points (point0, point1)\n    such that there is a circle of radius tangent to curve curve0 at point0 and\n    tangent to curve curve1 at point1. Of all possible fillet points, this\n    function returns the one which is the closest to the base point base_point_0,\n    base_point_1. Distance from the base point is measured by the sum of arc\n    lengths along the two curves. \n    Parameters:\n      curve_id_0 (guid): identifier of the first curve object.\n      curve_id_1 (guid): identifier of the second curve object.\n      radius (number, optional): The fillet radius. If omitted, a radius\n                     of 1.0 is specified.\n      base_point_0 (point, optional): The base point on the first curve.\n                     If omitted, the starting point of the curve is used.\n      base_point_1 (point, optional): The base point on the second curve. If omitted,\n                     the starting point of the curve is used.\n      return_points (bool, optional): If True (Default), then fillet points are\n                     returned. Otherwise, a fillet curve is created and\n                     it's identifier is returned.\n    Returns:\n      list(point, point, point, vector, vector, vector): If return_points is True, then a list of point and vector values\n      if successful. The list elements are as follows:\n          [0]    A point on the first curve at which to cut (point).\n          [1]    A point on the second curve at which to cut (point).\n          [2]    The fillet plane's origin (point). This point is also\n                   the center point of the fillet\n          [3]    The fillet plane's X axis (vector).\n          [4]    The fillet plane's Y axis (vector).\n          [5]    The fillet plane's Z axis (vector).\n      \n      guid: If return_points is False, then the identifier of the fillet curve\n            if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.AddLine([0,0,0], [5,1,0])\n      curve1 = rs.AddLine([0,0,0], [1,5,0])\n      fillet = rs.CurveFilletPoints(curve0, curve1)\n      if fillet:\n          rs.AddPoint( fillet[0] )\n          rs.AddPoint( fillet[1] )\n          rs.AddPoint( fillet[2] )\n    See Also:\n      AddFilletCurve\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve_id_0, -1, True)\n    curve1 = rhutil.coercecurve(curve_id_1, -1, True)\n    t0_base = curve0.Domain.Min\n    \n    if base_point_0:\n        rc = curve0.ClosestPoint(base_point_0, t0_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n    \n    t1_base = curve1.Domain.Min\n    if base_point_1:\n        rc = curve1.ClosestPoint(base_point_1, t1_base)\n        if not rc[0]: return scriptcontext.errorhandler()\n\n    r = radius if (radius and radius>0) else 1.0\n    rc = Rhino.Geometry.Curve.GetFilletPoints(curve0, curve1, r, t0_base, t1_base)\n    if rc[0]:\n        point_0 = curve0.PointAt(rc[1])\n        point_1 = curve1.PointAt(rc[2])\n        return point_0, point_1, rc[3].Origin, rc[3].XAxis, rc[3].YAxis, rc[3].ZAxis\n    return scriptcontext.errorhandler()\n\n\ndef CurveFrame(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns the plane at a parameter of a curve. The plane is based on the\n    tangent and curvature vectors at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      parameter (number): parameter to evaluate.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane at the specified parameter if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetCurveObject(\"Select a curve\")\n      if curve:\n          plane = rs.CurveFrame(curve[0], curve[4])\n          rs.AddPlaneSurface(plane, 5.0, 3.0)\n    See Also:\n      CurvePerpFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    domain = curve.Domain\n    if not domain.IncludesParameter(parameter):\n        tol = scriptcontext.doc.ModelAbsoluteTolerance\n        if parameter>domain.Max and (parameter-domain.Max)<=tol:\n            parameter = domain.Max\n        elif parameter<domain.Min and (domain.Min-parameter)<=tol:\n            parameter = domain.Min\n        else:\n            return scriptcontext.errorhandler()\n    rc, frame = curve.FrameAt(parameter)\n    if rc and frame.IsValid: return frame\n    return scriptcontext.errorhandler()\n\n\ndef CurveKnotCount(curve_id, segment_index=-1):\n    \"\"\"Returns the knot count of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve.\n    Returns:\n      number: The number of knots if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurveKnotCount(obj)\n          print(\"Curve knot count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    return nc.Knots.Count\n\n\ndef CurveKnots(curve_id, segment_index=-1):\n    \"\"\"Returns the knots, or knot vector, of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve.\n    Returns:\n      list(number, ....): knot values if successful.\n      None: if not successful or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          knots = rs.CurveKnots(obj)\n          if knots:\n              for knot in knots: print(\"Curve knot value:{}\".format(knot))\n    See Also:\n      CurveKnotCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if not nc: return scriptcontext.errorhandler()\n    rc = [nc.Knots[i] for i in range(nc.Knots.Count)]\n    return rc\n\n\ndef CurveLength(curve_id, segment_index=-1, sub_domain=None):\n    \"\"\"Returns the length of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      sub_domain ([number, number], optional): list of two numbers identifying the sub-domain of the\n          curve on which the calculation will be performed. The two parameters\n          (sub-domain) must be non-decreasing. If omitted, the length of the\n          entire curve is returned.\n    Returns:\n      number: The length of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          length = rs.CurveLength(object)\n          print(\"Curve length:{}\".format(length))\n    See Also:\n      CurveDomain\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if sub_domain:\n        if len(sub_domain)==2:\n            dom = Rhino.Geometry.Interval(sub_domain[0], sub_domain[1])\n            return curve.GetLength(dom)\n        return scriptcontext.errorhandler()\n    return curve.GetLength()\n\n\ndef CurveMidPoint(curve_id, segment_index=-1):\n    \"\"\"Returns the mid point of a curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: The 3D midpoint of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveMidPoint(pbject)\n          rs.AddPoint( point )\n    See Also:\n      CurveEndPoint\n      CurveStartPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, t = curve.NormalizedLengthParameter(0.5)\n    if rc: return curve.PointAt(t)\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormal(curve_id, segment_index=-1):\n    \"\"\"Returns the normal direction of the plane in which a planar curve object lies.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      vector: The 3D normal vector if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a planar curve\")\n      if rs.IsCurve(object) and rs.IsCurvePlanar(object):\n          normal = rs.CurveNormal(object)\n          if normal: print(\"Curve Normal:{}\".format(normal))\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane.Normal\n    return scriptcontext.errorhandler()\n\n\ndef CurveNormalizedParameter(curve_id, parameter):\n    \"\"\"Converts a curve parameter to a normalized curve parameter;\n    one that ranges between 0-1\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the curve parameter to convert\n    Returns:\n      number: normalized curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0]+domain[1])/2.0\n          print(\"Curve parameter:{}\".format(parameter))\n          normalized = rs.CurveNormalizedParameter(obj, parameter)\n          print(\"Normalized parameter:{}\".format(normalized))\n    See Also:\n      CurveDomain\n      CurveParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.NormalizedParameterAt(parameter)\n\n\ndef CurveParameter(curve_id, parameter):\n    \"\"\"Converts a normalized curve parameter to a curve parameter;\n    one within the curve's domain\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): the normalized curve parameter to convert\n    Returns:\n      number: curve parameter\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve\")\n      if rs.IsCurve(obj):\n          normalized = 0.5\n          print(\"Normalized parameter:{}\".format(normalized))\n          parameter = rs.CurveParameter(obj, normalized)\n          print(\"Curve parameter:{}\".format(parameter))\n    See Also:\n      CurveDomain\n      CurveNormalizedParameter\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    return curve.Domain.ParameterAt(parameter)\n\n\ndef CurvePerpFrame(curve_id, parameter):\n    \"\"\"Returns the perpendicular plane at a parameter of a curve. The result\n    is relatively parallel (zero-twisting) plane\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter to evaluate\n    Returns:\n      plane: Plane on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetCurveObject(\"Select a curve\")\n      if crv:\n          plane = rs.CurvePerpFrame(crv[0], crv[4])\n          rs.AddPlaneSurface( plane, 1, 1 )\n    See Also:\n      CurveFrame\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    parameter = float(parameter)\n    rc, plane = curve.PerpendicularFrameAt(parameter)\n    if rc: return plane\n\n\ndef CurvePlane(curve_id, segment_index=-1):\n    \"\"\"Returns the plane in which a planar curve lies. Note, this function works\n    only on planar curves.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      plane: The plane in which the curve lies if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePlanar(curve):\n          plane = rs.CurvePlane(curve)\n          rs.ViewCPlane(None, plane)\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    rc, plane = curve.TryGetPlane(tol)\n    if rc: return plane\n    return scriptcontext.errorhandler()\n\n\ndef CurvePointCount(curve_id, segment_index=-1):\n    \"\"\"Returns the control points count of a curve object.\n    Parameters:\n      curve_id (guid) identifier of the curve object\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      number: Number of control points if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          count = rs.CurvePointCount(obj)\n          print(\"Curve point count:{}\".format(count))\n    See Also:\n      DivideCurve\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc: return nc.Points.Count\n    return scriptcontext.errorhandler()\n\n\ndef CurvePoints(curve_id, segment_index=-1):\n    \"\"\"Returns the control points, or control vertices, of a curve object.\n    If the curve is a rational NURBS curve, the euclidean control vertices\n    are returned.\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): the curve segment if `curve_id` identifies a polycurve\n    Returns:\n      list(point, ...): the control points, or control vertices, of a curve object\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          points = rs.CurvePoints(obj)\n          if points: [rs.AddPoint(pt) for pt in points]\n    See Also:\n      CurvePointCount\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    points = [nc.Points[i].Location for i in compat.RANGE(nc.Points.Count)]\n    return points\n\n\ndef CurveRadius(curve_id, test_point, segment_index=-1):\n    \"\"\"Returns the radius of curvature at a point on a curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      test_point (point): sampling point\n      segment_index (number, optional): the curve segment if curve_id identifies a polycurve\n    Returns:\n      number: The radius of curvature at the point on the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPointOnCurve(obj, \"Pick a test point\")\n          if point:\n              radius = rs.CurveRadius(obj, point)\n              print(\"Radius of curvature:{}\".format(radius))\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    point = rhutil.coerce3dpoint(test_point, True)\n    rc, t = curve.ClosestPoint(point, 0.0)\n    if not rc: return scriptcontext.errorhandler()\n    v = curve.CurvatureAt( t )\n    k = v.Length\n    if k>Rhino.RhinoMath.ZeroTolerance: return 1/k\n    return scriptcontext.errorhandler()\n\n\ndef CurveSeam(curve_id, parameter):\n    \"\"\"Adjusts the seam, or start/end, point of a closed curve.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): The parameter of the new start/end point.\n                  Note, if successful, the resulting curve's\n                  domain will start at `parameter`.\n    Returns:\n      bool: True or False indicating success or failure.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(obj):\n          domain = rs.CurveDomain(obj)\n          parameter = (domain[0] + domain[1])/2.0\n          rs.CurveSeam( obj, parameter )\n    See Also:\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if (not curve.IsClosed or not curve.Domain.IncludesParameter(parameter)):\n        return False\n    dupe = curve.Duplicate()\n    if dupe:\n        dupe.ChangeClosedCurveSeam(parameter)\n        curve_id = rhutil.coerceguid(curve_id)\n        dupe_obj = scriptcontext.doc.Objects.Replace(curve_id, dupe)\n        return dupe_obj is not None\n    return False\n\n\ndef CurveStartPoint(curve_id, segment_index=-1, point=None):\n    \"\"\"Returns the start point of a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n      point (point, optional): new start point\n    Returns:\n      point: The 3D starting point of the curve if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          point = rs.CurveStartPoint(object)\n          rs.AddPoint(point)\n    See Also:\n      CurveEndPoint\n      CurveMidPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = curve.PointAtStart\n    if point:\n        point = rhutil.coerce3dpoint(point, True)\n        if point and curve.SetStartPoint(point):\n            curve_id = rhutil.coerceguid(curve_id, True)\n            scriptcontext.doc.Objects.Replace(curve_id, curve)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveSurfaceIntersection(curve_id, surface_id, tolerance=-1, angle_tolerance=-1):\n    \"\"\"Calculates intersection of a curve object with a surface object.\n    Note, this function works on the untrimmed portion of the surface.\n    Parameters:\n      curve_id (guid): The identifier of the first curve object.\n      surface_id (guid): The identifier of the second curve object. If omitted,\n          the a self-intersection test will be performed on curve.\n      tolerance (number, optional): The absolute tolerance in drawing units. If omitted,\n          the document's current absolute tolerance is used.\n      angle_tolerance (number, optional) angle tolerance in degrees. The angle\n          tolerance is used to determine when the curve is tangent to the\n          surface. If omitted, the document's current angle tolerance is used.\n    Returns:\n      list(list(point, point, point, point, number, number, number, number, number, number), ...): of intersection information if successful.\n      The list will contain one or more of the following elements:\n        Element Type     Description\n        [n][0]  Number   The intersection event type, either Point(1) or Overlap(2).\n        [n][1]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection start point on the first curve.\n        [n][2]  Point3d  If the event type is Point(1), then the intersection point\n                         on the first curve. If the event type is Overlap(2), then\n                         intersection end point on the first curve.\n        [n][3]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection start point on the surface.\n        [n][4]  Point3d  If the event type is Point(1), then the intersection point\n                         on the second curve. If the event type is Overlap(2), then\n                         intersection end point on the surface.\n        [n][5]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the start value of the\n                         first curve parameter range.\n        [n][6]  Number   If the event type is Point(1), then the first curve parameter.\n                         If the event type is Overlap(2), then the end value of the\n                         curve parameter range.\n        [n][7]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 5).\n        [n][8]  Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 5).\n        [n][9]  Number   If the event type is Point(1), then the U surface parameter.\n                         If the event type is Overlap(2), then the U surface parameter\n                         for curve at (n, 6).\n        [n][10] Number   If the event type is Point(1), then the V surface parameter.\n                         If the event type is Overlap(2), then the V surface parameter\n                         for curve at (n, 6).\n    Example:\n      import rhinoscriptsyntax as rs\n      def csx():\n          curve = rs.GetObject(\"Select curve\", rs.filter.curve)\n          if curve is None: return\n          surface = rs.GetObject(\"Select surface\", rs.filter.surface)\n          if surface is None: return\n          intersection_list = rs.CurveSurfaceIntersection(curve, surface)\n          if intersection_list is None:\n              print(\"Curve and surface do not intersect.\")\n              return\n          for intersection in intersection_list:\n              if intersection[0]==1:\n                  print(\"Point\")\n                  print(\"Intersection point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection point on surface:{}\".format(intersection[3]))\n                  print(\"Curve parameter:{}\".format(intersection[5]))\n                  print(\"Surface parameter: {}, {}\".format(intersection[7], intersection[8]))\n              else:\n                  print(\"Overlap\")\n                  print(\"Intersection start point on curve:{}\".format(intersection[1]))\n                  print(\"Intersection end point on curve:{}\".format(intersection[2]))\n                  print(\"Intersection start point on surface:{}\".format(intersection[3]))\n                  print(\"Intersection end point on surface:{}\".format(intersection[4]))\n                  print(\"Curve parameter range: {} to {}\".format(intersection[5], intersection[6]))\n                  print(\"Surface parameter range: {}, {} to {}, {}\".format(intersection[7] intersection[8], intersection[9], intersection[10]))\n      csx()\n    See Also:\n      CurveCurveIntersection\n      CurveBrepIntersect\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    if tolerance is None or tolerance<0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    else:\n        angle_tolerance = math.radians(angle_tolerance)\n    rc = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve, surface, tolerance, angle_tolerance)\n    if rc:\n        events = []\n        for i in compat.RANGE(rc.Count):\n            event_type = 2 if rc[i].IsOverlap else 1\n            item = rc[i]\n            oa = item.OverlapA\n            u,v = item.SurfaceOverlapParameter()\n            e = (event_type, item.PointA, item.PointA2, item.PointB, item.PointB2, oa[0], oa[1], u[0], u[1], v[0], v[1])\n            events.append(e)\n        return events\n\n\ndef CurveTangent(curve_id, parameter, segment_index=-1):\n    \"\"\"Returns a 3D vector that is the tangent to a curve at a parameter.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number) parameter to evaluate\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      vector: A 3D vector if successful.\n      None: on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj)\n          if point:\n              param = rs.CurveClosestPoint(obj, point)\n              normal = rs.CurveTangent(obj, param)\n              print(normal)\n    See Also:\n      CurveClosestPoint\n      CurveDomain\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc = Rhino.Geometry.Point3d.Unset\n    if curve.Domain.IncludesParameter(parameter):\n        return curve.TangentAt(parameter)\n    return scriptcontext.errorhandler()\n\n\ndef CurveWeights(curve_id, segment_index=-1):\n    \"\"\"Returns list of weights that are assigned to the control points of a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      number: The weight values of the curve if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          weights = rs.CurveWeights(obj)\n          if weights:\n              for weight in weights:\n                  print(\"Curve control point weight value:{}\".format(weight))\n    See Also:\n      CurveKnots\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    nc = curve\n    if type(curve) is not Rhino.Geometry.NurbsCurve:\n        nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    return [pt.Weight for pt in nc.Points]\n\n\ndef DivideCurve(curve_id, segments, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into a specified number of segments.\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segments (number): The number of segments.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point|number, ...): If `return_points` is not specified or True, then a list containing 3D division points.\n      list(point|number, ...): If `return_points` is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if obj:\n          points = rs.DivideCurve(obj, 4)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurveEquidistant\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByCount(segments, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if return_points: rc = outputpoints\n        if create_points:\n            for point in outputpoints:\n                if point.IsValid: scriptcontext.doc.Objects.AddPoint(point)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef DivideCurveEquidistant(curve_id, distance, create_points=False, return_points=True):\n    \"\"\"Divides a curve such that the linear distance between the points is equal.\n    Parameters:\n      curve_id (guid): the object's identifier\n      distance (number): linear distance between division points\n      create_points (bool, optional): create the division points if True.\n      return_points (bool, optional): If True, return a list of points.\n                                      If False, return a list of curve parameters\n    Returns:\n      list(point|number, ...): points or curve parameters based on the value of return_points\n      none on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if obj:\n          points = rs.DivideCurveEquidistant(obj, 4, True)\n    See Also:\n      DivideCurve\n      DivideCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    points = curve.DivideEquidistant(distance)\n    if not points: return scriptcontext.errorhandler()\n    if create_points:\n        for point in points: scriptcontext.doc.Objects.AddPoint(point)\n        scriptcontext.doc.Views.Redraw()\n    if return_points: return points\n    tvals = []\n    for point in points:\n        rc, t = curve.ClosestPoint(point)\n        tvals.append(t)\n    return tvals\n\n\ndef DivideCurveLength(curve_id, length, create_points=False, return_points=True):\n    \"\"\"Divides a curve object into segments of a specified length.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      length (number): The length of each segment.\n      create_points (bool, optional): Create the division points. If omitted or False,\n          points are not created.\n      return_points (bool, optional): If omitted or True, points are returned.\n          If False, then a list of curve parameters are returned.\n    Returns:\n      list(point, ...): If return_points is not specified or True, then a list containing division points.\n      list(number, ...): If return_points is False, then an array containing division curve parameters.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          length = rs.CurveLength(obj) / 4\n          points = rs.DivideCurveLength(obj, length)\n          for point in points: rs.AddPoint(point)\n    See Also:\n      DivideCurve\n      DivideCurveEquidistant\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc = curve.DivideByLength(length, True)\n    if not rc: return scriptcontext.errorhandler()\n    if return_points or create_points:\n        outputpoints = [curve.PointAt(t) for t in rc]\n        if create_points:\n            for point in outputpoints:\n                if (point.IsValid): scriptcontext.doc.Objects.AddPoint(point)\n        if return_points: rc = outputpoints\n    return rc\n\n\ndef EllipseCenterPoint(curve_id):\n    \"\"\"Returns the center point of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      point: The 3D center point of the ellipse if successful.\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          point = rs.EllipseCenterPoint(obj)\n          rs.AddPoint( point )\n    See Also:\n      IsEllipse\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    return ellipse.Plane.Origin\n\n\ndef EllipseQuadPoints(curve_id):\n    \"\"\"Returns the quadrant points of an elliptical-shaped curve object.\n    Parameters:\n      curve_id (guid): identifier of the curve object.\n    Returns:\n      list(point, point, point, point): Four points identifying the quadrants of the ellipse\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select ellipse\")\n      if rs.IsEllipse(obj):\n          rs.AddPoints( rs.EllipseQuadPoints(obj) )\n    See Also:\n      IsEllipse\n      EllipseCenterPoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    rc, ellipse = curve.TryGetEllipse()\n    if not rc: raise ValueError(\"curve is not an ellipse\")\n    origin = ellipse.Plane.Origin;\n    xaxis = ellipse.Radius1 * ellipse.Plane.XAxis;\n    yaxis = ellipse.Radius2 * ellipse.Plane.YAxis;\n    return (origin-xaxis, origin+xaxis, origin-yaxis, origin+yaxis)\n\n\ndef EvaluateCurve(curve_id, t, segment_index=-1):\n    \"\"\"Evaluates a curve at a parameter and returns a 3D point\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      t (number): the parameter to evaluate\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      point: a 3-D point if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          domain = rs.CurveDomain(obj)\n          t = domain[1]/2.0\n          point = rs.EvaluateCurve(obj, t)\n          rs.AddPoint( point )\n    See Also:\n      CurveClosestPoint\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.PointAt(t)\n\n\ndef ExplodeCurves(curve_ids, delete_input=False):\n    \"\"\"Explodes, or un-joins, one curves. Polycurves will be exploded into curve\n    segments. Polylines will be exploded into line segments. ExplodeCurves will\n    return the curves in topological order. \n    Parameters:\n      curve_ids (guid): the curve object(s) to explode.\n      delete_input (bool, optional): Delete input objects after exploding if True.\n    Returns:\n      list(guid, ...): identifying the newly created curve objects\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve to explode\", rs.filter.curve)\n      if rs.IsCurve(crv): rs.ExplodeCurves(crv)\n    See Also:\n      IsCurve\n      IsPolyCurve\n      IsPolyline\n      JoinCurves\n    \"\"\"\n    if( type(curve_ids) is list or type(curve_ids) is tuple ): pass\n    else: curve_ids = [curve_ids]\n    rc = []\n    for id in curve_ids:\n        curve = rhutil.coercecurve(id, -1, True)\n        pieces = curve.DuplicateSegments()\n        if pieces:\n            for piece in pieces:\n                rc.append(scriptcontext.doc.Objects.AddCurve(piece))\n            if delete_input:\n                id = rhutil.coerceguid(id, True)\n                scriptcontext.doc.Objects.Delete(id, True)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExtendCurve(curve_id, extension_type, side, boundary_object_ids):\n    \"\"\"Extends a non-closed curve object by a line, arc, or smooth extension\n    until it intersects a collection of objects.\n    Parameters:\n      curve_id (guid): identifier of curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from the start of the curve\n        1=extend from the end of the curve\n        2=extend from both the start and the end of the curve\n      boundary_object_ids (guid): curve, surface, and polysurface objects to extend to\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      filter = rs.filter.curve | rs.filter.surface | rs.filter.polysurface\n      objects = rs.GetObjects(\"Select boundary objects\", filter)\n      if objects:\n          curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n          if curve: rs.ExtendCurve( curve, 2, 1, objects )\n    See Also:\n      ExtendCurveLength\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    rhobjs = [rhutil.coercerhinoobject(id) for id in boundary_object_ids]\n    if not rhobjs: raise ValueError(\"boundary_object_ids must contain at least one item\")\n    geometry = [obj.Geometry for obj in rhobjs]\n    newcurve = curve.Extend(side, extension_type, geometry)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurveLength(curve_id, extension_type, side, length):\n    \"\"\"Extends a non-closed curve by a line, arc, or smooth extension for a\n    specified distance\n    Parameters:\n      curve_id (guid): curve to extend\n      extension_type (number):\n        0 = line\n        1 = arc\n        2 = smooth\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n        2=Extend from both ends\n      length (number): distance to extend\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          length = rs.GetReal(\"Length to extend\", 3.0)\n          if length: rs.ExtendCurveLength( curve, 2, 2, length )\n    See Also:\n      ExtendCurve\n      ExtendCurvePoint\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    newcurve = None\n    if length<0: newcurve = curve.Trim(side, -length)\n    else: newcurve = curve.Extend(side, length, extension_type)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef ExtendCurvePoint(curve_id, side, point, extension_type=2):\n    \"\"\"Extends a non-closed curve by smooth extension to a point\n    Parameters:\n      curve_id (guid): curve to extend\n      side (number):\n        0=extend from start of the curve\n        1=extend from end of the curve\n      point (guid|point): point to extend to\n      extension_type (number, optional): type of extension\n        0 = Line\n        1 = Arc\n        2 = Smooth\n    Returns:\n      guid: The identifier of the new object if successful.\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to extend\", rs.filter.curve)\n      if curve:\n          point = rs.GetPoint(\"Point to extend to\")\n          if point: rs.ExtendCurvePoint(curve, 1, point)\n    See Also:\n      ExtendCurve\n      ExtendCurveLength\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    point = rhutil.coerce3dpoint(point, True)\n    \n    if side==0: side = Rhino.Geometry.CurveEnd.Start\n    elif side==1: side = Rhino.Geometry.CurveEnd.End\n    elif side==2: side = Rhino.Geometry.CurveEnd.Both\n    else: raise ValueError(\"side must be 0, 1, or 2\")\n    \n    if extension_type==0: extension_type = Rhino.Geometry.CurveExtensionStyle.Line\n    elif extension_type==1: extension_type = Rhino.Geometry.CurveExtensionStyle.Arc\n    elif extension_type==2: extension_type = Rhino.Geometry.CurveExtensionStyle.Smooth\n    else: raise ValueError(\"extension_type must be 0, 1, or 2\")\n    \n    newcurve = curve.Extend(side, extension_type, point)\n    if newcurve and newcurve.IsValid:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        if scriptcontext.doc.Objects.Replace( curve_id, newcurve ):\n            scriptcontext.doc.Views.Redraw()\n            return curve_id\n    return scriptcontext.errorhandler()\n\n\ndef FairCurve(curve_id, tolerance=1.0):\n    \"\"\"Fairs a curve. Fair works best on degree 3 (cubic) curves. Fair attempts\n    to remove large curvature variations while limiting the geometry changes to\n    be no more than the specified tolerance. Sometimes several applications of\n    this method are necessary to remove nasty curvature problems.\n    Parameters:\n      curve_id (guid): curve to fair\n      tolerance (number, optional): fairing tolerance\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curves = rs.GetObjects(\"Select curves to fair\", rs.filter.curve)\n      if curves:\n          [rs.FairCurve(curve) for curve in curves]\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    angle_tol = 0.0\n    clamp = 0\n    if curve.IsPeriodic:\n        curve = curve.ToNurbsCurve()\n        clamp = 1\n    newcurve = curve.Fair(tolerance, angle_tol, clamp, clamp, 100)\n    if not newcurve: return False\n    curve_id = rhutil.coerceguid(curve_id, True)\n    if scriptcontext.doc.Objects.Replace(curve_id, newcurve):\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef FitCurve(curve_id, degree=3, distance_tolerance=-1, angle_tolerance=-1):\n    \"\"\"Reduces number of curve control points while maintaining the curve's same\n    general shape. Use this function for replacing curves with many control\n    points. For more information, see the Rhino help for the FitCrv command.\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      degree (number, optional): The curve degree, which must be greater than 1.\n                     The default is 3.\n      distance_tolerance (number, optional): The fitting tolerance. If distance_tolerance\n          is not specified or <= 0.0, the document absolute tolerance is used.\n      angle_tolerance (number, optional): The kink smoothing tolerance in degrees. If\n          angle_tolerance is 0.0, all kinks are smoothed. If angle_tolerance\n          is > 0.0, kinks smaller than angle_tolerance are smoothed. If\n          angle_tolerance is not specified or < 0.0, the document angle\n          tolerance is used for the kink smoothing.\n    Returns:\n      guid: The identifier of the new object\n      None: if not successful, or on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      oldCurve = rs.GetObject(\"Select curve to fit\", rs.filter.curve)\n      if oldCurve:\n          newCurve = rs.FitCurve(oldCurve)\n          if newCurve: rs.DeleteObject(oldCurve)\n    See Also:\n      \n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if distance_tolerance is None or distance_tolerance<0:\n        distance_tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if angle_tolerance is None or angle_tolerance<0:\n        angle_tolerance = scriptcontext.doc.ModelAngleToleranceRadians\n    nc = curve.Fit(degree, distance_tolerance, angle_tolerance)\n    if nc:\n        rhobj = rhutil.coercerhinoobject(curve_id)\n        rc = None\n        if rhobj:\n            rc = scriptcontext.doc.Objects.AddCurve(nc, rhobj.Attributes)\n        else:\n            rc = scriptcontext.doc.Objects.AddCurve(nc)\n        if rc==System.Guid.Empty: raise Exception(\"Unable to add curve to document\")\n        scriptcontext.doc.Views.Redraw()\n        return rc\n    return scriptcontext.errorhandler()\n\n\ndef InsertCurveKnot(curve_id, parameter, symmetrical=False ):\n    \"\"\"Inserts a knot into a curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      parameter (number): parameter on the curve\n      symmetrical (bool, optional): if True, then knots are added on both sides of\n          the center of the curve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select curve for knot insertion\", rs.filter.curve)\n      if obj:\n          point = rs.GetPointOnCurve(obj, \"Point on curve to add knot\")\n          if point:\n              parameter = rs.CurveClosestPoint(obj, point)\n              rs.InsertCurveKnot( obj, parameter )\n    See Also:\n      CurveKnotCount\n      CurveKnots\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.Domain.IncludesParameter(parameter): return False\n    nc = curve.ToNurbsCurve()\n    if not nc: return False\n    rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)\n    if rc:\n        rc = nc.Knots.InsertKnot(t,1)\n        if rc and symmetrical:\n            domain = nc.Domain\n            t_sym = domain.T1 - t + domain.T0\n            if abs(t_sym)>Rhino.RhinoMath.SqrtEpsilon:\n                rc = nc.Knots.InsertKnot(t_sym,1)\n        if rc:\n            curve_id = rhutil.coerceguid(curve_id)\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsArc(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is an open arc curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an arc\")\n      if rs.IsArc(obj):\n          print(\"The object is an arc.\")\n      else:\n          print(\"The object is not an arc.\")\n    See Also:\n      AddArc3Pt\n      ArcAngle\n      ArcCenterPoint\n      ArcMidPoint\n      ArcRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsArc() and not curve.IsClosed\n\n\ndef IsCircle(curve_id, tolerance=None):\n    \"\"\"Verifies an object is a circle curve\n    Parameters:\n      curve_id (guid): Identifier of the curve object\n      tolerance (number, optional) If the curve is not a circle, then the tolerance used\n        to determine whether or not the NURBS form of the curve has the\n        properties of a circle. If omitted, Rhino's internal zero tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a circle\")\n      if rs.IsCircle(obj):\n          print(\"The object is a circle.\")\n      else:\n          print(\"The object is not a circle.\")\n    See Also:\n      AddCircle\n      AddCircle3Pt\n      CircleCenterPoint\n      CircleCircumference\n      CircleRadius\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None or tolerance < 0:\n        tolerance = Rhino.RhinoMath.ZeroTolerance\n    return curve.IsCircle(tolerance)\n\n\ndef IsCurve(object_id):\n    \"\"\"Verifies an object is a curve\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          print(\"The object is a curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return curve is not None\n\n\ndef IsCurveClosable(curve_id, tolerance=None):\n    \"\"\"Decide if it makes sense to close off the curve by moving the end point\n    to the start point based on start-end gap size and length of curve as\n    approximated by chord defined by 6 points\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      tolerance[opt] = maximum allowable distance between start point and end\n        point. If omitted, the document's current absolute tolerance is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      crv = rs.GetObject(\"Select curve\", rs.filter.curve)\n      if not rs.IsCurveClosed(crv) and rs.IsCurveClosable(crv):\n          rs.CloseCurve( crv, 0.1 )\n    See Also:\n      CloseCurve\n      IsCurveClosed\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if tolerance is None: tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsClosable(tolerance)\n\n\ndef IsCurveClosed(object_id):\n    \"\"\"Verifies an object is a closed curve object\n    Parameters:\n      object_id (guid): the object's identifier\n    Returns:\n      bool: True if successful otherwise False.  None on error\n    Example:\n      import rhinoscriptsyntax as rs\n      object = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(object):\n          if rs.IsCurveClosed(oObject):\n              print(\"The object is a closed curve.\")\n          else:\n              print(\"The object is not a closed curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveLinear\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id)\n    return None if not curve else curve.IsClosed\n\n\ndef IsCurveInPlane(object_id, plane=None):\n    \"\"\"Test a curve to see if it lies in a specific plane\n    Parameters:\n      object_id (guid): the object's identifier\n      plane (plane, optional): plane to test. If omitted, the active construction plane is used\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj) and rs.IsCurvePlanar(obj):\n          if rs.IsCurveInPlane(obj):\n              print(\"The curve lies in the current cplane.\")\n          else:\n              print(\"The curve does not lie in the current cplane.\")\n      else:\n          print(\"The object is not a planar curve.\")\n    See Also:\n      IsCurve\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    if not plane:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    else:\n        plane = rhutil.coerceplane(plane, True)\n    return curve.IsInPlane(plane, scriptcontext.doc.ModelAbsoluteTolerance)\n\n\ndef IsCurveLinear(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a linear curve\n    Parameters:\n      curve_id (guid):identifier of the curve object\n      segment_index (number): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      id = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(id):\n          if rs.IsCurveLinear(id):\n              print(\"The object is a linear curve.\")\n          else:\n              print(\"The object is not a linear curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurvePeriodic\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsLinear()\n\n\ndef IsCurvePeriodic(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a periodic curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePeriodic(obj):\n              print(\"The object is a periodic curve.\")\n          else:\n              print(\"The object is not a periodic curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePlanar\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    return curve.IsPeriodic\n\n\ndef IsCurvePlanar(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a planar curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurvePlanar(obj):\n              print(\"The object is a planar curve.\")\n          else:\n              print(\"The object is not a planar curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    return curve.IsPlanar(tol)\n\n\ndef IsCurveRational(curve_id, segment_index=-1):\n    \"\"\"Verifies an object is a rational NURBS curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          if rs.IsCurveRational(obj):\n              print(\"The object is a rational NURBS curve.\")\n          else:\n              print(\"The object is not a rational NURBS curve.\")\n      else:\n          print(\"The object is not a curve.\")\n    See Also:\n      IsCurve\n      IsCurveClosed\n      IsCurveLinear\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.NurbsCurve): return curve.IsRational\n    return False\n\n\ndef IsEllipse(object_id, segment_index=-1):\n    \"\"\"Verifies an object is an elliptical-shaped curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select an ellipse\")\n      if rs.IsEllipse(obj):\n          print(\"The object is an ellipse.\")\n      else:\n          print(\"The object is not an ellipse.\")\n    See Also:\n      EllipseCenterPoint\n      EllipseQuadPoints\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return curve.IsEllipse()\n\n\ndef IsLine(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a line curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a line\")\n      if rs.IsLine(obj):\n          print(\"The object is a line.\")\n      else:\n          print(\"The object is not a line.\")\n    See Also:\n      AddLine\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.LineCurve): return True\n    rc, polyline = curve.TryGetPolyline()\n    if rc and polyline.Count==2: return True\n    return False\n\n\ndef IsPointOnCurve(object_id, point, segment_index=-1):\n    \"\"\"Verifies that a point is on a curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      point (point): the test point\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\")\n      if rs.IsCurve(obj):\n          point = rs.GetPoint(\"Pick a test point\")\n          if point:\n              if rs.IsPointOnCurve(obj, point):\n                  print(\"The point is on the curve\")\n              else:\n                  print(\"The point is not on the curve\")\n    See Also:\n      IsCurve\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    point = rhutil.coerce3dpoint(point, True)\n    rc, t = curve.ClosestPoint(point, Rhino.RhinoMath.SqrtEpsilon)\n    return rc\n\n\ndef IsPolyCurve(object_id, segment_index=-1):\n    \"\"\"Verifies an object is a PolyCurve curve\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional) the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          print(\"The object is a polycurve.\")\n      else:\n          print(\"The object is not a polycurve.\")\n    See Also:\n      PolyCurveCount\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolyCurve)\n\n\ndef IsPolyline( object_id, segment_index=-1 ):\n    \"\"\"Verifies an object is a Polyline curve object\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      segment_index (number, optional): the curve segment index if `curve_id` identifies a polycurve\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          print(\"The object is a polyline.\")\n      else:\n          print(\"The object is not a polyline.\")\n    See Also:\n      IsPolyline\n      PolylineVertices\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, segment_index, True)\n    return isinstance(curve, Rhino.Geometry.PolylineCurve)\n\n\ndef JoinCurves(object_ids, delete_input=False, tolerance=None):\n    \"\"\"Joins multiple curves together to form one or more curves or polycurves\n    Parameters:\n      object_ids (guid): list of multiple curves\n      delete_input (bool, optional): delete input objects after joining\n      tolerance (number, optional): join tolerance. If omitted, 2.1 * document absolute\n          tolerance is used\n    Returns:\n      list(guid, ...): Object id representing the new curves\n    Example:\n      import rhinoscriptsyntax as rs\n      objs = rs.GetObjects(\"Select curves to join\", rs.filter.curve)\n      if objs: rs.JoinCurves(objs)\n    See Also:\n      ExplodeCurves\n      IsCurve\n      IsCurveClosed\n    \"\"\"\n    if len(object_ids)<2: raise ValueError(\"object_ids must contain at least 2 items\")\n    curves = [rhutil.coercecurve(id, -1, True) for id in object_ids]\n    if tolerance is None:\n        tolerance = 2.1 * scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.JoinCurves(curves, tolerance)\n    rc = []\n    if newcurves:\n        rc = [scriptcontext.doc.Objects.AddCurve(crv) for crv in newcurves]\n    if rc and delete_input:\n        for id in object_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, False)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef LineFitFromPoints(points):\n    \"\"\"Returns a line that was fit through an array of 3D points\n    Parameters:\n      points ([point, point, ...]): a list of at least two 3D points\n    Returns:\n      line: line on success\n    Example:\n      import rhinoscriptsyntax as rs\n      points = rs.GetPoints()\n      if points and len(points)>1:\n          line=rs.LineFitFromPoints(points)\n          if line: rs.AddLine(line.From, line.To)\n    See Also:\n      AddLine\n      CurveEndPoint\n      CurveStartPoint\n    \"\"\"\n    points = rhutil.coerce3dpointlist(points, True)\n    rc, line = Rhino.Geometry.Line.TryFitLineToPoints(points)\n    if rc: return line\n    return scriptcontext.errorhandler()\n\n\ndef MakeCurveNonPeriodic(curve_id, delete_input=False):\n    \"\"\"Makes a periodic curve non-periodic. Non-periodic curves can develop\n    kinks when deformed\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      delete_input (bool): delete the input curve. If omitted, the input curve will not be deleted.\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurvePeriodic(curve): rs.MakeCurveNonPeriodic( curve )\n    See Also:\n      IsCurvePeriodic\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if not curve.IsPeriodic: return scriptcontext.errorhandler()\n    nc = curve.ToNurbsCurve()\n    if nc is None: return scriptcontext.errorhandler()\n    nc.Knots.ClampEnd( Rhino.Geometry.CurveEnd.Both )\n    rc = None\n    if delete_input:\n        if type(curve_id) is Rhino.DocObjects.ObjRef: pass\n        else: curve_id = rhutil.coerceguid(curve_id)\n        if curve_id:\n            rc = scriptcontext.doc.Objects.Replace(curve_id, nc)\n            if not rc: return scriptcontext.errorhandler()\n            rc = rhutil.coerceguid(curve_id)\n    else:\n        attrs = None\n        if type(scriptcontext.doc) is Rhino.RhinoDoc:\n            rhobj = rhutil.coercerhinoobject(curve_id)\n            if rhobj: attrs = rhobj.Attributes\n        rc = scriptcontext.doc.Objects.AddCurve(nc, attrs)\n        if rc==System.Guid.Empty: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeanCurve(curve0, curve1, tolerance=None):\n    \"\"\"Creates an average curve from two curves\n    Parameters:\n      curve0, curve1 (guid): identifiers of two curves\n      tolerance (number, optional): angle tolerance used to match kinks between curves\n    Returns:\n      guid: id of the new or modified curve if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve0 = rs.GetObject(\"Select the first curve\", rs.filter.curve)\n      curve1 = rs.GetObject(\"Select the second curve\", rs.filter.curve)\n      rs.MeanCurve( curve0, curve1 )\n    See Also:\n      UnitAngleTolerance\n    \"\"\"\n    curve0 = rhutil.coercecurve(curve0, -1, True)\n    curve1 = rhutil.coercecurve(curve1, -1, True)\n    if tolerance is None: tolerance=Rhino.RhinoMath.UnsetValue\n    crv = Rhino.Geometry.Curve.CreateMeanCurve(curve0,curve1,tolerance)\n    if crv:\n        rc = scriptcontext.doc.Objects.AddCurve(crv)\n        scriptcontext.doc.Views.Redraw()\n        return rc\n\n\ndef MeshPolyline(polyline_id):\n    \"\"\"Creates a polygon mesh object based on a closed polyline curve object.\n    The created mesh object is added to the document\n    Parameters:\n      polyline_id (guid): identifier of the polyline curve object\n    Returns:\n      guid: identifier of the new mesh object\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      polyline = rs.GetObject(\"Select a polyline\", rs.filter.curve)\n      if polyline:\n          if rs.IsPolyline(polyline) and rs.IsCurveClosed(polyline):\n              rs.MeshPolyline( polyline )\n    See Also:\n      IsCurveClosed\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(polyline_id, -1, True)\n    ispolyline, polyline = curve.TryGetPolyline()\n    if not ispolyline: return scriptcontext.errorhandler()\n    mesh = Rhino.Geometry.Mesh.CreateFromClosedPolyline(polyline)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurve(object_id, direction, distance, normal=None, style=1):\n    \"\"\"Offsets a curve by a distance. The offset curve will be added to Rhino\n    Parameters:\n      object_id (guid): identifier of a curve object\n      direction (point): point describing direction of the offset\n      distance (number): distance of the offset\n      normal (vector, optional): normal of the plane in which the offset will occur.\n          If omitted, the normal of the active construction plane will be used\n      style (number, optional): the corner style. If omitted, the style is sharp.\n                                0 = None\n                                1 = Sharp\n                                2 = Round\n                                3 = Smooth\n                                4 = Chamfer\n    Returns:\n      list(guid, ...): list of ids for the new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a curve\", rs.filter.curve)\n      if rs.IsCurve(obj):\n          rs.OffsetCurve( obj, [0,0,0], 1.0 )\n    See Also:\n      OffsetCurveOnSurface\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    direction = rhutil.coerce3dpoint(direction, True)\n    if normal:\n        normal = rhutil.coerce3dvector(normal, True)\n    else:\n        normal = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    style = System.Enum.ToObject(Rhino.Geometry.CurveOffsetCornerStyle, style)\n    curves = curve.Offset(direction, normal, distance, tolerance, style)\n    if curves is None: return scriptcontext.errorhandler()\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef OffsetCurveOnSurface(curve_id, surface_id, distance_or_parameter):\n    \"\"\"Offset a curve on a surface. The source curve must lie on the surface.\n    The offset curve or curves will be added to Rhino\n    Parameters:\n      curve_id, surface_id (guid): curve and surface identifiers\n      distance_or_parameter (number|tuple(number, number)): If a single number is passed, then this is the\n        distance of the offset. Based on the curve's direction, a positive value\n        will offset to the left and a negative value will offset to the right.\n        If a tuple of two values is passed, this is interpreted as the surface\n        U,V parameter that the curve will be offset through\n    Returns:\n      list(guid, ...): identifiers of the new curves if successful\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      def TestOffset():\n          curve = rs.GetObject(\"Select curve on a surface\", rs.filter.curve)\n          if curve is None: return False\n          surface = rs.GetObject(\"Select base surface\", rs.filter.surface)\n          if surface is None: return False\n          point = rs.GetPointOnSurface( surface, \"Through point\" )\n          if point is None: return False\n          parameter = rs.SurfaceClosestPoint(surface, point)\n          rc = rs.OffsetCurveOnSurface( curve, surface, parameter )\n          return rc is not None\n       \n      TestOffset()\n    See Also:\n      OffsetCurve\n      OffsetSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    surface = rhutil.coercesurface(surface_id, True)\n    x = None\n    if type(distance_or_parameter) is list or type(distance_or_parameter) is tuple:\n        x = Rhino.Geometry.Point2d( distance_or_parameter[0], distance_or_parameter[1] )\n    else:\n        x = float(distance_or_parameter)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    curves = curve.OffsetOnSurface(surface, x, tol)\n    if curves is None: return scriptcontext.errorhandler()\n    curves = [curve.ExtendOnSurface(Rhino.Geometry.CurveEnd.Both, surface) for curve in curves]\n    rc = [scriptcontext.doc.Objects.AddCurve(curve) for curve in curves]\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef PlanarClosedCurveContainment(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines the relationship between the regions bounded by two coplanar\n    simple closed curves\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar, closed curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      number: a number identifying the relationship if successful\n        0 = the regions bounded by the curves are disjoint\n        1 = the two curves intersect\n        2 = the region bounded by curve_a is inside of curve_b\n        3 = the region bounded by curve_b is inside of curve_a\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\", rs.filter.curve )\n      curve2 = rs.GetObject(\"Select second curve\", rs.filter.curve )\n      if rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2):\n          if rs.IsCurveClosed(curve1) and rs.IsCurveClosed(curve2):\n              if rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2):\n                  result = rs.PlanarClosedCurveContainment(curve1, curve2)\n                  if result==0: print(\"The regions bounded by the curves are disjoint.\")\n                  elif result==1: print(\"The two curves intersect..\")\n                  elif result==2: print(\"The region bounded by Curve1 is inside of Curve2.\")\n                  else: print(\"The region bounded by Curve2 is inside of Curve1.\")\n    See Also:\n      PlanarCurveCollision\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = Rhino.Geometry.Curve.PlanarClosedCurveRelationship(curve_a, curve_b, plane, tolerance)\n    return int(rc)\n\n\ndef PlanarCurveCollision(curve_a, curve_b, plane=None, tolerance=None):\n    \"\"\"Determines if two coplanar curves intersect\n    Parameters:\n      curve_a, curve_b (guid): identifiers of two planar curves\n      plane (plane, optional): test plane. If omitted, the currently active construction\n        plane is used\n      tolerance (number, optional): if omitted, the document absolute tolerance is used\n    Returns:\n      bool: True if the curves intersect; otherwise False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve1 = rs.GetObject(\"Select first curve\")\n      curve2 = rs.GetObject(\"Select second curve\")\n      if( rs.IsCurvePlanar(curve1) and rs.IsCurvePlanar(curve2) and rs.IsCurveInPlane(curve1) and rs.IsCurveInPlane(curve2) ):\n          if rs.PlanarCurveCollision(curve1, curve2):\n              print(\"The coplanar curves intersect.\")\n          else:\n              print(\"The coplanar curves do not intersect.\")\n    See Also:\n      CurveCurveIntersection\n      PlanarClosedCurveContainment\n      PointInPlanarClosedCurve\n    \"\"\"\n    curve_a = rhutil.coercecurve(curve_a, -1, True)\n    curve_b = rhutil.coercecurve(curve_b, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    return Rhino.Geometry.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tolerance)\n\n\ndef PointInPlanarClosedCurve(point, curve, plane=None, tolerance=None):\n    \"\"\"Determines if a point is inside of a closed curve, on a closed curve, or\n    outside of a closed curve\n    Parameters:\n      point (point|guid): text point\n      curve (guid): identifier of a curve object\n      plane (plane, optional): plane containing the closed curve and point. If omitted,\n          the currently active construction plane is used\n      tolerance (number, optional) it omitted, the document abosulte tolerance is used\n    Returns:\n      number: number identifying the result if successful\n              0 = point is outside of the curve\n              1 = point is inside of the curve\n              2 = point in on the curve\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a planar, closed curve\", rs.filter.curve)\n      if rs.IsCurveClosed(curve) and rs.IsCurvePlanar(curve):\n          point = rs.GetPoint(\"Pick a point\")\n          if point:\n              result = rs.PointInPlanarClosedCurve(point, curve)\n              if result==0: print(\"The point is outside of the closed curve.\")\n              elif result==1: print(\"The point is inside of the closed curve.\")\n              else: print(\"The point is on the closed curve.\")\n    See Also:\n      PlanarClosedCurveContainment\n      PlanarCurveCollision\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    curve = rhutil.coercecurve(curve, -1, True)\n    if tolerance is None or tolerance<=0:\n        tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if plane:\n        plane = rhutil.coerceplane(plane)\n    else:\n        plane = scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n    rc = curve.Contains(point, plane, tolerance)\n    if rc==Rhino.Geometry.PointContainment.Unset: raise Exception(\"Curve.Contains returned Unset\")\n    if rc==Rhino.Geometry.PointContainment.Outside: return 0\n    if rc==Rhino.Geometry.PointContainment.Inside: return 1\n    return 2\n\n\ndef PolyCurveCount(curve_id, segment_index=-1):\n    \"\"\"Returns the number of curve segments that make up a polycurve\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if `curve_id` identifies a polycurve object, then `segment_index` identifies the curve segment of the polycurve to query.\n    Returns:\n      number: the number of curve segments in a polycurve if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polycurve\")\n      if rs.IsPolyCurve(obj):\n          count = rs.PolyCurveCount(obj)\n          if count: print(\"The polycurve contains {} curves\".format(count))\n    See Also:\n      IsPolyCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    if isinstance(curve, Rhino.Geometry.PolyCurve): return curve.SegmentCount\n    raise ValueError(\"curve_id does not reference a polycurve\")\n\n\ndef PolylineVertices(curve_id, segment_index=-1):\n    \"\"\"Returns the vertices of a polyline curve on success\n    Parameters:\n      curve_id (guid): the object's identifier\n      segment_index (number, optional): if curve_id identifies a polycurve object, then segment_index identifies the curve segment of the polycurve to query.\n    Returns:\n      list(point, ...): an list of Point3d vertex points if successful\n      None: if not successful\n    Example:\n      import rhinoscriptsyntax as rs\n      obj = rs.GetObject(\"Select a polyline\")\n      if rs.IsPolyline(obj):\n          points = rs.PolylineVertices(obj)\n          if points:\n              for point in points: rs.AddPoint(point)\n    See Also:\n      AddPolyline\n      IsPolyline\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, segment_index, True)\n    rc, polyline = curve.TryGetPolyline()\n    if rc: return [pt for pt in polyline]\n    raise ValueError(\"curve_id does not reference a polyline\")\n\n\ndef ProjectCurveToMesh(curve_ids, mesh_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or meshes\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      mesh_ids ([guid, ...]): identifiers of meshes to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers for the resulting curves.\n    Example:\n      import rhinoscriptsyntax as rs\n      mesh = rs.GetObject(\"Select mesh to project onto\", rs.filter.mesh)\n      curve= rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      #Project down...\n      results = rs.ProjectCurveToMesh(curve, mesh, (0,0,-1))\n    See Also:\n      ProjectCurveToSurface\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    mesh_ids = rhutil.coerceguidlist(mesh_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToMesh(curves, meshes, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef ProjectCurveToSurface(curve_ids, surface_ids, direction):\n    \"\"\"Projects one or more curves onto one or more surfaces or polysurfaces\n    Parameters:\n      curve_ids ([guid, ...]): identifiers of curves to project\n      surface_ids ([guid, ...]): identifiers of surfaces to project onto\n      direction (vector): projection direction\n    Returns:\n      list(guid, ...): list of identifiers\n    Example:\n      import rhinoscriptsyntax as rs\n      surface = rs.GetObject(\"Select surface to project onto\", rs.filter.surface)\n      curve = rs.GetObject(\"Select curve to project\", rs.filter.curve)\n      # Project down...\n      results = rs.ProjectCurveToSurface(curve, surface, (0,0,-1))\n    See Also:\n      ProjectCurveToMesh\n      ProjectPointToMesh\n      ProjectPointToSurface\n    \"\"\"\n    curve_ids = rhutil.coerceguidlist(curve_ids)\n    surface_ids = rhutil.coerceguidlist(surface_ids)\n    direction = rhutil.coerce3dvector(direction, True)\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    breps = [rhutil.coercebrep(id, True) for id in surface_ids]\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    newcurves = Rhino.Geometry.Curve.ProjectToBrep(curves, breps, direction, tolerance)\n    ids = [scriptcontext.doc.Objects.AddCurve(curve) for curve in newcurves]\n    if ids: scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef RebuildCurve(curve_id, degree=3, point_count=10):\n    \"\"\"Rebuilds a curve to a given degree and control point count. For more\n    information, see the Rhino help for the Rebuild command.\n    Parameters:\n      curve_id (guid): identifier of the curve object\n      degree (number, optional): new degree (must be greater than 0)\n      point_count (number, optional) new point count, which must be bigger than degree.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select curve to rebuild\", rs.filter.curve)\n      if curve: rs.RebuildCurve(curve, 3, 10)\n    See Also:\n      RebuildSurface\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if degree<1: raise ValueError(\"degree must be greater than 0\")\n    newcurve = curve.Rebuild(point_count, degree, False)\n    if not newcurve: return False\n    scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef RemoveCurveKnot(curve, parameter):\n    \"\"\"Deletes a knot from a curve object.\n    Parameters:\n      curve (guid): The reference of the source object\n      parameter (number): The parameter on the curve. Note, if the parameter is not equal to one\n                      of the existing knots, then the knot closest to the specified parameter\n                      will be removed.\n    Returns:\n      bool: True of False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n\n      crv_info = rs.GetCurveObject(\"Select curve near knot to be removed\")\n      if crv_info:\n          crv_id = crv_info[0]\n          crv_param = crv_info[4]\n          rs.RemoveCurveKnot(crv_id, crv_param)\n    See Also:\n      RemoveSurfaceKnot\n    \"\"\"\n    curve_inst = rhutil.coercecurve(curve, -1, True)\n    success, n_param = curve_inst.GetCurveParameterFromNurbsFormParameter(parameter)\n    if not success: return False\n    n_curve = curve_inst.ToNurbsCurve()\n    if not n_curve: return False\n    success = n_curve.Knots.RemoveKnotAt(n_param)\n    if not success: return False\n    scriptcontext.doc.Objects.Replace(curve, n_curve)\n    scriptcontext.doc.Views.Redraw()\n    return True\n\n\ndef ReverseCurve(curve_id):\n    \"\"\"Reverses the direction of a curve object. Same as Rhino's Dir command\n    Parameters:\n      curve_id (guid): identifier of the curve object\n    Returns:\n      bool: True or False indicating success or failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to reverse\")\n      if rs.IsCurve(curve): rs.ReverseCurve(curve)\n    See Also:\n      CurveDirectionsMatch\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if curve.Reverse():\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, curve)\n        return True\n    return False\n\n\ndef SimplifyCurve(curve_id, flags=0):\n    \"\"\"Replace a curve with a geometrically equivalent polycurve.\n    \n    The polycurve will have the following properties:\n     - All the polycurve segments are lines, polylines, arcs, or NURBS curves.\n     - The NURBS curves segments do not have fully multiple interior knots.\n     - Rational NURBS curves do not have constant weights.\n     - Any segment for which IsCurveLinear or IsArc is True is a line, polyline segment, or an arc.\n     - Adjacent co-linear or co-circular segments are combined.\n     - Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.\n     - If the polycurve is a polyline, a polyline will be created\n\n\n    Parameters:\n      curve_id (guid): the object's identifier\n      flags (number, optional): the simplification methods to use. By default, all methods are used (flags = 0)\n        Value Description\n        0     Use all methods.\n        1     Do not split NURBS curves at fully multiple knots.\n        2     Do not replace segments with IsCurveLinear = True with line curves.\n        4     Do not replace segments with IsArc = True with arc curves.\n        8     Do not replace rational NURBS curves with constant denominator with an equivalent non-rational NURBS curve.\n        16    Do not adjust curves at G1-joins.\n        32    Do not merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline.\n\n    Returns:\n      bool: True or False\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to simplify\", rs.filter.curve)\n      if curve: rs.SimplifyCurve(curve)\n    See Also:\n      IsArc\n      IsCurveLinear\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    _flags = Rhino.Geometry.CurveSimplifyOptions.All\n    if( flags&1 ==1 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.SplitAtFullyMultipleKnots)\n    if( flags&2 ==2 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildLines)\n    if( flags&4 ==4 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildArcs)\n    if( flags&8 ==8 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.RebuildRationals)\n    if( flags&16==16 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.AdjustG1)\n    if( flags&32==32 ): _flags &= (~Rhino.Geometry.CurveSimplifyOptions.Merge)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    ang_tol = scriptcontext.doc.ModelAngleToleranceRadians\n    newcurve = curve.Simplify(_flags, tol, ang_tol)\n    if newcurve:\n        curve_id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Replace(curve_id, newcurve)\n        scriptcontext.doc.Views.Redraw()\n        return True\n    return False\n\n\ndef SplitCurve(curve_id, parameter, delete_input=True):\n    \"\"\"Splits, or divides, a curve at a specified parameter. The parameter must\n    be in the interior of the curve's domain\n    Parameters:\n      curve_id (guid): the curve to split\n      parameter ({number, ...]) one or more parameters to split the curve at\n      delete_input (bool, optional): delete the input curve\n    Returns:\n      list(guid, ....): list of new curves on success\n      None: on error\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to split\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          parameter = domain[1] / 2.0\n          rs.SplitCurve( curve, parameter )\n    See Also:\n      TrimCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    newcurves = curve.Split(parameter)\n    if newcurves is None: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = [scriptcontext.doc.Objects.AddCurve(crv, att) for crv in newcurves]\n    if rc and delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef TrimCurve(curve_id, interval, delete_input=True):\n    \"\"\"Trims a curve by removing portions of the curve outside a specified interval\n    Parameters:\n      curve_id (guid):the curve to trim\n      interval ([number, number]): two numbers identifying the interval to keep. Portions of\n        the curve before domain[0] and after domain[1] will be removed. If the\n        input curve is open, the interval must be increasing. If the input\n        curve is closed and the interval is decreasing, then the portion of\n        the curve across the start and end of the curve is returned\n      delete_input (bool): delete the input curve. If omitted the input curve is deleted.\n    Returns:\n      list(guid, ...): identifier of the new curve on success\n      None: on failure\n    Example:\n      import rhinoscriptsyntax as rs\n      curve = rs.GetObject(\"Select a curve to trim\", rs.filter.curve)\n      if rs.IsCurve(curve):\n          domain = rs.CurveDomain(curve)\n          domain[1] /= 2.0\n          rs.TrimCurve( curve, domain )\n    See Also:\n      SplitCurve\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    if interval[0]==interval[1]: raise ValueError(\"interval values are equal\")\n    newcurve = curve.Trim(interval[0], interval[1])\n    if not newcurve: return scriptcontext.errorhandler()\n    att = None\n    rhobj = rhutil.coercerhinoobject(curve_id)\n    if rhobj: att = rhobj.Attributes\n    rc = scriptcontext.doc.Objects.AddCurve(newcurve, att)\n    if delete_input:\n        id = rhutil.coerceguid(curve_id, True)\n        scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ChangeCurveDegree(object_id, degree):\n    \"\"\"Changes the degree of a curve object. For more information see the Rhino help file for the ChangeDegree command.\n      Parameters:\n        object_id (guid): the object's identifier.\n        degree (number): the new degree.\n      Returns:\n        bool: True of False indicating success or failure.\n        None: on failure\n      Example:\n    \n      See Also:\n        IsCurve\n        CurveDegree\n    \"\"\" \n    curve = rhutil.coercerhinoobject(object_id)\n    if not curve: return None\n    if not isinstance(curve, Rhino.DocObjects.CurveObject): return None\n\n    curve = curve.CurveGeometry\n    if not isinstance(curve, Rhino.Geometry.NurbsCurve):\n        curve = curve.ToNurbsCurve()\n\n    max_nurbs_degree = 11\n    if degree < 1 or degree > max_nurbs_degree or curve.Degree == degree:\n        return None\n\n    r = False\n    if curve.IncreaseDegree(degree):\n        r = scriptcontext.doc.Objects.Replace(object_id, curve)\n    return r\n\n\ndef AddTweenCurves(from_curve_id, to_curve_id, number_of_curves = 1, method = 0, sample_number = 10):\n    \"\"\"Creates curves between two open or closed input curves.\n    Parameters:\n      from_curve_id (guid): identifier of the first curve object.\n      to_curve_id (guid): identifier of the second curve object.\n      number_of_curves (number): The number of curves to create. The default is 1.\n      method (number): The method for refining the output curves, where:\n        0: (Default) Uses the control points of the curves for matching. So the first control point of first curve is matched to first control point of the second curve.\n        1: Refits the output curves like using the FitCurve method.  Both the input curve and the output curve will have the same structure. The resulting curves are usually more complex than input unless input curves are compatible.\n        2: Input curves are divided to the specified number of points on the curve, corresponding points define new points that output curves go through. If you are making one tween curve, the method essentially does the following: divides the two curves into an equal number of points, finds the midpoint between the corresponding points on the curves, and interpolates the tween curve through those points.\n      sample_number (number): The number of samples points to use if method is 2. The default is 10.\n    Returns:\n      list(guid, ...): The identifiers of the new tween objects if successful, None on error.\n    Example:\n      import rhinoscriptsyntax as rs\n      curveA = rs.GetObject(\"Select first curve\", rs.filter.curve)\n      curveB = rs.GetObject(\"Select second curve\", rs.filter.curve)\n      arrResult = rs.AddTweenCurves(curveA, curveB, 6, 2, 30)\n    \"\"\"\n    curve0 = rhutil.coercecurve(from_curve_id, -1, True)\n    curve1 = rhutil.coercecurve(to_curve_id, -1, True)\n    out_curves = 0\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    if method == 0:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurves(curve0, curve1, number_of_curves, tolerance)\n    elif method == 1:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithMatching(curve0, curve1, number_of_curves, tolerance)\n    elif method == 2:\n        out_curves = Rhino.Geometry.Curve.CreateTweenCurvesWithSampling(curve0, curve1, number_of_curves, sample_number, tolerance)\n    else: raise ValueError(\"method must be 0, 1, or 2\")\n    curves = None\n    if out_curves:\n        curves = []\n        for curve in out_curves:\n            if curve and curve.IsValid:\n                rc = scriptcontext.doc.Objects.AddCurve(curve)\n            curve.Dispose()\n            if rc==System.Guid.Empty: raise Exception(\"unable to add curve to document\")\n            curves.append(rc)\n        scriptcontext.doc.Views.Redraw()\n    return curves\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}