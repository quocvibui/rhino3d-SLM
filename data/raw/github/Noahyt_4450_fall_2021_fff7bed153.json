{
  "source_url": "https://github.com/Noahyt/4450_fall_2021/blob/f039c7f9977156dd5b371543612144f01afb9be3/5/src/fdm_hops.py",
  "repo": "Noahyt/4450_fall_2021",
  "repo_stars": 0,
  "repo_description": "coursework for MIT.4450 as taught fall 2021",
  "license": "unknown",
  "filepath": "5/src/fdm_hops.py",
  "instruction": "Creates Flask server for calling `fdm.py` from Grasshopper.",
  "code": "\"\"\"Creates Flask server for calling `fdm.py` from Grasshopper.\"\"\"\n\n\nfrom flask import Flask\nimport ghhops_server as hs\n\nimport fdm\nimport re\n\nimport rhino3dm\n\n\n# register hops app as middleware\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n\ndef _parse_tree_key(k):\n    \"\"\"Extracts coordinates from key\"\"\"\n    # Extract coordinates.\n    k = re.findall('{(.*?)}', k)[0]\n\n    # Split by `;` to get individual indices.\n    k = k.split(r';')\n\n    return [int(k_) for k_ in k]\n\n\ndef _insert_at(mod_list, coor, data):\n    \"\"\"Inserts `data` into `mod_list` at `coor`.\n\n    `coor` in general may be a list of coordinates. This function then\n    recursively inserts lists until the appropriate level is reached.\n    \"\"\"\n    if len(mod_list) < coor[0]:\n        raise ValueError(\"List too short.\")\n    # TODO: Need to make clear whether this will ALWAYS add new items or\n    # add to existing lists if they exis.\n    if len(coor) > 1:\n        # If list doesn't exist, insert one.\n        if len(mod_list) <= coor[0]:\n            mod_list.insert(coor[0], [])\n        if not isinstance(mod_list[coor[0]], list):\n            raise ValueError(\n                \"Cannot insert data at requested level. Not a list.\")\n        _insert_at(mod_list[coor[0]], coor[1:], data)\n    else:\n        mod_list.insert(coor[0], data)\n\n\ndef list_from_tree(tree):\n    \"\"\"Constructs list of list containing data in `tree`.\n\n    It is useful to construct a list representation first, since different\n    final indices may contain different.\n    \"\"\"\n    address = [_parse_tree_key(k) for k in tree.keys()]\n    data = tree.values()\n\n    # Instantiate list which we will fill in whith data at `address`.\n    lt = []\n\n    [_insert_at(lt, a, d) for a, d in zip(address, data)]\n    return lt\n\n\ndef _point_to_numpy(points):\n    \"\"\"Generates list of coordinates from list of `rhino3dm.point`.\"\"\"\n    return [[p.X, p.Y, p.Z] for p in points]\n\n\n@hops.component(\n    \"/fdm\",\n    name=\"FDM\",\n    description=\"Computes final node positions using Force Density Method.\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"Bool\", \"Runs Computation.\"),\n        hs.HopsPoint(\"Nodes\", \"N\", access=hs.HopsParamAccess.LIST),\n        hs.HopsNumber(\"Edges\", \"E\", access=hs.HopsParamAccess.TREE),\n        hs.HopsVector(\"Loads\", \"L\", access=hs.HopsParamAccess.LIST),\n        hs.HopsNumber(\"Force Densities\", \"FD\", access=hs.HopsParamAccess.TREE),\n        hs.HopsInteger(\"Fixed Node ID\", \"Fixed\",\n                       access=hs.HopsParamAccess.TREE)\n        ],\n    outputs=[\n        hs.HopsPoint(\"Nodes\", \"N\", access=hs.HopsParamAccess.TREE),\n        # hs.HopsLine(\"Edges\", \"E\", access=hs.HopsParamAccess.TREE)\n        ]\n    )\ndef hops_fdm(trigger, nodes, edges, loads, force_density, fixed):\n    \"\"\"Process hops/grasshopper objects and returns fdm solution.\"\"\"\n    if trigger:\n        # Parse into numpy array.\n        nodes = _point_to_numpy(nodes)\n        print(f\"nodes {nodes}\")\n\n        edges = list_from_tree(edges)\n        edges = [list(map(int, e)) for e in edges]\n        print(f\"edges {edges}\")\n\n        loads = _point_to_numpy(loads)\n        print(f\"loads {loads}\")\n\n        force_densities = list_from_tree(force_density)[0]\n        print(f\"force_densities {force_densities}\")\n\n        fixed = list_from_tree(fixed)[0]\n        print(f\"fixed {fixed}\")\n\n        a = fdm.compute_fdm(nodes, edges, loads, force_densities, fixed)\n\n        # Convert to points.\n        points = [rhino3dm.Point3d(*p) for p in a]\n\n        # Create new mesh edges.\n        edges = [rhino3dm.Line(points[e[0]], points[e[1]]) for e in edges]\n\n        print(edges)\n\n        return points\n\n\ndef run_app():\n    app.run(threaded=True)\n\n\nif __name__ == \"__main__\":\n    run_app()\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}