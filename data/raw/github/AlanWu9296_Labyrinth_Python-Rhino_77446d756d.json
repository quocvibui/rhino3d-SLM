{
  "source_url": "https://github.com/AlanWu9296/Labyrinth_Python-Rhino/blob/e2d162d43c2134ab1a1d32b894e2f3b3ee11965a/ClassSet.py",
  "repo": "AlanWu9296/Labyrinth_Python-Rhino",
  "repo_stars": 3,
  "repo_description": "These are the Rhino Python scripts that can creat different labyrinth. The algorithms are origined from the book Maze for Programmers but are not translated into Rhino Python in a word-to-word way. The project is still on working!",
  "license": "MIT",
  "filepath": "ClassSet.py",
  "instruction": "Class set",
  "code": "import GridMath as gm\r\nimport rhinoscriptsyntax as rs\nimport RhinoMethod as rm\n\nclass Point(object):\n    \"\"\"docstring for Point.It is the conceptual class to shape the grid\"\"\"\n    def __init__(self, referencePoint, gridIndex, unitWidth, unitLength,layer, color):\n        super(Point, self).__init__()\n        self.referencePoint = referencePoint\n        self.gridIndex = gridIndex\n        self.unitWidth = unitWidth\n        self.unitLength = unitLength\n        self.layer = layer\n        self.color = color\n        rp = referencePoint\n\n        i = gridIndex[0]\n        j = gridIndex[1]\n        xOffset = (i) * unitWidth\n        yOffset = (j) * unitLength\n\n        self.position = ((xOffset+rp[0]), (yOffset+rp[1]),rp[2]) #2D now\n\n    def draw(self):\n        rm.drawAtLayer(rs.AddPoint, self.position, self.layer, self.color)\n        pass\n\n\nclass PositionPoint(Point):\n    \"\"\"docstring for PositionPoint. It's the point which phisically define the shape of the grid\"\"\"\n    def __init__(self, referencePoint, gridIndex, unitWidth, unitLength,layer='PositionPoint', color=(120,120,120)):\n        super(PositionPoint, self).__init__(referencePoint, gridIndex, unitWidth, unitLength,layer, color)\n        self.neighbors = []# wait to be initialized by Grid class, 0=left, 1=up, 2=right, 3=down\n\n\nclass LogicPoint(Point):\n    \"\"\"\n       It's the invisible points which will later define the path finding\n       and will define how the grid lines will be open or closed.\n    \"\"\"\n    def __init__(self,referencePoint, gridIndex, unitWidth, unitLength,layer='LogicPoint', color=(150,0,0)):\n        rp = referencePoint\n        referencePoint = ((rp[0]-0.5*unitWidth),(rp[1]-0.5*unitLength),rp[2])\n        super(LogicPoint, self).__init__(referencePoint, gridIndex, unitWidth, unitLength,layer,color)\n        self.neighbors = []# wait to be initialized by Grid class, 0=left, 1=up, 2=right, 3=down\n        self.mazeNeighbors = [] # wait to be initialized by the MazeMethods and for later analysis\n        self.interiorNeighbors = [] #wait to be initialized by the MazeMethods\n        self.isInterior = False # wait to be changed by Grid class\n        self.isEnd = False # wait to be changed on the users' demands\n        self.isVisited = False # wait to be changed by PathMaker class\n        self.isChosen = False # wait to be changed by PathMaker class\r\n        self.DijkstraIndex = int # wait to be given by Dijkstra analysis\r\n\r\n    def drawDijkstraIndex(self,fontHeight, layer='DijkstraIndex', color=(120,120,120)):\r\n        if rs.IsLayer(layer):\r\n            rs.LayerColor(layer, color)\r\n            pass\r\n        else:\r\n            rs.AddLayer(layer, color)\r\n        rs.CurrentLayer(layer)\r\n        rs.AddText(str(self.DijkstraIndex),self.position, height=fontHeight, justification=2)\r\n        pass\r\n\r\n    def drawDijkstraColor(self, width, height, color, maxIndex, layer='DijkstraColor' ):\r\n        if rs.IsLayer(layer):\r\n            rs.LayerColor(layer)\r\n            pass\r\n        else:\r\n            rs.AddLayer(layer)\r\n        rs.CurrentLayer(layer)\r\n        pass\r\n        drawColor = rm.setChoromeColor(self.DijkstraIndex, maxIndex, color)\r\n        drawPosition = (self.position[0]-width*0.5, self.position[1]-height*0.5, self.position[2])\r\n        rectGuid = rs.AddRectangle(drawPosition, width, height)\r\n        guid = rs.AddPlanarSrf(rectGuid)\r\n        rs.DeleteObject(rectGuid)\r\n        rs.ObjectColor(guid, drawColor)\r\n        pass\r\n\n\nclass Line(object):\n    \"\"\"It's the conceptual skeleton for all line-like class\"\"\"\n    def __init__(self, endPoints, layer, color, isDrawedOpen=False, openRatio=0.5):\n        super(Line, self).__init__()\n        self.endPoints = endPoints\n        self.isDrawedOpen = isDrawedOpen\n        self.openRatio = openRatio\n        self.layer = layer\n        self.color = color\n        self.direction = gm.getDirection(endPoints[0], endPoints[1])\n\n    def draw(self):\n        if self.isDrawedOpen == False: #normal\n            rm.drawAtLayer2(rs.AddLine, self.endPoints[0], self.endPoints[1], self.layer, self.color)\n        #else:\n            #rm.drawOpenLine(self.endPoints, self.openRatio, self.layer, self.color)\n        pass\n\n\nclass Wall(Line):\n    \"\"\"the graph presentation and has nothing to do with logic\"\"\"\n    def __init__(self, endPoints, layer='Wall', isDrawedOpen=False, openRatio=0.5, color=0):\n        super(Wall, self).__init__(endPoints, layer, color)\n        self.controlLogicPoints = [] # wait to be initialized by Grid class\n\n\nclass Path(Line):\n    \"\"\"shows all the routes of the maze and which types of the routes\"\"\"\n    def __init__(self, endPoints, layer='Path', isDrawedOpen=False, openRatio=0.5, color=(0,255,0)):\n        super(Path, self).__init__(endPoints, layer, color)\n        self.type = 4 # 0=undefined, 1=main, 2=subsidiary, 3=circuit, 4=unchosen\n\n\n\nclass Grid(object):\n    \"\"\"The mother class which holds all other classes together and give the comprehensive idea of the maze. 2D version\"\"\"\n    def __init__(self, referecePoint, gridWidth, gridLength, width, length):\n        self.referencePoint = referecePoint\n        self.gridWidth = gridWidth\n        self.gridLength = gridLength\n        self.width = width\n        self.length = length\n        self.positionPoints = []\n        self.logicPoints = []\n        self.interiorLogicPoints = []\n        self.exteriorLogicPoints = []\n        self.walls = []\n        self.wallsDict = {}\n        self.paths = []\n#initialize all positionPoints\n        i = 0\n        j = 0\n        while  (j < gridLength):\n            while (i < gridWidth):\n                pp = PositionPoint(self.referencePoint, (i,j), width, length, layer='PositionPoint')\n                self.positionPoints.append(pp)\n                i = i + 1\n                pass\n            j = j + 1\r\n            i = 0\n            pass\n        for pt in self.positionPoints: #initialize each point's neighbors\n            pt.neighbors = gm.setNeighbors(pt.gridIndex, self.positionPoints, self.gridLength, self.gridWidth)\n            pass\n\n#initialize all logicPoints\n        i = 0\n        j = 0\n        while  (j <= gridLength ):\n            while (i <= gridWidth):\n                lp = LogicPoint(self.referencePoint, (i,j), width, length, layer='LogicPoint', color=(150,0,0))\n                self.logicPoints.append(lp)\n                i = i + 1\n            j = j + 1\r\n            i = 0\n        for pt in self.logicPoints:\n            pt.neighbors = gm.setNeighbors(pt.gridIndex, self.logicPoints, (self.gridLength+1), (self.gridWidth+1))\n            count = 0\n            for neighborPt in pt.neighbors:\n                if neighborPt != None:\n                    count = count + 1\n                    pass\n            if count == 4:\n                self.interiorLogicPoints.append(pt)\n                pt.isInterior = True\n                pass\n            else:\n                self.exteriorLogicPoints.append(pt)\n            pass\n#initialize all walls to be closed\n        wallPositionList = []\n        controlPointsList = []\r\n        wallPositionList = wallPositionList + gm.getCrossPairs(self.positionPoints, self.logicPoints, self.gridWidth, (self.gridWidth+1), isHorizontal=True)[0]\n        controlPointsList = controlPointsList + gm.getCrossPairs(self.positionPoints, self.logicPoints, self.gridWidth, (self.gridWidth+1), isHorizontal=True)[1]\r\n\r\n        verticalArray = gm.getVerticalPointsArray(self.positionPoints, self.gridWidth, self.gridLength)\n        wallPositionList = wallPositionList + gm.getCrossPairs(verticalArray, self.logicPoints, self.gridLength, (self.gridWidth+1), isHorizontal=False)[0]\n        controlPointsList = controlPointsList + gm.getCrossPairs(verticalArray, self.logicPoints, self.gridLength, (self.gridWidth+1), isHorizontal=False)[1]\n\r\n        i = 0\n        while (i < len(wallPositionList)):\n            endPoints = []\n            for positionPoint in wallPositionList:\n                endPoints.append((positionPoint[0].position, positionPoint[1].position))\n            wall = Wall(endPoints[i], layer='Wall', isDrawedOpen=False, openRatio=0.5, color=0)\n            wall.controlLogicPoints = controlPointsList[i]\n            self.walls.append(wall)\n            key1 = wall.controlLogicPoints[0].gridIndex\n            key2 = wall.controlLogicPoints[1].gridIndex\n            self.wallsDict[(key1,key2)] = i\n            i = i + 1\n            pass\n\n    def drawAll(self, isPositionPointOn = False, isLogicPointOn = False, isWallOn = True, isPathOn = False):\n        def checkDraw(trigger, list):\n            if trigger == True:\n                for item in list:\n                    item.draw()\n                pass\n            pass\n        checkDraw(isPositionPointOn, self.positionPoints)\n        checkDraw(isLogicPointOn, self.logicPoints)\n        checkDraw(isWallOn, self.walls)\n        checkDraw(isPathOn, self.paths)\n\n    def update(self,controlPointsList):\n        for pts in controlPointsList:\n            #change the walls state to make the maze\n            key = (pts[0].gridIndex, pts[1].gridIndex)\n            index = self.wallsDict[key]\n            wall = self.walls[index]\n            wall.isDrawedOpen = True\n#initaiize the Path class to represent the route in the maze\n            position1 = pts[0].position\n            position2 = pts[1].position\n            path = Path((position1, position2), layer='Path', isDrawedOpen=False, openRatio=0.5, color=(0,255,0))\n            self.paths.append(path)\n    def drawAnalysis(self, max, color = (200,150,255)):\n        for pt in self.interiorLogicPoints:\n            pt.drawDijkstraIndex(self.width/5)\n            pt.drawDijkstraColor(self.width, self.length, color, max, layer='DijkstraColor')\n        pass\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}