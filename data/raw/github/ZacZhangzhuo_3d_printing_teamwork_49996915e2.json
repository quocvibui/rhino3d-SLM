{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/Design_Substructure/Archive/Agents%20Generation/221213_Substructure_khara_working_ahm_2.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "Design_Substructure/Archive/Agents Generation/221213_Substructure_khara_working_ahm_2.py",
  "instruction": "221213 substructure khara working ahm 2",
  "code": "import Rhino.Geometry as rg\nimport ghpythonlib.treehelpers as th\nimport math\n\n#hellooo\ntolerance = 0.001\n\n#this class is focused on the properties and methods of each instance MAS (multi agent system)\nclass Environment(object):\n    \n    def __init__(self, u_div, v_div, surface, agents_list = [], repulsion_thresh = 0.5):\n        #self.num_agents = 0    #total number of agents\n        self.u_div = u_div\n        self.v_div = v_div\n        self.surface = surface\n        self.agents = []\n\n        self.finished_agents = []\n        if len(agents_list) > 0:\n            self.agents = agents_list\n       \n        self.strong_agents = self.GenerateStrongAgentsList()\n\n    #this function takes the u values and transform them into agents\n    def populate_agents(self, u_vals, target_factors):\n        # instantiatie all agents\n        for u, t_fac in zip(u_vals,target_factors) :\n            self.agents.append(Agent(u, 0, 0, t_fac / self.v_div,t_fac, self.surface)) \n\n    def update_agents_pos (self, coherence_rad, coherence_fac, align_rad, align_fac, avoid_rad, avoid_fac, Coherence_T, Alignment_T, Separation_T, repulsion_rad = 0, repulsion_fac = 0, Repulsion_T = False):\n        # generate the new position of each agent by calculating their new direction and velocity\n        #for each agent apply all the functions on it given the required factors for each parameter\n        #if the agent arrives we pop out this agent from the list and add it to the finished list \n        # add a function that if everything is arrived just stop \n        #list of all effects so as not to change the behaviour of the agents during update\n        effects_list = []\n        for agent in self.agents:\n            #always add a positive up vector in the beginning\n            effects_vector = rg.Vector2d(0,agent.up_force)            \n\n            if Coherence_T:\n                coherence_vector = agent.Coherence(coherence_rad, self.agents, self.u_div, self.v_div, coherence_fac)\n                effects_vector += coherence_vector\n\n            if Alignment_T:\n                alignment_vector = agent.Alignment(align_rad, self.agents, self.u_div, self.v_div, align_fac)\n                effects_vector += alignment_vector\n\n            if Separation_T:\n                separation_vector = agent.Separation(avoid_rad, self.agents, self.u_div, self.v_div, avoid_fac)\n                effects_vector += separation_vector\n\n                #sum all of the vectors + the actual du and dv of the agent + unitize --> do nothing but add them to the effects_list\n                effects_list.append(agent.AddTotalEffect(self.u_div, self.v_div, effects_vector))\n\n\n        temp_removed_agents = []\n        for agent, effect in zip(self.agents, effects_list):\n            agent.AgentStep(effect)\n            if agent.arrived:\n                temp_removed_agents.append(agent)\n       \n        for fin_agent in temp_removed_agents:\n            self.finished_agents.append(fin_agent)\n            self.agents.remove(fin_agent)\n\n\n        #pending: function that ensures all agents have reached the final destination\n    #checks all agents in the environment if they are strong or not based on their direction vector\n    def GenerateStrongAgentsList(self):\n        strong_Agents_list = []\n        for agent in self.agents:\n            if agent.unitized_upForce > self.repulsion_thresh:\n                strong_Agents_list.append(agent)\n        return strong_Agents_list\n\n\nclass Agent(object):\n\n#the main parameters are poisiton on the surface, velocity in both directions \n    def __init__(self, u, v, du, dv,unit_dv, surface):\n        self.u = u\n        self.v = v\n        self.surface = surface\n        self.position = self.surface.PointAt(self.u, self.v) ##for the surface\n\n        #save the dv as the constant upward vector for the current agent\n        self.up_force = dv\n        self.unitized_upForce = unit_dv #unitized value of the up vector\n        print (self.unitized_upForce)\n        self.du = du\n        self.dv = dv\n        self.pts = []\n        self.pts.append(self.position)\n        self.arrived = False\n        \n\n    def Coherence(self, radius, agents, u_div, v_div, coh_fac):\n        # agents : list of agents in the environment\n        # fx for Coherence\n        \"\"\" \n        --- within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> calculate the center (u,v) of the surrounding by 2 getting the average over all of the points \n        -> this shall be the point to aim at from the agent position \n        -> unitize the produced vector \n        \"\"\"\n        #coherence_distance = ra\n        centerU= 0\n        centerV= 0\n        num_neighbors = 0\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist<= radius:\n                    num_neighbors +=1\n                    centerU += agent.u\n                    centerV += agent.v\n\n        #get the average vector\n        if  num_neighbors > 0:\n            centerU /= num_neighbors\n            centerV /= num_neighbors\n\n            #unitize the product vector of the coherence  \n            cohesion_unit_vect = rg.Vector2d(centerU-self.u, centerV-self.v)\n            cohesion_unit_vect = self.UnitizeEffect(u_div, v_div,cohesion_unit_vect) * coh_fac\n\n            return cohesion_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n\n    # fx for Alignment (match velocity)\n    def Alignment(self, radius, agents, u_div, v_div, align_fac):\n        \n        \"\"\"within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> calculate the average velocity [adding all the velocities and dividing the result with the total number of neighbors]\n        \"\"\"\n        #radius = 10\n\n        average_du = 0\n        average_dv = 0\n        num_neighbors = 0\n\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist <= radius:\n                    num_neighbors +=1\n                    average_du += agent.du\n                    average_dv += agent.dv\n        \n        if  num_neighbors > 0:\n            average_du /= num_neighbors\n            average_dv /= num_neighbors\n\n            align_unit_vect = rg.Vector2d(average_du, average_dv)\n            align_unit_vect = self.UnitizeEffect(u_div, v_div,align_unit_vect) * align_fac\n\n            return align_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n    \n    #pending: trial\n    def Separation (self, radius, agents, u_div, v_div, avoid_fac):\n        # fx for Separation\n        \"\"\"within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> define how close two agents can be [min distance before collision]\n        -> define a new direction [maybe reversed]\n        \"\"\"\n        move_dU= 0\n        move_dV= 0\n\n        min_dist = 1000000\n        closest_agent = self\n\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist<= radius:\n                    if dist < min_dist:\n                        min_dist = dist\n                        closest_agent = agent\n        if closest_agent != self:\n            move_dU += self.u - closest_agent.u\n            move_dV += self.v - closest_agent.v\n\n            avoid_unit_vect = rg.Vector2d(move_dU, move_dV)\n            avoid_unit_vect = self.UnitizeEffect(u_div, v_div,avoid_unit_vect) * avoid_fac\n            return avoid_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n    \n\n    #checks the boundaries and for end of life of agent\n    def withinBounds (self): \n        \"\"\"\n        ->check if (0<=u,v<=1)\n        ->if not mirror u (*-1)\n        ->\n        \"\"\"\n        if abs(0.5 - self.u) >= 0.5 :       \n            if self.u < 0:\n                self.u = 0\n\n            elif self.u > 1:\n                self.u = 1\n\n            self.du *= -1\n            \n        #we check if it has arrived (finished)  \n        if self.v >= 1:\n            self.v = 1\n            self.arrived = True\n\n    \n    \n    # pending: fx for limiting speed?\n\n    # helper fxs:7\n\n    # add the effect to the new veloctity vector of the agent that will be added later to its current velocity\n    # as an input is the vector of a certain effect, the function does the following\n    # --> unitize the vector\n    # --> multiply by the effect value \n    # --> add this value to sum of new velocity vector \n    # --> this fx is called in each effect fx \n    def UnitizeEffect(self, u_div, v_div, vector_2b_unitised):           \n        vector_2b_unitised.Unitize()\n        vector_2b_unitised = rg.Vector2d(vector_2b_unitised.X/u_div, vector_2b_unitised.Y/v_div)\n        return vector_2b_unitised\n\n    # adds the new velocty vector to the current velocity vector and unitizes it \n    def AddTotalEffect(self, u_div, v_div, effects_vector):\n        effects_vector += rg.Vector2d(self.du, self.dv)\n        return self.UnitizeEffect(u_div, v_div, effects_vector)\n\n    # update the agent's params and move it one step forward while checking its elgibility for movement\n    def AgentStep(self, effects_vector):\n\n        self.du = effects_vector.X\n        self.dv = effects_vector.Y\n        self.u += self.du\n        self.v += self.dv\n        #checks the agent compliance with boundary\n        self.withinBounds()\n\n        self.pts.append(self.surface.PointAt(self.u, self.v))\n\n\n\n    #hello Eleniiiii\n    #hello Ahmed\n######################################################################################################################################\n# the execution function:\n# given the list of different points to initiate the agents do:\n# a for loop iterating over the lists, instantiating each agent in the list then instantaiting an environment given all these agents\n# afterwards, for each environment do some action till a certain time t\n# afterwards instantiate a bigger environment containing all agents and giving it a certain value for all parameters.\n\n#Swap UV directions of surface if needed\ncorner_b= surface.PointAt(1,0)\ncorner_d= surface.PointAt(0,1)\n\nif corner_b.Z > corner_d.Z:\n    surface.Transpose(True)\n\nall_agents = []\n#strt with first phase (t1)\ninitial_env_list = []\nu_lists = th.tree_to_list(u_lists)\ntarget_factors = th.tree_to_list(target_factors)\nfor u_list, t_factor in zip(u_lists, target_factors):\n    #instantiate an instance of the environment:\n    new_env = Environment(u_div, v_div, surface)\n    new_env.populate_agents(u_list, t_factor)\n    #add all agents to the big list\n    all_agents.extend(new_env.agents)\n    initial_env_list.append(new_env)\n\n\n#depending on the input timestep we update the agents\nfor t in range(time_1):\n    for env in initial_env_list:\n        env.update_agents_pos(coherence_rad, coherence_fac, align_rad, align_fac, avoid_rad, avoid_fac, Coherence_T, Alignment_T, Separation_T)\n\n#Create a new env contaiing all agents\ncombined_env = Environment(u_div, v_div, surface, all_agents)\nfor t in range(time_2):\n    combined_env.update_agents_pos(coherence_rad2, coherence_fac2, align_rad2, align_fac2, avoid_rad2, avoid_fac2, Coherence_T2, Alignment_T2, Separation_T2)\n\nlist_pts = []\npaths=[]\n#for env in initial_env_list:\n#   list_pts.append([agent.pts for agent in env.agents])\n#    for agent in env.agents:\n#        path = surface.InterpolatedCurveOnSurface(agent.pts,tolerance)\n#       paths.append(path)\n# \nfor agent in all_agents:\n    path = surface.InterpolatedCurveOnSurface(agent.pts,tolerance) \n    paths.append(path)  \n\npaths = th.list_to_tree(paths)\nlist_pts = th.list_to_tree(list_pts)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}