{
  "source_url": "https://github.com/kartpat/NoC/blob/a938cdfe36a5c75f53d5f28a5b3ee017660672f4/GAbasic.py",
  "repo": "kartpat/NoC",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "GAbasic.py",
  "instruction": "Gabasic",
  "code": "import rhinoscriptsyntax as rs \nimport math\nimport random\n\ndef mapRange(value, leftMin, leftMax, rightMin, rightMax):\n    # Figure out how 'wide' each range is\n    leftSpan = leftMax - leftMin\n    rightSpan = rightMax - rightMin\n\n    # Convert the left range into a 0-1 range (float)\n    valueScaled = float(value - leftMin) / float(leftSpan)\n\n    # Convert the 0-1 range into a value in the right range.\n    return rightMin + (valueScaled * rightSpan)\n\nclass DNA(object):\n\tdef __init__(self):\n\t\tself.gene = [random.randrange(-300,300,1),random.randrange(-300,300,1),random.randrange(-300,300,1)]\n\t\tself.fitness = 0\n\n\tdef fitness(self, targetLoc):\n\t\tdist = rs.Distance(self.gene, targetLoc)\n\t\tself.fitness = 1.0 / (1.0 + dist)\n\n\tdef crossover(self, partner):\n\t\tchild = DNA()\n\t\tchild.gene[0] = (self.gene[0] + partner.gene[0]) / 2.0\n\t\tchild.gene[1] = (self.gene[1] + partner.gene[1]) / 2.0\n\t\tchild.gene[2] = (self.gene[2] + partner.gene[2]) / 2.0\n\t\treturn child\n\n\tdef mutate(self,mutation):\n\t\tif random.random() < mutation:\n\t\t\tself.gene = [random.randrange(-300,300,1),random.randrange(-300,300,1),random.randrange(-300,300,1)]\n\nclass Population(object):\n\tdef __init__(self, t, m ,n):\n\n\t\tself.targetLoc = t;\n\t\tself.mutationRate = m\n\t\tself.pop = []\n\t\tfor i in range(n):\n\t\t\tself.pop.append(DNA())\n\n\t\tself.calcFitness()\n\t\tself.matingPool = list()\n\t\tself.finished = false\n\t\tself.generation = 0\n\t\tself.perfectScore = 1\n\n\tdef calcFitness(self):\n\t\tfor x in range(len(self.pop)):\n\t\t\t# check if self needs to be removed from below\n\t\t\tself.pop[x].fitness(self.targetLoc)\n\n\tdef naturalSelection(self):\n\t\tself.matingPool = []\n\t\tmaxFitness = 0\n\t\tfor i in range(len(self.pop)):\n\t\t\tif self.pop[i].fitness > maxFitness:\n\t\t\t\tmaxFitness = self.pop[i].fitness\n\n\t\tfor j in range(len(self.pop)):\n\t\t\tfit = mapRange(self.pop[j].fitness, 0, maxFitness , 0,1)\n\t\t\tn = int(fit*100)\n\t\t\tfor k in range(n):\n\t\t\t\tself.matingPool.append(self.pop[j])\n\n\tdef generate(self):\n\t\tfor i in range(len(self.pop)):\n\t\t\ta = int(random.random(len(self.matingPool)))\n\t\t\tb = int(random.random(len(self.matingPool)))\n\t\t\t# get function of the python - change it after reference\n\t\t\tpartnerA = \tself.matingPool[a]\n\t\t\tpartnerB = \tself.matingPool[b]\n\t\t\tchild = partnerA.crossover(partnerB)\n\t\t\tchild.mutate(self.mutation)\n\t\tself.generation = self.generation+1\n\n\tdef getBest(self):\n\t\tworldRecord = 0.0\n\t\tindex = 0\n\t\tfor i in range(len(self.pop)):\n\t\t\tif self.pop[i].fitness > worldRecord:\n\t\t\t\tindex = i\n\t\t\t\tworldRecord = self.pop[i].fitness\n\t\tif worldRecord == self.perfectScore:\n\t\t\tself.finished = true\n\t\treturn self.pop[index].gene\t\n\n\tdef finished(self):\n\t\treturn self.finished\n\n\tdef generations():\n\t\treturn self.generations\n\npointList = []\ntarget = [250,250,250]\nmutationRate = 0.01\npopMax = 50\n\npopul = Population(target,mutationRate, popMax)\n\n# The fucntion below simlates the Draw loop in processing\n\nfor x in range(5000):\n\t\n\tpopul.naturalSelection()\n\tpopul.generate()\n\tpopul.calcFitness()\n\tanswer = popul.getBest()\n\trs.AddPoint(answer)\n\tif popul.finished():\n\t\tprint \"Its all done.\"\n\n#     for n1 in range(len(moverList)):\n#         for n2 in range(len(moverList)): \n#             if n1 != n2:\n#                 attraction = moverList[n2].attract(moverList[n1])\n#                 # a.update()\n#                 # print attraction[0]\n#                 # print m.vecAcceleration\n#                 moverList[n1].applyForce(attraction)\n#                 # moverList[n].applyForce([0,.1,.1])\n#         moverList[n1].update()\n#         moverList[n1].display()\n#                 # rs.AddPoint(m.location)\n\n# # print m.location[0]\n# # print m.listPoints\n# for p in range(len(moverList)):\n#     rs.AddInterpCurve(moverList[p].listPoints)\n\n# # rs.AddPoint(m.listPoints)\n\n\n\n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}