{
  "source_url": "https://github.com/fstwn/pyembroideryGH/blob/ee7fd47316b364962a69976b4168ce9fef2702cf/usrobj_src/pyembroideryGH_PatternColorblocks.py",
  "repo": "fstwn/pyembroideryGH",
  "repo_stars": 11,
  "repo_description": "Set of UserObjects enabling Grasshopper to directly read, write and manipulate various kinds of embroidery formats. It is based on an IronPython-compatible fork of the original pyembroidery library.",
  "license": "MIT",
  "filepath": "usrobj_src/pyembroideryGH_PatternColorblocks.py",
  "instruction": "Get the stitches and threads of an embroidery pattern, formatted as\ncolorblocks. The pattern has to be supplied as an instance of\npyembroidery.EmbPattern.\n    Inputs:\n        Pattern: Pattern as...",
  "code": "\"\"\"\nGet the stitches and threads of an embroidery pattern, formatted as\ncolorblocks. The pattern has to be supplied as an instance of\npyembroidery.EmbPattern.\n    Inputs:\n        Pattern: Pattern as pyembroidery.EmbPattern instance\n    Output:\n        Stitch: The stitch(es) formatted as colorblocks\n        Thread: The thread, corresponding to the colorblock\n        as pyembroidery.EmbThread instance.\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 201030\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"PatternColorBlocks\"\nghenv.Component.NickName = \"PCB\"\nghenv.Component.Category = \"pyembroideryGH\"\nghenv.Component.SubCategory = \"2 Pattern Analysis\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    import pyembroidery\nexcept ImportError:\n    errMsg = (\"The pyembroidery python module seems to be not correctly \" +\n              \"installed! Please make sure the module is in you search \" +\n              \"path, see README for instructions!.\")\n    raise ImportError(errMsg)\n\nclass PatternColorBlocks(component):\n    \n    def RunScript(self, PatternTree):\n        # initialize outputs\n        Stitch = Grasshopper.DataTree[object]()\n        Thread = Grasshopper.DataTree[object]()\n        \n        # only do something if there is an input to begin with.\n        if PatternTree != None and PatternTree.DataCount:\n            # loop through all branches of the incoming tree(s)\n            for i, branch in enumerate(PatternTree.Branches):\n                branch_path = PatternTree.Path(i)\n                \n                # loop through all items of the current branch\n                for j, pattern in enumerate(branch):\n                    \n                    # make sure supplied pattern is really valid\n                    if not isinstance(pattern, pyembroidery.EmbPattern):\n                        rml = self.RuntimeMessageLevel.Warning\n                        errMsg = (\"The supplied pattern at branch {}, \" +\n                                  \"index {} is not a valid pyembroidery.\" + \n                                  \"EmbPattern instance! Null items will be \" + \n                                  \"inserted into the output trees!\")\n                        errMsg = errMsg.format(i, j)\n                        self.AddRuntimeMessage(rml, errMsg)\n                        # create the new tree path by modding the original path\n                        path = list(branch_path)\n                        path.append(j)\n                        path.append(0)\n                        path = Grasshopper.Kernel.Data.GH_Path(*path)\n                        Stitch.Add(None, path)\n                        Thread.Add(None, path)\n                        continue\n                    \n                    # get the colorblocks of the pattern\n                    stitchblock = zip(*list(pattern.get_as_colorblocks()))\n                    blocks = stitchblock[0]\n                    threads = stitchblock[1]\n                    \n                    # loop through all of the blocks of stitches\n                    for u, block in enumerate(blocks):\n                        stitches = list(block)\n                        for k, stitch in enumerate(stitches):\n                            stitch = [stitch[0] * 0.1,\n                                      stitch[1] * -0.1,\n                                      stitch[2]]\n                            stitch = [str(s) for s in stitch]\n                            stitch = \",\".join(stitch)\n                            stitches[k] = stitch\n                        \n                        # create the new tree path by modding the original path\n                        path = list(branch_path)\n                        path.append(j)\n                        path.append(u)\n                        path = Grasshopper.Kernel.Data.GH_Path(*path)\n                        \n                        # add all the stitches to the output tree\n                        Stitch.AddRange(stitches, path)\n                    \n                    # loop through all of the threads\n                    for u, thread in enumerate(threads):\n                        # create the new tree path by modding the original path\n                        path = list(branch_path)\n                        path.append(j)\n                        path.append(u)\n                        path = Grasshopper.Kernel.Data.GH_Path(*path)\n                        \n                        # add all the threads to the output tree\n                        Thread.Add(thread, path)\n        else:\n            rml = self.RuntimeMessageLevel.Warning\n            errMsg = (\"Input Pattern failed to collect data!\")\n            self.AddRuntimeMessage(rml, errMsg)\n        \n        # return outputs if you have them; here I try it for you:\n        return Stitch, Thread",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}