{
  "source_url": "https://github.com/egradman/rhinotools/blob/db6e79170674b887c00ad096eba3ba834382a98d/faces.py",
  "repo": "egradman/rhinotools",
  "repo_stars": 23,
  "repo_description": null,
  "license": "unknown",
  "filepath": "faces.py",
  "instruction": null,
  "code": "import rhinoscriptsyntax as rs\nfrom collections import defaultdict\nfrom collections import Iterable\nimport Rhino\n\ndef faces():\n  surfaces = rs.GetObjects(\"select surfaces\", filter=rs.filter.surface)\n  \n  points = [rs.EvaluateSurface(surface, *rs.SurfaceParameter(surface, (0.5, 0.5))) for surface in surfaces]\n  x = reduce(lambda s, point: s+point.X, points, 0) / len(points)\n  y = reduce(lambda s, point: s+point.Y, points, 0) / len(points)\n  z = reduce(lambda s, point: s+point.Z, points, 0) / len(points)\n\n  # find the center of the object\n  mass_center = rs.AddPoint(x,y,z)\n\n  extrude_curves = {}\n  # find the appropriate extrusion curve with the lowest dot product\n  for surface in surfaces:\n    surface_center = rs.EvaluateSurface(surface, *rs.SurfaceParameter(surface, (0.5, 0.5)))\n    center_vector = rs.VectorCreate(surface_center, mass_center)\n\n    normals = []\n    normals.append(rs.SurfaceNormal(surface, rs.SurfaceParameter(surface, (0.5, 0.5))))\n    normals.append(-rs.SurfaceNormal(surface, rs.SurfaceParameter(surface, (0.5, 0.5))))\n\n    if (rs.VectorDotProduct(normals[0], center_vector) < rs.VectorDotProduct(normals[1], center_vector)):\n      extrude_curve = normals[0]\n    else:\n      extrude_curve = normals[1]\n    extrude_curve = rs.VectorUnitize(extrude_curve)\n    extrude_curve = rs.VectorScale(extrude_curve, 0.25)\n    extrude_curve = [surface_center, rs.VectorAdd(surface_center, extrude_curve)]\n    extrude_curve = rs.AddCurve(extrude_curve)\n    \n    rs.ExtrudeSurface(surface, extrude_curve)\n    rs.DeleteObject(extrude_curve)\n    rs.DeleteObject(surface)\n\n  rs.DeleteObject(mass_center)\n\n\n\n\n\n\n\n\nif __name__=='__main__':\n  faces()\n\n#\"\"\"\n## notes\n#- doesn't handle laser curf currently.  to do this, simple scale alternating\n#  cylinders along the intersection axis\n#\n#\"\"\"\n#\n## this dictionary maps a guid to the fingers\n## which will be booleansubtracted from it\n## in the final step\n#guid_to_difference = defaultdict(list)\n#\n#def perform_subtraction():\n#  # each time make_fingers is run, it fills guid_to_difference\n#  # with more fingers to subtract.\n#  # after all the fingers are subtracted at once\n#  for guid, objs in guid_to_difference.items():\n#    print guid, len(objs)\n#    rs.BooleanDifference(guid, objs)\n#\n#def make_fingers(positive, negative, subdivisions):\n#  \"\"\"\n#  intersect two collections of planes\n#  subdivide the intersections\n#  assign each subdivision to a guid from which it will be subtracted\n#  \"\"\"\n#\n#  # this vector is used to indicate axis of the intersection.\n#  # it needs to be parallel to the intersection\n#  # (there are other ways of doing this!)\n#  p0 = rs.GetPoint(\"select start of intersection\")\n#  p1 = rs.GetPoint(\"select end of intersection\")\n#\n#  edge = rs.AddLine(p0, p1)\n#  vector = rs.VectorCreate(p0, p1)\n#\n#  rs.EnableRedraw(False)\n#\n#  # this dict maps a pair of planes (ps, ns) to their booleanintersection\n#  intersections = {}\n#\n#  for ps in positive:\n#    for ns in negative:\n#      intersection = rs.BooleanIntersection(ps, ns, False)\n#      intersections[(ps, ns)] = intersection\n#\n#  # here we construct some very large cylinders aligned with the axis you drew\n#  origins = []\n#  cylinders = []\n#  for i in range(subdivisions+1):\n#    origin = rs.EvaluateCurve(edge, rs.CurveParameter(edge, i * 1.0/(subdivisions)))\n#    origins.append(origin)\n#\n#  rs.DeleteObject(edge)\n#\n#  for i in range(subdivisions):\n#    plane = rs.PlaneFromNormal(origins[i], vector)\n#    circle = rs.AddCircle(plane, 100)\n#    planar_circle = rs.AddPlanarSrf(circle)\n#\n#    extrusion_curve = rs.AddLine(origins[i], origins[i+1])\n#    cylinders.append(rs.ExtrudeSurface(planar_circle, extrusion_curve))\n#\n#    rs.DeleteObject(circle)\n#    rs.DeleteObject(planar_circle)\n#    rs.DeleteObject(extrusion_curve)\n#\n#\n#  # we perform a boolean intersection between each intersection and\n#  # the cylinders to construct the fingers\n#  for key, intersection in intersections.items():\n#    ps, ns = key\n#\n#    for i, cylinder in enumerate(cylinders):\n#      print \"intersection\", intersection\n#      print \"cylinder\", cylinder\n#      objs = [brep for brep in rs.BooleanIntersection(intersection, cylinder, False) if rs.IsBrep(brep)]\n#      # assign the resulting fingers to either the positive or negative\n#      if i % 2 == 0:\n#        guid_to_difference[ps].extend(objs)\n#      else:\n#        guid_to_difference[ns].extend(objs)\n#\n#  DeleteItemOrList(cylinders)\n#  DeleteItemOrList(intersections.values())\n#\n#  rs.EnableRedraw(True)\n#\n#def DeleteItemOrList(d):\n#  \"\"\"\n#  helper to delete a guid or a list of guids\n#  \"\"\"\n#  if isinstance(d, Iterable):\n#    for item in d: DeleteItemOrList(item)\n#  else:\n#    rs.DeleteObject(d)\n#\n#if __name__ == '__main__':\n#  main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}