{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/mmmesh/mmfabmesh_robobend.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "mmmesh/mmfabmesh_robobend.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 21.01.2017\n\n@author: kathrind\n'''\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\nfrom System.Collections.Generic import IEnumerable, List\nfrom mmmesh import MMMesh\nfrom node_robobend import Node\n\n# globals\ndiscrete_insertion_offset = 15 #= 35\ndiscrete_insertion_bending_offset = 0 #--> = formerly 8\ndiscrete_offset_to_wire_continuous = 4.5 #6.0 #4.5\ndiscrete_excess_len_top = 13 #0 #15\ndiscrete_excess_len_bottom = 5 #0 #10\n\nsafe_offset_lead_in = 10\noffset_lead_out = 10\nlead_out_top = 2800 + discrete_insertion_offset + 40\noffset_lead_out_z = 150\noffset_to_plinth = 386\n\n\nclass MMFabMeshRoboBend(MMMesh):\n\n    #===========================================================================\n    def __init__(self):\n        MMMesh.__init__(self)\n        \n        # mesh nodes\n        self.nodes_in_layers = [] #layer based structure [[[nodes_interior],[nodes_exterior_srf1],[nodes_exterior_srf2]],[[],[],[]],...]\n        self.nodes = [] #shallow list of nodes\n        \n        self.collision_geo = None\n    \n    #===========================================================================\n    def set_collision_geo(self, geo):\n        self.collision_geo = geo\n    \n    #===========================================================================\n    def generate_fab_mesh(self, row_from, row_to):\n        ''' generate the mesh node topology of the intersection pts grid'''\n        self.nodes_in_layers = []\n        self.nodes = []\n        \n        self.nodes_in_layers = self.generate_nodes_in_layers(row_from, row_to)\n        self.nodes = self.get_flat_list_from_2dlist([j for i in self.nodes_in_layers for j in i])\n        \n        self.calc_node_indices_from_nodes()\n    \n    def calc_neighbor_nodes_for_line_est(self):\n        '''calculate the neighbor geometry for all nodes for the line estimation'''\n        [self.calc_neighbor_nodes_geo_for_line_est(n) for n in self.nodes]\n\n    #===========================================================================\n    def generate_nodes_in_layers(self, row_from, row_to):\n        '''calculcate the nodes in layers, starting with srf1, srf2 and each x row interiors'''\n        \n        nodes_in_row_srf2 = [self.get_fab_nodes_row(row, index_row, \"srf2\", index_layer_list=0) for index_row, row in enumerate(range(max(row_from,1), row_to))]\n        nodes_in_row_srf1 = [self.get_fab_nodes_row(row, index_row, \"srf1\", index_layer_list=1) for index_row, row in enumerate(range(max(row_from,1), row_to))]\n\n        return zip(nodes_in_row_srf2, nodes_in_row_srf1)\n\n    #===========================================================================\n    def get_fab_nodes_row(self, row, index_row, srf = \"srf1\", index_layer_list=0):\n        \"return nodes of one row\"\n        \n        layer_type = \"even\" if row%2 == 0 else \"odd\"\n        node_type = \"ext_srf1\" if srf== \"srf1\" else \"ext_srf2\"\n        \n        nodes_in_row = []\n        \n        if layer_type == \"even\":\n        \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            \n            # 1. lead in nodes\n            nodes = self.generate_nodes_exterior_lead_in(row, index_row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n            \n            # 2. normal nodes\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 0: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            nodes = self.generate_nodes_exterior_lead_out(row, index_row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n        \n        else: #layer_type == \"odd\":\n            \n            # 1. lead in nodes\n            nodes = self.generate_nodes_exterior_lead_in(row, index_row, 0, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n            \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                #elif col==self.cols: # lead out nodes\n                #    pass \n                else:\n                    if col % 2 == 1: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, index_row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type, index_layer_list = index_layer_list)\n                        nodes_in_row.append(node)\n            \n            # 3. lead out nodes\n            nodes = self.generate_nodes_exterior_lead_out(row, index_row, node_type = node_type, srf = srf, layer_type = layer_type, index_layer_list = index_layer_list)\n            nodes_in_row += nodes\n        \n        self.calc_lines_in_cont_dir_row(nodes_in_row) # calculate the continuous members\n        self.calc_bending_angles_row(nodes_in_row) # calculate the absolute bending angles of the individual nodes\n        self.calc_node_indices_col_in_row(nodes_in_row)\n        self.set_collision_geo_for_nodes_in_row(nodes_in_row) # calculate the collision geo associated with every node which has a insertion\n        \n        return nodes_in_row\n    \n    def get_node_in_layer(self, row, col, index_layer_list = 0):\n        ''' return the node given by row and column and side of the mesh '''\n        row = min(len(self.nodes_in_layers)-1, row)\n        col = min(len(self.nodes_in_layers[row][index_layer_list])-1, col)\n        return self.nodes_in_layers[row][index_layer_list][col]\n    \n    def get_corner_pts(self, row, col, srf = \"srf1\"):\n        pt1_row_current = self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n        pt2_row_current = self.get_pt_row_col_rgmesh_fab(row, col - 2, srf = srf)\n        pt1_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col, srf = srf)\n        pt2_row_under = self.get_pt_row_col_rgmesh_fab(row - 1, col - 2, srf = srf)\n        return (pt1_row_current, pt2_row_current, pt1_row_under, pt2_row_under)\n    \n    def get_plane_wrist(self, cutting_plane, pt_before, axis):\n        ''' the wrist planes have an offset to the inserted vertical, given the vertical insertion offset and the additional offset for bending'''\n\n        plane_wrist = rg.Plane(cutting_plane)\n        plane_wrist.Origin = rg.Point3d.Add(pt_before, axis * discrete_insertion_offset)\n        \n        return plane_wrist\n    \n    def get_plane_for_inserting(self, plane_wrist, corner_pts):\n        \n        pt_current, pt_before, pt_under_current, pt_under_before = corner_pts\n        vec_xaxis = rg.Vector3d(pt_current-pt_before)\n        vec_zaxis = rg.Vector3d(pt_current-pt_under_before)\n        vec_yaxis = rg.Vector3d.CrossProduct(vec_zaxis, vec_xaxis)\n        \n        plane_for_inserting = rg.Plane(plane_wrist.Origin, vec_xaxis, vec_yaxis)\n        \n        return plane_for_inserting\n    \n    def generate_node_exterior(self, row, index_row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\", index_layer_list = 0):\n        ''' creating an exterior node '''\n        \n        node = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        cutting_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square\n        pt_current, pt_before, pt_under_current, pt_under_before = self.get_corner_pts(row, col, srf = srf)\n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n        \n        if insert_discrete_element == True:\n            \n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            intersect_line_cont_disc = rg.Point3d(pt_before)\n            \n            line_discrete_element_vec = line_discrete_element.Direction\n            line_discrete_element_vec.Unitize()\n            \n            T_stretch_above = rg.Transform.Translation(line_discrete_element_vec * -discrete_excess_len_top)\n            T_stretch_under = rg.Transform.Translation(line_discrete_element_vec * discrete_excess_len_bottom)\n            \n            pt_before_stretched, pt_under_before_stretched = (rg.Point3d(pt_before), rg.Point3d(pt_under_before))\n            \n            pt_before_stretched.Transform(T_stretch_above)\n            pt_under_before_stretched.Transform(T_stretch_under)\n            \n            line_discrete_element = rg.Line(pt_before_stretched, pt_under_before_stretched)\n\n            plane_wrist = self.get_plane_wrist(cutting_plane, pt_before, axis)\n            plane_for_inserting = self.get_plane_for_inserting(plane_wrist, [pt_current, pt_before, pt_under_current, pt_under_before])\n            \n            T_offset = rg.Transform.Translation(plane_for_inserting.YAxis * -discrete_offset_to_wire_continuous)\n            line_discrete_element.Transform(T_offset)\n            \n            \n        else:\n            \n            line_discrete_element = None\n            intersect_line_cont_disc = None\n            \n            plane_wrist = rg.Plane(cutting_plane)\n            plane_wrist.Origin = pt_current\n            plane_for_inserting = None\n        \n        node.fill_params(plane_wrist, axis, insert_discrete_element, plane_for_inserting, line_discrete_element, intersect_line_cont_disc)\n\n        #node.corner_pts = self.get_corner_pts(row, col, srf = srf)\n        return node\n\n    def generate_nodes_exterior_lead_in(self, row, index_row, col, node_type, srf, layer_type, index_layer_list):\n        ''' creating the exterior node for lead in '''\n        \n        #node_lead_in_0 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_in_1 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        cutting_plane = self.cutting_planes[row]\n        \n        wrist_plane_1 = rg.Plane(cutting_plane)\n        wrist_plane_1.Origin = self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n        \n        wrist_plane_1.Translate(wrist_plane_1.XAxis * safe_offset_lead_in)\n        \n        node_lead_in_1.fill_params(wrist_plane_1)  \n        \n        #wrist_plane_0 = rg.Plane(wrist_plane_1)\n        \n        #vec_lead_in = self.get_pt_row_col_rgmesh_fab(row, 1, srf = srf) - self.get_pt_row_col_rgmesh_fab(row, 0, srf = srf)\n        #vec_lead_in.Unitize()\n        \n        #wrist_plane_0.Translate(wrist_plane_0.XAxis * - offset_lead_in)\n        \n        #node_lead_in_0.fill_params(wrist_plane_0)  \n        \n        #node_lead_in_1.estimate_with_eeff_cam = False\n        \n        #return [node_lead_in_0, node_lead_in_1]\n        return [node_lead_in_1]\n\n    def generate_nodes_exterior_lead_out(self, row, index_row, node_type, srf, layer_type, index_layer_list):\n        ''' creating an exterior node '''\n        \n        node_lead_out_0 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_out_1 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_out_2 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        node_lead_out_3 = Node(node_type, layer_type, index_row, index_layer_list) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        cutting_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square\n        # pt_current, pt_before, pt_under_current, pt_under_before = self.get_corner_pts(row, col, srf = srf)\n        \n        if layer_type == \"even\":\n            pt_current = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf)\n            pt_before = self.get_pt_row_col_rgmesh_fab(row, self.cols-2, srf = srf)\n            pt_under_current = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf)\n            pt_under_before = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-2, srf = srf)\n        else:\n            vec_lead_out = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf) - self.get_pt_row_col_rgmesh_fab(row, self.cols-2, srf = srf)\n            vec_lead_out.Unitize()\n            \n            pt_current = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf) + vec_lead_out*100\n            pt_before = self.get_pt_row_col_rgmesh_fab(row, self.cols-1, srf = srf)\n            pt_under_current = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf) + vec_lead_out*100\n            pt_under_before = self.get_pt_row_col_rgmesh_fab(row - 1, self.cols-1, srf = srf)\n            \n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n            \n        line_discrete_element = rg.Line(pt_before, pt_under_before)\n        intersect_line_cont_disc = rg.Point3d(pt_before)\n        \n        line_discrete_element_vec = line_discrete_element.Direction\n        line_discrete_element_vec.Unitize()\n        \n        T_stretch_above = rg.Transform.Translation(line_discrete_element_vec * -discrete_excess_len_top)\n        T_stretch_under = rg.Transform.Translation(line_discrete_element_vec * discrete_excess_len_bottom)\n        \n        pt_before_stretched, pt_under_before_stretched = (rg.Point3d(pt_before), rg.Point3d(pt_under_before))\n        \n        pt_before_stretched.Transform(T_stretch_above)\n        pt_under_before_stretched.Transform(T_stretch_under)\n        \n        line_discrete_element = rg.Line(pt_before_stretched, pt_under_before_stretched)\n\n        #wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n        plane_wrist = self.get_plane_wrist(cutting_plane, pt_before, axis)\n        plane_for_inserting = self.get_plane_for_inserting(plane_wrist, [pt_current, pt_before, pt_under_current, pt_under_before])\n        \n        T_offset = rg.Transform.Translation(plane_for_inserting.YAxis * -discrete_offset_to_wire_continuous)\n        line_discrete_element.Transform(T_offset)\n        \n        \n        node_lead_out_0.fill_params(plane_wrist, axis, True, plane_for_inserting, line_discrete_element, intersect_line_cont_disc)\n\n        #node_lead_out_0.corner_pts = [pt_current, pt_before, pt_under_current, pt_under_before]\n        \n        #plane_wrist_1 = rg.Plane(plane_wrist)\n        plane_wrist_1 = rg.Plane(plane_for_inserting)\n        \n        #plane_wrist_1.Translate(plane_wrist_1.XAxis * offset_lead_out)\n        plane_wrist_1.Origin = rg.Point3d(plane_wrist_1.Origin.X, plane_wrist_1.Origin.Y, lead_out_top)\n        \n        node_lead_out_1.fill_params(plane_wrist_1)  \n        \n        plane_wrist_2 = rg.Plane(plane_wrist_1)\n        plane_wrist_2.Translate(plane_wrist_2.ZAxis * offset_lead_out_z)\n        \n        node_lead_out_2.fill_params(plane_wrist_2)  \n        \n        plane_wrist_3 = rg.Plane(plane_wrist_2)\n        plane_wrist_3.Translate(plane_wrist_3.XAxis * - 500)\n        \n        node_lead_out_3.fill_params(plane_wrist_3)  \n        \n        return [node_lead_out_0, node_lead_out_1, node_lead_out_2, node_lead_out_3]\n    \n    def get_angle(self,n1,n2,axis): \n        ''' get the angle for the tilted plane for inserting the discrete rebar element'''\n        \n        #________________check for the rotation direction_______________________\n        #angle           = rs.VectorAngle (n1,n2) # rotation angle\n        angle           = rg.Vector3d.VectorAngle(rg.Vector3d(n1), rg.Vector3d(n2))\n         \n        #print \"angle: \", angle\n        test_vec_clw = rg.Vector3d(n1)\n        test_vec_clw.Rotate(angle, axis)\n        \n        sub_vec_clw = rg.Vector3d.Subtract(test_vec_clw,n2)\n        length_clw = sub_vec_clw.Length\n        test_vec_aclw = rg.Vector3d(n1)\n        test_vec_aclw.Rotate(angle*-1, axis)       \n        sub_vec_aclw = rg.Vector3d.Subtract(test_vec_aclw, n2)\n        length_aclw = sub_vec_aclw.Length\n        \n        if angle == 0 or length_clw < length_aclw:\n            rot_angle = angle * -1\n        else:\n            rot_angle = angle \n   \n        return rot_angle\n    \n    def calc_neighbor_nodes_geo_for_line_est(self, node):\n        ''' this method returns the lines for the line estimation with the endeffector cameras\n        line 1 = line_c = line from discrete element 01 startpt to discrete element 02 startpt (= continuous element)\n        line 2 = line_d1 = line of discrete element 01 (= discrete element in front)\n        line 3 = line_d2 = line of discrete element 02 (= discrete element in the back)\n        '''\n        \n        # estimation_type: 1: front discrete wire, 2: back discrete wire, 3: match both wires\n        \n        neighbor_nodes = self.get_neighbor_nodes_from_node_for_line_est(node)\n        if len(neighbor_nodes):\n            node.estimate_with_eeff_cam = True\n            node.neighbor_node_for_est_01, node.neighbor_node_for_est_02 = neighbor_nodes\n            line_d1, line_d2 = [n.line_discrete_element for n in neighbor_nodes]\n            \n            if line_d1 and line_d2:\n                #print \"line_d1 and line_d2\"\n                node.estimation_type = 2\n                p1, p2 = [n.intersect_line_cont_disc for n in neighbor_nodes]\n                line_c = rg.Line(p1, p2)\n                #print line_c\n            \n            if line_d1 and line_d2 == None:\n                #print \"line_d1 and line_d2 == None\"\n                node.estimation_type = 1\n                p1 = neighbor_nodes[0].intersect_line_cont_disc\n                p2 = neighbor_nodes[1].plane_wrist.Origin\n                line_c = rg.Line(p1, p2)\n                #print line_c\n                \n            if line_d1 == None and line_d2:\n                #print \"line_d1 == None and line_d2\"\n                node.estimation_type = 2\n                p2 = neighbor_nodes[1].intersect_line_cont_disc\n                p1 = neighbor_nodes[0].plane_wrist.Origin\n                line_c = rg.Line(p1, p2)\n                #print line_c\n                \n            if line_d1 == None and line_d2 == None:\n                #print \"line_d1 == None and line_d2 == None\"\n                node.estimate_with_eeff_cam = False\n                node.estimation_type = 0\n                \n                p2 = neighbor_nodes[1].plane_wrist.Origin\n                p1 = neighbor_nodes[0].plane_wrist.Origin\n                line_c = rg.Line(p1, p2)\n            \n            \n            #node.estimated_lines_global = [line_c, line_d1, line_d2]\n            node.lines_for_estimation_WCS = [line_c, line_d1, line_d2]\n\n\n    def get_neighbor_nodes_from_node_for_line_est(self, node):\n        #node.index_row\n        #node.index_col\n        #node.index\n        #node.index_layer_list\n        \n        if node.insert_discrete_element and node.node_type != \"interior\":\n            row_prev = node.index_row-1\n            \n            if node.layer_type == \"odd\":  \n                neighbor_node_for_est_01 = self.get_node_in_layer(row_prev, node.index_col+1, index_layer_list = node.index_layer_list)\n                neighbor_node_for_est_02 = self.get_node_in_layer(row_prev, node.index_col, index_layer_list = node.index_layer_list)\n            else:\n                neighbor_node_for_est_01 = self.get_node_in_layer(row_prev, node.index_col, index_layer_list = node.index_layer_list)\n                neighbor_node_for_est_02 = self.get_node_in_layer(row_prev, node.index_col-1, index_layer_list = node.index_layer_list)\n            \n            return (neighbor_node_for_est_01, neighbor_node_for_est_02)\n        else:\n            return []\n        \n    def calc_neighbor_nodes_from_node_for_line_est(self, node):\n        neighbor_nodes = self.get_neighbor_nodes_from_node_for_line_est(node)\n        if len(neighbor_nodes): node.neighbor_node_for_est_01, node.neighbor_node_for_est_02 = neighbor_nodes\n    \n    def calc_neighbor_nodes_for_line_estimation(self):\n        for layer in self.nodes_in_layers[1:]:\n            for node_list in layer:\n                for node in node_list[1:len(node_list)-1]:\n                    self.calc_neighbor_nodes_from_node_for_line_est(node)\n    \n    def calc_node_indices_from_nodes(self):\n        '''calculates the index of nodes from the falt list of nodes'''\n        [node.set_index(i) for i, node in enumerate(self.nodes)]\n        \n    def calc_node_indices_col_in_row(self, nodes_in_row):\n        '''calculates the index of nodes from the falt list of nodes'''\n        [node.set_index_col(i) for i, node in enumerate(nodes_in_row)]\n\n    def calc_lines_in_cont_dir_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the line members in contiuous direction '''\n        \n        # first node\n        if not nodes_in_row[0].node_type == \"interior\":\n            node_current = nodes_in_row[0]\n            node_current.line_continuous_element = rg.Line(node_current.plane_wrist.Origin, rg.Point3d(node_current.plane_wrist.Origin.X,  node_current.plane_wrist.Origin.Y, -offset_to_plinth))\n            \n        for i in range(1, len(nodes_in_row)-1):\n            node_current = nodes_in_row[i]\n            node_before = nodes_in_row[i-1]\n            node_current.line_continuous_element = rg.Line(node_current.plane_wrist.Origin, node_before.plane_wrist.Origin)\n                \n    def calc_bending_angles_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the bending angles for the robot itself. \n        The values are absolute in relation to the X axis of the current wrist plane of each layer '''             \n\n        for i in range(len(nodes_in_row)-1):\n            \n            if nodes_in_row[i+1].line_continuous_element:\n                node_current = nodes_in_row[i]\n                node_next = nodes_in_row[i+1]\n                \n                vec = rg.Vector3d(node_next.line_continuous_element.From - node_next.line_continuous_element.To)\n                angle = rg.Vector3d.VectorAngle(node_current.plane_wrist.XAxis, vec, node_current.plane_wrist)\n                \n                try: angle = m.degrees(angle) # needs to be done because of a math overflow error\n                except: angle = 0\n                \n                if angle > 180:\n                    angle = (360-angle)*-1\n\n                node_current.absolute_bending_angle = angle\n                #nodes_in_row[i].is_for_bending = True\n                \n                \n                if node_current.plane_for_inserting:\n                    angle = rg.Vector3d.VectorAngle(node_current.plane_for_inserting.XAxis, vec, node_current.plane_for_inserting)\n                    plane_for_bending = rg.Plane(node_current.plane_for_inserting)\n                    plane_for_bending.Rotate(angle, plane_for_bending.ZAxis)\n                    node_current.plane_for_bending = plane_for_bending\n                    #plane_for_bending.Origin = node_next.plane_wrist.Origin\n                    #node_next.plane_for_bending = plane_for_bending\n                    \n                \n                \"\"\"\n                if node_current.wrist_plane_for_inserting_tilted:\n                    robo_plane_after_bending = rg.Plane(node_current.wrist_plane_for_inserting_tilted)\n                else:\n                    robo_plane_after_bending = rg.Plane(node_current.wrist_plane_for_bending)\n                \n                if node_next.wrist_plane_for_inserting_tilted:\n                    robo_plane_before_bending = rg.Plane(node_next.wrist_plane_for_inserting_tilted)\n                else:\n                    robo_plane_before_bending = rg.Plane(node_next.wrist_plane_for_bending)\n                \n                robo_plane_after_bending.Rotate(m.radians(angle), robo_plane_after_bending.ZAxis)\n                robo_plane_before_bending.Rotate(m.radians(angle), robo_plane_before_bending.ZAxis)\n                \n                node_current.robo_plane_after_bending = rg.Plane(robo_plane_after_bending)\n                node_next.robo_plane_before_bending = rg.Plane(robo_plane_before_bending)\"\"\"\n                    \n    \n    def set_collision_geo_for_nodes_in_row(self, nodes_in_row):\n        if self.collision_geo:\n            for i, node in enumerate(nodes_in_row):\n                if node.insert_discrete_element:\n                    T1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, node.plane_for_inserting)\n                    bending_angle = nodes_in_row[i-1].absolute_bending_angle  if i>0 else node.absolute_bending_angle\n                    #T2 = rg.Transform.Rotation(m.radians(bending_angle), node.wrist_plane_for_inserting_tilted.ZAxis, node.wrist_plane_for_inserting_tilted.Origin)\n                    T2 = rg.Transform.Rotation(m.radians(bending_angle), rg.Plane.WorldXY.ZAxis, rg.Plane.WorldXY.Origin)\n    \n                    coll_geo_transformed = ghcomp.Transform(self.collision_geo, T1*T2)\n                    node.collision_geo = coll_geo_transformed\n    \n    def get_collcheck_geo(self, node_idx, collcheck_num):\n        mesh_nodes_collcheck = self.nodes[max(node_idx - collcheck_num, 0):node_idx]\n        geo_c_collcheck = [node.line_continuous_element for node in mesh_nodes_collcheck if node.line_continuous_element]\n        geo_d_collcheck = [node.line_discrete_element for node in mesh_nodes_collcheck if node.line_discrete_element]\n        return geo_c_collcheck+geo_d_collcheck\n        ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}