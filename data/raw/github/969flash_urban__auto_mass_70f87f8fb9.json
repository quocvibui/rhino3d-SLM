{
  "source_url": "https://github.com/969flash/urban__auto_mass/blob/ae21bb79b4b6147e0ee88e4d4a4deadf7586083e/fx/utils.py",
  "repo": "969flash/urban__auto_mass",
  "repo_stars": 0,
  "repo_description": "Using Rhino Grasshopper for making mass modeling",
  "license": "unknown",
  "filepath": "fx/utils.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional, Union\nexcept ImportError:\n    pass\nimport collections\nfrom operator import attrgetter\nimport functools\n\nimport Rhino\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\n\nBIGNUM = 10000000\n\nTOL = 0.001\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\n\n\ndef trim_crv_from_length(crv, length, reverse=False):\n    # type: (geo.Curve, float, bool) -> geo.Curve\n    \"\"\"crv의 시작점부터 lenth까지의 커브를 구한다.\"\"\"\n    is_len_possible, param = crv.LengthParameter(length)\n    if not is_len_possible:\n        return crv\n\n    ## for Rhino 8, REMOVE FOR RHINO7 !!!##\n    param = float(param)\n    ########################################\n\n    if reverse:\n        return crv.Trim(param, crv.Domain.Max)\n    return crv.Trim(0.0, param)\n\n\ndef trim_crv_from_length(crv, length, reverse=False):\n    # type: (geo.Curve, float, bool) -> geo.Curve\n    \"\"\"crv의 시작점부터 lenth까지의 커브를 구한다.\"\"\"\n    is_len_possible, param = crv.LengthParameter(length)\n    if not is_len_possible:\n        return crv\n\n    ## for Rhino 8, REMOVE FOR RHINO7 !!!##\n    param = float(param)\n    ########################################\n\n    if reverse:\n        return crv.Trim(param, crv.Domain.Max)\n    return crv.Trim(0.0, param)\n\n\ndef get_length(crvs, ndigits=3):\n    # type: (List[geo.Curve], int) -> float\n    if not isinstance(crvs, list):\n        return round(crvs.GetLength(), ndigits)\n    length = 0\n    for crv in crvs:\n        length += round(crv.GetLength(), ndigits)\n    return length\n\n\ndef get_dist_from_crv_crv(crv_a, crv_b):\n    # type: (geo.Curve, geo.Curve) -> float\n    \"\"\"두 커브 사이의 거리를 잰다.\n\n    Args:\n        crv_a : crv_b과 거리를 잴 커브\n        crv_b : crv_a과 거리를 잴 커브\n\n    Returns:\n        두 커브 사이 거리\n    \"\"\"\n    _, a, b = crv_a.ClosestPoints(crv_b)\n    dist = a.DistanceTo(b)\n    dist = round(dist, 6)\n    return dist\n\n\ndef is_intersection_with_other_crvs(crv, crvs):\n    # type: (geo.Curve, List[geo.Curve]) -> bool\n    return any(\n        geo.Curve.PlanarCurveCollision(crv, other_crv, geo.Plane.WorldXY, OP_TOL)\n        for other_crv in crvs\n    )\n\n\ndef offset_regions_inward(regions, dist, miter=BIGNUM):\n    # type: (geo.Curve | List[geo.Curve], float, int) -> List[geo.Curve]\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_region_outward(region, dist, miter=BIGNUM):\n    # type: (geo.Curve, float, float) -> geo.Curve\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef convert_io_to_list(func):\n    \"\"\"인풋과 아웃풋을 리스트로 만들어주는 데코레이터\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour = None  # type: Optional[List[geo.Curve]]\n            self.holes = None  # type: Optional[List[geo.Curve]]\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs,\n        dists,\n        miter=BIGNUM,\n        closed_fillet=2,\n        open_fillet=2,\n        tol=Rhino.RhinoMath.ZeroTolerance,\n    ):\n        # type: (List[geo.Curve], List[float], int, int, int, float) -> _PolylineOffsetResult\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if tol == Rhino.RhinoMath.ZeroTolerance and open_fillet == 0:\n            raise ValueError(\"open_fillet must be 1 or 2\")\n\n        if not crvs:\n            raise ValueError(\"crvs must be more than 1\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}