{
  "source_url": "https://github.com/augmentedfabricationlab/cdf_2023/blob/94c04507eb0690390113fc90f608622e504275eb/src/cdf_2023/assembly/assembly.py",
  "repo": "augmentedfabricationlab/cdf_2023",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/cdf_2023/assembly/assembly.py",
  "instruction": "Assembly",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport math\nimport compas\n\nfrom copy import deepcopy\nfrom compas.geometry import Frame, Vector, Plane\nfrom compas.geometry import Transformation, Translation, Rotation\nfrom compas.geometry import intersection_line_plane\nfrom compas.geometry import distance_point_point, distance_line_line, distance_point_line\nfrom compas.datastructures import Network, mesh_offset\nfrom compas.artists import Artist\nfrom compas.colors import Color\nfrom compas.topology import connected_components\nfrom compas_rhino.conversions import line_to_rhino_curve, point_to_compas, point_to_rhino, line_to_compas\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as gh\n\nfrom .element import Element\n\nfrom .utilities import FromToData\nfrom .utilities import FromToJson\nfrom .utilities import element_to_INCON\nfrom .utilities import tag_to_INCON\n\n__all__ = ['Assembly']\n\n\n\nclass Assembly(FromToData, FromToJson):\n    \"\"\"A data structure for discrete element assemblies.\n\n    An assembly is essentially a network of assembly elements.\n    Each element is represented by a node of the network.\n    Each interface or connection between elements is represented by an edge of the network.\n\n    Attributes\n    ----------\n    network : :class:`compas.Network`, optional\n    elements : list of :class:`Element`, optional\n        A list of assembly elements.\n    attributes : dict, optional\n        User-defined attributes of the assembly.\n        Built-in attributes are:\n        * name (str) : ``'Assembly'``\n    default_element_attribute : dict, optional\n        User-defined default attributes of the elements of the assembly.\n        The built-in attributes are:\n        * is_planned (bool) : ``False``\n        * is_placed (bool) : ``False``\n    default_connection_attributes : dict, optional\n        User-defined default attributes of the connections of the assembly.\n\n    Examples\n    --------\n    >>> assembly = Assembly()\n    >>> for i in range(2):\n    >>>     element = Element.from_box(Box(Frame.worldXY(), 10, 5, 2))\n    >>>     assembly.add_element(element)\n    \"\"\"\n\n    def __init__(self,\n                 elements=None,\n                 attributes=None,\n                 default_element_attributes=None,\n                 default_connection_attributes=None):\n\n        self.network = Network()\n        self.network.attributes.update({\n            'name' : 'Assembly'})\n\n        if attributes is not None:\n            self.network.attributes.update(attributes)\n\n        self.network.default_node_attributes.update({\n            'elem_type' : 1,\n            'is_planned': False,\n            'is_built' : False,\n            'placed_by' : 'human',\n            'is_support' : False,\n            'robot_name' : 'AA',\n            'is_held_by_robot' : False,\n            'robot_AA_base_frame' : False,\n            'robot_AB_base_frame' : False,\n            'frame_measured':False\n\n        })\n\n        if default_element_attributes is not None:\n            self.network.default_node_attributes.update(default_element_attributes)\n\n        if default_connection_attributes is not None:\n            self.network.default_edge_attributes.update(default_connection_attributes)\n\n        if elements:\n            for element in elements:\n                self.add_element(element)\n\n    @property\n    def name(self):\n        \"\"\"str : The name of the assembly.\"\"\"\n        return self.network.attributes.get('name', None)\n\n    @name.setter\n    def name(self, value):\n        self.network.attributes['name'] = value\n\n    def number_of_elements(self):\n        \"\"\"Compute the number of elements of the assembly.\n\n        Returns\n        -------\n        int\n            The number of elements.\n\n        \"\"\"\n        return self.network.number_of_nodes()\n\n    def number_of_connections(self):\n        \"\"\"Compute the number of connections of the assembly.\n\n        Returns\n        -------\n        int\n            the number of connections.\n\n        \"\"\"\n        return self.network.number_of_edges()\n\n    @property\n    def data(self):\n        \"\"\"Return a data dictionary of the assembly.\n        \"\"\"\n        # Network data does not recursively serialize to data...\n        d = self.network.data\n\n        # so we need to trigger that for elements stored in nodes\n        node = {}\n        for vkey, vdata in d['node'].items():\n            node[vkey] = {key: vdata[key] for key in vdata.keys() if key != 'element'}\n            node[vkey]['element'] = vdata['element'].to_data()\n\n            if 'frame_measured' in vdata:\n                if node[vkey]['frame_measured']:\n                    node[vkey]['frame_measured'] = node[vkey]['frame_measured'].to_data()\n\n            if 'robot_AA_base_frame' in vdata:\n                if node[vkey]['robot_AA_base_frame']:\n                    node[vkey]['robot_AA_base_frame'] = node[vkey]['robot_AA_base_frame'].to_data()\n\n            if 'robot_AB_base_frame' in vdata:\n                if node[vkey]['robot_AB_base_frame']:\n                    node[vkey]['robot_AB_base_frame'] = node[vkey]['robot_AB_base_frame'].to_data()\n\n        d['node'] = node\n\n        return d\n\n    @data.setter\n    def data(self, data):\n        # Deserialize elements from node dictionary\n        for _vkey, vdata in data['node'].items():\n            vdata['element'] = Element.from_data(vdata['element'])\n\n            if 'frame_measured' in vdata:\n                if vdata['frame_measured']:\n                    vdata['frame_measured'] = Frame.from_data(vdata['frame_measured']) #node[vkey]['frame_measured'].to_data()\n\n            if 'robot_AA_base_frame' in vdata:\n                if vdata['robot_AA_base_frame']:\n                    vdata['robot_AA_base_frame'] = Frame.from_data(vdata['robot_AA_base_frame']) #node[vkey]['frame_measured'].to_data()\n\n            if 'robot_AB_base_frame' in vdata:\n                if vdata['robot_AB_base_frame']:\n                    vdata['robot_AB_base_frame'] = Frame.from_data(vdata['robot_AB_base_frame']) #node[vkey]['frame_measured'].to_data()\n\n        self.network = Network.from_data(data)\n\n    def clear(self):\n        \"\"\"Clear all the assembly data.\"\"\"\n        self.network.clear()\n\n    def add_element(self, element, key=None, attr_dict={}, **kwattr):\n        \"\"\"Add an element to the assembly.\n\n        Parameters\n        ----------\n        element : Element\n            The element to add.\n        attr_dict : dict, optional\n            A dictionary of element attributes. Default is ``None``.\n\n        Returns\n        -------\n        hashable\n            The identifier of the element.\n        \"\"\"\n        attr_dict.update(kwattr)\n        x, y, z = element.frame.point\n        key = self.network.add_node(key=key, attr_dict=attr_dict,\n                                    x=x, y=y, z=z, element=element)\n        return key\n\n\n    def add_rf_unit_element(\n            self,\n            current_key,\n            flip='AA',\n            angle=0,\n            shift_value=0,\n            placed_by='human',\n            robot_name = 'AA',\n            robot_AA_base_frame = None,\n            robot_AB_base_frame = None,\n            on_ground=False,\n            unit_index=0,\n            frame_measured=None\n        ):\n        \"\"\"Add an element to the assembly.\n        \"\"\"\n        radius = self.globals['rod_radius']\n        length = self.globals['rod_length']\n        rf_unit_radius = self.globals['rf_unit_radius']\n        rf_unit_offset = self.globals['rf_unit_offset']\n\n        N = self.network.number_of_nodes()\n\n        current_elem = self.network.node[current_key]['element']\n\n        # Find the open connector of the current element\n        if current_elem.connector_1_state:\n            current_connector_frame = current_elem.connector_frame_1\n            c = -1\n        else:\n            current_connector_frame = current_elem.connector_frame_2\n            c = 1\n\n        if flip == 'AA':\n            a = b = 0\n        if flip == 'AB':\n            a = 0\n            b = 1*c\n        if flip == 'BA':\n            a = 1*c\n            b = 0\n        if flip == 'BB':\n            a = b = 1*c\n\n        new_elem = current_elem.copy()\n\n        if placed_by == 'robot':\n            R1 = Rotation.from_axis_and_angle(current_connector_frame.zaxis, math.radians(120), current_connector_frame.point)\n            T1 = Translation.from_vector(-new_elem.frame.xaxis*a*((length-rf_unit_radius+rf_unit_offset)/2.))\n        else:\n            R1 = Rotation.from_axis_and_angle(current_connector_frame.zaxis, math.radians(240), current_connector_frame.point)\n            T1 = Translation.from_vector(-new_elem.frame.xaxis*b*((length-rf_unit_radius+rf_unit_offset)/2.))\n\n        new_elem.transform(R1*T1)\n\n        # Define a desired rotation around the parent element\n        T_point = Translation.from_vector(current_elem.frame.xaxis)\n        new_point = current_elem.frame.point.transformed(T_point)\n        R2 = Rotation.from_axis_and_angle(current_elem.frame.xaxis, math.radians(angle), new_point)\n\n        # Define a desired shift value along the parent element\n        T3 = Translation.from_vector(current_elem.frame.xaxis*shift_value)\n\n        # Transform the new element\n        new_elem.transform(R2*T3)\n\n        self.add_element(new_elem,\n                         placed_by=placed_by,\n                         robot_name=robot_name,\n                         robot_AA_base_frame=robot_AA_base_frame,\n                         robot_AB_base_frame=robot_AB_base_frame,\n                         on_ground=on_ground,\n                         frame_measured=frame_measured,\n                         is_planned=True,\n                         is_built=False,\n                         is_support=False)\n\n        # Add adges\n        if unit_index == 0:\n            self.network.add_edge(current_key, N, edge_to='neighbour')\n        else:\n            self.network.add_edge(N-1, N, edge_to='parent')\n            self.network.add_edge(current_key, N, edge_to='parent')\n\n        self.update_connectors_states(current_key, flip, new_elem, unit_index)\n\n        if unit_index == 1:\n            if current_elem.connector_1_state:\n                current_elem.connector_1_state = False\n            else:\n                current_elem.connector_2_state = False\n\n        return new_elem\n\n    def add_connection(self, u, v, attr_dict=None, **kwattr):\n        \"\"\"Add a connection between two elements and specify its attributes.\n\n        Parameters\n        ----------\n        u : hashable\n            The identifier of the first element of the connection.\n        v : hashable\n            The identifier of the second element of the connection.\n        attr_dict : dict, optional\n            A dictionary of connection attributes.\n        kwattr\n            Other connection attributes as additional keyword arguments.\n\n        Returns\n        -------\n        tuple\n            The identifiers of the elements.\n        \"\"\"\n        return self.network.add_edge(u, v, attr_dict, **kwattr)\n\n    def add_joint(self, edge, joint):\n        \"\"\"\n        \"\"\"\n        u, v = edge\n        return self.add_edge(u, v, joint=joint)\n\n    def transform(self, transformation):\n        \"\"\"Transforms this assembly.\n\n        Parameters\n        ----------\n        transformation : :class:`Transformation`\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for _k, element in self.elements(data=False):\n            element.transform(transformation)\n\n    def transformed(self, transformation):\n        \"\"\"Returns a transformed copy of this assembly.\n\n        Parameters\n        ----------\n        transformation : :class:`Transformation`\n\n        Returns\n        -------\n        Assembly\n        \"\"\"\n        assembly = self.copy()\n        assembly.transform(transformation)\n        assembly.network.transform(transformation)\n        return assembly\n\n    def copy(self):\n        \"\"\"Returns a copy of this assembly.\n        \"\"\"\n        cls = type(self)\n        return cls.from_data(deepcopy(self.data))\n\n    def element(self, key, data=False):\n        \"\"\"Get an element by its key.\"\"\"\n        if data:\n            return self.network.node[key]['element'], self.network.node[key]\n        else:\n            return self.network.node[key]['element']\n\n    def elements(self, data=False):\n        \"\"\"Iterate over the elements of the assembly.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, yield both the identifier and the attributes.\n\n        Yields\n        ------\n        2-tuple\n            The next element as a (key, element) tuple, if ``data`` is ``False``.\n        3-tuple\n            The next element as a (key, element, attr) tuple, if ``data`` is ``True``.\n\n        \"\"\"\n        if data:\n            for vkey, vattr in self.network.nodes(True):\n                yield vkey, vattr['element'], vattr\n        else:\n            for vkey in self.network.nodes(data):\n                yield vkey, self.network.node[vkey]['element']\n\n    def connections(self, data=False):\n        \"\"\"Iterate over the connections of the network.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, yield both the identifier and the attributes.\n\n        Yields\n        ------\n        2-tuple\n            The next connection identifier (u, v), if ``data`` is ``False``.\n        3-tuple\n            The next connection as a (u, v, attr) tuple, if ``data`` is ``True``.\n\n        \"\"\"\n        return self.network.edges(data)\n\n    def shortest_distance_between_two_lines(self, line1, line2):\n\n        # l1 = line_to_compas(line1)\n        # l2 = line_to_compas(line2)\n\n        # d = distance_line_line(l1, l2)\n        # return d\n        a, b, d = gh.CurveProximity(line1, line2)\n        return d\n\n    def collision_check(self, current_key, option_elems, tolerance):\n        \"\"\"Check for collisions with previously built elements.\n        \"\"\"\n\n        collision = False\n        results = []\n        dist_list = []\n        for key, elem in self.elements():\n            if key != current_key:\n                line1 = Artist(elem.line).draw()\n                for option_elem in option_elems:\n                    line2 = Artist(option_elem.line).draw()\n                    #results.append(True if distance_line_line(elem.line, option_elem.line, tol = 0.001) < assembly.globals['rod_radius']*2. + tolerance else False)\n                    distance = self.shortest_distance_between_two_lines(line1, line2)\n                    results.append(True if distance < (self.globals['rod_radius'] * 2. + 0.015 + tolerance) else False)\n                    dist_list.append(distance)\n                collision = True if True in results else False\n                dist = min(dist_list)\n        return collision, dist\n\n    def check_ground_collision(self, option_elems):\n        \"\"\"Check if an element touches the ground.\n        \"\"\"\n\n        ground_plane = Plane.from_frame(Frame.worldXY())\n\n        for option in option_elems:\n            intersection = intersection_line_plane(option.line, ground_plane)\n            if intersection != None:\n                return intersection\n\n    def get_rot_angle(self, step, rot_axis, rot_point, elem_line1, elem_line2, rot_dir, epsilon):\n        \"\"\"\n        elem_line1: element to rotate\n        elem_line2: element to attach to\n        \"\"\"\n\n        rot_angle = 0\n        init_step = math.radians(step)\n        alpha = init_step\n\n        if rot_dir == 0:\n            alpha = -alpha\n\n        i = 0\n        max_i = 25\n\n        d = self.shortest_distance_between_two_lines(elem_line1, elem_line2)\n\n        while d < self.globals['rod_radius'] * 2.0 + 0.015:\n            i += 1\n\n            if i >= max_i:\n                break\n\n            rot_angle += alpha\n\n            # rotate the cylinder axis by alpha\n            R = rg.Transform.Rotation(alpha, rot_axis, rot_point)\n            elem_line1.Transform(R)\n\n            d = self.shortest_distance_between_two_lines(elem_line1, elem_line2)\n\n        i = 0\n        max_i= 50\n        d = self.shortest_distance_between_two_lines(elem_line1, elem_line2)\n\n        while abs(d - (self.globals['rod_radius'] * 2.0 + 0.015)) > epsilon:\n            i += 1\n\n            if i >= max_i:\n                break\n\n            # half the rotation step and ensure it is > 0\n            alpha = abs(0.5 * alpha)\n\n            if rot_dir == 0:\n                alpha = -alpha   # invert direction for counter clockwise rotation\n\n            # test distance\n            d = self.shortest_distance_between_two_lines(elem_line1, elem_line2)\n            if d > self.globals['rod_radius'] * 2.0 + 0.015:\n                alpha = -alpha   # distance too large --> rotate back\n            else:\n                alpha = alpha   # distance too small --> rotate in same direction\n\n            # rotate axis\n            R = rg.Transform.Rotation(alpha, rot_axis, rot_point)\n            elem_line1.Transform(R)\n\n            rot_angle += alpha\n\n        return math.degrees(rot_angle)\n\n    def add_third_element(self, elem, elem1, elem2, point1, point2, shift_value, epsilon):\n        \"\"\"\n        elem1: open connector\n        elem2: option elem\n        \"\"\"\n\n        elem1_line_rg = line_to_rhino_curve(elem1.line)\n        elem2_line_rg = line_to_rhino_curve(elem2.line)\n\n        param1 = elem2_line_rg.NormalizedLengthParameter(point1)\n        param2 = elem1_line_rg.NormalizedLengthParameter(point2)\n\n        start_point = elem1_line_rg.PointAt(param1[1])\n        end_point = elem2_line_rg.PointAt(param2[1])\n\n        elem_x_vector = rg.Vector3d(end_point - start_point)\n        elem_y_vector = elem_x_vector.Clone()\n        elem_y_vector.Rotate(math.radians(90), rg.Vector3d.XAxis)\n\n        elem_frame = Frame(point_to_compas(start_point), Vector(elem_x_vector.X, elem_x_vector.Y, elem_x_vector.Z), Vector(elem_y_vector.X, elem_y_vector.Y, elem_y_vector.Z))\n\n        T1 = Transformation.from_frame_to_frame(Frame.worldXY(), elem_frame)\n        new_elem = elem.transformed(T1)\n        T2 = Translation.from_vector(elem_frame.xaxis * shift_value)\n        new_elem.transform(T2)\n\n        rot_dir1 = 0\n        rot_dir2 = 1\n        step1 = 0.3\n        step2 = 0.3\n\n        rot_axis1 = rg.Vector3d(elem2_line_rg.PointAtStart- elem2_line_rg.PointAtEnd)\n        rot_axis2 = rg.Vector3d(elem1_line_rg.PointAtStart - elem1_line_rg.PointAtEnd)\n        rot_point1 = point_to_rhino(elem2.frame.point)\n        rot_point2 = point_to_rhino(elem1.frame.point)\n        new_elem_line = line_to_rhino_curve(new_elem.line)\n\n        tol_angle1 = self.get_rot_angle(step1, rot_axis1, rot_point1, new_elem_line, elem1_line_rg, rot_dir1, epsilon)\n        tol_angle2 = self.get_rot_angle(step2, rot_axis2, rot_point2, new_elem_line, elem2_line_rg, rot_dir2, epsilon)\n\n        R1 = Rotation.from_axis_and_angle(elem2.frame.xaxis, math.radians(tol_angle1), elem2.frame.point)\n        R2 = Rotation.from_axis_and_angle(elem1.frame.xaxis, math.radians(tol_angle2), elem1.frame.point)\n        new_elem.transform(R1)\n        new_elem.transform(R2)\n\n        return new_elem\n\n    def calculate_global_equilibrium(self, support, option_elems, radius, allow_temp_support=True):\n        \"\"\"Check if the structure is in equilibrium.\n        \"\"\"\n        static_equilibrium = []\n        supports = []\n        vol = []\n        cen = []\n\n        if allow_temp_support == True:\n            s_glob = True\n\n        e = [element.line for key, element in self.elements()]\n        e += [elem_option.line for elem_option in option_elems]\n\n        supports.append(support)\n        supports.extend(e)\n        e = supports\n\n        for i, element in enumerate(e):\n            if i == 0:\n                #print element\n                voll = rs.SurfaceVolume(element)[0] # volume Vector of base; Material weight is considered as constant; Input as Brep\n                cenl = rs.SurfaceVolumeCentroid(element)[0] # center node\n                cenl = (cenl[0], cenl[1], 0) # planar Center-nodes\n            else:\n                voll = element.length *  math.pi * radius**2 # volume Vector for Rods; Material weight is considered as constant; Input as Line\n                cenl = (element.midpoint.x, element.midpoint.y, element.midpoint.z) # center nodes\n                cenl = (cenl[0], cenl[1], 0) # planar Center-nodes\n            vol.append(voll)\n            cen.append(cenl)\n\n\n        # Global Equlibrium\n        res_pos_x = 0\n        res_pos_y = 0\n\n        for i in range(len(e)):\n            m_x = cen[i][0] * vol[i]\n            m_y = cen[i][1] * vol[i]\n\n            res_pos_x += m_x\n            res_pos_y += m_y\n\n            res_pos_x_loc = res_pos_x / sum(vol[:(i+1)]) #moment in x-dir\n            res_pos_y_loc = res_pos_y / sum(vol[:(i+1)]) #moment in y-dir\n\n            res_loc = rs.AddLine((res_pos_x_loc, res_pos_y_loc, 0), (res_pos_x_loc, res_pos_y_loc, sum(vol[:(i+1)]))) #Resultant\n            se_loc = rg.Brep.IsPointInside(supports[0], rg.Point3d(res_pos_x_loc, res_pos_y_loc, 0), 0.001, False)\n\n            if s_glob == True and allow_temp_support == False:\n                if i > s_int+1:\n                    allow_temp_support = True\n\n            if se_loc == True: # Structure is in Equilibrium\n                static_equilibrium = True\n                msg = \"Structure is in Equilibrium.\"\n\n            if se_loc == False and allow_temp_support == False: # Structure is NOT in Equilibrium\n                static_equilibrium = False\n                msg = \"Structure is NOT in Equilibrium.\"\n\n            if se_loc == False and allow_temp_support == True: # Structure is only in Equilibrium if Robot holds the last Element\n                static_equilibrium = True\n                allow_temp_support = False\n                s_int = i\n                msg = \"Structure is only in Equilibrium if Robot holds the last Element.\"\n\n            res = res_loc\n\n    #        if static_equilibrium == False:\n    #            break\n    #        else:\n    #            continue\n\n    #    if res == False:\n    #        res = None\n\n        return static_equilibrium, res, msg\n\n    def calculate_local_equilibrium_in_a_branch(self, cp, sp, l, r):\n        \"\"\"\n        Calculates the local static Equilibrium condition.\n\n        Parameters\n        ----------\n        cp : point\n            The mid points of the elements.\n\n        Returns\n        -------\n        la: float\n            The lever arm of the branch [m].\n        rp: point\n            The position of the resultant z-vector [point].\n\n        \"\"\"\n\n        if cp and sp:\n            # Variables:\n            # cp = Center Points of the individual elements of one branch\n            # sp = Planar Supports of the branch\n            # l = #Length of the Rods [m]\n            # r = #Radius of the Pipe Elements\n\n\n            # Step 1: Calculate single Resultants\n            vol = l * math.pi * r**2 #Volume Vector for Rods; Material weight is considered as constant\n            cp0 = [(p[0], p[1], 0) for p in cp] #Planar Center Points of the Resultant\n            sp = [(p[0], p[1], 0) for p in sp] #Make Supports planar\n\n\n            # Step 2: Calculate the Resultant for each element\n            res_pos_x = 0\n            res_pos_y = 0\n\n            for i, cp0l in enumerate(cp0):\n                m_x = cp0l[0] * vol\n                m_y = cp0l[1] * vol\n\n                res_pos_x += m_x # Local Moment in x-dir\n                res_pos_y += m_y # Local Moment in y-dir\n\n                res_pos_x_loc = res_pos_x / (vol*(i+1)) # Position of Resultant in x-dir\n                res_pos_y_loc = res_pos_y / (vol*(i+1)) # Position of Resultant in y-dir\n\n                rp = rs.AddPoint(res_pos_x_loc, res_pos_y_loc, 0)\n\n                # Lever Arm for a single support\n                if len(sp) == 1:\n                    la = rs.Distance(rp, sp)\n\n                # Lever Arm for two supports\n                if len(sp) == 2:\n                    l = rs.AddLine(sp[0], sp[1])\n                    la = rs.Distance(rs.EvaluateCurve(l, rs.CurveClosestPoint(l, rp)), rp)\n\n                # Lever Arm for multiple supports\n                if len(sp) > 2:\n                    sp.append(sp[0])\n                    l = rs.AddPolyline(sp)\n\n                    check = rs.PointInPlanarClosedCurve(rp, l)\n                    if check == 1 or check == 2: la = 0\n                    if check == 0: la = rs.Distance(rs.EvaluateCurve(l, rs.CurveClosestPoint(l, rp)), rp)\n\n        else:\n            la = 'No Input'\n            rp = 'No Input'\n\n        return([la, rp])\n\n    def calculate_local_equilibrium_in_all_branches(self, current_key, elem_options):\n\n        # Identify the connected elements (branches) in the assembly.\n        branches = connected_components(self.network.adjacency)\n\n        stability_feedback = []\n        lever_arm_branches = []\n        resultant_branches = []\n\n        for i, branch in enumerate(branches):\n\n            # The mid points of the elements in one branch\n            cp = [Artist(self.element(bkey).line.midpoint).draw() for bkey in branch]\n\n            # Add option to branch\n            if current_key in branch:\n                cp += [Artist(elem_options.line.midpoint).draw() for elem_options in elem_options]\n            sp = [Artist(self.element(branch[0]).line.end).draw()]\n\n            # calculate local equilibrium (level arm) and the resultant point of the selected option elements\n            lever_arm, resultant_point = self.calculate_local_equilibrium_in_a_branch(cp, sp, self.globals['rod_length'], self.globals['rod_radius'])\n\n            resultant_point = rs.coerce3dpoint(resultant_point)\n            resultant_line = rg.Line(resultant_point, rg.Vector3d.ZAxis, 0.1)\n\n            lever_arm_branches.append(lever_arm[0])\n            resultant_branches.append(resultant_line)\n\n        return lever_arm_branches, resultant_branches\n\n    def close_rf_unit(self,\n                      current_key,\n                      flip,\n                      angle,\n                      shift_value,\n                      robot_name='AA',\n                      robot_AA_base_frame=None,\n                      robot_AB_base_frame=None,\n                      on_ground=False,\n                      frame_measured=None):\n        \"\"\"Add a module to the assembly.\n        \"\"\"\n\n        keys_robot = []\n\n        for i in range(2):\n            if i == 0:\n                placed_by = 'robot'\n                #frame_id = None\n                my_new_elem = self.add_rf_unit_element(current_key,\n                                                       flip=flip,\n                                                       angle=angle,\n                                                       shift_value=shift_value,\n                                                       placed_by=placed_by,\n                                                       robot_name='AA',\n                                                       robot_AA_base_frame=robot_AA_base_frame,\n                                                       robot_AB_base_frame=robot_AB_base_frame,\n                                                       on_ground=False,\n                                                       unit_index=i,\n                                                       frame_measured=None)\n                keys_robot += list(self.network.nodes_where({'element': my_new_elem}))\n            else:\n                placed_by = 'human'\n                #frame_id = added_frame_id\n                my_new_elem = self.add_rf_unit_element(current_key,\n                                                       flip=flip,\n                                                       angle=angle,\n                                                       shift_value=shift_value,\n                                                       placed_by=placed_by,\n                                                       robot_name='AA',\n                                                       robot_AA_base_frame=robot_AA_base_frame,\n                                                       robot_AB_base_frame=robot_AB_base_frame,\n                                                       on_ground=False,\n                                                       unit_index=i,\n                                                       frame_measured=None)\n                keys_human = list((self.network.nodes_where({'element': my_new_elem})))\n\n        keys_dict = {'keys_human': keys_human, 'keys_robot':keys_robot}\n\n        return keys_dict\n\n    def join_branches(self,\n                      keys_pair,\n                      flip,\n                      angle,\n                      shift_value,\n                      new_elem,\n                      robot_name = 'AA',\n                      robot_AA_base_frame = None,\n                      robot_AB_base_frame = None,\n                      on_ground=False,\n                      frame_measured=None):\n        \"\"\"Join to branches by adding three elements.\n        \"\"\"\n\n        keys_robot = []\n\n        for i in range(3):\n            if i == 0:\n                placed_by = 'robot'\n                #frame_id = None\n                my_new_elem = self.add_rf_unit_element(keys_pair[0],\n                                                       flip=flip,\n                                                       angle=angle,\n                                                       shift_value=shift_value,\n                                                       placed_by=placed_by,\n                                                       robot_name=robot_name,\n                                                       robot_AA_base_frame=robot_AA_base_frame,\n                                                       robot_AB_base_frame=robot_AB_base_frame,\n                                                       on_ground=False,\n                                                       unit_index=i,\n                                                       frame_measured=None)\n                keys_robot += list(self.network.nodes_where({'element': my_new_elem}))\n            if i == 1:\n                placed_by = 'human'\n                #frame_id = None\n                my_new_elem = self.add_rf_unit_element(keys_pair[0],\n                                                       flip=flip,\n                                                       angle=angle,\n                                                       shift_value=shift_value,\n                                                       placed_by=placed_by,\n                                                       robot_name=robot_name,\n                                                       robot_AA_base_frame=robot_AA_base_frame,\n                                                       robot_AB_base_frame=robot_AB_base_frame,\n                                                       on_ground=False,\n                                                       unit_index=i,\n                                                       frame_measured=None)\n                keys_human = list((self.network.nodes_where({'element': my_new_elem})))\n            if i == 2:\n                placed_by = 'human'\n                #frame_id = None\n                my_new_elem = self.add_element(new_elem,\n                                               placed_by=placed_by,\n                                               robot_name=robot_name,\n                                               robot_AA_base_frame=robot_AA_base_frame,\n                                               robot_AB_base_frame=robot_AB_base_frame,\n                                               on_ground=False,\n                                               unit_index=2,\n                                               frame_measured=None)\n                keys_human = list((self.network.nodes_where({'element': my_new_elem})))\n\n        N = self.network.number_of_nodes()\n\n        d1 = distance_point_point(new_elem.line.end, self.element(keys_pair[1]).frame.point)\n        d2 = distance_point_point(new_elem.line.start, self.element(keys_pair[1]).frame.point)\n\n        if d1 < d2:\n            self.element(N-1).connector_1_state = False\n        else:\n            self.element(N-1).connector_2_state = False\n\n        self.element(N-2).connector_1_state = False\n        self.element(N-2).connector_2_state = False\n        self.element(keys_pair[1]).connector_1_state = False\n        self.element(keys_pair[1]).connector_2_state = False\n\n        self.network.add_edge(N-2, N-1, edge_to='neighbour')\n        self.network.add_edge(N-2, keys_pair[1], edge_to='neighbour')\n        self.network.add_edge(N-1, keys_pair[1], edge_to='neighbour')\n\n        keys_dict = {'keys_human': keys_human, 'keys_robot':keys_robot}\n\n        return keys_dict, d1,d2\n\n    def parent_key(self, point, within_dist):\n        \"\"\"Return the parent key of a tracked object.\n        \"\"\"\n        parent_key = None\n\n        for key, element in self.elements():\n            connectors = element.connectors(state='open')\n            for connector in connectors:\n                dist = distance_point_point(point, connector.point)\n                if dist < within_dist:\n                    parent_key = key\n\n        return parent_key\n\n\n    def update_connectors_states(self, current_key, flip, my_new_elem, unit_index):\n\n\n        key_index = self.network.key_index()\n        current_elem = self.network.node[current_key]['element']\n        keys = [key_index[key] for key in self.network.nodes()]\n        previous_elem = self.network.node[keys[-2]]['element']\n\n        if unit_index == 1:\n            if current_elem.connector_2_state:\n                if flip == 'AA':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'AB':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'BA':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'BB':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_1_state = False\n            if current_elem.connector_1_state:\n                if flip == 'AA':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'AB':\n                    previous_elem.connector_1_state = False\n                    my_new_elem.connector_2_state = False\n                if flip == 'BA':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_1_state = False\n                if flip == 'BB':\n                    previous_elem.connector_2_state = False\n                    my_new_elem.connector_2_state = False\n\n\n    def keys_within_radius(self, current_key):\n\n        for key, element in self.elements(data=True):\n            pass\n\n    def keys_within_radius_xy(self, current_key):\n        pass\n\n    def keys_within_radius_domain(self, current_key):\n        pass\n\n    def range_filter(self, base_frame):\n        \"\"\"Disable connectors outside of a given range, e.g. robot reach.\n        \"\"\"\n        ur_range_max = 1.3\n        ur_range_min = 0.75\n\n        for key, element in self.elements():\n            if element.connector_1_state == True:\n                distance = distance_point_point(element.connector_frame_1.point, base_frame.point)\n                if not ur_range_min <= distance <= ur_range_max:\n                    element.connector_1_state = False\n            elif element.connector_2_state == True:\n                distance = distance_point_point(element.connector_frame_2.point, base_frame.point)\n                if not ur_range_min <= distance <= ur_range_max:\n                    element.connector_2_state = False\n            else:\n                pass\n\n    def distance_to_target_geo(self, key, angle, input_geo):\n\n        open_connector_frame = self.element(key).connectors(state='open')[0]\n        elem_frame = self.element(key).frame\n\n        R = Rotation.from_axis_and_angle(elem_frame.xaxis, math.radians(angle), elem_frame.point)\n\n        open_connector_frame_copy = open_connector_frame.transformed(R)\n        open_connector_plane = Artist(open_connector_frame_copy).draw()\n\n        closest_point = input_geo.ClosestPoint(open_connector_plane.Origin)\n        distance = closest_point.DistanceTo(open_connector_plane.Origin)\n\n        vector = rg.Vector3d(closest_point) - rg.Vector3d(open_connector_plane.Origin)\n\n        return distance, vector\n\n    def orientation_to_target_geo(self, key, angle, input_geo):\n\n        open_connector_frame = self.element(key).connectors(state='open')[0]\n        elem_frame = self.element(key).frame\n\n        R = Rotation.from_axis_and_angle(elem_frame.xaxis, math.radians(angle), elem_frame.point)\n\n        open_connector_frame_copy = open_connector_frame.transformed(R)\n        open_connector_plane = Artist(open_connector_frame_copy).draw()\n\n        closest_point = input_geo.ClosestPoint(open_connector_plane.Origin)\n\n        vector = Vector(closest_point.X, closest_point.Y, closest_point.Z) - open_connector_frame_copy.point\n\n        #angle = 180 - math.degrees(conn_frame_copy.zaxis.angle(vector))\n        v1 = open_connector_frame_copy.zaxis\n        v1.unitize()\n        vector.unitize()\n        dot_product = v1.dot(vector)\n\n        return abs(dot_product)*100, vector\n\n    def all_options_elements(self, flip, angle):\n        \"\"\"Returns a list of elements.\n        \"\"\"\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).current_option_elements(self, flip, angle) for key in keys]\n\n\n    def all_options_vectors(self, len):\n        \"\"\"Returns a list of vectors.\n        \"\"\"\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).current_option_vectors(len) for key in keys]\n\n    def all_options_viz(self, rf_unit_radius):\n        \"\"\"Returns a list of frames.\n        \"\"\"\n        keys = [key for key, element in self.elements()]\n        return [self.element(key).current_option_viz(rf_unit_radius) for key in keys]\n\n\n    def connectors(self, state='all'):\n        \"\"\" Iterate over the connectors of the assembly elements.\n\n        Parameters\n        ----------\n        state : string\n            A string indentifying the connectors' state.\n\n            If 'all', yeild all connectors.\n            If 'open' : yeild all open connectors.\n            If 'closed' : yeild all closed connectors.\n\n        Yields\n        ------\n        2-tuple\n            The connectors as a (key, frame) tuple.\n\n        \"\"\"\n        for key, element in self.elements():\n            if self.element(key).connectors(state):\n                yield key, element.connectors(state)\n\n        # keys = [key for key, element in self.elements()]\n        # return [(key, self.element(key).connectors(state)) for key in keys]\n\n    def connectors_ranges(self, state='all'):\n        \"\"\" Iterate over the connectors of the assembly elements.\n\n        Parameters\n        ----------\n        state : string\n            A string indentifying the connectors' state.\n\n            If 'all', yeild all connectors_ranges.\n            If 'open' : yeild all open connectors_ranges.\n            If 'closed' : yeild all closed connectors_ranges.\n\n        Yieldsframe\n        ------\n        2-tuple\n            The connectors as a (key, cone) tuple.\n\n        \"\"\"\n        for key, element in self.elements():\n            yield key, element.connectors_ranges(state)\n\n        # keys = [key for key, element in self.elements()]\n        # return [(key, self.element(key).connectors(state)) for key in keys]\n\n\n    def export_building_plan(self):\n        \"\"\"\n        exports the building plan by using the following protocol:\n\n        the first lines are the description of the global markers (fixed in the world frame):\n        type [string], element pose [6]\n        = \"GM\", x, y, z, qw, qx, qy, qz\n\n        the next lines contain the wall information:\n        type [string], element pose [6], string_message [string]\n        = type, x, y, z, qw, qx, qy, qz, string_message\n        \"\"\"\n\n        print(\"exporting\")\n        building_plan = []\n\n        for key, element, data in self.elements(data=True):\n            line = []\n\n            t = element._type\n            line.append(t) #type\n            line += element.get_pose_quaternion() #element pose\n            string_message = \"This is the element with the key index %i\" %key\n            line.append(string_message)\n            building_plan.append(line)\n\n        print(building_plan)\n        exporter = Exporter()\n        exporter.delete_file()\n        exporter.export_building_plan(building_plan)\n\n    def export_to_json_for_xr(self, path, is_built=False):\n\n        self.network.update_default_node_attributes({\"is_built\":False,\"idx_v\":None,\"custom_attr_1\":None,\"custom_attr_2\":None,\"custom_attr_3\":None})\n\n        for key, element in self.elements():\n            idx_v = self.network.node_attribute(key, \"course\")\n            self.network.node_attribute(key, \"idx_v\", idx_v)\n            self.network.node_attribute(key, \"is_built\", is_built)\n\n        self.to_json(path)\n\n    def export_to_json_incon(self, path, qr_code, starting_geometry=True, is_built=True, pretty=True):\n        buildingplan = {\"id\":\"iaac_plan\",'name':\"iaac_plan\", \"description\":\"iaac_plan\", \"building_steps\":[]}\n        building_steps = []\n        len = 0\n\n        if starting_geometry:\n            element_to_INCON(\"starting element\", len, None, building_steps, True, \"starting_material.obj\")\n            len += 1\n\n        for key, element, data in self.elements(data=True):\n            element_to_INCON(\"dynamic_cylinder\", key, element, building_steps, True, \"cylinder_for_iaac_workshop.obj\")\n\n        placeholder = {\"type\":\"object\",'object_type':\"cylinder_for_iaac_workshop_1m.obj\", \"id\": \"dynamic_cylinder\", \"is_tag\": False, \"is_already_built\": False, \"color_rgb\": [1.0, 0.0, 0.0],\"instances\": 200,\"build_instructions\" : []}\n        building_steps.append(placeholder)\n\n        for key, tag in enumerate(qr_code):\n            tag_to_INCON(key, tag, building_steps)\n\n        buildingplan['building_steps'] = building_steps\n        compas.json_dump(buildingplan, path, pretty)\n\n\n    def assembly_to_json(self, path, pretty):\n\n        building_plan = {\"node\":{}}\n\n        for key, element, data in self.elements(data=True):\n            elem_dict = {}\n            elem_dict[\"element\"] = {\"frame\" : self.element(key).frame.to_data()}\n\n            elem_dict[\"is_planned\"] = data[\"is_planned\"],\n            elem_dict[\"is_built\"] = data['is_built'],\n            elem_dict[\"placed_by\"] = data[\"placed_by\"],\n            elem_dict[\"is_support\"] = data[\"is_support\"],\n            elem_dict[\"is_held_by_robot\"] = data[\"is_held_by_robot\"],\n            elem_dict[\"robot_frame\"] = data[\"robot_frame\"],\n            elem_dict[\"frame_measured\"] = data[\"frame_measured\"]\n\n            building_plan[\"node\"][str(key)] = elem_dict\n\n        compas.json_dump(building_plan, path, pretty)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}