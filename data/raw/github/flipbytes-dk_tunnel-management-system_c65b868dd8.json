{
  "source_url": "https://github.com/flipbytes-dk/tunnel-management-system/blob/1f00beb3d17ed61a3a2146f1cba560d86c88a2d1/utils/AllExToGlb.py",
  "repo": "flipbytes-dk/tunnel-management-system",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "utils/AllExToGlb.py",
  "instruction": "AllExToGlb - Universal 3D Model to Web-Ready GLB Pipeline\n==========================================================\nConverts 3D files from 20+ formats into a single Draco-compressed .glb...",
  "code": "#!/usr/bin/env python3\n\"\"\"\nAllExToGlb - Universal 3D Model to Web-Ready GLB Pipeline\n==========================================================\nConverts 3D files from 20+ formats into a single Draco-compressed .glb file\nsuitable for viewing in Three.js.\n\nBackends (auto-detected):\n    pip install trimesh numpy .............. OBJ, STL, PLY, OFF, 3MF, DAE\n    pip install cascadio ................... STEP/STP, IGES/IGS (CAD)\n    pip install ifcopenshell ............... IFC (BIM)\n    pip install rhino3dm ................... 3DM (Rhino)\n    npm install -g fbx2gltf ............... FBX\n    Blender (free, on PATH) ............... BLEND, 3DS, X3D, DXF, ABC, USD, SKP\n    npm install -g @gltf-transform/cli .... Merge + Draco compression\n\nUsage:\n    python AllExToGlb.py <folder_or_file> [--output out.glb] [--scale 0.1] [--serve]\n    python AllExToGlb.py --check              Show available backends\n    python AllExToGlb.py --formats            Show all supported formats\n\nExamples:\n    python AllExToGlb.py ./models\n    python AllExToGlb.py model.step --output part.glb --serve\n    python AllExToGlb.py ./mixed_files --scale 0.001 --output building.glb\n\"\"\"\n\nimport argparse\nimport glob as globmod\nimport http.server\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport webbrowser\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  FORMAT REGISTRY\n# ══════════════════════════════════════════════════════════════════════════════\n\nFORMAT_REGISTRY = {\n    # ── Tier 1: trimesh (pip install trimesh numpy) ──────────────────────────\n    \".obj\":  {\"converter\": \"trimesh\",       \"name\": \"Wavefront OBJ\"},\n    \".stl\":  {\"converter\": \"trimesh\",       \"name\": \"STL Mesh\"},\n    \".ply\":  {\"converter\": \"trimesh\",       \"name\": \"Stanford PLY\"},\n    \".off\":  {\"converter\": \"trimesh\",       \"name\": \"OFF Mesh\"},\n    \".3mf\":  {\"converter\": \"trimesh\",       \"name\": \"3D Manufacturing\"},\n    \".dae\":  {\"converter\": \"trimesh\",       \"name\": \"COLLADA\"},\n    \".gltf\": {\"converter\": \"copy\",          \"name\": \"glTF (already target)\"},\n    \".glb\":  {\"converter\": \"copy\",          \"name\": \"GLB (already target)\"},\n\n    # ── Tier 2: CAD / BIM (Python packages) ──────────────────────────────────\n    \".step\": {\"converter\": \"cascadio\",      \"name\": \"STEP CAD\"},\n    \".stp\":  {\"converter\": \"cascadio\",      \"name\": \"STEP CAD\"},\n    \".iges\": {\"converter\": \"cascadio\",      \"name\": \"IGES CAD\"},\n    \".igs\":  {\"converter\": \"cascadio\",      \"name\": \"IGES CAD\"},\n    \".ifc\":  {\"converter\": \"ifcopenshell\",  \"name\": \"IFC BIM\"},\n    \".3dm\":  {\"converter\": \"rhino3dm\",      \"name\": \"Rhino 3DM\"},\n\n    # ── Tier 3: CLI tools ────────────────────────────────────────────────────\n    \".fbx\":  {\"converter\": \"fbx2gltf\",      \"name\": \"Autodesk FBX\"},\n    \".blend\": {\"converter\": \"blender\",      \"name\": \"Blender Native\"},\n    \".3ds\":  {\"converter\": \"blender\",       \"name\": \"3D Studio\"},\n    \".x3d\":  {\"converter\": \"blender\",       \"name\": \"X3D\"},\n    \".wrl\":  {\"converter\": \"blender\",       \"name\": \"VRML\"},\n    \".abc\":  {\"converter\": \"blender\",       \"name\": \"Alembic\"},\n    \".usd\":  {\"converter\": \"blender\",       \"name\": \"USD\"},\n    \".usdc\": {\"converter\": \"blender\",       \"name\": \"USD Crate\"},\n    \".usda\": {\"converter\": \"blender\",       \"name\": \"USD ASCII\"},\n    \".dxf\":  {\"converter\": \"blender\",       \"name\": \"AutoCAD DXF\"},\n    \".skp\":  {\"converter\": \"blender\",       \"name\": \"SketchUp (add-on)\"},\n\n    # ── Proprietary (need original software to export first) ─────────────────\n    \".max\":        {\"converter\": \"proprietary\", \"name\": \"3ds Max\"},\n    \".ma\":         {\"converter\": \"proprietary\", \"name\": \"Maya ASCII\"},\n    \".mb\":         {\"converter\": \"proprietary\", \"name\": \"Maya Binary\"},\n    \".rvt\":        {\"converter\": \"proprietary\", \"name\": \"Revit Project\"},\n    \".rfa\":        {\"converter\": \"proprietary\", \"name\": \"Revit Family\"},\n    \".rte\":        {\"converter\": \"proprietary\", \"name\": \"Revit Template\"},\n    \".rft\":        {\"converter\": \"proprietary\", \"name\": \"Revit Family Template\"},\n    \".nwd\":        {\"converter\": \"proprietary\", \"name\": \"Navisworks\"},\n    \".nwf\":        {\"converter\": \"proprietary\", \"name\": \"Navisworks Federated\"},\n    \".ipt\":        {\"converter\": \"proprietary\", \"name\": \"Inventor Part\"},\n    \".iam\":        {\"converter\": \"proprietary\", \"name\": \"Inventor Assembly\"},\n    \".idw\":        {\"converter\": \"proprietary\", \"name\": \"Inventor Drawing\"},\n    \".f3d\":        {\"converter\": \"proprietary\", \"name\": \"Fusion 360\"},\n    \".f3z\":        {\"converter\": \"proprietary\", \"name\": \"Fusion 360 Archive\"},\n    \".dwg\":        {\"converter\": \"proprietary\", \"name\": \"AutoCAD DWG\"},\n    \".catpart\":    {\"converter\": \"proprietary\", \"name\": \"CATIA Part\"},\n    \".catproduct\": {\"converter\": \"proprietary\", \"name\": \"CATIA Assembly\"},\n    \".prt\":        {\"converter\": \"proprietary\", \"name\": \"NX / Creo Part\"},\n    \".c4d\":        {\"converter\": \"proprietary\", \"name\": \"Cinema 4D\"},\n    \".pln\":        {\"converter\": \"proprietary\", \"name\": \"ArchiCAD\"},\n    \".mud\":        {\"converter\": \"proprietary\", \"name\": \"Mudbox\"},\n    \".wire\":       {\"converter\": \"proprietary\", \"name\": \"Alias\"},\n    \".vpb\":        {\"converter\": \"proprietary\", \"name\": \"VRED\"},\n}\n\n# When primary converter isn't available, try these in order\nFALLBACK_MAP = {\n    \"trimesh\":      [\"blender\"],\n    \"cascadio\":     [\"trimesh\", \"blender\"],\n    \"ifcopenshell\": [\"blender\"],\n    \"rhino3dm\":     [\"blender\"],\n    \"fbx2gltf\":     [\"blender\"],\n}\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  BACKEND DETECTION\n# ══════════════════════════════════════════════════════════════════════════════\n\n_backend_cache = {}\n\n\ndef _check_python_module(name):\n    \"\"\"Check if a Python module is importable.\"\"\"\n    if name not in _backend_cache:\n        try:\n            __import__(name)\n            _backend_cache[name] = True\n        except ImportError:\n            _backend_cache[name] = False\n    return _backend_cache[name]\n\n\ndef find_fbx2gltf():\n    \"\"\"Locate FBX2glTF executable.\"\"\"\n    result = shutil.which(\"FBX2glTF\") or shutil.which(\"FBX2glTF.exe\")\n    if result:\n        return result\n    # npm global install location on Windows\n    appdata = os.environ.get(\"APPDATA\", \"\")\n    npm_path = os.path.join(appdata, \"npm\", \"node_modules\", \"fbx2gltf\", \"bin\", \"Windows_NT\", \"FBX2glTF.exe\")\n    if os.path.isfile(npm_path):\n        return npm_path\n    return None\n\n\ndef find_blender():\n    \"\"\"Locate Blender executable.\"\"\"\n    result = shutil.which(\"blender\")\n    if result:\n        return result\n    # Common Windows install paths\n    candidates = globmod.glob(r\"C:\\Program Files\\Blender Foundation\\Blender *\\blender.exe\")\n    if candidates:\n        return sorted(candidates)[-1]  # latest version\n    return None\n\n\ndef find_npx():\n    \"\"\"Locate npx executable.\"\"\"\n    return shutil.which(\"npx\")\n\n\ndef detect_backends():\n    \"\"\"Detect all available converter backends. Returns dict of backend -> path/bool.\"\"\"\n    return {\n        \"trimesh\":      _check_python_module(\"trimesh\"),\n        \"numpy\":        _check_python_module(\"numpy\"),\n        \"cascadio\":     _check_python_module(\"cascadio\"),\n        \"ifcopenshell\": _check_python_module(\"ifcopenshell\"),\n        \"rhino3dm\":     _check_python_module(\"rhino3dm\"),\n        \"fbx2gltf\":     find_fbx2gltf(),\n        \"blender\":      find_blender(),\n        \"npx\":          find_npx(),\n    }\n\n\ndef print_backend_status(backends):\n    \"\"\"Print a table of backend availability.\"\"\"\n    print(\"\\n  Backend Availability:\")\n    print(\"  \" + \"-\" * 60)\n\n    checks = [\n        (\"trimesh\",      \"trimesh\",      \"pip install trimesh numpy\",      \"OBJ STL PLY OFF 3MF DAE\"),\n        (\"cascadio\",     \"cascadio\",     \"pip install cascadio\",           \"STEP STP IGES IGS\"),\n        (\"ifcopenshell\", \"ifcopenshell\", \"pip install ifcopenshell\",       \"IFC\"),\n        (\"rhino3dm\",     \"rhino3dm\",     \"pip install rhino3dm\",           \"3DM\"),\n        (\"FBX2glTF\",     \"fbx2gltf\",     \"npm install -g fbx2gltf\",       \"FBX\"),\n        (\"Blender\",      \"blender\",      \"https://blender.org (free)\",     \"BLEND 3DS X3D DXF ABC USD SKP\"),\n        (\"gltf-transform\", \"npx\",        \"npm install -g @gltf-transform/cli\", \"Merge + Draco\"),\n    ]\n\n    for label, key, install, formats in checks:\n        val = backends.get(key)\n        if val and val is not True:\n            status = f\"FOUND  ({val})\"\n        elif val:\n            status = \"FOUND\"\n        else:\n            status = f\"MISSING  ->  {install}\"\n        tag = \"+\" if val else \"-\"\n        print(f\"  {tag} {label:<18} {status}\")\n        print(f\"    {'Formats:':<18} {formats}\")\n\n    print(\"  \" + \"-\" * 60)\n\n\ndef print_supported_formats(backends):\n    \"\"\"Print all formats grouped by availability.\"\"\"\n    convertible = []\n    fallback_available = []\n    not_available = []\n    proprietary = []\n\n    for ext, info in sorted(FORMAT_REGISTRY.items()):\n        conv = info[\"converter\"]\n        name = info[\"name\"]\n\n        if conv == \"proprietary\":\n            proprietary.append((ext, name))\n        elif conv == \"copy\":\n            convertible.append((ext, name, \"copy\"))\n        elif _is_backend_available(conv, backends):\n            convertible.append((ext, name, conv))\n        elif _find_fallback(conv, backends):\n            fb = _find_fallback(conv, backends)\n            fallback_available.append((ext, name, conv, fb))\n        else:\n            not_available.append((ext, name, conv))\n\n    print(\"\\n  SUPPORTED FORMATS (converter available):\")\n    for ext, name, conv in convertible:\n        print(f\"    {ext:<14} {name:<28} [{conv}]\")\n\n    if fallback_available:\n        print(\"\\n  SUPPORTED VIA FALLBACK (primary missing, using alternative):\")\n        for ext, name, primary, fallback in fallback_available:\n            print(f\"    {ext:<14} {name:<28} [{fallback}] (primary: {primary})\")\n\n    if not_available:\n        print(\"\\n  NOT AVAILABLE (install required backend):\")\n        for ext, name, conv in not_available:\n            print(f\"    {ext:<14} {name:<28} needs: {conv}\")\n\n    if proprietary:\n        print(\"\\n  PROPRIETARY (export from original software as FBX/OBJ/IFC first):\")\n        for ext, name in proprietary:\n            print(f\"    {ext:<14} {name}\")\n\n    print()\n\n\ndef _is_backend_available(converter, backends):\n    \"\"\"Check if a converter backend is available.\"\"\"\n    if converter == \"copy\":\n        return True\n    if converter == \"trimesh\":\n        return backends.get(\"trimesh\") and backends.get(\"numpy\")\n    if converter == \"cascadio\":\n        return backends.get(\"trimesh\") and backends.get(\"cascadio\")\n    if converter in (\"ifcopenshell\", \"rhino3dm\"):\n        return backends.get(converter) and backends.get(\"trimesh\")\n    if converter == \"fbx2gltf\":\n        return bool(backends.get(\"fbx2gltf\"))\n    if converter == \"blender\":\n        return bool(backends.get(\"blender\"))\n    return False\n\n\ndef _find_fallback(converter, backends):\n    \"\"\"Find an available fallback converter.\"\"\"\n    for fb in FALLBACK_MAP.get(converter, []):\n        if _is_backend_available(fb, backends):\n            return fb\n    return None\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  CONVERTER FUNCTIONS\n# ══════════════════════════════════════════════════════════════════════════════\n\ndef convert_copy(input_path, output_path):\n    \"\"\"Copy .glb or convert .gltf to .glb.\"\"\"\n    ext = os.path.splitext(input_path)[1].lower()\n    if ext == \".glb\":\n        shutil.copy2(input_path, output_path)\n        return True, None\n    # For .gltf, try trimesh to pack into binary GLB\n    try:\n        import trimesh\n        scene = trimesh.load(input_path)\n        scene.export(output_path, file_type=\"glb\")\n        return os.path.isfile(output_path), None\n    except Exception:\n        # Last resort: just copy\n        shutil.copy2(input_path, output_path)\n        return True, None\n\n\ndef convert_with_trimesh(input_path, output_path):\n    \"\"\"Convert mesh formats using trimesh.\"\"\"\n    try:\n        import trimesh\n        import numpy  # noqa: F401\n    except ImportError:\n        return False, \"trimesh/numpy not installed. Run: pip install trimesh numpy\"\n\n    try:\n        scene_or_mesh = trimesh.load(input_path, force=None)\n        scene_or_mesh.export(output_path, file_type=\"glb\")\n        return os.path.isfile(output_path), None\n    except Exception as e:\n        return False, str(e)\n\n\ndef convert_with_cascadio(input_path, output_path):\n    \"\"\"Convert STEP/IGES using trimesh + cascadio.\"\"\"\n    try:\n        import trimesh\n        import cascadio  # noqa: F401 — registers itself with trimesh\n    except ImportError:\n        return False, \"cascadio not installed. Run: pip install trimesh cascadio\"\n\n    try:\n        scene_or_mesh = trimesh.load(input_path)\n        scene_or_mesh.export(output_path, file_type=\"glb\")\n        return os.path.isfile(output_path), None\n    except Exception as e:\n        return False, str(e)\n\n\ndef convert_with_ifcopenshell(input_path, output_path):\n    \"\"\"Convert IFC files using ifcopenshell geometry extraction.\"\"\"\n    try:\n        import ifcopenshell\n        import ifcopenshell.geom\n        import trimesh\n        import numpy as np\n    except ImportError:\n        return False, \"ifcopenshell not installed. Run: pip install ifcopenshell trimesh numpy\"\n\n    try:\n        settings = ifcopenshell.geom.settings()\n        settings.set(settings.USE_WORLD_COORDS, True)\n\n        ifc_file = ifcopenshell.open(input_path)\n        iterator = ifcopenshell.geom.iterator(settings, ifc_file)\n\n        meshes = []\n        if iterator.initialize():\n            while True:\n                shape = iterator.get()\n                verts = np.array(shape.geometry.verts).reshape(-1, 3)\n                faces = np.array(shape.geometry.faces).reshape(-1, 3)\n\n                if len(verts) > 0 and len(faces) > 0:\n                    # Extract per-face materials if available\n                    mat_ids = shape.geometry.material_ids\n                    colors = None\n                    if shape.geometry.materials:\n                        # Use first material diffuse color for face colors\n                        mat = shape.geometry.materials[0]\n                        if hasattr(mat, \"diffuse\") and mat.diffuse:\n                            r, g, b = mat.diffuse[:3]\n                            colors = np.full((len(verts), 4), [r, g, b, 1.0])\n\n                    mesh = trimesh.Trimesh(\n                        vertices=verts,\n                        faces=faces,\n                        vertex_colors=colors,\n                    )\n                    meshes.append(mesh)\n\n                if not iterator.next():\n                    break\n\n        if not meshes:\n            return False, \"No geometry found in IFC file\"\n\n        scene = trimesh.Scene(meshes)\n        scene.export(output_path, file_type=\"glb\")\n        return os.path.isfile(output_path), None\n    except Exception as e:\n        return False, str(e)\n\n\ndef convert_with_rhino3dm(input_path, output_path):\n    \"\"\"Convert Rhino 3DM files using rhino3dm.\"\"\"\n    try:\n        import rhino3dm\n        import trimesh\n        import numpy as np\n    except ImportError:\n        return False, \"rhino3dm not installed. Run: pip install rhino3dm trimesh numpy\"\n\n    try:\n        model = rhino3dm.File3dm.Read(input_path)\n        meshes = []\n\n        for obj in model.Objects:\n            geo = obj.Geometry\n\n            # Direct mesh objects\n            if isinstance(geo, rhino3dm.Mesh) and geo.Vertices.Count > 0:\n                verts = [(v.X, v.Y, v.Z) for v in geo.Vertices]\n                faces = []\n                for i in range(geo.Faces.Count):\n                    f = geo.Faces[i]\n                    faces.append([f[0], f[1], f[2]])\n                    if f[3] != f[2]:  # quad face\n                        faces.append([f[0], f[2], f[3]])\n                meshes.append(trimesh.Trimesh(vertices=verts, faces=np.array(faces)))\n\n            # Brep objects — try to get render mesh\n            elif isinstance(geo, rhino3dm.Brep):\n                render_meshes = geo.GetMesh(rhino3dm.MeshType.Any)\n                if render_meshes and render_meshes.Vertices.Count > 0:\n                    rm = render_meshes\n                    verts = [(v.X, v.Y, v.Z) for v in rm.Vertices]\n                    faces = []\n                    for i in range(rm.Faces.Count):\n                        f = rm.Faces[i]\n                        faces.append([f[0], f[1], f[2]])\n                        if f[3] != f[2]:\n                            faces.append([f[0], f[2], f[3]])\n                    meshes.append(trimesh.Trimesh(vertices=verts, faces=np.array(faces)))\n\n            # Extrusion objects\n            elif isinstance(geo, rhino3dm.Extrusion):\n                m = geo.GetMesh(rhino3dm.MeshType.Any)\n                if m and m.Vertices.Count > 0:\n                    verts = [(v.X, v.Y, v.Z) for v in m.Vertices]\n                    faces = []\n                    for i in range(m.Faces.Count):\n                        f = m.Faces[i]\n                        faces.append([f[0], f[1], f[2]])\n                        if f[3] != f[2]:\n                            faces.append([f[0], f[2], f[3]])\n                    meshes.append(trimesh.Trimesh(vertices=verts, faces=np.array(faces)))\n\n        if not meshes:\n            return False, \"No mesh geometry found in 3DM file\"\n\n        scene = trimesh.Scene(meshes)\n        scene.export(output_path, file_type=\"glb\")\n        return os.path.isfile(output_path), None\n    except Exception as e:\n        return False, str(e)\n\n\ndef convert_with_fbx2gltf(input_path, output_path):\n    \"\"\"Convert FBX using FBX2glTF CLI.\"\"\"\n    fbx2gltf = find_fbx2gltf()\n    if not fbx2gltf:\n        return False, \"FBX2glTF not found. Run: npm install -g fbx2gltf\"\n\n    output_base = output_path.replace(\".glb\", \"\")  # FBX2glTF appends .glb\n    cmd = [fbx2gltf, \"-b\", \"-i\", input_path, \"-o\", output_base]\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    if result.returncode != 0:\n        return False, result.stderr.strip()\n    return os.path.isfile(output_path), None\n\n\n# ── Blender headless converter ───────────────────────────────────────────────\n\nBLENDER_SCRIPT = r'''\nimport bpy\nimport sys\nimport os\n\nargv = sys.argv[sys.argv.index(\"--\") + 1:]\ninput_path = argv[0]\noutput_path = argv[1]\next = os.path.splitext(input_path)[1].lower()\n\nif ext == \".blend\":\n    bpy.ops.wm.open_mainfile(filepath=input_path)\nelse:\n    # Clear default scene\n    bpy.ops.object.select_all(action=\"SELECT\")\n    bpy.ops.object.delete(use_global=False)\n    for c in [bpy.data.meshes, bpy.data.materials, bpy.data.textures, bpy.data.images]:\n        for item in list(c):\n            c.remove(item)\n\n    IMPORTERS = {\n        \".obj\":  [lambda: bpy.ops.wm.obj_import(filepath=input_path),\n                  lambda: bpy.ops.import_scene.obj(filepath=input_path)],\n        \".stl\":  [lambda: bpy.ops.wm.stl_import(filepath=input_path),\n                  lambda: bpy.ops.import_mesh.stl(filepath=input_path)],\n        \".ply\":  [lambda: bpy.ops.wm.ply_import(filepath=input_path),\n                  lambda: bpy.ops.import_mesh.ply(filepath=input_path)],\n        \".fbx\":  [lambda: bpy.ops.import_scene.fbx(filepath=input_path)],\n        \".3ds\":  [lambda: bpy.ops.import_scene.autodesk_3ds(filepath=input_path)],\n        \".x3d\":  [lambda: bpy.ops.import_scene.x3d(filepath=input_path)],\n        \".wrl\":  [lambda: bpy.ops.import_scene.x3d(filepath=input_path)],\n        \".dae\":  [lambda: bpy.ops.wm.collada_import(filepath=input_path)],\n        \".abc\":  [lambda: bpy.ops.wm.alembic_import(filepath=input_path)],\n        \".usd\":  [lambda: bpy.ops.wm.usd_import(filepath=input_path)],\n        \".usdc\": [lambda: bpy.ops.wm.usd_import(filepath=input_path)],\n        \".usda\": [lambda: bpy.ops.wm.usd_import(filepath=input_path)],\n        \".dxf\":  [lambda: bpy.ops.import_scene.dxf(filepath=input_path)],\n        \".skp\":  [lambda: bpy.ops.import_scene.skp(filepath=input_path)],\n        \".ifc\":  [lambda: bpy.ops.bim.load_project(filepath=input_path)],\n        \".step\": [lambda: bpy.ops.import_scene.occ_import(filepath=input_path)],\n        \".stp\":  [lambda: bpy.ops.import_scene.occ_import(filepath=input_path)],\n        \".iges\": [lambda: bpy.ops.import_scene.occ_import(filepath=input_path)],\n        \".igs\":  [lambda: bpy.ops.import_scene.occ_import(filepath=input_path)],\n        \".3dm\":  [lambda: bpy.ops.import_3dm.import_3dm(filepath=input_path)],\n    }\n\n    ops = IMPORTERS.get(ext, [])\n    imported = False\n    for op in ops:\n        try:\n            op()\n            imported = True\n            break\n        except Exception as e:\n            print(f\"  Blender import attempt failed: {e}\")\n    if not imported:\n        print(f\"ERROR: Blender has no importer for {ext}\")\n        sys.exit(1)\n\n# Export as GLB\nbpy.ops.export_scene.gltf(\n    filepath=output_path,\n    export_format=\"GLB\",\n    export_draco_mesh_compression_enable=False,\n)\nprint(f\"SUCCESS: {output_path}\")\n'''\n\n\ndef convert_with_blender(input_path, output_path):\n    \"\"\"Convert using Blender in headless mode.\"\"\"\n    blender = find_blender()\n    if not blender:\n        return False, \"Blender not found. Install from https://blender.org (free)\"\n\n    # Write temporary Blender script\n    script_fd, script_path = tempfile.mkstemp(suffix=\".py\", prefix=\"allexblender_\")\n    try:\n        with os.fdopen(script_fd, \"w\") as f:\n            f.write(BLENDER_SCRIPT)\n\n        ext = os.path.splitext(input_path)[1].lower()\n        cmd = [blender, \"--background\"]\n\n        # For .blend files, open the file directly\n        if ext == \".blend\":\n            cmd.append(input_path)\n\n        cmd += [\"--python\", script_path, \"--\", input_path, output_path]\n\n        result = subprocess.run(\n            cmd, capture_output=True, text=True, timeout=300\n        )\n\n        if result.returncode != 0 or not os.path.isfile(output_path):\n            # Extract useful error from Blender output\n            stderr = result.stderr.strip()\n            stdout_lines = result.stdout.strip().split(\"\\n\")\n            errors = [l for l in stdout_lines if \"ERROR\" in l]\n            msg = errors[-1] if errors else stderr or \"Blender conversion failed\"\n            return False, msg\n\n        return True, None\n    except subprocess.TimeoutExpired:\n        return False, \"Blender conversion timed out (>300s)\"\n    except Exception as e:\n        return False, str(e)\n    finally:\n        os.unlink(script_path)\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  MAIN CONVERSION DISPATCH\n# ══════════════════════════════════════════════════════════════════════════════\n\nCONVERTER_FUNCTIONS = {\n    \"copy\":          convert_copy,\n    \"trimesh\":       convert_with_trimesh,\n    \"cascadio\":      convert_with_cascadio,\n    \"ifcopenshell\":  convert_with_ifcopenshell,\n    \"rhino3dm\":      convert_with_rhino3dm,\n    \"fbx2gltf\":      convert_with_fbx2gltf,\n    \"blender\":       convert_with_blender,\n}\n\n\ndef convert_file(input_path, output_path, backends):\n    \"\"\"\n    Convert a single 3D file to GLB.\n    Tries primary converter, then fallbacks.\n    Returns (success: bool, converter_used: str, error: str|None).\n    \"\"\"\n    ext = os.path.splitext(input_path)[1].lower()\n    info = FORMAT_REGISTRY.get(ext)\n\n    if not info:\n        return False, None, f\"Unknown format: {ext}\"\n\n    if info[\"converter\"] == \"proprietary\":\n        return False, None, (\n            f\"{info['name']} ({ext}) is proprietary. \"\n            \"Export from original software as .fbx / .obj / .ifc first.\"\n        )\n\n    # Build list of converters to try: primary + fallbacks\n    converters_to_try = [info[\"converter\"]]\n    converters_to_try.extend(FALLBACK_MAP.get(info[\"converter\"], []))\n\n    for conv_name in converters_to_try:\n        if not _is_backend_available(conv_name, backends):\n            continue\n\n        func = CONVERTER_FUNCTIONS.get(conv_name)\n        if not func:\n            continue\n\n        success, error = func(input_path, output_path)\n        if success:\n            return True, conv_name, None\n        # If primary failed, try next fallback\n        print(f\"    [{conv_name}] failed: {error}\")\n\n    return False, None, \"No available converter backend. Run: python AllExToGlb.py --check\"\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  PIPELINE: MERGE + COMPRESS + VIEWER\n# ══════════════════════════════════════════════════════════════════════════════\n\ndef merge_glbs(glb_files, output_path, npx_path):\n    \"\"\"Merge multiple GLB files into one using gltf-transform.\"\"\"\n    cmd = [npx_path, \"@gltf-transform/cli\", \"merge\", *glb_files, output_path]\n    print(f\"  Merging {len(glb_files)} files...\")\n    result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)\n    if result.returncode != 0:\n        print(f\"    ERROR: {result.stderr.strip()}\")\n        return False\n    return os.path.isfile(output_path)\n\n\ndef compress_glb(input_path, output_path, npx_path):\n    \"\"\"Apply Draco compression to a GLB file.\"\"\"\n    cmd = [npx_path, \"@gltf-transform/cli\", \"draco\", input_path, output_path]\n    print(f\"  Applying Draco compression...\")\n    result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)\n    if result.returncode != 0:\n        print(f\"    ERROR: {result.stderr.strip()}\")\n        return False\n    return os.path.isfile(output_path)\n\n\ndef generate_viewer_html(glb_filename, scale_factor):\n    \"\"\"Generate a self-contained Three.js viewer HTML.\"\"\"\n    return f\"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Viewer - {glb_filename}</title>\n    <style>\n        * {{ margin: 0; padding: 0; box-sizing: border-box; }}\n        body {{ overflow: hidden; background: #1a1a2e; font-family: Arial, sans-serif; }}\n        canvas {{ display: block; }}\n        #info {{\n            position: absolute; top: 10px; left: 10px; color: #fff;\n            background: rgba(0,0,0,0.7); padding: 12px 16px; border-radius: 8px;\n            font-size: 13px; line-height: 1.6; pointer-events: none;\n        }}\n        #loading {{\n            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);\n            color: #fff; font-size: 18px; background: rgba(0,0,0,0.8);\n            padding: 20px 30px; border-radius: 10px; text-align: center;\n        }}\n        #loading .bar {{ width: 300px; height: 6px; background: #333; border-radius: 3px; margin-top: 12px; }}\n        #loading .bar-fill {{ height: 100%; background: #4fc3f7; border-radius: 3px; width: 0%; transition: width 0.3s; }}\n        #controls {{\n            position: absolute; bottom: 10px; left: 10px; color: #fff;\n            background: rgba(0,0,0,0.7); padding: 10px 14px; border-radius: 8px; font-size: 12px;\n        }}\n        #controls label {{ display: block; margin: 4px 0; cursor: pointer; }}\n    </style>\n</head>\n<body>\n<div id=\"info\">\n    {glb_filename}<br>\n    Mouse: Orbit | Scroll: Zoom | Right-click: Pan\n</div>\n<div id=\"loading\">\n    Loading model...<br>\n    <span id=\"load-status\">0%</span>\n    <div class=\"bar\"><div class=\"bar-fill\" id=\"bar-fill\"></div></div>\n</div>\n<div id=\"controls\" style=\"display:none;\">\n    <label><input type=\"checkbox\" id=\"wireframe\"> Wireframe</label>\n</div>\n\n<script type=\"importmap\">\n{{\n    \"imports\": {{\n        \"three\": \"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js\",\n        \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/\"\n    }}\n}}\n</script>\n<script type=\"module\">\n    import * as THREE from 'three';\n    import {{ OrbitControls }} from 'three/addons/controls/OrbitControls.js';\n    import {{ GLTFLoader }} from 'three/addons/loaders/GLTFLoader.js';\n    import {{ DRACOLoader }} from 'three/addons/loaders/DRACOLoader.js';\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x1a1a2e);\n\n    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100000);\n    camera.position.set(50, 30, 80);\n\n    const renderer = new THREE.WebGLRenderer({{ antialias: true }});\n    renderer.setSize(innerWidth, innerHeight);\n    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    document.body.appendChild(renderer.domElement);\n\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n\n    scene.add(new THREE.AmbientLight(0xffffff, 0.6));\n    const dir1 = new THREE.DirectionalLight(0xffffff, 1.2);\n    dir1.position.set(100, 200, 100);\n    scene.add(dir1);\n    const dir2 = new THREE.DirectionalLight(0x8899bb, 0.5);\n    dir2.position.set(-100, 50, -100);\n    scene.add(dir2);\n\n    scene.add(new THREE.GridHelper(1000, 100, 0x444466, 0x333355));\n    scene.add(new THREE.AxesHelper(50));\n\n    const dracoLoader = new DRACOLoader();\n    dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/draco/');\n    const loader = new GLTFLoader();\n    loader.setDRACOLoader(dracoLoader);\n\n    const SCALE = {scale_factor};\n\n    loader.load(\n        '{glb_filename}',\n        (gltf) => {{\n            const model = gltf.scene;\n            model.scale.set(SCALE, SCALE, SCALE);\n            scene.add(model);\n            document.getElementById('loading').style.display = 'none';\n            document.getElementById('controls').style.display = 'block';\n\n            const box = new THREE.Box3().setFromObject(model);\n            const center = box.getCenter(new THREE.Vector3());\n            const size = box.getSize(new THREE.Vector3());\n            const maxDim = Math.max(size.x, size.y, size.z);\n            camera.position.copy(center);\n            camera.position.x += maxDim * 0.5;\n            camera.position.y += maxDim * 0.3;\n            camera.position.z += maxDim * 0.5;\n            controls.target.copy(center);\n            controls.update();\n\n            document.getElementById('wireframe').addEventListener('change', (e) => {{\n                model.traverse((child) => {{\n                    if (child.isMesh && child.material) {{\n                        const mats = Array.isArray(child.material) ? child.material : [child.material];\n                        mats.forEach(m => {{ m.wireframe = e.target.checked; }});\n                    }}\n                }});\n            }});\n        }},\n        (progress) => {{\n            if (progress.total > 0) {{\n                const pct = Math.round((progress.loaded / progress.total) * 100);\n                document.getElementById('load-status').textContent = pct + '%';\n                document.getElementById('bar-fill').style.width = pct + '%';\n            }}\n        }},\n        (error) => {{\n            document.getElementById('load-status').textContent = 'Error loading model';\n            console.error(error);\n        }}\n    );\n\n    addEventListener('resize', () => {{\n        camera.aspect = innerWidth / innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(innerWidth, innerHeight);\n    }});\n\n    (function animate() {{\n        requestAnimationFrame(animate);\n        controls.update();\n        renderer.render(scene, camera);\n    }})();\n</script>\n</body>\n</html>\"\"\"\n\n\ndef serve_folder(folder, port=8080):\n    \"\"\"Start a local HTTP server and open the viewer.\"\"\"\n    os.chdir(folder)\n    handler = http.server.SimpleHTTPRequestHandler\n    server = http.server.HTTPServer((\"\", port), handler)\n    print(f\"\\n  Serving at http://localhost:{port}/viewer.html\")\n    print(\"  Press Ctrl+C to stop.\\n\")\n    webbrowser.open(f\"http://localhost:{port}/viewer.html\")\n    try:\n        server.serve_forever()\n    except KeyboardInterrupt:\n        server.shutdown()\n        print(\"\\n  Server stopped.\")\n\n\n# ══════════════════════════════════════════════════════════════════════════════\n#  MAIN\n# ══════════════════════════════════════════════════════════════════════════════\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Universal 3D model to web-ready GLB converter.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nSupported free formats:\n  Mesh:  .obj .stl .ply .off .3mf .dae .gltf .glb .fbx\n  CAD:   .step .stp .iges .igs\n  BIM:   .ifc\n  3D:    .blend .3ds .x3d .wrl .abc .usd .usdc .usda .3dm .dxf .skp\n\nRun with --check to see which backends are installed.\nRun with --formats to see all supported formats.\n        \"\"\",\n    )\n    parser.add_argument(\"target\", nargs=\"?\", help=\"Folder containing 3D files, or a single file\")\n    parser.add_argument(\"--output\", \"-o\", default=None, help=\"Output GLB filename (default: combined.glb)\")\n    parser.add_argument(\"--scale\", \"-s\", type=float, default=1.0,\n                        help=\"Scale factor applied in the viewer (e.g. 0.1 for mm->cm)\")\n    parser.add_argument(\"--serve\", action=\"store_true\", help=\"Start local server and open viewer\")\n    parser.add_argument(\"--port\", type=int, default=8080, help=\"Port for local server (default: 8080)\")\n    parser.add_argument(\"--check\", action=\"store_true\", help=\"Show available backends and exit\")\n    parser.add_argument(\"--formats\", action=\"store_true\", help=\"Show all supported formats and exit\")\n    args = parser.parse_args()\n\n    # Detect backends\n    backends = detect_backends()\n\n    # Info-only modes\n    if args.check:\n        print_backend_status(backends)\n        return\n    if args.formats:\n        print_supported_formats(backends)\n        return\n\n    # Need a target\n    if not args.target:\n        parser.print_help()\n        sys.exit(1)\n\n    target = os.path.abspath(args.target)\n\n    # ── Collect input files ──────────────────────────────────────────────────\n\n    if os.path.isfile(target):\n        input_files = [target]\n        folder = os.path.dirname(target)\n    elif os.path.isdir(target):\n        folder = target\n        input_files = []\n        for f in sorted(os.listdir(folder)):\n            ext = os.path.splitext(f)[1].lower()\n            if ext in FORMAT_REGISTRY:\n                input_files.append(os.path.join(folder, f))\n    else:\n        print(f\"ERROR: '{target}' not found.\")\n        sys.exit(1)\n\n    if not input_files:\n        print(f\"ERROR: No supported 3D files found in '{folder}'.\")\n        print(\"  Run: python AllExToGlb.py --formats  to see supported formats.\")\n        sys.exit(1)\n\n    # Separate convertible from proprietary\n    convertible = []\n    proprietary_found = []\n    for f in input_files:\n        ext = os.path.splitext(f)[1].lower()\n        info = FORMAT_REGISTRY.get(ext, {})\n        if info.get(\"converter\") == \"proprietary\":\n            proprietary_found.append((f, info.get(\"name\", ext)))\n        else:\n            convertible.append(f)\n\n    output_name = args.output or \"combined.glb\"\n    if not output_name.endswith(\".glb\"):\n        output_name += \".glb\"\n    output_path = os.path.join(folder, output_name)\n\n    # ── Print header ─────────────────────────────────────────────────────────\n\n    print(f\"\\nAllExToGlb - Universal 3D to GLB Pipeline\")\n    print(f\"{'=' * 55}\")\n    print(f\"  Input          : {target}\")\n    print(f\"  Files found    : {len(input_files)} total ({len(convertible)} convertible)\")\n    print(f\"  Output         : {output_name}\")\n    print(f\"  Viewer scale   : {args.scale}\")\n    print(f\"{'=' * 55}\")\n\n    if proprietary_found:\n        print(f\"\\n  SKIPPED (proprietary — export from original software first):\")\n        for f, name in proprietary_found:\n            print(f\"    {os.path.basename(f):<30} ({name})\")\n\n    if not convertible:\n        print(\"\\n  ERROR: No convertible files. All files are proprietary formats.\")\n        print(\"  Export them from original software as .fbx / .obj / .ifc first.\")\n        sys.exit(1)\n\n    # ── Step 1: Convert each file to GLB ─────────────────────────────────────\n\n    npx_path = find_npx()\n\n    print(f\"\\n[1/3] Converting {len(convertible)} files to GLB...\")\n    temp_dir = tempfile.mkdtemp(prefix=\"allexglb_\")\n    individual_glbs = []\n    failed = []\n\n    for input_file in convertible:\n        basename = os.path.basename(input_file)\n        name_no_ext = os.path.splitext(basename)[0]\n        ext = os.path.splitext(basename)[1].lower()\n        temp_glb = os.path.join(temp_dir, f\"{name_no_ext}.glb\")\n\n        info = FORMAT_REGISTRY.get(ext, {})\n        print(f\"\\n  {basename} ({info.get('name', '?')})\")\n\n        success, converter_used, error = convert_file(input_file, temp_glb, backends)\n\n        if success:\n            size_mb = os.path.getsize(temp_glb) / (1024 * 1024)\n            print(f\"    -> OK  [{converter_used}]  {size_mb:.1f} MB\")\n            individual_glbs.append(temp_glb)\n        else:\n            print(f\"    -> FAILED: {error}\")\n            failed.append((basename, error))\n\n    if not individual_glbs:\n        print(\"\\nERROR: No files converted successfully.\")\n        shutil.rmtree(temp_dir, ignore_errors=True)\n        sys.exit(1)\n\n    # ── Step 2: Merge ────────────────────────────────────────────────────────\n\n    print(f\"\\n[2/3] Merging {len(individual_glbs)} GLB files...\")\n\n    if len(individual_glbs) == 1:\n        merged_path = individual_glbs[0]\n        print(\"  Only one file, skipping merge.\")\n    elif not npx_path:\n        print(\"  WARNING: npx not found — cannot merge. Using largest file.\")\n        merged_path = max(individual_glbs, key=os.path.getsize)\n    else:\n        merged_path = os.path.join(temp_dir, \"_merged.glb\")\n        if not merge_glbs(individual_glbs, merged_path, npx_path):\n            print(\"  Merge failed. Using largest individual file.\")\n            merged_path = max(individual_glbs, key=os.path.getsize)\n\n    merged_size = os.path.getsize(merged_path) / (1024 * 1024)\n    print(f\"  Merged size: {merged_size:.1f} MB\")\n\n    # ── Step 3: Draco compress ───────────────────────────────────────────────\n\n    print(f\"\\n[3/3] Compressing with Draco...\")\n\n    if not npx_path:\n        print(\"  WARNING: npx not found — skipping Draco compression.\")\n        shutil.copy2(merged_path, output_path)\n    elif not compress_glb(merged_path, output_path, npx_path):\n        print(\"  Draco compression failed. Copying uncompressed.\")\n        shutil.copy2(merged_path, output_path)\n\n    final_size = os.path.getsize(output_path) / (1024 * 1024)\n    print(f\"  Final size: {final_size:.1f} MB\")\n\n    # Generate viewer HTML\n    viewer_path = os.path.join(folder, \"viewer.html\")\n    with open(viewer_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(generate_viewer_html(output_name, args.scale))\n\n    # Cleanup\n    shutil.rmtree(temp_dir, ignore_errors=True)\n\n    # ── Summary ──────────────────────────────────────────────────────────────\n\n    print(f\"\\n{'=' * 55}\")\n    print(f\"  DONE!\")\n    print(f\"  Output : {output_path} ({final_size:.1f} MB)\")\n    if merged_size > 0:\n        ratio = (1 - final_size / merged_size) * 100\n        print(f\"  Savings: {merged_size:.1f} MB -> {final_size:.1f} MB ({ratio:.0f}% reduction)\")\n    print(f\"  Viewer : {viewer_path}\")\n\n    if failed:\n        print(f\"\\n  FAILED ({len(failed)}):\")\n        for name, err in failed:\n            print(f\"    {name}: {err}\")\n\n    print(f\"{'=' * 55}\\n\")\n\n    if args.serve:\n        serve_folder(folder, args.port)\n    else:\n        print(f\"  To view:\")\n        print(f\"    python AllExToGlb.py \\\"{args.target}\\\" --serve\")\n        print(f\"  Or open viewer.html via any HTTP server.\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}