{
  "source_url": "https://github.com/compas-dev/compas_fab/blob/431e82c810ea299b9727b010b73a39abc73c5d62/src/compas_fab/ghpython/components/Cf_VisualizeRobot/code.py",
  "repo": "compas-dev/compas_fab",
  "repo_stars": 124,
  "repo_description": "Robotic fabrication package for the COMPAS Framework.",
  "license": "MIT",
  "filepath": "src/compas_fab/ghpython/components/Cf_VisualizeRobot/code.py",
  "instruction": "Visualizes the robot.",
  "code": "\"\"\"\nVisualizes the robot.\n\nCOMPAS FAB v1.0.2\n\"\"\"\n\nimport time\n\nfrom compas.geometry import Frame\nfrom compas.geometry import Transformation\nfrom compas.scene import SceneObject\nfrom compas_ghpython import create_id\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom ghpythonlib.componentbase import executingcomponent as component\nfrom scriptcontext import sticky as st\n\nfrom compas_fab.backends import BackendFeatureNotSupportedError\nfrom compas_fab.robots import PlanningScene\n\n\nclass RobotVisualize(component):\n    def RunScript(\n        self,\n        robot,\n        group,\n        configuration,\n        show_visual,\n        show_collision,\n        show_frames,\n        show_base_frame,\n        show_end_effector_frame,\n        show_cm,\n        show_acm,\n    ):\n        visual = None\n        collision = None\n        collision_meshes = None\n        attached_meshes = None\n        frames = None\n        base_frame = None\n        ee_frame = None\n\n        if robot:\n            show_visual = True if show_visual is None else show_visual\n            show_cm = True if show_cm is None else show_cm\n            show_acm = True if show_acm is None else show_acm\n            configuration = configuration or robot.zero_configuration()\n\n            robot.update(configuration, visual=show_visual, collision=show_collision)\n            compas_frames = robot.transformed_frames(configuration, group)\n\n            if show_visual:\n                visual = robot.scene_object.draw_visual()\n\n            if show_collision:\n                collision = robot.scene_object.draw_collision()\n\n            if show_base_frame:\n                base_compas_frame = compas_frames[0]\n                base_frame = frame_to_rhino_plane(base_compas_frame)\n\n            if show_end_effector_frame:\n                options = dict(solver=\"model\")\n                if robot.attached_tool:\n                    options[\"link\"] = robot.attached_tool.connected_to\n\n                ee_compas_frame = robot.forward_kinematics(configuration, group, options=options)\n                ee_frame = frame_to_rhino_plane(ee_compas_frame)\n\n            if show_frames:\n                frames = []\n                for compas_frame in compas_frames[1:]:\n                    frame = frame_to_rhino_plane(compas_frame)\n                    frames.append(frame)\n\n            cached_scene_key = create_id(self, \"cached_scene\")\n\n            if show_cm or show_acm:\n                cached_scene = st.get(cached_scene_key)\n                if not cached_scene:\n                    cached_scene = {\"time\": 0}\n\n                # expire cache if the component has not been executed in the last 2 seconds\n                # this allows to slide through a list of configurations\n                # without triggering refreshes of the scene in the middle of it\n                if time.time() - cached_scene[\"time\"] > 2:\n                    update_scene = True\n                else:\n                    update_scene = False\n\n                if update_scene:\n                    scene = PlanningScene(robot)\n                    try:\n                        scene = robot.client.get_planning_scene()\n                    except BackendFeatureNotSupportedError:\n                        print(\n                            \"The selected backend does not support collision meshes. If you need collision mesh support, use a different backend.\"\n                        )\n                        scene = None\n                        show_cm = False\n                        show_acm = False\n\n                if update_scene and show_cm:\n                    collision_meshes = []\n\n                    for co in scene.world.collision_objects:\n                        header = co.header\n                        frame_id = header.frame_id\n                        cms = co.to_collision_meshes()\n\n                        for cm in cms:\n                            if cm.frame != Frame.worldXY():\n                                t = Transformation.from_frame(cm.frame)\n                                mesh = cm.mesh.transformed(t)\n                            else:\n                                mesh = cm.mesh\n\n                            collision_meshes.extend(SceneObject(mesh).draw())\n\n                        cached_scene[\"cm\"] = collision_meshes\n\n                collision_meshes = cached_scene.get(\"cm\", [])\n\n                if update_scene and show_acm:\n                    attached_meshes = []\n\n                    for aco in scene.robot_state.attached_collision_objects:\n                        for acm in aco.to_attached_collision_meshes():\n                            frame_id = aco.object[\"header\"][\"frame_id\"]\n                            frame = robot.forward_kinematics(configuration, options=dict(link=frame_id))\n                            t = Transformation.from_frame(frame)\n\n                            # Local CM frame\n                            if acm.collision_mesh.frame and acm.collision_mesh.frame != Frame.worldXY():\n                                t = t * Transformation.from_frame(acm.collision_mesh.frame)\n\n                            mesh = acm.collision_mesh.mesh.transformed(t)\n\n                            attached_meshes.extend(SceneObject(mesh).draw())\n\n                    cached_scene[\"acm\"] = attached_meshes\n\n                attached_meshes = cached_scene.get(\"acm\", [])\n\n                cached_scene[\"time\"] = time.time()\n                st[cached_scene_key] = cached_scene\n\n        return (\n            visual,\n            collision,\n            collision_meshes,\n            attached_meshes,\n            frames,\n            base_frame,\n            ee_frame,\n        )\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}