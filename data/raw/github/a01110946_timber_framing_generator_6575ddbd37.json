{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/header_cripples.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/header_cripples.py",
  "instruction": "File: timber_framing_generator/framing_elements/header_cripples.py",
  "code": "# File: timber_framing_generator/framing_elements/header_cripples.py\n\nfrom typing import Dict, List, Any, Tuple, Optional\nimport Rhino.Geometry as rg\nimport math\n\nfrom src.timber_framing_generator.utils.safe_rhino import safe_create_extrusion\nfrom src.timber_framing_generator.config.framing import FRAMING_PARAMS, get_framing_param\n\n# Import our custom logging module\nfrom ..utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\n# Ensure FRAMING_PARAMS includes the min_cripple_length parameter:\n# \"min_cripple_length\": 6.0/12,  # Minimum length for header cripples (6 inches in feet)\n\n\nclass HeaderCrippleGenerator:\n    \"\"\"\n    Generates header cripple studs above openings.\n\n    Header cripples are vertical framing members placed between the header\n    above an opening and the underside of the top plate. They transfer loads\n    from the top plate to the header and help support the wall structure\n    above openings.\n    \"\"\"\n\n    def __init__(self, wall_data: Dict[str, Any]):\n        \"\"\"\n        Initialize the header cripple generator with wall data.\n\n        Args:\n            wall_data: Dictionary containing wall information including:\n                - base_plane: Reference plane for wall coordinate system\n                - wall_base_elevation: Base elevation of the wall\n                - wall_top_elevation: Top elevation of the wall\n        \"\"\"\n        logger.debug(\"Initializing HeaderCrippleGenerator\")\n        logger.trace(f\"Wall data: {wall_data}\")\n        \n        # Store the wall data for use throughout the generation process\n        self.wall_data = wall_data\n\n        # Initialize storage for debug geometry\n        self.debug_geometry = {\"points\": [], \"planes\": [], \"profiles\": [], \"paths\": []}\n        \n        logger.debug(\"HeaderCrippleGenerator initialized successfully\")\n\n    def generate_header_cripples(\n        self,\n        opening_data: Dict[str, Any],\n        header_data: Dict[str, Any],\n        top_plate_data: Dict[str, Any],\n        trimmer_positions: Optional[Tuple[float, float]] = None,\n    ) -> List[rg.Brep]:\n        \"\"\"\n        Generate header cripple studs above an opening.\n\n        This method creates a series of header cripple studs between the top of a header\n        and the bottom of the top plate. The cripples are spaced equidistantly between\n        the trimmers on either side of the opening.\n\n        Args:\n            opening_data: Dictionary with opening information including:\n                - start_u_coordinate: Position along wall where opening starts\n                - rough_width: Width of the rough opening\n            header_data: Dictionary with header geometry information including:\n                - top_elevation: Top face elevation of the header\n            top_plate_data: Dictionary with top plate information including:\n                - bottom_elevation: Bottom face elevation of the top plate\n            trimmer_positions: Optional tuple of (left, right) u-coordinates for trimmers\n                               If not provided, calculated from opening dimensions\n\n        Returns:\n            List of header cripple Brep geometries\n        \"\"\"\n        try:\n            logger.info(\"Generating header cripples\")\n            logger.trace(f\"Opening data: {opening_data}\")\n            logger.trace(f\"Header data: {header_data}\")\n            logger.trace(f\"Top plate data: {top_plate_data}\")\n            logger.trace(f\"Trimmer positions: {trimmer_positions}\")\n            \n            # Extract opening information\n            opening_u_start = opening_data.get(\"start_u_coordinate\")\n            opening_width = opening_data.get(\"rough_width\")\n\n            if None in (opening_u_start, opening_width):\n                logger.warning(\"Missing required opening data for header cripple generation\")\n                return []\n\n            # Get essential parameters\n            base_plane = self.wall_data.get(\"base_plane\")\n            if base_plane is None:\n                logger.warning(\"No base plane available for header cripple generation\")\n                return []\n\n            # Calculate header cripple dimensions from framing parameters\n            # Uses wall_data config if available (for material-specific dimensions)\n            cripple_width = get_framing_param(\n                \"cripple_width\", self.wall_data, 1.5 / 12\n            )  # Typically 1.5 inches\n            cripple_depth = get_framing_param(\n                \"cripple_depth\", self.wall_data, 3.5 / 12\n            )  # Typically 3.5 inches\n            cripple_spacing = get_framing_param(\n                \"cripple_spacing\", self.wall_data, 16 / 12\n            )  # Typically 16 inches\n            min_cripple_length = get_framing_param(\n                \"min_cripple_length\", self.wall_data, 6 / 12\n            )  # Minimum 6 inches\n            \n            logger.debug(\"Header cripple dimensions:\")\n            logger.debug(f\"  Width: {cripple_width}\")\n            logger.debug(f\"  Depth: {cripple_depth}\")\n            logger.debug(f\"  Spacing: {cripple_spacing}\")\n            logger.debug(f\"  Minimum length: {min_cripple_length}\")\n\n            # Calculate vertical bounds\n            # BUG FIX: Convert from absolute Z to relative (above base plane origin)\n            # These elevations are absolute, but PointAt/Add adds them to origin.Z\n            base_z = base_plane.Origin.Z if base_plane else 0.0\n            header_top_elevation_abs = header_data.get(\"top_elevation\")\n            header_top_elevation = header_top_elevation_abs - base_z if header_top_elevation_abs is not None else None\n\n            # Try different keys for bottom elevation\n            top_plate_bottom_elevation_abs = top_plate_data.get(\n                \"bottom_elevation\"\n            ) or top_plate_data.get(\"boundary_elevation\")\n            top_plate_bottom_elevation = top_plate_bottom_elevation_abs - base_z if top_plate_bottom_elevation_abs is not None else None\n\n            logger.debug(f\"Header top elevation: {header_top_elevation} (relative), absolute was {header_top_elevation_abs}\")\n            logger.debug(f\"Top plate bottom elevation: {top_plate_bottom_elevation} (relative), absolute was {top_plate_bottom_elevation_abs}\")\n\n            if None in (header_top_elevation, top_plate_bottom_elevation):\n                logger.warning(\"Missing elevation data for header or top plate\")\n                logger.debug(f\"Header data keys: {header_data.keys()}\")\n                logger.debug(f\"Top plate data keys: {top_plate_data.keys()}\")\n                return []\n\n            # Calculate cripple length\n            cripple_length = top_plate_bottom_elevation - header_top_elevation\n            logger.debug(f\"Calculated cripple length: {cripple_length}\")\n\n            # Check if cripple length meets minimum requirement\n            if cripple_length < min_cripple_length:\n                logger.warning(\n                    f\"Header cripple length {cripple_length} is less than minimum {min_cripple_length}\"\n                )\n                return []\n\n            # Calculate horizontal positions\n            if trimmer_positions:\n                # Use provided trimmer positions\n                u_left, u_right = trimmer_positions\n                # trimmer_width = FRAMING_PARAMS.get(\"trimmer_width\", 1.5/12)\n\n                u_left_inner = u_left  # + (trimmer_width / 2)\n                u_right_inner = u_right  # - (trimmer_width / 2)\n                logger.debug(\"Using provided trimmer positions for header cripples\")\n            else:\n                # Calculate positions based on opening with standard offsets\n                u_left_inner = opening_u_start - (cripple_width / 2)\n                u_right_inner = opening_u_start + opening_width + (cripple_width / 2)\n                logger.debug(\"Calculated trimmer positions based on opening data\")\n\n            # Calculate internal width between inner faces\n            internal_width = u_right_inner - u_left_inner\n\n            logger.debug(\"Header cripple calculation details:\")\n            logger.debug(f\"  Trimmer positions: left={u_left_inner}, right={u_right_inner}\")\n            logger.debug(f\"  Internal width: {internal_width}\")\n            logger.debug(f\"  Cripple spacing parameter: {cripple_spacing}\")\n\n            # Calculate number of spaces based on standard spacing\n            num_spaces = math.ceil(internal_width / cripple_spacing)\n\n            # Number of cripples is one more than number of spaces\n            cripple_count = num_spaces + 1\n\n            # Calculate actual spacing\n            actual_spacing = internal_width / num_spaces\n\n            logger.debug(f\"  Number of spaces: {num_spaces}\")\n            logger.debug(f\"  Number of cripples: {cripple_count}\")\n            logger.debug(f\"  Actual spacing: {actual_spacing}\")\n\n            # Generate cripple positions\n            cripple_positions = []\n            for i in range(cripple_count):\n                position = u_left_inner + i * actual_spacing\n                cripple_positions.append(position)\n                logger.trace(f\"  Cripple {i+1} position: {position}\")\n\n            # TODO: Implement alternative spacing mode where spacing is exact value from FRAMING_PARAMS[\"cripple_spacing\"]\n            # except for the last header cripple which adjusts to the remainder space\n\n            # Store header cripples\n            header_cripples = []\n\n            # Generate cripples at calculated positions\n            logger.debug(f\"Creating {len(cripple_positions)} header cripples\")\n            for i, u_position in enumerate(cripple_positions):\n                # Create the cripple stud\n                logger.trace(f\"Creating cripple {i+1} at position {u_position}\")\n                cripple = self._create_cripple_geometry(\n                    base_plane,\n                    u_position,\n                    header_top_elevation,\n                    top_plate_bottom_elevation,\n                    cripple_width,\n                    cripple_depth,\n                )\n\n                if cripple is not None:\n                    header_cripples.append(cripple)\n                    logger.trace(f\"Cripple {i+1} created successfully\")\n                else:\n                    logger.warning(f\"Failed to create cripple at position {u_position}\")\n\n            logger.info(f\"Generated {len(header_cripples)} header cripples\")\n            return header_cripples\n\n        except Exception as e:\n            logger.error(f\"Error generating header cripples: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return []\n\n    def _create_cripple_geometry(\n        self,\n        base_plane: rg.Plane,\n        u_coordinate: float,\n        bottom_v: float,\n        top_v: float,\n        width: float,\n        depth: float,\n    ) -> Optional[rg.Brep]:\n        \"\"\"\n        Create the geometry for a single header cripple stud.\n\n        This method creates a header cripple stud by:\n        1. Creating start and end points in the wall's coordinate system\n        2. Creating a profile perpendicular to the stud's centerline\n        3. Extruding the profile along the centerline\n\n        Args:\n            base_plane: Wall's base plane for coordinate system\n            u_coordinate: Position along wall (horizontal)\n            bottom_v: Bottom elevation of cripple (top of header)\n            top_v: Top elevation of cripple (bottom of top plate)\n            width: Width of cripple (perpendicular to wall face)\n            depth: Depth of cripple (parallel to wall length)\n\n        Returns:\n            Brep geometry for the header cripple stud, or None if creation fails\n        \"\"\"\n        try:\n            logger.trace(f\"Creating cripple geometry at u={u_coordinate}, bottom_v={bottom_v}, top_v={top_v}\")\n\n            # 1. Create the centerline endpoints in wall-local coordinates\n            # The wall's base_plane coordinate system is:\n            #   - XAxis = along wall (U direction)\n            #   - YAxis = vertical (V direction) - derived from World Z\n            #   - ZAxis = wall normal (W direction)\n            # Position using wall-local U,V coordinates via base_plane axes\n\n            start_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, bottom_v),\n                ),\n            )\n\n            end_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, top_v),\n                ),\n            )\n\n            # Create the centerline as a curve\n            centerline = rg.LineCurve(start_point, end_point)\n            self.debug_geometry[\"paths\"].append(centerline)\n\n            # 2. Create a profile plane at the start point\n            # X axis goes across wall thickness (for width)\n            profile_x_axis = base_plane.ZAxis\n            # Y axis goes along wall length (for depth)\n            profile_y_axis = base_plane.XAxis\n\n            profile_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n            self.debug_geometry[\"planes\"].append(profile_plane)\n\n            # 3. Create a rectangular profile centered on the plane\n            profile_rect = rg.Rectangle3d(\n                profile_plane,\n                rg.Interval(-depth / 2, depth / 2),\n                rg.Interval(-width / 2, width / 2),\n            )\n\n            profile_curve = profile_rect.ToNurbsCurve()\n            self.debug_geometry[\"profiles\"].append(profile_rect)\n\n            # 4. Extrude the profile along the centerline path\n            # Calculate the vector from start to end\n            path_vector = rg.Vector3d(end_point - start_point)\n\n            # Create the extrusion\n            extrusion = safe_create_extrusion(profile_curve, path_vector)\n\n            # Convert to Brep and return\n            if extrusion and extrusion.IsValid:\n                logger.debug(\"Cripple extrusion created successfully\")\n                return extrusion.ToBrep().CapPlanarHoles(0.001)\n            else:\n                logger.warning(\"Failed to create valid header cripple extrusion, trying box fallback\")\n\n            # Fallback: Box creation method\n            try:\n                logger.debug(\"Attempting box creation for header cripple\")\n\n                # Calculate height based on start and end points\n                height = 0\n                if start_point is not None and end_point is not None:\n                    height = start_point.DistanceTo(end_point)\n                    if height <= 0:\n                        logger.warning(f\"Invalid cripple height: {height}\")\n                        return None\n                else:\n                    logger.warning(\"Invalid start/end points for header cripple\")\n                    return None\n\n                # Create a wall-aligned box plane at start point\n                # For vertical members going UP: X = wall direction, Y = wall normal, Z = UP (World Z)\n                # Note: Using base_plane.YAxis for the plane's Y ensures Z points UP\n                box_plane = rg.Plane(\n                    start_point,\n                    base_plane.XAxis,  # X = wall direction (for depth along wall)\n                    base_plane.YAxis   # Y = vertical (so Z = X cross Y points into wall, but we'll use height for vertical)\n                )\n                # Override to ensure Z is pointing UP (World Z direction)\n                box_plane = rg.Plane(\n                    start_point,\n                    base_plane.XAxis,       # X = along wall (for depth)\n                    rg.Vector3d(0, 0, 1)    # Y = World Z (vertical), so plane Z = wall normal\n                )\n\n                # Create box - vertical cripple stud\n                # X interval = depth (along wall), Y interval = height (vertical UP), Z interval = width (into wall)\n                box = rg.Box(\n                    box_plane,\n                    rg.Interval(-depth / 2, depth / 2),   # X = depth along wall\n                    rg.Interval(0, height),               # Y = height (vertical UP)\n                    rg.Interval(-width / 2, width / 2)    # Z = width into wall\n                )\n\n                if box and box.IsValid:\n                    box_brep = box.ToBrep()\n                    if box_brep and hasattr(box_brep, 'IsValid') and box_brep.IsValid:\n                        logger.debug(\"Successfully created header cripple using box method\")\n                        return box_brep\n            except Exception as box_error:\n                logger.warning(f\"Box creation for header cripple failed: {str(box_error)}\")\n\n            logger.error(\"All header cripple creation methods failed\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"Error creating header cripple geometry: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}