{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Load%20Aggregation%20from%20File.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Load Aggregation from File.py",
  "instruction": "Loads an aggregation from a previously saved .txt file\n-\nProvided by Wasp 0.6\n    Args:\n        PART: Parts definition for the aggregation\n        FILE: File where the aggregation is saved (.json)\n  ...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nLoads an aggregation from a previously saved .txt file\n-\nProvided by Wasp 0.6\n    Args:\n        PART: Parts definition for the aggregation\n        FILE: File where the aggregation is saved (.json)\n        RENUM: If True, Part IDs are renumbered in sequential order, avoiding issues with missing IDs if elements have been removed from the Aggregation (False by default)\n    Returns:\n        PART_OUT: Imported aggregation parts\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Load Aggregation from File\"\nghenv.Component.NickName = 'LoadAggr'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"6 | Aggregation\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\nimport math\nimport json\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    pass\n\n\ndef main(parts, file_path, renumber):\n        \n    check_data = True\n    \n    ## check inputs\n    if len(parts) == 0:\n        check_data = False\n        msg = \"No parts provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if file_path is None:\n        check_data = False\n        msg = \"No path provided for the file to load\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if renumber is None:\n        renumber = False\n    \n    ## execute main code if all needed inputs are available\n    if check_data:\n        \n        loaded_parts = []\n        aggr_dict = {}\n        \n        ## load json data\n        with open(file_path, \"r\") as inF:\n            txt_data = inF.read()\n            aggr_dict = json.loads(txt_data)\n        \n        ## sort part ids\n        part_ids = [int(id) for id in aggr_dict['parts'].keys()]\n        part_ids.sort()\n        \n        ## create new ids for renumbering\n        renumbered_ids = None\n        if renumber:\n            renumbered_ids = range(len(part_ids))\n        \n        ## load parts\n        for i in range(len(part_ids)):\n            id = part_ids[i]\n            part_data = aggr_dict['parts'][str(id)]\n            \n            if renumber:\n                id = i\n            \n            ## part name\n            name = part_data['name']\n            \n            ## part active connections\n            active_conn = part_data['active_connections']\n            \n            parent = part_data['parent']\n            if renumber:\n                try:\n                    parent = part_ids.index(parent)\n                except:\n                    parent = None\n            \n            children = part_data['children']\n            if renumber:\n                children_renum = []\n                for child in children:\n                    try:\n                        children_renum.append(part_ids.index(child))\n                    except:\n                        pass\n                children = children_renum\n            \n            \n            ## part transform\n            trans = rg.Transform(0)\n            trans.M00 = part_data['transform']['M00']\n            trans.M01 = part_data['transform']['M01']\n            trans.M02 = part_data['transform']['M02']\n            trans.M03 = part_data['transform']['M03']\n            \n            trans.M10 = part_data['transform']['M10']\n            trans.M11 = part_data['transform']['M11']\n            trans.M12 = part_data['transform']['M12']\n            trans.M13 = part_data['transform']['M13']\n            \n            trans.M20 = part_data['transform']['M20']\n            trans.M21 = part_data['transform']['M21']\n            trans.M22 = part_data['transform']['M22']\n            trans.M23 = part_data['transform']['M23']\n            \n            trans.M30 = part_data['transform']['M30']\n            trans.M31 = part_data['transform']['M31']\n            trans.M32 = part_data['transform']['M32']\n            trans.M33 = part_data['transform']['M33']\n            \n            constrained = part_data['is_constrained']\n            \n            new_part = None\n            for part in PART:\n                if part.name == name:\n                    new_part = part.transform(trans)\n                    \n                    ## flip part if negative scaling occurs\n                    if trans.M00 * trans.M11 * trans.M22 < 0:\n                        ## geometry\n                        new_part.geo.Flip(True, True, True)\n                        ## connections\n                        for conn in new_part.connections:\n                            pass\n                            conn.pln.Flip()\n                            conn.pln.Rotate(math.pi/2, conn.pln.ZAxis)\n                        ## collider\n                        for geo in new_part.collider.geometry:\n                            geo.Flip(True, True, True)\n                    \n                    break\n            \n            if new_part is not None:\n                new_part.id = id\n                new_part.active_connections = active_conn\n                new_part.parent = parent\n                new_part.children = children\n                new_part.is_constrained = constrained\n                \n                loaded_parts.append(new_part)\n            \n        return loaded_parts\n    else:\n        return -1\n\nresult = main(PART, FILE, RENUM)\n\nif result != -1:\n    PART_OUT = result",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}