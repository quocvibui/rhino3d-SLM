{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_2PDF_Print.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_2PDF_Print.py",
  "instruction": "This will take in a Tree of GH objects, bake to the scene and Print to PDF, then remove the baked geom from the scene. Basically, its a GH PDF Printer. \r\r\nEach branch on the GH input tree will be...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nThis will take in a Tree of GH objects, bake to the scene and Print to PDF, then remove the baked geom from the scene. Basically, its a GH PDF Printer. \r\r\nEach branch on the GH input tree will be output to a separate PDF, so organize inputs accordingly. Use a 'MeshColor' object on all surfaces before passing in to make them come out as solid fills in the PDF\r\r\nNOTE: be sure to turn off all your GH Previews - otherwise they will print to the PDF as well.\r\r\n-\r\r\nEM Jun. 07, 2020\r\r\n    Args:\r\r\n        layersOn_: (Tree - strings) <Optional> A Tree of layers names to have 'On' during each export. If the tree length matches the '_geomToBake' the layer states will be modified for each output. Otherwise the first tree branch's values will be used for all. If none are passed, all Rhino Layers will be set to 'Off' for all the exports. Note: When passing in child/nested layers, use the Rhino convention <\"Parent::Child\"> - ie: \"00_CAD::Floor_1\" for a nested layer 'Floor_1' under '00_CAD'.\r\r\n        _print: (Bool): Set to True to run. Use Boolean toggle not a button (for some reason?)\r\r\n        _saveFolder: (string) File path where the outputs should be saved. Will create if it doesn't exist. ie: \"C:\\My_Project\\Exports\"\r\r\n        fileName_:(List - string) <Optional> If a List of names are input, will use those for the exports. The length of the list should match the BranchCount of \"_geomToBake\". If a single name is input, will use that as the base name for the export files. If nothing is input, will use the name of the active Rhino File as the base.\r\r\n        _viewName: (string) Input the name of the view you'd like to export. Will accept either a basic Rhino View or a Layout Page name\r\r\n        _geomToBake: (Tree - meshes) The Grasshopper objects to be printed as a Tree. Each branch of the tree and all objects on that branch will be printed one at a time to separate PDF files. Before inputting surfaces, pass them through a 'MeshColor' component to assign colors correctly.\r\r\n        _geomAttributes: (Tree - Rhino.DocObjects.ObjectAttributes) The Rhino Object Attributes (Color, Draworder, etc) to use for printing.\r\r\n        _notesToBake: (Tree - strings) A Tree of any notes / text to be printed to the files\r\r\n        _noteLocations: (Tree - Point3d) A Tree of center-point locations for the text note. Should match the _notesToBake in length and order\r\r\n        noteTxtSize_: (Float) <Optional> A size (height) for the text. Note this refers to the 'Layout' units. File/Properties/Units/Layout.... For reference 7pt=2.5mm, 8pt=2.8mm, 9pt=3.4mm, 10pt=3.6mm, 12pt=4.2mm, 14pt=5mm\r\r\n        _tablesToBake: (Tree - Table Object) <Optional>\r\r\n        titleBlockTxtToBake_: (Tree) Each Branch should contain one or more text strings to write out to the Layout Page (Paperspace). Useful for Titleblock items.\r\r\n        titleBlockTxtLocatons_: (List) Center Points for the Text items to be bakes to the Layout. List length should match the length of each of the Tree Branches in 'titleBlockTxtToBake_'\r\r\n    Returns:\r\r\n        \r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_2PDF_Print\"\r\r\nghenv.Component.NickName = \"2PDF | Print\"\r\r\nghenv.Component.Message = 'JUN_07_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"03 | PDF\"\r\r\n\r\r\nimport Rhino\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport scriptcontext as sc\r\r\nimport System.Guid, System.Drawing, System.Drawing.Color\r\r\nimport Grasshopper.Kernel as ghK\r\r\nimport ghpythonlib.components as ghc\r\r\nimport os\r\r\nimport System\r\r\n\r\r\ndef mesh2Hatch(mesh):\r\r\n    # Copied / Adapted from Ladybug Definition\r\r\n    \r\r\n    #Make some lists to hold key parameters\r\r\n    hatches = []\r\r\n    colors = []\r\r\n    guids = []\r\r\n    runningVertexCount = 0\r\r\n    meshColors = mesh.VertexColors\r\r\n    \r\r\n    for faceCount, face in enumerate(mesh.Faces):\r\r\n        faceColorList = []\r\r\n        facePointList = []\r\r\n        \r\r\n        #Extract the points and colors.\r\r\n        if face.IsQuad:\r\r\n            faceColorList.append(meshColors[face.A])\r\r\n            faceColorList.append(meshColors[face.B])\r\r\n            faceColorList.append(meshColors[face.C])\r\r\n            faceColorList.append(meshColors[face.D])\r\r\n            \r\r\n            facePointList.append(mesh.PointAt(faceCount, 1,0,0,0))\r\r\n            facePointList.append(mesh.PointAt(faceCount, 0,1,0,0))\r\r\n            facePointList.append(mesh.PointAt(faceCount, 0,0,1,0))\r\r\n            facePointList.append(mesh.PointAt(faceCount, 0,0,0,1))\r\r\n        else:\r\r\n            faceColorList.append(meshColors[face.A])\r\r\n            faceColorList.append(meshColors[face.B])\r\r\n            faceColorList.append(meshColors[face.C])\r\r\n            \r\r\n            facePointList.append(mesh.PointAt(faceCount, 1,0,0,0))\r\r\n            facePointList.append(mesh.PointAt(faceCount, 0,1,0,0))\r\r\n            facePointList.append(mesh.PointAt(faceCount, 0,0,1,0))\r\r\n        \r\r\n        #Calculate the average color of the face.\r\r\n        if face.IsQuad:\r\r\n            hatchColorR = (faceColorList[0].R + faceColorList[1].R + faceColorList[2].R + faceColorList[3].R) / 4\r\r\n            hatchColorG = (faceColorList[0].G + faceColorList[1].G + faceColorList[2].G + faceColorList[3].G) / 4\r\r\n            hatchColorB = (faceColorList[0].B + faceColorList[1].B + faceColorList[2].B + faceColorList[3].B) / 4\r\r\n        else:\r\r\n            hatchColorR = (faceColorList[0].R + faceColorList[1].R + faceColorList[2].R) / 3\r\r\n            hatchColorG = (faceColorList[0].G + faceColorList[1].G + faceColorList[2].G) / 3\r\r\n            hatchColorB = (faceColorList[0].B + faceColorList[1].B + faceColorList[2].B) / 3\r\r\n        hatchColor = System.Drawing.Color.FromArgb(255, hatchColorR, hatchColorG, hatchColorB)\r\r\n        \r\r\n        #Create the outline of a new hatch.\r\r\n        hatchCurveInit = Rhino.Geometry.PolylineCurve(facePointList)\r\r\n        if face.IsQuad: hatchExtra = Rhino.Geometry.LineCurve(facePointList[0], facePointList[3])\r\r\n        else: hatchExtra = Rhino.Geometry.LineCurve(facePointList[0], facePointList[2])\r\r\n        hatchCurve = Rhino.Geometry.Curve.JoinCurves([hatchCurveInit, hatchExtra], sc.doc.ModelAbsoluteTolerance)[0]\r\r\n        \r\r\n        #Create the hatch.\r\r\n        try:\r\r\n            if hatchCurve.IsPlanar():\r\r\n                meshFaceHatch = Rhino.Geometry.Hatch.Create(hatchCurve, 0, 0, 0)[0]\r\r\n                hatches.append(meshFaceHatch)\r\r\n                colors.append(hatchColor)\r\r\n            else:\r\r\n                #We have to split the quad face into two triangles.\r\r\n                hatchCurveInit1 = Rhino.Geometry.PolylineCurve([facePointList[0], facePointList[1], facePointList[2]])\r\r\n                hatchExtra1 = Rhino.Geometry.LineCurve(facePointList[0], facePointList[2])\r\r\n                hatchCurve1 = Rhino.Geometry.Curve.JoinCurves([hatchCurveInit1, hatchExtra1], sc.doc.ModelAbsoluteTolerance)[0]\r\r\n                meshFaceHatch1 = Rhino.Geometry.Hatch.Create(hatchCurve1, 0, 0, 0)[0]\r\r\n                hatchCurveInit2 = Rhino.Geometry.PolylineCurve([facePointList[2], facePointList[3], facePointList[0]])\r\r\n                hatchExtra2 = Rhino.Geometry.LineCurve(facePointList[2], facePointList[0])\r\r\n                hatchCurve2 = Rhino.Geometry.Curve.JoinCurves([hatchCurveInit2, hatchExtra2], sc.doc.ModelAbsoluteTolerance)[0]\r\r\n                meshFaceHatch2 = Rhino.Geometry.Hatch.Create(hatchCurve2, 0, 0, 0)[0]\r\r\n                \r\r\n                hatches.extend([meshFaceHatch1, meshFaceHatch2])\r\r\n                colors.extend([hatchColor, hatchColor])\r\r\n        except:pass\r\r\n        \r\r\n    return hatches, colors\r\r\n\r\r\ndef bakeText(_txt, _txtLocation, _layer, _txtSize=1, _neighbors=[], _avoidCollisions=False):\r\r\n    \"\"\"Bakes some Text to the Rhino scene\r\r\n    \r\r\n    _txt: <String> The actual text / note to bake\r\r\n    _txtLocation: <Point3D> The reference point  / location for the object\r\r\n    _layer: <String> The layer to bake the object to\r\r\n    _txtSize: <Float> The size of the text (height). Refers to the Annotation scale of the Page being printed\r\r\n    _neighbors: <List> The other text tags being printed\r\r\n    \"\"\"\r\r\n    # https://developer.rhino3d.com/api/RhinoCommon/html/T_Rhino_Geometry_TextEntity.htm\r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    \r\r\n    # The baseplane for the Text\r\r\n    origin = _txtLocation\r\r\n    basePlane_origin = Rhino.Geometry.Point3d(origin)\r\r\n    basePlan_normal = Rhino.Geometry.Vector3d(0,0,1) # Assumes Top View\r\r\n    basePlane = Rhino.Geometry.Plane(origin=basePlane_origin, normal=basePlan_normal)\r\r\n    \r\r\n    # Create the txt object\r\r\n    txt = Rhino.Geometry.TextEntity()\r\r\n    txt.Text = _txt\r\r\n    txt.Plane = basePlane\r\r\n    txt.TextHeight = _txtSize\r\r\n    txt.Justification = Rhino.Geometry.TextJustification.MiddleCenter\r\r\n    \r\r\n    if _avoidCollisions:\r\r\n        # Test against the other text items on the sheet\r\r\n        # First, find / create the bouding box rectangle of the text note\r\r\n        thisBB = txt.GetBoundingBox(txt.Plane)\r\r\n        boxXdim = abs(thisBB.Min.X - thisBB.Max.X)\r\r\n        boxYdim = abs(thisBB.Min.Y - thisBB.Max.Y)\r\r\n        domainX = ghc.ConstructDomain( (boxXdim/2)*-1,  boxXdim/2) \r\r\n        domainY = ghc.ConstructDomain( (boxYdim/2)*-1,  boxYdim/2) \r\r\n        boundingRect = ghc.Rectangle(txt.Plane, domainX, domainY, 0).rectangle\r\r\n        \r\r\n        # Compare the current text note to the others already in the scene\r\r\n        # Move the current tag if neccessary\r\r\n        for eachNeighbor in _neighbors:\r\r\n            intersection = ghc.CurveXCurve(eachNeighbor, boundingRect)\r\r\n            if intersection.points != None:\r\r\n                neighbor = ghc.DeconstuctRectangle(eachNeighbor) # The overlapping textbox\r\r\n                neighborY = neighbor.Y # Returns a domain\r\r\n                #neighborY = abs(neighborY[0] - neighborY[1]) # Total Y distance\r\r\n                \r\r\n                neighborCP = neighbor.base_plane.Origin\r\r\n                thisCP = ghc.DeconstuctRectangle(boundingRect).base_plane.Origin\r\r\n                \r\r\n                if thisCP.Y > neighborCP.Y:\r\r\n                    # Move the tag 'up'\r\r\n                    neighborMaxY = neighborCP.Y + neighborY[1]\r\r\n                    thisMinY = thisCP.Y - (boxYdim/2)\r\r\n                    moveVector = Rhino.Geometry.Vector3d(0,neighborMaxY-thisMinY,0)\r\r\n                    boundingRect = ghc.Move(boundingRect, moveVector).geometry\r\r\n                else:\r\r\n                    # Move the tag 'down'\r\r\n                    neighborMinY = neighborCP.Y - neighborY[1]\r\r\n                    thisMaxY = thisCP.Y + (boxYdim/2)\r\r\n                    moveVector = Rhino.Geometry.Vector3d(0,neighborMinY-thisMaxY,0)\r\r\n                    boundingRect = ghc.Move(boundingRect, moveVector).geometry\r\r\n                \r\r\n                #Re-Set the text tag's origin to the new location\r\r\n                txt.Plane = ghc.DeconstuctRectangle(boundingRect).base_plane\r\r\n    else:\r\r\n        boundingRect = None\r\r\n    \r\r\n    # Add the new text object to the Scene\r\r\n    txtObj = Rhino.RhinoDoc.ActiveDoc.Objects.AddText(txt)\r\r\n    \r\r\n    # Set the new Text's Layer\r\r\n    if not rs.IsLayer(_layer):\r\r\n        rs.AddLayer(_layer)\r\r\n    rs.ObjectLayer(txtObj, _layer)\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n    \r\r\n    return boundingRect # Return the text bounding box\r\r\n\r\r\ndef bakeObject(_obj, _attrs, _layer):\r\r\n    \"\"\" Takes in an obj and bakes to a Layer\r\r\n    \r\r\n    If the Object is a Mesh, will bake that using the Mesh's Vertex Colors. To \r\r\n    set these, use the Grasshopper MeshColor component (ghc.MeshColours() ) before\r\r\n    inputting here.\r\r\n    \r\r\n    If its a Curve input, will try and look for Attribute information in the\r\r\n    _geomAttributes input.\r\r\n    \r\r\n    If its some other type of geometry, will just use a default attribute for printing.\r\r\n    \"\"\"\r\r\n    doc_object = rs.coercerhinoobject(_obj, True, True)\r\r\n    geometry = doc_object.Geometry\r\r\n    \r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    layerT = Rhino.RhinoDoc.ActiveDoc.Layers #layer table\r\r\n    \r\r\n    if rs.IsMesh(geometry):\r\r\n        # Find the targer layer index\r\r\n        parentLayerIndex = Rhino.DocObjects.Tables.LayerTable.FindByFullPath(layerT, _layer, True)\r\r\n        \r\r\n        # Create a hatch from the mesh\r\r\n        guids = []\r\r\n        hatches, colors = mesh2Hatch(geometry)\r\r\n        \r\r\n        # Bake the Hatches into the Rhino Doc\r\r\n        for count, hatch in enumerate(hatches):\r\r\n            attr = Rhino.DocObjects.ObjectAttributes()\r\r\n            attr.LayerIndex = parentLayerIndex\r\r\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\r\r\n            attr.ObjectColor = colors[count]\r\r\n            attr.DisplayOrder = -1 # 1 = Front, -1 = Back\r\r\n            \r\r\n            guids.append(Rhino.RhinoDoc.ActiveDoc.Objects.AddHatch(hatch, attr))\r\r\n        \r\r\n        # Group the hatches so are manageable\r\r\n        groupT = Rhino.RhinoDoc.ActiveDoc.Groups\r\r\n        Rhino.DocObjects.Tables.GroupTable.Add(groupT, guids)\r\r\n        sc.doc.Views.Redraw()\r\r\n    \r\r\n    elif geometry.GetType() == Rhino.Geometry.PolylineCurve or geometry.GetType() == Rhino.Geometry.Curve:\r\r\n        # If its a curve, use the input User Determined Attributes\r\r\n        \r\r\n        # Check that the input is a good ObjectAttributes Object\r\r\n        if type(_attrs) is Rhino.DocObjects.ObjectAttributes:\r\r\n            attr = _attrs \r\r\n        else:\r\r\n            doc_object.Attributes\r\r\n        \r\r\n        rhino_geom = sc.doc.Objects.Add(geometry, attr)\r\r\n        \r\r\n        # Set the new Object's Layer\r\r\n        if not rs.IsLayer(_layer):\r\r\n            rs.AddLayer(_layer)\r\r\n        rs.ObjectLayer(rhino_geom, _layer)\r\r\n    \r\r\n    else:\r\r\n        # Just bake the regular Geometry with default attributes\r\r\n        rhino_geom = sc.doc.Objects.Add(geometry, doc_object.Attributes)\r\r\n        \r\r\n        # Set the new Object's Layer\r\r\n        if not rs.IsLayer(_layer):\r\r\n            rs.AddLayer(_layer)\r\r\n        rs.ObjectLayer(rhino_geom, _layer)\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n\r\r\ndef setOutputLayerVis(_detailViewLayers=[], _udLayersOn=[]):\r\r\n    # Turn all Layer Visibilities 'Off' except for the designeted layers\r\r\n    \r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    layers = rs.LayerNames()\r\r\n    allLayersOn = _detailViewLayers + _udLayersOn # All the Page's DetailView Layers, as well we as the User Determined 'On'\r\r\n    allLayersOn.append(str(Rhino.RhinoDoc.ActiveDoc.Layers.CurrentLayer)) # Add in the Current Active Layer\r\r\n    \r\r\n    print 'Turning on layers: {}'.format(allLayersOn)\r\r\n    print '----'\r\r\n    \r\r\n    # Record the Starting State\r\r\n    layerVisibilites = [] # True/False record (for resetting when done)\r\r\n    for layer in layers:\r\r\n        layerVisibilites.append( rs.LayerVisible(layer) )\r\r\n    \r\r\n    # Set layers 'off' if they aren't on the list to stay on\r\r\n    for layer in layers:\r\r\n        #if list(layer.Split(\":\"))[-1] not in allLayersOn:\r\r\n        if layer in allLayersOn:\r\r\n            rs.LayerVisible(layer,True)\r\r\n        else:\r\r\n            rs.LayerVisible(layer, False)\r\r\n    \r\r\n    Rhino.RhinoDoc.ActiveDoc.Views.RedrawEnabled = True\r\r\n    Rhino.RhinoDoc.ActiveDoc.Views.Redraw()\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n    \r\r\n    return layerVisibilites\r\r\n\r\r\ndef createTempLayer():\r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    \r\r\n    # Create an Unused Layer Name\r\r\n    layer_name = sc.doc.Layers.GetUnusedLayerName(False)\r\r\n    \r\r\n    # Add a new Layer to the Document\r\r\n    layer_index = sc.doc.Layers.Add(layer_name, System.Drawing.Color.Black)\r\r\n    \r\r\n    if layer_index<0:\r\r\n        print \"Unable to add {} layer.\".format(layer_name)\r\r\n    else:\r\r\n        print \"Added Layer: '{}' \".format(layer_name)\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n    \r\r\n    return layer_name\r\r\n\r\r\ndef removeTempLayer(_tmpLayerName):\r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    \r\r\n    # Be sure the temp layer exists?\r\r\n    if _tmpLayerName in rs.LayerNames():\r\r\n        print \"Removing Layer: '{}'\".format(_tmpLayerName)\r\r\n        tmpLayer = sc.doc.Layers.FindName(_tmpLayerName)\r\r\n        sc.doc.Layers.Delete(tmpLayer)\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n\r\r\ndef allLayersReset(_layerVisSettings):\r\r\n    # Reset all the Layer Vis settings to the original State\r\r\n    \r\r\n    sc.doc=Rhino.RhinoDoc.ActiveDoc\r\r\n    \r\r\n    currentLayer = Rhino.RhinoDoc.ActiveDoc.Layers.CurrentLayer\r\r\n    layers = rs.LayerNames()\r\r\n    for i in range(len(layers)):\r\r\n        #print layers[i], _layerVisSettings[i]\r\r\n        rs.LayerVisible(layers[i],_layerVisSettings[i])\r\r\n    Rhino.RhinoDoc.ActiveDoc.Views.RedrawEnabled = True\r\r\n    Rhino.RhinoDoc.ActiveDoc.Views.Redraw()\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n\r\r\ndef createSinglePDF(_view, _saveFolder, _fileName):\r\r\n    # Takes in a RhinoView and Exports it to PDF\r\r\n    \r\r\n    subFolder = '' #'\\Exports\\\\'\r\r\n    outputFolderPath = '{}{}'.format( _saveFolder, subFolder )\r\r\n    \r\r\n    if outputFolderPath[-1]=='\\\\':\r\r\n        pass\r\r\n    else:\r\r\n        outputFolderPath = outputFolderPath + '\\\\'\r\r\n    \r\r\n    # If the folder doesn't already exist, create it\r\r\n    if os.path.exists(os.path.dirname(outputFolderPath)) == False:\r\r\n        print 'Creating the folder: {}'.format(outputFolderPath) \r\r\n        os.makedirs(os.path.dirname(outputFolderPath))\r\r\n    else:\r\r\n        pass\r\r\n    \r\r\n    # Layout Page Size in Layout's Units\r\r\n    pageHeight = sc.doc.Views.ActiveView.PageHeight\r\r\n    pageWidth = sc.doc.Views.ActiveView.PageWidth\r\r\n    \r\r\n    # Layout Page Size in Inches\r\r\n    # Ref: https://developer.rhino3d.com/api/RhinoScriptSyntax/#document-UnitScale\r\r\n    # Ref: https://developer.rhino3d.com/api/RhinoCommon/html/P_Rhino_RhinoDoc_PageUnitSystem.htm\r\r\n    pageUnitSysemNumber = rs.UnitSystem(in_model_units=False)\r\r\n    \r\r\n    pageHeight = pageHeight * rs.UnitScale(8, pageUnitSysemNumber) # Type 8 = Inches\r\r\n    pageWidth = pageWidth * rs.UnitScale(8, pageUnitSysemNumber)\r\r\n    pageHeight = round(pageHeight, 2)\r\r\n    pageWidth = round(pageWidth, 2)\r\r\n    \r\r\n    pdf = Rhino.FileIO.FilePdf.Create()\r\r\n    dpi = 300\r\r\n    size = System.Drawing.Size(pageWidth*dpi,pageHeight*dpi) # Should get this from the view?\r\r\n    settings = Rhino.Display.ViewCaptureSettings(_view, size, dpi)\r\r\n    settings.OutputColor = Rhino.Display.ViewCaptureSettings.ColorMode.DisplayColor\r\r\n    pdf.AddPage(settings)\r\r\n    \r\r\n    filePath = outputFolderPath + _fileName + '.pdf'\r\r\n    pdf.Write(filePath)\r\r\n\r\r\ndef setActiveViewByName(_targetViewName):\r\r\n    # https://developer.rhino3d.com/samples/rhinocommon/get-and-set-the-active-view/\r\r\n    \r\r\n    # active view and non-active view names\r\r\n    active_view_name = sc.doc.Views.ActiveView.ActiveViewport.Name\r\r\n    non_active_views = [(view.ActiveViewport.Name, view) for view in sc.doc.Views if view.ActiveViewport.Name != active_view_name]\r\r\n    \r\r\n    if _targetViewName != active_view_name:\r\r\n        if _targetViewName in [seq[0] for seq in non_active_views]:\r\r\n            sc.doc.Views.ActiveView = [seq[1] for seq in non_active_views if seq[0] == _targetViewName][0]\r\r\n            print \"Setting Active View to {}\".format(_targetViewName) \r\r\n        else:\r\r\n            warning = \"\\\"{0}\\\" is not a valid view name?\".format(_targetViewName) \r\r\n            ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n\r\r\ndef findAllDetailViewLayers():\r\r\n    # Goes to the Active Layer, looks to see if there are any DetailViews, \r\r\n    # If so, finds the Layer the DetailViews are on and adds the layerIndex to the list to keep 'on'\r\r\n    \r\r\n    layer_Names_ = []\r\r\n    layer_IDs_ = []\r\r\n    \r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    \r\r\n    active_view = sc.doc.Views.ActiveView  # .ActiveViewport.Name\r\r\n    detailViews = active_view.GetDetailViews()\r\r\n    for eachDtlView in detailViews:\r\r\n        layer_IDs_.append(eachDtlView.Attributes.LayerIndex)\r\r\n        #print 'View: \"{}\" has a DetailView: \"{}\" on LayerIndex: {}'.format(active_view.ActiveViewport.Name, eachDtlView, eachDtlView.Attributes.LayerIndex)\r\r\n    \r\r\n    # Find the right Layer Names from the Index vals\r\r\n    layer_IDs_ = list(set(layer_IDs_)) # Keep only one of each unique index val\r\r\n    \r\r\n    for i in range(len(layer_IDs_)):\r\r\n        layerPath = sc.doc.Layers[layer_IDs_[i]].FullPath # Get the Layer and any parents\r\r\n        layerNames = list(layerPath.Split(':'))\r\r\n        \r\r\n        for layerName in layerNames:\r\r\n            layer_Names_.append(layerPath)\r\r\n            layer_Names_.append(layerName)\r\r\n    \r\r\n    sc.doc = ghdoc\r\r\n    \r\r\n    print list(set(layer_Names_))\r\r\n    return list(set(layer_Names_))\r\r\n\r\r\n## Sort out the filenames to use for outputs\r\r\nif fileName_ and _geomToBake:\r\r\n    if len(fileName_) == _geomToBake.BranchCount:\r\r\n        fileNames = fileName_\r\r\n    else:\r\r\n        fileNames = []\r\r\n        for i in range(_geomToBake.BranchCount):\r\r\n            fileNames.append(\"{}_{:03d}\".format(fileName_[0], i+1).replace(\" \", \"_\")  )\r\r\nelif _geomToBake and not fileName_:\r\r\n    fileNames = []\r\r\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n    rhinoFileName =  sc.doc.Name.replace('.3dm', \"\") # Use the Rhino filename if none provided\r\r\n    sc.doc = ghdoc\r\r\n    \r\r\n    for i in range(_geomToBake.BranchCount): fileNames.append(\"{}_{:03d}\".format(rhinoFileName, i+1).replace(\" \", \"_\")  )\r\r\n\r\r\n## Bake all the objects and print to PDF\r\r\nif _print and _viewName and _saveFolder and _geomToBake:\r\r\n    setActiveViewByName(_viewName) # Set to the View to be exported\r\r\n    detailViewLayers = findAllDetailViewLayers() # Find the layers to leave on\r\r\n    \r\r\n    for branchNum, branch in enumerate(_geomToBake.Branches):\r\r\n        try: \r\r\n            udLayersOn = list(layersOn_.Branch(branchNum))\r\r\n        except:\r\r\n            try:\r\r\n                udLayersOn = list(layersOn_.Branch(0))\r\r\n            except:\r\r\n                udLayersOn = []\r\r\n                msg = 'No input in \"LayersOn_\" found? Turning all Rhino Scene layers off.'\r\r\n                ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, msg)\r\r\n        \r\r\n        layerVis = setOutputLayerVis(detailViewLayers, udLayersOn) # Turn off all the Layers (Except the Designated Layers)\r\r\n        \r\r\n        # Bake------\r\r\n        tempLayer_Notes = createTempLayer() \r\r\n        tempLayer_Geom = createTempLayer() # Create a temporary layer for the Baked Geometry\r\r\n        tempLayer_TitleBlock = createTempLayer() \r\r\n        setActiveViewByName('Top') # Change to 'Top' View for Baking\r\r\n        \r\r\n        # > Geometry\r\r\n        for i, geomGUID in enumerate(branch):\r\r\n            try:\r\r\n                geomAttrs = _geomAttributes.Branch(branchNum)[i]\r\r\n            except:\r\r\n                geomAttrs = None\r\r\n            bakeObject(geomGUID, geomAttrs, tempLayer_Geom) # Bake Geometry to the specified layer\r\r\n        \r\r\n        # > Notes\r\r\n        setActiveViewByName(_viewName) # Change to the Designated Output view/Page for Printing PDF\r\r\n        dtlViews = sc.doc.Views.ActiveView.GetDetailViews()\r\r\n        dtlViewTransforms = []\r\r\n        for eachView in dtlViews: dtlViewTransforms.append( eachView.WorldToPageTransform )\r\r\n        \r\r\n        if len(dtlViewTransforms)>1:\r\r\n            warning = \"Looks like there are two Detail Views on your Layout Page? This Probably will not work right with more than one view on a page.\"\r\r\n            ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n        \r\r\n        # > Find the note's Paperspace location\r\r\n        noteCP_transformed = []\r\r\n        if _noteLocations.BranchCount > 0:\r\r\n            for eachCP in _noteLocations.Branch(branchNum):\r\r\n                noteCP_transformed.append( ghc.Transform(eachCP, dtlViewTransforms[0]) )\r\r\n            \r\r\n            txtBoxes = [] # the note bounding boxes\r\r\n            for noteNum, eachNote in enumerate(_notesToBake.Branch(branchNum)):\r\r\n                txtBox = bakeText(_txt=eachNote,\r\r\n                        _txtLocation=noteCP_transformed[noteNum],\r\r\n                        _layer=tempLayer_Notes,\r\r\n                        _txtSize=float(noteTxtSize_),\r\r\n                        _neighbors=txtBoxes,\r\r\n                        _avoidCollisions=True)\r\r\n                txtBoxes.append( txtBox )\r\r\n        \r\r\n        # > Layout Page Titleblock Text Objects\r\r\n        if titleBlockTxtToBake_.BranchCount > 0:\r\r\n            for i, txtItem in enumerate( titleBlockTxtToBake_.Branch(branchNum) ):\r\r\n                bakeText(_txt = txtItem,\r\r\n                    _txtLocation = titleBlockTxtLocatons_.Branch(0)[i],\r\r\n                    _layer=tempLayer_TitleBlock,\r\r\n                    _txtSize=3.4,\r\r\n                    _avoidCollisions=False)\r\r\n        \r\r\n        # > Layout Page Table Objects\r\r\n        if _tablesToBake.BranchCount > 0:\r\r\n            for table in _tablesToBake.Branch(branchNum):\r\r\n                for k, cell in table.Cells.items():\r\r\n                    bakeText(_txt=str(cell.ValueFormated),\r\r\n                        _txtLocation=cell.Location,\r\r\n                        _layer=tempLayer_Notes,\r\r\n                        _txtSize=cell.TextHeight,\r\r\n                        _avoidCollisions=False)\r\r\n        \r\r\n        # > Export the PDF\r\r\n        createSinglePDF(sc.doc.Views.ActiveView, _saveFolder, fileNames[branchNum]) # Export to PDF\r\r\n        \r\r\n        # Delete the baked Geometry and the Temporary Layer(s)\r\r\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n        rs.DeleteObjects(rs.ObjectsByLayer(tempLayer_Geom))\r\r\n        rs.DeleteObjects(rs.ObjectsByLayer(tempLayer_Notes))\r\r\n        rs.DeleteObjects(rs.ObjectsByLayer(tempLayer_TitleBlock))\r\r\n        removeTempLayer(tempLayer_Geom)\r\r\n        removeTempLayer(tempLayer_Notes)\r\r\n        removeTempLayer(tempLayer_TitleBlock)\r\r\n        \r\r\n        # Turn all the Layers back to original Visibilities\r\r\n        allLayersReset(layerVis)\r\r\n        \r\r\n        sc.doc = ghdoc\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}