{
  "source_url": "https://github.com/Nihalmannath/Grounded-one_click_structural_solution/blob/94373d5c3a0ea210040d9de1195b23acb6fba0c2/Experiments/2/TERM%202/opensees_training.py",
  "repo": "Nihalmannath/Grounded-one_click_structural_solution",
  "repo_stars": 0,
  "repo_description": "Research studio/term_2",
  "license": "unknown",
  "filepath": "Experiments/2/TERM 2/opensees_training.py",
  "instruction": "Opensees training",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"Opensees training\n\nAutomatically generated by Colab.\n\nOriginal file is located at\n    https://colab.research.google.com/drive/1kyVMFqzJ3oWalbde9J-uLLzOuwcQWNvf\n\"\"\"\n\n\n\npip install rhino3dm\n\npip install openseespy\n\nimport rhino3dm\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\n\ndef get_all_edges(geometry):\n    \"\"\"\n    Extracts edges from Breps and Meshes, returning pairs of connected vertices.\n    \"\"\"\n    edges = []\n\n    for geom in geometry:\n        # Extract edges from Brep\n        if isinstance(geom, rhino3dm.Brep):\n            for edge in geom.Edges:\n                start = [edge.PointAtStart.X, edge.PointAtStart.Y, edge.PointAtStart.Z]\n                end = [edge.PointAtEnd.X, edge.PointAtEnd.Y, edge.PointAtEnd.Z]\n                edges.append([start, end])\n\n        # If it's a Mesh, extract edges by connecting vertices\n        elif isinstance(geom, rhino3dm.Mesh):\n            for i in range(geom.TopologyEdges.Count):\n                line = geom.TopologyEdges.EdgeLine(i)\n                start = [line.From.X, line.From.Y, line.From.Z]\n                end = [line.To.X, line.To.Y, line.To.Z]\n                edges.append([start, end])\n\n    return np.array(edges)\n\ndef add_structural_elements(edges):\n    \"\"\"\n    Adds columns at vertical edges and beams along all non-ground horizontal & tilted edges.\n    \"\"\"\n    columns = []\n    beams = []\n\n    # Find the lowest Z value (ground level)\n    z_values = [point[2] for edge in edges for point in edge]\n    ground_level = min(z_values) + 0.2  # Small buffer to avoid near-ground beams\n\n    for edge in edges:\n        start, end = edge\n        vector = np.array(end) - np.array(start)\n\n        # Identify columns (strictly vertical edges)\n        if abs(vector[0]) < 0.1 and abs(vector[1]) < 0.1:  # Vertical alignment check\n            columns.append(edge)\n\n        # Identify beams (non-vertical edges, excluding those near ground level)\n        elif abs(vector[2]) < 1.5 and start[2] > ground_level and end[2] > ground_level:\n            beams.append(edge)\n\n    return np.array(columns), np.array(beams)\n\n# Load the Rhino 3DM file\nfile_path = \"/content/basicformMETERS.3dm\"  # Update with your file path\n\ntry:\n    model = rhino3dm.File3dm.Read(file_path)\n    geometry = [obj.Geometry for obj in model.Objects if obj.Geometry is not None]\n\n    # Extract edges\n    edges = get_all_edges(geometry)\n\n    # Identify columns and beams\n    columns, beams = add_structural_elements(edges)\n\n    # Plot edges, columns, and beams in 3D\n    fig = plt.figure(figsize=(8, 8))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Convert edges to a format suitable for Line3DCollection\n    edge_lines = [np.array(edge) for edge in edges]\n    column_lines = [np.array(col) for col in columns]\n    beam_lines = [np.array(beam) for beam in beams]\n\n    # Add the original edges in black\n    ax.add_collection3d(Line3DCollection(edge_lines, colors='black', linewidths=1))\n\n    # Add columns in blue\n    ax.add_collection3d(Line3DCollection(column_lines, colors='blue', linewidths=2))\n\n    # Add beams in red (Now avoids beams near ground level)\n    ax.add_collection3d(Line3DCollection(beam_lines, colors='red', linewidths=2))\n\n    # Set axis labels\n    ax.set_xlabel('X Axis')\n    ax.set_ylabel('Y Axis')\n    ax.set_zlabel('Z Axis')\n    ax.set_title('3D Visualization with Columns (Blue) and Beams (Red, Above Ground)')\n\n    # Auto scale axes\n    all_points = edges.reshape(-1, 3)\n    ax.set_xlim([np.min(all_points[:, 0]), np.max(all_points[:, 0])])\n    ax.set_ylim([np.min(all_points[:, 1]), np.max(all_points[:, 1])])\n    ax.set_zlim([np.min(all_points[:, 2]), np.max(all_points[:, 2])])\n\n    plt.show()\n\nexcept Exception as e:\n    print(\"Error loading or processing the file:\", e)\n\nimport numpy as np\nimport pandas as pd\nimport openseespy.opensees as ops\n\n# For optional 3D plotting (if desired)\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 2.1 Read columns, beams, and all_edges DataFrames\ncolumns_df = pd.read_csv(r\"/content/columns.csv\")   # e.g. x_start, y_start, z_start, x_end, y_end, z_end\nbeams_df   = pd.read_csv(r\"/content/beams.csv\")     # same or similar format\nedges_df   = pd.read_csv(r\"/content/all_edges.csv\") # possibly the union or adjacency data\n\n# 2.2 Tag each entry to differentiate them if needed\ncolumns_df[\"type\"] = \"column\"\nbeams_df[\"type\"]   = \"beam\"\nedges_df[\"type\"]   = \"edge\"  # if itâ€™s purely adjacency or combined edges\n\ncombined_df = pd.concat([columns_df, beams_df, edges_df], ignore_index=True)\n\nnode_map = {}  # (x, y, z) -> node_id\nnext_node_id = 1\n\nfor _, row in combined_df.iterrows():\n    coord_start = (row[\"start_x\"], row[\"start_y\"], row[\"start_z\"])\n    coord_end   = (row[\"end_x\"], row[\"end_y\"], row[\"end_z\"])\n\n    if coord_start not in node_map:\n        node_map[coord_start] = next_node_id\n        next_node_id += 1\n    if coord_end not in node_map:\n        node_map[coord_end] = next_node_id\n        next_node_id += 1\n\n# Store the node IDs in the DataFrame for convenience\ncombined_df[\"startNode\"] = combined_df.apply(\n    lambda r: node_map[(r[\"start_x\"], r[\"start_y\"], r[\"start_z\"])],\n    axis=1\n)\ncombined_df[\"endNode\"] = combined_df.apply(\n    lambda r: node_map[(r[\"end_x\"], r[\"end_y\"], r[\"end_z\"])],\n    axis=1\n)\n\nops.wipe()\nops.model(\"basic\", \"-ndm\", 3, \"-ndf\", 6)  # 3D model, 6 DOFs per node\n\nnode_map = {}  # (x, y, z) -> node_id\nnext_node_id = 1\n\nfor coord, node_id in node_map.items():\n    (x, y, z) = coord\n    ops.node(node_id, x, y, z)\n\n# Example boundary condition: fix all nodes where z ~ 0\nfor coord, node_id in node_map.items():\n    x, y, z = coord\n    if abs(z) < 1e-8:\n        ops.fix(node_id, 1,1,1,1,1,1)  # fully fixed\n\nE  = 2.1e11     # Young's modulus (Pa)\nG  = 8.0769e10  # Shear modulus\nA  = 0.02       # Cross-sectional area (m^2)\nIz = 8.3e-5     # Moment of inertia about z\nIy = 4.2e-5     # Moment of inertia about y\nJ  = 1.0e-4     # Torsional inertia\n\n# Example transformation (3D)\ntransfTag = ops.geomTransf(\"Linear\", 1, 0, 0, 0, 1, 0)  # local y or z axis vector, etc.\n\n# Create a copy so we don't alter combined_df in-place\ndf_copy = combined_df.copy()\n\n# Force each row to store (min_node, max_node) to unify duplicates\ndf_copy[[\"startNode\", \"endNode\"]] = df_copy.apply(\n    lambda r: pd.Series(sorted((r[\"startNode\"], r[\"endNode\"]))),\n    axis=1\n)\n\n# Now drop duplicates on the sorted pairs\nunique_df = df_copy.drop_duplicates(subset=[\"startNode\", \"endNode\"])\n\nelemTag = 1\nfor idx, row in combined_df.iterrows():\n    start_id = int(row[\"startNode\"])\n    end_id   = int(row[\"endNode\"])\n\n    # Decide section properties based on type\n    if row[\"type\"] == \"column\":\n        # For instance, a column might have a different cross-section\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n    elif row[\"type\"] == \"beam\":\n        # Another approach for beams\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n    else:\n        # If \"edge\" is something generic (like a bracing?), treat it similarly\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n\n    elemTag += 1\n\n# 5.1 Time series & load pattern\nops.timeSeries(\"Constant\", 1)\nops.pattern(\"Plain\", 1, 1)\n\ngravity = -9.81  # negative z direction, if Z is vertical\nmass_per_node = 1000.0  # example (kg) or (mass units), adjust to your model scale\n\nfor coord, node_id in node_map.items():\n    # Assign mass in all translational DOFs\n    # mass = [mX, mY, mZ, rX, rY, rZ] for a 3D problem if needed\n    # We'll just do translational:\n    ops.mass(node_id, mass_per_node, mass_per_node, mass_per_node, 0.0, 0.0, 0.0)\n\n# Apply gravity as acceleration load\nops.loadConst('-time', 0.0)  # This finalizes the mass assignment\n\nops.system(\"BandGeneral\")\nops.numberer(\"RCM\")\nops.constraints(\"Plain\")\nops.test(\"NormUnbalance\", 1e-6, 10)\nops.algorithm(\"Newton\")\nops.integrator(\"LoadControl\", 1.0)\nops.analysis(\"Static\")\n\n# In OpenSees, you can set the gravity factor:\nops.record()  # optional, if you want to record data\nops.setTime(0.0)\nops.analyze(1)  # single step\n\n# Print reactions for nodes at base (z=0).\nfor coord, node_id in node_map.items():\n    if abs(coord[2]) < 1e-8:\n        rxn = ops.nodeReaction(node_id)\n        print(f\"Node {node_id} at {coord}, Reaction = {rxn}\")\n\ndef plot_deformed_3d(scale=1.0):\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Original vs. deformed coords\n    deformed_coords = {}\n    for (x,y,z), nd_id in node_map.items():\n        disp = ops.nodeDisp(nd_id)\n        dx, dy, dz = disp[0], disp[1], disp[2]  # 3D translations\n        deformed_coords[nd_id] = (x + scale*dx, y + scale*dy, z + scale*dz)\n\n    # Plot elements\n    elemTag = 1\n    for idx, row in combined_df.iterrows():\n        ndI = int(row[\"startNode\"])\n        ndJ = int(row[\"endNode\"])\n        if ndI in deformed_coords and ndJ in deformed_coords:\n            xI, yI, zI = deformed_coords[ndI]\n            xJ, yJ, zJ = deformed_coords[ndJ]\n            ax.plot([xI, xJ], [yI, yJ], [zI, zJ], color=\"red\")\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n    ax.set_title(f\"Deformed Shape (scale={scale})\")\n    plt.show()\n\n# Plot with an arbitrary scale factor\nplot_deformed_3d(scale=50.0)\n\nimport numpy as np\nimport pandas as pd\nimport openseespy.opensees as ops\n\n# For plotting and animation\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.animation as animation\n\n# --------------------------------------------------------------\n# 0. Assume you have already:\n#    - Created nodes (ops.node(...))\n#    - Defined elements (ops.element(...))\n#    - Assigned loads or masses\n#    - Performed static analysis ops.analyze(...)\n# --------------------------------------------------------------\n\n# node_map:  (x, y, z) -> nodeID\n# Invert it to get nodeID -> (x, y, z)\nnode_coords = {}\nfor coord, nID in node_map.items():\n    node_coords[nID] = coord\n\ndisplacements = {}\nfor nID in node_coords.keys():\n    # ops.nodeDisp(nID) -> array [uX, uY, uZ, rX, rY, rZ] in 3D\n    disp = ops.nodeDisp(nID)\n    displacements[nID] = disp  # store entire array if you like\n\ndef init():\n    # Usually you can return an empty iterable or\n    # set up lines in their initial positions (scale=0).\n    # We'll do the latter so it starts from undeformed.\n    for (line, start_id, end_id) in lines:\n        (x0, y0, z0) = node_coords[start_id]\n        (x1, y1, z1) = node_coords[end_id]\n        line.set_data_3d([x0, x1], [y0, y1], [z0, z1])\n    return [l[0] for l in lines]\n\ndef animate(i):\n    # i runs from 0..(nFrames-1). Let's vary scale from 0..maxScale\n    nFrames = 30  # or however many frames you want\n    scale = (i / (nFrames - 1)) * maxScale\n\n    # Update each line\n    for (line, start_id, end_id) in lines:\n        (x0, y0, z0) = node_coords[start_id]\n        (x1, y1, z1) = node_coords[end_id]\n\n        # Node displacements\n        dx0, dy0, dz0 = displacements[start_id][0:3]\n        dx1, dy1, dz1 = displacements[end_id][0:3]\n\n        # Deformed coords\n        x0_def = x0 + scale * dx0\n        y0_def = y0 + scale * dy0\n        z0_def = z0 + scale * dz0\n        x1_def = x1 + scale * dx1\n        y1_def = y1 + scale * dy1\n        z1_def = z1 + scale * dz1\n\n        # Update line data\n        # In 3D, we do:\n        line.set_data_3d([x0_def, x1_def],\n                         [y0_def, y1_def],\n                         [z0_def, z1_def])\n\n    # Return updated artists\n    return [l[0] for l in lines]\n\n# Optionally compute min/max for x,y,z from the original node_coords\nxs = [c[0] for c in node_coords.values()]\nys = [c[1] for c in node_coords.values()]\nzs = [c[2] for c in node_coords.values()]\n\nx_min, x_max = min(xs), max(xs)\ny_min, y_max = min(ys), max(ys)\nz_min, z_max = min(zs), max(zs)\n\n# Expand a bit:\nax.set_xlim([x_min - 1, x_max + 1])\nax.set_ylim([y_min - 1, y_max + 1])\nax.set_zlim([z_min - 1, z_max + 1])\n\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nax.set_zlabel(\"Z\")\nax.set_title(\"Animated Deformed Shape\")\n\nfrom matplotlib.animation import FuncAnimation\n\nnFrames = 30  # or however many steps you want\nanim = FuncAnimation(\n    fig,\n    animate,\n    init_func=init,\n    frames=nFrames,\n    interval=400,  # milliseconds between frames\n    blit=True  # advanced: can speed up rendering\n)\n\nplt.show()\n\nanim.save(\"deformed_animation.gif\", writer=\"imagemagick\", fps=5)\n# or\n# anim.save(\"deformed_animation.mp4\", writer=\"ffmpeg\", fps=5)\n\nfrom openseespy.opensees import *\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ------------------------------\n# Start of model generation\n# -----------------------------\n\n# remove existing model\nwipe()\n\n# set modelbuilder\nmodel('basic', '-ndm', 2, '-ndf', 2)\n\n# create nodes\nnode(1, 0.0, 0.0)\nnode(2, 144.0,  0.0)\nnode(3, 168.0,  0.0)\nnode(4,  72.0, 96.0)\n\n# set boundary condition\nfix(1, 1, 1)\nfix(2, 1, 1)\nfix(3, 1, 1)\n\n# define materials\nuniaxialMaterial(\"Elastic\", 1, 3000.0)\n\n# define elements\nelement(\"Truss\",1,1,4,10.0,1)\nelement(\"Truss\",2,2,4,5.0,1)\nelement(\"Truss\",3,3,4,5.0,1)\n\n# create TimeSeries\ntimeSeries(\"Linear\", 1)\n\n# create a plain load pattern\npattern(\"Plain\", 1, 1)\n\n# Create the nodal load - command: load nodeID xForce yForce\nload(4, 100.0, -50.0)\n\n# ------------------------------\n# Start of analysis generation\n# ------------------------------\n\n# create SOE\nsystem(\"BandSPD\")\n\n# create DOF number\nnumberer(\"RCM\")\n\n# create constraint handler\nconstraints(\"Plain\")\n\n# create integrator\nintegrator(\"LoadControl\", 1.0)\n\n# create algorithm\nalgorithm(\"Linear\")\n\n# create analysis object\nanalysis(\"Static\")\n\n# perform the analysis\nanalyze(1)\n\nux = nodeDisp(4,1)\nuy = nodeDisp(4,2)\nif abs(ux-0.53009277713228375450)<1e-12 and abs(uy+0.17789363846931768864)<1e-12:\n    print(\"Passed!\")\nelse:\n    print(\"Failed!\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}