{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Create%20Therm%20Polygons.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Create Therm Polygons.py",
  "instruction": "Use this component to create a THERM polygon with material properties.\n-\nProvided by Honeybee 0.0.66",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to create a THERM polygon with material properties.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _geometry: A closed planar curve or list of closed planar curves that represent the portions of a construction that have the same material type.  This input can also accept closed planar surfaces/breps/polysurfaces and even meshes!\n        _material: Either the name of an EnergyPlus material from the OpenStudio library (from the \"Call from EP Construction Library\" component) or the output of any of the components in the \"06 | Energy | Material\" tab for creating materials.\n        RGBColor_: An optional color to set the color of the material when you import it into THERM.  All materials from the Honyebee Therm Library already possess colors but materials from the EP material lib will have a default blue color if no one is assigned here.\n    Returns:\n        readMe!:...\n        thermPolygon: A polygon representing material properties\n\"\"\"\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport uuid\nimport decimal\n\nghenv.Component.Name = 'Honeybee_Create Therm Polygons'\nghenv.Component.NickName = 'createThermPolygons'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"11 | THERM\"\n#compatibleHBVersion = VER 0.0.56\\nMAY_08_2017\n#compatibleLBVersion = VER 0.0.59\\nNOV_07_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\n\ntolerance = sc.doc.ModelAbsoluteTolerance\nw = gh.GH_RuntimeMessageLevel.Warning\ne = gh.GH_RuntimeMessageLevel.Error\n\ndef getSrfCenPtandNormal(surface):\n    brepFace = surface.Faces[0]\n    u_domain = brepFace.Domain(0)\n    v_domain = brepFace.Domain(1)\n    centerU = (u_domain.Min + u_domain.Max)/2\n    centerV = (v_domain.Min + v_domain.Max)/2\n    \n    centerPt = brepFace.PointAt(centerU, centerV)\n    normalVector = brepFace.NormalAt(centerU, centerV)\n    \n    return centerPt, normalVector\n\n\ndef main(geometry, material, RGBColor):\n    # import the classes\n    hb_thermPolygon = sc.sticky[\"honeybee_ThermPolygon\"]\n    hb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\n    thermDefault = sc.sticky[\"honeybee_ThermDefault\"]()\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    \n    #Define a varialbe for acceptable geometry.\n    geometryAccepted = False\n    \n    # if the input is mesh, convert it to a surface\n    try:\n        # check if this is a mesh\n        geometry.Faces[0].IsQuad\n        # convert to brep\n        geometry = rc.Geometry.Brep.CreateFromMesh(geometry, False)\n        geometryAccepted = True\n    except:\n        pass\n    \n    #If the input is a polyline, convert it to a surface.\n    try:\n        geometry = rc.Geometry.Brep.CreatePlanarBreps(geometry)\n        if len(geometry) == 1:\n            geometryAccepted = True\n            geometry = geometry[0]\n        else:\n            warning = \"The connected polyline geometry does not form a single closed planar surface. \\n Try joining the curves into a single polyline before inputting them.\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n    except:\n        pass\n    \n    #If the input has failed all tests up to this point, it is hopefully a planar brep or surface and we will just check this.\n    if geometryAccepted == False:\n        try:\n            geometry.IsSurface\n            geometryAccepted = True\n        except: pass\n        try:\n            if geometry.HasBrepForm: geometry = geometry.ToBrep()\n            geometryAccepted = True\n        except: pass\n    \n    #If the geometry was not recognized, give a warning.\n    if geometryAccepted == False:\n        warning = \"The connected geometry was not recognized as a polyline, surface, brep/polysurface, or mesh.\"\n        print warning\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    #Make a list to hold the final outputs.\n    HBThermPolygons = []\n    \n    for faceCount in range(geometry.Faces.Count):\n        #Check to be sure that the surface is planar.\n        polyPlane = None\n        if geometry.Faces[faceCount].IsPlanar(sc.doc.ModelAbsoluteTolerance):\n            centPt, normal = getSrfCenPtandNormal(geometry)\n            plane = rc.Geometry.Plane(centPt, normal)\n        else:\n            warning = \"The connected surface geometry is not planar.\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        \n        #Assign a material\n        if material!=None:\n            # if it is just the name of the material make sure it is already defined\n            if material.startswith(\"<Material\"):\n                #Its a full string of a custom THERM material.\n                material = thermDefault.addThermMatToLib(material)\n            elif len(material.split(\"\\n\")) == 1:\n                #Its the name of a material.\n                material = material.upper()\n                if material in sc.sticky [\"honeybee_materialLib\"].keys(): pass\n                elif material in sc.sticky [\"honeybee_windowMaterialLib\"].keys():pass\n                elif material in sc.sticky[\"honeybee_thermMaterialLib\"].keys():pass\n                else:\n                    warningMsg = \"Can't find \" + material + \" in EP Material Library.\\n\" + \\\n                                \"Create the material and try again.\"\n                    print warningMsg\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warningMsg)\n                    return -1\n            # if the material is not in the library add it to the library\n            else:\n                # it is a full string of an EP material.\n                added, material = hb_EPMaterialAUX.addEPConstructionToLib(material, overwrite = True)\n                material = material.upper()\n                \n                if not added:\n                    msg = material + \" is not added to the project library!\"\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n                    print msg\n                    return -1\n        \n        #Make the therm polygon.\n        guid = str(uuid.uuid4())\n        polyName = \"\".join(guid.split(\"-\")[:-1])\n        HBThermPolygon = hb_thermPolygon(geometry.Faces[faceCount].DuplicateFace(False), material, polyName, plane, RGBColor, ghenv)\n        \n        if HBThermPolygon.warning != None:\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, HBThermPolygon.warning)\n        \n        HBThermPolygons.append(HBThermPolygon)\n    \n    # add to the hive\n    HBThermPolygon  = hb_hive.addToHoneybeeHive(HBThermPolygons, ghenv.Component)\n    \n    return HBThermPolygon\n\n\n#Honeybee check.\ninitCheck = True\nif not sc.sticky.has_key('honeybee_release') == True:\n    initCheck = False\n    print \"You should first let Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee fly...\")\nelse:\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): initCheck = False\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n#If the Rhino model tolerance is not fine enough for THERM modelling, give a warning.\nif initCheck == True:\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    conversionFactor = lb_preparation.checkUnits()*1000\n    d = decimal.Decimal(str(sc.doc.ModelAbsoluteTolerance))\n    numDecPlaces = abs(d.as_tuple().exponent)\n    numConversionFacPlaces = len(list(str(int(conversionFactor))))-1\n    numDecPlaces = numDecPlaces - numConversionFacPlaces\n    if numDecPlaces < 2:\n        zeroText = ''\n        for val in range(abs(2-numDecPlaces)): zeroText = zeroText + '0'\n        correctDecimal = '0.' + zeroText + str(sc.doc.ModelAbsoluteTolerance).split('.')[-1]\n        warning = \"Your Rhino model tolerance is coarser than the default tolerance for THERM. \\n It is recommended that you decrease your Rhino model tolerance to \" + correctDecimal + \" \" + str(sc.doc.ModelUnitSystem) + \" \\n by typing 'units' in the Rhino command bar and adding decimal places to the 'tolerance'.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\nif initCheck == True and _geometry != None and _material != None:\n    result= main(_geometry, _material, RGBColor_)\n    \n    if result!=-1:\n        thermPolygon = result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}