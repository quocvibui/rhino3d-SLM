{
  "source_url": "https://github.com/le-ar-n/le-ar-n/blob/64600ee3bbe7e42f87f28442923b216cc565cf24/code/02_geometry/libraries/geometry/frame.py",
  "repo": "le-ar-n/le-ar-n",
  "repo_stars": 9,
  "repo_description": null,
  "license": "unknown",
  "filepath": "code/02_geometry/libraries/geometry/frame.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 14.09.2016\n\n@authors: rust & dorf\n'''\n\n\n# =================================================================================    \n# this import is only necessary if you execute the file outside of Rhino or Grasshopper\n# =================================================================================    \nimport sys\nimport clr\nimport System\nimport copy\n\nsys.path.append(r\"C:\\Program Files\\Rhinoceros 5 (64-bit)\\System\")\nclr.AddReference('RhinoCommon') \n# ================================================================================= \n\nimport Rhino.Geometry as rg\nimport math  \n\n\nclass Frame():\n    \n    def __init__(self, plane = None, draw_geo = False):\n        '''\n        The class \"Frame\" is initialized with a Rhino plane.\n        It is a generic class, that allows to derive the euler angles (Kuka), axis angle (UR), or quaternions (ABB) from this plane,\n        the transformation matrix to and from another plane, and also contains some transformation methods.\n        If no plane is given as an input, the origin of the plane is in world XY.\n        If draw_geo is set to true: the axes can be visualized as lines (length = 100)\n        \n        quaternion definition: [qw, qx, qy, qz]\n        angle_axis definition: [ax,ay,az] (angle = length of the vector, axis = vector)\n        '''       \n        self.draw_geo = draw_geo\n        if plane:\n            self.set_to_plane(plane)\n        else:\n            self.set_to_worldXY()\n                \n    def update_geo(self, plane):\n        '''\n        updates geometry for the axes if draw_geo == True \n        '''\n        if self.draw_geo:\n            self.x_axis = rg.Line(plane.Origin, plane.XAxis*100)\n            self.y_axis = rg.Line(plane.Origin, plane.YAxis*100)\n            self.z_axis = rg.Line(plane.Origin, plane.ZAxis*100)     \n            self.frame_geo = [self.x_axis, self.y_axis, self.z_axis]\n    \n    def get_axes_as_lines(self, length = 100):\n        '''\n        returns the axes of the plane as lines for visualization\n        '''\n        return [rg.Line(self.plane.Origin, self.plane.XAxis*length), rg.Line(self.plane.Origin, self.plane.YAxis*length), rg.Line(self.plane.Origin, self.plane.ZAxis*length)]\n        \n    def set_to_worldXY(self):\n        '''\n        sets the plane with the origin in world XY\n        '''\n        self.plane = rg.Plane.WorldXY\n        self.update_geo(self.plane)\n    \n    def set_to_plane(self, plane):\n        ''' \n        sets the plane of the frame\n        '''\n        self.plane = rg.Plane(plane)\n        self.update_geo(self.plane)\n    \n    def set_to_tmatrix(self, T):\n        '''\n        sets the plane of the frame with a transformation matrix from world XY\n        '''\n        self.plane = rg.Plane.WorldXY\n        self.plane.Transform(T)\n        self.update_geo(self.plane)\n            \n    def set_to_pose_quaternion(self, pose_quaternion):\n        '''\n        sets the plane of the frame with the input of a pose_quaternion\n        '''\n        x, y, z, qw, qx, qy, qz = pose_quaternion\n        self.set_rotation_from_quaternion([qw, qx, qy, qz])\n        self.set_to_point3d(rg.Point3d(x, y, z))\n    \n    def set_to_pose_angle_axis(self, pose_angle_axis):\n        '''\n        sets the plane of the frame with the input of a pose_angle_axis\n        '''\n        #TODO: Romana: please fill in according to your conventions. \n        \n        x, y, z, ax, ay, az = pose_angle_axis\n        self.set_rotation_from_angle_axis(ax, ay, az)\n        self.set_to_point3d(rg.Point3d(x, y, z))\n    \n    def set_to_pose_euler_angles(self, pose_euler_angles):\n        '''\n        sets the plane of the frame with the input of a pose_euler_angles\n        '''\n        x, y, z, a, b, c = pose_euler_angles\n        self.set_rotation_from_euler_angles(a, b, c)\n        self.set_to_point3d(rg.Point3d(x, y, z))\n \n    def set_to_point3d(self, point3d):\n        '''\n        sets the origin of the plane to the point coordinate\n        '''\n        self.plane.Origin = point3d\n        self.update_geo(self.plane)\n        \n    def get_plane(self):\n        '''\n        returns the copy of the plane of the frame\n        '''\n        return rg.Plane(self.plane)\n        \n    def set_rotation_from_quaternion(self, quaternion):\n        '''\n        sets the plane's orientation according to the quaternion values, origin is set back to World XY\n        '''\n        if type(quaternion) <> type(rg.Quaternion()):\n            a,b,c,d = quaternion\n            quaternion = rg.Quaternion(a,b,c,d)        \n        qplane = quaternion.GetRotation()[1]\n        self.set_to_plane(qplane)\n        \n    def set_rotation_from_angle_axis(self, ax, ay, az):\n        '''\n        sets the plane's orientation according to the angle axis values, origin is set back to World XY\n        TODO: Romana: please fill in according to your conventions.\n        '''\n        \n        ex = rg.Vector3d(ax, ay, az)\n        R = self.rotation_from_angle_axis(ex)\n        self.set_to_tmatrix(R)\n\n    \n    def set_rotation_from_euler_angles(self, a, b, c):\n        ''' \n        sets the plane's orientation according to the angle axis values, origin is set back to World XY\n        TODO: Kathrin or Romana :) '''\n        pass\n        \n    def get_quaternion(self):\n        '''\n        returns rotation from plane as quaternion (as Rhino quaternion)\n        '''     \n        # info: unfortunately this does not work, returns None:\n        # q = rg.Quaternion.Rotation(rg.Plane.WorldZX, self.plane) / q.SetRotation(plane1, plane2)\n        # therefore calculate from Rotation        \n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        a, b, c, d = self.rotation_to_quaternion(T)     \n        quaternion = rg.Quaternion(a, b, c, d)        \n        return quaternion\n    \n    def get_quaternion_as_list(self):\n        '''\n        returns rotation from plane as quaternion (as list)\n        '''     \n        # info: unfortunately this does not work, returns None:\n        # q = rg.Quaternion.Rotation(rg.Plane.WorldZX, self.plane) / q.SetRotation(plane1, plane2)\n        # therefore calculate from Rotation        \n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        return self.rotation_to_quaternion(T)\n    \n    def get_angle_axis(self):\n        '''\n        returns rotation from plane as angle axis (as Rhino Vector3d)\n        '''\n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        angle, axis = self.rotation_to_angle_axis(T)  \n        return rg.Vector3d.Multiply(angle, rg.Vector3d(axis[0], axis[1], axis[2])) \n    \n    def get_angle_axis_as_list(self):\n        '''\n        returns rotation from plane as angle axis (as list) \n        '''\n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        angle, axis = self.rotation_to_angle_axis(T)\n        vec = rg.Vector3d.Multiply(angle, rg.Vector3d(axis[0], axis[1], axis[2]))\n        return [vec.X, vec.Y, vec.Z]\n    \n    def get_euler_angles(self):\n        '''\n        returns rotation from plane as euler angles (as Rhino Vector3d)\n        '''\n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        ex, ey, ez = self.rotation_to_euler_angles(T)  \n        return rg.Vector3d(ex, ey, ez)\n    \n    def get_euler_angles_as_list(self):\n        '''\n        returns rotation from plane as euler angles (as list)\n        '''\n        T = rg.Transform.Rotation(rg.Vector3d.XAxis, rg.Vector3d.YAxis, rg.Vector3d.ZAxis, self.plane.XAxis, self.plane.YAxis, self.plane.ZAxis) \n        return self.rotation_to_euler_angles(T)\n    \n    def get_pose_quaternion(self):\n        '''\n        returns a pose with quaternions as [x,y,z,qw,qx,qy,qz]\n        '''\n        quaternion = self.get_quaternion()\n        point = self.plane.Origin\n        return [point.X, point.Y, point.Z, quaternion.A, quaternion.B, quaternion.C, quaternion.D]\n    \n    def get_pose_angle_axis(self):\n        '''\n        returns a pose with angle_axis as [x,y,z,ax,ay,az]\n        '''\n        angle_axis = self.get_angle_axis()\n        point = self.plane.Origin\n        return [point.X, point.Y, point.Z, angle_axis.X, angle_axis.Y, angle_axis.Z]\n    \n    def get_pose_euler_angles(self):\n        '''\n        returns a pose with euler angles as [x,y,z,ex,ey,ez]\n        '''\n        euler_angles = self.get_euler_angles()\n        point = self.plane.Origin\n        return [point.X, point.Y, point.Z, euler_angles.X, euler_angles.Y, euler_angles.Z]\n    \n    def rotation_to_angle_axis(self, T):\n        '''\n        create angle and axis from matrix,\n        references Martin Baker's implementation of matrix to axis angle function at\n        http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n        ''' \n        \n        epsilon = 0.01 # margin to allow for rounding errors\n        epsilon2 = 0.1 # margin to distinguish between 0 and 180 degrees\n        \n        if ((math.fabs(T.M01-T.M10)< epsilon) and \\\n            (math.fabs(T.M02-T.M20)< epsilon) and \\\n            (math.fabs(T.M12-T.M21)< epsilon)):\n        #singularity found\n        #first check for identity matrix which must have +1 for all terms in leading diagonal and zero in other terms\n            if ((math.fabs(T.M01+T.M10) < epsilon2) and \\\n                (math.fabs(T.M02+T.M20) < epsilon2) and \\\n                (math.fabs(T.M12+T.M21) < epsilon2) and \\\n                (math.fabs(T.M00+T.M11+T.M22-3) < epsilon2)) :\n                # this singularity is identity matrix so angle = 0\n                    return 0, (1,0,0) # zero angle, arbitrary axis\n            else:\n                # otherwise this singularity is angle = 180\n                angle = math.pi\n                xx = (T.M00+1)/2\n                yy = (T.M11+1)/2\n                zz = (T.M22+1)/2\n                xy = (T.M01+T.M10)/4\n                xz = (T.M02+T.M20)/4\n                yz = (T.M12+T.M21)/4\n                root_half = math.sqrt(0.5)\n                if ((xx > yy) and (xx > zz)) : # T.M00 is the largest diagonal term\n                    if (xx< epsilon) :\n                        axis = (0,root_half,root_half)\n                    else:\n                        x = math.sqrt(xx)\n                        axis = (x,xy/x,xz/x)                    \n                elif (yy > zz) : # T.M11 is the largest diagonal term\n                    if (yy< epsilon):\n                        axis = (root_half,0,root_half)\n                    else :\n                        y = math.sqrt(yy)\n                        axis = (xy/y,y,yz/y)                        \n                else : # T.M22 is the largest diagonal term so base result on this\n                    if (zz< epsilon) :\n                        axis = (root_half,root_half,0)\n                    else :\n                        z = math.sqrt(zz)\n                        axis = (xz/z,yz/z,z)\n                                    \n                return angle, axis # return 180 degree rotation\n    \n        # as we have reached here there are no singularities so we can handle normally\n        s = math.sqrt(\\\n            (T.M21 - T.M12)*(T.M21 - T.M12)+\n            (T.M02 - T.M20)*(T.M02 - T.M20)+\n            (T.M10 - T.M01)*(T.M10 - T.M01)) # used to normalize\n        \n        # prevent divide by zero, should not happen if matrix is orthogonal and should be\n        # caught by singularity test above, but I've left it in just in case\n        if (math.fabs(s) < 0.001): s=1\n        angle = math.acos((T.M00 + T.M11 + T.M22 - 1)/2)\n        \n        x = (T.M21 - T.M12)/s\n        y = (T.M02 - T.M20)/s\n        z = (T.M10 - T.M01)/s\n        return angle, (x,y,z)\n    \n    def rotation_to_quaternion(self, T):\n        '''\n        create a unit quaternion from matrix as qw, qx, qy, qz,\n        references Martin Baker's implementation of matrix to quaternion: \n        http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/ \n        '''\n        \n        qw, qx, qy, qz = 0,0,0,0\n        trace = T.M00 + T.M11 + T.M22 # m[0][0] + m[1][1] + m[2][2]\n        \n        if trace > 0.0:\n            # print \"case 1\"\n            s = (0.5 / math.sqrt(trace+1.0)) # s = 0.5f / sqrtf(trace+ 1.0f);\n            qw = 0.25 / s # 0.25f / s;\n            qx = (T.M21 - T.M12) * s #( a[2][1] - a[1][2] ) * s;\n            qy = (T.M02 - T.M20) * s #( a[0][2] - a[2][0] ) * s;\n            qz = (T.M10 - T.M01) * s #( a[1][0] - a[0][1] ) * s;\n            \n        elif ( (T.M00 > T.M11) and (T.M00 > T.M22) ): # ( a[0][0] > a[1][1] && a[0][0] > a[2][2] )\n            # print \"case 2\"\n            s = 2.0 * math.sqrt(1.0 + T.M00 - T.M11 - T.M22) # s = 2.0f * sqrtf( 1.0f + a[0][0] - a[1][1] - a[2][2]);\n            qw = (T.M21 - T.M12) / s #(a[2][1] - a[1][2] ) / s;\n            qx = 0.25 * s #0.25f * s;\n            qy = (T.M01 + T.M10) / s #(a[0][1] + a[1][0] ) / s;\n            qz = (T.M02 + T.M20) / s #(a[0][2] + a[2][0] ) / s;\n            \n        elif (T.M11 > T.M22 ): #(a[1][1] > a[2][2]) {\n            # print \"case 3\"\n            s = 2.0 * math.sqrt(1.0 + T.M11 - T.M00 - T.M22) #float s = 2.0f * sqrtf( 1.0f + a[1][1] - a[0][0] - a[2][2]);\n            qw = (T.M02 - T.M20) / s #q.w = (a[0][2] - a[2][0] ) / s;\n            qx = (T.M01 + T.M10) / s #q.x = (a[0][1] + a[1][0] ) / s;\n            qy = 0.25 * s #q.y = 0.25f * s;\n            qz = (T.M12 + T.M21) / s #q.z = (a[1][2] + a[2][1] ) / s;\n        else:\n            # print \"case 4\"\n            s = 2.0 * math.sqrt(1.0 + T.M22 - T.M00 - T.M11) # float s = 2.0f * sqrtf( 1.0f + a[2][2] - a[0][0] - a[1][1] );\n            qw = (T.M10 - T.M01) / s  # q.w = (a[1][0] - a[0][1] ) / s;\n            qx = (T.M02 + T.M20) / s # q.x = (a[0][2] + a[2][0] ) / s;\n            qy = (T.M12 + T.M21) / s # q.y = (a[1][2] + a[2][1] ) / s;\n            qz = 0.25 * s  # q.z = 0.25f * s;\n            \n        return [qw, qx, qy, qz]\n    \n    def rotation_to_euler_angles(self, T):\n        '''\n        create euler angles from matrix\n        TODO: Kathrin or Romana :) \n        '''\n        ex, ey, ez = [0, 0, 0]\n        return [ex, ey, ez]\n    \n\n    def rotation_from_angle_axis(self, angle_axis):\n        ax = rg.Vector3d(angle_axis)\n        ax.Unitize()\n        R = rg.Transform.Rotation(angle_axis.Length, ax, rg.Point3d(0,0,0)) \n        return R\n    \n    def get_transformation_from(self, other = None):\n        '''\n        returns the transformation matrix either from the world xy to self, or from another plane to self,\n        other can be a frame or a plane\n        '''\n        if other == None:\n            return rg.Transform.PlaneToPlane(rg.Plane.WorldXY, self.plane)\n        else:\n            if type(other) == rg.Plane: \n                return rg.Transform.PlaneToPlane(other, self.plane)\n            else:\n                return rg.Transform.PlaneToPlane(other.plane, self.plane)\n    \n    def get_transformation_to(self, other = None):\n        '''\n        returns the transformation matrix either from self to the world xy, or from self to another plane,\n        other can be a frame or a plane\n        '''\n        if other == None:\n            return rg.Transform.PlaneToPlane(self.plane, rg.Plane.WorldXY)\n        else:            \n            if type(other) == rg.Plane: \n                return rg.Transform.PlaneToPlane(self.plane, other)\n            else:\n                return rg.Transform.PlaneToPlane(self.plane, other.plane)\n            \n    def transform(self, T):\n        '''\n        transform the frame with a Rhino transformation matrix\n        '''\n        self.plane.Transform(T)\n        self.update_geo(self.plane)\n    \n    def rotate(self, angle, axis, centerpt):\n        '''\n        rotate the frame with angle, axis and centerpoint\n        '''\n        self.plane.Rotate(math.radians(angle), axis, centerpt)\n        self.update_geo(self.plane)\n    \n    def translate(self, vector):\n        '''\n        translate the frame by a vector\n        '''\n        self.plane.Translate(vector)\n        self.update_geo(self.plane)  \n    \n    def copy(self):\n        '''\n        return a deepcopy of the frame\n        '''\n        return copy.deepcopy(self)\n\n\nif __name__ == '__main__':\n    \n    plane = rg.Plane(rg.Point3d(6,9,5), rg.Vector3d(8,4,7))\n    frame = Frame(plane)\n    print frame.plane\n    \n    print frame.get_pose_quaternion()\n    print frame.get_pose_angle_axis()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}