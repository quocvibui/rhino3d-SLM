{
  "source_url": "https://github.com/Brandes21/PyPa/blob/713d1e35bd5490521eab2d0efe869fff9692e351/Packages/PSL_Tracer/src/PSL_Tracer/Tracer_A.py",
  "repo": "Brandes21/PyPa",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Packages/PSL_Tracer/src/PSL_Tracer/Tracer_A.py",
  "instruction": "Tracer a",
  "code": "def main(h,num_steps,k,collision_threshold,merge_radius,n_back,sample_count,k_edge,seed_points,principal_vectors,points,domain_surface,boundary_curves):\n\n\n    import math\n    import rhinoscriptsyntax as rs\n    import Rhino\n    import Rhino.Geometry as rg\n    import scriptcontext as sc\n    import numpy as np\n    from scipy.spatial import KDTree\n    from ghpythonlib import treehelpers as tr\n    import cProfile, pstats, io\n\n\n    # ------------------------------------------------------------------------\n    # Variables\n    # ------------------------------------------------------------------------\n\n\n\n\n\n    #set values\n    tolerance_proj = 2000        #Max distance for projection\n    boundary_tolerance= h\n    closing_threshold=h\n\n\n    # ------------------------------------------------------------------------\n    # 3D UTILITY FUNCTIONS\n    # ------------------------------------------------------------------------\n\n\n\n\n\n    def distance_3d(a, b):\n        return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)\n\n    def to_xyz(pt_or_vec):\n        #Converts Rhino.Geometry.Point3d or Vector3d (or numeric [x,y,z]) to a Python list [x, y, z]\n        if hasattr(pt_or_vec, \"X\"):\n            return [pt_or_vec.X, pt_or_vec.Y, pt_or_vec.Z]\n        else:\n            return [pt_or_vec[0], pt_or_vec[1], pt_or_vec[2]]\n\n    def normalize_3d(vec):\n        #Normalize a 3D vector [x, y, z] to unit length. Returns [0,0,0] if near zero length\n        mag = math.sqrt(vec[0]**2 + vec[1]**2 + vec[2]**2)\n        if mag < 1e-12:\n            return [0.0, 0.0, 0.0]\n        return [vec[0]/mag, vec[1]/mag, vec[2]/mag]\n\n    def find_closest_neighbors_kd_3d(point, kd_tree, k):\n \n        distances, indices = kd_tree.query(point, k=k)\n        if isinstance(indices, int):\n            return [indices]\n        return list(indices)\n\n\n\n    # ------------------------------------------------------------------------\n    # TRACING FUNCTIONS\n    # ------------------------------------------------------------------------\n\n\n    def interpolate_vector_3d_consistent(pt, points_3d, vectors_3d, neighbors, ref_dir):\n        \"\"\"\n        Distance-weighted interpolation of neighbor vectors in 3D,\n        flipping each neighbor's vector if dot < 0 with respect to 'ref_dir'.\n\n        - pt: [x, y, z], the point where we want the interpolated vector\n        - points_3d: Nx3 array of point coords\n        - vectors_3d: Nx3 array of principal vectors\n        - neighbors: list of indices from the KDTree\n        - ref_dir: [dx, dy, dz], the direction from the previous step (or None if first step)\n        \"\"\"\n        weights = []\n        weighted_vec = [0.0, 0.0, 0.0]\n\n        for i in neighbors:\n            vx, vy, vz = vectors_3d[i]  # copy so we can flip locally\n            if ref_dir is not None:\n                dotp = vx*ref_dir[0] + vy*ref_dir[1] + vz*ref_dir[2]\n                if dotp < 0:\n                    vx, vy, vz = -vx, -vy, -vz\n            \n            npt = points_3d[i]\n            dx = pt[0] - npt[0]\n            dy = pt[1] - npt[1]\n            dz = pt[2] - npt[2]\n            dist = (dx*dx + dy*dy + dz*dz)**0.5\n            \n            w = 1.0 / (dist + 1e-6)\n            weights.append(w)\n            \n            weighted_vec[0] += vx*w\n            weighted_vec[1] += vy*w\n            weighted_vec[2] += vz*w\n\n        total_w = sum(weights)\n        if total_w > 1e-12:\n            weighted_vec[0] /= total_w\n            weighted_vec[1] /= total_w\n            weighted_vec[2] /= total_w\n\n        mag = (weighted_vec[0]**2 + weighted_vec[1]**2 + weighted_vec[2]**2)**0.5\n        if mag < 1e-12:\n            return [0.0, 0.0, 0.0]\n        \n        return [weighted_vec[0]/mag, weighted_vec[1]/mag, weighted_vec[2]/mag]\n\n    def runge_kutta_step_3d(\n        current_point, \n        current_dir,\n        h, \n        k, \n        principal_vectors, \n        points_3d, \n        step_sign, \n        kd_tree, \n        boundary_curves=None, \n        boundary_tolerance=boundary_tolerance,prev_dir=None):\n        \n        # Perform one RK4 step in 3D. Stop if next point is within 'boundary_tolerance'\n        # of any boundary curve (edges).\n        # Returns the next 3D point or None if out-of-bound / near boundary.\n        \n        \n        # 1) Neighbors & dynamic step size\n        neighbors = find_closest_neighbors_kd_3d(current_point, kd_tree, k)\n        h = h * step_sign#adjust_step_size_3d(current_point, neighbors, points_3d, step_sign)\n        \n        # k1\n        k1_dir = interpolate_vector_3d_consistent(current_point, points_3d, principal_vectors, neighbors, current_dir)\n        mid1 = [\n            current_point[0] + 0.5*h*k1_dir[0],\n            current_point[1] + 0.5*h*k1_dir[1],\n            current_point[2] + 0.5*h*k1_dir[2]\n        ]\n        \n        # k2\n        neigh_mid1 = find_closest_neighbors_kd_3d(mid1, kd_tree, k)\n        k2_dir = interpolate_vector_3d_consistent(mid1, points_3d, principal_vectors, neigh_mid1, k1_dir)\n        mid2 = [\n            current_point[0] + 0.5*h*k2_dir[0],\n            current_point[1] + 0.5*h*k2_dir[1],\n            current_point[2] + 0.5*h*k2_dir[2]\n        ]\n        \n        # k3\n        neigh_mid2 = find_closest_neighbors_kd_3d(mid2, kd_tree, k)\n        k3_dir = interpolate_vector_3d_consistent(mid2, points_3d, principal_vectors, neigh_mid2, k2_dir)\n        end_pt = [\n            current_point[0] + h*k3_dir[0],\n            current_point[1] + h*k3_dir[1],\n            current_point[2] + h*k3_dir[2]\n        ]\n        \n        # k4\n        neigh_end = find_closest_neighbors_kd_3d(end_pt, kd_tree, k)\n        k4_dir = interpolate_vector_3d_consistent(end_pt, points_3d, principal_vectors, neigh_end, k3_dir)\n        \n        # Summation\n        dx = h*(k1_dir[0] + 2*k2_dir[0] + 2*k3_dir[0] + k4_dir[0]) / 6.0\n        dy = h*(k1_dir[1] + 2*k2_dir[1] + 2*k3_dir[1] + k4_dir[1]) / 6.0\n        dz = h*(k1_dir[2] + 2*k2_dir[2] + 2*k3_dir[2] + k4_dir[2]) / 6.0\n        \n        next_point = [\n            current_point[0] + dx,\n            current_point[1] + dy,\n            current_point[2] + dz\n        ]\n        next_dir = k4_dir\n\n        if domain_surface is not None:\n            projected = project_onto_surface(domain_surface, next_point, tolerance_proj)\n            #print(projected)\n            if projected is None:\n                # Means we're off domain or near an open edge you consider invalid\n                return None\n            next_point = projected  \n\n\n        # Otherwise return the next valid point\n        return next_point, next_dir\n\n\n    # ------------------------------------------------------------------------#\n    # SURFACE / BREP PROJECTION UTILS\n    # ------------------------------------------------------------------------#\n\n    def project_onto_surface(surface, pt3d, tolerance_proj):\n        pt_rh = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n        \n        if isinstance(surface, rg.Brep):\n            # Note the 6 returned values:\n            rc, closest_pt, cindex, u, v, normal = surface.ClosestPoint(pt_rh, tolerance_proj)\n            if rc:\n                # Check if cindex is a face\n                if cindex.ComponentIndexType == rg.ComponentIndexType.BrepFace:\n                    face_id = cindex.Index\n                    face = surface.Faces[face_id]\n                    \n                    # 'closest_pt' is the 3D point on that face\n                    # Optionally confirm it's within the face domain or do face.IsPointOnFace(u,v)\n                    \n                    return [closest_pt.X, closest_pt.Y, closest_pt.Z]\n                else:\n                    # The closest component might be an edge or vertex\n                    return None\n            else:\n                return None\n        \n        elif isinstance(surface, rg.Surface):\n            rc, u, v = surface.ClosestPoint(pt_rh)\n            if rc:\n                pt_srf = surface.PointAt(u, v)\n                return [pt_srf.X, pt_srf.Y, pt_srf.Z]\n            else:\n                return None\n        else:\n            return None\n\n    def is_on_surface(surface, pt3d, tol=0.01):\n        \n        \n\n        if not surface: \n            return True  # no surface provided\n        pproj = project_onto_surface(surface, pt3d)\n        if pproj is None:\n            return False\n        dx = pt3d[0] - pproj[0]\n        dy = pt3d[1] - pproj[1]\n        dz = pt3d[2] - pproj[2]\n        dist = math.sqrt(dx*dx + dy*dy + dz*dz)\n        return (dist < tol)\n\n\n\n    # ------------------------------------------------------------------------\n    # COLLISION/DISTANCE CHECKS\n    # ------------------------------------------------------------------------\n\n\n    def build_polyline_curve_3d(poly_pts):\n        pts3d = [rg.Point3d(pt[0], pt[1], pt[2]) for pt in poly_pts]\n        poly = rg.Polyline(pts3d)\n        return rg.PolylineCurve(poly)\n\n    def closest_point_on_polyline_3d(pt3d, poly_curve):\n  \n        test_pt = rg.Point3d(pt3d[0], pt3d[1], pt3d[2])\n        rc, t = poly_curve.ClosestPoint(test_pt)\n        if rc:\n            cp = poly_curve.PointAt(t)\n            dist = cp.DistanceTo(test_pt)\n            return [cp.X, cp.Y, cp.Z], dist\n        else:\n            return None, float('inf')\n\n    def find_closest_existing_line_3d(next_point, existing_trajectories, threshold):\n        \n        # Among all previously traced lines (in 3D), find if 'next_point' is within 'threshold' of any line.\n        # Returns (closest_line_index, closest_point_on_line, distance).\n        \n        min_dist = float('inf')\n        closest_line_idx = None\n        closest_pt = None\n        \n        for i, (polyline_pts, poly_curve) in enumerate(existing_trajectories):\n            cp, dist = closest_point_on_polyline_3d(next_point, poly_curve)\n            if dist < min_dist:\n                min_dist = dist\n                closest_line_idx = i\n                closest_pt = cp\n        \n        if min_dist < threshold:\n            return (closest_line_idx, closest_pt, min_dist)\n        else:\n            return (None, None, float('inf'))\n\n    def is_point_close_to_any(point_list, single_point, threshold):\n        flat = [item for sublist in point_list for item in sublist]\n\n        single_point_1 = rg.Point3d(single_point[0],single_point[1],single_point[2])\n        \n        \n        for pt in flat:\n \n            if single_point_1.DistanceTo(pt) <= threshold:\n                return pt\n        return single_point\n\n    def find_most_parallel_boundary_point(\n        current_pt,\n        last_step_vec,\n        boundary_points,\n        k=10):\n        \"\"\"\n        Given a KD-tree of boundary sample points (boundary_kdtree)\n        and the original array (boundary_points),\n        find the boundary sample whose direction from current_pt \n        is most opposite (or \"most parallel\" â€“ depends on how you measure) \n        to last_step_vec. Return (best_point, min_dist).\n\n        boundary_points should be a Nx3 np.array or a list of [x,y,z].\n        \"\"\"\n        \n        if boundary_kdtree is None:\n            return None, float('inf')\n        \n        cur_np = np.array(current_pt, dtype=float)\n        step_np = np.array(last_step_vec, dtype=float)\n        \n        # if zero length, can't define direction\n        step_len = np.linalg.norm(step_np)\n        if step_len < 1e-12:\n            return None, float('inf')\n        step_np /= step_len\n        \n        # 1) Quickly find the 'k' closest boundary samples to current_pt\n\n        distances, indices = boundary_kdtree.query(cur_np, k=k)\n\n        # If k=1, make them arrays for consistency\n        if k == 1:\n            distances = [distances]\n            indices = [indices]\n\n        # 2) Among these k points, pick the direction which has \n        #    the smallest dot or largest negative dot, etc.\n        best_dot = 9999\n        best_pt = None\n        min_dist = float('inf')\n\n\n        for dist, idx in zip(distances, indices):\n            cand_np = boundary_points_array[idx]  \n            dir_vec = cand_np - cur_np\n            dir_len = np.linalg.norm(dir_vec)\n            if dir_len < 1e-12:\n                continue\n            dir_unit = dir_vec / dir_len\n            dot_val = np.dot(dir_unit, step_np)\n            \n\n            if dot_val < best_dot:\n                best_dot = dot_val\n                best_pt = cand_np\n                \n                if dist < min_dist:\n                    min_dist = dist\n\n        # Convert best_pt to Rhino point\n        if best_pt is not None:\n            return rg.Point3d(best_pt[0], best_pt[1], best_pt[2]), min_dist\n        else:\n            return None, float('inf')\n\n\n    # ------------------------------------------------------------------------\n    # TRACE PSL IN BOTH DIRECTIONS (3D)\n    # ------------------------------------------------------------------------               \n\n\n    def trace_psl_both_directions_in_one_loop_3d(\n        seed_point_3d,\n        h, \n        num_steps,\n        k,\n        principal_vectors, \n        points_3d,\n        kd_tree,\n        boundary_curves=None,\n        boundary_tolerance=boundary_tolerance,\n        existing_trajectories=None,\n        collision_threshold=collision_threshold,\n        closing_threshold=closing_threshold,\n        existing_merge_pts = None):\n        \n        # Traces a PSL forward (+1) and backward (-1) in ONE loop, letting each direction\n        # stop or collide independently. If forward is done, backward can keep going (and vice versa).\n        # If both are done, or tips meet, we stop entirely.\n        \n        if existing_trajectories is None:\n            existing_trajectories = []\n        \n        import Rhino.Geometry as rg\n        from math import sqrt\n\n        # Initialize lines\n        forward_line = [rg.Point3d(*seed_point_3d)]\n        backward_line = [rg.Point3d(*seed_point_3d)]\n\n        # Current states\n        f_current_pt = list(seed_point_3d)\n        f_current_dir = None\n        b_current_pt = list(seed_point_3d)\n        b_current_dir = None\n\n        bridging_lines = []\n        merge_points = []\n\n        #Flags for forward/backward\n        forward_active = True\n        backward_active = True\n\n        for step_i in range(num_steps):\n            # --------------------------------------------------\n            # FORWARD STEP (if still active)\n            # --------------------------------------------------\n            if forward_active:\n                f_next = runge_kutta_step_3d(\n                    f_current_pt,\n                    f_current_dir,\n                    h,\n                    k,\n                    principal_vectors,\n                    points_3d,\n                    step_sign=+1,\n                    kd_tree=kd_tree,\n                    boundary_curves=boundary_curves,\n                    boundary_tolerance=boundary_tolerance\n                )\n                if not f_next or (f_next[0] is None):\n                    print(f\"PSL forward direction stopped at iteration {step_i}.\")\n                    # Do NOT break from the entire loop\n                    forward_active = False\n                else:\n                    # Accept the new point\n                    f_next_pt, f_next_dir = f_next\n                    \n                    #collision check\n                    if existing_trajectories:\n                        line_idx, close_pt, dist_cl = find_closest_existing_line_3d(\n                            f_next_pt, existing_trajectories, collision_threshold\n                        )\n                        if len(existing_merge_pts) > 1 and close_pt is not None:\n                            \n                            close_pt = is_point_close_to_any(existing_merge_pts, close_pt, merge_radius)\n\n                        if line_idx is not None and close_pt is not None:\n                            # Instead of break, we do bridging & disable forward\n                            steps_back = n_back\n                            if len(forward_line) > steps_back:\n                                bridging_line = rg.Line(\n                                    forward_line[-steps_back],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                                del forward_line[-(steps_back-1):]\n                            if len(forward_line)==0:\n                                print(\"too short for bridge\")\n                            else:\n                                bridging_line = rg.Line(\n                                    forward_line[-1],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                            \n                            print(f\"PSL forward collided with line {line_idx} at dist {dist_cl:.3f}.\")\n                            forward_active = False\n\n                        # 2) Check distance to boundary edges\n\n                    if boundary_curves:\n                        dir_vec = [-1*x for x in f_next_dir]\n                        cp,dist_to_edge = find_most_parallel_boundary_point(f_next_pt,dir_vec,boundary_curves,k_edge)\n                        if dist_to_edge < boundary_tolerance:\n                            # \"off\" or \"too close\" => stop\n                            print(f\"PSL forward reached boundary.\")\n                            forward_active = False\n                            bridging_line = rg.Line(\n                                    forward_line[-1],\n                                    rg.Point3d(cp)\n                            )\n                            bridging_lines.append(bridging_line)\n                            \n                    # append the step\n                    if forward_active:\n                        forward_line.append(rg.Point3d(*f_next_pt))\n                        f_current_pt = f_next_pt\n                        f_current_dir = f_next_dir\n\n            # --------------------------------------------------\n            # BACKWARD STEP (if still active)\n            # --------------------------------------------------\n            if backward_active:\n                b_next = runge_kutta_step_3d(\n                    b_current_pt,\n                    b_current_dir,\n                    h,\n                    k,\n                    principal_vectors,\n                    points_3d,\n                    step_sign=-1,\n                    kd_tree=kd_tree,\n                    boundary_curves=boundary_curves,\n                    boundary_tolerance=boundary_tolerance\n                )\n                if not b_next or (b_next[0] is None):\n                    print(f\"PSL backward direction stopped at iteration {step_i}.\")\n                    backward_active = False\n                else:\n                    b_next_pt, b_next_dir = b_next\n                    \n                    if existing_trajectories:\n                        line_idx, close_pt, dist_cl = find_closest_existing_line_3d(\n                            b_next_pt, existing_trajectories, collision_threshold\n                        )\n                        if len(existing_merge_pts) > 1 and close_pt is not None:\n                            close_pt = is_point_close_to_any(existing_merge_pts, close_pt, merge_radius)\n\n                        if line_idx is not None and close_pt is not None:\n                            steps_back = n_back\n                        \n                            if len(backward_line) > steps_back:\n                                bridging_line = rg.Line(\n                                    backward_line[-steps_back],\n                                    rg.Point3d(*close_pt)\n                                )\n                                del backward_line[-(steps_back-1):]\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n\n                            if len(backward_line)==0:\n                                print(\"too short for bridge\")\n                            else:\n                                bridging_line = rg.Line(\n                                    backward_line[-1],\n                                    rg.Point3d(*close_pt)\n                                )\n                                bridging_lines.append(bridging_line)\n                                merge_points.append(rg.Point3d(*close_pt))\n                            print(f\"PSL backward collided with line {line_idx} at dist {dist_cl:.3f}.\")\n                            backward_active = False\n\n\n\n\n                    #print(f\"direction = {b_current_dir}\")\n                    if boundary_curves:\n                        cp,dist_to_edge = find_most_parallel_boundary_point(b_next_pt,b_next_dir,boundary_curves,k_edge)\n                        if dist_to_edge < boundary_tolerance:\n                            #\"off\" or \"too close\" => stop\n                            print(f\"PSL forward reached boundary.\")\n                            backward_active = False\n                            bridging_line = rg.Line(\n                                    backward_line[-1],\n                                    rg.Point3d(cp)\n                            )\n                            bridging_lines.append(bridging_line)\n\n\n\n\n\n                    if backward_active:\n                        backward_line.append(rg.Point3d(*b_next_pt))\n                        b_current_pt = b_next_pt\n                        b_current_dir = b_next_dir\n\n            # --------------------------------------------------\n            # If BOTH directions are inactive => stop\n            # --------------------------------------------------\n            if not forward_active and not backward_active:\n                print(\"Both directions inactive => done.\")\n                break\n\n            # --------------------------------------------------\n            # TIP DISTANCE CHECK\n            # --------------------------------------------------\n            if forward_active and backward_active and step_i >= 10:\n                f_tip = [forward_line[-1].X, forward_line[-1].Y, forward_line[-1].Z]\n                b_tip = [backward_line[-1].X, backward_line[-1].Y, backward_line[-1].Z]\n                dist_fb = sqrt(\n                    (f_tip[0] - b_tip[0])**2 +\n                    (f_tip[1] - b_tip[1])**2 +\n                    (f_tip[2] - b_tip[2])**2\n                )\n                if dist_fb < closing_threshold:\n                    # bridging line \n                    bridging_line = [forward_line[-1], backward_line[-1]]\n                    bridging_lines.append(bridging_line)\n\n                    print(\n                        f\"PSL tips meet at iteration {step_i}, dist= {dist_fb:.3f} < {closing_threshold}.\"\n                    )\n                    forward_active = False\n                    backward_active = False\n                    break\n\n        # MERGE\n        backward_line.reverse()\n        if len(backward_line) > 1:\n            backward_line.pop()\n        merged_pts = backward_line + forward_line\n\n        return merged_pts, bridging_lines, merge_points\n\n\n    # ------------------------------------------------------------------------\n    # \"MAIN\" LOGIC\n    # ------------------------------------------------------------------------\n\n\n    # 1) Convert your input points/vectors to lists of [x,y,z].\n    points_array_3d = [to_xyz(pt) for pt in points]\n    vectors_array_3d = [to_xyz(vec) for vec in principal_vectors]\n\n\n\n\n    sampled_boundary_pts = []\n    for crv in boundary_curves:\n        params = crv.DivideByCount(sample_count, True)\n        for t in params:\n            p = crv.PointAt(t)\n            sampled_boundary_pts.append([p.X, p.Y, p.Z])\n\n    # Build KDTree for boundary points\n    if sampled_boundary_pts:\n        boundary_points_array = np.array(sampled_boundary_pts, dtype=float)\n        #print(boundary_points_array)\n        boundary_kdtree = KDTree(boundary_points_array)\n        #print(boundary_kdtree)\n    else:\n        boundary_kdtree = None\n        \n\n\n\n    # 2) Build a 3D KD-tree\n    points_np = np.array(points_array_3d)  # shape (N, 3)\n    #print(points_np)\n    kd_tree = KDTree(points_np)\n    #print(f\"old_kdTree = {kd_tree}\")\n\n    # 3) 'existing_trajectories' as: ( [pt3d_list], polyline_curve )\n    existing_trajectories = []\n    bridging_lines_out = []\n    existing_merge_pts = []\n    psl_out = []\n\n\n\n    # 4) Loop over seed points (3D)\n    for seed in seed_points:\n        seed_xyz = to_xyz(seed)\n        \n        merged_psl,  new_bridges, merge_points = trace_psl_both_directions_in_one_loop_3d(\n            seed_point_3d=seed_xyz,\n            h=h,\n            num_steps=num_steps,\n            k=k,\n            principal_vectors=vectors_array_3d,\n            points_3d=points_array_3d,\n            kd_tree=kd_tree,\n            boundary_curves=boundary_curves,\n            boundary_tolerance=boundary_tolerance,\n            existing_trajectories=existing_trajectories,\n            collision_threshold=collision_threshold,\n            closing_threshold=closing_threshold,  \n            existing_merge_pts = existing_merge_pts\n        )\n        \n        # Build the cached polyline for collisions\n        psl_curve_3d = build_polyline_curve_3d([[pt.X, pt.Y, pt.Z] for pt in merged_psl])\n        existing_trajectories.append((merged_psl, psl_curve_3d))\n        existing_merge_pts.append(merge_points)\n\n        psl_out.append(psl_curve_3d)\n        bridging_lines_out.extend(new_bridges)\n        \n\n    # 5) Output\n    main_lines = tr.list_to_tree(psl_out)  \n    connections = tr.list_to_tree(bridging_lines_out)\n\n    return main_lines, connections",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}