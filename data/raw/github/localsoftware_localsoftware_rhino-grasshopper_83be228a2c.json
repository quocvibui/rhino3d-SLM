{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/Rhino8_Scripts/import_shp.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "Rhino8_Scripts/import_shp.py",
  "instruction": "Import shp",
  "code": "import Grasshopper, GhPython, System, Rhino, os, sys, System.Text\nimport struct, datetime, decimal, itertools\nimport rhinoscriptsyntax as rs\nfrom struct import unpack\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport ghpythonlib.treehelpers as th\n\n\ndef dbfreader(f):\n    \"\"\"Returns an iterator over records in a Xbase DBF file.\n\n    The first row returned contains the field names.\n    The second row contains field specs: (type, size, decimal places).\n    Subsequent rows contain the data records.\n    If a record is marked as deleted, it is skipped.\n\n    File should be opened for binary reads.\n\n    \"\"\"\n    # See DBF format spec at:\n    #     http://www.pgts.com.au/download/public/xbase.htm#DBF_STRUCT\n\n    numrec, lenheader = struct.unpack('<xxxxLH22x', f.read(32))\n    numfields = (lenheader - 33) // 32\n\n    fields = []\n    for fieldno in range(numfields):  # Changed from xrange to range\n        name, typ, size, deci = struct.unpack('<11sc4xBB14x', f.read(32))\n        name = name.decode('utf-8').replace('\\0', '')  # Decode bytes to string\n        typ = typ.decode('utf-8')  # Decode type to string\n        fields.append((name, typ, size, deci))\n    yield [field[0] for field in fields]\n    yield [tuple(field[1:]) for field in fields]\n\n    terminator = f.read(1)\n    assert terminator == b'\\r'  # Compare with bytes\n\n    fields.insert(0, ('DeletionFlag', 'C', 1, 0))\n    fmt = ''.join(['%ds' % fieldinfo[2] for fieldinfo in fields])\n    fmtsiz = struct.calcsize(fmt)\n    for i in range(numrec):  # Changed from xrange to range\n        record = struct.unpack(fmt, f.read(fmtsiz))\n        if record[0] != b' ':  # Compare with bytes\n            continue                        # deleted record\n        result = []\n        for (name, typ, size, deci), value in zip(fields, record):  # Changed from itertools.izip to zip\n            if name == 'DeletionFlag':\n                continue\n            if typ == \"N\":\n                value = value.decode('utf-8').replace('\\0', '').lstrip()  # Decode to string\n                if value == '':\n                    value = 0\n                elif deci:\n                    try: value = float(decimal.Decimal(value))\n                    except: value = value\n                else:\n                    try: value = int(value)\n                    except: value = value\n            elif typ == 'D':\n                value = value.decode('utf-8')  # Decode to string\n                try:\n                    y, m, d = int(value[:4]), int(value[4:6]), int(value[6:8])\n                    value = datetime.date(y, m, d)\n                    value = value.strftime('%y/%m/%d')\n\n                except:\n                    value = None\n                    self.AddRuntimeMessage(RML.Warning,\"We couldn't get a date for a geometry in your dbf\")\n            elif typ == 'L':\n                value = value.decode('utf-8')  # Decode to string\n                value = (value in 'YyTt' and 'T') or (value in 'NnFf' and 'F') or '?'\n            else:\n                # For other field types, try to decode if it's bytes\n                if isinstance(value, bytes):\n                    try:\n                        value = value.decode('utf-8').strip()\n                    except:\n                        value = str(value)\n            result.append(value)\n        yield result\n\n##########################################################################\n\nclass ShpFeature(object):\n    \"\"\"\n    This is a base class for each record in a shapefile.\n    each record corresponds to one row in the shapefile's dbf table.\n    To clarify the distinction between a feature and a record:\n    the record is the feature + the dbf data associated with the feature\n    the feature is shape (or multi-shape)\n    In this class, I attach the dbf data for each record to it's feature.\n    \"\"\"\n\n    def __init__(self, shpFile, recordNumber):\n        self.shpFile = shpFile\n        self.recordNumber = recordNumber\n        self.shapeType = shpFile.shapeType\n        self.dbfData = self.readDbfData()\n\n    def readDbfData(self):\n        db = self.shpFile.dbfTable\n        dbfData = {}\n        for i in range(len(db[0])): # for each column\n                dbfData[db[0][i]] = db[self.recordNumber + 2][i]\n        return dbfData\n\n    def make3D(self, zVals=None):\n        \"\"\"\n        This method will take a list of z values and use them to create a new\n        attribute called points3D, which contains 3d points. ESRI shapefiles\n        place z values in a separate list form x and y values for each point,\n        so this essentially integrates those values to make full 3d points.\n        If the number of z values does not match the number of points,\n        then this method will not work.\n        This method will overwrite the points3d attribute if it already exists.\n        \"\"\"\n        # if there's not enough z values for the number of points\n        # or not enough points for the number of z values\n        if not zVals:\n            try: zVals = [0 for i in range(self.numPoints)]\n            except:  \n                print(\"This geometry has too many vertices, try simplifying it\")\n                return\n        if zVals is None:\n            return\n        if len(zVals) != self.numPoints:\n            print(\"The number of Z values does not correspond to the number of points.\")\n            return\n        # clear points3D\n        self.points3D = []\n        for i in range(len(zVals)):\n            z = zVals[i]\n            x = self.points[i][0]\n            y = self.points[i][1]\n            point3d = (x,y,z)\n            self.points3D.append(point3d)\n\n    def chopParts(self, partlist, pointlist):\n        if type(partlist) == tuple:\n            indexSpread = list(partlist)\n        elif type(partlist) == list:\n            indexSpread = partlist\n        else:\n            indexSpread = [partlist]\n        indexSpread.append(len(pointlist))\n        chunks = []\n        for i in range(len(indexSpread) - 1):\n            chunks.append(pointlist[indexSpread[i]:indexSpread[i+1]])\n        return chunks\n\nclass ShpPoint(ShpFeature):\n\n    def __init__(self, ShpFile, recordNumber):\n        ShpFeature.__init__(self, ShpFile, recordNumber)\n        self.parts = [0]\n        self.numParts = 1\n        self.numPoints = 1\n        self.points = [self.shpFile._readPoint()]\n        self.x = self.points[0][0]\n        self.y = self.points[0][1]\n        self.make3D()\n\nclass ShpPointM(ShpPoint):\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPoint.__init__(self, ShpFile, recordNumber)\n\n        self.m = self.shpFile._readZ()\n        self.make3D()\n\nclass ShpPointZ(ShpPoint):\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPoint.__init__(self, ShpFile, recordNumber)\n\n        self.z = self.shpFile._readZ()\n        self.m = self.shpFile._readZ()\n        self.make3D([self.z])\n\nclass ShpMultiPoint(ShpFeature):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpFeature.__init__(self, ShpFile, recordNumber)\n        self.parts = [0]  # Fixed: was missing assignment\n        self.numParts = 1\n        self.boundingBox = self.shpFile._readBoundingBox()\n        self.numPoints = self.shpFile._readNumPoints()\n        self.points = self.shpFile._readPoints(self.numPoints)\n        self.make3D()\n\nclass ShpMultiPointM(ShpMultiPoint):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpMultiPoint.__init__(self, ShpFile, recordNumber)\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D()\n\nclass ShpMultiPointZ(ShpMultiPoint):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpMultiPoint.__init__(self, ShpFile, recordNumber)\n        self.zBounds = self.shpFile._readZBounds()\n        self.zArray = self.shpFile._readZArray(self.numPoints)\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D(self.zArray)\n\nclass ShpPolyLine(ShpFeature):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpFeature.__init__(self, ShpFile, recordNumber)\n\n        self.boundingBox = self.shpFile._readBoundingBox()\n        self.numParts = self.shpFile._readNumParts()\n        self.numPoints = self.shpFile._readNumPoints()\n        self.parts = self.shpFile._readParts(self.numParts)\n        self.points = self.shpFile._readPoints(self.numPoints)\n        self.make3D()\n\nclass ShpPolyLineM(ShpPolyLine):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPolyLine.__init__(self, ShpFile, recordNumber)\n\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D()\n\nclass ShpPolyLineZ(ShpPolyLine):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPolyLine.__init__(self, ShpFile, recordNumber)\n\n        self.zBounds = self.shpFile._readZBounds()\n        self.zArray = self.shpFile._readZArray(self.numPoints)\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D(self.zArray)\n\nclass ShpPolygon(ShpFeature):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpFeature.__init__(self, ShpFile, recordNumber)\n\n        self.boundingBox = self.shpFile._readBoundingBox()\n        self.numParts = self.shpFile._readNumParts()\n        self.numPoints = self.shpFile._readNumPoints()\n        self.parts = self.shpFile._readParts(self.numParts)\n        self.points = self.shpFile._readPoints(self.numPoints)\n        self.make3D()\n\nclass ShpPolygonM(ShpPolygon):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPolygon.__init__(self, ShpFile, recordNumber)\n\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D()\n\nclass ShpPolygonZ(ShpPolygon):\n\n    def __init__(self,ShpFile, recordNumber):\n\n        ShpPolygon.__init__(self, ShpFile, recordNumber)\n\n        self.zBounds = self.shpFile._readZBounds()\n        self.zArray = self.shpFile._readZArray(self.numPoints)\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D(self.zArray)\n\nclass ShpMultiPatch(ShpFeature):\n\n    def __init__(self, ShpFile, recordNumber):\n\n        ShpFeature.__init__(self, ShpFile, recordNumber)\n\n        self.boundingBox = self.shpFile._readBoundingBox()\n        self.numParts = self.shpFile._readNumParts()\n        self.numPoints = self.shpFile._readNumPoints()\n        self.parts = self.shpFile._readParts(self.numParts)\n        self.partTypes = self.shpFile._readParts(self.numParts)\n        self.points = self.shpFile._readPoints(self.numPoints)\n        self.zBounds = self.shpFile._readZBounds()\n        self.zArray = self.shpFile._readZArray(self.numPoints)\n        self.mBounds = self.shpFile._readZBounds()\n        self.mArray = self.shpFile._readZArray(self.numPoints)\n        self.make3D(self.zArray)\n\n##################################################\n\ndef readAndUnpack(type, data):\n    if data==b'': return data  # Compare with bytes\n    return unpack(type, data)[0]\n\nshapeTypeDict = {\n                    0:'Null Shape',\n                    1:'Point',\n                    3:'PolyLine',\n                    5:'Polygon',\n                    8:'MultiPoint',\n                    11:'PointZ',\n                    13:'PolyLineZ',\n                    15:'PolygonZ',\n                    18:'MultiPointZ',\n                    21:'PointM',\n                    23:'PolyLineM',\n                    25:'PolygonM',\n                    28:'MultiPointM',\n                    31:'MultiPatch'\n                    }\n\nclassTypeDict = {\n                'Point':ShpPoint,\n                'PointM':ShpPointM,\n                'PointZ':ShpPointZ,\n                'MultiPoint':ShpMultiPoint,\n                'MultiPointM':ShpMultiPointM,\n                'MultiPointZ':ShpMultiPointZ,\n                'PolyLine':ShpPolyLine,\n                'PolyLineM':ShpPolyLineM,\n                'PolyLineZ':ShpPolyLineZ,\n                'Polygon':ShpPolygon,\n                'PolygonM':ShpPolygonM,\n                'PolygonZ':ShpPolygonZ,\n                'MultiPatch':ShpMultiPatch\n                }\n\n\nclass ShpFile(object):\n    \"\"\"\n    This class is instantiated using the file path to a shapefile (must contain the .shp file extension), and as soon as it is instantiated, it reads the entire shapefile.\n    Once instantiated, it contains objects for each feature based on shape type (the objects are accessible using the\n    .records attribute), and allows access to the shapefile data at multiple levels.\n    \"\"\"\n\n    def __init__(self,filePath):\n        self.filePath = filePath\n        self.proj = self._readProjText()\n        self.dbfTable = self._readDbfTable()\n        self.f = open(self.filePath, 'rb')\n        header = self._readFileHeader()\n        self.shapeType = header[0]\n        self.boundingBox = header[1]\n        self.records = self._readRecords()\n        self.f.close()\n\n    def _readBoundingBox(self):\n        xMin = readAndUnpack('d', self.f.read(8))\n        yMin = readAndUnpack('d', self.f.read(8))\n        xMax = readAndUnpack('d', self.f.read(8))\n        yMax = readAndUnpack('d', self.f.read(8))\n        bbox = (xMin, yMin, xMax, yMax)\n        return bbox\n\n    def _readProjText(self):\n        projPath = self.filePath[0:-4] + '.prj'\n        f = open(projPath, 'r', encoding='utf-8')  # Added encoding\n        s = f.read()\n        f.close()  # Close the file\n        return s\n\n\n    def _readFileHeader(self):\n        self.f.seek(32)\n        shapeKey = readAndUnpack('i', self.f.read(4))\n        shapeType = shapeTypeDict[shapeKey]\n        boundingBox = self._readBoundingBox()\n        return (shapeType, boundingBox)\n\n    def _readPoint(self):\n        x = readAndUnpack('d', self.f.read(8))\n        y = readAndUnpack('d', self.f.read(8))\n        return (x,y)\n\n    def _readNumParts(self):\n        return readAndUnpack('i', self.f.read(4))\n\n    def _readNumPoints(self):\n        return readAndUnpack('i', self.f.read(4))\n\n    def _readParts(self, numParts):\n        partIndices = []\n        try:\n            for i in range(numParts):\n                partIndex = readAndUnpack('i', self.f.read(4))\n                partIndices.append(partIndex)\n            return partIndices\n        except: print(\"This geometry has too many vertices, try simplifying it\")\n\n    def _readPoints(self, numPoints):\n        points = []\n        try:\n            for i in range(numPoints):\n                point = self._readPoint()\n                points.append(point)\n            return points\n        except: print(\"This geometry has too many vertices, try simplifying it\")\n\n    def _readZ(self):\n        z = readAndUnpack('d', self.f.read(8))\n        return z\n\n    def _readZBounds(self):\n        zMin = self._readZ()\n        zMax = self._readZ()\n        return (zMin,zMax)\n\n    def _readZArray(self, numPoints):\n        zArray = []\n        try:\n            for i in range(numPoints):\n                z = self._readZ()\n                zArray.append(z)\n        except: print(\"This geometry has too many vertices, try simplifying it\")\n        return zArray\n\n    def setZfield(self, fieldKey=None, zValue=0.0):\n        # this method will erase any existing\n        # z data of the geometry\n        # and will replace it with values\n        # from the field designated\n        # by the fieldKey\n        zValue = 0.0\n        for record in self.records:\n            if fieldKey != None:\n                try:\n                    zValue = float(record.dbfData[fieldKey])\n                except:\n                    print('There is no field by that name in the table')\n                    self.AddRuntimeMessage(RML.Warning,\"There is no field by that name in the table\")\n                    return\n            zArray = []\n            for each in range(record.numPoints):\n                zArray.append(zValue)\n            record.make3D(zArray)\n\n    def _readDbfTable(self):\n        dbfFile = self.filePath[0:-4] + '.dbf'\n        dbf = open(dbfFile, 'rb')\n        db = list(dbfreader(dbf))\n        dbf.close()\n        return db\n\n    def _readRecords(self):\n        records = []\n        self.f.seek(100)\n        iterator = 0\n        while True:\n            record = self._readFeature(iterator)\n            if record == False:\n                    break\n            records.append(record)\n            iterator += 1\n        return records\n\n    def _readFeature(self, iterator):\n        # the next 12 bytes are simply passed over, though they contain:\n        # a record number: which doesn't seem to correspond to the dbf\n        # a content length integer\n        # a shapeType integer, which is never different form the shapeType of the file\n        read = self.f.read(12)\n        if read == b'':  # Compare with bytes\n                # signifies end of shapefile\n                return False\n        else:\n            # get shapeType and creates appropriate feature\n            feature = classTypeDict[self.shapeType](self,iterator)\n            return feature\n\ndef tVect(geom, vector):\n    geom.Translate(vector)\n    geom.SetUserString('TranslationVector', str(vector) )\n    return geom\n\ndef transVectorFromBBox(shpFile):\n    \"\"\"Uses the bounding box of a shapefile to make a vector moving Rhino geometry to the origin. The translation vector\n    can also be stored as a user string the Rhino geometry, for later conversion back into geospatial data.\"\"\"\n    b = shpFile.boundingBox\n    originalCenterPoint = ((b[0]+b[2])/2, (b[1]+b[3])/2, 0.0)\n    translationVectr = Rhino.Geometry.Vector3d((b[0]+b[2])/-2.0, (b[1]+b[3])/-2.0, 0.0)\n    return translationVectr\n\ndef chop(indices, someList):\n    for i in range(len(indices)-1):\n        idx1, idx2 = indices[i], indices[i+1]\n        yield someList[idx1:idx2]\n\ndef chopPoints( feature ):\n    try:\n        if feature.numParts > 1:\n            return [p for p in chop(feature.parts, feature.points3D)]\n        else:\n            return [feature.points3D]\n    except: \n        print('Try a different geometry')\n        return []\n\ndef shpToPoints( feature, translationVector=None ):\n    points = [Rhino.Geometry.Point3d(*p) for p in feature.points3D]\n    vals = list(feature.dbfData.values())  # Convert to list for Python 3\n\n    if translationVector:\n        points = [p.Add(p, translationVector) for p in points]\n    return [points, vals]\n\ndef shpToCurve( feature, translationVector=None, degree=1):\n    parts = chopPoints( feature )\n    crvs = []\n    vals = list(feature.dbfData.values())  # Convert to list for Python 3\n    for part in parts:\n        points = []\n        for pt in part:\n            rhPoint = Rhino.Geometry.Point3d( *pt )\n            points.append( rhPoint )\n        crv = Rhino.Geometry.Curve.CreateControlPointCurve( points, degree )\n        if translationVector:\n            crv = tVect(crv, translationVector )\n        crvs.append( crv )\n    return [crvs, vals]\n\ndef shpToMesh( multiPatchFeature, translationVector=None ):\n    m = multiPatchFeature\n\n    parts = chopPoints(m)\n    mesh = Rhino.Geometry.Mesh()\n    vals = list(multiPatchFeature.dbfData.values())  # Convert to list for Python 3\n    for i, points in enumerate(parts):\n        if m.partTypes[i] == 0: # it's a a triangle strip\n            submesh = Rhino.Geometry.Mesh()\n            for j, pt in enumerate(points): # build vertices\n                rhPoint = Rhino.Geometry.Point3d(*pt)\n                submesh.Vertices.Add(rhPoint)\n            for n in range(len(points)-1):\n                submesh.Faces.AddFace(n, n +1, n +2 )\n            submesh.Normals.ComputeNormals()\n            submesh.Compact()\n            mesh.Append(submesh)\n        else: # it's some other geometry\n            self.AddRuntimeMessage(RML.Error,\"This geometry type is not yet supported, sorry.\")\n            return 'This geometry type is not yet supported, sorry.'\n    mesh.UnifyNormals()\n    mesh.Normals.ComputeNormals()\n    mesh.Compact() # mesh all fresh and ready!\n    if translationVector:\n        mesh = tVect( mesh, translationVector)\n    return [[ mesh ], vals]\n\n\n\ntranslationDict = {\n                    'Point':shpToPoints,\n                    'Polygon':shpToCurve,\n                    'PolyLine':shpToCurve,\n                    'PolyLineZ':shpToCurve,\n                    'PolygonZ':shpToCurve,\n                    'MultiPatch':shpToMesh\n                    }\n\ndef ShpFileToRhino( filepath, zero=True, tVect=None ):\n    shpfile = ShpFile( filepath )\n    if zero:\n        tVect = transVectorFromBBox( shpfile )\n    records = shpfile.records\n    geoms = []\n    values = []\n    for r in records:\n        new_record =  translationDict[ shpfile.shapeType ]( r, tVect )\n        geoms.append(new_record[0])\n        values.append(new_record[1])\n    return [geoms, list(records[0].dbfData.keys()), values]  # Convert keys to list\n\n##################################################\n\nif read:\n    if shapefile:\n        if not os.path.exists(shapefile):\n            self.AddRuntimeMessage(RML.Error,\"The shapefile you gave me does not exist.\\nDouble check the path: '%s'\" % shapefile)\n            print('The shapefile you gave me does not exist.\\nDouble check the path: \"%s\"' % shapefile)\n        # import stuff\n        out = ShpFileToRhino( shapefile, moveToCenter )\n        geometry = th.list_to_tree(out[0], source=[0,0])\n        attributes = out[1]\n        values = th.list_to_tree(out[2], source=[0,0])\n    else:\n        print('no shapefile supplied')\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}