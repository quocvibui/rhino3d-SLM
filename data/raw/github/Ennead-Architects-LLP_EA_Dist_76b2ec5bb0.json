{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_rhino/Create.tab/quick_massing.button/quick_massing_left.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_rhino/Create.tab/quick_massing.button/quick_massing_left.py",
  "instruction": "Quick massing left",
  "code": "# -*- coding: utf-8 -*-\r\n__title__ = \"QuickMassing\"\r\n__doc__ = \"\"\"Create parametric massing models with advanced level editor interface.\r\n\r\nFeatures:\r\n- Interactive level editor table with reorder, add, remove functionality\r\n- Dedicated surface picker with surface filter\r\n- Real-time elevation calculations\r\n- Persistent settings storage\r\n- Visual level management interface\r\n\r\nUsage:\r\n1. Left-click to activate the QuickMassing tool\r\n2. Use the level editor to configure building levels\r\n3. Pick surfaces for massing creation\r\n4. Generate massing model based on your specifications\r\n\r\nNote: All settings are saved between sessions for convenience.\"\"\"\r\n__is_popular__ = True\r\n\r\nimport os\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Eto.Forms as Forms # pyright: ignore\r\nimport Eto.Drawing as Drawing # pyright: ignore\r\nimport Rhino # pyright: ignore\r\nfrom EnneadTab import DATA_FILE, NOTIFICATION, ERROR_HANDLE\r\nfrom EnneadTab.RHINO import RHINO_UI\r\nimport traceback\r\n\r\nFORM_KEY = 'quick_massing_modeless_form'\r\n\r\nclass LevelEditorTable(Forms.GridView):\r\n    \"\"\"Custom GridView for managing building levels with elevation calculations.\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.levels = []\r\n        self.refresh_callback = None  # Will be set to a callable function\r\n        self.load_default_levels()\r\n        \r\n        # Configure grid\r\n        self.AllowColumnReordering = False\r\n        self.AllowMultipleSelection = False\r\n        self.GridLines = Forms.GridLines.Horizontal\r\n        self.ShowHeader = True\r\n        self.AllowEditing = True\r\n        \r\n        # Disable cell editing to prevent crashes - we'll use buttons instead\r\n        self.AllowEditing = False\r\n        \r\n        # Preview control flag\r\n        self.preview_enabled = True\r\n        \r\n        # Create columns\r\n        self.create_columns()\r\n        \r\n        # Load data\r\n        self.load_data()\r\n        \r\n    def create_columns(self):\r\n        \"\"\"Create and configure grid columns.\"\"\"\r\n        # Level Name column\r\n        level_col = Forms.GridColumn()\r\n        level_col.HeaderText = \"Level\"\r\n        level_col.DataCell = Forms.TextBoxCell(0)  # Index 0 for level name\r\n        # Remove fixed width to allow auto-sizing\r\n        level_col.Editable = False  # Disable editing to prevent crashes\r\n        self.Columns.Add(level_col)\r\n        \r\n        # Floor to Floor Height column\r\n        height_col = Forms.GridColumn()\r\n        height_col.HeaderText = \"FloorToFloor\"\r\n        height_col.DataCell = Forms.TextBoxCell(1)  # Index 1 for height\r\n        # Remove fixed width to allow auto-sizing\r\n        height_col.Editable = False  # Disable editing to prevent crashes\r\n        self.Columns.Add(height_col)\r\n        \r\n        # Elevation column (read-only)\r\n        elev_col = Forms.GridColumn()\r\n        elev_col.HeaderText = \"Elevation (ReadOnly)\"\r\n        elev_col.DataCell = Forms.TextBoxCell(2)  # Index 2 for elevation\r\n        # Remove fixed width to allow auto-sizing\r\n        elev_col.Editable = False  # Make elevation column read-only\r\n        self.Columns.Add(elev_col)\r\n        \r\n    def load_default_levels(self):\r\n        \"\"\"Load default levels from settings or create default set.\"\"\"\r\n        saved_levels = DATA_FILE.get_sticky(\"quick_massing_levels\", None, DATA_FILE.DataType.DICT, tiny_wait=True)\r\n        if saved_levels and isinstance(saved_levels, list):\r\n            self.levels = saved_levels\r\n        else:\r\n            # Create default levels\r\n            self.levels = [\r\n                {\"name\": \"Level B1\", \"height\": 4.5, \"is_datum\": False},\r\n                {\"name\": \"Level 1\", \"height\": 6.0, \"is_datum\": True},\r\n                {\"name\": \"Level 2\", \"height\": 4.5, \"is_datum\": False},\r\n                {\"name\": \"Level 3\", \"height\": 4.5, \"is_datum\": False}\r\n            ]\r\n            \r\n    def get_elevation_for_level(self, level_index):\r\n        \"\"\"Calculate elevation for a specific level based on DATUM level and cumulative heights.\"\"\"\r\n        if not isinstance(self.levels, list) or level_index < 0 or level_index >= len(self.levels):\r\n            return 0\r\n        \r\n        # Find DATUM level index\r\n        datum_index = None\r\n        for i, level in enumerate(self.levels):\r\n            if isinstance(level, dict) and level.get(\"is_datum\", False):\r\n                datum_index = i\r\n                break\r\n        \r\n        if datum_index is None:\r\n            # If no DATUM level found, use the first level as base\r\n            datum_index = 0\r\n        \r\n        # DATUM level always has elevation 0\r\n        if level_index == datum_index:\r\n            return 0.0\r\n        \r\n        # Calculate elevation based on DATUM level position\r\n        if level_index > datum_index:\r\n            # Level is above DATUM - add heights from DATUM to this level\r\n            elevation = 0.0\r\n            for i in range(datum_index, level_index):\r\n                if i < len(self.levels) and isinstance(self.levels[i], dict):\r\n                    elevation += self.levels[i].get(\"height\", 0)\r\n            return elevation\r\n        else:\r\n            # Level is below DATUM - subtract heights from this level to DATUM\r\n            elevation = 0.0\r\n            for i in range(level_index, datum_index):\r\n                if i < len(self.levels) and isinstance(self.levels[i], dict):\r\n                    elevation -= self.levels[i].get(\"height\", 0)\r\n            return elevation\r\n                \r\n    def load_data(self):\r\n        \"\"\"Load data into the grid with error handling.\"\"\"\r\n        try:\r\n            if not isinstance(self.levels, list):\r\n                print(\"ERROR: Levels is not a list\")\r\n                return\r\n                \r\n            # Create data tuples for the grid\r\n            # Display levels in reverse order (highest elevation at top, lowest at bottom)\r\n            data_tuples = []\r\n            for i in reversed(range(len(self.levels))):\r\n                level = self.levels[i]\r\n                \r\n                if not isinstance(level, dict):\r\n                    continue\r\n                    \r\n                elevation = self.get_elevation_for_level(i)\r\n                \r\n                data_tuples.append((\r\n                    level.get(\"name\", \"\"),\r\n                    str(level.get(\"height\", 0)),\r\n                    str(elevation)\r\n                ))\r\n            \r\n            # Set the data store\r\n            self.DataStore = data_tuples\r\n            \r\n        except Exception as ex:\r\n            print(\"ERROR loading data: {}\".format(str(ex)))\r\n            \r\n    def add_level(self, index=None):\r\n        \"\"\"Add a new level at the specified index.\"\"\"\r\n        if not isinstance(self.levels, list):\r\n            self.levels = []\r\n            \r\n        if index is None:\r\n            index = len(self.levels)\r\n            \r\n        new_level = {\r\n            \"name\": \"Level {}\".format(len(self.levels) + 1),\r\n            \"height\": 4.5,\r\n            \"is_datum\": False\r\n        }\r\n        self.levels.insert(index, new_level)\r\n        self.load_data()\r\n        self.save_levels()\r\n        \r\n    def remove_level(self, grid_index):\r\n        \"\"\"Remove level at specified grid index, but not DATUM level.\"\"\"\r\n        level_index = self.grid_index_to_level_index(grid_index)\r\n        if not isinstance(self.levels, list) or len(self.levels) <= 1:\r\n            return\r\n        \r\n        # Prevent removing DATUM level\r\n        if self.levels[level_index].get(\"is_datum\", False):\r\n            return  # Cannot remove DATUM level\r\n            \r\n        if 0 <= level_index < len(self.levels):\r\n            del self.levels[level_index]\r\n            self.load_data()\r\n            self.save_levels()\r\n            \r\n    def grid_index_to_level_index(self, grid_index):\r\n        \"\"\"Convert grid row index to actual level index (reversed).\"\"\"\r\n        try:\r\n            if not isinstance(self.levels, list) or len(self.levels) == 0:\r\n                print(\"ERROR: levels is not a list or is empty\")\r\n                return -1\r\n            if grid_index < 0 or grid_index >= len(self.levels):\r\n                print(\"ERROR: grid_index {} out of range for levels length {}\".format(grid_index, len(self.levels)))\r\n                return -1\r\n            result = len(self.levels) - 1 - grid_index\r\n            print(\"Converted grid_index {} to level_index {}\".format(grid_index, result))\r\n            return result\r\n        except Exception as ex:\r\n            print(\"ERROR in grid_index_to_level_index: {}\".format(str(ex)))\r\n            return -1\r\n    \r\n    def level_index_to_grid_index(self, level_index):\r\n        \"\"\"Convert actual level index to grid row index (reversed).\"\"\"\r\n        try:\r\n            if not isinstance(self.levels, list) or len(self.levels) == 0:\r\n                print(\"ERROR: levels is not a list or is empty\")\r\n                return -1\r\n            if level_index < 0 or level_index >= len(self.levels):\r\n                print(\"ERROR: level_index {} out of range for levels length {}\".format(level_index, len(self.levels)))\r\n                return -1\r\n            result = len(self.levels) - 1 - level_index\r\n            print(\"Converted level_index {} to grid_index {}\".format(level_index, result))\r\n            return result\r\n        except Exception as ex:\r\n            print(\"ERROR in level_index_to_grid_index: {}\".format(str(ex)))\r\n            return -1\r\n    \r\n    def move_level(self, grid_index, direction):\r\n        \"\"\"Move level in specified direction (up/down in elevation order).\r\n        \r\n        Args:\r\n            grid_index: Index in the grid display\r\n            direction: \"up\" (towards higher elevation/top of display) or \"down\" (towards lower elevation/bottom of display)\r\n        \"\"\"\r\n        try:\r\n            level_index = self.grid_index_to_level_index(grid_index)\r\n            \r\n            # Check if trying to move DATUM level itself\r\n            if self.levels[level_index].get(\"is_datum\", False):\r\n                return  # Cannot move DATUM level itself\r\n            \r\n            # Determine target index based on direction\r\n            if direction == \"up\":\r\n                # Move up = towards higher elevation = towards top of display = towards index 0\r\n                target_index = level_index - 1\r\n                if level_index <= 0:\r\n                    return\r\n            elif direction == \"down\":\r\n                # Move down = towards lower elevation = towards bottom of display = towards higher index\r\n                target_index = level_index + 1\r\n                if level_index >= len(self.levels) - 1:\r\n                    return\r\n            else:\r\n                return\r\n            \r\n            # Validate target index\r\n            if target_index < 0 or target_index >= len(self.levels):\r\n                return\r\n            \r\n            # Disable preview during move operation\r\n            self.disable_preview()\r\n                \r\n            self.levels[level_index], self.levels[target_index] = self.levels[target_index], self.levels[level_index]\r\n            \r\n            # Calculate new selection index after the move\r\n            if direction == \"up\":\r\n                new_selection_index = grid_index - 1  # Moving up means selection moves up in grid\r\n            else:  # direction == \"down\"\r\n                new_selection_index = grid_index + 1  # Moving down means selection moves down in grid\r\n            \r\n            self.load_data()\r\n            self.save_levels()\r\n            \r\n            # Restore selection to the new position\r\n            if 0 <= new_selection_index < len(self.levels):\r\n                self.SelectedRowIndex = new_selection_index\r\n            \r\n            # Re-enable preview after move is complete\r\n            self.enable_preview()\r\n            \r\n        except Exception as ex:\r\n            print(\"ERROR moving level {}: {}\".format(direction, str(ex)))\r\n    \r\n    def move_level_up(self, grid_index):\r\n        \"\"\"Move level up in elevation (towards higher elevation, top of grid display).\"\"\"\r\n        self.move_level(grid_index, \"up\")\r\n            \r\n    def move_level_down(self, grid_index):\r\n        \"\"\"Move level down in elevation (towards lower elevation, bottom of grid display).\"\"\"\r\n        self.move_level(grid_index, \"down\")\r\n            \r\n    def save_levels(self):\r\n        \"\"\"Save levels to settings with error handling.\"\"\"\r\n        try:\r\n            DATA_FILE.set_sticky(\"quick_massing_levels\", self.levels, DATA_FILE.DataType.DICT, tiny_wait=True)\r\n        except Exception as ex:\r\n            print(\"ERROR saving levels: {}\".format(str(ex)))\r\n    \r\n    def on_cell_edited(self, sender, e):\r\n        \"\"\"Handle cell edited events - fires after user finishes editing.\"\"\"\r\n        try:\r\n            print(\"=== CELL EDITED DEBUG ===\")\r\n            print(\"Event type: {}\".format(type(e)))\r\n            print(\"Event Row: {}\".format(getattr(e, 'Row', 'NO_ROW')))\r\n            print(\"Event Column: {}\".format(getattr(e, 'Column', 'NO_COLUMN')))\r\n            \r\n            # Get row and column from event\r\n            row = getattr(e, 'Row', None)\r\n            column = getattr(e, 'Column', None)\r\n            \r\n            print(\"Extracted - Row: {}, Column: {}\".format(row, column))\r\n            \r\n            # Validate we have the minimum required data\r\n            if row is None or column is None:\r\n                print(\"ERROR: Missing row or column information\")\r\n                return\r\n            \r\n            # Process the cell edit directly (CellEdited fires after edit is complete)\r\n            self.process_cell_edit(row, column, e)\r\n            \r\n        except Exception as ex:\r\n            print(\"=== CELL EDITED CRITICAL ERROR ===\")\r\n            print(\"Error type: {}\".format(type(ex).__name__))\r\n            print(\"Error message: {}\".format(str(ex)))\r\n            import traceback\r\n            print(\"Full traceback:\")\r\n            traceback.print_exc()\r\n            print(\"=== END CRITICAL ERROR ===\")\r\n            return\r\n    \r\n    def process_cell_edit(self, row, column, e):\r\n        \"\"\"Process the cell edit with comprehensive validation.\"\"\"\r\n        try:\r\n            print(\"=== PROCESS CELL EDIT ===\")\r\n            print(\"Row: {}, Column: {}\".format(row, column))\r\n            print(\"Event type: {}\".format(type(e)))\r\n            print(\"Levels type: {}\".format(type(self.levels)))\r\n            print(\"Levels count: {}\".format(len(self.levels) if isinstance(self.levels, list) else \"Not a list\"))\r\n            \r\n            # Validate levels data\r\n            if not isinstance(self.levels, list) or len(self.levels) == 0:\r\n                print(\"ERROR: Levels is not a valid list or is empty\")\r\n                return\r\n            \r\n            # Validate row index\r\n            if row < 0 or row >= len(self.levels):\r\n                print(\"ERROR: Row index {} out of range for levels length {}\".format(row, len(self.levels)))\r\n                return\r\n            \r\n            # Convert grid row index to level index with error handling\r\n            try:\r\n                level_index = self.grid_index_to_level_index(row)\r\n                print(\"Converted level_index: {}\".format(level_index))\r\n            except Exception as conv_ex:\r\n                print(\"ERROR in grid_index_to_level_index conversion: {}\".format(str(conv_ex)))\r\n                return\r\n            \r\n            # Validate level index\r\n            if level_index < 0 or level_index >= len(self.levels):\r\n                print(\"ERROR: Invalid level_index: {}\".format(level_index))\r\n                return\r\n            \r\n            # Get level data with validation\r\n            try:\r\n                level = self.levels[level_index]\r\n                print(\"Level data: {}\".format(level))\r\n            except Exception as level_ex:\r\n                print(\"ERROR accessing level data: {}\".format(str(level_ex)))\r\n                return\r\n            \r\n            # Validate level is a dictionary\r\n            if not isinstance(level, dict):\r\n                print(\"ERROR: Level is not a dict: {}\".format(type(level)))\r\n                return\r\n            \r\n            # Get the new value from the event (recommended approach)\r\n            try:\r\n                print(\"Event Item: {}\".format(getattr(e, 'Item', 'NO_ITEM')))\r\n                print(\"Event Column: {}\".format(column))\r\n                \r\n                # Use e.Item[e.Column] as recommended in Eto.Forms documentation\r\n                if hasattr(e, 'Item') and e.Item is not None:\r\n                    if isinstance(e.Item, (list, tuple)) and column < len(e.Item):\r\n                        new_value = e.Item[column]\r\n                        print(\"New value from e.Item[{}]: {}\".format(column, new_value))\r\n                    else:\r\n                        print(\"ERROR: e.Item is not accessible or column out of range\")\r\n                        return\r\n                else:\r\n                    print(\"ERROR: e.Item is None or not available\")\r\n                    return\r\n                \r\n            except Exception as data_ex:\r\n                print(\"ERROR getting value from event: {}\".format(str(data_ex)))\r\n                import traceback\r\n                print(\"Event access traceback:\")\r\n                traceback.print_exc()\r\n                return\r\n            \r\n            # Update level data based on column with individual error handling\r\n            try:\r\n                if column == 0:  # Level name column\r\n                    print(\"Editing level name: {} -> {}\".format(level.get(\"name\", \"\"), str(new_value)))\r\n                    level[\"name\"] = str(new_value)\r\n                elif column == 1:  # Height column\r\n                    print(\"Editing height: {} -> {}\".format(level.get(\"height\", 0), new_value))\r\n                    try:\r\n                        new_height = float(new_value)\r\n                        if new_height < 0:\r\n                            print(\"WARNING: Negative height value, setting to 0\")\r\n                            new_height = 0.0\r\n                        level[\"height\"] = new_height\r\n                        print(\"Height updated successfully: {}\".format(level[\"height\"]))\r\n                    except (ValueError, TypeError) as ve:\r\n                        print(\"Height conversion error: {}\".format(str(ve)))\r\n                        level[\"height\"] = 0.0\r\n                else:\r\n                    print(\"WARNING: Unknown column index: {}\".format(column))\r\n                    return\r\n                \r\n                print(\"Level after update: {}\".format(level))\r\n                \r\n            except Exception as update_ex:\r\n                print(\"ERROR updating level data: {}\".format(str(update_ex)))\r\n                return\r\n            \r\n            # Save changes with error handling\r\n            try:\r\n                print(\"Saving levels...\")\r\n                self.save_levels()\r\n                print(\"Levels saved successfully\")\r\n            except Exception as save_ex:\r\n                print(\"ERROR saving levels: {}\".format(str(save_ex)))\r\n                return\r\n            \r\n            # Refresh grid display with error handling\r\n            try:\r\n                print(\"Loading data...\")\r\n                self.load_data()  # Refresh the grid display\r\n                print(\"Grid data loaded successfully\")\r\n            except Exception as load_ex:\r\n                print(\"ERROR loading grid data: {}\".format(str(load_ex)))\r\n                return\r\n            \r\n            # Trigger refresh callback with error handling\r\n            try:\r\n                print(\"Triggering refresh callback...\")\r\n                if self.refresh_callback:\r\n                    self.refresh_callback()\r\n                    print(\"Refresh callback completed successfully\")\r\n                else:\r\n                    print(\"No refresh callback set\")\r\n            except Exception as callback_ex:\r\n                print(\"ERROR in refresh callback: {}\".format(str(callback_ex)))\r\n                # Don't return here - callback error shouldn't stop the process\r\n            \r\n            print(\"Cell editing completed successfully\")\r\n                        \r\n        except Exception as ex:\r\n            print(\"=== PROCESS CELL EDIT CRITICAL ERROR ===\")\r\n            print(\"Error type: {}\".format(type(ex).__name__))\r\n            print(\"Error message: {}\".format(str(ex)))\r\n            import traceback\r\n            print(\"Full traceback:\")\r\n            traceback.print_exc()\r\n            print(\"=== END CRITICAL ERROR ===\")\r\n            # Don't re-raise the exception to prevent Rhino crash\r\n            return\r\n    \r\n    def disable_preview(self):\r\n        \"\"\"Disable preview generation to avoid rapid-fire changes during editing.\"\"\"\r\n        self.preview_enabled = False\r\n        print(\"Preview disabled\")\r\n    \r\n    def enable_preview(self):\r\n        \"\"\"Re-enable preview generation after editing is complete.\"\"\"\r\n        self.preview_enabled = True\r\n        print(\"Preview enabled\")\r\n    \r\n    def refresh_preview(self, selected_surfaces=None, is_final_creation=False):\r\n        \"\"\"Shared method to refresh preview massing with validation and cleanup.\"\"\"\r\n        try:\r\n            # Check if preview is enabled\r\n            if not self.preview_enabled:\r\n                print(\"Preview disabled - skipping refresh\")\r\n                return\r\n            \r\n            # Disable auto redraw for better performance during preview generation\r\n            rs.EnableRedraw(False)\r\n            \r\n            # 1. Validate all input ready: level data and input surfaces\r\n            if not isinstance(self.levels, list) or len(self.levels) == 0:\r\n                return  # No level data available\r\n            \r\n            # Use provided surfaces or create preview surface\r\n            if selected_surfaces and len(selected_surfaces) > 0:\r\n                surfaces_to_use = selected_surfaces\r\n            else:\r\n                # Create a simple preview surface for demonstration\r\n                preview_surface = self.create_preview_surface()\r\n                if not preview_surface:\r\n                    return  # Cannot create preview surface\r\n                surfaces_to_use = [preview_surface]\r\n            \r\n            # 2. Purge previous temp preview elements by keyword (only for preview, not final creation)\r\n            if not is_final_creation:\r\n                self.purge_temp_massing()\r\n            \r\n            # 3. Make new elements for massing and text dots\r\n            for surface in surfaces_to_use:\r\n                self.create_massing_for_surface(surface, is_final_creation)\r\n            \r\n            # Re-enable auto redraw after preview generation is complete\r\n            rs.EnableRedraw(True)\r\n            \r\n        except Exception:\r\n            # Re-enable auto redraw even if there's an error\r\n            rs.EnableRedraw(True)\r\n            # Silently handle preview errors to not interrupt main functionality\r\n            pass\r\n    \r\n    def generate_preview_massing(self):\r\n        \"\"\"Legacy method - now calls shared refresh_preview.\"\"\"\r\n        self.refresh_preview()\r\n    \r\n    def purge_temp_massing(self):\r\n        \"\"\"Remove all temporary massing objects from the document.\"\"\"\r\n        try:\r\n            # Get all objects in the document\r\n            all_objects = rs.AllObjects()\r\n            if all_objects:\r\n                for obj in all_objects:\r\n                    if rs.IsObject(obj):\r\n                        obj_name = rs.ObjectName(obj)\r\n                        if obj_name and (\"TEMP_MASSING_PREVIEW\" in str(obj_name) or \"TEMP_MASSING_PREVIEW_TEXT\" in str(obj_name)):\r\n                            rs.DeleteObject(obj)\r\n        except Exception:\r\n            # Silently handle purge errors\r\n            pass\r\n    \r\n    def create_preview_surface(self):\r\n        \"\"\"Create a simple preview surface for massing demonstration.\"\"\"\r\n        try:\r\n            # Create a simple rectangular surface for preview\r\n            points = [\r\n                [0, 0, 0],\r\n                [10, 0, 0], \r\n                [10, 10, 0],\r\n                [0, 10, 0],\r\n                [0, 0, 0]\r\n            ]\r\n            \r\n            # Create the surface\r\n            surface = rs.AddSrfPt(points)\r\n            if surface:\r\n                # Name the surface for identification\r\n                rs.ObjectName(surface, \"TEMP_MASSING_PREVIEW_SURFACE\")\r\n                return surface\r\n        except Exception:\r\n            pass\r\n        return None\r\n    \r\n    def create_massing_for_surface(self, surface, is_final_creation=False):\r\n        \"\"\"Create massing for a single surface based on configured levels.\r\n        Uses consistent stacking logic: each level builds its own massing using its floor-to-floor height.\"\"\"\r\n        if not isinstance(self.levels, list) or len(self.levels) == 0:\r\n            return\r\n        \r\n        # Find DATUM level index (base level)\r\n        datum_index = None\r\n        for i, level in enumerate(self.levels):\r\n            if isinstance(level, dict) and level.get(\"is_datum\", False):\r\n                datum_index = i\r\n                break\r\n        \r\n        if datum_index is None:\r\n            # If no DATUM level found, use the first level as base\r\n            datum_index = 0\r\n        \r\n        # Create massing for each level using consistent logic\r\n        self.create_massing_consistent_stacking(surface, datum_index, is_final_creation)\r\n    \r\n    def create_massing_consistent_stacking(self, surface, datum_index, is_final_creation=False):\r\n        \"\"\"Create massing using consistent stacking logic: each level builds its own massing using its floor-to-floor height.\"\"\"\r\n        try:\r\n            # Process ALL levels using their own elevation and floor-to-floor height\r\n            for i in range(len(self.levels)):\r\n                level = self.levels[i]\r\n                if not isinstance(level, dict):\r\n                    continue\r\n                    \r\n                level_height = level.get(\"height\", 0)\r\n                level_elevation = self.get_elevation_for_level(i)\r\n                \r\n                # Create massing for this level using its own elevation and floor-to-floor height\r\n                self.create_single_level_massing(surface, level, i, level_elevation, level_height, is_final_creation)\r\n            \r\n        except Exception as ex:\r\n            print(\"ERROR in consistent stacking: {}\".format(str(ex)))\r\n    \r\n    def create_single_level_massing(self, surface, level, level_index, level_elevation, level_height, is_final_creation=False):\r\n        \"\"\"Create massing for a single level using its floor-to-floor height.\"\"\"\r\n        try:\r\n            \r\n            # Copy surface to level elevation\r\n            level_surface = rs.CopyObject(surface, [0, 0, level_elevation])\r\n            if not level_surface:\r\n                print(\"ERROR: Failed to copy surface for level {}\".format(level_index))\r\n                return\r\n            \r\n            # Create extrusion curve using this level's floor-to-floor height\r\n            extrusion_curve = rs.AddCurve([\r\n                [0, 0, 0],\r\n                [0, 0, level_height]\r\n            ])\r\n            \r\n            if extrusion_curve:\r\n                # Create the massing volume and name it\r\n                massing_obj = rs.ExtrudeSurface(level_surface, extrusion_curve)\r\n                if massing_obj:\r\n                    # Name the object based on whether it's preview or final creation\r\n                    if is_final_creation:\r\n                        object_name = \"MASSING_LEVEL_{}_{}\".format(level_index, level.get(\"name\", \"\"))\r\n                    else:\r\n                        object_name = \"TEMP_MASSING_PREVIEW_LEVEL_{}\".format(level_index)\r\n                    rs.ObjectName(massing_obj, object_name)\r\n                    # Add text label to the center of the massing\r\n                    self.add_massing_text_label(massing_obj, level, level_index, is_final_creation)\r\n                else:\r\n                    print(\"ERROR: Failed to create massing object for level {}\".format(level_index))\r\n                \r\n                rs.DeleteObject(extrusion_curve)\r\n            else:\r\n                print(\"ERROR: Failed to create extrusion curve for level {}\".format(level_index))\r\n            \r\n            # Clean up\r\n            rs.DeleteObject(level_surface)\r\n            \r\n        except Exception as ex:\r\n            print(\"=== SINGLE LEVEL MASSING ERROR ===\")\r\n            print(\"Error type: {}\".format(type(ex).__name__))\r\n            print(\"Error message: {}\".format(str(ex)))\r\n            import traceback\r\n            print(\"Full traceback:\")\r\n            traceback.print_exc()\r\n            print(\"=== END SINGLE LEVEL MASSING ERROR ===\")\r\n    \r\n    def create_massing_for_datum_level(self, surface, datum_index, base_elevation):\r\n        \"\"\"Create massing for the DATUM level itself.\"\"\"\r\n        level = self.levels[datum_index]\r\n        if not isinstance(level, dict):\r\n            return\r\n            \r\n        level_height = level.get(\"height\", 0)\r\n        \r\n        # Copy surface for DATUM level\r\n        current_surface = rs.CopyObject(surface, [0, 0, base_elevation])\r\n        if not current_surface:\r\n            return\r\n            \r\n        # Create extrusion curve for DATUM level\r\n        extrusion_curve = rs.AddCurve([\r\n            [0, 0, 0],\r\n            [0, 0, level_height]\r\n        ])\r\n        \r\n        if extrusion_curve:\r\n            # Create the massing volume and name it\r\n            massing_obj = rs.ExtrudeSurface(current_surface, extrusion_curve)\r\n            if massing_obj:\r\n                rs.ObjectName(massing_obj, \"TEMP_MASSING_PREVIEW_LEVEL_{}\".format(datum_index))\r\n                # Add text label to the center of the massing\r\n                self.add_massing_text_label(massing_obj, level, datum_index)\r\n            \r\n            rs.DeleteObject(extrusion_curve)\r\n        \r\n        # Clean up\r\n        rs.DeleteObject(current_surface)\r\n    \r\n    def create_massing_upward(self, surface, datum_index, base_elevation):\r\n        \"\"\"Create massing from DATUM level upward.\"\"\"\r\n        current_surface = surface\r\n        cumulative_height = 0\r\n        \r\n        # Process levels above DATUM level\r\n        for i in range(datum_index + 1, len(self.levels)):\r\n            level = self.levels[i]\r\n            if not isinstance(level, dict):\r\n                continue\r\n                \r\n            level_height = level.get(\"height\", 0)\r\n            \r\n            # Create extrusion curve upward from current position\r\n            extrusion_curve = rs.AddCurve([\r\n                [0, 0, 0],\r\n                [0, 0, level_height]\r\n            ])\r\n            \r\n            # Move surface to correct elevation (DATUM + cumulative height)\r\n            rs.MoveObject(current_surface, [0, 0, cumulative_height])\r\n            \r\n            # Create the massing volume and name it\r\n            massing_obj = rs.ExtrudeSurface(current_surface, extrusion_curve)\r\n            if massing_obj:\r\n                rs.ObjectName(massing_obj, \"TEMP_MASSING_PREVIEW_LEVEL_{}\".format(i))\r\n                # Add text label to the center of the massing\r\n                self.add_massing_text_label(massing_obj, level, i)\r\n            \r\n            rs.DeleteObject(extrusion_curve)\r\n            \r\n            # Update cumulative height for next level\r\n            cumulative_height += level_height\r\n            \r\n            # Copy surface for next level\r\n            if current_surface != surface:\r\n                rs.DeleteObject(current_surface)\r\n            current_surface = rs.CopyObject(surface, [0, 0, level_height])\r\n        \r\n        # Clean up\r\n        if current_surface != surface:\r\n            rs.DeleteObject(current_surface)\r\n    \r\n    def create_massing_downward(self, surface, datum_index, base_elevation):\r\n        \"\"\"Create massing from DATUM level downward.\"\"\"\r\n        current_surface = surface\r\n        cumulative_height = 0\r\n        \r\n        # Process levels below DATUM level (in reverse order)\r\n        for i in range(datum_index - 1, -1, -1):\r\n            level = self.levels[i]\r\n            if not isinstance(level, dict):\r\n                continue\r\n                \r\n            level_height = level.get(\"height\", 0)\r\n            \r\n            # Create extrusion curve downward from current position\r\n            extrusion_curve = rs.AddCurve([\r\n                [0, 0, 0],\r\n                [0, 0, -level_height]  # Negative for downward extrusion\r\n            ])\r\n            \r\n            # Move surface to correct elevation (DATUM - cumulative height)\r\n            rs.MoveObject(current_surface, [0, 0, -cumulative_height])\r\n            \r\n            # Create the massing volume and name it\r\n            massing_obj = rs.ExtrudeSurface(current_surface, extrusion_curve)\r\n            if massing_obj:\r\n                rs.ObjectName(massing_obj, \"TEMP_MASSING_PREVIEW_LEVEL_{}\".format(i))\r\n                # Add text label to the center of the massing\r\n                self.add_massing_text_label(massing_obj, level, i)\r\n            \r\n            rs.DeleteObject(extrusion_curve)\r\n            \r\n            # Update cumulative height for next level\r\n            cumulative_height += level_height\r\n            \r\n            # Copy surface for next level\r\n            if current_surface != surface:\r\n                rs.DeleteObject(current_surface)\r\n            current_surface = rs.CopyObject(surface, [0, 0, -level_height])\r\n        \r\n        # Clean up\r\n        if current_surface != surface:\r\n            rs.DeleteObject(current_surface)\r\n    \r\n    def add_massing_text_label(self, massing_obj, level, level_index, is_final_creation=False):\r\n        \"\"\"Add text label to the center of a massing object.\"\"\"\r\n        try:\r\n            # Get the bounding box of the massing object\r\n            bbox = rs.BoundingBox(massing_obj)\r\n            if not bbox:\r\n                return\r\n            \r\n            # Calculate center point\r\n            center = [\r\n                (bbox[0][0] + bbox[2][0]) / 2,\r\n                (bbox[0][1] + bbox[2][1]) / 2,\r\n                (bbox[0][2] + bbox[2][2]) / 2\r\n            ]\r\n            \r\n            # Get level data\r\n            level_name = level.get(\"name\", \"Level {}\".format(level_index + 1))\r\n            level_height = level.get(\"height\", 0)\r\n            elevation = self.get_elevation_for_level(level_index)\r\n            \r\n            # Create text dot label\r\n            text_content = \"{} @ {} w/ {}\".format(level_name, elevation, level_height)\r\n            text_obj = rs.AddTextDot(text_content, center)\r\n            \r\n            if text_obj:\r\n                # Name the text object based on whether it's preview or final creation\r\n                if is_final_creation:\r\n                    text_name = \"TEXT_LEVEL_{}_{}\".format(level_index, level_name)\r\n                else:\r\n                    text_name = \"TEMP_MASSING_PREVIEW_TEXT_{}\".format(level_index)\r\n                rs.ObjectName(text_obj, text_name)\r\n                \r\n        except Exception:\r\n            # Silently handle text creation errors\r\n            pass\r\n\r\nclass QuickMassingDialog(Forms.Form):\r\n    \"\"\"Modeless dialog for QuickMassing level editor interface.\"\"\"\r\n    \r\n    def __init__(self):\r\n        \"\"\"Initialize dialog UI components and default state.\"\"\"\r\n        # Eto initials\r\n        self.Title = \"Quick Massing - Level Editor\"\r\n        self.Resizable = True\r\n        self.Padding = Drawing.Padding(10)\r\n        self.Spacing = Drawing.Size(5, 5)\r\n        self.Size = Drawing.Size(400, 500)\r\n        self.Closed += self.OnFormClosed\r\n        \r\n        # Initialize data\r\n        self.selected_surfaces = []\r\n        \r\n        # Create layout\r\n        self.create_layout()\r\n        \r\n        # Apply dark style with logo\r\n        RHINO_UI.apply_dark_style(self)\r\n        \r\n    def create_logo_image(self):\r\n        \"\"\"Create logo image for the dialog.\"\"\"\r\n        self.logo = Forms.ImageView()\r\n        \r\n        # Use the same logo path pattern as other forms\r\n        from EnneadTab import IMAGE\r\n        logo_path = IMAGE.get_image_path_by_name(\"icon_logo_dark_background.png\")\r\n        if logo_path and os.path.exists(logo_path):\r\n            temp_bitmap = Drawing.Bitmap(logo_path)\r\n            self.logo.Image = temp_bitmap.WithSize(200, 30)\r\n        else:\r\n            # Fallback to a simple text label if logo not found\r\n            self.logo = Forms.Label(Text=\"Quick Massing\", Font=Drawing.Font(\"Arial\", 14, Drawing.FontStyle.Bold))\r\n        \r\n        return self.logo\r\n        \r\n    def create_layout(self):\r\n        \"\"\"Create the main dialog layout.\"\"\"\r\n        layout = Forms.DynamicLayout()\r\n        layout.Padding = Drawing.Padding(10)\r\n        layout.Spacing = Drawing.Size(5, 5)\r\n        \r\n        # Add logo at the top\r\n        layout.AddSeparateRow(None, self.create_logo_image())\r\n        layout.AddRow(None)  # Spacer\r\n        \r\n        # Surface picker section\r\n        surface_section = Forms.GroupBox(Text=\"Surface Selection\")\r\n        surface_layout = Forms.DynamicLayout()\r\n        surface_layout.Padding = Drawing.Padding(5)\r\n        \r\n        self.surface_picker_button = Forms.Button(Text=\"Pick Surfaces for Massing\")\r\n        self.surface_picker_button.Click += self.on_pick_surfaces\r\n        self.surface_info_label = Forms.Label(Text=\"No surfaces selected\")\r\n        \r\n        surface_layout.AddRow(self.surface_picker_button)\r\n        surface_layout.AddRow(self.surface_info_label)\r\n        surface_section.Content = surface_layout\r\n        \r\n        # Level editor section\r\n        level_section = Forms.GroupBox(Text=\"Level Editor\")\r\n        level_layout = Forms.DynamicLayout()\r\n        level_layout.Padding = Drawing.Padding(5)\r\n        \r\n        # Create level editor table\r\n        self.level_table = LevelEditorTable()\r\n        # Set refresh callback to use selected surfaces\r\n        setattr(self.level_table, 'refresh_callback', self.refresh_level_preview)\r\n        \r\n        # Add control buttons for level management\r\n        controls_layout = Forms.DynamicLayout()\r\n        \r\n        self.add_level_button = Forms.Button(Text=\"Add Level\")\r\n        self.add_level_button.Click += self.on_add_level\r\n        \r\n        self.remove_level_button = Forms.Button(Text=\"Remove Selected\")\r\n        self.remove_level_button.Click += self.on_remove_level\r\n        \r\n        self.move_up_button = Forms.Button(Text=\"Move Up (Higher Elevation)\")\r\n        self.move_up_button.Click += self.on_move_level_up\r\n        \r\n        self.move_down_button = Forms.Button(Text=\"Move Down (Lower Elevation)\")\r\n        self.move_down_button.Click += self.on_move_level_down\r\n        \r\n        self.edit_level_button = Forms.Button(Text=\"Edit Selected Level\")\r\n        self.edit_level_button.Click += self.on_edit_level\r\n        \r\n        controls_layout.AddRow(self.add_level_button, self.remove_level_button)\r\n        controls_layout.AddRow(self.move_up_button, self.move_down_button)\r\n        controls_layout.AddRow(self.edit_level_button)\r\n        \r\n        level_layout.AddRow(self.level_table)\r\n        level_layout.AddRow(controls_layout)\r\n        level_section.Content = level_layout\r\n        \r\n        # Action buttons\r\n        action_layout = Forms.DynamicLayout()\r\n        \r\n        self.create_button = Forms.Button(Text=\"Create Massing\")\r\n        self.create_button.Click += self.on_create_massing\r\n        \r\n        self.cancel_button = Forms.Button(Text=\"Cancel\")\r\n        self.cancel_button.Click += self.on_cancel_clicked\r\n        \r\n        action_layout.AddRow(None, self.create_button, self.cancel_button)\r\n        \r\n        # Add sections to main layout\r\n        layout.AddRow(surface_section)\r\n        layout.AddRow(level_section)\r\n        layout.AddRow(action_layout)\r\n        \r\n        self.Content = layout\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_pick_surfaces(self, sender, e):\r\n        \"\"\"Handle surface picking with surface filter.\"\"\"\r\n        try:\r\n            # Clear previous selection\r\n            rs.UnselectAllObjects()\r\n            \r\n            # Get surfaces with filter\r\n            surfaces = rs.GetObjects(\"Select surfaces for massing\", filter=rs.filter.surface)\r\n            if surfaces:\r\n                self.selected_surfaces = surfaces\r\n                self.surface_info_label.Text = \"{} surface(s) selected\".format(len(surfaces))\r\n                NOTIFICATION.messenger(\"Selected {} surface(s) for massing\".format(len(surfaces)))\r\n                # Save selected surfaces\r\n                self.save_surfaces()\r\n                # Generate preview massing with selected surfaces\r\n                self.level_table.refresh_preview(self.selected_surfaces)\r\n            else:\r\n                self.selected_surfaces = []\r\n                self.surface_info_label.Text = \"No surfaces selected\"\r\n                \r\n        except Exception as e:\r\n            NOTIFICATION.messenger(\"Error picking surfaces: {}\".format(str(e)))\r\n    \r\n    def refresh_level_preview(self):\r\n        \"\"\"Refresh the level preview with current selected surfaces.\"\"\"\r\n        self.level_table.refresh_preview(self.selected_surfaces)\r\n            \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_add_level(self, sender, e):\r\n        \"\"\"Add a new level to the table.\"\"\"\r\n        self.level_table.add_level()\r\n        # Generate preview after adding level\r\n        self.level_table.refresh_preview(self.selected_surfaces)\r\n        \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_remove_level(self, sender, e):\r\n        \"\"\"Remove selected level from the table.\"\"\"\r\n        selected_rows = list(self.level_table.SelectedRows)\r\n        if selected_rows and len(selected_rows) > 0:\r\n            selected_index = selected_rows[0]\r\n            # Check if trying to remove DATUM level\r\n            level_index = self.level_table.grid_index_to_level_index(selected_index)\r\n            if self.level_table.levels[level_index].get(\"is_datum\", False):\r\n                NOTIFICATION.messenger(\"Cannot remove DATUM level - it must stay as the reference level\")\r\n                return\r\n            self.level_table.remove_level(selected_index)\r\n            # Generate preview after removing level\r\n            self.level_table.refresh_preview(self.selected_surfaces)\r\n    \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_move_level_up(self, sender, e):\r\n        \"\"\"Move selected level up in elevation (towards top of list).\"\"\"\r\n        selected_rows = list(self.level_table.SelectedRows)\r\n        if selected_rows and len(selected_rows) > 0:\r\n            selected_index = selected_rows[0]\r\n            # Check if trying to move DATUM level\r\n            level_index = self.level_table.grid_index_to_level_index(selected_index)\r\n            if self.level_table.levels[level_index].get(\"is_datum\", False):\r\n                NOTIFICATION.messenger(\"Cannot move DATUM level - it must stay at elevation 0\")\r\n                return\r\n            # Move up in elevation means move towards top of list (decrease grid index)\r\n            self.level_table.move_level_up(selected_index)\r\n            # Generate preview after moving level\r\n            self.level_table.refresh_preview(self.selected_surfaces)\r\n    \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_move_level_down(self, sender, e):\r\n        \"\"\"Move selected level down in elevation (towards bottom of list).\"\"\"\r\n        selected_rows = list(self.level_table.SelectedRows)\r\n        if selected_rows and len(selected_rows) > 0:\r\n            selected_index = selected_rows[0]\r\n            # Check if trying to move DATUM level\r\n            level_index = self.level_table.grid_index_to_level_index(selected_index)\r\n            if self.level_table.levels[level_index].get(\"is_datum\", False):\r\n                NOTIFICATION.messenger(\"Cannot move DATUM level - it must stay at elevation 0\")\r\n                return\r\n            # Move down in elevation means move towards bottom of list (increase grid index)\r\n            self.level_table.move_level_down(selected_index)\r\n            # Generate preview after moving level\r\n            self.level_table.refresh_preview(self.selected_surfaces)\r\n    \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_edit_level(self, sender, e):\r\n        \"\"\"Handle edit level button click - open simple edit dialog.\"\"\"\r\n        try:\r\n            # Check if any rows are selected\r\n            selected_rows = list(self.level_table.SelectedRows)\r\n            if not selected_rows or len(selected_rows) == 0:\r\n                NOTIFICATION.messenger(\"Please select a level to edit\")\r\n                return\r\n            \r\n            selected_index = selected_rows[0]\r\n            level_index = self.level_table.grid_index_to_level_index(selected_index)\r\n            \r\n            if level_index < 0 or level_index >= len(self.level_table.levels):\r\n                NOTIFICATION.messenger(\"Invalid level selection\")\r\n                return\r\n            \r\n            level = self.level_table.levels[level_index]\r\n            \r\n            # Create simple edit dialog\r\n            edit_dialog = Forms.Dialog()\r\n            edit_dialog.Title = \"Edit Level: {}\".format(level.get(\"name\", \"\"))\r\n            edit_dialog.Size = Drawing.Size(300, 200)\r\n            edit_dialog.Resizable = False\r\n            \r\n            # Create layout\r\n            layout = Forms.DynamicLayout()\r\n            layout.Padding = Drawing.Padding(10)\r\n            layout.Spacing = Drawing.Size(5, 5)\r\n            \r\n            # Level name input\r\n            layout.AddRow(Forms.Label(Text=\"Level Name:\"))\r\n            name_textbox = Forms.TextBox()\r\n            name_textbox.Text = level.get(\"name\", \"\")\r\n            layout.AddRow(name_textbox)\r\n            \r\n            # Height input\r\n            layout.AddRow(Forms.Label(Text=\"Floor-to-Floor Height:\"))\r\n            height_textbox = Forms.TextBox()\r\n            height_textbox.Text = str(level.get(\"height\", 0))\r\n            layout.AddRow(height_textbox)\r\n            \r\n            # Buttons\r\n            button_layout = Forms.DynamicLayout()\r\n            ok_button = Forms.Button(Text=\"OK\")\r\n            cancel_button = Forms.Button(Text=\"Cancel\")\r\n            \r\n            button_layout.AddRow(ok_button, cancel_button)\r\n            layout.AddRow(button_layout)\r\n            \r\n            edit_dialog.Content = layout\r\n            \r\n            # Disable preview during editing to avoid rapid-fire changes\r\n            self.level_table.disable_preview()\r\n            \r\n            # Handle button clicks\r\n            def on_ok_click(s, ev):\r\n                try:\r\n                    # Update level data\r\n                    level[\"name\"] = name_textbox.Text\r\n                    try:\r\n                        level[\"height\"] = float(height_textbox.Text)\r\n                        if level[\"height\"] < 0:\r\n                            level[\"height\"] = 0.0\r\n                    except (ValueError, TypeError):\r\n                        level[\"height\"] = 0.0\r\n                    \r\n                    # Save and refresh\r\n                    self.level_table.save_levels()\r\n                    self.level_table.load_data()\r\n                    \r\n                    # Re-enable preview and refresh\r\n                    self.level_table.enable_preview()\r\n                    self.level_table.refresh_preview(self.selected_surfaces)\r\n                    edit_dialog.Close()\r\n                except Exception as ex:\r\n                    print(\"ERROR updating level: {}\".format(str(ex)))\r\n                    NOTIFICATION.messenger(\"Error updating level: {}\".format(str(ex)))\r\n            \r\n            def on_cancel_click(s, ev):\r\n                # Re-enable preview even if cancelled\r\n                self.level_table.enable_preview()\r\n                edit_dialog.Close()\r\n            \r\n            ok_button.Click += on_ok_click\r\n            cancel_button.Click += on_cancel_click\r\n            \r\n            # Show dialog\r\n            edit_dialog.ShowModal()\r\n            \r\n        except Exception as ex:\r\n            print(\"ERROR in on_edit_level: {}\".format(str(ex)))\r\n            NOTIFICATION.messenger(\"Error opening edit dialog: {}\".format(str(ex)))\r\n\r\n    @ERROR_HANDLE.try_catch_error()\r\n    def on_create_massing(self, sender, e):\r\n        \"\"\"Create massing based on level configuration.\"\"\"\r\n        if not self.selected_surfaces:\r\n            NOTIFICATION.messenger(\"Please select surfaces first\")\r\n            return\r\n            \r\n        if not self.level_table.levels:\r\n            NOTIFICATION.messenger(\"Please configure at least one level\")\r\n            return\r\n       \r\n        self.Close()\r\n        self.create_massing()\r\n        \r\n    @ERROR_HANDLE.try_catch_error()\r\n    def create_massing(self):\r\n        \"\"\"Create massing based on configured levels.\"\"\"\r\n        if not self.selected_surfaces:\r\n            NOTIFICATION.messenger(\"No surfaces selected for massing\")\r\n            return\r\n            \r\n        if not self.level_table.levels:\r\n            NOTIFICATION.messenger(\"No levels configured\")\r\n            return\r\n\r\n        try:\r\n            # Use the unified preview logic with final creation flag\r\n            self.level_table.refresh_preview(self.selected_surfaces, is_final_creation=True)\r\n            \r\n            # Save level configuration after successful massing creation\r\n            self.level_table.save_levels()\r\n            \r\n            NOTIFICATION.messenger(\"Created final massing for {} surface(s)\".format(len(self.selected_surfaces)))\r\n            \r\n        except Exception as e:\r\n            NOTIFICATION.messenger(\"Error creating final massing: {}\".format(str(e)))\r\n            \r\n    # Old create_massing_for_surface method removed - now using unified preview logic\r\n    \r\n    # Old create_massing_upward and create_massing_downward methods removed - now using unified preview logic\r\n\r\n    \r\n    def save_surfaces(self):\r\n        \"\"\"Save selected surfaces to settings.\"\"\"\r\n        try:\r\n            if self.selected_surfaces:\r\n                DATA_FILE.set_sticky(\"quick_massing_surfaces\", self.selected_surfaces, DATA_FILE.DataType.STR, tiny_wait=True)\r\n        except Exception:\r\n            # If saving fails, continue silently\r\n            pass\r\n\r\n    def on_cancel_clicked(self, sender, e):\r\n        \"\"\"Handle cancel button click.\"\"\"\r\n        self.Close()\r\n        \r\n    def OnFormClosed(self, sender, e):\r\n        \"\"\"Handle form closed event.\"\"\"\r\n        # Clean up temp massing objects when dialog closes\r\n        try:\r\n            self.level_table.purge_temp_massing()\r\n        except Exception:\r\n            pass\r\n            \r\n        if sc.sticky.has_key(FORM_KEY):\r\n            del sc.sticky[FORM_KEY]\r\n        self.Close()\r\n\r\n\r\n# @ERROR_HANDLE.try_catch_error()\r\ndef quick_massing():\r\n    \"\"\"Open the QuickMassing dialog as a modeless UI in Rhino.\"\"\"\r\n    try:\r\n        if sc.sticky.has_key(FORM_KEY):\r\n            return\r\n            \r\n        dlg = QuickMassingDialog()\r\n        dlg.Owner = Rhino.UI.RhinoEtoApp.MainWindow\r\n        dlg.Show()\r\n        sc.sticky[FORM_KEY] = dlg\r\n    except Exception:\r\n        print (traceback.format_exc())\r\n    \r\nif __name__ == \"__main__\":\r\n    quick_massing()",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}