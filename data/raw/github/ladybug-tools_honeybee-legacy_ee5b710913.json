{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Export%20To%20OpenStudio.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Export To OpenStudio.py",
  "instruction": "Use this component to export HBZones into an OpenStudio file, and run them through EnergyPlus.\n_\nThe component outputs the report from the simulation, the file path of the IDF file, and the CSV...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools>, Chris Mackey <chris@ladybug.tools>, and Chien Si Harriman <charriman@terabuild.com>\n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to export HBZones into an OpenStudio file, and run them through EnergyPlus.\n_\nThe component outputs the report from the simulation, the file path of the IDF file, and the CSV result file from the EnergyPlus run, and two other result files that record outputs in different formats.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        north_: Input a vector to be used as a true North direction for the energy simulation or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n        _epwWeatherFile: An .epw file path on your system as a text string.\n        _analysisPeriod_: An optional analysis period from the Ladybug_Analysis Period component.  If no Analysis period is given, the energy simulation will be run for the enitre year.\n        _energySimPar_: Optional Energy Simulation Parameters from the \"Honeybee_Energy Simulation Par\" component.  If no value is connected here, the simulation will run with the following parameters:\n            1 - 6 timeSteps per hour\n            2 - A shadow calculation that averages over multiple days (as opposed to running it for each timeStep)\n            3 - A shadow calculation frequency of 30 (meaning that the shadow calulation is averaged over every 30 days)\n            4 - A maximum of 3000 points used in the shadow calculation. (This may need to be higher if you have a lot of detailed context geometry)\n            5 - A solar energy calculation that includes both interior and exterior light reflections.\n            6 - A simulation including a zone sizing calculation, a system sizing calculation, a plat sizing calculation, and a full run of the energy use ofver the analysis period.  The simulation is not run for the sizing period by default.\n            7 - A system sizing period that runs from the extreme periods of the weather file and not a ddy file.\n            8 - City terrian.\n        ::::::::::::::::::::::::::::::::::::::: ...\n        _HBZones: The HBZones that you wish to write into an OSM file and/or run through EnergyPlus.  These can be from any of the components that output HBZones.\n        HVACSystem_: A customized HVAC system modeled with Ironbug.\n        HBContext_: Optional HBContext geometry from the \"Honeybee_EP Context Surfaces.\" component.\n        simulationOutputs_: A list of the outputs that you would like EnergyPlus to write into the result CSV file.  This can be any set of any outputs that you would like from EnergyPlus, writen as a list of text that will be written into the IDF.  It is recommended that, if you are not expereinced with writing EnergyPlus outputs, you should use the \"Honeybee_Write EP Result Parameters\" component to request certain types of common outputs. \n        _OSMeasures: Any number of OpenStudio measures that you want to apply to your OpenStudio model. Use the \"Honeybee_Load OpenStudio Measure\" component to load a measure into Grasshopper.  OpenStudio measures can be downloaded from the NREL Building Components Library (BCL) at this link: https://bcl.nrel.gov/\n        additionalStrings_: THIS OPTION IS JUST FOR ADVANCED USERS OF ENERGYPLUS.  You can input additional text strings here that you would like written into the IDF.  The strings input here should be complete EnergyPlus objects that are correctly formatted.  You can input as many objects as you like in a list.  This input can be used to write objects into the IDF that are not currently supported by Honeybee.\n        ::::::::::::::::::::::::::::::::::::::: ...\n        _writeOSM: Set to \"True\" to have the component take your HBZones and other inputs and write them into an OSM file.  Note that only setting this to \"True\" and not setting the output below to \"True\" will not automatically run the file through EnergyPlus for you.\n        runSimulation_: Set to \"True\" to have the component generate an IDF file from the OSM file and run the IDF through through EnergyPlus.  Set to \"False\" to not run the file (this is the default).  You can also connect an integer for the following options:\n            0 = Do Not Run OSM and IDF thrrough EnergyPlus\n            1 = Run the OSM and IDF through EnergyPlus with a command prompt window that displays the progress of the simulation\n            2 = Run the OSM and IDF through EnergyPlus in the background (without the command line popup window).\n            3 = Generate an IDF from the OSM file but do not run it through EnergyPlus\n        openOpenStudio_: Set to \"True\" to open the OSM file in the OpenStudio interface.  This is useful if you want to visualize the HVAC system in OpenStudio, you want to edit the HVAC further in OpenStudio, or just want to run the simulation from OpenStudio instead of Rhino/GH.  Note that, for this to work, you must have .osm files associated with the OpenStudio application.\n        fileName_: Optional text which will be used to name your OSM, IDF and result files.  Change this to aviod over-writing results of previous energy simulations.\n        workingDir_: An optional working directory to a folder on your system, into which your OSM, IDF and result files will be written.  NOTE THAT DIRECTORIES INPUT HERE SHOULD NOT HAVE ANY SPACES OR UNDERSCORES IN THE FILE PATH.\n    Returns:\n        readMe!: Check here to see a report of the EnergyPlus run, including errors.\n        osmFileAddress: The file path of the OSM file that has been generated on your machine.\n        idfFileAddress: The file path of the IDF file that has been generated on your machine. This file is only generated when you set \"runSimulation_\" to \"True.\"\n        resultFileAddress: The file path of the CSV result file that has been generated on your machine.  This file is only generated when you set \"runSimulation_\" to \"True.\"\n        sqlFileAddress: The file path to the SQL result file that has been generated on your machine.  This file contains all results from the energy model run. This file is only generated when you set \"runSimulation_\" to \"True.\"\n        eioFileAddress:  The file path of the EIO file that has been generated on your machine.  This file contains information about the sizes of all HVAC equipment from the simulation.  This file is only generated when you set \"runSimulation_\" to \"True.\"\n        rddFileAddress: The file path of the Result Data Dictionary (.rdd) file that is generated after running the file through EnergyPlus.  This file contains all possible outputs that can be requested from the EnergyPlus model.  Use the \"Honeybee_Read Result Dictionary\" to see what outputs can be requested.\n        htmlReport: The file path to the HTML report that was generated after running the file through EnergyPlus.  Open this in a web browser for an overview of the energy model results.\n        studyFolder: The directory in which the simulation has been run.  Connect this to the 'Honeybee_Lookup EnergyPlus' folder to bring many of the files in this directory into Grasshopper.\n        model: The openStudio model ojbect. Use this output to generate gbXML files from your OpwnStudio models.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Export To OpenStudio\"\nghenv.Component.NickName = 'exportToOpenStudio'\nghenv.Component.Message = 'VER 0.0.66\\nAUG_11_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nMAY_18_2018\n#compatibleLBVersion = VER 0.0.59\\nJUL_24_2015\nghenv.Component.AdditionalHelpFromDocStrings = \"1\"\n\n\nimport os\nimport sys\nimport System\nimport scriptcontext as sc\nimport Rhino as rc\nimport Grasshopper.Kernel as gh\nimport time\nfrom pprint import pprint\nimport shutil\nimport copy\nimport math\nimport subprocess\nimport operator\nimport collections\nimport platform\n\nrc.Runtime.HostUtils.DisplayOleAlerts(False)\n\nassert platform.architecture()[0] == '64bit', \\\n    'You must use Rhino 64-bit to run OpenStudio not {}.'.format(platform.architecture()[0])\n\nosVersion = ''\nif sc.sticky.has_key('honeybee_release'):\n    if sc.sticky[\"honeybee_folders\"][\"OSLibPath\"] != None:\n        # openstudio is there\n        openStudioLibFolder = sc.sticky[\"honeybee_folders\"][\"OSLibPath\"]\n        openStudioIsReady = True\n        \n        # check the version of OpenStudio.\n        try:\n            osVersion = openStudioLibFolder.split('-')[-1].split('/')[0]\n        except:\n            pass\n        if 'ladybug_tools_legacy' in osVersion:\n            vernum1, vernum2 = 3, 0\n        else:\n            try:\n                vernum1, vernum2 = int(osVersion.split('.')[0]), int(osVersion.split('.')[1])\n            except:\n                vernum1 = 1\n                vernum2 = 0\n        \n        import clr\n        clr.AddReferenceToFileAndPath(openStudioLibFolder+\"\\\\openStudio.dll\")\n        \n        import sys\n        if openStudioLibFolder not in sys.path:\n            sys.path.append(openStudioLibFolder)\n        \n        import OpenStudio as ops\n    else:\n        openStudioIsReady = False\n        # let the user know that they need to download OpenStudio libraries\n        msg1 = \"You do not have OpenStudio installed on Your System.\\n\" + \\\n            \"You wont be able to use this component until you install it.\\n\" + \\\n            \"Download the latest OpenStudio for Windows from:\\n\"\n        msg2 = \"https://www.openstudio.net/downloads\"\n        print msg1\n        print msg2\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg1)\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg2)\nelse:\n    openStudioIsReady = False\n\n\nclass WriteOPS(object):\n\n    def __init__(self, EPParameters, weatherFilePath):\n        self.weatherFile = weatherFilePath # just for batch file as an alternate solution\n        self.lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        self.hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n        self.hb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\n        self.hb_EPScheduleAUX = sc.sticky[\"honeybee_EPScheduleAUX\"]()\n        self.hb_EPPar = sc.sticky[\"honeybee_EPParameters\"]()\n        self.simParameters = self.hb_EPPar.readEPParams(EPParameters)\n        \n        if self.simParameters[4] != None:\n            self.ddyFile = self.simParameters[4]\n            self.customddy = True\n        else:\n            self.ddyFile = weatherFilePath.replace(\".epw\", \".ddy\", 1)\n            self.customddy = False\n        \n        self.constructionList = {}\n        self.materialList = {}\n        self.scheduleList = {}\n        self.scheduleSetList = {}\n        self.peopleList = {}\n        self.lightingList = {}\n        self.equipList = {}\n        self.ventList = {}\n        self.internalMassList = {}\n        self.shdCntrlList = {}\n        self.frameObjList = {}\n        self.levels = {}\n        self.HVACSystemDict = {}\n        self.adjacentSurfacesDict = {}\n        self.adjacentFenSrfsDict = {}\n        self.thermalZonesDict = {}\n        self.spaceTypeDict = {}\n        \n        self.infiltList = []\n        self.schSetList = []\n        self.pplList = []\n        self.lightList = []\n        self.eqList = []\n        \n        self.csvSchedules = []\n        self.csvScheduleCount = 0\n        self.shadeCntrlToReplace = []\n        self.replaceShdCntrl = False\n        self.windowSpectralDatasets = {}\n        \n        self.waterSourceVRFs = {}\n        self.generatorCosts = []\n    \n    def setSimulationControls(self, model):\n        solarDist = self.simParameters[2]\n        simulationControls = self.simParameters[3]\n        \n        simControl = ops.Model.getSimulationControl(model);\n        simControl.setDoZoneSizingCalculation(simulationControls[0])\n        simControl.setDoSystemSizingCalculation(simulationControls[1])\n        simControl.setDoPlantSizingCalculation(simulationControls[2])\n        simControl.setRunSimulationforSizingPeriods(simulationControls[3])\n        simControl.setRunSimulationforWeatherFileRunPeriods(simulationControls[4])\n        if simulationControls[5] != '':\n            simControl.setMaximumNumberofWarmupDays(simulationControls[5])\n        if simulationControls[6] != '':\n            simControl.setMinimumNumberofWarmupDays(simulationControls[6])\n        \n        simControl.setSolarDistribution(solarDist)\n    \n    def setShadowCalculation(self, model):\n        calcMethod, freq, maxFigure = self.simParameters[1]\n        shadowCalculation = ops.Model.getShadowCalculation(model)\n        if vernum1 < 3:\n            shadowCalculation.setMaximumFiguresInShadowOverlapCalculations(int(maxFigure))\n            shadowCalculation.setCalculationFrequency(int(freq))\n        else:\n            shadowCalculation.setShadingCalculationUpdateFrequencyMethod(calcMethod)\n            shadowCalculation.setShadingCalculationUpdateFrequency(freq)\n            shadowCalculation.setMaximumFiguresInShadowOverlapCalculations(maxFigure)\n    \n    def setTimestep(self, model):\n        timestepInput = self.simParameters[0]\n        timestep = ops.Model.getTimestep(model)\n        timestep.setNumberOfTimestepsPerHour(int(timestepInput))\n    \n    def setSite(self, epwFilePath, model):\n        # Read the site from the EPW file.\n        epwfile = open(epwFilePath,\"r\")\n        headline = epwfile.readline()\n        csheadline = headline.split(',')\n        locName = csheadline[1]+'\\t'+csheadline[3]\n        lat = float(csheadline[6])\n        lngt = float(csheadline[7])\n        timeZone = float(csheadline[8])\n        try:\n            elev = float(csheadline[9][:-1])\n        except:\n            elev = float(csheadline[9])\n        epwfile.close()\n        \n        # Get the OpenStudio Model Site.\n        site = ops.Model.getSite(model)\n        \n        # Set the properties of the site.\n        site.setName(locName)\n        site.setLatitude(lat)\n        site.setLongitude(lngt)\n        site.setTimeZone(timeZone)\n        site.setElevation(elev)\n        \n        # Set weather file for OSM\n        ops.WeatherFile.setWeatherFile(model,ops.EpwFile(tryGetOSPath(epwFilePath)))\n    \n    def setStartDayOfWeek(self, model):\n        # The ability to set the start day of week currently breaks OpenStudio's way of assigning schedules.\n        # As a result, this feature of OpenStudio SDK is not being used now.\n        # Instead, any specified start day of the year is assigned in the IDF after export.\n        startDOW = self.simParameters[8]\n        if startDOW == None:\n            startDOW = \"UseWeatherFile\"\n        \n        yearDesc = ops.OpenStudioModelSimulation.getYearDescription(model)\n        yds = model.getObjectsByType(ops.IddObjectType(\"OS:YearDescription\"))\n        yds[0].setString(2, startDOW)\n    \n    def setHolidays(self, model):\n        # Even though holidays are built into OpenStudio SDK and written into the OSM,\n        # it seems like they are not yet written into the IDF.\n        # as a result, there is an additional function to add the holidays into the IDF later in this component.\n        if self.simParameters[7] != []:\n            for count, hol in enumerate(self.simParameters[7]):\n                holiday = ops.RunPeriodControlSpecialDays(hol, model)\n                holiday.setDuration(1)\n                holiday.setSpecialDayType(\"Holiday\")\n    \n    def setTerrain(self, model):\n        terrain = self.simParameters[5]\n        site = ops.Model.getSite(model)\n        site.setTerrain(terrain)\n    \n    def setGroundTemps(self, model):\n        grndTemps = self.simParameters[6]\n        if grndTemps != []:\n            opsGrndTemps = model.getSiteGroundTemperatureBuildingSurface()\n            opsGrndTemps.setJanuaryGroundTemperature(grndTemps[0])\n            opsGrndTemps.setFebruaryGroundTemperature(grndTemps[1])\n            opsGrndTemps.setMarchGroundTemperature(grndTemps[2])\n            opsGrndTemps.setAprilGroundTemperature(grndTemps[3])\n            opsGrndTemps.setMayGroundTemperature(grndTemps[4])\n            opsGrndTemps.setJuneGroundTemperature(grndTemps[5])\n            opsGrndTemps.setJulyGroundTemperature(grndTemps[6])\n            opsGrndTemps.setAugustGroundTemperature(grndTemps[7])\n            opsGrndTemps.setSeptemberGroundTemperature(grndTemps[8])\n            opsGrndTemps.setOctoberGroundTemperature(grndTemps[9])\n            opsGrndTemps.setNovemberGroundTemperature(grndTemps[10])\n            opsGrndTemps.setDecemberGroundTemperature(grndTemps[11])\n    \n    def setRunningPeriod(self, runningPeriod, model):\n        # get the days from numbers\n        stMonth, stDay, stHour, endMonth, endDay, endHour = self.lb_preparation.readRunPeriod(runningPeriod, True)\n        \n        runPeriod = ops.Model.getRunPeriod(model)\n        \n        runPeriod.setBeginDayOfMonth(stDay)\n        runPeriod.setBeginMonth(stMonth)\n        runPeriod.setEndDayOfMonth(endDay)\n        runPeriod.setEndMonth(endMonth)\n    \n    def setNorth(self, north, model):\n        northAngle, northVector = self.lb_preparation.angle2north(north)\n        building = ops.Model.getBuilding(model)\n        building.setNorthAxis(math.degrees(northAngle))\n    \n    def generateStories(self, HBZones, model):\n        levels = []\n        for HBZone in HBZones:\n            floorH = \"%.2f\"%HBZone.getFloorZLevel()\n            if float(floorH) not in levels:\n                levels.append(float(floorH))\n        \n        levels.sort()\n        for floorH in levels:\n            story = ops.BuildingStory(model)\n            story.setNominalZCoordinate(float(floorH))\n            key = \"%.2f\"%floorH\n            if str(key) == '-0.00':\n                key = '0.00'\n            self.levels[key] = story\n    \n    def setupLevels(self, zone, space):\n        floorH = \"%.2f\"%zone.getFloorZLevel()\n        if str(floorH) == '-0.00':\n            floorH = '0.00'\n        space.setBuildingStory(self.levels[floorH])\n        return space\n    \n    def setSizingFactors(self, model):\n        heatSizFac = self.simParameters[9]\n        coolSizFac = self.simParameters[10]\n        sizParams = ops.Model.getSizingParameters(model)\n        try:\n            sizParams.setHeatingSizingFactor(heatSizFac)\n        except:\n            pass\n        try:\n            sizParams.setCoolingSizingFactor(coolSizFac)\n        except:\n            pass\n    \n    def addDesignDays(self, model):\n        # check ddy file to be available\n        ddyFile = self.ddyFile\n        ddFound = False\n        \n        if not os.path.isfile(ddyFile):\n            print \"Can't find ddy file next to the EPW.\"\n            print \"Extreme values from the weather file design will be used instead.\"\n        else:\n            ddyPath = tryGetOSPath(ddyFile)\n            ddyIdf = ops.IdfFile.load(ddyPath, ops.IddFileType(\"EnergyPlus\"))\n            ddyWorkSpcae = ops.Workspace(ddyIdf.get())\n            reverseTranslator = ops.EnergyPlusReverseTranslator()\n            ddyModel = reverseTranslator.translateWorkspace(ddyWorkSpcae)\n            designDayVector = ddyModel.getDesignDays()\n            selectedDesignDays = ops.WorkspaceObjectVector()\n            for dday in designDayVector:\n                if self.customddy == True:\n                    selectedDesignDays.Add(dday)\n                    ddFound = True\n                if dday.name().get().find(\".4%\")> -1 or dday.name().get().find(\"99.6%\") > -1:\n                    selectedDesignDays.Add(dday)\n                    ddFound = True\n            model.addObjects(selectedDesignDays)\n        \n        return ddFound\n    \n    def writeDDObjStr(self, ddName, designType, month, day, dbTemp, dbTempRange, wbTemp, enth, humidConditType, pressure, windSpeed, windDir, ashraeSkyClearness):\n        ddStr =  '! ' + ddName + '\\n' + \\\n            'SizingPeriod:DesignDay,\\n' + \\\n            '\\t' + ddName + ',     !- Name\\n' + \\\n            '\\t' + str(month) + ',      !- Month\\n' + \\\n            '\\t' + str(day) + ',      !- Day of Month\\n' + \\\n            '\\t' + designType + ',!- Day Type\\n' + \\\n            '\\t' + str(dbTemp) + ',      !- Maximum Dry-Bulb Temperature {C}\\n' + \\\n            '\\t' + str(dbTempRange) + ',      !- Daily Dry-Bulb Temperature Range {C}\\n' + \\\n            '\\t' + 'DefaultMultipliers, !- Dry-Bulb Temperature Range Modifier Type\\n' + \\\n            '\\t' + ',      !- Dry-Bulb Temperature Range Modifier Schedule Name\\n' + \\\n            '\\t' + humidConditType + ',      !- Humidity Condition Type\\n' + \\\n            '\\t' + str(wbTemp) + ',      !- Wetbulb or Dewpoint at Maximum Dry-Bulb {C}\\n' + \\\n            '\\t' + ',      !- Humidity Indicating Day Schedule Name\\n' + \\\n            '\\t' + ',      !- Humidity Ratio at Maximum Dry-Bulb {kgWater/kgDryAir}\\n' + \\\n            '\\t' + str(enth) + ',      !- Enthalpy at Maximum Dry-Bulb {J/kg}\\n' + \\\n            '\\t' + ',      !- Daily Wet-Bulb Temperature Range {deltaC}\\n' + \\\n            '\\t' + str(pressure) + ',      !- Barometric Pressure {Pa}\\n' + \\\n            '\\t' + str(windSpeed) + ',      !- Wind Speed {m/s} design conditions vs. traditional 6.71 m/s (15 mph)\\n' + \\\n            '\\t' + str(windDir) + ',      !- Wind Direction {Degrees; N=0, S=180}\\n' + \\\n            '\\t' + 'No,      !- Rain {Yes/No}\\n' + \\\n            '\\t' + 'No,      !- Snow on ground {Yes/No}\\n' + \\\n            '\\t' + 'No,      !- Daylight Savings Time Indicator\\n' + \\\n            '\\t' + 'ASHRAEClearSky' + ', !- Solar Model Indicator\\n' + \\\n            '\\t' + ',      !- Beam Solar Day Schedule Name\\n' + \\\n            '\\t' + ',      !- Diffuse Solar Day Schedule Name\\n' + \\\n            '\\t' + ',      !- ASHRAE Clear Sky Optical Depth for Beam Irradiance (taub)\\n' + \\\n            '\\t' + ',      !- ASHRAE Clear Sky Optical Depth for Diffuse Irradiance (taud)\\n' + \\\n            '\\t' + str(ashraeSkyClearness) + ';      !- Clearness {0.0 to 1.1}\\n' + '\\n'\n        \n        return ddStr\n    \n    def createDdyFromEPW(self, epwWeatherFile, workingDir, lb_preparation, lb_comfortModels):\n        # Extract the relevant data from the EPW.\n        # We need the following: dbTemp, dewPoint, rH, windSpeed, windDir, windDir, wetBulb, enthalpy\n        dbTemp = []\n        dewPoint = []\n        rH = []\n        windSpeed = []\n        windDir = []\n        barPress = []\n        wetBulb = []\n        epwfile = open(epwWeatherFile,\"r\")\n        for count, line in enumerate(epwfile):\n            if count > 7:\n                dbTemp.append(float(line.split(',')[6]))\n                dewPoint.append(float(line.split(',')[7]))\n                rH.append(float(line.split(',')[8]))\n                barPress.append(float(line.split(',')[9]))\n                windSpeed.append(float(line.split(',')[21]))\n                windDir.append(float(line.split(',')[20]))\n        epwfile.close()\n        hR, enthalpy, pP, sP = lb_comfortModels.calcHumidRatio(dbTemp, rH, barPress)\n        for i, tem in enumerate(dbTemp):\n            wetBulb.append(lb_comfortModels.findWetBulb(tem, rH[i], barPress[i]))\n        \n        # Find the conditions for the most extreme hours in the epw.  These are the 7 extreme conditions we need:\n            # 1 - Winnter Design Day - Min Dry Bulb (Sensible Heating)\n            # 2 - Winter Design Day - Min Dew Point (Humidification)\n            # 3 - Winter Design Day = Max Wind Speed when temperature is less than 1 standard deviation of annual mean.\n            # 4 - Summer Design Day - Max Dry Bulb (Sensible Cooling)\n            # 5 - Summer Design Day - Max Wet Bulb (Dehumidification)\n            # 6 - Summer Design Day - Max Dew Point (Dehumidification)\n            # 7 - Summer Design Day - Max Enthalpy (Dehumidification)\n        sortedDB, corrWB = zip(*sorted(zip(dbTemp, wetBulb)))\n        minDB = sortedDB[34] # Design Condition 1\n        WBforMinDB = corrWB[34]\n        maxDB = sortedDB[-35] # Design Condition 4\n        WBforMaxDB = corrWB[-35]\n        sortedDP, corrDB = zip(*sorted(zip(dewPoint, dbTemp)))\n        minDP = sortedDP[34] # Design Condition 2\n        DBforMinDP = corrDB[34]\n        maxDP = sortedDP[-35] # Design Condition 6\n        DBforMaxDP = corrDB[-35]\n        sortedWB, corresDB = zip(*sorted(zip(wetBulb, dbTemp)))\n        maxWB = sortedWB[-35] # Design Condition 5\n        DBforMaxWB = corresDB[-35]\n        sortedEnth, correspondDB = zip(*sorted(zip(enthalpy, dbTemp)))\n        maxEnth = int(sortedEnth[-35] * 1000) # Design Condition 7\n        DBforMaxEnth = correspondDB[-35]\n        \n        coldStdDevTemp = sortedDB[1384]\n        hotStdDevTemp = sortedDB[-1385]\n        winSpBelowTemp = []\n        windDirBelowTemp = []\n        winSpAboveTemp = []\n        windDirAboveTemp = []\n        for i, tem in enumerate(dbTemp):\n            if tem < coldStdDevTemp:\n                winSpBelowTemp.append(windSpeed[i])\n                windDirBelowTemp.append(windDir[i])\n            elif tem > hotStdDevTemp:\n                winSpAboveTemp.append(windSpeed[i])\n                windDirAboveTemp.append(windDir[i])\n        winSpBelowTemp.sort()\n        coldMonWind = winSpBelowTemp[922]\n        coldMonWinDir = int(sum(windDirBelowTemp)/len(windDirBelowTemp))\n        maxWind = winSpBelowTemp[-5] # Design Condition 3\n        winSpAboveTemp.sort()\n        hotMonWind = winSpAboveTemp[922]\n        hotMonWinDir = int(sum(windDirAboveTemp)/len(windDirAboveTemp))\n        \n        # Calculate a few other required values from the epw data.\n        # Like average annual pressure and coldest/hottest month.\n        # and average wind speed/direction during these months.\n        avgEpwParPress = int(sum(barPress)/len(barPress))\n        \n        def binAndAvgByMonth(dataSet):\n            avgMonthData = []\n            binnedMonthData = []\n            for mon in range(12):\n                binnedMonthData.append([])\n            for i, x in enumerate(dataSet):\n                d, m, t = lb_preparation.hour2Date(i, True)\n                binnedMonthData[m].append(x)\n            for dataList in binnedMonthData:\n                avgMonthData.append(sum(dataList)/len(dataList))\n            return avgMonthData, binnedMonthData\n        \n        def partitionList(l, n):\n            for i in range(0, len(l), n):\n                yield l[i:i+n]\n        \n        avgMonTemps, binMonTemps = binAndAvgByMonth(dbTemp)\n        monNums = range(12)\n        avgMonTempsSort, monNumsSort = zip(*sorted(zip(avgMonTemps, monNums)))\n        coldMonth = monNumsSort[0]\n        hotMonth = monNumsSort[-1]\n        allHotMonthTemps = binMonTemps[hotMonth]\n        dayHotMonTemps = partitionList(allHotMonthTemps, 24)\n        dailyTempDiff = []\n        for day in dayHotMonTemps:\n            day.sort()\n            dailyTempDiff.append(day[-1]-day[0])\n        hotDayDBTempRange = (int((sum(dailyTempDiff)/len(dailyTempDiff))*100))/100\n        \n        \n        # Assemble a list of design condition strings to write into the ddy file.\n        ddStrs = []\n        ddStrs.append(self.writeDDObjStr('Ann Htg 99.6% Condns DB', 'WinterDesignDay', coldMonth+1, 21, minDB, 0, minDB, '', 'Wetbulb', avgEpwParPress, coldMonWind, coldMonWinDir, 0))\n        ddStrs.append(self.writeDDObjStr('Ann Hum_n 99.6% Condns DP=>MCDB', 'WinterDesignDay', coldMonth+1, 21, DBforMinDP, 0, minDP, '', 'Dewpoint', avgEpwParPress, coldMonWind, coldMonWinDir, 0))\n        ddStrs.append(self.writeDDObjStr('Ann Htg Wind 99.6% Condns WS=>MCDB', 'WinterDesignDay', coldMonth+1, 21, coldStdDevTemp, 0, coldStdDevTemp, '', 'Wetbulb', avgEpwParPress, maxWind, coldMonWinDir, 0))\n        \n        ddStrs.append(self.writeDDObjStr('Ann Clg .4% Condns DB=>MWB', 'SummerDesignDay', hotMonth+1, 21, maxDB, hotDayDBTempRange, WBforMaxDB, '', 'Wetbulb', avgEpwParPress, hotMonWind, hotMonWinDir, 1.2))\n        ddStrs.append(self.writeDDObjStr('Ann Clg .4% Condns WB=>MDB', 'SummerDesignDay', hotMonth+1, 21, DBforMaxWB, hotDayDBTempRange, maxWB, '', 'Wetbulb', avgEpwParPress, hotMonWind, hotMonWinDir, 1.2))\n        ddStrs.append(self.writeDDObjStr('Ann Clg .4% Condns DP=>MDB', 'SummerDesignDay', hotMonth+1, 21, DBforMaxDP, hotDayDBTempRange, maxDP, '', 'Dewpoint', avgEpwParPress, hotMonWind, hotMonWinDir, 1.2))\n        ddStrs.append(self.writeDDObjStr('Ann Clg .4% Condns Enth=>MDB', 'SummerDesignDay', hotMonth+1, 21, DBforMaxEnth, hotDayDBTempRange, '', maxEnth, 'Enthalpy', avgEpwParPress, hotMonWind, hotMonWinDir, 1.2))\n        \n        # Write the design day objects into a .ddy file.\n        epwFileName = epwWeatherFile.split('\\\\')[-1].split('.')[0]\n        self.ddyFile = workingDir + '\\\\' + epwFileName + '.ddy'\n        ddyFile = open(self.ddyFile, \"w\")\n        for sizingObj in ddStrs:\n            ddyFile.write(sizingObj)\n        ddyFile.close()\n    \n    def isConstructionInLib(self, constructionName):\n        return constructionName in self.constructionList\n    \n    def addConstructionToLib(self, constructionName, construction):\n        self.constructionList[constructionName] = construction\n    \n    def getConstructionFromLib(self, constructionName):\n        return self.constructionList[constructionName]\n    \n    def isMaterialInLib(self, materialName):\n        return materialName in self.materialList.keys()\n    \n    def addMaterialToLib(self, materialName, material):\n        self.materialList[materialName] = material\n        \n    def getMaterialFromLib(self, materialName):\n        return self.materialList[materialName]\n    \n    def isScheduleInLib(self, scheduleName):\n        return scheduleName in self.scheduleList.keys()\n        \n    def addScheduleToLib(self, scheduleName, schedule):\n        self.scheduleList[scheduleName] = schedule\n    \n    def getScheduleFromLib(self, scheduleName):\n        return self.scheduleList[scheduleName]\n    \n    def isShdCntrlInLib(self, shdCntrlName):\n        return shdCntrlName in self.shdCntrlList.keys()\n    \n    def addShdCntrlToLib(self, shdCntrlName, shdCntrl):\n        self.shdCntrlList[shdCntrlName] = shdCntrl\n        \n    def getShdCntrlFromLib(self, shdCntrlName):\n        return self.shdCntrlList[shdCntrlName]\n    \n    def isFrameObjInLib(self, frameObjName):\n        return frameObjName in self.frameObjList.keys()\n    \n    def addFrameObjToLib(self, frameObjName, frameObj):\n        self.frameObjList[frameObjName] = frameObj\n        \n    def getFrameObjFromLib(self, frameObjName):\n        return self.frameObjList[frameObjName]\n    \n    def createOSScheduleTypeLimitsFromValues(self, model, lowerLimit, upperLimit, numericType, unitType):\n        typeLimit = ops.ScheduleTypeLimits(model)\n        try: typeLimit.setLowerLimitValue(float(lowerLimit))\n        except: pass\n        try: typeLimit.setUpperLimitValue(float(upperLimit))\n        except: pass\n        typeLimit.setNumericType(numericType)\n        try: typeLimit.setUnitType(unitType)\n        except: pass\n        \n        return typeLimit\n    \n    def createOSScheduleTypeLimits(self, schdTypeLimitsName, model):\n        \"\"\"\n        ['ScheduleTypeLimits', '0', '1', 'Continuous']\n        ['Schedule Type', 'Lower Limit Value {BasedOnField A3}', 'Upper Limit Value {BasedOnField A3}', 'Numeric Type']\n        \"\"\"\n        \n        values, comments = self.hb_EPScheduleAUX.getScheduleTypeLimitsDataByName(schdTypeLimitsName, ghenv.Component)\n        typeLimit = ops.ScheduleTypeLimits(model)\n        try: typeLimit.setLowerLimitValue(float(values[1]))\n        except: pass\n        try: typeLimit.setUpperLimitValue(float(values[2]))\n        except: pass\n        typeLimit.setNumericType(values[3])\n        try: typeLimit.setUnitType(values[4])\n        except: pass\n        \n        return typeLimit\n    \n    def createConstantScheduleRuleset(self, ruleSetName, schName, typeLimitName, value, model):\n        scheduleRuleset = ops.ScheduleRuleset(model)\n        scheduleRuleset.setName(ruleSetName)\n        scheduleDay = scheduleRuleset.defaultDaySchedule()\n        scheduleDay.setName(schName)\n        scheduleDay.setScheduleTypeLimits(self.createOSScheduleTypeLimits(typeLimitName, model))\n        osUntilTime = ops.Time(1)\n        scheduleDay.removeValue(osUntilTime)\n        scheduleDay.addValue(osUntilTime, float(value))\n        return scheduleRuleset\n    \n    def createConstantOSSchedule(self, schName, values, model):\n        \"\"\"\n        'Schedule:Constant'\n        ['Schedule Type', 'Schedule Type Limits Name', 'Hourly Value']\n        \"\"\"\n        scheduleConstant = ops.ScheduleConstant(model)\n        scheduleConstant.setName(schName)\n        scheduleConstant.setValue(float(values[2]))\n        if values[1] != None:\n            typeLimitName = values[1]\n            try: scheduleConstant.setScheduleTypeLimits(self.getScheduleFromLib(typeLimitName))\n            except: scheduleConstant.setScheduleTypeLimits(typeLimitName)\n        return scheduleConstant\n        \n    def createDayOSSchedule(self, schName, values, model):\n        \"\"\"\n        Schedule:Day:Interval\n        ['Schedule Type', 'Schedule Type Limits Name', 'Interpolate to Timestep', 'Time 1 {hh:mm}', 'Value Until Time 1']\n        \"\"\"\n        scheduleDay = ops.ScheduleDay(model)\n        scheduleDay.setName(schName)\n        typeLimitName = values[1]\n        \n        scheduleDay.setScheduleTypeLimits(self.getScheduleFromLib(typeLimitName))\n        \n        numberOfDaySch = int((len(values) - 3) /2)\n\n        for i in range(numberOfDaySch):\n            untilTime = map(int, values[2 * i + 3].split(\":\"))\n            fractionalTime = untilTime[0] +  untilTime[1]/60\n            osUntilTime = ops.Time(fractionalTime/24)\n            scheduleDay.addValue(osUntilTime, float(values[2 * i + 4]))\n            \n        return scheduleDay\n        \n    def createWeeklyOSSchedule(self, schName, values, model):\n        \"\"\"\n        Schedule:Week:Daily\n        ['Schedule Type', 'Sunday Schedule:Day Name', 'Monday Schedule:Day Name',\n        'Tuesday Schedule:Day Name', 'Wednesday Schedule:Day Name', 'Thursday Schedule:Day Name',\n        'Friday Schedule:Day Name', 'Saturday Schedule:Day Name', 'Holiday Schedule:Day Name',\n        'SummerDesignDay Schedule:Day Name', 'WinterDesignDay Schedule:Day Name',\n        'CustomDay1 Schedule:Day Name', 'CustomDay2 Schedule:Day Name']\n        \"\"\"\n        \n        \n        weeklySchd = ops.ScheduleWeek(model)\n        weeklySchd.setName(schName)\n        \n        sundaySchedule = self.getOSSchedule(values[1], model)\n        weeklySchd.setSundaySchedule(sundaySchedule)\n        \n        mondaySchedule = self.getOSSchedule(values[2], model)\n        weeklySchd.setMondaySchedule(mondaySchedule)\n        \n        tuesdaySchedule = self.getOSSchedule(values[3], model)\n        weeklySchd.setTuesdaySchedule(tuesdaySchedule)\n        \n        wednesdaySchedule = self.getOSSchedule(values[4], model)\n        weeklySchd.setWednesdaySchedule(wednesdaySchedule)\n        \n        thursdaySchedule = self.getOSSchedule(values[5], model)\n        weeklySchd.setThursdaySchedule(thursdaySchedule)\n        \n        fridaySchedule = self.getOSSchedule(values[6], model)\n        weeklySchd.setFridaySchedule(fridaySchedule)\n        \n        saturdaySchedule = self.getOSSchedule(values[7], model)\n        weeklySchd.setSaturdaySchedule(saturdaySchedule)\n        \n        holidaySchedule = self.getOSSchedule(values[8], model)\n        weeklySchd.setHolidaySchedule(holidaySchedule)\n        \n        summerDesignDaySchedule = self.getOSSchedule(values[9], model)\n        weeklySchd.setSummerDesignDaySchedule(summerDesignDaySchedule)\n        \n        winterDesignDaySchedule = self.getOSSchedule(values[10], model)\n        weeklySchd.setWinterDesignDaySchedule(winterDesignDaySchedule)\n        \n        customDay1Schedule = self.getOSSchedule(values[11], model)\n        weeklySchd.setCustomDay1Schedule(customDay1Schedule)\n        \n        customDay2Schedule = self.getOSSchedule(values[12], model)\n        weeklySchd.setCustomDay2Schedule(customDay2Schedule)\n        \n        return weeklySchd\n    \n    def createYearlyOSSchedule(self, schName, values, model):\n        \"\"\"\n        \"Schedule:Year\"\n        \"\"\"\n        name = schName\n        typeLimitName = values[1]\n        schedule = ops.ScheduleYear(model)\n        schedule.setName(name)\n        schedule.setScheduleTypeLimits(self.getScheduleFromLib(typeLimitName))\n        \n        # generate weekly schedules\n        numOfWeeklySchedules = int((len(values)-2)/5)\n        \n        for i in range(numOfWeeklySchedules):\n            weekDayScheduleName = values[5 * i + 2]\n            startDate = ops.Date(ops.MonthOfYear(int(values[5 * i + 3])), int(values[5 * i + 4]))\n            endDate = ops.Date(ops.MonthOfYear(int(values[5 * i + 5])), int(values[5 * i + 6]))\n            \n            ScheduleWeek = self.getOSSchedule(weekDayScheduleName, model)\n            \n            schedule.addScheduleWeek(endDate, ScheduleWeek)\n            \n        return schedule\n    \n    def getOSSchedule(self, schName, model):\n        csvSched = False\n        if schName.lower().endswith(\".csv\"):\n            msg = \"Currently OpenStudio component des not support .csv file as a schedule.\\n\" + \\\n                      \"The schedule: \" + schName + \" will be written into IDF after it is translated from an OSM.\"\n            print msg\n            self.csvSchedules.append(schName)\n            self.csvScheduleCount += 1\n            csvSched = True\n        \n        if csvSched == True:\n            values, comments = self.hb_EPScheduleAUX.getScheduleDataByName('DEFAULTCSVPLACEHOLDER', ghenv.Component)\n            # Check the type limits.\n            with open(schName, \"r\") as schFile:\n                for lineCount, line in enumerate(schFile):\n                    if lineCount == 0:\n                        typeLims = line.split(',')[-1]\n            if 'dimensionless' not in typeLims.lower():\n                if typeLims.strip().lower() == 'temperature':\n                    values[1] = typeLims.strip() + ' 1'\n                elif 'daysim schedule file' in typeLims.lower():\n                    values[1] = 'fractional'\n                else:\n                    values[1] = typeLims.strip()\n        else:\n            values, comments = self.hb_EPScheduleAUX.getScheduleDataByName(schName, ghenv.Component)\n        \n        if values[0].lower() != \"schedule:week:daily\":\n            scheduleTypeLimitsName = values[1]\n            if not self.isScheduleInLib(scheduleTypeLimitsName):\n                OSScheduleTypeLimits = self.createOSScheduleTypeLimits(values[1], model)\n                self.addScheduleToLib(scheduleTypeLimitsName, OSScheduleTypeLimits)\n        \n        if not self.isScheduleInLib(schName):\n            if values[0].lower() == \"schedule:year\":\n                OSSchedule = self.createYearlyOSSchedule(schName, values, model)\n            elif values[0].lower() == \"schedule:day:interval\":\n                OSSchedule = self.createDayOSSchedule(schName, values, model)\n            elif values[0].lower() == \"schedule:week:daily\":\n                OSSchedule = self.createWeeklyOSSchedule(schName, values, model)\n            elif values[0].lower() == \"schedule:constant\":\n                OSSchedule = self.createConstantOSSchedule(schName, values, model)\n            else:\n                OSSchedule = None\n            \n            if OSSchedule!=None:\n                # add to library\n                self.addScheduleToLib(schName, OSSchedule)\n            \n            return OSSchedule\n        else:\n            return self.getScheduleFromLib(schName)\n    \n    def getOSFrameObj(self, frameObjName, model):\n        if not self.isFrameObjInLib(frameObjName):\n            values = sc.sticky[\"honeybee_WindowPropLib\"][frameObjName]\n            \n            OSFrameObj = ops.WindowPropertyFrameAndDivider(model)\n            OSFrameObj.setFrameWidth(float(values[1][0]))\n            OSFrameObj.setFrameConductance(float(values[4][0]))\n            OSFrameObj.setRatioOfFrameEdgeGlassConductanceToCenterOfGlassConductance(float(values[5][0]))\n            OSFrameObj.setFrameSolarAbsorptance(float(values[6][0]))\n            OSFrameObj.setFrameVisibleAbsorptance(float(values[7][0]))\n            OSFrameObj.setFrameThermalHemisphericalEmissivity(float(values[8][0]))\n            \n            self.addFrameObjToLib(frameObjName, OSFrameObj)\n            return OSFrameObj\n        else:\n            return self.getFrameObjFromLib(frameObjName)\n    \n    def getOSShdCntrl(self, shdCntrlName, parent_zone, model):\n        final_shd_cntrl_name = '{}_{}'.format(shdCntrlName, parent_zone)\n        if not self.isShdCntrlInLib(final_shd_cntrl_name):\n            # Make the shade control obect.\n            values = self.hb_EPObjectsAux.getEPObjectDataByName(shdCntrlName)\n            \n            if values[2][0] != '':\n                # Iniitalize for construction (for switchable glazing).\n                constrName = values[2][0]\n                if not self.isConstructionInLib(constrName):\n                    OSConstruction = self.getOSConstruction(constrName, model)\n                    self.addConstructionToLib(constrName, OSConstruction)\n                else:\n                    OSConstruction = self.getConstructionFromLib(constrName)\n                OSShdCntrl = ops.ShadingControl(OSConstruction)\n            else:\n                # Iniitalize for material (for blinds and shades).\n                materialName = values[8][0]\n                if not self.isMaterialInLib(materialName):\n                    OSMaterial = self.getOSMaterial(materialName, model)\n                    self.addMaterialToLib(materialName, OSMaterial)\n                else:\n                    OSMaterial = self.getMaterialFromLib(materialName)\n                \n                OSShdCntrl = ops.ShadingControl(OSMaterial)\n            \n            # Shading Type\n            if values[1][0] != '':\n                OSShdCntrl.setShadingType(values[1][0])\n            \n            # Shading Control Type.\n            if values[3][0] != '':\n                ### Openstudio currently does not support any shading control other than OnIfHighSolarOnWindow.\n                # As such, there is a workaround above for now.\n                if values[3][0] == 'OnIfHighSolarOnWindow' or (vernum1 >2 or (vernum1 == 2 and vernum2 >= 8)):\n                    OSShdCntrl.setShadingControlType(str(values[3][0]))\n                else:\n                    self.replaceShdCntrl = True\n            self.shadeCntrlToReplace.append([shdCntrlName, OSShdCntrl.name()])\n            \n            # Shading Schedule.\n            if values[4][0] != '':\n                osSched = self.getOSSchedule(values[4][0], model)\n                OSShdCntrl.setSchedule(osSched)\n            \n            # Shading setpoint.\n            if values[5][0] != '':\n                OSShdCntrl.setSetpoint(float(values[5][0]))\n            \n            # Openstudio also does not support a second setpoint.  This code really doen't do anything for now.\n            try:\n                setP2 = float(values[11][0])\n                OSShdCntrl.setDouble(12, setP2)\n            except:\n                pass\n            \n            self.addShdCntrlToLib(final_shd_cntrl_name, OSShdCntrl)\n            return OSShdCntrl\n        else:\n            return self.getShdCntrlFromLib(final_shd_cntrl_name)\n    \n    def assignThermalZone(self, zone, space, model):\n        thermalZone = ops.ThermalZone(model)\n        ops.OpenStudioModelHVAC.setThermalZone(space, thermalZone)\n        thermalZone.setName(zone.name)\n        if zone.isPlenum or not zone.partOfArea:\n            space.partofTotalFloorArea = False\n        if zone.multiplier and zone.multiplier != 1:\n            thermalZone.setMultiplier(zone.multiplier)\n        if zone.ceilingHeight:\n            thermalZone.setCeilingHeight(zone.ceilingHeight)\n        if zone.volume:\n            thermalZone.setVolume(zone.volume)\n        if zone.insideConvectionAlgorithm:\n            thermalZone.setZoneInsideConvectionAlgorithm(zone.insideConvectionAlgorithm)\n        if zone.outsideConvectionAlgorithm:\n            thermalZone.setZoneOutsideConvectionAlgorithm(zone.outsideConvectionAlgorithm)\n        return space, thermalZone\n    \n    ### START OF FUNCTIONS FOR CREATING HVAC SYSTEMS FROM SCRATCH ###\n    \"\"\"\n    These functions are a python adaptation of several functions from the OsLib_HVAC.rb.\n    These ruby versions of these functions are used for many of the \n    Advanced Energy Design Guideline (AEDG) measures that have been released by NREL.\n    \"\"\"\n    def createDefaultAEDGPump(self, model, pEfficiency, pressRise=119563):\n        pump = ops.PumpVariableSpeed(model)\n        pump.setRatedPumpHead(pressRise) #Pa\n        pump.setMotorEfficiency(pEfficiency)\n        pump.setCoefficient1ofthePartLoadPerformanceCurve(0)\n        pump.setCoefficient2ofthePartLoadPerformanceCurve(0.0216)\n        pump.setCoefficient3ofthePartLoadPerformanceCurve(-0.0325)\n        pump.setCoefficient4ofthePartLoadPerformanceCurve(1.0095)\n        return pump\n    \n    def createDefaultAEDGFan(self, fanType, model, airDetails):\n        if fanType == 'CV':\n            fan = ops.FanConstantVolume(model, model.alwaysOnDiscreteSchedule())\n        elif fanType == 'VV':\n            fan = ops.FanVariableVolume(model, model.alwaysOnDiscreteSchedule())\n        \n        if airDetails != None and airDetails.fanTotalEfficiency != 'Default': \n            fan.setFanEfficiency(airDetails.fanTotalEfficiency)\n        else:\n            if fanType == 'CV':\n                fan.setFanEfficiency(0.6)\n            else:\n                fan.setFanEfficiency(0.69)\n        if airDetails != None and airDetails.fanPressureRise != 'Default': \n            fan.setPressureRise(airDetails.fanPressureRise)\n        else:\n            if fanType == 'CV':\n                fan.setPressureRise(500) #Pa\n            else:\n                fan.setPressureRise(1125) #Pa\n        if airDetails != None and airDetails.airSysHardSize != 'Default':\n            fan.setMaximumFlowRate(float(airDetails.airSysHardSize))\n        else:\n            fan.autosizeMaximumFlowRate()\n        if airDetails != None and airDetails.fanMotorEfficiency != 'Default':\n            fan.setMotorEfficiency(airDetails.fanMotorEfficiency)\n        else:\n            fan.setMotorEfficiency(0.9)\n        fan.setMotorInAirstreamFraction(1.0)\n        return fan\n    \n    def createDefaultGroundSourceChiller(self, model, coolingDetails, HVACCount, heatingDetails):\n        # cooling\n        # create clgCapFuncTempCurve\n        clgCapFuncTempCurve = ops.CurveBiquadratic(model)\n        clgCapFuncTempCurve.setName('ChillerHeaterClgCapFT' +str(HVACCount))\n        clgCapFuncTempCurve.setCoefficient1Constant(0.950829)\n        clgCapFuncTempCurve.setCoefficient2x(0.03419327)\n        clgCapFuncTempCurve.setCoefficient3xPOW2(0.000266642)\n        clgCapFuncTempCurve.setCoefficient4y(-0.001733397)\n        clgCapFuncTempCurve.setCoefficient5yPOW2(-0.0001762417)\n        clgCapFuncTempCurve.setCoefficient6xTIMESY(-0.0000369198)\n        clgCapFuncTempCurve.setMinimumValueofx(4.44)\n        clgCapFuncTempCurve.setMaximumValueofx(12.78)\n        clgCapFuncTempCurve.setMinimumValueofy(12.78)\n        clgCapFuncTempCurve.setMaximumValueofy(29.44)\n        clgCapFuncTempCurve.setInputUnitTypeforX('Temperature')\n        clgCapFuncTempCurve.setInputUnitTypeforY('Temperature')\n        clgCapFuncTempCurve.setOutputUnitType('Dimensionless')\n        \n        # create eirFuncTempCurve\n        eirFuncTempCurve = ops.CurveBiquadratic(model)\n        eirFuncTempCurve.setName('ChillerHeaterClgEIRFT' +str(HVACCount))\n        eirFuncTempCurve.setCoefficient1Constant(0.7362431)\n        eirFuncTempCurve.setCoefficient2x(0.02136491)\n        eirFuncTempCurve.setCoefficient3xPOW2(0.0003638909)\n        eirFuncTempCurve.setCoefficient4y(-0.004284947)\n        eirFuncTempCurve.setCoefficient5yPOW2(0.0003389817)\n        eirFuncTempCurve.setCoefficient6xTIMESY(-0.0003632396)\n        eirFuncTempCurve.setMinimumValueofx(4.44)\n        eirFuncTempCurve.setMaximumValueofx(12.78)\n        eirFuncTempCurve.setMinimumValueofy(12.78)\n        eirFuncTempCurve.setMaximumValueofy(29.44)\n        eirFuncTempCurve.setInputUnitTypeforX('Temperature')\n        eirFuncTempCurve.setInputUnitTypeforY('Temperature')\n        eirFuncTempCurve.setOutputUnitType('Dimensionless')\n        \n        # create eirFuncPlrCurve\n        eirFuncPlrCurve = ops.CurveBicubic(model)\n        eirFuncPlrCurve.setName('ChillerHeaterClgEIRFPLR' +str(HVACCount))\n        eirFuncPlrCurve.setCoefficient1Constant(0)\n        eirFuncPlrCurve.setCoefficient2x(1.22895)\n        eirFuncPlrCurve.setCoefficient3xPOW2(-0.751383)\n        eirFuncPlrCurve.setCoefficient7xPOW3(0.517396)\n        eirFuncPlrCurve.setMinimumValueofx(0.2)\n        eirFuncPlrCurve.setMaximumValueofx(1)\n        \n        # heating\n        # create htgCapFuncTempCurve\n        htgCapFuncTempCurve = ops.CurveBiquadratic(model)\n        htgCapFuncTempCurve.setName('ChillerHeaterHtgCapFT' +str(HVACCount))\n        htgCapFuncTempCurve.setCoefficient1Constant(0.9415266)\n        htgCapFuncTempCurve.setCoefficient2x(0.05527431)\n        htgCapFuncTempCurve.setCoefficient3xPOW2(0.0003573558)\n        htgCapFuncTempCurve.setCoefficient4y(0.001258391)\n        htgCapFuncTempCurve.setCoefficient5yPOW2(-0.00006420546)\n        htgCapFuncTempCurve.setCoefficient6xTIMESY(-0.0005350989)\n        htgCapFuncTempCurve.setMinimumValueofx(4.44)\n        htgCapFuncTempCurve.setMaximumValueofx(15.56)\n        htgCapFuncTempCurve.setMinimumValueofy(35)\n        htgCapFuncTempCurve.setMaximumValueofy(57.22)\n        htgCapFuncTempCurve.setInputUnitTypeforX('Temperature')\n        htgCapFuncTempCurve.setInputUnitTypeforY('Temperature')\n        htgCapFuncTempCurve.setOutputUnitType('Dimensionless')\n        \n        # create eirFuncTempCurve\n        chillerHeaterHtgEIRFT = ops.CurveBiquadratic(model)\n        chillerHeaterHtgEIRFT.setName('ChillerHeaterHtgEIRFT' +str(HVACCount))\n        chillerHeaterHtgEIRFT.setCoefficient1Constant(0.2286246)\n        chillerHeaterHtgEIRFT.setCoefficient2x(0.02498714)\n        chillerHeaterHtgEIRFT.setCoefficient3xPOW2(-0.00001267106)\n        chillerHeaterHtgEIRFT.setCoefficient4y(0.009327184)\n        chillerHeaterHtgEIRFT.setCoefficient5yPOW2(0.00005892037)\n        chillerHeaterHtgEIRFT.setCoefficient6xTIMESY(-0.0003268512)\n        chillerHeaterHtgEIRFT.setMinimumValueofx(4.44)\n        chillerHeaterHtgEIRFT.setMaximumValueofx(15.56)\n        chillerHeaterHtgEIRFT.setMinimumValueofy(35)\n        chillerHeaterHtgEIRFT.setMaximumValueofy(57.22)\n        chillerHeaterHtgEIRFT.setInputUnitTypeforX('Temperature')\n        chillerHeaterHtgEIRFT.setInputUnitTypeforY('Temperature')\n        chillerHeaterHtgEIRFT.setOutputUnitType('Dimensionless')\n        \n        # create eirFuncPlrCurve\n        chillerHeaterHtgEIRFPLR = ops.CurveBicubic(model)\n        chillerHeaterHtgEIRFPLR.setName('ChillerHeaterHtgEIRFPLR' +str(HVACCount))\n        chillerHeaterHtgEIRFPLR.setCoefficient1Constant(0)\n        chillerHeaterHtgEIRFPLR.setCoefficient2x(1.12853)\n        chillerHeaterHtgEIRFPLR.setCoefficient3xPOW2(-0.0264962)\n        chillerHeaterHtgEIRFPLR.setCoefficient7xPOW3(-0.103811)\n        chillerHeaterHtgEIRFPLR.setMinimumValueofx(0.3)\n        chillerHeaterHtgEIRFPLR.setMaximumValueofx(1)\n        \n        # performance of entire heat pump system.\n        chiller1 = ops.ChillerHeaterPerformanceElectricEIR(model, clgCapFuncTempCurve, eirFuncTempCurve, \n            eirFuncPlrCurve, htgCapFuncTempCurve, chillerHeaterHtgEIRFT, chillerHeaterHtgEIRFPLR)\n        \n        # For now I need to ard size the system to get it to run correctly.\n        # This a bug in EnergyPlus.\n        # See here for more information:\n        # https://github.com/NREL/EnergyPlus/issues/6445\n        if coolingDetails != None and coolingDetails.coolHardSize != 'Autosize':\n            chiller1.setReferenceCoolingModeEvaporatorCapacity(float(coolingDetails.coolHardSize))\n        if heatingDetails != None and heatingDetails.heatHardSize != 'Autosize':\n            chiller1.setReferenceHeatingModeCoolingCapacityRatio(float(heatingDetails.heatHardSize) / float(str(chiller1.referenceCoolingModeEvaporatorCapacity())))\n        \n        # set the properties of the chiller/heater\n        if coolingDetails != None and coolingDetails.coolingCOP != 'Default':\n            chiller1.setReferenceCoolingModeCOP(coolingDetails.coolingCOP)\n        else:\n            chiller1.setReferenceCoolingModeCOP(5.5)\n        if coolingDetails != None and coolingDetails.supplyTemperature != 'Default':\n            chiller1.setReferenceLeavingChilledWaterTemperature(coolingDetails.supplyTemperature)\n        chiller1.setCondenserType(\"WaterCooled\")\n        chiller1.setChilledWaterFlowModeType(\"VariableFlow\")\n        \n        # create the two modules\n        centralPumpModule1 = ops.CentralHeatPumpSystemModule(model)\n        centralPumpModule1.setChillerHeaterModulesPerformanceComponent(chiller1)\n        centralPumpModule1.setNumberofChillerHeaterModules(2)\n        \n        # construct the system\n        centralPumpSystem = ops.CentralHeatPumpSystem(model)\n        centralPumpSystem.addModule(centralPumpModule1)\n        \n        return centralPumpSystem\n    \n    def createDefaultAEDGWaterChiller(self, model, coolingDetails):\n        # create clgCapFuncTempCurve\n        clgCapFuncTempCurve = ops.CurveBiquadratic(model)\n        clgCapFuncTempCurve.setCoefficient1Constant(1.07E+00)\n        clgCapFuncTempCurve.setCoefficient2x(4.29E-02)\n        clgCapFuncTempCurve.setCoefficient3xPOW2(4.17E-04)\n        clgCapFuncTempCurve.setCoefficient4y(-8.10E-03)\n        clgCapFuncTempCurve.setCoefficient5yPOW2(-4.02E-05)\n        clgCapFuncTempCurve.setCoefficient6xTIMESY(-3.86E-04)\n        clgCapFuncTempCurve.setMinimumValueofx(0)\n        clgCapFuncTempCurve.setMaximumValueofx(20)\n        clgCapFuncTempCurve.setMinimumValueofy(0)\n        clgCapFuncTempCurve.setMaximumValueofy(50)\n        # create eirFuncTempCurve\n        eirFuncTempCurve = ops.CurveBiquadratic(model)\n        eirFuncTempCurve.setCoefficient1Constant(4.68E-01)\n        eirFuncTempCurve.setCoefficient2x(-1.38E-02)\n        eirFuncTempCurve.setCoefficient3xPOW2(6.98E-04)\n        eirFuncTempCurve.setCoefficient4y(1.09E-02)\n        eirFuncTempCurve.setCoefficient5yPOW2(4.62E-04)\n        eirFuncTempCurve.setCoefficient6xTIMESY(-6.82E-04)\n        eirFuncTempCurve.setMinimumValueofx(0)\n        eirFuncTempCurve.setMaximumValueofx(20)\n        eirFuncTempCurve.setMinimumValueofy(0)\n        eirFuncTempCurve.setMaximumValueofy(50)\n        # create eirFuncPlrCurve\n        eirFuncPlrCurve = ops.CurveQuadratic(model)\n        eirFuncPlrCurve.setCoefficient1Constant(1.41E-01)\n        eirFuncPlrCurve.setCoefficient2x(6.55E-01)\n        eirFuncPlrCurve.setCoefficient3xPOW2(2.03E-01)\n        eirFuncPlrCurve.setMinimumValueofx(0)\n        eirFuncPlrCurve.setMaximumValueofx(1.2)\n        # construct chiller\n        chiller = ops.ChillerElectricEIR(model,clgCapFuncTempCurve,eirFuncTempCurve,eirFuncPlrCurve)\n        if coolingDetails != None and coolingDetails.coolingCOP != 'Default':\n            chiller.setReferenceCOP(coolingDetails.coolingCOP)\n        else:\n            chiller.setReferenceCOP(5.5)\n        if coolingDetails != None and coolingDetails.supplyTemperature != 'Default':\n            chiller.setReferenceLeavingChilledWaterTemperature(coolingDetails.supplyTemperature)\n        if coolingDetails != None and coolingDetails.coolHardSize != 'Autosize':\n            chiller.setReferenceCapacity(float(coolingDetails.coolHardSize))\n        chiller.setCondenserType(\"WaterCooled\")\n        chiller.setChillerFlowMode(\"ConstantFlow\")\n        \n        return chiller\n    \n    def createDefaultAEDGAirChiller(self, model, coolingDetails):\n        # create clgCapFuncTempCurve\n        clgCapFuncTempCurve = ops.CurveBiquadratic(model)\n        clgCapFuncTempCurve.setCoefficient1Constant(1.05E+00)\n        clgCapFuncTempCurve.setCoefficient2x(3.36E-02)\n        clgCapFuncTempCurve.setCoefficient3xPOW2(2.15E-04)\n        clgCapFuncTempCurve.setCoefficient4y(-5.18E-03)\n        clgCapFuncTempCurve.setCoefficient5yPOW2(-4.42E-05)\n        clgCapFuncTempCurve.setCoefficient6xTIMESY(-2.15E-04)\n        clgCapFuncTempCurve.setMinimumValueofx(0)\n        clgCapFuncTempCurve.setMaximumValueofx(20)\n        clgCapFuncTempCurve.setMinimumValueofy(0)\n        clgCapFuncTempCurve.setMaximumValueofy(50)\n        # create eirFuncTempCurve\n        eirFuncTempCurve = ops.CurveBiquadratic(model)\n        eirFuncTempCurve.setCoefficient1Constant(5.83E-01)\n        eirFuncTempCurve.setCoefficient2x(-4.04E-03)\n        eirFuncTempCurve.setCoefficient3xPOW2(4.68E-04)\n        eirFuncTempCurve.setCoefficient4y(-2.24E-04)\n        eirFuncTempCurve.setCoefficient5yPOW2(4.81E-04)\n        eirFuncTempCurve.setCoefficient6xTIMESY(-6.82E-04)\n        eirFuncTempCurve.setMinimumValueofx(0)\n        eirFuncTempCurve.setMaximumValueofx(20)\n        eirFuncTempCurve.setMinimumValueofy(0)\n        eirFuncTempCurve.setMaximumValueofy(50)\n        # create eirFuncPlrCurve\n        eirFuncPlrCurve = ops.CurveQuadratic(model)\n        eirFuncPlrCurve.setCoefficient1Constant(4.19E-02)\n        eirFuncPlrCurve.setCoefficient2x(6.25E-01)\n        eirFuncPlrCurve.setCoefficient3xPOW2(3.23E-01)\n        eirFuncPlrCurve.setMinimumValueofx(0)\n        eirFuncPlrCurve.setMaximumValueofx(1.2)\n        # construct chiller\n        chiller = ops.ChillerElectricEIR(model,clgCapFuncTempCurve,eirFuncTempCurve,eirFuncPlrCurve)\n        if coolingDetails != None and coolingDetails.coolingCOP != 'Default':\n            chiller.setReferenceCOP(coolingDetails.coolingCOP)\n        else:\n            chiller.setReferenceCOP(2.93)\n        if coolingDetails != None and coolingDetails.supplyTemperature != 'Default':\n            chiller.setReferenceLeavingChilledWaterTemperature(coolingDetails.supplyTemperature)\n        if coolingDetails != None and coolingDetails.coolHardSize != 'Autosize':\n            chiller.setReferenceCapacity(float(coolingDetails.coolHardSize))\n        chiller.setCondenserType(\"AirCooled\")\n        chiller.setChillerFlowMode(\"ConstantFlow\")\n        return chiller\n    \n    def createHotWaterPlant(self, model, hotWaterSetpointSchedule, heatingDetails, HVACCount, radLoop = False):\n        hotWaterPlant = ops.PlantLoop(model)\n        if radLoop == True:\n            hotWaterPlant.setName(\"Hot Water Radiant Loop\" + str(HVACCount))\n        else:\n            hotWaterPlant.setName(\"Hot Water Loop\" + str(HVACCount))\n        hotWaterPlant.setMaximumLoopTemperature(100)\n        hotWaterPlant.setMinimumLoopTemperature(0)\n        loopSizing = hotWaterPlant.sizingPlant()\n        loopSizing.setLoopType(\"Heating\")\n        loopSizing.setDesignLoopExitTemperature(82)  \n        loopSizing.setLoopDesignTemperatureDifference(11)\n        # create a pump\n        if heatingDetails != None and heatingDetails.pumpMotorEfficiency != 'Default':\n            pEfficiency = heatingDetails.pumpMotorEfficiency\n        else:\n            pEfficiency = 0.9\n        pump = self.createDefaultAEDGPump(model, pEfficiency)\n        \n        # create a boiler\n        boiler = ops.BoilerHotWater(model)\n        if heatingDetails != None and heatingDetails.heatingEffOrCOP != 'Default':\n            boiler.setNominalThermalEfficiency(heatingDetails.heatingEffOrCOP)\n        else:\n            boiler.setNominalThermalEfficiency(0.9)\n        if heatingDetails != None and heatingDetails.heatHardSize != 'Autosize':\n            boiler.setNominalCapacity(float(heatingDetails.heatHardSize))\n        # boiler efficiency curve\n        boilerEfficiency = ops.CurveBiquadratic(model)\n        boilerEfficiency.setName(\"Boiler Efficiency\" + str(HVACCount))\n        boilerEfficiency.setCoefficient1Constant(1)\n        boilerEfficiency.setCoefficient2x(0)\n        boilerEfficiency.setCoefficient3xPOW2(0)\n        boilerEfficiency.setCoefficient4y(0)\n        boilerEfficiency.setCoefficient5yPOW2(0)\n        boilerEfficiency.setCoefficient6xTIMESY(0)\n        boilerEfficiency.setMinimumValueofx(0)\n        boilerEfficiency.setMaximumValueofx(1)\n        boilerEfficiency.setMinimumValueofy(0)\n        boilerEfficiency.setMaximumValueofy(1)\n        boiler.setNormalizedBoilerEfficiencyCurve(boilerEfficiency)\n        boiler.setEfficiencyCurveTemperatureEvaluationVariable('LeavingBoiler')\n        \n        # create a scheduled setpoint manager\n        setpointManagerScheduled = ops.SetpointManagerScheduled(model,hotWaterSetpointSchedule)\n        # create pipes\n        pipeSupplyBypass = ops.PipeAdiabatic(model)\n        pipeSupplyOutlet = ops.PipeAdiabatic(model)\n        pipeDemandBypass = ops.PipeAdiabatic(model)\n        pipeDemandInlet = ops.PipeAdiabatic(model)\n        pipeDemandOutlet = ops.PipeAdiabatic(model)\n        # connect components to plant loop\n        # supply side components\n        hotWaterPlant.addSupplyBranchForComponent(boiler)\n        hotWaterPlant.addSupplyBranchForComponent(pipeSupplyBypass)\n        pump.addToNode(hotWaterPlant.supplyInletNode())\n        pipeSupplyOutlet.addToNode(hotWaterPlant.supplyOutletNode())\n        setpointManagerScheduled.addToNode(hotWaterPlant.supplyOutletNode())\n        # demand side components (water coils are added as they are added to airloops and zoneHVAC)\n        hotWaterPlant.addDemandBranchForComponent(pipeDemandBypass)\n        pipeDemandInlet.addToNode(hotWaterPlant.demandInletNode())\n        pipeDemandOutlet.addToNode(hotWaterPlant.demandOutletNode())\n        \n        # pass back hot water plant\n        return hotWaterPlant\n    \n    def createChilledWaterPlant(self, model, chilledWaterSetpointSchedule, coolingDetails, HVACCount, chillerType, radLoop=False, heatingDetails=None):\n        chilleWaterPlant = ops.PlantLoop(model)\n        if radLoop == True:\n            chilleWaterPlant.setName(\"Chilled Water Radiant Loop\" + str(HVACCount))\n        else:\n            chilleWaterPlant.setName(\"Chilled Water Loop\" + str(HVACCount))\n        chilleWaterPlant.setMaximumLoopTemperature(98)\n        chilleWaterPlant.setMinimumLoopTemperature(1)\n        loopSizing = chilleWaterPlant.sizingPlant()\n        loopSizing.setLoopType(\"Cooling\")\n        loopSizing.setDesignLoopExitTemperature(6.7)  \n        loopSizing.setLoopDesignTemperatureDifference(6.7)\n        # create a pump\n        if coolingDetails != None and coolingDetails.pumpMotorEfficiency != 'Default':\n            pEfficiency = coolingDetails.pumpMotorEfficiency\n        else:\n            pEfficiency = 0.9\n        pump = self.createDefaultAEDGPump(model, pEfficiency)\n        # create a chiller\n        if chillerType == \"WaterCooled\":\n            chiller = self.createDefaultAEDGWaterChiller(model, coolingDetails)\n        elif chillerType == \"AirCooled\":\n            chiller = self.createDefaultAEDGAirChiller(model, coolingDetails)\n        elif chillerType == \"GroundSourced\":\n            chiller = self.createDefaultGroundSourceChiller(model, coolingDetails, HVACCount, heatingDetails)\n        \n        # create a scheduled setpoint manager\n        setpointManagerScheduled = ops.SetpointManagerScheduled(model, chilledWaterSetpointSchedule)\n        # create pipes\n        pipeSupplyBypass = ops.PipeAdiabatic(model)\n        pipeSupplyOutlet = ops.PipeAdiabatic(model)\n        pipeDemandBypass = ops.PipeAdiabatic(model)\n        pipeDemandInlet = ops.PipeAdiabatic(model)\n        pipeDemandOutlet = ops.PipeAdiabatic(model)\n        # connect components to plant loop\n        # supply side components\n        chilleWaterPlant.addSupplyBranchForComponent(chiller)\n        chilleWaterPlant.addSupplyBranchForComponent(pipeSupplyBypass)\n        pump.addToNode(chilleWaterPlant.supplyInletNode())\n        pipeSupplyOutlet.addToNode(chilleWaterPlant.supplyOutletNode())\n        setpointManagerScheduled.addToNode(chilleWaterPlant.supplyOutletNode())\n        # demand side components (water coils are added as they are added to airloops and ZoneHVAC)\n        chilleWaterPlant.addDemandBranchForComponent(pipeDemandBypass)\n        pipeDemandInlet.addToNode(chilleWaterPlant.demandInletNode())\n        pipeDemandOutlet.addToNode(chilleWaterPlant.demandOutletNode())\n        \n        # pass back chilled water plant\n        return chilleWaterPlant\n    \n    def createCondenser(self, model, chillerWaterPlant, HVACCount):\n        # create condenser loop for water-cooled chiller(s)\n        condenserLoop = ops.PlantLoop(model)\n        condenserLoop.setName(\"AEDG Condenser Loop\"  + str(HVACCount))\n        condenserLoop.setMaximumLoopTemperature(80)\n        condenserLoop.setMinimumLoopTemperature(5)\n        loopSizing = condenserLoop.sizingPlant()\n        loopSizing.setLoopType(\"Condenser\")\n        loopSizing.setDesignLoopExitTemperature(29.4)\n        loopSizing.setLoopDesignTemperatureDifference(5.6)\n        # create a pump\n        pump = self.createDefaultAEDGPump(model, 0.9, pressRise=134508)\n        # create a cooling tower\n        tower = ops.CoolingTowerVariableSpeed(model)\n        # create pipes\n        pipeSupplyBypass = ops.PipeAdiabatic(model)\n        pipeSupplyOutlet = ops.PipeAdiabatic(model)\n        pipeDemandBypass = ops.PipeAdiabatic(model)\n        pipeDemandInlet = ops.PipeAdiabatic(model)\n        pipeDemandOutlet = ops.PipeAdiabatic(model)\n        # create a setpoint manager\n        setpointManagerFollowOA = ops.SetpointManagerFollowOutdoorAirTemperature(model)\n        setpointManagerFollowOA.setOffsetTemperatureDifference(0)\n        setpointManagerFollowOA.setMaximumSetpointTemperature(80)\n        setpointManagerFollowOA.setMinimumSetpointTemperature(5)\n        # connect components to plant loop\n        # supply side components\n        condenserLoop.addSupplyBranchForComponent(tower)\n        condenserLoop.addSupplyBranchForComponent(pipeSupplyBypass)\n        pump.addToNode(condenserLoop.supplyInletNode())\n        pipeSupplyOutlet.addToNode(condenserLoop.supplyOutletNode())\n        setpointManagerFollowOA.addToNode(condenserLoop.supplyOutletNode())\n        # demand side components\n        if chillerWaterPlant != None:\n            chillervec = chillerWaterPlant.supplyComponents(ops.IddObjectType(\"OS:Chiller:Electric:EIR\"))\n            chiller = model.getChillerElectricEIR(chillervec[0].handle()).get()\n            condenserLoop.addDemandBranchForComponent(chiller)\n            condenserLoop.addDemandBranchForComponent(pipeDemandBypass)\n            pipeDemandInlet.addToNode(condenserLoop.demandInletNode())\n            pipeDemandOutlet.addToNode(condenserLoop.demandOutletNode())\n        return condenserLoop\n    \n    def createVRFCondenser(self, model, HVACCount, condLoopTemp, coolLoopTemp, heatLoopTemp):\n        # create condenser loop for VRFs or WSHPs\n        condenserLoop = ops.PlantLoop(model)\n        condenserLoop.setName(\"Heat Pump Loop\"  + str(HVACCount))\n        condenserLoop.setMaximumLoopTemperature(80)\n        condenserLoop.setMinimumLoopTemperature(5)\n        loopSizing = condenserLoop.sizingPlant()\n        loopSizing.setLoopType(\"Condenser\")\n        loopSizing.setDesignLoopExitTemperature(32.222)\n        loopSizing.setLoopDesignTemperatureDifference(5.6)\n        # create a pump\n        pump = self.createDefaultAEDGPump(model, 0.9, pressRise=134508)\n        # create pipes\n        pipeSupplyBypass = ops.PipeAdiabatic(model)\n        pipeSupplyOutlet = ops.PipeAdiabatic(model)\n        pipeDemandBypass = ops.PipeAdiabatic(model)\n        pipeDemandInlet = ops.PipeAdiabatic(model)\n        pipeDemandOutlet = ops.PipeAdiabatic(model)\n        # create setpoint managers\n        setpointManagerLoop = ops.SetpointManagerScheduled(model,condLoopTemp)\n        setpointManagerCooling = ops.SetpointManagerScheduled(model,coolLoopTemp)\n        setpointManagerHeating = ops.SetpointManagerScheduled(model,heatLoopTemp)\n        # connect components to plant loop\n        # supply side components\n        condenserLoop.addSupplyBranchForComponent(pipeSupplyBypass)\n        pump.addToNode(condenserLoop.supplyInletNode())\n        pipeSupplyOutlet.addToNode(condenserLoop.supplyOutletNode())\n        setpointManagerLoop.addToNode(condenserLoop.supplyOutletNode())\n        # demand side components\n        condenserLoop.addDemandBranchForComponent(pipeDemandBypass)\n        pipeDemandInlet.addToNode(condenserLoop.demandInletNode())\n        pipeDemandOutlet.addToNode(condenserLoop.demandOutletNode())\n        # add a boiler and cooling tower to supply side\n        # create a boiler\n        boiler = ops.BoilerHotWater(model)\n        boiler.setNominalThermalEfficiency(0.9)\n        boiler.setDesignWaterOutletTemperature(48)\n        condenserLoop.addSupplyBranchForComponent(boiler)\n        setpointManagerHeating.addToNode(boiler.outletModelObject().get().to_Node().get())\n        # create a cooling tower\n        tower = ops.CoolingTowerVariableSpeed(model)\n        tower.setDesignInletAirWetBulbTemperature(20)\n        tower.setDesignApproachTemperature(3.89)\n        tower.setDesignRangeTemperature(5.56)\n        tower.addToNode(boiler.outletModelObject().get().to_Node().get())\n        setpointManagerCooling.addToNode(tower.outletModelObject().get().to_Node().get())\n        \n        return condenserLoop\n    \n    def addInfiniteCapacityGroundLoop(self, model, chillerWaterPlant, HVACCount, coolingDetails=None):\n        # create the temperature schedules for the loop.\n        loopSetPtSchedule = self.createConstantScheduleRuleset('Ground_Loop_Temp_Schedule' + str(HVACCount), 'Ground_Loop_Temp_Schedule_Default' + str(HVACCount), 'TEMPERATURE 1', 21, model)\n        coolingSetPtSchedule = self.createConstantScheduleRuleset('Ground_Loop_Clg_Temp_Schedule' + str(HVACCount), 'Ground_Loop_Clg_Temp_Schedule' + str(HVACCount), 'TEMPERATURE 1', 21, model)\n        heatingSetPtSchedule = self.createConstantScheduleRuleset('Ground_Loop_Htg_Temp_Schedule' + str(HVACCount), 'Ground_Loop_Htg_Temp_Schedule' + str(HVACCount), 'TEMPERATURE 1', 5, model)\n        \n        # create condenser loop for heat pumps\n        condenserLoop = ops.PlantLoop(model)\n        condenserLoop.setName(\"AEDG Ground Source Heat Pump Loop\")\n        condenserLoop.setMaximumLoopTemperature(80)\n        condenserLoop.setMinimumLoopTemperature(1)\n        loopSizing = condenserLoop.sizingPlant()\n        loopSizing.setLoopType(\"Condenser\")\n        loopSizing.setDesignLoopExitTemperature(21)\n        loopSizing.setLoopDesignTemperatureDifference(5)\n        # create a pump\n        pump = ops.PumpVariableSpeed(model)\n        pump.setRatedPumpHead(134508) #Pa\n        pump.setMotorEfficiency(0.9)\n        pump.setCoefficient1ofthePartLoadPerformanceCurve(0)\n        pump.setCoefficient2ofthePartLoadPerformanceCurve(0.0216)\n        pump.setCoefficient3ofthePartLoadPerformanceCurve(-0.0325)\n        pump.setCoefficient4ofthePartLoadPerformanceCurve(1.0095)\n        # create a supply bypass pipe\n        pipeSupplyBypass = ops.PipeAdiabatic(model)\n        # create a supply outlet pipe\n        pipeSupplyOutlet = ops.PipeAdiabatic(model)\n        # create a demand bypass pipe\n        pipeDemandBypass = ops.PipeAdiabatic(model)\n        # create a demand inlet pipe\n        pipeDemandInlet = ops.PipeAdiabatic(model)\n        # create a demand outlet pipe\n        pipeDemandOutlet = ops.PipeAdiabatic(model)\n        # create setpoint managers\n        setpointManagerScheduledLoop = ops.SetpointManagerScheduled(model,loopSetPtSchedule)\n        setpointManagerScheduledCooling = ops.SetpointManagerScheduled(model,coolingSetPtSchedule)\n        setpointManagerScheduledHeating = ops.SetpointManagerScheduled(model,heatingSetPtSchedule)\n        # connect components to plant loop\n        # supply side components\n        condenserLoop.addSupplyBranchForComponent(pipeSupplyBypass)\n        pump.addToNode(condenserLoop.supplyInletNode())\n        pipeSupplyOutlet.addToNode(condenserLoop.supplyOutletNode())\n        setpointManagerScheduledLoop.addToNode(condenserLoop.supplyOutletNode())\n        # demand side components\n        condenserLoop.addDemandBranchForComponent(pipeDemandBypass)\n        pipeDemandInlet.addToNode(condenserLoop.demandInletNode())\n        pipeDemandOutlet.addToNode(condenserLoop.demandOutletNode())\n        # add district cooling and heating to supply side\n        districtCooling = ops.DistrictCooling(model)\n        districtCooling.setNominalCapacity(1000000000000) # large number; no autosizing\n        condenserLoop.addSupplyBranchForComponent(districtCooling)\n        setpointManagerScheduledCooling.addToNode(districtCooling.outletModelObject().get().to_Node().get())\n        districtHeating = ops.DistrictHeating(model)\n        districtHeating.setNominalCapacity(1000000000000) # large number; no autosizing\n        districtHeating.addToNode(districtCooling.outletModelObject().get().to_Node().get())\n        setpointManagerScheduledHeating.addToNode(districtHeating.outletModelObject().get().to_Node().get())\n        \n        # demand side components\n        if chillerWaterPlant != None:\n            chillervec = chillerWaterPlant.supplyComponents(ops.IddObjectType(\"OS:CentralHeatPumpSystem\"))\n            chiller = model.getCentralHeatPumpSystem(chillervec[0].handle()).get()\n            condenserLoop.addDemandBranchForComponent(chiller)\n            condenserLoop.addDemandBranchForComponent(pipeDemandBypass)\n            pipeDemandInlet.addToNode(condenserLoop.demandInletNode())\n            pipeDemandOutlet.addToNode(condenserLoop.demandOutletNode())\n            chiller.setName('Central Heat Pump System ' + str(HVACCount))\n        \n        return condenserLoop\n    \n    def replaceChillerWithHeatPump(self, model, centHeatPump, cwl, HVACCount):\n        # replace the chiller.\n        chillerVec = cwl.supplyComponents(ops.IddObjectType(\"OS:Chiller:Electric:EIR\"))\n        for chiller in chillerVec:\n            osChiller = model.getChillerElectricEIR(chiller.handle()).get()\n            condenserLoop = osChiller.secondaryPlantLoop().get()\n            condenserLoop.remove()\n            osChiller.remove()\n        cwl.addSupplyBranchForComponent(centHeatPump)\n    \n    def replaceBoilerWithHeatPump(self, model, hotWaterPlant, chillerWaterPlant, HVACCount):\n        # replace the boiler.\n        boilerVec = hotWaterPlant.supplyComponents(ops.IddObjectType(\"OS:Boiler:HotWater\"))\n        for boiler in boilerVec:\n            osBoiler = model.getBoilerHotWater(boiler.handle()).get()\n            osBoiler.remove()\n        \n        # get the chiller/heat pump\n        chillervec = chillerWaterPlant.supplyComponents(ops.IddObjectType(\"OS:CentralHeatPumpSystem\"))\n        chiller = model.getCentralHeatPumpSystem(chillervec[0].handle()).get()\n        hotWaterPlant.addSupplyBranchForComponent(chiller)\n    \n    def replaceWaterChillWithAirChill(self, model, airChiller, cwl, HVACCount):\n        # replace the chiller.\n        chillerVec = cwl.supplyComponents(ops.IddObjectType(\"OS:Chiller:Electric:EIR\"))\n        for chiller in chillerVec:\n            osChiller = model.getChillerElectricEIR(chiller.handle()).get()\n            condenserLoop = osChiller.secondaryPlantLoop().get()\n            condenserLoop.remove()\n            osChiller.remove()\n        cwl.addSupplyBranchForComponent(airChiller)\n    \n    def setDemandVent(self, model, airloop):\n        oasys = airloop.airLoopHVACOutdoorAirSystem()\n        oactrl = oasys.get().getControllerOutdoorAir()\n        controllerMv = oactrl.controllerMechanicalVentilation()\n        controllerMv.setDemandControlledVentilation(True)\n    \n    def setOutdoorAirReq(self, airTerminal, zone):\n        space = zone.spaces()[0]\n        oaReq = space.designSpecificationOutdoorAir()\n        airTerminal.setControlForOutdoorAir(oaReq)\n    \n    def createPrimaryAirLoop(self, airType, model, thermalZones, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hotWaterPlant=None, chilledWaterPlant=None, condenserPlant=None, terminalOption=None, heatRecovOverride = False):\n        # Create the air loop.\n        airloopPrimary = ops.AirLoopHVAC(model)\n        if airType == 'DOAS':\n            airloopPrimary.setName(\"DOAS Air Loop HVAC\" + str(HVACCount))\n        else:\n            airloopPrimary.setName(\"VAV Air Loop HVAC\" + str(HVACCount))\n        \n        # Modify hard sizing\n        if airDetails != None and airDetails.airSysHardSize != 'Default':\n            airloopPrimary.setDesignSupplyAirFlowRate(float(airDetails.airSysHardSize))\n        \n        # modify system sizing properties\n        sizingSystem = airloopPrimary.sizingSystem()\n        # set central heating and cooling temperatures for sizing\n        sizingSystem.setCentralCoolingDesignSupplyAirTemperature(12.8)\n        sizingSystem.setCentralHeatingDesignSupplyAirTemperature(40) #ML OS default is 16.7\n        \n        # load specification\n        if airType == 'DOAS':\n            sizingSystem.setTypeofLoadtoSizeOn(\"VentilationRequirement\") #DOAS\n            sizingSystem.setAllOutdoorAirinCooling(True) #DOAS\n            sizingSystem.setAllOutdoorAirinHeating(True) #DOAS\n        else:\n            sizingSystem.setTypeofLoadtoSizeOn(\"Sensible\") #VAV\n            sizingSystem.setAllOutdoorAirinCooling(False) #VAV\n            sizingSystem.setAllOutdoorAirinHeating(False) #VAV\n            if airDetails != None and airDetails.recirculation == 'False':\n                self.setAirLoopToOnceThroughAir(airloopPrimary, model)\n        \n        airLoopComps = []\n        # set availability schedule\n        if airDetails != None and airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n            hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched, model)\n            airloopPrimary.setAvailabilitySchedule(hvacAvailSch)\n        else:\n            airloopPrimary.setAvailabilitySchedule(model.alwaysOnDiscreteSchedule())\n        \n        # Check if there are any ventilation schedules on the zones.\n        ventSchedTrigger = False\n        recircTrigger = False\n        for zone in hbZones:\n            if zone.ventilationSched != '':\n                ventSchedTrigger = True\n            if zone.recirculatedAirPerArea != 0:\n                recircTrigger = True\n        \n        # constant or variable speed fan\n        sizingSystem.setMinimumSystemAirFlowRatio(1.0) #DCV\n        if airType == 'VAV':\n            fan = self.createDefaultAEDGFan('VV', model, airDetails)\n        elif airDetails != None and airDetails.fanControl == 'Variable Volume':\n            fan = self.createDefaultAEDGFan('VV', model, airDetails)\n        elif airDetails != None and airDetails.airsideEconomizer != 'Default' and airDetails.airsideEconomizer != 'NoEconomizer':\n            fan = self.createDefaultAEDGFan('VV', model, airDetails)\n        elif ventSchedTrigger == True or recircTrigger == True:\n            fan = self.createDefaultAEDGFan('VV', model, airDetails)\n        else:\n            fan = self.createDefaultAEDGFan('CV', model, airDetails)\n        airLoopComps.append(fan)\n        \n        # create heating coil\n        if hotWaterPlant != None:\n            heatingCoil = ops.CoilHeatingWater(model, model.alwaysOnDiscreteSchedule())\n        elif condenserPlant == None:\n            heatingCoil = ops.CoilHeatingGas(model, model.alwaysOnDiscreteSchedule())\n        \n        # create cooling coil\n        if chilledWaterPlant != None:\n            coolingCoil = ops.CoilCoolingWater(model, model.alwaysOnDiscreteSchedule())\n            if coolingDetails != None and coolingDetails.supplyTemperature != 'Default':\n                coolingCoil.setDesignInletWaterTemperature(coolingDetails.supplyTemperature)\n        elif condenserPlant == None:\n            coolingCoil = ops.CoilCoolingDXSingleSpeed(model)\n            coolingCoil.setRatedCOP(ops.OptionalDouble(4.0))\n        \n        # create unitary heat pumps if a condenser is connected.\n        if condenserPlant != None:\n            unitarySystemCool = ops.AirLoopHVACUnitarySystem(model)\n            unitarySystemCool.setName('Unitary System for Cooling Coil'+ str(HVACCount))\n            unitarySystemCool.setFanPlacement('DrawThrough')\n            coolingCoil = ops.CoilCoolingWaterToAirHeatPumpEquationFit(model)\n            coolingCoil.setName('DOAS Cooling Heat Pump' + str(HVACCount))\n            condenserPlant.addDemandBranchForComponent(coolingCoil)\n            unitarySystemCool.setCoolingCoil(coolingCoil)\n            # Have this coil obey the setpoint manager (not the zone thermostat).\n            unitarySystemCool.setString(2,'SetPoint')\n            \n            unitarySystemHeat = ops.AirLoopHVACUnitarySystem(model)\n            unitarySystemHeat.setName('Unitary System for Heating Coil'+ str(HVACCount))\n            unitarySystemHeat.setFanPlacement('DrawThrough')\n            heatingCoil = ops.CoilHeatingWaterToAirHeatPumpEquationFit(model)\n            heatingCoil.setName('DOAS Heating Heat Pump' + str(HVACCount))\n            condenserPlant.addDemandBranchForComponent(heatingCoil)\n            unitarySystemHeat.setHeatingCoil(heatingCoil)\n            # Have this coil obey the setpoint manager (not the zone thermostat).\n            unitarySystemHeat.setString(2,'SetPoint')\n        \n        # Set availabilty of heating/cooling coils.\n        if heatingDetails != None and heatingDetails.heatingAvailSched != 'ALWAYS ON':\n             heatAvailSch = self.getOSSchedule(heatingDetails.heatingAvailSched,model)\n             heatingCoil.setAvailabilitySchedule(heatAvailSch)\n        if coolingDetails != None and coolingDetails.coolingAvailSched != 'ALWAYS ON':\n             coolAvailSch = self.getOSSchedule(coolingDetails.coolingAvailSched, model)\n             coolingCoil.setAvailabilitySchedule(coolAvailSch)\n        \n        # Add the coils to the airloop.\n        if condenserPlant != None:\n            airLoopComps.append(unitarySystemHeat)\n            airLoopComps.append(unitarySystemCool)\n        else:\n            airLoopComps.append(heatingCoil)\n            airLoopComps.append(coolingCoil)\n        \n        # create controller outdoor air\n        controllerOA = ops.ControllerOutdoorAir(model)\n        controllerOA.autosizeMinimumOutdoorAirFlowRate()\n        controllerOA.autosizeMaximumOutdoorAirFlowRate()\n        controllerOA.setHeatRecoveryBypassControlType(\"BypassWhenOAFlowGreaterThanMinimum\")\n        if airType == 'VAV':\n            controllerOA.setEconomizerControlType('DifferentialEnthalpy')\n        # create outdoor air system\n        systemOA = ops.AirLoopHVACOutdoorAirSystem(model, controllerOA)\n        airLoopComps.append(systemOA)\n        \n        # create scheduled setpoint manager for airloop\n        # DOAS or VAV for cooling and not ventilation\n        if airType == 'VAV':\n            setpointManager = ops.SetpointManagerOutdoorAirReset(model)\n            setpointManager.setOutdoorLowTemperature(14.4)\n            setpointManager.setOutdoorHighTemperature(21.1)\n            if airDetails!= None and airDetails.heatingSupplyAirTemp != 'Default':\n                setpointManager.setSetpointatOutdoorLowTemperature(airDetails.heatingSupplyAirTemp)\n            else:\n                setpointManager.setSetpointatOutdoorLowTemperature(15.6)\n            if airDetails!= None and airDetails.coolingSupplyAirTemp != 'Default':\n                setpointManager.setSetpointatOutdoorHighTemperature(airDetails.coolingSupplyAirTemp)\n            else:\n                setpointManager.setSetpointatOutdoorHighTemperature(12.8)\n        else:\n            if airDetails!= None and airDetails.heatingSupplyAirTemp != 'Default':\n                suppTemp = airDetails.heatingSupplyAirTemp\n            elif airDetails!= None and airDetails.coolingSupplyAirTemp != 'Default':\n                suppTemp = airDetails.coolingSupplyAirTemp\n            else:\n                suppTemp = 20\n            setpointSchedule = self.createConstantScheduleRuleset('DOAS_Temperature_Setpoint' + str(HVACCount), 'DOAS_Temperature_Setpoint_Default' + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n            setpointManager = ops.SetpointManagerScheduled(model, setpointSchedule)\n        \n        # connect components to airloop\n        # find the supply inlet node of the airloop\n        airloopSupplyInlet = airloopPrimary.supplyInletNode()\n        # add the components to the airloop\n        for count, comp in enumerate(airLoopComps):\n          comp.addToNode(airloopSupplyInlet)\n          if count == 1 and hotWaterPlant != None:\n            hotWaterPlant.addDemandBranchForComponent(comp)\n            comp.controllerWaterCoil().get().setMinimumActuatedFlow(0)\n          elif count == 2 and chilledWaterPlant != None:\n            chilledWaterPlant.addDemandBranchForComponent(comp)\n            comp.controllerWaterCoil().get().setMinimumActuatedFlow(0)\n        \n        # Add airside economizer if requested\n        if airDetails != None and airDetails.airsideEconomizer != 'Default':\n            self.adjustAirSideEcon(airloopPrimary, airDetails)\n        \n        # add erv to outdoor air system either based on user input or add the default AEDG erv.\n        if airDetails != None and (airDetails.sensibleHeatRecovery != 'Default' or airDetails.latentHeatRecovery != 'Default'):\n            self.addHeatRecovToModel(model, airloopPrimary, airDetails.sensibleHeatRecovery, airDetails.latentHeatRecovery, False, True)\n        elif heatRecovOverride == False:\n            self.addHeatRecovToModel(model, airloopPrimary, 'Default', 'Default', False, True, 0.69)\n        \n        # add setpoint manager to supply equipment outlet node\n        setpointManager.addToNode(airloopPrimary.supplyOutletNode())\n        \n        # add thermal zones to airloop.\n        recircAirFlowRates = []\n        for zCount, zone in enumerate(thermalZones):\n            zoneTotAir = self.getZoneTotalAir(hbZones[zCount])\n            recircAirFlowRates.append(zoneTotAir)\n            # make an air terminal for the zone\n            airTerminal = None\n            if terminalOption == \"ChilledBeam\":\n                # create cooling coil\n                coolingCoil = ops.CoilCoolingCooledBeam(model)\n                chilledWaterPlant.addDemandBranchForComponent(coolingCoil)\n                airTerminal = ops.AirTerminalSingleDuctConstantVolumeCooledBeam(model, model.alwaysOnDiscreteSchedule(), coolingCoil)\n                airTerminal.setCooledBeamType('Active')\n                if coolingDetails != None and coolingDetails.coolingAvailSched != 'ALWAYS ON':\n                     coolAvailSch = self.getOSSchedule(coolingDetails.coolingAvailSched, model)\n                     airTerminal.setAvailabilitySchedule(coolAvailSch)\n            else:\n                if ventSchedTrigger == True:\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                    self.setOutdoorAirReq(airTerminal, zone)\n                elif airType == 'VAV':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif airDetails != None and airDetails.fanControl == 'Variable Volume':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif airDetails != None and airDetails.airsideEconomizer != 'Default' and airDetails.airsideEconomizer != 'NoEconomizer':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif hbZones[zCount].recirculatedAirPerArea == 0:\n                    if vernum1 > 2 or (vernum1 == 2 and vernum2 >= 7):\n                        airTerminal = ops.AirTerminalSingleDuctConstantVolumeNoReheat(model, model.alwaysOnDiscreteSchedule())\n                    else:\n                        airTerminal = ops.AirTerminalSingleDuctUncontrolled(model, model.alwaysOnDiscreteSchedule())\n                else:\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n            if hbZones[zCount].recirculatedAirPerArea != 0 and terminalOption != \"ChilledBeam\":\n                self.sizeAirTerminalForRecirc(model, hbZones[zCount], airTerminal, zoneTotAir)\n            elif hbZones[zCount].recirculatedAirPerArea != 0:\n                airTerminal.setSupplyAirVolumetricFlowRate(zoneTotAir)\n            elif recircTrigger == True:\n                try:\n                    airTerminal.setZoneMinimumAirFlowInputMethod('Constant')\n                    airTerminal.autosizeMaximumAirFlowRate()\n                    airTerminal.resetMinimumAirFlowFractionSchedule()\n                except:\n                    try:\n                        airTerminal.autosizeSupplyAirVolumetricFlowRate()\n                    except:\n                        pass\n            \n            # attach new terminal to the zone and to the airloop\n            airloopPrimary.addBranchForZone(zone, airTerminal.to_StraightComponent())\n        \n        \n        if airDetails != None and airDetails.fanControl == 'Variable Volume':\n            self.setDemandVent(model, airloopPrimary)\n        else:\n            # create ventilation schedules and assign to OA controller for DOAS\n            controllerOA.setMinimumFractionofOutdoorAirSchedule(model.alwaysOnDiscreteSchedule())\n            controllerOA.setMaximumFractionofOutdoorAirSchedule(model.alwaysOnDiscreteSchedule())\n        \n        # Size fan for recirc if needed.\n        if recircTrigger == True:\n            self.sizeVAVFanForRecirc(model, airloopPrimary, recircAirFlowRates)\n        \n        return airloopPrimary\n    \n    \n    def addVAVairLoop(self, model, chilledWaterPlant, hotWaterPlant, sysType):\n        if sysType == 7:\n            hvacHandle = ops.OpenStudioModelHVAC.addSystemType7(model).handle()\n        elif sysType == 8:\n            hvacHandle = ops.OpenStudioModelHVAC.addSystemType8(model).handle()\n        elif sysType == 5:\n            hvacHandle = ops.OpenStudioModelHVAC.addSystemType5(model).handle()\n        \n        airloop = model.getAirLoopHVAC(hvacHandle).get()\n        \n        # Replace the hot water loop.\n        if sysType == 7 or sysType == 5:\n            if hotWaterPlant != None:\n                x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Water\"))\n                hc = model.getCoilHeatingWater(x[0].handle()).get()\n                hwl = hc.plantLoop().get()\n                hwl.remove()\n                hotWaterPlant.addDemandBranchForComponent(hc)\n        \n        # Replace the chilled water loop.\n        if sysType == 7 or sysType == 8:\n            if chilledWaterPlant != None:\n                x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                cc = model.getCoilCoolingWater(x[0].handle()).get()\n                cwl = cc.plantLoop().get()\n                x = cwl.supplyComponents(ops.IddObjectType(\"OS:Chiller:Electric:EIR\"))\n                if sysType == 7:\n                    chiller = model.getChillerElectricEIR(x[0].handle()).get()\n                    cnwl = chiller.secondaryPlantLoop().get()\n                    cnwl.remove()\n                cwl.remove()\n                chilledWaterPlant.addDemandBranchForComponent(cc)\n        \n        return airloop\n    \n    \n    def addZoneToAirLoop(self, airloopPrimary, airType, model, thermalZones, hbZones, airDetails, coolingDetails, chilledWaterPlant=None, terminalOption=None):\n        ventSchedTrigger = False\n        recircTrigger = False\n        for zone in hbZones:\n            if zone.ventilationSched != '':\n                ventSchedTrigger = True\n            if zone.recirculatedAirPerArea != 0:\n                recircTrigger = True\n        \n        # add thermal zones to airloop.\n        recircAirFlowRates = []\n        for zCount, zone in enumerate(thermalZones):\n            zoneTotAir = self.getZoneTotalAir(hbZones[zCount])\n            recircAirFlowRates.append(zoneTotAir)\n            # make an air terminal for the zone\n            airTerminal = None\n            if terminalOption == \"ChilledBeam\":\n                # create cooling coil\n                coolingCoil = ops.CoilCoolingCooledBeam(model)\n                chilledWaterPlant.addDemandBranchForComponent(coolingCoil)\n                airTerminal = ops.AirTerminalSingleDuctConstantVolumeCooledBeam(model, model.alwaysOnDiscreteSchedule(), coolingCoil)\n                airTerminal.setCooledBeamType('Active')\n                if coolingDetails != None and coolingDetails.coolingAvailSched != 'ALWAYS ON':\n                     coolAvailSch = self.getOSSchedule(coolingDetails.coolingAvailSched, model)\n                     airTerminal.setAvailabilitySchedule(coolAvailSch)\n            else:\n                if ventSchedTrigger == True:\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                    self.setOutdoorAirReq(airTerminal, zone)\n                elif airType == 'VAV':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif airDetails != None and airDetails.fanControl == 'Variable Volume':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif airDetails != None and airDetails.airsideEconomizer != 'Default' and airDetails.airsideEconomizer != 'NoEconomizer':\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n                elif hbZones[zCount].recirculatedAirPerArea == 0:\n                    if vernum1 > 2 or (vernum1 == 2 and vernum2 >= 7):\n                        airTerminal = ops.AirTerminalSingleDuctConstantVolumeNoReheat(model, model.alwaysOnDiscreteSchedule())\n                    else:\n                        airTerminal = ops.AirTerminalSingleDuctUncontrolled(model, model.alwaysOnDiscreteSchedule())\n                else:\n                    airTerminal = ops.AirTerminalSingleDuctVAVNoReheat(model, model.alwaysOnDiscreteSchedule())\n            if hbZones[zCount].recirculatedAirPerArea != 0 and terminalOption != \"ChilledBeam\":\n                self.sizeAirTerminalForRecirc(model, hbZones[zCount], airTerminal, zoneTotAir)\n            elif hbZones[zCount].recirculatedAirPerArea != 0:\n                airTerminal.setSupplyAirVolumetricFlowRate(zoneTotAir)\n            elif recircTrigger == True:\n                try:\n                    airTerminal.setZoneMinimumAirFlowInputMethod('Constant')\n                    airTerminal.autosizeMaximumAirFlowRate()\n                    airTerminal.resetMinimumAirFlowFractionSchedule()\n                except:\n                    try:\n                        airTerminal.autosizeSupplyAirVolumetricFlowRate()\n                    except:\n                        pass\n            \n            # attach new terminal to the zone and to the airloop\n            airloopPrimary.addBranchForZone(zone, airTerminal.to_StraightComponent())\n        \n        # Size fan for recirc if needed.\n        try:\n            x = airloopPrimary.supplyComponents(ops.IddObjectType(\"OS:Fan:VariableVolume\"))\n            vvfan = model.getFanVariableVolume(x[0].handle()).get()\n            if recircTrigger == True or bool(vvfan.isMaximumFlowRateAutosized()) == False:\n                recircAirFlowRates.append(float(str(vvfan.maximumFlowRate())))\n                self.sizeVAVFanForRecirc(model, airloopPrimary, recircAirFlowRates)\n        except:\n            pass\n        \n        return airloopPrimary\n    \n    \n    def createVRFSystem(self, model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, condenserLoop=None):\n        vrfAirConditioner = ops.AirConditionerVariableRefrigerantFlow(model)\n        vrfAirConditioner.setZoneforMasterThermostatLocation(thermalZoneVector[0])\n        vrfName = \"VRF Heat Pump - \" + str(HVACCount)\n        vrfAirConditioner.setName(vrfName)\n        \n        # Set the COP.\n        if coolingDetails != None and coolingDetails.coolingCOP != 'Default':\n            vrfAirConditioner.setRatedCoolingCOP(coolingDetails.coolingCOP)\n        if heatingDetails != None and heatingDetails.heatingEffOrCOP != 'Default':\n            vrfAirConditioner.setRatedHeatingCOP(heatingDetails.heatingEffOrCOP)\n        \n        # set the heat pump to recover wast heat by default\n        vrfAirConditioner.setHeatPumpWasteHeatRecovery(True)\n        \n        vrfAirConditioner.setAvailabilitySchedule(model.alwaysOnDiscreteSchedule())\n        if heatingDetails != None and heatingDetails.heatingAvailSched != \"ALWAYS ON\":\n            heatAvailSch = self.getOSSchedule(heatingDetails.heatingAvailSched, model)\n            vrfAirConditioner.setAvailabilitySchedule(heatAvailSch)\n        if coolingDetails != None and coolingDetails.coolingAvailSched != \"ALWAYS ON\":\n            coolAvailSch = self.getOSSchedule(coolingDetails.coolinggAvailSched, model)\n            vrfAirConditioner.setAvailabilitySchedule(coolAvailSch)\n        \n        if coolingDetails != None and (coolingDetails.chillerType == \"WaterCooled\" or coolingDetails.chillerType == \"GroundSourced\") and condenserLoop == None:\n            cndwl = self.createCondenser(model, None, \"VRF - \" + str(HVACCount))\n        \n        # For water source VRFs.\n        if (coolingDetails != None and (coolingDetails.chillerType == \"WaterCooled\" or coolingDetails.chillerType == \"GroundSourced\") and condenserLoop == None) or (condenserLoop != None):\n            # The following should connect the VRF to a plant loop.\n            # However, OpenStudio does not currently support this and these inputs end up doing nothing.\n            vrfAirConditioner.setString(56,\"WaterCooled\")\n            condenserLoop.addDemandBranchForComponent(vrfAirConditioner)\n            # ... So I will add some placeholders in the plant loop now\n            # and substitue them with VRF connections after the export to IDF.\n            vrfPlaceHolder = ops.PipeAdiabatic(model)\n            pipeName = 'VRF PLACEHOLDER ' + str(HVACCount)\n            vrfPlaceHolder.setName(pipeName)\n            condenserLoop.addDemandBranchForComponent(vrfPlaceHolder)\n            # Add all of the relevant info about the VRF to the dictionary.\n            self.waterSourceVRFs[vrfName] = {}\n            \n            outNode = str(vrfPlaceHolder.outletModelObject().get().to_Node().get().name())\n            inNode = str(vrfPlaceHolder.inletModelObject().get().to_Node().get().name())\n            splitter = condenserLoop.demandSplitter()\n            branchInd = int(splitter.branchIndexForOutletModelObject(vrfPlaceHolder.inletModelObject().get().to_Node().get())) +1\n            branchName = str(condenserLoop.name()) + ' Demand Branch ' + str(branchInd)\n            self.waterSourceVRFs[vrfName]['outlet'] = outNode\n            self.waterSourceVRFs[vrfName]['inlet'] = inNode\n            self.waterSourceVRFs[vrfName]['pipe'] = pipeName\n            self.waterSourceVRFs[vrfName]['branch'] = branchName\n        \n        for zone in thermalZoneVector:\n            # construct Terminal VRF Unit\n            vrfTerminalUnit = ops.ZoneHVACTerminalUnitVariableRefrigerantFlow(model)\n            vrfTerminalUnit.setTerminalUnitAvailabilityschedule(model.alwaysOnDiscreteSchedule())\n            vrfTerminalUnit.setOutdoorAirFlowRateDuringCoolingOperation(0)\n            vrfTerminalUnit.setOutdoorAirFlowRateDuringHeatingOperation(0)\n            vrfTerminalUnit.setOutdoorAirFlowRateWhenNoCoolingorHeatingisNeeded(0)\n            vrfTerminalUnit.addToThermalZone(zone)\n            vrfAirConditioner.addTerminal(vrfTerminalUnit)\n    \n    \n    def createZoneEquip(self, model, thermalZones, hbZones, equipList, hotWaterPlant=None, chilledWaterPlant=None, heatPumpLoop=None, heatOnly=False):\n        # create radiant constructions.\n        radiantFloor = None\n        radConstructions = {}\n        customRadFound = False\n        if 'RadiantFloor' in equipList:\n            # create radiant construction and substitute for existing surface (interior or exterior) constructions\n            # ignore layer below insulation, which will depend on boundary condition\n            insul = ops.StandardOpaqueMaterial(model,\"Rough\",0.0254,0.02,56.06,1210) # rigid_insulation_1in\n            conc = ops.StandardOpaqueMaterial(model,\"MediumRough\",0.0508,2.31,2322,832) # concrete_2in\n            layers= [insul, conc, conc]\n            # create an empty vector to collect the materials\n            materials = ops.MaterialVector()\n            for OSMaterial in layers:\n                # add it as a layer\n                materials.Add(OSMaterial)\n            radiantFloor = ops.ConstructionWithInternalSource(model)\n            radiantFloor.setName('4in Radiant Slab Construction')\n            radiantFloor.setLayers(materials)\n            radiantFloor.setSourcePresentAfterLayerNumber(2)\n        \n        for zoneCount, zone in enumerate(thermalZones):\n            if 'FanCoil' in equipList:\n                # create fan coil\n                # create fan\n                fan = ops.FanOnOff(model, model.alwaysOnDiscreteSchedule())\n                fan.setFanEfficiency(0.5)\n                fan.setPressureRise(75) #Pa\n                fan.autosizeMaximumFlowRate()\n                fan.setMotorEfficiency(0.9)\n                fan.setMotorInAirstreamFraction(1.0)\n                # create cooling coil and connect to chilled water plant\n                coolingCoil = ops.CoilCoolingWater(model, model.alwaysOnDiscreteSchedule())\n                chilledWaterPlant.addDemandBranchForComponent(coolingCoil)\n                coolingCoil.controllerWaterCoil().get().setMinimumActuatedFlow(0)\n                # create heating coil and connect to hot water plant\n                heatingCoil = ops.CoilHeatingWater(model, model.alwaysOnDiscreteSchedule())\n                hotWaterPlant.addDemandBranchForComponent(heatingCoil)\n                heatingCoil.controllerWaterCoil().get().setMinimumActuatedFlow(0)\n                # construct fan coil\n                fanCoil = ops.ZoneHVACFourPipeFanCoil(model, model.alwaysOnDiscreteSchedule(), fan, coolingCoil, heatingCoil)\n                fanCoil.setMaximumOutdoorAirFlowRate(0)                                                          \n                # add fan coil to thermal zone\n                fanCoil.addToThermalZone(zone)\n            if \"Baseboard\" in equipList:\n                # create baseboard heater add add to thermal zone and hot water loop\n                baseboardCoil = ops.CoilHeatingWaterBaseboard(model)\n                baseboardHeater = ops.ZoneHVACBaseboardConvectiveWater(model, model.alwaysOnDiscreteSchedule(), baseboardCoil)\n                baseboardHeater.addToThermalZone(zone)          \n                hotWaterPlant.addDemandBranchForComponent(baseboardCoil)\n            if 'RadiantFloor' in equipList or 'CustomRadiant' in equipList:\n                # create hot water coil and attach to radiant hot water loop\n                heatingCoil = ops.CoilHeatingLowTempRadiantVarFlow(model, model.alwaysOnDiscreteSchedule())\n                heatSetPtSch = self.getOSSchedule(hbZones[zoneCount].heatingSetPtSchedule, model)\n                heatingCoil.setHeatingControlTemperatureSchedule(heatSetPtSch)\n                hotWaterPlant.addDemandBranchForComponent(heatingCoil)\n                # create chilled water coil and attach to radiant chilled water loop\n                coolingCoil = ops.CoilCoolingLowTempRadiantVarFlow(model, model.alwaysOnDiscreteSchedule())\n                coolSetPtSch = self.getOSSchedule(hbZones[zoneCount].coolingSetPtSchedule, model)\n                coolingCoil.setCoolingControlTemperatureSchedule(coolSetPtSch)\n                chilledWaterPlant.addDemandBranchForComponent(coolingCoil)\n                if heatOnly == True:\n                    coolingCoil.setMaximumColdWaterFlow(0)\n                # create the hydronic system\n                lowTempRadiant = ops.ZoneHVACLowTempRadiantVarFlow(model, model.alwaysOnDiscreteSchedule(), heatingCoil, coolingCoil)\n                if 'RadiantFloor' in equipList:\n                    lowTempRadiant.setRadiantSurfaceType(\"Floors\")\n                else:\n                    lowTempRadiant.setRadiantSurfaceType(\"AllSurfaces\")\n                lowTempRadiant.setHydronicTubingInsideDiameter(0.012)\n                lowTempRadiant.setTemperatureControlType(\"MeanRadiantTemperature\")\n                lowTempRadiant.addToThermalZone(zone)\n                \n                # assign radiant construction to zone surfaces\n                space = zone.spaces()[0]\n                if 'RadiantFloor' in equipList:\n                    for surface in space.surfaces:\n                        if surface.surfaceType() == \"Floor\":\n                            surface.setConstruction(radiantFloor)\n                else:\n                    for surface in space.surfaces:\n                        srfConstruction = surface.construction().get()\n                        constrName = str(srfConstruction.name())\n                        if not  '_REVERSED' in constrName:\n                            materialNames, comments, UVSI, UVIP = self.hb_EPMaterialAUX.decomposeEPCnstr(constrName)\n                            if 'INTERNAL SOURCE' in str(materialNames).upper():\n                                customRadFound = True\n                                adjacentSrf = None\n                                if surface.adjacentSurface().is_initialized():\n                                    adjacentSrf = surface.adjacentSurface().get()\n                                try:\n                                    surface.setConstruction(radConstructions[constrName])\n                                    if adjacentSrf is not None:\n                                        adjacentSrf.setConstruction(radConstructions[constrName + '_REVERSED'])\n                                except:\n                                    # create an empty vector to collect the materials\n                                    layers = []\n                                    sourceLoc = 1\n                                    for count, materialName in enumerate(materialNames):\n                                        # check if the material has been already produced\n                                        if materialName.upper() == 'INTERNAL SOURCE':\n                                            sourceLoc = count\n                                        elif not self.isMaterialInLib(materialName):\n                                            # create an openstudio material for EP material\n                                            OSMaterial = self.getOSMaterial(materialName, model)\n                                            layers.append(OSMaterial)\n                                            self.addMaterialToLib(materialName, OSMaterial)\n                                        else:\n                                            # material has been already created so let's just use it\n                                            layers.append(self.getMaterialFromLib(materialName))\n                                    \n                                    materials = ops.MaterialVector()\n                                    for OSMaterial in layers:\n                                        materials.Add(OSMaterial)\n                                    radiantSrf = ops.ConstructionWithInternalSource(model)\n                                    radiantSrf.setName(constrName)\n                                    radiantSrf.setLayers(materials)\n                                    radiantSrf.setSourcePresentAfterLayerNumber(sourceLoc)\n                                    surface.setConstruction(radiantSrf)\n                                    radConstructions[constrName] = radiantSrf\n                                    \n                                    if adjacentSrf is not None:\n                                        sourceLoc_rev = len(layers) - sourceLoc\n                                        materials_rev = ops.MaterialVector()\n                                        layers.reverse()\n                                        for OSMaterial in layers:\n                                            materials_rev.Add(OSMaterial)\n                                        radiantSrf_rev = ops.ConstructionWithInternalSource(model)\n                                        radiantSrf_rev.setName(constrName + '_REVERSED')\n                                        radiantSrf_rev.setLayers(materials_rev)\n                                        radiantSrf_rev.setSourcePresentAfterLayerNumber(sourceLoc_rev)\n                                        adjacentSrf.setConstruction(radiantSrf_rev)\n                                        radConstructions[constrName+ '_REVERSED'] = radiantSrf_rev\n            if 'WSHP' in equipList:\n                # create water source heat pump and attach to heat pump loop\n                # create fan\n                fan = ops.FanOnOff(model, model.alwaysOnDiscreteSchedule())\n                fan.setFanEfficiency(0.5)\n                fan.setPressureRise(75) #Pa\n                fan.autosizeMaximumFlowRate()\n                fan.setMotorEfficiency(0.9)\n                fan.setMotorInAirstreamFraction(1.0)\n                # create cooling coil and connect to heat pump loop\n                coolingCoil = ops.CoilCoolingWaterToAirHeatPumpEquationFit(model)\n                coolingCoil.setRatedCoolingCoefficientofPerformance(6.45)\n                coolingCoil.setTotalCoolingCapacityCoefficient1(-9.149069561)\n                coolingCoil.setTotalCoolingCapacityCoefficient2(10.87814026)\n                coolingCoil.setTotalCoolingCapacityCoefficient3(-1.718780157)\n                coolingCoil.setTotalCoolingCapacityCoefficient4(0.746414818)\n                coolingCoil.setTotalCoolingCapacityCoefficient5(0.0)\n                coolingCoil.setSensibleCoolingCapacityCoefficient1(-5.462690012)\n                coolingCoil.setSensibleCoolingCapacityCoefficient2(17.95968138)\n                coolingCoil.setSensibleCoolingCapacityCoefficient3(-11.87818402)\n                coolingCoil.setSensibleCoolingCapacityCoefficient4(-0.980163419)\n                coolingCoil.setSensibleCoolingCapacityCoefficient5(0.767285761)\n                coolingCoil.setSensibleCoolingCapacityCoefficient6(0.0)\n                coolingCoil.setCoolingPowerConsumptionCoefficient1(-3.205409884)\n                coolingCoil.setCoolingPowerConsumptionCoefficient2(-0.976409399)\n                coolingCoil.setCoolingPowerConsumptionCoefficient3(3.97892546)\n                coolingCoil.setCoolingPowerConsumptionCoefficient4(0.938181818)\n                coolingCoil.setCoolingPowerConsumptionCoefficient5(0.0)\n                heatPumpLoop.addDemandBranchForComponent(coolingCoil)\n                # create heating coil and connect to heat pump loop\n                heatingCoil = ops.CoilHeatingWaterToAirHeatPumpEquationFit(model)\n                heatingCoil.setRatedHeatingCoefficientofPerformance(4.0)\n                heatingCoil.setHeatingCapacityCoefficient1(-1.361311959)\n                heatingCoil.setHeatingCapacityCoefficient2(-2.471798046)\n                heatingCoil.setHeatingCapacityCoefficient3(4.173164514)\n                heatingCoil.setHeatingCapacityCoefficient4(0.640757401)\n                heatingCoil.setHeatingCapacityCoefficient5(0.0)\n                heatingCoil.setHeatingPowerConsumptionCoefficient1(-2.176941116)\n                heatingCoil.setHeatingPowerConsumptionCoefficient2(0.832114286)\n                heatingCoil.setHeatingPowerConsumptionCoefficient3(1.570743399)\n                heatingCoil.setHeatingPowerConsumptionCoefficient4(0.690793651)\n                heatingCoil.setHeatingPowerConsumptionCoefficient5(0.0)\n                heatPumpLoop.addDemandBranchForComponent(heatingCoil)\n                # create supplemental heating coil\n                supplementalHeatingCoil = ops.CoilHeatingElectric(model, model.alwaysOnDiscreteSchedule())\n                # construct heat pump\n                heatPump = ops.ZoneHVACWaterToAirHeatPump(model, model.alwaysOnDiscreteSchedule(), fan, heatingCoil, coolingCoil, supplementalHeatingCoil)\n                heatPump.setSupplyAirFlowRateWhenNoCoolingorHeatingisNeeded(ops.OptionalDouble(0))\n                heatPump.setOutdoorAirFlowRateDuringCoolingOperation(ops.OptionalDouble(0))\n                heatPump.setOutdoorAirFlowRateDuringHeatingOperation(ops.OptionalDouble(0))\n                heatPump.setOutdoorAirFlowRateWhenNoCoolingorHeatingisNeeded(ops.OptionalDouble(0))\n                # add heat pump to thermal zone\n                heatPump.addToThermalZone(zone)\n        \n        if 'CustomRadiant' in equipList and customRadFound == False:\n            warning = 'Custom Radiant HVAC selected \\n but no surfaces with Internal Source constructions were found.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    ### END OF FUNCTIONS FOR CREATING HVAC SYSTEMS FROM SCRATCH ###\n    \n    ### START OF FUNCTIONS FOR EDITING HVAC SYSTEMS ###\n    def updateFan(self,fan,totalEfficiency,motorEfficiency,pressureRise,airSysHardSize):\n        if totalEfficiency != 'Default': \n            fan.setFanEfficiency(totalEfficiency)\n        if motorEfficiency != 'Default':\n            fan.setMotorEfficiency(motorEfficiency)\n        if pressureRise != 'Default': \n            fan.setPressureRise(pressureRise)\n        if airSysHardSize != 'Default':\n            fan.setMaximumFlowRate(float(airSysHardSize))\n    \n    def updatePump(self, pump, pumpMotorEfficiency):\n        if pumpMotorEfficiency != 'Default':\n            pump.setMotorEfficiency(pumpMotorEfficiency)\n    \n    def updateChiller(self, model, osChiller, coolingCOP, supplyTemperature, coolHardSize):\n        if coolingCOP != 'Default':\n            osChiller.setReferenceCOP(coolingCOP)\n        if supplyTemperature != 'Default':\n            osChiller.setReferenceLeavingChilledWaterTemperature(supplyTemperature)\n        if coolHardSize != 'Autosize':\n            osChiller.setReferenceCapacity(coolHardSize)\n   \n    def updateBoiler(self, model, osboiler, heatingEffOrCOP, supplyTemperature, heatHardSize):\n        if heatingEffOrCOP != 'Default':\n            osboiler.setNominalThermalEfficiency(heatingEffOrCOP)\n        if supplyTemperature != 'Default':\n            osboiler.setDesignWaterOutletTemperature(supplyTemperature)\n        if heatHardSize != 'Autosize':\n            boiler.setNominalCapacity(float(heatingDetails.heatHardSize))\n    \n    def updateDXCoolingCoil(self, model, coolCoil, coolingAvailSched, coolingCOP):\n        if coolingAvailSched != 'ALWAYS ON':\n             coolAvailSch = self.getOSSchedule(coolingAvailSched, model)\n             coolCoil.setAvailabilitySchedule(coolAvailSch)\n        if coolingCOP != 'Default':\n            coolCoil.setRatedCOP(ops.OptionalDouble(coolingCOP))\n    \n    def updateDXCoolingCoilTwoSpeed(self, model, coolCoil, coolingAvailSched, coolingCOP):\n        if coolingAvailSched != 'ALWAYS ON':\n             coolAvailSch = self.getOSSchedule(coolingAvailSched, model)\n             coolCoil.setAvailabilitySchedule(coolAvailSch)\n        if coolingCOP != 'Default':\n            coolCoil.setRatedHighSpeedCOP(coolingCOP)\n            coolCoil.setRatedLowSpeedCOP(coolingCOP)\n    \n    def updateWaterCoolingCoil(delf, model, coolCoil, coolingAvailSched, supplyTemperature):\n        if coolingAvailSched != 'ALWAYS ON':\n             coolAvailSch = self.getOSSchedule(coolingAvailSched,model)\n             coolCoil.setAvailabilitySchedule(coolAvailSch)\n        if supplyTemperature != 'Default':\n            coolCoil.setDesignInletWaterTemperature(supplyTemperature)\n    \n    def updateDXHeatingCoil(self, model, heatCoil, heatingAvailSched, heatingEffOrCOP):\n        if heatingAvailSched != 'ALWAYS ON':\n             heatAvailSch = self.getOSSchedule(heatingAvailSched, model)\n             heatCoil.setAvailabilitySchedule(heatAvailSch)\n        if heatingEffOrCOP != 'Default':\n            heatCoil.setRatedCOP(heatingEffOrCOP)\n    \n    def updateGasHeatingCoil(self, model, heatCoil, heatingAvailSched, heatingEffOrCOP):\n        if heatingAvailSched != 'ALWAYS ON':\n             heatAvailSch = self.getOSSchedule(heatingAvailSched, model)\n             heatCoil.setAvailabilitySchedule(heatAvailSch)\n        if heatingEffOrCOP != 'Default':\n            heatCoil.setGasBurnerEfficiency(heatingEffOrCOP)\n    \n    def updateElectricHeatingCoil(self, model, heatCoil, heatingAvailSched, heatingEffOrCOP):\n        if heatingAvailSched != 'ALWAYS ON':\n             heatAvailSch = self.getOSSchedule(heatingAvailSched, model)\n             heatCoil.setAvailabilitySchedule(heatAvailSch)\n        if heatingEffOrCOP != 'Default':\n            heatCoil.setEfficiency(heatingEffOrCOP)\n    \n    def updateWaterHeatingCoil(self, model, heatcoil, heatingAvailSched, supplyTemperature):\n        if heatingAvailSched != 'ALWAYS ON':\n             heatAvailSch = self.getOSSchedule(heatingAvailSched,model)\n             heatcoil.setAvailabilitySchedule(heatAvailSch)\n    \n    def getZoneTotalAir(self, hbZone):\n        zoneFlrArea = hbZone.getFloorArea(True)\n        totalZoneFlow = (hbZone.recirculatedAirPerArea*zoneFlrArea) +  (hbZone.ventilationPerArea*zoneFlrArea) + (hbZone.ventilationPerPerson*hbZone.numOfPeoplePerArea*zoneFlrArea)\n        return totalZoneFlow\n    \n    def setRecircOnSingleZoneSys(self, hbZone, system, fan):\n        totalZoneFlow = self.getZoneTotalAir(hbZone)\n        system.setSupplyAirFlowRateDuringCoolingOperation(totalZoneFlow)\n        system.setSupplyAirFlowRateDuringHeatingOperation(totalZoneFlow)\n        system.setSupplyAirFlowRateWhenNoCoolingorHeatingisNeeded(totalZoneFlow)\n        fan.setMaximumFlowRate(totalZoneFlow)\n    \n    def sizeAirTerminalForRecirc(self, model, HBZone, vavBox, zoneTotAir):\n        if HBZone.ventilationSched != '':\n            try:\n                vavBox.setZoneMinimumAirFlowMethod('Scheduled')\n            except:\n                vavBox.setZoneMinimumAirFlowInputMethod('Scheduled')\n            vavBox.setMaximumAirFlowRate(zoneTotAir)\n            minVentSch = self.getOSSchedule(HBZone.ventilationSched,model)\n            vavBox.setMinimumAirFlowFractionSchedule(minVentSch)\n        else:\n            try:\n                vavBox.setZoneMinimumAirFlowMethod('FixedFlowRate')\n            except:\n                vavBox.setZoneMinimumAirFlowInputMethod('FixedFlowRate')\n            vavBox.setFixedMinimumAirFlowRate(zoneTotAir)\n            vavBox.setMaximumAirFlowRate(2*zoneTotAir)\n    \n    def sizeVAVFanForRecirc(self, model, airloop, recircAirFlowRates):\n        fullHVACAirFlow = sum(recircAirFlowRates)\n        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:VariableVolume\"))\n        vvfan = model.getFanVariableVolume(x[0].handle()).get()\n        vvfan.setMaximumFlowRate(fullHVACAirFlow*2)\n    \n    def applyVentilationSched(self, model, HBZone, vavBox, zoneTotAir):\n        vavBox.setZoneMinimumAirFlowMethod('Scheduled')\n        vavBox.setMaximumAirFlowRate(zoneTotAir)\n        minVentSch = self.getOSSchedule(HBZone.ventilationSched,model)\n        vavBox.setMinimumAirFlowFractionSchedule(minVentSch)\n    \n    def addDehumidController(self, model, airloop, setPNode=None):\n        # Add a humidity set point controller into the air loop.\n        if setPNode == None:\n            setPNode = airloop.supplyOutletNode()\n        humidController = ops.SetpointManagerMultiZoneHumidityMaximum(model)\n        humidController.setMinimumSetpointHumidityRatio(0.001)\n        humidController.addToNode(setPNode)\n        return setPNode\n    \n    def addChilledWaterDehumid(self, model, airloop):\n        # Set the cooling coil to control humidity. \n        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n        cc = model.getCoilCoolingWater(x[0].handle()).get()\n        ccontroller = cc.controllerWaterCoil().get()\n        ccontroller.setControlVariable('TemperatureAndHumidityRatio')\n        sensorNode = self.addDehumidController(model, airloop)\n        ccontroller.setSensorNode(sensorNode)\n    \n    def addHeatPumpCoilDehumid(self, model, airloop):\n        # Get the unitary air system.\n        x = airloop.supplyComponents(ops.IddObjectType(\"OS:AirLoopHVAC:UnitarySystem\"))\n        unitarySystemCool = model.getAirLoopHVACUnitarySystem(x[0].handle()).get()\n        # Set the deumidification control type to CoolReheat\n        unitarySystemCool.setDehumidificationControlType('CoolReheat')\n        unitarySystemCool.setLatentLoadControl('LatentOrSensibleLoadControl')\n        # Add a humidity set point controller into the air loop.\n        humidController = ops.SetpointManagerMultiZoneHumidityMaximum(model)\n        humidController.setMinimumSetpointHumidityRatio(0.001)\n        setPNode = unitarySystemCool.airOutletModelObject().get().to_Node().get()\n        humidController.addToNode(setPNode)\n    \n    def addHumidifierController(self, model, airloop):\n        # Add a humidity set point controller into the air loop.\n        humidController = ops.SetpointManagerMultiZoneHumidityMinimum(model)\n        setPNode = airloop.supplyOutletNode()\n        humidController.addToNode(setPNode)\n        return setPNode\n    \n    def addElectricHumidifier(self, model, airloop):\n        humidifier = ops.HumidifierSteamElectric(model)\n        supplyNode = airloop.supplyOutletNode()\n        humidifier.addToNode(supplyNode)\n        self.addHumidifierController(model, airloop)\n    \n    def addHeatRecovToModel(self, model, airloop, sensibleHeatRecovery, latentHeatRecovery, econLockout=False, aedgRecov=False, latentEff=None):\n        if not (sensibleHeatRecovery == 0 and latentHeatRecovery == 0):\n            # Create an air-to-air heat exchanger.\n            heatEx = ops.HeatExchangerAirToAirSensibleAndLatent(model)\n            #Set how the economizer interacts with the heat recovery.\n            heatEx.setEconomizerLockout(econLockout)\n            # Change the properties of the heat exchanger based on the inputs.\n            if latentHeatRecovery == 'Default':\n                heatEx.setLatentEffectivenessat100CoolingAirFlow(0.68)\n                heatEx.setLatentEffectivenessat100HeatingAirFlow(0.68)\n                heatEx.setLatentEffectivenessat75CoolingAirFlow(0.73)\n                heatEx.setLatentEffectivenessat75HeatingAirFlow(0.73)\n            if sensibleHeatRecovery == 'Default':\n                heatEx.setSensibleEffectivenessat100CoolingAirFlow(0.76)\n                heatEx.setSensibleEffectivenessat100HeatingAirFlow(0.76)\n                heatEx.setSensibleEffectivenessat75CoolingAirFlow(0.81)\n                heatEx.setSensibleEffectivenessat75HeatingAirFlow(0.81)\n            if latentHeatRecovery != 'Default':\n                effAtMax = latentHeatRecovery*(0.68/0.73)\n                heatEx.setLatentEffectivenessat100CoolingAirFlow(effAtMax)\n                heatEx.setLatentEffectivenessat100HeatingAirFlow(effAtMax)\n                heatEx.setLatentEffectivenessat75CoolingAirFlow(latentHeatRecovery)\n                heatEx.setLatentEffectivenessat75HeatingAirFlow(latentHeatRecovery)\n            if sensibleHeatRecovery != 'Default':\n                effAtMax = sensibleHeatRecovery*(0.76/0.81)\n                heatEx.setSensibleEffectivenessat100CoolingAirFlow(effAtMax)\n                heatEx.setSensibleEffectivenessat100HeatingAirFlow(effAtMax)\n                heatEx.setSensibleEffectivenessat75CoolingAirFlow(sensibleHeatRecovery)\n                heatEx.setSensibleEffectivenessat75HeatingAirFlow(sensibleHeatRecovery)\n            \n            if aedgRecov == True:\n                heatEx.setFrostControlType(\"ExhaustOnly\")\n                heatEx.setThresholdTemperature(-12.2)\n                heatEx.setInitialDefrostTimeFraction(0.1670)\n                heatEx.setRateofDefrostTimeFractionIncrease(0.0240)\n            # Add the heat exchanger to the model.\n            outdoorNode = airloop.reliefAirNode().get()\n            heatEx.addToNode(outdoorNode)\n    \n    def setAirLoopToOnceThroughAir(self, airloop, model):\n        oasys = airloop.airLoopHVACOutdoorAirSystem()\n        oactrl = oasys.get().getControllerOutdoorAir()\n        onceTrhoughSched = self.createConstantScheduleRuleset('OnceThroughAir', 'OnceThroughAirSched', 'FRACTION', 1, model)\n        oactrl.setMinimumFractionofOutdoorAirSchedule(onceTrhoughSched)\n    \n    def setSizingForRecirc(self, airloop):\n        # set the sizing on the system to not use 100% outdoor air\n        sizingSystem = airloop.sizingSystem()\n        sizingSystem.setAllOutdoorAirinCooling(False)\n        sizingSystem.setAllOutdoorAirinHeating(False)\n    \n    def addDefaultAirsideEcon(self, airloop, dehumidTrigger):\n        oasys = airloop.airLoopHVACOutdoorAirSystem()\n        oactrl = oasys.get().getControllerOutdoorAir()\n        if dehumidTrigger is True:\n            oactrl.setEconomizerControlType('DifferentialEnthalpy')\n        else:\n            oactrl.setEconomizerControlType('DifferentialDryBulb')\n    \n    def adjustAirSideEcon(self, airloop, airDetails):\n        oasys = airloop.airLoopHVACOutdoorAirSystem()\n        oactrl = oasys.get().getControllerOutdoorAir()\n        oactrl.setEconomizerControlType(airDetails.airsideEconomizer)\n    \n    def swapCVFanForVV(self, model, airloop, airDetails):\n        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:ConstantVolume\"))\n        cvfan = model.getFanConstantVolume(x[0].handle()).get()\n        cvfan.remove()\n        vvFan = self.createDefaultAEDGFan('VV', model, airDetails)\n        supplyAirNode = airloop.supplyOutletNode()\n        vvFan.addToNode(supplyAirNode)\n    \n    def adjustCVAirLoop(self, model, airloop, airDetails):\n        econLockout = False\n        if airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n            hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched, model)\n            airloop.setAvailabilitySchedule(hvacAvailSch)\n        if airDetails.fanTotalEfficiency != \"Default\" or airDetails.fanMotorEfficiency != \"Default\" or airDetails.fanPressureRise != \"Default\" or airDetails.airSysHardSize != \"Default\":\n            x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:ConstantVolume\"))\n            cvfan = model.getFanConstantVolume(x[0].handle()).get()\n            self.updateFan(cvfan,airDetails.fanTotalEfficiency,airDetails.fanMotorEfficiency,airDetails.fanPressureRise,airDetails.airSysHardSize)\n        if airDetails.airSysHardSize != \"Default\":\n            airloop.setDesignSupplyAirFlowRate(float(airDetails.airSysHardSize))\n        if airDetails.fanPlacement != 'Default':\n            if airDetails.fanPlacement == 'Blow Through':\n                x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:ConstantVolume\"))\n                cvfan = model.getFanConstantVolume(x[0].handle()).get()\n                mixAirNode = airloop.mixedAirNode().get()\n                cvfan.addToNode(mixAirNode)\n        if airDetails.heatingSupplyAirTemp != 'Default' or airDetails.coolingSupplyAirTemp != 'Default':\n            self.updateCVLoopSupplyTemp(airloop, model, airDetails.coolingSupplyAirTemp, airDetails.heatingSupplyAirTemp)\n        if airDetails.recirculation == 'False':\n            self.setAirLoopToOnceThroughAir(airloop, model)\n        if airDetails.airsideEconomizer != 'Default':\n            if airDetails.airsideEconomizer == 'NoEconomizer':\n                econLockout = True\n            self.adjustAirSideEcon(airloop, airDetails)\n        else:\n            self.addDefaultAirsideEcon(airloop, False)\n        if airDetails.sensibleHeatRecovery != 'Default' or airDetails.latentHeatRecovery != 'Default':\n            self.addHeatRecovToModel(model, airloop, airDetails.sensibleHeatRecovery, airDetails.latentHeatRecovery, econLockout)\n        if airDetails.fanControl == 'Variable Volume':\n            self.swapCVFanForVV(model, airloop, airDetails)\n            self.setDemandVent(model, airloop)\n    \n    def adjustVAVAirLoop(self, model, airloop, airDetails, HVACCount, dehumidTrigger, waterCoolCoil=False, fanAdjustable=True):\n        econLockout = False\n        if airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n            hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched, model)\n            airloop.setAvailabilitySchedule(hvacAvailSch)\n        if airDetails.fanTotalEfficiency != \"Default\" or airDetails.fanMotorEfficiency != \"Default\" or airDetails.fanPressureRise != \"Default\" or airDetails.airSysHardSize != \"Default\":\n            x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:VariableVolume\"))\n            vvfan = model.getFanVariableVolume(x[0].handle()).get()\n            self.updateFan(vvfan,airDetails.fanTotalEfficiency,airDetails.fanMotorEfficiency,airDetails.fanPressureRise,airDetails.airSysHardSize)\n        if airDetails.airSysHardSize != \"Default\":\n            airloop.setDesignSupplyAirFlowRate(float(airDetails.airSysHardSize))\n        if airDetails.recirculation == 'False':\n            self.setAirLoopToOnceThroughAir(airloop, model)\n        if airDetails.airsideEconomizer != 'Default':\n            self.adjustAirSideEcon(airloop, airDetails)\n            if airDetails.airsideEconomizer == 'NoEconomizer':\n                econLockout = True\n        else:\n            self.addDefaultAirsideEcon(airloop, dehumidTrigger)\n        if airDetails.sensibleHeatRecovery != 'Default' or airDetails.latentHeatRecovery != 'Default':\n            self.addHeatRecovToModel(model, airloop, airDetails.sensibleHeatRecovery, airDetails.latentHeatRecovery, econLockout)\n        if airDetails.fanPlacement != 'Default' and fanAdjustable == True:\n            if airDetails.fanPlacement == 'Blow Through':\n                x = airloop.supplyComponents(ops.IddObjectType(\"OS:Fan:VariableVolume\"))\n                vvfan = model.getFanVariableVolume(x[0].handle()).get()\n                mixAirNode = airloop.mixedAirNode().get()\n                vvfan.addToNode(mixAirNode)\n        if airDetails.coolingSupplyAirTemp != 'Default':\n            self.updateLoopSupplyTemp(airloop, model, airDetails.coolingSupplyAirTemp, \"Deck_Temperature_Default\", \"Deck_Temp\", HVACCount)\n            if waterCoolCoil == True:\n                # Change the rating on the cooling coil.\n                x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                hc = model.getCoilCoolingWater(x[0].handle()).get()\n                hc.setDesignOutletAirTemperature(airDetails.coolingSupplyAirTemp)\n    \n    def adjustWaterReheatCoil(self, model, vavBox, airDetails, heatingDetails):\n        if heatingDetails != None:\n            if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.supplyTemperature != \"Default\":\n                reheatCoil = vavBox.reheatCoil()\n                hc = model.getCoilHeatingWater(reheatCoil.handle()).get()\n                self.updateWaterHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.supplyTemperature)\n    \n    def adjustElectricReheatCoil(self, model, vavBox, heatingDetails):\n        if heatingDetails != None:\n            if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                reheatCoil = vavBox.reheatCoil()\n                hc = model.getCoilHeatingElectric(reheatCoil.handle()).get()\n                self.updateElectricHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n    \n    def adjustHotWaterLoop(self, model, airloop, heatingDetails, HVACCount):\n        if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != \"Default\" or heatingDetails.supplyTemperature != \"Default\"  or heatingDetails.pumpMotorEfficiency != \"Default\":\n            x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Water\"))\n            hc = model.getCoilHeatingWater(x[0].handle()).get()\n            hwl = hc.plantLoop().get()\n            if heatingDetails.heatingEffOrCOP != \"Default\" or heatingDetails.supplyTemperature != \"Default\":\n                boilerVec = hwl.supplyComponents(ops.IddObjectType(\"OS:Boiler:HotWater\"))\n                for boiler in boilerVec:\n                    osBoiler = model.getBoilerHotWater(boiler.handle()).get()\n                    self.updateBoiler(model, osBoiler, heatingDetails.heatingEffOrCOP, heatingDetails.supplyTemperature, heatingDetails.heatHardSize)\n            if heatingDetails.pumpMotorEfficiency != \"Default\":\n                pumpVec = hwl.supplyComponents(ops.IddObjectType(\"OS:Pump:VariableSpeed\"))\n                for pump in enumerate(pumpVec):\n                    osPump = model.getPumpVariableSpeed(pump[1].handle()).get()\n                    self.updatePump(osPump, heatingDetails.pumpMotorEfficiency)\n            if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.supplyTemperature != \"Default\":\n                self.updateWaterHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.supplyTemperature)\n            if heatingDetails.supplyTemperature != \"Default\":\n                self.updateLoopSupplyTemp(hwl, model, heatingDetails.supplyTemperature, \"Hot_Water_Temperature_Default\", \"Hot_Water_Temp\", HVACCount)\n    \n    def adjustChilledWaterLoop(self, model, airloop, coolingDetails, HVACCount):\n        if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\" or coolingDetails.supplyTemperature != \"Default\"  or coolingDetails.pumpMotorEfficiency != \"Default\":\n            x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n            cc = model.getCoilCoolingWater(x[0].handle()).get()\n            cwl = cc.plantLoop().get()\n            if coolingDetails.coolingCOP != \"Default\" or coolingDetails.supplyTemperature != \"Default\" or coolingDetails.coolHardSize != \"Autosize\":\n                chillervec = cwl.supplyComponents(ops.IddObjectType(\"OS:Chiller:Electric:EIR\"))\n                for chiller in chillervec:\n                    osChiller = model.getChillerElectricEIR(chiller.handle()).get()\n                    self.updateChiller(model, osChiller, coolingDetails.coolingCOP, coolingDetails.supplyTemperature, coolingDetails.coolHardSize)\n            if coolingDetails.pumpMotorEfficiency != \"Default\":\n                pumpVec = cwl.supplyComponents(ops.IddObjectType(\"OS:Pump:VariableSpeed\"))\n                for pump in enumerate(pumpVec):\n                    osPump = model.getPumpVariableSpeed(pump[1].handle()).get()\n                    self.updatePump(osPump, coolingDetails.pumpMotorEfficiency)\n            if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.supplyTemperature != \"Default\":\n                self.updateWaterCoolingCoil(model, cc, coolingDetails.coolingAvailSched, coolingDetails.supplyTemperature)\n            if coolingDetails.supplyTemperature != \"Default\":\n                self.updateLoopSupplyTemp(cwl, model, coolingDetails.supplyTemperature, 'Chilled_Water_Temperature_Default', 'Chilled_Water_Temp', HVACCount)\n    \n    def updateCVLoopSupplyTemp(self, airloop, model, suppTempLow, supTempHigh):\n        supplyNode = airloop.supplyOutletNode()\n        spManager = supplyNode.getSetpointManagerSingleZoneReheat().get()\n        if suppTempLow != 'Default':\n            spManager.setMinimumSupplyAirTemperature(suppTempLow)\n        if supTempHigh != 'Default':\n            spManager.setMaximumSupplyAirTemperature(supTempHigh)\n    \n    def updateLoopSupplyTemp(self, loop, model, suppTemp, schedName, ruleSetName, HVACCount):\n        #Change the cooling supply air temperature schedule.\n        suppTempRuleset = self.createConstantScheduleRuleset(ruleSetName + str(HVACCount), schedName + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n        supplyNode = loop.supplyOutletNode()\n        spManager = supplyNode.setpointManagerScheduled().get()\n        spManager.setSchedule(suppTempRuleset)\n    \n    ### END OF FUNCTIONS FOR EDITING HVAC SYSTEMS ###\n    \n    \n    ### START OF FUNCTION FOR ADDING HVAC SYSTEMS TO THE MODEL ###\n    def addSystemsToZones(self, model):\n        # Variabe to track the number of systems.\n        HVACCount = 0\n        # Variables for central plants (if requested).\n        centralHeat = None\n        centralCool = None\n        centralConden = None\n        centralAir = None\n        for osHVAC in (sorted(self.HVACSystemDict.values(), key=operator.attrgetter('count'))):\n            # HAVC system index for this group and thermal zones.\n            HAVCGroupID, systemIndex, thermalZones, hbZones, airDetails, heatingDetails, coolingDetails = osHVAC.getData()\n            # Put thermal zones into a vector and create a list of the thermal zone handles to help identify the zones that are a part of the HVAC system.\n            thermalZoneVector = ops.ThermalZoneVector(thermalZones)\n            thermalZoneHandles = []\n            for tZone in thermalZones:\n                thermalZoneHandles.append(str(tZone.handle()))\n            \n            # Variables that signal whether the zones have something definied that needs to be applied to the whole HVAC.\n            recircAirFlowRates = []\n            recicTrigger = False\n            dehumidTrigger = False\n            humidTrigger = False\n            HVACCount +=1\n            \n            # Check that the version of OpenStudio is correct for ground source hydronic systems.\n            if coolingDetails != None:\n                if coolingDetails.chillerType == 'GroundSourced':\n                    if vernum1 > 2:\n                        pass\n                    elif vernum1 == 2 and vernum2 >=4:\n                        pass\n                    else:\n                        msg = 'You must have OpenStudio 2.5 or greater to use ground sourced systems.'\n                        raise Exception(msg)\n            \n            # add systems. There are 10 standard ASHRAE systems + Ideal Air Loads\n            if systemIndex == -1:\n                # -1: Thermostat Only (no system)\n                #This is useful if someone wants to build all systems within the OpenStudio interface or apply them through a measure.\n                pass\n            elif systemIndex == 0:\n                # 0: Ideal Air Loads\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    #Set the zone's use of ideal air to \"True.\"\n                    zone.setUseIdealAirLoads(True)\n                    # Create the ideal air system\n                    zoneIdealAir = ops.ZoneHVACIdealLoadsAirSystem(model)\n                    \n                    # Set the name of the system to include the zone name.\n                    zoneIdealAir.setName(hbZones[zoneCount].name + ' IDEAL LOADS AIR SYSTEM')\n                    \n                    #Set the dehumidifcation / humidification based on the presence/absence of a zone humidistat.\n                    dehumidTrigger = False\n                    if hbZones[zoneCount].humidityMax != \"\":\n                        dehumidTrigger = True\n                        zoneIdealAir.setDehumidificationControlType(\"Humidistat\")\n                    else: zoneIdealAir.setDehumidificationControlType(\"None\")\n                    if hbZones[zoneCount].humidityMin != \"\":\n                        zoneIdealAir.setHumidificationControlType(\"Humidistat\")\n                    else: zoneIdealAir.setHumidificationControlType(\"None\")\n                    \n                    # Set an airside economizer and demand controlled ventilation by default.\n                    if dehumidTrigger is True:\n                        zoneIdealAir.setOutdoorAirEconomizerType('DifferentialEnthalpy')\n                    else:\n                        zoneIdealAir.setOutdoorAirEconomizerType('DifferentialDryBulb')\n                    zoneIdealAir.setCoolingLimit('LimitFlowRate')\n                    zoneIdealAir.autosizeMaximumCoolingAirFlowRate()\n                    \n                    # Set the airDetails.\n                    if airDetails != None:\n                        if airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n                            hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched,model)\n                            zoneIdealAir.setAvailabilitySchedule(hvacAvailSch)\n                        if airDetails.fanControl == 'Variable Volume':\n                            zoneIdealAir.setDemandControlledVentilationType('OccupancySchedule')\n                        if airDetails.heatingSupplyAirTemp != 'Default':\n                            zoneIdealAir.setMaximumHeatingSupplyAirTemperature(airDetails.heatingSupplyAirTemp)\n                        if airDetails.coolingSupplyAirTemp != 'Default':\n                            zoneIdealAir.setMinimumCoolingSupplyAirTemperature(airDetails.coolingSupplyAirTemp)\n                        if airDetails.airsideEconomizer != 'Default':\n                            zoneIdealAir.setOutdoorAirEconomizerType(airDetails.airsideEconomizer)\n                            if airDetails.airsideEconomizer == 'NoEconomizer':\n                                zoneIdealAir.setCoolingLimit('NoLimit')\n                        if airDetails.airSysHardSize != \"Default\":\n                            zoneIdealAir.setCoolingLimit('LimitFlowRate')\n                            zoneIdealAir.setMaximumCoolingAirFlowRate(float(airDetails.airSysHardSize))\n                        if airDetails.sensibleHeatRecovery != 'Default' and airDetails.sensibleHeatRecovery != 0:\n                            zoneIdealAir.setHeatRecoveryType('Sensible')\n                            zoneIdealAir.setSensibleHeatRecoveryEffectiveness(airDetails.sensibleHeatRecovery)\n                            zoneIdealAir.setLatentHeatRecoveryEffectiveness(0)\n                        if airDetails.latentHeatRecovery != 'Default' and airDetails.latentHeatRecovery != 0:\n                            zoneIdealAir.setHeatRecoveryType('Enthalpy')\n                            zoneIdealAir.setLatentHeatRecoveryEffectiveness(airDetails.latentHeatRecovery)\n                            if airDetails.sensibleHeatRecovery == 'Default':\n                                zoneIdealAir.setSensibleHeatRecoveryEffectiveness(0.8)\n                    \n                    # Set the heatingDetails.\n                    if heatingDetails != None:\n                        if heatingDetails.heatingAvailSched != 'ALWAYS ON':\n                            heatAvailSch = self.getOSSchedule(heatingDetails.heatingAvailSched,model)\n                            zoneIdealAir.setHeatingAvailabilitySchedule(heatAvailSch)\n                    \n                    # Set the coolingDetails.\n                    if coolingDetails != None:\n                        if coolingDetails.coolingAvailSched != 'ALWAYS ON':\n                            coolAvailSch = self.getOSSchedule(coolingDetails.coolingAvailSched,model)\n                            zoneIdealAir.setCoolingAvailabilitySchedule(coolAvailSch)\n                    \n                    # Add the ideal air system to the thermal zone.\n                    zoneIdealAir.addToThermalZone(zone)\n                \n            elif systemIndex == 1:\n                # 1: PTAC, Residential\n                ops.OpenStudioModelHVAC.addSystemType1(model, thermalZoneVector)\n                allptacs = model.getZoneHVACPackagedTerminalAirConditioners()\n                zoneCount = 0\n                \n                for ptac in allptacs:\n                    zoneHandle = str(ptac.thermalZone().get().handle())\n                    if zoneHandle in thermalZoneHandles:\n                        hvacHandle = ptac.handle()\n                        \n                        #Set the airDetails.\n                        if airDetails != None:\n                            if airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n                                hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched, model)\n                                ptac.setAvailabilitySchedule(hvacAvailSch)\n                            if airDetails.fanPlacement != 'Default':\n                                ptac.setFanPlacement(airDetails.fanPlacement)\n                            if airDetails.fanTotalEfficiency != \"Default\" or airDetails.fanMotorEfficiency != \"Default\" or airDetails.fanPressureRise != \"Default\" or airDetails.airSysHardSize != \"Default\":\n                                sfname = ptac.supplyAirFan().name()\n                                cvfan = model.getFanConstantVolumeByName(str(sfname)).get()\n                                self.updateFan(cvfan,airDetails.fanTotalEfficiency,airDetails.fanMotorEfficiency,airDetails.fanPressureRise,airDetails.airSysHardSize)\n                        \n                        #Set the heatingDetails.\n                        if heatingDetails != None:\n                            if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.supplyTemperature != 'Default':\n                                x = ptac.heatingCoil().name()\n                                hc = model.getCoilHeatingWaterByName(str(x)).get()\n                                self.updateWaterHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.supplyTemperature)\n                        \n                        #Set the coolingDetails.\n                        if coolingDetails != None:\n                            if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                                ccname = ptac.coolingCoil().name()\n                                cc = model.getCoilCoolingDXSingleSpeedByName(str(ccname)).get()\n                                self.updateDXCoolingCoil(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n                        \n                        # Set zone-specific parameters like a specified portion of recirculated air.\n                        # Recirculated air also means that we have to hard-size the fan.\n                        if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                            sfname = ptac.supplyAirFan().name()\n                            cvfan = model.getFanConstantVolumeByName(str(sfname)).get()\n                            self.setRecircOnSingleZoneSys(hbZones[zoneCount], ptac, cvfan)\n                        zoneCount += 1\n                \n                #If heating details are set, change them at the level of the boiler.\n                if heatingDetails != None:\n                    if heatingDetails.heatingEffOrCOP != \"Default\" or heatingDetails.supplyTemperature != \"Default\"  or heatingDetails.pumpMotorEfficiency != \"Default\":\n                        x = ptac.heatingCoil().name()\n                        hc = model.getCoilHeatingWaterByName(str(x)).get()\n                        hwl = hc.plantLoop().get()\n                        if heatingDetails.heatingEffOrCOP != \"Default\" or heatingDetails.supplyTemperature != \"Default\" or heatingDetails.heatHardSize != \"Autosize\":\n                            boilerVec = hwl.supplyComponents(ops.IddObjectType(\"OS:Boiler:HotWater\"))\n                            for boiler in boilerVec:\n                                osBoiler = model.getBoilerHotWater(boiler.handle()).get()\n                                self.updateBoiler(model, osBoiler, heatingDetails.heatingEffOrCOP, heatingDetails.supplyTemperature, heatingDetails.heatHardSize)\n                        if heatingDetails.pumpMotorEfficiency != \"Default\":\n                            pumpVec = hwl.supplyComponents(ops.IddObjectType(\"OS:Pump:VariableSpeed\"))\n                            for pump in enumerate(pumpVec):\n                                osPump = model.getPumpVariableSpeed(pump[1].handle()).get()\n                                self.updatePump(osPump, heatingDetails.pumpMotorEfficiency)\n                        if heatingDetails.supplyTemperature != \"Default\":\n                            self.updateLoopSupplyTemp(hwl, model, heatingDetails.supplyTemperature, \"Hot_Water_Temperature_Default\", \"Hot_Water_Temp\", HVACCount)\n                \n            elif systemIndex == 2:\n                # 2: PTHP, Residential\n                ops.OpenStudioModelHVAC.addSystemType2(model, thermalZoneVector)\n                allpthps = model.getZoneHVACPackagedTerminalHeatPumps()\n                zoneCount = 0\n                \n                for pthp in allpthps:\n                    zoneHandle = str(pthp.thermalZone().get().handle())\n                    if zoneHandle in thermalZoneHandles:\n                        hvacHandle = pthp.handle()\n                        \n                        #Set the airDetails.\n                        if airDetails != None:\n                            if airDetails.HVACAvailabiltySched != 'ALWAYS ON':\n                                hvacAvailSch = self.getOSSchedule(airDetails.HVACAvailabiltySched, model)\n                                pthp.setAvailabilitySchedule(hvacAvailSch)\n                            if airDetails.fanPlacement != 'Default':\n                                pthp.setFanPlacement(airDetails.fanPlacement)\n                            if airDetails.fanTotalEfficiency != \"Default\" or airDetails.fanMotorEfficiency != \"Default\" or airDetails.fanPressureRise != \"Default\" or airDetails.airSysHardSize != \"Default\":\n                                sfname = pthp.supplyAirFan().name()\n                                cvfan = model.getFanConstantVolumeByName(str(sfname)).get()\n                                self.updateFan(cvfan,airDetails.fanTotalEfficiency,airDetails.fanMotorEfficiency,airDetails.fanPressureRise,airDetails.airSysHardSize)\n                        \n                        #Set the heatingDetails.\n                        if heatingDetails != None:\n                            if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                                x = pthp.heatingCoil().handle()\n                                hc = model.getCoilHeatingDXSingleSpeed(x).get()\n                                self.updateDXHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n                        \n                        #Set the coolingDetails.\n                        if coolingDetails != None:\n                            if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                                ccname = pthp.coolingCoil().name()\n                                cc = model.getCoilCoolingDXSingleSpeedByName(str(ccname)).get()\n                                self.updateDXCoolingCoil(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n                        \n                        # Set zone-specific parameters like a specified portion of recirculated air.\n                        # Recirculated air also means that we have to hard-size the fan.\n                        if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                            sfname = pthp.supplyAirFan().name()\n                            cvfan = model.getFanConstantVolumeByName(str(sfname)).get()\n                            self.setRecircOnSingleZoneSys(hbZones[zoneCount], pthp, cvfan)\n                        zoneCount += 1\n                \n            elif systemIndex == 3:\n                # 3: Packaged Single Zone - AC\n                hvacHandle = ops.OpenStudioModelHVAC.addSystemType3(model).handle()\n                airloop = model.getAirLoopHVAC(hvacHandle).get()\n                self.setSizingForRecirc(airloop)\n                humidTrigg = False\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    if hbZones[zoneCount].humidityMin != '' and humidTrigg == False:\n                        humidTrigg = True\n                        self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustCVAirLoop(model, airloop, airDetails)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                #Set the heatingDetails.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Gas\"))\n                        hc = model.getCoilHeatingGas(hcs[0].handle()).get()\n                        self.updateGasHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n                \n                #Set the coolingDetails.\n                if coolingDetails != None:\n                    if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                        comps = airloop.supplyComponents()\n                        ccs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:DX:SingleSpeed\"))\n                        cc = model.getCoilCoolingDXSingleSpeed(ccs[0].handle()).get()\n                        self.updateDXCoolingCoil(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n            \n            elif systemIndex == 4:\n                # 4: Packaged Single Zone - HP\n                handle = ops.OpenStudioModelHVAC.addSystemType4(model).handle()\n                airloop = model.getAirLoopHVAC(handle).get()\n                self.setSizingForRecirc(airloop)\n                humidTrigg = False\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    \n                    if hbZones[zoneCount].humidityMin != '' and humidTrigg == False:\n                        humidTrigg = True\n                        self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustCVAirLoop(model, airloop, airDetails)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                #Set the heatingDetails.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:DX:SingleSpeed\"))\n                        hc = model.getCoilHeatingDXSingleSpeed(hcs[0].handle()).get()\n                        self.updateDXHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n                \n                #Set the coolingDetails.\n                if coolingDetails != None:\n                    if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                        comps = airloop.supplyComponents()\n                        ccs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:DX:SingleSpeed\"))\n                        cc = model.getCoilCoolingDXSingleSpeed(ccs[0].handle()).get()\n                        self.updateDXCoolingCoil(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n            \n            elif systemIndex == 5:\n                # 5: Packaged VAV w/ Reheat\n                if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat != None:\n                    airloop = self.addVAVairLoop(model, centralCool, centralHeat, 5)\n                else:\n                    hvacHandle = ops.OpenStudioModelHVAC.addSystemType5(model).handle()\n                    airloop = model.getAirLoopHVAC(hvacHandle).get()\n                    if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat == None:\n                        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Water\"))\n                        hc = model.getCoilHeatingWater(x[0].handle()).get()\n                        hwl = hc.plantLoop().get()\n                        centralHeat = hwl\n                self.setSizingForRecirc(airloop)\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    \n                    # If there is recirculated air specificed, then specify it at the level of the VAV Box.\n                    zoneTotAir = self.getZoneTotalAir(hbZones[zoneCount])\n                    recircAirFlowRates.append(zoneTotAir)\n                    x = airloop.demandComponents(ops.IddObjectType(\"OS:AirTerminal:SingleDuct:VAV:Reheat\"))\n                    vavBox = model.getAirTerminalSingleDuctVAVReheat(x[zoneCount].handle()).get()\n                    \n                    if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat != None:\n                        reheatCoil = vavBox.reheatCoil()\n                        hc = model.getCoilHeatingWater(reheatCoil.handle()).get()\n                        centralHeat.addDemandBranchForComponent(hc)\n                    \n                    if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                        recicTrigger = True\n                        self.sizeAirTerminalForRecirc(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    elif recicTrigger == True:\n                        vavBox.setZoneMinimumAirFlowMethod('Constant')\n                        vavBox.autosizeMaximumAirFlowRate()\n                        vavBox.resetMinimumAirFlowFractionSchedule()\n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                    \n                    # If there are any ventilation schedules specified, then set the VAV Box to follow them.\n                    if hbZones[zoneCount].ventilationSched != '':\n                        self.applyVentilationSched(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    \n                    self.adjustWaterReheatCoil(model, vavBox, airDetails, heatingDetails)\n                \n                #If there is recirculated air, we also have to hard size the fan to ensure that enough air can get through the system.\n                if recicTrigger == True:\n                    self.sizeVAVFanForRecirc(model, airloop, recircAirFlowRates)\n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustVAVAirLoop(model, airloop, airDetails, HVACCount, dehumidTrigger, False)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                # Set the heatingDetails at the level of the boiler.\n                if heatingDetails != None:\n                    self.adjustHotWaterLoop(model, airloop, heatingDetails, HVACCount)\n                \n                # Set the coolingDetails at the level of the central DX coil.\n                if coolingDetails != None:\n                    if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                        comps = airloop.supplyComponents()\n                        ccs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:DX:TwoSpeed\"))\n                        cc = model.getCoilCoolingDXTwoSpeed(ccs[0].handle()).get()\n                        self.updateDXCoolingCoilTwoSpeed(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n            \n            elif systemIndex == 6:\n                # 6: Packaged VAV w/ PFP Boxes\n                hvacHandle = ops.OpenStudioModelHVAC.addSystemType6(model).handle()\n                airloop = model.getAirLoopHVAC(hvacHandle).get()\n                self.setSizingForRecirc(airloop)\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    \n                    # If there is recirculated air specificed, then specify it at the level of the VAV Box.\n                    zoneTotAir = self.getZoneTotalAir(hbZones[zoneCount])\n                    recircAirFlowRates.append(zoneTotAir)\n                    x = airloop.demandComponents(ops.IddObjectType(\"OS:AirTerminal:SingleDuct:ParallelPIU:Reheat\"))\n                    vavBox = model.getAirTerminalSingleDuctParallelPIUReheat(x[zoneCount].handle()).get()\n                    if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                        recicTrigger = True\n                        self.sizeAirTerminalForRecirc(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    elif recicTrigger == True:\n                        vavBox.setZoneMinimumAirFlowMethod('Constant')\n                        vavBox.autosizeMaximumAirFlowRate()\n                        vavBox.resetMinimumAirFlowFractionSchedule()\n                    \n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                    self.adjustElectricReheatCoil(model, vavBox, heatingDetails)\n                \n                #If there is recirculated air, we also have to hard size the fan to ensure that enough air can get through the system.\n                if recicTrigger == True:\n                    self.sizeVAVFanForRecirc(model, airloop, recircAirFlowRates)\n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustVAVAirLoop(model, airloop, airDetails, HVACCount, False, False, False)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                # Set the heatingDetails at the level of the electric resistance heater.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Electric\"))\n                        hc = model.getCoilHeatingElectric(hcs[0].handle()).get()\n                        self.updateElectricHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n                \n                # Set the coolingDetails at the level of the central DX coil.\n                if coolingDetails != None:\n                    if coolingDetails.coolingAvailSched != \"ALWAYS ON\" or coolingDetails.coolingCOP != \"Default\":\n                        comps = airloop.supplyComponents()\n                        ccs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:DX:TwoSpeed\"))\n                        cc = model.getCoilCoolingDXTwoSpeed(ccs[0].handle()).get()\n                        self.updateDXCoolingCoilTwoSpeed(model, cc, coolingDetails.coolingAvailSched, coolingDetails.coolingCOP)\n            \n            elif systemIndex == 7:\n                # 7: VAV w/ Reheat\n                if (coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool != None) or (heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat != None):\n                    airloop = self.addVAVairLoop(model, centralCool, centralHeat, 7)\n                else:\n                    hvacHandle = ops.OpenStudioModelHVAC.addSystemType7(model).handle()\n                    airloop = model.getAirLoopHVAC(hvacHandle).get()\n                    if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat == None:\n                        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Water\"))\n                        hc = model.getCoilHeatingWater(x[0].handle()).get()\n                        hwl = hc.plantLoop().get()\n                        centralHeat = hwl\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool == None:\n                        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                        cc = model.getCoilCoolingWater(x[0].handle()).get()\n                        cwl = cc.plantLoop().get()\n                        centralCool = cwl\n                self.setSizingForRecirc(airloop)\n                \n                if (coolingDetails != None and coolingDetails.chillerType == \"GroundSourced\"):\n                    centHeatPump = self.createDefaultGroundSourceChiller(model, coolingDetails, HVACCount, heatingDetails)\n                    x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                    cc = model.getCoilCoolingWater(x[0].handle()).get()\n                    cwl = cc.plantLoop().get()\n                    self.replaceChillerWithHeatPump(model, centHeatPump, cwl, HVACCount)\n                    cndwl = self.addInfiniteCapacityGroundLoop(model, cwl, HVACCount, coolingDetails)\n                    \n                    x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Water\"))\n                    hc = model.getCoilHeatingWater(x[0].handle()).get()\n                    hwl = hc.plantLoop().get()\n                    # remove boiler and add heat pump.\n                    self.replaceBoilerWithHeatPump(model, hwl, cwl, HVACCount)\n                    self.updateLoopSupplyTemp(hwl, model, 45, \"Hot_Water_Temperature_Default\", \"Hot_Water_Temp\", HVACCount)\n                elif (coolingDetails != None and coolingDetails.chillerType == \"AirCooled\"):\n                    airChill = self.createDefaultAEDGAirChiller(model, coolingDetails, HVACCount)\n                    x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                    cc = model.getCoilCoolingWater(x[0].handle()).get()\n                    cwl = cc.plantLoop().get()\n                    self.replaceWaterChillWithAirChill(model, airChill, cwl, HVACCount)\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    \n                    # If there is recirculated air specificed, then specify it at the level of the VAV Box.\n                    zoneTotAir = self.getZoneTotalAir(hbZones[zoneCount])\n                    recircAirFlowRates.append(zoneTotAir)\n                    x = airloop.demandComponents(ops.IddObjectType(\"OS:AirTerminal:SingleDuct:VAV:Reheat\"))\n                    vavBox = model.getAirTerminalSingleDuctVAVReheat(x[zoneCount].handle()).get()\n                    \n                    if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat != None:\n                        reheatCoil = vavBox.reheatCoil()\n                        hc = model.getCoilHeatingWater(reheatCoil.handle()).get()\n                        centralHeat.addDemandBranchForComponent(hc)\n                    \n                    if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                        recicTrigger = True\n                        self.sizeAirTerminalForRecirc(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    elif recicTrigger == True:\n                        vavBox.setZoneMinimumAirFlowMethod('Constant')\n                        vavBox.autosizeMaximumAirFlowRate()\n                        vavBox.resetMinimumAirFlowFractionSchedule()\n                    \n                    # If there are any ventilation schedules specified, then set the VAV Box to follow them.\n                    if hbZones[zoneCount].ventilationSched != '':\n                        self.applyVentilationSched(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    \n                    #Check for any humidity setpoints.\n                    if hbZones[zoneCount].humidityMax != '':\n                        dehumidTrigger = True\n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                    self.adjustWaterReheatCoil(model, vavBox, airDetails, heatingDetails)\n                \n                #If there is recirculated air, we also have to hard size the fan to ensure that enough air can get through the system.\n                if recicTrigger == True:\n                    self.sizeVAVFanForRecirc(model, airloop, recircAirFlowRates)\n                # If there is a maximum humidity assigned to the zone, set the cooling coil to dehumidify the air.\n                if dehumidTrigger == True:\n                    self.addChilledWaterDehumid(model, airloop)\n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustVAVAirLoop(model, airloop, airDetails, HVACCount, dehumidTrigger, True)\n                else:\n                    self.addDefaultAirsideEcon(airloop, dehumidTrigger)\n                \n                # Set the heatingDetails at the level of the boiler.\n                if heatingDetails != None:\n                    self.adjustHotWaterLoop(model, airloop, heatingDetails, HVACCount)\n                \n                # Set the coolingDetails at the level of the chiller.\n                if coolingDetails != None:\n                    self.adjustChilledWaterLoop(model, airloop, coolingDetails, HVACCount)\n            \n            elif systemIndex == 8:\n                # 8: VAV w/ PFP Boxes\n                if (coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool != None):\n                    airloop = self.addVAVairLoop(model, centralCool, centralHeat, 8)\n                else:\n                    hvacHandle = ops.OpenStudioModelHVAC.addSystemType8(model).handle()\n                    airloop = model.getAirLoopHVAC(hvacHandle).get()\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool == None:\n                        x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                        cc = model.getCoilCoolingWater(x[0].handle()).get()\n                        cwl = cc.plantLoop().get()\n                        centralCool = cwl\n                self.setSizingForRecirc(airloop)\n                \n                if (coolingDetails != None and coolingDetails.chillerType == \"GroundSourced\"):\n                    warning = \"VAV w/ PFP Boxes cannot be ground sourced. \\n Defaulting to a water cooled chiller.\"\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                elif (coolingDetails != None and coolingDetails.chillerType == \"AirCooled\"):\n                    airChill = self.createDefaultAEDGAirChiller(model, coolingDetails, HVACCount)\n                    x = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Cooling:Water\"))\n                    cc = model.getCoilCoolingWater(x[0].handle()).get()\n                    cwl = cc.plantLoop().get()\n                    self.replaceWaterChillWithAirChill(model, airChill, cwl, HVACCount)\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    \n                    # If there is recirculated air specificed, then specify it at the level of the VAV Box.\n                    zoneTotAir = self.getZoneTotalAir(hbZones[zoneCount])\n                    recircAirFlowRates.append(zoneTotAir)\n                    x = airloop.demandComponents(ops.IddObjectType(\"OS:AirTerminal:SingleDuct:ParallelPIU:Reheat\"))\n                    vavBox = model.getAirTerminalSingleDuctParallelPIUReheat(x[zoneCount].handle()).get()\n                    if hbZones[zoneCount].recirculatedAirPerArea != 0:\n                        recicTrigger = True\n                        self.sizeAirTerminalForRecirc(model, hbZones[zoneCount], vavBox, zoneTotAir)\n                    elif recicTrigger == True:\n                        vavBox.setZoneMinimumAirFlowMethod('Constant')\n                        vavBox.autosizeMaximumAirFlowRate()\n                        vavBox.resetMinimumAirFlowFractionSchedule()\n                    \n                    if hbZones[zoneCount].humidityMax != '':\n                        dehumidTrigger = True\n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                    self.adjustElectricReheatCoil(model, vavBox, heatingDetails)\n                \n                #If there is recirculated air, we also have to hard size the fan to ensure that enough air can get through the system.\n                if recicTrigger == True:\n                    self.sizeVAVFanForRecirc(model, airloop, recircAirFlowRates)\n                # If there is a maximum humidity assigned to the zone, set the cooling coil to dehumidify the air.\n                if dehumidTrigger == True:\n                    self.addChilledWaterDehumid(model, airloop)\n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustVAVAirLoop(model, airloop, airDetails, HVACCount, dehumidTrigger, True, False)\n                else:\n                    self.addDefaultAirsideEcon(airloop, dehumidTrigger)\n                \n                # Set the heatingDetails at the level of the electric resistance heater.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Electric\"))\n                        hc = model.getCoilHeatingElectric(hcs[0].handle()).get()\n                        self.updateElectricHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n                \n                # Set the coolingDetails at the level of the chiller.\n                if coolingDetails != None:\n                    self.adjustChilledWaterLoop(model, airloop, coolingDetails, HVACCount)\n            \n            elif systemIndex == 9:\n                # 9: Warm Air Furnace - Gas Fired\n                hvacHandle = ops.OpenStudioModelHVAC.addSystemType9(model).handle()\n                airloop = model.getAirLoopHVAC(hvacHandle).get()\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                \n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustCVAirLoop(model, airloop, airDetails)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                #Set the heatingDetails.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Gas\"))\n                        hc = model.getCoilHeatingGas(hcs[0].handle()).get()\n                        self.updateGasHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n            \n            elif systemIndex == 10:\n                # 10: Warm Air Furnace - Electric\n                hvacHandle = ops.OpenStudioModelHVAC.addSystemType10(model).handle()\n                airloop = model.getAirLoopHVAC(hvacHandle).get()\n                \n                # Add branches for zones.\n                for zoneCount, zone in enumerate(thermalZoneVector):\n                    airloop.addBranchForZone(zone)\n                    if hbZones[zoneCount].humidityMin != '':\n                        humidTrigger = True\n                \n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airloop)\n                \n                #Set the airDetails.\n                if airDetails != None:\n                    self.adjustCVAirLoop(model, airloop, airDetails)\n                else:\n                    self.addDefaultAirsideEcon(airloop, False)\n                \n                # Set the heatingDetails at the level of the electric resistance heater.\n                if heatingDetails != None:\n                    if heatingDetails.heatingAvailSched != \"ALWAYS ON\" or heatingDetails.heatingEffOrCOP != 'Default':\n                        comps = airloop.supplyComponents()\n                        hcs = airloop.supplyComponents(ops.IddObjectType(\"OS:Coil:Heating:Electric\"))\n                        hc = model.getCoilHeatingElectric(hcs[0].handle()).get()\n                        self.updateElectricHeatingCoil(model, hc, heatingDetails.heatingAvailSched, heatingDetails.heatingEffOrCOP)\n            \n            elif systemIndex == 11 or systemIndex == 12 or systemIndex == 13 or systemIndex == 14 or systemIndex == 15:\n                # Check to see if there is humidity control on any of the zones and make sure there is ventilation demand.\n                totalAirFlowRates = []\n                for zone in hbZones:\n                    if zone.humidityMax != '':\n                        dehumidTrigger = True\n                    if zone.humidityMin != '':\n                        humidTrigger = True\n                    \n                    zoneTotAir = self.getZoneTotalAir(zone)\n                    totalAirFlowRates.append(zoneTotAir)\n                \n                if coolingDetails != None and coolingDetails.chillerType != 'Default':\n                    chillType = coolingDetails.chillerType\n                else:\n                    chillType = \"WaterCooled\"\n                \n                # Create the hot water plant.\n                if heatingDetails != None and heatingDetails.supplyTemperature != 'Default':\n                    suppTemp = heatingDetails.supplyTemperature\n                else:\n                    if systemIndex == 13 or systemIndex == 14 or systemIndex == 15:\n                        suppTemp = 40\n                    elif chillType == \"GroundSourced\":\n                        suppTemp = 45\n                    else:\n                        suppTemp = 67\n                radLoop = False\n                if systemIndex == 13 or systemIndex == 14:\n                    hotLoopTemp = self.createConstantScheduleRuleset('Hot_Water_Radiant_Loop_Temperature' + str(HVACCount), 'Hot_Water_Radiant_Loop_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n                    radLoop = True\n                else:\n                    hotLoopTemp = self.createConstantScheduleRuleset('Hot_Water_Temperature' + str(HVACCount), 'Hot_Water_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n                if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat != None:\n                    hwl = centralHeat\n                else:\n                    hwl = self.createHotWaterPlant(model, hotLoopTemp, heatingDetails, HVACCount, radLoop)\n                if heatingDetails != None and heatingDetails.centralPlant == 'True' and centralHeat == None:\n                    centralHeat = hwl\n                \n                # Create the chilled water plant.\n                if coolingDetails != None and coolingDetails.supplyTemperature != 'Default':\n                    suppTemp = coolingDetails.supplyTemperature\n                else:\n                    if systemIndex == 13 or systemIndex == 14:\n                        suppTemp = 15\n                    else:\n                        suppTemp = 6.7\n                \n                if systemIndex == 13 or systemIndex == 14:\n                    coolLoopTemp = self.createConstantScheduleRuleset('Chilled_Water_Radiant_Loop_Temperature' + str(HVACCount), 'Chilled_Water_Radiant_Loop_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n                else:\n                    coolLoopTemp = self.createConstantScheduleRuleset('Chilled_Water_Temperature' + str(HVACCount), 'Chilled_Water_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', suppTemp, model)\n                \n                if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool != None:\n                    cwl = centralCool\n                else:\n                    if chillType != \"GroundSourced\":\n                        cwl = self.createChilledWaterPlant(model, coolLoopTemp, coolingDetails, HVACCount, chillType, radLoop)\n                    else:\n                        cwl = self.createChilledWaterPlant(model, coolLoopTemp, coolingDetails, HVACCount, chillType, radLoop, heatingDetails)\n                if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool == None:\n                    centralCool = cwl\n                \n                # create a condenser if necessary.\n                if chillType == \"WaterCooled\":\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool != None:\n                        cndwl = centralConden\n                    else:\n                        cndwl = self.createCondenser(model, cwl, HVACCount)\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool == None:\n                        centralConden = cndwl\n                elif chillType == \"GroundSourced\":\n                    # add a ground loop.\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool != None:\n                        cndwl = centralConden\n                    else:\n                        cndwl = self.addInfiniteCapacityGroundLoop(model, cwl, HVACCount, coolingDetails)\n                        # remove boiler and add heat pump.\n                        self.replaceBoilerWithHeatPump(model, hwl, cwl, HVACCount)\n                    if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralCool == None:\n                        centralConden = cndwl\n                \n                # Create air loop.\n                if sum(totalAirFlowRates) > 0:\n                    if systemIndex == 11:\n                        airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hwl, cwl)\n                    elif systemIndex == 12:\n                        airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hwl, cwl, None, \"ChilledBeam\")\n                    elif systemIndex == 13 or systemIndex == 14 or systemIndex == 15:\n                        if chillType != \"GroundSourced\" or systemIndex == 15 or (dehumidTrigger == True and not ((systemIndex == 13 or systemIndex == 14) and chillType == \"GroundSourced\")):\n                            hotterLoopTemp = self.createConstantScheduleRuleset('Hot_Water_Temperature' + str(HVACCount), 'Hot_Water_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', 67, model)\n                            hotwl = self.createHotWaterPlant(model, hotterLoopTemp, heatingDetails, HVACCount)\n                        if systemIndex == 13  or systemIndex == 14:\n                            if chillType != \"GroundSourced\" and dehumidTrigger == False:\n                                airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hotwl)\n                            elif chillType != \"GroundSourced\" and dehumidTrigger == True:\n                                coolerLoopTemp = self.createConstantScheduleRuleset('Chilled_Water_Temperature' + str(HVACCount), 'Chilled_Water_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', 6.7, model)\n                                coolwl = self.createChilledWaterPlant(model, coolerLoopTemp, coolingDetails, HVACCount, chillType)\n                                airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hotwl, coolwl)\n                            else:\n                                airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, None, None, cndwl, None, True)\n                        else:\n                            airLoop = self.createPrimaryAirLoop('VAV', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, hotwl, cwl)\n                    \n                    # If there is a maximum humidity assigned to the zone, set the cooling coil to dehumidify the air.\n                    if dehumidTrigger == True and not ((systemIndex == 13 or systemIndex == 14) and chillType == \"GroundSourced\"):\n                        self.addChilledWaterDehumid(model, airLoop)\n                    elif dehumidTrigger == True and (systemIndex == 13 or systemIndex == 14) and chillType == \"GroundSourced\":\n                        self.addHeatPumpCoilDehumid(model, airLoop)\n                    # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                    if humidTrigger == True:\n                        self.addElectricHumidifier(model, airLoop)\n                \n                if systemIndex == 11:\n                    # Add the fain coil units.\n                    equipList = ['FanCoil']\n                    self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, hwl, cwl)\n                elif systemIndex == 12:\n                    #Add the baseboard heating.\n                    equipList = ['Baseboard']\n                    self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, hwl, cwl)\n                elif systemIndex == 14 or systemIndex == 15:\n                    equipList = ['CustomRadiant']\n                    if systemIndex == 14:\n                        self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, hwl, cwl)\n                    elif systemIndex == 15:\n                        self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, hwl, cwl, None, True)\n                elif systemIndex == 13:\n                    #Add the radiant floors.\n                    equipList = ['RadiantFloor']\n                    self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, hwl, cwl)\n            \n            elif systemIndex == 16 or systemIndex == 17 :\n                # Check to see if there is humidity control on any of the zones.\n                for zone in hbZones:\n                    if zone.humidityMax != '':\n                        dehumidTrigger = True\n                    if zone.humidityMin != '':\n                        humidTrigger = True\n                \n                if coolingDetails == None or coolingDetails.chillerType != \"GroundSourced\":\n                    # Make a chilled water loop for the DOAS if it has been specified.\n                    cndwl = None\n                    if (coolingDetails != None and coolingDetails.chillerType != 'Default') or (coolingDetails == None and systemIndex == 17):\n                        if (coolingDetails == None and systemIndex == 17) or coolingDetails.chillerType == \"WaterCooled\":\n                            if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralConden!= None:\n                                cndwl = centralConden\n                            else:\n                                if coolingDetails != None and coolingDetails.supplyTemperature != \"Default\":\n                                    condLoopTemp = self.createConstantScheduleRuleset('Condenser_Temperature' + str(HVACCount), 'Condenser_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', float(coolingDetails.supplyTemperature), model)\n                                    coolLoopTemp = self.createConstantScheduleRuleset('Condenser_Cooling_Temperature' + str(HVACCount), 'Condenser_Cooling_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', float(coolingDetails.supplyTemperature), model)\n                                else:\n                                    condLoopTemp = self.createConstantScheduleRuleset('Condenser_Temperature' + str(HVACCount), 'Condenser_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', 30, model)\n                                    coolLoopTemp = self.createConstantScheduleRuleset('Condenser_Cooling_Temperature' + str(HVACCount), 'Condenser_Cooling_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', 30, model)\n                                if heatingDetails != None and heatingDetails.supplyTemperature != \"Default\":\n                                    heatLoopTemp = self.createConstantScheduleRuleset('Condenser_Heating_Temperature' + str(HVACCount), 'Condenser_Heating_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', float(heatingDetails.supplyTemperature), model)\n                                else:\n                                    heatLoopTemp = self.createConstantScheduleRuleset('Condenser_Heating_Temperature' + str(HVACCount), 'Condenser_Heating_Temperature_Default' + str(HVACCount), 'TEMPERATURE 1', 20, model)\n                                cndwl = self.createVRFCondenser(model, HVACCount, condLoopTemp, coolLoopTemp, heatLoopTemp)\n                                if coolingDetails != None and coolingDetails.centralPlant == 'True' and centralConden == None:\n                                    centralConden = cndwl\n                    #Make a DOAS air loop.\n                    if airDetails != None and airDetails.centralAirLoop == 'True' and centralAir != None:\n                        airLoop = self.addZoneToAirLoop(centralAir, 'DOAS', model, thermalZoneVector, hbZones, airDetails, coolingDetails, None, None)\n                    else:\n                        airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, None, None, cndwl, None, True)\n                else:\n                    # Make a ground source condenser loop.\n                    if (coolingDetails != None and coolingDetails.centralPlant == 'True') or (heatingDetails != None and heatingDetails.centralPlant == 'True'):\n                        if centralConden == None:\n                            centralConden = cndwl = self.addInfiniteCapacityGroundLoop(model, None, HVACCount, coolingDetails)\n                        else:\n                            cndwl = centralConden\n                    else:\n                        cndwl = self.addInfiniteCapacityGroundLoop(model, None, HVACCount, coolingDetails)\n                    if airDetails != None and airDetails.centralAirLoop == 'True' and centralAir != None:\n                        airLoop = self.addZoneToAirLoop(centralAir, 'DOAS', model, thermalZoneVector, hbZones, airDetails, coolingDetails, None, None)\n                    else:\n                        airLoop = self.createPrimaryAirLoop('DOAS', model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, None, None, cndwl, None, True)\n                \n                # If central air loop is specified, se tthe current air loop to the job.\n                if airDetails != None and airDetails.centralAirLoop == 'True' and centralAir == None:\n                    centralAir = airLoop\n                \n                # If there is a minimum humidity assigned to the zone, add in an electric humidifier to humidify the air.\n                if humidTrigger == True:\n                    self.addElectricHumidifier(model, airLoop)\n                # If there is a maximum humidity assigned to the zone, set the cooling coil to dehumidify the air.\n                if dehumidTrigger == True:\n                    if systemIndex == 17 or systemIndex == 18:\n                        self.addHeatPumpCoilDehumid(model, airLoop)\n                    elif systemIndex == 16 and coolingDetails != None and coolingDetails.chillerType == 'GroundSourced':\n                        self.addHeatPumpCoilDehumid(model, airLoop)\n                    else:\n                        pass\n                \n                if systemIndex == 17:\n                    equipList = ['WSHP']\n                    self.createZoneEquip(model, thermalZoneVector, hbZones, equipList, None, None, cndwl)\n                else:\n                    # Make the VRF System.\n                    self.createVRFSystem(model, thermalZoneVector, hbZones, airDetails, heatingDetails, coolingDetails, HVACCount, cndwl)\n            \n            else:\n                msg = \"HVAC system index \" + str(systemIndex) +  \" is not implemented yet!\"\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n    \n    ### END OF FUNCTION FOR ADDING HVAC SYSTEMS TO THE MODEL ###\n    \n    \n    def addThermostat(self, HBZone, OSThermalZone, space, model):\n        # create a dual set point\n        thermostat = ops.ThermostatSetpointDualSetpoint(model)\n        time24hrs = ops.Time(0,24,0,0)\n        \n        # assign schedules\n        thermostat.setName(\"dualSetPtThermostat\" + str(OSThermalZone.name()))\n        \n        heatingSetPtSchedule = self.getOSSchedule(HBZone.heatingSetPtSchedule, model)\n        coolingSetPtSchedule = self.getOSSchedule(HBZone.coolingSetPtSchedule, model)\n        \n        thermostat.setHeatingSetpointTemperatureSchedule(heatingSetPtSchedule)\n        thermostat.setCoolingSetpointTemperatureSchedule(coolingSetPtSchedule)\n        \n        OSThermalZone.setThermostatSetpointDualSetpoint(thermostat)\n    \n    def addHumidistat(self, HBZone, OSThermalZone, space, model):\n        # create a humidistat.\n        humidistat = ops.ZoneControlHumidistat(model)\n        \n        # name the humidistat\n        humidistat.setName(\"humidistat\" + str(space.name()))\n        \n        # get type limits for humidity and create them if they don't exist.\n        try:\n            humidTypeLimits = self.humidTypeLimits\n        except:\n            humidTypeLimits = self.humidTypeLimits = self.createOSScheduleTypeLimitsFromValues(model, 0, 100, 'CONTINUOUS', 'Percent')\n        \n        if HBZone.humidityMax != \"\":\n            values = [\"schedule:constant\", humidTypeLimits, float(HBZone.humidityMax)]\n            maxHumidSched = self.createConstantOSSchedule(\"maxHumidity\" + str(space.name()), values, model)\n            humidistat.setDehumidifyingRelativeHumiditySetpointSchedule(maxHumidSched)\n        else:\n            values = [\"schedule:constant\", humidTypeLimits, 100]\n            maxHumidSched = self.createConstantOSSchedule(\"maxHumidity\" + str(space.name()), values, model)\n            humidistat.setDehumidifyingRelativeHumiditySetpointSchedule(maxHumidSched)\n        \n        if HBZone.humidityMin != \"\":\n            values = [\"schedule:constant\", humidTypeLimits, float(HBZone.humidityMin)]\n            minHumidSched = self.createConstantOSSchedule(\"minHumidity\" + str(space.name()), values, model)\n            humidistat.setHumidifyingRelativeHumiditySetpointSchedule(minHumidSched)\n        else:\n            values = [\"schedule:constant\", humidTypeLimits, 0]\n            minHumidSched = self.createConstantOSSchedule(\"minHumidity\" + str(space.name()), values, model)\n            humidistat.setHumidifyingRelativeHumiditySetpointSchedule(minHumidSched)\n        \n        OSThermalZone.setZoneControlHumidistat(humidistat)\n    \n    def addDaylightCntrl(self, HBZone, OSThermalZone, space, model):\n        zoneDayLCntrl = ops.DaylightingControl(model)\n        zoneDayLCntrl.setSpace(space)\n        zoneDayLCntrl.setIlluminanceSetpoint(HBZone.illumSetPt)\n        zoneDayLCntrl.setMaximumAllowableDiscomfortGlareIndex(HBZone.GlareDiscomIndex)\n        zoneDayLCntrl.setThetaRotationAroundYAxis(-math.radians(HBZone.glareView))\n        if HBZone.illumCntrlSensorPt == None:\n            HBZone.atuoPositionDaylightSensor()\n        zoneDayLCntrl.setPositionXCoordinate(HBZone.illumCntrlSensorPt.X)\n        zoneDayLCntrl.setPositionYCoordinate(HBZone.illumCntrlSensorPt.Y)\n        zoneDayLCntrl.setPositionZCoordinate(HBZone.illumCntrlSensorPt.Z)\n        OSThermalZone.setPrimaryDaylightingControl(zoneDayLCntrl)\n        OSThermalZone.setFractionofZoneControlledbyPrimaryDaylightingControl(HBZone.daylightCntrlFract)\n    \n    def getSpaceType(self, zone, space, model):\n        # Create a unique string that contains all unique space info.\n        loadsIDstr = str(zone.equipmentLoadPerArea) + str(zone.infiltrationRatePerArea) + str(zone.lightingDensityPerArea) + \\\n            str(zone.numOfPeoplePerArea) + str(zone.ventilationPerPerson)\n        schIDstr = str(zone.occupancySchedule) + str(zone.occupancyActivitySch) + str(zone.lightingSchedule) + \\\n            str(zone.equipmentSchedule) + str(zone.infiltrationSchedule)\n        spaceIDstr = loadsIDstr + schIDstr\n        \n        # Create a new space type if there is nothing in the library with all of the right properties.\n        if spaceIDstr not in self.spaceTypeDict.keys():\n            spaceTypeName = \":\".join([zone.bldgProgram, zone.zoneProgram, zone.name])\n            spaceType = ops.SpaceType(model)\n            spaceType.setName(spaceTypeName)\n            self.spaceTypeDict[spaceIDstr] = spaceType\n        else:\n            spaceType = self.spaceTypeDict[spaceIDstr]\n        \n        return spaceType\n    \n    def setupNameAndType(self, zone, space, model):\n        space.setName('{}_space'.format(zone.name))\n        \n        spaceType = self.getSpaceType(zone, space, model)\n        space.setSpaceType(spaceType)\n        \n        return space\n    \n    def setInfiltration(self, zone, space, model):\n        spaceType = space.spaceType.get()\n        spaceName = str(spaceType.name())\n        if spaceName not in self.infiltList:\n            infiltration = ops.SpaceInfiltrationDesignFlowRate(model)\n            infiltration.setFlowperExteriorSurfaceArea(zone.infiltrationRatePerArea)\n            infiltration.setSchedule(self.getOSSchedule(zone.infiltrationSchedule, model))\n            infiltration.setSpaceType(spaceType)\n            self.infiltList.append(spaceName)\n    \n    def setAirMixing(self, zone, model):\n        # air mixing from air walls\n        targetZone = self.thermalZonesDict[zone.name]\n        for mixZoneCount, zoneMixName in enumerate(zone.mixAirZoneList):\n            zoneMixing = ops.ZoneMixing(targetZone)\n            sourceZone = self.thermalZonesDict[zoneMixName]\n            zoneMixing.setSourceZone(sourceZone)\n            zoneMixing.setDesignFlowRate(zone.mixAirFlowList[mixZoneCount])\n            zoneMixing.setSchedule(self.getOSSchedule(zone.mixAirFlowSched[mixZoneCount], model))\n    \n    def setDefaultSchedule(self, zone, space, model):\n        # Make sure that we do not have redundant schedule sets.\n        equipStr = zone.equipmentSchedule\n        if equipStr == None:\n            equipStr = ''\n        occStr = zone.occupancySchedule\n        if occStr == None:\n            occStr = ''\n        occActStr = zone.occupancyActivitySch\n        if occActStr == None:\n            occActStr = ''\n        \n        defSchStr = occStr + occActStr + zone.lightingSchedule + \\\n            equipStr + zone.infiltrationSchedule\n        \n        if defSchStr not in self.scheduleSetList.keys():\n            defSchedule = ops.DefaultScheduleSet(model)\n            defSchedule.setName(zone.name + \"_DefaultScheduleSet\")\n            defSchedule.setInfiltrationSchedule(self.getOSSchedule(zone.infiltrationSchedule, model))\n            defSchedule.setLightingSchedule(self.getOSSchedule(zone.lightingSchedule, model))\n            # Not all default zone types have people, or equipment.\n            try:\n                defSchedule.setElectricEquipmentSchedule(self.getOSSchedule(zone.equipmentSchedule, model))\n            except:\n                pass\n            try:\n                defSchedule.setHoursofOperationSchedule(self.getOSSchedule(zone.occupancySchedule, model))\n            except:\n                pass\n            try:\n                defSchedule.setPeopleActivityLevelSchedule(self.getOSSchedule(zone.occupancyActivitySch, model))\n            except:\n                pass\n            self.scheduleSetList[defSchStr] = defSchedule\n        else:\n            defSchedule = self.scheduleSetList[defSchStr]\n        \n        spaceType = space.spaceType.get()\n        spaceName = str(spaceType.name())\n        if spaceName not in self.schSetList:\n            spaceType.setDefaultScheduleSet(defSchedule)\n            self.schSetList.append(spaceName)\n        \n        return space\n    \n    def findDominantConstr(self, lst):\n        return max(set(lst), key=lst.count)\n    \n    def buildDefaultConstrSet(self, HBZones, model):\n        self.defaultConstrDict = {\n        '0':[],\n        '0.25':[],\n        '0.5': [],\n        '1': [],\n        '1.5': [],\n        '2': [],\n        '2.5': [],\n        '2.75': [],\n        '3': [],\n        '5': [],\n        '5.5': [],\n        '5.25': []\n        }\n        \n        # Pull all of the constructions out of the model.\n        for zone in HBZones:\n            for srf in zone.surfaces:\n                if srf.EPConstruction != None:\n                    constructionText = srf.EPConstruction\n                else:\n                    constructionText = srf.construction\n                \n                if srf.type == 4:\n                    self.defaultConstrDict['0.25'].append(constructionText)\n                elif srf.type == 0 and (srf.BC.lower() == 'surface' or srf.BC.lower() == 'adiabatic'):\n                    self.defaultConstrDict['0.25'].append(constructionText)\n                elif int(srf.type) == 2 and srf.BC.lower() == 'ground':\n                    self.defaultConstrDict['2.5'].append(constructionText)\n                elif int(srf.type) == 2 and (srf.BC.lower() == 'surface' or srf.BC.lower() == 'adiabatic'):\n                    self.defaultConstrDict['2'].append(constructionText)\n                elif int(srf.type) == 2 and srf.BC.lower() == 'outdoors':\n                    self.defaultConstrDict['2.75'].append(constructionText)\n                else:\n                    self.defaultConstrDict[str(srf.type)].append(constructionText)\n                \n                if srf.hasChild:\n                    for childSrf in srf.childSrfs:\n                        if childSrf.EPConstruction != None:\n                            constructionText = childSrf.EPConstruction\n                        else:\n                            constructionText = childSrf.construction\n                        \n                        if srf.BC.lower() == 'surface' or srf.BC.lower() == 'adiabatic':\n                            self.defaultConstrDict['5.5'].append(constructionText)\n                        elif srf.type == 1:\n                            self.defaultConstrDict['5.25'].append(constructionText)\n                        else:\n                            self.defaultConstrDict['5'].append(constructionText)\n        \n        # Get the most common constructions of each type in the model.\n        for key in self.defaultConstrDict.keys():\n            if self.defaultConstrDict[key] != []:\n                constrName = self.findDominantConstr(self.defaultConstrDict[key])\n                # create construction.\n                if self.isConstructionInLib(constrName):\n                    construction = self.getConstructionFromLib(constrName)\n                else:\n                    construction = self.getOSConstruction(constrName, model)\n                    self.addConstructionToLib(constrName, construction)\n                self.defaultConstrDict[key] = construction\n            else:\n                self.defaultConstrDict[key] = None\n        \n        # Make an OpenStudio construction set.\n        self.defaultConstrSet = ops.DefaultConstructionSet(model)\n        \n        # Exterior Constructions.\n        exteriorConstrs = ops.DefaultSurfaceConstructions(model)\n        if self.defaultConstrDict['0'] != None:\n            exteriorConstrs.setWallConstruction(self.defaultConstrDict['0'])\n        if self.defaultConstrDict['1'] != None:\n            exteriorConstrs.setRoofCeilingConstruction(self.defaultConstrDict['1'])\n        if self.defaultConstrDict['2.75'] != None:\n            exteriorConstrs.setFloorConstruction(self.defaultConstrDict['2.75'])\n        self.defaultConstrSet.setDefaultExteriorSurfaceConstructions(exteriorConstrs)\n        \n        # Interior Constructions.\n        interiorConstrs = ops.DefaultSurfaceConstructions(model)\n        if self.defaultConstrDict['0.25'] != None:\n            interiorConstrs.setWallConstruction(self.defaultConstrDict['0.25'])\n        if self.defaultConstrDict['3'] != None:\n            interiorConstrs.setRoofCeilingConstruction(self.defaultConstrDict['3'])\n        if self.defaultConstrDict['2'] != None:\n            interiorConstrs.setFloorConstruction(self.defaultConstrDict['2'])\n        self.defaultConstrSet.setDefaultInteriorSurfaceConstructions(interiorConstrs)\n        \n        # Ground Constructions.\n        groundConstrs = ops.DefaultSurfaceConstructions(model)\n        if self.defaultConstrDict['0.5'] != None:\n            groundConstrs.setWallConstruction(self.defaultConstrDict['0.5'])\n        if self.defaultConstrDict['1.5'] != None:\n            groundConstrs.setRoofCeilingConstruction(self.defaultConstrDict['1.5'])\n        if self.defaultConstrDict['2.5'] != None:\n            groundConstrs.setFloorConstruction(self.defaultConstrDict['2.5'])\n        self.defaultConstrSet.setDefaultGroundContactSurfaceConstructions(groundConstrs)\n        \n        # Windows.\n        extWindowConstrs = ops.DefaultSubSurfaceConstructions(model)\n        if self.defaultConstrDict['5'] != None:\n            extWindowConstrs.setFixedWindowConstruction(self.defaultConstrDict['5'])\n        if self.defaultConstrDict['5.25'] != None:\n            extWindowConstrs.setSkylightConstruction(self.defaultConstrDict['5.25'])\n        self.defaultConstrSet.setDefaultExteriorSubSurfaceConstructions(extWindowConstrs)\n        \n        intWindowConstrs = ops.DefaultSubSurfaceConstructions(model)\n        if self.defaultConstrDict['5.5'] != None:\n            intWindowConstrs.setFixedWindowConstruction(self.defaultConstrDict['5.5'])\n        self.defaultConstrSet.setDefaultInteriorSubSurfaceConstructions(intWindowConstrs)\n        \n        return self.defaultConstrSet\n    \n    def setPeopleDefinition(self, zone, space, model):\n        if zone.numOfPeoplePerArea != 0:\n            if zone.numOfPeoplePerArea not in self.peopleList.keys():\n                peopleDefinition = ops.PeopleDefinition(model)\n                peopleDefinition.setName(zone.name + \"_PeopleDefinition\")\n                flrArea = zone.getFloorArea(True)\n                peopleDefinition.setNumberOfPeopleCalculationMethod(\"People/Area\", flrArea)\n                peopleDefinition.setPeopleperSpaceFloorArea(zone.numOfPeoplePerArea)\n                self.peopleList[zone.numOfPeoplePerArea] = peopleDefinition\n            else:\n                peopleDefinition = self.peopleList[zone.numOfPeoplePerArea]\n            \n            # This was so confusing to find people and people definition as two different objects\n            spaceType = space.spaceType.get()\n            spaceName = str(spaceType.name())\n            if spaceName not in self.pplList:\n                people = ops.People(peopleDefinition)\n                people.setName(spaceName + \"_PeopleObject\")\n                people.setActivityLevelSchedule(self.getOSSchedule(zone.occupancyActivitySch, model))\n                people.setNumberofPeopleSchedule(self.getOSSchedule(zone.occupancySchedule, model))\n                people.setPeopleDefinition(peopleDefinition)\n                people.setSpaceType(spaceType)\n                self.pplList.append(spaceName)\n     \n    def setInternalMassDefinition(self, zone, space, model):\n        for srfNum,srfArea in enumerate(zone.internalMassSrfAreas):\n            if str(zone.internalMassConstructions[srfNum])+str(srfArea) not in self.internalMassList.keys():\n                # Create internal mass definition\n                internalMassDefinition = ops.InternalMassDefinition(model)\n                internalMassDefinition.setName(zone.internalMassNames[srfNum]+\"_Definition\")\n                if self.isConstructionInLib(zone.internalMassConstructions[srfNum]):\n                    construction = self.getConstructionFromLib(zone.internalMassConstructions[srfNum])\n                else:\n                    construction = self.getOSConstruction(zone.internalMassConstructions[srfNum],model)\n                    self.addConstructionToLib(zone.internalMassConstructions[srfNum], construction)\n                internalMassDefinition.setConstruction(construction)\n                internalMassDefinition.setSurfaceArea(float(srfArea))\n                self.internalMassList[str(zone.internalMassConstructions[srfNum])+str(srfArea)] = internalMassDefinition\n            else:\n                internalMassDefinition = self.internalMassList[str(zone.internalMassConstructions[srfNum])+str(srfArea)]\n            \n            # Create actual internal mass by using the definition above\n            internalMass = ops.InternalMass(internalMassDefinition)\n            internalMass.setName(zone.internalMassNames[srfNum])\n            internalMass.setSpace(space)\n    \n    def setLightingDefinition(self, zone, space, model):\n        if zone.lightingDensityPerArea != 0:\n            if zone.lightingDensityPerArea not in self.lightingList.keys():\n                lightsDefinition = ops.LightsDefinition(model)\n                lightsDefinition.setName(zone.name + \"_LightsDefinition\")\n                flrArea = zone.getFloorArea(True)\n                lightsDefinition.setDesignLevelCalculationMethod(\"Watts/Area\", flrArea, space.numberOfPeople())\n                lightsDefinition.setWattsperSpaceFloorArea(float(zone.lightingDensityPerArea))\n                self.lightingList[zone.lightingDensityPerArea] = lightsDefinition\n            else:\n                lightsDefinition = self.lightingList[zone.lightingDensityPerArea]\n            \n            spaceType = space.spaceType.get()\n            spaceName = str(spaceType.name())\n            if spaceName not in self.lightList:\n                lights = ops.Lights(lightsDefinition)\n                lights.setName(spaceName + \"_LightsObject\")\n                lights.setSchedule(self.getOSSchedule(zone.lightingSchedule, model))\n                lights.setSpaceType(spaceType)\n                self.lightList.append(spaceName)\n    \n    def setEquipmentDefinition(self, zone, space, model):\n        if zone.equipmentLoadPerArea != 0:\n            if zone.equipmentLoadPerArea not in self.equipList.keys():\n                electricDefinition = ops.ElectricEquipmentDefinition(model)\n                electricDefinition.setName(zone.name + \"_ElectricEquipmentDefinition\")\n                flrArea = zone.getFloorArea(True)\n                electricDefinition.setDesignLevelCalculationMethod(\"Watts/Area\", flrArea, space.numberOfPeople())\n                electricDefinition.setWattsperSpaceFloorArea(zone.equipmentLoadPerArea)\n                self.equipList[zone.equipmentLoadPerArea] = electricDefinition\n            else:\n                electricDefinition = self.equipList[zone.equipmentLoadPerArea]\n            \n            spaceType = space.spaceType.get()\n            spaceName = str(spaceType.name())\n            if spaceName not in self.eqList:\n                electricEqipment = ops.ElectricEquipment(electricDefinition)\n                electricEqipment.setName(zone.name + \"_ElectricEquipmentObject\")\n                electricEqipment.setSchedule(self.getOSSchedule(zone.equipmentSchedule, model))\n                electricEqipment.setEndUseSubcategory('ElectricEquipment')\n                electricEqipment.setSpaceType(spaceType)\n                self.eqList.append(spaceName)\n        \n    def setDesignSpecificationOutdoorAir(self, zone, space, model):\n        if zone.outdoorAirReq != 'None':\n            if str(zone.ventilationPerArea)+str(zone.ventilationPerPerson)+str(zone.ventilationSched) not in self.ventList.keys():\n                ventilation = ops.DesignSpecificationOutdoorAir(model)\n                ventilation.setName(zone.name + \"_DSOA\")\n                ventilation.setOutdoorAirMethod(zone.outdoorAirReq)\n                ventilation.setOutdoorAirFlowperPerson(zone.ventilationPerPerson)\n                ventilation.setOutdoorAirFlowperFloorArea(zone.ventilationPerArea)\n                if zone.ventilationSched != '':\n                    ventSch = self.getOSSchedule(zone.ventilationSched,model)\n                    ventilation.setOutdoorAirFlowRateFractionSchedule(ventSch)\n                self.ventList[str(zone.ventilationPerArea)+str(zone.ventilationPerPerson)+str(zone.ventilationSched)] = ventilation\n            else:\n                ventilation = self.ventList[str(zone.ventilationPerArea)+str(zone.ventilationPerPerson)+str(zone.ventilationSched)]\n            \n            spaceType = space.spaceType.get()\n            if spaceType.isDesignSpecificationOutdoorAirDefaulted() == True:\n                spaceType.setDesignSpecificationOutdoorAir(ventilation)\n            \n        return space\n        \n        \n    def setGenerators(self,generators,simulationOutputs,model):\n        \n        def checks(HBsystemgenerators):\n            \n            # CHECK that HBgenerator names are unique for each HB generator\n            HBgenerators = []\n            for HBgenerator in HBsystemgenerators:\n                HBgenerators.extend([generator.name for generator in HBgenerator.windgenerators])\n                HBgenerators.extend([generator.name for generator in HBgenerator.PVgenerators])\n            if len(HBgenerators) != len(set(HBgenerators)):\n                duplicateHBgenerators =  [item for item, count in collections.Counter([item for item in HBgenerators]).items() if count > 1]\n                for HBgenerator in duplicateHBgenerators:\n                    warn = \" Duplicate Honeybee generator (A PV or wind generator) name, named : \" + HBgenerator +\" detected!\"+ \"\\n\"+\\\n                    \"Please ensure that all PV and wind generators have unique names for EnergyPlus to run!\"+ \"\\n\"+\\\n                    \"This error usually occurs when several PVgen components are connected to one EnergyPlus simulation, and default names \" + \"\\n\"+\\\n                    \"have been assigned in each component. Fix this issue by inputing unique names to the input _name_ on the PVgen component.\"\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warn )\n                return -1\n            \n            # CHECK that the HBsystemgenerator_name is unique for this simulation - Otherwise E+ will crash\n            if len(set([HBsystemgenerator.name for HBsystemgenerator in HBsystemgenerators])) != len(HBsystemgenerators):\n                duplicateHBsystemgenerators = [HBsystemgenerator for HBsystemgenerator, count in collections.Counter([HBsystemgenerator.name for HBsystemgenerator in HBsystemgenerators]).items() if count > 1]\n                for HBsystemgenerator in duplicateHBsystemgenerators:\n                    warn = \" Duplicate Honeybee generation system name, named: \" + HBsystemgenerator +\" detected!\"+ \"\\n\"+\\\n                    \"Please ensure that all Honeybee generation systems have unique names for EnergyPlus to run!\"\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warn )\n                return -1\n                \n        hb_hivegen = sc.sticky[\"honeybee_generationHive\"]()\n\n        HBsystemgenerators = hb_hivegen.callFromHoneybeeHive(generators)\n        # Generation objects use \"always on\" schedule\n        #EPScheduleCollection.append('ALWAYS ON')\n        \n        checks(HBsystemgenerators)\n        \n        # This code here is used to extractingruntime periods if outputs are specified externally\n        # If the function returns and exception that means that external outputs are not specified.\n        # and teh default below will be used.\n        timePeriods = ['hourly', 'daily', 'monthly', 'annual']\n        def extracttimeperiod(simulationOutputs):\n            try:\n                for output in simulationOutputs:\n                    endWord = output.split(',')[-1].strip().replace(\";\",\"\")\n                    if endWord in timePeriods:\n                        HBgeneratortimeperiod = endWord\n                return HBgeneratortimeperiod\n            except:\n                # By default return hourly if no simulation outputs are returned\n                return 'hourly'\n        \n        # Extract the timestep from the incoming component simulationOutputs if its being used\n        HBgeneratortimeperiod = extracttimeperiod(simulationOutputs)\n        HBgeneratoroutputs = []\n        \n        # 1. Ensure the correct simulation outputs for the electric generators\n        if simulationOutputs == []:\n            HBgeneratoroutputs.append(\"Output:Variable,*,Facility Net Purchased Electric Energy, hourly;\")\n            HBgeneratoroutputs.append(\"Output:Variable,*,Facility Total Electric Demand Power, hourly;\")\n        \n        # 2. Add default PV outputs\n        HBgeneratoroutputs.append(\"outputcontrol:table:style,*,Photovoltaic:ElectricityProduced, monthly;\")\n        HBgeneratoroutputs.append(\"output:meter,*,Photovoltaic:ElectricityProduced, runperiod;\")\n        \n        if simulationOutputs != []:\n            if (not any('Output:Variable,*,Facility Total Electric Demand Power' in s for s in simulationOutputs)) and (not any('Output:Variable,*,Facility Net Purchased Electric Power' in s for s in simulationOutputs)):\n                # These are the default inputs if the user does not specify their own using the component\n                # simulationOutputs, the default timestep is therefore hourly \n                # the component Ladybug monthly bar chart needs hourly in order to run\n                HBgeneratoroutputs.append(\"Output:Variable,*,Facility Net Purchased Electric Energy, hourly;\")\n                HBgeneratoroutputs.append(\"Output:Variable,*,Facility Total Electric Demand Power, hourly;\")\n\n        # 3. Ensure the correct simulation outputs for each electric generator\n        for HBsystemcount, HBsystemgenerator in enumerate(HBsystemgenerators):\n            \n            # Define the name for the list of generators and to use in generator's list name in ElectricLoadCenter:Distribution\n            if HBsystemgenerator.name == None:\n                # This shouldn't happen as Honeybee generation system has a check on it \n                # which doesnt allow for no names to be specified.\n                HBsystemgenerator_name = \"generatorsystem\" + str(HBsystemcount)\n            else:\n                HBsystemgenerator_name = str(HBsystemgenerator.name)\n            \n            \n            self.generatorCosts.append('Honeybee system generator '+str(HBsystemgenerator.name))\n            # Add the Honeybee generation systems' annual operation and maintenance costs\n            self.generatorCosts.append('Honeybee system annual maintenance cost - '+str(HBsystemgenerator.maintenance_cost))\n            \n            # For this HBsystemgenerator write the output so that the produced electric energy is reported.\n            HBgeneratoroutputs.append(\"Output:Variable,*,Electric Load Center Produced Electric Energy,\"+ HBgeneratortimeperiod +\";\")\n            \n            # Determine whether it is a PV, Wind or fuel generator system\n            if HBsystemgenerator.PVgenerators != []:\n                    \n                for surface in HBsystemgenerator.HBzonesurfaces:\n                    if not surface.name in [surface.name().get() for surface in model.getSurfaces()]:\n                        warn  = \"It has been detected that there are PV generators attached to sufaces of a Honeybee zone\\n\"+\\\n                        \" However this Honeybee zone has not been connected to the _HBZones input on this component\\n\"+\\\n                        \" Please connect it to run the EnergyPlus simulation!\"\n                        print warn \n                        ghenv.Component.AddRuntimeMessage(w, warn)\n                        return -1\n                        \n                if HBsystemgenerator.simulationinverter != None:\n                    \n                    # HBsystem contains a inverter and is a DC system there are NO batteries in the system\n\n                    inverterobject = HBsystemgenerator.simulationinverter[0] # All inverters are the same doesnt matter which one you pick\n                    \n                    # Write HBsystemgenerator inverters\n                    \n                    inverter = ops.ElectricLoadCenterInverterSimple(model)\n                    inverter.setInverterEfficiency(inverterobject.efficiency)\n                    \n                    # Write HBsystemgenerator ElectricLoadCenter:Distribution\n                    elcd = ops.ElectricLoadCenterDistribution(model)\n                    elcd.setInverter(inverter)\n                    elcd.setName('PVgenerators:Distributionsystem')\n                    \n                    self.generatorCosts.append('Inverter cost - '+ str(HBsystemgenerator.simulationinverter[0].cost_)+ ' replacement time = '+ str(HBsystemgenerator.simulationinverter[0].replacementtime)+ ' years') \n                    \n                    # Write HBsystemgenerator photovoltaic generators\n                    for PVgen in HBsystemgenerator.PVgenerators:\n                        try:\n                            # Get the panel's surface by name from the openstudio model\n                            # model.getSurfaces is only zone surfaces\n                            panel_surface = None\n                            for opssurface in model.getSurfaces():\n                                if str(opssurface.name().get()) == str(PVgen.mountedSurface.name):\n                                    panel_surface = opssurface\n                            \n                            if panel_surface == None:\n                                # Happens when the mounted surface is not in the zone surfaces\n                                raise UnboundLocalError(\"Local variable 'panel_surface' referenced before assignment.\")\n                            \n                            # Add the pv generator to the openstudio model\n                            pvgenerator = ops.GeneratorPhotovoltaic.simple(model)\n                            pvgenerator.setName(PVgen.name)\n                            pvgenerator.setNumberOfModulesInParallel(PVgen.NOparallel)\n                            pvgenerator.setNumberOfModulesInSeries(PVgen.NOseries)\n                            pvgenerator.setSurface(panel_surface)\n                            pv_perform = pvgenerator.photovoltaicPerformance()\n                            pv_perform.setString(2, str(PVgen.surfaceareacells))\n                            pv_perform.setString(4, str(PVgen.efficiency))\n                            elcd.addGenerator(pvgenerator)\n                            \n                            self.generatorCosts.append('PVgenerator cost - '+str(PVgen.cost_)) # - Does the class PV_gen need an ID?\n                            \n                        except UnboundLocalError as e:\n                            # mounted surface is not in model.getSurfaces so so PV generator is mounted on context surface\n\n                            if str(e) != \"Local variable 'panel_surface' referenced before assignment.\":\n                                # Some other error\n                                raise \n                            else:\n                                \n                                # https://stackoverflow.com/questions/16001959/how-can-you-execute-a-command-at-the-end-of-a-for-loop\n                                \n                                assigned = False\n                                \n                                def assignMountingSurface(PVgen,model):\n                                    for shadingSurface in model.getShadingSurfaces():\n                                        \n                                        def coordinatesOfMountedSurface(PVgen):\n                                        \n                                            coordinates = PVgen.mountedSurface.extractPoints(1, False, None, 'UpperLeftCorner')\n                                            if type(coordinates[0])is not list and type(coordinates[0]) is not tuple:\n                                                coordinates = [coordinates]\n                                            \n                                            # generate OpenStudio points\n                                            shdPointVectors = ops.Point3dVector()\n                                            \n                                            for shadingCount, ptList in enumerate(coordinates):\n                                                for pt in ptList:\n                                                    # add the points to an openStudio list\n                                                    shdPointVectors.Add(ops.Point3d(round(pt.X, 3), round(pt.Y, 3), round(pt.Z, 3)))\n                                                    \n                                            return shdPointVectors\n                                                    \n                                        def toPythonArray(shdsrfvert):\n                                            # for some reason the equals in OpenStudio arrays dont compare\n                                            # for this reason extract out all the points for a comparision\n                                            allPoints = []\n                                            \n                                            for point in shdsrfvert:\n                                                allPoints.append([round(point.x(),3), round(point.y(), 3), round(point.z(),3)])\n                                                \n                                            return allPoints\n                                        \n                                        shdPointVectors = coordinatesOfMountedSurface(PVgen)\n                                        if toPythonArray(shdPointVectors) == toPythonArray(shadingSurface.vertices()):\n                                            # If coordinates of Mounted Surface and Context Surface are the same - they are the same surface so mount the surface there\n                                            pvgenerator = ops.GeneratorPhotovoltaic.simple(model)\n                                            pvgenerator.setName(PVgen.name)\n                                            pvgenerator.setNumberOfModulesInParallel(PVgen.NOparallel)\n                                            pvgenerator.setNumberOfModulesInSeries(PVgen.NOseries)\n                                            pvgenerator.setSurface(shadingSurface)\n                                            pv_perform = pvgenerator.photovoltaicPerformance()\n                                            pv_perform.setString(2, str(PVgen.surfaceareacells))\n                                            pv_perform.setString(4, str(PVgen.efficiency))\n                                            elcd.addGenerator(pvgenerator)\n                                            return True\n                                    return False\n                                \n                                assigned = assignMountingSurface(PVgen,model)\n                                \n                                if not assigned:\n                                    # Shading surface is not in the model yet! So it wasn't connected to HBContext_\n                                    # Add it! - copied the code from the function OPSShdSurface - but we didnt need all the function\n\n                                    # Shading Group\n                                    shadingGroup = ops.ShadingSurfaceGroup(model)\n            \n                                    coordinates = PVgen.mountedSurface.extractPoints(1, False, None, 'UpperLeftCorner')\n                                    if type(coordinates[0])is not list and type(coordinates[0]) is not tuple:\n                                        coordinates = [coordinates]\n                                    \n                                    shadingSch = \"\"\n                                    schedule = PVgen.mountedSurface.TransmittanceSCH\n                                    if schedule!=\"\":\n                                        # transmittance schedule\n                                        shadingSch = self.getOSSchedule(schedule, model)\n                                    \n                                    # generate OpenStudio points\n                                    shdPointVectors = ops.Point3dVector();\n                                    \n                                    # surfaceCount is the number of shading surfaces already in the model\n                                    surfaceCount = model.getShadingSurfaces().Count\n                                    \n                                    for shadingCount, ptList in enumerate(coordinates):\n                                        for pt in ptList:\n                                            # add the points to an openStudio list\n                                            shdPointVectors.Add(ops.Point3d(pt.X,pt.Y,pt.Z))\n                                        \n                                        shdSurface = ops.ShadingSurface(shdPointVectors, model)\n                                        shdSurface.setName(\"shdSurface_\" + str(surfaceCount) + \"_\" + str(shadingCount))\n                                        shdSurface.setShadingSurfaceGroup(shadingGroup)\n\n                                        if shadingSch!=\"\": shdSurface.setTransmittanceSchedule(shadingSch)\n                                            \n                                    # Finally add the PV generator\n                                    \n                                    assignMountingSurface(PVgen,model)\n                                    \n                                                                    \n                    if HBsystemgenerator.battery != None:\n                        # XXX No implemented yet\n                        elecstorageobject = HBsystemgenerator.battery\n                        battery = ops.ElectricalStorage(model)\n                        # Write HBsystemgenerator battery\n                        \n                        battery = ops.ElectricLoadCenter_Storage.simple(model)\n                        \n\n            elif HBsystemgenerator.windgenerators != []:\n                operationscheme = 'Baseload'\n                busstype = 'AlternatingCurrent'\n                demandlimit = ''\n                trackschedule = 'Always On'\n                trackmeterschedule = ''\n                inverterobject = None\n                elecstorageobject = None\n                \n                # Write HBsystemgenerator wind generators\n                for windgenerator in HBsystemgenerator.windgenerators:\n                    idfFile.write(hb_writeIDF.wind_generator(windgenerator))\n                    WriteIDF.financialdata.append('Wind turbine cost - '+str(windgenerator.cost_)) \n                # Write HBsystemgenerator ElectricLoadCenter:Distribution\n                idfFile.write(hb_writeIDF.writeloadcenterdistribution(distribution_name,HBsystemgenerator_name,operationscheme,demandlimit,trackschedule,trackmeterschedule,busstype,inverterobject,elecstorageobject))\n            \n            elif HBsystemgenerator.fuelgenerators != []: # XXX 14/04/2015 not yet implemented so always equal to []\n                pass\n            \n            \n        # Write the outputs required for HB generators to the model\n        \n        self.setOutputs(HBgeneratoroutputs, model)\n    \n    def writegeneration_system_financialdata(self,financialdata):\n        \"\"\"This function takes the financial data and writes it to the IDF in such a way so that the\n        Honeybee_Read_generation_system_results can read it this is why the list is called newfinancialdata\"\"\"\n        newfinancialdata = []\n        newfinancialdata.append('\\n')\n        newfinancialdata.append('!########## Facility generation system financial data ##########'+ '\\n')\n        newfinancialdata.append('\\n')\n        newfinancialdata.append('!!!!Y Honeybee generation system financial data'+'\\n')\n        \n        for dataitem in financialdata:\n            if dataitem.find('Honeybee system generator ') != -1:\n                newfinancialdata.append('!!!X Honeybee generation system name - ' + str(dataitem.replace('Honeybee system generator ',''))+'\\n')\n            else:\n                newfinancialdata.append('!!!Z '+str(dataitem)+'\\n')\n        newfinancialdata.append('\\n')\n        \n        return newfinancialdata\n    \n    def createOSStanadardOpaqueMaterial(self, HBMaterialName, values, model):\n        # values = ['Roughness', 'Thickness {m}', 'Conductivity {W/m-K}', 'Density {kg/m3}', 'Specific Heat {J/kg-K}', 'Thermal Absorptance', 'Solar Absorptance', 'Visible Absorptance']\n        material = ops.StandardOpaqueMaterial(model)\n        material.setName(HBMaterialName)\n        roughness = values[0]\n        \n        material.setRoughness(roughness)\n        if values[1] != '':\n            material.setThickness(float(values[1]))\n        if values[2] != '':\n            material.setConductivity(float(values[2]))\n        if values[3] != '':\n            material.setDensity(float(values[3]))\n        if values[4] != '':\n            material.setSpecificHeat(float(values[4]))\n        if len(values) > 6 and values[5] != '':\n            material.setThermalAbsorptance(float(values[5]))\n        if len(values) > 7 and values[6] != '':\n            material.setSolarAbsorptance(float(values[6]))\n        if len(values) > 8 and values[7] != '':\n            material.setVisibleAbsorptance(float(values[7]))\n        \n        return material\n    \n    def createOSSimpleGlazingMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:SimpleGlazingSystem\n        ['Material Type', 'U-Factor {W/m2-K}',\n        'Solar Heat Gain Coefficient',\n        'Visible Transmittance']\n        \"\"\"\n        simpleGlazing = ops.SimpleGlazing(model)\n        simpleGlazing.setName(HBMaterialName)\n        uFactor, SHGC, TVis = map(float, values)\n        simpleGlazing.setUFactor(uFactor)\n        simpleGlazing.setSolarHeatGainCoefficient(SHGC)\n        simpleGlazing.setVisibleTransmittance(TVis)\n        \n        return simpleGlazing\n    \n    def createOSStandardGlazingMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:Glazing\n        ['Optical Data Type', 'Window Glass Spectral Data Set Name', 'Thickness {m}',\n        'Solar Transmittance at Normal Incidence', 'Front Side Solar Reflectance at Normal Incidence',\n        'Back Side Solar Reflectance at Normal Incidence', 'Visible Transmittance at Normal Incidence',\n        'Front Side Visible Reflectance at Normal Incidence', 'Back Side Visible Reflectance at Normal Incidence',\n        'Infrared Transmittance at Normal Incidence', 'Front Side Infrared Hemispherical Emissivity',\n        'Back Side Infrared Hemispherical Emissivity', 'Conductivity {W/m-K}',\n        'Dirt Correction Factor for Solar and Visible Transmittance', 'Solar Diffusing']\n        \"\"\"\n        standardGlazing = ops.StandardGlazing(model)\n        standardGlazing.setName(HBMaterialName)\n        standardGlazing.setOpticalDataType(values[0])\n        standardGlazing.setThickness(float(values[2]))\n        try:\n            # Glass material is defined by average values of transmittance and reflectance.\n            standardGlazing.setSolarTransmittanceatNormalIncidence(float(values[3]))\n            standardGlazing.setFrontSideSolarReflectanceatNormalIncidence(float(values[4]))\n            standardGlazing.setBackSideSolarReflectanceatNormalIncidence(float(values[5]))\n            standardGlazing.setVisibleTransmittanceatNormalIncidence(float(values[6]))\n            standardGlazing.setFrontSideVisibleReflectanceatNormalIncidence(float(values[7]))\n            standardGlazing.setBackSideVisibleReflectanceatNormalIncidence(float(values[8]))\n        except:\n            # Glass material is defined by detailed spectral data.\n            self.windowSpectralDatasets[HBMaterialName] = values[1]\n            # Ah, OpenStudio. You put this in your SDK but don't wirte it into the IDF.\n            # I'll leave it here until you support it.\n            standardGlazing.setWindowGlassSpectralDataSetName(values[1])\n        \n        standardGlazing.setInfraredTransmittanceatNormalIncidence(float(values[9]))\n        standardGlazing.setFrontSideInfraredHemisphericalEmissivity(float(values[10]))\n        standardGlazing.setBackSideInfraredHemisphericalEmissivity(float(values[11]))\n        standardGlazing.setConductivity(float(values[12]))\n        try: standardGlazing.setDirtCorrectionFactorforSolarandVisibleTransmittance(float(values[13]))\n        except: pass\n        \n        return standardGlazing\n    \n    def createOSNoMassMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        Material:NoMass\n        ['Roughness', 'Thermal Resistance {m2-K/W}', 'Thermal Absorptance', 'Solar Absorptance', 'Visible Absorptance']\n        \"\"\"\n        nomassMaterial = ops.MasslessOpaqueMaterial(model)\n        nomassMaterial.setName(HBMaterialName)\n        \n        roughness = values[0]\n        thermalResistance = values[1]\n        nomassMaterial.setRoughness(roughness)\n        nomassMaterial.setThermalResistance(float(thermalResistance))\n        \n        if len(values) == 5:\n            thermalAbsorptance, solarAbsorptance, visibleAbsorptance = map(float, values[2:])\n            nomassMaterial.setThermalAbsorptance(thermalAbsorptance)\n            nomassMaterial.setSolarAbsorptance(solarAbsorptance)\n            nomassMaterial.setVisibleAbsorptance(visibleAbsorptance)\n        \n        return nomassMaterial\n    \n    def createOSVegetationMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        Material:NoMass\n        ['Height of Plants {m}', 'Leaf Area Index {dimensionless}', 'Leaf Reflectivity {dimensionless}', 'Leaf Emissivity', 'Minimum Stomatal Resistance {s/m}', 'Soil Layer Name', 'Roughness', 'Thickness {m}', 'Conductivity of Dry Soil {W/m-K}', 'Density of Dry Soil {kg/m3}', 'Specific Heat of Dry Soil {J/kg-K}', 'Thermal Absorptance', 'Solar Absorptance', 'Visible Absorptance', 'Saturation Volumetric Moisture Content of the Soil Layer', 'Residual Volumetric Moisture Content of the Soil Layer', 'Initial Volumetric Moisture Content of the Soil Layer', 'Moisture Diffusion Calculation Method']\n        \"\"\"\n        vegMaterial = ops.RoofVegetation(model)\n        vegMaterial.setName(HBMaterialName)\n        \n        plantHeight = values[0]\n        lai = float(values[1])\n        lf = float(values[2])\n        le = float(values[3])\n        stomatalResis = float(values[4])\n        soilLayer = values[5]\n        roughness = values[6]\n        thickness = float(values[7])\n        conductivity = float(values[8])\n        density = float(values[9])\n        thermalAbsorptance = float(values[10])\n        solarAbsorptance = float(values[11])\n        visibleAbsorptance = float(values[12])\n        saturationVolumetricMoisture = float(values[13])\n        residualVolumetricMoisture = float(values[14])\n        initialVolumetricMoisture = float(values[15])\n        moistureDiffusionMethod = values[16]\n        \n        vegMaterial.setString(2, plantHeight)\n        vegMaterial.setLeafAreaIndex(lai)\n        vegMaterial.setLeafReflectivity(lf)\n        vegMaterial.setLeafEmissivity(le)\n        vegMaterial.setMinimumStomatalResistance(stomatalResis)\n        vegMaterial.setSoilLayerName(soilLayer)\n        vegMaterial.setRoughness(roughness)\n        vegMaterial.setThickness(thickness)\n        vegMaterial.setConductivityofDrySoil(conductivity)\n        vegMaterial.setDensityofDrySoil(density)\n        vegMaterial.setThermalAbsorptance(thermalAbsorptance)\n        vegMaterial.setSolarAbsorptance(solarAbsorptance)\n        vegMaterial.setVisibleAbsorptance(visibleAbsorptance)\n        vegMaterial.setSaturationVolumetricMoistureContentoftheSoilLayer(saturationVolumetricMoisture)\n        vegMaterial.setResidualVolumetricMoistureContentoftheSoilLayer(residualVolumetricMoisture)\n        vegMaterial.setInitialVolumetricMoistureContentoftheSoilLayer(initialVolumetricMoisture)\n        vegMaterial.setMoistureDiffusionCalculationMethod(moistureDiffusionMethod)\n        \n        return vegMaterial\n    \n    def createOSWindowGasMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:Gas\n        ['Gas Type', 'Thickness {m}']\n        \"\"\"\n        windowGasMaterial = ops.Gas(model)\n        windowGasMaterial.setName(HBMaterialName)\n        windowGasMaterial.setGasType(values[0])\n        windowGasMaterial.setThickness(float(values[1]))\n        \n        return windowGasMaterial\n    \n    def createOSWindowGasMixtureMaterial(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:Gas\n        ['Thickness {m}', 'Number of Gases', 'Gas 1 Type', 'Gas 1 Fraction', 'Gas 2 Type', 'Gas 2 Fraction']\n        \"\"\"\n        windowGasMixMaterial = ops.GasMixture(model)\n        windowGasMixMaterial.setName(HBMaterialName)\n        windowGasMixMaterial.setThickness(float(values[0]))\n        numOfGas = int(values[1])\n        windowGasMixMaterial.setNumberofGasesinMixture(numOfGas)\n        windowGasMixMaterial.setGas1Type(values[2])\n        windowGasMixMaterial.setGas1Fraction(float(values[3]))\n        windowGasMixMaterial.setGas2Type(values[4])\n        windowGasMixMaterial.setGas2Fraction(float(values[5]))\n        if numOfGas > 2:\n            windowGasMixMaterial.setGas3Type(values[6])\n            windowGasMixMaterial.setGas3Fraction(float(values[7]))\n        if numOfGas > 3:\n            windowGasMixMaterial.setGas4Type(values[8])\n            windowGasMixMaterial.setGas4Fraction(float(values[9]))\n        \n        return windowGasMixMaterial\n    \n    def createOSAirGap(self, HBMaterialName, values, model):\n        \"\"\"\n        Material:AirGap\n        ['Thermal Resistance {m2-K/W}']\n        \"\"\"\n        airGap = ops.AirGap(model, float(values[0]))\n        return airGap\n    \n    def createOSBlind(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:Blind\n        [Slat Orientation, Slat Width {m}, Slat Separation {m}, Slat Thickness {m}, Slat Angle {deg}, Slat Conductivity {W/m-K},\n        Slat Beam Solar Transmittance, Front Side Slat Beam Solar Reflectance, Back Side Slat Beam Solar Reflectance,\n        Slat Diffuse Solar Transmittance, Front Side Slat Diffuse Solar Reflectance, Back Side Slat Diffuse Solar Reflectance,\n        Slat Beam Visible Transmittance, Front Side Slat Beam Visible Reflectance, Back Side Slat Beam Visible Reflectance,\n        Slat Diffuse Visible Transmittance, Front Side Slat Diffuse Visible Reflectance, Back Side Slat Diffuse Visible Reflectance,\n        Slat Infrared Hemispherical Transmittance, Front Side Slat Infrared Hemispherical Emissivity, Back Side Slat Infrared Hemispherical Emissivity,\n        Blind to Glass Distance {m}, Blind Top Opening Multiplier, Blind Bottom Opening Multiplier, Blind Left Side Opening Multiplier\n        Blind Right Side Opening Multiplier, Minimum Slat Angle {deg}, Maximum Slat Angle {deg}]\n        \n        \"\"\"\n        windowBlindMaterial = ops.Blind(model)\n        windowBlindMaterial.setName(HBMaterialName)\n        windowBlindMaterial.setSlatOrientation(values[0])\n        windowBlindMaterial.setSlatWidth(float(values[1]))\n        windowBlindMaterial.setSlatSeparation(float(values[2]))\n        windowBlindMaterial.setSlatThickness(float(values[3]))\n        windowBlindMaterial.setSlatAngle(float(values[4]))\n        windowBlindMaterial.setSlatConductivity(float(values[5]))\n        windowBlindMaterial.setSlatBeamSolarTransmittance(float(values[6]))\n        windowBlindMaterial.setFrontSideSlatBeamSolarReflectance(float(values[7]))\n        windowBlindMaterial.setBackSideSlatBeamSolarReflectance(float(values[8]))\n        windowBlindMaterial.setSlatDiffuseSolarTransmittance(float(values[9]))\n        windowBlindMaterial.setFrontSideSlatDiffuseSolarReflectance(float(values[10]))\n        windowBlindMaterial.setBackSideSlatDiffuseSolarReflectance(float(values[11]))\n        windowBlindMaterial.setSlatBeamVisibleTransmittance(float(values[12]))\n        windowBlindMaterial.setSlatDiffuseVisibleTransmittance(float(values[15]))\n        windowBlindMaterial.setFrontSideSlatBeamVisibleReflectance(float(values[7]))\n        windowBlindMaterial.setBackSideSlatBeamVisibleReflectance(float(values[7]))\n        windowBlindMaterial.setFrontSideSlatDiffuseVisibleReflectance(float(values[7]))\n        windowBlindMaterial.setBackSideSlatDiffuseVisibleReflectance(float(values[7]))\n        windowBlindMaterial.setFrontSideSlatInfraredHemisphericalEmissivity(float(values[19]))\n        windowBlindMaterial.setBackSideSlatInfraredHemisphericalEmissivity(float(values[20]))\n        windowBlindMaterial.setBlindtoGlassDistance(float(values[21]))\n        windowBlindMaterial.setBlindTopOpeningMultiplier(float(values[22]))\n        windowBlindMaterial.setBlindBottomOpeningMultiplier(float(values[23]))\n        windowBlindMaterial.setBlindLeftSideOpeningMultiplier(float(values[24]))\n        windowBlindMaterial.setBlindRightSideOpeningMultiplier(float(values[25]))\n        windowBlindMaterial.setMaximumSlatAngle(float(values[27]))\n        \n        return windowBlindMaterial\n    \n    def createOSShade(self, HBMaterialName, values, model):\n        \"\"\"\n        WindowMaterial:Shade\n        [Solar Transmittance, Solar Reflectance, Visible Transmittance, Visible Reflectance, \n        Infrared Hemispherical Emissivity, Infrared Transmittance, Thickness {m},Conductivity {W/m-K},\n        Shade to Glass Distance {m}, Top Opening Multiplier, ottom Opening Multiplier, Left Side Opening Multiplier,\n        Right Side Opening Multiplier, Airflow Permeability]\n        \n        \"\"\"\n        windowShadeMaterial = ops.Shade(model)\n        windowShadeMaterial.setName(HBMaterialName)\n        \n        windowShadeMaterial.setSolarTransmittance(float(values[0]))\n        windowShadeMaterial.setSolarReflectance(float(values[1]))\n        windowShadeMaterial.setVisibleTransmittance(float(values[2]))\n        windowShadeMaterial.setVisibleReflectance(float(values[3]))\n        windowShadeMaterial.setThermalHemisphericalEmissivity(float(values[4]))\n        windowShadeMaterial.setThermalTransmittance(float(values[5]))\n        windowShadeMaterial.setThickness(float(values[6]))\n        windowShadeMaterial.setConductivity(float(values[7]))\n        windowShadeMaterial.setShadetoGlassDistance(float(values[8]))\n        windowShadeMaterial.setTopOpeningMultiplier(float(values[9]))\n        windowShadeMaterial.setBottomOpeningMultiplier(float(values[10]))\n        windowShadeMaterial.setLeftSideOpeningMultiplier(float(values[11]))\n        windowShadeMaterial.setRightSideOpeningMultiplier(float(values[12]))\n        windowShadeMaterial.setAirflowPermeability(float(values[13]))\n        \n        return windowShadeMaterial\n    \n    def getOSMaterial(self, HBMaterialName, model):\n        values, comments, UVSI, UVIP = self.hb_EPMaterialAUX.decomposeMaterial(HBMaterialName, ghenv.Component)\n        \n        if values[0].lower() == \"material\":\n            # standard opaque material\n            return self.createOSStanadardOpaqueMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:simpleglazingsystem\":\n            return self.createOSSimpleGlazingMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:glazing\":\n            return self.createOSStandardGlazingMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:gas\":\n            return self.createOSWindowGasMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:gasmixture\":\n            return self.createOSWindowGasMixtureMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"material:nomass\":\n            return self.createOSNoMassMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"material:roofvegetation\":\n            return self.createOSVegetationMaterial(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"material:airgap\":\n            return self.createOSAirGap(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:blind\":\n            return self.createOSBlind(HBMaterialName, values[1:], model)\n        \n        elif values[0].lower() == \"windowmaterial:shade\":\n            return self.createOSShade(HBMaterialName, values[1:], model)\n        \n        else:\n            warning =  \"The material type \" + values[0] + \" hasn't been implemented yet!\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        \n    def getOSConstruction(self, HBConstructionlName, model):\n        # call the layers form HB library\n        materialNames, comments, UVSI, UVIP = self.hb_EPMaterialAUX.decomposeEPCnstr(HBConstructionlName)\n        \n        # create an empty vector to collect the materials\n        materials = ops.MaterialVector()\n        \n        for materialName in materialNames:\n            # check if the material has been already produced\n            if not self.isMaterialInLib(materialName):\n                # create an openstudio material for EP material\n                OSMaterial = self.getOSMaterial(materialName, model)\n                # keep track of materials\n                self.addMaterialToLib(materialName, OSMaterial)\n            else:\n                # material has been already created so let's just use it\n                OSMaterial = self.getMaterialFromLib(materialName)\n            \n            # add it as a layer\n            materials.Add(OSMaterial)\n    \n        construction = ops.Construction(model)\n        construction.setName(HBConstructionlName)\n        construction.setLayers(materials)\n    \n        return construction\n    \n    @staticmethod\n    def checkCoordinates(coordinates):\n        # check if coordinates are so close or duplicated\n        # this is a place holder for now I just return true\n        #return True, glzCoordinates\n    \n        def isDuplicate(pt, newPts):\n            for p in newPts:\n                if pt.DistanceTo(p) < 2 * sc.doc.ModelAbsoluteTolerance:\n                    return True\n            return False\n            \n        newCoordinates = [coordinates[0]]\n        for pt in coordinates[1:]:\n            if not isDuplicate(pt, newCoordinates):\n                newCoordinates.append(pt)\n            \n        if len(newCoordinates) > 2:\n            return True, newCoordinates\n        else:\n            print \"One of the surfaces has less than 3 identical coordinates and is removed.\"\n            return False,[]\n    \n    def opsZoneSurface (self, surface, model, space):\n        # collect Honeybee surfaces for nonplanar cases\n        # this is just for OpenStudio and not energyplus\n        coordinates = surface.coordinates\n        checked, coordinates= self.checkCoordinates(coordinates)\n        \n        if int(surface.type) == 4: surface.type = 0\n        \n        if checked:\n            # generate OpenStudio points\n            pointVectors = ops.Point3dVector();\n            for pt in coordinates:\n                # add the points to an openStudio list\n                pointVectors.Add(ops.Point3d(pt.X,pt.Y,pt.Z))\n            \n            # create surface\n            thisSurface = ops.Surface(pointVectors, model);\n            thisSurface.setName(surface.name);\n            thisSurface.setNumberofVertices(len(coordinates));\n            thisSurface.setSpace(space);\n            thisSurface.setSurfaceType(surface.srfType[surface.type]);\n            srfType = surface.srfType[int(surface.type)].lower().capitalize()\n            if srfType.upper().Contains(\"ROOF\") or srfType.upper().Contains(\"CEILING\"):\n                srfType = \"RoofCeiling\" # This is an OpenStudio type that will be converted as a roof or ceiling in idf file\n            \n            thisSurface.setSurfaceType(srfType);\n            \n            # create constructions if it's not in the default set.\n            if surface.EPConstruction != None:\n                if surface.type == 4:\n                    constructionText = str(self.defaultConstrDict['0.25'].name())\n                elif surface.type == 0 and (surface.BC.lower() == 'surface' or surface.BC.lower() == 'adiabatic'):\n                    constructionText = str(self.defaultConstrDict['0.25'].name())\n                elif int(surface.type) == 2 and surface.BC.lower() == 'ground':\n                    constructionText = str(self.defaultConstrDict['2.5'].name())\n                elif int(surface.type) == 2 and (surface.BC.lower() == 'surface' or surface.BC.lower() == 'adiabatic'):\n                    constructionText = str(self.defaultConstrDict['2'].name())\n                elif int(surface.type) == 2 and surface.BC.lower() == 'outdoors':\n                    constructionText = str(self.defaultConstrDict['2.75'].name())\n                else:\n                    try:\n                        constructionText = str(self.defaultConstrDict[str(surface.type)].name())\n                    except:\n                        constructionText = None\n                \n                if constructionText != str(surface.EPConstruction) or surface.BC.upper() == \"ADIABATIC\" or surface.BC.upper() == \"SURFACE\":\n                    if self.isConstructionInLib(surface.EPConstruction):\n                        construction = self.getConstructionFromLib(surface.EPConstruction)\n                    else:\n                        construction = self.getOSConstruction(surface.EPConstruction, model)\n                        self.addConstructionToLib(surface.EPConstruction, construction)\n                    thisSurface.setConstruction(construction)\n            elif surface.BC.upper() == \"ADIABATIC\" or surface.BC.upper() == \"SURFACE\":\n                if self.isConstructionInLib(surface.construction):\n                    construction = self.getConstructionFromLib(surface.construction)\n                else:\n                    construction = self.getOSConstruction(surface.construction, model)\n                    self.addConstructionToLib(surface.construction, construction)\n                thisSurface.setConstruction(construction)\n            \n            thisSurface.setOutsideBoundaryCondition(surface.BC.capitalize())\n            if surface.BC.capitalize()!= \"ADIABATIC\":\n                thisSurface.setSunExposure(surface.sunExposure.capitalize())\n                thisSurface.setWindExposure(surface.windExposure.capitalize())\n            else:\n                thisSurface.setSunExposure(\"NOSUN\")\n                thisSurface.setWindExposure(\"NOWIND\")\n            \n            # Boundary condition object\n            #setAdjacentSurface(self: Surface, surface: Surface)\n            if surface.BC.lower() == \"surface\" and surface.BCObject.name.strip()!=\"\":\n                self.adjacentSurfacesDict[surface.name] = [surface.BCObject.name, thisSurface.handle()]\n            \n            return thisSurface\n    \n    \n    def OPSFenSurface (self, surface, openStudioParentSrf, model):\n        for childSrf in surface.childSrfs:\n            coordinates = childSrf.coordinates\n            \n            # generate OpenStudio points\n            windowPointVectors = ops.Point3dVector();\n            \n            for pt in coordinates:\n                # add the points to an openStudio list\n                windowPointVectors.Add(ops.Point3d(pt.X,pt.Y,pt.Z))\n            \n            glazing = ops.SubSurface(windowPointVectors, model)\n            glazing.setName(childSrf.name)\n            glazing.setSurface(openStudioParentSrf)\n            glazing.setSubSurfaceType(childSrf.srfType[childSrf.type])\n            \n            # create constructions if it's not in the default set.\n            if childSrf.EPConstruction != None:\n                if childSrf.BC.lower() == 'surface' or childSrf.BC.lower() == 'adiabatic':\n                    constructionText = str(self.defaultConstrDict['5.5'].name())\n                elif surface.type == 1:\n                    constructionText = str(self.defaultConstrDict['5.25'].name())\n                else:\n                    constructionText = str(self.defaultConstrDict['5'].name())\n                \n                if constructionText != str(childSrf.EPConstruction) or surface.BC.upper() == \"SURFACE\":\n                    if self.isConstructionInLib(childSrf.EPConstruction):\n                        construction = self.getConstructionFromLib(childSrf.EPConstruction)\n                    else:\n                        construction = self.getOSConstruction(childSrf.EPConstruction, model)\n                        self.addConstructionToLib(childSrf.EPConstruction, construction)\n                    glazing.setConstruction(construction)\n            \n            # Check if there are any frame objects associated with the window.\n            try:\n                frameProps = sc.sticky[\"honeybee_WindowPropLib\"][childSrf.EPConstruction]\n                opsFrameObj = self.getOSFrameObj(childSrf.EPConstruction, model)\n                glazing.setWindowPropertyFrameAndDivider(opsFrameObj)\n            except:\n                pass\n            \n            # Set any shading control objects.\n            try:\n                shdCntrlName = childSrf.shadingControlName[0]\n                opsSdhCntrl = self.getOSShdCntrl(shdCntrlName, surface.parent.name, model)\n                glazing.setShadingControl(opsSdhCntrl)\n            except: pass\n            \n            # Boundary condition object\n            #setAdjacentSurface(self: Surface, surface: Surface)\n            if surface.BC.lower() == \"surface\" and surface.BCObject.name.strip()!=\"\":\n                if childSrf.name == childSrf.BCObject.name:\n                    raise Exception(\"Interior facing surfaces can't have the same name: %s\"%childSrf.name + \\\n                        \"\\nRename one of the surfaces and try again!\")\n                self.adjacentFenSrfsDict[childSrf.name] = [childSrf.BCObject.name, glazing.handle()]\n    \n    def OPSShdSurface(self, shdSurfaces, model):\n        shadingGroup = ops.ShadingSurfaceGroup(model)\n        \n        for surfaceCount, surface in enumerate(shdSurfaces):\n            coordinates = surface.extractPoints(1, False, None, 'UpperLeftCorner')\n            if type(coordinates[0])is not list and type(coordinates[0]) is not tuple:\n                coordinates = [coordinates]\n            \n            shadingSch = \"\"\n            schedule = surface.TransmittanceSCH\n            if schedule!=\"\":\n                # transmittance schedule\n                shadingSch = self.getOSSchedule(schedule, model)\n            \n            # generate OpenStudio points\n            shdPointVectors = ops.Point3dVector();\n            \n\n            for shadingCount, ptList in enumerate(coordinates):\n                for pt in ptList:\n                    # add the points to an openStudio list\n                    shdPointVectors.Add(ops.Point3d(pt.X,pt.Y,pt.Z))\n                \n                shdSurface = ops.ShadingSurface(shdPointVectors, model)\n                shdSurface.setName(\"shdSurface_\" + str(surfaceCount) + \"_\" + str(shadingCount))\n                shdSurface.setShadingSurfaceGroup(shadingGroup)\n                if shadingSch!=\"\": shdSurface.setTransmittanceSchedule(shadingSch)\n                \n    \n    def setAdjacentSurfaces(self, model):\n        defaultConstrDict = {\n            'Wall': 'Interior Wall',\n            'Ceiling': 'Interior Ceiling',\n            'RoofCeiling': 'Interior Ceiling',\n            'Floor': 'Interior Floor'}\n        \n        # Set Adjacent zone surfaces.\n        for surfaceName in self.adjacentSurfacesDict.keys():\n            adjacentSurfaceName, OSSurfaceHandle = self.adjacentSurfacesDict[surfaceName]\n            OSSurface = model.getSurface(OSSurfaceHandle).get()\n            \n            try:\n                adjacentOSSurfaceHandle = self.adjacentSurfacesDict[adjacentSurfaceName][1]\n                adjacentOSSurface = model.getSurface(adjacentOSSurfaceHandle).get()\n                OSSurface.setAdjacentSurface(adjacentOSSurface)\n            except:\n                # if we didn't find the adjacent surfcae, do the next most accurate thing:\n                # make the surface adiabatic and add an interior construction\n                try:\n                    OSSurface.setOutsideBoundaryCondition(\"ADIABATIC\")\n                    OSSurface.setSunExposure(\"NOSUN\")\n                    OSSurface.setWindExposure(\"NOWIND\")\n                    if self.isConstructionInLib(defaultConstrDict[str(OSSurface.surfaceType())]):\n                        construction = self.getConstructionFromLib(defaultConstrDict[str(OSSurface.surfaceType())])\n                    else:\n                        construction = self.getOSConstruction(defaultConstrDict[str(OSSurface.surfaceType())], model)\n                        self.addConstructionToLib(defaultConstrDict[str(OSSurface.surfaceType())], construction)\n                    OSSurface.setConstruction(construction)\n                    warning = \"Adjacent surface \" + adjacentSurfaceName + \" was not found.\\n\" + \\\n                        \"Boundary for surface \" + surfaceName + \" will be set to adiabatic.\"\n                    print warning\n                except:\n                    warning = \"Adjacent surface \" + adjacentSurfaceName + \" was not found.\\n\" + \\\n                        \"Boundary for surface \" + surfaceName + \" will be set to adiabatic.\"\n                    print warning\n        \n        # Set adjacent Fenestration surfaces.\n        for surfaceName in self.adjacentFenSrfsDict.keys():\n            adjacentSurfaceName, OSSurfaceHandle = self.adjacentFenSrfsDict[surfaceName]\n            OSSurface = model.getSubSurface(OSSurfaceHandle).get()\n            \n            try:\n                adjacentOSSurfaceHandle = self.adjacentFenSrfsDict[adjacentSurfaceName][1]\n                adjacentOSSurface = model.getSubSurface(adjacentOSSurfaceHandle).get()\n                OSSurface.setAdjacentSubSurface(adjacentOSSurface)\n            except:\n                # if we didn't find the adjacent surfcae, do the next most accurate thing:\n                # delete the interior window and treat the parent surface as adiabatic.\n                try:\n                    OSSurface.remove()\n                    warning = \"Adjacent surface \" + adjacentSurfaceName + \" was not found.\\n\" + \\\n                            \"Interior window \" + surfaceName + \" will be removed and its parent will be set to adiabatic.\"\n                    print warning\n                except:\n                    warning = \"Adjacent surface \" + adjacentSurfaceName + \" was not found.\\n\" + \\\n                        \"Interior window \" + surfaceName + \" will be removed and its parent will be set to adiabatic.\"\n                    print warning\n    \n    def setOutputVariable(self, fields, model):\n        \"\"\"\n        Output:Variable\n        \"\"\"\n        var, key, name, freq = fields\n        outputVariable = ops.OutputVariable(name.strip(), model)\n        outputVariable.setKeyValue(key.strip())\n        outputVariable.setReportingFrequency(freq.strip())\n    \n    def setOutputMeter(self, fields, model):\n        \"\"\"\n        Output:Meter\n        \"\"\"\n        var, name, freq = fields\n        outputMeter = ops.Meter(model)\n        outputMeter.setMeterFileOnly(False)\n        outputMeter.setName(name.strip())\n        outputMeter.setReportingFrequency(freq.strip())\n    \n    def setOutputs(self, simulationOutputs, model):\n        if simulationOutputs == []:\n            return\n        else:\n            \n            for output in simulationOutputs:\n                try:\n                    # remove comment\n                    outstr = output.split(\"!\")[0].strip()\n                    # remove ; from the end\n                    finalout = outstr.replace(\";\", \"\", 1)\n                    # split into fields\n                    fields = finalout.split(\",\")\n                    if fields[0].strip().lower() == \"output:variable\":\n                        self.setOutputVariable(fields, model)\n                    elif fields[0].strip().lower() == \"output:meter\":\n                        self.setOutputMeter(fields, model)\n                    elif fields[0].strip().lower() == \"outputcontrol:table:style\":\n                        pass\n                        #self.setOutputControl(fields, model)\n                    else:\n                        msg = fields[0] + \" is missing from the outputs!\"\n                        #ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n                except Exception, e:\n                    print  e\n                    pass\n    \n    def getObjToReplace(self):\n        return self.csvSchedules, self.csvScheduleCount, self.shadeCntrlToReplace, self.replaceShdCntrl, self.windowSpectralDatasets, self.waterSourceVRFs, self.writegeneration_system_financialdata(self.generatorCosts)\n\nclass HoneybeeHVAC(object):\n    def __init__(self, ID, systemIndex, thermalZones, hbZones, airDetails, heatingDetails, coolingDetails, count):\n        self.ID = ID\n        self.systemIndex = systemIndex\n        self.thermalZones = thermalZones\n        self.hbZones = hbZones\n        self.airDetails = airDetails\n        self.heatingDetails = heatingDetails\n        self.coolingDetails = coolingDetails\n        self.count = count\n    \n    def getData(self):\n        return [self.ID, self.systemIndex, self.thermalZones, self.hbZones, self.airDetails, self.heatingDetails, self.coolingDetails]\n\nclass OPSmeasures(object):\n    def __init__(self, model, OSMeasures, osmFile):\n        # Load the measure class.\n        self.hb_OpenStudioMeasure = sc.sticky[\"honeybee_Measure\"]\n        \n        # Set up the paths to the files.\n        self.osmName = os.path.split(osmFile)[-1].split('.osm')[0]\n        self.workingDir = os.path.split(osmFile)[0]\n        self.oswAddress = self.workingDir + '\\\\' + 'workflow.osw'\n        self.osmPath = tryGetOSPath(osmFile)\n        self.oswPath = tryGetOSPath(self.oswAddress)\n        \n        # Put measures and model into the class.\n        self.OSMeasures = OSMeasures\n        self.model = model\n        \n        # Check the measures that are connected to be sure that they are valid.\n        for OSMeasure in OSMeasures:\n            try:\n                measureArgs = OSMeasure.args\n                measurePath = OSMeasure.path\n            except:\n                raise Exception(\"Not a valid Honeybee measure. \\nUse the Honeybee_Load OpenStudio Measure component to create one!\")\n    \n    def setupOSW(self):\n        # Create the workflow JSON.\n        wf = ops.WorkflowJSON()\n        wf.setOswPath(self.oswPath)\n        wf.setSeedFile(self.osmPath)\n        \n        # Sort the measures so that the OpenStudio ones come first, then E+, then reporting.\n        measureOrder = {\"OpenStudio\":[], \"EnergyPlus\":[], \"Reporting\":[]}\n        for measure in self.OSMeasures:\n            measureOrder[measure.type].append(measure)\n        sortedMeasures = measureOrder[\"OpenStudio\"]\n        sortedMeasures.extend(measureOrder[\"EnergyPlus\"])\n        sortedMeasures.extend(measureOrder[\"Reporting\"])\n        \n        # Add the measures to the workflow.\n        workflowSteps = []\n        for OSMeasure in sortedMeasures:\n            # Copy measure files to a folder next to the OSM.\n            measureName = OSMeasure.path.split('\\\\')[-1]\n            destDir = self.workingDir + '\\\\measures\\\\' + measureName + '\\\\'\n            if os.path.isdir(destDir):\n                shutil.rmtree(destDir)\n            shutil.copytree(OSMeasure.path, destDir)\n            \n            # Create the measure step\n            measure = ops.MeasureStep(measureName)\n            for arg in OSMeasure.args.values():\n                if str(arg.userInput) != str(arg.default_value):\n                    measure.setArgument(arg.name, str(arg.userInput))\n            workflowSteps.append(measure)\n        \n        # Set the workflow steps and save the JSON.\n        stepVector = ops.WorkflowStepVector(workflowSteps)\n        wf.setWorkflowSteps(stepVector)\n        wf.save()\n        \n        # Associate the workflowJSON with the OpenStudio model.\n        self.model.setWorkflowJSON(wf)\n    \n    def applyMeasures(self, runIt):\n        # Write the batch file.\n        workingDrive = self.workingDir[:2].upper()\n        osExePath = '/'.join(openStudioLibFolder.split('/')[:-2]) +'/bin/'\n        osExePath = osExePath.replace('/', '\\\\')\n        osExePath = osExePath.replace((workingDrive + '\\\\'), '')\n        \n        # Write the batch file to apply the measures.\n        batchStr = workingDrive + '\\ncd\\\\' +  osExePath + '\\n\"' + 'openstudio.exe\"' + ' run -m -w ' + self.oswAddress\n        batchFileAddress = self.workingDir + '\\\\' + self.osmName.replace(\" \", \"_\") +'.bat'\n        batchfile = open(batchFileAddress, 'w')\n        batchfile.write(batchStr)\n        batchfile.close()\n        \n        # Apply the measures.\n        if runIt == 2:\n            self.runCmd(batchFileAddress)\n        else:\n            os.system(batchFileAddress)\n        \n        # Check to be sure that the measures were applied correctly.\n        runDir = self.workingDir + '\\\\' + 'run\\\\'\n        epRunDir = self.workingDir + '\\\\' + self.osmName + '\\\\'\n        idfFolder = os.path.join(epRunDir)\n        idfFolder = os.path.join(idfFolder, \"ModelToIdf\")\n        idfFilePath = os.path.join(idfFolder, \"in.idf\")\n        if not os.path.isfile(runDir+\"in.idf\"):\n            # The simulation has not run correctly and we must parse the error log.\n            logfile  = runDir + 'run.log'\n            if os.path.isfile(logfile):\n                errorFound = False\n                errorMsg = 'The measures did not correctly as a result of the following error:\\n'\n                with open(logfile, \"r\") as log:\n                    for line in log:\n                        if 'ERROR]' in line and errorFound == False:\n                            errorFound = True\n                            msg = line.split('ERROR]')[-1]\n                            errorMsg = errorMsg + msg\n                print errorMsg\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, errorMsg)\n                return None\n        \n        try:\n            os.mkdir(epRunDir)\n        except:\n            pass\n        try:\n            os.mkdir(idfFolder)\n        except:\n            pass\n        shutil.copy(runDir+\"pre-preprocess.idf\", idfFilePath)\n        return idfFolder, idfFilePath\n    \n    def runCmd(self, batchFileAddress, shellKey = True):\n        batchFileAddress.replace(\"\\\\\", \"/\")\n        p = subprocess.Popen([\"cmd /c \", batchFileAddress], shell=shellKey, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\t\t\n        out, err = p.communicate()\n\n\n\nclass EPFeaturesNotInOS(object):\n    def __init__(self, workingDir):\n        self.fileBasedSchedules = {}\n        self.schedTypLims = []\n        self.workingDir = workingDir\n    \n    def createCSVSchedString(self, scheduleName):\n        # check if the schedule is already created\n        if scheduleName.upper() in self.fileBasedSchedules.keys(): return \"\\n\"\n        # set up default values\n        schTypeLimitStr = \"\\n\"\n        schTypeLimitName = \"Fraction\"\n        numOfHours = 8760\n        \n        # create schedule object based on file\n        # find file name and use it as schedule name\n        scheduleFileName = os.path.basename(scheduleName)\n        scheduleObjectName = \"_\".join(scheduleFileName.split(\".\")[:-1])\n        \n        # copy schedule file into working dir\n        scheduleNewAddress = os.path.join(self.workingDir, scheduleFileName)\n        shutil.copyfile(scheduleName, scheduleNewAddress)\n        \n        # put them as key, value so I can find the new name when write schedule\n        self.fileBasedSchedules[scheduleName.upper()] = scheduleObjectName\n        \n        # get the inputs if the schedule is generated by Honeybee\n        with open(scheduleName, \"r\") as schFile:\n            for lineCount, line in enumerate(schFile):\n                if lineCount == 3: break\n                elif lineCount == 0:\n                    # try to collect information related to type limit\n                    lineSeg = line.split(\",\")\n                    if not lineSeg[0].startswith(\"Honeybee\"):\n                        schTypeLimitStr = \"ScheduleTypeLimits,\\t!Schedule Type\\n\" + \\\n                                          '    FRACTION' + \",\\t! Name\\n\" + \\\n                                          '    0' + \",\\t!- Lower Limit Value\\n\" + \\\n                                          '    1' + \",\\t!- Upper Limit Value\\n\" + \\\n                                          '    CONTINUOUS' + \";\\t!- Numeric Type\\n\\n\"\n                    else:\n                        lowerLimit, upperLimit, numericType, unitType = lineSeg[1:5]\n                        \n                        # prepare the schedulTypeLimitObject\n                        schTypeLimitName = os.path.basename(scheduleName).lower(). \\\n                                           replace(\".\", \"\").split(\"csv\")[0] + \"TypeLimit\"\n                        \n                        schTypeLimitStr = \"ScheduleTypeLimits,\\t!Schedule Type\\n\" + \\\n                                          schTypeLimitName + \",\\t! Name\\n\" + \\\n                                          lowerLimit.strip() + \",\\t!- Lower Limit Value\\n\" + \\\n                                          upperLimit.strip() + \",\\t!- Upper Limit Value\\n\" + \\\n                                          numericType.strip() + \",\\t!- Numeric Type\\n\" + \\\n                                          unitType.strip() + \";\\t!- Unit Type\\n\\n\"\n                elif lineCount == 2:\n                    # check timestep\n                    try: numOfHours *= int(line.split(\",\")[0])\n                    except: pass\n        \n        # scheduleStr writes the section Schedule:File in the EnergyPlus file\n        # for custom schedules.\n        if schTypeLimitName in self.schedTypLims:\n            scheduleStr = ''\n        else:\n            scheduleStr = schTypeLimitStr\n        \n        scheduleStr = scheduleStr + \\\n            \"Schedule:File,\\n\" + \\\n            scheduleObjectName + \",\\t!- Name\\n\" + \\\n            schTypeLimitName + \",\\t!- Schedule Type Limits Name\\n\" + \\\n            scheduleNewAddress + \",\\t!- File Name\\n\" + \\\n            \"5,\\t!- Column Number\\n\" + \\\n            \"4,\\t!- Rows To Skip\\n\" + \\\n            str(int(numOfHours)) + \",\\t!- Hours of Data\\n\" + \\\n            \"Comma;\\t!- Column Separator\\n\"\n        \n        self.schedTypLims.append(schTypeLimitName)\n        \n        return scheduleStr\n    \n    def EPNatVentSimple(self, zone, natVentCount):\n        if zone.natVentSchedule[natVentCount] == None: natVentSched = 'ALWAYS ON'\n        elif zone.natVentSchedule[natVentCount].upper().endswith('CSV'):\n            natVentSchedFileName = os.path.basename(zone.natVentSchedule[natVentCount])\n            natVentSched = \"_\".join(natVentSchedFileName.split(\".\")[:-1])\n        else: natVentSched = zone.natVentSchedule[natVentCount]\n        \n        return '\\nZoneVentilation:WindandStackOpenArea,\\n' + \\\n                '\\t' + zone.name + 'NatVent' + str(natVentCount) + ',  !- Name\\n' + \\\n                '\\t' + zone.name + ',  !- Zone Name\\n' + \\\n                '\\t' + str(zone.windowOpeningArea[natVentCount]) + ',  !- Opening Area\\n' + \\\n                '\\t' + natVentSched + ',  !- Nat Vent Schedule\\n' + \\\n                '\\t' + str(zone.natVentWindDischarge[natVentCount]) + ',   !- Opening Effectiveness\\n' + \\\n                '\\t' + str(zone.windowAngle[natVentCount]) + ',  !- Effective Angle\\n' + \\\n                '\\t' + str(zone.windowHeightDiff[natVentCount]) + ', !- Height Difference\\n' + \\\n                '\\t' + str(zone.natVentStackDischarge[natVentCount]) + ',    !- Discharge Coefficient for Opening\\n' + \\\n                '\\t' + str(zone.natVentMinIndoorTemp[natVentCount])  + ',     !- Minimum Indoor Temperature\\n' + \\\n                '\\t' + ',     !- Minimum Indoor Temperature Schedule Name\\n' + \\\n                '\\t' + str(zone.natVentMaxIndoorTemp[natVentCount])  + ',     !- Maximum Indoor Temperature\\n' + \\\n                '\\t' + ',     !- Maximum Indoor Temperature Schedule Name\\n' + \\\n                '\\t' + str(zone.natVentDeltaTemp[natVentCount])  + ',     !- Delta Temperature\\n' + \\\n                '\\t' + ',     !- Delta Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentMinOutdoorTemp[natVentCount])  + ',     !- Minimum Outdoor Temperature\\n' + \\\n                '\\t' + ',     !- Minimum Outdoor Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentMaxOutdoorTemp[natVentCount])  + ',     !- Maximum Outdoor Temperature\\n' + \\\n                '\\t' + ',     !- Maximum Outdoor Temperature Shcedule Name\\n' + \\\n                '\\t' + '40' + ';                        !- Maximum Wind Speed\\n'\n    \n    def EPNatVentFan(self, zone, natVentCount):\n        if zone.natVentSchedule[natVentCount] == None:\n            natVentSched = 'ALWAYS ON'\n        elif zone.natVentSchedule[natVentCount].upper().endswith('CSV'):\n            natVentSchedFileName = os.path.basename(zone.natVentSchedule[natVentCount])\n            natVentSched = \"_\".join(natVentSchedFileName.split(\".\")[:-1])\n        else: natVentSched = zone.natVentSchedule[natVentCount]\n        \n        return '\\nZoneVentilation:DesignFlowRate,\\n' + \\\n                '\\t' + zone.name + 'NatVent' + str(natVentCount) + ',  !- Name\\n' + \\\n                '\\t' + zone.name + ',  !- Zone Name\\n' + \\\n                '\\t' + natVentSched + ',  !- Nat Vent Schedule\\n' + \\\n                '\\t' + 'Flow/Zone' + ',  !- Design Flow Rate Calculation Method\\n' + \\\n                '\\t' + str(zone.fanFlow[natVentCount]) + ',   !- Design flow rate m3/s\\n' + \\\n                '\\t' + ',  !- Design flow rate per floor area\\n' + \\\n                '\\t' + ', !- Flow Rate per person\\n' + \\\n                '\\t' + ',    !- Air chancges per hour\\n' + \\\n                '\\t' + 'Intake' + ',  !- Ventilation Type\\n' + \\\n                '\\t' + str(zone.FanPressure[natVentCount]) + ',   !- Fan Pressure Rise (Pa)\\n' + \\\n                '\\t' + str(zone.FanEfficiency[natVentCount]) + ',   !- Fan Efficiency (Pa)\\n' + \\\n                '\\t' + '1' + ',  !- Constant Term Coefficient\\n' + \\\n                '\\t' + '0' + ',  !- Temperature Term Coefficient\\n' + \\\n                '\\t' + '0' + ',  !- Velocity Term Coefficient\\n' + \\\n                '\\t' + '0' + ',  !- Velocity Squared Term Coefficient\\n' + \\\n                '\\t' + str(zone.natVentMinIndoorTemp[natVentCount])  + ',     !- Minimum Indoor Temperature\\n' + \\\n                '\\t' + ',     !- Minimum Indoor Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentMaxIndoorTemp[natVentCount])  + ',     !- Maximum Indoor Temperature\\n' + \\\n                '\\t' + ',     !- Maximum Indoor Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentDeltaTemp[natVentCount]) + ',     !- Delta Temperature\\n' + \\\n                '\\t' + ',     !- Delta Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentMinOutdoorTemp[natVentCount])  + ',     !- Minimum Outdoor Temperature\\n' + \\\n                '\\t' + ',     !- Minimum Outdoor Temperature Shcedule Name\\n' + \\\n                '\\t' + str(zone.natVentMaxOutdoorTemp[natVentCount])  + ',     !- Maximum Outdoor Temperature\\n' + \\\n                '\\t' + ',     !- Maximum Outdoor Temperature Shcedule Name\\n' + \\\n                '\\t' + '40' + ';                        !- Maximum Wind Speed\\n'\n    \n    def EPHoliday(self, date, count):\n        \n        return '\\nRunPeriodControl:SpecialDays,\\n' + \\\n                '\\t' + 'Holiday' + str(count) + ',  !- Name\\n' + \\\n                '\\t' + date.split(' ' )[0] + '/' + date.split(' ')[1] + ',  !- Date\\n' + \\\n                '\\t' + '1' + ',  !- Duration\\n' + \\\n                '\\t' + 'Holiday' + ';  !- Special Day Type\\n'\n\n    def EarthTube(self,zone):\n        \n        if zone.ETschedule.upper().endswith('CSV'):\n            # For custom schedule\n            scheduleFileName = os.path.basename(zone.ETschedule)\n            scheduleObjectName = \"_\".join(scheduleFileName.split(\".\")[:-1]).upper()\n            earthTubeSched = scheduleObjectName\n        else: earthTubeSched = zone.ETschedule\n        \n        return '\\nZoneEarthtube,\\n' + \\\n            '\\t' + zone.name + ',\\t!- Zone Name\\n' + \\\n            '\\t' + str(earthTubeSched) + ',\\t!- Schedule Name\\n'+\\\n            '\\t' + str(zone.design_flow_rate) + ',\\t!- Design Flow Rate {m3/s}\\n'+\\\n            '\\t' + str(zone.mincooltemp) + ',\\t!- Minimum Zone Temperature when Cooling {C}\\n'+\\\n            '\\t' + str(zone.maxheatingtemp) + ',\\t!- Maximum Zone Temperature when Heating {C}\\n'+\\\n            '\\t' + str(zone.delta_temp) + ',\\t!- Delta Temperature {deltaC}\\n'+\\\n            '\\t' + str(zone.et_type) + ',\\t!- Earthtube Type\\n'+\\\n            '\\t' + str(zone.fanprise) + ',\\t!- Fan Pressure Rise {Pa}\\n'+\\\n            '\\t' + str(zone.efficiency) + ',\\t!- Fan Total Efficiency\\n'+\\\n            '\\t' + str(zone.piperadius) + ',\\t!- Pipe Radius {m}\\n'+\\\n            '\\t' + str(zone.thick) + ',\\t!- Pipe Thickness {m}\\n'+\\\n            '\\t' + str(zone.length) + ',\\t!- Pipe Length {m}\\n'+\\\n            '\\t' + str(zone.thermal_k) + ',\\t!- Pipe Thermal Conductivity {W/m-K}\\n'+\\\n            '\\t' + str(zone.pipedepth) + ',\\t!- Pipe Depth Under Ground Surface {m}\\n'+\\\n            '\\t' + str(zone.soil_con) + ',\\t!- Soil Condition\\n'+\\\n            '\\t' + str(zone.soil_avannual) +',\\t!- Average Soil Surface Temperature {C}\\n'+\\\n            '\\t' + str(zone.soil_amplitude) + ',\\t!- Amplitude of Soil Surface Temperature {C}\\n'+\\\n            '\\t' + str(zone.soil_phaseconstant) + ',\\t!- Phase Constant of Soil Surface Temperature {days}\\n'+\\\n            '\\t' + zone.termflow + ',\\t!- Constant Term Flow Coefficient\\n'+\\\n            '\\t' + zone.tempflowco + ',\\t!- Temperature Term Flow Coefficient\\n'+\\\n            '\\t' + zone.veltermflow  + ',\\t!- Velocity Term Flow Coefficient\\n'+\\\n            '\\t' + zone.velsquflow  + ';\\t!- Velocity Squared Term Flow Coefficient\\n'\n\n\nclass RunOPS(object):\n    def __init__(self, model, weatherFilePath, HBZones, simParameters, openStudioLibFolder, csvSchedules, \\\n            csvScheduleCount, additionalcsvSchedules, shadeCntrlToReplace, replaceShdCntrl, windowSpectralData, \\\n            waterSourceVRFs, generatorCosts):\n        self.weatherFile = weatherFilePath # just for batch file as an alternate solution\n        self.EPFolder = self.getEPFolder()\n        self.EPPath = tryGetOSPath(self.EPFolder + \"\\EnergyPlus.exe\")\n        self.epwFile = tryGetOSPath(weatherFilePath)\n        self.iddFile = tryGetOSPath(self.EPFolder + \"\\Energy+.idd\")\n        self.model = model\n        self.HBZones = HBZones\n        self.simParameters = simParameters\n        self.csvSchedules = csvSchedules\n        self.csvScheduleCount = csvScheduleCount\n        self.additionalcsvSchedules = additionalcsvSchedules\n        self.shadeCntrlToReplace = shadeCntrlToReplace\n        self.replaceShdCntrl = replaceShdCntrl\n        self.windowSpectralData = windowSpectralData\n        self.waterSourceVRFs = waterSourceVRFs\n        self.generatorCosts = generatorCosts\n        self.hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n        self.lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    \n    def getEPFolder(self):\n        try:\n            return sc.sticky[\"honeybee_folders\"][\"EPPath\"]\n        except:\n            raise Exception(\"Failed to find EnergyPlus folder.\")\n    \n    def osmToidf(self, workingDir, projectName, osmPath):\n        # create a new folder to run the analysis\n        projectFolder =os.path.join(workingDir, projectName)\n        \n        try: os.mkdir(projectFolder)\n        except: pass\n        \n        idfFolder = os.path.join(projectFolder)\n        idfFilePath = tryGetOSPath(os.path.join(projectFolder, \"ModelToIdf\", \"in.idf\"))\n        \n        forwardTranslator = ops.EnergyPlusForwardTranslator()\n        workspace = forwardTranslator.translateModel(ops.Model.load(osmPath).get())\n        \n        # remove the current object\n        tableStyleObjects = workspace.getObjectsByType(ops.IddObjectType(\"OutputControl_Table_Style\"))\n        for obj in tableStyleObjects: obj.remove()\n        \n        tableStyle = ops.IdfObject(ops.IddObjectType(\"OutputControl_Table_Style\"))\n        tableStyle.setString(0, \"CommaAndHTML\")\n        workspace.addObject(tableStyle)\n        \n        workspace.save(idfFilePath, overwrite = True)\n        \n        \"\"\"\n        Code added by chriswmackey to add the following capabilities that do not yet exist in OS:\n        Simple Natural Ventilation\n        CSV Schedules\n        Additional IDF Strings\n        Advanced Shading Control\n        Earth Tubes\n        Holidays\n        \"\"\"\n        self.writeNonOSFeatures(idfFilePath, self.HBZones, self.simParameters, workingDir)\n        \n        return idfFolder, idfFilePath\n    \n    \n    def writeNonOSFeatures(self, idfFilePath, HBZones, simParameters, workingDir):\n        # Go through the lines of the exiting IDF and find and references to CSV schedules.\n        wrongLineTrigger = True\n        fi = open(str(idfFilePath),'r')\n        fi.seek(0)\n        lines=[]\n        foundCSVSchedules = []\n        for lineCount, line in enumerate(fi):\n            if 'Schedule:' in line:\n                lines.append(line)\n                wrongLineTrigger = True\n            elif 'CSV' in line or 'csv' in line:\n                origName = line.split(',')[0]\n                if origName == line:\n                    origName = line.split(';')[0]\n                newName = origName.split('\\\\')[-1].split('.')[0]\n                #Ignore csv file path in Schedule:File generaged from OpenStudio 2.8\n                if '/files/' in origName:\n                    newName = origName\n                if origName not in foundCSVSchedules:\n                    foundCSVSchedules.append(origName)\n                if wrongLineTrigger ==True: lines.append(line)\n                else: lines.append(line.replace(origName, newName))\n            elif wrongLineTrigger == True:\n                wrongLineTrigger = False\n                lines.append(line)\n            else:\n                lines.append(line)\n        fi.close()\n        \n        #Write in any CSV schedules.\n        otherFeatureClass = EPFeaturesNotInOS(workingDir)\n        for schedule in self.csvSchedules:\n            lines.append(otherFeatureClass.createCSVSchedString(schedule))\n        for schedule in self.additionalcsvSchedules:\n            lines.append(otherFeatureClass.createCSVSchedString(schedule))\n        \n        # If a start day of the week is specified, change it.\n        if vernum1 < 2 or (vernum1 == 2 and vernum2 < 7):\n            magic_num = 7\n            default_d = \"UseWeatherFile\"\n        else:\n            magic_num = 9\n            default_d = \"Thursday\"\n        counter = 0\n        swapTrigger = False\n        for lCount, line in enumerate(lines):\n            if 'RunPeriod,' in line:\n                swapTrigger = True\n            if swapTrigger == True:\n                counter += 1\n            if counter == magic_num:\n                if simParameters[8] != None:\n                    lines[lCount] = simParameters[8] + ',\\n'\n                else:\n                    lines[lCount] = default_d + ',\\n'\n        \n        # Write in any Holidays.\n        if simParameters[7] != []:\n            for count, hol in enumerate(simParameters[7]):\n                lines.append(otherFeatureClass.EPHoliday(hol, count))\n        \n        # Replace any incorrect shading control objects.\n        if self.replaceShdCntrl == True:\n            # Remove shading control objects from the file.\n            newLines = []\n            winPropTrigger = False\n            for line in lines:\n                if 'WindowProperty:ShadingControl,' in line:\n                    winPropTrigger = True\n                elif winPropTrigger == True and ';' in line:\n                    winPropTrigger = False\n                elif winPropTrigger == True: pass\n                else:\n                    newLines.append(line)\n            lines = newLines\n            \n            for shdCntrlItem in self.shadeCntrlToReplace:\n                # Add correct shading control objects to file.\n                shdCntrlName = shdCntrlItem[0]\n                values = self.hb_EPObjectsAux.getEPObjectDataByName(shdCntrlName)\n                \n                if not values[4][0].endswith('.CSV'):\n                    shdCntrlStr = self.hb_EPObjectsAux.getEPObjectsStr(shdCntrlName)\n                else:\n                    newSchedName = os.path.basename(values[4][0]).replace('.CSV', '')\n                    initStr = self.hb_EPObjectsAux.getEPObjectsStr(shdCntrlName)\n                    shdCntrlStr = initStr.replace(values[4][0], newSchedName)\n                    shdCntrlName = shdCntrlName.replace(values[4][0], newSchedName)\n                \n                \n                shdCntrlStrList = shdCntrlStr.split(shdCntrlName)\n                shdCntrlStr = shdCntrlStrList[0] + str(shdCntrlItem[1]) + shdCntrlStrList[1]\n                lines.append(shdCntrlStr)\n        \n        # Connect any water source VRFs to their plant loops.\n        if self.waterSourceVRFs != {}:\n            VRFs2Find = self.waterSourceVRFs.keys()\n            # Connect any VRFs to the right plant loop.\n            # Delete the adiabatic pipe placeholders.\n            # Change the ground source branch to refernce the VRF.\n            for VRF in VRFs2Find:\n                vrfFound = False\n                condenCount = 0\n                pipeFound = False\n                pipeName = self.waterSourceVRFs[VRF]['pipe']\n                pipeCount = 0\n                branchFound = False\n                branchName = self.waterSourceVRFs[VRF]['branch']\n                branchCount = 0\n                for count, line in enumerate(lines):\n                    if VRF in line:\n                        vrfFound = True\n                    elif vrfFound == True and ';' in line:\n                        vrfFound = False\n                    elif vrfFound == True and 'AirCooled' in line:\n                        lines[count] = 'WaterCooled,\\n'\n                        condenCount = 1\n                    elif vrfFound == True and condenCount == 1:\n                        lines[count] = self.waterSourceVRFs[VRF]['inlet'] + ',\\n'\n                        condenCount = 2\n                    elif vrfFound == True and condenCount == 2:\n                        lines[count] = self.waterSourceVRFs[VRF]['outlet'] + ',\\n'\n                        condenCount = 0\n                    elif 'Pipe:Adiabatic,\\n' in line:\n                        pipeFound = True\n                    elif pipeFound == True and pipeName in line:\n                        lines[count-1] = '\\n'\n                        lines[count] = '\\n'\n                        pipeCount = 1\n                    elif pipeCount == 1:\n                        lines[count] = '\\n'\n                        pipeCount = 2\n                    elif pipeCount == 2:\n                        lines[count] = '\\n'\n                        pipeCount = 0\n                        pipeFound = False\n                    elif pipeFound == True and ';' in line:\n                        pipeFound = False\n                    elif 'Branch,\\n' in line:\n                        branchFound = True\n                    elif branchFound == True and branchName in line:\n                        branchCount = 1\n                    elif branchCount == 1 and 'Pipe:Adiabatic' in line:\n                        lines[count] = '  AirConditioner:VariableRefrigerantFlow,\\n'\n                        branchCount = 2\n                    elif branchCount == 2:\n                        lines[count] = '  ' + VRF + ',\\n'\n                        branchCount = 0\n                        branchFound = False\n                    elif branchFound == True and ';' in line:\n                        branchFound = False\n        \n        # Write in any requested natural ventilation objects.\n        # Find any natural ventilation objects on the Zones.\n        natVentStrings = []\n        for zone in HBZones:\n            if zone.natVent == True:\n                for natVentCount, natVentObj in enumerate(zone.natVentType):\n                    if natVentObj == 1 or natVentObj == 2:\n                        natVentStrings.append(otherFeatureClass.EPNatVentSimple(zone, natVentCount))\n                    elif natVentObj == 3:\n                        natVentStrings.append(otherFeatureClass.EPNatVentFan(zone, natVentCount))\n        # Write the natural ventilation objects into the IDF.\n        if len(natVentStrings) > 0:\n            for line in natVentStrings:\n                lines.append(line)\n        \n        # Add EarthTubes\n        for zone in HBZones:\n            if zone.earthtube == True:\n                lines.append(otherFeatureClass.EarthTube(zone))\n                if zone.ETschedule != 'Always On Discrete':\n                    if zone.ETschedule.upper().endswith('.CSV'):\n                        lines.append(otherFeatureClass.createCSVSchedString(zone.ETschedule))\n                    else:\n                        warning = 'Please use a CSV schedule for earth tubes. Other schedules are not supported at the moment.'\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        \n        # Write in any window spectral data.\n        if self.windowSpectralData != {}:\n            # First, I have to write in the name of the spectral data on the glass materials.\n            glazTrigger = False\n            matName = None\n            for lcount, line in enumerate(lines):\n                if 'WindowMaterial:Glazing' in line:\n                    glazTrigger = True\n                elif line == '\\n':\n                    glazTrigger = False\n                elif glazTrigger == True and '!- Name' in line:\n                    matName = line.split(',')[0].strip()\n                elif glazTrigger == True and '!- Window Glass Spectral Data Set Name' in line:\n                    lines[lcount] = '  ' + self.windowSpectralData[matName] + ',     !- Window Glass Spectral Data Set Name\\n'\n            for matName in self.windowSpectralData.keys():\n                spectDatStr = self.hb_EPObjectsAux.getEPObjectsStr(self.windowSpectralData[matName])\n                lines.append(spectDatStr)\n        \n        # write in any generator objects.\n        if len(self.generatorCosts) != 5:\n            for lin in self.generatorCosts:\n                lines.append(lin)\n        \n        # Write in a request for the surface names in the .eio file.\n        lines.append('\\nOutput:Surfaces:List,\\n')\n        lines.append('\\t' + 'Details;                 !- Report Type' + '\\n')\n        \n        # Write any additional strings.\n        if additionalStrings_ != []:\n            lines.append(\"\\n\")\n            for string in additionalStrings_:\n                if \":\" in string and not '!' in string:\n                    lines.append(\"\\n\")\n                    lines.append(\"\\n\")\n                    lines.append(string)\n                elif \"!\" not in string:\n                    lines.append(\"\\n\")\n                    lines.append(\"\\n\")\n                    lines.append(string)\n                    lines.append(\"\\n\")\n                else:\n                    lines.append(string)\n                    lines.append(\"\\n\")\n            lines.append(\"\\n\")\n        \n        fiw = open(str(idfFilePath),'w')\n        for line in lines:\n            fiw.write(line)\n        fiw.close()\n    \n    def runAnalysis(self, osmFile, runEnergyPlus, idfFileP=None, idfFold=None):\n        # Preparation\n        workingDir, fileName = os.path.split(osmFile)\n        projectName = (\".\").join(fileName.split(\".\")[:-1])\n        osmPath = tryGetOSPath(osmFile)\n        \n        # create idf - I separated this job as putting them together\n        # was making EnergyPlus to crash\n        if idfFileP == None:\n            idfFolder, idfPath = self.osmToidf(workingDir, projectName, osmPath)\n        else:\n            self.writeNonOSFeatures(idfFileP, self.HBZones, self.simParameters, workingDir)\n            idfPath = idfFileP\n            idfFolder = idfFold.split('ModelToIdf')[0]\n        print 'OSM > IDF: ' + str(idfPath)\n        \n        if runEnergyPlus < 3:\n            resultFile = self.writeBatchFile(idfFolder, \"ModelToIdf\\\\in.idf\", self.weatherFile, runEnergyPlus > 1)\n            return os.path.join(idfFolder, \"ModelToIdf\", \"in.idf\"), resultFile\n        else:\n            return os.path.join(idfFolder, \"ModelToIdf\", \"in.idf\"), None\n    \n    def writeBatchFile(self, workingDir, idfFileName, epwFileAddress, runInBackground = False):\n        EPDirectory = self.EPFolder\n        workingDrive = workingDir[:2]\n        if idfFileName.EndsWith('.idf'):  shIdfFileName = idfFileName.replace('.idf', '')\n        else: shIdfFileName = idfFileName\n        \n        if not workingDir.EndsWith('\\\\'): workingDir = workingDir + '\\\\'\n        \n        fullPath = workingDir + shIdfFileName\n        folderName = workingDir.replace( (workingDrive + '\\\\'), '')\n        batchStr = workingDrive + '\\ncd\\\\' +  folderName + '\\n\"' + EPDirectory + \\\n                'Epl-run\" ' + fullPath + ' ' + fullPath + ' idf ' + epwFileAddress + ' EP N nolimit N N 0 Y'\n        \n        batchFileAddress = fullPath +'.bat'\n        batchfile = open(batchFileAddress, 'w')\n        batchfile.write(batchStr)\n        batchfile.close()\n        \n        #execute the batch file\n        if runInBackground:\n            self.runCmd(batchFileAddress)\n        else:\n            os.system(batchFileAddress)\n        \n        return fullPath + \"Zsz.csv\",fullPath+\".sql\",fullPath+\".csv\", fullPath+\".rdd\", fullPath+\".eio\", fullPath+\"Table.html\"\n    \n    def runCmd(self, batchFileAddress, shellKey = True):\n        batchFileAddress.replace(\"\\\\\", \"/\")\n        p = subprocess.Popen([\"cmd /c \", batchFileAddress], shell=shellKey, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\t\t\n        out, err = p.communicate()\n\ndef checkUnits():\n    units = sc.doc.ModelUnitSystem\n    if `units` == 'Rhino.UnitSystem.Meters': conversionFactor = 1.00\n    elif `units` == 'Rhino.UnitSystem.Centimeters': conversionFactor = 0.01\n    elif `units` == 'Rhino.UnitSystem.Millimeters': conversionFactor = 0.001\n    elif `units` == 'Rhino.UnitSystem.Feet': conversionFactor = 0.305\n    elif `units` == 'Rhino.UnitSystem.Inches': conversionFactor = 0.0254\n    else:\n        print 'Kidding me! Which units are you using?'+ `units`+'?'\n        print 'Please use Meters, Centimeters, Millimeters, Inches or Feet'\n        return\n    print 'Current document units is in', sc.doc.ModelUnitSystem\n    print 'Conversion to Meters will be applied = ' + \"%.3f\"%conversionFactor\n    \n    return conversionFactor\n\n\ndef tryGetOSPath(path):\n    \"\"\"Try to convert a string path to OpenStudio Path.\"\"\"\n    try:\n        return ops.Path(path)\n    except TypeError:\n        # OpenStudio 2.6.1\n        ospath = ops.OpenStudioUtilitiesCore.toPath(path)\n        return ops.Path(ospath)\n\n\ndef main(HBZones, HVACSystem, HBContext, north, epwWeatherFile, analysisPeriod, simParameters, simulationOutputs, OSMeasures, runIt, openOpenStudio, workingDir = \"C:\\ladybug\", fileName = \"openStudioModel.osm\"):\n    # check the release\n    w = gh.GH_RuntimeMessageLevel.Warning\n    \n    if not sc.sticky.has_key('ladybug_release')and sc.sticky.has_key('honeybee_release'):\n        print \"You should first let both Ladybug and Honeybee to fly...\"\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let both Ladybug and Honeybee to fly...\")\n        return -1\n    \n    # Units check with HB_HB.\n    convFac = sc.sticky[\"honeybee_ConversionFactor\"]\n    convCheck = checkUnits()\n    if convFac != convCheck:\n        msg = \"There is a mismatch between the current units system and that read by HB_HB. Recompute the grasshopper canvass!\"\n        ghenv.Component.AddRuntimeMessage(w, msg)\n        return -1\n    \n    # version check\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \" Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n     \n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \" Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1    \n        \n    # make sure epw file address is correct\n    if not os.path.isfile(epwWeatherFile):\n        msg = \"EPW weather file does not exist in the specified location!\"\n        print msg\n        ghenv.Component.AddRuntimeMessage(w, msg)\n        return -1\n    \n    # Make sure that the version of OpenStudio is correct if OSMeasures are specified.\n    if OSMeasures != [] and OSMeasures[0] != None:\n        versionOk = False\n        try:\n            verNum = osVersion.split('.')[0]\n            if verNum >= 2:\n                versionOk = True\n        except:\n            pass\n        if versionOk == False:\n            msg = \"Your version of OpenStudio must be 2.0 or above to use OSMeasures_.\"\n            print msg\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n    \n    # Import all classes\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_comfortModels = sc.sticky[\"ladybug_ComfortModels\"]()\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    hb_reEvaluateHBZones= sc.sticky[\"honeybee_reEvaluateHBZones\"]\n    \n    # Set up the folder structure.\n    if fileName == None: \n         fileName = \"unnamed\"\n    fileName = fileName.replace(' ', '_')\n    \n    if workingDir == None:\n        workingDir = sc.sticky[\"Honeybee_DefaultFolder\"] \n        originalWorkDir = os.path.join(workingDir, fileName)\n    else:\n        originalWorkDir = copy.copy(workingDir)\n    \n    if ' ' in workingDir:\n        warning = \"A white space was found in the workingDir_ path.  EnergyPlus cannot run out of directories with white spaces.\\n\" + \\\n        \"Set the workingDir_ on this component to be a directory without a white space and try again.\"\n        print warning\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    subWorkingDir = lb_preparation.makeWorkingDir(os.path.join(workingDir, fileName, \"OpenStudio\")).replace(\"\\\\\\\\\", \"\\\\\")\n    \n    print 'Current working directory is set to: ', subWorkingDir\n    \n    # remove current folder\n    try:\n        lb_preparation.nukedir(subWorkingDir, rmdir = False)\n    except:\n        pass\n    fname = os.path.join(subWorkingDir, fileName + \".osm\")\n    \n    # initiate OpenStudio model\n    model = ops.Model()\n    \n    hb_writeOPS = WriteOPS(simParameters, epwWeatherFile)\n    \n    #set runningPeriod\n    hb_writeOPS.setRunningPeriod(analysisPeriod, model)\n    \n    # set timestep\n    hb_writeOPS.setTimestep(model)\n    \n    # set holidays\n    hb_writeOPS.setHolidays(model)\n    \n    # set start day of week.\n    #hb_writeOPS.setStartDayOfWeek(model)\n    \n    # set north\n    hb_writeOPS.setNorth(north, model)\n    \n    # set site.\n    hb_writeOPS.setSite(epwWeatherFile, model)\n    \n    # set terrain.\n    hb_writeOPS.setTerrain(model)\n    \n    # set ground temperatures.\n    hb_writeOPS.setGroundTemps(model)\n    \n    # set simulation control\n    hb_writeOPS.setSimulationControls(model)\n    \n    # set shadow calculation parameters\n    hb_writeOPS.setShadowCalculation(model)\n    \n    # set hvac suzung factor\n    hb_writeOPS.setSizingFactors(model)\n    \n    # add design days\n    ddyFound = hb_writeOPS.addDesignDays(model)\n    if ddyFound == False:\n        # Create a ddy file from the information in the EPW.\n        try:\n            hb_writeOPS.createDdyFromEPW(epwWeatherFile, subWorkingDir, lb_preparation, lb_comfortModels)\n            hb_writeOPS.addDesignDays(model)\n        except:\n            warning = \"Honeybee could not find a ddy next to the epw file and could not create sizing criteria from the data in the epw file.\\n\" + \\\n                \"No sizing calcualtion will be performed for this model.\"\n            print warning\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            \n    # call Honeybee objects from the hive\n    HBZones = hb_hive.callFromHoneybeeHive(HBZones)\n    \n    reEvaluate = hb_reEvaluateHBZones(HBZones, None, \"UpperLeftCorner\")\n    reEvaluate.evaluateZones()\n    \n    # generate stories\n    hb_writeOPS.generateStories(HBZones, model)\n    \n    # build a default construction set from the connected zones.\n    defaultConstrSet = hb_writeOPS.buildDefaultConstrSet(HBZones, model)\n    \n    #Make a list of schedules to keep track of what needs to be written into the model.\n    additionalSchedList = []\n    additionalcsvSchedules = []\n    \n    for zoneCount, zone in enumerate(HBZones):\n        # create a space - OpenStudio works based of space and not zone\n        # Honeybee though is structured based on zones similar to EnergyPlus\n        space = ops.Space(model)\n        \n        # assign name and type\n        space = hb_writeOPS.setupNameAndType(zone, space, model)\n        \n        # assign level/building story to zone\n        space = hb_writeOPS.setupLevels(zone, space)\n        \n        # schedules\n        space = hb_writeOPS.setDefaultSchedule(zone, space, model)\n        \n        # construction set\n        space.setDefaultConstructionSet(defaultConstrSet)\n        \n        #   INFILTRATION\n        hb_writeOPS.setInfiltration(zone, space, model)\n        \n        # set people definition\n        hb_writeOPS.setPeopleDefinition(zone, space, model)\n        \n        # set people definition\n        hb_writeOPS.setLightingDefinition(zone, space, model)\n        \n        # set electrical equipment\n        hb_writeOPS.setEquipmentDefinition(zone, space, model)\n        \n        # design specification outdoor air\n        space = hb_writeOPS.setDesignSpecificationOutdoorAir(zone, space, model)\n        \n        # assign the thermal zone\n        space, thermalZone = hb_writeOPS.assignThermalZone(zone, space, model)\n        \n        #Keep the thermal zones in a dictionary for later.\n        hb_writeOPS.thermalZonesDict[zone.name] = thermalZone\n        \n        #If there are internal masses assigned to the zone, write them\n        if len(zone.internalMassNames) > 0:\n            for massCount, massName in enumerate(zone.internalMassNames):\n               hb_writeOPS.setInternalMassDefinition(zone, space, model)\n        \n        if zone.isConditioned:\n            # add HVAC system\n            HAVCGroupID = zone.HVACSystem.GroupID\n            \n            if HAVCGroupID!= -1:\n                if HAVCGroupID not in hb_writeOPS.HVACSystemDict.keys():\n                    # add place holder for lists\n                    hb_writeOPS.HVACSystemDict[HAVCGroupID] = HoneybeeHVAC(HAVCGroupID, zone.HVACSystem.Index, [], [], zone.HVACSystem.airDetails, zone.HVACSystem.heatingDetails, zone.HVACSystem.coolingDetails, zoneCount)\n            \n            # collect the information for systems here, such as the zones in each system and the recirculation specifcations for each zone.\n            hb_writeOPS.HVACSystemDict[HAVCGroupID].thermalZones.append(thermalZone)\n            hb_writeOPS.HVACSystemDict[HAVCGroupID].hbZones.append(zone)\n            \n            # add thermostat\n            hb_writeOPS.addThermostat(zone, thermalZone, space, model)\n            \n            # add humidistat if specified\n            if zone.humidityMax != \"\" or zone.humidityMin != \"\":\n                hb_writeOPS.addHumidistat(zone, thermalZone, space, model)\n        \n        # add daylighting controls\n        if zone.daylightCntrlFract != 0:\n            hb_writeOPS.addDaylightCntrl(zone, thermalZone, space, model)\n        \n        # write the surfaces\n        for HBSrf in zone.surfaces:\n            OPSSrf = hb_writeOPS.opsZoneSurface(HBSrf, model, space)\n            if HBSrf.hasChild:\n                    hb_writeOPS.OPSFenSurface(HBSrf, OPSSrf, model)\n                    \n        \n        #Check other schedules.\n        if zone.natVent == True:\n            for ventObj in zone.natVentSchedule:\n                if ventObj != None:\n                    if ventObj.upper().endswith('.CSV'): additionalcsvSchedules.append(ventObj)\n                    else: additionalSchedList.append(ventObj)\n                elif 'ALWAYS ON' not in additionalSchedList: additionalSchedList.append('ALWAYS ON')\n    \n    #Add and extra schedules pulled off of the zones.\n    for schedName in additionalSchedList:\n        ossch = hb_writeOPS.getOSSchedule(schedName, model)\n    \n    # this should be done once for the whole model\n    hb_writeOPS.setAdjacentSurfaces(model)\n    \n    # add systems\n    hb_writeOPS.addSystemsToZones(model)\n    \n    # add zone air mixing objects.\n    for zoneCount, zone in enumerate(HBZones):\n        if zone.mixAir == True: hb_writeOPS.setAirMixing(zone, model)\n        \n    # outputs\n    defaultOutputs = ['Output:Variable,*,Zone Ideal Loads Supply Air Total Cooling Energy, hourly;',\\\n        'Output:Variable,*,Cooling Coil Electric Energy, hourly;',\\\n        'Output:Variable,*,Chiller Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone Ideal Loads Supply Air Total Heating Energy, hourly;',\\\n        'Output:Variable,*,Boiler Gas Energy, hourly;',\\\n        'Output:Variable,*,Heating Coil Total Heating Energy, hourly;',\\\n        'Output:Variable,*,Heating Coil Gas Energy, hourly;',\\\n        'Output:Variable,*,Heating Coil Electric Energy, hourly;',\\\n        'Output:Variable,*,Humidifier Electric Energy, hourly;',\\\n        'Output:Variable,*,Fan Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone Ventilation Fan Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone Lights Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone Electric Equipment Electric Energy, hourly;',\\\n        'Output:Variable,*,Pump Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone VRF Air Terminal Cooling Electric Energy, hourly;',\\\n        'Output:Variable,*,Zone VRF Air Terminal Heating Electric Energy, hourly;',\\\n        'Output:Variable,*,VRF Heat Pump Cooling Electric Energy, hourly;',\\\n        'Output:Variable,*,VRF Heat Pump Heating Electric Energy, hourly;']\n    if simulationOutputs:\n        outputs = simulationOutputs\n    else:\n       outputs = defaultOutputs\n       \n    # Add generators to the model (PV,wind etc)\n\n    # add shading surfaces if any\n    if HBContext!=[] and HBContext[0]!=None:\n        shdingSurfcaes = hb_hive.callFromHoneybeeHive(HBContext)\n        if sc.sticky[\"honeybee_ConversionFactor\"] != 1:\n            NUscale = rc.Geometry.Transform.Scale(rc.Geometry.Plane(rc.Geometry.Plane.WorldXY),sc.sticky[\"honeybee_ConversionFactor\"],sc.sticky[\"honeybee_ConversionFactor\"],sc.sticky[\"honeybee_ConversionFactor\"])\n            for con in shdingSurfcaes:\n                con.transform(NUscale, \"\", False)\n        hb_writeOPS.OPSShdSurface(shdingSurfcaes, model)\n    \n    if HBGenerators_ != []:\n        \n        hb_writeOPS.setGenerators(HBGenerators_,outputs,model)\n       \n    hb_writeOPS.setOutputs(outputs, model)\n    \n    # Get the objects in the file that we need to replace or add because OpenStudio does not support them.\n    csvSchedules, csvScheduleCount, shadeCntrlToReplace, replaceShdCntrl, windowSpectralData, waterSourceVRFs, generatorCosts = hb_writeOPS.getObjToReplace()\n    \n    # If there are OSMeasures, assign them to the OpenStudio model.\n    measureApplied = False\n    if OSMeasures != [] and OSMeasures[0] != None:\n        hb_assingMeasures = OPSmeasures(model, OSMeasures, fname)\n        hb_assingMeasures.setupOSW()\n        measureApplied =  True\n    \n    # save the model\n    if model.save(tryGetOSPath(fname), True):\n        if HVACSystem != None:\n            HVACSystem.SaveHVAC(fname)\n    print \"Model saved to: \" + fname\n    workingDir, fileName = os.path.split(fname)\n    projectName = (\".\").join(fileName.split(\".\")[:-1])\n    \n    # Open the model in OpenStudio (if requested).\n    def openModel(fname):\n        #TODO: need to find a way to check other nonOpsStrings as well, such as Natural Ventilation, CSV file, etc.\n        if additionalStrings_ !=[]:\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Error, \"additionalStrings are raw energyPlus idf strings, which cannot be exported to OpenStudio. \\nYou have to run the simulation directly here, by setting runSimulation_ to True\")\n        else:\n            try:\n                os.startfile(fname)\n            except:\n                try:\n                    os.system(\"start \" + fname)\n                except:\n                    os.system(\"OpenStudioApp.exe \" + fname)\n    if openOpenStudio and not (measureApplied == True and runIt > 0):\n        openModel(fname)\n    \n    # Run the file through OpenStudio\n    if runIt > 0:\n        # Apply measures if necessary.\n        idfFold, idfFileP = None, None\n        if OSMeasures != [] and OSMeasures[0] != None:\n            idfFold, idfFileP = hb_assingMeasures.applyMeasures(runIt)\n        \n        # Run the model through OpenStudio\n        hb_runOPS = RunOPS(model, epwWeatherFile, HBZones, hb_writeOPS.simParameters, openStudioLibFolder, csvSchedules, \\\n            csvScheduleCount, additionalcsvSchedules, shadeCntrlToReplace, replaceShdCntrl, windowSpectralData, \\\n            waterSourceVRFs, generatorCosts)\n        \n        idfFile, resultFile = hb_runOPS.runAnalysis(fname, runIt, idfFileP, idfFold)\n        if runIt < 3:\n            try:\n                errorFileFullName = idfFile.replace('.idf', '.err')\n                errFile = open(errorFileFullName, 'r')\n                for line in errFile:\n                    print line\n                    if \"**  Fatal  **\" in line:\n                        warning = \"The simulation has failed because of this fatal error: \\n\" + str(line)\n                        w = gh.GH_RuntimeMessageLevel.Warning\n                        ghenv.Component.AddRuntimeMessage(w, warning)\n                        resultFile = None\n                    elif \"** Severe  **\" in line and 'CheckControllerListOrder' not in line and not \"surfaces and are non-convex\" in line and not \"Degenerate surfaces\" in line:\n                        comment = \"The simulation has not run correctly because of this severe error: \\n\" + str(line)\n                        c = gh.GH_RuntimeMessageLevel.Warning\n                        ghenv.Component.AddRuntimeMessage(c, comment)\n                errFile.close()\n            except:\n                pass\n        \n        if measureApplied == True and runIt > 0:\n            fname = fname.split(fileName)[0] + 'run\\\\in.osm'\n            if openOpenStudio:\n                openModel(fname)\n        \n        return fname, idfFile, resultFile, originalWorkDir, model\n        \n    return fname, None, None, originalWorkDir, model\n\nif _HBZones and _HBZones[0]!=None and _epwWeatherFile and _writeOSM and openStudioIsReady:\n    results = main(_HBZones, HVACSystem_, HBContext_, north_, _epwWeatherFile,\n                  _analysisPeriod_, _energySimPar_, simulationOutputs_, OSMeasures_,\n                  runSimulation_, openOpenStudio_, workingDir_, fileName_)\n    if results!=-1:\n        osmFileAddress, idfFileAddress, resultsFiles, studyFolder, model = results\n        try:\n            resultFileAddress = resultsFiles[2]\n            eioFileAddress = resultsFiles[4]\n            rddFileAddress = resultsFiles[3]\n            sqlFileAddress = resultsFiles[1]\n            meterFileAddress = resultsFiles[0]\n            htmlReport = resultsFiles[5]\n        except: resultFileAddress = resultsFiles\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}