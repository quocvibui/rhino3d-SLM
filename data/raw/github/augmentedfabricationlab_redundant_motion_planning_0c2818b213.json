{
  "source_url": "https://github.com/augmentedfabricationlab/redundant_motion_planning/blob/62438c504b98f3b179b7ed25388c741400278a2c/src/redundant_motion_planning/utilities/grassopper_io/export_mesh.py",
  "repo": "augmentedfabricationlab/redundant_motion_planning",
  "repo_stars": 0,
  "repo_description": "Python-based framework designed for redundant motion planning and collision checking in mobile robotic systems.",
  "license": "MIT",
  "filepath": "src/redundant_motion_planning/utilities/grassopper_io/export_mesh.py",
  "instruction": "Export mesh",
  "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nfrom compas.datastructures import Mesh\n\n\n# https://github.com/compas-dev/compas/issues/512\n\n\nclass MeshExport:\n    def __init__(self, GH_Mesh, Folder_Path, file_format):\n        for i, mesh in enumerate(GH_Mesh):\n            if not isinstance(mesh, rg.Mesh):\n                raise ValueError(\"Input must be a mesh\")\n            if file_format == \"OBJ\":\n                Path = Folder_Path + str(i) + \".obj\"\n                self.mesh_to_OBJ(mesh, Path)\n            elif file_format == \"STL\":\n                Path = Folder_Path + str(i) + \".stl\"\n                self.mesh_to_STL(mesh, Path)\n\n    def rMesh2cMesh(self, rg_mesh):\n        if isinstance(rg_mesh, rg.Mesh):\n            # single mesh\n            compas_mesh_vertices = [(v.X, v.Y, v.Z) for v in rg_mesh.Vertices]\n            compas_mesh_faces = rg_mesh.Faces.ToIntArray(True)\n            compas_mesh_faces_sorted = []\n            for i in range(0, len(compas_mesh_faces), 3):\n                face = [compas_mesh_faces[i], compas_mesh_faces[i + 1], compas_mesh_faces[i + 2]]\n                compas_mesh_faces_sorted.append(face)\n            return Mesh.from_vertices_and_faces(compas_mesh_vertices, compas_mesh_faces_sorted)\n        else:\n            # array of meshes\n            meshes = []\n            for m in rg_mesh:\n                compas_mesh_vertices = [(v.X, v.Y, v.Z) for v in m.Vertices]\n                compas_mesh_faces = m.Faces.ToIntArray(True)\n                compas_mesh_faces = [compas_mesh_faces[i:i + 3] for i in range(0, len(compas_mesh_faces), 3)]\n                meshes.append(Mesh.from_vertices_and_faces(compas_mesh_vertices, compas_mesh_faces))\n            return meshes\n\n    def mesh_to_OBJ(self, mesh_to_export, File_Path):\n        # Create a FileWriteOptions object\n        Compas_Mesh = self.rMesh2cMesh(mesh_to_export)\n        Compas_Mesh.to_obj(File_Path)\n\n    def mesh_to_STL(self, mesh_to_export, File_Path):\n        # Write an ASCII format STL file for the input mesh.\n        if not isinstance(mesh_to_export, rg.Mesh):\n            try:\n                mesh_to_export = rs.coercegeometry(mesh_to_export)\n            except Exception:\n                raise ValueError(\"Input must be a mesh\")\n        mesh_to_export.Normals.ComputeNormals()  # NITM (\"Not In The Manual\") but this is needed first.\n        verts = mesh_to_export.Vertices  # Get all vertices of the mesh from Rhino.\n\n        stl_file = open(\"%s\" % File_Path, \"w\", encoding=\"utf-8\")\n        stl_file.write(\"solid OBJECT\\n\")\n        for i, face in enumerate(mesh_to_export.Faces):  # Rhino gives faces by vertex index number.\n            stl_file.write(\"  facet normal %s\\n\" % str(mesh_to_export.FaceNormals[i]).replace(\",\", \" \"))  # Rhino gives normals!\n            stl_file.write(\"    outer loop\\n\")\n            stl_file.write(\"      vertex %s\\n\" % str(verts[face.A]).replace(\",\", \" \"))  # Rhino has ABCD properties for face vertex index numbers.\n            stl_file.write(\"      vertex %s\\n\" % str(verts[face.B]).replace(\",\", \" \"))\n            stl_file.write(\"      vertex %s\\n\" % str(verts[face.C]).replace(\",\", \" \"))\n            stl_file.write(\"    endloop\\n\")\n            stl_file.write(\"  endfacet\\n\")\n            if face.IsQuad:\n                stl_file.write(\"  facet normal %s\\n\" % str(mesh_to_export.FaceNormals[i]).replace(\",\", \" \"))\n                stl_file.write(\"    outer loop\\n\")\n                stl_file.write(\"      vertex %s\\n\" % str(verts[face.C]).replace(\",\", \" \"))\n                stl_file.write(\"      vertex %s\\n\" % str(verts[face.D]).replace(\",\", \" \"))\n                stl_file.write(\"      vertex %s\\n\" % str(verts[face.A]).replace(\",\", \" \"))\n                stl_file.write(\"    endloop\\n\")\n                stl_file.write(\"  endfacet\\n\")\n        stl_file.write(\"endsolid OBJECT\\n\")\n        stl_file.close()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}