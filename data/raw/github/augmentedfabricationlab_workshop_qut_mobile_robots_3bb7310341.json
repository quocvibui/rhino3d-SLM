{
  "source_url": "https://github.com/augmentedfabricationlab/workshop_qut_mobile_robots/blob/f85385b3cb7008c1caae04880e3d2b694f5023ed/src/base_positioning/base_map.py",
  "repo": "augmentedfabricationlab/workshop_qut_mobile_robots",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/base_positioning/base_map.py",
  "instruction": "Base map",
  "code": "from compas.datastructures import Network\nfrom compas.geometry import Point, Pointcloud\nfrom compas.geometry import Frame, Vector, Transformation, Translation\nfrom compas.geometry import KDTree, closest_point_in_cloud, closest_points_in_cloud_numpy\nfrom numpy import meshgrid, linspace\nfrom statistics import mean, median_low, median_high\nimport math\n\nclass BaseMap(object):\n    def __init__(self):\n        self.base_map = Network(name=\"base_map\")\n        self.base_map.default_node_attributes = {\n            \"frame\": Frame.worldXY(),\n            \"point\": [0, 0, 0],\n            \"xaxis\": [1, 0, 0],\n            \"yaxis\": [0, 1, 0],\n            \"valid_position\": True,\n            \"mean_reuleax_index\": None,\n            \"mean_reach_index\": -1,\n            \"reuleaux_data\": None,\n            \"closeness_penalty\": 0,\n        }\n\n    @property\n    def kdtree(self):\n        objects = []\n        for key, data in self.base_map.nodes(data=True):\n            objects.append((data[\"frame\"].point, key))\n        kdtree = KDTree()\n        kdtree.build(objects)\n        return kdtree\n\n    def add_pose(self, pose, **kwargs):\n        return self.base_map.add_node(\n            frame=pose, point=pose.point, xaxis=pose.xaxis, yaxis=pose.yaxis, **kwargs\n        )\n\n    def set_poses(self, points, attractor_point=[0, 0, 0]):\n        self.base_map.clear()\n        for i, pt in enumerate(points):\n            vec = Vector.from_start_end(pt, attractor_point).unitized()\n            self.base_map.add_node(\n                key=i, x=pt.x, y=pt.y, z=pt.z, vx=vec.x, vy=vec.y, vz=vec.z\n            )\n\n    def reuleaux_at_pose(self, pose, reuleaux):\n        T = Transformation.from_change_of_basis(pose, Frame.worldXY())\n        kdtree, reuleaux_points = reuleaux.get_kdtree_transformed(T)\n        # print(\"t2: \", time()-t0)\n        reuleaux_data = {\n            \"goal_points\": None,\n            \"collision_points\": None,\n            \"reuleaux_points\": reuleaux_points,\n            \"goal_reuleaux_index\": [],\n            \"collision_reuleaux_index\": [],\n            \"reachable\": [],\n        }\n        return kdtree, reuleaux_data\n\n    def evaluate_pose(self, kdtree, reuleaux, reuleaux_data, goal_pointcloud):\n        ## TODO should add minimum required reachability index\n        reuleaux_data[\"goal_points\"] = goal_pointcloud.points\n        goal_data = [\n            kdtree.nearest_neighbors(pt, 2, distance_sort=True)\n            for pt in goal_pointcloud.points\n        ]\n\n        for d in goal_data:\n            eval_data = {\"goal_reuleaux_index\": 0, \"reachable\": False}\n            # Check if two points of the reachability map are within a set distance (removes points close enough to the boundary of the map)\n            if d[0][2] < (reuleaux.resolution * 1.415) and d[1][2] < (\n                reuleaux.resolution * 1.415\n            ):\n                point_ri = math.sqrt(reuleaux.spheres[d[0][1]].ri)\n                eval_data.update({\"goal_reuleaux_index\": point_ri, \"reachable\": True})\n            for key, value in eval_data.items():\n                reuleaux_data[key].append(value)\n\n        ri_mean = median_low(reuleaux_data[\"goal_reuleaux_index\"])\n        return ri_mean, reuleaux_data\n\n    def reuleaux_kdtree_includes_points(self, kdtree, resolution, points):\n        return all(\n            [\n                kdtree.nearest_neighbor(pt)[2] <= resolution * (0.5 * 1.415)\n                for pt in points\n            ]\n        )\n\n    def get_reuleaux_index_by_base_pose(self, pose, reuleaux, goal_pointcloud):\n        if reuleaux.resolution == 0:\n            raise ValueError(\"ReuleauxReachability instance has resolution == 0.0\")\n        closest_map_point, id, distance = self.kdtree.nearest_neighbor(pose.point)\n        if distance > 0.01:\n            id = self.add_pose(pose)\n        if self.base_map.node_attribute(id, \"mean_reuleaux_index\") is None:\n            kdtree, reuleaux_data = self.reuleaux_at_pose(pose, reuleaux)\n            ri_mean, reuleaux_data = self.evaluate_pose(\n                kdtree, reuleaux, reuleaux_data, goal_pointcloud\n            )\n\n            self.base_map.node_attribute(id, \"mean_reuleaux_index\", ri_mean)\n            self.base_map.node_attribute(id, \"reuleaux_data\", reuleaux_data)\n        else:\n            ri_mean = self.base_map.node_attribute(id, \"mean_reuleaux_index\")\n            reuleaux_data = self.base_map.node_attribute(id, \"reuleaux_data\")\n        return id, reuleaux_data\n\n    def get_reuleaux_index_with_req_points(\n        self, pose, reuleaux, goal_pointcloud, required_points\n    ):\n        if reuleaux.resolution == 0:\n            raise ValueError(\"ReuleauxReachability instance has resolution == 0.0\")\n        closest_map_point, id, distance = self.kdtree.nearest_neighbor(pose.point)\n        if distance > 0.01:\n            id = self.add_pose(pose)\n        if self.base_map.node_attribute(id, \"mean_reuleaux_index\") is None:\n            kdtree, reuleaux_data = self.reuleaux_at_pose(pose, reuleaux)\n            if self.reuleaux_kdtree_includes_points(\n                kdtree, reuleaux.resolution, required_points.points\n            ):\n                ri_mean, reuleaux_data = self.evaluate_pose(\n                    kdtree, reuleaux, reuleaux_data, goal_pointcloud\n                )\n\n                self.base_map.node_attribute(id, \"mean_reuleaux_index\", ri_mean)\n                self.base_map.node_attribute(id, \"reuleaux_data\", reuleaux_data)\n            else:\n                self.base_map.node_attribute(id, \"mean_reuleaux_index\", 0)\n                reuleaux_data[\"goal_reuleaux_index\"] = [0]\n                self.base_map.node_attribute(id, \"reuleaux_data\", reuleaux_data)\n        else:\n            ri_mean = self.base_map.node_attribute(id, \"mean_reuleaux_index\")\n            reuleaux_data = self.base_map.node_attribute(id, \"reuleaux_data\")\n        return id, reuleaux_data\n\n    def get_ideal_pose(self):\n        ideal_key = None\n        mean_ri = None\n        node_data = None\n        for key, data in self.base_map.nodes(data=True):\n            if mean_ri < data[\"mean_reuleaux_index\"] or mean_ri is None:\n                ideal_key = key\n                mean_ri = data[\"mean_reuleaux_index\"]\n                node_data = data\n        return ideal_key, node_data\n\n    def get_ideal_pose_with_closeness_penalty(self, pointcloud, distance=1.0, factor=1):\n        ideal_key = None\n        mean_ri = None\n        node_data = None\n        for key, data in self.base_map.nodes(data=True):\n            dist, pt, idx = closest_point_in_cloud(data[\"point\"], pointcloud)\n            if dist < distance:\n                data[\"penalty_factor\"] = 1 - (dist / distance) / factor\n            else:\n                data[\"penalty_factor\"] = 0\n            node_mean_ri = data[\"mean_reuleaux_index\"] * (1 - data[\"penalty_factor\"])\n            if mean_ri is None or mean_ri < node_mean_ri:\n                ideal_key = key\n                mean_ri = node_mean_ri\n                node_data = data\n        return ideal_key, node_data\n\n    def get_ideal_pose_with_closeness_penalty_and_mean_distance(self, pointcloud, distance=1.0, factor=1):\n        ideal_key = None\n        mean_dist = None\n        mean_ri = None\n        node_data = None\n        mean_dists = []\n        for key, data in self.base_map.nodes(data=True):\n            kdtree = KDTree(pointcloud)\n            result = kdtree.nearest_neighbors(data[\"point\"], 20, distance_sort=True)\n            pt, idx, dist = result[0]\n            vec = Vector.from_start_end(data[\"point\"], pt)\n            vec.z = 0\n            dist = vec.length\n            if dist < distance:\n                data[\"penalty_factor\"] = math.sqrt(1 - (dist / distance) / factor)\n            else:\n                data[\"penalty_factor\"] = 0\n            node_mean_ri = data[\"mean_reuleaux_index\"] * (1 - data[\"penalty_factor\"])\n            node_mean_dist = median_high([r[2] for r in result])\n            mean_dists.append(node_mean_dist)\n            if mean_ri is None or (mean_ri/mean_dist <= node_mean_ri/node_mean_dist):\n                ideal_key = key\n                mean_ri = node_mean_ri\n                mean_dist = node_mean_dist\n                node_data = data\n        return ideal_key, node_data, mean_dists\n\n    def get_ideal_pose_with_segment_and_collision_objects(self, segment_pointcloud, collision_breps, segment_distance=1.0, collision_distance=1.0, factor=1):\n        ideal_key = None\n        mean_dist = None\n        mean_ri = None\n        node_data = None\n        mean_dists = []\n        for key, data in self.base_map.nodes(data=True):\n            kdtree = KDTree(segment_pointcloud)\n            segment_result = kdtree.nearest_neighbors(data[\"point\"], 20, distance_sort=True)\n            pt, idx, dist = segment_result[0]\n            vec = Vector.from_start_end(data[\"point\"], pt)\n            vec.z = 0\n            dist = vec.length\n\n            if dist < segment_distance:\n                data[\"penalty_factor\"] = math.sqrt(1 - (dist / segment_distance) / factor)\n            else:\n                data[\"penalty_factor\"] = 0\n\n            import ghpythonlib.components as ghcomp\n            import Rhino.Geometry as rg\n\n            brep_distance = None\n            for cbrep in collision_breps:\n                collision_result = ghcomp.BrepClosestPoint(rg.Point3d(*data[\"point\"]), cbrep)\n                # print(collision_result)\n                if brep_distance is None:\n                    brep_distance = collision_result[\"distance\"]\n                elif collision_result[\"distance\"] < brep_distance:\n                    brep_distance = collision_result[\"distance\"]\n            # print(brep_distance, collision_distance)\n            if brep_distance < collision_distance:\n                data[\"collision_penalty_factor\"] = math.sqrt(1 - (brep_distance / collision_distance) / factor)\n            else: \n                data[\"collision_penalty_factor\"] = 0\n\n            sum_penalties = data[\"penalty_factor\"] + data[\"collision_penalty_factor\"]\n            if data[\"penalty_factor\"] + data[\"collision_penalty_factor\"] > 1:\n                sum_penalties = 1.0\n\n            node_mean_ri = data[\"mean_reuleaux_index\"] * (1 - sum_penalties)\n            node_mean_dist = median_high([r[2] for r in segment_result])\n            # print(node_mean_ri, node_mean_dist)\n            mean_dists.append(node_mean_dist)\n            if mean_ri is None or (mean_ri/mean_dist <= node_mean_ri/node_mean_dist):\n                ideal_key = key\n                mean_ri = node_mean_ri\n                mean_dist = node_mean_dist\n                node_data = data\n        return ideal_key, node_data\n    \n    def populate_rectangle(self, rectangle, resolution):\n        w = rectangle.Width\n        h = rectangle.Height\n        frame = Frame(\n            rectangle.Plane.Origin, rectangle.Plane.XAxis, rectangle.Plane.YAxis\n        )\n\n        nu = int(w / resolution)\n        nv = int(h / resolution)\n\n        u = linspace(-w / 2, w / 2, nu)\n        v = linspace(h / 2, -h / 2, nv)\n\n        X, Y = meshgrid(u, v)\n\n        def flatten(matrix):\n            flat_list = []\n            for row in matrix:\n                flat_list += list(row)\n            return flat_list\n\n        X_flat = flatten(X)\n        Y_flat = flatten(Y)\n        # pts_crds = zip(X, Y)\n        print(X)\n        pts = [Point(x, y, 0) for x, y in zip(X_flat, Y_flat)]\n        print(pts)\n        pc = Pointcloud(pts)\n        T = Transformation.from_change_of_basis(frame, Frame.worldXY())\n        pc.transform(T)\n\n        return pc\n\n    def populate_surface(self, surface, number_of_points):\n        # points = populate(surface, number of points)\n        # for i, pt in enumerate(points):\n        #   node = {\n        #       'x':pt.x, 'y':pt.y, 'z':pt.z,\n        #   }\n        #   self.base_map.add_node(key=i, attr_dict=node)\n        pass\n\n    def populate_around_point(self, surface, point, number_of_points, radius):\n        # sphere(point, radius)\n        # cut_surface with sphere\n        # populate area with new points\n        # for i, pt in enumerate(points):\n        #   node = {\n        #       'x':pt.x, 'y':pt.y, 'z':pt.z,\n        #   }\n        #   self.base_map.add_node(key=i, attr_dict=node)\n        pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}