{
  "source_url": "https://discourse.mcneel.com/t/gh-mesh-masters-how-trim-away-inner-surface-splinters/45083",
  "topic_id": 45083,
  "title": "GH: Mesh Masters: How trim away inner surface & \"splinters\"?",
  "question": "I’m trying to clean up meshes of bones (from CT scans) which are full of “trash” inside which disturbs my further modelling.\n\n\nFor example I want to get rid of double surfaces (CT-scans results in inner surfaces separating the bone tissue from the marrow) and a bunch of irregular mesh splinters on the inside of the outmost surface. I want all faces inside cleaned up (deleted), including all polygons with non-manifold edges.\n\n\nQ:\n What would be the most straight forward method (GH components to be used) to achieve such a clean-up?\n\n\nFig 1. This is an example of what can be found inside the outmost surface (A).  B and C are the double (inner) surface and some stray facets, probably caused by bone marrow.\n\n\n\n\nimage.png\n968×520 249 KB\n\n\n\n\nExample mesh to be cleaned up:\n\n\nForum Example Mesh Cleanup 000.3dm\n (3.2 MB)\n\n\nEfter clean up all the holes to be closed.\n\n\nNotice that\n this mesh is exploded, so it would be easy to simply delete all except the top surface, but in most cases the mesh is not separated like this one, so usually the mesh is one whole and the trick is to determine which facets are being part of the external surface, and delete the rest.\n\n\n// Rolf",
  "code_blocks": [
    {
      "code": "import Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext\n\ndef xforms( xside, yside, zside, subindex, xfor, xbak ):\n  '''\n  xside, yside, zside : 1.0 OR -1.0\n  subindex in ( 0, 1, 2 )\n    calc transform, transform-back\n    update xfor, xbak lists\n  '''\n  subside = [ xside, yside, zside ]\n  vec0 = ( Rhino.Geometry.Vector3d.XAxis * xside +\n      Rhino.Geometry.Vector3d.YAxis * yside +\n      Rhino.Geometry.Vector3d.ZAxis * zside ) / 3.0\n  vec0.Unitize()\n  vec1 = [ Rhino.Geometry.Vector3d.XAxis * xside,\n      Rhino.Geometry.Vector3d.YAxis * yside,\n      Rhino.Geometry.Vector3d.ZAxis * zside ][ subindex ]\n  vec2 = vec0 + vec1\n  pla = Rhino.Geometry.Plane.WorldXY\n  plb = Rhino.Geometry.Plane( Rhino.Geometry.Point3d.Origin, vec2 )\n  xfa = Rhino.Geometry.Transform.PlaneToPlane( plb, pla )\n  xfb = Rhino.Geometry.Transform.PlaneToPlane( pla, plb )\n  if not xfa.IsValid:\n    print 'XFA is not valid'\n  if not xfb.IsValid:\n    print 'XFB is not valid'\n  xfor.append( xfa )\n  xbak.append( xfb )\n\ndef purge( pset, xfor, xbak, side, deltaz ):\n# ( unable to make this work )\n# pset = list( xfor.TransformList( pset ) )\n  for ix in range( len( pset ) ):\n    pset[ ix ].Transform( xfor )\n# rs.ObjectColor( rs.AddPoints( pset ), [ 255, 0, 0 ] )\n  pset.sort( key = lambda x: x.Z, reverse = True )\n# for ix in range( len( pset ) ):\n#   print str( pset[ ix ] )\n  hsid = side * 0.5\n  for ix in range( len( pset ) ):\n    pt = pset[ ix ]\n    if not pt:\n      continue\n    xmi = pt.X - hsid\n    xma = pt.X + hsid\n    ymi = pt.Y - hsid\n    yma = pt.Y + hsid\n    zma = pt.Z - deltaz\n    for iy in range( len( pset ) ):\n      pp = pset[ iy ]\n      if not pp:\n        continue\n      if ( ( pp.X > xmi ) and ( pp.X < xma ) and\n          ( pp.Y > ymi ) and ( pp.Y < yma ) and\n          ( pp.Z < zma ) ):\n        pset[ iy ] = None\n  res = []\n  for pt in pset:\n    if pt:\n      res.append( pt )\n  for ix in range( len( res ) ):\n    res[ ix ].Transform( xbak )\n  return res\n\ndef main():\n# get points\n  gids = rs.GetObjects( 'Points ?', filter = 1, preselect = True )\n  pts = [ rs.PointCoordinates( gid ) for gid in gids ]\n# get centroid\n  cen = Rhino.Geometry.Point3d.Origin\n  for pt in pts:\n    cen += pt\n  cen /= len( pts )\n# move to origin\n  for ix in range( len( pts ) ):\n    pts[ ix ] -= cen\n# split into 24 point sets\n  # points\n  pset = []\n  for ix in range( 24 ):\n    pset.append( [] )\n  # transforms\n  xfor = []\n  # back transforms\n  xbak = []\n# build transforms\n# 0 1 2\n  xforms( 1.0, 1.0, 1.0, 0, xfor, xbak )\n  xforms( 1.0, 1.0, 1.0, 1, xfor, xbak )\n  xforms( 1.0, 1.0, 1.0, 2, xfor, xbak )\n# 3 4 5\n  xforms( -1.0, 1.0, 1.0, 0, xfor, xbak )\n  xforms( -1.0, 1.0, 1.0, 1, xfor, xbak )\n  xforms( -1.0, 1.0, 1.0, 2, xfor, xbak )\n# 6 7 8\n  xforms( -1.0, -1.0, 1.0, 0, xfor, xbak )\n  xforms( -1.0, -1.0, 1.0, 1, xfor, xbak )\n  xforms( -1.0, -1.0, 1.0, 2, xfor, xbak )\n# 9 10 11\n  xforms( 1.0, -1.0, 1.0, 0, xfor, xbak )\n  xforms( 1.0, -1.0, 1.0, 1, xfor, xbak )\n  xforms( 1.0, -1.0, 1.0, 2, xfor, xbak )\n# 12 13 14\n  xforms( 1.0, 1.0, -1.0, 0, xfor, xbak )\n  xforms( 1.0, 1.0, -1.0, 1, xfor, xbak )\n  xforms( 1.0, 1.0, -1.0, 2, xfor, xbak )\n# 15 16 17\n  xforms( -1.0, 1.0, -1.0, 0, xfor, xbak )\n  xforms( -1.0, 1.0, -1.0, 1, xfor, xbak )\n  xforms( -1.0, 1.0, -1.0, 2, xfor, xbak )\n# 18 19 20\n  xforms( -1.0, -1.0, -1.0, 0, xfor, xbak )\n  xforms( -1.0, -1.0, -1.0, 1, xfor, xbak )\n  xforms( -1.0, -1.0, -1.0, 2, xfor, xbak )\n# 21 22 23\n  xforms( 1.0, -1.0, -1.0, 0, xfor, xbak )\n  xforms( 1.0, -1.0, -1.0, 1, xfor, xbak )\n  xforms( 1.0, -1.0, -1.0, 2, xfor, xbak )\n# build point sets\n  for pt in pts:\n    ax = abs( pt.X )\n    ay = abs( pt.Y )\n    az = abs( pt.Z )\n# 0 1 2\n    if ( pt.X > 0.0 ) and ( pt.Y > 0.0 ) and ( pt.Z > 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 0 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 0 + 1 ].append( pt )\n      else:\n        pset[ 0 + 2 ].append( pt )\n# 3 4 5\n    elif ( pt.X <= 0.0 ) and ( pt.Y > 0.0 ) and ( pt.Z > 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 3 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 3 + 1 ].append( pt )\n      else:\n        pset[ 3 + 2 ].append( pt )\n# 6 7 8\n    elif ( pt.X <= 0.0 ) and ( pt.Y <= 0.0 ) and ( pt.Z > 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 6 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 6 + 1 ].append( pt )\n      else:\n        pset[ 6 + 2 ].append( pt )\n# 9 10 11\n    elif ( pt.X > 0.0 ) and ( pt.Y <= 0.0 ) and ( pt.Z > 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 9 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 9 + 1 ].append( pt )\n      else:\n        pset[ 9 + 2 ].append( pt )\n# 12 13 14\n    elif ( pt.X > 0.0 ) and ( pt.Y > 0.0 ) and ( pt.Z <= 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 12 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 12 + 1 ].append( pt )\n      else:\n        pset[ 12 + 2 ].append( pt )\n# 15 16 17\n    elif ( pt.X <= 0.0 ) and ( pt.Y > 0.0 ) and ( pt.Z <= 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 15 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 15 + 1 ].append( pt )\n      else:\n        pset[ 15 + 2 ].append( pt )\n# 18 19 20\n    elif ( pt.X <= 0.0 ) and ( pt.Y <= 0.0 ) and ( pt.Z <= 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 18 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 18 + 1 ].append( pt )\n      else:\n        pset[ 18 + 2 ].append( pt )\n# 21 22 23\n    elif ( pt.X > 0.0 ) and ( pt.Y <= 0.0 ) and ( pt.Z <= 0.0 ):\n      if ( ax > ay ) and ( ax > az ):\n        pset[ 21 + 0 ].append( pt )\n      elif ( ay > ax ) and ( ay > az ):\n        pset[ 21 + 1 ].append( pt )\n      else:\n        pset[ 21 + 2 ].append( pt )\n# debug\n# for ix in range( 24 ):\n#   print len( pset[ ix ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 0 ] ), [ 255, 0, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 1 ] ), [ 0, 255, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 2 ] ), [ 0, 0, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 3 ] ), [ 255, 255, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 4 ] ), [ 255, 0, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 5 ] ), [ 0, 255, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 6 ] ), [ 255, 0, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 7 ] ), [ 255, 127, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 8 ] ), [ 255, 127, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 9 ] ), [ 127, 0, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 10 ] ), [ 127, 127, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 11 ] ), [ 127, 0, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 12 ] ), [ 127, 255, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 13 ] ), [ 0, 255, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 14 ] ), [ 127, 255, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 15 ] ), [ 0, 127, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 16 ] ), [ 127, 127, 0 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 17 ] ), [ 0, 127, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 18 ] ), [ 127, 0, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 19 ] ), [ 0, 127, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 20 ] ), [ 127, 127, 255 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 21 ] ), [ 0, 0, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 22 ] ), [ 127, 0, 127 ] )\n# rs.ObjectColor( rs.AddPoints( pset[ 23 ] ), [ 0, 127, 127 ] )\n\n  ppts = []\n  for ix in range( len( pset ) ):\n    ppts.extend( purge( pset[ ix ], xfor[ ix ], xbak[ ix ], 15.0, 5.0 ) )\n    print( '%d / 24' % ix )\n\n# move points back\n  for ix in range( len( ppts ) ):\n    ppts[ ix ] += cen\n# delete original points\n# rs.DeleteObjects( gids )\n# draw purged points\n  rs.AddPoints( ppts )\n\nmain()",
      "language": "python",
      "author": "emilio",
      "post_number": 14,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "mesh",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 2,
  "posts_count": 15,
  "views": 4496
}