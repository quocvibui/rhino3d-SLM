{
  "source_url": "https://github.com/969flash/LausLecture/blob/004c0a8938bf805b8d70c744ddf5eb911fd4277f/Lecture2/utils.py",
  "repo": "969flash/LausLecture",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Lecture2/utils.py",
  "instruction": null,
  "code": "# r: pyshp\n\nimport Rhino.Geometry as geo\nimport shapefile\nimport os\nfrom typing import List, Tuple, Any, Optional\nimport ghpythonlib.components as ghcomp\n\n\nclass Parcel:\n    \"\"\"기본 필지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve],\n    ):\n        self.region = curve_crv  # 외부 경계 커브\n        self.hole_regions = (\n            hole_regions if hole_regions is not None else []\n        )  # 내부 구멍들\n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n    def preprocess_curve(self) -> bool:\n        \"\"\"커브 전처리 (invalid 제거, 자체교차 제거, 단순화)\"\"\"\n        if not self.region or not self.region.IsValid:\n            return False\n\n        # 자체교차 확인\n        intersection_events = geo.Intersect.Intersection.CurveSelf(self.region, 0.001)\n        if intersection_events:\n            simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n            if simplified:\n                self.region = simplified\n            else:\n                return False\n\n        # 일반 단순화\n        simplified = self.region.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n        if simplified:\n            self.region = simplified\n\n        # 내부 구멍들도 처리\n        valid_holes = []\n        for hole in self.hole_regions:\n            if hole and hole.IsValid:\n                simplified_hole = hole.Simplify(geo.CurveSimplifyOptions.All, 0.1, 1.0)\n                if simplified_hole:\n                    valid_holes.append(simplified_hole)\n                else:\n                    valid_holes.append(hole)\n        self.hole_regions = valid_holes\n\n        return True\n\n\nclass Road(Parcel):\n    \"\"\"도로 클래스\"\"\"\n\n    pass\n\n\nclass Lot(Parcel):\n    \"\"\"대지 클래스\"\"\"\n\n    def __init__(\n        self,\n        curve_crv: geo.Curve,\n        pnu: str,\n        jimok: str,\n        record: List[Any],\n        hole_regions: List[geo.Curve] = None,\n    ):\n        super().__init__(curve_crv, pnu, jimok, record, hole_regions)\n        self.is_flag_lot = False  # 자루형 토지 여부\n        self.has_road_access = False  # 도로 접근 여부\n\n\ndef read_shp_file(file_path: str) -> Tuple[List[Any], List[Any], List[str]]:\n    \"\"\"shapefile을 읽어서 shapes와 records를 반환\"\"\"\n    try:\n        sf = shapefile.Reader(file_path, encoding=\"utf-8\")\n    except:\n        try:\n            sf = shapefile.Reader(file_path, encoding=\"cp949\")\n        except:\n            sf = shapefile.Reader(file_path)\n\n    shapes = sf.shapes()\n    records = sf.records()\n    fields = [field[0] for field in sf.fields[1:]]\n    return shapes, records, fields\n\n\ndef get_curve_from_points(\n    points: List[Tuple[float, float]], start_idx: int, end_idx: int\n) -> Optional[geo.PolylineCurve]:\n    \"\"\"점 리스트에서 특정 구간의 커브를 생성\"\"\"\n    # 최소 3개의 점이 필요\n    if end_idx - start_idx < 3:\n        return None\n\n    # 시작과 끝 점이 동일하지 않으면(닫혀있지 않으면) None 반환\n    first_pt = points[start_idx]\n    last_pt = points[end_idx - 1]\n    if first_pt[0] != last_pt[0] or first_pt[1] != last_pt[1]:\n        return None\n\n    curve_points = [\n        geo.Point3d(points[i][0], points[i][1], 0) for i in range(start_idx, end_idx)\n    ]\n\n    curve_crv = geo.PolylineCurve(curve_points)\n    return curve_crv if curve_crv and curve_crv.IsValid else None\n\n\ndef get_part_indices(shape: Any) -> List[Tuple[int, int]]:\n    \"\"\"shape의 각 파트의 시작과 끝 인덱스를 반환\"\"\"\n    if not hasattr(shape, \"parts\") or len(shape.parts) <= 1:\n        return [(0, len(shape.points))]\n\n    parts = list(shape.parts) + [len(shape.points)]\n    return [(parts[i], parts[i + 1]) for i in range(len(shape.parts))]\n\n\ndef get_curves_from_shape(\n    shape: Any,\n) -> Tuple[Optional[geo.PolylineCurve], List[geo.PolylineCurve]]:\n    \"\"\"shape에서 외부 경계와 내부 구멍 커브들을 추출\"\"\"\n    boundary_region = None\n    hole_regions = []\n\n    part_indices = get_part_indices(shape)\n\n    for i, (start_idx, end_idx) in enumerate(part_indices):\n        curve_crv = get_curve_from_points(shape.points, start_idx, end_idx)\n        if curve_crv:\n            if i == 0:\n                boundary_region = curve_crv\n            else:\n                hole_regions.append(curve_crv)\n\n    # 단일 폴리곤이고 닫혀있지 않은 경우 처리\n    if boundary_region is None and len(part_indices) == 1:\n        points = [geo.Point3d(pt[0], pt[1], 0) for pt in shape.points]\n        if len(points) >= 3:\n            if points[0].DistanceTo(points[-1]) > 0.001:\n                points.append(points[0])\n            curve_crv = geo.PolylineCurve(points)\n            if curve_crv and curve_crv.IsValid:\n                boundary_region = curve_crv\n\n    return boundary_region, hole_regions\n\n\ndef get_field_value(\n    record: List[Any], fields: List[str], field_name: str, default: str = \"Unknown\"\n) -> str:\n    \"\"\"레코드에서 특정 필드값을 안전하게 추출\"\"\"\n    try:\n        index = fields.index(field_name)\n        return record[index]\n    except (ValueError, IndexError):\n        return default\n\n\ndef create_parcel_from_shape(\n    shape: Any, record: List[Any], fields: List[str]\n) -> Optional[Parcel]:\n    \"\"\"shape에서 Parcel 객체 생성\"\"\"\n    boundary_region, hole_regions = get_curves_from_shape(shape)\n\n    if not boundary_region or not boundary_region.IsValid:\n        return None\n\n    pnu = get_field_value(record, fields, \"A1\")  # 구 PNU\n    jimok = get_field_value(record, fields, \"A11\")  # 구 JIMOK\n\n    if jimok == \"도로\":\n        parcel = Road(boundary_region, pnu, jimok, record, hole_regions)\n    else:\n        parcel = Lot(boundary_region, pnu, jimok, record, hole_regions)\n\n    return parcel if parcel.preprocess_curve() else None\n\n\ndef get_parcels_from_shapes(\n    shapes: List[Any], records: List[Any], fields: List[str]\n) -> List[Parcel]:\n    \"\"\"모든 shape에서 Parcel 객체들을 생성\"\"\"\n    parcels = []\n\n    for shape, record in zip(shapes, records):\n        parcel = create_parcel_from_shape(shape, record, fields)\n        if parcel:\n            parcels.append(parcel)\n\n    return parcels\n\n\ndef classify_parcels(parcels: List[Parcel]) -> Tuple[List[Lot], List[Road]]:\n    \"\"\"Parcel 리스트를 Lot과 Road로 분류\"\"\"\n    lots = []\n    roads = []\n\n    for parcel in parcels:\n        if isinstance(parcel, Road):\n            roads.append(parcel)\n        else:\n            lots.append(parcel)\n\n    return lots, roads\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}