{
  "source_url": "https://github.com/komotoshunto/RDP-Automatic/blob/680b2cc9081582547d1b37440ec7ea97a94a14ea/%E9%96%A2%E6%95%B0/%E9%9D%A2%E3%81%AB%E6%B2%BF%E3%81%A3%E3%81%A6%E8%90%BD%E3%81%A1%E3%82%8B.py",
  "repo": "komotoshunto/RDP-Automatic",
  "repo_stars": 0,
  "repo_description": "雨水排水計画を自動化するツール",
  "license": "unknown",
  "filepath": "関数/面に沿って落ちる.py",
  "instruction": "Input brep_list, List Access, Brep Landingsurface_list, List Access, Geometry face_normal_vec, List Access, Vector3d",
  "code": "#Input\n#brep_list, List Access, Brep\n#Landingsurface_list, List Access, Geometry\n#face_normal_vec, List Access, Vector3d\n\n#Output\n#surface_list, 各MeshのFaceをSurface化したもの\n#area_list, surface_listの面積\n#locus_list, 雨の軌跡\n#LandingIndex_list, 各Surface化した面の雨が、落ちた先のSurfaceのインデックスを返す\n#LandingSurface_list, \n\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\n\n\n#法線方向から面を流れる方向を求める関数\ndef FlowVector(normal_vec):\n    if normal_vec[2] == 0:\n        z = -1\n    else:\n        z = -1 * ((normal_vec[0]**2 + normal_vec[1]**2)**(1/2))\n    k = (-1) * ((normal_vec[2] * z) / (normal_vec[0]**2 + normal_vec[1]**2))\n    x = normal_vec[0] * k\n    y = normal_vec[1] * k\n    flow_vec = rg.Vector3d(x, y, z)\n    return flow_vec\n\n#surfaceをmesh化させる\ndef MeshFromSurface(surface, edge_length):\n    mesh_list = []\n    param = rg.MeshingParameters()\n    param.MaximumEdgeLength = edge_length\n    param.MinimumEdgeLength = edge_length\n    param.JaggedSeams = True\n    mesh = rg.Mesh.CreateFromBrep(surface, param)\n    return mesh\n\n#屋根面を伝って、降下するpointを返す関数\ndef DescentPoint(center, normal_vec, barriers):\n    flow_vec = FlowVector(normal_vec)\n    projectpoint = ghcomp.ProjectPoint(center, flow_vec, barriers)\n    point = projectpoint[0]\n    return point\n\n#Brepから法線方向に障壁を立ち上げる関数\ndef BarrierFromBrep(Brep, normal_vec):\n    edges = Brep.Edges\n    barriers = []\n    for edge in edges:\n        #「barrier」がそのサーフェス単体の障壁\n        barrier = rg.Surface.CreateExtrusion(edge, normal_vec)\n        barriers.append(barrier)\n    return barriers\n\n#PointをVector方向へ指定の長さ分ずらす\ndef MovePoint(point, vector, length):\n    rg.Vector3d.Unitize(vector)\n    normal = vector * length\n    transform = rg.Transform.Translation(normal)\n    rg.Point3d.Transform(point, transform)\n    return point\n\n#Meshの各FaceをSurface, 重心, 面積を返す関数\ndef SurfaceFromMesh(mesh):\n    surface_list = []\n    centroid_list = []\n    area_list = []\n    edges = ghcomp.FaceBoundaries(mesh)\n    if isinstance(edges, list):\n        for edge in edges:\n            explode = ghcomp.Explode(edge, True)\n            segment = explode[0]\n            if len(segment) == 4:\n                surface = ghcomp.EdgeSurface(segment[0], segment[1], segment[2], segment[3])\n                \n            elif len(segment) == 3:\n                surface = ghcomp.EdgeSurface(segment[0], segment[1], segment[2])\n            surface_list.append(surface)\n            area = ghcomp.Area(surface)\n            area_list.append(area[0])\n            centroid_list.append(area[1])\n    else:\n        explode = ghcomp.Explode(edges, True)\n        segment = explode[0]\n        if len(segment) == 4:\n            surface = ghcomp.EdgeSurface(segment[0], segment[1], segment[2], segment[3])\n        elif len(segment) == 3:\n            surface = ghcomp.EdgeSurface(segment[0], segment[1], segment[2])\n        surface_list.append(surface)\n        area = ghcomp.Area(surface)\n        area_list.append(area[0])\n        centroid_list.append(area[1])\n    return surface_list, centroid_list, area_list\n\n#雨の到着地点とその軌跡を返す関数\ndef RainFlow(point, normal_vec, barriers, LandingSurface_list):\n    moved_point = MovePoint(point, normal_vec, 0.5)\n    descent_point = DescentPoint(moved_point, normal_vec, barriers)\n    projectpoint = ghcomp.ProjectPoint(descent_point, rg.Vector3d(0, 0, -1), LandingSurface_list)\n    project_index = projectpoint[1]\n    \n    #軌跡を表す\n    if projectpoint[1] != -1:\n        locus_end_point = projectpoint[0]\n    else:\n        locus_end_point = rg.Point3d(descent_point[0], descent_point[1], descent_point[2] - 1000)\n    locus_points = [moved_point, descent_point, locus_end_point]\n    locus = rg.Polyline(locus_points)\n    return project_index, locus\n\n\n\nnormal_list = []\nbarriers_list = []\n\n\nsurface_list = []\narea_list = []\ncentroid_list = []\nindex_list = []\n\n\n#brepのタイプはBrepであるが、実際には単一面なのでsurface。\nfor brep_num, brep in enumerate(slope_roof):\n    normal_vec = rs.SurfaceNormal(brep, (0.5, 0.5))\n    normal_list.append(normal_vec)\n    #barriers：そのsurfaceの障壁\n    barriers = BarrierFromBrep(brep, normal_vec)\n    barriers_list.append(barriers)\n    \n    \n    #centroid：そのsurface上にある点群(点群はmesh化した重点)\n    mesh = MeshFromSurface(brep, 1500)\n    surfaces, centroids, areas  = SurfaceFromMesh(mesh)\n    for face_num in range(len(surfaces)):\n        surface_list.append(surfaces[face_num])\n        area_list.append(areas[face_num])\n        centroid_list.append(centroids[face_num])\n        index_list.append(brep_num)\n\n\nsurface_type = [0 for cou1 in range(len(surface_list))]\ncharge_roof_type = [1 for cou2 in range(len(charge_roof))]\nLandingSurface_type = surface_type + charge_roof_type\nLandingSurface_list = surface_list + charge_roof\n\n\nlocus_list = []\nLandingIndex_list = []\nfor num in range(len(LandingSurface_list)):\n    if LandingSurface_type[num] == 0:\n        centroid = centroid_list[num]\n        normal_vec = normal_list[index_list[num]]\n        barriers = barriers_list[index_list[num]]\n        \n        \n        project_index, locus = RainFlow(centroid, normal_vec, barriers, LandingSurface_list)\n        LandingIndex_list.append(project_index)\n        locus_list.append(locus)\n    else:\n        print(1)        \n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}