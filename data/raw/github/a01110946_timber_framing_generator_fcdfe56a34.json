{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_config_builder.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_config_builder.py",
  "instruction": "Config Builder for Grasshopper.",
  "code": "# File: scripts/gh_config_builder.py\n\"\"\"Config Builder for Grasshopper.\n\nBuilds a config_json string from user-friendly Grasshopper inputs. This\ncomponent acts as the single source of truth for pipeline configuration,\nproducing a JSON string consumed by downstream components (Multi-Layer\nSheathing Generator, Framing Generator, etc.).\n\nKey Features:\n1. User-Friendly Configuration\n   - Exposes common settings as individual GH inputs (sliders, panels, toggles)\n   - No need to hand-craft JSON strings\n   - Always produces valid JSON even with zero inputs connected\n\n2. Validation and Defaults\n   - Validates assembly_mode (\"auto\" or \"revit\")\n   - Validates framing_system (\"timber\" or \"cfs\")\n   - Parses and validates JSON sub-objects (assembly_overrides, layer_configs)\n   - Provides sensible defaults for all settings\n\n3. Selective Output\n   - Only includes optional keys when they carry non-default values\n   - Keeps output JSON minimal and readable\n   - Downstream components apply their own defaults for missing keys\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Grasshopper: Component framework and parameter access\n    - json: Serialization of config dictionary\n\nPerformance Considerations:\n    - Lightweight string processing only; negligible execution time\n    - No geometry or heavy computation involved\n\nUsage:\n    1. Place component on canvas; it outputs default config immediately\n    2. Optionally connect a Panel with \"auto\" or \"revit\" to Assembly Mode\n    3. Optionally connect a Panel with \"timber\" or \"cfs\" to Framing System\n    4. Optionally connect assembly_overrides or layer_configs as JSON strings\n    5. Optionally wire a Number Slider to Stud Spacing (inches OC)\n    6. Connect config_json output to downstream components\n\nInput Requirements:\n    Assembly Mode (assembly_mode) - str:\n        Assembly resolution mode: \"auto\" or \"revit\".\n        Required: No (defaults to \"auto\")\n        Access: Item\n        Type Hint: str (set via GH UI)\n\n    Framing System (framing_system) - str:\n        Material system: \"timber\" or \"cfs\".\n        Required: No (defaults to \"timber\")\n        Access: Item\n        Type Hint: str (set via GH UI)\n\n    Assembly Overrides (assembly_overrides) - str:\n        Optional JSON string for per-Wall-Type assembly mappings.\n        Example: {\"Basic Wall - 2x6 Exterior\": \"2x6_exterior\"}\n        Required: No\n        Access: Item\n        Type Hint: str (set via GH UI)\n\n    Faces (faces) - str:\n        Wall faces to process. Provide one or more of:\n        \"exterior\", \"interior\". Each face as a separate list item.\n        Required: No (defaults to [\"exterior\", \"interior\"])\n        Access: List\n        Type Hint: str (set via GH UI)\n\n    Panel Size (panel_size) - str:\n        Default panel size for all layers (e.g., \"4x8\", \"4x10\", \"4x12\").\n        Required: No (defaults to \"4x8\")\n        Access: Item\n        Type Hint: str (set via GH UI)\n\n    Stud Spacing (stud_spacing) - float:\n        Stud spacing in inches on-center (e.g., 16.0, 24.0).\n        Required: No (defaults to 16.0)\n        Access: Item\n        Type Hint: float (set via GH UI)\n\n    Include Functions (include_functions) - str:\n        Layer function filter. Provide one or more of:\n        \"substrate\", \"finish\", \"thermal\". Each as a separate list item.\n        Required: No (defaults to all panelizable functions)\n        Access: List\n        Type Hint: str (set via GH UI)\n\n    Layer Configs (layer_configs) - str:\n        Optional JSON string with per-layer configuration overrides.\n        Keys are layer names, values are config dicts.\n        Example: {\"OSB Sheathing\": {\"panel_size\": \"4x10\"}}\n        Required: No\n        Access: Item\n        Type Hint: str (set via GH UI)\n\nOutputs:\n    Config JSON (config_json) - str:\n        Serialized JSON configuration string for downstream components.\n        Always valid JSON. Minimal keys — only includes non-default values.\n\nTechnical Details:\n    - No geometry output; RhinoCommonFactory not required\n    - No module reloading needed (no project imports)\n    - Always-active component (no run toggle)\n    - Stud spacing is converted from inches to feet in the output JSON\n\nError Handling:\n    - Invalid assembly_mode: warns and falls back to \"auto\"\n    - Invalid framing_system: warns and falls back to \"timber\"\n    - Invalid JSON in assembly_overrides: warns and skips key\n    - Invalid JSON in layer_configs: warns and skips key\n    - Empty/None inputs: silently use defaults\n    - Always outputs valid JSON regardless of input errors\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Grasshopper\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Config Builder\"\nCOMPONENT_NICKNAME = \"ConfBuild\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"0-Config\"\n\n# Allowed values for validated inputs\nVALID_ASSEMBLY_MODES = {\"auto\", \"revit\"}\nVALID_FRAMING_SYSTEMS = {\"timber\", \"cfs\"}\nVALID_FACES = {\"exterior\", \"interior\"}\nVALID_INCLUDE_FUNCTIONS = {\"substrate\", \"finish\", \"thermal\"}\n\n# Defaults\nDEFAULT_ASSEMBLY_MODE = \"auto\"\nDEFAULT_FRAMING_SYSTEM = \"timber\"\nDEFAULT_PANEL_SIZE = \"4x8\"\nDEFAULT_STUD_SPACING_INCHES = 16.0\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message: str, level: str = \"info\") -> None:\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log.\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\".\n    \"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_info(message: str) -> None:\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message: str) -> None:\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message: str) -> None:\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component() -> None:\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1].\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type.\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # NickName becomes the Python variable name — must be valid Python identifier\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        # Index 0\n        (\"Assembly Mode\", \"assembly_mode\",\n         'Assembly resolution mode: \"auto\" or \"revit\" (default: \"auto\")',\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        # Index 1\n        (\"Framing System\", \"framing_system\",\n         'Material system: \"timber\" or \"cfs\" (default: \"timber\")',\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        # Index 2\n        (\"Assembly Overrides\", \"assembly_overrides\",\n         \"Optional JSON for per-Wall-Type assembly mappings\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        # Index 3\n        (\"Faces\", \"faces\",\n         'Wall faces to process (default: exterior + interior)',\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        # Index 4\n        (\"Panel Size\", \"panel_size\",\n         'Default panel size, e.g. \"4x8\", \"4x10\" (default: \"4x8\")',\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        # Index 5\n        (\"Stud Spacing\", \"stud_spacing\",\n         \"Stud spacing in inches OC (default: 16.0)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        # Index 6\n        (\"Include Functions\", \"include_functions\",\n         'Layer function filter: \"substrate\", \"finish\", \"thermal\"',\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        # Index 7\n        (\"Layer Configs\", \"layer_configs\",\n         'Optional per-layer config JSON (e.g. {\"OSB Sheathing\": {\"panel_size\": \"4x10\"}})',\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Config JSON\", \"config_json\",\n         \"Serialized JSON config for downstream components\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef _read_input(index: int, default=None):\n    \"\"\"Read a GH input value by parameter index via VolatileData.\n\n    This approach is more reliable than NickName-based global injection\n    in Rhino 8 CPython, because setup_component() renames NickNames but\n    GH injects globals based on the NickName at solve-start.\n\n    Args:\n        index: Zero-based input parameter index.\n        default: Value to return when the input is empty or missing.\n\n    Returns:\n        The input value, or default if not connected / empty.\n    \"\"\"\n    inputs = ghenv.Component.Params.Input\n    if index >= inputs.Count:\n        return default\n    param = inputs[index]\n    if param.VolatileDataCount == 0:\n        return default\n    all_data = list(param.VolatileData.AllData(True))\n    if not all_data:\n        return default\n    # For list-access params, return full list\n    if param.Access == Grasshopper.Kernel.GH_ParamAccess.list:\n        values = []\n        for goo in all_data:\n            if hasattr(goo, \"Value\"):\n                values.append(goo.Value)\n            elif hasattr(goo, \"ScriptVariable\"):\n                values.append(goo.ScriptVariable())\n        return values if values else default\n    # For item-access params, return single value\n    goo = all_data[0]\n    if hasattr(goo, \"Value\"):\n        return goo.Value\n    if hasattr(goo, \"ScriptVariable\"):\n        return goo.ScriptVariable()\n    return default\n\n\ndef _read_input_list(index: int, default=None):\n    \"\"\"Read a GH list input by parameter index.\n\n    Convenience wrapper around _read_input that always returns a list.\n\n    Args:\n        index: Zero-based input parameter index.\n        default: Value to return when the input is empty or missing.\n\n    Returns:\n        List of input values, or default if not connected / empty.\n    \"\"\"\n    result = _read_input(index, default)\n    if result is None:\n        return default\n    if isinstance(result, (list, tuple)):\n        return list(result)\n    return [result]\n\n\ndef _safe_str(value, default: str = \"\") -> str:\n    \"\"\"Safely convert a value to a stripped string.\n\n    Args:\n        value: Input value (may be None, str, or other type).\n        default: Fallback when value is None or empty.\n\n    Returns:\n        Stripped lowercase string, or default.\n    \"\"\"\n    if value is None:\n        return default\n    s = str(value).strip()\n    return s if s else default\n\n\ndef _parse_json_input(value, input_name: str):\n    \"\"\"Parse a JSON string input, logging warnings on failure.\n\n    Args:\n        value: Raw input value (str or None).\n        input_name: Human-readable name for log messages.\n\n    Returns:\n        Parsed dict, or None if input is empty or invalid.\n    \"\"\"\n    if value is None:\n        return None\n    s = str(value).strip()\n    if not s:\n        return None\n    try:\n        parsed = json.loads(s)\n        if not isinstance(parsed, dict):\n            log_warning(\n                f\"{input_name} must be a JSON object (dict), \"\n                f\"got {type(parsed).__name__}. Ignoring.\"\n            )\n            return None\n        return parsed\n    except json.JSONDecodeError as e:\n        log_warning(f\"Invalid JSON in {input_name}: {e}\")\n        return None\n\n\ndef validate_inputs(assembly_mode_raw, framing_system_raw):\n    \"\"\"Validate user inputs and return cleaned values.\n\n    Checks assembly_mode and framing_system against allowed values.\n    Warns on invalid values and falls back to defaults.\n\n    Args:\n        assembly_mode_raw: Raw assembly mode string from input.\n        framing_system_raw: Raw framing system string from input.\n\n    Returns:\n        tuple: (assembly_mode, framing_system) with validated values.\n    \"\"\"\n    # Validate assembly_mode\n    assembly_mode = _safe_str(assembly_mode_raw, DEFAULT_ASSEMBLY_MODE).lower()\n    if assembly_mode not in VALID_ASSEMBLY_MODES:\n        log_warning(\n            f'Invalid assembly_mode \"{assembly_mode}\". '\n            f\"Expected one of {sorted(VALID_ASSEMBLY_MODES)}. \"\n            f'Falling back to \"{DEFAULT_ASSEMBLY_MODE}\".'\n        )\n        assembly_mode = DEFAULT_ASSEMBLY_MODE\n\n    # Validate framing_system\n    framing_system = _safe_str(framing_system_raw, DEFAULT_FRAMING_SYSTEM).lower()\n    if framing_system not in VALID_FRAMING_SYSTEMS:\n        log_warning(\n            f'Invalid framing_system \"{framing_system}\". '\n            f\"Expected one of {sorted(VALID_FRAMING_SYSTEMS)}. \"\n            f'Falling back to \"{DEFAULT_FRAMING_SYSTEM}\".'\n        )\n        framing_system = DEFAULT_FRAMING_SYSTEM\n\n    return assembly_mode, framing_system\n\n\ndef _clean_faces_list(raw_faces):\n    \"\"\"Clean and validate a faces list input.\n\n    Filters to valid face names and deduplicates. Returns None if\n    the input is empty (so downstream components use their defaults).\n\n    Args:\n        raw_faces: List of face name strings from GH input, or None.\n\n    Returns:\n        Deduplicated list of valid face names, or None if empty.\n    \"\"\"\n    if not raw_faces:\n        return None\n\n    cleaned = []\n    seen = set()\n    for item in raw_faces:\n        face = _safe_str(item).lower()\n        if not face:\n            continue\n        if face not in VALID_FACES:\n            log_warning(\n                f'Ignoring unknown face \"{face}\". '\n                f\"Valid faces: {sorted(VALID_FACES)}\"\n            )\n            continue\n        if face not in seen:\n            cleaned.append(face)\n            seen.add(face)\n\n    return cleaned if cleaned else None\n\n\ndef _clean_include_functions_list(raw_functions):\n    \"\"\"Clean and validate an include_functions list input.\n\n    Filters to valid function names and deduplicates. Returns None if\n    the input is empty (so downstream components process all functions).\n\n    Args:\n        raw_functions: List of function name strings from GH input, or None.\n\n    Returns:\n        Deduplicated list of valid function names, or None if empty.\n    \"\"\"\n    if not raw_functions:\n        return None\n\n    cleaned = []\n    seen = set()\n    for item in raw_functions:\n        func = _safe_str(item).lower()\n        if not func:\n            continue\n        if func not in VALID_INCLUDE_FUNCTIONS:\n            log_warning(\n                f'Ignoring unknown include_function \"{func}\". '\n                f\"Valid functions: {sorted(VALID_INCLUDE_FUNCTIONS)}\"\n            )\n            continue\n        if func not in seen:\n            cleaned.append(func)\n            seen.add(func)\n\n    return cleaned if cleaned else None\n\n\ndef _parse_stud_spacing(raw_value):\n    \"\"\"Parse and validate stud spacing input.\n\n    Args:\n        raw_value: Raw stud spacing value from GH input (float or None).\n\n    Returns:\n        Stud spacing in inches, or None if input is empty / default.\n    \"\"\"\n    if raw_value is None:\n        return None\n\n    try:\n        spacing = float(raw_value)\n    except (TypeError, ValueError):\n        log_warning(\n            f\"Invalid stud_spacing value: {raw_value!r}. \"\n            f\"Expected a number (inches OC). Ignoring.\"\n        )\n        return None\n\n    if spacing <= 0:\n        log_warning(\n            f\"stud_spacing must be positive, got {spacing}. Ignoring.\"\n        )\n        return None\n\n    return spacing\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the Config Builder component.\n\n    Orchestrates the config building workflow:\n    1. Sets up component metadata\n    2. Reads all inputs by index\n    3. Validates constrained inputs (assembly_mode, framing_system)\n    4. Parses JSON sub-inputs (assembly_overrides, layer_configs)\n    5. Builds config dict with only non-default values\n    6. Serializes to JSON string\n\n    Returns:\n        str: Serialized JSON config string. Always valid JSON.\n    \"\"\"\n    setup_component()\n\n    try:\n        # Read all inputs by index (reliable in Rhino 8 CPython)\n        assembly_mode_raw = _read_input(0)       # assembly_mode\n        framing_system_raw = _read_input(1)       # framing_system\n        assembly_overrides_raw = _read_input(2)   # assembly_overrides\n        faces_raw = _read_input_list(3)           # faces (list)\n        panel_size_raw = _read_input(4)           # panel_size\n        stud_spacing_raw = _read_input(5)         # stud_spacing\n        include_functions_raw = _read_input_list(6)  # include_functions (list)\n        layer_configs_raw = _read_input(7)        # layer_configs\n\n        # Validate constrained inputs\n        assembly_mode, framing_system = validate_inputs(\n            assembly_mode_raw, framing_system_raw\n        )\n\n        # Parse JSON sub-inputs\n        assembly_overrides = _parse_json_input(\n            assembly_overrides_raw, \"assembly_overrides\"\n        )\n        layer_configs = _parse_json_input(layer_configs_raw, \"layer_configs\")\n\n        # Clean list inputs\n        faces = _clean_faces_list(faces_raw)\n        include_functions = _clean_include_functions_list(include_functions_raw)\n\n        # Parse scalar inputs\n        panel_size = _safe_str(panel_size_raw) or None\n        stud_spacing = _parse_stud_spacing(stud_spacing_raw)\n\n        # Build config dict — only include keys with non-default / non-None values\n        config = {}\n\n        # Always include assembly_mode and framing_system\n        config[\"assembly_mode\"] = assembly_mode\n        config[\"framing_system\"] = framing_system\n\n        # Optional keys — only included when explicitly provided\n        if assembly_overrides is not None:\n            config[\"assembly_overrides\"] = assembly_overrides\n\n        if faces is not None:\n            config[\"faces\"] = faces\n\n        if panel_size is not None:\n            config[\"panel_size\"] = panel_size\n\n        if stud_spacing is not None:\n            # Convert inches to feet for downstream components\n            config[\"stud_spacing\"] = stud_spacing / 12.0\n\n        if include_functions is not None:\n            config[\"include_functions\"] = include_functions\n\n        if layer_configs is not None:\n            config[\"layer_configs\"] = layer_configs\n\n        # Log summary of what was built\n        log_info(f\"Config Builder {COMPONENT_MESSAGE}\")\n        log_info(f\"  assembly_mode: {assembly_mode}\")\n        log_info(f\"  framing_system: {framing_system}\")\n        if faces is not None:\n            log_info(f\"  faces: {faces}\")\n        if panel_size is not None:\n            log_info(f\"  panel_size: {panel_size}\")\n        if stud_spacing is not None:\n            log_info(f\"  stud_spacing: {stud_spacing} in ({stud_spacing / 12.0:.4f} ft)\")\n        if include_functions is not None:\n            log_info(f\"  include_functions: {include_functions}\")\n        if assembly_overrides is not None:\n            log_info(f\"  assembly_overrides: {len(assembly_overrides)} mappings\")\n        if layer_configs is not None:\n            log_info(f\"  layer_configs: {list(layer_configs.keys())}\")\n\n        config_json_output = json.dumps(config, indent=2)\n        log_info(f\"  Output keys: {list(config.keys())}\")\n\n        return config_json_output\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        print(traceback.format_exc())\n        # Return minimal valid JSON even on error\n        fallback = {\n            \"assembly_mode\": DEFAULT_ASSEMBLY_MODE,\n            \"framing_system\": DEFAULT_FRAMING_SYSTEM,\n        }\n        return json.dumps(fallback, indent=2)\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# No run toggle — this component is always active.\n# No module reload — no project imports to cache.\n# Inputs are read inside main() via _read_input() by index.\n\nif __name__ == \"__main__\":\n    config_json = main()\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}