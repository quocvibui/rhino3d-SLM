{
  "source_url": "https://github.com/TransportLab/smart-city/blob/5cc9f21f594e027086a708275af4519aefd39910/src/python/generate_solid.py",
  "repo": "TransportLab/smart-city",
  "repo_stars": 0,
  "repo_description": "DSI Smart City Installation",
  "license": "unknown",
  "filepath": "src/python/generate_solid.py",
  "instruction": "Generate solid",
  "code": "import sys\nimport os\nimport json5\nimport numpy\nimport matplotlib.pyplot as plt\n# import rhino3dm as r3d\nfrom tqdm import tqdm\nimport tifffile\n\nfrom OCC.Core.TopoDS import TopoDS_Compound\nfrom OCC.Core.BRep import BRep_Builder\nfrom OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeFace\nfrom OCC.Core.GeomAPI import GeomAPI_PointsToBSplineSurface\nfrom OCC.Core.TColgp import TColgp_Array2OfPnt\nfrom OCC.Core.gp import gp_Pnt\nfrom OCC.Core.STEPControl import STEPControl_Writer, STEPControl_AsIs\nfrom OCC.Core.Interface import Interface_Static\n\nwith open('params.json5', 'r') as f:\n    params = json5.load(f)\n\nnx = int(params['model']['width'] / params['model']['pixel_size'])\nny = int(params['model']['height'] / params['model']['pixel_size'])\ndx = params['model']['pixel_size']\n# Assume vertices and faces are defined\n# vertices = [(x1, y1, z1), (x2, y2, z2), ...]\n# faces = [(i1, i2, i3), (i4, i5, i6), ...] - indices in the vertices list\n\n# Initialize a BRep compound\nbuilder = BRep_Builder()\ncompound = TopoDS_Compound()\nbuilder.MakeCompound(compound)\n\nheights = tifffile.imread(f'heights_{nx}_{ny}.tif')\n\ndef make_BRep_OCC(heights):\n    baseplate_height = 0\n\n    # Assuming the elevation array is a 2D numpy array\n    rows, cols = heights.shape\n    points_array = TColgp_Array2OfPnt(1, rows, 1, cols)\n\n    # Create the base plate at a certain depth below your model\n    # base_plate = BRepPrimAPI_MakeBox(-baseplate_height, -baseplate_height, -baseplate_height, rows + 2 * baseplate_height, height + 2 * baseplate_height, baseplate_height).Shape()\n\n    # # Create side walls based on the TIFF dimensions\n    # wall_1 = BRepPrimAPI_MakeBox(0, 0, 0, width, baseplate_height, 50).Shape()  # Front wall\n    # wall_2 = BRepPrimAPI_MakeBox(0, height - baseplate_height, 0, width, baseplate_height, 50).Shape()  # Back wall\n    # wall_3 = BRepPrimAPI_MakeBox(0, 0, 0, baseplate_height, height, 50).Shape()  # Left wall\n    # wall_4 = BRepPrimAPI_MakeBox(width - baseplate_height, 0, 0, baseplate_height, height, 50).Shape()  # Right wall\n\n    # Create a grid of 3D points\n    for i in tqdm(range(rows)):\n        for j in tqdm(range(cols), leave=False):\n            # Create a point with elevation data\n            # Adjust x, y, z coordinates as per your data's spatial reference\n            pnt = gp_Pnt(j, i, heights[i][j])\n            points_array.SetValue(i + 1, j + 1, pnt)\n\n    # Create a B-spline surface from these points\n    bspline_surface = GeomAPI_PointsToBSplineSurface(points_array).Surface()\n\n    # Make a face from this surface\n    face = BRepBuilderAPI_MakeFace(bspline_surface, 1e-6).Face()\n\n    # Now, 'face' contains your BRep model\n    # You can proceed to export this as IGES or STEP\n    # Create a STEP writer\n    step_writer = STEPControl_Writer()\n    Interface_Static.SetCVal(\"write.step.schema\", \"AP203\")\n\n    # Add your face to the STEP writer\n    step_writer.Transfer(face, STEPControl_AsIs)\n\n    # Write the file\n    status = step_writer.Write(f\"heights_{nx}_{ny}.step\")\n\n    if status != 0:\n        print(\"Error: Unable to write STEP file.\")\n    else:\n        print(\"STEP file successfully written.\")\n\n\ndef make_3dm(heights):\n    # Create a new mesh object\n    mesh = r3d.Mesh()\n    # Create points from your 2D array of heights\n    for i, h in tqdm(enumerate(heights.flatten())):\n        j = i % nx\n        # Create a point at (i, j, height)\n        # point = r3d.Point3d(i * dx, j * dx, h)\n        # points.append(point)\n\n        mesh.Vertices.Add(i*dx, j*dx, h*1000)\n\n    # Define faces\n    # This is a simple example assuming you have a grid of points and want to create quad faces\n    # You'll need to adjust this logic based on your specific points and how they're ordered\n    for i in tqdm(range(nx - 1)):  # width is the number of points in the x-direction\n        for j in tqdm(range(ny - 1), leave=False):  # height is the number of points in the y-direction\n            # Calculate the indices of the four corners of the face\n            a = i + j * nx\n            b = (i + 1) + j * nx\n            c = (i + 1) + (j + 1) * nx\n            d = i + (j + 1) * nx\n            mesh.Faces.AddFace(a, b, c, d)\n\n    # Create a surface from the points (assuming a rectangular grid of points)\n    # surface = r3d.NurbsSurface.CreateFromPoints(points, nx, ny, 3, 3, False, False)\n\n    # At this point, 'surface' is a BRep in rhino3dm\n    brep = r3d.Brep.CreateFromMesh(mesh, True)\n\n    # Save your BRep to a 3dm file (Rhino format)\n    model = r3d.File3dm()\n    # model.Objects.AddMesh(mesh)\n    model.Objects.AddBrep(brep)\n    model.Write('model.3dm', 7)\n\n\nif __name__ == '__main__':\n    make_BRep_OCC(heights)\n    # make_3dm(heights)",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}