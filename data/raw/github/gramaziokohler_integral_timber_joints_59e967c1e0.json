{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/debug_scene.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/debug_scene.py",
  "instruction": "Debug scene",
  "code": "import Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext\nimport re\nfrom integral_timber_joints.rhino.process_artist import ProcessArtist\nfrom integral_timber_joints.rhino.load import get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.rhino.assembly_artist import AssemblyNurbsArtist\nfrom integral_timber_joints.process import RobotClampAssemblyProcess\nfrom integral_timber_joints.process import ComputationalResult\nfrom integral_timber_joints.assembly import BeamAssemblyMethod\n\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_mesh\n\ntry:\n    from typing import Dict, List, Optional, Tuple\n\n    from integral_timber_joints.process import RFLPathPlanner\nexcept:\n    pass\n\nfrom compas.geometry import Transformation, Frame\n\ndef get_current_selected_scene_state(self, override_attached_objects_with_fk = True):\n    # type: (ProcessArtist, bool) -> SceneState\n    \"\"\"\n    Return the currently selected SceneState\n\n    if `override_attached_objects_with_fk` is true, and if robot config is defined,\n    the frame of the attached objects will be overridden by the FK result of the robot.\n\n    Note state_id = 1 is referring to end of the first (0) movement.\n    \"\"\"\n    state_id = self.selected_state_id\n    scene = None\n    # Short circuit for returning the initial state.\n    # No override_attached_objects_with_fk will be performed.\n    if state_id == 0:\n        scene =  self.process.initial_state\n        return scene\n\n\n    movement = self.process.movements[state_id - 1]  # type: RoboticMovement\n    scene =  self.process.get_movement_end_scene(movement)\n\n    process = self.process\n    if override_attached_objects_with_fk:\n        if ('robot', 'c') in scene and scene[('robot', 'c')] is not None:\n            print (\"override_attached_objects_with_fk\")\n            from copy import deepcopy\n            scene = deepcopy(scene)\n\n            # * Compute FK\n            configuration = scene[('robot', 'c')]  # type: Configuration\n            fk_flange_frame = process.robot_model.forward_kinematics(configuration.scaled(1000), process.ROBOT_END_LINK)\n            print (fk_flange_frame)\n            t_world_from_flange = Transformation.from_frame(fk_flange_frame)\n\n            # * Set attached objects, use `t_flange_from_attached_objects` in Movement\n            object_id = 'tool_changer'\n            print (object_id)\n            print (scene[(object_id, 'f')])\n            scene[(object_id, 'f')] = fk_flange_frame\n            print (scene[(object_id, 'f')])\n\n            for object_id, t_flange_from_attached_objects in zip(movement.attached_objects, movement.t_flange_from_attached_objects):\n                print (object_id)\n                # print (t_flange_from_attached_objects)\n                print (scene[(object_id, 'f')])\n                t_world_from_object = t_world_from_flange * t_flange_from_attached_objects\n                scene[(object_id, 'f')] = Frame.from_transformation(t_world_from_object)\n                print (scene[(object_id, 'f')])\n\n    return scene\n\nif __name__ == '__main__':\n    process = get_process()\n    artist = get_process_artist()\n    artist.delete_state(redraw=True)\n\n    scene = get_current_selected_scene_state(artist)\n    artist.draw_state(scene=scene, redraw=True)\n    artist.draw_sweep_trajectory(scene=scene, redraw=False)",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}