{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Pedestrian%20Wind%20Comfort.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Pedestrian Wind Comfort.py",
  "instruction": "Use this component to analyse pedestrian wind comfort and safety for the present and potential (newly built) urban environments.\r\nConstruction of a new building changes the wind microclimate in its...",
  "code": "# pedestrian wind comfort\r\n#\r\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\r\n# \r\n# This file is part of Ladybug.\r\n# \r\n# Copyright (c) 2013-2020, Djordje Spasic <djordjedspasic@gmail.com>\r\n# with assistance of Dr. Liam Harrington\r\n# Ladybug is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# Ladybug is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# You should have received a copy of the GNU General Public License\r\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n\r\n\"\"\"\r\nUse this component to analyse pedestrian wind comfort and safety for the present and potential (newly built) urban environments.\r\nConstruction of a new building changes the wind microclimate in its vicinity. These changes can result in either decreased or increased wind speeds around the building, which may be uncomfortable or even dangerous.\r\n-\r\nBased on Lawsons Pedestrian Comfort Criteria (1990)\r\nhttps://www.dropbox.com/s/t9pxhr45vwg2xd2/Wind_Microclimate.pdf?dl=0\r\n-\r\nProvided by Ladybug 0.0.69\r\n    \r\n    input:\r\n        _epwFile: Input an .epw file path by using the \"File Path\" parameter, or Ladybug's \"Open EPW And STAT Weather Files\" component.\r\n        _windFactor: Division of cfd simulation's wind speed values, and annual average wind speed value from the weather data (.epw file) at 10 meters height.\r\n                     They are used to normalize against the weather data (.epw file), given that a CFD simulation with the exact .epw file wind speed and direction has not been performed.\r\n                     -\r\n                     _windFactor data should be supplied into different branches corresponding to different directions for which the cfd simulation has been performed.\r\n                     For example: the first branch holds windFactors for all analysis points for wind direction 0. Second branch would hold windFactors for all analysis points for wind direction 20. Third branch would hold windFactors for all analysis points for wind direction 40 ... and so on.\r\n        _analysisGeometry: Input a mesh for whose face centroids the cfd simulation has been performed.\r\n                           -\r\n                           The number of mesh face centroids needs to be equal to the number of values in each of the _windFactor branches.\r\n        pedestrianType_: Choose the pedestrian type used at the analysis location:\r\n                         0 = typical pedestrian (20 m/s)\r\n                         1 = sensitive pedestrian (15 m/s): elderly people, cyclists, children.\r\n                         -\r\n                         This input is used to analyse pedestrian safety.\r\n                         -\r\n                         If not supplied, the 0 (typical pedestrian) will be used by default.\r\n        northCfd_: Input a vector to be used as a Cfd simulation's true North direction, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis.\r\n                   -\r\n                   If not supplied, default North Cfd direction will be set to the Y-axis (0 degrees).\r\n        north_: Input a vector to be used as Rhino's true North direction, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis.\r\n                -\r\n                If not supplied, default North direction will be set to the Y-axis (0 degrees).\r\n        legendPar_: Optional legend parameters from the Ladybug \"Legend Parameters\" component.\r\n                    -\r\n                    Notice: the \"numSegments_\" and \"customColors_\" inputs of the \"Legend Parameters\" component will only affect the \"legend\" output, not the \"legend2\" output. This is due to \"legend2\" requirement of always having only two values: 0 and 1, representing Safe and Not safe pedestrian safety criteria.\r\n        resultGradient_: Choose whether or not the resulting geometry-values will be created as a gradient-float or not.\r\n                         -\r\n                         It allows the following two inputs:\r\n                         True - the resulting pedestrianComfortMesh, pedestrianSafetyMesh will be created as a gradient, and the pedestrianComfortCategory, pedestrianSafetyCategory will be outputed as float values.\r\n                         False - the resulting pedestrianComfortMesh, pedestrianSafetyMesh will NOT be created as a gradient, and the pedestrianComfortCategory, pedestrianSafetyCategory will be outputed as integer values.\r\n                         -\r\n                         If not supplied, no gradient (integer values) will be set by default.\r\n        analysisPeriod_: An optional analysis period from the \"Analysis Period\" component.\r\n                         -\r\n                         This input can be useful in cases where certain areas show higher pedestrianComfortCategory than required. For example: when analysis is run for the whole year period, the component shows that a certain location does not fulfill the comfort criteria for sitting.\r\n                         However if we perform the analysis for the period from late spring to early autumn (when the sitting is suppose to happen), the comfort criteria for sitting can be fulfilled.\r\n                         -\r\n                         If not supplied, the whole year period will be used as an analysis period.\r\n        annualHourlyData_: An optional list of hourly data from Ladybug's \"Import epw\" component (e.g. windSpeed), which will be used for \"conditionalStatement_\".\r\n        conditionalStatement_: This input allows users to calculate the Pedestrian wind comfort component results only for those annualHourlyData_ values which fit specific conditions or criteria. To use this input correctly, hourly data, such as windSpeed or windDirection, must be plugged into the \"annualHourlyData_\" input. The conditional statement input here should be a valid condition statement in Python, such as \"a>4\" or \"b<90\" (without the quotation marks).\r\n                               conditionalStatement_ accepts \"and\" and \"or\" operators. To visualize the hourly data, English letters should be used as variables, and each letter alphabetically corresponds to each of the lists (in their respective order): \"a\" always represents the 1st list, \"b\" always represents the 2nd list, etc.\r\n                               -\r\n                               For example, if you have an hourly windSpeed connected as the first list, and windDirection connected as the second list (both to the annualHourlyData_ input), and you want to plot the data for the time period when windSpeed is larger than 4m/s and windDirection is southerly, the conditionalStatement_ should be written as \"a>4 and b==180\" (without the quotation marks).\r\n        bakeIt_: Set to \"True\" to bake the pedestrianComfortMesh, pedestrianSafetyMesh, legend, legend2 into the Rhino scene.\r\n                 -\r\n                 If not supplied default value \"False\" will be used.\r\n        _runIt: ...\r\n    \r\n    output:\r\n        readMe!: ...\r\n        pedestrianComfortCategory: Pedestrian wind comfort categories for each face centroid of the _analysisGeometry mesh.\r\n                                   The categories depend on the threshold wind speed for particular point: the wind speed that for 95% of the chosen analysis period is below a certain value. With values being the following:\r\n                                   -\r\n                                   0) < 4 m/s  sitting (outdoor cafes, patios, terraces, benches, gardens, parks, fountains, monuments...)\r\n                                   1) 4-6 m/s  standing (building entrances or exits, bus stops, childrens play areas...)\r\n                                   2) 6-8 m/s  leisurely walking (general areas of walking, strolling and sightseeing, window shopping, public/private sidewalks, pathways, public spaces...)\r\n                                   3) 8-10 m/s  business walking (walking from one place to another quickly, or where individuals pass rapidly through local areas around buildings, public/private vehicular drop-off zones, roads and car parks, cyclists pathways...)\r\n                                   4) > 10 m/s  uncomfortable (uncomfortable for all pedestrian activities)\r\n                                   -\r\n                                   If resultGradient_ input is set to True, then upper mentioned category values will be calculated as floats, instead of integers.\r\n        pedestrianSafetyCategory: Pedestrian wind safety categories for each face centroid of the _analysisGeometry mesh.\r\n                                  -\r\n                                  Infrequent strong wind can cause some pedestrians to have difficulties with walking, to stumble or fall.\r\n                                  The location is safe if these infrequent strong winds appear for only 0.01% of the whole year period, and do not exceed the:\r\n                                  -\r\n                                  20 m/s for typical pedestrians (pedestrianType_ = 0)\r\n                                  15 m/s for sensitive pedestrians (pedestrianType_ = 1): elderly people, cyclists, children\r\n                                  -\r\n                                  So the pedestrian safety categories are the following:\r\n                                  -\r\n                                  0) not safe (upper mentioned wind speeds and its occurrences are exceeded)\r\n                                  1) safe (upper mentioned winds speeds and its occurrences are NOT exceeded)\r\n                                  -\r\n                                  If resultGradient_ input is set to True, then the mentioned category values will be calculated as floats, instead of integers.\r\n        thresholdWindSpeed: Wind speed that for 95% of the chosen analysis period is below the outputted value, for each _analysisGeometry face centroid.\r\n                            It is used to determine the pedestrianComfortCategory output.\r\n                            -\r\n                            In meters/second.\r\n        strongestLocationWindSpeed: The strongest wind speed for the chosen analysis period, for each _analysisGeometry face centroid.\r\n                                    It is used along with pedestrianType_ input to determine the pedestrianSafetyCategory output.\r\n                                    -\r\n                                    In meters/second.\r\n        locationWindSpeed: Wind speed values for each hour during the chosen analysis period, for each _analysisGeometry face centroid.\r\n                           -\r\n                           In meters/second.\r\n        pedestrianComfortMesh: Colored _analysisGeometry mesh in accordance with disposition of the pedestrian wind comfort categories.\r\n                               For explanation of each of the categories, check the upper \"pedestrianComfortCategory\" output.\r\n        pedestrianSafetyMesh: Colored _analysisGeometry mesh. Coloring performed on the basis of whether the pedestrian safety criteria for the chosen location is fulfilled or not.\r\n                              For explanation of each of the categories, check the upper \"pedestrianSafetyCategory\" output.\r\n                              -\r\n                              Green colored areas are locations where the pedestrian safety criteria has been fulfilled.\r\n                              Red colored areas are locations where the pedestrian safety criteria has NOT been fulfilled.\r\n        legend: Legend for the pedestrianComfortMesh and its title.\r\n        legend2: Legend for the pedestrianSafetyMesh and its title.\r\n                 -\r\n                 Red colored areas are locations where the pedestrian safety criteria has NOT been fulfilled.\r\n                 Green colored areas are locations where the pedestrian safety criteria has been fulfilled.\r\n        legendBasePt: Legend base point, which can be used to move the \"legend\" geometry with grasshopper's \"Move\" component.\r\n                      -\r\n                      Connect this output to a Grasshopper's \"Point\" parameter in order to preview the point in the Rhino scene.\r\n        legendBasePt2: Legend2 base point, which can be used to move the \"legend2\" geometry with grasshopper's \"Move\" component.\r\n                      -\r\n                      Connect this output to a Grasshopper's \"Point\" parameter in order to preview the point in the Rhino scene.\r\n\"\"\"\r\n\r\nghenv.Component.Name = \"Ladybug_Pedestrian Wind Comfort\"\r\nghenv.Component.NickName = \"PedestrianWindComfort\"\r\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\nghenv.Component.Category = \"LB-Legacy\"\r\nghenv.Component.SubCategory = \"7 | WIP\"\r\n#compatibleLBVersion = VER 0.0.63\\nJUN_09_2016\r\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\r\nexcept: pass\r\n\r\nimport Grasshopper.Kernel as gh\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Grasshopper\r\nimport System\r\nimport Rhino\r\nimport time\r\nimport math\r\nimport re\r\n\r\n\r\ndef getEpwData(epwFile):\r\n    \r\n    if epwFile:\r\n        try:\r\n            # location data\r\n            locationName, latitude, longitude, timeZone, elevation, locationString = lb_preparation.epwLocation(epwFile)\r\n            # weather data\r\n            weatherData = lb_preparation.epwDataReader(epwFile, locationName)\r\n            dryBulbTemperature, dewPointTemperature, relativeHumidity, windSpeed, windDirection, directNormalRadiation, diffuseHorizontalRadiation, globalHorizontalRadiation, directNormalIlluminance, diffuseHorizontalIlluminance, globalHorizontalIlluminance, totalSkyCover, liquidPrecipitationDepth, barometricPressure, modelYear = weatherData\r\n            \r\n            windSpeedData = windSpeed[7:]\r\n            windDirectionData = windDirection[7:]\r\n            \r\n            validEpwData = True\r\n            printMsg = \"ok\"\r\n            \r\n            return locationName, windSpeedData, windDirectionData, validEpwData, printMsg\r\n        \r\n        except Exception, e:\r\n            # something is wrong with \"_epwFile\" input\r\n            locationName = windSpeedData = windDirectionData = None\r\n            validEpwData = False\r\n            printMsg = \"Something is wrong with \\\"_epwFile\\\" input.\"\r\n    else:\r\n        locationName = windSpeedData = windDirectionData = None\r\n        validEpwData = False\r\n        printMsg = \"Please supply an .epw file path to the \\\"_epwFile\\\" input.\"\r\n    \r\n    return locationName, windSpeedData, windDirectionData, validEpwData, printMsg\r\n\r\n\r\ndef HOYs_from_analysisPeriod(analysisPeriod):\r\n    \r\n    if (len(analysisPeriod) != 0) and (analysisPeriod[0] != None):\r\n        \r\n        startingDate = analysisPeriod[0]\r\n        endingDate = analysisPeriod[1]\r\n        timeStep = 1\r\n        HOYs, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriod, timeStep)\r\n    \r\n    else:  # no \"analysisPeriod_\" inputted. Use the whole year period\r\n        HOYs = range(1,8761)\r\n        analysisPeriod = [(1, 1, 1),(12, 31, 24)]\r\n    \r\n    days = []\r\n    months = []\r\n    hours = []\r\n    for hoy in HOYs:\r\n        d, m, h = lb_preparation.hour2Date(hoy, True)\r\n        days.append(d)\r\n        months.append(m + 1)\r\n        hours.append(h)\r\n    \r\n    startingDate = lb_preparation.hour2Date(lb_preparation.date2Hour(months[0], days[0], hours[0]))\r\n    endingDate = lb_preparation.hour2Date(lb_preparation.date2Hour(months[-1], days[-1], hours[-1]))\r\n    date = startingDate + \" to \" + endingDate\r\n    \r\n    return HOYs, analysisPeriod, date\r\n\r\n\r\ndef checkInputData(windFactor, analysisGeometryMesh, pedestrianType, north, northCfd, resultGradient, analysisPeriod):\r\n    \r\n    if (windFactor.DataCount == 0):  # if an empty data tree inputted into \"_windFactor\". Not if \"None\" inputted into \"_windFactor\"\r\n        windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n        validInputData = False\r\n        printMsg = \"Please supply the data to the \\\"_windFactor\\\" input.\\n\" + \\\r\n                   \"\\\"_windFactor\\\" data should be supplied into different branches corresponding to different directions for which the cfd simulation has been performed.\\n\" + \\\r\n                   \"For example: the first branch holds windFactors for all analysis points for wind direction 0. Second branch would hold windFactors for all analysis points for wind direction 20. Third branch would hold windFactors for all analysis points for wind direction 40 ... and so on.\"\r\n        return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n    \r\n    \r\n    windFactorPaths = windFactor.Paths\r\n    windFactorBranchesLists = windFactor.Branches  # each subList contains windFactors for all points for particular cfd direction\r\n    windFactorBranchesFirstListLength = len(windFactorBranchesLists[0])\r\n    \r\n    windFactorAllBranchesEqualLength = 0\r\n    for windFactorList in windFactorBranchesLists:\r\n        if len(windFactorList) == windFactorBranchesFirstListLength:\r\n            windFactorAllBranchesEqualLength += 1\r\n    if windFactorAllBranchesEqualLength != len(windFactor.Branches):\r\n        windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n        validInputData = False\r\n        printMsg = \"The \\\"_windFactor\\\" data you supplied has unequal number of values in its branches.\\n\" + \\\r\n                   \"Please input the \\\"_windFactor\\\" data with equal number of values in all its branches.\"\r\n        return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n    \r\n    \r\n    if (analysisGeometryMesh == None):\r\n        windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n        validInputData = False\r\n        printMsg = \"Please supply a mesh to the \\\"_analysisGeometry\\\" input.\\n\" + \\\r\n                   \"-\\n\" + \\\r\n                   \"The number of mesh face centroids needs to be equal to the number of values in each of the \\\"_windFactor\\\" branches.\"\r\n        return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n    else:\r\n        faceCentroids = [analysisGeometryMesh.Faces.GetFaceCenter(i) for i in xrange(analysisGeometryMesh.Faces.Count)]\r\n        if len(faceCentroids) != windFactorBranchesFirstListLength:\r\n            windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n            validInputData = False\r\n            printMsg = \"The mesh you supplied to the \\\"_analysisGeometry\\\" input does not have the same number of face centroids as the number of values in each \\\"_windFactor\\\" branches.\\n\" + \\\r\n                       \"Please input a mesh which does.\"\r\n            return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n    \r\n    \r\n    if (pedestrianType == None):\r\n        pedestrianSafetyThreshold = 20  # default, typical pedestrian\r\n        pedestrianTypeLabel = \"typical pedestrian\"\r\n    elif (pedestrianType == 0):\r\n        pedestrianSafetyThreshold = 20  # typical pedestrian\r\n        pedestrianTypeLabel = \"typical pedestrian\"\r\n    elif (pedestrianType == 1):\r\n        pedestrianSafetyThreshold = 15  # sensitive pedestrians (elderly people, cyclists, children)\r\n        pedestrianTypeLabel = \"sensitive pedestrian\"\r\n    elif (pedestrianType < 0) or (pedestrianType > 1):\r\n        pedestrianSafetyThreshold = 20  # default, typical pedestrian\r\n        pedestrianTypeLabel = \"typical pedestrian\"\r\n        printMsg = \"The \\\"pedestrianType_\\\" input can only take \\\"0\\\" or \\\"1\\\" as inputs.\\n\" + \\\r\n                   \"\\\"pedestrianType_\\\" input set to \\\"0\\\" (typical pedestrian).\"\r\n    \r\n    \r\n    if (north == None):\r\n        northRad = 0  # default, in radians\r\n        northVec = Rhino.Geometry.Vector3d(0,1,0)\r\n    else:\r\n        try:  # check if it's a number\r\n            north = float(north)\r\n            if north < 0 or north > 360:\r\n                windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n                validInputData = False\r\n                printMsg = \"Please input north angle value from 0 to 360.\"\r\n                return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n        except Exception, e:  # check if it's a vector\r\n            north.Unitize()\r\n        \r\n        northRad, northVec = lb_photovoltaics.angle2northClockwise(north)\r\n    northVec.Unitize()\r\n    northD = 360-math.degrees(northRad)\r\n    if northD == 360: northD = 0\r\n    \r\n    \r\n    if (northCfd == None):\r\n        northCfdRad = 0  # default, in radians\r\n        northCfdVec = Rhino.Geometry.Vector3d(0,1,0)\r\n    else:\r\n        try:  # check if it's a number\r\n            northCfd = float(northCfd)\r\n            if northCfd < 0 or northCfd > 360:\r\n                windFactorsPerPointLL = analysisGeometryMesh = cfdSimulationDirections = pedestrianSafetyThreshold = pedestrianTypeLabel = northCfdD = northD = resultGradient = HOYs = analysisPeriod = date = None\r\n                validInputData = False\r\n                printMsg = \"Please input northCfd angle value from 0 to 360.\"\r\n                return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n        except Exception, e:  # check if it's a vector\r\n            northCfd.Unitize()\r\n        \r\n        northCfdRad, northCfdVec = lb_photovoltaics.angle2northClockwise(northCfd)\r\n    northCfdVec.Unitize()\r\n    northCfdD = 360-math.degrees(northCfdRad)\r\n    if northCfdD == 360: northCfdD = 0\r\n    \r\n    \r\n    if (resultGradient == None):\r\n        resultGradient = True  # default\r\n    \r\n    \r\n    HOYs, analysisPeriod, date = HOYs_from_analysisPeriod(analysisPeriod)\r\n    \r\n    \r\n    cfdSimulationDirections = []  # directions for which cfd simulation has been conducted and from it the _windFactors branches created\r\n    startingCfdSimulationDirection = 0\r\n    cfdSimulationDirectionStep = 360/len(windFactor.Branches)\r\n    for i in range(len(windFactor.Branches)):\r\n        cfdSimulationDirections.append(startingCfdSimulationDirection)\r\n        startingCfdSimulationDirection += cfdSimulationDirectionStep\r\n    \r\n    \r\n    # create windFactors for each point in a single list\r\n    windFactorsPerPointLL = [[] for i in range(len(windFactorBranchesLists[0]))]\r\n    for i in range(len(windFactorBranchesLists[0])):\r\n        for k in range(len(windFactorBranchesLists)):\r\n            windFactorsPerPointLL[i].append(windFactorBranchesLists[k][i])\r\n    \r\n    \r\n    validInputData = True\r\n    printMsg = \"ok\"\r\n    \r\n    return windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg\r\n\r\n\r\ndef checkAnnualHourlyInputData(annualHourlyData):\r\n    \r\n    if annualHourlyData == []:\r\n        annualHourlyDataLists = []\r\n        annualHourlyDataListsEpwNames = []\r\n        validAnnualHourlyData = True\r\n        printMsg = \"ok\"\r\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\r\n    elif len(annualHourlyData) % 8767 != 0:\r\n        annualHourlyDataLists = annualHourlyDataListsEpwNames = None\r\n        validAnnualHourlyData = False\r\n        printMsg = \"Your annualHourlyData_ input is not correct. Please input complete 8767 items long list(s) from \\\"Ladybug_Import epw\\\" component\"\r\n        return annualHourlyDataLists, validAnnualHourlyData, annualHourlyDataListsEpwNames, printMsg\r\n    else:\r\n        annualHourlyDataLists = []\r\n        annualHourlyDataListsEpwNames = []\r\n        startIndex = 0\r\n        endIndex = 8767\r\n        for i in range(int(len(annualHourlyData)/8767)):\r\n            untrimmedList = annualHourlyData[startIndex:endIndex]\r\n            trimmedList = untrimmedList[7:]\r\n            annualHourlyDataListsName = untrimmedList[2]\r\n            annualHourlyDataLists.append(trimmedList)\r\n            annualHourlyDataListsEpwNames.append(annualHourlyDataListsName)\r\n            startIndex += 8767\r\n            endIndex += 8767\r\n        \r\n        validAnnualHourlyData = True\r\n        printMsg = \"ok\"\r\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\r\n\r\n\r\ndef checkConditionalStatement(conditionalStatement, annualHourlyDataLists, annualHourlyDataListsEpwNames, weatherPerHourDataSubLists, addZero):\r\n    \r\n    if conditionalStatement == None and len(annualHourlyDataLists) > 0: # conditionalStatement_ not inputted, annualHourlyData_ inputted\r\n        validConditionalStatement = False\r\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\r\n        printMsg = \"Please supply \\\"conditionalStatement_\\\" for inputted \\\"annualHourlyData_\\\" data.\"\r\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n    elif conditionalStatement == None and len(annualHourlyDataLists) == 0:  # conditionalStatement_ not inputted, annualHourlyData_ not inputted\r\n        conditionalStatement = \"True\"\r\n    else:  # conditionalStatement_ inputted, annualHourlyData_ not\r\n        if annualHourlyDataLists == []:\r\n            validConditionalStatement = False\r\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\r\n            printMsg = \"Please supply \\\"annualHourlyData_\\\" data for inputted \\\"conditionalStatement_\\\".\"\r\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n        else:  # both conditionalStatement_ and annualHourlyData_ inputted\r\n            conditionalStatement = conditionalStatement.lower()\r\n            conditionalStatement = re.sub(r\"\\b([a-z])\\b\", r\"\\1[i]\", conditionalStatement)\r\n    \r\n    annualHourlyDataListsNames = map(chr, range(97, 123))\r\n    \r\n    # finalPrint conditonal statements for \"printOutput\" function\r\n    if conditionalStatement != \"True\":  # conditionalStatement_ not inputted\r\n        # replace conditionalStatement annualHourlyDataListsNames[i] names with annualHourlyDataListsEpwNames:\r\n        conditionalStatementForFinalPrint = conditionalStatement[:]\r\n        for i in range(len(annualHourlyDataLists)):\r\n            conditionalStatementForFinalPrint = conditionalStatementForFinalPrint.replace(annualHourlyDataListsNames[i]+\"[i]\", annualHourlyDataListsEpwNames[i])\r\n    else:\r\n        conditionalStatementForFinalPrint = \"No condition\"\r\n    \r\n    annualHourlyDataListsNames = map(chr, range(97, 123))\r\n    numberOfLetters = 0\r\n    \r\n    for letter in annualHourlyDataListsNames:\r\n        changedLetter = letter+\"[i]\"\r\n        if changedLetter in conditionalStatement:\r\n            numberOfLetters += 1\r\n    if numberOfLetters > len(annualHourlyDataLists):\r\n        validConditionalStatement = False\r\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\r\n        printMsg = \"The number of a,b,c... variables you supplied in \\\"conditionalStatement_\\\" is larger than the number of \\\"annualHourlyData_\\\" lists you inputted. Please make the numbers of these two equal or less.\"\r\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n    else:\r\n        for i in range(len(annualHourlyDataLists)):\r\n            exec(\"%s = %s\" % (annualHourlyDataListsNames[i],annualHourlyDataLists[i]))\r\n        \r\n        try:\r\n            weatherPerHourDataConditionalStatementSubLists = []\r\n            for i in range(len(weatherPerHourDataSubLists)):\r\n                weatherPerHourDataConditionalStatementSubLists.append([])\r\n            for i in range(len(weatherPerHourDataSubLists[0])):\r\n                exec(\"conditionalSt = %s\" % conditionalStatement)\r\n                if addZero == True:  # add 0 if conditionalStatement == False\r\n                    if conditionalSt:\r\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\r\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\r\n                    else:\r\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\r\n                            weatherPerHourDataConditionalStatementSubLists[k].append(0)\r\n                else:  # skip the value\r\n                    if conditionalSt:\r\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\r\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\r\n        except Exception, e:\r\n            validConditionalStatement = False\r\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\r\n            printMsg = \"Your \\\"conditionalStatement_\\\" is incorrect. Please provide a valid conditional statement in Python, such as \\\"a>25 and b<80\\\" (without the quotation marks)\"\r\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n        \r\n        if len(weatherPerHourDataConditionalStatementSubLists[0]) == 0:\r\n            validConditionalStatement = False\r\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\r\n            printMsg = \"No \\\"annualHourlyData_\\\" coresponds to \\\"conditionalStatement_\\\". Please edit your \\\"conditionalStatement_\\\"\"\r\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n        else:\r\n            validConditionalStatement = True\r\n            printMsg = \"ok\"\r\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\r\n\r\n\r\ndef correctEpwWindDirection(cfdSimulationDirections, epwWindDirection):\r\n    # correct the \"windDirectionsData\" according to the \"cfdSimulationDirections\"\r\n    # the first closer value will always be used (e.g. epwWindDirection = 30, cfdSimulationDirections = [0,60...], closestEpwWindDirection = 0\r\n    \r\n    difference = []\r\n    for index,cfdSimulationDir in enumerate(cfdSimulationDirections):\r\n        if (epwWindDirection < 90) and (cfdSimulationDir > 270): cfdSimulationDir = abs(360-cfdSimulationDir)  # if 0 to 90 epwWindDirection is closer to 270 to 360 degrees than 0 to 90 degrees\r\n        difference.append([abs(epwWindDirection-cfdSimulationDir),index])\r\n    difference.sort()\r\n    \r\n    closestEpwWindDirection = cfdSimulationDirections[difference[0][1]]\r\n    if (closestEpwWindDirection == 360) and (0 in cfdSimulationDirections):\r\n        closestEpwWindDirection = 0\r\n    \r\n    return closestEpwWindDirection\r\n\r\n\r\ndef percentile(listOfValues, percent, key=lambda x:x):\r\n    # by Wai Yip Tung\r\n    # http://code.activestate.com/recipes/511478\r\n    \r\n    k = (len(listOfValues)-1) * percent\r\n    f = math.floor(k)\r\n    c = math.ceil(k)\r\n    if f == c:\r\n        return key(listOfValues[int(k)])\r\n    d0 = key(listOfValues[int(f)]) * (c-k)\r\n    d1 = key(listOfValues[int(c)]) * (k-f)\r\n    \r\n    return d0+d1\r\n\r\n\r\ndef choosePedestrianComfortCategory(windSpeed95percentPerYear):\r\n    \r\n    if (windSpeed95percentPerYear < 4):\r\n        pedestrianComfortCategoryInt_perPoint = 0\r\n        pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 3\r\n        if pedestrianComfortCategoryFloat_perPoint < 0: pedestrianComfortCategoryFloat_perPoint = 0\r\n    elif (windSpeed95percentPerYear >= 4) and (windSpeed95percentPerYear < 6):\r\n        pedestrianComfortCategoryInt_perPoint = 1\r\n        if windSpeed95percentPerYear <= 5:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 3\r\n        elif windSpeed95percentPerYear < 6:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 4\r\n    elif (windSpeed95percentPerYear >= 6) and (windSpeed95percentPerYear < 8):\r\n        pedestrianComfortCategoryInt_perPoint = 2\r\n        if windSpeed95percentPerYear <= 7:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 4\r\n        elif windSpeed95percentPerYear < 8:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 5\r\n    elif (windSpeed95percentPerYear >= 8) and (windSpeed95percentPerYear < 10):\r\n        pedestrianComfortCategoryInt_perPoint = 3\r\n        if windSpeed95percentPerYear <= 9:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 5\r\n        elif windSpeed95percentPerYear < 10:\r\n            pedestrianComfortCategoryFloat_perPoint = windSpeed95percentPerYear - 6\r\n    elif (windSpeed95percentPerYear >= 10):\r\n        pedestrianComfortCategoryInt_perPoint = 4\r\n        pedestrianComfortCategoryFloat_perPoint = 4.0\r\n    \r\n    return pedestrianComfortCategoryInt_perPoint, pedestrianComfortCategoryFloat_perPoint\r\n\r\n\r\ndef main(windSpeedData, windDirectionData, windFactorsPerPointLL, outputLocationWindSpeed, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, northCfdD, northD, resultGradient, HOYs, analysisPeriod):\r\n    \r\n    # correct the cfdSimulationDirections for the inputted \"northCfd_\"\r\n    cfdSimulationDirections_corrected = []\r\n    for cfdWindDirection in cfdSimulationDirections:\r\n        correctedCfdWindDirection, northDegDummy, validNorthDummy, printMsgDummy = lb_photovoltaics.correctSrfAzimuthDforNorth(northCfdD, cfdWindDirection)\r\n        cfdSimulationDirections_corrected.append(correctedCfdWindDirection)\r\n    \r\n    # correct the cfdSimulationDirections for the inputted \"northCfd_\"\r\n    cfdSimulationDirections_corrected_forWindDirectionData_corrected2 = []\r\n    for cfdWindDirection2 in cfdSimulationDirections:\r\n        correctedCfdWindDirection, northDegDummy, validNorthDummy, printMsgDummy = lb_photovoltaics.correctSrfAzimuthDforNorth(northCfdD, cfdWindDirection2)\r\n        cfdSimulationDirections_corrected_forWindDirectionData_corrected2.append(correctedCfdWindDirection)\r\n    if 360 not in cfdSimulationDirections_corrected_forWindDirectionData_corrected2:\r\n        cfdSimulationDirections_corrected_forWindDirectionData_corrected2.append(360+northCfdD)  # add 360, so that \"windDirectionData\" values closer to 360 will be corrected to 360, and then set to 0, if there are both 0 and 360 in \"cfdSimulationDirections\"\r\n    \r\n    \r\n    # correct the .epw windDirectionData for the inputted \"north_\"\r\n    windDirectionData_corrected = []\r\n    for epwWindDirection in windDirectionData:\r\n        correctedEpwWindDirection, northDegDummy, validNorthDummy, printMsgDummy = lb_photovoltaics.correctSrfAzimuthDforNorth(northD, epwWindDirection)\r\n        windDirectionData_corrected.append(correctedEpwWindDirection)\r\n    \r\n    \r\n    # correct (simplify) the .epw windDirectionData for the cfdSimulationDirections\r\n    windDirectionData_corrected2 = []  \r\n    for epwWindDirection2 in windDirectionData_corrected:\r\n        correctedEpwWindDirection2 = correctEpwWindDirection(cfdSimulationDirections_corrected_forWindDirectionData_corrected2, epwWindDirection2)\r\n        windDirectionData_corrected2.append(correctedEpwWindDirection2)\r\n    \r\n    \r\n    \r\n    # correct epw windSpeed with windFactor for each point\r\n    windSpeedDataPerPointDataTree_corrected = Grasshopper.DataTree[object]()  # \"locationWindSpeed\" output\r\n    header = [\"key:location/dataType/units/frequency/startsAt/endsAt\", \"%s\" % locationName, \"Location's wind speed\", \"m/s\", \"Hourly\", analysisPeriod[0], analysisPeriod[1]]\r\n    \r\n    \"\"\"\r\n    # option 1 (slower)\r\n    windSpeedDataPerPointLL_corrected = []\r\n    for pointIndex, windFactorsPerPointL in enumerate(windFactorsPerPointLL):  # iterrate through each point\r\n        windSpeedDataPerPoint_corrected = []\r\n        for hoy in HOYs:\r\n            hoyIndex = hoy - 1\r\n            for cfdDirIndex,correctedCfdWindDirection in enumerate(cfdSimulationDirections_corrected):\r\n                correctedEpwWindDirection2 = windDirectionData_corrected2[hoyIndex]\r\n                if (correctedEpwWindDirection2 == correctedCfdWindDirection):\r\n                    correctedEpwWindSpeed = windSpeedData[hoyIndex] * windFactorsPerPointL[cfdDirIndex]  # \"locationWindSpeed\" output hourly value\r\n                    windSpeedDataPerPoint_corrected.append(correctedEpwWindSpeed)\r\n                    break\r\n        windSpeedDataPerPointLL_corrected.append(windSpeedDataPerPoint_corrected)\r\n        if outputLocationWindSpeed:\r\n            path = Grasshopper.Kernel.Data.GH_Path(pointIndex)\r\n            windSpeedDataPerPointDataTree_corrected.AddRange(header + windSpeedDataPerPoint_corrected, path)\r\n    \"\"\"\r\n    \r\n    # option 2 (faster)\r\n    cfdSimulationDirections_corrected_dict = {correctedCfdWindDirection:cfdDirIndex for cfdDirIndex,correctedCfdWindDirection in enumerate(cfdSimulationDirections_corrected)}\r\n    \r\n    windSpeedDataPerPointLL_corrected = [[windSpeedData[hoy - 1] * windFactorsPerPointL[cfdSimulationDirections_corrected_dict[windDirectionData_corrected2[hoy-1]]]\r\n         for hoy in HOYs]\r\n     for windFactorsPerPointL in windFactorsPerPointLL]\r\n    \r\n    \r\n    if outputLocationWindSpeed:\r\n        path = Grasshopper.Kernel.Data.GH_Path(pointIndex)\r\n        windSpeedDataPerPointDataTree_corrected.AddRange(header + windSpeedDataPerPoint_corrected, path)\r\n    \r\n    \r\n    \r\n    # Lawson's comfort and safety assessment criteria (1990)\r\n    pedestrianComfortCategoryInt_forAllPoints = []\r\n    pedestrianComfortCategoryFloat_forAllPoints = []\r\n    pedestrianSafetyInt_forAllPoints = []\r\n    pedestrianSafetyFloat_forAllPoints = []\r\n    windSpeed95percentPerYear_forAllPoints = []\r\n    strongestLocationWindSpeed_forAllPoints = []\r\n    for windSpeedDataPerPoint_corrected in windSpeedDataPerPointLL_corrected:\r\n        # pedestrian comfort\r\n        windSpeedDataPerPoint_corrected.sort()\r\n        windSpeed95percentPerYear = percentile(windSpeedDataPerPoint_corrected, 0.95)  # \"windSpeed95percentPerYear\" is threshold wind speed for particular point, in m/s\r\n        pedestrianComfortCategoryInt_perPoint, pedestrianComfortCategoryFloat_perPoint = choosePedestrianComfortCategory(windSpeed95percentPerYear)\r\n        windSpeed95percentPerYear_forAllPoints.append(windSpeed95percentPerYear)\r\n        pedestrianComfortCategoryInt_forAllPoints.append(pedestrianComfortCategoryInt_perPoint)\r\n        pedestrianComfortCategoryFloat_forAllPoints.append(pedestrianComfortCategoryFloat_perPoint)\r\n        \r\n        # pedestrian safety\r\n        if (windSpeedDataPerPoint_corrected[-1] > pedestrianSafetyThreshold):  # check if pedestrianSafetyThreshold wind speed appeared at least 0.011% during the chosen analysis period\r\n            pedestrianSafetyInt_perPoint = 0  # False\r\n            pedestrianSafetyFloat_perPoint = 0.0  # False\r\n        else:\r\n            pedestrianSafetyInt_perPoint = 1  # True\r\n            pedestrianSafetyFloat_perPoint = 1-(windSpeedDataPerPoint_corrected[-1]/pedestrianSafetyThreshold)  # True\r\n        pedestrianSafetyInt_forAllPoints.append(pedestrianSafetyInt_perPoint)\r\n        pedestrianSafetyFloat_forAllPoints.append(pedestrianSafetyFloat_perPoint)\r\n        strongestLocationWindSpeed_forAllPoints.append(windSpeedDataPerPoint_corrected[-1])\r\n    \r\n    if resultGradient == True:\r\n        pedestrianComfortCategory_forAllPoints = pedestrianComfortCategoryFloat_forAllPoints\r\n        pedestrianSafety_forAllPoints = pedestrianSafetyFloat_forAllPoints\r\n    elif resultGradient == False:\r\n        pedestrianComfortCategory_forAllPoints = pedestrianComfortCategoryInt_forAllPoints\r\n        pedestrianSafety_forAllPoints = pedestrianSafetyInt_forAllPoints\r\n    \r\n    \r\n    return windSpeedDataPerPointDataTree_corrected, windSpeed95percentPerYear_forAllPoints, strongestLocationWindSpeed_forAllPoints, pedestrianComfortCategory_forAllPoints, pedestrianSafety_forAllPoints\r\n\r\n\r\ndef createGeometry(legendPar, locationName, analysisGeometryMesh, pedestrianTypeLabel, pedestrianComfortCategory_forAllPoints, pedestrianSafety_forAllPoints, northCfdD, northD, resultGradient, date):\r\n    \r\n    # extract data from \"legendPar_\" input\r\n    if len(legendPar) == 0:\r\n        lowB = \"min\"; highB = \"max\"; legendBasePt = None; legendScale = 1; legendFont = None; legendFontSize = None; legendBold = None; decimalPlaces = 2; removeLessThan = False\r\n        \r\n        # define the colors according to present pedestrian category values in pedestrianComfortCategory_forAllPoints\r\n        unique_pedestrianComfortCategory_forAllPoints = list(set(pedestrianComfortCategory_forAllPoints))\r\n        customColors = []\r\n        for categoryNumber in unique_pedestrianComfortCategory_forAllPoints:\r\n            if int(categoryNumber) == 4:\r\n                customColors.append(System.Drawing.Color.FromArgb(75,107,169))  # sitting\r\n                customColors.append(System.Drawing.Color.FromArgb(176,203,237))  # standing\r\n                customColors.append(System.Drawing.Color.FromArgb(249,235,89))  # leisurely walking\r\n                customColors.append(System.Drawing.Color.FromArgb(235,131,5))  # business walking\r\n                customColors.append(System.Drawing.Color.FromArgb(234,38,0))  # uncomfortable\r\n                break\r\n        else:\r\n            for categoryNumber in unique_pedestrianComfortCategory_forAllPoints:\r\n                if int(categoryNumber) == 3:\r\n                    customColors.append(System.Drawing.Color.FromArgb(75,107,169))  # sitting\r\n                    customColors.append(System.Drawing.Color.FromArgb(176,203,237))  # standing\r\n                    customColors.append(System.Drawing.Color.FromArgb(249,235,89))  # leisurely walking\r\n                    customColors.append(System.Drawing.Color.FromArgb(235,131,5))  # business walking\r\n                    break\r\n            else:\r\n                for categoryNumber in unique_pedestrianComfortCategory_forAllPoints:\r\n                    if int(categoryNumber) == 2:\r\n                        customColors.append(System.Drawing.Color.FromArgb(75,107,169))  # sitting\r\n                        customColors.append(System.Drawing.Color.FromArgb(176,203,237))  # standing\r\n                        customColors.append(System.Drawing.Color.FromArgb(249,235,89))  # leisurely walking\r\n                        break\r\n                else:\r\n                    for categoryNumber in unique_pedestrianComfortCategory_forAllPoints:\r\n                        if int(categoryNumber) == 1:\r\n                            customColors.append(System.Drawing.Color.FromArgb(75,107,169))  # sitting\r\n                            customColors.append(System.Drawing.Color.FromArgb(176,203,237))  # standing\r\n                            break\r\n                    else:\r\n                        for categoryNumber in unique_pedestrianComfortCategory_forAllPoints:\r\n                            if int(categoryNumber) == 0:\r\n                                customColors.append(System.Drawing.Color.FromArgb(75,107,169))  # sitting\r\n                                customColors.append(System.Drawing.Color.FromArgb(176,203,237))  # standing\r\n                                break\r\n        \r\n        numSeg = len(customColors)\r\n        legendPar = [lowB, highB, numSeg, customColors, legendBasePt, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan]\r\n    else:\r\n        lowB, highB, numSeg, customColors, legendBasePt, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\r\n    # always used for legend2:\r\n    numSeg2 = 2; lowB2 = \"min\"; highB2 = \"max\";\r\n    customColors2 = [System.Drawing.Color.FromArgb(255,0,0), System.Drawing.Color.FromArgb(42,182,64)]\r\n    # fix in case all values in the \"pedestrianSafety_forAllPoints\" are 1 (in case resultGradient == False), or > 0 (in case resultGradient == True):\r\n    numberOfSafePoints = [math.ceil(item) for item in pedestrianSafety_forAllPoints if math.ceil(item) == 1]\r\n    if len(numberOfSafePoints) == len(pedestrianSafety_forAllPoints):  # all points are safe (have value: 1)\r\n        customColors2 = [System.Drawing.Color.FromArgb(42,182,64), System.Drawing.Color.FromArgb(255,0,0)]\r\n    \r\n    # color the analysisGeometryMesh to pedestrianComfortMesh\r\n    pedestrianComfortCategory_colors = lb_visualization.gradientColor(pedestrianComfortCategory_forAllPoints, lowB, highB, customColors)\r\n    pedestrianComfortMesh = lb_visualization.colorMesh(pedestrianComfortCategory_colors, analysisGeometryMesh)\r\n    \r\n    # color the analysisGeometryMesh to pedestrianSafetyMesh\r\n    pedestrianSafety_colors = lb_visualization.gradientColor(pedestrianSafety_forAllPoints, lowB, highB, customColors2)\r\n    pedestrianSafetyMesh = lb_visualization.colorMesh(pedestrianSafety_colors, analysisGeometryMesh)\r\n    \r\n    # move the pedestrianSafetyMesh below from the pedestrianComfortMesh\r\n    lb_visualization.calculateBB([analysisGeometryMesh])\r\n    pedestrianComfortMesh_bottomLeftPt = lb_visualization.BoundingBoxPar[5]\r\n    pedestrianSafetyMesh_bottomLeftPt = Rhino.Geometry.Point3d(pedestrianComfortMesh_bottomLeftPt.X, pedestrianComfortMesh_bottomLeftPt.Y-(2*lb_visualization.BoundingBoxPar[2]), pedestrianComfortMesh_bottomLeftPt.Z)\r\n    transformMatrix = Rhino.Geometry.Transform.PlaneToPlane(Rhino.Geometry.Plane(pedestrianComfortMesh_bottomLeftPt, Rhino.Geometry.Vector3d(0,0,1)), Rhino.Geometry.Plane(pedestrianSafetyMesh_bottomLeftPt, Rhino.Geometry.Vector3d(0,0,1)))\r\n    pedestrianSafetyMesh.Transform(transformMatrix)\r\n    \r\n    \r\n    # titlePedestrianComfort\r\n    if legendFont == None: legendFont = \"Verdana\"\r\n    if legendFontSize == None: legendFontSize = ((lb_visualization.BoundingBoxPar[2]/10)/3) * legendScale\r\n    legendFontSize = legendFontSize * 1.2  # enlarge the title font size 1.2 times of the legend font size\r\n    \r\n    titleLabelOrigin = lb_visualization.BoundingBoxPar[5]\r\n    titleLabelOrigin.Y = titleLabelOrigin.Y - (lb_visualization.BoundingBoxPar[2]/10)*legendScale  # (height2d_ofBB/10)*legendScale\r\n    titleLabelText = \"Pedestrian wind comfort: %s\\nResult gradient: %s, northCfd: %s, north: %s\\n%s\" % (locationName, resultGradient, northCfdD, northD, date)\r\n    titleLabelMeshes = lb_visualization.text2srf([titleLabelText], [titleLabelOrigin], legendFont, legendFontSize*1.2, legendBold, None, 6)[0]\r\n    titleDescriptionLabelMeshes = titleLabelMeshes\r\n    \r\n    # titlePedestrianSafety\r\n    titleLabelOrigin2 = Rhino.Geometry.Point3d(pedestrianSafetyMesh_bottomLeftPt.X, pedestrianSafetyMesh_bottomLeftPt.Y, pedestrianSafetyMesh_bottomLeftPt.Z)\r\n    titleLabelOrigin2.Y = titleLabelOrigin2.Y - (lb_visualization.BoundingBoxPar[2]/10)*legendScale  # (height2d_ofBB/10)*legendScale\r\n    titleLabelText2 = \"Pedestrian wind safety: %s\\nResult gradient: %s, northCfd: %s, north: %s, %s\\n%s\" % (locationName, resultGradient, northCfdD, northD, pedestrianTypeLabel, date)\r\n    titleLabelMeshes2 = lb_visualization.text2srf([titleLabelText2], [titleLabelOrigin2], legendFont, legendFontSize*1.2, legendBold, None, 6)[0]\r\n    titleDescriptionLabelMeshes2 = titleLabelMeshes2\r\n    \r\n    \r\n    # legendPedestrianComfort (legend1)\r\n    if legendBasePt == None:\r\n        legendBasePt = lb_visualization.BoundingBoxPar[0]\r\n    # generate the legend\r\n    try:\r\n        legendSrfs, legendText, legendTextSrfs, textPt, textSize = lb_visualization.createLegend([int(item) for item in pedestrianComfortCategory_forAllPoints], lowB, highB, numSeg, \"comfort category\", lb_visualization.BoundingBoxPar, legendBasePt, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\r\n    except:\r\n        validModelTolerance = False\r\n        pedestrianComfortMesh = pedestrianSafetyMesh = titleDescriptionLabelMeshes = titleDescriptionLabelMeshes2 = legend = legend2 = legendBasePt = legendBasePt2 = None\r\n        printMsg = \"The mesh you supplied to the _analysisGeometry input is too small for the current Rhino model tolerance.\\n\" + \\\r\n                   \"\\n\" + \\\r\n                   \"Increase your tolerance by choosing in Rhino: Tools -> Options, then click on Units -> Model.\\n\" + \\\r\n                   \"Decrease the \\\"Absolute tolerance\\\" value. For example if it was: 0.01, set it to 0.001. Click on \\\"OK\\\" to close the Rhino Options window.\\n\" + \\\r\n                   \"Rerun the \\\"Pedestrian wind comfort\\\" component (set the _runIt to False, and then to True).\"\r\n        return pedestrianComfortMesh, pedestrianSafetyMesh, titleDescriptionLabelMeshes, titleDescriptionLabelMeshes2, legend, legend2, legendBasePt, legendBasePt2, validModelTolerance, printMsg\r\n    # generate legend colors\r\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\r\n    # color legend surfaces\r\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\r\n    legend = [legendSrfs] + lb_preparation.flattenList(legendTextSrfs)\r\n    \r\n    # legendPedestrianSafety (legend2)\r\n    lb_visualization.calculateBB([pedestrianSafetyMesh])\r\n    legendBasePt2 = Rhino.Geometry.Point3d(legendBasePt.X, legendBasePt.Y -(2*lb_visualization.BoundingBoxPar[2]), legendBasePt.Z)\r\n    # generate the legend2\r\n    legendSrfs2, legendText2, legendTextSrfs2, textPt2, textSize2 = lb_visualization.createLegend([math.ceil(item) for item in pedestrianSafety_forAllPoints], lowB, highB, numSeg2, \"safe or not\", lb_visualization.BoundingBoxPar, legendBasePt2, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\r\n    # generate legend colors2\r\n    legendColors2 = lb_visualization.gradientColor(legendText2[:-1], lowB2, highB2, customColors2)\r\n    # color legend surfaces2\r\n    legendSrfs2 = lb_visualization.colorMesh(legendColors2, legendSrfs2)\r\n    legend2 = [legendSrfs2] + lb_preparation.flattenList(legendTextSrfs2)\r\n    \r\n    \r\n    # hide legendBasePt, legendBasePt2 output\r\n    ghenv.Component.Params.Output[11].Hidden = True\r\n    ghenv.Component.Params.Output[12].Hidden = True\r\n    \r\n    validModelTolerance = True\r\n    printMsg = \"ok\"\r\n    \r\n    return pedestrianComfortMesh, pedestrianSafetyMesh, titleDescriptionLabelMeshes, titleDescriptionLabelMeshes2, legend, legend2, legendBasePt, legendBasePt2, validModelTolerance, printMsg\r\n\r\n\r\ndef bakingGrouping(locationName, pedestrianComfortMesh, pedestrianSafetyMesh, titleDescriptionLabelMeshes, titleDescriptionLabelMeshes2, legend, legend2):\r\n    \r\n    layerName = locationName\r\n    \r\n    layerIndex, l = lb_visualization.setupLayers(layerName, \"LADYBUG\", \"PEDESTRIAN WIND COMFORT-SAFETY\", \"WIND ANALYSIS\")\r\n    \r\n    attr = Rhino.DocObjects.ObjectAttributes()\r\n    attr.LayerIndex = layerIndex\r\n    attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\r\n    attr.PlotColorSource = Rhino.DocObjects.ObjectPlotColorSource.PlotColorFromObject\r\n    \r\n    # bake pedestrianComfortMesh\r\n    geometryIds = []\r\n    geometry = [pedestrianComfortMesh]\r\n    for obj in geometry:\r\n        id = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj,attr)\r\n        geometryIds.append(id)\r\n    \r\n    # bake title1\r\n    geometryIds2 = []\r\n    geometry2 = titleDescriptionLabelMeshes\r\n    for obj2 in geometry2:\r\n        id2 = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj2,attr)\r\n        geometryIds2.append(id2)\r\n    \r\n    # bake legend1\r\n    geometryIds3 = []\r\n    geometry3 = legend\r\n    for obj3 in geometry3:\r\n        id3 = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj3,attr)\r\n        geometryIds3.append(id3)\r\n    \r\n    \r\n    # bake pedestrianSafetyMesh\r\n    geometryIds_ = []\r\n    geometry_ = [pedestrianSafetyMesh]\r\n    for obj_ in geometry_:\r\n        id_ = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj_,attr)\r\n        geometryIds_.append(id_)\r\n    \r\n    # bake title2\r\n    geometryIds2_ = []\r\n    geometry2_ = titleDescriptionLabelMeshes2\r\n    for obj2_ in geometry2_:\r\n        id2_ = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj2_,attr)\r\n        geometryIds2_.append(id2_)\r\n    \r\n    # bake legend1\r\n    geometryIds3_ = []\r\n    geometry3_ = legend2\r\n    for obj3_ in geometry3_:\r\n        id3_ = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj3_,attr)\r\n        geometryIds3_.append(id3_)\r\n    \r\n    \r\n    # grouping of pedestrianComfortMesh\r\n    groupIndex = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindComfort_mesh_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex, geometryIds)\r\n    # grouping of title1\r\n    groupIndex2 = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindComfort_title1_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex2, geometryIds2)\r\n    # grouping of legend1\r\n    groupIndex3 = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindComfort_legend1_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex3, geometryIds3)\r\n    \r\n    # grouping of pedestrianSafetyMesh\r\n    groupIndex_ = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindSafety_mesh_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex_, geometryIds_)\r\n    # grouping of title2\r\n    groupIndex2_ = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindComfort_title2_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex2_, geometryIds2_)\r\n    # grouping of legend2\r\n    groupIndex3_ = Rhino.RhinoDoc.ActiveDoc.Groups.Add(layerName + \"_pedestrianWindComfort_legend2_\" + str(time.time()))\r\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex3_, geometryIds3_)\r\n\r\n\r\ndef printOutput(locationName, cfdSimulationDirections, pedestrianType, pedestrianTypeLabel, northCfd, north, resultGradient, analysisPeriod, conditionalStatementForFinalPrint):\r\n    \r\n    resultsCompletedMsg = \"Pedestrian wind comfort component results successfully completed!\"\r\n    \r\n    printOutputMsg = \\\r\n    \"\"\"\r\nInput data:\r\n\r\nLocation (deg.): %s\r\nWind factor directions: %s\r\nPedestrian type: %s (%s)\r\nNorth Cfd (deg.): %s\r\nNorth Rhino (deg.): %s\r\nResult gradient: %s\r\n\r\nAnalysis period: %s\r\n\r\nCaclulation based on the following condition:\r\n%s\r\n    \"\"\" % (locationName, cfdSimulationDirections, pedestrianType, pedestrianTypeLabel, northCfd, north, resultGradient, analysisPeriod, conditionalStatementForFinalPrint)\r\n    print resultsCompletedMsg\r\n    print printOutputMsg\r\n\r\n\r\nlevel = gh.GH_RuntimeMessageLevel.Warning\r\nif sc.sticky.has_key(\"ladybug_release\"):\r\n    if sc.sticky[\"ladybug_release\"].isCompatible(ghenv.Component):\r\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\r\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\r\n        lb_photovoltaics = sc.sticky[\"ladybug_Photovoltaics\"]()\r\n        \r\n        if _epwFile:\r\n            locationName, windSpeedData, windDirectionData, validEpwData, printMsg = getEpwData(_epwFile)\r\n            if validEpwData:\r\n                windFactorsPerPointLL, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, pedestrianTypeLabel, northCfdD, northD, resultGradient, HOYs, analysisPeriod, date, validInputData, printMsg = checkInputData(_windFactor, _analysisGeometry, pedestrianType_, north_, northCfd_, resultGradient_, analysisPeriod_)\r\n                if validInputData:\r\n                    validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg = checkAnnualHourlyInputData(annualHourlyData_)\r\n                    if validAnnualHourlyData:\r\n                        validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg = checkConditionalStatement(conditionalStatement_, annualHourlyDataLists, annualHourlyDataListsEpwNames, [windSpeedData, windDirectionData], True)\r\n                        if validConditionalStatement:\r\n                            windSpeedCondStat, windDirectionCondStat = weatherPerHourDataConditionalStatementSubLists\r\n                            if _runIt:\r\n                                outputLocationWindSpeed = False\r\n                                windSpeedDataPerPointDataTree_corrected, windSpeed95percentPerYear_forAllPoints, strongestLocationWindSpeed_forAllPoints, pedestrianComfortCategory_forAllPoints, pedestrianSafety_forAllPoints = main(windSpeedCondStat, windDirectionCondStat, windFactorsPerPointLL, outputLocationWindSpeed, analysisGeometryMesh, cfdSimulationDirections, pedestrianSafetyThreshold, northCfdD, northD, resultGradient, HOYs, analysisPeriod)\r\n                                pedestrianComfortMesh, pedestrianSafetyMesh, titleDescriptionLabelMeshes, titleDescriptionLabelMeshes2, legend, legend2, legendBasePt, legendBasePt2, validModelTolerance, printMsg = createGeometry(legendPar_, locationName, analysisGeometryMesh, pedestrianTypeLabel, pedestrianComfortCategory_forAllPoints, pedestrianSafety_forAllPoints, northCfdD, northD, resultGradient, date)\r\n                                \r\n                                if validModelTolerance:\r\n                                    if bakeIt_: bakingGrouping(locationName, pedestrianComfortMesh, pedestrianSafetyMesh, titleDescriptionLabelMeshes, titleDescriptionLabelMeshes2, legend, legend2)\r\n                                    printOutput(locationName, cfdSimulationDirections, pedestrianType_, pedestrianTypeLabel, northCfd_, north_, resultGradient, analysisPeriod, conditionalStatementForFinalPrint)\r\n                                    pedestrianComfortCategory = pedestrianComfortCategory_forAllPoints; pedestrianSafetyCategory = pedestrianSafety_forAllPoints;\r\n                                    thresholdWindSpeed = windSpeed95percentPerYear_forAllPoints; strongestLocationWindSpeed = strongestLocationWindSpeed_forAllPoints; locationWindSpeed = windSpeedDataPerPointDataTree_corrected;\r\n                                    legend = titleDescriptionLabelMeshes + legend; legend2 = titleDescriptionLabelMeshes2 + legend2\r\n                                else:\r\n                                    print printMsg\r\n                                    ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n                            else:\r\n                                print \"All inputs are ok. Please set \\\"_runIt\\\" to True, in order to run the Pedestrian wind comfort component\"\r\n                        else:\r\n                            print printMsg\r\n                            ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n                    else:\r\n                        print printMsg\r\n                        ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n                else:\r\n                    print printMsg\r\n                    ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n            else:\r\n                print printMsg\r\n                ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n        else:\r\n            printMsg = \"Please supply an .epw file path to the \\\"_epwFile\\\" input.\"\r\n            print printMsg\r\n            ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n    else:\r\n        printMsg = \"You need a newer version of Ladybug to use this component.\\n\" + \\\r\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\r\n            \"If you have already updated userObjects drag the Ladybug_Ladybug component \" + \\\r\n            \"into the canvas and try again.\"\r\n        print printMsg\r\nelse:\r\n    printMsg = \"First please let the Ladybug fly...\"\r\n    print printMsg\r\n    ghenv.Component.AddRuntimeMessage(level, printMsg)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}