{
  "source_url": "https://github.com/JaumeMonclus/Rhino-Grasshopper-Scripts/blob/ca6be60d1f0266c805ce4d76dfc277bd05070c87/AT-AP-Sessions/Session-3/MPDA25-Assignment3/A03_Jaume_Monclus.py",
  "repo": "JaumeMonclus/Rhino-Grasshopper-Scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "AT-AP-Sessions/Session-3/MPDA25-Assignment3/A03_Jaume_Monclus.py",
  "instruction": "r: networkx r: matplotlib",
  "code": "#r: networkx\r\n#r: matplotlib\r\n\r\nfrom typing import cast, Any\r\nimport networkx as nx # type: ignore\r\nimport matplotlib.pyplot as plt # type: ignore\r\nimport ghpythonlib.treehelpers as th # type: ignore\r\nimport System # type: ignore\r\nimport Rhino # type: ignore\r\nimport Rhino.Geometry as rg # type: ignore\r\nimport rhinoscriptsyntax as rs # type: ignore\r\nimport math # type: ignore\r\nimport ghpythonlib.components as comps # type: ignore\r\nimport KangarooSolver as KS # type: ignore\r\n\r\n# DECLARE INPUT VARIABLES\r\nm = cast(rg.Mesh, m)  # type: ignore\r\ns = cast(int, s)  # type: ignore\r\nt = cast(int, t)  # type: ignore\r\n\r\n\r\ndef PlotGraph(G,filepath):\r\n    # add position\r\n    pos = nx.spring_layout(G)\r\n\r\n    #draw serttings\r\n    fig = plt.figure(figsize=(10,10))\r\n    ax = plt.subplot()\r\n    ax.set_title('Graph', fontsize=12)\r\n    nx.draw(G, pos, node_size=1500, with_labels=True, node_color='pink', font_size=12)\r\n\r\n    #draw the graph\r\n    plt.tight_layout()\r\n\r\n    # plt.show()\r\n    plt.savefig(filepath, format=\"PNG\")\r\n\r\ndef GetMeshFaceCentroid(mesh, mfi):\r\n\r\n    mf = mesh.Faces[mfi]\r\n    if mf.IsTriangle:\r\n        v1 = m.Vertices[mf.A]\r\n        v2 = m.Vertices[mf.B]\r\n        v3 = m.Vertices[mf.C]\r\n\r\n        return (v1 + v2 +v3) * (1/3)\r\n\r\n    if mf.IsQuad:\r\n        v1 = m.Vertices[mf.A]\r\n        v2 = m.Vertices[mf.B]\r\n        v3 = m.Vertices[mf.C]\r\n        v4 = m.Vertices[mf.D]\r\n\r\n        return (v1 + v2 +v3+ v4) * (1/4)\r\n\r\n\r\ndef DualGraphFromMesh(mesh):\r\n    G=nx.Graph()\r\n\r\n    dual_vertices = []\r\n    dual_edges = []\r\n\r\n    for i,mf in enumerate(mesh.Faces):\r\n\r\n        faceCentroid = GetMeshFaceCentroid(mesh, i)\r\n        dual_vertices.append(faceCentroid)\r\n        \r\n        G.add_node(i, pos = faceCentroid)\r\n\r\n        neighbours =   mesh.Faces.AdjacentFaces(i)\r\n\r\n        # Add edges to graph\r\n        for n in neighbours:\r\n\r\n            if n > i:\r\n                p1= faceCentroid\r\n\r\n                p2= GetMeshFaceCentroid(m, n)\r\n\r\n                line = rg.Line(p1,p2)\r\n                dual_edges.append(line)\r\n\r\n                G.add_edge(i,n, w = line.Length)\r\n\r\n    return G, dual_vertices, dual_edges\r\n\r\n\r\n\r\ndef mirrored_face(m,source,G):\r\n    mesh_indexes = []\r\n\r\n    # Get the face index of the source face\r\n\r\n    ray_vector_reversed = -m.FaceNormals[source]\r\n\r\n    ray_initial_face = m.Faces[source]\r\n    \r\n    vr1 = m.Vertices[ray_initial_face.A]\r\n    vr2 = m.Vertices[ray_initial_face.B]\r\n    vr3 = m.Vertices[ray_initial_face.C]\r\n    vr4 = m.Vertices[ray_initial_face.D]\r\n\r\n    ray_initial_point = (vr1 + vr2 +vr3+ vr4) * (1/4)\r\n\r\n    # mesh curve intersectiion\r\n\r\n    mesh_line = rg.Line(ray_initial_point, ray_vector_reversed, 200)\r\n\r\n    Face_point_intersection = rg.Intersect.Intersection.MeshLine(m, mesh_line)\r\n    \r\n    Mesh_index_list = m.ClosestPoint(Face_point_intersection[0],20)\r\n\r\n    # this is the mesh index\r\n\r\n    Mesh_index = Mesh_index_list[0]\r\n\r\n    # extract the shortest path of the oposite point\r\n    \r\n    sp = nx.shortest_path(G, source, Mesh_index, weight = \"weight\")\r\n    \r\n    pts = [G.nodes[i][\"pos\"] for i in sp]\r\n    faceInd = [i for i in sp]\r\n\r\n    # next face index\r\n\r\n    next_faces = m.Faces.GetConnectedFaces(\r\n        source,\r\n        0.5,\r\n        True)\r\n\r\n\r\nclass TorusStripes:\r\n    def __init__(self, m, G):\r\n        self.m = m\r\n        self.G = G\r\n        return \r\n    def mesh_faces(self):\r\n\r\n        mesh_indexes = []\r\n        self.striped_mesh_faces = []\r\n        processed_faces = set()\r\n        for i in range(0, len(m.Faces)):\r\n            if i in processed_faces:\r\n                continue\r\n            else:\r\n                next_faces = m.Faces.GetConnectedFaces(\r\n                    i,\r\n                    0.5,\r\n                    True)\r\n                stripe_faces = []\r\n                \r\n                # si vas a hacer un list(), siempre en append.\r\n                for idx in next_faces:\r\n                    mesh_face = m.Faces.GetFace(idx)\r\n                    stripe_faces.append(mesh_face)\r\n\r\n                self.striped_mesh_faces.append(stripe_faces)\r\n                mesh_indexes.append(list(next_faces))\r\n                processed_faces.update(next_faces)\r\n\r\n    \r\n        return self.striped_mesh_faces\r\n            \r\n    def torus_stripes(self):\r\n\r\n        self.nested_face_meshes = []\r\n        \r\n        for stripe in self.striped_mesh_faces:\r\n            stripe_meshes = []  # Lista para almacenar los mini meshes de este stripe\r\n            for face in stripe:\r\n                new_mesh = rg.Mesh()\r\n                v_indices = []\r\n                # Agregar los 4 vértices de la cara (quad)\r\n                for orig_idx in [face.A, face.B, face.C, face.D]:\r\n                    v_indices.append(new_mesh.Vertices.Add(m.Vertices[orig_idx]))\r\n                new_mesh.Faces.AddFace(v_indices[0], v_indices[1], v_indices[2], v_indices[3])\r\n                new_mesh.Normals.ComputeNormals()\r\n                new_mesh.Compact()\r\n                stripe_meshes.append(new_mesh)\r\n            self.nested_face_meshes.append(stripe_meshes)\r\n\r\n        return self.nested_face_meshes\r\n\r\n    def sorting_mesh_faces(self):\r\n\r\n        # create the initial group of centroids\r\n        self.centroids = []\r\n        self.average_middle_point = []\r\n        keys = []  \r\n\r\n        # Recorremos cada grupo en nested_face_meshes\r\n        for nested_face in self.nested_face_meshes:\r\n\r\n            # create the subgroups of centroids\r\n            centroids_group = []\r\n            \r\n            for face in nested_face:\r\n                amp = rg.AreaMassProperties.Compute(face)\r\n                if amp: \r\n                    # double append\r\n                    centroids_group.append(amp.Centroid)\r\n                    \r\n            # average point of the group\r\n            if len(centroids_group) > 0:\r\n                avg = rg.Point3d(0, 0, 0)\r\n                for pt in centroids_group:\r\n                    avg += pt\r\n                avg /= len(centroids_group)\r\n            \r\n            \r\n            # Guardamos el punto promedio individualmente (por grupo)\r\n            self.average_middle_point.append(avg)\r\n            \r\n            \r\n            sorting_circle = rg.Circle(1)\r\n            result = comps.CurveClosestPoint(avg, sorting_circle)\r\n            t_value = list(result)[1]\r\n            \r\n            # outputs: agregamos el grupo completo y su promedio ya calculado\r\n            self.centroids.append(centroids_group)\r\n\r\n            # Agregamos la key (un solo float) para este grupo\r\n            keys.append(t_value)\r\n        \r\n        zipped_data = list(zip(keys, self.centroids))\r\n        zipped_data.sort(key=lambda x: x[0])\r\n        keys_sorted_cent = []\r\n        centroids_sorted = []\r\n        for k, g in zipped_data:\r\n            keys_sorted_cent.append(k)\r\n            centroids_sorted.append(g)\r\n\r\n        sorted_keys = keys_sorted_cent\r\n        self.centroids = centroids_sorted\r\n\r\n        zipped_data_average = list(zip(keys, self.average_middle_point))\r\n        zipped_data_average.sort(key=lambda x: x[0])\r\n\r\n        # keys for the vectors and polyline\r\n\r\n        keys_sorted_avg = []\r\n        self.average_middle_point_sorted = []\r\n        for k, g in zipped_data_average:\r\n            keys_sorted_avg.append(k)\r\n            self.average_middle_point_sorted.append(g)\r\n\r\n\r\n        # order the mesh stripes\r\n\r\n        zipped_data = list(zip(keys, self.nested_face_meshes))\r\n        zipped_data.sort(key=lambda x: x[0])\r\n        keys_sorted_cent = []\r\n        self.striped_mesh_faces_sorted = []\r\n        for k, g in zipped_data:\r\n            keys_sorted_cent.append(k)\r\n            self.striped_mesh_faces_sorted.append(g)\r\n\r\n       \r\n\r\n        # Devuelve las stripes ordenadas\r\n        return self.striped_mesh_faces_sorted\r\n    \r\n    def sorted_stripes (self):\r\n    \r\n        # here we are going to get a plane, a coplanar cirlce and sort the points accordingly for each grou`p\r\n        \r\n        self.average_middle_point_sorted\r\n        self.centroids\r\n\r\n        # get the connecting vectors between i and i * 1 for the average_middle_point_sorted\r\n        connecting_vectors = []\r\n        cross_vectors = []\r\n        stripes_plane = []\r\n        circles = []\r\n        t_values = []\r\n        sorted_keys_all = []\r\n        self.sorted_mesh_faces = []\r\n        \r\n        for i in range(len(self.average_middle_point_sorted)):\r\n            next_index = (i + 1) % len(self.average_middle_point_sorted)\r\n            vector = self.average_middle_point_sorted[next_index] - self.average_middle_point_sorted[i]\r\n            connecting_vectors.append(vector)\r\n        \r\n            # calculating the cross product\r\n\r\n            cross_vector = rg.Vector3d.CrossProduct(vector, rg.Vector3d.ZAxis)\r\n            cross_vectors.append(cross_vector)\r\n\r\n            # create the plane for the stripe\r\n\r\n            plane = rg.Plane(self.average_middle_point_sorted[i], rg.Vector3d.ZAxis, cross_vector)\r\n            stripes_plane.append(plane)\r\n\r\n            # create a circle in each plane\r\n\r\n            circle = rg.Circle(plane, 1)\r\n            circles.append(circle)\r\n\r\n            # order all the centroid correspondingly\r\n\r\n            result = comps.CurveClosestPoint(self.centroids[i], circle)\r\n            t_value = list(result)[1]\r\n            t_values.append(list(t_value))\r\n\r\n        # order the centroids correspondingly zip them first\r\n        # this is a working method for embeded list sorting\r\n\r\n        for ex_t_values, ex_mesh_faces in zip(t_values, self.striped_mesh_faces_sorted):\r\n            zipped_data = list(zip(ex_t_values, ex_mesh_faces))\r\n            zipped_data.sort(key=lambda x: x[0])\r\n            sorted_keys, sorted_group = zip(*zipped_data)  if zipped_data else ([], [])\r\n            sorted_keys_all.append(list(sorted_keys))\r\n            self.sorted_mesh_faces.append(list(sorted_group))\r\n\r\n        return sorted_keys_all, self.sorted_mesh_faces\r\n    \r\n    def unroll(self):\r\n        \r\n        self.first_halves = []\r\n        self.second_halves = []\r\n        \r\n        # Se recorre cada branch en self.sorted_mesh_faces\r\n        for branch in self.sorted_mesh_faces:\r\n            half_index = len(list(branch)) // 2  # Si el número es impar, la segunda mitad tendrá 1 elemento más\r\n            self.first_halves.append(branch[:half_index])\r\n            self.second_halves.append(branch[half_index:])\r\n\r\n        # primero juntamos las mallas\r\n\r\n        joined_first_meshes = []  \r\n\r\n        # para las caras exteriores convexas\r\n\r\n        for mesh_list in self.first_halves:\r\n            if not mesh_list:\r\n                continue  \r\n            joined_mesh = comps.MeshJoin(mesh_list)\r\n            joined_first_meshes.append(joined_mesh)\r\n\r\n        joined_second_meshes = []  \r\n\r\n        # para las caras interiores concavas\r\n\r\n        for mesh_list in self.second_halves:\r\n            if not mesh_list:\r\n                continue  \r\n            joined_mesh = comps.MeshJoin(mesh_list)\r\n            joined_second_meshes.append(joined_mesh)\r\n        \r\n        return joined_first_meshes, joined_second_meshes\r\n    \r\n\r\n\r\n    \r\n    \r\ndef shortestPath(G, source, target):\r\n\r\n    sp = nx.shortest_path(G, source, target, weight = \"weight\")\r\n    \r\n    pts = [G.nodes[i][\"pos\"] for i in sp]\r\n    faceInd = [i for i in sp]\r\n\r\n    return pts, faceInd, sp       \r\n          \r\n\r\n########################\r\n### initial OUTPUTS  ###\r\n########################\r\n\r\nG, dv,de = DualGraphFromMesh(m)\r\nSP = shortestPath(G, s, t)\r\npts = SP[0]\r\nfaceInd = SP[1]\r\n\r\n###############\r\n### OUTPUTS ###\r\n###############\r\n\r\ntorus = TorusStripes(m,G)\r\nmesh_faces = th.list_to_tree(torus.mesh_faces())\r\nunordered_stripes = th.list_to_tree(torus.torus_stripes())\r\nsorted_faces = th.list_to_tree(torus.sorting_mesh_faces())\r\nsorted_stripes = th.list_to_tree(torus.sorted_stripes()[0])\r\nsorted_keys = th.list_to_tree(torus.sorted_stripes()[1])\r\njoined_first_meshes = th.list_to_tree(torus.unroll()[0])\r\njoined_second_meshes = th.list_to_tree(torus.unroll()[1])\r\n\r\n#plot\r\n# path= r\"C:\\Users\\david\\Desktop\\Session02\\session02\\images\\MDPA_plot5.png\"\r\n# PlotGraph(G, path)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}