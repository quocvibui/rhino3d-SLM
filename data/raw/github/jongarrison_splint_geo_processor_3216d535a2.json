{
  "source_url": "https://github.com/jongarrison/splint_geo_processor/blob/b4a410b94aa8ddd9dad7ee8d35d452964254ef41/generators/src/BooleanUnionDiagnostic.py",
  "repo": "jongarrison/splint_geo_processor",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "generators/src/BooleanUnionDiagnostic.py",
  "instruction": "Grasshopper Python Component: Boolean Union Diagnostic Tool",
  "code": "\"\"\"\nGrasshopper Python Component: Boolean Union Diagnostic Tool\n\nINPUTS:\n    BrepA: First Brep (Brep)\n    BrepB: Second Brep (Brep)\n    Tolerance: Tolerance for checks (float, default: 0.01)\n    RunFix: Attempt automatic fixes (bool, default: False)\n\nOUTPUTS:\n    Report: Diagnostic report (string)\n    IsValidA: Is BrepA valid (bool)\n    IsValidB: Is BrepB valid (bool)\n    CanUnion: Likely to union successfully (bool)\n    FixedA: Fixed version of BrepA (Brep)\n    FixedB: Fixed version of BrepB (Brep)\n\"\"\"\n\nimport Rhino\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\ndef analyze_brep(brep, name=\"Brep\"):\n    \"\"\"Analyze a brep and return diagnostic information\"\"\"\n    report = []\n    report.append(\"=\" * 50)\n    report.append(\"ANALYZING: {}\".format(name))\n    report.append(\"=\" * 50)\n    \n    # Basic validity\n    is_valid = brep.IsValid\n    report.append(\"Valid: {}\".format(is_valid))\n    \n    if not is_valid:\n        valid_result, log_message = brep.IsValidWithLog()\n        report.append(\"Validation Error: {}\".format(log_message))\n    \n    # Check if solid\n    is_solid = brep.IsSolid\n    report.append(\"Is Solid: {}\".format(is_solid))\n    \n    # Check if manifold (solid implies manifold and closed)\n    is_manifold = brep.IsManifold\n    report.append(\"Is Manifold: {}\".format(is_manifold))\n    \n    # Surface count\n    report.append(\"Surface Count: {}\".format(brep.Faces.Count))\n    \n    # Edge analysis\n    naked_edges = []\n    interior_edges = []\n    \n    for edge in brep.Edges:\n        if edge.Valence == rg.EdgeAdjacency.Naked:\n            naked_edges.append(edge)\n        elif edge.Valence == rg.EdgeAdjacency.Interior:\n            interior_edges.append(edge)\n    \n    report.append(\"Naked Edges: {}\".format(len(naked_edges)))\n    report.append(\"Interior Edges: {}\".format(len(interior_edges)))\n    \n    if len(naked_edges) > 0 and is_solid:\n        report.append(\"WARNING: Solid has naked edges - geometry inconsistency!\")\n    \n    # Volume check\n    try:\n        volume_result = brep.GetVolume()\n        # GetVolume may return float directly OR (success_bool, volume_float, error_float) depending on Rhino version\n        if isinstance(volume_result, (float, int)):\n            report.append(\"Volume: {:.6f}\".format(volume_result))\n        elif isinstance(volume_result, tuple) and len(volume_result) >= 2:\n            if volume_result[0]:\n                report.append(\"Volume: {:.6f}\".format(volume_result[1]))\n            else:\n                report.append(\"Volume: Could not compute (GetVolume returned False)\")\n        else:\n            report.append(\"Volume: Unexpected return format: {}\".format(type(volume_result)))\n    except Exception as e:\n        report.append(\"Volume: Error computing - {}\".format(str(e)))\n    \n    # Bounding box\n    bbox = brep.GetBoundingBox(True)\n    report.append(\"Bounding Box: Min{} Max{}\".format(bbox.Min, bbox.Max))\n    \n    # Check for self-intersections\n    report.append(\"\\nSelf-Intersection Check:\")\n    has_self_intersect = False\n    for i, faceA in enumerate(brep.Faces):\n        for j, faceB in enumerate(brep.Faces):\n            if i < j:  # Only check each pair once\n                try:\n                    result = rg.Intersect.Intersection.SurfaceSurface(\n                        faceA.UnderlyingSurface(), \n                        faceB.UnderlyingSurface(), \n                        0.01\n                    )\n                    if result[0]:\n                        curves = result[1]\n                        if curves and len(curves) > 0:\n                            # Check if intersection is at edge (normal) or interior (problem)\n                            is_interior = False\n                            for crv in curves:\n                                if crv:\n                                    # Sample points along curve and check distance to edges\n                                    for t in [0.0, 0.5, 1.0]:\n                                        test_pt = crv.PointAt(crv.Domain.ParameterAt(t))\n                                        \n                                        # Find closest edge\n                                        closest_edge_dist = float('inf')\n                                        for edge in brep.Edges:\n                                            edge_param = edge.ClosestPoint(test_pt, 0.0)[1]\n                                            edge_pt = edge.PointAt(edge_param)\n                                            dist = test_pt.DistanceTo(edge_pt)\n                                            closest_edge_dist = min(closest_edge_dist, dist)\n                                        \n                                        # If any point is far from edges, it's an interior intersection\n                                        if closest_edge_dist > 0.1:\n                                            is_interior = True\n                                            break\n                                    if is_interior:\n                                        break\n                            \n                            if is_interior:\n                                has_self_intersect = True\n                                report.append(\"  WARNING: Face {} and Face {} have interior intersection\".format(i, j))\n                except:\n                    pass\n    \n    if not has_self_intersect:\n        report.append(\"  No interior self-intersections detected\")\n    \n    return \"\\n\".join(report), is_valid, is_solid, naked_edges\n\ndef check_intersection(brepA, brepB):\n    \"\"\"Check how two breps intersect\"\"\"\n    report = []\n    report.append(\"\\n\" + \"=\" * 50)\n    report.append(\"INTERSECTION ANALYSIS\")\n    report.append(\"=\" * 50)\n    \n    # Bounding box overlap\n    bboxA = brepA.GetBoundingBox(True)\n    bboxB = brepB.GetBoundingBox(True)\n    \n    overlap = rg.BoundingBox.Intersection(bboxA, bboxB)\n    if overlap.IsValid:\n        report.append(\"Bounding boxes overlap: YES\")\n        report.append(\"Overlap volume: {:.6f}\".format(overlap.Volume))\n    else:\n        report.append(\"Bounding boxes overlap: NO\")\n        report.append(\"WARNING: Breps don't overlap - union may fail!\")\n    \n    # Try to compute intersection\n    try:\n        tolerance = sc.doc.ModelAbsoluteTolerance\n        intersection = rg.Intersect.Intersection.BrepBrep(brepA, brepB, tolerance)\n        if intersection[0]:\n            curves = intersection[1]\n            points = intersection[2]\n            report.append(\"Intersection curves: {}\".format(len(curves)))\n            report.append(\"Intersection points: {}\".format(len(points)))\n            \n            if len(curves) > 20:\n                report.append(\"WARNING: Many intersection curves - complex intersection!\")\n        else:\n            report.append(\"No intersection found\")\n            report.append(\"WARNING: Breps may not touch!\")\n    except Exception as e:\n        report.append(\"Intersection computation failed: {}\".format(str(e)))\n    \n    return \"\\n\".join(report)\n\ndef attempt_fix(brep, tolerance, name=\"Brep\"):\n    \"\"\"Attempt to fix common brep issues\"\"\"\n    fixed = brep.Duplicate()\n    \n    # Try to repair\n    if not fixed.IsValid:\n        fixed.Repair(tolerance)\n    \n    # Try to cap planar holes if not solid\n    if not fixed.IsSolid:\n        fixed = fixed.CapPlanarHoles(tolerance)\n    \n    # Try to split kinky faces (can help with complex surface intersections)\n    try:\n        fixed.Faces.SplitKinkyFaces(sc.doc.ModelAngleToleranceRadians, True)\n    except:\n        pass\n    \n    # Compact the brep\n    fixed.Compact()\n    \n    return fixed\n\ndef test_union_with_tolerance(brepA, brepB, tolerance):\n    \"\"\"Test if union works with a specific tolerance and validate result quality\"\"\"\n    try:\n        result = rg.Brep.CreateBooleanUnion([brepA, brepB], tolerance)\n        if result and len(result) > 0:\n            union_brep = result[0]\n            \n            # Collect validation issues\n            issues = []\n            \n            # Basic validity checks\n            if not union_brep.IsValid:\n                issues.append(\"Invalid\")\n            if not union_brep.IsSolid:\n                issues.append(\"NotSolid\")\n            if not union_brep.IsManifold:\n                issues.append(\"NotManifold\")\n            \n            # Check for naked edges (shouldn't have any if solid)\n            naked_count = sum(1 for edge in union_brep.Edges if edge.Valence == rg.EdgeAdjacency.Naked)\n            if naked_count > 0:\n                issues.append(\"NakedEdges={}\".format(naked_count))\n            \n            # Check face count explosion\n            if union_brep.Faces.Count > 1000:\n                issues.append(\"TooManyFaces={}\".format(union_brep.Faces.Count))\n            elif union_brep.Faces.Count > 100:\n                issues.append(\"HighFaceCount={}\".format(union_brep.Faces.Count))\n            \n            # Check for self-intersections in result (critical!)\n            self_intersect_count = 0\n            for i, faceA in enumerate(union_brep.Faces):\n                for j, faceB in enumerate(union_brep.Faces):\n                    if i < j:\n                        try:\n                            result_check = rg.Intersect.Intersection.SurfaceSurface(\n                                faceA.UnderlyingSurface(), \n                                faceB.UnderlyingSurface(), \n                                0.01\n                            )\n                            if result_check[0]:\n                                curves = result_check[1]\n                                if curves and len(curves) > 0:\n                                    # Check if this is an interior intersection\n                                    for crv in curves:\n                                        if crv:\n                                            # Sample middle point\n                                            test_pt = crv.PointAt(crv.Domain.ParameterAt(0.5))\n                                            \n                                            # Find closest edge\n                                            closest_edge_dist = float('inf')\n                                            for edge in union_brep.Edges:\n                                                edge_param = edge.ClosestPoint(test_pt, 0.0)[1]\n                                                edge_pt = edge.PointAt(edge_param)\n                                                dist = test_pt.DistanceTo(edge_pt)\n                                                closest_edge_dist = min(closest_edge_dist, dist)\n                                            \n                                            # If far from edges, it's a self-intersection\n                                            if closest_edge_dist > 0.1:\n                                                self_intersect_count += 1\n                                                break\n                        except:\n                            pass\n            \n            if self_intersect_count > 0:\n                issues.append(\"SelfIntersections={}\".format(self_intersect_count))\n            \n            # Try to compute volume\n            try:\n                vol_result = union_brep.GetVolume()\n                # Handle both direct float return and tuple return\n                if isinstance(vol_result, tuple):\n                    if len(vol_result) >= 2 and not vol_result[0]:\n                        issues.append(\"VolumeComputeFailed\")\n                elif not isinstance(vol_result, (float, int)):\n                    issues.append(\"VolumeError\")\n            except:\n                issues.append(\"VolumeError\")\n            \n            # If we have any issues, this is a problematic union\n            if len(issues) > 0:\n                return False, None, issues\n            \n            return True, union_brep, []\n        return False, None, [\"NoResult\"]\n    except Exception as e:\n        return False, None, [\"Exception:{}\".format(str(e))]\n\ndef do_diagnostic_solid_union(BrepA, BrepB, Tolerance=None, RunFix=False):\n  if BrepA and BrepB:\n      # Set default tolerance\n      if not Tolerance or Tolerance <= 0:\n          Tolerance = sc.doc.ModelAbsoluteTolerance\n      \n      # Analyze both breps\n      reportA, validA, solidA, nakedA = analyze_brep(BrepA, \"Brep A\")\n      reportB, validB, solidB, nakedB = analyze_brep(BrepB, \"Brep B\")\n      \n      # Check intersection\n      intersection_report = check_intersection(BrepA, BrepB)\n      \n      # Combine reports\n      full_report = [reportA, reportB, intersection_report]\n      \n      # Test union at different tolerances\n      full_report.append(\"\\n\" + \"=\" * 50)\n      full_report.append(\"UNION TESTS\")\n      full_report.append(\"=\" * 50)\n      \n      # More comprehensive tolerance tests with no duplicates\n      test_tolerances = sorted(list(set([\n          Tolerance, \n          Tolerance * 10, \n          Tolerance * 100,\n          Tolerance * 1000,\n          0.001, \n          0.01, \n          0.1,\n          1.0,\n          10.0\n      ])))\n      \n      union_success = False\n      union_result = None\n\n      for tol in test_tolerances:\n          success, result, issues = test_union_with_tolerance(BrepA, BrepB, tol)\n          if success:\n              status = \"SUCCESS\"\n          elif len(issues) > 0:\n              status = \"FAILED ({})\".format(\", \".join(issues))\n          else:\n              status = \"FAILED\"\n          \n          full_report.append(\"Tolerance {:.6f}: {}\".format(tol, status))\n          if success and not union_success:\n              union_success = True\n              union_result = result\n              full_report.append(\"  -> First successful tolerance: {:.6f}\".format(tol))\n      \n      # If still failing, try with simplified/fixed breps\n      if not union_success:\n          full_report.append(\"\\nAttempting union with pre-fixed breps...\")\n          fixedA_temp = attempt_fix(BrepA, Tolerance, \"Brep A\")\n          fixedB_temp = attempt_fix(BrepB, Tolerance, \"Brep B\")\n          \n          for tol in [0.01, 0.1, 1.0, 10.0]:\n              success, result, issues = test_union_with_tolerance(fixedA_temp, fixedB_temp, tol)\n              if success:\n                  status = \"SUCCESS\"\n              elif len(issues) > 0:\n                  status = \"FAILED ({})\".format(\", \".join(issues))\n              else:\n                  status = \"FAILED\"\n              \n              full_report.append(\"Fixed breps, Tolerance {:.6f}: {}\".format(tol, status))\n              if success and not union_success:\n                  union_success = True\n                  union_result = result\n                  full_report.append(\"  -> SUCCESS with pre-fixed breps at tolerance: {:.6f}\".format(tol))\n                  break\n      \n      # Recommendations\n      full_report.append(\"\\n\" + \"=\" * 50)\n      full_report.append(\"RECOMMENDATIONS\")\n      full_report.append(\"=\" * 50)\n      \n      if not validA or not validB:\n          full_report.append(\"• Fix invalid geometry first (RunFix=True)\")\n      if not solidA or not solidB:\n          full_report.append(\"• One or both breps are not solid - cap holes if needed\")\n      if len(nakedA) > 0 or len(nakedB) > 0:\n          full_report.append(\"• Naked edges detected - check for gaps in surfaces\")\n      \n      # Check for self-intersections in the analysis\n      if \"WARNING: Face\" in reportA and \"interior intersection\" in reportA:\n          full_report.append(\"• CRITICAL: Brep A has interior self-intersecting faces - rebuild geometry\")\n      if \"WARNING: Face\" in reportB and \"interior intersection\" in reportB:\n          full_report.append(\"• CRITICAL: Brep B has interior self-intersecting faces - rebuild geometry\")\n      \n      if union_success:\n          full_report.append(\"• Union succeeded - verify result is valid solid\")\n          if union_result:\n              full_report.append(\"  Result: {} faces, Solid={}, Valid={}\".format(\n                  union_result.Faces.Count,\n                  union_result.IsSolid,\n                  union_result.IsValid\n              ))\n      else:\n          full_report.append(\"• Union failed at all tolerances\")\n          full_report.append(\"• Try: 1) Fix self-intersections, 2) Offset one brep slightly, 3) Use mesh boolean\")\n          full_report.append(\"• To export for inspection: Right-click breps in Grasshopper > Bake\")\n      \n      # Output results\n      Report = \"\\n\".join(full_report)\n      IsValidA = validA\n      IsValidB = validB\n      #CanUnion = union_success\n      UnionResult = union_result\n      \n      # Attempt fixes if requested\n      if RunFix:\n          FixedA = attempt_fix(BrepA, Tolerance, \"Brep A\")\n          FixedB = attempt_fix(BrepB, Tolerance, \"Brep B\")\n          Report += \"\\n\\n\" + \"=\" * 50\n          Report += \"\\nFIXES APPLIED\"\n          Report += \"\\n\" + \"=\" * 50\n          Report += \"\\nFixed A Valid: {}\".format(FixedA.IsValid)\n          Report += \"\\nFixed B Valid: {}\".format(FixedB.IsValid)\n      else:\n          FixedA = BrepA\n          FixedB = BrepB\n\n      print(Report)\n      return FixedA, FixedB, UnionResult\n  else:\n      Report = \"Please provide both BrepA and BrepB inputs\"\n      IsValidA = False\n      IsValidB = False\n      CanUnion = False\n      FixedA = None\n      FixedB = None\n      print(Report)\n      return FixedA, FixedB, None\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}