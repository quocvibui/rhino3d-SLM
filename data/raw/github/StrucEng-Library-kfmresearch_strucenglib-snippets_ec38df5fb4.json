{
  "source_url": "https://github.com/StrucEng-Library-kfmresearch/strucenglib-snippets/blob/2e4b498eaa5b2928c1766e9ed99bf6493e5fe056/strucenglib/prepost_functions/Normalspurbahnverkehr_load_generator.py",
  "repo": "StrucEng-Library-kfmresearch/strucenglib-snippets",
  "repo_stars": 1,
  "repo_description": "StrucEng Library (snippets) for Rhinoceros",
  "license": "unknown",
  "filepath": "strucenglib/prepost_functions/Normalspurbahnverkehr_load_generator.py",
  "instruction": "Author(s): Marius  Weber (ETHZ, HSLU T&A)",
  "code": " # Author(s): Marius  Weber (ETHZ, HSLU T&A)\n\nimport os \nfrom datetime import datetime\nimport rhinoscriptsyntax as rs\nfrom compas_fea.structure import Structure\nfrom compas_fea.cad import rhino\nfrom compas.geometry import scale_vector\nfrom compas.geometry import add_vectors\nimport Rhino\nimport scriptcontext\nimport System.Guid, System.Drawing.Color\nimport math\nfrom strucenglib.prepost_functions import area_load_generator_elements\nfrom compas_fea.structure import AreaLoad\n\n\n\ndef Normalspurbahnverkehr_load_generator(mdl, name=None, l_Pl=None, h_Pl=None, s=None, beta=None, q_Gl=4.8+1.7, b_Bs=2500, \n                                         h_Strich=None, h_GL=160, h_w=None, Q_k=225*1000, y_A=200, m=4650, gamma_G=1, gamma_Q=1, \n                                         direction='all', verbalise=False):\n\n    \"\"\"  \n    Function calculating and generating the loading resulting from a railway track. It generates the dead load of the track as\n    well as the life load. The life load is applied according to SIA 269/1 11.2. The axle loads of a train is applied iteratively \n    starting from the defined starting point y_A.\n\n    Parameters\n    ----------\n    mdl : structurObject\n        A structure object, representing the structure to be analysed\n    name : str\n        Name of the track (e.g. \"Track1\")\n    l_Pl : float\n        Plate length/ Span between two walls + 2*wall Thickness [mm]\n    h_Pl : float\n        deck slab thickness [mm]\n    s : float\n        Distance between origin (0,0,0) and the track in global x-direction [mm]\n    beta: float\n        Angle between global y-axis and track axis [Degree], should be in range[-90,90]\n    q_Gl : float\n        Load form concrete sleeper(Betonschwelle, normally 4.8 N/mm)) and load from the tracks themselfs (normally 1.7 N/mm) [N/mm]\n    b_Bs : float\n        Width of the concrete sleeper of one track [mm] (normally 2500 mm PAIngB Page 157)\n    h_Strich : float\n        Height between lower level of concrete sleepers of the tracks to the upper surface of the slab deck of the bridge [mm] \n        (ca. height of gravel layer + insulation layer height)\n    h_Gl:float\n        Height of the tracks (normally arround 130 and 180 mm) [mm]\n    Q_k : float\n        axle load [N] (for D4 225*1000 N, SIA 269/1 11.2.1.1)\n    y_A : float\n        y-coordinate of the starting point for the live load generation iteration.\n    m: int\n        Distance between inner Qact (see SIA 269/1 11.2.1.1; for D4: 4650 mm) [mm]\n    gamma_G: float\n        Safety factor for dead load (default=1, SIA 269: 1.35 ) [-]\n    gamma_Q: float\n        Safety factor for live load (default=1, SIA 269: 1.45 ) [-]\n    verbalise: bool\n        If set to true it prints the caluclated load values. \n\n    Returns\n    ----------\n    List[str]\n        A list of load names, which were generated within the function.\n    \"\"\"\n\n\n    # Basic definitions\n    #-------------------------------------------------------\n\n    # Schreiben des Warning files zum fullen bei anfanglichen Warnungen\n    now = datetime.now()\n    dt_string = now.strftime(\"%d/%m/%Y %H:%M:%S\")\n    file = open('WARNINGS_in_Normalspurbahnverkehr_load_generator.txt','a')\n    file.write('Warnings im Pythonfile Normalspurbahnverkehr_load_generator,'+dt_string+'\\n')\n    file.write('-------------------------------------------------------------------------------\\n')\n    file.close()\n\n    # Winkeldefinition\n    beta_rad=math.radians(beta)\n\n    # Aufbau Liste fur Layer Namen\n    Lasten_aus_Normalspurverkehr=[]\n\n\n    # Generierung der Mittelachse aus s und beta \n    #-------------------------------------------------------\n\n    # Create layername fur die Mittelachse\n    Gleis_Mittelachse=name+'_Mittelachse'\n\n    # Definition eines neuen Layers\n    if rs.IsLayer(Gleis_Mittelachse):\n        rs.PurgeLayer(Gleis_Mittelachse)\n        scriptcontext.doc.Layers.Add(Gleis_Mittelachse, System.Drawing.Color.Red)\n    else:\n        scriptcontext.doc.Layers.Add(Gleis_Mittelachse, System.Drawing.Color.Red)\n    \n    rs.CurrentLayer(Gleis_Mittelachse)\n\n    # Startpunkt der Mittelachse (Annahme: Globaler Nullpunkt immer bei x=0,y=0,z=0)\n    point_start_x=s\n    point_start_y=0\n\n    # Endpunkt der Mittelachse\n    point_end_x=s+math.tan(beta_rad)*l_Pl\n    point_end_y=l_Pl\n\n    # Hinzufugen der Linie in Layer als Polyline\n    rs.AddCurve([(point_start_x,point_start_y,0),(point_end_x,point_end_y,0)])\n       \n    # Selektieren der Mittelachse   \n    selectcurve = rs.ObjectsByLayer(Gleis_Mittelachse)\n    \n    # Calculate End and Startpoints der Mittelachse\n    point_start = rs.CurveStartPoint(selectcurve)\n    point_end = rs.CurveEndPoint(selectcurve)\n    \n      \n    # Lastgenerator fur Eigengewichte Gleise/Schwellen\n    #-------------------------------------------------------\n\n    # Create layername\n    Gleis_Eigengewichte_Schiene=name+'_EIGENGEWICHTE_SCHIENE_Lasteinzugsflache'\n\n    # Definition eines neues Layers fur alle belasteten Elementmittelpunkte \n    if rs.IsLayer(Gleis_Eigengewichte_Schiene):\n        rs.PurgeLayer(Gleis_Eigengewichte_Schiene)\n        scriptcontext.doc.Layers.Add(Gleis_Eigengewichte_Schiene, System.Drawing.Color.Green)\n    else:\n        scriptcontext.doc.Layers.Add(Gleis_Eigengewichte_Schiene, System.Drawing.Color.Green)\n\n    rs.CurrentLayer(Gleis_Eigengewichte_Schiene)\n\n    # Geometrische Berechnung der Lastflachen\n    # Berechnung b_Gl (Lastausbreitung in Querrichtung)\n    b_Gl=(b_Bs/2+h_Strich/4+h_Pl/2)*2\n\n    # Berechnung b_strich_Gl\n    b_Strich_Gl=b_Gl/math.cos(abs(beta_rad))\n\n    # Berechnung der vier Eckpunkte der Lastflachen\n    # x Koordinanten\n    P_A_x=(point_start[0]-b_Strich_Gl/2)\n    P_B_x=(point_start[0]+b_Strich_Gl/2)\n    P_C_x=(point_end[0]+b_Strich_Gl/2)\n    P_D_x=(point_end[0]-b_Strich_Gl/2)\n\n    # y Koordinanten\n    P_A_y=(point_start[1])\n    P_B_y=(point_start[1])\n    P_C_y=(point_end[1])\n    P_D_y=(point_end[1])\n\n    # z Koordinanten\n    P_A_z=(point_start[2])\n    P_B_z=(point_start[2])\n    P_C_z=(point_end[2])\n    P_D_z=(point_end[2])\n\n    # Berechnung der vier Eckpunkte der Lastflache und Kurvne in Rhino Layer ploten\n    rs.CurrentLayer(Gleis_Eigengewichte_Schiene)\n    rs.AddPolyline([(P_A_x,P_A_y,P_A_z),(P_B_x,P_B_y,P_B_z),(P_C_x,P_C_y,P_C_z),(P_D_x,P_D_y,P_D_z),(P_A_x,P_A_y,P_A_z)])\n\n    # Berechnung der verteilten Belastung q_k_Gl der Gleise\n    q_k_Gl=gamma_G*q_Gl/b_Gl\n\n    # verbalise\n    if verbalise:\n        print('The area load resulting from concret sleeper and the tracks: ', q_k_Gl, ' N/mm2 ;',q_k_Gl*1000, ' kN/m2' )\n\n    # Berechnung der belasteten Elemente (Gibt Nummern der belastete Elemente raus)\n    loaded_element_numbers=area_load_generator_elements(mdl,Gleis_Eigengewichte_Schiene) # Calculate Element numbers within the area load curve\n    \n    # Hinzufugen der belasteten Elemente\n    mdl.add(AreaLoad(Gleis_Eigengewichte_Schiene, elements=loaded_element_numbers,x=0,y=0,z=q_k_Gl, axes ='global')) # Add new element set\n\n    # Hinzufugen des Namens des Layers der Lasteinzugsflache\n    # Bemerkung: Naming _Lasteinzugsflaeche_der_Schienen_Eigengewichte' gibt es pro Schiene (d.h. pro Funktionsaufruf) nur einmal\n    Lasten_aus_Normalspurverkehr.append(Gleis_Eigengewichte_Schiene)  \n\n    # Lastgenerator fur Bahnlasten\n    #-------------------------------------------------------\n  \n    # Berechnung der x_A Koordinante (Lage der Einzellast) aus y_A\n    x_A=math.tan(beta_rad)*y_A+s \n\n    # Lastausbreitung in Langsrichtung und Querrichtung\n    l_Bl=(h_GL*2+h_Strich/4+h_Pl/2)*2 #Langsrichtung\n    b_Bl=b_Gl #Querrichtung\n\n    #Berechnung Flachenlast\n    #Fur Hoechstgeschwindigkeit bis 140 #TODO adapt for other Hoechstgewschwindigkeiten 125\n    l_phi=(1.3*(l_Pl+(h_w+h_Pl/2)*2))/3 #[mm]\n    l_phi_list=[1,2,4,6,8,10,15,20,25,30,40,50,60,70,80,100] #[m]\n    dynF_list=[1.60, 1.59, 1.57, 1.54, 1.50, 1.45, 1.35, 1.32, 1.29, 1.26, 1.23, 1.20, 1.18, 1.17, 1.16, 1.14]\n    index=max(i for i, num in enumerate(l_phi_list) if num <= l_phi/1000)\n    dynF=dynF_list[index]\n    alpha=1 # Klassifizierungsbeiwert Alpha (PAIngB S.34, =1 for evaluation of existing structures)\n    area=l_Bl*b_Bl\n    q_k_Bl=(Q_k*1.1*dynF*alpha)/area\n    q_d_Bl=gamma_Q*q_k_Bl\n\n    # verbalise\n    if verbalise:\n        print('The area load resulting from the rail traffic live load: ', q_d_Bl, ' N/mm2 ;',q_d_Bl*1000, ' kN/m2' )\n\n       \n    # Schleife uber neg und pos richtung ausgehend von x_A, y_A\n    # d.h. es werden in neg. und pos Richtung weitrere Lastblocke gemass Abstand Lastmodell angeordnet\n    if direction == 'positive':\n        i_list=[0]\n    elif direction == 'negative':\n        i_list=[-1]\n    elif direction in ['all', 'both']:\n        i_list=range(1,3)\n    else:\n        raise ValueError('Invalid input for direction. Choose between \"negative\", \"positive\", and \"all\".')\n    \n    for LB_VZ in i_list: # zweimal durchlaufen - einmal pos. und einmal neg. Richtung\n\n        # Liste mit absolunten Abstanden L_i zum Punkt x_A, y_A\n        if LB_VZ==0: #in positive Richtung (y wird grosser)\n            L_i_list=[0,+1800,+1800+m,1800+m+1800,+1800+m+1800+3000,+1800+m+1800+3000+1800,+1800+m+1800+3000+1800+m,+1800+m+1800+3000+1800+m+1800]\n        if LB_VZ==-1: #in negative Richtung (y wird kleiner)\n            L_i_list=[0,-1800,-1800-m,-1800-m-1800,-1800-m-1800-3000,-1800-m-1800-3000-1800,-1800-m-1800-3000-1800-m,-1800-m-1800-3000-1800-m-1800]\n        if LB_VZ==1:  # all direction, in positive Richtung (y wird grosser)\n            L_i_list=[0,3000,3000+1800,3000+1800+m,3000+1800+m+1800,3000+1800+m+1800+3000,3000+1800+m+1800+3000+1800,3000+1800+m+1800+3000+1800+m,3000+1800+m+1800+3000+1800+m+1800]            \n        if LB_VZ==2: #  all direction, in negative Richtung (y wird kleiner) (with first train in negative y direction)\n            L_i_list=[-1800,-1800-m,-1800-m-1800,-1800-m-1800-3000,-1800-m-1800-3000-1800,-1800-m-1800-3000-1800-m,-1800-m-1800-3000-1800-m-1800]\n            \n\n        lauf_LB=0\n        List_lengh=len(L_i_list)\n\n        for L_i in L_i_list: # Schleife uber alle Lastblocke\n            \n            # Anzahl der Durchlaufe fur naming der Layers\n            if LB_VZ==1:  \n                lauf_LB=lauf_LB+1\n            else:\n                lauf_LB=lauf_LB-1\n\n            # Mittelkoordinanten des Lastpunktes\n\n            # Create layername with load area\n            Bahnlasten_Einzellasten=name+'_BAHNLASTEN_Einzellasten'+'_Lastblock_'+str(lauf_LB)\n\n            # Definition eines neues Layers fur alle belasteten Elementmittelpunkte des Lastblockes\n            if rs.IsLayer(Bahnlasten_Einzellasten):\n                rs.PurgeLayer(Bahnlasten_Einzellasten)\n                scriptcontext.doc.Layers.Add(Bahnlasten_Einzellasten, System.Drawing.Color.Green)\n            else:\n                scriptcontext.doc.Layers.Add(Bahnlasten_Einzellasten, System.Drawing.Color.Green)\n\n            rs.CurrentLayer(Bahnlasten_Einzellasten)\n\n            # Berechnung relativer Abstand zu Einzellast bei x_A, y_A\n            d_x=L_i*math.sin(beta_rad)\n            d_y=L_i*math.cos(beta_rad)\n\n           # Berechnung Koordinaten der Einzellast zur Einzellast bei x_A, y_A\n            x_point=x_A+d_x\n            y_point=y_A+d_y\n\n            rs.AddPoint((x_point,y_point))\n\n            \n            # Lastpolygone bzw. Lastausbreitung berechnen \n\n            # Koordinaten Punkt A_strich        \n            x_P_A_strich=-b_Bl/2\n            y_P_A_strich=l_Bl/2\n            # Koordinaten Punkt B_strich\n            x_P_B_strich=-b_Bl/2\n            y_P_B_strich=-l_Bl/2\n            # Koordinaten Punkt C_strich\n            x_P_C_strich=b_Bl/2\n            y_P_C_strich=-l_Bl/2\n            # Koordinaten Punkt D_strich\n            x_P_D_strich=b_Bl/2\n            y_P_D_strich=l_Bl/2                \n\n            # Berucksichtigung der Drehmatrix fur Punkte A, B, C, D\n            \n            # Punkt A\n            x_P_A=x_P_A_strich*math.cos(-1*beta_rad)-y_P_A_strich*math.sin(-1*beta_rad)\n            y_P_A=x_P_A_strich*math.sin(-1*beta_rad)+y_P_A_strich*math.cos(-1*beta_rad)\n            x_def_A=x_point+x_P_A\n            y_def_A=y_point+y_P_A\n            # Punkt B\n            x_P_B=x_P_B_strich*math.cos(-1*beta_rad)-y_P_B_strich*math.sin(-1*beta_rad)\n            y_P_B=x_P_B_strich*math.sin(-1*beta_rad)+y_P_B_strich*math.cos(-1*beta_rad)\n            x_def_B=x_point+x_P_B\n            y_def_B=y_point+y_P_B\n            # Punkt C\n            x_P_C=x_P_C_strich*math.cos(-1*beta_rad)-y_P_C_strich*math.sin(-1*beta_rad)\n            y_P_C=x_P_C_strich*math.sin(-1*beta_rad)+y_P_C_strich*math.cos(-1*beta_rad)\n            x_def_C=x_point+x_P_C\n            y_def_C=y_point+y_P_C        \n            # Punkt D\n            x_P_D=x_P_D_strich*math.cos(-1*beta_rad)-y_P_D_strich*math.sin(-1*beta_rad)\n            y_P_D=x_P_D_strich*math.sin(-1*beta_rad)+y_P_D_strich*math.cos(-1*beta_rad)\n            x_def_D=x_point+x_P_D\n            y_def_D=y_point+y_P_D\n\n            # Create layername with load area\n            Bahnlasten_Lasteinzug=name+'_BAHNLASTEN_Lasteinzugsflache'+'_Lastblock_'+str(lauf_LB)\n\n            # Definition eines neues Layers fur alle belasteten Elementmittelpunkte \n            if rs.IsLayer(Bahnlasten_Lasteinzug):\n                rs.PurgeLayer(Bahnlasten_Lasteinzug)\n                scriptcontext.doc.Layers.Add(Bahnlasten_Lasteinzug, System.Drawing.Color.Green)\n            else:\n                scriptcontext.doc.Layers.Add(Bahnlasten_Lasteinzug, System.Drawing.Color.Green)\n\n            rs.CurrentLayer(Bahnlasten_Lasteinzug)\n\n            # Build rectangle for load area\n            points=[(x_def_A,y_def_A,0),(x_def_B,y_def_B,0),(x_def_C,y_def_C,0),(x_def_D,y_def_D,0),(x_def_A,y_def_A,0)]\n            rs.AddPolyline(points)\n\n            # Kontrolle ob Lastpolygon mindestes ein Punkt der Punkte A,B,C,D innerhalb der Fahrbahnplatte liegt\n                \n            # Falls alle Eckpunkte (A,B,C,D) der Lasteinzugsflache ausserhalb der Platte liegen -> Loop L_i abbrechen\n            if y_def_A <= point_start_y or y_def_A >= point_end_y: # Ausserhalb der Platte\n                check_lage_A=1\n            else:\n                check_lage_A=0\n\n            if y_def_B <= point_start_y or y_def_B >= point_end_y: # Ausserhalb der Platte\n                check_lage_B=1\n            else:\n                check_lage_B=0    \n\n            if y_def_C <= point_start_y or y_def_C >= point_end_y: # Ausserhalb der Platte\n                check_lage_C=1\n            else:\n                check_lage_C=0                             \n\n            if y_def_D <= point_start_y or y_def_D >= point_end_y: # Ausserhalb der Platte\n                check_lage_D=1\n            else:\n                check_lage_D=0 \n\n            # Summe der check_lage gleich 4 dann Loop L_i abbrechen sonst (else) weiterer im L_i loop\n            check_lage=check_lage_A+check_lage_B+check_lage_C+check_lage_D\n            if check_lage == 4:\n                rs.CurrentLayer(Gleis_Mittelachse)\n                rs.PurgeLayer(Bahnlasten_Einzellasten)\n                rs.PurgeLayer(Bahnlasten_Lasteinzug)  \n                break\n            else:\n                pass\n                \n\n            # Kontrolle ob Lastpolygone Elemente beinhaltet\n\n            # Berechnung der Elementnummern welche im oben definieren Polygon liegen\n            loaded_element_numbers=area_load_generator_elements(mdl,Bahnlasten_Lasteinzug) \n            \n            # \n            # Die oben definierten Polygon beinhaltet keine Elemente     \n            if not loaded_element_numbers:            \n                rs.CurrentLayer(Gleis_Mittelachse)\n                rs.PurgeLayer(Bahnlasten_Einzellasten)\n                rs.PurgeLayer(Bahnlasten_Lasteinzug)  \n                load_layer_ele_centroids_loaded=Bahnlasten_Lasteinzug+'_Elementmittelpunkte_belastet' # Aus Definition in Funktion area_load_generator_elements\n                rs.PurgeLayer(load_layer_ele_centroids_loaded)\n\n                          \n                warning_string='Warning: Load block ' +str(lauf_LB)+ ' inside plate, but does not contain any element -> choose smaller mesh'   \n                file = open('WARNINGS_in_Normalspurbahnverkehr_load_generator.txt','a')\n                file.write(warning_string+'\\n')\n                file.close()\n               \n                \n            else:                       \n                # Abspeichern der Namen fur die Bahnlasten_Lasteinzug                         \n                Lasten_aus_Normalspurverkehr.append(Bahnlasten_Lasteinzug)\n\n                # OLD: Berechnung der Flachenlast\n                # selectloadedarea = rs.ObjectsByLayer(Bahnlasten_Lasteinzug)\n                # area=rs.Area(selectloadedarea)\n                # print(area,'area')\n                # q_k_Bl=(Q_k/4)/area\n                # print('q_k_Bl',q_k_Bl)\n\n                # Hinzufugen der belasten Elemente zu Struktur                \n                mdl.add(AreaLoad(Bahnlasten_Lasteinzug, elements=loaded_element_numbers,x=0,y=0,z=q_d_Bl, axes='global')) # postive z direction is downwards\n\n                # Warnung, das alle vorgegeben lastblocke durchlaufen wurden und eventuell noch mehr auf der Platte platz hatten\n                if L_i == L_i_list[List_lengh-1]:\n\n                    warning_string='Warning: More load blocks could have placed on the plate -> Please adjust L_i_List in the pythonfile Normalspurbahnverkehr_load_generator'\n                    file = open('WARNINGS_in_Normalspurbahnverkehr_load_generator.txt','a')\n                    file.write(warning_string+'\\n')\n                    file.close()\n  \n                else:\n                    pass\n                \n\n    return Lasten_aus_Normalspurverkehr  #  Beinhaltet alle Namen der Layer mit den Lasten\n\n\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}