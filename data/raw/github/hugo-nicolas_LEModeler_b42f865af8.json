{
  "source_url": "https://github.com/hugo-nicolas/LEModeler/blob/7780bc8a0163ea84ce0b2934858ecab2ff124a63/PythonFiles/AirCONICStools.py",
  "repo": "hugo-nicolas/LEModeler",
  "repo_stars": 5,
  "repo_description": "Automated generation and export of parametric hydrofoil geometries using Rhinoceros 3D CAD engine",
  "license": "GPL-3.0",
  "filepath": "PythonFiles/AirCONICStools.py",
  "instruction": "AirCONICStools.py ============================================================ Ancillary methods called by the higher level AirCONICS functions. ============================================================================== AirCONICS Aircraft CONfiguration through Integrated Cross-disciplinary Scripting version 0.2.1 Andras Sobester, 2015. Bug reports to a.sobester@soton.ac.uk or @ASobester please. ==============================================================================",
  "code": "# AirCONICStools.py ============================================================\r\n# Ancillary methods called by the higher level AirCONICS functions. \r\n# ==============================================================================\r\n# AirCONICS\r\n# Aircraft CONfiguration through Integrated Cross-disciplinary Scripting \r\n# version 0.2.1\r\n# Andras Sobester, 2015.\r\n# Bug reports to a.sobester@soton.ac.uk or @ASobester please.\r\n# ==============================================================================\r\n\r\n# Preamble\r\nfrom __future__ import division\r\nimport math, random, cmath, os, bisect, rhinoscriptsyntax as rs\r\nimport airconics_setup\r\n\r\n\r\ndef AddTEtoOpenAirfoil(AirfoilCurve):\r\n# If the airfoil curve given as an argument is open at the trailing edge, it adds\r\n# a line between the ends of the curve and joins this with the rest of the curve.\r\n    if rs.IsCurveClosed(AirfoilCurve) == False:\r\n        EP1 = rs.CurveEndPoint(AirfoilCurve)\r\n        rs.ReverseCurve(AirfoilCurve)\r\n        EP2 = rs.CurveEndPoint(AirfoilCurve)\r\n        rs.ReverseCurve(AirfoilCurve)\r\n        Closure = rs.AddLine(EP1,EP2)\r\n        rs.UnselectAllObjects()\r\n        rs.SelectObject(Closure)\r\n        rs.SelectObject(AirfoilCurve)\r\n        rs.Command(\"_Join \")\r\n        LO = rs.LastCreatedObjects()\r\n        AirfoilCurve = LO[0]\r\n        rs.UnselectAllObjects()\r\n\r\n    return AirfoilCurve\r\n\r\ndef ObjectsExtents(ObjectIds):\r\n    # Compute the extents in the X, Y and Z direction (in the current coordinate\r\n    # system) of the objects listed in the argument.\r\n\r\n    BB = rs.BoundingBox(ObjectIds)\r\n    \r\n    XVec = []\r\n    YVec = []\r\n    ZVec = []\r\n\r\n    for i,P in enumerate(BB):\r\n        list.append(XVec,P.X)\r\n        list.append(YVec,P.Y)\r\n        list.append(ZVec,P.Z)\r\n        \r\n    Xmin = min(XVec)\r\n    Ymin = min(YVec)\r\n    Zmin = min(ZVec)\r\n    \r\n    Xmax = max(XVec)\r\n    Ymax = max(YVec)\r\n    Zmax = max(ZVec)\r\n    \r\n    return (Xmin,Ymin,Zmin,Xmax,Ymax,Zmax)\r\n\r\ndef MirrorObjectXZ(ObjectId):\r\n# Mirrors an object with respect to the XoZ plane\r\n# Argument: the object to be mirrored.\r\n# Returns: the ID of the object if succesful\r\n    TransMat = []\r\n    TransMat.append([1, 0, 0, 0])\r\n    TransMat.append([0, -1, 0,0])\r\n    TransMat.append([0, 0, 1, 0])\r\n    TransMat.append([0, 0, 0, 1])\r\n    TransObjId = rs.TransformObject(ObjectId, TransMat,True)\r\n    return TransObjId\r\n\r\ndef ScaleObjectWorld000(ObjectId, Scaling):\r\n# Scales an object in the World coordinate system. Similar functionality to \r\n# Rhino's ScaleObject, but the latter uses the current construction plane.\r\n# The scaling is done with respect to the origin of the World system (0,0,0)\r\n# Arguments: ObjectId - the object to be scaled\r\n#            Scaling  - a three element list or tuple containg the scaling\r\n#                       factors along x, y and z respectively\r\n    xform = rs.XformScale(Scaling)\r\n    ObjectId = rs.TransformObjects(ObjectId, xform)\r\n    return ObjectId\r\n\r\ndef frange(r1, r2, incr):\r\n    # A float version of the built-in range method\r\n    # NOTE - due to round-off issues this is due to be replaced in the next ver.\r\n    while r1 <= r2:\r\n        yield r1\r\n        r1 += incr\r\n\r\ndef pwfrange(start, stop, n):\r\n    # Immune to round-off problems\r\n    L = [0.0] * n \r\n    nm1 = n - 1 \r\n    nm1inv = 1.0 / nm1 \r\n    for i in range(n): \r\n        L[i] = nm1inv * (start*(nm1 - i) + stop*i) \r\n    return L \r\n\r\ndef CrossPlatformExtrudeSurface(SurfaceId, CurveId, Capped = True):\r\n    # rs.ExtrudeSurface not implemented in Rhino for OS X\r\n\r\n    if airconics_setup.RhinoVersion==1:\r\n        SolidId = rs.ExtrudeSurface(SurfaceId, CurveId, Capped)\r\n    else:\r\n        rs.SelectObject(CurveId)\r\n        rs.Command(\"_SelNone\")\r\n        rs.SelectObject(SurfaceId)\r\n        rs.Command(\"_ExtrudeSrfAlongCrv _SelPrev\")\r\n        SolidId = rs.LastCreatedObjects()\r\n        rs.Command(\"_SelNone\")\r\n\r\n    return SolidId\r\n\r\ndef blendcorners(polyline_id, radius):\r\n    # Fillets the corners of a polyline (from the McNeel website)\r\n    if not polyline_id: return\r\n\r\n    vertices = rs.PolylineVertices(polyline_id)\r\n    if not vertices: return\r\n\r\n    if radius is None: return\r\n\r\n    between = lambda a,b: (a+b)/2.0\r\n    newverts = []\r\n    for i in range(len(vertices)-1):\r\n        a = vertices[i]\r\n        b = vertices[i+1]\r\n        segmentlength = rs.Distance(a, b)\r\n        vec_segment = rs.PointSubtract(b, a)\r\n        vec_segment = rs.VectorUnitize(vec_segment)\r\n\r\n        if radius<(0.5*segmentlength):\r\n            vec_segment = rs.VectorScale(vec_segment, radius)\r\n        else:\r\n            vec_segment = rs.VectorScale(vec_segment, 0.5*segmentlength)\r\n\r\n        w1 = rs.PointAdd(a, vec_segment)\r\n        w2 = rs.PointSubtract(b, vec_segment)\r\n        newverts.append(a)\r\n        newverts.append(between(a,w1))\r\n        newverts.append(w1)\r\n        newverts.append(between(w1,w2))\r\n        newverts.append(w2)\r\n        newverts.append(between(w2,b))\r\n    newverts.append(vertices[len(vertices)-1])\r\n    CrvId = rs.AddCurve(newverts, 5)\r\n    rs.DeleteObject(polyline_id)\r\n    return CrvId\r\n\r\n\r\ndef coslin(TransitionPoint):\r\n    # Creates a series of abscissas with cosine spacing from 0 to a TransitionPoint\r\n    # and a linear spacing thereafter, up to 1. The TransitionPoint corresponds to \r\n    # pi. Distribution suitable for airfoils defined by points. TransitionPoint\r\n    # must be in the range [0,1].\r\n    NCosPoints = 8\r\n    NLinPoints = 8\r\n    Abscissa = []\r\n    for ang in frange(0.0, math.pi/2 + 0.001, math.pi/(2*(NCosPoints-1.0))):\r\n        list.append(Abscissa, TransitionPoint*(1.0-math.cos(ang)))\r\n    for stp in frange((1-TransitionPoint)/NLinPoints, 1.0 + 0.001 - TransitionPoint, (1-TransitionPoint)/NLinPoints):\r\n        list.append(Abscissa, stp + TransitionPoint)\r\n    return Abscissa, NCosPoints\r\n\r\n\r\n# Cubic equation solver based on Simple Recipes in Python by W. Park (1999) ====\r\ndef polar(x, y, deg=0): # radian if deg=0; degree if deg=1\r\n    from math import hypot, atan2, pi\r\n    if deg:\r\n        return hypot(x, y), 180.0 * atan2(y, x) / pi\r\n    else:\r\n        return hypot(x, y), atan2(y, x)\r\n\r\ndef cbrt(x):\r\n    from math import pow\r\n    if x >= 0: \r\n        return pow(x, 1.0/3.0)\r\n    else:\r\n        return -pow(abs(x), 1.0/3.0)\r\n\r\ndef quadratic(a, b, c=None):\r\n    import math, cmath\r\n    if c: # (ax^2 + bx + c = 0)\r\n        a, b = b / float(a), c / float(a)\r\n    t = a / 2.0\r\n    r = t**2 - b\r\n    if r >= 0: # real roots\r\n        y1 = math.sqrt(r)\r\n    else: # complex roots\r\n        y1 = cmath.sqrt(r)\r\n    y2 = -y1\r\n    return y1 - t, y2 - t\r\n\r\ndef cubic(a, b, c, d=None):\r\n    from math import cos\r\n    if d: \r\n        a, b, c = b / float(a), c / float(a), d / float(a)\r\n    t = a / 3.0\r\n    p, q = b - 3 * t**2, c - b * t + 2 * t**3\r\n    u, v = quadratic(q, -(p/3.0)**3)\r\n    if type(u) == type(0j): # complex cubic root\r\n        r, w = polar(u.real, u.imag)\r\n        \r\n        y1 = 2 * cbrt(r) * cos(w / 3.0)\r\n    else:   # real root\r\n        y1 = cbrt(u) + cbrt(v)\r\n    y2, y3 = quadratic(y1, p + y1**2)\r\n    return (y1 - t, y2 - t, y3 - t)\r\n#===============================================================================\r\n\r\ndef linear_interpolation(x, y):\r\n    # Returns a function that interpolates the data in the argument (linearly)\r\n    x = x[:]\r\n    y = y[:]\r\n    def fn( v ) :\r\n        j = bisect.bisect_left(x, v)\r\n        i = j-1\r\n        if i < 0 :\r\n            return y[0]\r\n        if j >= len(x) :\r\n            return y[ -1 ]\r\n        return y[i] + (v-x[i])*(y[j]-y[i])/(x[j]-x[i])\r\n    return fn\r\n\r\n\r\ndef boxevopmin2d(funct, x0, deltax, xtol, MaxIter):\r\n# A simple, 2d evolutionary optimizer to eliminate the need for scipy (only\r\n# compatible at the moment on 32-bit Windows installations of Rhino)\r\n\r\n    def _evopmatrix2d(x0,deltax):\r\n    # Internal function - generates search matrix around current iteration\r\n    \r\n        x1 = [x0[0]+deltax[0],x0[1]]\r\n        x2 = [x0[0]+deltax[0],x0[1]+deltax[1]]\r\n        x3 = [x0[0]+deltax[0],x0[1]-deltax[1]]\r\n        \r\n        x4 = [x0[0],x0[1]+deltax[1]]\r\n        x5 = [x0[0],x0[1]-deltax[1]]\r\n        \r\n        x6 = [x0[0]-deltax[0],x0[1]]\r\n        x7 = [x0[0]-deltax[0],x0[1]+deltax[1]]\r\n        x8 = [x0[0]-deltax[0],x0[1]-deltax[1]]\r\n        \r\n        return [x0, x1, x2, x3, x4, x5, x6, x7, x8] \r\n\r\n    Iter = 1\r\n    f = []\r\n\r\n    # Evaluate the starting point\r\n    list.append(f,funct(x0))\r\n\r\n\r\n    while (Iter < MaxIter): \r\n    \r\n        print(\"EVOP optimizer iteration\", Iter)\r\n    \r\n        # Generate the eight points around it\r\n        xmat = _evopmatrix2d(x0,deltax)\r\n    \r\n        # ...and evaluate them\r\n        for i in range(1,9):\r\n            list.append(f, funct(xmat[i]))\r\n        # f and xmat should now contain 9 points\r\n    \r\n        m = min(f)\r\n        mi = [i for i, j in enumerate(f) if j == m]\r\n        # Point mi is the best and should form the basis of the next iteration\r\n\r\n        x0 = xmat[mi[0]]\r\n        f = []\r\n        list.append(f, m)\r\n        # Ready to construct new matrix around this point or finish\r\n        \r\n        if mi[0]==0:\r\n            # We are stuck, step size reduction is needed\r\n            # - cut both by the golden ratio\r\n            deltax[0] = 0.618*deltax[0]\r\n            deltax[1] = 0.618*deltax[1]\r\n            \r\n            print(\"Step size reduced to\", deltax[0], deltax[1])\r\n            \r\n            if max(deltax) < xtol:\r\n                # Trigger an exit if tolerance xtol is reached\r\n                print(\"Step size is now below xtol - stopping\") \r\n                Iter = MaxIter\r\n\r\n        Iter = Iter + 1\r\n\r\n        xmin = x0\r\n        fmin = f[0]\r\n\r\n    return xmin, fmin\r\n\r\n\r\ndef AssignMaterial(object_id, Material):\r\n# Adds simple, pre-defined material surface property sets to objects. Note that\r\n# these are simply visual properties, they do not make the model suitable for \r\n# centre of gravity, etc. calculations.  \r\n    MatInd = rs.AddMaterialToObject(object_id)\r\n    if Material==\"White_composite_external\":\r\n        rs.MaterialColor(MatInd,(255,255,255))\r\n        rs.MaterialShine(MatInd, 100)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n        rs.MaterialReflectiveColor(MatInd, (255,255,255))\r\n    elif Material==\"Plexiglass\":\r\n        rs.MaterialColor(MatInd,(255,255,255))\r\n        rs.MaterialShine(MatInd, 255)\r\n        rs.MaterialTransparency(MatInd, 0.8)\r\n    elif Material==\"Skin\":\r\n        rs.MaterialColor(MatInd,(229,184,143))\r\n        rs.MaterialShine(MatInd, 0)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"Panel\":\r\n        rs.MaterialColor(MatInd,(0,0,0))\r\n        rs.MaterialShine(MatInd, 0)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"PropDisk\":\r\n        rs.MaterialColor(MatInd,(255,255,255))\r\n        rs.MaterialShine(MatInd, 0)\r\n        rs.MaterialTransparency(MatInd, 0.9)\r\n    elif Material==\"Structure\":\r\n        rs.MaterialColor(MatInd,(0,0,0))\r\n        rs.MaterialShine(MatInd, 0)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"ShinyBABlueMetal\":\r\n        rs.MaterialColor(MatInd,(0,32,91))\r\n        rs.MaterialShine(MatInd, 150)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"ShinyBARedMetal\":\r\n        rs.MaterialColor(MatInd,(218, 41, 28))\r\n        rs.MaterialShine(MatInd, 150)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"UnpaintedMetal\":\r\n        rs.MaterialColor(MatInd,(188,198,204))\r\n        rs.MaterialShine(MatInd, 30)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n    elif Material==\"FanDisk\":\r\n        rs.MaterialColor(MatInd,(0,0,0))\r\n        rs.MaterialShine(MatInd, 30)\r\n        rs.MaterialTransparency(MatInd, 0.2)\r\n    elif Material==\"ShinyBlack\":\r\n        rs.MaterialColor(MatInd,(0,0,0))\r\n        rs.MaterialShine(MatInd, 120)\r\n        rs.MaterialTransparency(MatInd, 0)\r\n\r\ndef CutSect(SurfaceId, SpanStation):\r\n    # SpanStation is assumed to be along the y direction, in the range [0,1]\r\n    \r\n    (Xmin,Ymin,Zmin,Xmax,Ymax,Zmax) = ObjectsExtents(SurfaceId)\r\n    \r\n    YStation = Ymin + (Ymax-Ymin)*SpanStation\r\n    OriginX = Xmin -1\r\n    OriginZ = Zmin -1\r\n    \r\n    \r\n    CutPlane = rs.PlaneFromPoints((OriginX, YStation, OriginZ), (Xmax+1, YStation, OriginZ), (OriginX, YStation, Zmax + 1))\r\n    CutPlaneSrf = rs.AddPlaneSurface(CutPlane, max([(Xmax-Xmin),(Ymax-Ymin),(Zmax-Zmin)])+1, max([(Xmax-Xmin),(Ymax-Ymin),(Zmax-Zmin)])+1 )\r\n\r\n    I = rs.IntersectBreps(CutPlaneSrf, SurfaceId)\r\n    Section = I[0]\r\n    rs.DeleteObject(CutPlaneSrf)\r\n\r\n    (Xmin,Ymin,Zmin,Xmax,Ymax,Zmax) = ObjectsExtents(Section)\r\n    \r\n    \r\n    # Find the apparent chord of the section (that is, the line connecting the fore\r\n    # most and aftmost points on the curve\r\n    DivPoints = rs.DivideCurve(Section, 200)\r\n\r\n    Xs = []\r\n    Ys = []\r\n    Zs = []\r\n    for DP in DivPoints:\r\n        list.append(Xs, DP[0])\r\n        list.append(Ys, DP[1])\r\n        list.append(Zs, DP[2])\r\n        \r\n    val, idx = min((val, idx) for (idx, val) in enumerate(Xs))\r\n    LeadingPoint = [Xs[idx], Ys[idx], Zs[idx]]\r\n    val, idx = max((val, idx) for (idx, val) in enumerate(Xs))\r\n    TrailingPoint = [Xs[idx], Ys[idx], Zs[idx]]\r\n    \r\n    Chord = rs.AddLine(TrailingPoint, LeadingPoint)\r\n\r\n    return Section, Chord\r\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}