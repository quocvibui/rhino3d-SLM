{
  "source_url": "https://discourse.mcneel.com/t/drawtoscreenspaceforeground-rendered-view-issue/196087",
  "topic_id": 196087,
  "title": "DrawToScreenSpaceForeground Rendered View issue",
  "question": "I compiled a plugin that creates a legend described here:\n\n\n\n\n\n\n\n\n\n\nDraw To Screen Space Foreground From DrawViewportWires\n \nGrasshopper Developer\n\n\n\n\n\n    Thanks a lot, works perfect. \nThere are still some strange bugs: \n\nThe title of the legend can be updated via the input\nThe legend values not for some reason I do not understand\n\nAd. 2: They are only updated when the code is being rerun. However, it then overlaps the old inputs, as can be seen here. \n \n[Bildschirmfoto 2023-09-27 um 16.54.18]\n \ni tried to implement sth like the \nRedraw\n method, but was not successful in calling it. \n\n230927_HUD.gh\n (10.6 KB) \nedit: i found the solution, the values have…\n  \n\n\n\n\nMost things work fine, except when entering Rendered View, then the colors get distorted. I thought the method is drawing over the screen and thus should not be affected by what view mode is selected?\n\n\nBildschirmfoto 2024-12-06 um 00.52.18\n646×1710 22.8 KB\n\n\nBildschirmfoto 2024-12-06 um 00.52.24\n650×1696 22.3 KB\n\n\nInterestingly this happens only to the Legend being drawn in the foreground…\n\n\nBildschirmfoto 2024-12-06 um 01.54.23\n1920×1791 256 KB",
  "code_blocks": [
    {
      "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Drawing;\n\nusing Rhino;\nusing Rhino.Geometry;\n\nusing Grasshopper;\nusing Grasshopper.Kernel;\nusing Grasshopper.Kernel.Data;\nusing Grasshopper.Kernel.Types;\n\nusing System.IO;\nusing System.Linq;\nusing System.Data;\nusing System.Reflection;\nusing System.Windows.Forms;\nusing System.Xml;\nusing System.Xml.Linq;\nusing System.Runtime.InteropServices;\n\nusing Rhino.DocObjects;\nusing Rhino.Collections;\nusing GH_IO;\nusing GH_IO.Serialization;\n\n/*\nAufgaben\n- Bilschirmskalierung anpassen (für Retina und Nicht-Retina)\n- ViewCapture to File Option hinzufügen\n- Veränderbare Farben\n\n*/\npublic class Script_Instance : GH_ScriptInstance\n{\n  /* \n    Members:\n      RhinoDoc RhinoDocument\n      GH_Document GrasshopperDocument\n      IGH_Component Component\n      int Iteration\n\n    Methods (Virtual & overridable):\n      Print(string text)\n      Print(string format, params object[] args)\n      Reflect(object obj)\n      Reflect(object obj, string method_name)\n  */\n\n  private Color GammaCorrect(Color originalColor, double gamma)\n  {\n    double R = originalColor.R / 255.0;\n    double G = originalColor.G / 255.0;\n    double B = originalColor.B / 255.0;\n\n    double _correctedR = System.Math.Pow(R, gamma) * 255.0;\n    double _correctedG = System.Math.Pow(G, gamma) * 255.0;\n    double _correctedB = System.Math.Pow(B, gamma) * 255.0;\n    \n    Color _correctedColor = System.Drawing.Color.FromArgb((int)_correctedR, (int)_correctedG, (int)_correctedB);\n    return _correctedColor;\n  }\n  \n  private void RunScript(string txt, Interval valDomain)\n  {\n    Print(\"Running script\");\n    List<System.Drawing.Color> colorsList = new List<System.Drawing.Color>\n    { //Taken from Alpaca4D color componennt.\n      System.Drawing.Color.FromArgb(5, 48, 97),\n      System.Drawing.Color.FromArgb(33, 102, 172),\n      System.Drawing.Color.FromArgb(67, 147, 195),\n      System.Drawing.Color.FromArgb(146, 197, 222),\n      System.Drawing.Color.FromArgb(209, 229, 240),\n      System.Drawing.Color.FromArgb(255, 255, 255),\n      System.Drawing.Color.FromArgb(253, 219, 199),\n      System.Drawing.Color.FromArgb(244, 165, 130),\n      System.Drawing.Color.FromArgb(214, 96, 77),\n      System.Drawing.Color.FromArgb(178, 24, 43),\n      System.Drawing.Color.FromArgb(103, 0, 31)\n    };\n\n    factor = 0.75;\n    title = txt;\n    divisions = colorsList.Count;\n\n    double gamma = 2.2;\n    for (int i=0; i<(colorsList.Count); i++)\n    {\n        plotColors.Add(colorsList[i]);\n    }\n    \n    for(int i=0; i<(colorsList.Count+1); i++)\n    {   double roundVal = Math.Round((valDomain.T0 + i * (valDomain.Length / (colorsList.Count))),3);\n        plotValues.Add(roundVal);\n    }\n\n  }\n  List<double> plotValues = new List<double>();\n  List<System.Drawing.Color> plotColors = new List<System.Drawing.Color>();\n  double factor;\n  int divisions;\n  string title;\n  List<string> toCorrectFor = new List<string> {\n      \"Rendered\",\n      \"Raytraced\"\n  };\n\n  BoundingBox box;\n\n  public override void BeforeRunScript()\n  {\n    box = BoundingBox.Empty;\n\n    // Unregister & register new event\n    Rhino.Display.DisplayPipeline.DrawForeground -= DrawForeground;\n    Rhino.Display.DisplayPipeline.DrawForeground += DrawForeground;\n  }\n\n  public override BoundingBox ClippingBox { get{ return box; } }\n\n  // Event function\n  private void DrawForeground(object sender, Rhino.Display.DrawEventArgs e)\n  {\n    DrawLegend(e);\n  }\n\n  private void DrawLegend(Rhino.Display.DrawEventArgs pipeline)\n  {\n    if (pipeline.Viewport.Id == pipeline.RhinoDoc.Views.ActiveView.ActiveViewportID\n        &&\n        !this.Component.Hidden\n    )\n    {\n      var viewport = pipeline.Viewport;\n      var colsToUse = plotColors;\n      bool correctForGamma = toCorrectFor.Contains(viewport.DisplayMode.EnglishName);\n      double _gamma = correctForGamma ?\n                          pipeline.RhinoDoc.RenderSettings.LinearWorkflow.PostProcessGamma\n                          : 1.0;\n\n      var viewportHeight = viewport.Size.Height;\n      int barHeight = (int)(viewportHeight * factor);\n\n      //legend properties\n\n      int plotWidth = (int)(barHeight * 0.05);\n      int xStart = (int)(plotWidth * 0.75);\n\n      //posY \n      int posY = (int)(viewportHeight * ((1 - factor) / 2));\n\n      List<int> yPositions = new List<int>(); ;\n\n      for (int i = 0; i < divisions + 1; i++)\n      {\n        yPositions.Add(posY + i * (barHeight / (divisions)));\n      }\n\n      List<Rectangle> colRectangles = new List<Rectangle>();\n      for (int i = 0; i < (divisions); i++)\n      {\n        Rectangle tempRec = new Rectangle(xStart, yPositions[i], plotWidth, barHeight / (divisions - 1));\n\n        Color correctedColor = GammaCorrect(colsToUse[i], _gamma);\n\n        pipeline.Display.Draw2dRectangle(tempRec, Color.Black, 1, correctedColor);\n      }\n\n      int plotValuesHeight = (int)(plotWidth * 0.5);\n\n      for (int i = 0; i < divisions + 1; i++)\n      {\n        var p3 = new System.Drawing.Point(xStart + (int)(plotWidth * 0.666), yPositions[i]);\n        var p4 = new System.Drawing.Point(xStart + plotWidth, yPositions[i]);\n        pipeline.Display.Draw2dLine(p3, p4, Color.Black, 3);\n\n        pipeline.Display.Draw2dText(plotValues[i].ToString(), Color.Black, new Point2d(xStart + (int)(plotWidth * 1.2), yPositions[i] - (int)(plotValuesHeight * 0.4)), false, plotValuesHeight, \"NewComputerModernMath\"); //why factor 0.4 here? not perfect vertival alignment\n      }\n\n      pipeline.Display.Draw2dText(title, Color.Black, new Point2d(xStart, (yPositions[0] - (int)(plotWidth * 1.2))), false, (int)(plotWidth), \"NewComputerModernMath\");\n    }\n\n  }\n}",
      "language": "csharp",
      "author": "nathanletwory",
      "post_number": 2,
      "is_solution": true
    }
  ],
  "tags": [
    "csharp",
    "geometry",
    "grasshopper",
    "materials",
    "python",
    "rhinocommon"
  ],
  "has_accepted_answer": true,
  "category_id": 8,
  "posts_count": 6,
  "views": 90
}