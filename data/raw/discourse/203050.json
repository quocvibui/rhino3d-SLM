{
  "source_url": "https://discourse.mcneel.com/t/help-on-object-transform/203050",
  "topic_id": 203050,
  "title": "Help on object transform",
  "question": "I am working on a script which will transform multiple polysurfaces to the face of another polysurface.\n\nThis almost works, in that the objects are transformed to the plane of the face, but they lose two dimensions. So if a polysurface started at x=2.5,  y=120, z=0.75, once transformed it is x=0, y=120, z=0. Clearly there is something I donâ€™t understand about how to use PlaneToPlane transformation.\n\nIf anyone can help guide me in the right direction that would much appreciated.\n\nHere is the script and attached is a sample file. In this sample the objective is to transform the group of objects on the wall_framing and wall_skin layers to the selected face of the object on the 02_sketch layer.\n\n\n#! python 3\n\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\n\ndef get_objects_plane(objects):\n\n    objects_bbox = None\n    for obj in objects:\n        obj = rs.coercerhinoobject(obj)\n        obj_bbox = obj.Geometry.GetBoundingBox(True)\n        if obj_bbox.IsValid:\n            if objects_bbox is None:\n                objects_bbox = obj_bbox\n            else:\n                objects_bbox.Union(obj_bbox)\n    \n    if not objects_bbox or not objects_bbox.IsValid:\n        print(\"Could not compute bounding box for the group.\")\n        return\n    \n    # Compute the center points of both bounding boxes    \n    objects_center = objects_bbox.Center\n                    \n    # Define the coordinate system of the group\n    objects_min = objects_bbox.Min\n    objects_x_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, True) - objects_min)\n    objects_y_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(False, True, True) - objects_min)\n    objects_z_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, False) - objects_min)\n    \n    # Normalize the vectors\n    if objects_x_axis.Length > 0:\n        objects_x_axis.Unitize()\n    if objects_y_axis.Length > 0:\n        objects_y_axis.Unitize()\n    if objects_z_axis.Length > 0:\n        objects_z_axis.Uniti...",
  "code_blocks": [
    {
      "code": "def main():\n    # Step 1: Select 3 points on the face (target plane)\n    target_pts = rs.GetPoints(True, False, \"Select 3 points for the target plane\")\n    if not target_pts or len(target_pts) != 3:\n        print(\"You must select exactly 3 points.\")\n        return\n    \n    origin, x_dir_pt, y_dir_pt = target_pts\n    x_vec = rs.VectorUnitize(rs.VectorCreate(x_dir_pt, origin))\n    y_vec = rs.VectorUnitize(rs.VectorCreate(y_dir_pt, origin))\n    plane = rs.PlaneFromFrame(origin, x_vec, y_vec)\n    \n    # Step 2: Select objects to transform\n    objs = rs.GetObjects(\"Select objects to transform\", preselect=True)\n    if not objs:\n        print(\"No objects selected.\")\n        return\n\n    # Step 3: Select 3 reference points for objects' original position (objects_plane)\n    obj_pts = rs.GetPoints(True, False, \"Select 3 reference points\")\n    if not obj_pts or len(obj_pts) != 3:\n        print(\"You must select exactly 3 reference points.\")\n        return\n    \n    obj_origin, obj_x_dir_pt, obj_y_dir_pt = obj_pts\n    obj_x_vec = rs.VectorUnitize(rs.VectorCreate(obj_x_dir_pt, obj_origin))\n    obj_y_vec = rs.VectorUnitize(rs.VectorCreate(obj_y_dir_pt, obj_origin))\n    objects_plane = rs.PlaneFromFrame(obj_origin, obj_x_vec, obj_y_vec)\n\n    # Step 4: Compute and apply the transformation\n    arrXform = rs.XformRotation1(objects_plane, plane)\n    rs.TransformObjects(objs, arrXform, copy=False)\n\nmain()",
      "language": "python",
      "author": "rajaa",
      "post_number": 3,
      "is_solution": false
    },
    {
      "code": "#! python 3\n\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\n\ndef get_objects_plane(objects):\n\n    objects_bbox = None\n    for obj in objects:\n        obj = rs.coercerhinoobject(obj)\n        obj_bbox = obj.Geometry.GetBoundingBox(True)\n        if obj_bbox.IsValid:\n            if objects_bbox is None:\n                objects_bbox = obj_bbox\n            else:\n                objects_bbox.Union(obj_bbox)\n    \n    if not objects_bbox or not objects_bbox.IsValid:\n        print(\"Could not compute bounding box for the group.\")\n        return\n    \n    # Compute the center points of both bounding boxes    \n    objects_center = objects_bbox.Center\n                    \n    # Define the coordinate system of the group\n    objects_min = objects_bbox.Min\n\n    # THIS ISN'T QUITE RIGHT\n    # objects_x_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, True) - objects_min)\n    # objects_y_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(False, True, True) - objects_min)\n    # objects_z_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, False) - objects_min)\n\n    # THIS IS WHAT YOU WERE TRYING TO DO...\n    # BUT WHILE IT NO LONGER SQUASHES THE OBJECTS, THEY ARE ORIENTED WRONG\n    # objects_x_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(False, True, True) - objects_min)\n    # objects_y_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, False, True) - objects_min)\n    # objects_z_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, False) - objects_min)\n\n    # FOR SOME REASON WE HAVE TO SWITCH UP THE AXES LIKE THIS\n    objects_y_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(False, True, True) - objects_min)\n    objects_z_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, False, True) - objects_min)\n    objects_x_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, False) - objects_min)\n\n    # IT SEEMS NORMALIZING THE VECTORS IS UNNECESSARY\n    # (AT LEAST FOR WHAT THE SCRIPT DOES SO FAR)\n    # # Normalize the vectors\n    # if objects_x_axis.Length > 0:\n    #     objects_x_axis.Unitize()\n    # if objects_y_axis.Length > 0:\n    #     objects_y_axis.Unitize()\n    # if objects_z_axis.Length > 0:\n    #     objects_z_axis.Unitize()\n    \n    # Create planes for orientation    \n    objects_plane = Rhino.Geometry.Plane(objects_center, objects_x_axis, objects_y_axis)\n    return objects_plane\n\ngo = Rhino.Input.Custom.GetObject()\ngo.SubObjectSelect = True\ngo.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\ngo.SetCommandPrompt(\"Select face of object to transform objects to.\")\ngo.Get()                        \nres = go.Result()\n\nobjref = go.Object(0)  \ngeo = sc.doc.Objects.Find(objref.ObjectId)          \nface = objref.Geometry()\n\nif face.IsPlanar:\n   \n    res, plane = face.TryGetPlane()\n    if res and plane.IsValid:\n        objects = rs.GetObjects(\"Select objects to transform\", filter = rs.filter.polysurface)\n\n        objects_plane = get_objects_plane(objects)\n        print(f\"objects_plane is {objects_plane}\")\n        print(f\"plane is {plane}\")\n                \n        # Compute the transformation\n        xform = Rhino.Geometry.Transform.PlaneToPlane(objects_plane, plane)\n\n        # Apply the transformation to all group members\n        for obj in objects:\n            sc.doc.Objects.Transform(obj, xform, True)",
      "language": "python",
      "author": "webdunce",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "#! python 3\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino.Geometry as rg\n\ntarget_id = rs.GetObject('Select planar target surface', rs.filter.surface | rs.filter.polysurface, True, False, None, True)\nbbox = rs.BoundingBox(target_id)\n\ntarget = rs.coercesurface(target_id)\nif target:\n    if target.IsPlanar():\n        # record original u,v domains of surface\n        original_interval0 = target.Domain(0)\n        original_interval1 = target.Domain(1)\n\n        # unitize u,v domains\n        target.SetDomain(0, rg.Interval(0,1))\n        target.SetDomain(1, rg.Interval(0,1))\n\n        # make some isocurves across the middle of the surface\n        # in both the u and v directions\n        iso1 = target.IsoCurve(0, 0.5)\n        iso2 = target.IsoCurve(1, 0.5)\n\n        # set the domains back to what they were\n        target.SetDomain(0, original_interval0)\n        target.SetDomain(0, original_interval1)\n\n        origin = iso1.PointAtMid\n        target_pln = rg.Plane(origin, iso1.PointAtEnd - origin, iso2.PointAtEnd - origin)\n\n        pln2 = rg.PlaneSurface(target_pln, rg.Interval(-50,50), rg.Interval(-50,50))\n        \n        sc.doc.Objects.AddCurve(iso1)\n        sc.doc.Objects.AddCurve(iso2)\n        sc.doc.Objects.Add(pln2)\n    else:\n        print('Surface was not planar')\nelse:\n    print('You did not select a surface')",
      "language": "python",
      "author": "webdunce",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "#! python 3\n\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\n\ndef get_objects_plane(objects):\n\n    objects_bbox = None\n    for obj in objects:\n        obj = rs.coercerhinoobject(obj)\n        obj_bbox = obj.Geometry.GetBoundingBox(True)\n        if obj_bbox.IsValid:\n            if objects_bbox is None:\n                objects_bbox = obj_bbox\n            else:\n                objects_bbox.Union(obj_bbox)\n    \n    if not objects_bbox or not objects_bbox.IsValid:\n        print(\"Could not compute bounding box for the group.\")\n        return\n    \n    # Compute the center points of both bounding boxes    \n    objects_center = objects_bbox.Center\n                    \n    # Define the coordinate system of the group\n    objects_min = objects_bbox.Min\n    objects_x_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, True) - objects_min)\n    objects_y_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(False, True, True) - objects_min)\n    objects_z_axis = Rhino.Geometry.Vector3d(objects_bbox.Corner(True, True, False) - objects_min)\n    \n    # Normalize the vectors\n    if objects_x_axis.Length > 0:\n        objects_x_axis.Unitize()\n    if objects_y_axis.Length > 0:\n        objects_y_axis.Unitize()\n    if objects_z_axis.Length > 0:\n        objects_z_axis.Unitize()\n    \n    # Create planes for orientation    \n    objects_plane = Rhino.Geometry.Plane(objects_center, objects_x_axis, objects_y_axis)\n    return objects_plane\n\ngo = Rhino.Input.Custom.GetObject()\ngo.SubObjectSelect = True\ngo.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\ngo.SetCommandPrompt(\"Select face of object to transform objects to.\")\ngo.Get()                        \nres = go.Result()\n\nobjref = go.Object(0)  \ngeo = sc.doc.Objects.Find(objref.ObjectId)          \nface = objref.Geometry()\n\nif face.IsPlanar:\n   \n    res, plane = face.TryGetPlane()\n    if res and plane.IsValid:\n        objects = rs.GetObjects(\"Select objects to transform\", filter = rs.filter.polysurface)\n\n        objects_plane = get_objects_plane(objects)\n        print(f\"objects_plane is {objects_plane}\")\n        print(f\"plane is {plane}\")\n                \n        # Compute the transformation\n        xform = Rhino.Geometry.Transform.PlaneToPlane(objects_plane, plane)\n        \n        # Apply the transformation to all group members\n        for obj in objects:\n            sc.doc.Objects.Transform(obj, xform, True)",
      "language": "python",
      "author": "GaryC",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "layers",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 5,
  "views": 159
}