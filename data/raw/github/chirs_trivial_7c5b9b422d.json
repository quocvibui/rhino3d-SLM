{
  "source_url": "https://github.com/chirs/trivial/blob/c06da676e6061e4c497b134a546581c4886f8393/src/code/lewitt.py",
  "repo": "chirs/trivial",
  "repo_stars": 0,
  "repo_description": "trivia repository",
  "license": "unknown",
  "filepath": "src/code/lewitt.py",
  "instruction": "Sol Lewitt inspired work.",
  "code": "\n# Sol Lewitt inspired work.\n\nimport random\n\n#import rhinoscriptsyntax as rs\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\ndef random_connections(width, height, points):\n    \"\"\"\n    WALL DRAWING\n    BOSTON MUSEUM\n\n    On a wall surface, any\n    continuous stretch of wall,\n    using a hard pencil, place\n    fifty points at random.\n    The points should be evenly\n    distributed over the area \n    of the wall. All of the\n    points should be connected\n    by straight lines.\n    \"\"\"\n\n    px = []\n\n    for i in range(points):\n        x = random.uniform(0, width)\n        y = random.uniform(0, height)\n        px.append((x, y, 0))\n\n    lines = []\n\n    for i, p in enumerate(px):\n        connections = px[i+1:]\n        for c in connections:\n            line = (p, c)\n            lines.append(line)\n\n    for p in px:\n        rs.AddCircle(p, .5)\n\n    for start, end in lines:\n        rs.AddLine(start, end)\n\n\ndef wall_drawing_797(width, count, distance):\n    \"\"\"\n    The first drafter has a black marker and makes an irregular\n    horizontal line near the top of the wall. Then the second drafter\n    tries to copy it (without touching it) using a red marker. The third\n    drafter does the same, using a yellow marker. THe fourth drafter\n    does the same, using a blue marker. Then the second drafter,\n    followed by the third and fourth, copies the last line drawn until\n    the bottom of the wall is reached.\n    \"\"\"\n    # How to simulate a hand-drawn line?\n    \n\n\n# could do something with permutations here.\ndef create_grid(width, height):\n    l = []\n    for x in range(width):\n        for y in range(height):\n            p = (x, y, 0)\n            l.append(p)\n\n    return l\n\n\ndef create_inner_grid(width, height):\n    l = []\n    for x in range(1, width-1):\n        for y in range(1, height-1):\n            p = (x, y, 0)\n            l.append(p)\n\n    return l\n\n\n    \ndef wall_drawing_273(grid_size):\n    \"\"\"\n    7. Wall Drawing #273: Lines to points on a grid. A six-inch (15 cm) grid covering the wall. \n    Lines from the corners, sides, and center of the walls to random points on the grid. \n    Composite (seventh wall): red lines from the midpoints of four sides, \n      blue lines from four corners, yellow lines from the center. \n    1975\n    \"\"\"\n\n    grid_points = []\n\n    for i in range(grid_size):\n        for j in range(grid_size):\n            grid_points.append((i, j))\n\n    end = grid_size - 1\n    midpoint = grid_size / 2\n    origins = [\n        (0, 0), (0, midpoint), (0, end),\n        (midpoint, 0), (end, 0),\n        (midpoint, end), (end, midpoint), \n        (end, end), (midpoint, midpoint)\n        ]\n\n    lines = []\n\n    for origin in origins:\n        for e in range(10):\n            terminus = select_grid_point(grid_points, (0, end))\n            lines.append((origin, terminus))\n\n    lx = []\n\n    for start, end in lines:\n        s2 = (start[0], start[1], 0)\n        e2 = (end[0], end[1], 0)\n        lx.append(rs.AddLine(s2, e2))\n        #print(start)\n        #print(end)\n\n    g = rs.AddGroup(lx)\n    return g\n\n\n    #print(lines)\n\n    \"\"\"\n    for line in lines:\n        x0, y0 = lines[0]\n        x1, y1 = lines[1]\n        p0 = (x0, y0, 0)\n        p1 = (x1, y1, 0)\n        print(p0, p1)\n        #rs.AddLine(p0, p1)\n    \"\"\"\n\n\n\ndef select_grid_point(grid_points, exclude):\n    while True:\n        candidate = random.choice(grid_points)\n        if candidate[0] not in exclude and candidate[1] not in exclude:\n            return candidate\n\n\ndef open_cubes():\n    l = []\n    for n in range(2, 12): # all possible edge counts between 2 and 11\n        ix = open_cubes_n(n)\n        l.append(ix)\n\n    return l\n\n\n\ndef open_cubes_n(edge_count):\n    from cube import Cube\n\n    base_cube = Cube()\n    v0 = base_cube.vertices\n\n    orientations = Cube().orientations()\n    ocubes = [Cube(faces) for faces in orientations]\n\n    uniques = set()\n    edge_indices = itertools.permutations(range(12), edge_count)\n\n    # For every list of edge candidates,\n    # permute along 24 possible orientations\n    # if none of these is already in uniques\n    # this is a unique edge set and add it.\n\n    for ei in edge_indices:\n        unique = True\n\n        for oc in ocubes:\n            edges = oc.edges\n            l = []\n            for index in ei:\n                l.append(oc[index])\n                \n            t = tuple(l)\n            if t in uniques:\n                unique = False\n\n        if unique:\n            uniques.append(tuple(ei))\n            \n        return uniques\n        \n\n\n\n            \n\nif __name__ == \"__main__\":\n    #random_connections(80, 80, 50)\n\n    #wall_drawing_273(16)\n\n    open_cubes()\n\n    #units = 16\n    #for e in range(20):\n    #    wall_drawing_273(16)\n    \n        \n\n\n    \n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}