{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_SplitFloor2ThermalZones.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_SplitFloor2ThermalZones.py",
  "instruction": "Use this component to divide up a brep (polysurface) representative of a building floor into smaller volumes that roughly correspond to how a generic EnergyPlus model should be zoned.\nThis zoning...",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n#\n# This file is part of Honeybee.\n#\n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> and Saeran Vasanthakumar <saeranv@gmail.com>\n# Honeybee is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published\n# by the Free Software Foundation; either version 3 of the License,\n# or (at your option) any later version.\n#\n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n#\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to divide up a brep (polysurface) representative of a building floor into smaller volumes that roughly correspond to how a generic EnergyPlus model should be zoned.\nThis zoning divide up each floor into a core and perimeter zones, which helps account for the different microclimates you would get on each of the different orientations of a building.\nNote: This component is intended mainly for convex geometry. Most concave geometries will fail, and any shapes with holes in them will fail. You should therefore prepare the\nmassing of your building by dividing it into convex volumes before using this component.\n_\nIf you have a single mass representing two towers off of a podium, the two towers are not a continuous mass and you should therefore send each tower and the podium in as a separate Brep into this component.\nCore and perimeter zoneing should work for almost all masses where all walls are planar.\nWhile this component can usually get you the most of the way there, it is still recommended that you bake the output and check the geometry in Rhino before turning the breps into HBZones.\n_\nThe assumption about an E+ zone is that the air is well mixed and all at the same temperature.\nTherefore, it is usually customary to break up a building depending on the areas where you would expect different building microclimates to exist.\nThis includes breaking up the building into floors (since each floor can have a different microclimate) and breaking up each floor into a core zone and perimeter zones (since each side of the buidling gets a different amount of solar gains and losses/gains through the envelope).\nThis component helps break up building masses in such a manner.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _bldgFloors: A Closed brep or list of closed breps representing building floors. In this WIP only convex geometries and very simple concave geometries will succeed. You should prepare the massing of your building by dividing it into convex volumes before using this component. You can use the Honeybee_SplitBuildingMass2Floors to generate floors from a building mass.\n        _perimeterZoneDepth: A number for perimeter depths in Rhino model units that will be used to divide up each floor of the building into core and perimeter zones.\n    Returns:\n        readMe!: ...\n        splitBldgZones: A series of breps that correspond to the recommended means of breaking up building geometry into zones for energy simulations. All zones for each floor will have its own list.\n\n\"\"\"\n\n\nghenv.Component.Name = 'Honeybee_SplitFloor2ThermalZones'\nghenv.Component.NickName = 'Split2Zone'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"00 | Honeybee\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport rhinoscriptsyntax as rs\n\nfrom Rhino import RhinoApp\nimport heapq\nimport math\nimport copy\n\ntolerance = sc.doc.ModelAbsoluteTolerance\n\ndef checkTheInputs():\n    if len(_bldgFloors) != 0 and _bldgFloors[0] != None:\n        #Check for guid\n        for i,b in enumerate(_bldgFloors):\n            if type(b)==type(rs.AddPoint(0,0,0)):\n                _bldgFloors[i] = rs.coercebrep(b)\n\n        brepSolid = []\n        for brep in _bldgFloors:\n            if brep.IsSolid == True:\n                brepSolid.append(1)\n            else:\n                warning = \"Building floors must be closed solids!\"\n                print warning\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warning)\n        if sum(brepSolid) == len(_bldgFloors):\n            checkData1 = True\n\n    else:\n        checkData1 = False\n        print \"Connect closed solid building floors to split them up into zones.\"\n\n    if _perimeterZoneDepth != []:\n        checkData2 = True\n    else:\n        checkData2 = False\n        print \"A value must be conneted for _perimeterZoneDepth in order to run.\"\n\n    if checkData1 == True and checkData2 == True:\n        checkData = True\n    else: checkData = False\n\n    return checkData\n\n\ndef is_near_zero(num,eps=1E-10):\n    return abs(float(num)) < eps\n\nclass DoubleLinkedList(object):\n    #Creates empty doubly linked list\n    def __init__(self):\n        self.size = 0\n        self.head = None\n        self.tail = None\n    def __str__(self):\n        L = []\n        curr_node = self.head\n        for i in xrange(self.size):\n            L.append(curr_node.data)\n            curr_node = curr_node.next\n        return str(L)\n    def IsEmpty(self):\n        return self.size == 0\n    def __len__(self):\n        return self.size\n    def reset_size(self):\n        curr_node = self.head\n        self.size = 0\n        while curr_node != self.tail:\n            self.size += 1\n            curr_node = curr_node.next\n        self.size += 1\n    def append(self,data):\n        new_node = DLLNode(data)\n        if self.head == None:\n            self.head = self.tail = new_node\n        else:\n            #Add new node to front of list\n            new_node.prev = self.tail\n            new_node.next = None\n            self.tail.next = new_node\n            self.tail = new_node\n        #Now complete circle\n        self.head.prev = self.tail\n        self.tail.next = self.head\n        self.size += 1\n    def insert_node(self,new_node,prev_node):\n        #Modify the list of active vertices/nodes\n        #Swap node_A, node_B w/ V in LAV\n        next_node = prev_node.next\n\n        prev_node.next = new_node\n        next_node.prev = new_node\n        new_node.prev = prev_node\n        new_node.next = next_node\n\n        self.size += 1\n\n        #change if prev/next node were head/tail\n        if self.head == new_node.next:\n            self.tail = new_node\n        elif self.tail == new_node.prev:\n            self.tail = new_node\n\n    def remove_node(self,old_node):\n        #change if prev/next node were head/tail\n        if self.head == old_node:\n            self.head = old_node.next\n        elif self.tail == old_node:\n            self.tail = old_node.prev\n\n        next_node = old_node.next\n        prev_node = old_node.prev\n\n        next_node.prev = prev_node\n        prev_node.next = next_node\n\n        #Detach links from node\n        old_node.next = None\n        old_node.prev = None\n\n        self.size -= 1\n\n    def __getitem__(self, i):\n        #Worst case O(n) time. Don't use if not neccessary\n        curr_node = self.head\n        for j in xrange(self.size):\n            if i == j:\n                return curr_node\n            curr_node = curr_node.next\n        return None\n    def get_node_index(self,node_ref):\n        #Worst case O(n) time. Don't use if not neccessary\n        curr_node = self.head\n        for j in xrange(self.size):\n            if curr_node is node_ref:\n                return j\n            curr_node = curr_node.next\n        return None\nclass DLLNode(object):\n    def __init__(self,data):\n        self.data = data\n        self.next = None\n        self.prev = None\n    def __str__(self):\n        return str(self.data)\nclass Vertex(object):\n    def __init__(self,vertex,edge_prev=None,edge_next=None):\n        self.vertex = vertex\n        self.edge_prev = edge_prev\n        self.edge_next = edge_next\n        self.bisector_ray = None\n        self.is_reflex = False\n        self.is_processed = False\n    def __str__(self):\n        return str(self.vertex)\nclass Event(object):\n    def __init__(self,int_vertex,node_A,node_B,length2edge,event_type=\"event\",LAV=None):\n        self.int_vertex = int_vertex\n        self.node_A = node_A\n        self.node_B = node_B\n        self.event_type = event_type\n        self.length2edge = length2edge\n        self.LAV = LAV\n        self.opposite_edge = None\n    def __str__(self):\n        return str(self.int_vertex)\n\n\n#Adjacency list class make into own library\nclass _AdjGraphNode(object):\n    #This is a bare bones private class\n    def __init__(self,key,value,id,is_out_edge=False,adj_lst=None):\n        #adj_lst: ['key1', 'key2' ....  'keyn']\n        self.key = key\n        self.id = id\n        self.value = value\n        self.is_out_edge = is_out_edge\n        self.adj_lst = adj_lst if adj_lst!=None else []\n    def num_neighbor(self):\n        return len(self.adj_lst)\n    def __repr__(self):\n        return \"id: \" + str(self.id)\nclass AdjGraph(object):\n    #Graph as adjacency list\n    #Good ref for adj graphs: http://interactivepython.org/runestone/static/pythonds/Graphs/Implementation.html\n    #adj_graph is a dict like this:\n    #{key1: _AdjGraphNode.adj_lst = [2,4],\n    # key2: _AdjGraphNode.adj_lst = [3,4],\n    # key3: _AdjGraphNode.adj_lst = [4],\n    # key4: _AdjGraphNode.adj_lst = [1]}\n    #\n    # 1<--->4\n    # |  /  |\n    # 2---->3\n    #\n    def __init__(self,adj_graph=None):\n        self.adj_graph = adj_graph if adj_graph != None else {}\n        self.num_node = len(self.adj_graph.keys())\n    def vector2hash(self,vector,tol=4):\n        #Tolerance set to\n        myhash = \"(\"\n        for i in xrange(len(vector)):\n            coordinate = vector[i]\n            myhash += str(round(coordinate,tol))\n            if i < len(vector)-1:\n                myhash += \",\"\n        myhash += \")\"\n        return myhash\n    def add_node(self,key,value,is_out_edge=False):\n        #_AdjGraphNode is a private class\n        #Instantiate _AdjGraphNode, we creates key = num_node\n        if key in self.adj_graph:\n            n = self.adj_graph[key]\n            print n.id, ' key already exists in adj_graph!'\n            return self.adj_graph[key]\n        id = len(self.adj_graph.keys())\n        adj_graph_node = _AdjGraphNode(key,value,id,is_out_edge)\n        #Now add it to the adj_graph\n        self.adj_graph[key] = adj_graph_node\n        self.num_node += 1\n        return adj_graph_node\n    def __getitem__(self,k):\n        if k in self.adj_graph:\n            return self.adj_graph[k]\n        else:\n            return None\n    def keylst_2_nodelst(self,keylst):\n        return map(lambda k: self.adj_graph[k],keylst)\n    def add_directed_edge(self,key,key2add):\n        #This function will add existing node key to adjacency list of\n        #another node indicating a directed edge\n        if key in self.adj_graph and key2add in self.adj_graph:\n            node = self.adj_graph[key]\n            if key2add in node.adj_lst or key2add == key:\n                print 'key2add already in adj list or self-intersection'\n                return None\n            node.adj_lst.append(key2add)\n        else:\n            print 'key not in adj graph'\n    def recurse_ccw(self,refn,nextn,lok,cycle,count):\n        def get_ccw_angle(prev_dir,next_dir):\n            #Input prev_dir vector and next_dir vector in CCW ordering\n            #Output CCW angle between them in radians\n\n            #Reverse prev_dir order for angle checking\n            #We create a new vector b/c must be ccw order for reflex check\n            reverse_prev_dir = prev_dir * -1.0\n            #Use the dot product to find the angle\n            dotprod = rc.Geometry.Vector3d.Multiply(reverse_prev_dir,next_dir)\n            try:\n                cos_angle = dotprod/(prev_dir.Length * next_dir.Length)\n            except ZeroDivisionError:\n                print 'ZeroDivisionError'\n                cos_angle = 0.0\n\n            # Get angle from dot product\n            # This will be between 0 and pi\n            # b/c -1 < cos theta < 1\n            dotrad = math.acos(cos_angle)\n\n            #Use 2d cross product (axby - bxay) to see if next_vector is right/left\n            #This requires ccw ordering of vectors\n            #If cross is positive (for ccw ordering) then next_vector is to left (inner)\n            #If cross is negative (for ccw ordering) then next_vector is to right (outer)\n            #If cross is equal then zero vector, then vectors are colinear. Assume inner.\n\n            cross_z_sign = prev_dir[0] * next_dir[1] - prev_dir[1] * next_dir[0]\n            #print 'deg: ', round(math.degrees(dotrad),2)\n            #If reflex we must subtract 2pi from it to get reflex angle\n            if cross_z_sign < 0.0:\n                dotrad = 2*math.pi - dotrad\n            return dotrad\n\n        if True: pass #weird code folding glitch neccessitatest this\n        #Input list of keys\n        #output key with most ccw\n        #Base case\n        #print 'startid, chkid:', cycle[0].id, nextn.id\n        cycle.append(nextn)\n        cycle_id_lst = map(lambda n: n.id, cycle)\n        if nextn.id == cycle_id_lst[0] or count > 20:\n            return cycle\n\n        #print 'cycle', cycle_id_lst\n\n        #reference direction vector\n        ref_edge_dir =  nextn.value - refn.value\n\n        min_rad = float(\"Inf\")\n        min_node = None\n\n        for i in xrange(len(lok)):\n            k = lok[i]\n            n2chk = self.adj_graph[k]\n            #Make sure we don't backtrack\n            if n2chk.id == cycle_id_lst[-2]:\n                continue\n            chk_edge_dir = n2chk.value - nextn.value\n            #print 'chkccw', refn.id, '--', nextn.id, '--->', n2chk.id\n            rad = get_ccw_angle(ref_edge_dir,chk_edge_dir)\n            if rad < min_rad:\n                min_rad = rad\n                min_node = n2chk\n            #print '---'\n        #print 'min is', n2chk.id,':', round(math.degrees(rad),2)\n        #print '---'\n        alok = min_node.adj_lst\n\n        return self.recurse_ccw(nextn,min_node,alok,cycle,count+1)\n    def find_most_ccw_cycle(self):\n        #def helper_most_ccw(lok):\n\n        #Input adjacency graph\n        #Output loc: listof (listof (listof pts in closed cycle))\n        LOC = []\n        keylst = self.get_sorted_keylst()\n        for i in xrange(len(keylst)):\n            key = keylst[i]\n            root_node = self.adj_graph[key]\n            if not root_node.is_out_edge:\n                continue\n\n            #Identify the next node on outer edge\n            #b/c outer edge vertexes are placed first in adj graph\n            #worst complexity <= O(n)\n            for i in xrange(root_node.num_neighbor()):\n                adj_key = root_node.adj_lst[i]\n                neighbor = self.adj_graph[adj_key]\n                if neighbor.is_out_edge:\n                    next_node = neighbor\n                    break\n\n            #Now we recursively check most ccw\n            n_adj_lst = next_node.adj_lst\n            cycle = [root_node]\n            try:\n                cycle = self.recurse_ccw(root_node,next_node,n_adj_lst,cycle,0)\n            except:\n                pass\n            #print '-------\\n-----FINISHED CYCLE\\n', cycle, '---\\---\\n'\n            LOC.append(cycle)\n        #print '-'\n        return LOC\n    def get_sorted_keylst(self):\n        valuelst = self.adj_graph.values()\n        valuelst.sort(key=lambda v: v.id)\n        keylst = map(lambda v: v.key,valuelst)\n        return keylst\n    def is_near_zero(self,num,eps=1E-10):\n        return abs(float(num)) < eps\n    def __repr__(self):\n        keylst = self.get_sorted_keylst()\n        strgraph = \"\"\n        for i in xrange(len(keylst)):\n            key = keylst[i]\n            node = self.adj_graph[key]\n            strgraph += str(node.id) + ': '\n            strgraph += str(map(lambda k: self.adj_graph[k].id,node.adj_lst))\n            strgraph += '\\n'\n        return strgraph\n    def __contains__(self,key):\n        return self.adj_graph.has_key(key)\n\nclass Shape:\n    \"\"\"\n    Temporary class for WIP!\n    \"\"\"\n    def __init__(self,geom,flrcrv=None):\n        def get_dim_bbox(b):\n            ## counterclockwise, start @ bottom SW\n            #      n_wt\n            #      -----\n            #      |   |\n            # w_ht |   | e_ht = y_dist\n            #      |   |\n            #      -----\n            #     s_wt = x_dist\n            \"\"\"    self.s_wt,self.e_ht,self.n_wt,self.w_ht \"\"\"\n            return b[:2],b[1:3],b[2:4],[b[3],b[0]]\n        self.geom = geom\n        self.bottom_crv = flrcrv\n        self.base_matrix = None\n        self.cplane = None\n        self.normal = rc.Geometry.Vector3d(0,0,1)\n        self.bbpts = self.get_boundingbox(self.geom,self.cplane)\n        self.s_wt,self.e_ht,self.n_wt,self.w_ht = get_dim_bbox(self.bbpts)\n        self.ew_vector = self.n_wt[1]-self.n_wt[0]\n        self.ns_vector = self.e_ht[1]-self.e_ht[0]\n        \"\"\"\n        print 'check ew'\n        print self.primary_axis_vector.IsParallelTo(self.ew_vector)\n        print self.primary_axis_vector.IsPerpendicularTo(self.ew_vector)\n        print ''\n        \"\"\"\n        self.set_base_matrix()\n        # x,y,z distances\n        self.x_dist = float(rs.Distance(self.s_wt[0],self.s_wt[1]))\n        self.y_dist = float(rs.Distance(self.e_ht[0],self.e_ht[1]))\n        self.cpt = rc.Geometry.AreaMassProperties.Compute(self.bottom_crv).Centroid\n\n        try:\n            if self.cplane == None:\n                self.cplane = self.get_cplane_advanced(self.geom)\n            self.primary_axis_vector = self.cplane.YAxis\n        except Exception as e:\n            print str(e)##sys.exc_traceback.tb_lineno\n            self.cplane, self.primary_axis_vector = None, None\n        self.ht = float(self.bbpts[4][2])\n    def is_near_zero(self,num,eps=1E-10):\n        return abs(float(num)) < eps\n    def get_boundingbox(self,geom_,cplane_):\n        def check_bbpts(b):\n            ## check if 3d shape and if first 4 pts at bottom\n            if b[0][2] > b[4][2]:\n                b_ = b[4:] + b[:4]\n                b = b_\n            return b\n        try:\n            bbpts_ = rs.BoundingBox(geom_,cplane_)\n            return check_bbpts(bbpts_)\n        except Exception as e:\n            print \"Error @ get_boundingbox\"\n            #print str(e)#sys.exc_traceback.tb_lineno\n    def get_shape_axis(self,crv=None):\n        def helper_group_parallel(AL):\n            ## Identifies parallel lines and groups them\n            lop = []\n            CULLDICT = {}\n            for i,v in enumerate(AL):\n                refdist = rs.Distance(v[0],v[1])\n                refdir = v[1] - v[0]\n                power_lst = []\n                if i < len(AL)-1 and not CULLDICT.has_key(refdist):\n                    power_lst.append(refdist)\n                    AL_ = AL[i+1:]\n                    for v_ in AL_:\n                        currdist = rs.Distance(v_[0],v_[1])\n                        currdir = v_[1] - v_[0]\n                        if currdir.IsParallelTo(refdir) != 0 and not CULLDICT.has_key(currdist):\n                            power_lst.append(currdist)\n                            CULLDICT[currdist] = True\n                if power_lst != []:\n                    power_lst.sort(reverse=True)\n                    power_num = reduce(lambda x,y: x+y,power_lst)\n                else:\n                    power_num = 0.\n                lop.append(power_num)\n            return lop\n\n        ### Purpose: Input 2d planar curve\n        ### and return list of vector axis based\n        ### on prominence\n        ##debug = sc.sticky['#debug']\n        try:\n            if crv==None:\n                crv = self.bottom_crv\n            axis_matrix = self.set_base_matrix(crv)\n            if axis_matrix != []:\n                axis_power_lst = helper_group_parallel(axis_matrix)\n                pa_index = axis_power_lst.index(max(axis_power_lst))\n                pa_vector = axis_matrix[pa_index][1]-axis_matrix[pa_index][0]\n            else:\n                #degenerate crv\n                pa_vector = None\n            self.primary_axis_vector = pa_vector\n            return self.primary_axis_vector\n        except Exception as e:\n            print \"Error @ shape.get_shape_axis\"\n            print str(e)#sys.exc_traceback.tb_lineno\n    def get_cplane_advanced(self,g):\n        def helper_define_axis_pts(primary_vec):\n            ##(origin,x,y)\n            o_pt_ = rc.Geometry.Point3d(0,0,0)\n            y_pt_ = primary_vec\n            z_pt_ = rc.Geometry.Vector3d(0,0,1)\n            ## construct x_pt_ using the communitive property of crossproduct\n            x_pt_ = rc.Geometry.Vector3d.CrossProduct(y_pt_,z_pt_)\n            return o_pt_,x_pt_,y_pt_\n        #try:\n        if True:\n            if self.is_guid(g):\n                brep = rs.coercebrep(g)\n            else: brep = g\n            ##debug = sc.sticky['#debug']\n            ## Get primary axis\n            nc = self.bottom_crv.ToNurbsCurve()\n            planar_pts = [nc.Points[i].Location for i in xrange(nc.Points.Count)]\n            primary_axis_vector = self.get_shape_axis(self.bottom_crv)\n            if primary_axis_vector:\n                o_pt,x_pt,y_pt = helper_define_axis_pts(primary_axis_vector)\n            else:\n                #degenerate shape\n                o_pt = rc.Geometry.Point3d(0,0,0)\n                x_pt = rc.Geometry.Point3d(1,0,0)\n                y_pt = rc.Geometry.Point3d(0,1,0)\n            cplane = rc.Geometry.Plane(o_pt,x_pt,y_pt)\n            return cplane\n        #except Exception as e:\n        #    print \"Error @ shape.get_cplane_advanced\"\n        #    print str(e)#sys.exc_traceback.tb_lineno\n    def move_geom(self,guidobj,dir_vector,copy=False):\n        #Moves a geometry\n        #Note, you MUST convert to guid and convert back to rc geom\n        xf = rc.Geometry.Transform.Translation(dir_vector)\n        xform = rs.coercexform(xf, True)\n        guidid = rs.coerceguid(guidobj, False)\n        guidid = sc.doc.Objects.Transform(guidid, xform, not copy)\n        return guidid\n    def get_long_short_axis(self):\n        if (self.x_dist > self.y_dist):\n            long_dist,short_dist = self.x_dist,self.y_dist\n            long_axis,short_axis = 'EW','NS'\n        else:\n            long_dist,short_dist = self.y_dist,self.x_dist\n            long_axis,short_axis = 'NS','EW'\n        return long_axis,long_dist,short_axis,short_dist\n    def get_bottom(self,g,refpt,tol=1.0,bottomref=0.0):\n        ## Extract curves from brep according to input cpt lvl\n        ##debug = sc.sticky['#debug']\n        IsAtGroundPlane = False\n        if abs(refpt[2]-bottomref) < 0.01:\n            #print 'ground ref at:', refpt[2]\n            refpt.Z += 1.0\n            IsAtGroundPlane = True\n        if g == None: g = self.geom\n            ##debug.append(g)\n        try:\n            if g == None: g = self.geom\n            #print g\n            if self.is_guid(refpt): refpt = rs.coerce3dpoint(refpt)\n            if self.is_guid(g): g = rs.coercebrep(g)\n            plane = rc.Geometry.Plane(refpt,rc.Geometry.Vector3d(0,0,1))\n\n            crv = g.CreateContourCurves(g,plane)[0]\n            if IsAtGroundPlane==True:\n                crv = sc.doc.Objects.AddCurve(crv)\n                move_crv = self.move_geom(crv,rc.Geometry.Vector3d(0,0,-1.))\n                crv = rs.coercecurve(move_crv)\n            return crv\n        except Exception as e:\n            #print 'chk', refpt.Z\n            ##debug.append(refpt)\n            print \"Error @ shape.get_bottom\"\n            print str(e)#sys.exc_traceback.tb_lineno\n    def is_guid(self,geom):\n            return type(rs.AddPoint(0,0,0)) == type(geom)\n    def set_base_matrix(self,crv=None):\n        ## Breaks up geometry into:\n        ##[ [[vector1a,vector1b],  // line 1\n        ##   [vector2a,vector2b],  // line 2\n        ##          ....\n        ##   [vectorna, vectornb]] // line n\n        ## topological ordering preserved\n        ## direction counterclockwise\n        ## but can start from anywhere!\n        ##debug = sc.sticky['#debug']\n\n        if self.base_matrix == None:\n            if crv == None:\n                if self.bottom_crv == None:\n                    bbrefpt = self.get_boundingbox(self.geom,None)[0]\n                    self.bottom_crv = self.get_bottom(self.geom,bbrefpt,bottomref=bbrefpt[2])\n                crv = self.bottom_crv\n\n            segments = crv.DuplicateSegments()\n            matrix = []\n            for i in xrange(len(segments)):\n                segment = segments[i]\n                nc = segment.ToNurbsCurve()\n                end_pts = [nc.Points[i_].Location for i_ in xrange(nc.Points.Count)]\n                matrix.append(end_pts)\n            self.base_matrix = matrix\n        return self.base_matrix\n    def check_colinear_pt(self,crv,testpt,tol=0.01):\n        ## May need to swap with own method\n        dist = ghcomp.CurveClosestPoint(testpt,crv)[2]\n        IsColinear = True if abs(dist-0.)<tol else False\n        return IsColinear\n    def intersect_infinite_lines(self,line1,line2):\n        #Input line1 and line2\n        #where: line: (startpt,endpt)\n        #and startpt and endpt are rc.Geometry.Point3d\n        #Compute intersection of infinite lines\n        #Return point of intersection\n        ##debug = sc.sticky['#debug']\n        intersect_pt = None\n        #Convert to rhino common geometry obj\n        line1 = rc.Geometry.Line(line1[0],line1[1])\n        line2 = rc.Geometry.Line(line2[0],line2[1])\n\n        int_exist,a,b = rc.Geometry.Intersect.Intersection.LineLine(line1,line2,0.001,False)\n        if int_exist:\n            intersect_pt = line2.PointAt(b)\n        return intersect_pt\n    def planar_intersect_ray_with_line(self,base_vector,direction_vector,linept1,linept2,refz=0.0):\n        #Input: ray (basevector and dirvector), line (two pts)\n        #Output: intersection point or else False\n        #Will only take place in 2d at defined z ht\n        #This function took me half a day to understand!\n\n        r0 = base_vector\n        r1 = direction_vector\n        a = linept1\n        b = linept2\n\n        #For ray: r0,r1; and line: a,b\n        #parametric form of ray: r0 + t_1*r1 = pt\n        #parametric form of line: a + t_2*b = pt\n\n        #ray: r0 + t * d\n        #r0: base point\n        #d: direction vector\n        #t = scalar parameter t, where 0 <= t < infinity\n        #if line segment, then 0 <= t <= 1 is the parametric form of a line.\n\n        #Solve for r0 + t_1*r1 = a + t_2*b; two unknowns t_1, t_2\n        #This can result in a lot of algebra, but essentially can\n        #simplify to the vector operations below\n        #Ref: http://stackoverflow.com/questions/14307158/how-do-you-check-for-intersection-between-a-line-segment-and-a-line-ray-emanatin\n\n        ## This needs to have push/pop/transformation matrix\n        ## so that it can work outside of z-axis\n        def helper_flatten_z(lst,z):\n            return rc.Geometry.Vector3d(lst[0],lst[1],z)\n\n        ##debug = sc.sticky['#debug']\n        z = 0.0 #flatten then unflatten\n        a = helper_flatten_z(a,z)\n        b = helper_flatten_z(b,z)\n\n        #Correct the ordering of the line segment\n        IsCCW = self.check_vertex_order(refline=[a,b])\n        if not IsCCW:\n            a,b = b,a\n\n        r0 = helper_flatten_z(r0,z)\n        r1 = helper_flatten_z(r1,z)\n        ray_dir = r0+(r1*5) - r0#(r0+r1) - r0\n        ##debug.append(rs.AddCurve([r0,ray_dir+r0]))\n        ##debug.append(b)\n\n        ortho = rc.Geometry.Vector3d(ray_dir.Y*-1.,ray_dir.X,z)\n        aToO = r0 - a\n        aToB = b - a\n        point_intersect = False\n        denominator = aToB * ortho\n        #Check if zero: Then cos(90) = 0, or ray normal and segment\n        #perpendicular therefore no intersection\n\n        if not self.is_near_zero(denominator):\n            cross_prod = rc.Geometry.Vector3d.CrossProduct(aToB,aToO)\n            dot_prod = ortho * aToO\n            t_1 = cross_prod.Length / denominator\n            t_2 = dot_prod / denominator\n\n            #t_1 = abs(t_1)\n            #t_2 = abs(t_2)\n            if (t_2 >= 0. and t_2 <= 1.) and t_1 >= 0.: #t_1 can go to infinity\n                #print 't1', t_1\n                #print 't2', t_2\n                #print '--'\n                ##debug.append(rs.AddCurve([r0,ray_dir+r0]))\n                #Collision detected\n                ix,iy = r0.X + (t_1 * ray_dir.X), r0.Y + (t_1 * ray_dir.Y)\n                #print t_1\n                point_intersect = rc.Geometry.Vector3d(ix,iy,refz)\n        #if point_intersect:\n            ##debug.append(point_intersect)\n            ##debug.append(rs.AddCurve([r0,point_intersect]))\n        return point_intersect\n    def intersect_ray_with_line(self,base_vector,direction_vector,linept1,linept2,refz=None):\n        #Input: ray (basevector and dirvector), line (two pts)\n        #Output: intersection point or else False\n        #Same as above but with rhinocommon library\n\n        vertical_tolerance = -5.0\n        r0 = base_vector\n        r1 = direction_vector\n        a = linept1\n        b = linept2\n        a.Z = a.Z + vertical_tolerance\n        b.Z = b.Z + vertical_tolerance\n        if refz==None: refz = self.ht\n        refz -= vertical_tolerance\n        ##debug = sc.sticky['#debug']\n\n        #extrude as surface to check int\n        upnormal = self.normal * refz\n        upnormalcrv = rc.Geometry.Curve.CreateControlPointCurve([self.cpt,self.cpt + upnormal])\n        reflinepath = rc.Geometry.Curve.CreateControlPointCurve([a,b])\n        srf2int = rc.Geometry.SumSurface.Create(reflinepath,upnormalcrv)\n        ray = rc.Geometry.Ray3d(r0,r1)\n        point_intersect_lst = rc.Geometry.Intersect.Intersection.RayShoot(ray,[srf2int],1)\n        if point_intersect_lst:\n            point_intersect_lst = list(point_intersect_lst)\n            ##debug.extend(point_intersect_lst)\n            ##debug.append(self.cpt)\n        return point_intersect_lst\n    def intersect_ray_to_infinite_line(self,raypt,raydir,line):\n        #Input: Ray(raystartpt, ray_dir_vector)\n        #and Line (startpt, endpt)\n        #Output intersection in direction of ray\n\n        ray_line = (raypt,rc.Geometry.Point3d(raypt + raydir))\n        int_pt = self.intersect_infinite_lines(ray_line,line)\n\n        #Check validity of int_pt\n        if not int_pt:\n            return None\n        #Identify if intpt same dir as ray dir\n        ref_dir = raydir\n        int_dir = rc.Geometry.Vector3d(int_pt-raypt)\n\n        #If int_pt = start_pt then intpt \"behind\" vertex\n        if self.is_near_zero(int_dir.Length):\n            return None\n\n        dotprod = ref_dir * int_dir\n        cos_theta = dotprod/(ref_dir.Length * int_dir.Length)\n        #if cos theta = 1 is parellel b/c cos(0) = 1\n        if cos_theta < 0.0:\n            return None\n\n        return int_pt\n    def extend_ray_to_line(self,chk_ray,lineref):\n        #ray: (ray_origin (pt), ray_dir (vector))\n        #line: control point curve\n        #Output: line that is intersected\n        chk_line = rc.Geometry.Curve.CreateControlPointCurve([chk_ray[0],chk_ray[0]+chk_ray[1]*2.],0)\n        chk_line.SetStartPoint(chk_ray[0])\n        #Checking t parameter: 0.0 = ray_origin, 1.0 = ray_endpt\n        #b,t = chk_line.ClosestPoint(chk_ray[0],0.001)\n        #print t < chk_line.Domain.Mid\n        chk_line_end = rc.Geometry.CurveEnd.End\n        int_line = chk_line.ExtendByLine(chk_line_end,[lineref])\n        return int_line\n    def get_inner_angle(self,v_prev,v_next,anglerad):\n        #Input: v2,v1 as direction vectors facing away from ref pt, and angle to check\n        # True if cross is positive\n        # False if negative or zero\n        #Ref: http://stackoverflow.com/questions/20252845/best-algorithm-for-detecting-interior-and-exterior-angles-of-an-arbitrary-shape\n        IsPositive = v_next[0] * v_prev[1] > v_prev[0] * v_next[1]\n        if not IsPositive:\n            anglerad = 2.*math.pi - anglerad\n        return anglerad\n    def convert_shape_to_circular_double_linked_list(self):\n\n        LAV = DoubleLinkedList()\n        #Add all vertices and incident edges from polygon\n        for i in xrange(len(self.base_matrix)):\n            v = self.base_matrix[i][0]\n            i -= 1\n            #Edge data is stable. We don't relink it in LAV\n            edge_prev = self.base_matrix[i]\n            edge_next = self.base_matrix[i+1]\n            vrt = Vertex(v,edge_prev,edge_next)\n            LAV.append(vrt)\n        return LAV\n    def compute_interior_bisector_vector(self,LAV,angle_index=False):\n        #Computes interior bisector ray for all vertices in LAV\n        #If single_angle_index == index, will only check that vertice\n        ##debug = sc.sticky['#debug']\n        for i in xrange(LAV.size):\n            curr_node = LAV[i]\n            if type(angle_index)==type(1) and not self.is_near_zero(i-angle_index):\n                continue\n\n            edge_prev = curr_node.data.edge_prev\n            edge_next = curr_node.data.edge_next\n\n            # Get two vectors pointing AWAY from the curr_vertex\n            # i.e <--- v --->\n            dir_prev = edge_prev[0]-edge_prev[1]\n            dir_next = edge_next[1]-edge_next[0]\n            dir_prev.Unitize()\n            dir_next.Unitize()\n            \n            # Get angle / Make this own function?\n            dotprod = rc.Geometry.Vector3d.Multiply(dir_next,dir_prev)\n            cos_theta = dotprod/(dir_next.Length * dir_prev.Length)\n            \n            # Deal with floating point precision errors from the dot product\n            # by setting tolerances for domain limit of -1, 1, and 0\n            \n            # at 90 deg\n            if self.is_near_zero(cos_theta):\n                dotrad = math.pi/2.0\n            # at 180 or 0 deg (collinear)\n            if self.is_near_zero(abs(cos_theta) - 1.0):\n                dotrad = 0.0 \n            else:\n                dotrad = math.acos(cos_theta)\n            \n            inrad = self.get_inner_angle(dir_prev,dir_next,dotrad)\n\n            if inrad > math.pi:\n                curr_node.data.is_reflex = True\n                ##debug.append(curr_node.data.vertex)\n            \n            #print 'deg:', round(math.degrees(inrad),2)\n            #print 'is reflex:', curr_node.data.is_reflex\n\n            #Flip the cross prod if dotprod gave outer angle\n            if self.is_near_zero(abs(inrad - dotrad)):\n                crossprod = rc.Geometry.Vector3d.CrossProduct(dir_prev,dir_next)\n            else:\n                crossprod = rc.Geometry.Vector3d.CrossProduct(dir_next,dir_prev)\n\n            #Rotate next point CCW by inner_rad\n            #We could also use unit vector addition to get biesctor\n            dir_next.Rotate(-inrad/2.,crossprod)\n\n            #Create bisector ray\n            ray_origin = curr_node.data.vertex\n            ray_dir = dir_next\n            #Create ray tuple\n            curr_node.data.bisector_ray = (ray_origin,ray_dir)\n\n            xchk = 178.000124531\n            xcor = curr_node.data.vertex[0]\n            if True==False:#Sangle_index == 0 and i == 0: #and self.is_near_zero(abs(xcor-xchk),1):\n                print curr_node.data.vertex[0]\n                ##debug.append(curr_node.data.vertex)\n                ptlst = [ray_origin,ray_origin+ray_dir*15.0]\n                ##debug.append(rc.Geometry.Curve.CreateControlPointCurve(ptlst))\n                ##debug.append(rc.Geometry.Curve.CreateControlPointCurve(edge_prev))\n                ##debug.append(rc.Geometry.Curve.CreateControlPointCurve(edge_next))\n\n        return LAV\n    def find_opposite_edge_from_node(self,curr_node_,SLAV_,is_LOV=True,edge_event_=None,cchk=None):\n        def distline2pt(v,w,p):\n            ##This algorithm returns the minimum distance between\n            ##line segment vw and point p\n            ##Modified from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n            ##This is the explaination from stackoverflow for ref:\n            ##Consider the line extending the segment, parameterized as v + t (w - v).\n            ##We find projection of point p onto the line.\n            ##It falls where t = [(p-v) . (w-v)] / |w-v|^2\n            ##We clamp t from [0,1] to handle points outside the segment vw.\n\n            ##Convert to rc geometry\n            v = rc.Geometry.Vector3d(v)\n            w = rc.Geometry.Vector3d(w)\n            p = rc.Geometry.Vector3d(p)\n\n            ##Create dir vectors for line and point\n            wv = w-v\n            pv = p-v\n\n            ##Calculate |w-v|^2 w/o costly sqrt\n            lsq = wv.SquareLength\n            # Check for zero line segment case: v == w\n            if self.is_near_zero(lsq):\n                return pv.Length\n\n            ##ProjectionPVonWV = (w-v)/|w-v| * (w-v)/|w-v| * (p-v)\n            ##simplfiied = projpv = (w-v) * ((p-v) * (w-v))/|w-v|^2\n            ##Then: projpv - p == perpendicular line\n\n            ##clamp_to_line: ((p-v) * (w-v))/|w-v|^2\n            ##(w-v): wv\n            ##projpv = clamp_to_line * wv\n            clamp_to_line = (pv * wv)/lsq\n\n            ##This is to handle points outside line segment. They will have\n            ##obtuse angle so costheta < 0. in that case will clamp_to_line factor == 0.\n            ##therefore if obtuse, clamp_to_line turns projpv into a zero vector and\n            ##and will return (non perpendicular) distance from point v to p.\n            clamp_to_line = max(0., min(1.,clamp_to_line))\n            projpv = clamp_to_line * wv\n\n            ##Instead of simply subtracting projpv-p, we first add it to v\n            ##and then subtract it from p\n            ##This is so that if p is outside of line segment, then projpv = 0 vector, so\n            ##v - p will be our minimum distance.\n            perpvector = (v + projpv) - p\n\n            ##Return values\n            perpgeom = rs.AddLine(projpv,p)\n            perpline = rs.AddLine(v,w)\n            perppt = rc.Geometry.Point3d(p)\n            return perpvector.Length, (perpgeom,perpline,perppt)\n        #Split event: when interior vertex hits opposite edge, splitting\n        #polygon in two\n        #Compute point B, where a 'split event' will occur\n        #Returns opposite edge, B, and node_A if exists\n        #print 'is_reflex', curr_node_.data.is_reflex\n        #debug = sc.sticky[\"#debug\"]\n        raypt = curr_node_.data.bisector_ray[0]\n        raydir = curr_node_.data.bisector_ray[1]\n\n        ##debug.append(vertex_bisector_line[1])\n        #Loop through LAV original edges\n        min_dist = float(\"Inf\")\n        min_candidate_B = None\n        min_edge_line = None\n        min_node_A = None\n        #print '\\n\\ncurrverte', curr_node_.data.vertex[0]\n        debugisfirst = False\n        #if self.is_near_zero(abs(curr_node_.data.vertex[0] - 434.),1.0):\n        #    debugisfirst = True\n        #if not debugisfirst:\n        #    #debug.append(curr_node_.data.vertex)\n        #print 'checking reflex ----------'\n        #if edge_event_ != None:\n        #    print 'This is second round LAV'#, edge_event_.opposite_edge\n        #Botffy uses original edges (LOV) to calculate split events\n        #But Felzel and Obdzel seem to suggest use active SLAV...\n\n        for i in xrange(len(SLAV_)):\n            LAV_ = SLAV_[i]\n            for j in xrange(LAV_.size):\n                #print '-\\nj', j\n                orig_node_ = LAV_[j]\n\n                edge_line = [orig_node_.data.vertex,orig_node_.data.edge_next[1]]\n                if edge_event_!= None:\n                    opposite_edge = edge_event_.opposite_edge\n                    orig_oppo_vec = opposite_edge[1] - opposite_edge[0]\n                    orig_oppo_vec.Unitize()\n\n                    edge_line_next_vec = orig_node_.data.edge_next[1] - orig_node_.data.vertex\n                    edge_line_prev_vec = orig_node_.data.vertex - orig_node_.data.edge_prev[0]\n                    edge_line_next_vec.Unitize()\n                    edge_line_prev_vec.Unitize()\n                    #print 'is parrallel', orig_oppo_vec.IsParallelTo(edge_line_next_vec,0.01)\n                    #print 'is parrallel', orig_oppo_vec.IsParallelTo(edge_line_prev_vec, 0.01)\n\n                    if orig_oppo_vec == edge_line_next_vec and edge_event_.opposite_edge[0] == orig_node_.data.vertex:\n                        #print 'is next vec'\n                        edge_line = [orig_node_.data.vertex, orig_node_.data.edge_next[1]]# orig_node_.next.data.vertex]#\n                    elif orig_oppo_vec == edge_line_prev_vec and edge_event_.opposite_edge[0] == orig_node_.data.edge_prev[0]:\n                        #print 'is prev vec'\n                        edge_line = [orig_node_.data.edge_prev[0], orig_node_.data.vertex]#[orig_node_.prev.data.vertex,orig_node_.data.vertex]#\n                    else:\n                        #print 'cant find match'\n                        edge_line = [orig_node_.data.vertex, orig_node_.data.edge_next[1]]#[orig_node_.data.vertex, orig_node_.next.data.vertex]\n                        #break\n\n                    #if norm == v.edge_left.v.normalized() and event.opposite_edge.p == v.edge_left.p:\n        \t\t\t#\tx = v\n        \t\t\t#\ty = x.prev\n        \t\t\t#elif norm == v.edge_right.v.normalized() and event.opposite_edge.p == v.edge_right.p:\n        \t\t\t#\ty=v\n        \t\t\t#\tx=y.next\n\n                #print 'why is this failing'\n                #print orig_node_.data.edge_next\n                #print edge_line\n                #print '-'\n                #edge_line = orig_node_.data.edge_prev\n\n                chk_next = edge_line == curr_node_.data.edge_next\n                chk_prev = edge_line == curr_node_.data.edge_prev\n                if chk_next or chk_prev:\n                    continue\n\n                bisect_int_pt = self.intersect_ray_to_infinite_line(raypt,raydir,edge_line)\n                if not bisect_int_pt:\n                    continue\n\n                #Now we use edge_line to compute point B\n                #pt_B: intersection btwn bisector at V and\n                #bisector btwn least parrallel edge starting at V and edge_line\n\n                #Choose least parallel edge for curr_node_.prev/next with edge_line\n                #Maintain CCW ordering\n                #Note that we are using pointers to edge_next/edge_prev\n                edge_next_vec = curr_node_.data.edge_next[1] - curr_node_.data.edge_next[0]\n                edge_prev_vec = curr_node_.data.edge_prev[1] - curr_node_.data.edge_prev[0]\n                edge_line_vec = edge_line[1] - edge_line[0]\n\n                edge_prev_vec.Unitize()\n                edge_next_vec.Unitize()\n                edge_line_vec.Unitize()\n\n                #Use dot prod to get angle\n                prev_rad = math.acos(edge_prev_vec * edge_line_vec)\n                next_rad = math.acos(edge_next_vec * edge_line_vec)\n\n                #Store this info carefully bc need it for Event creation\n                if next_rad > prev_rad:\n                    vertex_edge_line = curr_node_.data.edge_next\n                else:\n                    vertex_edge_line = curr_node_.data.edge_prev\n\n                vertex_vec = vertex_edge_line[1]-vertex_edge_line[0]\n                #vertex_vec.Unitize()\n\n                #print 'print chk prallel', edge_line_vec.IsParallelTo(vertex_vec)\n\n                #Intersection at edge\n                edge_int_pt = self.intersect_infinite_lines(vertex_edge_line,edge_line)\n                if not edge_int_pt:\n                    continue\n\n                #Now get bisector btwn edge_line and vertex_edge_line\n                #B_bisect: edge_line_vec.unitize - vertex_edge_vec.unitize\n                #^ Trying a cleaner way to get angle bisector!\n                vertex_edge_vec = vertex_edge_line[1] - vertex_edge_line[0]\n                #Unitize edge vectors to create rhombus for bisector\n                vertex_edge_vec.Unitize()\n                edge_line_vec.Unitize()\n                #Get bisector by subtraction\n\n                B_bisect_dir =  edge_line_vec - vertex_edge_vec\n\n                B_bisect_dir.Unitize()\n\n\n\n                Bline = [edge_int_pt, edge_int_pt + B_bisect_dir*50.0]\n                #if j==2:\n                #    pass##debug.extend(vertex_edge_line)\n                    ##debug.append(curr_node_.data.vertex)\n                rayline = [raypt, raypt + raydir]\n                B = self.intersect_infinite_lines(Bline,rayline)\n                if not B:\n                    continue\n                #if not debugisfirst:\n                    #if j<=3:#if j==1:#if cchk >= j:\n                    #    #debug.append(B)\n                #if debugisfirst and j==0:\n                #    #debug.append(B)\n                #else:\n                #    break\n                #print 'B exists'\n\n                #Check if B is bound by edge_line, and left,right bisectors of edge_line\n                def is_pt_bound_by_vectors(pt2chk,ray2chk,direction=\"istoleft\",chkdebug=False):\n                    #Input: pt, and ray(raypt, raydir)\n                    #Output: Bool if bound by area (i.e. inside)\n                    #This function uses cross product to see if pt2chk is inside rays\n                    boundvec = (ray2chk[0] + ray2chk[1]) - ray2chk[0]\n                    chkvec = pt2chk - ray2chk[0]\n                    boundvec.Unitize()\n                    chkvec.Unitize()\n                    if j==0 and debugisfirst:\n                        pass##debug.append(ray2chk[0])\n                        ##debug.append(ray2chk[0] + ray2chk[1])\n                        ##debug.append(pt2chk)\n                        ##debug.append(ray2chk[0])\n\n                    crossprod2d = boundvec[0]*chkvec[1] - chkvec[0]*boundvec[1]\n                    #print 'crossprod is: ', crossprod2d\n                    #print 'actual cross', rc.Geometry.Vector3d.CrossProduct(boundvec,chkvec)\n                    #print 'dir', direction\n                    #print res = a[0] * b[1] - b[0] * a[1]\n\n                    if self.is_near_zero(crossprod2d):\n                        #print 'cross prod at 0, must be parallel edges'\n                        #print 'print chk prallel', boundvec.IsParallelTo(chkvec)\n                        IsBound = True\n                    elif direction==\"istoright\":\n                        IsBound = True if crossprod2d < 0.0 else False\n                    else:\n                        IsBound = True if crossprod2d > 0.0 else False\n                    return IsBound\n\n                #Create left/right bisectors from edge\n                #Using node.next rather then node.data.edge_next... careful...\n                def _cross(a, b):\n                \tres = a[0] * b[1] - b[0] * a[1]\n                \treturn res\n\n                \"\"\"\n                xleft =  _cross(edge.bisector_left.v.normalized(), (b - edge.bisector_left.p).normalized())  > 0\n    \t\t\txright = _cross(edge.bisector_right.v.normalized(), (b - edge.bisector_right.p).normalized())  <  0\n    \t\t\txedge =  _cross(edge.edge.v.normalized(), (b - edge.edge.p).normalized()) < 0\n                \"\"\"\n\n                #if j==3 and not debugisfirst:\n                #    #debug.append(orig_node_.data.vertex)\n                #    #debug.append(orig_node_.next.data.vertex)\n                    #edgeline = rc.Geometry.Curve.CreateControlPointCurve(edge_line)\n                    ##debug.append(edgeline)\n\n                leftray = orig_node_.data.bisector_ray\n                IsLeftBound = is_pt_bound_by_vectors(B,leftray,direction=\"istoright\",chkdebug=True)\n                #if edge_event_: print 'isleftbound', IsLeftBound\n\n                rightray = orig_node_.next.data.bisector_ray\n                IsRightBound = is_pt_bound_by_vectors(B,rightray,direction=\"istoleft\")\n                #if edge_event_: print 'isrightbound', IsRightBound\n\n                bottomray = (edge_line[0], edge_line_vec)\n                IsBottomBound = is_pt_bound_by_vectors(B,bottomray,direction=\"istoleft\")\n                #if edge_event_: print 'isbottombound', IsBottomBound\n\n                if not (IsLeftBound and IsRightBound and IsBottomBound):\n                    continue\n\n                #if debugisfirst and edge_event_ != None and j==1:\n                #    debug.append(B)\n\n                #print 'B is bound'\n                #if debugisfirst and j==0:\n                #    print 'this B is bound'\n                    ##debug.append(B)\n\n                #prevdist,g = distline2pt(pn1,pn2,int_prev.PointAtEnd)\n                #B_dist,g_ = distline2pt(edge_line[0],edge_line[1],B)\n                B_dist = B.DistanceTo(curr_node_.data.vertex)\n\n                if min_dist > B_dist:\n                    min_dist = B_dist\n                    min_candidate_B = B\n                    min_edge_line = edge_line\n                    min_node_A = curr_node_\n\n                #edgeline = rc.Geometry.Curve.CreateControlPointCurve(edge_line)\n                ##debug.extend(min_edge_line)\n                #edgeline = rc.Geometry.Curve.CreateControlPointCurve(vertex_edge_line)\n                ##debug.append(edgeline)\n                ##debug.append(edge_int_pt)\n                #print '-'\n        return min_edge_line, min_candidate_B, min_node_A\n    def find_polygon_events(self,LAV,SLAV,PQ,angle_index=False,cchk=None):\n        def distline2pt(v,w,p):\n            ##This algorithm returns the minimum distance between\n            ##line segment vw and point p\n            ##Modified from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n            ##This is the explaination from stackoverflow for ref:\n            ##Consider the line extending the segment, parameterized as v + t (w - v).\n            ##We find projection of point p onto the line.\n            ##It falls where t = [(p-v) . (w-v)] / |w-v|^2\n            ##We clamp t from [0,1] to handle points outside the segment vw.\n\n            ##Convert to rc geometry\n            v = rc.Geometry.Vector3d(v)\n            w = rc.Geometry.Vector3d(w)\n            p = rc.Geometry.Vector3d(p)\n\n            ##Create dir vectors for line and point\n            wv = w-v\n            pv = p-v\n\n            ##Calculate |w-v|^2 w/o costly sqrt\n            lsq = wv.SquareLength\n            # Check for zero line segment case: v == w\n            if self.is_near_zero(lsq):\n                return pv.Length\n\n            ##ProjectionPVonWV = (w-v)/|w-v| * (w-v)/|w-v| * (p-v)\n            ##simplfiied = projpv = (w-v) * ((p-v) * (w-v))/|w-v|^2\n            ##Then: projpv - p == perpendicular line\n\n            ##clamp_to_line: ((p-v) * (w-v))/|w-v|^2\n            ##(w-v): wv\n            ##projpv = clamp_to_line * wv\n            clamp_to_line = (pv * wv)/lsq\n\n            ##This is to handle points outside line segment. They will have\n            ##obtuse angle so costheta < 0. in that case will clamp_to_line factor == 0.\n            ##therefore if obtuse, clamp_to_line turns projpv into a zero vector and\n            ##and will return (non perpendicular) distance from point v to p.\n            clamp_to_line = max(0., min(1.,clamp_to_line))\n            projpv = clamp_to_line * wv\n\n            ##Instead of simply subtracting projpv-p, we first add it to v\n            ##and then subtract it from p\n            ##This is so that if p is outside of line segment, then projpv = 0 vector, so\n            ##v - p will be our minimum distance.\n            perpvector = (v + projpv) - p\n\n            ##Return values\n            perpgeom = rs.AddLine(projpv,p)\n            perpline = rs.AddLine(v,w)\n            perppt = rc.Geometry.Point3d(p)\n            return perpvector.Length, (perpgeom,perpline,perppt)\n\n        #debug = sc.sticky['#debug']\n        #Create Priotity Queue from Python module\n        #Ref: https://docs.python.org/2.7/library/heapq.html#priority-queue-implementation-notes\n\n        #hypothenuse = sqrt(a^2 + b^2) = c; to get longest line\n        side1 = self.get_long_short_axis()[1]\n        side2 = self.get_long_short_axis()[3]\n        linedim = math.sqrt(side1*side1 + side2*side2)\n\n        debug_minev = None\n\n        for i in xrange(LAV.size):\n            curr_node = LAV[i]\n            if type(angle_index)==type(1) and not self.is_near_zero(i-angle_index):\n                continue\n\n            curr_ray = curr_node.data.bisector_ray\n            prev_ray = curr_node.prev.data.bisector_ray\n            next_ray = curr_node.next.data.bisector_ray\n\n            #In case of reflex angle, edge_event or split_event can occur\n            split_event_pt = None\n            if curr_node.data.is_reflex==True:\n                #print 'found reflex'\n                if angle_index==False:\n                    split_event_line, split_event_pt, split_node_A = self.find_opposite_edge_from_node(curr_node,SLAV,cchk=cchk)\n                else:\n                    #print 'this is not LOV'\n                    split_event_line, split_event_pt, split_node_A = self.find_opposite_edge_from_node(curr_node,SLAV,is_LOV=False,cchk=cchk)\n                ##debug.append(split_event_pt)\n            else:\n                pass#print 'not reflex'\n            #Get intersection\n            p_start = curr_ray[0] + (curr_ray[1]*-1) * linedim\n            p_end = curr_ray[0]+curr_ray[1]*linedim\n            curr_line = rc.Geometry.Curve.CreateControlPointCurve([p_start,p_end],0)\n\n            #!!!should check for parallel edge case\n            int_prev = self.extend_ray_to_line(prev_ray,curr_line)\n            int_next = self.extend_ray_to_line(next_ray,curr_line)\n\n            #Get nodes from prevedge and nextedge for distance check\n            #Use edge pointers we stored earlier as\n            #we updated LAV. This edge pointer point back to original edges in polgon\n            #but changes along with LAV\n\n            pn1,pn2 = curr_node.data.edge_prev[0],curr_node.data.edge_prev[1]\n            nn1,nn2 = curr_node.data.edge_next[0],curr_node.data.edge_next[1]\n\n            ##--- Debug ---##\n            def debug_dist2line(pn1,pn2,curr_node,int_prev,int_next):\n                pdt,g1 = distline2pt(pn1,pn2,int_prev.PointAtEnd)\n                ndt,g2 = distline2pt(nn1,nn2,int_next.PointAtEnd)\n\n                #debug.append(curr_line)\n                #debug.append(curr_node.prev.data.vertex)\n                #debug.append(curr_node.data.vertex)\n                ##debug.append(curr_ray[0]+curr_ray[1]*5)\n                #debug.append(curr_node.next.data.vertex)\n                ##debug.append(g1[0])#proj\n                #debug.append(g1[1])#line\n                #debug.append(g1[2])#pt\n                ##debug.append(g2[0])#proj\n                #debug.append(g2[1])#line\n                #debug.append(g2[2])#pt\n            ##debug_dist2line(pn1,pn2,curr_node,int_prev,int_next)\n            ##--- Debug ---##\n\n            event_tuple = []\n            ##ref: __init__(self,int_vertex,node_A,node_B,length2edge):\n            #node_A, node_B are the two nodes whose intersection creates new node\n            if int_prev != None:\n                #Calculate distance to original edge in polygon\n                prevdist,g = distline2pt(pn1,pn2,int_prev.PointAtEnd)\n                #Event: (I (point3d), Va (pointer to previos node in LAV), Vb (pointer to next node in LAV), current node, ....)\n                prev_edge_event = Event(int_prev.PointAtEnd,curr_node.prev,curr_node,prevdist,\"edge\")#int_prev.GetLength(),curr_node)\n                event_tuple.append(prev_edge_event)\n            if int_next != None:\n                #Calculate distance to edge\n                nextdist,g = distline2pt(nn1,nn2,int_next.PointAtEnd)\n                next_edge_event = Event(int_next.PointAtEnd,curr_node,curr_node.next,nextdist,\"edge\")#int_next.GetLength(),curr_node)\n                event_tuple.append(next_edge_event)\n            if split_event_pt != None:\n                split_event_dist,g = distline2pt(split_event_line[0],split_event_line[1],split_event_pt)\n                split_edge_event = Event(split_event_pt,split_node_A,split_event_line,split_event_dist,\"split\")\n                split_edge_event.opposite_edge = split_event_line\n                event_tuple.append(split_edge_event)\n            #make edge_event\n            #event_tuple.append(edge_event)\n\n            if event_tuple:\n                min_event = min(event_tuple, key=lambda e: e.length2edge)\n                min_event.LAV = LAV #store pointer to LAV\n                heapq.heappush(PQ,(min_event.length2edge,min_event))\n                if angle_index:\n                    debug_minev = min_event\n\n            #print '-'\n        #print '----'\n        return PQ, debug_minev\n    def shape_to_adj_graph(self):\n        #Purpose: converts bottom of polygon into a adjacency list\n        #Input: self base_matrix\n        #Output: adjacency list polygon shape as directed cycles\n\n        #Add all vertices from polygon\n        ##base_matrix: listof (list of edge vertices)\n        #Label of vertice is index (may have to change this to coordinates)\n        #Instantiate with empty adjancencies\n        ##debug = sc.sticky[\"#debug\"]\n        adjgraph = AdjGraph()\n        for i in xrange(len(self.base_matrix)-1):\n            prev_v = self.base_matrix[i-1][0]\n            prev_key = adjgraph.vector2hash(prev_v)\n            prev_node = adjgraph[prev_key]\n\n            #If beggining need to add previous node\n            if prev_node == None:\n                prev_node = adjgraph.add_node(prev_key,prev_v,is_out_edge=True)\n                first_key = prev_node.key\n            curr_v = self.base_matrix[i][0]\n            #add_node(key,value)\n            curr_key = adjgraph.vector2hash(curr_v)\n            curr_node = adjgraph.add_node(curr_key,curr_v,is_out_edge=True)\n            adjgraph.add_directed_edge(prev_key,curr_key)\n        #Make sure to connect last edge back to first edge\n        adjgraph.add_directed_edge(curr_key,first_key)\n        return adjgraph\n    def update_shape_adj_graph(self,adj_graph_,exist_vertex,new_vertex,twoside=True):\n        # Update our adjacency list\n        #Get the key by hashing vertex\n        exist_key = adj_graph_.vector2hash(exist_vertex)\n        new_key = adj_graph_.vector2hash(new_vertex)\n        #Get the node with the key\n        exist_node = adj_graph_[exist_key]\n\n        if new_key in adj_graph_:\n            new_node = adj_graph_[new_key]\n        else:\n            new_node = adj_graph_.add_node(new_key,new_vertex)\n            #print 'newnode', new_node\n\n        #Add new node to graph\n        adj_graph_.add_directed_edge(exist_key,new_key)\n        if twoside == True:\n            adj_graph_.add_directed_edge(new_key,exist_key)\n        return adj_graph_\n    def straight_skeleton(self,perimeter_depth,stepnum):\n        ##debug = sc.sticky[\"#debug\"]\n        #Move this into its own repo/class\n        #call bibil for shape libraries\n        #thats how we can transition to HB\n\n        ##Initialization of ABNunlo\n        #Organize given vertices into LAV in SLAV\n        #Set of LAV: (listof LAV)\n        SLAV = []\n        PQ = []\n\n        #LAV: doubly linked list (DLL).\n        #Initialize List of Active Vertices as Double Linked List\n        LAV = self.convert_shape_to_circular_double_linked_list()\n        adj_graph = self.shape_to_adj_graph()\n        #Compute the vertex angle bisector (ray) bi\n        LAV = self.compute_interior_bisector_vector(LAV)\n        #Keep a copy of LAV for original polygon\n        #LOV: List of Original Vertices\n        LOV = copy.deepcopy(LAV)\n\n        #Add LAV to SLAV\n        SLAV.append(LAV)\n        #Compute bisector intersections and maintain Priority Queue of Edge Events\n        #An edge event is when a edge shrinks to point in Straight Skeleton\n        PQ,minev = self.find_polygon_events(LAV,SLAV,PQ,cchk=stepnum)\n\n        #Main skeleton algorithm\n        ##--- Debug ---##\n        #print 'length: ', len(PQ), ' vertices'\n        count = 0\n        create_geom = True\n        debug_crv = stepnum\n        ##--- Debug ---##\n        #if True:\n        #    return None\n        while len(PQ) > 0 and count<=30:\n\n            if count > stepnum:\n                break\n            #print '-'\n            #print 'count: ', count\n            #edge_event: int_vertex,int_arc,node_A,node_B,length2edge\n\n            #Priority Queue as Heap data structure\n            #time complexity for insertion is: O(nlogn)\n            #space complexity is: O(1)\n            #find minimum is O(1) time, so good for us!\n            #heap absolutely, completely beats sorting arrays is a\n            #situation where small numbers of items are removed or added,\n            #and after each change you want to know again which is the\n            #smallest element\n\n            edge_event = heapq.heappop(PQ)[1]\n\n            #Get specific LAV from SLAV using event class\n            LAV_ = edge_event.LAV\n            #print 'lav size', LAV_.size\n            if edge_event.event_type == \"edge\":\n                #print 'event type edge'\n\n                #If not processed this edge will shrink to zero edge\n                if edge_event.node_A.data.is_processed or edge_event.node_B.data.is_processed:\n                    #print '0 peak'\n                    count+=1\n                    continue\n\n                Vc_I_arc = None\n                #Check for peak of the roof event\n                #print 'eenA', edge_event.node_A.prev\n                def debug_LAV_links(LA):\n                    #print '---- ----'\n                    #print 'checking LAV_ size is:', LAV.size\n                    for cnt in xrange(LAV.size):\n                        cn = LAV[cnt]\n                        #if cnt > 4:\n                        #    break\n                        #print cnt, \":\", self.vector2hash(cn.data.vertex,1)\n                        #print ''\n                        #if cnt == 5:\n                            #debug.append(cn.next.data.vertex)\n                        ##debug.append(cn.data.vertex)\n                    #print '---- ----'\n\n                ##debug_LAV_links(LAV_V1)\n                ##debug.append(edge_event.node_A.data.vertex)\n                #print edge_event.node_A.data.is_processed\n                #break\n\n                if edge_event.node_A.prev.prev is edge_event.node_B:\n                    #print '3 peak'\n                    new_int_vertex = edge_event.int_vertex\n                    A_vertex = edge_event.node_A.data.vertex\n                    B_vertex = edge_event.node_B.data.vertex\n                    prev_A_vertex = edge_event.node_A.prev.data.vertex\n\n                    #Update adjacency graph\n                    adj_graph = self.update_shape_adj_graph(adj_graph,prev_A_vertex,new_int_vertex)\n                    adj_graph = self.update_shape_adj_graph(adj_graph,A_vertex,new_int_vertex)\n                    adj_graph = self.update_shape_adj_graph(adj_graph,B_vertex,new_int_vertex)\n\n                    Vc_I_arc = rc.Geometry.Curve.CreateControlPointCurve([prev_A_vertex, new_int_vertex])\n                    Va_I_arc = rc.Geometry.Curve.CreateControlPointCurve([A_vertex, new_int_vertex])\n                    Vb_I_arc = rc.Geometry.Curve.CreateControlPointCurve([B_vertex, new_int_vertex])\n\n                    #if create_geom and debug_crv >= 0 and debug_crv >= count:\n                        ##debug.append(Va_I_arc)\n                        ##debug.append(Vb_I_arc)\n                        ##debug.append(Vc_I_arc)\n                        #pass\n                    edge_event.node_A.data.is_processed = True\n                    edge_event.node_B.data.is_processed = True\n                    count += 1\n\n                    #Update the adjacency list\n                    #tbd\n                    continue\n\n                new_int_vertex = edge_event.int_vertex\n                A_vertex = edge_event.node_A.data.vertex\n                B_vertex = edge_event.node_B.data.vertex\n                #Update adjacency graph\n                adj_graph = self.update_shape_adj_graph(adj_graph,A_vertex,new_int_vertex)\n                adj_graph = self.update_shape_adj_graph(adj_graph, B_vertex,new_int_vertex)\n\n                Va_I_arc = rc.Geometry.Curve.CreateControlPointCurve([A_vertex, new_int_vertex])\n                Vb_I_arc = rc.Geometry.Curve.CreateControlPointCurve([B_vertex, new_int_vertex])\n                #print '2 peak'\n                if create_geom and debug_crv >= 0 and debug_crv >= count:\n                    ##debug.append(Va_I_arc)\n                    ##debug.append(Vb_I_arc)\n                    pass\n\n                #Pointer to appropriate edge for bisector compution\n                #Note that these edges according to Felkel and Obdrsalek are NOT adjacent\n                #edges, but actually original edges from polygon linked via LAV\n                new_prev_edge = edge_event.node_A.data.edge_prev\n                new_next_edge = edge_event.node_B.data.edge_next\n\n                #Create new vertex node\n                int_vertex_obj = Vertex(edge_event.int_vertex,new_prev_edge,new_next_edge)\n                V = DLLNode(int_vertex_obj)\n\n                LAV_.insert_node(V,edge_event.node_A)\n                LAV_.remove_node(edge_event.node_A)\n                LAV_.remove_node(edge_event.node_B)\n\n                #Mark as processed\n                edge_event.node_A.data.is_processed = True\n                edge_event.node_B.data.is_processed = True\n\n                #Now compute bisector and edge event for new V node\n                V_index = LAV_.get_node_index(V)\n                LAV_ = self.compute_interior_bisector_vector(LAV_,angle_index=V_index)\n                PQ,minev = self.find_polygon_events(LAV_,SLAV,PQ,angle_index=V_index,cchk=count)\n            else:\n                #print 'split event type'\n                #If not processed this edge will shrink to zero edge\n                ##ref: __init__(self,int_vertex,node_A,node_B,length2edge):\n                if edge_event.node_A.data.is_processed:# or edge_event.node_B==True:\n                    count+=1\n                    continue\n\n                #if count == 2:\n                #    #debug.append(edge_event.node_A.data.vertex)\n                #    #debug.extend(edge_event.node_B)\n\n                int_vertex = edge_event.int_vertex\n                node_V = edge_event.node_A #this is the only node/vertex that points to I/int_vertex\n\n                #C) Check for peak of the roof event\n                ref_edge = edge_event.node_B\n                if LAV_.size < 3:\n                    Vb_H_arc = rc.Geometry.Curve.CreateControlPointCurve([LAV.head.data.vertex,LAV.head.next.data.vertex])\n                    ##debug.append(Vb_H_arc)\n                    #print 'LAV == 2'\n                    count += 1\n                    #edge_event.node_A.data.is_processed = True\n                    continue\n\n                if edge_event.node_A.next.next.data.vertex == ref_edge[0]:\n                    pass#print '3 peak'\n                    \"\"\"\n                    #edge_event.node_A.prev.prev.data.vertex == ref_edge[0]:\n                    new_int_vertex = edge_event.int_vertex\n                    A_vertex = edge_event.node_A.data.vertex\n                    B_vertex = ref_edge[1]\n                    prev_A_vertex = edge_event.node_A.prev.data.vertex\n\n                    Vc_I_arc = rc.Geometry.Curve.CreateControlPointCurve([prev_A_vertex, new_int_vertex])\n                    Va_I_arc = rc.Geometry.Curve.CreateControlPointCurve([A_vertex, new_int_vertex])\n                    Vb_I_arc = rc.Geometry.Curve.CreateControlPointCurve([B_vertex, new_int_vertex])\n\n                    #debug.append(Vc_I_arc)\n                    #debug.append(Va_I_arc)\n                    #debug.append(Vb_I_arc)\n\n                    edge_event.node_A.data.is_processed = True\n                    #edge_event.node_B = True\n                    count += 1\n                    continue\n                    \"\"\"\n\n                #D) Output arc\n                split_I_arc = rc.Geometry.Curve.CreateControlPointCurve([int_vertex, node_V.data.vertex])\n                #Update adjacency graph\n                adj_graph = self.update_shape_adj_graph(adj_graph,node_V.data.vertex,int_vertex)\n\n                if create_geom and debug_crv >= 0 and debug_crv >= count:\n                    pass##debug.append(split_I_arc)\n                #print '2 peak'\n                edge_event.node_A.data.is_processed = True\n                #if count == 7:\n                #    #debug.append(LAV_.head.next.data.vertex)\n\n                #Find opposite edge from V\n                #Botsky just uses original, Fezkel suggests do it again.\n                opposite_edge, opposite_I, opposite_A = self.find_opposite_edge_from_node(node_V,SLAV,edge_event_=edge_event)\n                #print 'does opposited edgevent exist????222', edge_event\n                #opposite_A is the node that you are evaluating for split_events, likely won't be used\n                if opposite_edge == None:\n                    #print 'Opposite edge not found! line 1930'\n                    count += 1\n                    continue\n                #Make two copies of V for our LAV splitting\n                #Add pointer to edge. This is based on Figure 6 from Felkel and Obdrzalek\n                vertex_V1 = Vertex(opposite_I,node_V.data.edge_prev,opposite_edge)\n                vertex_V2 = Vertex(opposite_I,opposite_edge,node_V.data.edge_next)\n                node_V1 = DLLNode(vertex_V1)\n                node_V2 = DLLNode(vertex_V2)\n\n                #E) Modify the SLAV\n                #Match the correct nodes to vertex from opposite_edge event ref\n                #The trick here is to ensure new opposite node may not be original original\n                #watch out for LAVs that share a vertex but not same node linked in different LAV\n                op_zero_node,op_one_node = None, None\n                #opposite_vector = opposite_edge[1] - opposite_edge[0]\n                for i in xrange(len(SLAV)):\n                    LAV__ = SLAV[i]\n                    for j in xrange(LAV__.size):\n                        chk_zero_pt = LAV__[j].data.vertex\n                        chk_one_pt = LAV__[j].next.data.vertex\n                        #chk_vector = chk_one_pt - chk_zero_pt\n                        #IsVector = opposite_vector.IsParallelTo(chk_vector)\n                        IsLine = chk_zero_pt == opposite_edge[0] and chk_one_pt == opposite_edge[1]\n                        if IsLine:\n                            op_zero_node = LAV__[j]\n                            op_one_node = LAV__[j].next\n                            break\n                    if op_zero_node != None:\n                        break\n\n                if op_zero_node == None or op_one_node == None:\n                    #print 'opposite edge nodes not found!'\n                    count += 1\n                    continue\n\n                def copy_DLL_from_node(old_LAV):\n                    copy_LAV = DoubleLinkedList()\n                    curr_node = old_LAV.head\n                    while curr_node != old_LAV.tail:\n                        copy_LAV.append(curr_node.data)\n                        curr_node = curr_node.next\n                    #get tail data in to\n                    copy_LAV.append(curr_node.data)\n                    return copy_LAV\n\n\n                #Split LAV - V1\n                node_V.prev.next = node_V1\n                op_one_node.prev = node_V1\n                node_V1.prev = node_V.prev\n                node_V1.next = op_one_node\n                #Copy LAV_ for V1\n                LAV_.head = node_V1\n                LAV_.tail = node_V1.prev\n                LAV_V1 = copy_DLL_from_node(LAV_)\n\n\n                #Split LAV - V2\n                node_V.next.prev = node_V2\n                op_zero_node.next = node_V2\n                node_V2.next = node_V.next\n                node_V2.prev = op_zero_node\n\n                ##debug.append(node_V.next.data.vertex)\n                ##debug.append(opposite_left_node.data.vertex)\n                #Copy LAV_ for V2\n                LAV_.head = node_V2\n                LAV_.tail = node_V2.prev\n                LAV_V2 = copy_DLL_from_node(LAV_)\n\n                #remove node_V\n                #LAV_.remove_node(node_V)\n                node_V.next = None\n                node_V.prev = None\n\n                #opposite_left_node.is_processed = True\n                #opposite_right_node.is_processed = True\n\n                for i in xrange(len(SLAV)):\n                    if SLAV[i] == LAV_:\n                        SLAV[i] = None\n\n                SLAV = filter(lambda n: n!=None,SLAV)\n                SLAV.append(LAV_V1)\n                SLAV.append(LAV_V2)\n                #print 'LAV_V1', len(LAV_V1)\n                #print 'LAV_V2', len(LAV_V2)\n\n                for i in xrange(len(SLAV)):\n                    LAV__ = SLAV[i]\n                    if LAV__.size < 3:\n                        for j in xrange(LAV__.size):\n                            cn = LAV__[j]\n                            cn.is_processed = True\n\n                #Now compute bisector and edge event for new V1/2 node\n                V1_index = LAV_V1.get_node_index(node_V1)\n                V2_index = LAV_V2.get_node_index(node_V2)\n\n                LAV_V1 = self.compute_interior_bisector_vector(LAV_V1,angle_index=V1_index)\n                LAV_V2 = self.compute_interior_bisector_vector(LAV_V2,angle_index=V2_index)\n\n                PQ,minev = self.find_polygon_events(LAV_V1,SLAV,PQ,angle_index=V1_index,cchk=count)\n\n                def debug_LAV_links(LAV):\n                    print '---- ----'\n                    print 'checking LAV_ size is:', LAV.size\n                    for cnt in xrange(LAV.size):\n                        cn = LAV[cnt]\n                        #if cnt > 4:\n                        #    break\n                        print cnt, \":\", self.vector2hash(cn.data.vertex,1)\n                        print ''\n                        #if cnt == 5:\n                        #    #debug.append(cn.next.data.vertex)\n                        #debug.append(cn.data.vertex)\n                    print '---- ----'\n\n                ##debug.append(opposite_edge[0])\n                ##debug.append(opposite_edge[1])\n                ##debug.append(node_V.data.vertex)\n                ##debug.append(node_V1.data.vertex)\n                ##debug_LAV_links(LAV_V1)\n                ##debug_LAV_links(LAV_V1)\n                ##debug.append(LAV_V2.head.next.next.data.vertex)\n                #break\n                PQ,minev = self.find_polygon_events(LAV_V2,SLAV,PQ,angle_index=V2_index,cchk=count)\n                #break\n            count += 1\n\n        #Take the cycles and create perimeter\n        #print adj_graph\n\n        #loc: listof (listof cycles)\n        loc = adj_graph.find_most_ccw_cycle()\n        #Get offset\n        corner_style = rc.Geometry.CurveOffsetCornerStyle.Sharp\n        core_crv_lst = self.bottom_crv.Offset(self.cpt,\\\n                                 self.normal,perimeter_depth,\\\n                                 sc.doc.ModelAbsoluteTolerance,corner_style)\n\n        ##debug.extend(core_crv_lst)\n        core_brep_lst = []\n        split_zones = []\n        if core_crv_lst == None:\n            core_crv_lst = []\n        if not self.is_near_zero(len(core_crv_lst)):\n            for i in xrange(len(core_crv_lst)):\n                core_crv_chk = core_crv_lst[i]\n                if not core_crv_chk.IsClosed:\n                    continue\n                try:\n                    core_extrusion = rc.Geometry.Extrusion.Create(core_crv_chk,\\\n                                                              self.ht-self.cpt[2],True)\n                    core_brep = core_extrusion.ToBrep()\n                    core_brep_lst.append(core_brep)\n                except:\n                    pass\n        #debug.extend(core_brep_lst)\n        split_zones.extend(core_brep_lst)\n        #if len(core_brep_lst)>1:\n        #    print 'we have multiple cores check the way we are diffing this:',\\\n        #     len(core_brep_lst)\n        #Make preimeter breps\n\n        for i in xrange(len(loc)):\n            cycle = loc[i]\n            ptlst = map(lambda n: n.value,cycle)\n\n            # This is to deal with degenerate polygons (just two lines) by making it into a triangle\n            # Could be a better solution for this.\n            if len(ptlst) < 4:\n                ptlst.append(ptlst[0])\n\n            per_crv = rc.Geometry.PolylineCurve(ptlst)\n            per_extrusion = rc.Geometry.Extrusion.Create(per_crv,self.ht-self.cpt[2],True)\n            per_brep = per_extrusion.ToBrep()\n            diff_per_lst = []\n            if not self.is_near_zero(len(core_brep_lst)):\n                for i in xrange(len(core_brep_lst)):\n                    core_brep = core_brep_lst[i]\n                    diff_per = rc.Geometry.Brep.CreateBooleanDifference(per_brep,\\\n                                                                        core_brep,sc.doc.ModelAbsoluteTolerance)\n\n                    #If no difference, then just include original zone\n                    if diff_per == None or self.is_near_zero(len(diff_per)):\n                        diff_per_lst.append(per_brep)\n                    else:\n                        diff_per_lst.extend(diff_per)\n            else:#if no core just include original zone\n                diff_per_lst = [per_brep]\n            split_zones.extend(diff_per_lst)\n            ##debug.extend(diff_per_lst)\n\n\n        \"\"\"\n        #For #debugging/checkign\n        tnode.grammar.type['idlst'] = []\n        tnode.grammar.type['ptlst'] = []\n        for key in adj_graph.get_sorted_keylst():\n            node = adj_graph[key]\n            if True:#if node.id == 4:\n                ##debug.append(node.value)\n                tnode.grammar.type['idlst'].append(node.id)\n                tnode.grammar.type['ptlst'].append(node.value)\n                #adj_node_lst = adj_graph.get_adj_lst_as_node_lst(key)\n                ##debug.extend(adj_node_lst)\n        print 'final count: ', count\n        print '--'\n        \"\"\"\n        #print split_zones\n        #print '--'\n        adj_graph = None\n        return [split_zones]\n\n\ndef main(mass, _perimeterZoneDepth):\n    ##debug = sc.sticky['#debug']\n    #Import the Ladybug Classes.\n    if sc.sticky.has_key('ladybug_release')and sc.sticky.has_key('honeybee_release'):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n\n        splitZones = []\n        for i in xrange(len(mass)):\n            mass_ = mass[i]\n\n            if _perimeterZoneDepth < 0.001:\n                splitZones.append([mass_])\n                continue\n            #bbBox = mass_.GetBoundingBox(rc.Geometry.Plane.WorldXY)\n            #maxHeights = bbBox.Max.Z\n            #minHeights = bbBox.Min.Z\n            #splitters, flrCrvs, topIncl, nurbL, lastInclu = getFloorCrvs(mass_, [0, maxHeights-minHeights], maxHeights)\n            #flrCrv = flrCrvs[0][0]\n            mass_shape = Shape(mass_)#,#flrCrv)\n            split_zones_per_mass = mass_shape.straight_skeleton(_perimeterZoneDepth,1000)\n\n            splitZones.append(split_zones_per_mass)\n            RhinoApp.Wait()\n        return splitZones\n    else:\n        print \"You should first let both Ladybug and Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let both Ladybug and Honeybee to fly...\")\n        return -1\n\n\n\ndef checkNonConvex(breps):\n    \"\"\"\n    Temporary until I get the concave section working!\n    Credit to Devang Chauhan for code from:\n    https://github.com/mostaphaRoudsari/honeybee/blob/master/src/Honeybee_Find%20Non-Convex.py\n    \"\"\"\n    #import the classes\n    if sc.sticky.has_key('honeybee_release'):\n        try:\n            if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n            \"Use updateHoneybee component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n\n        #Bringing NonConvexChecking class from Honeybee_Honeybee\n        hb_NonConvexChecking = sc.sticky[\"honeybee_NonConvexChecking\"]\n\n        nonConvex = []\n        faultyGeometry = []\n\n        for brep in breps:\n            surfaces = [brep.Faces.ExtractFace(i) for i in range(brep.Faces.Count)]\n            for surface in surfaces:\n                if hb_NonConvexChecking(surface).isConvex()[0] == False:\n                    nonConvex.append(surface)\n                if hb_NonConvexChecking(surface).isConvex()[1] > 0:\n                    faultyGeometry.extend(hb_NonConvexChecking(surface).isConvex()[1])\n        return (nonConvex , faultyGeometry)\n    else:\n        print \"You should first let Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee to fly...\")\n        return -1\n\n\ncheckData = False\nif _runIt == True:\n    checkData = checkTheInputs()\n\n    #---------------- TEMP ----------------------------\n    brep4convexchk = copy.deepcopy(_bldgFloors)\n    convex_result = checkNonConvex(brep4convexchk)\n    if convex_result != -1:\n        nonConvex, faultyGeometry = convex_result\n        if len(faultyGeometry) > 0.0 or len(nonConvex) > 0.0:\n            convex_error_msg = \"You have a non-convex (or faulty) geometry, and this component mainly handles convex geometries (at this point). You should prepare the massing of your building by dividing it into convex volumes before using this component.\"\n            print convex_error_msg\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, convex_error_msg)\n    #---------------- TEMP ----------------------------\n\n\nif checkData == True:\n    #sc.sticky['#debug'] = []\n\n    splitBldgMassesLists = main(_bldgFloors, _perimeterZoneDepth)\n\n    if splitBldgMassesLists!= -1:\n        pass#splitBldgMasses = DataTree[Object]()\n        splitBldgZones = []\n    names = DataTree[Object]()\n    for i, buildingMasses in enumerate(splitBldgMassesLists):\n        for j, mass in enumerate(buildingMasses):\n            p = GH_Path(i,j)\n\n            # in case mass is not a list change it to list\n            try: mass[0]\n            except: mass = [mass]\n            #splitBldgMasses.Add(mass)\n            splitBldgZones.extend(mass)\n\n            newMass = []\n            for brep in mass:\n                if brep != None:\n                    #Bake the objects into the Rhino scene to ensure that surface normals are facing the correct direction\n                    sc.doc = rc.RhinoDoc.ActiveDoc #change target document\n                    rs.EnableRedraw(False)\n                    guid1 = [sc.doc.Objects.AddBrep(brep)]\n                    if guid1:\n                        a = [rs.coercegeometry(a) for a in guid1]\n                        for g in a: g.EnsurePrivateCopy() #must ensure copy if we delete from doc\n\n                        rs.DeleteObjects(guid1)\n\n                    sc.doc = ghdoc #put back document\n                    rs.EnableRedraw()\n                    newMass.append(g)\n                mass = newMass\n\n            #try:\n            #    splitBldgZones.AddRange(mass, p)\n            #except:\n            #    splitBldgZones.Add(mass, p)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}