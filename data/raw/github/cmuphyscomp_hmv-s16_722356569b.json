{
  "source_url": "https://github.com/cmuphyscomp/hmv-s16/blob/7863c66ed645b463b72aef98a5c484a18cc9f396/Grasshopper/MocapDemo/optirecv.py",
  "repo": "cmuphyscomp/hmv-s16",
  "repo_stars": 5,
  "repo_description": "Course resources for the Human-Machine Virtuosity course at Carnegie Mellon University, Spring 2016.",
  "license": "BSD-3-Clause",
  "filepath": "Grasshopper/MocapDemo/optirecv.py",
  "instruction": "optirecv.py : motion capture data receiver for use within Grasshopper ghpython objects",
  "code": "# optirecv.py : motion capture data receiver for use within Grasshopper ghpython objects\n\n# Copyright (c) 2016, Garth Zeglin. All rights reserved. Licensed under the\n# terms of the BSD 3-clause license.\n\n# use RhinoCommon API\nimport Rhino\n\n# Make sure that the Python libraries that are also contained within this course\n# package are on the load path. This adds the python/ folder to the load path\n# *after* the current folder.  The path manipulation assumes that this module is\n# still located within the Grasshopper/MocapDemo subfolder, and so the package\n# modules are at ../../python.\nimport sys, os\nsys.path.insert(1, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(os.path.dirname(__file__)))), \"python\"))\n\n# import the Optitrack stream decoder\nimport optirx\n\n# import a quaternion conversion function\nfrom optitrack.geometry import quaternion_to_xaxis_yaxis\n\n# load the Grasshopper utility functions from the course packages\nfrom ghutil import *\n\n# share the mocap coordinate conversion code with the CSV loader\nfrom optiload import rotated_point, rotated_orientation, plane_or_null\n\n#================================================================\nclass OptitrackReceiver(object):\n    def __init__(self, version_string, ip_address=None):\n        # The version string should be of the form \"2900\" and should match the SDK version of the Motive software.\n        # E.g. Motive 1.9 == SDK 2.9.0.0 == \"2900\"\n        #      Motive 1.8 == SDK 2.8.0.0 == \"2800\"\n        self.sdk_version = tuple(map(int,version_string)) # e.g. result is (2,9,0,0)\n\n        # create a multicast UDP receiver socket\n        self.receiver = optirx.mkdatasock(ip_address=ip_address)\n\n        # set non-blocking mode so the socket can be polled\n        self.receiver.setblocking(0)\n\n        # Keep track of the most recent results.  These are stored as normal Python list structures, but\n        # already rotated into Rhino coordinate conventions.\n        self.positions = list()  # list of Point3d objects\n        self.rotations = list()  # list of [x,y,z,w] quaternions as Python list of numbers\n        self.bodynames = list()  # list of name strings associated with the bodies\n        return\n\n    #================================================================\n    def make_plane_list(self):\n        \"\"\"Return the received rigid body frames as a list of Plane or None (for missing data), one entry per rigid body stream.\"\"\"\n\n        # convert each quaternion into a pair of X,Y basis vectors\n        basis_vectors = [quaternion_to_xaxis_yaxis(rot) for rot in self.rotations]\n\n        # Extract the X and Y axis basis elements into lists of Vector3d objects.\n        xaxes = [Rhino.Geometry.Vector3d(*(basis[0])) for basis in basis_vectors]\n        yaxes = [Rhino.Geometry.Vector3d(*(basis[1])) for basis in basis_vectors]\n\n        # Generate either Plane or None for each coordinate frame.\n        planes = [plane_or_null(origin, x, y) for origin,x,y in zip(self.positions, xaxes, yaxes)]\n        return planes\n\n    #================================================================\n    def _markers_coincide(self, m1, m2):\n        \"\"\"For now, an exact match (could be fuzzy match).\"\"\"\n        return m1[0] == m2[0] and m1[1] == m2[1] and m1[2] == m2[2]\n        \n    def _identify_rigid_bodies(self, sets, bodies):\n        \"\"\"Compare marker positions to associate a named marker set with a rigid body.\n        :param sets: dictionary of lists of marker coordinate triples\n        :param bodies: list of rigid bodies\n        :return: dictionary mapping body ID numbers to body name\n\n        Some of the relevant fields:\n        bodies[].markers  is a list of marker coordinate triples\n        bodies[].id       is an integer body identifier with the User Data field specified for the body in Motive\n        \"\"\"\n\n        # for now, do a simple direct comparison on a single marker on each body\n        mapping = dict()\n        for body in bodies:\n            marker1 = body.markers[0]\n            try:\n                for name,markerset in sets.items():\n                    if name != 'all':\n                        for marker in markerset:\n                            if self._markers_coincide(marker1, marker):\n                                mapping[body.id] = name\n                                raise StopIteration\n            except StopIteration:\n                pass\n\n        return mapping\n                         \n    #================================================================\n    def poll(self):\n        \"\"\"Poll the mocap receiver port and return True if new data is available.\"\"\"\n        try:\n            data = self.receiver.recv(optirx.MAX_PACKETSIZE)\n        except:\n            return False\n\n        packet = optirx.unpack(data, version=self.sdk_version)\n\n        if type(packet) is optirx.SenderData:\n            version = packet.natnet_version\n            print \"NatNet version received:\", version\n\n        elif type(packet) is optirx.FrameOfData:\n            nbodies = len(packet.rigid_bodies)\n            # print \"Received frame data with %d rigid bodies.\" % nbodies\n            # print \"Received FrameOfData with sets:\", packet.sets\n            # There appears to be one marker set per rigid body plus 'all'.\n            # print \"Received FrameOfData with names:\", packet.sets.keys()\n            # print \"First marker of first marker set:\", packet.sets.values()[0][0]\n            # print \"Received FrameOfData with rigid body IDs:\", [body.id for body in packet.rigid_bodies]\n            # print \"First marker of first rigid body:\", packet.rigid_bodies[0].markers[0]\n            # print \"First tracking flag of first rigid body:\", packet.rigid_bodies[0].tracking_valid\n\n            # compare markers to associate the numbered rigid bodies with the named marker sets\n            mapping = self._identify_rigid_bodies( packet.sets, packet.rigid_bodies)\n            # print \"Body identification:\", mapping\n            \n            if nbodies > 0:\n                # print packet.rigid_bodies[0]\n\n                # rotate the coordinates into Rhino conventions and save them in the object instance as Python lists\n                self.positions = [ rotated_point(body.position) if body.tracking_valid else None for body in packet.rigid_bodies]\n                self.rotations = [ rotated_orientation(body.orientation) for body in packet.rigid_bodies]\n                self.bodynames = [ mapping.get(body.id, '<Missing>') for body in packet.rigid_bodies]\n                \n                # return a new data indication\n                return True\n\n        elif type(packet) is optirx.ModelDefs:\n            print \"Received ModelDefs:\", packet\n\n        else:\n            print \"Received unhandled NatNet packet type:\", packet\n            \n        # else return a null result\n        return False\n\n#================================================================\ndef frames_to_tree(frame_list):\n    \"\"\"Utility function to convert a list of list of Plane objects representing a trajectory segment into a GH data tree.\"\"\"\n\n    # Transpose the frame list for output.  As accumulated, it is a list of lists:\n    # [[body1_sample0, body2_sample0, body3_sample0, ...], [body1_sample1, body2_sample1, body3_sample1, ...], ...]\n    segment = zip(*frame_list)\n\n    # Convert a Python list-of-lists into a data tree.  Segment is a list of trajectories:\n    # [[body1_sample0, body1_sample1, body1_sample2, ...], [body2_sample0, body2_sample1, body2_sample2, ...], ...]\n    return list_to_tree(segment)\n\n#================================================================\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}