{
  "source_url": "https://github.com/Mulimark/Tinyhouse-Generator/blob/c0817671402882dbc32291426822fc5040241fa1/app.py",
  "repo": "Mulimark/Tinyhouse-Generator",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "app.py",
  "instruction": null,
  "code": "import json\nimport rhino3dm\nfrom pathlib import Path\n\nfrom viktor import ViktorController, File\nfrom viktor.views import DataGroup, DataItem, GeoJSONAndDataResult, GeometryResult, TableResult, TableView, GeoJSONAndDataView, GeometryView, MapLabel\nfrom viktor.external.grasshopper import GrasshopperAnalysis\nfrom viktor.utils import memoize\n\nfrom gis_functions import get_gdf, create_legend, find_climate_zone\nfrom json_utils import parse_data_string, get_inner_tree_by_param_name\nfrom parametrization import Parametrization\n\n@memoize\ndef memoized_grasshopper_analysis(json_input):\n        #Funktion die die Grasshopper simulation ausführt\n        #wird im Arbeitsspeicher zwischengespeichert       \n        #Ergebnis kann deswegen mehrfach wieder aufgerufen werden\n\n        formatted_params = json.loads(json_input)\n\n\n        #Festlegen wo das gh Skript liegt und übergeben der Hops-Parameter an das Skript\n        grasshopper_script_path = Path(__file__).parent / \"files/Tinyhouse Generator.gh\"\n        script = File.from_path(grasshopper_script_path)\n\n        analysis = GrasshopperAnalysis(script=script, input_parameters=formatted_params)\n        #Analyse wird durchgeführt, sollte sie läger als 240 Sekunden dauern, wird sie angebrochen\n        analysis.execute(timeout=240)\n\n        return analysis.get_output()\n\nclass Controller(ViktorController):\n    label = 'My Entity Type'\n    parametrization = Parametrization(width=20)\n\n    #######################################################\n    # Views für Step 1 Beinhalten GIS und deren Funktionen#\n    #######################################################\n\n    @GeoJSONAndDataView(\"Kartenansicht - Standortauswahl\", duration_guess=1)\n    def get_geojson_view(self, params, **kwargs) -> GeoJSONAndDataResult:\n\n        #Kartenansicht mit GroJSON Overlay\n\n        gdf = get_gdf(params.step_1.styling)\n        geojson = json.loads(gdf.to_json())\n        gdf_labels = gdf.copy()\n        gdf_labels[\"label_geometry\"] = gdf_labels.representative_point()\n        labels = [MapLabel(gdf_labels.label_geometry[0].x, gdf_labels.label_geometry[0].x, \" \", 20)]\n\n        #Festlegen der Position des Pins und das Styling des\n\n        if 'GeoPointField' in params.step_1.point:\n            latitude = params.step_1.point.GeoPointField.lat\n            longitude = params.step_1.point.GeoPointField.lon\n            point_geojson = {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [longitude, latitude]\n                },\n                \"properties\": {\n                    \"marker-symbol\": \"pin\",\n                    \"marker-color\": \"#ff0000\"\n                }\n            }\n        else:\n            print(\"Kein valider Punkt angegeben\")\n\n        #Runden des Längen und Breitengrades in übliches Format\n        #zur späteren Anzeige in der Webapp\n\n        longitude = round(params.step_1.point.GeoPointField.lon, 3)\n        latitude = round(params.step_1.point.GeoPointField.lat, 2)\n\n        selected_zone = find_climate_zone(gdf, latitude, longitude)\n\n        #Wurde eine Korrekte Klimazone ausgewählt?\n        if selected_zone:\n            climate_zone = f\"Klimazone am Punkt ({latitude}, {longitude}): {selected_zone}\"\n        else:\n            climate_zone = f\"Keine Klimazone am Punkt ({latitude}, {longitude}) gefunden\"\n\n        #Hinzufügen der Information zum View\n        geojson['features'].append(point_geojson)\n        data_items = DataItem(\"\", climate_zone)\n        attribute_results = DataGroup(data_items)\n        legend = create_legend()\n\n        #Abrufen der Legende samt Farben\n        if params.step_1.styling.showlegend:\n            return GeoJSONAndDataResult(geojson, attribute_results, labels, legend)\n        else:\n            return GeoJSONAndDataResult(geojson, attribute_results, labels)\n\n    ################################################\n    # Views für Step 2 Beinhaltet Gebäude Geometrie#\n    ################################################\n\n\n\n    @GeometryView(\"3D Modell Ansicht\", duration_guess=10, x_axis_to_right=True, update_label='Simulation starten')\n    def run_grasshopper(self, params, **kwargs):\n        \n        #Geometrieanzeige\n        #Zunächst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhöhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhöhe=raumhoehe,\n            Längengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen für GH Skript, fragt immer vorher ab ob sich Parameter verändert haben\n        output = memoized_grasshopper_analysis(json_input)\n\n        file3dm = rhino3dm.File3dm()\n        geometry_inner_tree = get_inner_tree_by_param_name(output, \"Geometry\")\n\n        #Hinzufügen der Geometrien zum Viewmodel\n        def add_objects_to_model(inner_tree):\n            if not inner_tree:\n                print(\"Kein InnerTree gefunden.\")\n                return\n            for key in inner_tree:\n                for data_item in inner_tree[key]:\n                    obj = rhino3dm.CommonObject.Decode(json.loads(data_item[\"data\"]))\n                    file3dm.Objects.Add(obj)\n\n        add_objects_to_model(geometry_inner_tree)\n\n        geometry_file = File()\n        file3dm.Write(geometry_file.source, version=7)\n\n        return GeometryResult(geometry=geometry_file, geometry_type=\"3dm\")\n\n    @GeometryView(\"Grundriss und Schnitte\", duration_guess=10, x_axis_to_right=True, update_label='Lade aktuellen Grundriss', view_mode=\"2D\")\n    def view_floorplan(self, params, **kwargs):\n\n        #2D View für Grundriss und Schnitte\n        #Zunächst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhöhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhöhe=raumhoehe,\n            Längengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen für GH Skript, fragt immer vorher ab ob sich Parameter verändert haben\n        output = memoized_grasshopper_analysis(json_input)\n\n        file3dm = rhino3dm.File3dm()\n        floorplan_inner_tree = output[\"values\"][2][\"InnerTree\"]\n\n        #Hinzufügen der Geometrien zum Viewmodel\n        def add_objects_to_model(inner_tree):\n            for key in inner_tree:\n                for data_item in inner_tree[key]:\n                    obj = rhino3dm.CommonObject.Decode(json.loads(data_item[\"data\"]))\n                    file3dm.Objects.Add(obj)\n\n        add_objects_to_model(floorplan_inner_tree)\n\n        geometry_file = File()\n        file3dm.Write(geometry_file.source, version=7)\n        return GeometryResult(geometry=geometry_file, geometry_type=\"3dm\")\n\n    ################################################\n    # Views für Step 3 Beinhaltet Datenverarbeitung#\n    ################################################\n\n    @TableView(\"Informationen zur Parametrisierung\", duration_guess=1)\n    def run_data_analysis(self, params, **kwargs):\n\n        #Tabelle für Datenansicht\n        #Zunächst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhöhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhöhe=raumhoehe,\n            Längengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen für GH Skript, fragt immer vorher ab ob sich Parameter verändert haben\n        output = memoized_grasshopper_analysis(json_input)\n        text_inner_tree = get_inner_tree_by_param_name(output, \"Tx\")\n\n        #Hinzufügen der Infos zur richtigen Tabelle\n        if text_inner_tree and '{0}' in text_inner_tree:\n            #String aus dem Textdata bilden\n            text_data = text_inner_tree['{0}'][0]['data']\n            formatted_text = text_data.replace(\"\\\\r\\\\n\", \"\\n\").splitlines()\n\n            #\"Parameter_data\" aus dem String herauslesen (erste Ausgabe)\n            parameter_data, _ = parse_data_string(formatted_text)\n\n            #Tablle Vorbereiten und hinzufügen der Daten\n            table_data = []\n            row_headers = []\n            for key, value_dict in parameter_data.items():\n                row_headers.append(key)\n                table_data.append([value_dict[\"value\"], value_dict[\"begründung\"]])\n\n            return TableResult(table_data, column_headers=[\"Wert\", \"Begründung\"], row_headers=row_headers)\n        else:\n            print(\"Keine Daten gefunden\")\n            return TableResult([], column_headers=[\"Wert\", \"Begründung\"], row_headers=[])\n\n    @TableView(\"Wetterdaten\", duration_guess=1)\n    def run_weather_data(self, params, **kwargs):\n\n        #Tabelle für Wetterdaten\n        #Zunächst initialisierung der Parameter\n        gdf = get_gdf(params.step_1.styling)\n        latitude = params.step_1.point.GeoPointField.lat\n        longitude = params.step_1.point.GeoPointField.lon\n        raumhoehe = params.step_2.geometrie.Raumhöhe\n        azimutRichtungEingang = params.step_2.geometrie.AzimutRichtungEingang\n        klimazone = find_climate_zone(gdf, latitude, longitude)\n\n        formatted_params = dict(\n            Raumhöhe=raumhoehe,\n            Längengrad=longitude,\n            Breitangrad=latitude,\n            Klimazone=klimazone,\n            AzimutRichtungEingang=azimutRichtungEingang\n        )\n\n        #Parameter in ein JSON String damit Hops sie lesen kann\n        json_input = json.dumps(formatted_params)\n\n        #memoized Function aufrufen für GH Skript, fragt immer vorher ab ob sich Parameter verändert haben\n        output = memoized_grasshopper_analysis(json_input)\n        text_inner_tree = get_inner_tree_by_param_name(output, \"Tx\")\n\n        #Hinzufügen der Infos zur richtigen Tabelle\n        if text_inner_tree and '{0}' in text_inner_tree:\n            #String aus dem Textdata bilden\n            text_data = text_inner_tree['{0}'][0]['data']\n            formatted_text = text_data.replace(\"\\\\r\\\\n\", \"\\n\").splitlines()\n\n            #\"wetterdaten\" aus dem String herauslesen (zweite Ausgabe)\n            _, wetterdaten = parse_data_string(formatted_text)\n\n            #Tablle Vorbereiten und hinzufügen der Daten\n            table_data = []\n            row_headers = []\n            for monat, daten in wetterdaten.items():\n                row_headers.append(monat)\n                table_data.append([\n                    daten.get(\"Schneefall [mm]\", 0),\n                    daten.get(\"Niederschlag [mm]\", 0)\n                ])\n\n            return TableResult(table_data, column_headers=[\"Schneefall [mm]\", \"Niederschlag [mm]\"], row_headers=row_headers)\n        else:\n            print(\"Keine Daten gefunden\")\n            return TableResult([], column_headers=[\"Schneefall [mm]\", \"Niederschlag [mm]\"], row_headers=[])",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}