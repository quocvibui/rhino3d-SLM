{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_PipelineController.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_PipelineController.py",
  "instruction": "Provides an interface to work with interactive geometry pipelines.\n    Inputs:\n        DynamicUpdate: If True, the component will listen to changes in the Rhino document and update automatically....",
  "code": "\"\"\"\nProvides an interface to work with interactive geometry pipelines.\n    Inputs:\n        DynamicUpdate: If True, the component will listen to changes in the Rhino document and update automatically. {item, boolean}\n        CreateAndRef: Set to true to create new timestamped pipeline-layers and reference them. {item, boolean}\n        LoadAndRef: Set to true to load existing pipeline-layers based on the currently active Rhino layer. {item, boolean}\n        ParentLayerPrefix: The prefix for parent pipeline-layers {item, string}\n        ReferenceLayers: Specify the referenced layer names here (i.e. connect a panel). {list, string}\n        AssistanceLayers: Specify additional non-referenced assistance layers here (i.e. connect a panel). {list, string}\n        LayerColours: Use this to specify a color for the layers that are created by the component. {list, string}\n    Outputs:\n        AssemblyGeo: The geometry in a datatree branched based on the specified layers. {tree, geometry}\n        CurrentLayers: The currently referenced layers as strings. {list, string}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport time\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# CUSTOM RHINO IMPORTS\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nfrom scriptcontext import sticky as st\n\n# ADDITIONAL IMPORTS\nfrom System.Drawing import Color\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"PipelineController\"\nghenv.Component.NickName = \"PC\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"01 Pipeline Controlling\"\n\nclass PipelineController(component):\n    \n    # UNIQUE STICKY KEY OR STORING LAYERNAMES\n    LNKEY = str(ghenv.Component.InstanceGuid) + \"___LAYERNAMES\"\n    EVKEY = str(ghenv.Component.InstanceGuid) + \"___EVENTS\"\n    FLAG = str(ghenv.Component.InstanceGuid) + \"___FLAG\"\n    \n    # COMPONENT UPDATING -------------------------------------------------------\n    \n    def updateComponent(self):\n        # define callback action\n        def callBack(e):\n            self.ExpireSolution(False)\n        # get ghDoc\n        ghDoc = self.OnPingDocument()\n        # schedule new solution\n        ghDoc.ScheduleSolution(1, Grasshopper.Kernel.GH_Document.GH_ScheduleDelegate(callBack))\n    \n    # EVENT HANDLING -----------------------------------------------------------\n    \n    def subscribe_to(self, event, func, key):\n        if not self.EVKEY in st:\n            st[self.EVKEY] = {}\n        if key not in st[self.EVKEY]:\n            st[self.EVKEY][key] = event\n        ukey = str(self.InstanceGuid) + \"_\" + key\n        if ukey not in st:\n            st[ukey] = func\n            event += st[ukey]\n    \n    def unsubscribe_all(self):\n        if self.EVKEY in st:\n            for key in st[self.EVKEY]:\n                ukey = str(self.InstanceGuid) + \"_\" + key\n                if ukey in st:\n                    st[self.EVKEY][key] -= st[ukey]\n                    st.Remove(ukey)\n        st[self.EVKEY] = {}\n    \n    def flagEvent(self, sender, e):\n        st[self.FLAG] = True\n    \n    def updateEvent(self, sender, e):\n        if st[self.FLAG] == True:\n            st[self.FLAG] = False\n            self.updateComponent()\n    \n    def unsubEvent(self, sender, e):\n        self.unsubscribe_all()\n    \n    # LAYER SET HANDLING -------------------------------------------------------\n    \n    def CreateReferenceLayers(self, parentPrefix, refLayers, norefLayers, colours):\n        # get timestamp\n        ts = time.strftime(\"%y%m%d_%H-%M\")\n        \n        # create parent layer name\n        parentLayername = parentPrefix + ts\n        self.Message = \"Referenced: \" + str(parentLayername)\n        \n        # check if parent layer exists\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        exists = rs.IsLayer(parentLayername)\n        \n        if exists:\n            self.AddRuntimeMessage(self.RuntimeMessageLevel.Remark,\n                \"Parent Layer already exists! Returning valid existing layers.\")\n            # get all children layers\n            allchildren = rs.LayerChildren(parentLayername)\n            # check all children layers for validity\n            validchildren = [parentLayername + \"::\" + vc for vc in refLayers]\n            realchildren = []\n            for c in allchildren:\n                if c in validchildren:\n                    realchildren.append(c)\n            # set sticky to real found child layers\n            st[self.LNKEY] = realchildren\n            \n            # switch back to ghdoc\n            sc.doc = ghdoc\n            \n            # return layer names\n            return realchildren\n        else:\n            # switch to Rhino doc\n            sc.doc = Rhino.RhinoDoc.ActiveDoc\n            # create parent layer\n            parentLayer = rs.AddLayer(parentLayername, Color.Black)\n            \n            # create referenced layers\n            newLayers = []\n            for i, rl in enumerate(refLayers + norefLayers):\n                lay = rs.AddLayer(rl, \n                                  colours[i], \n                                  parent = parentLayername)\n                if rl in refLayers:\n                    newLayers.append(lay)\n            \n            # add them to the sticky\n            st[self.LNKEY] = newLayers\n            \n            # switch back to ghdoc\n            scdoc = ghdoc\n            \n            # return layer names/paths\n            return newLayers\n    \n    def LoadCurrentLayers(self, refLayers):\n        # switch to RhinoDoc\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        \n        # retrieve current layer\n        cl = rs.CurrentLayer()\n        \n        # check childcount\n        childcount = rs.LayerChildCount(cl)\n        \n        # if no children, layer has to be childlayer or unrelated\n        if childcount == 0:\n            # get parent layer\n            parent = rs.ParentLayer(cl)\n            # switch back to GhDoc\n            sc.doc = ghdoc\n            if parent:\n                allvalid = [parent + \"::\" + l for l in refLayers]\n                # set message and return all valid children\n                self.Message = \"Referenced: \" + str(parent)\n                st[self.LNKEY] = allvalid\n                return allvalid\n            else:\n                st[self.LNKEY] = None\n                self.Message = None\n                return None\n        \n        # if no children, layer has to be parent layer\n        elif childcount > 0:\n            parent = cl\n            # switch back to GhDoc and return all valid layers\n            scdoc = ghdoc\n            if parent:\n                allvalid = [parent + \"::\" + l for l in refLayers]\n                # set message and return all valid children\n                self.Message = \"Referenced: \" + str(parent)\n                st[self.LNKEY] = allvalid\n                return allvalid\n        \n        else:\n            # switch back to GhDoc\n            scdoc = ghdoc\n            st[self.LNKEY] = None\n            return None\n    \n    def retrieveGeometry(self, layers):\n        geometry = []\n        \n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        \n        for i, layer in enumerate(layers):\n            objs = [rs.coercegeometry(obj) for obj in rs.ObjectsByLayer(layer)]\n            \n            if objs == None:\n                objs = []\n            \n            for i, obj in enumerate(objs):\n                if type(obj) == Rhino.Geometry.Point:\n                    objs[i] = Rhino.Geometry.Point3d(obj.Location)\n            \n            geometry.append(objs)\n        \n        sc.doc = ghdoc\n        return geometry\n    \n    def RunScript(self, DynamicUpdate, CreateAndRef, LoadAndRef, ParentLayerPrefix, ReferenceLayers, AssistanceLayers, LayerColours):\n        # check for unique key in sticky dictionary\n        if not self.LNKEY in st:\n            st[self.LNKEY] = None\n        \n        # define output variables ----------------------------------------------\n        AssemblyGeo = Grasshopper.DataTree[object]()\n        CurrentLayers = []\n        \n        # subscribe to events for automatic component updating -----------------\n        if DynamicUpdate:\n            self.subscribe_to(Rhino.RhinoDoc.BeforeTransformObjects, self.flagEvent, \"BeforeTransformObjects\")\n            self.subscribe_to(Rhino.RhinoDoc.DeleteRhinoObject, self.flagEvent, \"DeleteRhinoObject\")\n            self.subscribe_to(Rhino.RhinoDoc.AddRhinoObject, self.flagEvent, \"AddRhinoObject\")\n            #self.subscribe_to(Rhino.RhinoDoc.LayerTableEvent, self.flagEvent, \"LayerTableEvent\")\n            self.subscribe_to(Rhino.RhinoDoc.UndeleteRhinoObject, self.flagEvent, \"UndeleteRhinoObjects\")\n            self.subscribe_to(Rhino.RhinoApp.Idle, self.updateEvent, \"Idle\")\n            self.subscribe_to(Rhino.RhinoDoc.CloseDocument, self.unsubEvent, \"CloseDocument\")\n            self.subscribe_to(Rhino.RhinoDoc.NewDocument, self.unsubEvent, \"NewDocument\")\n        else:\n            self.unsubscribe_all()\n        \n        # catch missing layer colours ------------------------------------------\n        laycount = len(ReferenceLayers + AssistanceLayers)\n        if not LayerColours or len(LayerColours) == 0:\n            LayerColours = [Color.Black] * laycount\n        elif len(LayerColours) < len(ReferenceLayers + AssistanceLayers):\n            addCols = [Color.Black] * (laycount - len(LayerColours))\n            LayerColours.extend(addCols)\n        \n        # if create button is pressed, create new layers and reference them ----\n        if CreateAndRef == True:\n            CurrentLayers = self.CreateReferenceLayers(ParentLayerPrefix,\n                                                       ReferenceLayers,\n                                                       AssistanceLayers,\n                                                       LayerColours)\n        # if load button is pressed, load from the current rhino-layer ---------\n        elif LoadAndRef == True:\n            # retrieve the current layerset based on the active rhino layer\n            CurrentLayers = self.LoadCurrentLayers(ReferenceLayers)\n        # if no button is pressed, make some checks and run standard procedure -\n        elif self.LNKEY in st and st[self.LNKEY] != None:\n            layer_names = st[self.LNKEY]\n            CurrentLayers = layer_names\n        # fall back and return if there are no layer names stored in sticky\n        elif st[self.LNKEY] == None:\n            try:\n                # retrieve the current layerset based on the active rhino layer\n                CurrentLayers = self.LoadCurrentLayers(ReferenceLayers)\n            except:\n                return AssemblyGeo, PipelineGeometry, CurrentLayers\n        \n        # retrieve all geometry\n        if CurrentLayers:\n            try:\n                allgeometry = self.retrieveGeometry(CurrentLayers)\n            except ValueError, errMsg:\n                self.AddRuntimeMessage(self.RuntimeMessageLevel.Error,\n                                       str(errMsg))\n                allgeometry = None\n        else:\n            self.AddRuntimeMessage(self.RuntimeMessageLevel.Warning,\n                \"Could not load layerset. Check your current Rhino layer or \" +\n                \"the controllers input parameters\")\n            allgeometry = None\n        \n        if allgeometry:\n            for i, geo in enumerate(allgeometry):\n                AssemblyGeo.AddRange(geo, Grasshopper.Kernel.Data.GH_Path(i))\n        \n        # return outputs\n        return AssemblyGeo, CurrentLayers",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}