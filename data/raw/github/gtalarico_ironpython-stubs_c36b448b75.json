{
  "source_url": "https://github.com/gtalarico/ironpython-stubs/blob/c7f6a6cb197e3949e40a4880a0b2a44e72d0a940/release/stubs.min/Rhino/Geometry/__init___parts/Curve.py",
  "repo": "gtalarico/ironpython-stubs",
  "repo_stars": 261,
  "repo_description": "Autocomplete stubs for common IronPython/.NET libraries",
  "license": "NOASSERTION",
  "filepath": "release/stubs.min/Rhino/Geometry/__init___parts/Curve.py",
  "instruction": null,
  "code": "class Curve(GeometryBase,IDisposable,ISerializable):\r\n \"\"\"\r\n Represents a base class that is common to most RhinoCommon curve types.\r\n\r\n    A curve represents an entity that can be all visited by providing\r\n\r\n    a single parameter,usually called t.\r\n \"\"\"\r\n def ChangeClosedCurveSeam(self,t):\r\n  \"\"\"\r\n  ChangeClosedCurveSeam(self: Curve,t: float) -> bool\r\n\r\n  \r\n\r\n   If this curve is closed,then modify it so that the start/end point is at curve parameter t.\r\n\r\n  \r\n\r\n   t: Curve parameter of new start/end point. The returned curves domain will start at t.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ChangeDimension(self,desiredDimension):\r\n  \"\"\"\r\n  ChangeDimension(self: Curve,desiredDimension: int) -> bool\r\n\r\n  \r\n\r\n   Changes the dimension of a curve.\r\n\r\n  \r\n\r\n   desiredDimension: The desired dimension.\r\n\r\n   Returns: true if the curve's dimension was already desiredDimension\r\n\r\n     or if the curve's \r\n\r\n    dimension was successfully changed to desiredDimension;\r\n\r\n     otherwise false.\r\n  \"\"\"\r\n  pass\r\n def ClosedCurveOrientation(self,*__args):\r\n  \"\"\"\r\n  ClosedCurveOrientation(self: Curve,xform: Transform) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve.\r\n\r\n       \r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   xform: Transformation to map the curve to the xy plane. If the curve is parallel\r\n\r\n     to the xy \r\n\r\n    plane,you may pass Identity matrix.\r\n\r\n  \r\n\r\n   Returns: The orientation of this curve in the world xy-plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,plane: Plane) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: The plane in which to solve the orientation.\r\n\r\n   Returns: The orientation of this curve in the given plane.\r\n\r\n  ClosedCurveOrientation(self: Curve,upDirection: Vector3d) -> CurveOrientation\r\n\r\n  \r\n\r\n   Determines the orientation (counterclockwise or clockwise) of a closed planar curve in a given \r\n\r\n    plane.\r\n\r\n     Only works with simple (no self intersections) closed planar curves.\r\n\r\n  \r\n\r\n  \r\n\r\n   upDirection: A vector that is considered \"up\".\r\n\r\n   Returns: The orientation of this curve with respect to a defined up direction.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoint(self,testPoint,t,maximumDistance=None):\r\n  \"\"\"\r\n  ClosestPoint(self: Curve,testPoint: Point3d,maximumDistance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds the parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to project.\r\n\r\n   maximumDistance: The maximum allowed distance.\r\n\r\n     Past this distance,the search is given up and false \r\n\r\n    is returned.Use 0 to turn off this parameter.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  ClosestPoint(self: Curve,testPoint: Point3d) -> (bool,float)\r\n\r\n  \r\n\r\n   Finds parameter of the point on a curve that is closest to testPoint.\r\n\r\n     If the \r\n\r\n    maximumDistance parameter is > 0,then only points whose distance\r\n\r\n     to the given \r\n\r\n    point is <= maximumDistance will be returned.  Using a \r\n\r\n     positive value of \r\n\r\n    maximumDistance can substantially speed up the search.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to search from.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def ClosestPoints(self,*__args):\r\n  \"\"\"\r\n  ClosestPoints(self: Curve,otherCurve: Curve) -> (bool,Point3d,Point3d)\r\n\r\n  \r\n\r\n   Gets closest points between this and another curves.\r\n\r\n  \r\n\r\n   otherCurve: The other curve.\r\n\r\n   Returns: true on success; false on error.\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase]) -> (bool,Point3d,Point3d,int)\r\n\r\n  ClosestPoints(self: Curve,geometry: IEnumerable[GeometryBase],maximumDistance: float) -> (bool,Point3d,Point3d,int)\r\n  \"\"\"\r\n  pass\r\n def ConstructConstObject(self,*args):\r\n  \"\"\"\r\n  ConstructConstObject(self: CommonObject,parentObject: object,subobject_index: int)\r\n\r\n   Assigns a parent object and a subobject index to this.\r\n\r\n  \r\n\r\n   parentObject: The parent object.\r\n\r\n   subobject_index: The subobject index.\r\n  \"\"\"\r\n  pass\r\n def Contains(self,testPoint,plane=None,tolerance=None):\r\n  \"\"\"\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane,tolerance: float) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   tolerance: Tolerance to use during comparison.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d,plane: Plane) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   plane: Plane in in which to compare point and region.\r\n\r\n   Returns: Relationship between point and curve region.\r\n\r\n  Contains(self: Curve,testPoint: Point3d) -> PointContainment\r\n\r\n  \r\n\r\n   Computes the relationship between a point and a closed curve region. \r\n\r\n     This curve \r\n\r\n    must be closed or the return value will be Unset.\r\n\r\n     Both curve and point are \r\n\r\n    projected to the World XY plane.\r\n\r\n  \r\n\r\n  \r\n\r\n   testPoint: Point to test.\r\n\r\n   Returns: Relationship between point and curve region.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBlendCurve(*__args):\r\n  \"\"\"\r\n  CreateBlendCurve(curve0: Curve,t0: float,reverse0: bool,continuity0: BlendContinuity,curve1: Curve,t1: float,reverse1: bool,continuity1: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Makes a curve blend between 2 curves at the parameters specified\r\n\r\n     with the \r\n\r\n    directions and continuities specified\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: First curve to blend from\r\n\r\n   t0: Parameter on first curve for blend endpoint\r\n\r\n   reverse0: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity0: continuity for the blend at the start\r\n\r\n   curve1: Second curve to blend from\r\n\r\n   t1: Parameter on second curve for blend endpoint\r\n\r\n   reverse1: If false,the blend will go in the natural direction of the curve.\r\n\r\n     If true,the \r\n\r\n    blend will go in the opposite direction to the curve\r\n\r\n  \r\n\r\n   continuity1: continuity for the blend at the end\r\n\r\n   Returns: the blend curve on success. null on failure\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity,bulgeA: float,bulgeB: float) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   bulgeA: Bulge factor at curveA end of blend. Values near 1.0 work best.\r\n\r\n   bulgeB: Bulge factor at curveB end of blend. Values near 1.0 work best.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n\r\n  CreateBlendCurve(curveA: Curve,curveB: Curve,continuity: BlendContinuity) -> Curve\r\n\r\n  \r\n\r\n   Create a Blend curve between two existing curves.\r\n\r\n  \r\n\r\n   curveA: Curve to blend from (blending will occur at curve end point).\r\n\r\n   curveB: Curve to blend to (blending will occur at curve start point).\r\n\r\n   continuity: Continuity of blend.\r\n\r\n   Returns: A curve representing the blend between A and B or null on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanDifference(curveA,*__args):\r\n  \"\"\"\r\n  CreateBooleanDifference(curveA: Curve,subtractors: IEnumerable[Curve]) -> Array[Curve]\r\n\r\n  CreateBooleanDifference(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean difference between two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no difference could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanIntersection(curveA,curveB):\r\n  \"\"\"\r\n  CreateBooleanIntersection(curveA: Curve,curveB: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Calculates the boolean intersection of two closed,planar curves. \r\n\r\n     Note,curves \r\n\r\n    must be co-planar.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: The first closed,planar curve.\r\n\r\n   curveB: The second closed,planar curve.\r\n\r\n   Returns: Result curves on success,empty array if no intersection could be calculated.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateBooleanUnion(curves):\r\n  \"\"\" CreateBooleanUnion(curves: IEnumerable[Curve]) -> Array[Curve] \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateControlPointCurve(points,degree=None):\r\n  \"\"\"\r\n  CreateControlPointCurve(points: IEnumerable[Point3d]) -> Curve\r\n\r\n  CreateControlPointCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFillet(curve0,curve1,radius,t0Base,t1Base):\r\n  \"\"\"\r\n  CreateFillet(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> Arc\r\n\r\n  \r\n\r\n   Computes the fillet arc for a curve filleting operation.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter on curve0 where the fillet ought to start (approximately).\r\n\r\n   t1Base: Parameter on curve1 where the fillet ought to end (approximately).\r\n\r\n   Returns: The fillet arc on success,or Arc.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateFilletCurves(curve0,point0,curve1,point1,radius,join,trim,arcExtension,tolerance,angleTolerance):\r\n  \"\"\"\r\n  CreateFilletCurves(curve0: Curve,point0: Point3d,curve1: Curve,point1: Point3d,radius: float,join: bool,trim: bool,arcExtension: bool,tolerance: float,angleTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates a tangent arc between two curves and trims or extends the curves to the arc.\r\n\r\n  \r\n\r\n   curve0: The first curve to fillet.\r\n\r\n   point0: A point on the first curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   curve1: The second curve to fillet.\r\n\r\n   point1: A point on the second curve that is near the end where the fillet will\r\n\r\n     be created.\r\n\r\n   radius: The radius of the fillet.\r\n\r\n   join: Join the output curves.\r\n\r\n   trim: Trim copies of the input curves to the output fillet curve.\r\n\r\n   arcExtension: Applies when arcs are filleted but need to be extended to meet the\r\n\r\n     fillet curve or \r\n\r\n    chamfer line. If true,then the arc is extended\r\n\r\n     maintaining its validity. If false,\r\n\r\n    then the arc is extended with a\r\n\r\n     line segment,which is joined to the arc converting \r\n\r\n    it to a polycurve.\r\n\r\n  \r\n\r\n   tolerance: The tolerance,generally the document's absolute tolerance.\r\n\r\n   Returns: The results of the fillet operation. The number of output curves depends\r\n\r\n     on the \r\n\r\n    input curves and the values of the parameters that were used\r\n\r\n     during the fillet \r\n\r\n    operation. In most cases,the output array will contain\r\n\r\n     either one or three curves,\r\n\r\n    although two curves can be returned if the\r\n\r\n     radius is zero and join=false.\r\n\r\n      \r\n\r\n      For example,if both join and trim=true,then the output curve\r\n\r\n     will be a \r\n\r\n    polycurve containing the fillet curve joined with trimmed copies\r\n\r\n     of the input \r\n\r\n    curves. If join=false and trim=true,then three curves,\r\n\r\n     the fillet curve and \r\n\r\n    trimmed copies of the input curves,will be returned.\r\n\r\n     If both join and trim=\r\n\r\n    false,then just the fillet curve is returned.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateInterpolatedCurve(points,degree,knots=None,startTangent=None,endTangent=None):\r\n  \"\"\"\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle,startTangent: Vector3d,endTangent: Vector3d) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int,knots: CurveKnotStyle) -> Curve\r\n\r\n  CreateInterpolatedCurve(points: IEnumerable[Point3d],degree: int) -> Curve\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateMeanCurve(curveA,curveB,angleToleranceRadians=None):\r\n  \"\"\"\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   Returns: The average curve,or null on error.\r\n\r\n  CreateMeanCurve(curveA: Curve,curveB: Curve,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Constructs a mean,or average,curve from two curves.\r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   angleToleranceRadians: The angle tolerance,in radians,used to match kinks between curves.\r\n\r\n     If you are \r\n\r\n    unsure how to set this parameter,then either use the\r\n\r\n     document's angle tolerance \r\n\r\n    RhinoDoc.AngleToleranceRadians,\r\n\r\n     or the default value (RhinoMath.UnsetValue)\r\n\r\n  \r\n\r\n   Returns: The average curve,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurves(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurves(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Uses the control points of the curves \r\n\r\n    for finding tween curves.\r\n\r\n     That means the first control point of first curve is \r\n\r\n    matched to first control point of the second curve and so on.\r\n\r\n     There is no matching \r\n\r\n    of curves direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithMatching(curve0,curve1,numCurves):\r\n  \"\"\"\r\n  CreateTweenCurvesWithMatching(curve0: Curve,curve1: Curve,numCurves: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Make the structure of input curves \r\n\r\n    compatible if needed.\r\n\r\n     Refits the input curves to have the same structure. The \r\n\r\n    resulting curves are usually more complex than input unless\r\n\r\n     input curves are \r\n\r\n    compatible and no refit is needed. There is no matching of curves direction.\r\n\r\n     Caller \r\n\r\n    must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   Returns: An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def CreateTweenCurvesWithSampling(curve0,curve1,numCurves,numSamples):\r\n  \"\"\"\r\n  CreateTweenCurvesWithSampling(curve0: Curve,curve1: Curve,numCurves: int,numSamples: int) -> Array[Curve]\r\n\r\n  \r\n\r\n   Creates curves between two open or closed input curves. Use sample points method to make curves \r\n\r\n    compatible.\r\n\r\n     This is how the algorithm workd: Divides the two curves into an equal \r\n\r\n    number of points,finds the midpoint between the \r\n\r\n     corresponding points on the \r\n\r\n    curves and interpolates the tween curve through those points. There is no matching of curves\r\n\r\n     \r\n\r\n       direction. Caller must match input curves direction before calling the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   curve0: The first,or starting,curve.\r\n\r\n   curve1: The second,or ending,curve.\r\n\r\n   numCurves: Number of tween curves to create.\r\n\r\n   numSamples: Number of sample points along input curves.\r\n\r\n   Returns: >An array of joint curves. This array can be empty.\r\n  \"\"\"\r\n  pass\r\n def CurvatureAt(self,t):\r\n  \"\"\"\r\n  CurvatureAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluate the curvature vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Curvature vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def DerivativeAt(self,t,derivativeCount,side=None):\r\n  \"\"\"\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int,side: CurveEvaluationSide) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   side: Side of parameter to evaluate. If the parameter is at a kink,\r\n\r\n     it makes a big \r\n\r\n    difference whether the evaluation is from below or above.\r\n\r\n  \r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n\r\n  DerivativeAt(self: Curve,t: float,derivativeCount: int) -> Array[Vector3d]\r\n\r\n  \r\n\r\n   Evaluate the derivatives at the specified curve parameter.\r\n\r\n  \r\n\r\n   t: Curve parameter to evaluate.\r\n\r\n   derivativeCount: Number of derivatives to evaluate,must be at least 0.\r\n\r\n   Returns: An array of vectors that represents all the derivatives starting at zero.\r\n  \"\"\"\r\n  pass\r\n def Dispose(self):\r\n  \"\"\"\r\n  Dispose(self: Curve,disposing: bool)\r\n\r\n   For derived class implementers.\r\n\r\n     This method is called with argument true when class \r\n\r\n    user calls Dispose(),while with argument false when\r\n\r\n     the Garbage Collector invokes \r\n\r\n    the finalizer,or Finalize() method.You must reclaim all used unmanaged resources in both cases,\r\n\r\n    and can use this chance to call Dispose on disposable fields if the argument is true.Also,you \r\n\r\n    must call the base virtual method within your overriding method.\r\n\r\n  \r\n\r\n  \r\n\r\n   disposing: true if the call comes from the Dispose() method; false if it comes from the Garbage Collector \r\n\r\n    finalizer.\r\n  \"\"\"\r\n  pass\r\n def DivideAsContour(self,contourStart,contourEnd,interval):\r\n  \"\"\"\r\n  DivideAsContour(self: Curve,contourStart: Point3d,contourEnd: Point3d,interval: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Divides this curve at fixed steps along a defined contour line.\r\n\r\n  \r\n\r\n   contourStart: The start of the contouring line.\r\n\r\n   contourEnd: The end of the contouring line.\r\n\r\n   interval: A distance to measure on the contouring axis.\r\n\r\n   Returns: An array of points; or null on error.\r\n  \"\"\"\r\n  pass\r\n def DivideByCount(self,segmentCount,includeEnds,points=None):\r\n  \"\"\"\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: Array containing division curve parameters on success,null on failure.\r\n\r\n  DivideByCount(self: Curve,segmentCount: int,includeEnds: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into a number of equal-length segments.\r\n\r\n  \r\n\r\n   segmentCount: Segment count. Note that the number of division points may differ from the segment count.\r\n\r\n   includeEnds: If true,then the points at the start and end of the curve are included.\r\n\r\n   Returns: List of curve parameters at the division points on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideByLength(self,segmentLength,includeStart,points=None):\r\n  \"\"\"\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> (Array[float],Array[Point3d])\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the point at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n\r\n  DivideByLength(self: Curve,segmentLength: float,includeStart: bool) -> Array[float]\r\n\r\n  \r\n\r\n   Divide the curve into specific length segments.\r\n\r\n  \r\n\r\n   segmentLength: The length of each and every segment (except potentially the last one).\r\n\r\n   includeStart: If true,then the points at the start of the curve is included.\r\n\r\n   Returns: Array containing division curve parameters if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def DivideEquidistant(self,distance):\r\n  \"\"\"\r\n  DivideEquidistant(self: Curve,distance: float) -> Array[Point3d]\r\n\r\n  \r\n\r\n   Calculates 3d points on a curve where the linear distance between the points is equal.\r\n\r\n  \r\n\r\n   distance: The distance betwen division points.\r\n\r\n   Returns: An array of equidistant points,or null on error.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def DoDirectionsMatch(curveA,curveB):\r\n  \"\"\"\r\n  DoDirectionsMatch(curveA: Curve,curveB: Curve) -> bool\r\n\r\n  \r\n\r\n   Determines whether two curves travel more or less in the same direction.\r\n\r\n  \r\n\r\n   curveA: First curve to test.\r\n\r\n   curveB: Second curve to test.\r\n\r\n   Returns: true if both curves more or less point in the same direction,\r\n\r\n     false if they point \r\n\r\n    in the opposite directions.\r\n  \"\"\"\r\n  pass\r\n def Duplicate(self):\r\n  \"\"\"\r\n  Duplicate(self: Curve) -> GeometryBase\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this Curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateCurve(self):\r\n  \"\"\"\r\n  DuplicateCurve(self: Curve) -> Curve\r\n\r\n  \r\n\r\n   Constructs an exact duplicate of this curve.\r\n\r\n   Returns: An exact copy of this curve.\r\n  \"\"\"\r\n  pass\r\n def DuplicateSegments(self):\r\n  \"\"\"\r\n  DuplicateSegments(self: Curve) -> Array[Curve]\r\n\r\n  \r\n\r\n   Polylines will be exploded into line segments. ExplodeCurves will\r\n\r\n     return the curves \r\n\r\n    in topological order.\r\n\r\n  \r\n\r\n   Returns: An array of all the segments that make up this curve.\r\n  \"\"\"\r\n  pass\r\n def Extend(self,*__args):\r\n  \"\"\"\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,geometry: IEnumerable[GeometryBase]) -> Curve\r\n\r\n  Extend(self: Curve,side: CurveEnd,style: CurveExtensionStyle,endPoint: Point3d) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve to a point.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   style: The style or type of extension to use.\r\n\r\n   endPoint: A new end point.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  Extend(self: Curve,side: CurveEnd,length: float,style: CurveExtensionStyle) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve by a specific length.\r\n\r\n  \r\n\r\n   side: Curve end to extend.\r\n\r\n   length: Length to add to the curve end.\r\n\r\n   style: Extension style.\r\n\r\n   Returns: A curve with extended ends or null on failure.\r\n\r\n  Extend(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t0: Start of extension domain,if the start is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   t1: End of extension domain,if the end is not inside the \r\n\r\n     Domain of this curve,an \r\n\r\n    attempt will be made to extend the curve.\r\n\r\n  \r\n\r\n   Returns: Extended curve on success,null on failure.\r\n\r\n  Extend(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Where possible,analytically extends curve to include the given domain. \r\n\r\n     This will \r\n\r\n    not work on closed curves. The original curve will be identical to the \r\n\r\n     restriction \r\n\r\n    of the resulting curve to the original curve domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   domain: Extension domain.\r\n\r\n   Returns: Extended curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ExtendByArc(self,side,geometry):\r\n  \"\"\" ExtendByArc(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendByLine(self,side,geometry):\r\n  \"\"\" ExtendByLine(self: Curve,side: CurveEnd,geometry: IEnumerable[GeometryBase]) -> Curve \"\"\"\r\n  pass\r\n def ExtendOnSurface(self,side,*__args):\r\n  \"\"\"\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,face: BrepFace) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   face: BrepFace that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n\r\n  ExtendOnSurface(self: Curve,side: CurveEnd,surface: Surface) -> Curve\r\n\r\n  \r\n\r\n   Extends a curve on a surface.\r\n\r\n  \r\n\r\n   side: The end of the curve to extend.\r\n\r\n   surface: Surface that contains the curve.\r\n\r\n   Returns: New extended curve result on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fair(self,distanceTolerance,angleTolerance,clampStart,clampEnd,iterations):\r\n  \"\"\"\r\n  Fair(self: Curve,distanceTolerance: float,angleTolerance: float,clampStart: int,clampEnd: int,iterations: int) -> Curve\r\n\r\n  \r\n\r\n   Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \r\n\r\n     \r\n\r\n    remove large curvature variations while limiting the geometry changes to be no \r\n\r\n     \r\n\r\n    more than the specified tolerance.\r\n\r\n  \r\n\r\n  \r\n\r\n   distanceTolerance: Maximum allowed distance the faired curve is allowed to deviate from the input.\r\n\r\n   angleTolerance: (in radians) kinks with angles <= angleTolerance are smoothed out 0.05 is a good default.\r\n\r\n   clampStart: The number of (control vertices-1) to preserve at start. \r\n\r\n     0=preserve start point1 \r\n\r\n   =preserve start point and 1st derivative2=preserve start point,1st and 2nd derivative\r\n\r\n  \r\n\r\n   clampEnd: Same as clampStart.\r\n\r\n   iterations: The number of iteratoins to use in adjusting the curve.\r\n\r\n   Returns: Returns new faired Curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Fit(self,degree,fitTolerance,angleTolerance):\r\n  \"\"\"\r\n  Fit(self: Curve,degree: int,fitTolerance: float,angleTolerance: float) -> Curve\r\n\r\n  \r\n\r\n   Fits a new curve through an existing curve.\r\n\r\n  \r\n\r\n   degree: The degree of the returned Curve. Must be bigger than 1.\r\n\r\n   fitTolerance: The fitting tolerance. If fitTolerance is RhinoMath.UnsetValue or <=0.0,\r\n\r\n     the \r\n\r\n    document absolute tolerance is used.\r\n\r\n  \r\n\r\n   angleTolerance: The kink smoothing tolerance in radians.\r\n\r\n     If angleTolerance is 0.0,all kinks are \r\n\r\n    smoothedIf angleTolerance is >0.0,kinks smaller than angleTolerance are smoothedIf \r\n\r\n    angleTolerance is RhinoMath.UnsetValue or <0.0,the document angle tolerance is used for the \r\n\r\n    kink smoothing\r\n\r\n  \r\n\r\n   Returns: Returns a new fitted Curve if successful,null on failure.\r\n  \"\"\"\r\n  pass\r\n def FrameAt(self,t,plane):\r\n  \"\"\"\r\n  FrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Returns a 3d frame at a parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetCurveParameterFromNurbsFormParameter(self,nurbsParameter,curveParameter):\r\n  \"\"\"\r\n  GetCurveParameterFromNurbsFormParameter(self: Curve,nurbsParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a NURBS curve parameter to a curve parameter.\r\n\r\n  \r\n\r\n   nurbsParameter: Nurbs form parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetDistancesBetweenCurves(curveA,curveB,tolerance,maxDistance,maxDistanceParameterA,maxDistanceParameterB,minDistance,minDistanceParameterA,minDistanceParameterB):\r\n  \"\"\"\r\n  GetDistancesBetweenCurves(curveA: Curve,curveB: Curve,tolerance: float) -> (bool,float,float,float,float,float,float)\r\n\r\n  \r\n\r\n   Computes the distances between two arbitrary curves that overlap.\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: true if the operation succeeded; otherwise false.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def GetFilletPoints(curve0,curve1,radius,t0Base,t1Base,t0,t1,filletPlane):\r\n  \"\"\"\r\n  GetFilletPoints(curve0: Curve,curve1: Curve,radius: float,t0Base: float,t1Base: float) -> (bool,float,float,Plane)\r\n\r\n  \r\n\r\n   Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.\r\n\r\n  \r\n\r\n   curve0: First curve to fillet.\r\n\r\n   curve1: Second curve to fillet.\r\n\r\n   radius: Fillet radius.\r\n\r\n   t0Base: Parameter value for base point on curve0.\r\n\r\n   t1Base: Parameter value for base point on curve1.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetLength(self,*__args):\r\n  \"\"\"\r\n  GetLength(self: Curve,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float,subdomain: Interval) -> float\r\n\r\n  \r\n\r\n   Get the length of a sub-section of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve (must be non-decreasing).\r\n\r\n   Returns: The length of the sub-curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve) -> float\r\n\r\n  \r\n\r\n   Gets the length of the curve with a fractional tolerance of 1.0e-8.\r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n\r\n  GetLength(self: Curve,fractionalTolerance: float) -> float\r\n\r\n  \r\n\r\n   Get the length of the curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: The length of the curve on success,or zero on failure.\r\n  \"\"\"\r\n  pass\r\n def GetNextDiscontinuity(self,continuityType,t0,t1,t):\r\n  \"\"\"\r\n  GetNextDiscontinuity(self: Curve,continuityType: Continuity,t0: float,t1: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Searches for a derivative,tangent,or curvature discontinuity.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to search for.\r\n\r\n   t0: Search begins at t0. If there is a discontinuity at t0,it will be ignored. This makes it\r\n\r\n     \r\n\r\n       possible to repeatedly call GetNextDiscontinuity() and step through the discontinuities.\r\n\r\n  \r\n\r\n   t1: (t0 != t1)  If there is a discontinuity at t1 it will be ignored unless continuityType is\r\n\r\n     \r\n\r\n       a locus discontinuity type and t1 is at the start or end of the curve.\r\n\r\n  \r\n\r\n   Returns: Parametric continuity tests c=(C0_continuous,...,G2_continuous):\r\n\r\n      true if a \r\n\r\n    parametric discontinuity was found strictly between t0 and t1. Note well that\r\n\r\n      all \r\n\r\n    curves are parametrically continuous at the ends of their domains.\r\n\r\n     \r\n\r\n     \r\n\r\n    Locus continuity tests c=(C0_locus_continuous,...,G2_locus_continuous):\r\n\r\n      true if \r\n\r\n    a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\r\n\r\n      \r\n\r\n    of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\r\n\r\n  \r\n\r\n        ends of their domains.  All closed curves (IsClosed()=true) are at least \r\n\r\n    C0_locus_continuous at \r\n\r\n      the ends of their domains.\r\n  \"\"\"\r\n  pass\r\n def GetNurbsFormParameterFromCurveParameter(self,curveParameter,nurbsParameter):\r\n  \"\"\"\r\n  GetNurbsFormParameterFromCurveParameter(self: Curve,curveParameter: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Convert a curve parameter to a NURBS curve parameter.\r\n\r\n  \r\n\r\n   curveParameter: Curve parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def GetPerpendicularFrames(self,parameters):\r\n  \"\"\" GetPerpendicularFrames(self: Curve,parameters: IEnumerable[float]) -> Array[Plane] \"\"\"\r\n  pass\r\n def HasNurbsForm(self):\r\n  \"\"\"\r\n  HasNurbsForm(self: Curve) -> int\r\n\r\n  \r\n\r\n   Does a NURBS curve representation of this curve exist?\r\n\r\n   Returns: 0   unable to create NURBS representation with desired accuracy.\r\n\r\n     1   success - \r\n\r\n    NURBS parameterization matches the curve's to the desired accuracy\r\n\r\n     2   success - \r\n\r\n    NURBS point locus matches the curve's and the domain of the NURBS\r\n\r\n          \r\n\r\n    curve is correct. However,This curve's parameterization and the\r\n\r\n          \r\n\r\n    NURBS curve parameterization may not match. This situation happens\r\n\r\n          \r\n\r\n    when getting NURBS representations of curves that have a\r\n\r\n          \r\n\r\n    transendental parameterization like circles.\r\n  \"\"\"\r\n  pass\r\n def IsArc(self,tolerance=None):\r\n  \"\"\"\r\n  IsArc(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n\r\n  IsArc(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve can be represented by an arc or a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsCircle(self,tolerance=None):\r\n  \"\"\"\r\n  IsCircle(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within the given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve can be represented by a circle to within tolerance.\r\n\r\n  IsCircle(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by a circle within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsClosable(self,tolerance,minimumAbsoluteSize=None,minimumRelativeSize=None):\r\n  \"\"\"\r\n  IsClosable(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint \r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as \r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n\r\n  IsClosable(self: Curve,tolerance: float,minimumAbsoluteSize: float,minimumRelativeSize: float) -> bool\r\n\r\n  \r\n\r\n   Decide if it makes sense to close off this curve by moving the endpoint\r\n\r\n     to the \r\n\r\n    start based on start-end gap size and length of curve as\r\n\r\n     approximated by chord \r\n\r\n    defined by 6 points.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Maximum allowable distance between start and end. \r\n\r\n     If start - end gap is greater \r\n\r\n    than tolerance,this function will return false.\r\n\r\n  \r\n\r\n   minimumAbsoluteSize: If greater than 0.0 and none of the interior sampled points are at\r\n\r\n     least \r\n\r\n    minimumAbsoluteSize from start,this function will return false.\r\n\r\n  \r\n\r\n   minimumRelativeSize: If greater than 1.0 and chord length is less than \r\n\r\n     minimumRelativeSize*gap,this \r\n\r\n    function will return false.\r\n\r\n  \r\n\r\n   Returns: true if start and end points are close enough based on above conditions.\r\n  \"\"\"\r\n  pass\r\n def IsContinuous(self,continuityType,t):\r\n  \"\"\"\r\n  IsContinuous(self: Curve,continuityType: Continuity,t: float) -> bool\r\n\r\n  \r\n\r\n   Test continuity at a curve parameter value.\r\n\r\n  \r\n\r\n   continuityType: Type of continuity to test for.\r\n\r\n   t: Parameter to test.\r\n\r\n   Returns: true if the curve has at least the c type continuity at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def IsEllipse(self,tolerance=None):\r\n  \"\"\"\r\n  IsEllipse(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within a given tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use for checking.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n\r\n  IsEllipse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the Curve can be represented by an ellipse within tolerance.\r\n  \"\"\"\r\n  pass\r\n def IsInPlane(self,testPlane,tolerance=None):\r\n  \"\"\"\r\n  IsInPlane(self: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= tolerance.\r\n\r\n  IsInPlane(self: Curve,testPlane: Plane) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it lies in a specific plane.\r\n\r\n  \r\n\r\n   testPlane: Plane to test for.\r\n\r\n   Returns: true if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def IsLinear(self,tolerance=None):\r\n  \"\"\"\r\n  IsLinear(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within the custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking linearity.\r\n\r\n   Returns: true if the ends of the curve are farther than tolerance apart\r\n\r\n     and the maximum \r\n\r\n    distance from any point on the curve to\r\n\r\n     the line segment connecting the curve ends \r\n\r\n    is <= tolerance.\r\n\r\n  \r\n\r\n  IsLinear(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).\r\n\r\n   Returns: true if the curve is linear.\r\n  \"\"\"\r\n  pass\r\n def IsPlanar(self,tolerance=None):\r\n  \"\"\"\r\n  IsPlanar(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  IsPlanar(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Test a curve for planarity.\r\n\r\n   Returns: true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).\r\n  \"\"\"\r\n  pass\r\n def IsPolyline(self):\r\n  \"\"\"\r\n  IsPolyline(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline\r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form of\r\n\r\n\r\n    \r\n     polyline. IsPolyline tests a curve to see if it can be\r\n\r\n     represented as \r\n\r\n    a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def IsShort(self,tolerance,subdomain=None):\r\n  \"\"\"\r\n  IsShort(self: Curve,tolerance: float,subdomain: Interval) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   subdomain: The test is performed on the interval that is the intersection of subdomain with Domain()\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n\r\n  IsShort(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Used to quickly find short curves.\r\n\r\n  \r\n\r\n   tolerance: Length threshold value for \"shortness\".\r\n\r\n   Returns: true if the length of the curve is <= tolerance.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def JoinCurves(inputCurves,joinTolerance=None,preserveDirection=None):\r\n  \"\"\"\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float,preserveDirection: bool) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve],joinTolerance: float) -> Array[Curve]\r\n\r\n  JoinCurves(inputCurves: IEnumerable[Curve]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def LengthParameter(self,segmentLength,t,*__args):\r\n  \"\"\"\r\n  LengthParameter(self: Curve,segmentLength: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the subdomain.\r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve rather than the whole \r\n\r\n    curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve. \r\n\r\n      \r\n\r\n      A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  LengthParameter(self: Curve,segmentLength: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Gets the parameter along the curve which coincides with a given length along the curve.\r\n\r\n  \r\n\r\n   segmentLength: Length of segment to measure. Must be less than or equal to the length of the curve.\r\n\r\n   fractionalTolerance: Desired fractional precision.\r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def MakeClosed(self,tolerance):\r\n  \"\"\"\r\n  MakeClosed(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   If IsClosed,just return true. Otherwise,decide if curve can be closed as \r\n\r\n     \r\n\r\n    follows: Linear curves polylinear curves with 2 segments,Nurbs with 3 or less \r\n\r\n     \r\n\r\n    control points cannot be made closed. Also,if tolerance > 0 and the gap between \r\n\r\n     \r\n\r\n    start and end is larger than tolerance,curve cannot be made closed. \r\n\r\n     Adjust the \r\n\r\n    curve's endpoint to match its start point.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: If nonzero,and the gap is more than tolerance,curve cannot be made closed.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def MakeEndsMeet(curveA,adjustStartCurveA,curveB,adjustStartCurveB):\r\n  \"\"\"\r\n  MakeEndsMeet(curveA: Curve,adjustStartCurveA: bool,curveB: Curve,adjustStartCurveB: bool) -> bool\r\n\r\n  \r\n\r\n   Makes adjustments to the ends of one or both input curves so that they meet at a point.\r\n\r\n  \r\n\r\n   curveA: 1st curve to adjust.\r\n\r\n   adjustStartCurveA: Which end of the 1st curve to adjust: true is start,false is end.\r\n\r\n   curveB: 2nd curve to adjust.\r\n\r\n   adjustStartCurveB: which end of the 2nd curve to adjust true==start,false==end.\r\n\r\n   Returns: true on success.\r\n  \"\"\"\r\n  pass\r\n def NonConstOperation(self,*args):\r\n  \"\"\"\r\n  NonConstOperation(self: Curve)\r\n\r\n   For derived classes implementers.\r\n\r\n     Defines the necessary implementation to free the \r\n\r\n    instance from being const.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameter(self,s,t,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameter(self: Curve,s: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float,subdomain: Interval) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n\r\n  NormalizedLengthParameter(self: Curve,s: float,fractionalTolerance: float) -> (bool,float)\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Normalized arc length parameter. \r\n\r\n     E.g.,0=start of curve,1/2=midpoint of \r\n\r\n    curve,1=end of curve.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision. \r\n\r\n     fabs((\"exact\" length from start to t) - \r\n\r\n    arc_length)/arc_length <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def NormalizedLengthParameters(self,s,absoluteTolerance,*__args):\r\n  \"\"\"\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float,subdomain: Interval) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   subdomain: The calculation is performed on the specified sub-domain of the curve. \r\n\r\n     A 0.0 s \r\n\r\n    value corresponds to subdomain->Min() and a 1.0 s value corresponds to subdomain->Max().\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve. \r\n\r\n     A fractional tolerance of 1e-8 is used in this version of the function.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n\r\n  \r\n\r\n  NormalizedLengthParameters(self: Curve,s: Array[float],absoluteTolerance: float,fractionalTolerance: float) -> Array[float]\r\n\r\n  \r\n\r\n   Input the parameter of the point on the curve that is a prescribed arc length from the start of \r\n\r\n    the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   s: Array of normalized arc length parameters. \r\n\r\n     E.g.,0=start of curve,1/2=\r\n\r\n    midpoint of curve,1=end of curve.\r\n\r\n  \r\n\r\n   absoluteTolerance: If absoluteTolerance > 0,then the difference between (s[i+1]-s[i])*curve_length \r\n\r\n     \r\n\r\n    and the length of the curve segment from t[i] to t[i+1] will be <= absoluteTolerance.\r\n\r\n  \r\n\r\n   fractionalTolerance: Desired fractional precision for each segment. \r\n\r\n     fabs(\"true\" length - actual \r\n\r\n    length)/(actual length) <= fractionalTolerance.\r\n\r\n  \r\n\r\n   Returns: If successful,array of curve parameters such that the length of the curve from its start to \r\n\r\n    t[i] is s[i]*curve_length. \r\n\r\n     Null on failure.\r\n  \"\"\"\r\n  pass\r\n def Offset(self,*__args):\r\n  \"\"\"\r\n  Offset(self: Curve,directionPoint: Point3d,normal: Vector3d,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   directionPoint: A point that indicates the direction of the offset.\r\n\r\n   normal: The normal to the offset plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n\r\n  Offset(self: Curve,plane: Plane,distance: float,tolerance: float,cornerStyle: CurveOffsetCornerStyle) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offsets this curve. If you have a nice offset,then there will be one entry in \r\n\r\n     the \r\n\r\n    array. If the original curve had kinks or the offset curve had self \r\n\r\n     intersections,\r\n\r\n    you will get multiple segments in the offset_curves[] array.\r\n\r\n  \r\n\r\n  \r\n\r\n   plane: Offset solution plane.\r\n\r\n   distance: The positive or negative distance to offset.\r\n\r\n   tolerance: The offset or fitting tolerance.\r\n\r\n   cornerStyle: Corner style for offset kinks.\r\n\r\n   Returns: Offset curves on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def OffsetNormalToSurface(self,surface,height):\r\n  \"\"\"\r\n  OffsetNormalToSurface(self: Curve,surface: Surface,height: float) -> Curve\r\n\r\n  \r\n\r\n   Finds a curve by offsetting an existing curve normal to a surface.\r\n\r\n     The caller is \r\n\r\n    responsible for ensuring that the curve lies on the input surface.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: Surface from which normals are calculated.\r\n\r\n   height: offset distance (distance from surface to result curve)\r\n\r\n   Returns: Offset curve at distance height from the surface.  The offset curve is\r\n\r\n     interpolated \r\n\r\n    through a small number of points so if the surface is irregular\r\n\r\n     or complicated,the \r\n\r\n    result will not be a very accurate offset.\r\n  \"\"\"\r\n  pass\r\n def OffsetOnSurface(self,*__args):\r\n  \"\"\"\r\n  OffsetOnSurface(self: Curve,surface: Surface,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,surface: Surface,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a surface. This curve must lie on the surface.\r\n\r\n     This overload \r\n\r\n    allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   surface: A surface on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: Distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,distance: float,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset this curve on a brep face surface. This curve must lie on the surface.\r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   distance: A distance to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,throughPoint: Point2d,fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify a surface point at which the offset will pass.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   throughPoint: 2d point on the brep face to offset through.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n\r\n  OffsetOnSurface(self: Curve,face: BrepFace,curveParameters: Array[float],offsetDistances: Array[float],fittingTolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Offset a curve on a brep face surface. This curve must lie on the surface.\r\n\r\n     This \r\n\r\n    overload allows to specify different offsets for different curve parameters.\r\n\r\n  \r\n\r\n  \r\n\r\n   face: The brep face on which to offset.\r\n\r\n   curveParameters: Curve parameters corresponding to the offset distances.\r\n\r\n   offsetDistances: distances to offset (+)left,(-)right.\r\n\r\n   fittingTolerance: A fitting tolerance.\r\n\r\n   Returns: Offset curves on success,or null on failure.\r\n  \"\"\"\r\n  pass\r\n def OnSwitchToNonConst(self,*args):\r\n  \"\"\"\r\n  OnSwitchToNonConst(self: GeometryBase)\r\n\r\n   Is called when a non-const operation occurs.\r\n  \"\"\"\r\n  pass\r\n def PerpendicularFrameAt(self,t,plane):\r\n  \"\"\"\r\n  PerpendicularFrameAt(self: Curve,t: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Return a 3d frame at a parameter. This is slightly different than FrameAt in\r\n\r\n     that \r\n\r\n    the frame is computed in a way so there is minimal rotation from one\r\n\r\n     frame to the \r\n\r\n    next.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarClosedCurveRelationship(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarClosedCurveRelationship(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> RegionContainment\r\n\r\n  \r\n\r\n   Determines whether two coplanar simple closed curves are disjoint or intersect;\r\n\r\n     \r\n\r\n    otherwise,if the regions have a containment relationship,discovers\r\n\r\n     which curve \r\n\r\n    encloses the other.\r\n\r\n  \r\n\r\n  \r\n\r\n   curveA: A first curve.\r\n\r\n   curveB: A second curve.\r\n\r\n   testPlane: A plane.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A value indicating the relationship between the first and the second curve.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def PlanarCurveCollision(curveA,curveB,testPlane,tolerance):\r\n  \"\"\"\r\n  PlanarCurveCollision(curveA: Curve,curveB: Curve,testPlane: Plane,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Determines if two coplanar curves collide (intersect).\r\n\r\n  \r\n\r\n   curveA: A curve.\r\n\r\n   curveB: Another curve.\r\n\r\n   testPlane: A valid plane containing the curves.\r\n\r\n   tolerance: A tolerance value for intersection.\r\n\r\n   Returns: true if the curves intersect,otherwise false\r\n  \"\"\"\r\n  pass\r\n def PointAt(self,t):\r\n  \"\"\"\r\n  PointAt(self: Curve,t: float) -> Point3d\r\n\r\n  \r\n\r\n   Evaluates point at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Point (location of curve at the parameter t).\r\n  \"\"\"\r\n  pass\r\n def PointAtLength(self,length):\r\n  \"\"\"\r\n  PointAtLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain length along the curve. The length must be \r\n\r\n     non-negative \r\n\r\n    and less than or equal to the length of the curve. \r\n\r\n     Lengths will not be wrapped \r\n\r\n    when the curve is closed or periodic.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified length from the start point or Poin3d.Unset on failure.\r\n  \"\"\"\r\n  pass\r\n def PointAtNormalizedLength(self,length):\r\n  \"\"\"\r\n  PointAtNormalizedLength(self: Curve,length: float) -> Point3d\r\n\r\n  \r\n\r\n   Gets a point at a certain normalized length along the curve. The length must be \r\n\r\n     \r\n\r\n    between or including 0.0 and 1.0,where 0.0 equals the start of the curve and \r\n\r\n     1.0 \r\n\r\n    equals the end of the curve.\r\n\r\n  \r\n\r\n  \r\n\r\n   length: Normalized length along the curve between the start point and the returned point.\r\n\r\n   Returns: Point on the curve at the specified normalized length from the start point or Poin3d.Unset on \r\n\r\n    failure.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToBrep(*__args):\r\n  \"\"\"\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToBrep(curves: IEnumerable[Curve],breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> (Array[Curve],Array[int])\r\n\r\n  ProjectToBrep(curve: Curve,brep: Brep,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a Curve onto a Brep along a given direction.\r\n\r\n  \r\n\r\n   curve: Curve to project.\r\n\r\n   brep: Brep to project onto.\r\n\r\n   direction: Direction of projection.\r\n\r\n   tolerance: Tolerance to use for projection.\r\n\r\n   Returns: An array of projected curves or empty array if the projection set is empty.\r\n\r\n  ProjectToBrep(curve: Curve,breps: IEnumerable[Brep],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToMesh(*__args):\r\n  \"\"\"\r\n  ProjectToMesh(curves: IEnumerable[Curve],meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,meshes: IEnumerable[Mesh],direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  ProjectToMesh(curve: Curve,mesh: Mesh,direction: Vector3d,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Projects a curve to a mesh using a direction and tolerance.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   mesh: A mesh.\r\n\r\n   direction: A direction vector.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: A curve array.\r\n  \"\"\"\r\n  pass\r\n @staticmethod\r\n def ProjectToPlane(curve,plane):\r\n  \"\"\"\r\n  ProjectToPlane(curve: Curve,plane: Plane) -> Curve\r\n\r\n  \r\n\r\n   Constructs a curve by projecting an existing curve to a plane.\r\n\r\n  \r\n\r\n   curve: A curve.\r\n\r\n   plane: A plane.\r\n\r\n   Returns: The projected curve on success; null on failure.\r\n  \"\"\"\r\n  pass\r\n def PullToBrepFace(self,*__args):\r\n  \"\"\"\r\n  PullToBrepFace(curve: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pull a curve to a BrepFace using closest point projection.\r\n\r\n  \r\n\r\n   curve: Curve to pull.\r\n\r\n   face: Brepface that pulls.\r\n\r\n   tolerance: Tolerance to use for pulling.\r\n\r\n   Returns: An array of pulled curves,or an empty array on failure.\r\n\r\n  PullToBrepFace(self: Curve,face: BrepFace,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Pulls this curve to a brep face and returns the result of that operation.\r\n\r\n  \r\n\r\n   face: A brep face.\r\n\r\n   tolerance: A tolerance value.\r\n\r\n   Returns: An array containing the resulting curves after pulling. This array could be empty.\r\n  \"\"\"\r\n  pass\r\n def PullToMesh(self,mesh,tolerance):\r\n  \"\"\"\r\n  PullToMesh(self: Curve,mesh: Mesh,tolerance: float) -> PolylineCurve\r\n\r\n  \r\n\r\n   Makes a polyline approximation of the curve and gets the closest point on the mesh for each \r\n\r\n    point on the curve. \r\n\r\n     Then it \"connects the points\" so that you have a polyline on \r\n\r\n    the mesh.\r\n\r\n  \r\n\r\n  \r\n\r\n   mesh: Mesh to project onto.\r\n\r\n   tolerance: Input tolerance (RhinoDoc.ModelAbsoluteTolerance is a good default)\r\n\r\n   Returns: A polyline curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def Rebuild(self,pointCount,degree,preserveTangents):\r\n  \"\"\"\r\n  Rebuild(self: Curve,pointCount: int,degree: int,preserveTangents: bool) -> NurbsCurve\r\n\r\n  \r\n\r\n   Rebuild a curve with a specific point count.\r\n\r\n  \r\n\r\n   pointCount: Number of control points in the rebuild curve.\r\n\r\n   degree: Degree of curve. Valid values are between and including 1 and 11.\r\n\r\n   preserveTangents: If true,the end tangents of the input curve will be preserved.\r\n\r\n   Returns: A Nurbs curve on success or null on failure.\r\n  \"\"\"\r\n  pass\r\n def RemoveShortSegments(self,tolerance):\r\n  \"\"\"\r\n  RemoveShortSegments(self: Curve,tolerance: float) -> bool\r\n\r\n  \r\n\r\n   Looks for segments that are shorter than tolerance that can be removed. \r\n\r\n     Does not \r\n\r\n    change the domain,but it will change the relative parameterization.\r\n\r\n  \r\n\r\n  \r\n\r\n   tolerance: Tolerance which defines \"short\" segments.\r\n\r\n   Returns: true if removable short segments were found. \r\n\r\n     false if no removable short segments \r\n\r\n    were found.\r\n  \"\"\"\r\n  pass\r\n def Reverse(self):\r\n  \"\"\"\r\n  Reverse(self: Curve) -> bool\r\n\r\n  \r\n\r\n   Reverses the direction of the curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetEndPoint(self,point):\r\n  \"\"\"\r\n  SetEndPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to end at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New end point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def SetStartPoint(self,point):\r\n  \"\"\"\r\n  SetStartPoint(self: Curve,point: Point3d) -> bool\r\n\r\n  \r\n\r\n   Forces the curve to start at a specified point. \r\n\r\n     Not all curve types support this \r\n\r\n    operation.\r\n\r\n  \r\n\r\n  \r\n\r\n   point: New start point of curve.\r\n\r\n   Returns: true on success,false on failure.\r\n  \"\"\"\r\n  pass\r\n def Simplify(self,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  Simplify(self: Curve,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Returns a geometrically equivalent PolyCurve.\r\n\r\n     The PolyCurve has the following \r\n\r\n    properties\r\n\r\n     1. All the PolyCurve segments are LineCurve,PolylineCurve,ArcCurve,or \r\n\r\n    NurbsCurve.\r\n\r\n     \r\n\r\n     2. The Nurbs Curves segments do not have fully multiple \r\n\r\n    interior knots.\r\n\r\n     \r\n\r\n     3. Rational Nurbs curves do not have constant \r\n\r\n    weights.\r\n\r\n     \r\n\r\n     4. Any segment for which IsLinear() or IsArc() is true is a \r\n\r\n    Line,\r\n\r\n        Polyline segment,or an Arc.\r\n\r\n     \r\n\r\n     5. Adjacent \r\n\r\n    Colinear or Cocircular segments are combined.\r\n\r\n     \r\n\r\n     6. Segments that meet \r\n\r\n    with G1-continuity have there ends tuned up so\r\n\r\n        that they meet with G1-continuity \r\n\r\n    to within machine precision.\r\n\r\n  \r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SimplifyEnd(self,end,options,distanceTolerance,angleToleranceRadians):\r\n  \"\"\"\r\n  SimplifyEnd(self: Curve,end: CurveEnd,options: CurveSimplifyOptions,distanceTolerance: float,angleToleranceRadians: float) -> Curve\r\n\r\n  \r\n\r\n   Same as SimplifyCurve,but simplifies only the last two segments at \"side\" end.\r\n\r\n  \r\n\r\n   end: If CurveEnd.Start the function simplifies the last two start \r\n\r\n     side segments,\r\n\r\n    otherwise if CurveEnd.End the last two end side segments are simplified.\r\n\r\n  \r\n\r\n   options: Simplification options.\r\n\r\n   distanceTolerance: A distance tolerance for the simplification.\r\n\r\n   angleToleranceRadians: An angle tolerance for the simplification.\r\n\r\n   Returns: New simplified curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def SpanDomain(self,spanIndex):\r\n  \"\"\"\r\n  SpanDomain(self: Curve,spanIndex: int) -> Interval\r\n\r\n  \r\n\r\n   Get the domain of the curve span with the given index. \r\n\r\n     Use the SpanCount property \r\n\r\n    to test how many spans there are.\r\n\r\n  \r\n\r\n  \r\n\r\n   spanIndex: Index of span.\r\n\r\n   Returns: Interval of the span with the given index.\r\n  \"\"\"\r\n  pass\r\n def Split(self,*__args):\r\n  \"\"\"\r\n  Split(self: Curve,cutter: Brep,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a polysurface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,cutter: Surface,tolerance: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits a curve into pieces using a surface.\r\n\r\n  \r\n\r\n   cutter: A cutting surface or polysurface.\r\n\r\n   tolerance: A tolerance for computing intersections.\r\n\r\n   Returns: An array of curves. This array can be empty.\r\n\r\n  Split(self: Curve,t: float) -> Array[Curve]\r\n\r\n  \r\n\r\n   Splits (divides) the curve at the specified parameter. \r\n\r\n     The parameter must be in \r\n\r\n    the interior of the curve's domain.\r\n\r\n  \r\n\r\n  \r\n\r\n   t: Parameter to split the curve at in the interval returned by Domain().\r\n\r\n   Returns: Two curves on success,null on failure.\r\n\r\n  Split(self: Curve,t: IEnumerable[float]) -> Array[Curve]\r\n  \"\"\"\r\n  pass\r\n def TangentAt(self,t):\r\n  \"\"\"\r\n  TangentAt(self: Curve,t: float) -> Vector3d\r\n\r\n  \r\n\r\n   Evaluates the unit tangent vector at a curve parameter.\r\n\r\n  \r\n\r\n   t: Evaluation parameter.\r\n\r\n   Returns: Unit tangent vector of the curve at the parameter t.\r\n  \"\"\"\r\n  pass\r\n def ToNurbsCurve(self,subdomain=None):\r\n  \"\"\"\r\n  ToNurbsCurve(self: Curve) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n\r\n  ToNurbsCurve(self: Curve,subdomain: Interval) -> NurbsCurve\r\n\r\n  \r\n\r\n   Constructs a NURBS curve representation of this curve.\r\n\r\n  \r\n\r\n   subdomain: The NURBS representation for this portion of the curve is returned.\r\n\r\n   Returns: NURBS representation of the curve on success,null on failure.\r\n  \"\"\"\r\n  pass\r\n def ToPolyline(self,mainSegmentCount,subSegmentCount,maxAngleRadians,maxChordLengthRatio,maxAspectRatio,tolerance,minEdgeLength,maxEdgeLength,keepStartPoint,curveDomain=None):\r\n  \"\"\"\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool,curveDomain: Interval) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   curveDomain: This subdomain of the NURBS curve is approximated.\r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n\r\n  ToPolyline(self: Curve,mainSegmentCount: int,subSegmentCount: int,maxAngleRadians: float,maxChordLengthRatio: float,maxAspectRatio: float,tolerance: float,minEdgeLength: float,maxEdgeLength: float,keepStartPoint: bool) -> PolylineCurve\r\n\r\n  \r\n\r\n   Gets a polyline approximation of a curve.\r\n\r\n  \r\n\r\n   mainSegmentCount: If mainSegmentCount <= 0,then both subSegmentCount and mainSegmentCount are ignored. \r\n\r\n     \r\n\r\n    If mainSegmentCount > 0,then subSegmentCount must be >= 1. In this \r\n\r\n     case the \r\n\r\n    nurb will be broken into mainSegmentCount equally spaced \r\n\r\n     chords. If needed,each \r\n\r\n    of these chords can be split into as many \r\n\r\n     subSegmentCount sub-parts if the \r\n\r\n    subdivision is necessary for the \r\n\r\n     mesh to meet the other meshing constraints. In \r\n\r\n    particular,if \r\n\r\n     subSegmentCount=0,then the curve is broken into mainSegmentCount \r\n\r\n    \r\n\r\n     pieces and no further testing is performed.\r\n\r\n  \r\n\r\n   subSegmentCount: An amount of subsegments.\r\n\r\n   maxAngleRadians: ( 0 to pi ) Maximum angle (in radians) between unit tangents at \r\n\r\n     adjacent vertices.\r\n\r\n   maxChordLengthRatio: Maximum permitted value of \r\n\r\n     (distance chord midpoint to curve) / (length of chord).\r\n\r\n   maxAspectRatio: If maxAspectRatio < 1.0,the parameter is ignored. \r\n\r\n     If 1 <= maxAspectRatio < \r\n\r\n    sqrt(2),it is treated as if maxAspectRatio=sqrt(2). \r\n\r\n     This parameter controls the \r\n\r\n    maximum permitted value of \r\n\r\n     (length of longest chord) / (length of shortest chord).\r\n\r\n  \r\n\r\n   tolerance: If tolerance=0,the parameter is ignored. \r\n\r\n     This parameter controls the maximum \r\n\r\n    permitted value of the \r\n\r\n     distance from the curve to the polyline.\r\n\r\n  \r\n\r\n   minEdgeLength: The minimum permitted edge length.\r\n\r\n   maxEdgeLength: If maxEdgeLength=0,the parameter \r\n\r\n     is ignored. This parameter controls the \r\n\r\n    maximum permitted edge length.\r\n\r\n  \r\n\r\n   keepStartPoint: If true the starting point of the curve \r\n\r\n     is added to the polyline. If false the \r\n\r\n    starting point of the curve is \r\n\r\n     not added to the polyline.\r\n\r\n  \r\n\r\n   Returns: PolylineCurve on success,null on error.\r\n  \"\"\"\r\n  pass\r\n def Trim(self,*__args):\r\n  \"\"\"\r\n  Trim(self: Curve,side: CurveEnd,length: float) -> Curve\r\n\r\n  \r\n\r\n   Shortens a curve by a given length\r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,domain: Interval) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   domain: Trimming interval. Portions of the curve before curve(domain[0])\r\n\r\n     and after \r\n\r\n    curve(domain[1]) are removed.\r\n\r\n  \r\n\r\n   Returns: Trimmed curve if successful,null on failure.\r\n\r\n  Trim(self: Curve,t0: float,t1: float) -> Curve\r\n\r\n  \r\n\r\n   Removes portions of the curve outside the specified interval.\r\n\r\n  \r\n\r\n   t0: Start of the trimming interval. Portions of the curve before curve(t0) are removed.\r\n\r\n   t1: End of the trimming interval. Portions of the curve after curve(t1) are removed.\r\n\r\n   Returns: Trimmed portion of this curve is successfull,null on failure.\r\n  \"\"\"\r\n  pass\r\n def TryGetArc(self,*__args):\r\n  \"\"\"\r\n  TryGetArc(self: Curve,plane: Plane) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve,plane: Plane,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc within the given plane.\r\n\r\n  TryGetArc(self: Curve) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n\r\n  TryGetArc(self: Curve,tolerance: float) -> (bool,Arc)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Arc using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an arc.\r\n  \"\"\"\r\n  pass\r\n def TryGetCircle(self,circle,tolerance=None):\r\n  \"\"\"\r\n  TryGetCircle(self: Curve,tolerance: float) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a Circle using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into a Circle within tolerance.\r\n\r\n  TryGetCircle(self: Curve) -> (bool,Circle)\r\n\r\n  \r\n\r\n   Try to convert this curve into a circle using RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into a Circle.\r\n  \"\"\"\r\n  pass\r\n def TryGetEllipse(self,*__args):\r\n  \"\"\"\r\n  TryGetEllipse(self: Curve,plane: Plane) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve,plane: Plane,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   plane: Plane in which the comparison is performed.\r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse within the given plane.\r\n\r\n  TryGetEllipse(self: Curve) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n\r\n  TryGetEllipse(self: Curve,tolerance: float) -> (bool,Ellipse)\r\n\r\n  \r\n\r\n   Try to convert this curve into an Ellipse using a custom tolerance.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if the curve could be converted into an Ellipse.\r\n  \"\"\"\r\n  pass\r\n def TryGetPlane(self,plane,tolerance=None):\r\n  \"\"\"\r\n  TryGetPlane(self: Curve,tolerance: float) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n  \r\n\r\n   tolerance: Tolerance to use when checking.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    tolerance.\r\n\r\n  \r\n\r\n  TryGetPlane(self: Curve) -> (bool,Plane)\r\n\r\n  \r\n\r\n   Test a curve for planarity and return the plane.\r\n\r\n   Returns: true if there is a plane such that the maximum distance from the curve to the plane is <= \r\n\r\n    RhinoMath.ZeroTolerance.\r\n  \"\"\"\r\n  pass\r\n def TryGetPolyline(self,polyline,parameters=None):\r\n  \"\"\"\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline,Array[float])\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n\r\n  TryGetPolyline(self: Curve) -> (bool,Polyline)\r\n\r\n  \r\n\r\n   Several types of Curve can have the form of a polyline \r\n\r\n     including a degree 1 \r\n\r\n    NurbsCurve,a PolylineCurve,\r\n\r\n     and a PolyCurve all of whose segments are some form \r\n\r\n    of \r\n\r\n     polyline. IsPolyline tests a curve to see if it can be \r\n\r\n     \r\n\r\n    represented as a polyline.\r\n\r\n  \r\n\r\n   Returns: true if this curve can be represented as a polyline; otherwise,false.\r\n  \"\"\"\r\n  pass\r\n def __enter__(self,*args):\r\n  \"\"\"\r\n  __enter__(self: IDisposable) -> object\r\n\r\n  \r\n\r\n   Provides the implementation of __enter__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __exit__(self,*args):\r\n  \"\"\"\r\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\r\n\r\n   Provides the implementation of __exit__ for objects which implement IDisposable.\r\n  \"\"\"\r\n  pass\r\n def __init__(self,*args):\r\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n  pass\r\n @staticmethod\r\n def __new__(self,*args): #cannot find CLR constructor\r\n  \"\"\"\r\n  __new__(cls: type)\r\n\r\n  __new__(cls: type,info: SerializationInfo,context: StreamingContext)\r\n  \"\"\"\r\n  pass\r\n def __reduce_ex__(self,*args):\r\n  pass\r\n Degree=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the maximum algebraic degree of any span\r\n\r\n   or a good estimate if curve spans are not algebraic.\r\n\r\n\r\n\r\nGet: Degree(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Dimension=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the dimension of the object.\r\n\r\n   The dimension is typically three. For parameter space trimming\r\n\r\n   curves the dimension is two. In rare cases the dimension can\r\n\r\n   be one or greater than three.\r\n\r\n\r\n\r\nGet: Dimension(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n Domain=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets or sets the domain of the curve.\r\n\r\n\r\n\r\nGet: Domain(self: Curve) -> Interval\r\n\r\n\r\n\r\nSet: Domain(self: Curve)=value\r\n\r\n\"\"\"\r\n\r\n IsClosed=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is a closed curve.\r\n\r\n\r\n\r\nGet: IsClosed(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n IsPeriodic=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets a value indicating whether or not this curve is considered to be Periodic.\r\n\r\n\r\n\r\nGet: IsPeriodic(self: Curve) -> bool\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the end of the curve.\r\n\r\n\r\n\r\nGet: PointAtEnd(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n PointAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates point at the start of the curve.\r\n\r\n\r\n\r\nGet: PointAtStart(self: Curve) -> Point3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n SpanCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Gets the number of non-empty smooth (c-infinity) spans in the curve.\r\n\r\n\r\n\r\nGet: SpanCount(self: Curve) -> int\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtEnd=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluate unit tangent vector at the end of the curve.\r\n\r\n\r\n\r\nGet: TangentAtEnd(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n TangentAtStart=property(lambda self: object(),lambda self,v: None,lambda self: None)\r\n \"\"\"Evaluates the unit tangent vector at the start of the curve.\r\n\r\n\r\n\r\nGet: TangentAtStart(self: Curve) -> Vector3d\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": false
}