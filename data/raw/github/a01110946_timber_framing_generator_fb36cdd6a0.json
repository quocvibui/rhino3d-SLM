{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_mep_graph_builder.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_mep_graph_builder.py",
  "instruction": "MEP Graph Builder for Grasshopper.",
  "code": "# File: scripts/gh_mep_graph_builder.py\n\"\"\"MEP Graph Builder for Grasshopper.\n\nBuilds multi-domain routing graphs from wall and floor geometry for\nMEP routing. Part of the OAHS (Obstacle-Aware Hanan Sequential)\nMEP routing pipeline.\n\nKey Features:\n1. Wall Graph Construction\n   - Creates 2D grid graphs in UV (wall) space\n   - Marks stud obstacles with penetration costs\n   - Handles plate zones (blocked routing)\n\n2. Floor Graph Construction\n   - Creates 2D grid graphs in XY space\n   - Marks joist obstacles\n   - Supports web opening zones\n\n3. Transition Generation\n   - Wall-to-floor transitions at base plates\n   - Wall-to-wall transitions at corners\n   - Cross-domain path support\n\n4. Visualization\n   - Node points for Rhino preview\n   - Edge lines showing routing channels\n   - Transition edges highlighted\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - networkx: Graph operations\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for output\n    - timber_framing_generator.mep.routing: Graph builders\n\nUsage:\n    1. Connect walls JSON to 'walls_json' input\n    2. Optionally connect connectors and targets\n    3. Set 'run' to True to execute\n    4. Use output for debugging or downstream routing\n\nInput Requirements:\n    Walls JSON (walls_json) - str:\n        JSON string with wall geometry data\n        Required: Yes\n        Access: Item\n\n    Connectors JSON (connectors_json) - str:\n        Optional JSON with MEP connectors\n        Required: No\n        Access: Item\n\n    Targets JSON (targets_json) - str:\n        Optional JSON with routing targets\n        Required: No\n        Access: Item\n\n    Config (config) - str:\n        Optional configuration JSON\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Graph JSON (graph_json) - str:\n        Serialized graph for debugging\n\n    Node Points (node_points) - DataTree[Point3d]:\n        Graph nodes for visualization\n\n    Edge Lines (edge_lines) - DataTree[Line]:\n        Graph edges for visualization\n\n    Transition Lines (transition_lines) - DataTree[Line]:\n        Cross-domain transitions (highlighted)\n\n    Debug Info (debug_info) - str:\n        Statistics and debug information\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n_modules_to_clear = [k for k in sys.modules.keys() if 'timber_framing_generator' in k]\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.mep.routing import (\n    build_routing_graph,\n    UnifiedGraphBuilder,\n    MultiDomainGraph,\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"MEP Graph Builder\"\nCOMPONENT_NICKNAME = \"MEPGraph\"\nCOMPONENT_MESSAGE = \"v1.0\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"MEP Routing\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Walls JSON\", \"walls_json\", \"JSON string with wall geometry data\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Connectors JSON\", \"connectors_json\", \"Optional MEP connectors JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Targets JSON\", \"targets_json\", \"Optional routing targets JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config\", \"config\", \"Optional configuration JSON\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Graph JSON\", \"graph_json\", \"Serialized graph for debugging\"),\n        (\"Node Points\", \"node_points\", \"Graph nodes for visualization\"),\n        (\"Edge Lines\", \"edge_lines\", \"Graph edges for visualization\"),\n        (\"Transition Lines\", \"transition_lines\", \"Cross-domain transitions\"),\n        (\"Debug Info\", \"debug_info\", \"Statistics and debug info\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls_json, run):\n    \"\"\"Validate component inputs.\"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n    if not walls_json:\n        return False, \"No walls JSON provided\"\n    return True, None\n\n\ndef parse_config(config_json):\n    \"\"\"Parse configuration options.\"\"\"\n    default_config = {\n        \"wall_resolution\": 0.5,\n        \"floor_resolution\": 1.0,\n        \"show_all_edges\": False\n    }\n\n    if not config_json:\n        return default_config\n\n    try:\n        user_config = json.loads(config_json)\n        default_config.update(user_config)\n    except Exception:\n        pass\n\n    return default_config\n\n\ndef create_visualization_geometry(mdg: MultiDomainGraph, walls_data):\n    \"\"\"Create visualization geometry for Rhino preview.\"\"\"\n    factory = get_factory()\n\n    node_points = DataTree[object]()\n    edge_lines = DataTree[object]()\n    transition_lines = DataTree[object]()\n\n    if not mdg.unified_graph:\n        return node_points, edge_lines, transition_lines\n\n    # Build wall position lookup\n    wall_positions = {}\n    for wall in walls_data:\n        wall_id = wall.get('id') or wall.get('wall_id')\n        if wall_id and 'start' in wall:\n            start = wall['start']\n            end = wall.get('end', start)\n            wall_positions[wall_id] = {\n                'start': start,\n                'end': end\n            }\n\n    # Create node points\n    domain_idx = 0\n    for domain_id, domain in mdg.domains.items():\n        path = GH_Path(domain_idx)\n\n        # Get nodes for this domain\n        for node, data in mdg.unified_graph.nodes(data=True):\n            if data.get('domain_id') != domain_id:\n                continue\n\n            loc = data.get('location', (0, 0))\n\n            # Convert to world coordinates\n            world_pt = _convert_to_world(\n                loc, domain_id, domain, wall_positions\n            )\n\n            if world_pt:\n                pt = factory.create_point3d(world_pt[0], world_pt[1], world_pt[2])\n                node_points.Add(pt, path)\n\n        domain_idx += 1\n\n    # Create edge lines\n    edge_idx = 0\n    for u, v, data in mdg.unified_graph.edges(data=True):\n        is_transition = data.get('is_transition', False)\n\n        u_data = mdg.unified_graph.nodes[u]\n        v_data = mdg.unified_graph.nodes[v]\n\n        u_domain = u_data.get('domain_id', '')\n        v_domain = v_data.get('domain_id', '')\n        u_loc = u_data.get('location', (0, 0))\n        v_loc = v_data.get('location', (0, 0))\n\n        # Get domains\n        u_domain_obj = mdg.domains.get(u_domain)\n        v_domain_obj = mdg.domains.get(v_domain)\n\n        u_world = _convert_to_world(u_loc, u_domain, u_domain_obj, wall_positions)\n        v_world = _convert_to_world(v_loc, v_domain, v_domain_obj, wall_positions)\n\n        if u_world and v_world:\n            pt1 = factory.create_point3d(u_world[0], u_world[1], u_world[2])\n            pt2 = factory.create_point3d(v_world[0], v_world[1], v_world[2])\n            line = factory.create_line(pt1, pt2)\n\n            path = GH_Path(edge_idx % 100)  # Group edges\n\n            if is_transition:\n                transition_lines.Add(line, path)\n            else:\n                edge_lines.Add(line, path)\n\n        edge_idx += 1\n\n    return node_points, edge_lines, transition_lines\n\n\ndef _convert_to_world(loc, domain_id, domain, wall_positions):\n    \"\"\"Convert domain coordinates to world XYZ.\"\"\"\n    from src.timber_framing_generator.mep.routing import RoutingDomainType\n\n    if domain is None:\n        return None\n\n    if domain.domain_type == RoutingDomainType.WALL_CAVITY:\n        # Wall: loc is (U, V) where U is along wall, V is height\n        pos = wall_positions.get(domain_id, {})\n        start = pos.get('start', [0, 0, 0])\n        end = pos.get('end', start)\n\n        # Calculate direction\n        dx = end[0] - start[0]\n        dy = end[1] - start[1]\n        import math\n        length = math.sqrt(dx*dx + dy*dy)\n        if length > 0:\n            dir_x = dx / length\n            dir_y = dy / length\n        else:\n            dir_x, dir_y = 1, 0\n\n        u, v = loc\n        world_x = start[0] + u * dir_x\n        world_y = start[1] + u * dir_y\n        world_z = v\n\n        return (world_x, world_y, world_z)\n\n    elif domain.domain_type == RoutingDomainType.FLOOR_CAVITY:\n        # Floor: loc is (X, Y) directly\n        return (loc[0], loc[1], 0)\n\n    return None\n\n\ndef build_graph_json(mdg: MultiDomainGraph):\n    \"\"\"Build debug JSON output.\"\"\"\n    stats = mdg.get_statistics()\n\n    output = {\n        \"statistics\": stats,\n        \"domains\": list(mdg.domains.keys()),\n        \"transitions\": [\n            {\n                \"id\": t.id,\n                \"from\": t.from_domain,\n                \"to\": t.to_domain,\n                \"type\": t.transition_type.value\n            }\n            for t in mdg.transitions\n        ]\n    }\n\n    return json.dumps(output, indent=2)\n\n\n# =============================================================================\n# Main Processing\n# =============================================================================\n\ndef main(walls_json, connectors_json, targets_json, config_json):\n    \"\"\"Main processing function.\"\"\"\n    debug_lines = []\n    debug_lines.append(\"=== MEP Graph Builder ===\")\n\n    try:\n        # Parse config\n        config = parse_config(config_json)\n        debug_lines.append(f\"Config: wall_res={config['wall_resolution']}, floor_res={config['floor_resolution']}\")\n\n        # Parse walls\n        walls_data = json.loads(walls_json)\n        if isinstance(walls_data, dict) and 'walls' in walls_data:\n            walls_data = walls_data['walls']\n        debug_lines.append(f\"Parsed {len(walls_data)} walls\")\n\n        # Build graph\n        builder = UnifiedGraphBuilder(\n            wall_grid_resolution=config['wall_resolution'],\n            floor_grid_resolution=config['floor_resolution']\n        )\n\n        mdg = builder.build_from_json(\n            walls_json,\n            connectors_json=connectors_json,\n            targets_json=targets_json\n        )\n\n        # Get statistics\n        stats = mdg.get_statistics()\n        debug_lines.append(f\"Domains: {stats['num_domains']}\")\n        debug_lines.append(f\"Transitions: {stats['num_transitions']}\")\n\n        for domain_id, domain_stats in stats.get('domains', {}).items():\n            debug_lines.append(\n                f\"  {domain_id}: {domain_stats['num_nodes']} nodes, \"\n                f\"{domain_stats['num_edges']} edges\"\n            )\n\n        if 'unified' in stats:\n            debug_lines.append(\n                f\"Unified: {stats['unified']['num_nodes']} nodes, \"\n                f\"{stats['unified']['num_edges']} edges\"\n            )\n\n        # Create visualization\n        node_points, edge_lines, transition_lines = create_visualization_geometry(\n            mdg, walls_data\n        )\n\n        # Build output JSON\n        graph_json = build_graph_json(mdg)\n\n        debug_lines.append(\"=== Complete ===\")\n        debug_info = \"\\n\".join(debug_lines)\n\n        return graph_json, node_points, edge_lines, transition_lines, debug_info\n\n    except Exception as e:\n        error_msg = f\"Error: {str(e)}\\n{traceback.format_exc()}\"\n        log_error(str(e))\n        return None, DataTree[object](), DataTree[object](), DataTree[object](), error_msg\n\n\n# =============================================================================\n# Entry Point\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Setup component on first run\n    setup_component()\n\n    # Validate inputs\n    is_valid, error_msg = validate_inputs(walls_json, run)\n\n    if not is_valid:\n        graph_json = None\n        node_points = DataTree[object]()\n        edge_lines = DataTree[object]()\n        transition_lines = DataTree[object]()\n        debug_info = error_msg\n        log_info(error_msg)\n    else:\n        # Run main processing\n        graph_json, node_points, edge_lines, transition_lines, debug_info = main(\n            walls_json, connectors_json, targets_json, config\n        )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}