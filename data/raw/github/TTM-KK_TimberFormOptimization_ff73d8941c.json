{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/temp/cantilever_RhinoCommon.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "temp/cantilever_RhinoCommon.py",
  "instruction": "Cantilever rhino common",
  "code": "# -*- coding:utf-8 -*-\nimport rhinoscriptsyntax as rs\nimport random as rnd\nimport math  # ttm add 181003\nimport time\nimport Rhino\nimport scriptcontext\nimport rhinoscript.utility as rhutil\n\n\ndef GetTimberSectionLength_RhinoCommon(tim_srf, base_point):\n    \"\"\"\n    :param tim_srf: surface of timber , you want to measure the length\n    :param base_point:  base point that Adding Timber having\n    :return: section diameter length\n    \"\"\"\n    rc, u, v = tim_srf.Faces[0].ClosestPoint(base_point)\n    V = tim_srf.Faces[0].Domain(1).T0 , tim_srf.Faces[0].Domain(1).T1\n\n    if V[0] < 0:\n        divide_V = abs(V[0] / 10)\n    else:\n        divide_V = abs(V[1] / 10)\n\n    list_point = []\n    for i in range(10):\n        point = tim_srf.Faces[0].PointAt(u, V[0] + divide_V * i)\n        list_point.append(point)\n\n    length = (list_point[0] - list_point[5]).Length\n\n    return length, list_point[0]\n\n\n\ndivide_domain_num = 10\n\n\n# 各オブジェクトの取得　--->  Timber Instanceに置き換える\ntim1_srf = rhutil.coercebrep(rs.GetObject(\"select first srf\", rs.filter.surface))\ntim2_srf = rhutil.coercebrep(rs.GetObject(\"select second srf\", rs.filter.surface))\n\n\ntim1_center_crv = rhutil.coercecurve(rs.GetObject(\"select first center_crv\", rs.filter.curve))\ntim2_center_crv = rhutil.coercecurve(rs.GetObject(\"select second center_crv\", rs.filter.curve))\n\n\n# cantileverのRun timeを計測する\nstart_time = time.time()\n\n\ndomain_crv1 = tim1_center_crv.Domain\ndomain_crv2 = tim2_center_crv.Domain\n\neach_domain_length1 = (domain_crv1[1] - domain_crv1[0]) / divide_domain_num\neach_domain_length2 = (domain_crv2[1] - domain_crv2[0]) / divide_domain_num\n\nselect_domain1 = 2\nselect_domain2 = rnd.randint(0, 9)\n\ntim1_point = tim1_center_crv.PointAt(select_domain1 * each_domain_length1)\ntim2_point = tim2_center_crv.PointAt(select_domain2 * each_domain_length2)\n\nvec_move = tim1_point - tim2_point\n\nxf = Rhino.Geometry.Transform.Translation(vec_move)\ntim2_center_crv.Transform(xf)\ntim2_srf.Transform(xf)\n\ntim1_start_point = tim1_center_crv.PointAt(domain_crv1[0])\ntim1_end_point = tim1_center_crv.PointAt(domain_crv1[1])\n\np1 = Rhino.Geometry.Point3d(0,0,0)\np2 = Rhino.Geometry.Point3d(0,0,10)\np3 = Rhino.Geometry.Point3d(10,0,0)\n\nplane1 = Rhino.Geometry.Plane(p1, p2, p3)\nrotate_angle = math.radians(rnd.randint(0,360))\nxf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane1[3], tim1_point)\ntim2_center_crv.Transform(xf)\ntim2_srf.Transform(xf)\nprint(\"rotate angle\", math.degrees(rotate_angle))\n\n\np1 = Rhino.Geometry.Point3d(0,0,0)\np2 = Rhino.Geometry.Point3d(0,10,0)\np3 = Rhino.Geometry.Point3d(10,0,0)\n\nplane2 = Rhino.Geometry.Plane(p1,p2,p3)\nrotate_angle = math.radians(rnd.randint(0,360))\nxf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane2[3], tim1_point)\ntim2_center_crv.Transform(xf)\ntim2_srf.Transform(xf)\n\nlength1, rc1 = GetTimberSectionLength_RhinoCommon(tim1_srf, tim1_point)\nlength2, rc2 = GetTimberSectionLength_RhinoCommon(tim2_srf, tim2_point)\n\nprint(\"rc1\", rc1)\nvec_move = rc1 - tim2_point\nif length1 > length2:\n    rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n    rc.Unitize()\n    vec_move = rc * ((length1 / 2) + (length2 / 3))\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n    tim2_srf.Transform(xf)\n    tim2_center_crv.Transform(xf)\nelse:\n    rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n    rc.Unitize()\n    vec_move = rc * ((length1 / 2)+(length2 / 3))\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n    tim2_srf.Transform(xf)\n    tim2_center_crv.Transform(xf)\n\n\nscriptcontext.doc.Objects.AddBrep(tim2_srf)\nscriptcontext.doc.Objects.AddCurve(tim2_center_crv)\nscriptcontext.doc.Views.Redraw()\n\nend_time = time.time()\nprint(\"Processing Time : %s\"%(end_time - start_time))\n\n#\n#\n# # print(\"tim1 name\", self.used_list[tim_preexist_num].name)\n# # print(\"tim2 name\", self.used_list[tim_add_num].name)\n#\n# for loop in range(100):\n#\n#     # 使用するtimberを選ぶ(初期生成)\n#     if len(self.used_list) == 0:\n#         # 使用していないtimberから任意に2本選ぶ(x, yはリストのインデックス)\n#         x = 0\n#         y = 1\n#         used_timber = self.timber_list[x]\n#         unused_timber = self.timber_list[y]\n#\n#         # console\n#         # print(\"#######################################################\")\n#         # print(\"unused: %s | %s cantilever\" % (used_timber.name, unused_timber.name))\n#\n#     # 使用するtimberを選ぶ(複数生成)\n#     else:\n#         if init_generate:\n#             # 使用済みのtimberから任意に1本選ぶ --> used_list\n#             x = rnd.randint(0, len(self.init_used_list) - 1)\n#             used_timber = self.init_used_list[x]\n#\n#             # 使用していないtimberから任意に1本選ぶ --> timber_list\n#             y = rnd.randint(0, len(self.timber_list) - 1)\n#             unused_timber = self.timber_list[y]\n#\n#             # console\n#             # print(\"#######################################################\")\n#             # print(\"used: %s | unused: %s cantilever\" % (used_timber.name, unused_timber.name))\n#\n#         else:\n#\n#             used_timber = self.used_list[tim_preexist_num]\n#\n#             unused_timber = self.used_list[tim_add_num]\n#\n#             # console\n#             # print(\"#######################################################\")\n#             # print(\"used: %s | unused: %s cantilever\" % (used_timber.name, unused_timber.name))\n#\n#     # print(\"loop %s\" % loop)\n#\n#     # 再生成に使用する材のselect_domain_listを初期化する\n#     # print(\"START used_tim domain_list in cantilever\", used_timber.select_domain_list)\n#     unused_timber.select_domain_list = []\n#     # print(\"START unused_timber domain_list in cantilever\", unused_timber.select_domain_list)\n#\n#     # サーフェスのドメインを選択する\n#     select_domain1 = used_timber.selectSurfaceDomain_1()\n#     select_domain2 = unused_timber.selectSurfaceDomain_1()\n#\n#     # サーフェスから選択したドメイン内のある一点のuパラメータを取得する\n#     select1_u = used_timber.getSurfaceUparameter(select_domain1)\n#     select2_u = unused_timber.getSurfaceUparameter(select_domain2)\n#\n#     # サーフェス上の任意の点を取得する\n#     p1 = used_timber.getRandomSurfacePoint(select1_u)\n#     p2 = unused_timber.getRandomSurfacePoint(select2_u)\n#\n#     # 仮想断面(任意の点(p1, p2)が乗っている)を構成する点情報を取得する TODO splitで断面取得 --> 修正済み\n#     point_list1 = used_timber.getPointsfromSectionCurve(3, used_timber.select_u)\n#     point_list2 = unused_timber.getPointsfromSectionCurve(3, unused_timber.select_u)\n#\n#     # closest pointを生成する\n#     used_timber.createVectorClosestPointToCurve(p1)\n#     unused_timber.createVectorClosestPointToCurve(p2)\n#\n#     # 任意の仮想断面からの垂直ベクトルを生成し、仮想断面と中心線の交点を戻り値として返す\n#     base_point1 = used_timber.createCrossVectorOnSectionCurve(point_list1)\n#     base_point2 = unused_timber.createCrossVectorOnSectionCurve(\n#         point_list2)  # Message: Could not convert None to a Vector3d\n#\n#     # timberを移動させる(base_point1 to base_point2)\n#     unused_timber.moveTimber(base_point1, base_point2)\n#\n#     # timberをオフセットする\n#     unused_timber.offsetTimber(used_timber.cross_vector, base_point1, p1, used_timber.section_curve)\n#\n#     # timberを任意の角度回転させる\n#     unused_timber.rotateTimber(base_point1, rnd.randint(60, 120))\n#\n#\n#     # unused_timber.temp_partner_tim.append(used_timber.name)  # 一旦このリストに接合関係を保存。\n#     # used_timber.temp_partner_tim.append(unused_timber.name)\n#\n#     break\n#\n#     # 接点に近似させるために最適化を行い、交線を戻り値として返す\n#\n# #     curve_drill = opt.optimization(used_timber.closest_point, used_timber.point, used_timber.surface,\n# #                                    unused_timber.surface, unused_timber.center_line,\n# #                                    unused_timber.section_curve,\n# #                                    unused_timber.two_mark_line, opt_tolerance)\n# #\n# #     re_loop_flag = False\n# #\n# #     # print(\"-------------------------------------------------------\")\n# #     for j in range(10):\n# #         # もしこの時点でいずれかのtimberに接触している時の処理\n# #         collision = detection.collisionDetectionTolerance(self.used_list, self.not_use_list, unused_timber, x,\n# #                                                           dete_tolerance)\n# #\n# #         if collision:\n# #             # print(\"There is Collision\")\n# #\n# #             # 衝突してしまった場合の処理を書く TODO アルゴリズム作成 --> 少しずつ動かすなどの方法検討\n# #             #########################################################################################\n# #             unused_timber.rotateTimber(base_point1, j + 2)\n# #             #\n# #             #\n# #             #########################################################################################\n# #\n# #             if j == 9:\n# #                 re_loop_flag = True\n# #                 rs.DeleteObject(used_timber.section_curve)\n# #                 rs.DeleteObject(unused_timber.section_curve)\n# #                 for k in range(len(curve_drill)):\n# #                     rs.DeleteObject(curve_drill[k])\n# #\n# #                 break\n# #\n# #\n# #         else:\n# #             # print(\"There is not collision\")\n# #             break\n# #\n# #     if re_loop_flag is True:\n# #         continue\n# #     else:\n# #         break\n# #\n# # # # 接点に近似させるために最適化を行い、交線を戻り値として返す\n# # #\n# # # curve_drill = opt.optimization(used_timber.closest_point, used_timber.point, used_timber.surface,\n# # #                                unused_timber.surface, unused_timber.center_line, unused_timber.section_curve,\n# # #                                unused_timber.two_mark_line, tolerance)\n# #\n# # # ドリル穴をあけるための線データを生成する\n# # drill_line_info = drill.drilling(curve_drill, unused_timber.surface,\n# #                                  used_timber.center_line, unused_timber.center_line,\n# #                                  used_timber.closest_point)\n# #\n# # # ドリルラインをTimberのメンバー変数のリストに格納する\n# # copy_drill_line = rs.CopyObject(drill_line_info[0], None)\n# # used_timber.drill_line_list.append(drill_line_info[0])\n# # unused_timber.drill_line_list.append(copy_drill_line)\n#\n# # objectを削除する\n# for i in range(len(used_timber.section_curve)):\n#     rs.DeleteObject(used_timber.section_curve[i])\n#\n# for i in range(len(unused_timber.section_curve)):\n#     rs.DeleteObject(unused_timber.section_curve[i])\n#\n# # # 指定したドメインをTimberのメンバー変数リストに格納する\n# used_timber.select_domain_list.append([select_domain1, unused_timber.name])  # ttm change 190128\n# unused_timber.select_domain_list.append([select_domain2, used_timber.name])\n#\n# # print(\"END used_tim domain_list in cantilever\", used_timber.select_domain_list)\n# # print(\"END unused_timber domain_list in cantilever\", unused_timber.select_domain_list)\n#\n# # 追加した材と既に生成されている材との距離を取得してくる。\n# for i in range(len(self.used_list)):  # ttm add 190113\n#     already_exist_timber_name = self.used_list[i].name\n#     already_exist_timber = self.used_list[i]\n#     if already_exist_timber_name in already_regenerated_list:\n#         timber.distanceBetweenTimber(already_exist_timber, unused_timber)\n#\n# end_time = time.time()\n#\n# cantilever_run_time = end_time - start_time\n# print(\"-------------------------------------------------------\")\n# print(\"cantilever Run time: %s\" % cantilever_run_time)\n#\n# return True\n# # used_timber.partner_tim.append(unused_timber.name)  # add the partner timber name ---> name is number\n# # unused_timber.partner_tim.append(used_timber.name)\n#\n# # 接合数を更新する\n# # 初期生成\n# # if len(self.used_list) == 0:\n# #\n# #     used_timber.countjoint(num_count)\n# #     unused_timber.countjoint(num_count)\n# #\n# #     # どの部材と接合したかをリストに格納する\n# #     used_timber.joint_name_list.append(unused_timber.name)\n# #     unused_timber.joint_name_list.append(used_timber.name)\n# #\n# #     # 一度使ったtimberはused_listに格納する\n# #     if used_timber.num_joint > 0:\n# #         # 使用済みのtimberをused_listに格納する\n# #         self.used_list.append(used_timber)\n# #\n# #     if unused_timber.num_joint > 0:\n# #         # 使用済みのtimberをused_listに格納する\n# #         self.used_list.append(unused_timber)\n# #\n# #     # 使用したtimberはtimber_listクラスから除外する\n# #     if used_timber.num_joint > 0:\n# #         self.timber_list.pop(x)\n# #\n# #     if unused_timber.num_joint > 0:\n# #         self.timber_list.pop(y - 1)\n# #\n# #     # 片持ち生成に成功した場合\n# #     self.count_cantilever = self.count_cantilever + 1\n# #\n# #     # cantileverのRun timeを計測する\n# #     end_time = time.time()\n# #\n# #     cantilever_run_time = end_time - start_time\n# #     # print(\"-------------------------------------------------------\")\n# #     # print(\"cantilever Run time: %s\" % cantilever_run_time)\n# #\n# # # 複数生成\n# # else:\n# #     count1 = used_timber.countjoint(num_count)  # used_timberの現状の接合数\n# #\n# #     unused_timber.countjoint(num_count)\n# #     count2 = unused_timber.num_joint  # unused_timberの現状の接合数\n# #\n# #     # どの部材と接合したかをリストに格納する\n# #     used_timber.joint_name_list.append(unused_timber.name)\n# #     unused_timber.joint_name_list.append(used_timber.name)\n# #\n# #     # 部材が指定の接合数を満たした場合\n# #     if count1:\n# #         # もう使用しないnot_use_listに格納する\n# #         self.not_use_list.append(used_timber)\n# #\n# #         # 使用したtimberはused_listから除外する\n# #         self.used_list.pop(x)\n# #\n# #     # 一度使ったtimberはused_listに格納する\n# #     if count2 > 0:\n# #         # 使用済みのtimberをused_listに格納する\n# #         self.used_list.append(unused_timber)\n# #\n# #         # 使用したtimberはtimber_listクラスから除外する\n# #         self.timber_list.pop(y)\n# #\n# #     # init generate\n# #     if init_generate:\n# #         self.used_list.append(used_timber)\n# #         self.init_used_list.pop(x)\n# #\n# #     # 片持ち生成に成功した場合\n# #     self.count_cantilever = self.count_cantilever + 1\n# #\n#     # cantileverのRun timeを計測する\n#     # end_time = time.time()\n#     #\n#     # cantilever_run_time = end_time - start_time\n#     # print(\"-------------------------------------------------------\")\n#     # print(\"cantilever Run time: %s\" % cantilever_run_time)\n# #",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}