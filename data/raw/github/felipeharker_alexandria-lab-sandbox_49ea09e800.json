{
  "source_url": "https://github.com/felipeharker/alexandria-lab-sandbox/blob/93b52f07c5eda09beeec9be89fec8da8ad2c771e/alexandria-application-files/scripts/cell%20patternizer.py",
  "repo": "felipeharker/alexandria-lab-sandbox",
  "repo_stars": 0,
  "repo_description": "place to mess with alexandria lab repo without breaking the primary repo",
  "license": "unknown",
  "filepath": "alexandria-application-files/scripts/cell patternizer.py",
  "instruction": "Cell patternizer",
  "code": "__author__ = \"FHarker\"\n__version__ = \"2025.10.01\"\n\n\"\"\"Cell Patternizer (MVP)\nInputs:\n    Cells: list[Polyline]  # closed, from grid generator\n    Mode: str              # 'concentric', 'star', 'spokes'\n    Inset: float           # 0..1, amount toward centroid\n    Steps: int             # rings for concentric, spike factor for star (>=1)\n    Rotate: float          # degrees, per-cell rotation about centroid\nOutputs:\n    Curves: list[Rhino.Geometry.Curve]\n    Cutouts: list[Rhino.Geometry.Curve]\n    Centers: list[Rhino.Geometry.Point3d]\n    Report: str\n\"\"\"\nimport Rhino\nfrom Rhino.Geometry import *\nimport math\n\ndef centroid_of_curve(crv):\n    # For closed planar curves, use area mass properties\n    if crv and crv.IsClosed:\n        amp = Rhino.Geometry.AreaMassProperties.Compute(crv)\n        if amp:\n            return amp.Centroid\n    # Fallback: bounding-box center\n    bb = crv.GetBoundingBox(True)\n    return bb.Center\n\n\ndef to_polycurve(pl):\n    if isinstance(pl, Polyline):\n        return pl.ToPolylineCurve()\n    if isinstance(pl, PolylineCurve):\n        return pl\n    return None\n\ndef centroid_of_polyline(pl):\n    pts = list(pl)\n    if pts[0].DistanceTo(pts[-1]) < 1e-9: pts = pts[:-1]\n    A = 0.0; cx = 0.0; cy = 0.0; z = pts[0].Z\n    n = len(pts)\n    for i in range(n):\n        x0, y0 = pts[i].X, pts[i].Y\n        x1, y1 = pts[(i+1)%n].X, pts[(i+1)%n].Y\n        cross = x0*y1 - x1*y0\n        A += cross\n        cx += (x0 + x1)*cross\n        cy += (y0 + y1)*cross\n    if abs(A) < 1e-12:\n        sx = sum(p.X for p in pts)/n\n        sy = sum(p.Y for p in pts)/n\n        return Point3d(sx, sy, z)\n    A *= 0.5\n    return Point3d(cx/(6.0*A), cy/(6.0*A), z)\n\ndef best_plane(crv):\n    pln = Plane.Unset\n    ok, pln = crv.TryGetPlane()\n    if not ok:\n        # fall back to world XY\n        pln = Plane.WorldXY\n    return pln\n\ndef rotate_about(pt, angle_deg):\n    return Transform.Rotation(math.radians(angle_deg), pt)\n\ndef offset_in_plane(crv, pln, dist):\n    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    offs = crv.Offset(pln, dist, tol, CurveOffsetCornerStyle.Sharp)\n    return offs or []\n\ndef polygon_vertices(pl):\n    pts = list(pl)\n    if pts[0].DistanceTo(pts[-1]) < 1e-9: pts = pts[:-1]\n    return pts\n\ndef star_polygon(pl, t=0.25, spike=1, rot_deg=0.0):\n    \"\"\"General star: alternate vertices with points pulled toward centroid by t.\n       spike: integer multiplier to permute vertex order (for more spikes).\"\"\"\n    verts = polygon_vertices(pl)\n    n = len(verts)\n    if n < 3: return None\n    c = centroid_of_polyline(pl)\n    order = range(n)\n    # spike factor: permute indices (mod n)\n    order = [(i*spike) % n for i in range(n)]\n    # build 2n point star\n    pts = []\n    for idx in order:\n        v = verts[idx]\n        pts.append(v)\n        toward = Point3d(c.X + (v.X - c.X)*(1.0 - t), c.Y + (v.Y - c.Y)*(1.0 - t), v.Z)\n        pts.append(toward)\n    pts.append(pts[0])\n    plc = Polyline(pts).ToPolylineCurve()\n    if rot_deg:\n        plc.Transform(rotate_about(c, rot_deg))\n    return plc\n\ndef spoke_lines(pl, rot_deg=0.0):\n    verts = polygon_vertices(pl)\n    c = centroid_of_polyline(pl)\n    ln = []\n    for v in verts:\n        a, b = c, v\n        line = Line(a, b).ToNurbsCurve()\n        if rot_deg:\n            line.Transform(rotate_about(c, rot_deg))\n        ln.append(line)\n    # also mid-edge spokes for “plus-like” effect\n    for i in range(len(verts)):\n        a = verts[i]; b = verts[(i+1)%len(verts)]\n        mid = Point3d((a.X+b.X)/2.0, (a.Y+b.Y)/2.0, a.Z)\n        line = Line(c, mid).ToNurbsCurve()\n        if rot_deg:\n            line.Transform(rotate_about(c, rot_deg))\n        ln.append(line)\n    return ln\n\ndef concentric_insets(pl, k=0.15, steps=3, rot_deg=0.0):\n    \"\"\"Create inward offsets (concentric rings) of a polygonal cell.\n       k: fraction of average edge length used as offset distance per ring.\n    \"\"\"\n    plc = to_polycurve(pl)\n    if plc is None:\n        return []\n\n    pln = best_plane(plc)\n\n    # average edge length for a scale-aware offset distance\n    verts = polygon_vertices(pl)\n    avg = 0.0\n    for i in range(len(verts)):\n        avg += verts[i].DistanceTo(verts[(i+1) % len(verts)])\n    avg /= max(1, len(verts))\n\n    d = -k * avg  # inward offset\n\n    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    rings = []\n    crvs = [plc]\n    for _ in range(steps):\n        next_crvs = []\n        for c in crvs:\n            offs = c.Offset(pln, d, tol, Rhino.Geometry.CurveOffsetCornerStyle.Sharp)\n            if not offs:\n                continue\n            for oc in offs:\n                if rot_deg:\n                    ctr = centroid_of_curve(oc)\n                    oc.Transform(Transform.Rotation(math.radians(rot_deg), ctr))\n                next_crvs.append(oc)\n                rings.append(oc)\n        crvs = next_crvs\n        if not crvs:\n            break\n\n    return rings\n\n# defaults\nif not Mode: Mode = \"concentric\"\nif Inset is None: Inset = 0.2\nif Steps is None or Steps < 1: Steps = 3\nif Rotate is None: Rotate = 0.0\n\nCurves, Cutouts, Centers = [], [], []\ncount = 0\n\nfor pl in Cells or []:\n    if not isinstance(pl, Polyline): \n        # try convert from curve with points\n        continue\n    c = centroid_of_polyline(pl)\n    Centers.append(c)\n    if Mode == \"concentric\":\n        rings = concentric_insets(pl, k=max(0.01, min(0.9, Inset)), steps=Steps, rot_deg=Rotate)\n        Curves.extend(rings)\n        # the innermost ring is typically a good cutout\n        if rings: Cutouts.append(rings[-1])\n        count += 1\n    elif Mode == \"star\":\n        spike = max(1, int(Steps))\n        sc = star_polygon(pl, t=max(0.01, min(0.9, Inset)), spike=spike, rot_deg=Rotate)\n        if sc: \n            Curves.append(sc)\n            Cutouts.append(sc)  # closed curve suitable for perforation\n            count += 1\n    elif Mode == \"spokes\":\n        ln = spoke_lines(pl, rot_deg=Rotate)\n        Curves.extend(ln)\n        count += 1\n    else:\n        # passthrough\n        pc = to_polycurve(pl)\n        if pc: Curves.append(pc)\n\nReport = \"Cells: {} | Mode: {} | Inset: {} | Steps: {} | Rot: {}°\".format(\n    len(Cells or []), Mode, round(Inset,3), Steps, round(Rotate,2)\n)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}