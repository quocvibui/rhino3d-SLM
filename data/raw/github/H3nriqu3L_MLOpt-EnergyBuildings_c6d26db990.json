{
  "source_url": "https://github.com/H3nriqu3L/MLOpt-EnergyBuildings/blob/4526c6cdaeee607506543c9455b90802ecae4f22/Scripts/de.py",
  "repo": "H3nriqu3L/MLOpt-EnergyBuildings",
  "repo_stars": 0,
  "repo_description": "MLOpt EnergyBuildings\" is a repository dedicated to leveraging Machine Learning (ML) techniques for optimizing energy efficiency in buildings. Explore cutting-edge methods, tools, and resources for enhancing the sustainability and performance of architectural designs and energy systems within the built environment",
  "license": "unknown",
  "filepath": "Scripts/de.py",
  "instruction": "import rhinoscriptsyntax as rs",
  "code": "#import rhinoscriptsyntax as rs\nimport random\nimport copy\n\nPOPULATION_SIZE = 100    \nDIMENSION = 4           \nNUMBER_IT = 10000       \nSCALING_FACTOR = 0.5\nCROSSOVER_PROB = 0.7\nfirst = True\npopulation = []\nclass Vector:\n    def __init__(self, orientation, window_w, window_e, transmitance, fxv=None):\n        self.orientation = orientation\n        self.window_w = window_w\n        self.window_e = window_e\n        self.transmitance = transmitance\n        self.fxv = fxv\n\n    def __str__(self):\n        return f\"Orientation: {self.orientation}, Window W: {self.window_w}, Window E: {self.window_e}, Transmitance: {self.transmitance}, fx: {self.fxv}\"\n    \n\ndef sub_vectors(vector1, vector2):\n    orientation_diff = vector1.orientation - vector2.orientation\n    window_w_diff = vector1.window_w - vector2.window_w\n    window_e_diff = vector1.window_e - vector2.window_e\n    transmitance_diff = vector1.transmitance - vector2.transmitance\n    \n    difference_vector = Vector(orientation_diff, window_w_diff, window_e_diff, transmitance_diff)\n    \n    return difference_vector\n\ndef sum_vectors(vector1, vector2):\n    orientation_result = vector1.orientation + vector2.orientation\n    window_w_result = vector1.window_w + vector2.window_w\n    window_e_result = vector1.window_e + vector2.window_e\n    transmitance_result = vector1.transmitance + vector2.transmitance\n    \n    result_vector = Vector(orientation_result, window_w_result, window_e_result, transmitance_result)\n    \n    return result_vector\n\ndef clip_value(value, min_value, max_value):\n    # Verifica se o valor está abaixo do mínimo e ajusta para o mínimo\n    if value < min_value:\n        return min_value\n    # Verifica se o valor está acima do máximo e ajusta para o máximo\n    if value > max_value:\n        return max_value\n    # Caso contrário, retorna o valor original\n    return value\n\ndef is_vector_in_range(vector):\n    orientation_min, orientation_max = -180.0, 180.0\n    window_w_min, window_w_max = 0.1, 5.9\n    window_e_min, window_e_max = 0.1, 5.9\n    transmitance_min, transmitance_max = 0.2, 0.8\n\n    # Ajusta os valores das variáveis do Vector para que estejam dentro dos limites permitidos\n    orientation = clip_value(vector.orientation, orientation_min, orientation_max)\n    window_w = clip_value(vector.window_w, window_w_min, window_w_max)\n    window_e = clip_value(vector.window_e, window_e_min, window_e_max)\n    transmitance = clip_value(vector.transmitance, transmitance_min, transmitance_max)\n\n    return Vector(orientation, window_w, window_e, transmitance, fxv=vector.fxv)\n\ndef mult_vector_by_constant(vector, constant):\n    orientation_result = vector.orientation * constant\n    window_w_result = vector.window_w * constant\n    window_e_result = vector.window_e * constant\n    transmitance_result = vector.transmitance * constant\n    \n    result_vector = Vector(orientation_result, window_w_result, window_e_result, transmitance_result)\n    \n    return result_vector\n\ndef inicializePopulation():\n    for i in range(POPULATION_SIZE):\n        orientation = random.uniform(-180.0, 180.0)\n        window_w = random.uniform(0.1, 5.9)\n        window_e = random.uniform(0.1, 5.9)\n        transmitance = random.uniform(0.2, 0.8)\n        vetor = Vector(orientation, window_w, window_e, transmitance)\n        #Calcular fxv com o simulador\n        vetor.fxv = calcFx(vetor)\n        population.append(vetor)\n\n    print(\"Inicio\")\n    for i in population:\n        print(i)\n\n\ndef mutation():\n    population_copia = copy.deepcopy(population)\n\n    target_vector = random.choice(population_copia)\n    population_copia.remove(target_vector)\n\n    sol_1 = random.choice(population_copia)\n    population_copia.remove(sol_1)\n\n    sol_2 = random.choice(population_copia)\n    population_copia.remove(sol_2)\n\n    #Subtrai os vetores\n    sub_sol = sub_vectors(sol_1, sol_2)\n    #multiplica o sub_sol por Scaling_Factor\n    sub_sol = mult_vector_by_constant(sub_sol, SCALING_FACTOR)\n\n\n    trial_vector = sum_vectors(target_vector, sub_sol)\n    trial_vector = is_vector_in_range(trial_vector)\n\n    parent_vector = random.choice(population_copia)\n    parent_index = population_copia.index(parent_vector)\n\n    return trial_vector, parent_index\n\ndef crossover(trial_vector, parent_vector):\n    i_set = []\n    i_set.append(random.randint(0,DIMENSION-1))\n\n    for j in range(DIMENSION):\n        if((j!=i_set[0]) and (random.uniform(0,1)<CROSSOVER_PROB)):\n            i_set.append(j)\n\n    trial_list = [trial_vector.orientation, trial_vector.window_w, trial_vector.window_e, trial_vector.transmitance, trial_vector.fxv]\n    parent_list = [parent_vector.orientation, parent_vector.window_w, parent_vector.window_e,parent_vector.transmitance, parent_vector.fxv]\n    offspring = [0,0,0,0,None]\n    for i in range(DIMENSION):\n        if i in i_set:\n            offspring[i] = trial_list[i]\n        else:\n            offspring[i] = parent_list[i]\n\n    x1 = Vector(offspring[0], offspring[1],offspring[2],offspring[3],None)\n    return x1\n\ndef calcFx(vector):\n    return vector.orientation + vector.window_w + vector.window_e + vector.transmitance\n        \n\ninicializePopulation()\n\nfor i in range(NUMBER_IT):\n    result = mutation()\n    trial_v, parent_index = result\n    parent_v = population[parent_index]\n    x1 = crossover(trial_v, parent_v)\n    # Calcular fx1 pelo simulador Grasshopper\n    x1.fxv = calcFx(x1)\n\n    if(x1.fxv<parent_v.fxv):\n        population.remove(parent_v)\n        population.append(x1)\n\nprint(\"Fim\")\nfor i in population:\n    print(i)\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}