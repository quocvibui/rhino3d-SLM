{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/visualize_movement.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/visualize_movement.py",
  "instruction": "Visualize movement",
  "code": "import json\nimport os\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc  # type: ignore\nfrom compas.utilities import DataDecoder\nfrom compas_rhino.geometry import RhinoMesh\nfrom compas_rhino.ui import CommandMenu\nfrom compas_rhino.utilities.objects import get_object_name\n\nfrom integral_timber_joints.assembly import Assembly\nfrom integral_timber_joints.geometry.env_model import EnvironmentModel\nfrom integral_timber_joints.process import Movement, RobotClampAssemblyProcess, RoboticMovement, OperatorAttachToolMovement, RoboticFreeMovement\nfrom integral_timber_joints.rhino.process_artist import ProcessArtist\nfrom integral_timber_joints.rhino.load import get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.rhino.utility import get_existing_beams_filter, purge_objects, recompute_dependent_solutions\nfrom integral_timber_joints.tools import Clamp, Gripper, RobotWrist, ToolChanger\nfrom integral_timber_joints.rhino.process_artist import AddAnnotationText\n\ntry:\n    from typing import Dict, List, Optional, Tuple, cast\nexcept:\n    pass\n\n\n############\n# Drawing\n############\n\ndef redraw_state(process):\n    artist = get_process_artist()\n    # artist.delete_state(redraw=False)\n    artist.draw_state(redraw=False)  # Visualize the state\n    draw_tool_id_tag(artist, redraw=False)  # Visualize tool id tag\n    print_current_state_info(process)\n    rs.EnableRedraw(True)\n    sc.doc.Views.Redraw()\n\n\ndef print_current_state_info(process, print_prev=True, print_state=True, print_next=True):\n    # type: (RobotClampAssemblyProcess, bool, bool, bool) -> None\n    \"\"\"Note when state_id = 1, it is referring to end of the first (0) movement.\"\"\"\n    artist = get_process_artist()\n    all_movements = process.movements\n    state_id = artist.selected_state_id\n    # Retrive prev and next movement for information print out\n    prev_movement = all_movements[state_id - 1] if state_id > 0 else None  # type: Movement\n    next_movement = all_movements[state_id] if state_id < len(all_movements) else None  # type: Movement\n\n    print(\"-----------------------------------------------\")\n\n    # * Printing Previous Movement Info\n    if prev_movement is not None and print_prev:\n        action = process.get_action_of_movement(prev_movement)\n        print(\"- Prev Movement: %s (%s) (A:%s M:%s)\" % (prev_movement.tag, prev_movement.movement_id, action.__class__.__name__, prev_movement.__class__.__name__))\n        if isinstance(prev_movement, RoboticMovement):\n            print(\"  - Prev Movement allowed_collision_matrix: %s\" % prev_movement.allowed_collision_matrix)\n        if prev_movement.operator_stop_after is not None:\n            print(\"  - Operator Confirm: %s\" % prev_movement.operator_stop_after)\n\n    # * Printing Current State Info\n    if print_state:\n        if state_id == 0:\n            config_string = \"(Robot Initial State)\"\n        elif process.movement_has_end_robot_config(prev_movement):\n            config_string = \" (Robot Config is Fixed!)\"\n        else:\n            config_string = \"\"\n        print(\"- Current Scene: #%i [0 to %i]. %s\" % (state_id, len(all_movements), config_string))\n\n    # * Printing Next Movement Info\n    if next_movement is not None and print_next:\n        action = process.get_action_of_movement(next_movement)\n        print(\"- Next Movement: %s (%s) (A:%s M:%s)\" % (next_movement.tag, next_movement.movement_id, action.__class__.__name__, next_movement.__class__.__name__))\n        if isinstance(next_movement, RoboticMovement):\n            print(\"  - Next Movement allowed_collision_matrix: %s\" % next_movement.allowed_collision_matrix)\n        if next_movement.operator_stop_before is not None:\n            print(\"  - Operator Confirm: %s\" % next_movement.operator_stop_before)\n\n    print(\"-----------------------------------------------\")\n\n\ndef ui_show_env_meshes(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    artist = get_process_artist()\n    artist.show_all_env_mesh()\n\n\ndef ui_hide_env_meshes(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    artist = get_process_artist()\n    artist.hide_all_env_mesh()\n\n\n############\n# Navigation\n############\n\n\ndef ui_next_step(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n\n    if artist.selected_state_id < len(all_movements):\n        artist.selected_state_id += 1\n\n\ndef ui_prev_step(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n\n    if artist.selected_state_id > 0:\n        artist.selected_state_id -= 1\n\n\ndef ui_next_robotic_movement(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n    while artist.selected_state_id < len(all_movements):\n        artist.selected_state_id += 1\n        movement = all_movements[artist.selected_state_id - 1]\n        if isinstance(movement, RoboticMovement):\n            return\n\n\ndef ui_prev_robotic_movement(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n    while artist.selected_state_id > 0:\n        artist.selected_state_id -= 1\n        movement = all_movements[artist.selected_state_id - 1]\n        if isinstance(movement, RoboticMovement):\n            return\n\n\ndef ui_next_robotic_free_movement(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n    while artist.selected_state_id < len(all_movements):\n        artist.selected_state_id += 1\n        movement = all_movements[artist.selected_state_id - 1]\n        if isinstance(movement, RoboticFreeMovement):\n            return\n\n\ndef ui_prev_robotic_free_movement(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n    while artist.selected_state_id > 0:\n        artist.selected_state_id -= 1\n        movement = all_movements[artist.selected_state_id - 1]\n        if isinstance(movement, RoboticFreeMovement):\n            return\n\n\ndef ui_next_operator_attach_tool(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n    while artist.selected_state_id < len(all_movements):\n        artist.selected_state_id += 1\n        movement = all_movements[artist.selected_state_id - 1]\n        if isinstance(movement, OperatorAttachToolMovement):\n            return\n\n\ndef ui_goto_state_by_beam_seq(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n\n    # Ask use to chosse which beam (seq_id) to view\n    beam_input = rs.GetString(\"Which Beam to view, by assembly sequence: sequence_id = [0 to %i], or by beam_id\" % (\n        len(assembly.sequence) - 1), 0)\n\n\n    if beam_input is None:\n        return\n    elif beam_input in assembly.sequence:\n        beam_id = beam_input\n    elif beam_input.isdigit():\n        seq_n = int(beam_input)\n        if seq_n > len(assembly.sequence) - 1:\n            print(\"error: sequence_id must be between [0 to %i]\" % (len(assembly.sequence) - 1))\n            return\n        beam_id = assembly.sequence[seq_n]\n\n    # get the first movement before a selected beam\n    selected_movement = process.get_movements_by_beam_id(beam_id)[0]\n    if selected_movement is None:\n        return\n\n    # Select the start state of the first movement.\n    mov_id = all_movements.index(selected_movement)\n    artist.selected_state_id = mov_id\n\n\ndef ui_goto_state_by_state_index(process, selected_state_id=None):\n    # type: (RobotClampAssemblyProcess, Optional[int]) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n    all_movements = process.movements\n\n    # Ask use to chosse which beam (seq_id) to view\n    if selected_state_id is None:\n        selected_state_id = rs.GetInteger(\"Which State to view, state_id = [0 to %i]\" % (\n            len(all_movements)), artist.selected_state_id, 0, len(all_movements))\n        if selected_state_id is None:\n            return\n\n    # Check if entry is within bound\n    if selected_state_id > len(all_movements):\n        print(\"error: sequence_id must be between [0 to %i]\" % (len(all_movements)))\n        return\n\n    # Select the start state of the first movement.\n    artist.selected_state_id = selected_state_id\n\n############\n# Get IK\n############\n\n\ndef ui_get_ik(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    \"\"\"Retriving an IK solution for the current state.\n    The actual call would be to get the IK solution of the ending state of the previous movement.\n    \"\"\"\n    # * Check against computing for initial state.\n    artist = get_process_artist()\n    state_id = artist.selected_state_id\n    movement_id = state_id - 1\n\n    if state_id == 0:\n        print(\"Sorry - Cannot get IK solution for the initial state.\")\n        return\n\n    # * Check against computing for non Robotic Movements\n    all_movements = process.movements\n    prev_movement = all_movements[movement_id]\n    if not isinstance(prev_movement, RoboticMovement):\n        print(\"Sorry - Cannot get IK solution for State after non Robotic Movement.\")\n        return\n\n    # * Get Ik call to Yijiang's rhino_interface\n    print(\"-----------------------------------------------\")\n    print(\"Computing IK :\")\n\n    from compas.rpc import Proxy\n    rhino_interface = Proxy('integral_timber_joints.planning.rhino_interface', autoreload=False)\n    try:\n        success, configuration, msg = rhino_interface.get_ik_solutions(process, movement_id)\n    except Exception as err_msg:\n        success, configuration, msg = (False, None, err_msg)\n\n    if success:\n        print(\"IK Success: {} | {}\".format(msg, configuration))\n        # Delete rob_wrist visualization if present\n        purge_objects(artist.state_visualization_guids('rob_wrist'), redraw=False)\n        # Draw Robot with IK results\n        artist.draw_robot(configuration, True, True, True)\n        process.temp_ik[movement_id] = configuration\n    else:\n        print(\"IK Failed: {} \".format(msg))\n\n    print(\"-----------------------------------------------\")\n\n\ndef ui_save_ik(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    \"\"\"Retriving an IK solution for the current state.\n    The actual call would be to get the IK solution of the ending state of the previous movement.\n    \"\"\"\n    artist = get_process_artist()\n    state_id = artist.selected_state_id\n    movement_id = state_id - 1\n\n    # * Save IK\n    all_movements = process.movements\n    prev_movement = all_movements[movement_id]  # type: RoboticMovement\n    if movement_id in process.temp_ik and process.temp_ik[movement_id] is not None:\n        prev_movement.target_configuration = process.temp_ik[movement_id]\n        print(\"IK Saved at end of %s : %s\" % (prev_movement.__class__.__name__, prev_movement.tag))\n        del process.temp_ik[movement_id]\n\n\ndef draw_tool_id_tag(self, scene=None, redraw=True):\n    # type: (ProcessArtist, any, bool) -> None\n    \"\"\"Draw tags of tool_id\n    This is a hot fix function that is not yet imcoperated into Process artist\n    \"\"\"\n    if scene is None:\n        # Limit range\n        if self.selected_state_id < 0:\n            self.selected_state_id = 0\n        if self.selected_state_id > len(self.process.movements):\n            self.selected_state_id = len(self.process.movements)\n        scene = self.get_current_selected_scene_state()\n\n    # Layer:\n    rs.EnableRedraw(False)\n    layer = 'itj::interactive::beams_seqtag'\n    rs.CurrentLayer(layer)\n\n    delete_tool_id_tag(self)\n\n    # * Draw meshes to Rhino and add guids to tracking dict\n    for object_id in self.process.tool_ids:\n        tool_base_frame = scene[(object_id, 'f')]\n        layer = 'itj::interactive::beams_seqtag'\n        guid = AddAnnotationText(tool_base_frame, object_id, 50, layer, redraw=False)\n        self.tool_id_tags.append(guid)\n\n    # Enable Redraw\n    if redraw:\n        rs.EnableRedraw(True)\n        sc.doc.Views.Redraw()\n\n\ndef delete_tool_id_tag(self, redraw=True):\n\n    if hasattr(self, 'tool_id_tags'):\n        purge_objects(self.tool_id_tags, redraw=False)\n    self.tool_id_tags = []\n\n    # Enable Redraw\n    if redraw:\n        rs.EnableRedraw(True)\n        sc.doc.Views.Redraw()\n\n\ndef show_menu(process):\n    # type: (RobotClampAssemblyProcess) -> None\n    assembly = process.assembly  # type: Assembly\n    artist = get_process_artist()\n\n    # Temporary storage of IK solution when using ui_get_ik and ui_save_ik\n    if not hasattr(process, 'temp_ik'):\n        process.temp_ik = {}\n\n    # Check if all computatations are up to date.\n    for beam_id in assembly.sequence:\n        if not process.dependency.beam_all_valid(beam_id):\n            process.dependency.compute_all(beam_id)\n            if not process.dependency.beam_all_valid(beam_id):\n                print(\"WARNING: Beam (%s) contains invalid computations that cannot be resolved. Visualization maybe incorrect.\" % beam_id)\n\n    # Initial draw of the state (using previous selected_state_id)\n    rs.EnableRedraw(False)\n    artist.delete_state(redraw=False)\n    artist.draw_state(redraw=False)  # Visualize the state\n    draw_tool_id_tag(artist, redraw=False)  # Visualize the state\n    print_current_state_info(process)\n\n    # Hide interactive beams and beams in positions\n    for seq, beam_id in enumerate(assembly.sequence):\n        artist.hide_interactive_beam(beam_id)\n        artist.hide_beam_all_positions(beam_id)\n        artist.hide_gripper_all_positions(beam_id)\n        artist.hide_asstool_all_positions(beam_id)\n\n    # Show Environment Meshes\n    artist.draw_all_env_mesh(True, redraw=False)\n    rs.EnableRedraw(True)\n\n    def show_interactive_beams_delete_state_vis():\n        artist.delete_state(redraw=False)\n        [artist.show_interactive_beam(beam_id) for beam_id in assembly.sequence]\n        rs.EnableRedraw(True)\n        sc.doc.Views.Redraw()\n\n    def construct_menu():\n        # Menu for user\n        artist = get_process_artist()\n        state_id = artist.selected_state_id\n        prev_movement_id = state_id - 1\n        menu = {\n            'message': \"Choose Options or Type in State Number directly:\",\n            'options': [\n                {'name': 'Finish', 'action': 'Exit'\n                 },\n                {'name': 'NextStep', 'action': ui_next_step\n                 },\n                {'name': 'PrevStep', 'action': ui_prev_step\n                 },\n                {'name': 'NextRoboticMovement', 'action': ui_next_robotic_movement\n                 },\n                {'name': 'PrevRoboticMovement', 'action': ui_prev_robotic_movement\n                 },\n                {'name': 'NextOperatorAttachTool', 'action': ui_next_operator_attach_tool\n                 },\n                {'name': 'GoToBeam', 'action': ui_goto_state_by_beam_seq\n                 },\n                {'name': 'GoToState', 'action': ui_goto_state_by_state_index\n                 },\n                {'name': 'ShowEnv', 'action': ui_show_env_meshes\n                 },\n                {'name': 'HideEnv', 'action': ui_hide_env_meshes\n                 },\n                {'name': 'GetIK', 'action': ui_get_ik\n                 },\n            ]\n        }\n        # Add the repeat options when command_to_run is available\n        if command_to_run is not None:\n            menu['options'].insert(0, {'name': 'Repeat', 'action': 'Repeat'})\n\n        if prev_movement_id in process.temp_ik and process.temp_ik[prev_movement_id] is not None:\n            menu['options'].append({'name': 'SaveIK', 'action': ui_save_ik})\n\n        return menu\n\n    command_to_run = None\n    while (True):\n\n        # Create Menu\n        result = CommandMenu(construct_menu()).select_action()\n\n        def on_exit_ui():\n            print('Exit Function')\n            artist.hide_all_env_mesh()\n            artist.hide_robot()\n            show_interactive_beams_delete_state_vis()\n            delete_tool_id_tag(artist)\n            return Rhino.Commands.Result.Cancel\n\n        # User cancel command by Escape\n        if result is None:\n            return on_exit_ui()\n\n        # Shortcut to allow user to type in state directly\n        if isinstance(result, str):\n            if result.isnumeric():\n                ui_goto_state_by_state_index(process, int(result))\n                redraw_state(process)\n                continue\n            elif result.startswith(\"A\"):\n                movement_ids = process.movement_ids\n                if result in movement_ids:\n                    ui_goto_state_by_state_index(process, movement_ids.index(result) + 1)\n                    redraw_state(process)\n                    continue\n            elif result.startswith(\"Cancel\"):\n                return on_exit_ui()\n            else:\n                continue  # Catch other unknown input that are not numbers.\n\n        # User click Exit Button\n        if result['action'] == 'Exit':\n            return on_exit_ui()\n\n        # Set command-to-run according to selection, else repeat previous command.\n        if result['action'] != 'Repeat':\n            command_to_run = result['action']\n\n        # Run the selected command\n        command_to_run(process)\n\n        # The commands should not handle redrawing the main state.\n        # Redraw State after running commands\n        redraw_state(process)\n\n        # ! Draw Robot Config for temp IK\n        state_id = artist.selected_state_id\n        movement_id = state_id - 1\n        # if ('robot', 'c') in scene and scene[('robot', 'c')] is not None:\n        if movement_id in process.temp_ik and process.temp_ik[movement_id] is not None:\n            print(\"Temp IK Exist\")\n            artist = get_process_artist()\n            artist.draw_robot(process.temp_ik[movement_id], True, False, True)\n\n######################\n# Rhino Entry Point\n######################\n# Below is the functions that get evoked when user press UI Button\n# Put this in the Rhino button ! _-RunPythonScript 'integral_timber_joints.rhino.sequence.py'\n\n\nif __name__ == '__main__':\n    process = get_process()\n    if process_is_none(process):\n        print(\"Load json first\")\n    else:\n        show_menu(process)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}