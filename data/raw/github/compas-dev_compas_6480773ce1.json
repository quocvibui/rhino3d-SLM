{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/curves/nurbs.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/curves/nurbs.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom itertools import groupby\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import NurbsCurve\nfrom compas.geometry import Point\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\n\nfrom .curve import RhinoCurve\n\n\ndef native_curve_from_parameters(points, weights, knots, multiplicities, degree):\n    native_curve = Rhino.Geometry.NurbsCurve(3, True, degree + 1, len(points))\n    for index, (point, weight) in enumerate(zip(points, weights)):\n        native_curve.Points.SetPoint(index, point_to_rhino(point), weight)\n    knotvector = [knot for knot, mult in zip(knots, multiplicities) for _ in range(mult)]\n    # account for superfluous knots\n    # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n    p = len(points)\n    o = degree + 1\n    k = p + o\n    if len(knotvector) == k:\n        knotvector[:] = knotvector[1:-1]\n    for index, knot in enumerate(knotvector):\n        native_curve.Knots[index] = knot\n    return native_curve\n\n\nclass RhinoNurbsCurve(RhinoCurve, NurbsCurve):\n    \"\"\"Class representing a NURBS curve based on the NurbsCurve of Rhino.Geometry.\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the curve.\n\n    Attributes\n    ----------\n    points : list[:class:`compas.geometry.Point`], read-only\n        The control points of the curve.\n    weights : list[float], read-only\n        The weights of the control points.\n    knots : list[float], read-only\n        The knot vector, without duplicates.\n    multiplicities : list[int], read-only\n        The multiplicities of the knots in the knot vector.\n    knotsequence : list[float], read-only\n        The knot vector, with repeating values according to the multiplicities.\n    continuity : int, read-only\n        The degree of continuity of the curve.\n    degree : int, read-only\n        The degree of the curve.\n    order : int, read-only\n        The order of the curve (degree + 1).\n    is_rational : bool, read-only\n        True is the curve is rational.\n\n    References\n    ----------\n    * https://developer.rhino3d.com/api/RhinoCommon/html/T_Rhino_Geometry_NurbsCurve.htm\n    * https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline\n    * https://developer.rhino3d.com/guides/opennurbs/nurbs-geometry-overview/\n\n    \"\"\"\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        # add superfluous knots\n        # for compatibility with all/most other NURBS implementations\n        # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n        multiplicities = self.multiplicities[:]  # type: ignore\n        multiplicities[0] += 1\n        multiplicities[-1] += 1\n        return {\n            \"points\": [point.__data__ for point in self.points],  # type: ignore\n            \"weights\": self.weights,\n            \"knots\": self.knots,\n            \"multiplicities\": multiplicities,\n            \"degree\": self.degree,\n            \"is_periodic\": self.is_periodic,\n        }\n\n    @classmethod\n    def __from_data__(cls, data):\n        points = [Point.__from_data__(point) for point in data[\"points\"]]\n        weights = data[\"weights\"]\n        knots = data[\"knots\"]\n        multiplicities = data[\"multiplicities\"]\n        degree = data[\"degree\"]\n        # is_periodic = data['is_periodic']\n        # have not found a way to actually set this\n        # not sure if that is actually possible...\n        native_curve = native_curve_from_parameters(points, weights, knots, multiplicities, degree)\n        return cls.from_native(native_curve)\n\n    # ==============================================================================\n    # Rhino Properties\n    # ==============================================================================\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def points(self):\n        if self.native_curve:\n            return [point_to_compas(point.Location) for point in self.native_curve.Points]\n\n    @property\n    def weights(self):\n        if self.native_curve:\n            return [point.Weight for point in self.native_curve.Points]\n\n    @property\n    def knots(self):\n        if self.native_curve:\n            return [key for key, _ in groupby(self.native_curve.Knots)]\n\n    @property\n    def knotsequence(self):\n        if self.native_curve:\n            return list(self.native_curve.Knots)\n\n    @property\n    def multiplicities(self):\n        if self.native_curve:\n            return [len(list(group)) for _, group in groupby(self.native_curve.Knots)]\n\n    @property\n    def degree(self):\n        if self.native_curve:\n            return self.native_curve.Degree\n\n    @property\n    def order(self):\n        if self.native_curve:\n            return self.native_curve.Order\n\n    @property\n    def is_rational(self):\n        if self.native_curve:\n            return self.native_curve.IsRational\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_interpolation(cls, points, precision=1e-3):\n        \"\"\"Construct a NURBS curve by interpolating a set of points.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        precision : float, optional\n            The required precision of the interpolation.\n            This parameter is currently not supported.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        native_curve = Rhino.Geometry.NurbsCurve.CreateHSpline([point_to_rhino(point) for point in points])\n        return cls.from_native(native_curve)\n\n    @classmethod\n    def from_native(cls, native_curve):\n        \"\"\"Construct a NURBS curve from an existing Rhino curve.\n\n        Parameters\n        ----------\n        native_curve : Rhino.Geometry.Curve\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        return cls(native_curve)\n\n    @classmethod\n    def from_parameters(cls, points, weights, knots, multiplicities, degree, is_periodic=False):\n        \"\"\"Construct a NURBS curve from explicit curve parameters.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        weights : list[float]\n            The control point weights.\n        knots : list[float]\n            The curve knots, without duplicates.\n        multiplicities : list[int]\n            The multiplicities of the knots.\n        degree : int\n            The degree of the curve.\n        is_periodic : bool, optional\n            Flag indicating whether the curve is periodic or not.\n            Note that this parameters is currently not supported.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        degree = min(degree, len(points) - 1)\n        native_curve = native_curve_from_parameters(points, weights, knots, multiplicities, degree)\n        return cls.from_native(native_curve)\n\n    @classmethod\n    def from_points(cls, points, degree=3, is_periodic=False):\n        \"\"\"Construct a NURBS curve from control points.\n\n        Parameters\n        ----------\n        points : list[:class:`compas.geometry.Point`]\n            The control points.\n        degree : int, optional\n            The degree of the curve.\n        is_periodic : bool, optional\n            Flag indicating whether the curve is periodic or not.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsCurve`\n\n        \"\"\"\n        degree = min(degree, len(points) - 1)\n        native_curve = Rhino.Geometry.NurbsCurve.Create(is_periodic, degree, [point_to_rhino(point) for point in points])\n        return cls.from_native(native_curve)\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}