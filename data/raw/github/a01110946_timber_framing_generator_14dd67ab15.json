{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_framing_generator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_framing_generator.py",
  "instruction": "Framing Generator for Grasshopper.",
  "code": "# File: scripts/gh_framing_generator.py\n\"\"\"Framing Generator for Grasshopper.\n\nGenerates framing elements using the strategy pattern based on material type.\nOutputs JSON data (no geometry) for downstream geometry conversion. Supports\nmultiple material systems through a modular strategy architecture.\n\nReads segment metadata from Cell Decomposer (``segment_u_start``,\n``segment_u_end``) and injects ``_segment_bounds`` into wall data so that\nthe WBC (Wall Boundary Cell) is built at the correct junction-adjusted U\nrange. This propagates extend/trim/split adjustments into plates, studs,\nand all framing elements.\n\nKey Features:\n1. Multi-Material Support\n   - Timber framing (2x4, 2x6, etc.)\n   - CFS (Cold-Formed Steel) framing\n   - Extensible strategy pattern for new materials\n\n2. Element Generation\n   - Studs, plates, headers, sills\n   - King studs and trimmers at openings\n   - Cripple studs above/below openings\n   - End studs at wall and panel boundaries\n\n3. Junction-Aware Framing\n   - Reads segment bounds from cell_data metadata\n   - Injects _segment_bounds into wall data for WBC construction\n   - Framing elements correctly extend/trim at L-corners and T-intersections\n   - Multi-segment walls (X-crossings) produce independent framing runs\n\n4. Panel-Aware Framing\n   - Passes panel_id through element metadata\n   - Supports panelization-before-framing workflow\n   - Enables per-panel framing for prefab construction\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: Component framework\n    - timber_framing_generator.core: Strategy pattern, JSON schemas\n    - timber_framing_generator.materials: Material strategies\n\nPerformance Considerations:\n    - Processing time scales linearly with cell count\n    - Memory usage proportional to element count\n    - JSON serialization is the bottleneck for large walls\n\nUsage:\n    1. Connect 'cell_json' from Cell Decomposer\n    2. Connect 'walls_json' from Wall Analyzer (or Junction Analyzer enriched)\n    3. Set 'material_type' to \"timber\" or \"cfs\"\n    4. Set 'run' to True to execute\n    5. Connect 'framing_json' to Geometry Converter component\n\nInput Requirements:\n    Cell JSON (cell_json) - str:\n        JSON string from Cell Decomposer with cell decomposition data.\n        May include segment metadata (segment_u_start, segment_u_end) from\n        junction-adjusted framing segments.\n        Required: Yes\n        Access: Item\n\n    Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with wall geometry reference\n        Required: Yes\n        Access: Item\n\n    Material Type (material_type) - str:\n        Material system to use (\"timber\" or \"cfs\")\n        Required: No (defaults to \"timber\")\n        Access: Item\n\n    Config JSON (config_json) - str:\n        Optional JSON string with configuration overrides\n        Required: No\n        Access: Item\n\n    Panels JSON (panels_json) - str:\n        Optional JSON string from Panel Decomposer for panel-aware framing.\n        When provided, elements get panel_id metadata for prefab workflows.\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Framing JSON (framing_json) - str:\n        JSON string containing all framing elements for Geometry Converter\n\n    Element Count (element_count) - dict:\n        Dictionary of element counts by type\n\n    Generation Log (generation_log) - str:\n        Detailed generation log with debug information\n\nTechnical Details:\n    - Uses Strategy Pattern for material-specific generation\n    - Elements stored as centerline + profile (no geometry)\n    - Geometry created in separate Geometry Converter component\n    - Panel_id passed through metadata for traceability\n    - Segment bounds from cell metadata override WBC [0, wall_length] range\n\nError Handling:\n    - Invalid JSON returns empty results with error in log\n    - Unknown material type defaults to timber with warning\n    - Missing cells logged but don't halt execution\n    - Missing segment metadata falls back to full wall range (backward compatible)\n\nAuthor: Timber Framing Generator\nVersion: 1.2.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\nfrom dataclasses import asdict\nfrom io import StringIO\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n# Clear timber_framing_generator modules AND the 'src' package itself.\n# Other GH components may have already imported 'src', caching its\n# __path__ to the main repo.  Clearing it forces Python to re-resolve\n# 'src' from the updated sys.path (worktree at index 0).\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path (contains element_adapters fixes, etc.)\n# Fallback: main repo path (for modules not yet in the worktree)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\n# Ensure worktree path has highest priority (index 0) in sys.path.\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\n# Import materials module to trigger strategy registration\n# Import material strategies to trigger registration.\n# Both timber and cfs are imported so the strategy is available\n# regardless of which framing_system the Config Builder sets.\nfrom src.timber_framing_generator.materials import timber  # noqa: F401\ntry:\n    from src.timber_framing_generator.materials import cfs  # noqa: F401\nexcept ImportError:\n    pass  # CFS module may not exist yet\n\nfrom src.timber_framing_generator.core.material_system import (\n    MaterialSystem, get_framing_strategy, list_available_materials\n)\nfrom src.timber_framing_generator.core.json_schemas import (\n    FramingResults, FramingElementData, ProfileData, Point3D, Vector3D,\n    deserialize_cell_data, FramingJSONEncoder\n)\nfrom src.timber_framing_generator.panels.panel_decomposer import (\n    assign_panel_ids_to_elements,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Framing Generator\"\nCOMPONENT_NICKNAME = \"FrameGen\"\nCOMPONENT_MESSAGE = \"v1.2\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Framing\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input → Type hint → Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # NOTE: Type Hints must be set via GH UI (right-click → Type hint)\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Cell JSON\", \"cell_json\", \"JSON string from Cell Decomposer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Walls JSON\", \"walls_json\", \"JSON string from Wall Analyzer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Material Type\", \"material_type\", \"Material system: 'timber' or 'cfs' (default: timber)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Config JSON\", \"config_json\", \"Optional configuration overrides\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Panels JSON\", \"panels_json\", \"Optional panels JSON from Panel Decomposer for panel-aware framing\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Framing JSON\", \"framing_json\", \"JSON string containing all framing elements\"),\n        (\"Element Count\", \"element_count\", \"Dictionary of element counts by type\"),\n        (\"Generation Log\", \"generation_log\", \"Detailed generation log\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Parameter Reading Helpers (read by index, not NickName globals)\n# =============================================================================\n\ndef _get_first_branch(param):\n    \"\"\"Get the first branch of data from a GH parameter's VolatileData.\n\n    Handles both typed (GH_Structure[GH_String]) and untyped\n    (GH_Structure[IGH_Goo]) parameters.\n\n    Args:\n        param: A GH input parameter object\n\n    Returns:\n        List-like branch data, or None if empty\n    \"\"\"\n    data = param.VolatileData\n\n    # Try .Branch(0) first (works for typed parameters)\n    if hasattr(data, 'Branch'):\n        try:\n            return data.Branch(0)\n        except Exception:\n            pass\n\n    # Try get_Branch (pythonnet explicit getter)\n    if hasattr(data, 'get_Branch'):\n        try:\n            return data.get_Branch(0)\n        except Exception:\n            pass\n\n    # Fallback: iterate Branches property\n    if hasattr(data, 'Branches'):\n        try:\n            branches = list(data.Branches)\n            if branches:\n                return branches[0]\n        except Exception:\n            pass\n\n    # Last resort: AllData gives flat list of all items\n    if hasattr(data, 'AllData'):\n        try:\n            return data.AllData(True)\n        except Exception:\n            pass\n\n    return None\n\n\ndef _read_string_input(inputs, index):\n    \"\"\"Read a string value from a GH input by parameter index.\n\n    Args:\n        inputs: ghenv.Component.Params.Input collection\n        index: Zero-based parameter index\n\n    Returns:\n        str or None if input is empty or missing\n    \"\"\"\n    if index >= inputs.Count:\n        return None\n    if inputs[index].VolatileDataCount == 0:\n        return None\n    branch = _get_first_branch(inputs[index])\n    if branch is None or len(branch) == 0:\n        return None\n    item = branch[0]\n    val = item.Value if hasattr(item, 'Value') else item\n    if val is None:\n        return None\n    return str(val)\n\n\ndef _read_bool_input(inputs, index, default=False):\n    \"\"\"Read a boolean value from a GH input by parameter index.\n\n    Args:\n        inputs: ghenv.Component.Params.Input collection\n        index: Zero-based parameter index\n        default: Default value if input is empty\n\n    Returns:\n        bool\n    \"\"\"\n    if index >= inputs.Count:\n        return default\n    if inputs[index].VolatileDataCount == 0:\n        return default\n    branch = _get_first_branch(inputs[index])\n    if branch is None or len(branch) == 0:\n        return default\n    item = branch[0]\n    val = item.Value if hasattr(item, 'Value') else item\n    if val is None:\n        return default\n    return bool(val)\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(cell_json, walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        cell_json: JSON string with cell data\n        walls_json: JSON string with wall data\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not cell_json:\n        return False, \"No cell_json input provided\"\n\n    if not walls_json:\n        return False, \"No walls_json input provided\"\n\n    try:\n        json.loads(cell_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in cell_json: {e}\"\n\n    try:\n        json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in walls_json: {e}\"\n\n    return True, None\n\n\ndef get_material_system(material_type_str):\n    \"\"\"Convert material type string to MaterialSystem enum.\n\n    Args:\n        material_type_str: \"timber\" or \"cfs\"\n\n    Returns:\n        MaterialSystem enum value\n\n    Raises:\n        ValueError: If material type is not recognized\n    \"\"\"\n    material_map = {\n        \"timber\": MaterialSystem.TIMBER,\n        \"cfs\": MaterialSystem.CFS,\n    }\n\n    material_lower = material_type_str.lower().strip() if material_type_str else \"timber\"\n    if material_lower not in material_map:\n        available = list(material_map.keys())\n        raise ValueError(f\"Unknown material type: {material_type_str}. Available: {available}\")\n\n    return material_map[material_lower]\n\n\ndef generate_framing_for_wall(cell_data_dict, wall_data_dict, strategy, config,\n                              panels=None):\n    \"\"\"Generate framing elements for a single wall using the strategy.\n\n    Args:\n        cell_data_dict: Cell decomposition data for this wall\n        wall_data_dict: Wall data for this wall\n        strategy: FramingStrategy instance\n        config: Configuration parameters\n        panels: Optional list of panel dicts (with 'id', 'u_start', 'u_end')\n                for panel-aware framing and panel_id assignment\n\n    Returns:\n        Tuple of (list of FramingElementData, generation log lines)\n    \"\"\"\n    log_lines = []\n    elements = []\n\n    wall_id = cell_data_dict.get('wall_id', 'unknown')\n    log_lines.append(f\"Generating framing for wall {wall_id}\")\n    log_lines.append(f\"  Material: {strategy.material_system.value}\")\n    log_lines.append(f\"  Cells: {len(cell_data_dict.get('cells', []))}\")\n    if panels:\n        log_lines.append(f\"  Panels: {len(panels)}\")\n\n    # Capture stdout to include debug output\n    old_stdout = sys.stdout\n    captured_output = StringIO()\n    try:\n        sys.stdout = captured_output\n\n        framing_elements = strategy.generate_framing(\n            wall_data=wall_data_dict,\n            cell_data=cell_data_dict,\n            config=config\n        )\n\n        # Extract wall direction from wall_data_dict for geometry reconstruction\n        wall_x_axis = None\n        wall_z_axis = None\n        if wall_data_dict and 'base_plane' in wall_data_dict:\n            base_plane = wall_data_dict['base_plane']\n            if 'x_axis' in base_plane:\n                x_axis = base_plane['x_axis']\n                wall_x_axis = (x_axis['x'], x_axis['y'], x_axis['z'])\n            if 'z_axis' in base_plane:\n                z_axis = base_plane['z_axis']\n                wall_z_axis = (z_axis['x'], z_axis['y'], z_axis['z'])\n\n        for elem in framing_elements:\n            # Build element metadata with wall_id and wall direction\n            elem_metadata = dict(elem.metadata) if elem.metadata else {}\n            elem_metadata['wall_id'] = wall_id\n            if wall_x_axis:\n                elem_metadata['wall_x_axis'] = wall_x_axis\n            if wall_z_axis:\n                elem_metadata['wall_z_axis'] = wall_z_axis\n\n            elem_data = FramingElementData(\n                id=elem.id,\n                element_type=elem.element_type.value,\n                profile=ProfileData(\n                    name=elem.profile.name,\n                    width=elem.profile.width,\n                    depth=elem.profile.depth,\n                    material_system=elem.profile.material_system.value,\n                    properties=elem.profile.properties,\n                ),\n                centerline_start=Point3D(*elem.centerline_start),\n                centerline_end=Point3D(*elem.centerline_end),\n                u_coord=elem.u_coord,\n                v_start=elem.v_start,\n                v_end=elem.v_end,\n                cell_id=elem.cell_id,\n                panel_id=None,  # Assigned later by assign_panel_ids_to_elements\n                metadata=elem_metadata,\n            )\n            elements.append(elem_data)\n\n        # Assign panel_id to elements if panels are provided\n        if panels:\n            # Convert FramingElementData objects to dicts for assignment\n            elem_dicts = [\n                {\"u_coord\": e.u_coord, \"index\": i}\n                for i, e in enumerate(elements)\n            ]\n            assign_panel_ids_to_elements(elem_dicts, panels)\n            for ed in elem_dicts:\n                elements[ed[\"index\"]].panel_id = ed.get(\"panel_id\")\n            assigned_count = sum(1 for e in elements if e.panel_id is not None)\n            log_lines.append(f\"  Panel IDs assigned: {assigned_count}/{len(elements)}\")\n\n        log_lines.append(f\"  Generated: {len(elements)} elements\")\n\n    except Exception as e:\n        log_lines.append(f\"  ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    finally:\n        sys.stdout = old_stdout\n        debug_output = captured_output.getvalue()\n        if debug_output.strip():\n            log_lines.append(\"--- DEBUG OUTPUT ---\")\n            log_lines.append(debug_output.strip())\n            log_lines.append(\"--- END DEBUG ---\")\n\n    return elements, log_lines\n\n\ndef compute_effective_segment_bounds(\n    panel_start: \"float | None\",\n    panel_end: \"float | None\",\n    seg_start: \"float | None\",\n    seg_end: \"float | None\",\n    wall_length: float,\n    tolerance: float = 0.01,\n) -> \"tuple[float, float] | None\":\n    \"\"\"Compute effective _segment_bounds for a cell/panel.\n\n    In **panel mode** (panel_start/panel_end present), plates are bounded by\n    panel edges.  Junction adjustments (seg_start/seg_end) only apply at the\n    wall's own endpoints — i.e. the first panel inherits seg_start if its\n    panel_start is near 0, and the last panel inherits seg_end if its\n    panel_end is near wall_length.\n\n    In **segment mode** (no panel bounds), the raw junction-adjusted segment\n    bounds are used directly.\n\n    Args:\n        panel_start: Panel U-start from metadata (None if not panel mode).\n        panel_end: Panel U-end from metadata (None if not panel mode).\n        seg_start: Junction-adjusted segment U-start from metadata.\n        seg_end: Junction-adjusted segment U-end from metadata.\n        wall_length: Full wall length for endpoint comparison.\n        tolerance: How close to 0 / wall_length counts as \"at wall endpoint\".\n\n    Returns:\n        (eff_start, eff_end) tuple, or None if no bounds to inject.\n    \"\"\"\n    if panel_start is not None and panel_end is not None:\n        # Panel mode: plates bounded by panel edges\n        eff_start = panel_start\n        eff_end = panel_end\n        # First panel inherits junction extension at wall start\n        if seg_start is not None and panel_start <= tolerance:\n            eff_start = seg_start\n        # Last panel inherits junction extension at wall end\n        if seg_end is not None and panel_end >= wall_length - tolerance:\n            eff_end = seg_end\n        return (eff_start, eff_end)\n    elif seg_start is not None and seg_end is not None:\n        # Segment mode (no panels): junction-adjusted bounds\n        return (seg_start, seg_end)\n    return None\n\n\ndef process_framing(cell_list, wall_lookup, strategy, config,\n                    panels_by_wall=None):\n    \"\"\"Process all walls through the framing generator.\n\n    Args:\n        cell_list: List of cell data dictionaries\n        wall_lookup: Dictionary mapping wall_id to wall data\n        strategy: FramingStrategy instance\n        config: Configuration parameters\n        panels_by_wall: Optional dict mapping wall_id to list of panel dicts\n\n    Returns:\n        Tuple of (all_elements, type_counts, log_lines)\n    \"\"\"\n    log_lines = []\n    all_elements = []\n    type_counts = {}\n\n    # In panel mode, each wall produces multiple cell_data entries (one per\n    # panel).  Each call to generate_framing_for_wall() starts element-ID\n    # counters at 0, so \"stud_0\" would appear once per panel.  Prefix IDs\n    # with \"p{N}_\" to make them unique per wall.\n    # Pre-scan to find walls that appear more than once in cell_list.\n    wall_entry_counts = {}\n    for cd in cell_list:\n        wid = cd.get('wall_id', '')\n        wall_entry_counts[wid] = wall_entry_counts.get(wid, 0) + 1\n    wall_call_counter = {}\n\n    for i, cell_data_dict in enumerate(cell_list):\n        wall_id = cell_data_dict.get('wall_id', f'wall_{i}')\n        wall_data_dict = wall_lookup.get(wall_id, {})\n\n        # Inject segment bounds from cell metadata so that\n        # reconstruct_wall_data() builds the WBC at the correct\n        # framing U range (junction-adjusted, not raw wall_length).\n        # In panel mode, plates are bounded by panel edges with\n        # junction adjustments only at the wall's own endpoints.\n        meta = cell_data_dict.get('metadata', {})\n        wall_length = wall_data_dict.get('wall_length', 0)\n        bounds = compute_effective_segment_bounds(\n            panel_start=meta.get('panel_u_start'),\n            panel_end=meta.get('panel_u_end'),\n            seg_start=meta.get('segment_u_start'),\n            seg_end=meta.get('segment_u_end'),\n            wall_length=wall_length,\n        )\n        if bounds is not None:\n            wall_data_dict = dict(wall_data_dict)  # shallow copy\n            wall_data_dict['_segment_bounds'] = list(bounds)\n\n        # Get panels for this wall if available\n        wall_panels = None\n        if panels_by_wall:\n            wall_panels = panels_by_wall.get(wall_id)\n\n        elements, wall_log = generate_framing_for_wall(\n            cell_data_dict, wall_data_dict, strategy, config,\n            panels=wall_panels,\n        )\n\n        # Make element IDs unique when a wall has multiple cell_data entries\n        # (panel mode).  Each call generates IDs from 0 (stud_0, top_plate_0,\n        # etc.) so without a prefix the same ID appears in multiple panels,\n        # causing the baking element_index to overwrite and multiple panels\n        # to resolve to the same Revit ElementId.\n        panel_idx = wall_call_counter.get(wall_id, 0)\n        wall_call_counter[wall_id] = panel_idx + 1\n        if wall_entry_counts.get(wall_id, 1) > 1:\n            for elem in elements:\n                elem.id = \"p%d_%s\" % (panel_idx, elem.id)\n\n        all_elements.extend(elements)\n        log_lines.extend(wall_log)\n\n        # Count by type\n        for elem in elements:\n            elem_type = elem.element_type\n            type_counts[elem_type] = type_counts.get(elem_type, 0) + 1\n\n    return all_elements, type_counts, log_lines\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Returns:\n        tuple: (framing_json, element_count, generation_log)\n    \"\"\"\n    # -----------------------------------------------------------------\n    # Read inputs by parameter index (CRITICAL: NickName injection is unreliable)\n    # -----------------------------------------------------------------\n    inputs = ghenv.Component.Params.Input\n\n    cell_json_input = _read_string_input(inputs, 0)\n    walls_json_input = _read_string_input(inputs, 1)\n    material_type_input = _read_string_input(inputs, 2)\n    config_json_input = _read_string_input(inputs, 3)\n    panels_json_input = _read_string_input(inputs, 4)\n    run_val = _read_bool_input(inputs, 5, default=False)\n\n    # -----------------------------------------------------------------\n    # Setup component metadata (display only, AFTER inputs are captured)\n    # -----------------------------------------------------------------\n    setup_component()\n\n    # Initialize outputs\n    framing_json = \"{}\"\n    element_count = {}\n    log_lines = []\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(cell_json_input, walls_json_input, run_val)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            return framing_json, element_count, error_msg\n\n        # Parse inputs (config must be parsed BEFORE framing_system extraction)\n        cell_list = json.loads(cell_json_input)\n        wall_list = json.loads(walls_json_input)\n        wall_lookup = {w.get('wall_id'): w for w in wall_list}\n        config = json.loads(config_json_input) if config_json_input else {}\n\n        # Get material system -- framing_system from config_json overrides material_type input\n        framing_system = config.get(\"framing_system\")\n        if framing_system and framing_system.strip():\n            material_type_val = framing_system.strip().lower()\n            log_info(f\"Using framing_system from config_json: {material_type_val}\")\n        else:\n            material_type_val = material_type_input if material_type_input else \"timber\"\n        material_system = get_material_system(material_type_val)\n\n        # Check if strategy is available\n        available = list_available_materials()\n        if material_system not in available:\n            error_msg = (\n                f\"Strategy for {material_type_val} not available.\\n\"\n                f\"Available: {[m.value for m in available]}\"\n            )\n            log_error(error_msg)\n            return framing_json, element_count, error_msg\n\n        strategy = get_framing_strategy(material_system)\n\n        # Parse optional panels_json input\n        panels_by_wall = None\n        if panels_json_input:\n            try:\n                panels_list = json.loads(panels_json_input)\n                # panels_list is a list of PanelResults dicts, one per wall\n                # Build lookup: wall_id -> list of panel dicts\n                panels_by_wall = {}\n                for panel_result in panels_list:\n                    wid = panel_result.get(\"wall_id\", \"\")\n                    panels_by_wall[wid] = panel_result.get(\"panels\", [])\n                log_lines.append(f\"Panels loaded: {len(panels_by_wall)} walls with panels\")\n            except (json.JSONDecodeError, TypeError) as e:\n                log_lines.append(f\"WARNING: Could not parse panels_json: {e}\")\n\n        log_lines.append(f\"Framing Generator v1.2\")\n        log_lines.append(f\"Material System: {material_type_val}\")\n        log_lines.append(f\"Walls to process: {len(cell_list)}\")\n        log_lines.append(f\"Strategy: {strategy.__class__.__name__}\")\n        log_lines.append(\"\")\n\n        # Process framing\n        all_elements, type_counts, process_log = process_framing(\n            cell_list, wall_lookup, strategy, config,\n            panels_by_wall=panels_by_wall,\n        )\n        log_lines.extend(process_log)\n\n        # Create results object\n        results = FramingResults(\n            wall_id=\"all_walls\",\n            material_system=material_type_val,\n            elements=all_elements,\n            element_counts=type_counts,\n            metadata={\n                'total_walls': len(cell_list),\n                'total_elements': len(all_elements),\n            }\n        )\n\n        # Serialize to JSON\n        framing_json = json.dumps(asdict(results), cls=FramingJSONEncoder, indent=2)\n        element_count = type_counts\n\n        log_lines.append(\"\")\n        log_lines.append(f\"Summary:\")\n        log_lines.append(f\"  Total elements: {len(all_elements)}\")\n        for elem_type, count in sorted(type_counts.items()):\n            log_lines.append(f\"  {elem_type}: {count}\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    return framing_json, element_count, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# All inputs are read by parameter index inside main() — no NickName globals needed.\nif __name__ == \"__main__\":\n    framing_json, element_count, generation_log = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}