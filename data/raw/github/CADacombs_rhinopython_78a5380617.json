{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_fitRebuild.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_fitRebuild.py",
  "instruction": "An alternative to _Rebuild for curves, this script can test different degrees and control\r\npoint counts to find a rebuild result within a deviation tolerance of the input curve.\r\n\r\nTODO:\r\n    Limit...",
  "code": "\"\"\"\r\nAn alternative to _Rebuild for curves, this script can test different degrees and control\r\npoint counts to find a rebuild result within a deviation tolerance of the input curve.\r\n\r\nTODO:\r\n    Limit distance between consecutive control points?\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n170624-27: Created.\r\n...\r\n200307: When degree is not specified, now iterates from degree 3 to 5 before incrementing the number of control points.\r\n200401, 10: Improved handling of bad deviation result for closed curves.\r\n200610: Import-related update.  Purged some of this history.\r\n200611: Bug fix.\r\n200622: Modified some option inputs.\r\n210312: Modified some option default values.  Removed a print(statement used for debugging.\r\n210412: Added filter for PolylineCurves.\r\n220328: Added bPreserveEndG2 option.\r\n220809, 0823, 0910: Import-related update.\r\n\"\"\"\r\n\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport Eto.Drawing as drawing\r\nimport Eto.Forms as forms\r\n\r\nimport xCurve\r\nimport spb_Crv_deviation\r\nimport spb_NurbsCrv_fitByTranslatingControlPts\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    sDialogTexts = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"\"\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bPreserveEndG1'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Preserve end tangent dirs.\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPreserveEndG2'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Preserve end curvatures/radii\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bFurtherTranslateCps'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Further translate CPs to minimize CP count  (May be slow.)\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLimitDegree'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Limit degree\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMatchDegree'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Same as input curve\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDegree'; keys.append(key)\r\n    values[key] = 3\r\n    names[key] = 'CrvDegree'\r\n    sDialogTexts[key] = \"\"\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLimitMinCpCt'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Limit min. CP count\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iMinCpCt'; keys.append(key)\r\n    values[key] = 4\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Min. CP count\"\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLimitMaxCpCt'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Limit max. CP count\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMatchMaxCpCt'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Same as input curve\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iMaxCpCt'; keys.append(key)\r\n    values[key] = 32\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Max. CP count\"\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessPolyCrv'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'PolyCrv'\r\n    sDialogTexts[key] = \"Polycurves\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessPolyCrvSegs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Process'\r\n    sDialogTexts[key] = (\r\n        None,\r\n        \"In whole  \",\r\n        \"Each segment individually\")\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'WholePolyCrv', 'EachSegment')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessLinear'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Linear'\r\n    sDialogTexts[key] = \"Lines\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessPolyline'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'PolylineInWhole'\r\n    sDialogTexts[key] = \"Polylines in whole\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessArc'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Arc'\r\n    sDialogTexts[key] = \"Arcs\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessEllipse'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Ellipse'\r\n    sDialogTexts[key] = \"Ellipses\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessOtherRat'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'OtherRationalNurbs'\r\n    sDialogTexts[key] = \"Other rational NURBS\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessNonRatWithInternalPolyknot'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'NurbsWithInternalPolyknots'\r\n    sDialogTexts[key] = \"Having internal polyknots\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessNonRatWithSomeFullPolyknot'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Multiplicity'\r\n    sDialogTexts[key] = (\r\n        None,\r\n        \"Any multiplicity  \",\r\n        \"Some full\")\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Any', 'SomeFull')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessUniformNonRat'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Uniform'\r\n    sDialogTexts[key] = \"Uniform\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessBezierNonRat'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Bezier'\r\n    sDialogTexts[key] = \"Bezier\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bProcessOtherNonRat'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'NonrationalNurbs'\r\n    sDialogTexts[key] = \"Other\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    sDialogTexts[key] = \"Output:\", \"Add new    \", \"Replace input\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Echo\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    sDialogTexts[key] = \"Debug\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    @classmethod\r\n    def loadSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if cls.stickyKeys[key] in sc.sticky:\r\n                if key in cls.riOpts:\r\n                    cls.riOpts[key].CurrentValue = cls.values[key] = sc.sticky[cls.stickyKeys[key]]\r\n                else:\r\n                    cls.values[key] = sc.sticky[cls.stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\nclass FitRebuildCurveDialog(forms.Dialog[bool]):\r\n\r\n\r\n    def __init__(self):\r\n\r\n        Opts.loadSticky()\r\n\r\n        # Initialize dialog box\r\n        self.Title = 'Rebuild Curve'\r\n        self.Padding = drawing.Padding(10)\r\n        self.Resizable = False\r\n\r\n        self.divider = forms.Label()\r\n        #self.divider.Text = ''\r\n        self.divider.Height = 2\r\n        self.divider.BackgroundColor = drawing.Colors.Gray\r\n\r\n\r\n        self.radioButtonList = {}\r\n        self.checkBoxes = {}\r\n        self.labels = {}\r\n        self.textBoxes = {}\r\n\r\n        for key in Opts.keys:\r\n            if key[0] == 'b':\r\n                if isinstance(Opts.sDialogTexts[key], str):\r\n                    self.checkBoxes[key] = forms.CheckBox(Text=Opts.sDialogTexts[key])\r\n                    self.checkBoxes[key].Checked = Opts.values[key]\r\n                elif isinstance(Opts.sDialogTexts[key], tuple):\r\n                    self.radioButtonList[key] = forms.RadioButtonList()\r\n                    self.radioButtonList[key].DataStore = Opts.sDialogTexts[key][1:]\r\n                    self.radioButtonList[key].SelectedIndex = int(Opts.values[key])\r\n                    #self.radioButtonList[key].Orientation = forms.Orientation.Horizontal\r\n            elif key[0] == 'f':\r\n                self.labels[key] = forms.Label(Text=Opts.sDialogTexts[key])\r\n                self.textBoxes[key] = forms.TextBox(Text=str(Opts.values[key]))\r\n            elif key[0] == 'i':\r\n                self.labels[key] = forms.Label(Text=Opts.sDialogTexts[key])\r\n                self.textBoxes[key] = forms.TextBox(Text=str(int(Opts.values[key])))\r\n            elif key[0] == 's':\r\n                self.radioButtonList[key] = forms.RadioButtonList()\r\n                self.radioButtonList[key].DataStore = Opts.sDialogTexts[key]\r\n                self.radioButtonList[key].SelectedIndex = Opts.sDialogTexts[key].index(Opts.values[key])\r\n\r\n\r\n\r\n        # Set initial state.\r\n        self.enableTextBox_iDegree()\r\n        self.enableTextBox_iMinCpCt()\r\n        self.enableTextBox_iMaxCpCt()\r\n        self.enableCheckBox_bPreserveEndG2()\r\n        self.enableRadioButtonList_bProcessPolyCrvSegs()\r\n        self.enableRadioButtonList_bProcessNonRatWithOnlyFullyMultiK()\r\n        self.enableCheckBox_bProcessBezier()\r\n\r\n\r\n\r\n        # Events.\r\n        self.textBoxes['fDevTol'].TextChanged += self.onChange_fDevTol\r\n\r\n        self.checkBoxes['bLimitDegree'].CheckedChanged += self.onChange_bLimitDegree\r\n        self.checkBoxes['bMatchDegree'].CheckedChanged += self.onChange_bMatchDegree\r\n        self.textBoxes['iDegree'].TextChanged += self.onChange_iDegree\r\n\r\n        self.checkBoxes['bLimitMinCpCt'].CheckedChanged += self.onChange_bLimitMinCpCt\r\n        self.textBoxes['iMinCpCt'].TextChanged += self.onChange_iMinCpCt\r\n\r\n        self.checkBoxes['bLimitMaxCpCt'].CheckedChanged += self.onChange_bLimitMaxCpCt\r\n        self.checkBoxes['bMatchMaxCpCt'].CheckedChanged += self.onChange_bMatchMaxCpCt\r\n        self.textBoxes['iMaxCpCt'].TextChanged += self.onChange_iMaxCpCt\r\n\r\n        self.checkBoxes['bPreserveEndG1'].CheckedChanged += self.onChange_bPreserveEndG1\r\n\r\n        self.checkBoxes['bProcessPolyCrv'].CheckedChanged += self.OnChange_bProcessPolyCrv\r\n\r\n        self.checkBoxes['bProcessUniformNonRat'].CheckedChanged += self.OnChange_bProcessUniformNonRational\r\n        self.checkBoxes['bProcessNonRatWithInternalPolyknot'].CheckedChanged += self.OnChange_bProcessNonRatWithAnyMultiK\r\n\r\n        self.DefaultButton = forms.Button(Text = 'OK')\r\n        self.DefaultButton.Click += self.onOkButtonClick\r\n\r\n        self.AbortButton = forms.Button(Text = 'Cancel')\r\n        self.AbortButton.Click += self.onCancelButtonClick\r\n\r\n\r\n\r\n        # Layout.\r\n        layout = forms.DynamicLayout()\r\n        #layout.Spacing = drawing.Size(5, 5)\r\n        #layout.DefaultPadding = 5\r\n        layout.DefaultSpacing = drawing.Size(5, 5)\r\n\r\n        layout.AddSeparateRow(\r\n            None,\r\n            \"Deviation tolerance\",\r\n            self.textBoxes['fDevTol'],\r\n            )\r\n\r\n        layout.BeginVertical()\r\n        layout.AddSpace()\r\n        layout.AddRow(\r\n            self.checkBoxes['bLimitDegree'],\r\n            self.checkBoxes['bMatchDegree'],\r\n            self.textBoxes['iDegree'],\r\n            )\r\n        layout.AddSpace()\r\n        layout.AddRow(\r\n            self.checkBoxes['bLimitMinCpCt'],\r\n            None,\r\n            self.textBoxes['iMinCpCt'],\r\n            )\r\n        layout.AddSpace()\r\n        layout.AddRow(\r\n            self.checkBoxes['bLimitMaxCpCt'],\r\n            self.checkBoxes['bMatchMaxCpCt'],\r\n            self.textBoxes['iMaxCpCt'],\r\n            )\r\n        layout.EndVertical()\r\n\r\n        layout.AddSpace()\r\n        layout.AddSpace()\r\n\r\n        layout.BeginVertical()\r\n        layout.AddRow(\r\n            self.checkBoxes['bPreserveEndG1'],\r\n            self.checkBoxes['bPreserveEndG2'],\r\n            )\r\n        layout.EndVertical()\r\n\r\n        layout.AddSpace()\r\n        layout.AddSpace()\r\n\r\n        layout.BeginVertical()\r\n        layout.AddRow(self.checkBoxes['bFurtherTranslateCps'])\r\n        layout.EndVertical()\r\n\r\n        layout.AddSpace()\r\n        layout.AddSpace()\r\n\r\n        layout.AddRow(\"Process these curves:\")\r\n        layout.EndVertical()\r\n\r\n        layout.BeginVertical()\r\n        layout.AddSeparateRow(\r\n            \"\",\r\n            self.checkBoxes['bProcessPolyCrv'],\r\n            self.radioButtonList['bProcessPolyCrvSegs'])\r\n        layout.AddSeparateRow(\r\n            \"\",\r\n            self.checkBoxes['bProcessLinear'],\r\n            self.checkBoxes['bProcessPolyline'],\r\n            )\r\n        layout.AddSeparateRow(\r\n            \"\",\r\n            self.checkBoxes['bProcessArc'],\r\n            self.checkBoxes['bProcessEllipse'],\r\n            self.checkBoxes['bProcessOtherRat'],\r\n            )\r\n        layout.AddSeparateRow(\"\", \"Non-rational NURBS:\")\r\n        layout.AddSeparateRow(\r\n            \"   \",\r\n            self.checkBoxes['bProcessNonRatWithInternalPolyknot'],\r\n            self.radioButtonList['bProcessNonRatWithSomeFullPolyknot'],\r\n            )\r\n        layout.AddSeparateRow(\r\n            \"   \",\r\n            self.checkBoxes['bProcessUniformNonRat'],\r\n            self.checkBoxes['bProcessBezierNonRat'],\r\n            )\r\n        layout.AddSeparateRow(\r\n            \"   \",\r\n            self.checkBoxes['bProcessOtherNonRat'],\r\n            None,\r\n            )\r\n        layout.EndVertical()\r\n\r\n        layout.AddSeparateRow(\"\")\r\n        key = 'bReplace'\r\n        layout.AddSeparateRow(Opts.sDialogTexts[key][0], self.radioButtonList[key])\r\n        layout.BeginVertical()\r\n        layout.AddRow(\"\")\r\n        layout.AddRow(\r\n            self.checkBoxes['bEcho'],\r\n            None,\r\n            self.checkBoxes['bDebug'],\r\n            )\r\n        layout.AddRow(\"\")\r\n        layout.EndVertical()\r\n\r\n\r\n        layout.AddSeparateRow(None, self.DefaultButton, None, self.AbortButton, None)\r\n        #layout.AddRow(self.okButton, self.cancelButton)\r\n\r\n        # Set the dialog content\r\n        self.Content = layout\r\n\r\n\r\n\r\n    # Functions that set properties of controls based on the values of other controls.\r\n    # This is used in both __init__ and by individual onChange methods.\r\n    def enableCheckBox_bMatchDegree(self):\r\n        self.checkBoxes['bMatchDegree'].Enabled = (\r\n            self.checkBoxes['bLimitDegree'].Checked)\r\n\r\n\r\n    def enableTextBox_iDegree(self):\r\n        self.textBoxes['iDegree'].Enabled = (\r\n            self.checkBoxes['bLimitDegree'].Checked and\r\n            not self.checkBoxes['bMatchDegree'].Checked)\r\n\r\n\r\n    def enableTextBox_iMinCpCt(self):\r\n        self.textBoxes['iMinCpCt'].Enabled = (\r\n            self.checkBoxes['bLimitMinCpCt'].Checked)\r\n\r\n\r\n    def enableCheckBox_bMatchMaxCpCt(self):\r\n        self.checkBoxes['bMatchMaxCpCt'].Enabled = (\r\n            self.checkBoxes['bLimitMaxCpCt'].Checked)\r\n\r\n    def enableTextBox_iMaxCpCt(self):\r\n        self.textBoxes['iMaxCpCt'].Enabled = (\r\n            self.checkBoxes['bLimitMaxCpCt'].Checked and\r\n            not self.checkBoxes['bMatchMaxCpCt'].Checked)\r\n\r\n\r\n    def enableCheckBox_bPreserveEndG2(self):\r\n        self.checkBoxes['bPreserveEndG2'].Enabled = (\r\n            self.checkBoxes['bPreserveEndG1'].Checked)\r\n\r\n\r\n\r\n    def enableRadioButtonList_bProcessPolyCrvSegs(self):\r\n        self.radioButtonList['bProcessPolyCrvSegs'].Enabled = (\r\n            self.checkBoxes['bProcessPolyCrv'].Checked)\r\n\r\n\r\n    def enableRadioButtonList_bProcessNonRatWithOnlyFullyMultiK(self):\r\n        self.radioButtonList['bProcessNonRatWithSomeFullPolyknot'].Enabled = (\r\n            self.checkBoxes['bProcessNonRatWithInternalPolyknot'].Checked)\r\n\r\n\r\n    def enableCheckBox_bProcessBezier(self):\r\n        self.checkBoxes['bProcessBezierNonRat'].Enabled = (\r\n            self.checkBoxes['bProcessUniformNonRat'].Checked)\r\n\r\n\r\n\r\n    def onChange_bLimitCrvDev(self, sender, e):\r\n        self.enableTextBox_fDevTol()\r\n\r\n    def onChange_fDevTol(self, sender, e):\r\n        try:\r\n            float(self.textBoxes['fDevTol'].Text)\r\n            self.textBoxes['fDevTol'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['fDevTol'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onChange_bLimitDegree(self, sender, e):\r\n        self.enableCheckBox_bMatchDegree()\r\n        self.enableTextBox_iDegree()\r\n\r\n    def onChange_bMatchDegree(self, sender, e):\r\n        self.enableTextBox_iDegree()\r\n\r\n    def onChange_iDegree(self, sender, e):\r\n        try:\r\n            iDegree = int(self.textBoxes['iDegree'].Text)\r\n            if iDegree < 3:\r\n                iDegree = 3\r\n            elif iDegree > 5:\r\n                iDegree = 5\r\n            self.textBoxes['iDegree'].Text = str(iDegree)\r\n            self.textBoxes['iDegree'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['iDegree'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onChange_bLimitMinCpCt(self, sender, e):\r\n        self.enableTextBox_iMinCpCt()\r\n\r\n    def onChange_iMinCpCt(self, sender, e):\r\n        try:\r\n            iMinCpCt = int(self.textBoxes['iMinCpCt'].Text)\r\n            self.textBoxes['iMinCpCt'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['iMinCpCt'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onChange_bLimitMaxCpCt(self, sender, e):\r\n        self.enableCheckBox_bMatchMaxCpCt()\r\n        self.enableTextBox_iMaxCpCt()\r\n\r\n    def onChange_bMatchMaxCpCt(self, sender, e):\r\n        self.enableTextBox_iMaxCpCt()\r\n\r\n    def onChange_iMaxCpCt(self, sender, e):\r\n        try:\r\n            iMaxCpCt = int(self.textBoxes['iMaxCpCt'].Text)\r\n            self.textBoxes['iMaxCpCt'].BackgroundColor = drawing.SystemColors.ControlBackground\r\n        except:\r\n            self.textBoxes['iMaxCpCt'].BackgroundColor = drawing.Colors.Red\r\n\r\n\r\n    def onChange_bPreserveEndG1(self, sender, e):\r\n        self.enableCheckBox_bPreserveEndG2()\r\n\r\n\r\n    def OnChange_bProcessPolyCrv(self, sender, e):\r\n        self.enableRadioButtonList_bProcessPolyCrvSegs()\r\n\r\n\r\n    def OnChange_bProcessNonRatWithAnyMultiK(self, sender, e):\r\n        self.enableRadioButtonList_bProcessNonRatWithOnlyFullyMultiK()\r\n\r\n\r\n    def OnChange_bProcessUniformNonRational(self, sender, e):\r\n        self.enableCheckBox_bProcessBezier()\r\n\r\n\r\n\r\n\r\n    def onCancelButtonClick(self, sender, e):\r\n        self.Close(False)\r\n\r\n\r\n    def onOkButtonClick(self, sender, e):\r\n        # Save values.\r\n        for key in Opts.keys:\r\n            if key in self.checkBoxes:\r\n                Opts.values[key] = self.checkBoxes[key].Checked\r\n            elif key in self.radioButtonList:\r\n                if key[0] == 's':\r\n                    Opts.values[key] = (\r\n                        Opts.sDialogTexts[key][self.radioButtonList[key].SelectedIndex]\r\n                    )\r\n                if key[0] == 'b':\r\n                    Opts.values[key] = bool(self.radioButtonList[key].SelectedIndex)\r\n            elif key in self.textBoxes:\r\n                if key[0] == 'f':\r\n                    try:\r\n                        Opts.values[key] = float(self.textBoxes[key].Text)\r\n                    except:\r\n                        s  = \"Invalid input for {}.\".format(key[1:])\r\n                        s += \"  {} will be used instead.\".format(Opts.values[key])\r\n                        print(s)\r\n                if key[0] == 'i':\r\n                    try:\r\n                        Opts.values[key] = int(self.textBoxes[key].Text)\r\n                    except:\r\n                        s  = \"Invalid input for {}.\".format(key[1:])\r\n                        s += \"  {} will be used instead.\".format(Opts.values[key])\r\n                        print(s)\r\n\r\n\r\n        # Save sticky.\r\n        for key in Opts.keys:\r\n            if key in Opts.stickyKeys:\r\n                sc.sticky[Opts.stickyKeys[key]] = Opts.values[key]\r\n\r\n        self.Close(True)\r\n\r\n\r\ndef getPreselectedCurves():\r\n    gObjs_Preselected = [rdObj.Id for rdObj in sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False)]\r\n    if gObjs_Preselected:\r\n        gCrvs_Preselected = []\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n        for rdRhinoObject in sc.doc.Objects.GetObjectList(iter):\r\n            if rdRhinoObject.Id in gObjs_Preselected:\r\n                if rdRhinoObject.ObjectType == rd.ObjectType.Curve:\r\n                    gCrvs_Preselected.append(rdRhinoObject.Id)\r\n        if gCrvs_Preselected:\r\n            if Opts.values['bEcho']:\r\n                s  = \"{} curves\".format(len(gCrvs_Preselected))\r\n                s += \" were preselected and will thus be the selection set.\"\r\n                print(s)\r\n            return tuple(gCrvs_Preselected)\r\n\r\n\r\ndef getInput():\r\n    \"\"\"Get curves with optional input.\"\"\"\r\n\r\n\r\n\r\n    def setCurveFilter():\r\n        go_CrvTypes = ri.Custom.GetOption()\r\n\r\n        go_CrvTypes.SetCommandPrompt(\"Curve type(s) to process\")\r\n\r\n        idxs_Opt_CrvTypes = {}\r\n\r\n        while True:\r\n            key = 'bProcessPolyCrv'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessPolyCrvSegs'; idxs_Opt_CrvTypes[key] = (Opts.riAddOpts[key](go_CrvTypes)\r\n                                           if Opts.values['bProcessPolyCrv']\r\n                                           else None)\r\n            key = 'bProcessLinear'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessPolyline'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessArc'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessEllipse'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessOtherRat'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessNonRatWithInternalPolyknot'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessNonRatWithSomeFullPolyknot'; idxs_Opt_CrvTypes[key] = (\r\n                Opts.riAddOpts[key](go_CrvTypes)\r\n                if Opts.values['bProcessNonRatWithInternalPolyknot']\r\n                else None)\r\n            key = 'bProcessUniformNonRat'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            key = 'bProcessBezierNonRat'; idxs_Opt_CrvTypes[key] = (Opts.riAddOpts[key](go_CrvTypes)\r\n                                           if Opts.values['bProcessUniformNonRat']\r\n                                           else None)\r\n            key = 'bProcessOtherNonRat'; idxs_Opt_CrvTypes[key] = Opts.riAddOpts[key](go_CrvTypes)\r\n            #idxs_Opt_CrvTypes['YesToAll'] = go_CrvTypes.AddOption('YesToAll')\r\n            #idxs_Opt_CrvTypes['NoToAll'] = go_CrvTypes.AddOption('NoToAll')\r\n\r\n\r\n            res = go_CrvTypes.Get()\r\n            if res != ri.GetResult.Option:\r\n                break\r\n            #elif go_CrvTypes.OptionIndex() == idxs_Opt_CrvTypes['YesToAll']:\r\n            #    for key in sCrvFilterOpts:\r\n            #        Opts.riOpts[key].CurrentValue = True\r\n            #elif go_CrvTypes.OptionIndex() == idxs_Opt_CrvTypes['NoToAll']:\r\n            #    for key in sCrvFilterOpts:\r\n            #        Opts.riOpts[key].CurrentValue = False\r\n\r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            go_CrvTypes.ClearCommandOptions()\r\n\r\n\r\n\r\n    sCrvFilterOpts = [s[8:] for s in Opts.keys if s[:8] == 'bProcess']\r\n\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    \r\n    #    # Custom geometry filter to only select NurbsCurve wire curves.\r\n    #    def curvesEdgesNotInBlockInstGeomFilter(rdObj, geom, compIdx):\r\n    #        if rdObj.ObjectType == rd.ObjectType.InstanceReference: return False\r\n    #        print(geom\r\n    #        print(compIdx.Index\r\n    #        return isinstance(geom, rg.Curve)\r\n    #        return geom.GetType() == rg.Curve\r\n    #    go.SetCustomGeometryFilter(curvesEdgesNotInBlockInstGeomFilter)    \r\n    \r\n    go.AcceptNumber(True, True)\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    print(\"\\nMaxCpCt: \\\"0\\\" will allow any amount.\")\r\n\r\n    print(\"Curve types to process: {}\".format(\r\n        ', '.join([s for s in sCrvFilterOpts if Opts.values['bProcess'+s]])))\r\n\r\n\r\n    #bPreselectedObjsChecked = False\r\n\r\n    Opts.loadSticky()\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        idxs_Opts['CrvFilter'] = go.AddOption('CrvTypesToProcess')\r\n        key = 'fDevTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bPreserveEndG1'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bPreserveEndG2'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bFurtherTranslateCps'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bLimitDegree'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bMatchDegree'; idxs_Opts[key] = (Opts.riAddOpts[key](go)[0]\r\n                                           if Opts.values['bLimitDegree']\r\n                                           else None)\r\n        key = 'iDegree'; idxs_Opts[key] = (Opts.riAddOpts[key](go)[0]\r\n                                           if (\r\n                                               Opts.values['bLimitDegree'] and\r\n                                               not Opts.values['bMatchDegree'])\r\n                                           else None)\r\n        key = 'bLimitMinCpCt'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'iMinCpCt'; idxs_Opts[key] = (Opts.riAddOpts[key](go)[0]\r\n                                           if Opts.values['bLimitMinCpCt']\r\n                                           else None)\r\n        key = 'bLimitMaxCpCt'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bMatchMaxCpCt'; idxs_Opts[key] = (Opts.riAddOpts[key](go)[0]\r\n                                           if Opts.values['bLimitMaxCpCt']\r\n                                           else None)\r\n        key = 'iMaxCpCt'; idxs_Opts[key] = (Opts.riAddOpts[key](go)\r\n                                           if (\r\n                                               Opts.values['bLimitMaxCpCt'] and\r\n                                               not Opts.values['bMatchDegree'])\r\n                                           else None)\r\n        key = 'bReplace'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        ## Use bPreselectedObjsChecked so that only objects before the\r\n        ## first call to go.GetMultiple is considered.\r\n        #if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n        #    bPreselectedObjsChecked = True\r\n        #    go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple(\r\n                    [objrefs]\r\n                    +\r\n                    [Opts.values[key] for key in Opts.keys])\r\n        else:\r\n            # An option was selected or a number was entered.\r\n            key = 'fDevTol'\r\n            if go.Option().Index == idxs_Opts['CrvFilter']:\r\n                setCurveFilter()\r\n            if res == ri.GetResult.Number:\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n            if Opts.riOpts[key].CurrentValue < 0.0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n\r\n            \r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            go.ClearCommandOptions()\r\n\r\n\r\ndef removeNesting(rgCrv0):\r\n    \"\"\"\r\n    Parameters:\r\n        rgCrv0: rg.PolylineCurve or rg.\r\n    Returns:\r\n        Success: Curves without nesting.\r\n        Fail or N/A: None\r\n    \"\"\"\r\n\r\n\r\n    def convertMonoSpanPolylineCrvToLineCrv(crv):\r\n        if isinstance(crv, rg.PolylineCurve):\r\n            if crv.PointCount == 2:\r\n                line = rg.Line(crv.PointAtStart, crv.PointAtEnd)\r\n                return rg.LineCurve(line)\r\n\r\n\r\n\r\n    sType_C0 = rgCrv0.GetType().Name\r\n\r\n    if not sType_C0 == 'PolyCurve' or sType_C0 == 'PolylineCurve':\r\n        return None\r\n\r\n    rgCrv_WIP = rgCrv0.DuplicateCurve()\r\n\r\n    if sType_C0 == 'PolylineCurve':\r\n        rc = convertMonoSpanPolylineCrvToLineCrv(rgCrv_WIP)\r\n        if rc:\r\n            rgCrv_WIP.Dispose()\r\n            return rc\r\n\r\n    elif sType_C0 == 'PolyCurve':\r\n        bNestingRemoved = rgCrv_WIP.RemoveNesting()\r\n\r\n        if rgCrv_WIP.SegmentCount == 1:\r\n            exploded = rgCrv0.Explode()[0]\r\n            rgCrv_WIP.Dispose()\r\n            rgCrv_WIP = exploded\r\n            rc = convertMonoSpanPolylineCrvToLineCrv(rgCrv_WIP)\r\n            if rc:\r\n                rgCrv_WIP.Dispose()\r\n                return rc\r\n\r\n        # Process each segment in polysegment PolyCurve.\r\n\r\n        bSuccess, pline = rgCrv_WIP.TryGetPolyline()\r\n        if bSuccess:\r\n            rgCrv_WIP.Dispose()\r\n            return pline.ToPolylineCurve()\r\n\r\n        segs_forOut = []\r\n        bNewSeg = False\r\n\r\n        for seg in rgCrv_WIP.DuplicateSegments():\r\n            rc = convertMonoSpanPolylineCrvToLineCrv(seg)\r\n            if rc:\r\n                seg.Dispose()\r\n                segs_forOut.append(rc)\r\n                bNewSeg = True\r\n            else:\r\n                segs_forOut.append(rgCrv_WIP)\r\n\r\n        if bNewSeg:\r\n            rgCrv_WIP.Dispose()\r\n            joined = rg.Curve.JoinCurves(segs_forOut)\r\n            if len(joined) != 1:\r\n                raise (ValueError (\"{} curves resulted from Curve.JoinCurves.\".format(\r\n                    len(joined))))\r\n            return joined\r\n        else:\r\n            for seg in segs_forOut: seg.Dispose()\r\n            if bNestingRemoved: return rgCrv_WIP\r\n\r\n    rgCrv_WIP.Dispose()\r\n\r\n\r\ndef doesCurvePassTypeFilter(rgCurve0, **kwargs):\r\n    \"\"\"\r\n    Returns: bool\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bProcessPolyCrv = getOpt('bProcessPolyCrv')\r\n    bProcessLinear = getOpt('bProcessLinear')\r\n    bProcessPolyline = getOpt('bProcessPolyline')\r\n    bProcessArc = getOpt('bProcessArc')\r\n    bProcessEllipse = getOpt('bProcessEllipse')\r\n    bProcessOtherRat = getOpt('bProcessOtherRat')\r\n    bProcessNonRatWithInternalPolyknot = getOpt('bProcessNonRatWithInternalPolyknot')\r\n    bProcessNonRatWithSomeFullPolyknot = getOpt('bProcessNonRatWithSomeFullPolyknot')\r\n    bProcessUniformNonRat = getOpt('bProcessUniformNonRat')\r\n    bProcessBezierNonRat = getOpt('bProcessBezierNonRat')\r\n    bProcessOtherNonRat = getOpt('bProcessOtherNonRat')\r\n\r\n\r\n    sType_c0 = rgCurve0.GetType().Name\r\n\r\n    if sType_c0 == 'PolyCurve':\r\n        if bProcessPolyCrv:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped PolyCurve.\"\r\n\r\n    if sType_c0 == 'LineCurve':\r\n        if bProcessLinear:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped LineCurve.\"\r\n\r\n    if sType_c0 == 'PolylineCurve':\r\n        if bProcessPolyline:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped PolylineCurve.\"\r\n\r\n    if sType_c0 == 'ArcCurve':\r\n        if bProcessArc:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped ArcCurve.\"\r\n\r\n    if rgCurve0.IsLinear(1e-6):\r\n        if bProcessLinear:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped linear {}.\".format(sType_c0)\r\n    \r\n    rc = xCurve.getArcCurve(\r\n            rgCrv0=rgCurve0,\r\n            bTolByRatio=False,\r\n            fTolRatio=None,\r\n            fDevTol=1e-9,\r\n            fMinNewCrvLen=100.0*sc.doc.ModelAbsoluteTolerance,\r\n            fMaxRadius=(1e6)*sc.doc.ModelAbsoluteTolerance)\r\n    if rc is not None and rc[0] is not None:\r\n        if bProcessArc:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped arc-shaped {}.\".format(sType_c0)\r\n\r\n    if sType_c0 == \"NurbsCurve\":\r\n        rc = xCurve.getEllipticalNurbsCurve(\r\n                rgCrv0=rgCurve0,\r\n                bTolByRatio=False,\r\n                fTolRatio=None,\r\n                fDevTol=1e-9,\r\n                fMinNewCrvLen=100.0*sc.doc.ModelAbsoluteTolerance,\r\n                fMaxRadius=(1e6)*sc.doc.ModelAbsoluteTolerance)\r\n        if rc is not None and rc[0] is not None:\r\n            if bProcessEllipse:\r\n                return True, None\r\n            else:\r\n                return False, \"Skipped elliptical-shaped {}.\".format(sType_c0)\r\n\r\n        if rgCurve0.IsRational:\r\n            if bProcessOtherRat:\r\n                return True, None\r\n            else:\r\n                return False, \"Skipped rational non-arc, non-elliptical NurbsCurve.\"\r\n\r\n\r\n        if xCurve.Nurbs.hasInternalPolyknots(rgCurve0):\r\n            if bProcessNonRatWithInternalPolyknot:\r\n                if not bProcessNonRatWithSomeFullPolyknot:\r\n                    return True, None\r\n                else:\r\n                    if xCurve.Nurbs.hasSomeFullyMultiplePolyknots(rgCurve0):\r\n                        return True, None\r\n                    else:\r\n                        return False, \"Skipped non-rational NurbsCurve containing some internal full polyknots.\"\r\n            else:\r\n                return False, \"Skipped non-rational NurbsCurve containing some internal polyknots\"\r\n\r\n\r\n        if xCurve.Nurbs.isUniform(rgCurve0):\r\n            if bProcessUniformNonRat:\r\n                if rgCurve0.SpanCount == 1:\r\n                    if bProcessBezierNonRat:\r\n                        return True, None\r\n                    else:\r\n                        return False, \"Skipped Bezier NurbsCurve.\"\r\n                else:\r\n                    return True, None\r\n            else:\r\n                return False, \"Skipped uniform NurbsCurve.\"\r\n\r\n        if bProcessOtherNonRat:\r\n            return True, None\r\n        else:\r\n            return False, \"Skipped other non-rational NurbsCurve.\"\r\n\r\n\r\ndef rebuildCurve(rgCurve0, fDevTol, iDegree=3, bPreserveEndG1=True, bPreserveEndG2=False, bFurtherTranslateCps=True, iMinCpCt=None, iMaxCpCt=20, bDebug=False):\r\n    \"\"\"\r\n    Returns tuple of 3 values:\r\n        On success: rg.NurbsCurve, float(Max. deviation), None\r\n        On fail:\r\n            None, float(Last deviation calculated (required deviation), None\r\n            None, None, str(Feedback)\r\n    \"\"\"\r\n    \r\n    sCrvType = rgCurve0.GetType().Name\r\n    \r\n    if sCrvType == \"NurbsCurve\":\r\n        nc_In = rgCurve0.Duplicate()\r\n    else:\r\n        nc_In = rgCurve0.ToNurbsCurve()\r\n    \r\n    if not nc_In:\r\n        return None, None, \"NurbsCurve could not be constructed from {}.\".format(rgCurve0)\r\n    \r\n    if iDegree < 0:\r\n        iDegs = nc_In.Degree,\r\n    elif not iDegree:\r\n        iDegs = 3, 5\r\n    else:\r\n        iDegs = iDegree,\r\n    \r\n    if bDebug: sEval = 'iDegs'; print(sEval + ':', eval(sEval))\r\n\r\n\r\n    if 1 in iDegs:\r\n        if nc_In.IsClosed:\r\n            return None, None, \"Skip closed curve for Degree 1 conversion.\"\r\n\r\n\r\n        # Attempt to replace curve with a line.\r\n        # Don't Rebuild a degree 1 curve with more than 2 control points\r\n        # because smooth curves, not polylines, should be the geometry output of this function.\r\n        nc_Out = nc_In.Rebuild(\r\n                pointCount=2,\r\n                degree=1,\r\n                preserveTangents=False)\r\n        #\r\n\r\n\r\n        if nc_Out is None:\r\n            return None, None, \"Could not rebuild curve to a 2-point degree 1.\"\r\n\r\n\r\n        rc = spb_Crv_deviation.isMaxClosestDistBtwn2CrvsWithinTol(\r\n            nc_In,\r\n            nc_Out,\r\n            tolerance=fDevTol)\r\n        if rc is not False:\r\n            dev = rc\r\n            return nc_Out, dev, None\r\n\r\n\r\n    ct_cp = (iDegs[0] + 1 if not iMinCpCt\r\n             else (iMinCpCt if iMinCpCt >= iDegs[0] + 1 else iDegs[0] + 1))\r\n\r\n    if iMaxCpCt > 0:\r\n        if iMaxCpCt < ct_cp:\r\n            return None, None, \"Minimum control point count for curve degree already exceeds maximum allowed.\"\r\n    elif iMaxCpCt == -1: \r\n        iMaxCpCt = nc_In.Points.Count\r\n\r\n    dev = None\r\n\r\n    while True:\r\n        if sc.escape_test(False):\r\n            s  = \"Script stopped at iteration {}\".format(ct_cp)\r\n            s += \" with last deviation of {}.\".format(dev)\r\n            return None, dev, s\r\n        \r\n        for iDeg in iDegs:\r\n\r\n            if ct_cp < iDeg + 1: continue\r\n\r\n            if iMaxCpCt == 0 and ct_cp > nc_In.Points.Count:\r\n                if sCrvType == \"NurbsCurve\" and xCurve.Nurbs.isUniform(nc_In):\r\n                    pass\r\n                elif sCrvType == \"PolyCurve\":\r\n                    pass\r\n                else:\r\n                    return None, dev, None\r\n            elif iMaxCpCt > 0 and ct_cp > iMaxCpCt:\r\n                return None, dev, None\r\n\r\n\r\n            if bDebug:\r\n                sEval = 'ct_cp'; print(sEval + ':', eval(sEval),)\r\n                sEval = 'iDeg'; print(sEval + ':', eval(sEval))\r\n\r\n            #\r\n            #\r\n            nc_Out = nc_In.Rebuild(\r\n                    pointCount=ct_cp,\r\n                    degree=iDeg,\r\n                    preserveTangents=bPreserveEndG1)\r\n            #\r\n            #\r\n\r\n\r\n            if bPreserveEndG2:\r\n                bSuccess = nc_Out.SetEndCondition(\r\n                    bSetEnd=False,\r\n                    continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Curvature,\r\n                    point=nc_Out.PointAtStart,\r\n                    tangent=nc_In.TangentAtStart,\r\n                    curvature=nc_In.CurvatureAt(nc_In.Domain.T0))\r\n                if not bSuccess:\r\n                    print(\"SetEndCondition failed.\")\r\n                bSuccess = nc_Out.SetEndCondition(\r\n                    bSetEnd=True,\r\n                    continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Curvature,\r\n                    point=nc_Out.PointAtEnd,\r\n                    tangent=nc_In.TangentAtEnd,\r\n                    curvature=nc_In.CurvatureAt(nc_In.Domain.T1))\r\n                if not bSuccess:\r\n                    print(\"SetEndCondition failed.\")\r\n\r\n\r\n            if bFurtherTranslateCps:\r\n                rc = spb_NurbsCrv_fitByTranslatingControlPts.fitCurve(\r\n                        nc_Out,\r\n                        rgCurve0,\r\n                        bPreserveEndTans=bPreserveEndG1,\r\n                        bDebug=bDebug)\r\n                if rc is not None:\r\n                    nc_Out.Dispose()\r\n                    nc_Out = rc\r\n\r\n\r\n            rc = spb_Crv_deviation.isMaxClosestDistBtwn2CrvsWithinTol(\r\n                nc_In,\r\n                nc_Out,\r\n                tolerance=fDevTol)\r\n            if rc is not False:\r\n                dev = rc\r\n                return nc_Out, dev, None\r\n\r\n            # To next degree.\r\n        \r\n        # To next control point count increment.\r\n\r\n        ct_cp += 1\r\n\r\n\r\ndef rebuildPolyCurveSegments(rgPolyCrv0, fDevTol, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    iDegree = getOpt('iDegree')\r\n    bPreserveEndG1 = getOpt('bPreserveEndG1')\r\n    bPreserveEndG2 = getOpt('bPreserveEndG2')\r\n    bFurtherTranslateCps = getOpt('bFurtherTranslateCps')\r\n    iMinCpCt = getOpt('iMinCpCt')\r\n    iMaxCpCt = getOpt('iMaxCpCt')\r\n\r\n    bProcessLinear = getOpt('bProcessLinear')\r\n    bProcessPolyline = getOpt('bProcessPolyline')\r\n    bProcessArc = getOpt('bProcessArc')\r\n    bProcessEllipse = getOpt('bProcessEllipse')\r\n    bProcessOtherRat = getOpt('bProcessOtherRat')\r\n    bProcessNonRatWithInternalPolyknot = getOpt('bProcessNonRatWithInternalPolyknot')\r\n    bProcessNonRatWithSomeFullPolyknot = getOpt('bProcessNonRatWithSomeFullPolyknot')\r\n    bProcessUniformNonRat = getOpt('bProcessUniformNonRat')\r\n    bProcessBezierNonRat = getOpt('bProcessBezierNonRat')\r\n    bProcessOtherNonRat = getOpt('bProcessOtherNonRat')\r\n\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if not(rgPolyCrv0, rg.PolyCurve): return None, [], [], s\r\n\r\n    rc = removeNesting(rgPolyCrv0)\r\n\r\n    pc_WIP = rc if rc else rgPolyCrv0.DuplicateCurve()\r\n\r\n\r\n    segs_forOut = []\r\n    devs_Pass = []\r\n    devs_Fail = []\r\n    sLogs = []\r\n\r\n    bSomeRebuilt = False # Could also be determined by comparing sFails and segment counts.\r\n\r\n    for iSeg, seg_In in enumerate(pc_WIP.DuplicateSegments()):\r\n        if bDebug: sEval = 'iSeg'; print(sEval+':',eval(sEval))\r\n        if iSeg == 2:\r\n            pass\r\n\r\n        bPass, sLog = doesCurvePassTypeFilter(\r\n            rgCurve0=seg_In,\r\n            bProcessPolyCrv=True,\r\n            bProcessLinear=bProcessLinear,\r\n            bProcessPolyline=bProcessPolyline,\r\n            bProcessArc=bProcessArc,\r\n            bProcessEllipse=bProcessEllipse,\r\n            bProcessOtherRat=bProcessOtherRat,\r\n            bProcessNonRatWithInternalPolyknot=bProcessNonRatWithInternalPolyknot,\r\n            bProcessNonRatWithSomeFullPolyknot=bProcessNonRatWithSomeFullPolyknot,\r\n            bProcessUniformNonRat=bProcessUniformNonRat,\r\n            bProcessBezierNonRat=bProcessBezierNonRat,\r\n            bProcessOtherNonRat=bProcessOtherNonRat,\r\n            )\r\n        if not bPass:\r\n            segs_forOut.append(seg_In.Duplicate())\r\n            sLogs.append(sLog)\r\n            continue\r\n\r\n\r\n        ##\r\n        seg_forOut, dev, sLog = rebuildCurve(\r\n                rgCurve0=seg_In,\r\n                fDevTol=fDevTol,\r\n                iDegree=iDegree,\r\n                bPreserveEndG1=bPreserveEndG1,\r\n                bPreserveEndG2=bPreserveEndG2,\r\n                bFurtherTranslateCps=bFurtherTranslateCps,\r\n                iMinCpCt=iMinCpCt,\r\n                iMaxCpCt=iMaxCpCt,\r\n                bDebug=bDebug,\r\n                )\r\n        ##\r\n\r\n\r\n        if seg_forOut is None:\r\n            segs_forOut.append(seg_In.Duplicate())\r\n            if sLog is not None:\r\n                sLogs.append(sLog)\r\n            elif dev is not None:\r\n                devs_Fail.append(dev)\r\n        else:\r\n            # Success.\r\n            segs_forOut.append(seg_forOut)\r\n            devs_Pass.append(dev)\r\n            if sLog:\r\n                sLogs.append(sLog)\r\n            else:\r\n                sLogs.append(\"Replaced segment.\")\r\n            bSomeRebuilt = True\r\n\r\n\r\n    if not bSomeRebuilt:\r\n        return None, devs_Pass, devs_Fail, sLogs\r\n\r\n    joined = rg.Curve.JoinCurves(segs_forOut)\r\n\r\n    for c in segs_forOut: c.Dispose()\r\n\r\n    if len(joined) != 1:\r\n        s = \"JoinCurves returned {} curves.  They are discarded\".format(len(joined))\r\n        for c in joined: c.Dispose()\r\n        return None, [], [], [s]\r\n\r\n    return joined[0], devs_Pass, devs_Fail, sLogs\r\n\r\n\r\ndef processCurves(curvesAndEdges0, **kwargs):\r\n    \"\"\"\r\n    curvesAndEdges0 = (GUIDs of CurveObjects) or BrepEdges\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    iDegree = getOpt('iDegree')\r\n    bPreserveEndG1 = getOpt('bPreserveEndG1')\r\n    bPreserveEndG2 = getOpt('bPreserveEndG2')\r\n    bFurtherTranslateCps = getOpt('bFurtherTranslateCps')\r\n    iMinCpCt = getOpt('iMinCpCt')\r\n    iMaxCpCt = getOpt('iMaxCpCt')\r\n\r\n    bProcessPolyCrv = getOpt('bProcessPolyCrv')\r\n    bProcessPolyCrvSegs = getOpt('bProcessPolyCrvSegs')\r\n    bProcessLinear = getOpt('bProcessLinear')\r\n    bProcessPolyline = getOpt('bProcessPolyline')\r\n    bProcessArc = getOpt('bProcessArc')\r\n    bProcessEllipse = getOpt('bProcessEllipse')\r\n    bProcessOtherRat = getOpt('bProcessOtherRat')\r\n    bProcessNonRatWithInternalPolyknot = getOpt('bProcessNonRatWithInternalPolyknot')\r\n    bProcessNonRatWithSomeFullPolyknot = getOpt('bProcessNonRatWithSomeFullPolyknot')\r\n    bProcessUniformNonRat = getOpt('bProcessUniformNonRat')\r\n    bProcessBezierNonRat = getOpt('bProcessBezierNonRat')\r\n    bProcessOtherNonRat = getOpt('bProcessOtherNonRat')\r\n\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n    def formatDistance(fDistance):\r\n        if fDistance is None:\r\n            return \"(No deviation provided)\"\r\n        elif fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-3)):\r\n            return \"{:.2e}\".format(fDistance)\r\n        else:\r\n            return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\n    def stringOutput(rgCrv0, rgCrv_Res, crv_dev):\r\n    \r\n        s = \"Original curve is a {}.\".format(rgCrv0.GetType().Name)\r\n    \r\n        # Uncomment this only if needed:\r\n        #    if not rgNurbsCrv0:\r\n        #        s += \"\\nNurbsCurve could not be constructed from {}.\".format(curveOrEdge0)\r\n        #        s += \"  Input vs. output will not be stated.\"\r\n        #        return s\r\n    \r\n        if rgCrv_Res:\r\n            sType_Crv_Res = rgCrv_Res.GetType().Name\r\n            \r\n            if sType_Crv_Res == 'NurbsCurve':\r\n                nc0 = rgCrv0.ToNurbsCurve()\r\n            \r\n            if sType_Crv_Res == 'NurbsCurve':\r\n                s += \"  Prop:I,O\"\r\n                s += \"  {}:{},{}\".format(\"Deg\", nc0.Degree, rgCrv_Res.Degree)\r\n                s += \"  {}:{},{}\".format(\"PtCt\", nc0.Points.Count, rgCrv_Res.Points.Count)\r\n                s += \"  {}:{},{}\".format(\"IsUniform\",\r\n                        str(xCurve.Nurbs.isUniform(nc0))[0],\r\n                        str(xCurve.Nurbs.isUniform(rgCrv_Res))[0])\r\n                s += \"  {}:{},{}\".format(\"IsRational\",\r\n                        str(nc0.IsRational)[0],\r\n                        str(rgCrv_Res.IsRational)[0])\r\n                s += \"  {}:{},{}\".format(\"IsClosed\",\r\n                        str(nc0.IsClosed)[0],\r\n                        str(rgCrv_Res.IsClosed)[0])\r\n                if nc0.IsClosed or rgCrv_Res.IsClosed:\r\n                    s += \"  {}:{},{}\".format(\"IsPeriodic\",\r\n                            str(nc0.IsPeriodic)[0],\r\n                            str(rgCrv_Res.IsPeriodic)[0])\r\n        \r\n            nc0.Dispose()\r\n        \r\n            if crv_dev:\r\n                s += \"  Deviation: {}\".format(formatDistance(crv_dev))\r\n            else:\r\n                s += \"  Curve deviation cannot be calculated!\"\r\n    \r\n        else:\r\n            s = \"Curve could not be created using entered parameters.\"\r\n\r\n        return s\r\n\r\n\r\n    rdCs_In = []\r\n    gCrvs0 = []\r\n    for curveOrEdge0 in curvesAndEdges0:\r\n        rdC_In = rs.coercerhinoobject(curveOrEdge0)\r\n        rdCs_In.append(rdC_In)\r\n        gC_In = rdC_In.Id\r\n        if gC_In:\r\n            gCrvs0.append(gC_In)\r\n\r\n    rgCrv_Res = None\r\n\r\n    gCrvs0_Replaced = []\r\n    gCrvs_Added = []\r\n    devs_all = []\r\n    \r\n    fTols_needed = []\r\n    sFails = []\r\n\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*len(rdCs_In),0)) for i in range(10)]\r\n    \r\n    for iC, rdC_In in enumerate(rdCs_In):\r\n        if iC in idxs_AtTenths:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                \"Processing curve {} ...\".format(\r\n                    \"\" if len(rdCs_In) == 1 else \"{} of {} \".format(\r\n                        iC+1, len(rdCs_In))))\r\n\r\n        rgCrv0 = rdC_In.Geometry\r\n        #rgCrv0 = rs.coercecurve(curveOrEdge0) # Returns various rg.Curves, including BrepEdge.\r\n        if rgCrv0 is None:\r\n            sFails.append(\"Geometry for {} not found!\".format(rgCrv0))\r\n            if bDebug: print(sLog)\r\n            continue\r\n\r\n        bCrvIsEdge = isinstance(rgCrv0, rg.BrepEdge)\r\n\r\n        if bCrvIsEdge:\r\n            rgCrv0 = curveOrEdge0.EdgeCurve # This is for curve type checking.\r\n\r\n        gCrv0 = None if bCrvIsEdge else rdC_In.Id\r\n\r\n        sType_Crv0 = rgCrv0.GetType().Name\r\n\r\n        rc = removeNesting(rgCrv0)\r\n        if rc:\r\n            rgCrv0.Dispose()\r\n            rgCrv0 = rc\r\n\r\n        bPass, sLog = doesCurvePassTypeFilter(\r\n            rgCurve0=rgCrv0,\r\n            bProcessPolyCrv=bProcessPolyCrv,\r\n            bProcessLinear=bProcessLinear,\r\n            bProcessPolyline=bProcessPolyline,\r\n            bProcessArc=bProcessArc,\r\n            bProcessEllipse=bProcessEllipse,\r\n            bProcessOtherRat=bProcessOtherRat,\r\n            bProcessNonRatWithInternalPolyknot=bProcessNonRatWithInternalPolyknot,\r\n            bProcessNonRatWithSomeFullPolyknot=bProcessNonRatWithSomeFullPolyknot,\r\n            bProcessUniformNonRat=bProcessUniformNonRat,\r\n            bProcessBezierNonRat=bProcessBezierNonRat,\r\n            bProcessOtherNonRat=bProcessOtherNonRat,\r\n            )\r\n        if not bPass:\r\n            sFails.append(sLog)\r\n            if bDebug: print(sLog)\r\n            continue\r\n    \r\n        if bDebug: print(\"Original curve is a {}    {}.\".format(rgCrv0.GetType().Name, gCrv0))\r\n\r\n\r\n        ##\r\n\r\n        if sType_Crv0 == 'PolyCurve' and bProcessPolyCrvSegs:\r\n            rc = rebuildPolyCurveSegments(\r\n                    rgPolyCrv0=rgCrv0,\r\n                    fDevTol=fDevTol,\r\n                    iDegree=iDegree,\r\n                    bPreserveEndG1=bPreserveEndG1,\r\n                    bPreserveEndG2=bPreserveEndG2,\r\n                    bFurtherTranslateCps=bFurtherTranslateCps,\r\n                    iMinCpCt=iMinCpCt,\r\n                    iMaxCpCt=iMaxCpCt,\r\n                    bProcessLinear=bProcessLinear,\r\n                    bProcessPolyline=bProcessPolyline,\r\n                    bProcessArc=bProcessArc,\r\n                    bProcessEllipse=bProcessEllipse,\r\n                    bProcessOtherRat=bProcessOtherRat,\r\n                    bProcessNonRatWithInternalPolyknot=bProcessNonRatWithInternalPolyknot,\r\n                    bProcessNonRatWithSomeFullPolyknot=bProcessNonRatWithSomeFullPolyknot,\r\n                    bProcessUniformNonRat=bProcessUniformNonRat,\r\n                    bProcessBezierNonRat=bProcessBezierNonRat,\r\n                    bProcessOtherNonRat=bProcessOtherNonRat,\r\n                    bDebug=bDebug,\r\n                    )\r\n            rgCrv_Res, devs_Pass, devs_Fail, sLogs = rc\r\n            sFails.extend(sLogs)\r\n            if rgCrv_Res is None:\r\n                if bDebug: print(sLog)\r\n                continue\r\n            else:\r\n                s  = \"{} segments replaced.\".format(len(devs_Pass))\r\n                s += \"  {} segments not replaced.\".format(len(devs_Fail))\r\n                if devs_Fail:\r\n                    s += \"  Last deviations ranged [{}, {}].\".format(\r\n                        formatDistance(min(devs_Fail)),\r\n                        formatDistance(max(devs_Fail)),\r\n                        )\r\n                devs_all.extend(devs_Pass)\r\n                dev = max(devs_all) if devs_all else None\r\n                fTols_needed.extend(devs_Fail)\r\n            sSummary = None\r\n        else:\r\n            rgCrv_Res, dev, sLog = rebuildCurve(\r\n                rgCurve0=rgCrv0,\r\n                fDevTol=fDevTol,\r\n                iDegree=iDegree,\r\n                bPreserveEndG1=bPreserveEndG1,\r\n                bPreserveEndG2=bPreserveEndG2,\r\n                bFurtherTranslateCps=bFurtherTranslateCps,\r\n                iMinCpCt=iMinCpCt,\r\n                iMaxCpCt=iMaxCpCt,\r\n                bDebug=bDebug,\r\n                )\r\n\r\n            if bDebug or len(curvesAndEdges0) == 1:\r\n                sSummary = stringOutput(rgCrv0, rgCrv_Res, dev)\r\n\r\n            if rgCrv_Res is None:\r\n                if sLog is not None:\r\n                    sFails.append(sLog)\r\n                    if bDebug: print(sLog)\r\n                elif dev is not None:\r\n                    fTols_needed.append(dev)\r\n                    if bDebug:\r\n                        s  = \"Curve could not be Rebuilt within {}.\".format(formatDistance(fDevTol))\r\n                        s += \"  Last deviation was {}.\".format(formatDistance(dev))\r\n                        print(s)\r\n                continue\r\n\r\n            # Success.\r\n            devs_all.append(dev)\r\n\r\n\r\n        if bReplace and not bCrvIsEdge:\r\n            bReplaced = sc.doc.Objects.Replace(objectId=gCrv0, curve=rgCrv_Res)\r\n            if not bReplaced:\r\n                s = \"Curve could not be replaced.\"\r\n                rgCrv_Res.Dispose()\r\n                sFails.append(s)\r\n                if bDebug: print(s)\r\n            else:\r\n                if bDebug and sSummary: print(sSummary)\r\n                rgCrv_Res.Dispose()\r\n                gCrvs0_Replaced.append(gCrv0)\r\n        else:\r\n            gCrv_Res = sc.doc.Objects.AddCurve(rgCrv_Res)\r\n            if gCrv_Res != Guid.Empty:\r\n                if bReplace and bCrvsAdded and not bCrvIsEdge:\r\n                    sc.doc.Objects.Delete(curveOrEdge0, True)\r\n                if bDebug and sSummary: print(sSummary)\r\n                rgCrv_Res.Dispose()\r\n                gCrvs_Added.append(gCrv_Res)\r\n            else:\r\n                s = \"Curve could not be added.\"\r\n                rgCrv_Res.Dispose()\r\n                sFails.append(s)\r\n                if bDebug: print(s)\r\n\r\n\r\n    if not bEcho: return gCrvs0_Replaced, gCrvs_Added\r\n\r\n\r\n    # Output summary.\r\n\r\n    if len(curvesAndEdges0) == 1:\r\n        if sType_Crv0 == 'PolyCurve' and bProcessPolyCrvSegs:\r\n            s = \"Out of {} polycurve segments:\".format(rgCrv0.SegmentCount)\r\n            for sFail in set(sFails):\r\n                s += \"\\n[{}] {}\".format(sFails.count(sFail), sFail)\r\n            if fTols_needed:\r\n                s += \"\\n[{}] Segments not rebuilt within tolerance.\".format(len(fTols_needed))\r\n                s += \"  Tolerances needed: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                        min(fTols_needed), max(fTols_needed), 2)\r\n            if gCrvs0_Replaced:\r\n                s += \"\\nPolyCurve was replaced.\"\r\n                s += \"  Segment deviations: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                        min(devs_all), max(devs_all), 2)\r\n            if gCrvs_Added:\r\n                s += \"\\nPolyCurve was added.\"\r\n                s += \"  Segment deviations: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                        min(devs_all), max(devs_all), 2)\r\n        else:\r\n            if rgCrv_Res is None and sFails: print(sFails[0])\r\n            elif bEcho and sSummary: print(sSummary)\r\n            s = \"\"\r\n            if fTols_needed:\r\n                s += \"Curve could not be rebuilt within tolerance.\"\r\n                s += \"  Tolerance needed: {:.{}e}\".format(fTols_needed[0], 2)\r\n            if gCrvs0_Replaced:\r\n                s += \"Curve was replaced\"\r\n                s += \" at a deviation of {:.{}e}.\".format(devs_all[0], 2)\r\n            if gCrvs_Added:\r\n                s += \"Curve was added\"\r\n                s += \" at a deviation of {:.{}e}.\".format(devs_all[0], 2)\r\n    else:\r\n        s = \"Out of {} total curves:\".format(len(curvesAndEdges0))\r\n        for sFail in set(sFails):\r\n            s += \"\\n[{}] {}\".format(sFails.count(sFail), sFail)\r\n        if fTols_needed:\r\n            s += \"\\n[{}] Curve not rebuilt within tolerance.\".format(len(fTols_needed))\r\n            s += \"  Tolerances needed: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                    min(fTols_needed), max(fTols_needed), 2)\r\n        if gCrvs0_Replaced:\r\n            s += \"\\n{} curves were replaced.\".format(len(gCrvs0_Replaced))\r\n            s += \"  Deviations: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                    min(devs_all), max(devs_all), 2)\r\n        if gCrvs_Added:\r\n            s += \"\\n{} curves were added.\".format(len(gCrvs_Added))\r\n            s += \"  Deviations: [{0:.{2}e} through {1:.{2}e}]\".format(\r\n                    min(devs_all), max(devs_all), 2)\r\n        if not (gCrvs0_Replaced or gCrvs_Added):\r\n            s += \"\\nNo curves were added or replaced.\"\r\n\r\n    print(s)\r\n\r\n\r\n    return gCrvs0_Replaced, gCrvs_Added\r\n\r\n\r\ndef main():\r\n\r\n    gCrvs0_Preselected = getPreselectedCurves()\r\n\r\n    dialog = FitRebuildCurveDialog()\r\n    if not dialog.ShowModal(Rhino.UI.RhinoEtoApp.MainWindow): return\r\n\r\n\r\n    if gCrvs0_Preselected:\r\n        objrefs = None\r\n    else:\r\n        rc = getInput()\r\n        if rc is None: return\r\n        objrefs = rc[0]\r\n\r\n    \r\n    if Opts.values['bDebug']:\r\n        pass\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    gCrvs0_Replaced, gNurbsCrvs1 = None, None\r\n\r\n    if Opts.values['bLimitDegree']:\r\n        if Opts.values['bMatchDegree']:\r\n            iDegree = -1\r\n        else:\r\n            iDegree = Opts.values['iDegree']\r\n    else:\r\n        iDegree = None\r\n\r\n    if Opts.values['bLimitMinCpCt']:\r\n        iMinCpCt = Opts.values['iMinCpCt']\r\n    else:\r\n        iMinCpCt = None\r\n\r\n    if Opts.values['bLimitMaxCpCt']:\r\n        if Opts.values['bMatchMaxCpCt']:\r\n            iMaxCpCt = -1\r\n        else:\r\n            iMaxCpCt = Opts.values['iMaxCpCt']\r\n    else:\r\n        iMaxCpCt = None\r\n\r\n    rc = processCurves(\r\n        curvesAndEdges0=gCrvs0_Preselected if gCrvs0_Preselected else objrefs,\r\n        fDevTol=Opts.values['fDevTol'],\r\n        iDegree=iDegree,\r\n        iMinCpCt=iMinCpCt,\r\n        iMaxCpCt=iMaxCpCt,\r\n        )\r\n    if rc is not None:\r\n        gCrvs0_Replaced, gNurbsCrvs1 = rc\r\n    \r\n    if gCrvs0_Preselected:\r\n        [sc.doc.Objects.Select(objectId=_) for _ in gCrvs0_Preselected]\r\n    else:\r\n        if gCrvs0_Replaced:\r\n            [sc.doc.Objects.Select(objectId=_) for _ in gCrvs0_Replaced]\r\n        if gNurbsCrvs1:\r\n            [sc.doc.Objects.Select(objectId=_) for _ in gNurbsCrvs1]\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}