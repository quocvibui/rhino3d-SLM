{
  "source_url": "https://discourse.mcneel.com/t/chaos-game-rhinopython/137460",
  "topic_id": 137460,
  "title": "Chaos game rhinopython",
  "question": "Hi there! I am trying to generate chaos game code in rhinopython. I am trying to create something similar in photo that i uploaded. I was able to find this python code for chaos game but i don’t know how to implement this to rhinopython. Any ideas? Thanks in advance.\n\n\nimport pygame\n\nimport random\n\nimport math\n\nimport colorsys\n\nfrom pygame.locals import *\n\n\nidx = [0, 0, 0]\n\n\ndef mark_pixel(surface, pos, pcol):\n\ncol = surface.get_at(pos)\n\nsurface.set_at(pos, (min(col[0] + pcol[0]/10, 255),\n\nmin(col[1] + pcol[1]/10, 255),\n\nmin(col[2] + pcol[2]/10, 255)))\n\n\ndef random_point_index(p):\n\nglobal idx\n\nidx[2] = idx[1]\n\nidx[1] = idx[0]\n\ndst1 = abs(idx[1] - idx[2])\n\n\nwhile True:\n    idx[0] = random.randint(0, len(p) - 1)\n    dst = abs(idx[0] - idx[1])\n    if dst1 == 0 and (dst == 1 or dst == len(p) - 1):\n        continue\n    else:\n        break\n\nreturn idx[0]\n\n\n\ndef init_polygon(width, height, n):\n\ndelta_angle = 360/n\n\nr = width/2 - 10\n\np = \n\n\nfor i in range(0, n):\n    angle = (180 + i*delta_angle) * math.pi / 180\n    color = colorsys.hsv_to_rgb((i*delta_angle)/360, 0.8, 1)\n    p.append(((width/2 + r*math.sin(angle),\n               height/2 + r*math.cos(angle)),\n              (int(color[0]*255), int(color[1]*255), int(color[2]*255))))\nreturn p\n\n\n\ndef main(width, height, n, r):\n\npygame.init()\n\nsurface = pygame.display.set_mode((width, height))\n\npygame.display.set_caption(‘Das Chaos Spiel’)\n\n\np = init_polygon(width, height, n)\n\nx, y = (400, 300)\nfor i in range(0, width*height*3):\n    i = random_point_index(p)\n    x += (p[i][0][0] - x) * r\n    y += (p[i][0][1] - y) * r\n\n    mark_pixel(surface, (int(x), int(y)), p[i][1])\n    if i % 1000 == 0:\n        pygame.display.update()\n\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            return\n\npygame.image.save(surface, 'chaosspiel.jpg')\npygame.quit()\n\n\n\nif \nname\n == “\nmain\n”:\n\nmain(500, 500, 5, 0.45)\n\n\n\n\nScreen Shot 2022-02-04 at 21.39.52\n1854×696 169 KB",
  "code_blocks": [
    {
      "code": "\"\"\"chaos_game_rhino.py: Chaos Game Rhino implementation inspired by Daniel Shiffman's approach in Processing from Coding Train on YouTube.\"\"\"\n\n__author__ = \"diff-arch (diff-arch.xyz)\"\n__version__ = \"0.2.0b (2022-02-06)\"\n\n\nfrom scriptcontext import sticky\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport random\nimport math\n\n\nclass ChaosGame:\n    def __init__(self, update_speed=1, randomize=False):\n        self.width = 500\n        self.height = 500\n        self.update_speed = int(update_speed)  # default 1 equals real time\n        self.randomize = randomize\n        self.percent = 0.5  # percentile of the distance between two points (usually 0.5 for the center)\n        self.num_init_pts = 3\n        self.init_pts = []  # initial needle points\n        self.per_pts = [[] for i in xrange(self.num_init_pts)]\n        self.curr_pt = rg.Point3d(random.uniform(0.0, self.width), random.uniform(0.0, self.height), 0.0)\n        self.prev_pt = rg.Point3d(0.0, 0.0, 0.0)\n        \n    def setup(self):\n\t\tif len(self.init_pts) == 0:\n\t\t\tif self.randomize: \n\t            # Randomly distribute the initial points\n\t\t\t\tfor i in xrange(self.num_init_pts):\n\t\t\t\t\tpt = rg.Point3d(random.uniform(0.0, self.width), random.uniform(0.0, self.height), 0.0)\n\t\t\t\t\tself.init_pts.append(pt)\n\t\t\telse:\n\t\t\t\t# Distribute the initial points around a circle\n\t\t\t\tradius = min(self.width, self.height) / 2\n\t\t\t\ttheta = (2 * math.pi) / 3\n\t\t\t\tfor i in xrange(self.num_init_pts):\n\t\t\t\t\tdelta = theta * i + math.pi / 2\n\t\t\t\t\tpt = rg.Point3d(math.cos(delta) * radius, math.sin(delta) * radius, 0)\n\t\t\t\t\tself.init_pts.append(pt)\n    \n    def update(self):\n        for i in xrange(self.update_speed):  # update conditionless (without rules)\n            r = random.randint(0, self.num_init_pts-1)\n            next_pt = self.init_pts[r]\n        \n            if sum([len(lt) for lt in self.per_pts]) == 0: # first update\n                per_pt = (next_pt + self.curr_pt) * self.percent\n            else: # other updates\n                per_pt = (next_pt + self.curr_pt) * self.percent\n        \n            self.curr_pt = per_pt\n            self.per_pts[r].append(per_pt)\n\n\n##################################################################################            \n\n\nif __name__ == \"__main__\":\n\t\n\t#Get user input\n\tcount = rs.GetInteger(\"Number of Iterations\", 500, 1)\n\tspeed = rs.GetInteger(\"Update Speed\", 15, 1)\n\trandomize = rs.GetBoolean(\"Randomize Sierpinski Needle Points\", [(\"Randomize\", \"Off\", \"On\")], (False))[0]\n\t\n    # Initialize Chaos Game\n\tcg = ChaosGame(speed, randomize)\n\tcg.setup()\n\tcurr_pts = cg.init_pts\n\t\n\t# Bake the intial points to rhino\n\tfor i in xrange(len(curr_pts)):\n\t\trs.AddPoint(curr_pts[i])\n\trs.Redraw()\n\t\n\t# Update Chaos Game\n\tfor i in xrange(count):\n\t\tcg.update()\n\t\n\t# Bake the Chaos Game points to Rhino\n\trs.EnableRedraw(False)\n\tcurr_pts = cg.per_pts\n\tfor i in xrange(len(curr_pts)):\n\t\tfor pt in curr_pts[i]:\n\t\t\trs.AddPoint(pt)\n\trs.EnableRedraw(True)",
      "language": "python",
      "author": "diff-arch",
      "post_number": 6,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 5,
  "views": 975
}