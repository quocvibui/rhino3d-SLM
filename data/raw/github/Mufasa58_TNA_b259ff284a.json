{
  "source_url": "https://github.com/Mufasa58/TNA/blob/49dfff99579f489c3179470ce8507bbb849e1226/thrust_1_bundled.py",
  "repo": "Mufasa58/TNA",
  "repo_stars": 0,
  "repo_description": "Compas_TNA and Rhino Models and Scripts",
  "license": "unknown",
  "filepath": "thrust_1_bundled.py",
  "instruction": "Funicular Floor System — COMPAS-TNA scripted design engine (Rhino 8, Python 3.9)",
  "code": "\"\"\"\nFunicular Floor System — COMPAS-TNA scripted design engine (Rhino 8, Python 3.9)\n\nThis file is self-contained and intended to be imported + executed via a Rhino \"runner\" script.\n\nCore phases:\n0) Setup\n1) Topology: grid mesh -> FormDiagram\n2) Supports at column grid intersections\n3) Uniform nodal loads (pz = -w)\n4) Equilibrium: horizontal_nodal + vertical_from_zmax\n5) Visualization: decimated form + force diagram + seams\n6) Metrics: edge-force proxy + reaction proxy + seam \"traffic\" proxy\n\nSegmentation (per 7x7 bay):\n- 9-piece pattern: 1 center + 4 corners + 4 mid-edge pieces\n- Seam pattern is rotated to be oblique to local compression flow direction\n- Computes a \"joint traffic\" metric: sum(|edge force|) for edges crossing seams (per bay)\n\nNotes (academic honesty):\n- TNA gives membrane thrust equilibrium, not plate bending moments.\n- Seam traffic is a proxy for joint shear/bending risk; full FE shell/plate validation is a later step.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom typing import Dict, Tuple, List\n\nimport Rhino\nimport scriptcontext as sc\nimport System.Drawing as SD\n\nfrom compas.datastructures import Mesh\nfrom compas_tna.diagrams import FormDiagram, ForceDiagram\nfrom compas_tna.equilibrium import horizontal_nodal, vertical_from_zmax\n\n\n# ==============================================================================\n# Parameters (single source of truth)\n# ==============================================================================\n\nPARAMS: Dict[str, float] = {\n    # Geometry\n    \"bay\": 7.0,                 # [m]\n    \"bays_x\": 3,\n    \"bays_y\": 3,\n    \"subdiv_per_bay\": 20,        # <-- requested: dx = bay/subdiv = 0.1m\n    \"zmax\": 2.0,                # [m] target max height for lifting\n\n    # Loads\n    \"w\": 10.0,                  # abstract nodal load magnitude (downwards)\n\n    # Solver\n    \"kmax_hor\": 200,\n    \"alpha\": 100.0,\n\n    # Drawing\n    \"layer_form\": \"TNA_FORM\",\n    \"layer_force\": \"TNA_FORCE\",\n    \"layer_seams\": \"TNA_SEAMS\",\n    \"draw_vertices\": False,     # points are very heavy at high resolution\n    \"draw_form_as_mesh\": True,  # draw form as single Rhino mesh (fast + clean)\n    \"draw_form_edges\": False,   # turn off edge-line drawing\n    \"draw_force_edges\": False,  # force diagram off for now\n    \"draw_every_nth_edge\": 20,  # decimation for form edges drawing (1=draw all)\n    \"draw_every_nth_colored_edge\": 25,  # decimation for colored edges (1=draw all)\n    \"draw_colored_forces\": False,       # keep False initially at high resolution\n    \"draw_every_nth_force_edge\": 20,\n\n    \"draw_scale_force\": 1.0,\n    \"force_offset_x\": 24.0,\n    \"force_offset_y\": 0.0,\n\n    # Seams / segmentation\n    \"draw_seams\": True,\n    \"seam_draw_on_surface\": True,\n    \"seam_sample_step\": 2,       # sample every N grid points along seam polyline\n    \"oblique_offset_deg\": 45.0,  # rotate seams away from local force direction\n    \"seam_draw_z\": 0.02,         # plan seam draw height (small)\n    \"inner_radius_frac\": 0.22,   # center piece size relative to bay\n}\n\n\n# ==============================================================================\n# Rhino helpers\n# ==============================================================================\n\ndef units_per_meter() -> float:\n    \"\"\"\n    Return the conversion factor from meters to current Rhino document units.\n    E.g., if doc is in mm, returns 1000.0; if in meters, returns 1.0.\n    \"\"\"\n    unit_system = sc.doc.ModelUnitSystem\n    \n    # Rhino.UnitSystem enum values\n    if unit_system == Rhino.UnitSystem.Millimeters:\n        return 1000.0\n    elif unit_system == Rhino.UnitSystem.Centimeters:\n        return 100.0\n    elif unit_system == Rhino.UnitSystem.Meters:\n        return 1.0\n    elif unit_system == Rhino.UnitSystem.Inches:\n        return 39.3701\n    elif unit_system == Rhino.UnitSystem.Feet:\n        return 3.28084\n    elif unit_system == Rhino.UnitSystem.Yards:\n        return 1.09361\n    elif unit_system == Rhino.UnitSystem.Kilometers:\n        return 0.001\n    else:\n        # Default to meters if unknown\n        print(f\"[TNA] WARNING: Unknown unit system {unit_system}, assuming meters\")\n        return 1.0\n\n\ndef _ensure_layer(name: str) -> int:\n    \"\"\"Create layer if missing. Return layer index.\"\"\"\n    doc = sc.doc\n    layer = doc.Layers.FindName(name)\n    if layer is None:\n        layer = Rhino.DocObjects.Layer()\n        layer.Name = name\n        idx = doc.Layers.Add(layer)\n        return idx\n    return layer.Index\n\n\ndef _add_line(a: Tuple[float, float, float],\n              b: Tuple[float, float, float],\n              layer: str,\n              rgb01: Tuple[float, float, float] | None = None) -> None:\n    doc = sc.doc\n    idx = _ensure_layer(layer)\n\n    p0 = Rhino.Geometry.Point3d(*a)\n    p1 = Rhino.Geometry.Point3d(*b)\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = idx\n\n    if rgb01 is not None:\n        r = int(max(0, min(255, round(255 * float(rgb01[0])))))\n        g = int(max(0, min(255, round(255 * float(rgb01[1])))))\n        b2 = int(max(0, min(255, round(255 * float(rgb01[2])))))\n        attr.ObjectColor = SD.Color.FromArgb(r, g, b2)\n        attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n\n    doc.Objects.AddLine(p0, p1, attr)\n\n\ndef _add_point(p: Tuple[float, float, float], layer: str) -> None:\n    doc = sc.doc\n    idx = _ensure_layer(layer)\n\n    pt = Rhino.Geometry.Point3d(*p)\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = idx\n    doc.Objects.AddPoint(pt, attr)\n\n\ndef _color_map_blue_red(t: float) -> Tuple[float, float, float]:\n    \"\"\"t in [0,1] -> (r,g,b) in [0,1], blue->red.\"\"\"\n    t = max(0.0, min(1.0, float(t)))\n    return (t, 0.0, 1.0 - t)\n\n\ndef clear_layer_objects(layer_name: str) -> None:\n    doc = sc.doc\n    layer = doc.Layers.FindName(layer_name)\n    if layer is None:\n        return\n    layer_index = layer.Index\n    ids = [obj.Id for obj in doc.Objects if obj.Attributes.LayerIndex == layer_index]\n    for gid in ids:\n        doc.Objects.Delete(gid, True)\n\n\ndef _add_rhino_mesh(mesh: Rhino.Geometry.Mesh, layer: str, color=None) -> None:\n    \"\"\"Add a Rhino mesh to the document on the specified layer.\"\"\"\n    doc = sc.doc\n    idx = _ensure_layer(layer)\n\n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = idx\n    if color is not None:\n        attr.ObjectColor = color\n        attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n\n    doc.Objects.AddMesh(mesh, attr)\n\n\ndef formdiagram_to_rhinomesh(form: FormDiagram) -> Rhino.Geometry.Mesh:\n    \"\"\"Convert a FormDiagram to a Rhino mesh (lifted surface).\"\"\"\n    rm = Rhino.Geometry.Mesh()\n\n    # vertex index map\n    v_index = {}\n    for i, v in enumerate(form.vertices()):\n        x, y, z = form.vertex_coordinates(v)\n        rm.Vertices.Add(x, y, z)\n        v_index[v] = i\n\n    # faces (expect quads from meshgrid)\n    for fkey in form.faces():\n        vs = form.face_vertices(fkey)\n        if len(vs) == 4:\n            rm.Faces.AddFace(v_index[vs[0]], v_index[vs[1]], v_index[vs[2]], v_index[vs[3]])\n        elif len(vs) == 3:\n            rm.Faces.AddFace(v_index[vs[0]], v_index[vs[1]], v_index[vs[2]])\n        # else ignore\n\n    rm.Normals.ComputeNormals()\n    rm.Compact()\n    return rm\n\n\ndef build_vertex_xy_lookup(form: FormDiagram, dx: float) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Dict[(ix,iy)] -> vertex key, where ix=round(x/dx), iy=round(y/dx).\n    Works because mesh is exactly on that grid.\n    \"\"\"\n    lut = {}\n    for v in form.vertices():\n        x, y, _ = form.vertex_coordinates(v)\n        ix = int(round(x / dx))\n        iy = int(round(y / dx))\n        lut[(ix, iy)] = v\n    return lut\n\n\ndef seam_polyline_on_surface(form: FormDiagram, seam_xy: List[Tuple[float, float]], \n                              lut: Dict[Tuple[int, int], int], dx: float, \n                              sample_step: int = 1) -> List[Tuple[float, float, float]]:\n    \"\"\"Drape a 2D seam polyline onto the form surface using nearest grid vertex z.\"\"\"\n    pts3 = []\n    for k, (x, y) in enumerate(seam_xy):\n        if sample_step > 1 and (k % sample_step) != 0 and k not in (0, len(seam_xy) - 1):\n            continue\n        ix = int(round(x / dx))\n        iy = int(round(y / dx))\n        v = lut.get((ix, iy))\n        if v is None:\n            continue\n        px, py, pz = form.vertex_coordinates(v)\n        pts3.append((px, py, pz))\n    return pts3\n\n\ndef draw_polyline3d(pts3: List[Tuple[float, float, float]], layer: str) -> None:\n    \"\"\"Draw a 3D polyline as connected line segments.\"\"\"\n    if len(pts3) < 2:\n        return\n    for i in range(len(pts3) - 1):\n        _add_line(pts3[i], pts3[i + 1], layer)\n\n\n# ==============================================================================\n# Phase 1 — Topology (grid mesh -> FormDiagram)\n# ==============================================================================\n\ndef make_form(params: Dict[str, float]) -> FormDiagram:\n    bay = float(params[\"bay\"])\n    bays_x = int(params[\"bays_x\"])\n    bays_y = int(params[\"bays_y\"])\n    subdiv = int(params[\"subdiv_per_bay\"])\n\n    nx = bays_x * subdiv\n    ny = bays_y * subdiv\n\n    # Regular quad mesh: nx x ny faces\n    mesh = Mesh.from_meshgrid(dx=bay / subdiv, nx=nx, dy=bay / subdiv, ny=ny)\n    form = FormDiagram.from_mesh(mesh)\n\n    # Explicit z=0 initialization\n    for v in form.vertices():\n        x, y, _ = form.vertex_coordinates(v)\n        form.vertex_attributes(v, [\"x\", \"y\", \"z\"], [x, y, 0.0])\n\n    return form\n\n\n# ==============================================================================\n# Phase 2 — Boundary conditions (supports at column grid intersections)\n# ==============================================================================\n\ndef apply_supports(form: FormDiagram, params: Dict[str, float]) -> List[int]:\n    bay = float(params[\"bay\"])\n    tol = 1e-6\n\n    col_coords = set()\n    for i in range(int(params[\"bays_x\"]) + 1):\n        for j in range(int(params[\"bays_y\"]) + 1):\n            col_coords.add((i * bay, j * bay))\n\n    supports: List[int] = []\n    for v in form.vertices():\n        x, y, _ = form.vertex_coordinates(v)\n        for (cx, cy) in col_coords:\n            if abs(x - cx) < tol and abs(y - cy) < tol:\n                form.vertex_attribute(v, \"is_fixed\", True)\n                supports.append(v)\n                break\n\n    return supports\n\n\n# ==============================================================================\n# Phase 3 — Loads (uniform nodal pz on free vertices)\n# ==============================================================================\n\ndef apply_loads(form: FormDiagram, supports: List[int], params: Dict[str, float]) -> None:\n    w = float(params[\"w\"])\n\n    for v in form.vertices():\n        if v in supports:\n            form.vertex_attributes(v, [\"px\", \"py\", \"pz\"], [0.0, 0.0, 0.0])\n        else:\n            form.vertex_attributes(v, [\"px\", \"py\", \"pz\"], [0.0, 0.0, -w])\n\n\n# ==============================================================================\n# Phase 4 — Equilibrium (horizontal reciprocity + vertical lifting)\n# ==============================================================================\n\ndef _rebuild_edge_indices(diagram) -> None:\n    \"\"\"\n    Manually rebuild continuous edge indices for the diagram.\n    This ensures edge attribute '_i' is a continuous 0..n-1 sequence.\n    \"\"\"\n    for idx, edge in enumerate(diagram.edges()):\n        diagram.edge_attribute(edge, \"_i\", idx)\n\n\ndef _build_force_diagram_safe(form: FormDiagram) -> Tuple[ForceDiagram, bool]:\n    \"\"\"\n    Build a ForceDiagram from form, ensuring continuous indexing.\n    Returns (force_diagram, success_flag).\n    If ordered_edges fails, returns (force_diagram, False).\n    \"\"\"\n    # Ensure form has continuous edge indices\n    _rebuild_edge_indices(form)\n    \n    # Create force diagram\n    force = ForceDiagram.from_formdiagram(form)\n    \n    # Manually rebuild force diagram edge indices\n    _rebuild_edge_indices(force)\n    \n    # Validate that ordered_edges works\n    try:\n        _ = force.ordered_edges(form)\n        return force, True\n    except (KeyError, AttributeError, IndexError) as e:\n        print(f\"[TNA] WARNING: ordered_edges failed: {e}\")\n        print(\"[TNA] Falling back to vertical-only equilibrium (no horizontal_nodal)\")\n        return force, False\n\n\ndef solve_equilibrium(form: FormDiagram, params: Dict[str, float]) -> Tuple[ForceDiagram, float]:\n    # Build force diagram\n    force, can_do_horizontal = _build_force_diagram_safe(form)\n\n    # Only run horizontal_nodal if ordered_edges works\n    if can_do_horizontal:\n        try:\n            horizontal_nodal(\n                form,\n                force,\n                alpha=float(params[\"alpha\"]),\n                kmax=int(params[\"kmax_hor\"]),\n            )\n        except Exception as e:\n            print(f\"[TNA] horizontal_nodal failed: {e}\")\n            print(\"[TNA] Continuing with vertical equilibrium only...\")\n    else:\n        # Initialize default force densities for vertical_from_zmax\n        for edge in form.edges():\n            if form.edge_attribute(edge, \"q\") is None:\n                form.edge_attribute(edge, \"q\", 1.0)\n\n    # vertical_from_zmax returns (form, scale) tuple\n    result = vertical_from_zmax(form, float(params[\"zmax\"]))\n    if isinstance(result, tuple):\n        _, scale = result\n    else:\n        scale = float(result)\n    \n    return force, scale\n\n\n# ==============================================================================\n# Visualization — form / force\n# ==============================================================================\n\ndef draw_form(form: FormDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_form\"])\n    draw_pts = bool(params.get(\"draw_vertices\", False))\n    step = max(1, int(params.get(\"draw_every_nth_edge\", 1)))\n\n    if draw_pts:\n        for v in form.vertices():\n            x, y, z = form.vertex_coordinates(v)\n            _add_point((x, y, z), layer)\n\n    for k, (u, v) in enumerate(form.edges()):\n        if k % step != 0:\n            continue\n        a = form.vertex_coordinates(u)\n        b = form.vertex_coordinates(v)\n        _add_line(tuple(a), tuple(b), layer)\n\n\n\"\"\" def draw_force(force: ForceDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_force\"])\n    ox = float(params[\"force_offset_x\"])\n    oy = float(params[\"force_offset_y\"])\n    s = float(params[\"draw_scale_force\"])\n\n    for u, v in force.edges():\n        ax, ay, _ = force.vertex_coordinates(u)\n        bx, by, _ = force.vertex_coordinates(v)\n        a = (ox + s * ax, oy + s * ay, 0.0)\n        b = (ox + s * bx, oy + s * by, 0.0)\n        _add_line(a, b, layer)\n \"\"\"\n\ndef draw_force(force: ForceDiagram, params: Dict[str, float]) -> None:\n    layer = str(params[\"layer_force\"])\n    ox = float(params[\"force_offset_x\"])\n    oy = float(params[\"force_offset_y\"])\n    s = float(params[\"draw_scale_force\"])\n\n    step = int(params.get(\"draw_every_nth_force_edge\", 1))\n    step = max(1, step)\n\n    for k, (u, v) in enumerate(force.edges()):\n        if k % step != 0:\n            continue\n        ax, ay, _ = force.vertex_coordinates(u)\n        bx, by, _ = force.vertex_coordinates(v)\n        a = (ox + s * ax, oy + s * ay, 0.0)\n        b = (ox + s * bx, oy + s * by, 0.0)\n        _add_line(a, b, layer)\n\n\n# ==============================================================================\n# Edge force proxy + colored drawing (optional)\n# ==============================================================================\n\ndef _edge_force_magnitude(form: FormDiagram, u: int, v: int) -> float:\n    for key in (\"h\", \"f\"):\n        val = form.edge_attribute((u, v), key)\n        if isinstance(val, (int, float)):\n            return abs(float(val))\n    q = form.edge_attribute((u, v), \"q\")\n    if isinstance(q, (int, float)):\n        return abs(float(q))\n    return 0.0\n\n\ndef draw_form_colored_by_force(form: FormDiagram, params: Dict[str, float]) -> None:\n    \"\"\"\n    Decimated colored edges by |force| proxy.\n    WARNING: still heavy at high resolution; keep draw_colored_forces=False until stable.\n    \"\"\"\n    base_layer = str(params[\"layer_form\"]) + \"_FORCECOLOR\"\n    step = max(1, int(params.get(\"draw_every_nth_colored_edge\", 1)))\n\n    mags = []\n    edges = []\n    for u, v in form.edges():\n        mags.append(_edge_force_magnitude(form, u, v))\n        edges.append((u, v))\n\n    mmax = max(mags) if mags else 1.0\n    if mmax <= 0.0:\n        mmax = 1.0\n\n    for k, ((u, v), m) in enumerate(zip(edges, mags)):\n        if k % step != 0:\n            continue\n        t = m / mmax\n        rgb = _color_map_blue_red(t)\n        a = form.vertex_coordinates(u)\n        b = form.vertex_coordinates(v)\n        _add_line(tuple(a), tuple(b), base_layer, rgb01=rgb)\n\n\n# ==============================================================================\n# Segmentation — 9-piece seams per bay (force-aware rotation)\n# ==============================================================================\n\ndef _ray_square_intersection(cx, cy, dx, dy, ox, oy, bay):\n    \"\"\"Intersect ray from (cx,cy) in direction (dx,dy) with square [ox..ox+bay]x[oy..oy+bay].\"\"\"\n    eps = 1e-12\n    t_candidates = []\n\n    if abs(dx) > eps:\n        t = (ox - cx) / dx\n        y = cy + t * dy\n        if t > 0 and oy - eps <= y <= oy + bay + eps:\n            t_candidates.append((t, ox, y))\n\n        t = (ox + bay - cx) / dx\n        y = cy + t * dy\n        if t > 0 and oy - eps <= y <= oy + bay + eps:\n            t_candidates.append((t, ox + bay, y))\n\n    if abs(dy) > eps:\n        t = (oy - cy) / dy\n        x = cx + t * dx\n        if t > 0 and ox - eps <= x <= ox + bay + eps:\n            t_candidates.append((t, x, oy))\n\n        t = (oy + bay - cy) / dy\n        x = cx + t * dx\n        if t > 0 and ox - eps <= x <= ox + bay + eps:\n            t_candidates.append((t, x, oy + bay))\n\n    t_candidates.sort(key=lambda a: a[0])\n    if not t_candidates:\n        return (cx, cy)\n    _, x, y = t_candidates[0]\n    return (x, y)\n\n\ndef bay_seam_polylines_9piece(ox, oy, bay, theta_rad, r_frac=0.22):\n    \"\"\"\n    Seam polylines for one bay:\n    - inner octagon loop (center piece boundary)\n    - 8 spokes from inner octagon vertices to perimeter points\n    \"\"\"\n    cx = ox + 0.5 * bay\n    cy = oy + 0.5 * bay\n    r = float(r_frac) * bay\n\n    inner = []\n    outer = []\n\n    for k in range(8):\n        a = theta_rad + k * (math.pi / 4.0)\n        dx = math.cos(a)\n        dy = math.sin(a)\n\n        inner.append((cx + r * dx, cy + r * dy))\n        outer.append(_ray_square_intersection(cx, cy, dx, dy, ox, oy, bay))\n\n    polylines = []\n    polylines.append(inner + [inner[0]])  # inner loop\n    for k in range(8):\n        polylines.append([inner[k], outer[k]])  # spokes\n\n    return polylines\n\n\ndef snap_pt_to_grid_xy(x, y, dx):\n    sx = round(x / dx) * dx\n    sy = round(y / dx) * dx\n    return (sx, sy)\n\n\ndef snap_polyline_to_grid(polyline_xy, dx):\n    return [snap_pt_to_grid_xy(x, y, dx) for (x, y) in polyline_xy]\n\n\ndef draw_seam_polylines_in_rhino(seam_polylines_xy, layer, z=0.0):\n    for pl in seam_polylines_xy:\n        for i in range(len(pl) - 1):\n            x0, y0 = pl[i]\n            x1, y1 = pl[i + 1]\n            _add_line((x0, y0, z), (x1, y1, z), layer)\n\n\ndef bay_force_direction_xy(form, ox, oy, bay):\n    \"\"\"Dominant XY direction near bay center using weighted sum of incident edge directions.\"\"\"\n    cx, cy = ox + 0.5 * bay, oy + 0.5 * bay\n\n    v0 = min(\n        form.vertices(),\n        key=lambda v: (form.vertex_attribute(v, \"x\") - cx) ** 2 + (form.vertex_attribute(v, \"y\") - cy) ** 2\n    )\n\n    x0, y0, _ = form.vertex_coordinates(v0)\n    vx, vy = 0.0, 0.0\n\n    for nbr in form.vertex_neighbors(v0):\n        x1, y1, _ = form.vertex_coordinates(nbr)\n        ex, ey = (x1 - x0), (y1 - y0)\n        L = (ex * ex + ey * ey) ** 0.5\n        if L < 1e-12:\n            continue\n        ex /= L\n        ey /= L\n\n        # Try force keys in order\n        h = form.edge_attribute((v0, nbr), \"h\")\n        if h is None:\n            h = form.edge_attribute((v0, nbr), \"f\")\n        if h is None:\n            h = form.edge_attribute((v0, nbr), \"q\")\n        w = abs(float(h or 0.0))\n\n        vx += w * ex\n        vy += w * ey\n\n    L = (vx * vx + vy * vy) ** 0.5\n    if L < 1e-12:\n        return (1.0, 0.0)\n    return (vx / L, vy / L)\n\n\n# ==============================================================================\n# Seam traffic metric (proxy for joint demand)\n# ==============================================================================\n\ndef _seg_intersect_2d(a, b, c, d):\n    \"\"\"2D segment intersection (including touching). a,b,c,d are (x,y).\"\"\"\n    def orient(p, q, r):\n        return (q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0])\n\n    def on_seg(p, q, r):\n        return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n                min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\n    o1 = orient(a, b, c)\n    o2 = orient(a, b, d)\n    o3 = orient(c, d, a)\n    o4 = orient(c, d, b)\n\n    eps = 1e-12\n\n    if (o1 > eps and o2 < -eps or o1 < -eps and o2 > eps) and (o3 > eps and o4 < -eps or o3 < -eps and o4 > eps):\n        return True\n\n    if abs(o1) <= eps and on_seg(a, c, b): return True\n    if abs(o2) <= eps and on_seg(a, d, b): return True\n    if abs(o3) <= eps and on_seg(c, a, d): return True\n    if abs(o4) <= eps and on_seg(c, b, d): return True\n\n    return False\n\n\ndef seam_traffic_for_bay(form, seam_polylines_xy, ox, oy, bay):\n    \"\"\"\n    Sum |force| of form edges that intersect any seam segment.\n    Only edges whose midpoint lies within the bay are considered.\n    \"\"\"\n    seam_segs = []\n    for pl in seam_polylines_xy:\n        for i in range(len(pl) - 1):\n            seam_segs.append((pl[i], pl[i + 1]))\n\n    total = 0.0\n    for u, v in form.edges():\n        x0, y0, _ = form.vertex_coordinates(u)\n        x1, y1, _ = form.vertex_coordinates(v)\n        mx, my = 0.5 * (x0 + x1), 0.5 * (y0 + y1)\n\n        if not (ox <= mx <= ox + bay and oy <= my <= oy + bay):\n            continue\n\n        a = (x0, y0)\n        b = (x1, y1)\n\n        hit = False\n        for (c, d) in seam_segs:\n            if _seg_intersect_2d(a, b, c, d):\n                hit = True\n                break\n\n        if hit:\n            total += _edge_force_magnitude(form, u, v)\n\n    return total\n\n\n# ==============================================================================\n# Metrics\n# ==============================================================================\n\ndef compute_metrics(form: FormDiagram, supports: List[int]) -> Dict[str, float]:\n    edge_mags = [_edge_force_magnitude(form, u, v) for (u, v) in form.edges()]\n    if not edge_mags:\n        edge_mags = [0.0]\n\n    # Reaction proxy (if 'rz' exists, use it; else load-balance proxy)\n    rz_vals = []\n    for v in supports:\n        rz = form.vertex_attribute(v, \"rz\")\n        if isinstance(rz, (int, float)):\n            rz_vals.append(float(rz))\n\n    if rz_vals:\n        rmax = max(abs(r) for r in rz_vals)\n        ravg = sum(abs(r) for r in rz_vals) / len(rz_vals)\n    else:\n        total_pz = 0.0\n        for v in form.vertices():\n            pz = form.vertex_attribute(v, \"pz\") or 0.0\n            total_pz += float(pz)\n        per_support = abs(total_pz) / max(1, len(supports))\n        rmax = per_support\n        ravg = per_support\n\n    return {\n        \"edge_force_max\": max(edge_mags),\n        \"edge_force_avg\": sum(edge_mags) / len(edge_mags),\n        \"reaction_max_abs\": rmax,\n        \"reaction_avg_abs\": ravg,\n    }\n\n\n# ==============================================================================\n# Main entrypoint\n# ==============================================================================\n\ndef run(params: Dict[str, float] = None):\n    params = dict(PARAMS if params is None else params)\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # Unit scaling: convert meters to document units\n    # ─────────────────────────────────────────────────────────────────────────\n    U = units_per_meter()\n    unit_name = str(sc.doc.ModelUnitSystem)\n    print(f\"[TNA] Document units: {unit_name}, scale factor U = {U}\")\n\n    # Scale geometric parameters from meters to doc units\n    params[\"bay\"] = float(params[\"bay\"]) * U\n    params[\"zmax\"] = float(params[\"zmax\"]) * U\n    params[\"force_offset_x\"] = float(params[\"force_offset_x\"]) * U\n    params[\"force_offset_y\"] = float(params[\"force_offset_y\"]) * U\n    params[\"seam_draw_z\"] = float(params.get(\"seam_draw_z\", 0.02)) * U\n\n    # Phase 0 — Layers: ensure they exist\n    _ensure_layer(str(params[\"layer_form\"]))\n    _ensure_layer(str(params[\"layer_force\"]))\n    _ensure_layer(str(params[\"layer_seams\"]))\n    \n    # Clear existing geometry from all TNA layers before drawing new geometry\n    clear_layer_objects(str(params[\"layer_form\"]))\n    clear_layer_objects(str(params[\"layer_force\"]))\n    clear_layer_objects(str(params[\"layer_seams\"]))\n    clear_layer_objects(str(params[\"layer_form\"]) + \"_FORCECOLOR\")\n\n    # Phase 1 — Topology\n    form = make_form(params)\n\n    # Phase 2 — Supports\n    supports = apply_supports(form, params)\n\n    # Phase 3 — Loads\n    apply_loads(form, supports, params)\n\n    # Phase 4 — Equilibrium\n    force, scale = solve_equilibrium(form, params)\n\n    # Phase 6A — Seams + seam traffic (per bay)\n    bay = float(params[\"bay\"])\n    bx = int(params[\"bays_x\"])\n    by = int(params[\"bays_y\"])\n    subdiv = int(params[\"subdiv_per_bay\"])\n    dx = bay / subdiv  # grid spacing\n    ob = math.radians(float(params[\"oblique_offset_deg\"]))\n    seam_z = float(params.get(\"seam_draw_z\", 0.02))\n    r_frac = float(params.get(\"inner_radius_frac\", 0.22))\n\n    traffic_sum = 0.0\n    traffic_max = 0.0\n\n    # Build vertex lookup for seam draping\n    lut = build_vertex_xy_lookup(form, dx)\n    seam_sample_step = int(params.get(\"seam_sample_step\", 2))\n\n    for i in range(bx):\n        for j in range(by):\n            ox = i * bay\n            oy = j * bay\n\n            fx, fy = bay_force_direction_xy(form, ox, oy, bay)\n            theta = math.atan2(fy, fx) + ob\n\n            seams = bay_seam_polylines_9piece(ox, oy, bay, theta, r_frac=r_frac)\n            seams = [snap_polyline_to_grid(pl, dx) for pl in seams]\n\n            # Draw seams (on surface or flat)\n            if params.get(\"draw_seams\", True):\n                if params.get(\"seam_draw_on_surface\", True):\n                    for pl in seams:\n                        pts3 = seam_polyline_on_surface(form, pl, lut, dx, sample_step=seam_sample_step)\n                        draw_polyline3d(pts3, str(params[\"layer_seams\"]))\n                else:\n                    draw_seam_polylines_in_rhino(seams, str(params[\"layer_seams\"]), z=seam_z)\n\n            t = seam_traffic_for_bay(form, seams, ox, oy, bay)\n            traffic_sum += t\n            traffic_max = max(traffic_max, t)\n\n    # Phase 5 — Draw form (mesh or edges)\n    if params.get(\"draw_form_as_mesh\", True):\n        rm = formdiagram_to_rhinomesh(form)\n        _add_rhino_mesh(rm, str(params[\"layer_form\"]), color=SD.Color.FromArgb(220, 220, 220))\n    \n    if params.get(\"draw_form_edges\", False):\n        draw_form(form, params)\n    \n    # Draw force diagram (if enabled)\n    if params.get(\"draw_force_edges\", False):\n        draw_force(force, params)\n\n    if bool(params.get(\"draw_colored_forces\", False)):\n        draw_form_colored_by_force(form, params)\n\n    # Phase 6B — Metrics\n    metrics = compute_metrics(form, supports)\n\n    sc.doc.Views.Redraw()\n\n    # Compute total span for reporting\n    total_span_x = float(params[\"bay\"]) * int(params[\"bays_x\"])\n    total_span_y = float(params[\"bay\"]) * int(params[\"bays_y\"])\n\n    print(\"=== TNA Funicular Floor: results ===\")\n    print(f\"Document units: {unit_name} (U={U})\")\n    print(f\"Floor span: {total_span_x:.1f} x {total_span_y:.1f} {unit_name}\")\n    print(f\"supports (count): {len(supports)}\")\n    print(f\"vertical scale (from zmax): {scale:.6g}\")\n    print(f\"max edge |force| (proxy): {metrics['edge_force_max']:.6g}\")\n    print(f\"avg edge |force| (proxy): {metrics['edge_force_avg']:.6g}\")\n    print(f\"max |reaction| (proxy):   {metrics['reaction_max_abs']:.6g}\")\n    print(f\"avg |reaction| (proxy):   {metrics['reaction_avg_abs']:.6g}\")\n    print(\"=== Seam / Joint Metrics (proxy) ===\")\n    print(f\"Total seam traffic (sum over 9 bays): {traffic_sum:.6g}\")\n    print(f\"Max seam traffic (worst bay):         {traffic_max:.6g}\")\n\n    return {\n        \"supports\": len(supports),\n        \"scale\": scale,\n        \"metrics\": metrics,\n        \"seam_traffic_sum\": traffic_sum,\n        \"seam_traffic_max\": traffic_max,\n        \"dx\": dx,\n    }\n\n\nif __name__ == \"__main__\":\n    run()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}