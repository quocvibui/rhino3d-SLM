{
  "source_url": "https://github.com/969flash/parcel_layout_evaluation_analysis/blob/af8592ec3f658bf5bb8b63064ff33fdbf46240d0/grasshopper/block_generator.py",
  "repo": "969flash/parcel_layout_evaluation_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "grasshopper/block_generator.py",
  "instruction": "r: pyshp, geopandas, networkx",
  "code": "# r: pyshp, geopandas, networkx\n\nimport Rhino.Geometry as geo\nimport geopandas as gpd\nimport networkx as nx\nfrom shapely.geometry import Polygon\nfrom typing import List, Optional, Any\n\n# units.py에서 units.Lot과 units.Block 클래스를 임포트했다고 가정\n\nimport units\nimport utils\nimport importlib\n\nimportlib.reload(utils)\nimportlib.reload(units)\n\n\nclass BlockGenerator:\n    def __init__(self):\n        pass\n\n    def generate(self, lots: List[units.Lot]) -> List[units.Block]:\n        \"\"\"주어진 units.Lot 리스트로부터 units.Block 객체 리스트를 생성합니다.\"\"\"\n\n        lots_to_process = [p for p in lots if p.__class__.__name__ == \"Lot\"]\n        return self._create_blocks_from_lots(lots_to_process)\n\n    def _rhino_curve_to_shapely_polygon(\n        self, region_curve: geo.Curve, hole_curves: Optional[List[geo.Curve]] = None\n    ) -> Optional[Polygon]:\n        \"\"\"Rhino 커브를 utils.get_vertices 기반으로 Shapely Polygon으로 변환.\n        - 커브 Span 기준 정점 추출\n        - 중복 제거\n        - 닫힌 커브 미보장 시 첫/끝 점 강제 닫기\n        \"\"\"\n        if not region_curve or not region_curve.IsValid:\n            return None\n\n        verts = utils.get_vertices(region_curve)\n        if not verts:\n            return None\n\n        # 중복 제거(순서 유지)\n        shell_pts: List[tuple] = []\n        seen = set()\n        for pt in verts:\n            key = (round(pt.X, 9), round(pt.Y, 9))\n            if key in seen:\n                continue\n            seen.add(key)\n            shell_pts.append((pt.X, pt.Y))\n\n        # 닫힘 보장\n        if len(shell_pts) >= 3 and shell_pts[0] != shell_pts[-1]:\n            shell_pts.append(shell_pts[0])\n\n        if len(shell_pts) < 4:  # 시작=끝 포함 최소 4\n            return None\n\n        holes_coords: List[List[tuple]] = []\n        if hole_curves:\n            for h in hole_curves:\n                if not h or not h.IsValid:\n                    continue\n                h_verts = utils.get_vertices(h)\n                if not h_verts:\n                    continue\n                h_seen = set()\n                h_pts: List[tuple] = []\n                for p in h_verts:\n                    k = (round(p.X, 9), round(p.Y, 9))\n                    if k in h_seen:\n                        continue\n                    h_seen.add(k)\n                    h_pts.append((p.X, p.Y))\n                if len(h_pts) >= 3 and h_pts[0] != h_pts[-1]:\n                    h_pts.append(h_pts[0])\n                if len(h_pts) >= 4:\n                    holes_coords.append(h_pts)\n\n        try:\n            return Polygon(shell_pts, holes_coords)\n        except Exception:\n            return None\n\n    def _create_blocks_from_lots(self, lots: List[units.Lot]) -> List[units.Block]:\n        \"\"\"\n        units.Lot 리스트를 받아 공간적으로 인접한 units.Lot들을 그룹화하여 units.Block 리스트를 생성합니다.\n        \"\"\"\n        if not lots:\n            print(\"No valid lots to process.\")\n            return []\n\n        # 나중에 units.Lot 객체를 쉽게 찾기 위해 PNU를 키로 하는 딕셔너리 생성\n        lot_map = {lot.pnu: lot for lot in lots}\n\n        # GeoDataFrame 생성을 위한 데이터 준비\n        geometries = []\n        pnu_list = []\n        for lot in lots:\n            polygon = self._rhino_curve_to_shapely_polygon(lot.region, lot.hole_regions)\n            if polygon:\n                geometries.append(polygon)\n                pnu_list.append(lot.pnu)\n\n        # GeoDataFrame 생성 (공간 인덱스가 자동으로 만들어짐)\n        gdf = gpd.GeoDataFrame({\"pnu\": pnu_list, \"geometry\": geometries})\n        print(len(gdf), \"valid geometries created for lots.\")\n\n        # 1. sjoin으로 교차하거나 접하는 모든 units.Lot 쌍을 빠르게 찾기\n        intersecting_gdf = gpd.sjoin(gdf, gdf, how=\"inner\", predicate=\"intersects\")\n\n        # 2. 결과에서 자기 자신과의 쌍은 제외\n        intersecting_gdf = intersecting_gdf[\n            intersecting_gdf.pnu_left != intersecting_gdf.pnu_right\n        ]\n\n        # 3. NetworkX 그래프 생성을 위한 엣지(연결 관계) 리스트 만들기\n        edges = set()\n        for _, row in intersecting_gdf.iterrows():\n            pair = tuple(sorted((row[\"pnu_left\"], row[\"pnu_right\"])))\n            edges.add(pair)\n\n        # 4. 그래프를 만들고 '연결된 요소(뭉치)' 찾기\n        G = nx.Graph()\n        G.add_nodes_from(\n            pnu_list\n        )  # 모든 units.Lot을 노드로 추가 (연결 없는 units.Lot도 포함)\n        G.add_edges_from(edges)\n\n        clusters = list(nx.connected_components(G))\n\n        # 5. 찾은 클러스터(PNU 묶음)를 기반으로 units.Block 객체 생성\n        blocks = []\n        for i, pnu_group in enumerate(clusters):\n            cluster_lots = [lot_map[pnu] for pnu in pnu_group]\n            blocks.append(units.Block(lots=cluster_lots, id=i))\n\n        return blocks\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}