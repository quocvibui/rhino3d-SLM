{
  "source_url": "https://discourse.mcneel.com/t/classify-the-curves-into-inside-curves-and-bounding-curves/211442",
  "topic_id": 211442,
  "title": "Classify the curves into inside curves and bounding curves",
  "question": "I am writing a script to classify nested curves. The goal is to identify the outer bounding curves (the red contours in the attached picture) and the inside curves (the blue ones).\n\n\nMy current script works, but it becomes very slow (or ‘laggy’) when processing a large number of objects. How can I optimize this script for better performance?\n\n\n\n\n-- coding: utf-8 --\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\n\ndef cpcs_filt(rhino_object, geometry, component_index):\ntry:\nif rs.IsCurve(rhino_object.Id) and rs.IsCurveClosed(rhino_object.Id) and rs.IsCurvePlanar(rhino_object.Id):\nreturn True\nexcept Exception:\npass\nreturn False\n\ndef to_plane_xy(pt, plane):\nv = pt - plane.Origin\nx = v.X * plane.XAxis.X + v.Y * plane.XAxis.Y + v.Z * plane.XAxis.Z\ny = v.X * plane.YAxis.X + v.Y * plane.YAxis.Y + v.Z * plane.YAxis.Z\nreturn (x, y)\n\ndef point_in_polygon_strict(x, y, poly):\n“”“Strict point-in-polygon: True only if strictly inside (not on edge/vertex).”“”\nn = len(poly)\nif n < 4:\nreturn False\neps = 1e-9\nj = n - 1\ninside = False\nfor i in range(n):\nxi, yi = poly[i]\nxj, yj = poly[j]\n# on vertex\nif abs(x - xi) < eps and abs(y - yi) < eps:\nreturn False\n# on edge (colinear + between)\ndx1 = x - xi; dy1 = y - yi\ndx2 = xj - xi; dy2 = yj - yi\ncross = dx1 * dy2 - dy1 * dx2\nif abs(cross) < 1e-9:\nif (min(xi,xj) - eps <= x <= max(xi,xj) + eps) and (min(yi,yj) - eps <= y <= max(yi,yj) + eps):\nreturn False\n# ray cast\nif ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi):\ninside = not inside\nj = i\nreturn inside\n\ndef sample_curve_points(crv, sample_count):\npts = \n\ntry:\nparams = crv.DivideByCount(sample_count, True)\nif params:\npts = [crv.PointAt(t) for t in params]\nelse:\ndom = crv.Domain\npts = [crv.PointAt(dom.T0 + (dom.Length * i / float(sample_count))) for i in range(sample_count + 1)]\nexcept Exception:\ndom = crv.Domain\npts = [crv.PointAt(dom.T0 + (dom.Length * i / float(sample_count))) for i in range(sample_count + 1)]\nreturn pts\n\nd...",
  "code_blocks": [
    {
      "code": "# -*- coding: utf-8 -*-\nimport rhinoscriptsyntax as rs\nimport Rhino\n\n\ndef cpcs_filt(rhino_object, geometry, component_index):\n    try:\n        if rs.IsCurve(rhino_object.Id) and rs.IsCurveClosed(rhino_object.Id) and rs.IsCurvePlanar(rhino_object.Id):\n            return True\n    except Exception:\n        pass\n    return False\n\n\ndef to_plane_xy(pt, plane):\n    v = pt - plane.Origin\n    x = v.X * plane.XAxis.X + v.Y * plane.XAxis.Y + v.Z * plane.XAxis.Z\n    y = v.X * plane.YAxis.X + v.Y * plane.YAxis.Y + v.Z * plane.YAxis.Z\n    return (x, y)\n\n\ndef point_in_polygon_strict(x, y, poly):\n    n = len(poly)\n    if n < 4:\n        return False\n    eps = 1e-9\n    inside = False\n    j = n - 1\n    for i in range(n):\n        xi, yi = poly[i]\n        xj, yj = poly[j]\n        if abs(x - xi) < eps and abs(y - yi) < eps:\n            return False\n        dx1 = x - xi; dy1 = y - yi\n        dx2 = xj - xi; dy2 = yj - yi\n        cross = dx1 * dy2 - dy1 * dx2\n        if abs(cross) < eps:\n            if (min(xi, xj) - eps <= x <= max(xi, xj) + eps) and (min(yi, yj) - eps <= y <= max(yi, yj) + eps):\n                return False\n        if ((yi > y) != (yj > y)):\n            x_inter = (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi\n            if x < x_inter:\n                inside = not inside\n        j = i\n    return inside\n\n\ndef sample_curve_points(crv, sample_count):\n    pts = []\n    try:\n        params = crv.DivideByCount(sample_count, True)\n        if params:\n            pts = [crv.PointAt(t) for t in params]\n        else:\n            dom = crv.Domain\n            pts = [crv.PointAt(dom.T0 + (dom.Length * float(i) / float(sample_count))) for i in range(sample_count + 1)]\n    except Exception:\n        dom = crv.Domain\n        pts = [crv.PointAt(dom.T0 + (dom.Length * float(i) / float(sample_count))) for i in range(sample_count + 1)]\n    return pts\n\n\ndef bbox_inflate(bbox, tol):\n    if not bbox.IsValid:\n        return bbox\n    minp = Rhino.Geometry.Point3d(bbox.Min.X - tol, bbox.Min.Y - tol, bbox.Min.Z - tol)\n    maxp = Rhino.Geometry.Point3d(bbox.Max.X + tol, bbox.Max.Y + tol, bbox.Max.Z + tol)\n    return Rhino.Geometry.BoundingBox(minp, maxp)\n\n\ndef bbox_contains(small, big, eps=1e-9):\n    if not (small.IsValid and big.IsValid):\n        return False\n    return (big.Min.X - eps <= small.Min.X and big.Min.Y - eps <= small.Min.Y and big.Min.Z - eps <= small.Min.Z\n            and big.Max.X + eps >= small.Max.X and big.Max.Y + eps >= small.Max.Y and big.Max.Z + eps >= small.Max.Z)\n\n\ndef bbox_intersects(b1, b2, eps=1e-9):\n    \"\"\"Axis-aligned bounding-box intersection test (AABB).\n    Returns True if b1 and b2 intersect. Works across RhinoCommon versions.\n    \"\"\"\n    if not (b1.IsValid and b2.IsValid):\n        return False\n    if b1.Max.X < b2.Min.X - eps or b1.Min.X > b2.Max.X + eps:\n        return False\n    if b1.Max.Y < b2.Min.Y - eps or b1.Min.Y > b2.Max.Y + eps:\n        return False\n    if b1.Max.Z < b2.Min.Z - eps or b1.Min.Z > b2.Max.Z + eps:\n        return False\n    return True\n\n\ndef classify_by_nesting_rtree(guids, sample_count=160, bbox_inflate_tol=1e-6):\n    items = []\n    for g in guids:\n        crv = rs.coercecurve(g)\n        if not crv or not crv.IsClosed:\n            continue\n        ok, plane = crv.TryGetPlane()\n        if not ok:\n            plane = Rhino.Geometry.Plane.WorldXY\n        bbox = crv.GetBoundingBox(True)\n        items.append({'id': g, 'crv': crv, 'plane': plane, 'bbox': bbox})\n\n    if not items:\n        print(\"No valid closed planar curves.\")\n        return [], []\n\n    # Build R-Tree\n    try:\n        rtree = Rhino.Geometry.RTree()\n        for i, it in enumerate(items):\n            bb = bbox_inflate(it['bbox'], bbox_inflate_tol)\n            rtree.Insert(bb, i)\n        use_rtree = True\n    except Exception:\n        rtree = None\n        use_rtree = False\n\n    # Precompute samples + 2D polygons\n    for it in items:\n        crv = it['crv']\n        plane = it['plane']\n        pts3 = sample_curve_points(crv, sample_count)\n        poly2 = [to_plane_xy(p, plane) for p in pts3]\n        if poly2 and poly2[0] != poly2[-1]:\n            poly2.append(poly2[0])\n        it['sample_pts'] = pts3\n        it['poly2'] = poly2\n\n    inside = []\n    bounding = []\n\n    for idxA, A in enumerate(items):\n        ptsA = A['sample_pts']\n        bboxA = bbox_inflate(A['bbox'], bbox_inflate_tol)\n\n        candidate_indexes = []\n        if use_rtree:\n            hits = []\n            # The RTree.Search callback signature differs across RhinoCommon versions.\n            # Try several patterns but always collect integer indexes.\n            try:\n                def cb(args):\n                    # RhinoCommon sometimes passes an event args with Id or Index\n                    try:\n                        hits.append(args.Id)\n                    except Exception:\n                        try:\n                            hits.append(args.Index)\n                        except Exception:\n                            # older API might pass (id, box, userdata)\n                            pass\n                    return True\n                rtree.Search(bboxA, cb)\n            except Exception:\n                # fallback: alternate signature\n                try:\n                    hits2 = []\n                    rtree.Search(bboxA, lambda id, box, userdata: (hits2.append(id) or True))\n                    hits = hits2\n                except Exception:\n                    # give up on rtree-search and consider all indexes\n                    hits = list(range(len(items)))\n            candidate_indexes = [h for h in hits if isinstance(h, int) and h != idxA]\n        else:\n            candidate_indexes = [i for i in range(len(items)) if i != idxA]\n\n        # refine candidates by bbox containment/intersection using AABB functions\n        refined = []\n        for idxB in candidate_indexes:\n            bbB = items[idxB]['bbox']\n            # cheap world-axis containment test\n            if bbox_contains(A['bbox'], bbB):\n                refined.append(idxB)\n            else:\n                # use AABB intersection fallback\n                if bbox_intersects(A['bbox'], bbB):\n                    refined.append(idxB)\n\n        container_count = 0\n        for idxB in refined:\n            B = items[idxB]\n            polyB = B['poly2']\n            plB = B['plane']\n            if not polyB:\n                continue\n            all_inside = True\n            for p in ptsA:\n                x, y = to_plane_xy(p, plB)\n                if not point_in_polygon_strict(x, y, polyB):\n                    all_inside = False\n                    break\n            if all_inside:\n                container_count += 1\n\n        if (container_count % 2) == 1:\n            inside.append(A['id'])\n            try:\n                rs.ObjectColor(A['id'], (0, 255, 0))\n            except Exception:\n                pass\n        else:\n            bounding.append(A['id'])\n            try:\n                rs.ObjectColor(A['id'], (255, 0, 0))\n            except Exception:\n                pass\n\n    print(\"Classified (rtree used={}): inside = {}, bounding = {}  (sample_count={})\".format(use_rtree, len(inside), len(bounding), sample_count))\n    return inside, bounding\n\n\ndef main():\n    guids = rs.GetObjects(\"Select closed planar curves (filtered)\", filter=rs.filter.curve, preselect=True, custom_filter=cpcs_filt)\n    if not guids:\n        print(\"No curves selected.\")\n        return\n\n    rs.EnableRedraw(False)\n    try:\n        classify_by_nesting_rtree(guids, sample_count=160, bbox_inflate_tol=1e-6)\n    finally:\n        rs.EnableRedraw(True)\n\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "author": "theanhkc07",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "-- coding: utf-8 --\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\n\ndef cpcs_filt(rhino_object, geometry, component_index):\ntry:\nif rs.IsCurve(rhino_object.Id) and rs.IsCurveClosed(rhino_object.Id) and rs.IsCurvePlanar(rhino_object.Id):\nreturn True\nexcept Exception:\npass\nreturn False\n\ndef to_plane_xy(pt, plane):\nv = pt - plane.Origin\nx = v.X * plane.XAxis.X + v.Y * plane.XAxis.Y + v.Z * plane.XAxis.Z\ny = v.X * plane.YAxis.X + v.Y * plane.YAxis.Y + v.Z * plane.YAxis.Z\nreturn (x, y)\n\ndef point_in_polygon_strict(x, y, poly):\n“”“Strict point-in-polygon: True only if strictly inside (not on edge/vertex).”“”\nn = len(poly)\nif n < 4:\nreturn False\neps = 1e-9\nj = n - 1\ninside = False\nfor i in range(n):\nxi, yi = poly[i]\nxj, yj = poly[j]\n# on vertex\nif abs(x - xi) < eps and abs(y - yi) < eps:\nreturn False\n# on edge (colinear + between)\ndx1 = x - xi; dy1 = y - yi\ndx2 = xj - xi; dy2 = yj - yi\ncross = dx1 * dy2 - dy1 * dx2\nif abs(cross) < 1e-9:\nif (min(xi,xj) - eps <= x <= max(xi,xj) + eps) and (min(yi,yj) - eps <= y <= max(yi,yj) + eps):\nreturn False\n# ray cast\nif ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi):\ninside = not inside\nj = i\nreturn inside\n\ndef sample_curve_points(crv, sample_count):\npts = \n\ntry:\nparams = crv.DivideByCount(sample_count, True)\nif params:\npts = [crv.PointAt(t) for t in params]\nelse:\ndom = crv.Domain\npts = [crv.PointAt(dom.T0 + (dom.Length * i / float(sample_count))) for i in range(sample_count + 1)]\nexcept Exception:\ndom = crv.Domain\npts = [crv.PointAt(dom.T0 + (dom.Length * i / float(sample_count))) for i in range(sample_count + 1)]\nreturn pts\n\ndef classify_by_nesting_parity(guids,sample_count=160):\n\nitems = []\nfor g in guids:\n    crv = rs.coercecurve(g)\n    if not crv or not crv.IsClosed:\n        continue\n    ok, plane = crv.TryGetPlane()\n    if not ok:\n        plane = Rhino.Geometry.Plane.WorldXY\n    items.append((g, crv, plane))\n\nif not items:\n    print(\"No valid closed planar curves.\")\n    return [], []\n\n# Build sampled polygon (in its own plane coords) and also keep sampled 3D points\npolygons = {}  # guid -> (poly2_coords_list, plane, sample_pts3)\nfor g, crv, plane in items:\n    pts3 = sample_curve_points(crv, sample_count)\n    poly2 = [to_plane_xy(p, plane) for p in pts3]\n    if poly2 and poly2[0] != poly2[-1]:\n        poly2.append(poly2[0])\n    polygons[g] = (poly2, plane, pts3)\n\ninside = []\nbounding = []\n\n# For each curve A count how many other curves strictly contain it (all samples of A inside B)\ntotal = len(items)\nfor idx, (gA, crvA, plA) in enumerate(items):\n    # use the sample points already computed for A (if present)\n    if gA in polygons:\n        ptsA = polygons[gA][2]\n    else:\n        ptsA = sample_curve_points(crvA, sample_count)\n\n    container_count = 0\n    for gB, (polyB, plB, _) in polygons.items():\n        if gB == gA:\n            continue\n        if not polyB:\n            continue\n        # test all sample points of A in B's polygon (project each point to B plane)\n        all_inside = True\n        for p in ptsA:\n            x, y = to_plane_xy(p, plB)\n            if not point_in_polygon_strict(x, y, polyB):\n                all_inside = False\n                break\n        if all_inside:\n            container_count += 1\n\n    # classification by parity: odd -> inside; even -> bounding\n    if (container_count % 2) == 1:\n        inside.append(gA)\n        try:\n            rs.ObjectColor(gA, (0, 255, 0))\n        except: pass\n    else:\n        bounding.append(gA)\n        try:\n            rs.ObjectColor(gA, (255, 0, 0))\n        except: pass\n\nprint(\"Classified: inside = {}, bounding = {}  (sample_count={})\".format(len(inside), len(bounding), sample_count))\nreturn inside, bounding\n\ndef main():\nguids = rs.GetObjects(“Select closed planar curves (filtered)”, rs.filter.curve,\ncustom_filter=cpcs_filt, preselect=True)\nif not guids:\nprint(“No curves selected.”)\nreturn \n, \n\nrs.EnableRedraw(False)\nclassify_by_nesting_parity(guids)\nrs.EnableRedraw(True)\n\nif name == “main”:\nmain()",
      "language": "python",
      "author": "theanhkc07",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection"
  ],
  "has_accepted_answer": true,
  "category_id": 11,
  "posts_count": 10,
  "views": 199
}