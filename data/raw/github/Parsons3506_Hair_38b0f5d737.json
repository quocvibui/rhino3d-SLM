{
  "source_url": "https://github.com/Parsons3506/Hair/blob/2b9bdf0cafc9403964ca21e7a26b71872d408061/objectOriented_Hair.py",
  "repo": "Parsons3506/Hair",
  "repo_stars": 0,
  "repo_description": "spring 15",
  "license": "unknown",
  "filepath": "objectOriented_Hair.py",
  "instruction": "Object oriented hair",
  "code": "import rhinoscriptsyntax as rs\n#import myDefinitions as defs\nimport random as r\n\n\n\ndef GeneratePointFromCurve(inputCrv,distance,angle,threshold):\n    #generates a point off of a curve of a line\n    #returns list: [ point , vector ] \n    crvDomain = rs.CurveDomain(inputCrv)\n    ptParam = ((crvDomain[1]-crvDomain[0])/2)+crvDomain[0]\n    crvPt = rs.EvaluateCurve(inputCrv,ptParam)\n    curveTan = rs.CurveTangent(inputCrv,ptParam)\n    cPlane = rs.PlaneFromNormal(crvPt,curveTan)\n    rotVec = rs.VectorRotate(curveTan,r.uniform(angle-threshold,angle+threshold),cPlane[1])\n    newVec = rs.VectorRotate(rotVec,r.uniform(0,360),curveTan)\n    newVec = rs.VectorUnitize(newVec)\n    tailVec = rs.VectorScale(newVec,tailDist)\n    baseVec = rs.VectorScale(newVec,distance)\n    headVec = rs.VectorScale(newVec,headDist)\n    newPt = rs.PointAdd(crvPt,baseVec)\n\n    newBranch = Branch(crvPt,baseVec,[newPt,headVec],[crvPt,rs.VectorReverse(tailVec)])\n    objList.append(newBranch)\n    return [newPt,baseVec]\ndef GeneratePointFromPoint(inputPt,prevVec,distance,angle,threshold):\n    cPlane = rs.PlaneFromNormal(inputPt,prevVec)\n    rotVec = rs.VectorRotate(prevVec,r.uniform(angle-threshold,angle+threshold),cPlane[1])\n    newVec = rs.VectorRotate(rotVec,r.uniform(0,360),prevVec)\n    newVec = rs.VectorUnitize(newVec)\n    tailVec = rs.VectorScale(newVec,tailDist)\n    baseVec = rs.VectorScale(newVec,distance)\n    headVec = rs.VectorScale(newVec,headDist)\n    newPt = rs.PointAdd(inputPt,baseVec)\n    newBranch = Branch(inputPt,baseVec,[newPt,headVec],[inputPt,rs.VectorReverse(tailVec)])\n    objList.append(newBranch)\n    return [newPt,baseVec]\nclass Branch():\n\n\n    def __init__(self, BASE,VECTOR, HEAD, TAIL):\n        self.base = BASE\n        #vector list: previous vector,currentvector\n        self.vec = VECTOR\n        #self.bounds = BOUNDS\n        #self.bPts = BRANCHPOINTS\n        self.head = HEAD\n        self.tail = TAIL\n        #self.gen = GEN\n        \n    def grow(self):\n        p1 = self.head[0]\n        p2 = rs.PointAdd(self.head[0],self.head[1])\n        rs.AddLine(p1,p2)\n        p1 = self.tail[0]\n        p2 = rs.PointAdd(self.tail[0],self.tail[1])\n        rs.AddLine(p1,p2)\n#create the Branching\ndef update():\n    for i in range (0, len(objList)):\n        objList[i].grow()\n#def generateHair():\n    \ndef addCurve (inputCrv, distMin, distMax,inflow, arrVolume, gens, maxGen,vecInfluence):\n    #rs.EnableRedraw(False)\n    newgens = gens+1\n    \n    if gens<maxGen:\n        \n        domain = rs.CurveDomain (inputCrv)\n        randP1 = r.uniform(domain[0],domain[1])\n        curvePoint = rs.EvaluateCurve(inputCrv, randP1)\n        \n        if curvePoint != None:\n            \n    #Curve point Tangent Vector\n            strNewCrv = generate(inputCrv,curvePoint,randP1,distMin,distMax,rotAngle,angleThresh,vecInfluence)\n            strNewCrv = collideTest(strNewCrv,arrVolume)\n            lineList.append(strNewCrv)\n            rSd = r.randint(1, 10)\n            if rSd> 1 :\n                vecInf1 = influencer(strNewCrv,lineList,VInfScale)\n                vecInf2 = pathInfluence(strNewCrv,inflow,curvePullDistance)\n                vecInfTotal = vectorAverage([vecInf1,vecInf2])\n                addCurve (strNewCrv, distMin, distMax, inflow, arrVolume, newgens, maxGen, vecInfTotal)\n            if rSd>4:\n                vecInf1 = influencer(strNewCrv,lineList,VInfScale)\n                vecInf2 = pathInfluence(strNewCrv,inflow,curvePullDistance)\n                vecInfTotal = vectorAverage([vecInf1,vecInf2])\n                addCurve (strNewCrv, distMin, distMax, inflow, arrVolume, newgens, maxGen, vecInfTotal)\n    rs.EnableRedraw(True)\n\ndef main():\n    startCrv = rs.GetObject(\"select start Curve\",4)\n    if startCrv is None:\n        print \"curve Fail\"\n        return \n        \n    divPts = rs.DivideCurve(startCrv,divCount)\n    paramList = []\n    for i in range (0,len(divPts)):\n        cP = rs.CurveClosestPoint(startCrv,divPts[i])\n        paramList.append(cP)\n    divCrv = rs.SplitCurve(startCrv,paramList)\n    \n    for i in range (0,len(divCrv)):\n        branchPt = GeneratePointFromCurve(divCrv[i],dist,90,20)\n        rs.AddLine(rs.CurveMidPoint(divCrv[i]),branchPt[0])\n        \n        treeLoop(0,maxBranch,branchPt)\n            \ndef treeLoop(currentGen,maxGen,prevPt):\n    if currentGen < maxGen:\n        newPt = GeneratePointFromPoint(prevPt[0],prevPt[1],dist,45,10)\n        rs.AddLine(prevPt[0],newPt[0])\n        treeLoop(currentGen+1,maxGen,newPt)\n    else:\n        return\n            \nobjList = []\n\n\n\n\ndivCount = 30\nmaxBranch = 10\ndist = 10\nheadDist = 8\ntailDist = 3\n\n\n\n\nrs.EnableRedraw(False)\nmain()\nupdate()\nrs.EnableRedraw(True)\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}