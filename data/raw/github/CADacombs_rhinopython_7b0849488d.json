{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsCrv_starterFor_approximateCrv.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsCrv_starterFor_approximateCrv.py",
  "instruction": "Spb nurbs crv starter for approximate crv",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220905-06, 08-09: Created.\r\n230119: Added support for PolyCurve input.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'iDegree'; keys.append(key)\r\n    values[key] = 3\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iPointCt'; keys.append(key)\r\n    values[key] = 4\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPreserveEndTangentsForNonPolylines'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'iDegree':\r\n            if cls.riOpts[key].CurrentValue == cls.values[key]:\r\n                # No change.\r\n                return\r\n            if cls.riOpts[key].CurrentValue <= 0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                return\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            cls.values['iPointCt'] = cls.riOpts['iPointCt'].CurrentValue = cls.values['iDegree'] + 1\r\n            sc.sticky[cls.stickyKeys['iPointCt']] = cls.values['iPointCt']\r\n            return\r\n\r\n        if key == 'iPointCt':\r\n            if cls.riOpts[key].CurrentValue < (cls.values['iDegree'] + 1):\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = (cls.values['iDegree'] + 1)\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    #    def customGeometryFilter(rdObj, rgObj, compIdx):\r\n    #        return not rgObj.IsClosed\r\n    #\r\n    #    go.SetCustomGeometryFilter(customGeometryFilter)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('iDegree')\r\n        addOption('iPointCt')\r\n        addOption('bPreserveEndTangentsForNonPolylines')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iDegree'\r\n            Opts.riOpts[key].CurrentValue = int(abs(go.Number()))\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef simplifyPolyline(pl, target_pt_ct=6):\r\n    ct_In = pl.Count\r\n    if ct_In <= target_pt_ct:\r\n        return\r\n    \r\n    min = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    pl_WIP = pl.Duplicate()\r\n    ct_Min = ct_In - pl_WIP.ReduceSegments(tolerance=min)\r\n    if ct_Min == target_pt_ct:\r\n        return pl_WIP\r\n    \r\n    max = 10.0 * min\r\n    while True:\r\n        sc.escape_test()\r\n        pl_WIP = pl.Duplicate()\r\n        ct_Max = ct_In - pl_WIP.ReduceSegments(tolerance=max)\r\n        if ct_Max == target_pt_ct:\r\n            return pl_WIP\r\n        elif ct_Max < target_pt_ct:\r\n            break\r\n        max *= 10.0\r\n\r\n    while True:\r\n        sc.escape_test()\r\n        \r\n        mid = 0.5 * (min + max)\r\n        \r\n        #if abs(mid-min) <= Rhino.RhinoMath.ZeroTolerance:\r\n        #    return\r\n        \r\n        pl_WIP = pl.Duplicate()\r\n        ct_WIP = ct_In - pl_WIP.ReduceSegments(tolerance=mid)\r\n        \r\n        if ct_WIP == target_pt_ct:\r\n            return pl_WIP\r\n        if ct_WIP > target_pt_ct:\r\n            min = mid\r\n        elif ct_WIP < target_pt_ct:\r\n            max = mid\r\n        else:\r\n            raise Exception(\"What?\")\r\n        \r\n        if abs(max-min) <= Rhino.RhinoMath.ZeroTolerance:\r\n            return\r\n\r\n\r\ndef approximateCurveWithPolyline(crv, target_pt_ct=6):\r\n\r\n    tol_L = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    plc_WIP = crv.ToPolyline(\r\n        tolerance=tol_L,\r\n        angleTolerance=0.0,\r\n        minimumLength=0.0,\r\n        maximumLength=0.0)\r\n    ct_tL = plc_WIP.PointCount\r\n    if ct_tL == target_pt_ct:\r\n        return plc_WIP.ToPolyline()\r\n\r\n    plc_WIP.Dispose()\r\n\r\n    tol_H = 10.0 * tol_L\r\n    while tol_H < 0.1:\r\n        sc.escape_test()\r\n        plc_WIP = crv.ToPolyline(\r\n            tolerance=tol_H,\r\n            angleTolerance=0.0,\r\n            minimumLength=0.0,\r\n            maximumLength=0.0)\r\n        ct_tH = plc_WIP.PointCount\r\n        if ct_tH == target_pt_ct:\r\n            return plc_WIP.ToPolyline()\r\n        elif ct_tH < target_pt_ct:\r\n            break\r\n        tol_H *= 10.0\r\n\r\n    if ct_tH > target_pt_ct:\r\n        ret = simplifyPolyline(plc_WIP.ToPolyline(), target_pt_ct)\r\n        plc_WIP.Dispose()\r\n        return ret\r\n\r\n    plc_WIP.Dispose()\r\n\r\n    while True:\r\n        sc.escape_test()\r\n        \r\n        tol_M = 0.5 * (tol_L + tol_H)\r\n        \r\n        #if abs(tol_M-tol_L) <= Rhino.RhinoMath.ZeroTolerance:\r\n        #    return\r\n        \r\n        plc_WIP = crv.ToPolyline(\r\n            tolerance=tol_M,\r\n            angleTolerance=0.0,\r\n            minimumLength=0.0,\r\n            maximumLength=0.0)\r\n        \r\n        ct_tM = plc_WIP.PointCount\r\n        if ct_tM == target_pt_ct:\r\n            return plc_WIP.ToPolyline()\r\n        if ct_tM > target_pt_ct:\r\n            tol_L = tol_M\r\n            ct_tL = ct_tM\r\n        elif ct_tM < target_pt_ct:\r\n            tol_H = tol_M\r\n            ct_tH = ct_tM\r\n        else:\r\n            raise Exception(\"What?\")\r\n        \r\n        plc_WIP.Dispose()\r\n        \r\n        if abs(tol_H-tol_L) <= Rhino.RhinoMath.ZeroTolerance:\r\n            plc_Max = crv.ToPolyline(\r\n                tolerance=tol_H,\r\n                angleTolerance=0.0,\r\n                minimumLength=0.0,\r\n                maximumLength=0.0)\r\n            return plc_Max.ToPolyline()\r\n\r\n\r\ndef samplePointsOnArcCurve(ac, pt_ct):\r\n    ts = rg.ArcCurve.DivideByCount(\r\n        ac, segmentCount=pt_ct-1, includeEnds=True)\r\n    return Rhino.Collections.Point3dList(\r\n        [rg.ArcCurve.PointAt(ac, t) for t in ts])\r\n\r\n\r\ndef getStartingCpLocations(rgCrv_In, pt_ct):\r\n\r\n    if pt_ct == 2:\r\n        return rg.Polyline([rgCrv_In.PointAtStart, rgCrv_In.PointAtEnd])\r\n\r\n    if isinstance(rgCrv_In, rg.PolylineCurve):\r\n        pl = rgCrv_In.ToPolyline()\r\n        return simplifyPolyline(pl, target_pt_ct=pt_ct)\r\n    elif isinstance(rgCrv_In, rg.PolyCurve):\r\n        nc = rgCrv_In.ToNurbsCurve()\r\n        ret = approximateCurveWithPolyline(nc, target_pt_ct=pt_ct)\r\n        nc.Dispose()\r\n        return ret\r\n    elif isinstance(rgCrv_In, (rg.NurbsCurve, rg.PolyCurve)):\r\n        return approximateCurveWithPolyline(rgCrv_In, target_pt_ct=pt_ct)\r\n    elif isinstance(rgCrv_In, rg.ArcCurve):\r\n        return samplePointsOnArcCurve(rgCrv_In, pt_ct)\r\n\r\n\r\ndef setEndConditions(rgCrv_ToMod, rgCrv_Target, bTanEnds):\r\n    if bTanEnds:\r\n        bSuccess_Start = rgCrv_ToMod.SetEndCondition(\r\n            bSetEnd=False,\r\n            continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n            point=rgCrv_Target.PointAtStart,\r\n            tangent=rgCrv_Target.TangentAtStart)\r\n        bSuccess_End = rgCrv_ToMod.SetEndCondition(\r\n            bSetEnd=True,\r\n            continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n            point=rgCrv_Target.PointAtEnd,\r\n            tangent=rgCrv_Target.TangentAtEnd)\r\n    else:\r\n        bSuccess_Start = rgCrv_ToMod.SetEndCondition(\r\n            bSetEnd=False,\r\n            continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Position,\r\n            point=rgCrv_Target.PointAtStart,\r\n            tangent=rg.Vector3d.Unset)\r\n        bSuccess_End = rgCrv_ToMod.SetEndCondition(\r\n            bSetEnd=True,\r\n            continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Position,\r\n            point=rgCrv_Target.PointAtEnd,\r\n            tangent=rg.Vector3d.Unset)\r\n\r\n    return bSuccess_Start or bSuccess_End\r\n\r\n\r\ndef createCurve(rgCrv_In, degree, pt_ct, bTanEnds=True):\r\n    \"\"\"\r\n    Parameters:\r\n        rgCrv\r\n        degree\r\n        pt_ct\r\n        bPreserveTans: Only for non-polylines\r\n    Returns:\r\n    \"\"\"\r\n\r\n    points = getStartingCpLocations(rgCrv_In, pt_ct)\r\n    if not points: return\r\n\r\n    if points.Count == pt_ct:\r\n        nc = rg.NurbsCurve.Create(periodic=False, degree=degree, points=points)\r\n    else:\r\n        nc = rg.NurbsCurve.Create(\r\n            periodic=False,\r\n            degree=degree-(pt_ct-points.Count),\r\n            points=points)\r\n        nc.IncreaseDegree(degree)\r\n\r\n    if not bTanEnds:\r\n        return nc\r\n\r\n    if points.Count == 2:\r\n        # Nothing else can be done with this curve.\r\n        return nc\r\n\r\n    if degree == 2 and points.Count == 3:\r\n        print(\"TODO: Create parabolic degree 2.\")\r\n\r\n    if not setEndConditions(nc, rgCrv_In, bTanEnds):\r\n        print(\"Failed setting end condition (continuity).\")\r\n        return\r\n\r\n    return nc\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_In = getInput()\r\n    if objrefs_In is None: return\r\n\r\n    iDegree = Opts.values['iDegree']\r\n    iPointCt = Opts.values['iPointCt']\r\n    bPreserveEndTangentsForNonPolylines = Opts.values['bPreserveEndTangentsForNonPolylines']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    for objref_In in objrefs_In:\r\n        rgCrv = objref_In.Curve()\r\n        rc_Res = createCurve(\r\n            rgCrv,\r\n            degree=iDegree,\r\n            pt_ct=iPointCt,\r\n            bTanEnds=bPreserveEndTangentsForNonPolylines)\r\n        if rc_Res:\r\n            sc.doc.Objects.AddCurve(rc_Res)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}