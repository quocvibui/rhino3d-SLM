{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_CombineSolarEnvelopes.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_CombineSolarEnvelopes.py",
  "instruction": "Use this component to combine two or more solar envelopes from Ladybug_SolarEnvelope component",
  "code": "# Combine Solar Envelopes\n# Combine two or more solar envelopes from Ladybug_SolarEnvelope component\n# Applicable to solar rights and solar access.\n# A typical use could be to create nultiple envelopes by various filter parameters for different facades in the surrounding \n# and combining them to one. For instance choosing morning hours to apply for east facades, noon for south and after noon \n# for west to ensure solar access to each orientation on critical times.\n\n\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Boris Plotnikov <pborisp@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\"\"\"\nUse this component to combine two or more solar envelopes from Ladybug_SolarEnvelope component\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _baseSrf: A surface representing the area for which you want to create the solar envelope (could also be a closed planer curve). Must be the same as the _BaseSrf connected to the solar Envelope component.\n        _envelopePts: A list of 3d points representing the heights to which the solar envelope reaches. Use the envelopePts output from the solar envelope component.\n        HighestEnv_: if HighestEnv_ is True we'll take the highest points and if it's False we'll take the lowest ones. Default value is True\n        _gridSize: A numeric value inidcating the gird size of the analysis in Rhino model units. Muse be the same as the gridSize_ value connected to the solar Envelope component.\n    Returns:\n        newEnvPoints: A list of 3d points representing the heights to which the solar envelope reaches.  Plug into a native GH 'Delunay Mesh' component to visualize the full solar envelope.\n        envelopeBrep: Brep representing the envelope.\n\"\"\"\n\nghenv.Component.Name = 'Ladybug_CombineSolarEnvelopes'\nghenv.Component.NickName = 'CombineEnvelopes'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"5 | Extra\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport Rhino\nimport Grasshopper.Kernel as gh\n\ndef issueWarning(message,boolToReturn = False):\n    print message\n    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, message)\n    return boolToReturn\n\nallDataProvided = True\nif not _baseSrf :\n    allDataProvided = issueWarning(\"Base surface must be provided\")\nif not _envelopePts:\n    allDataProvided = issueWarning(\"Envelope points must be provided\")\nif not _gridSize:\n    allDataProvided = issueWarning(\"Grid size must be provided\")\n\nif allDataProvided:\n    if HighestEnv_ is None: HighestEnv_ = True\n    \n    #a weird way of determining how many solar envelope points we have - should probably get the lists as tree branches or something\n    numOfEnvelopes = len(ghenv.Component.Params.Input[1].Sources)\n    totalPoints = len(_envelopePts)\n    pointsPerEnv = int(totalPoints/numOfEnvelopes)\n    \n    #convert the base surface to a mesh\n    regionMeshPar = Rhino.Geometry.MeshingParameters.Default\n    regionMeshPar.MinimumEdgeLength = regionMeshPar.MaximumEdgeLength = _gridSize/2\n    regionMesh = Rhino.Geometry.Mesh.CreateFromBrep(_baseSrf, regionMeshPar)[0]\n    \n    #loop through all the points in all the envelopes and populate a list of the highest or lowest points\n    newEnvPoints = []\n    for i in range(0,pointsPerEnv,1):\n        val = _envelopePts[i]\n        for j in range(0,numOfEnvelopes - 1, 1):\n            if HighestEnv_:\n                if _envelopePts[i + (j + 1) * pointsPerEnv].Z > val.Z:\n                    val = _envelopePts[i + (j + 1) * pointsPerEnv]\n            else:\n                if _envelopePts[i + (j + 1) * pointsPerEnv].Z < val.Z:\n                    val = _envelopePts[i + (j + 1) * pointsPerEnv]\n        newEnvPoints.append(val)\n    \n    #set the new height of all the points constructing the envelope brep\n    for vertexCount, gridPt in enumerate(newEnvPoints):\n        regionMesh.Vertices[vertexCount] = Rhino.Geometry.Point3f(gridPt.X,gridPt.Y, gridPt.Z)\n        finalEnvelopeBrep = Rhino.Geometry.Brep.CreateFromMesh(regionMesh,True)\n    envelopeBrep = finalEnvelopeBrep\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}