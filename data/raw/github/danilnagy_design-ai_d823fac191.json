{
  "source_url": "https://github.com/danilnagy/design-ai/blob/3937e930b1c3dd86d86e721f31a640d62c9786a3/docs/projects/subd/subd.py",
  "repo": "danilnagy/design-ai",
  "repo_stars": 2,
  "repo_description": null,
  "license": "MIT",
  "filepath": "docs/projects/subd/subd.py",
  "instruction": null,
  "code": "import Rhino.Geometry as rh\nfrom scriptcontext import doc\n\n# get absolute and angle tolerances from document\nabs_tol = doc.ModelAbsoluteTolerance\nang_tol = doc.ModelAngleToleranceRadians\n\n# this function splits a curve c1 with another curve c2\n\n\ndef split_curve(c1, c2, close):\n    # get intersection events between two curves\n    inter = rh.Intersect.Intersection.CurveCurve(c1, c2, abs_tol, abs_tol)\n\n    # get parameters on first curve from all intersection events\n    # this code uses a \"list comprehension\" which is a shortcut for iterating over a list in Python\n    # this single line does the same thing as:\n\n    # p = []\n    # for i in range(inter.Count):\n    # p.append(inter[i].ParameterA)\n\n    p = [inter[i].ParameterA for i in range(inter.Count)]\n\n    # handle multiple intersections (for non-convex boundaries)\n\n    # if more than two parameters are returned, it means that the boundary shape is non-convex\n    # and was split by the split line into more than two pieces\n    # since we only want two pieces, we must find two consecutive parameters\n    # which split the boundary into only two separate pieces\n\n    if len(p) > 2:\n\n        # loop over all parameters\n        for i in range(len(p)):\n\n            # get the points at the previous and current parameters in the list\n            pt1 = c1.PointAt(p[i-1])\n            pt2 = c1.PointAt(p[i])\n\n            # get the line between the two points\n            l = rh.Line(pt1, pt2).ToNurbsCurve()\n\n            # check how many times the line intersects the boundary\n            inter = rh.Intersect.Intersection.CurveCurve(\n                c1, l.ToNurbsCurve(), abs_tol, abs_tol)\n\n            # if there are only two intersections, return the two parameters\n            # and break out of loop\n            if len(inter) == 2:\n                p = [p[i-1], p[i]]\n                break\n\n    # split the curve by the parameters\n    pieces = c1.Split(p)\n\n    # create a new list to store the final curves\n    curves = []\n\n    # iterate over pieces\n    for piece in pieces:\n        # if closed curves were requested and the curve is not closed\n        if close == True and not piece.IsClosed:\n            # create a new line to close the curve, join them together, and add the result to curves list\n            line = rh.Line(piece.PointAtStart, piece.PointAtEnd).ToNurbsCurve()\n            curves += rh.NurbsCurve.JoinCurves([piece, line])\n        else:\n            # otherwise add the original piece to the curves list\n            curves.append(piece)\n\n    # return the final curves\n    return curves\n\n# this function splits a space with two parameters\n\n\ndef split_space(curve, dir, param):\n\n    # get the bounding box of the curve\n    bb = curve.GetBoundingBox(True)\n    # get the base point of the bounding box\n    base_pt = rh.Point3d(bb.Min.X, bb.Min.Y, 0.0)\n\n    # get the x and y dimensions of the bounding box\n    x = bb.Max.X - bb.Min.X\n    y = bb.Max.Y - bb.Min.Y\n\n    # create a list of the x,y dimensions and x,y unit vectors\n    dims = [x, y]\n    vecs = [rh.Vector3d(1, 0, 0), rh.Vector3d(0, 1, 0)]\n\n    # create a vector to position the split line based on the two parameters\n    vec_1 = vecs[dir] * dims[dir] * param\n\n    # copy the base point\n    new_pt_1 = rh.Point3d(base_pt)\n    # move the new point according to the vector\n    new_pt_1.Transform(rh.Transform.Translation(vec_1))\n\n    # calculate the opposite of the dir parameter\n    # if the parameter is 0 this results in 1, if 1 then 0\n    other_dir = abs(dir-1)\n\n    # create a vector in the other direction the full extent of the bounding box\n    vec_2 = vecs[other_dir] * dims[other_dir]\n\n    # create a copy of the moved point\n    new_pt_2 = rh.Point3d(new_pt_1)\n    # move the point to define the other end point of the split line\n    new_pt_2.Transform(rh.Transform.Translation(vec_2))\n\n    # create the split line and convert it to a Nurbs Curve\n    # (this is necessary to make the splitting work in the next function)\n    split_line = rh.Line(new_pt_1, new_pt_2).ToNurbsCurve()\n\n    # use the split_curve() function to split the boundary with the split line\n    parts = split_curve(curve, split_line, True)\n\n    # return the curves resulting from the split\n    return parts\n\n# this function calls the split_space() function recursively\n# to continuosly split an input curve into parts based on a set of parameters\n\n\ndef split_recursively(curves, dirs, params):\n\n    # if there are no more parameters in the list, return the input curves\n    if len(dirs) <= 0 or len(params) <= 0:\n        return curves\n\n    # get the first parameters and the first curve from the input lists\n    dir = dirs.pop(0)\n    param = params.pop(0)\n    curve = curves.pop(0)\n\n    # split the curve and add the results to the curves list\n    curves += split_space(curve, dir, param)\n\n    # run the split_recursively() function again with the updated curves list and the remaining parameters\n    return split_recursively(curves, dirs, params)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}