{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/plugin_files/Batch_Export.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "plugin_files/Batch_Export.py",
  "instruction": "Batch export",
  "code": "ï»¿from ghpythonlib.componentbase import dotnetcompiledcomponent as component\nimport Grasshopper, GhPython\nimport System, Rhino, os\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.treehelpers as th\nimport ghpythonlib.components as ghcomp\nimport scriptcontext as sc\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\n\nrcdoc = Rhino.RhinoDoc.ActiveDoc\nghdoc = sc.doc\n\n\nclass MyComponent(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\n            \"BatchExport\", \"BatchExport\", \"\"\"Exports geometry to a new file or to multiple new files.\nThis component exports GH geometry structured as a tree into files.\nThe output file number is the same as the number of input file names.\nThe output file extensions can be .3DM, .DWG, .SVG, or .AI.\nBased on the work of Jackie Berry.\n    Typical usage example:\nInput geometry as branches, a list of file names, an export file path, and a boolean to activate the component.\nThe Layer names list, colors list, and 'delete existing' boolean inputas are optional.\nWhen 'Export' is set to 'True', files will be created.\"\"\", \"Extra\", \"LocalCode\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"a1ff11d2-e062-41d0-bd93-5503dc532301\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"geometry\", \"geometry\", \"Data tree of geometries. Every branch corresponds to a layer.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.tree\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"exportFileName\", \"exportFileName\", \"Export file name.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"exportFilePath\", \"exportFilePath\", \"Target directory.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"layerNames\", \"layerNames\", \"List of layer names to bake geometry into.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"layerColors\", \"layerColors\", \"List of colors (Optional). Can be one color or as many colors as layer names.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"Export\", \"Export\", \"boolean to run component\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"deleteExisting\", \"deleteExisting\", \"boolean to delete geometry already in document.\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    \n    def RegisterOutputParams(self, pManager):\n        pass    \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        p1 = self.marshal.GetInput(DA, 1)\n        p2 = self.marshal.GetInput(DA, 2)\n        p3 = self.marshal.GetInput(DA, 3)\n        p4 = self.marshal.GetInput(DA, 4)\n        p5 = self.marshal.GetInput(DA, 5)\n        p6 = self.marshal.GetInput(DA, 6)\n        result = self.RunScript(p0, p1, p2, p3, p4, p5, p6)\n\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY/l8WUAAAJuSURBVEhLvZRNaBNBGIY3FkUTi1ol/bOSEkkiokjtQdrUkh8bK8Glrdh4KBWq6EUPevCgWH8gaCuCIIgeAl7Eg3oQlYII6kW8iUcVSlGqqBSpxUot+XzfmR2omNaYrj7wEPbd+WY2386s9T/wws2w8R/Iea1UT6ZWBgbCku1fK9lTLoh5Bgcj0mVXCxdoOnIoICLbYRLGXXAbTMm+3jq1AMmk2/1fRkeiuBET+dpSulhg+FWzxGMVHzGvrafXRIJrfM8fPmjAoITItwLFszkOJ7equru3N0ldjfcJ5qvX0/7KIsvyXMmeCaknkelWXVxoUiPv5zFuOiYnjgXZkgtwgZptDvZ22FUTn0ZR/KeW4f674WZJJf1jqNuty4tjYyRU/uLpo8bfW6ZawskTMnSvQeoDvmcYH9Jlf4e3zFOWu3g+rFs2hT5z8h9oST4uZ7Ed0dLLGLdQDy+dA5numvHPH7DLvrfK+7dR6bRVS3r0bXfou5GL4J+0ydVL6/gyd+nYPez7t9ZjgbTcvL6BC8R07B4dnTv90n8yLOn2Si6Q0LF78KMYhDxA/F0MS8YDV8MAXMnAYQlcAbmYoRxWQT9kXVH44AicgtcYOAzBSfhYXWnOwQn4Bs5ceE6Wwjxkr+8wcHgJmb1WV5ocZEZZVxQ8OEfhaTjzi9gLmfWpK00SHoeH4bwP3Lzh7uDppKsYAL7sjCNfJKmEJqtmACpgl2Mtg0IchKafUQZgDzRZGwOwA5rMtJDjTcaaguyHZlATA8BPsMnM4UpBk6UZAI432ayfbf71Fsin4f4mPAfM6DIGzu8Wx+UMAHeQydguYFk/ATL702eHHBctAAAAAElFTkSuQmCC\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n\n    def RunScript(self, geometry, exportFileName, exportFilePath, layerNames, layerColors, Export, deleteExisting):\n        if geometry == None:\n            self.AddRuntimeMessage(RML.Warning, \"Add geometry in branches.\")\n        if exportFileName == None:\n            self.AddRuntimeMessage(RML.Warning, \"Add a export File Name.\")\n        if exportFilePath:\n            self.AddRuntimeMessage(RML.Warning, \"Add a export File Path.\")\n\n        def bake(geometry, layerNames, layerColors):\n            geometryList = [geometry.Branch(b) for b in range(geometry.BranchCount)]\n        #    print geometryList\n            if len(geometryList) != len(layerNames):\n                print \"The number of layers must match the number of branches\"\n                self.AddRuntimeMessage(RML.Error,\"The number of layers must match the number of branches\")\n                return\n            elif len(layerColors)!=len(layerNames) or layerColors==[]:\n                self.AddRuntimeMessage(RML.Warning, \"The number of layer colors must match the number of layers.\")\n                print \"The number of layer colors must match the number of layers.\"\n            else:\n                attr= Rhino.DocObjects.ObjectAttributes()\n                sc.doc = rcdoc\n\n                for i in range(len(geometryList)):\n                    currentLayer= layerNames[i]\n                    if layerColors== None:\n                        currentColor= None\n                    else:\n                        currentColor=layerColors[i]\n\n                    #if layer does not exist, make the layer and assign layer color\n                    if not rs.IsLayer(currentLayer):\n                        print \"layer doesn't exist\"\n                        if layerColors!= None:\n                            rs.AddLayer(name= currentLayer, color= currentColor)\n                    #if layer exists, check and assign layer color\n                    if currentColor!=None and rs.LayerColor(currentLayer)!=currentColor:\n                        rs.LayerColor(currentLayer, currentColor)\n\n                    #get index of current layer\n                    layerIndex = rs.LayerOrder(currentLayer)\n\n                    #get objects on this branch\n\n                    for id in geometryList[i]:\n                        sc.doc = ghdoc\n                        gh_to_rhino = rs.coercerhinoobject(id)\n\n                        #set object layer\n                        objAttr = gh_to_rhino.Attributes\n                        objAttr.LayerIndex = layerIndex\n                        #separate geometry\n                        objGeom = gh_to_rhino.Geometry\n\n                        #bake!\n                        sc.doc=rcdoc\n                        rcdoc.Objects.Add(objGeom, objAttr)\n            return\n\n\n        \"\"\"\n        Export geometry in file to file name\n        \"\"\"\n        def export():\n            #select objects to export\n            sc.doc= rcdoc\n            rs.AllObjects(select=True)\n            filepath = os.path.join(exportFilePath, exportFileName)\n            exportCommandString = '_-Export \"' + filepath + '\" _Enter _Enter _Enter'\n            out = rs.Command(exportCommandString, echo=True)\n            sc.doc=ghdoc\n            return\n\n\n        \"\"\"\n        deletes all existing geometry from document.\n        \"\"\"\n        def deleteExistingGeom():\n            sc.doc = rcdoc\n            allObjs = rs.AllObjects()\n            rs.DeleteObjects(allObjs)\n            sc.doc = ghdoc\n            return\n\n        \"\"\"\n        Meat of the component\n        \"\"\"\n        if Export:\n            if (geometry!=None) and (exportFileName!=None) and (exportFilePath!=None)\\\n            and (layerNames!=None) and (layerColors!=[]):\n                if deleteExisting:\n                    deleteExistingGeom()\n                bake(geometry, layerNames, layerColors)\n                export()\n                \n            elif geometry==None:\n                print \"Please add input geometry\"\n            elif exportFileName==None:\n                print \"Please specify a name for your export file.\"\n            elif exportFilePath==None:\n                print \"Please specify a destination directory for your export.\"\n            elif layerNames==None:\n                print \"Please specify target layers for each branch of your geometry.\"\n            elif layerColors==[]:\n                print \"Please add layer colors.\"\n\n        return\n\n\nimport GhPython\nimport System\n\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\n    def get_AssemblyName(self):\n        return \"BatchExport\"\n    \n    def get_AssemblyDescription(self):\n        return \"\"\"\"\"\"\n\n    def get_AssemblyVersion(self):\n        return \"0.1\"\n\n    def get_AuthorName(self):\n        return \"\"\n    \n    def get_Id(self):\n        return System.Guid(\"52e31e47-d50a-46b1-b138-9317d902a14f\")",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}