{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_PV%20SWH%20System%20Size.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_PV SWH System Size.py",
  "instruction": "Use this component to generate the PVsurface or SWHsurface for \"Photovoltaics surface\" or \"Solar Water Heating surface\" components, based on initial PV or SWH system sizes.\n-\nProvided by Ladybug...",
  "code": "# PV SWH system size\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Djordje Spasic <djordjedspasic@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate the PVsurface or SWHsurface for \"Photovoltaics surface\" or \"Solar Water Heating surface\" components, based on initial PV or SWH system sizes.\n-\nProvided by Ladybug 0.0.69\n    \n    input:\n        _location: The output from the \"importEPW\" or \"constructLocation\" component.  This is essentially a list of text summarizing a location on the earth.\n        systemSize_: 1) In case of PV array: DC (Direct current) power rating of the photovoltaic array in kilowatts (kW) at standard test conditions (STC). \n                     2) In case of SWH array: Capacity of the collectors array in thermal kilowatts (kw) at global or local testing conditions (ISO 9806, EN 12975, ASHRAE 93 ...)\n                     -\n                     If not supplied, 4 kW will be used as a default.\n                     -\n                     In kiloWatts (kW) or thermal kiloWatts (kWt).\n        arrayTiltAngle_: An angle from horizontal of the inclination of the PV/SWH array plane. Example: 0 = horizontal, 90 = vertical. (range 0-180)\n                         -\n                         To get the maximal amount of energy, input the \"optimalTilt\" output from \"Tilt And Orientation Factor\"'s component.\n                         -\n                         If not supplied, location's latitude will be used as default value.\n                         -\n                         In degrees ().\n        arrayAzimuthAngle_: The orientation angle (clockwise from the true north) of the PV/SWH array plane's normal vector. (range 0-360)\n                            -\n                            To get the maximal amount of energy, input the \"optimalAzimuth\" output from \"Tilt And Orientation Factor\"'s component.\n                            -\n                            If not supplied, the following values will be used as default: 180 (due south) for northern hemisphere, 0 (due north) for southern hemisphere.\n                            -\n                            In degrees().\n        tiltedArrayHeight_: The height of the array, measured in the tilted plane.\n                            It is depends on the height/width of the PV module/SWH collector. It also depends on the way modules/collectors are positioned in PV/SWH array (vertically or horizontally).\n                            It can vary from 1 to 2.3 meters x number of modules/collectors in a single PV/SWH column.\n                            -\n                            If not supplied, default value of 1.6 meters (with a single PV module/SWH collector per row) will be used.\n                            -\n                            In meters.\n        numberOfRows_: Number of rows to which PV or SWH array will be divided to.\n                       -\n                       If not supplied, 1 will be used as a default value (PV/SWH array will have only 1 row).\n        skewRowsDistance_: Distance in meters by which PV/SWH rows will be skewed.\n                           Use positive distance to skew the rows to the left.\n                           And negative distance to skew the rows to the right.\n                           -\n                           It requires the \"numberOfRows_\" to be larger than 1 in order to be able to skew the rows.\n                           -\n                           If not supplied, 0 will be used as a default (no rows skewing).\n        minimalSpacingPeriod_: Analysis period for which the minimal spacing distance between PV modules/SWH collector rows will derived of.\n                               In general this analysis period is taken from 9 to 15 hour on a day at which sun is at its lowest position during a year. That is 21th December in Northern and 21th June in Southern hemisphere (winter and summer solstice).\n                               However, this may not be economical for locations with higher latitudes due to low electricity generation during December/June.\n                               -\n                               So the following \"minimalSpacingPeriod_\" should be used based on location's latitude:\n                               * latitude <= 44: 21. December (northern hemisphere) / 21. June (southern hemisphere). 9-15hours\n                               * latitude 44 - 53: 15. November or 15. January (northern hemisphere) / 15. May or 15. July (southern hemisphere). 9-15hours\n                               * latitude 53 - 57: 15. October or 15. February (northern hemisphere) / 15. April or 15. August (southern hemisphere). 9-15hours\n                               * latitude > 57: 15. September or 15. March (for both northern and southern hemisphere). 9-15hours\n                               -\n                               It requires the \"numberOfRows_\" to be larger than 1 in order visualize the minimal spacing between rows.\n                               -\n                               Use Ladybug \"Analysis Period\" component to define this input.\n                               -\n                               If not supplied, it will be calculated based on upper mentioned criteria.\n        baseSurface_: Surface on which PV/SWH array will be laid onto.\n                      This can be a surface of an angled or flat roof. Or an angled or flat terrain. A facade of a building etc.\n                      -\n                      If not supplied, a regular horizontal surface in Rhino's XY plane will be used, as a default.\n        arrayOriginPt_: UV coordinate of baseSurface_ at which PV_SWH array will start.\n                        It ranges from 0 to 1.0 for both U and V coordinate.\n                        Use grasshopper's \"Construct Point\" or \"MD slider\" components to input it.\n                        -\n                        If not supplied, (0.5,0,0) will be used as a default value.\n        arrayOriginCorner_: Corner at which the PV/SWH array begins:\n                            -\n                            0 - center bottom\n                            1 - left bottom\n                            2 - right bottom\n                            3 - center top\n                            -\n                            If not supplied, 0 will be used as a default (bottom center).\n        north_: Input a vector to be used as a true North direction, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis.\n                -\n                If not supplied, default North direction will be set to the Y-axis (0 degrees).\n        energyLoadPerHour_: A list of energy load values for each hour, during a year.\n                            1) In case of PV array: Electrical energy used for any kind of load: heating, cooling, electric lights, solar water heating circulation pump etc.\n                               Use Honeybee \"Read EP Result\" component or any other one to generate it.\n                               -\n                            2) In case of SWH array: Thermal heating energy (or electrical energy) required to heat domestic hot water and/or space heating load and/or space cooling load.\n                               Use Ladybug \"Residential Hot Water\" or \"Commercial Public Apartment Hot Water\" components to calculate it (simply plugin their \"heatingLoadPerHour\" outputs).\n                               -\n                               The purpose of this input is to divide the energy loads to each PV/SWH array rows.\n                            -\n                            If not inputted, \"energyLoadPerRowPerHour\" output will not be calculated.\n    \n    output:\n        readMe!: ...\n        PV_SWHsurface: Surfaces on which PV modules/SWH collectors will be laid on.\n        PV_SWHsurfacesArea: Total area of the PV_SWHsurfaces.\n                            -\n                            In Rhino documents units (meters, centimeters, feets...).\n        minimalSpacing: Minimal distance between fixed (anchor) points of rows.\n                        The distance is measured on the ground (or along the base surface if it has been inputted).\n                        -\n                        In meters.\n        minimalSpacingDate: Exact date taken from \"minimalSpacingPeriod_\" input for which minimal spacing between rows has been calculated.\n        originPt: Origin point of the PV / SWH array.\n        energyLoadPerRowPerHour: \"energyLoadPerHour_\" input's data divided to rows.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_PV SWH System Size\"\nghenv.Component.NickName = \"PV_SWH_SystemSize\"\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"4 | Renewables\"\n#compatibleLBVersion = VER 0.0.64\\nAPR_12_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport Grasshopper as grass\nimport scriptcontext as sc\nimport Rhino\nimport math\n\n\ndef changeInputNamesAndDescriptions(inputIndex, inputtedOrNot):\n    \n    inputNickNames = [[\"_PVmoduleSettings\", \"-\"], [\"_SWHsystemSettings\", \"-\"]]\n    inputDescriptions = [ \n     [\"A list of PV module settings. Use the \\\"Simplified Photovoltaics Module\\\" or \\\"Import CEC Photovoltaics Module\\\" or \\\"Import Sandia Photovoltaics Module\\\" components to generate them.\", \n      \"This inputt is not necessary. If you would like to calculate SWH surface, only the data you inputted to _SWHsystemSettings is required (not to this _PVmoduleSettings also).\"],\n     [\"A list of all SWH system settings. Use the \\\"Solar Water Heating System\\\" or \\\"Solar Water Heating System Detailed\\\" components to generate them.\",\n      \"This inputt is not necessary. If you would like to calculate PV surface, only the data you inputted to _PVmoduleSettings is required (not to this _SWHsystemSettings also).\"]\n     ]\n    \n    ghenv.Component.Params.Input[inputIndex].Name = inputNickNames[inputIndex-1][inputtedOrNot]\n    ghenv.Component.Params.Input[inputIndex].NickName = inputNickNames[inputIndex-1][inputtedOrNot]\n    ghenv.Component.Params.Input[inputIndex].Description = inputDescriptions[inputIndex-1][inputtedOrNot]\n\n\ndef checkInputData(location, PVmoduleSettings, SWHsystemSettings, systemSize, arrayTiltD, arrayAzimuthD, tiltedArrayHeight, numberOfRows, skewRowsDistance, minimalSpacingPeriod, baseBrep, arrayOriginPt, arrayOriginCorner, north, energyLoadPerHour, unitConversionFactor):\n    \n    if (location == None):\n        locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n        validInputData = False\n        printMsg = \"Please input _location from \\\"Import EPW\\\" or \\\"Construct Location\\\" components.\"\n        return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    else:\n        locationName, latitude, longitude, timeZone, elevation = lb_preparation.decomposeLocation(location)\n        latitude = float(latitude)\n        longitude = float(longitude)\n        timeZone = float(timeZone)\n    \n    if (north == None):\n        northDeg = 0\n    else:\n        northDeg = north\n        # check if north is valid\n        correctedSrfAzimuthD_dummy, northDeg, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(northDeg, 0)\n        if (validNorth == False):\n            locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n            validInputData = False\n            return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    \n    if (systemSize == None) or (systemSize <= 0):\n        systemSize = 4  # default value in kw\n    \n    if (arrayTiltD == None):\n        #arrayTiltD = 3.7 + 0.69 * abs(latitude)   # initial optimal tilt angle by \"Handbook of Photovoltaic Science and Engineering\", A. Luque, S. Hegedus, Wiley, 2003.\n        arrayTiltD = abs(latitude)  # default value\n    arrayTiltR = math.radians(arrayTiltD)\n    \n    if (arrayAzimuthD == None):\n        if latitude >= 0:\n            # northern hemisphere\n            arrayAzimuthD = 180  # due south, not explicitly 180 degrees (it can be changed according to north_ input)\n        elif latitude < 0:\n            # southern hemisphere\n            arrayAzimuthD = 0  # due north, not explicitly 0 degrees (it can be changed according to north_ input)\n    if arrayAzimuthD > 360: arrayAzimuthD = arrayAzimuthD - 360\n    if arrayAzimuthD < 0: arrayAzimuthD = 360 - abs(arrayAzimuthD)\n    \n    if (arrayAzimuthAngle_ == None):\n        # arrayAzimuthAngle_ NOT inputted\n        correctedSrfAzimuthD, northDeg_dummy, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(northDeg, arrayAzimuthD)\n    elif (arrayAzimuthAngle_ != None):\n        # arrayAzimuthAngle_ inputted. Never correct the final \"PV_SWHsurface\" surface for north (northDeg = 0)\n        correctedSrfAzimuthD, northDeg_dummy, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(0, arrayAzimuthD)\n    \n    arrayAzimuthRdummy, arrayAzimuthVec = lb_photovoltaics.angle2northClockwise(correctedSrfAzimuthD)\n    arrayAzimuthR = math.radians(correctedSrfAzimuthD)\n    \n    \n    if (tiltedArrayHeight == None) or (tiltedArrayHeight <= 0):\n        tiltedArrayHeight = 1.6  # default, in meters\n    else:\n        tiltedArrayHeight = tiltedArrayHeight/unitConversionFactor\n    \n    if (numberOfRows == None) or (numberOfRows <= 0):\n        numberOfRows = 1  # default\n    \n    if (skewRowsDistance == None):\n        skewRowsDistance = 0  # default, no skewing\n    else:\n        skewRowsDistance = skewRowsDistance/unitConversionFactor\n    \n    if (baseBrep == None):\n        xyPlane = Rhino.Geometry.Plane(Rhino.Geometry.Point3d(0,0,0), Rhino.Geometry.Vector3d(0,0,1))\n        arrayRectangle = Rhino.Geometry.Rectangle3d(xyPlane, Rhino.Geometry.Interval(-tiltedArrayHeight,tiltedArrayHeight), Rhino.Geometry.Interval(0,-tiltedArrayHeight))\n        baseBrep = Rhino.Geometry.Brep.CreatePlanarBreps([arrayRectangle.ToNurbsCurve()])[0]\n        baseBrep.Flip()\n    baseSurface = baseBrep.Faces[0]\n    reparametarizedDomain = Rhino.Geometry.Interval(0,1)\n    baseSurface.SetDomain(0,reparametarizedDomain)\n    baseSurface.SetDomain(1,reparametarizedDomain)\n    \n    PVsurfaceAzimuthAngle = None  # arrayAzimuthD\n    PVsurfaceInputType = \"brep\"\n    srfAzimuthD, surfaceTiltDCalculated = lb_photovoltaics.srfAzimuthAngle(PVsurfaceAzimuthAngle, PVsurfaceInputType, baseBrep, latitude)\n    PVsurfaceTiltAngle = None\n    groundTiltD = lb_photovoltaics.srfTiltAngle(PVsurfaceTiltAngle, surfaceTiltDCalculated, PVsurfaceInputType, baseBrep, latitude)\n    groundTiltR = math.radians(groundTiltD)\n    \n    if (len(minimalSpacingPeriod) != 0) and (minimalSpacingPeriod[0] != None):\n        minimalSpacingPeriodHOYs, months, days = lb_preparation.getHOYsBasedOnPeriod(minimalSpacingPeriod, 1)\n        minimalSpacingPeriodStartHOY = minimalSpacingPeriodHOYs[0]\n        minimalSpacingPeriodEndHOY = minimalSpacingPeriodHOYs[-1]\n        if minimalSpacingPeriodStartHOY == minimalSpacingPeriodEndHOY:\n            locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n            validInputData = False\n            printMsg = \"Start and End time of your \\\"minimalSpacingPeriod_\\\" input are the same. Please input a valid \\\"minimalSpacingPeriod_\\\" input.\"\n            return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n        else:\n            # minimalSpacingPeriod input ok\n            minimalSpacingPeriod1 = minimalSpacingPeriod2 = minimalSpacingPeriod\n    \n    else:\n        # nothing inputted in \"minimalSpacingPeriod_\"\n        if (arrayTiltR < groundTiltR):  ## specific for angled PV arrays attached to a vertical building wall, or highly angled building wall\n            # highest sunAltitudeD angle\n            if latitude >= 0:  # northern hemisphere\n                # 21. June 9-15h\n                minimalSpacingPeriod1 = [(6, 21, 9), (6, 21, 15)]\n                minimalSpacingPeriod2 = [(6, 21, 9), (6, 21, 15)]\n            elif latitude < 0:  # southern hemisphere\n                # 21. December 9-15h\n                minimalSpacingPeriod1 = [(12, 21, 9), (12, 21, 15)]\n                minimalSpacingPeriod2 = [(12, 21, 9), (12, 21, 15)]\n        \n        else: ## for ground arrays, or lower angled roofs\n            if (latitude >= 0):  # northern hemisphere\n                if (latitude <= 44):\n                    # 21. December 9-15h\n                    minimalSpacingPeriod1 = [(12, 21, 9), (12, 21, 15)]\n                    minimalSpacingPeriod2 = [(12, 21, 9), (12, 21, 15)]\n                elif (latitude > 44) and (latitude <= 53):\n                    # 15. January/November 9-15h\n                    minimalSpacingPeriod1 = [(11, 15, 9), (11, 15, 15)]\n                    minimalSpacingPeriod2 = [(1, 15, 9), (1, 15, 15)]\n                elif (latitude > 53) and (latitude <= 57):\n                    # 15. February/October 9-15h\n                    minimalSpacingPeriod1 = [(10, 15, 9), (10, 15, 15)]\n                    minimalSpacingPeriod2 = [(2, 15, 9), (2, 15, 15)]\n                elif (latitude > 57):\n                    # 15. March/September 9-15h\n                    minimalSpacingPeriod1 = [(9, 15, 9), (9, 15, 15)]\n                    minimalSpacingPeriod2 = [(3, 15, 9), (3, 15, 15)]\n            \n            elif latitude < 0:  # southern hemisphere\n                if (latitude >= -44):\n                    # 21. June 9-15h\n                    minimalSpacingPeriod1 = [(6, 21, 9), (6, 21, 15)]\n                    minimalSpacingPeriod2 = [(6, 21, 9), (6, 21, 15)]\n                elif (latitude < -44) and (latitude >= -53):\n                    # 15. May/July 9-15h\n                    minimalSpacingPeriod1 = [(5, 15, 9), (5, 15, 15)]\n                    minimalSpacingPeriod2 = [(7, 15, 9), (7, 15, 15)]\n                elif (latitude < -53) and (latitude >= -57):\n                    # 15. April/August 9-15h\n                    minimalSpacingPeriod1 = [(4, 15, 9), (4, 15, 15)]\n                    minimalSpacingPeriod2 = [(8, 15, 9), (8, 15, 15)]\n                elif (latitude < -57):\n                    # 15. March/September 9-15h\n                    minimalSpacingPeriod1 = [(3, 15, 9), (3, 15, 15)]\n                    minimalSpacingPeriod2 = [(9, 15, 9), (9, 15, 15)]\n    \n    if (arrayOriginPt == None):\n        baseSurfaceUV = [(baseSurface.Domain(0)[0]+baseSurface.Domain(0)[1]) / 2, 0]\n    else:\n        baseSurfaceUV = [arrayOriginPt.X, arrayOriginPt.Y]\n    arrayOriginPt = baseSurface.PointAt(baseSurfaceUV[0], baseSurfaceUV[1])\n    # hide internalized \"arrayOriginPt_\" input's value\n    ghenv.Component.Params.Input[12].Hidden = True\n    \n    if (arrayOriginCorner == None) or (arrayOriginCorner < 0) or (arrayOriginCorner > 3):\n        arrayOriginCorner = 0  # bottom center origin\n    \n    \n    len_PVmoduleSettings = ghenv.Component.Params.Input[1].VolatileDataCount\n    len_SWHsystemSettings = ghenv.Component.Params.Input[2].VolatileDataCount\n    # calculate srfArea\n    if (len_PVmoduleSettings != 0) and (len_SWHsystemSettings != 0):  # data inputted into both PVmoduleSettings_ and SWHsystemSettings_ inputs\n        # assign descriptions to _PVmoduleSettings and _SWHsystemSettings inputs\n        changeInputNamesAndDescriptions(1, 0)\n        changeInputNamesAndDescriptions(2, 0)\n        locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n        validInputData = False\n        printMsg = \"Do not input data to _PVmoduleSettings, along with _SWHsystemSettings.\\n\\n\" +\\\n                   \"If you would like to calculate PV surface, input data to _PVmoduleSettings only (not to _SWHsystemSettings also).\\n\" +\\\n                   \"If you would like to calculate SWH surface, input data to _SWHsystemSettings only (not to _PVmoduleSettings also).\\n\"\n        return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    \n    if (len_PVmoduleSettings != 0) and (len_SWHsystemSettings == 0):  # data inputted to PVmoduleSettings_ but not to SWHsystemSettings_ input\n        changeInputNamesAndDescriptions(2, 1)\n        if (len_PVmoduleSettings == 9):\n            # 4 items inputted into \"PVmoduleSettings_\"\n            moduleModelName, mountTypeName, moduleMaterial, mountType, moduleActiveAreaPercent, moduleEfficiency, temperatureCoefficientFraction, a, b, deltaT = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n            collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = None\n            \n            activeArea = systemSize / (1 * (moduleEfficiency/100))  # area in m2\n            srfArea = activeArea * (100/moduleActiveAreaPercent) / (unitConversionFactor*unitConversionFactor)  # area in Rhino document units, PV system srfArea\n        elif (len_PVmoduleSettings == 23):\n            moduleModelName, moduleName, material, moduleMountType, moduleAreaM, moduleActiveAreaPercent, nameplateDCpowerRating_m, moduleEfficiency, Vmp_ref, Imp_ref, Voc_ref, Isc_ref, alpha_sc_ref, beta_oc_ref, IL_ref, Io_ref, Rs_ref, Rsh_ref, A_ref, n_s, adjust, gamma_r_ref, ws_adjusted_factor, Tnoct_adj = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n            collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = None\n            \n            moduleEfficiency = round( (Imp_ref * Vmp_ref) / (1000 * moduleAreaM * (moduleActiveAreaPercent/100))  * 100 ,2) # in percent (formula from SAM Technical Reference equation (9.33))\n            activeArea = systemSize / (1 * (moduleEfficiency/100))  # area in m2\n            srfArea = activeArea * (100/moduleActiveAreaPercent) / (unitConversionFactor*unitConversionFactor)  # area in Rhino document units, PV system srfArea\n        elif (len_PVmoduleSettings == 36):\n            moduleModelName, moduleName, material, moduleMountType, moduleAreaM, moduleActiveAreaPercent, nameplateDCpowerRating_m, moduleEfficiency, Vmp_ref, Imp_ref, Voc_ref, Isc_ref, alpha_sc_ref, beta_oc_ref, beta_mp_ref, mu_betamp, s, n, Fd, a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, b5, C0, C1, C2, C3, a, b, deltaT = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n            collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = None\n            \n            moduleEfficiency = round( (Imp_ref * Vmp_ref) / (1000 * moduleAreaM * (moduleActiveAreaPercent/100))  * 100 ,2) # in percent (formula from SAM Technical Reference equation (9.33))\n            activeArea = systemSize / (1 * (moduleEfficiency/100))  # area in m2\n            srfArea = activeArea * (100/moduleActiveAreaPercent) / (unitConversionFactor*unitConversionFactor)  # area in Rhino document units, PV system srfArea\n        elif (len_PVmoduleSettings != 9) and (len_PVmoduleSettings != 23) and (len_PVmoduleSettings != 36):\n            # not 4 items inputted into \"PVmoduleSettings_\"\n            locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n            validInputData = False\n            printMsg = \"Your \\\"_PVmoduleSettings\\\" input is incorrect. Please use \\\"PVmoduleSettings\\\" output from \\\"Simplified Photovoltaics Module\\\" or \\\"Import CEC Photovoltaics Module\\\" or \\\"Import Sandia Photovoltaics Module\\\" component.\"\n            return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    \n    elif (len_PVmoduleSettings == 0) and (len_SWHsystemSettings != 0):  # data not inputted to PVmoduleSettings_ but inputted to SWHsystemSettings_ input\n        changeInputNamesAndDescriptions(1, 1)\n        if (len_SWHsystemSettings == 23):\n            # 23 items inputted into \"SWHsystem_\"\n            collectorOpticalEfficiency = SWHsystemSettings[0]\n            collectorThermalLoss = SWHsystemSettings[1]\n            collectorActiveAreaPercent = SWHsystemSettings[2]\n            workingFluidHeatCapacity = SWHsystemSettings[3]\n            flowRatePerM2 = SWHsystemSettings[4]\n            IAMcoefficient = SWHsystemSettings[5]\n            skyViewFactor = SWHsystemSettings[6]\n            beamIndexPerHourData = SWHsystemSettings[7]\n            maxWorkingTemperature = SWHsystemSettings[8]\n            dischargeTemperature = SWHsystemSettings[9]\n            deliveryWaterTemperature = SWHsystemSettings[10]\n            avrJanuaryColdWaterTemperature = SWHsystemSettings[11]\n            mechanicalRoomTemperatureData = SWHsystemSettings[12]\n            pipeLength = SWHsystemSettings[13]\n            pipeDiameterMM = SWHsystemSettings[14]\n            pipeInsulationThicknessMM = SWHsystemSettings[15]\n            pipeInsulationConductivity = SWHsystemSettings[16]\n            pumpPower = SWHsystemSettings[17]\n            pumpEfficiency = SWHsystemSettings[18]\n            tankSizeLiters = SWHsystemSettings[19]\n            tankLoss = SWHsystemSettings[20]\n            heightDiameterTankRatio = SWHsystemSettings[21]\n            heatExchangerEffectiveness = SWHsystemSettings[22]\n            moduleEfficiency = moduleActiveAreaPercent = None\n            \n            activeArea = (systemSize + (collectorThermalLoss * 30/1000))/collectorOpticalEfficiency  # area in m2\n            srfArea = activeArea * (100/collectorActiveAreaPercent) / (unitConversionFactor*unitConversionFactor)  # area in Rhino document units, SWH system srfArea\n        elif (len_SWHsystemSettings != 23):\n            # not 23 items inputted into \"SWHsystem_\"\n            locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n            validInputData = False\n            printMsg = \"Your \\\"_SWHsystemSettings\\\" input is incorrect. Please use \\\"SWHsystemSettings\\\" outputs from \\\"Solar Water Heating system\\\" or \\\"Solar Water Heating system detailed\\\" components.\"\n            return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    \n    if (len_PVmoduleSettings == 0) and (len_SWHsystemSettings == 0):  # data inputted neither into both PVmoduleSettings_ nor SWHsystemSettings_ inputs\n        locationName = latitude = longitude = timeZone = northDeg = systemSize = srfArea = arrayTiltR = arrayAzimuthR = arrayAzimuthVec = tiltedArrayHeight = numberOfRows = skewRowsDistance = days = months = hours = sunAltitudeR_L = sunAzimuthR_L = minimalSpacingPeriod1 = minimalSpacingPeriod2 = baseSurfaceUV = arrayOriginPt = groundTiltR = arrayOriginCorner = moduleEfficiency = moduleActiveAreaPercent = collectorOpticalEfficiency = collectorThermalLoss = collectorActiveAreaPercent = energyLoadPerRowPerHourDataTree = None\n        validInputData = False\n        printMsg = \"If you would like to calculate PV surface, input data to _PVmoduleSettings (not to _SWHsystemSettings also).\\n\" +\\\n                   \"If you would like to calculate SWH surface, input data to _SWHsystemSettings (not to _PVmoduleSettings also).\"\n        return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n    \n    \n    if (len(energyLoadPerHour) == 0) or (energyLoadPerHour[0] == None):\n        energyLoadPerRowPerHour = []\n    else:\n        if (len(energyLoadPerHour) == 8767):\n            energyLoadPerHourData = energyLoadPerHour[7:]\n            header = energyLoadPerHour[:7]\n        elif (len(energyLoadPerHour) == 8760):\n            energyLoadPerHourData = energyLoadPerHour\n            header = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"unknown dataType\", \"unknown unit\", \"Hourly\", (1, 1, 1), (12, 31, 24)]\n        energyLoadPerRowPerHour = header + [value/numberOfRows for value in energyLoadPerHourData]\n    \n    \n    # extracting HOYs from minimalSpacingPeriod periods\n    minimalSpacingPeriodHOYs1, monthsDummy, daysDummy = lb_preparation.getHOYsBasedOnPeriod(minimalSpacingPeriod1, 1)\n    minimalSpacingPeriodHOYs2, monthsDummy, daysDummy = lb_preparation.getHOYsBasedOnPeriod(minimalSpacingPeriod2, 1)\n    \n    # clockwise sunAzimuthD\n    #northRad = math.radians(northDeg)\n    northRad, northVec = lb_photovoltaics.angle2northClockwise(northDeg)\n    northVec.Unitize()\n    \n    scale = 1\n    lb_sunpath.initTheClass(latitude, northRad, arrayOriginPt, scale, longitude, timeZone)\n    \n    # extracting hours, days, months from HOYs\n    solarTime = False\n    days = []; months = []; hours = []\n    sunAltitudeR_L = []; sunAzimuthR_L = []\n    for i,hoy in enumerate(minimalSpacingPeriodHOYs1):\n        d1, m1, h1 = lb_preparation.hour2Date(minimalSpacingPeriodHOYs1[i], True)\n        days.append(d1)\n        months.append(m1+1)\n        hours.append(h1)\n        lb_sunpath.solInitOutput(m1+1, d1, h1, solarTime)\n        sunAltitudeR1 = lb_sunpath.solAlt\n        sunAzimuthR1 = lb_sunpath.solAz\n        # correct \"sunAzimuthR1\" for north_\n        correctedSunAzimuthD = northDeg + math.degrees(sunAzimuthR1)\n        if correctedSunAzimuthD > 360:\n            correctedSunAzimuthD = correctedSunAzimuthD - 360\n        correctedSunAzimuthR1 = math.radians(correctedSunAzimuthD)\n        sunAltitudeR_L.append(sunAltitudeR1)\n        sunAzimuthR_L.append(correctedSunAzimuthR1)\n    \n    for i,hoy in enumerate(minimalSpacingPeriodHOYs2):\n        d2, m2, h2 = lb_preparation.hour2Date(minimalSpacingPeriodHOYs2[i], True)\n        days.append(d2)\n        months.append(m2+1)\n        hours.append(h2)\n        lb_sunpath.solInitOutput(m2+1, d2, h2, solarTime)\n        sunAltitudeR2 = lb_sunpath.solAlt\n        sunAzimuthR2 = lb_sunpath.solAz\n        # correct \"sunAzimuthR2\" for north_\n        correctedSunAzimuthD = northDeg + math.degrees(sunAzimuthR2)\n        if correctedSunAzimuthD > 360:\n            correctedSunAzimuthD = correctedSunAzimuthD - 360\n        correctedSunAzimuthR2 = math.radians(correctedSunAzimuthD)\n        sunAltitudeR_L.append(sunAltitudeR2)\n        sunAzimuthR_L.append(correctedSunAzimuthR2)\n    \n    # split the energyLoadPerHour_ according to numberOfRows_\n    energyLoadPerRowPerHourDataTree = grass.DataTree[object]()\n    for i in range(numberOfRows):\n        energyLoadPerRowPerHourDataTree.AddRange(energyLoadPerRowPerHour, grass.Kernel.Data.GH_Path(i))\n    \n    validInputData = True\n    printMsg = \"ok\"\n    \n    return locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg\n\n\ndef main(srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, skewRowsDistance, arrayOriginPt, groundTiltR, arrayOriginCorner):\n    \n    smallestSunAltitudeR_and_otherData = []\n    for i in range(len(sunAltitudeR_L)):\n        sunAltitudeR = sunAltitudeR_L[i]\n        sunAzimuthR = sunAzimuthR_L[i]\n        \n        if groundTiltR == 0: groundTiltR = 0.0000001  # fix for dividing with zero\n        if (arrayTiltR < groundTiltR):  # specific for angled PV arrays attached to a vertical building wall, or highly angled building wall\n            if arrayTiltR == 0: arrayTiltR = math.radians(0.0000001)  # fix for dividing with zero\n        \n        # arraySpacingDistance\n        if (arrayTiltR == 0):\n            # if arrayTiltAngle_ = 0\n            minArrayAngledRowSpacing = tiltedArrayHeight\n            horizontalProjectionOfTiltedArrayHeight = tiltedArrayHeight\n        else:\n            # based on: www.affordable-solar.com/Learning-Center/Building-a-System/Calculating-Tilted-Array-Spacing\n            arraysBoundingBoxHeight = tiltedArrayHeight * math.sin(arrayTiltR)\n            shadowDistance = arraysBoundingBoxHeight / math.tan(sunAltitudeR)\n            if sunAzimuthR >= math.pi:\n                # morning\n                minArrayHorizontalRowSpacing = shadowDistance * math.cos(arrayAzimuthR-sunAzimuthR)\n            else:\n                # afternoon\n                minArrayHorizontalRowSpacing = shadowDistance * math.cos(sunAzimuthR-arrayAzimuthR)\n            if minArrayHorizontalRowSpacing < 0:\n                minArrayHorizontalRowSpacing = abs(minArrayHorizontalRowSpacing)\n            if (minArrayHorizontalRowSpacing == 0) and (sunAltitudeR != 0):\n                minArrayHorizontalRowSpacing = tiltedArrayHeight\n            \n            horizontalProjectionOfTiltedArrayHeight = tiltedArrayHeight * math.cos(arrayTiltR)\n            XZplaneProjectedSunAltitudeR = math.atan(arraysBoundingBoxHeight/minArrayHorizontalRowSpacing)\n            firstSecondRowHeightDifference = (horizontalProjectionOfTiltedArrayHeight + minArrayHorizontalRowSpacing) / ((1/math.tan(groundTiltR)) + (1/math.tan(XZplaneProjectedSunAltitudeR)))\n            minArrayAngledRowSpacing = firstSecondRowHeightDifference / math.sin(groundTiltR)\n            smallestSunAltitudeR_and_otherData.append([minArrayAngledRowSpacing, sunAltitudeR, sunAzimuthR, days[i], months[i], hours[i]])\n    \n    # minimal spacing between rows will be take for the date with the longest minArrayAngledRowSpacing\n    smallestSunAltitudeR_and_otherData.sort()\n    minArrayAngledRowSpacing = smallestSunAltitudeR_and_otherData[-1][0]\n    day = smallestSunAltitudeR_and_otherData[-1][3]\n    month = smallestSunAltitudeR_and_otherData[-1][4]\n    hour = smallestSunAltitudeR_and_otherData[-1][5]\n    minimalSpacingDate = lb_preparation.hour2Date(lb_preparation.date2Hour(month, day, hour))\n    \n    \n    minArrayHorizonalRowSpacing = math.cos(groundTiltR) * minArrayAngledRowSpacing\n    horizontalProjectionOfTiltedArrayHeight = abs(horizontalProjectionOfTiltedArrayHeight)\n    \n    # generate PV SWH array surfaces\n    arrayPlane = Rhino.Geometry.Plane(arrayOriginPt, Rhino.Geometry.Vector3d(0,0,1))\n    arrayPlane.Rotate(-arrayTiltR, Rhino.Geometry.Vector3d(1,0,0))\n    # clockwise\n    arrayPlane.Rotate(-arrayAzimuthR, Rhino.Geometry.Vector3d(0,0,1))\n    # counterclockwise\n    #arrayPlane.Rotate(arrayAzimuthR, Rhino.Geometry.Vector3d(0,0,1))\n    \n    arraySideWidth = (srfArea/numberOfRows)/tiltedArrayHeight\n    \n    if arrayOriginCorner == 0:\n        # center bottom origin\n        arrayRectangle = Rhino.Geometry.Rectangle3d(arrayPlane, Rhino.Geometry.Interval(-arraySideWidth/2,arraySideWidth/2), Rhino.Geometry.Interval(0,-tiltedArrayHeight))\n    elif arrayOriginCorner == 1:\n        # left bottom origin\n        arrayRectangle = Rhino.Geometry.Rectangle3d(arrayPlane, Rhino.Geometry.Interval(-arraySideWidth,0), Rhino.Geometry.Interval(0,-tiltedArrayHeight))\n    elif arrayOriginCorner == 2:\n        # right bottom origin\n        arrayRectangle = Rhino.Geometry.Rectangle3d(arrayPlane, Rhino.Geometry.Interval(0,arraySideWidth), Rhino.Geometry.Interval(0,-tiltedArrayHeight))\n    if arrayOriginCorner == 3:\n        # center top origin\n        arrayRectangle = Rhino.Geometry.Rectangle3d(arrayPlane, Rhino.Geometry.Interval(arraySideWidth/2,-arraySideWidth/2), Rhino.Geometry.Interval(0, tiltedArrayHeight))\n    \n    PV_SWH_surface = Rhino.Geometry.Brep.CreatePlanarBreps([arrayRectangle.ToNurbsCurve()])[0]  # first row array surface\n    PV_SWH_surface.Flip()\n    \n    arrayAzimuthVec.Unitize()\n    arrayAzimuthVec.Reverse()\n    arrayAzimuthVec.Rotate(-groundTiltR, arrayPlane.XAxis)\n    \n    skewRowsMoveVector = Rhino.Geometry.Vector3d(arrayPlane.XAxis)\n    skewRowsMoveVector.Unitize()\n    skewRowsMoveVector = skewRowsMoveVector * skewRowsDistance\n    \n    transmatrix = Rhino.Geometry.Transform.Translation(arrayAzimuthVec*minArrayAngledRowSpacing + skewRowsMoveVector)\n    \n    PV_SWH_surfaceDataTree = grass.DataTree[object]()\n    PV_SWH_surfaceDataTree.AddRange([PV_SWH_surface], grass.Kernel.Data.GH_Path(0))\n    for i in range(numberOfRows-1):\n        nextRowSurface = PV_SWH_surfaceDataTree.Branches[i][0].Duplicate()\n        nextRowSurface.Transform(transmatrix)\n        PV_SWH_surfaceDataTree.AddRange([nextRowSurface], grass.Kernel.Data.GH_Path(i+1))\n    \n    return PV_SWH_surfaceDataTree, abs(minArrayAngledRowSpacing), minimalSpacingDate\n\n\ndef printOutput(locationName, latitude, longitude, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, tiltedArrayHeight, numberOfRows, skewRowsDistance, minimalSpacingPeriod1, minimalSpacingPeriod2, groundTiltR, baseSurfaceUV, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent):\n    resultsCompletedMsg = \"PV SWH system size component results successfully completed!\"\n    arrayOriginCornerDescription = [\"center bottom\", \"left bottom\", \"right bottom\", \"center top\"][arrayOriginCorner]\n    if moduleEfficiency != None:  # _PVmoduleSettings inputted:\n        PVSWHmoduleSystemSettings = \"Data taken from _PVmoduleSettings:\\nModule efficiency (perc.):  %s\\nModule active area percent (perc.):  %s\" % (moduleEfficiency, moduleActiveAreaPercent)\n    else:  # _SWHsystemSettings inputted:\n        PVSWHmoduleSystemSettings = \"Data taken from _SWHsystemSettings:\\nCollector optical efficiency (-):  %s,\\nCollector thermal loss (W/m2/C):  %s,\\nCollector active area percent (perc.):  %s,\" % (collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent)\n    if minimalSpacingPeriod1 == minimalSpacingPeriod2:\n        minimalSpacingPeriodString = \"%s\" % (minimalSpacingPeriod1)\n    else:\n        minimalSpacingPeriodString = \"%s or %s\" % (minimalSpacingPeriod1, minimalSpacingPeriod2)\n    printOutputMsg = \\\n    \"\"\"\nInput data:\n\nLocation:  %s,\nLatitude (deg.):  %s,\nLongitude (deg.):  %s,\nNorth (deg.):  %s,\n\nSystem size (kW):  %0.2f,\nSurface area (m2):  %0.2f,\nArray tilt angle (deg.):  %0.2f,\nArray azimuth angle (deg.):  %0.2f,\nTilted array height (m):  %0.2f,\nNumber of rows:  %0.2f,\nSkew rows distance (m):  %0.2f,\nMinimal spacing period:  %s,\nBase surface tilt angle(deg.):  %0.2f,\nArray origin point:  %0.2f, %0.2f,\nArray origin corner:  %s (%s),\n\n%s\n    \"\"\" % (locationName, latitude, longitude, northDeg, systemSize, srfArea, math.degrees(arrayTiltR), math.degrees(arrayAzimuthR), tiltedArrayHeight, numberOfRows, skewRowsDistance, minimalSpacingPeriodString, math.degrees(groundTiltR), baseSurfaceUV[0], baseSurfaceUV[1], arrayOriginCorner, arrayOriginCornerDescription, PVSWHmoduleSystemSettings)\n    print resultsCompletedMsg\n    print printOutputMsg\n\n\nlevel = gh.GH_RuntimeMessageLevel.Warning\nif sc.sticky.has_key(\"ladybug_release\"):\n    if sc.sticky[\"ladybug_release\"].isCompatible(ghenv.Component):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_sunpath = sc.sticky[\"ladybug_SunPath\"]()\n        lb_photovoltaics = sc.sticky[\"ladybug_Photovoltaics\"]()\n        unitConversionFactor = lb_preparation.checkUnits()\n        # assign descriptions to _PVmoduleSettings and _SWHsystemSettings inputs\n        changeInputNamesAndDescriptions(1, 0)\n        changeInputNamesAndDescriptions(2, 0)\n        if _location:\n            try:\n                PVmoduleSettingsInput = [item.Value if (item != None) else None for item in list(ghenv.Component.Params.Input[1].VolatileData)]\n            except:\n                PVmoduleSettingsInput = []\n            try:\n                SWHsystemSettingsInput = [item2.Value if (item2 != None) else None for item2 in list(ghenv.Component.Params.Input[2].VolatileData)]\n            except Exception, e:\n                SWHsystemSettingsInput = []\n            locationName, latitude, longitude, timeZone, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, skewRowsDistance, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, minimalSpacingPeriod1, minimalSpacingPeriod2, baseSurfaceUV, arrayOriginPt, groundTiltR, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, energyLoadPerRowPerHourDataTree, validInputData, printMsg = checkInputData(_location, PVmoduleSettingsInput, SWHsystemSettingsInput, systemSize_, arrayTiltAngle_, arrayAzimuthAngle_, tiltedArrayHeight_, numberOfRows_, skewRowsDistance_, minimalSpacingPeriod_, baseSurface_, arrayOriginPt_, arrayOriginCorner_, north_, energyLoadPerHour_, unitConversionFactor)\n            if validInputData:\n                PV_SWHsurface, minimalSpacing, minimalSpacingDate = main(srfArea, arrayTiltR, arrayAzimuthR, arrayAzimuthVec, tiltedArrayHeight, numberOfRows, days, months, hours, sunAltitudeR_L, sunAzimuthR_L, skewRowsDistance, arrayOriginPt, groundTiltR, arrayOriginCorner)\n                printOutput(locationName, latitude, longitude, northDeg, systemSize, srfArea, arrayTiltR, arrayAzimuthR, tiltedArrayHeight, numberOfRows, skewRowsDistance, minimalSpacingPeriod1, minimalSpacingPeriod2, groundTiltR, baseSurfaceUV, arrayOriginCorner, moduleEfficiency, moduleActiveAreaPercent, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent)\n                PV_SWHsurfacesArea = srfArea; energyLoadPerRowPerHour = energyLoadPerRowPerHourDataTree\n            else:\n                print printMsg\n                ghenv.Component.AddRuntimeMessage(level, printMsg)\n        else:\n            printMsg = \"Please input location from \\\"importEPW\\\" or \\\"constructLocation\\\" components.\"\n            print printMsg\n            ghenv.Component.AddRuntimeMessage(level, printMsg)\n    else:\n        printMsg = \"You need a newer version of Ladybug to use this component.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag the Ladybug_Ladybug component \" + \\\n            \"into the canvas and try again.\"\n        print printMsg\nelse:\n    printMsg = \"First please let the Ladybug fly...\"\n    print printMsg\n    ghenv.Component.AddRuntimeMessage(level, printMsg)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}