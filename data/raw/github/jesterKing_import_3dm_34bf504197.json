{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/converters/annotation.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/converters/annotation.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2024 Nathan Letwory\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\nimport rhino3dm as r3d\nfrom . import utils\nfrom . import curve\n\nfrom mathutils import Matrix\nimport math\n\nfrom enum import IntEnum, auto\nimport bpy\n\nclass PartType(IntEnum):\n    ExtensionLine = auto()\n    DimensionLine = auto()\n\nCONVERT = {}\n\n\nclass Arrow(IntEnum):\n    Arrow1 = auto()\n    Arrow2 = auto()\n    Leader = auto()\n    Leader2 = auto() # used in angular for second arrow\n\n\ndef _arrowtype_from_arrow(dimstyle : r3d.DimensionStyle, arrow : Arrow):\n    if arrow == Arrow.Arrow1:\n        return dimstyle.ArrowType1\n    elif arrow == Arrow.Arrow2:\n        return dimstyle.ArrowType2\n    elif arrow in (Arrow.Leader, Arrow.Leader2):\n        return dimstyle.LeaderArrowType\n\n\ndef _negate_vector3d(v : r3d.Vector3d):\n    return r3d.Vector3d(-v.X, -v.Y, -v.Z)\n\ndef _rotate_plane_to_line(plane : r3d.Plane, line : r3d.Line, addangle=0.0):\n    rotangle = r3d.Vector3d.VectorAngle(_negate_vector3d(line.Direction), plane.XAxis) + addangle\n    dpx = r3d.Vector3d.DotProduct(line.Direction, plane.XAxis)\n    dpy = r3d.Vector3d.DotProduct(line.Direction, plane.YAxis)\n    if dpx < 0 and dpy > 0 or dpx > 0 and dpy > 0:\n        rotangle = 2*math.pi - rotangle\n    plane = plane.Rotate(rotangle, plane.ZAxis)\n    return plane\n\n\ndef _add_arrow(dimstyle : r3d.DimensionStyle, pt : PartType, plane : r3d.Plane, bc, tip : r3d.Point3d, tail : r3d.Point3d, arrow : Arrow, scale : float):\n    arrtype = _arrowtype_from_arrow(dimstyle, arrow)\n    arrowhead_points = r3d.Arrowhead.GetPoints(arrtype, 1.0)\n    arrowhead = bc.splines.new('POLY')\n    arrowhead.use_cyclic_u = True\n    arrowhead.points.add(len(arrowhead_points)-1)\n    l = r3d.Line(tip, tail)\n    arrowLength = dimstyle.ArrowLength\n    inside = arrowLength * 2 < l.Length if arrow not in (Arrow.Leader, Arrow.Leader2) else True\n\n    tip_plane = r3d.Plane(tip, plane.XAxis, plane.YAxis)\n\n    if arrow == Arrow.Leader:\n        # rotate tip_plane so we get correct orientation of arrowhead\n        tip_plane = _rotate_plane_to_line(tip_plane, l)\n\n    if arrtype in (r3d.ArrowheadTypes.SolidTriangle, r3d.ArrowheadTypes.ShortTriangle, r3d.ArrowheadTypes.OpenArrow, r3d.ArrowheadTypes.LongTriangle, r3d.ArrowheadTypes.LongerTriangle):\n        if inside and arrow == Arrow.Arrow1:\n            tip_plane = tip_plane.Rotate(math.pi, tip_plane.ZAxis)\n        if not inside and arrow == Arrow.Arrow2:\n            tip_plane = tip_plane.Rotate(math.pi, tip_plane.ZAxis)\n    if arrtype in (r3d.ArrowheadTypes.Rectangle,):\n        if arrow == Arrow.Arrow1:\n            tip_plane = tip_plane.Rotate(math.pi, tip_plane.ZAxis)\n\n    if inside:\n        for i in range(0, len(arrowhead_points)):\n            uv = arrowhead_points[i]\n            p = tip_plane.PointAt(uv.X, uv.Y)\n            arrowhead.points[i].co = (p.X * scale, p.Y * scale, p.Z * scale, 1)\n\n\ndef _populate_line(dimstyle : r3d.DimensionStyle, pt : PartType, plane : r3d.Plane, bc, pt1 : r3d.Point3d, pt2 : r3d.Point3d, scale : float):\n    rhl = r3d.Line(pt1, pt2)\n    if rhl.Length < 1e-6:\n        return\n    line = bc.splines.new('POLY')\n    line.points.add(1)\n\n    # create line between given points\n    if pt == PartType.ExtensionLine:\n        ext = dimstyle.ExtensionLineExtension\n        offset = dimstyle.ExtensionLineOffset\n        extfr = 1.0 + ext / rhl.Length if rhl.Length > 0 else 0.0\n        offsetfr = offset / rhl.Length if rhl.Length > 0 else 0.0\n        pt1 = rhl.PointAt(offsetfr)\n        pt2 = rhl.PointAt(extfr)\n\n    pt1 *= scale\n    pt2 *= scale\n\n    line.points[0].co = (pt1.X, pt1.Y, pt1.Z, 1)\n    line.points[1].co = (pt2.X, pt2.Y, pt2.Z, 1)\n\n\ndef _add_text(dimstyle : r3d.DimensionStyle, plane : r3d.Plane, bc, pt : r3d.Point3d, txt : str, scale : float, left=False, textob=False):\n    textcurve = bpy.context.blend_data.curves.new(name=\"annotation_text\", type=\"FONT\")\n    textcurve.body = txt\n    # for now only use blender built-in font. Scale that down to\n    # 0.8 since it is a bit larger than Rhino default Arial\n    textcurve.size = dimstyle.TextHeight * scale * 0.8\n    textcurve.align_x = 'CENTER' if not left else 'LEFT'\n    pt *= scale\n    plane = r3d.Plane(pt, plane.XAxis, plane.YAxis)\n    if not textob:\n        xform = r3d.Transform.PlaneToPlane(r3d.Plane.WorldXY(), plane)\n    else:\n        textcurve.align_x = 'CENTER'\n        textcurve.align_y = 'TOP'\n        plane = plane.Rotate(math.pi, plane.ZAxis)\n        trl = r3d.Transform.Translation(0.0, -0.05, 0.00)\n        xform = r3d.Transform.Multiply(trl, r3d.Transform.PlaneToPlane(r3d.Plane.WorldXY(), plane))\n\n    bm = utils.matrix_from_xform(xform)\n\n    if textob:\n        # when adding a text annotation we need to verify that the tranform\n        # from XY plane to text plane has positive rotation value in the X of\n        # euler that represents the rotation for this transform.\n        # If it is negative add 180deg to both X and Z of the euler rotation.\n        (loc, rot, sca) = bm.decompose()\n        rote = rot.to_euler()\n        if rote.x < 0:\n            rote.x += math.pi\n            rote.z += math.pi\n            q = rote.to_quaternion()\n            bm = Matrix.LocRotScale(loc, q, sca)\n\n    return (textcurve, bm)\n\n\ndef import_dim_linear(model, dimlin, bc, scale):\n    pts = dimlin.Points\n    txt = dimlin.PlainText\n    dimstyle = model.DimStyles.FindId(dimlin.DimensionStyleId)\n    p = dimlin.Plane\n    displines = dimlin.GetDisplayLines(dimstyle)\n\n    for displine in displines[\"lines\"]:\n        _populate_line(dimstyle, PartType.DimensionLine, p, bc, displine.From, displine.To, scale)\n    _add_arrow(dimstyle, PartType.DimensionLine, p, bc, pts[\"arrowpt1\"], pts[\"arrowpt2\"], Arrow.Arrow1, scale)\n    _add_arrow(dimstyle, PartType.DimensionLine, p, bc, pts[\"arrowpt2\"], pts[\"arrowpt1\"], Arrow.Arrow2, scale)\n\n    return _add_text(dimstyle, p, bc, pts[\"textpt\"], txt, scale)\n\n\nCONVERT[r3d.AnnotationTypes.Aligned] = import_dim_linear\nCONVERT[r3d.AnnotationTypes.Rotated] = import_dim_linear\n\n\ndef import_radius(model, dimrad, bc, scale):\n    pts = dimrad.Points\n    txt = dimrad.PlainText\n    dimstyle = model.DimStyles.FindId(dimrad.DimensionStyleId)\n    p = dimrad.Plane\n    displines = dimrad.GetDisplayLines(dimstyle)\n\n    for displine in displines[\"lines\"]:\n        _populate_line(dimstyle, PartType.DimensionLine, p, bc, displine.From, displine.To, scale)\n    _add_arrow(dimstyle, PartType.DimensionLine, p, bc, pts[\"radiuspt\"], pts[\"dimlinept\"], Arrow.Leader, scale)\n\n    return _add_text(dimstyle, p, bc, pts[\"kneept\"], txt, scale)\n\n\nCONVERT[r3d.AnnotationTypes.Radius] = import_radius\nCONVERT[r3d.AnnotationTypes.Diameter] = import_radius\n\n\ndef import_angular(model, dimang, bc, scale):\n    pts = dimang.Points\n    r = dimang.Radius\n    a = dimang.Angle\n    txt = dimang.PlainText\n    dimstyle = model.DimStyles.FindId(dimang.DimensionStyleId)\n    displines = dimang.GetDisplayLines(dimstyle)\n    p = dimang.Plane\n\n    for line in displines[\"lines\"]:\n        _populate_line(dimstyle, PartType.DimensionLine, p, bc, line.From, line.To, scale)\n\n    # set up midline and angle addition for text plane orientation\n    arrow_line= r3d.Line(pts[\"arrowpt2\"], pts[\"arrowpt1\"])\n    mp = arrow_line.PointAt(0.5)\n    midline = r3d.Line(mp, pts[\"centerpt\"])\n    addangle = math.pi * -0.5\n    if a > math.pi:\n        addangle = math.pi * 1.5\n\n    for arc in displines[\"arcs\"]:\n        nc_arc = arc.ToNurbsCurve()\n        curve.import_nurbs_curve(nc_arc, bc, scale, is_arc=True)\n    arc = displines[\"arcs\"][0]\n\n    # calculate the arrow tail points. These points we can pass\n    # on to the arrow import function to ensure they are in a\n    # mostly correct orientation.\n    arrowLength = dimstyle.ArrowLength\n    arclen = arc.Length\n\n    T0 = nc_arc.Domain.T0\n    T1 = nc_arc.Domain.T1\n    domlen = T1 - T0\n\n    lenfrac = domlen / arclen\n    arr_frac = arrowLength / domlen * lenfrac\n\n    endpt1 = nc_arc.PointAt(T0 + arr_frac)\n    endpt2 = nc_arc.PointAt(T1 - arr_frac)\n\n    \"\"\"\n    # Debug code adding empties for end points\n    for ep, dispt in ((endpt1, 'PLAIN_AXES'), (endpt2, 'ARROWS')):\n        tstob = bpy.context.blend_data.objects.new(\"tst\", None)\n        tstob.location = (ep.X, ep.Y, ep.Z)\n        tstob.empty_display_type = dispt\n        tstob.empty_display_size = 0.3\n        bpy.context.blend_data.collections[0].objects.link(tstob)\n    \"\"\"\n\n    # Add the arrow heads\n    _add_arrow(dimstyle, PartType.DimensionLine, p, bc, pts[\"arrowpt1\"], endpt1, Arrow.Leader, scale)\n    _add_arrow(dimstyle, PartType.DimensionLine, p, bc, pts[\"arrowpt2\"], endpt2, Arrow.Leader, scale)\n\n    # set up the text plane\n    textplane = dimang.Plane\n    # rotate it according the midline and add extra angle to orient the text\n    # correctly\n    textplane = _rotate_plane_to_line(textplane, midline, addangle=addangle)\n    textplane = r3d.Plane(pts[\"textpt\"], textplane.XAxis, textplane.YAxis)\n\n    # add the text and return the text curve so it can be added\n    # properly to the scene, parented to the main annotation object\n    return _add_text(dimstyle, textplane, bc, pts[\"textpt\"], txt, scale)\n\n\nCONVERT[r3d.AnnotationTypes.Angular] = import_angular\nCONVERT[r3d.AnnotationTypes.Angular3pt] = import_angular\n\n\ndef import_leader(model, dimlead, bc, scale):\n    txt = dimlead.PlainText\n    dimstyle = model.DimStyles.FindId(dimlead.DimensionStyleId)\n    pts = dimlead.Points\n    textptuv = dimlead.GetTextPoint2d(dimstyle, 1.0)\n    textpt = dimlead.Plane.PointAt(textptuv.X, textptuv.Y)\n\n    for i in range(0, len(pts)-1):\n        _populate_line(dimstyle, PartType.DimensionLine, dimlead.Plane, bc, pts[i], pts[i+1], scale)\n\n    _add_arrow(dimstyle, PartType.DimensionLine, dimlead.Plane, bc, pts[0], pts[1], Arrow.Leader, scale)\n\n    return _add_text(dimstyle, dimlead.Plane, bc, textpt, txt, scale)\n\n\nCONVERT[r3d.AnnotationTypes.Leader] = import_leader\n\n\ndef import_text(model, textannotation, bc, scale):\n    txt = textannotation.PlainText\n    dimstyle = model.DimStyles.FindId(textannotation.DimensionStyleId)\n    textpt = textannotation.Plane.Origin\n\n    return _add_text(dimstyle, textannotation.Plane, bc, textpt, txt, scale, left=False, textob=True)\n\nCONVERT[r3d.AnnotationTypes.Text] = import_text\n\ndef import_ordinate(model, dimordinate, bc, scale):\n    txt = dimordinate.PlainText\n    dimstyle = model.DimStyles.FindId(dimordinate.DimensionStyleId)\n    pts = dimordinate.Points\n    textplane = dimordinate.Plane\n    displines = dimordinate.GetDisplayLines(dimstyle)\n    l = r3d.Line(pts[\"kinkpt1\"], pts[\"defpt\"])\n    textplane = _rotate_plane_to_line(textplane, l)\n\n    for displine in displines[\"lines\"]:\n        _populate_line(dimstyle, PartType.DimensionLine, dimordinate.Plane, bc, displine.From, displine.To, scale)\n\n    return _add_text(dimstyle, textplane, bc, pts[\"leaderpt\"], txt, scale, left=True)\n\n\nCONVERT[r3d.AnnotationTypes.Ordinate] = import_ordinate\n\n\ndef import_centermark(model, centermark, bc, scale):\n    dimstyle = model.DimStyles.FindId(centermark.DimensionStyleId)\n    lines = centermark.GetDisplayLines(dimstyle)\n    for line in lines:\n        _populate_line(dimstyle, PartType.DimensionLine, centermark.Plane, bc, line.From, line.To, scale)\n\n\nCONVERT[r3d.AnnotationTypes.CenterMark] = import_centermark\n\n\ndef import_annotation(context, ob, name, scale, options):\n    if not \"rh_model\" in options:\n        return\n    model = options[\"rh_model\"]\n    if not model:\n        return\n    og = ob.Geometry\n    oa = ob.Attributes\n    text = None\n\n    curve_data = context.blend_data.curves.new(name, type=\"CURVE\")\n    curve_data.dimensions = '2D'\n    curve_data.fill_mode = 'BOTH'\n\n    if og.AnnotationType in CONVERT:\n        text = CONVERT[og.AnnotationType](model, og, curve_data, scale)\n    else:\n        print(f\"Annotation type {og.AnnotationType} not implemented\")\n\n    return (curve_data, text)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}