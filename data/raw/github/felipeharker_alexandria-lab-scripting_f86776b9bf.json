{
  "source_url": "https://github.com/felipeharker/alexandria-lab-scripting/blob/1771434a741c840da1d8ab008876e4866d6fecf3/alexandria-scripts/ghpython/point_contour.py",
  "repo": "felipeharker/alexandria-lab-scripting",
  "repo_stars": 0,
  "repo_description": "python, c#, etc. script library for Alexandria Labs",
  "license": "unknown",
  "filepath": "alexandria-scripts/ghpython/point_contour.py",
  "instruction": "GhPython Component\nInputs:\n    Points:  List[Rhino.Geometry.Point3d] (section locations; typically y=0)\n    Surface: Rhino surface or brep to contour",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - SectionPts (GH: Points) | list[Rhino.Geometry.Point3d] | Points defining contour locations\n# - TargetGeo (GH: Surface) | Rhino.Geometry.Brep|Rhino.Geometry.Surface | Target surface/brep\n# Outputs:\n# - Curves (GH: Curves) | list[Rhino.Geometry.Curve] | Contour curves at unique X\n\n\"\"\"GhPython Component\nInputs:\n    Points:  List[Rhino.Geometry.Point3d] (section locations; typically y=0)\n    Surface: Rhino surface or brep to contour\n\nOutputs:\n    Curves:  List[Rhino.Geometry.Curve] resulting from cutting with YZ planes at each unique X\n\"\"\"\n\nimport Rhino\nimport scriptcontext as sc\nfrom Rhino.Geometry import Point3d, Plane, Brep\n\n# --- Helpers ---------------------------------------------------------------\n\ndef get_model_tol(default=0.01):\n    try:\n        if sc.doc and hasattr(sc.doc, \"ModelAbsoluteTolerance\"):\n            return sc.doc.ModelAbsoluteTolerance\n        if Rhino.RhinoDoc.ActiveDoc:\n            return Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    except:\n        pass\n    return default\n\ndef to_brep(geo):\n    \"\"\"Accept Brep or Surface; return Brep or None.\"\"\"\n    if isinstance(geo, Brep):\n        return geo\n    # Surfaces in GH often come in as Rhino.Geometry.Surface or BrepFace\n    if hasattr(geo, \"ToBrep\"):\n        try:\n            return geo.ToBrep()\n        except:\n            return None\n    return None\n\ndef unique_x_values(points, tol):\n    \"\"\"Cluster points by X within tolerance and return sorted representative X values.\"\"\"\n    if tol <= 0: tol = 1e-6\n    scale = 1.0 / tol\n    buckets = {}\n    # Ensure iterable\n    seq = points if isinstance(points, (list, tuple)) else [points]\n    for p in seq:\n        if not isinstance(p, Point3d):\n            continue\n        key = int(round(p.X * scale))\n        if key in buckets:\n            buckets[key] = min(buckets[key], p.X)\n        else:\n            buckets[key] = p.X\n    return sorted(buckets.values())\n\ndef yz_plane_at_x(x):\n    \"\"\"YZ plane translated to given X.\"\"\"\n    pl = Plane.WorldYZ\n    pl.Origin = Point3d(x, 0.0, 0.0)\n    return pl\n\n# --- Main ------------------------------------------------------------------\n\nCurves = []\n\nif Surface is None or Points is None:\n    pass\nelse:\n    tol = get_model_tol()\n    brep = to_brep(Surface)\n\n    if brep is None:\n        # Nothing to contour\n        Curves = []\n    else:\n        xs = unique_x_values(Points, tol)\n        for x in xs:\n            pl = yz_plane_at_x(x)\n            try:\n                # This reliably returns IEnumerable[Curve]\n                crvs = Brep.CreateContourCurves(brep, pl)\n            except Exception:\n                crvs = None\n\n            if crvs:\n                # Filter tiny/invalid results\n                for c in crvs:\n                    if c and c.IsValid and c.GetLength() > tol:\n                        Curves.append(c)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}