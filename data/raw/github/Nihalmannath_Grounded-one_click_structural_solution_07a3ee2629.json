{
  "source_url": "https://github.com/Nihalmannath/Grounded-one_click_structural_solution/blob/94373d5c3a0ea210040d9de1195b23acb6fba0c2/Experiments/2/TERM%202/opensees_training_R2.py",
  "repo": "Nihalmannath/Grounded-one_click_structural_solution",
  "repo_stars": 0,
  "repo_description": "Research studio/term_2",
  "license": "unknown",
  "filepath": "Experiments/2/TERM 2/opensees_training_R2.py",
  "instruction": "Opensees training",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"Opensees training\n\nAutomatically generated by Colab.\n\nOriginal file is located at\n    https://colab.research.google.com/drive/1kyVMFqzJ3oWalbde9J-uLLzOuwcQWNvf\n\"\"\"\n\n\n\n\n\n\n\nimport rhino3dm\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\n\ndef get_all_edges(geometry):\n    \"\"\"\n    Extracts edges from Breps and Meshes, returning pairs of connected vertices.\n    \"\"\"\n    edges = []\n\n    for geom in geometry:\n        # Extract edges from Brep\n        if isinstance(geom, rhino3dm.Brep):\n            for edge in geom.Edges:\n                start = [edge.PointAtStart.X, edge.PointAtStart.Y, edge.PointAtStart.Z]\n                end = [edge.PointAtEnd.X, edge.PointAtEnd.Y, edge.PointAtEnd.Z]\n                edges.append([start, end])\n\n        # If it's a Mesh, extract edges by connecting vertices\n        elif isinstance(geom, rhino3dm.Mesh):\n            for i in range(geom.TopologyEdges.Count):\n                line = geom.TopologyEdges.EdgeLine(i)\n                start = [line.From.X, line.From.Y, line.From.Z]\n                end = [line.To.X, line.To.Y, line.To.Z]\n                edges.append([start, end])\n\n    return np.array(edges)\n\ndef add_structural_elements(edges):\n    \"\"\"\n    Adds columns at vertical edges and beams along all non-ground horizontal & tilted edges.\n    \"\"\"\n    columns = []\n    beams = []\n\n    # Find the lowest Z value (ground level)\n    z_values = [point[2] for edge in edges for point in edge]\n    ground_level = min(z_values) + 0.2  # Small buffer to avoid near-ground beams\n\n    for edge in edges:\n        start, end = edge\n        vector = np.array(end) - np.array(start)\n\n        # Identify columns (strictly vertical edges)\n        if abs(vector[0]) < 0.1 and abs(vector[1]) < 0.1:  # Vertical alignment check\n            columns.append(edge)\n\n        # Identify beams (non-vertical edges, excluding those near ground level)\n        elif abs(vector[2]) < 1.5 and start[2] > ground_level and end[2] > ground_level:\n            beams.append(edge)\n\n    return np.array(columns), np.array(beams)\n\n# Load the Rhino 3DM file\nfile_path = \"C:\\Users\\LEGION\\Documents\\GitHub\\Octopusie\\Reference Files\\all_edges.csv\"  # Update with your file path\n\ntry:\n    model = rhino3dm.File3dm.Read(file_path)\n    geometry = [obj.Geometry for obj in model.Objects if obj.Geometry is not None]\n\n    # Extract edges\n    edges = get_all_edges(geometry)\n\n    # Identify columns and beams\n    columns, beams = add_structural_elements(edges)\n\n    # Plot edges, columns, and beams in 3D\n    fig = plt.figure(figsize=(8, 8))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Convert edges to a format suitable for Line3DCollection\n    edge_lines = [np.array(edge) for edge in edges]\n    column_lines = [np.array(col) for col in columns]\n    beam_lines = [np.array(beam) for beam in beams]\n\n    # Add the original edges in black\n    ax.add_collection3d(Line3DCollection(edge_lines, colors='black', linewidths=1))\n\n    # Add columns in blue\n    ax.add_collection3d(Line3DCollection(column_lines, colors='blue', linewidths=2))\n\n    # Add beams in red (Now avoids beams near ground level)\n    ax.add_collection3d(Line3DCollection(beam_lines, colors='red', linewidths=2))\n\n    # Set axis labels\n    ax.set_xlabel('X Axis')\n    ax.set_ylabel('Y Axis')\n    ax.set_zlabel('Z Axis')\n    ax.set_title('3D Visualization with Columns (Blue) and Beams (Red, Above Ground)')\n\n    # Auto scale axes\n    all_points = edges.reshape(-1, 3)\n    ax.set_xlim([np.min(all_points[:, 0]), np.max(all_points[:, 0])])\n    ax.set_ylim([np.min(all_points[:, 1]), np.max(all_points[:, 1])])\n    ax.set_zlim([np.min(all_points[:, 2]), np.max(all_points[:, 2])])\n\n    plt.show()\n\nexcept Exception as e:\n    print(\"Error loading or processing the file:\", e)\n\nimport numpy as np\nimport pandas as pd\nimport openseespy.opensees as ops\n\n# For optional 3D plotting (if desired)\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 2.1 Read columns, beams, and all_edges DataFrames\ncolumns_df = pd.read_csv(r\"/content/columns.csv\")   # e.g. x_start, y_start, z_start, x_end, y_end, z_end\nbeams_df   = pd.read_csv(r\"/content/beams.csv\")     # same or similar format\nedges_df   = pd.read_csv(r\"/content/all_edges.csv\") # possibly the union or adjacency data\n\n# 2.2 Tag each entry to differentiate them if needed\ncolumns_df[\"type\"] = \"column\"\nbeams_df[\"type\"]   = \"beam\"\nedges_df[\"type\"]   = \"edge\"  # if itâ€™s purely adjacency or combined edges\n\ncombined_df = pd.concat([columns_df, beams_df, edges_df], ignore_index=True)\n\nnode_map = {}  # (x, y, z) -> node_id\nnext_node_id = 1\n\nfor _, row in combined_df.iterrows():\n    coord_start = (row[\"start_x\"], row[\"start_y\"], row[\"start_z\"])\n    coord_end   = (row[\"end_x\"], row[\"end_y\"], row[\"end_z\"])\n\n    if coord_start not in node_map:\n        node_map[coord_start] = next_node_id\n        next_node_id += 1\n    if coord_end not in node_map:\n        node_map[coord_end] = next_node_id\n        next_node_id += 1\n\n# Store the node IDs in the DataFrame for convenience\ncombined_df[\"startNode\"] = combined_df.apply(\n    lambda r: node_map[(r[\"start_x\"], r[\"start_y\"], r[\"start_z\"])],\n    axis=1\n)\ncombined_df[\"endNode\"] = combined_df.apply(\n    lambda r: node_map[(r[\"end_x\"], r[\"end_y\"], r[\"end_z\"])],\n    axis=1\n)\n\nops.wipe()\nops.model(\"basic\", \"-ndm\", 3, \"-ndf\", 6)  # 3D model, 6 DOFs per node\n\nnode_map = {}  # (x, y, z) -> node_id\nnext_node_id = 1\n\nfor coord, node_id in node_map.items():\n    (x, y, z) = coord\n    ops.node(node_id, x, y, z)\n\n# Example boundary condition: fix all nodes where z ~ 0\nfor coord, node_id in node_map.items():\n    x, y, z = coord\n    if abs(z) < 1e-8:\n        ops.fix(node_id, 1,1,1,1,1,1)  # fully fixed\n\nE  = 2.1e11     # Young's modulus (Pa)\nG  = 8.0769e10  # Shear modulus\nA  = 0.02       # Cross-sectional area (m^2)\nIz = 8.3e-5     # Moment of inertia about z\nIy = 4.2e-5     # Moment of inertia about y\nJ  = 1.0e-4     # Torsional inertia\n\n# Example transformation (3D)\ntransfTag = ops.geomTransf(\"Linear\", 1, 0, 0, 0, 1, 0)  # local y or z axis vector, etc.\n\n# Create a copy so we don't alter combined_df in-place\ndf_copy = combined_df.copy()\n\n# Force each row to store (min_node, max_node) to unify duplicates\ndf_copy[[\"startNode\", \"endNode\"]] = df_copy.apply(\n    lambda r: pd.Series(sorted((r[\"startNode\"], r[\"endNode\"]))),\n    axis=1\n)\n\n# Now drop duplicates on the sorted pairs\nunique_df = df_copy.drop_duplicates(subset=[\"startNode\", \"endNode\"])\n\nelemTag = 1\nfor idx, row in combined_df.iterrows():\n    start_id = int(row[\"startNode\"])\n    end_id   = int(row[\"endNode\"])\n\n    # Decide section properties based on type\n    if row[\"type\"] == \"column\":\n        # For instance, a column might have a different cross-section\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n    elif row[\"type\"] == \"beam\":\n        # Another approach for beams\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n    else:\n        # If \"edge\" is something generic (like a bracing?), treat it similarly\n        # Use start_id and end_id for element definition\n        ops.element('elasticBeamColumn', elemTag, start_id, end_id, A, E, G, J, Iy, Iz, 1)\n\n    elemTag += 1\n\n# 5.1 Time series & load pattern\nops.timeSeries(\"Constant\", 1)\nops.pattern(\"Plain\", 1, 1)\n\ngravity = -9.81  # negative z direction, if Z is vertical\nmass_per_node = 1000.0  # example (kg) or (mass units), adjust to your model scale\n\nfor coord, node_id in node_map.items():\n    # Assign mass in all translational DOFs\n    # mass = [mX, mY, mZ, rX, rY, rZ] for a 3D problem if needed\n    # We'll just do translational:\n    ops.mass(node_id, mass_per_node, mass_per_node, mass_per_node, 0.0, 0.0, 0.0)\n\n# Apply gravity as acceleration load\nops.loadConst('-time', 0.0)  # This finalizes the mass assignment\n\nops.system(\"BandGeneral\")\nops.numberer(\"RCM\")\nops.constraints(\"Plain\")\nops.test(\"NormUnbalance\", 1e-6, 10)\nops.algorithm(\"Newton\")\nops.integrator(\"LoadControl\", 1.0)\nops.analysis(\"Static\")\n\n# In OpenSees, you can set the gravity factor:\nops.record()  # optional, if you want to record data\nops.setTime(0.0)\nops.analyze(1)  # single step\n\n# Print reactions for nodes at base (z=0).\nfor coord, node_id in node_map.items():\n    if abs(coord[2]) < 1e-8:\n        rxn = ops.nodeReaction(node_id)\n        print(f\"Node {node_id} at {coord}, Reaction = {rxn}\")\n\ndef plot_deformed_3d(scale=1.0):\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Original vs. deformed coords\n    deformed_coords = {}\n    for (x,y,z), nd_id in node_map.items():\n        disp = ops.nodeDisp(nd_id)\n        dx, dy, dz = disp[0], disp[1], disp[2]  # 3D translations\n        deformed_coords[nd_id] = (x + scale*dx, y + scale*dy, z + scale*dz)\n\n    # Plot elements\n    elemTag = 1\n    for idx, row in combined_df.iterrows():\n        ndI = int(row[\"startNode\"])\n        ndJ = int(row[\"endNode\"])\n        if ndI in deformed_coords and ndJ in deformed_coords:\n            xI, yI, zI = deformed_coords[ndI]\n            xJ, yJ, zJ = deformed_coords[ndJ]\n            ax.plot([xI, xJ], [yI, yJ], [zI, zJ], color=\"red\")\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n    ax.set_title(f\"Deformed Shape (scale={scale})\")\n    plt.show()\n\n# Plot with an arbitrary scale factor\nplot_deformed_3d(scale=50.0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}