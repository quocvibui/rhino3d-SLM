{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_KnotVector.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_KnotVector.py",
  "instruction": "V7 includes knot type reporting, so the isUniform function is more useful for V5 & V6.",
  "code": "\"\"\"\r\nV7 includes knot type reporting, so the isUniform function is more useful for V5 & V6.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190410: Created from another script.\r\n190510: Fixed bug in testing for invalid knot vector.\r\n210109: Now reports knot info when this script is run on its own.\r\n210417: Now processes SumSurface when at least one of its 2 defining curves is a NurbsCurve.\r\n210514: Fixed bug that was reporting single-spanned degree 1 as uniform.\r\n210714: Now supports analyzing PolyCurves with a single NurbsCurve segment.\r\n211001: Added SpanCount to printed output and fixed a printed output bug.\r\n211010: Full knot list is now included in report.\r\n211026: Modified format of printed output of knot parameters.\r\n211029: Now, the underlying curve of single-spanned PolyCurves are reported.\r\n211102: Added NurbsCurve(/Surface)KnotList.KnotStyle.\r\n211126-27: Bug fix in incorrect reporting of knot indices per knot parameter.\r\n        Now processes the NurbsCurve equivalent of a multi-span PolyCurve.\r\n211208: Minimum and maximum knot deltas are now reported.\r\n211228: getKnotInfo now reports degree for periodic curves and surfaces.\r\n220327: Added knot count to printed output.\r\n\r\n\r\nTODO: Test for invalid knot vector may need more work.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\n\r\n\r\ndef isUniform(knots):\r\n    \r\n    knots = list(knots)\r\n    \r\n    len_knots = len(knots)\r\n    \r\n    if len_knots == 2:\r\n        return True\r\n    elif len_knots < 2:\r\n        return\r\n    \r\n    bPeriodicOrDeg1 = not Rhino.RhinoMath.EpsilonEquals(\r\n            knots[0], knots[1], Rhino.RhinoMath.ZeroTolerance)\r\n    \r\n    if not bPeriodicOrDeg1 and len_knots > 2:\r\n        if not Rhino.RhinoMath.EpsilonEquals(\r\n                knots[-1], knots[-2], Rhino.RhinoMath.ZeroTolerance\r\n        ):\r\n            print(\"Knot vector is invalid: {}\".format(knots))\r\n            return\r\n    \r\n    knotVect1stSpan = knots[1] - knots[0]\r\n    \r\n    if not bPeriodicOrDeg1:\r\n        for i in xrange(1, len_knots//2):\r\n            if not Rhino.RhinoMath.EpsilonEquals(knots[i] - knots[i+1],\r\n                    knotVect1stSpan,\r\n                    Rhino.RhinoMath.ZeroTolerance):\r\n                break\r\n        else:\r\n            print(\"Degree cannot be determined.\")\r\n            return\r\n        \r\n        degree = i + 1\r\n    else:\r\n        degree = 1 # Even if periodic of degree > 1.\r\n    \r\n    # Set up for loop's range's start and stop based on whether knot vector is periodic.\r\n    # iKnot_Start: Start of spans to check.\r\n    # iKnot_End: End of spans to check.\r\n    if bPeriodicOrDeg1:\r\n        iKnot_Start = 0\r\n        iKnot_End = len_knots - 1\r\n        knotVect1stSpan_Not0 = knotVect1stSpan\r\n    else:\r\n        iKnot_Start = degree - 1\r\n        iKnot_End = len_knots - degree\r\n        if iKnot_Start == iKnot_End: return True # Is this also true when periodic?\r\n        knotVect1stSpan_Not0 = knots[degree] - knots[degree-1]\r\n    pass\r\n    #  A uniform knot vector's interior parameter spans are all equal.\r\n    for i in range(iKnot_Start, iKnot_End):\r\n        span = knots[i+1] - knots[i]\r\n        if not Rhino.RhinoMath.EpsilonEquals(\r\n                span,\r\n                knotVect1stSpan_Not0,\r\n                Rhino.RhinoMath.ZeroTolerance):\r\n            return False\r\n    \r\n    return True\r\n\r\n\r\ndef knotMultiplicityList(knots):\r\n    \"\"\"Returns a list.\"\"\"\r\n    i = 0\r\n    iMulties = []\r\n    fKnotTs_Unique = []\r\n    while True:\r\n        knot = knots[i]\r\n        fKnotTs_Unique.append(knot)\r\n        iMulti = knots.KnotMultiplicity(index=i)\r\n        iMulties.append(iMulti)\r\n        #print(\"{} at {:.4f}\".format(iMulti, knot),\r\n        i += iMulti\r\n        if i >= knots.Count:\r\n            break\r\n    return iMulties\r\n\r\n\r\ndef getKnotInfo(knots, degree=None):\r\n    \"\"\"\r\n    Parameters:\r\n        knots: iterable of knot parameters\r\n        degree: int  (This is only used for periodic curves and surfaces.)\r\n    Returns a string.\r\n    \"\"\"\r\n\r\n    iK = 0\r\n    ts_Unique = []\r\n    ms = []\r\n    iKsPerM = []\r\n    deltas_ts = []\r\n\r\n    while iK < knots.Count:\r\n        k = knots[iK]\r\n        ts_Unique.append(k)\r\n        m = knots.KnotMultiplicity(index=iK)\r\n        ms.append(m)\r\n        #print(\"{} at {:.4f}\".format(m, k),\r\n        iKsPerM.append(range(iK, iK+m))\r\n        if iK > 0: deltas_ts.append(ts_Unique[-1]-ts_Unique[-2])\r\n        iK += m\r\n\r\n    s = \"Domain:[{: .6f},{: .6f}]\".format(ts_Unique[0], ts_Unique[-1])\r\n    s += \"  KnotCt:{}\".format(knots.Count)\r\n    s += \"  SpanCt:{}\".format(len(ms)-1)\r\n    s += \"  Mults({})\".format(\",\".join(str(i) for i in ms))\r\n\r\n    if len(ms[1:-1]) == 0:\r\n        # For Bezier / single span.\r\n        pass\r\n    elif all(i == 1 for i in ms):\r\n        # Periodic.\r\n        if degree:\r\n            s += \"  Deg:{}\".format(degree)\r\n        s += \"  {} uniform\".format(\"Is\" if isUniform(knots) else \"Not\")\r\n    elif all(i == 1 for i in ms[1:-1]):\r\n        s += \"  {} uniform\".format(\"Is\" if isUniform(knots) else \"Not\")\r\n    else:\r\n        # For other non-uniform obvious by its list of multiplicies.\r\n        pass\r\n\r\n    if Rhino.RhinoApp.ExeVersion >= 7:\r\n        s += \"  .KnotStyle:{}\".format(knots.KnotStyle)\r\n\r\n    # Record knot parameters to at least 3 decimal places but more if\r\n    # required to display all unique values.\r\n    for dec_plcs in range(15, 3-1, -1):\r\n        LIST = [\" {: .{}f}\".format(t, dec_plcs) for t in ts_Unique]\r\n        if len(set(LIST)) != len(ts_Unique):\r\n            dec_plcs += 1\r\n            break\r\n\r\n    s += \"\\n  \"\r\n\r\n    zipped = zip(iKsPerM, ts_Unique)\r\n    s_JoinUs = []\r\n    for idxs, t in zipped:\r\n        if len(idxs) == 1:\r\n            s_JoinUs.append(\"{: .{}f}[{}]\".format(t, dec_plcs, idxs[0]))\r\n        else:\r\n            s_JoinUs.append(\"{: .{}f}[{},{}]\".format(t, dec_plcs, idxs[0], idxs[-1]))\r\n    s += \" \".join(s_JoinUs)\r\n\r\n    if abs(min(deltas_ts) - max(deltas_ts)) <= 10.0**(-dec_plcs):\r\n        s += \"  Deltas:{0:.{1}f}\".format(\r\n            deltas_ts[0], dec_plcs)\r\n    else:\r\n        s += \"  DeltaRange:[{0:.{2}f},{1:.{2}f}]\".format(\r\n            min(deltas_ts), max(deltas_ts), dec_plcs)\r\n\r\n    return s\r\n\r\n\r\ndef main():\r\n    import rhinoscriptsyntax as rs\r\n\r\n\r\n    gObj = rs.GetObject(\r\n        \"Select curve or face\",\r\n        filter=rs.filter.curve + rs.filter.surface,\r\n        preselect=True,\r\n        subobjects=True)\r\n    if gObj is None: return\r\n\r\n\r\n    rgObj = rs.coercegeometry(gObj)\r\n    rgCrv = rs.coercecurve(gObj)\r\n\r\n    fTol_Shape = 1e-8\r\n\r\n    if rgCrv is None:\r\n        # Report surface.\r\n\r\n        rgF = rs.coercesurface(gObj)\r\n        rgS = rgF.UnderlyingSurface()\r\n        if isinstance(rgS, rg.NurbsSurface):\r\n            ns = rgS\r\n        elif isinstance(rgS, rg.PlaneSurface):\r\n            print(\"Surface is a PlaneSurface.\")\r\n            return\r\n        elif rgS.IsPlanar(fTol_Shape):\r\n            print(\"Surface is a planar surface.\")\r\n            ns = rgS.ToNurbsSurface()\r\n        elif isinstance(rgS, rg.RevSurface):\r\n            rgCrv = rgS.Curve\r\n            if not isinstance(rgCrv, rg.NurbsCurve):\r\n                print(\"Surface is a RevSurface with a {} revolute curve.\".format(\r\n                    rgCrv.GetType().Name))\r\n                return\r\n            ns = rgS.ToNurbsSurface()\r\n        elif isinstance(rgS, rg.SumSurface):\r\n            rgC_South = rgS.IsoCurve(0, rgS.Domain(1).Min)\r\n            print(\"SumSurface\")\r\n            if isinstance(rgC_South, rg.PolyCurve):\r\n                rgC_WIP = rgC_South.CleanUp()\r\n                if rgC_WIP.Domain.EpsilonEquals(rgC_South.Domain, epsilon=1e-9):\r\n                    rgC_South = rgC_WIP\r\n            if isinstance(rgC_South, rg.NurbsCurve):\r\n                print(\"Curve U  Nurbs  Knot {}\".format(\r\n                    getKnotInfo(rgC_South.Knots, rgC_South.Degree)))\r\n            else:\r\n                print(\"Curve U is a {}.\".format(rgC_South.GetType().Name))\r\n\r\n            rgC_West = rgS.IsoCurve(1, rgS.Domain(0).Min)\r\n            if isinstance(rgC_West, rg.PolyCurve):\r\n                rgC_WIP = rgC_West.CleanUp()\r\n                if rgC_WIP.Domain.EpsilonEquals(rgC_West.Domain, epsilon=1e-9):\r\n                    rgC_West = rgC_WIP\r\n            if isinstance(rgC_West, rg.NurbsCurve):\r\n                print(\"Curve V  Nurbs  Knot {}\".format(\r\n                    getKnotInfo(rgC_West.Knots, rgC_South.Degree)))\r\n            else:\r\n                print(\"Curve V is a {}.\".format(rgC_West.GetType().Name))\r\n\r\n            if rgS.IsCone(fTol_Shape):\r\n                print(\"Surface is a cone-shaped SumSurface.\")\r\n                return\r\n            elif rgS.IsCylinder(fTol_Shape):\r\n                print(\"Surface is a cylindrical SumSurface.\")\r\n                return\r\n            elif rgS.IsSphere(fTol_Shape):\r\n                print(\"Surface is a spherical SumSurface.\")\r\n                return\r\n            elif rgS.IsPlanar(fTol_Shape):\r\n                print(\"Surface is a planar SumSurface.\")\r\n                return\r\n            return\r\n        else:\r\n            print(\"{} is not yet supported.\".format(rgS.GetType().Name))\r\n            return\r\n        print(\"KnotsU: {}\".format(getKnotInfo(ns.KnotsU, ns.Degree(0))))\r\n        print(\"KnotsV: {}\".format(getKnotInfo(ns.KnotsV, ns.Degree(1))))\r\n    else:\r\n        # Report curve.\r\n\r\n        if isinstance(rgCrv, rg.BrepEdge):\r\n            rgE = rgCrv\r\n            rgCrv = rgCrv.EdgeCurve\r\n        else:\r\n            rgE = None\r\n\r\n        if isinstance(rgCrv, rg.PolyCurve):\r\n            pc = rgCrv.DuplicateCurve()\r\n            pc.RemoveNesting()\r\n            if pc.SegmentCount > 1:\r\n                print(\"{} is a multi-segment polycurve.\".format(\r\n                    \"Edge's curve\" if rgE else \"Curve\"),\r\n                      \"NurbsCurve equivalent is analyzed.\",\r\n                      sep=\"  \")\r\n                rgCrv = rgCrv.ToNurbsCurve() # Overwrote variable.\r\n            else:\r\n                print(\"Segment from 1-segment polycurve retrieved ...\")\r\n                rgCrv = pc.SegmentCurve(0) # Overwrote variable.\r\n\r\n        if not isinstance(rgCrv, rg.NurbsCurve):\r\n            print(\"{} is a {}.\".format(\r\n                \"Edge's curve\" if rgE else \"Curve\",\r\n                rgCrv.GetType().Name))\r\n            return\r\n\r\n        nc = rgCrv\r\n        knots = nc.Knots\r\n        print(getKnotInfo(knots, nc.Degree))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}