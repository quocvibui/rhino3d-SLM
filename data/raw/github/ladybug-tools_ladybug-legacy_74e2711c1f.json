{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Solar%20Water%20Heating%20Surface.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Solar Water Heating Surface.py",
  "instruction": "Use this component to calculate amount of thermal energy that can be produced by a surface\nif a certain percentage of it is covered with Solar water heating liquid collectors.\nThe thermal energy can...",
  "code": "# Solar water heating surface\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Dr. Chengchu Yan and Djordje Spasic <ycc05ster@gmail.com, djordjedspasic@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\"\"\"\nUse this component to calculate amount of thermal energy that can be produced by a surface\nif a certain percentage of it is covered with Solar water heating liquid collectors.\nThe thermal energy can then be used for domestic hot water, space heating or space cooling.\n-\nComponent based on:\n\"Solar Engineering of Thermal Processes\", John Wiley and Sons, J. Duffie, W. Beckman, 4th ed., 2013.\n\"Technical Manual for the SAM Solar Water Heating Model\", NREL, N. DiOrio, C. Christensen, J. Burch, A. Dobos, 2014.\n\"A simplified method for optimal design of solar water heating systems based on life-cycle energy analysis\", Renewable Energy journal, Yan, Wang, Ma, Shi, Vol 74, Feb 2015\n-\nhttp://www.wiley.com/WileyCDA/WileyTitle/productCd-0470873663.html\nhttps://sam.nrel.gov/system/tdf/SimpleSolarWaterHeatingModel_SAM_0.pdf?file=1&type=node&id=69521\nhttp://www.sciencedirect.com/science/article/pii/S0960148114004807\n-\nProvided by Ladybug 0.0.69\n    \n    input:\n        _epwFile: Input .epw file path by using the \"File Path\" parameter, or Ladybug's \"Open EPW And STAT Weather Files\" component.\n        _heatingLoadPerHour: Heating load in electrical energy for each hour during a year. In kWh.\n                             It represents domestic hot water heating load.\n                             With added space heating and/or space cooling heating loads.\n                             -\n                             To calculate domestic hot water heating load, use Ladybug \"Residential Hot Water\" or \"Commercial Public Apartment Hot Water\" components.\n                             -\n                             Space heating and space cooling loads can be inputted from Honeybee's \"Read EP Result\" component.\n                             Divide each value of space heating load with 0.7, to account for COP(coefficient of performance) of the heating system.\n                             Space cooling values do not need to be divided with anything (COP = 1.0).\n        _SWHsurface: - Input planar Surface (not polysurface) on which the SWH collectors will be applied. If you have a polysurface, explode it (using \"Deconstruct Brep\" component) and then feed its Faces(F) output to _SWHsurface. Surface normal should be faced towards the sun.\n                     - Or create the Surface based on initial SWH system size by using \"PV SWH system size\" component.\n        SWHsurfacePercent_: The percentage of surface which will be used for SWH collectors (range 0-100).\n                            -\n                            There are no general rules or codes which would limit the percentage of the roof(surface) covered with SWH collectors.\n                            -\n                            If not supplied, default value of 100 (all surface area will be covered with SWH collectors) is used.\n        SWHsystemSettings_: A list of all Solar water heating system settings. Use the \"Solar Water Heating System\" or \"Solar Water Heating System Detailed\" components to generate them.\n                            -\n                            If not supplied, the following swh system settings will be used by default:\n                            - glazed flat plate collectors\n                            - active\n                            - closed loop\n                            - pipe length: 20 meters\n                            - unshaded\n        north_: Input a vector to be used as a true North direction for the sun path, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis to make North.\n                -\n                If not supplied, default North direction will be set to the Y-axis (0 degrees).\n        albedo_: A list of 8767 (with header) or 8760 (without the header) albedo values for each hour during a year.\n                 Albedo (or Reflection coefficient) is an average ratio of the global incident solar radiation reflected from the area surrounding the PV surface.\n                 It ranges from 0 to 1.\n                 -\n                 It depends on the time of the year/day, surface type, temperature, vegetation, presence of water, ice and snow etc.\n                 -\n                 If no list supplied, default value of 0.20 will be used, corrected(increased) for the presence of snow (if any).\n                 -\n                 Unitless.\n        annualHourlyData_: An optional list of hourly data from Ladybug's \"Import epw\" component (e.g. dryBulbTemperature), which will be used for \"conditionalStatement_\".\n        conditionalStatement_: This input allows users to calculate the Solar water heating surface component results only for those annualHourlyData_ values which fit specific conditions or criteria.\n                               To use this input correctly, hourly data, such as dryBulbTemperature or windSpeed, must be plugged into the \"annualHourlyData_\" input. The conditional statement input here should be a valid condition statement in Python, such as \"a>25\" or \"b<3\" (without the quotation marks).\n                               conditionalStatement_ accepts \"and\" and \"or\" operators. To visualize the hourly data, English letters should be used as variables, and each letter alphabetically corresponds to each of the lists (in their respective order): \"a\" always represents the 1st list, \"b\" always represents the 2nd list, etc.\n                               -\n                               For example, if you have an hourly dryBulbTemperature connected as the first list, and windSpeed connected as the second list (both to the annualHourlyData_ input), and you want to plot the data for the time period when temperature is between 18C and 23C, and windSpeed is larger than 3m/s, the conditionalStatement_ should be written as \"18<a<23 and b>3\" (without the quotation marks).\n                               -\n                               This input can also be used for analysis of drainback systems. Input a \"dryBulbTemperature\" data from \"Import epw\" component into upper \"annualHourlyData_\" input. Then input \"a>5\" to this (\"conditionalStatement_\") input.\n        _runIt: ...\n        \n    output:\n        readMe!: ...\n        heatFromTankPerHour: Thermal energy provided by the storage tank per each hour during a year.\n                             -\n                             In kWh.\n        heatFromTankPerYear: Total thermal energy provided by the storage tank for a whole year.\n                             -\n                             In kWh.\n        avrDailyheatFromTankPerYear: An average thermal energy provided by the storage tank per day for a whole year.\n                                     -\n                                     In kWh/day.\n        heatFromAuxiliaryHeaterPerHour: Thermal energy provided and Electrical energy spent by an auxiliary heater per each hour during a year.\n                                        Electric auxiliary heater used.\n                                        -\n                                        In kWh.\n        dischargedHeatPerHour: Discharged surplus energy (\"heat dump\") per each hour during a year.\n                               It can be used to heat a pool, hot tub, greenhouse or as snow-melt system (by using radiant floor tubing bellow sidewalks, or radiatior beneath the entrance stairs).\n                               -\n                               In kWh.\n        pumpEnergyPerHour: Electrical energy spent by the circulation pump(s) per hour during a year.\n                           -\n                           In kWh.\n        tankWaterTemperaturePerHour: Tank water temperature per each hour during a year.\n                                     -\n                                     In C.\n        SWHsurfaceTiltAngle: The angle from horizontal of the inclination of the SWHsurface. Example: 0 = horizontal, 90 = vertical.\n                             It ranges from 0-180.\n                             -\n                             In degrees.\n        SWHsurfaceAzimuthAngle: The orientation angle (clockwise from the true north) of the SWHsurface normal vector.\n                                It ranges from 0-360.\n                                -\n                                In degrees.\n        systemSize: Rated SWH system size. \n                    -\n                    In kWt.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Solar Water Heating Surface\"\nghenv.Component.NickName = \"SolarWaterHeatingSurface\"\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"4 | Renewables\"\n#compatibleLBVersion = VER 0.0.62\\nMAR_11_2016\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\nimport re\n\n\ndef getEpwData(epwFile, albedo):\n    \n    if epwFile:\n        try:\n            # location data\n            locationName, latitude, longitude, timeZone, elevation, locationString = lb_preparation.epwLocation(epwFile)\n            # weather data\n            weatherData = lb_preparation.epwDataReader(epwFile, locationName)\n            dryBulbTemperature, dewPointTemperature, relativeHumidity, windSpeed, windDirection, directNormalRadiation, diffuseHorizontalRadiation, globalHorizontalRadiation, directNormalIlluminance, diffuseHorizontalIlluminance, globalHorizontalIlluminance, totalSkyCover, liquidPrecipitationDepth, barometricPressure, modelYear = weatherData\n            \n            Ta = dryBulbTemperature[7:]\n            DNI = directNormalRadiation[7:]\n            DHI = diffuseHorizontalRadiation[7:]\n            yearsHOY = modelYear[7:]\n            \n            if (len(albedo) == 0) or (albedo[0] is \"\"):\n                albedoL = lb_photovoltaics.calculateAlbedo(Ta)  # default\n            elif (len(albedo) == 8767):\n                albedoL = albedo[7:]\n            elif (len(albedo) == 8760):\n                albedoL = albedo\n            else:\n                locationName = latitude = longitude = timeZone = Ta = DNI = DHI = albedoL = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = None\n                validEpwData = False\n                printMsg = \"Something is wrong with your \\\"albedo_\\\" list input.\\n\\\"albedo_\\\" input accepts a list of 8767 (with header) or 8760 (without the header) abledo values.\"\n                \n                return locationName, latitude, longitude, timeZone, Ta, DNI, DHI, albedoL, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, validEpwData, printMsg\n            \n            monthsHOY = [1 for i in range(744)] + [2 for i in range(672)] + [3 for i in range(744)] + [4 for i in range(720)] + [5 for i in range(744)] + [6 for i in range(720)] + [7 for i in range(744)] + [8 for i in range(744)] + [9 for i in range(720)] + [10 for i in range(744)] + [11 for i in range(720)] + [12 for i in range(744)]\n            \n            numberOfDaysMonth = [31,28,31,30,31,30,31,31,30,31,30,31]\n            daysHOY = []\n            day = 1\n            for i,item in enumerate(numberOfDaysMonth):\n                for k in range(item):\n                    for g in range(24):\n                        daysHOY.append(day)\n                    day += 1\n                day = 1\n            \n            hoursHOY = []\n            hour = 1\n            for i in range(365):\n                for k in range(24):\n                    hoursHOY.append(hour)\n                    hour += 1\n                hour = 1\n            \n            HOYs = range(1,8761)\n            \n            validEpwData = True\n            printMsg = \"ok\"\n            \n            return locationName, float(latitude), float(longitude), float(timeZone), Ta, DNI, DHI, albedoL, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, validEpwData, printMsg\n        \n        except Exception, e:\n            # something is wrong with \"_epwFile\" input\n            locationName = latitude = longitude = timeZone = Ta = DNI = DHI = albedoL = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = None\n            validEpwData = False\n            printMsg = \"Something is wrong with \\\"_epwFile\\\" input.\"\n    else:\n        locationName = latitude = longitude = timeZone = Ta = DNI = DHI = albedoL = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = None\n        validEpwData = False\n        printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n    \n    return locationName, latitude, longitude, timeZone, Ta, DNI, DHI, albedoL, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, validEpwData, printMsg\n\n\ndef heatingLoadSWHsurfaceInputData(heatingLoadPerHour, SWHsurface, SWHsurfacePercent, unitAreaConversionFactor):\n    \n    if (len(heatingLoadPerHour) == 0) or (heatingLoadPerHour[0] is \"\"):\n        heatingLoadPerHourData = srfArea = SWHsurfacePercent = None\n        validHeatingLoadSWHsurface = False\n        printMsg = \"Please input \\\"_heatingLoadPerHour\\\" data.\\nUse Ladybug's \\\"Residential Hot Water\\\" or \\\"Commercial Public Apartment Hot Water\\\" components if you want to input domestic hot water heating load.\\nFor space heating or cooling loads of a room or entire building, use Honeybee's \\\"Read EP Result\\\" component.\\nYou call also use all three of these heating load types, or their combinations.\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n    elif (heatingLoadPerHour[0] == None):\n        heatingLoadPerHourData = srfArea = SWHsurfacePercent = None\n        validHeatingLoadSWHsurface = False\n        printMsg = \"Inputted \\\"_heatingLoadPerHour\\\" data's annual output is 0 kWh.\\nPlease input the \\\"_heatingLoadPerHour\\\" which annual's output is higher than 0kwh.\\nUse Ladybug's \\\"Residential Hot Water\\\" or \\\"Commercial Public Apartment Hot Water\\\" components to input domestic hot water heating load.\\nAdditionally, for space heating and/or space cooling loads, use Honeybee's \\\"Read EP Result\\\" component.\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n    elif len(heatingLoadPerHour) == 8767:\n        heatingLoadPerHourData = heatingLoadPerHour[7:]  # in kWh\n    elif len(heatingLoadPerHour) == 8760:\n        heatingLoadPerHourData = heatingLoadPerHour  # in kWh\n    else:\n        heatingLoadPerHourData = srfArea = SWHsurfacePercent = None\n        validHeatingLoadSWHsurface = False\n        printMsg = \"Inputted \\\"_heatingLoadPerHour\\\" list does not have required length.\\n\\\"_heatingLoadPerHour\\\" needs to be a list of either 8767 (heading plus values) or 8760 (only values) items.\\nUse Ladybug's \\\"Residential Hot Water\\\" or \\\"Commercial Public Apartment Hot Water\\\" components to input domestic hot water heating load.\\nAdditionally, for space heating and/or space cooling loads, use Honeybee's \\\"Read EP Result\\\" component.\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n    \n    \n    if (SWHsurface == None):\n        heatingLoadPerHourData = srfArea = SWHsurfacePercent = None\n        validHeatingLoadSWHsurface = False\n        printMsg = \"Please input planar Surface (not a polysurface) on which the SWH collectors will be applied.\\n\" + \\\n                   \"Or create a Surface based on initial SWH system size by using \\\"PV SWH system size\\\" component.\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n    \n    if (SWHsurfacePercent == None) or (SWHsurfacePercent < 0) or (SWHsurfacePercent > 100):\n        SWHsurfacePercent = 100  # default value 100%\n    \n    # check SWHsurface input\n    facesCount = SWHsurface.Faces.Count\n    if facesCount > 1:\n        # inputted polysurface\n        heatingLoadPerHourData = srfArea = SWHsurfacePercent = None\n        validHeatingLoadSWHsurface = False\n        printMsg = \"The brep you supplied to \\\"SWHsurface_\\\" is a polysurface. Please supply a surface.\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n    else:\n        # inputted brep with a single surface\n        srfArea = Rhino.Geometry.AreaMassProperties.Compute(SWHsurface).Area * (SWHsurfacePercent/100)  # area in document units\n        srfArea = srfArea * unitAreaConversionFactor  # area in m2\n        \n        validHeatingLoadSWHsurface = True\n        printMsg = \"ok\"\n        \n        return heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg\n\n\ndef SWHsystemSettingsInput(heatingLoadPerHourData, SWHsystemSettings, srfArea, dryBulbTemperature):\n    \n    # SWH system inputs\n    if (len(SWHsystemSettings) != 23) and (len(SWHsystemSettings) != 0):\n        coldWaterTemperaturePerHour = activeArea = nameplateThermalCapacity = SWHsystemSettings = None\n        validSWHsystemSettings = False\n        printMsg = \"Your \\\"SWHsystemSettings_\\\" input is incorrect. Please use \\\"SWHsystemSettings\\\" output from \\\"Solar Water Heating System\\\" or \\\"Solar Water Heating System Detailed\\\" components.\"\n        \n        return coldWaterTemperaturePerHour, activeArea, nameplateThermalCapacity, SWHsystemSettings, validSWHsystemSettings, printMsg\n    \n    elif (len(SWHsystemSettings) == 0) or (SWHsystemSettings[0] is \"\"):\n        # nothing inputted into \"SWHsystemSettings_\", use default SWHsystemSettings values\n        collectorOpticalEfficiency = 0.70\n        collectorThermalLoss = 4\n        collectorActiveAreaPercent = 90\n        workingFluidHeatCapacity = 3840\n        flowRatePerM2 = 0.012\n        IAMcoefficient = 0.1\n        skyViewFactor = 1  # default - no shading\n        beamIndexPerHourData = [1 for i in range(0,8760)]  # default - no shading\n        maxWorkingTemperature = 95\n        dischargeTemperature = 92\n        deliveryWaterTemperature = 60\n        avrJanuaryColdWaterTemperature = None\n        mechanicalRoomTemperatureData = [20 for i in range(0,8760)]  # default 20C\n        pipeLength = 20\n        pipeDiameterMM = None  #math.sqrt((4 * (flowRatePerM2*collectorActiveArea)/0.7) / math.pi)\n        pipeInsulationThicknessMM = None\n        pipeInsulationConductivity = 0.027\n        pumpPower = None\n        pumpEfficiency = 0.85\n        tankSizeLiters = None\n        tankLoss = 0.30\n        heightDiameterTankRatio = 2.6\n        heatExchangerEffectiveness = 0.8\n    elif (len(SWHsystemSettings) == 23):\n        # 23 items inputted into \"SWHsystemSettings_\"\n        collectorOpticalEfficiency = SWHsystemSettings[0]\n        collectorThermalLoss = SWHsystemSettings[1]\n        collectorActiveAreaPercent = SWHsystemSettings[2]\n        workingFluidHeatCapacity = SWHsystemSettings[3]\n        flowRatePerM2 = SWHsystemSettings[4]\n        IAMcoefficient = SWHsystemSettings[5]\n        skyViewFactor = SWHsystemSettings[6]\n        beamIndexPerHourData = SWHsystemSettings[7]\n        maxWorkingTemperature = SWHsystemSettings[8]\n        dischargeTemperature = SWHsystemSettings[9]\n        deliveryWaterTemperature = SWHsystemSettings[10]\n        avrJanuaryColdWaterTemperature = SWHsystemSettings[11]\n        mechanicalRoomTemperatureData = SWHsystemSettings[12]\n        pipeLength = SWHsystemSettings[13]\n        pipeDiameterMM = SWHsystemSettings[14]\n        pipeInsulationThicknessMM = SWHsystemSettings[15]\n        pipeInsulationConductivity = SWHsystemSettings[16]\n        pumpPower = SWHsystemSettings[17]\n        pumpEfficiency = SWHsystemSettings[18]\n        tankSizeLiters = SWHsystemSettings[19]\n        tankLoss = SWHsystemSettings[20]\n        heightDiameterTankRatio = SWHsystemSettings[21]\n        heatExchangerEffectiveness = SWHsystemSettings[22]\n    \n    # srfArea, activeArea, nameplateThermalCapacity\n    activeArea = srfArea * (collectorActiveAreaPercent/100)  # in m2\n    nameplateThermalCapacity = (activeArea*collectorOpticalEfficiency) - (collectorThermalLoss * 30/1000)  # in kWt\n    \n    try:\n        # check the used coldWater_inputData for calculation of domestic hot water, from \"Cold water temperature\" component\n        coldWater_inputData = sc.sticky[\"swh_coldWater_inputData\"]\n        method, minimalTemperature, pipesDepth, soilThermalDiffusivity = coldWater_inputData\n    except:\n        # domestic hot water is not included in \"_heatingLoadPerHour\" input, so by default:\n        # method 1 (Christensen and Burch) is used to calculate the initial (tankSizeLiters_fromHWC) tank size\n        method = 1; minimalTemperature = 1  # default: method 1 (Christensen and Burch), pipes depth from 0.3 to 1 meters, unknown soil type\n    coldWaterTemperaturePerHour, coldWaterTemperaturePerYear, TcoldHOYminimal, TcoldHOYmaximal = lb_photovoltaics.inletWaterTemperature(dryBulbTemperature, method, minimalTemperature)\n    if (avrJanuaryColdWaterTemperature == None):\n        avrJanuaryColdWaterTemperature = sum(coldWaterTemperaturePerHour[:(31*24)])/(31*24)\n    \n    if (mechanicalRoomTemperatureData[0] == \"air temperature\"):\n        mechanicalRoomTemperatureData = dryBulbTemperature\n    \n    if (pipeDiameterMM == None) or (pipeDiameterMM <= 0):\n        # based on: Planning & Installing Solar Thermal Systems, Earthscan, 2nd edition\n        flowSpeed = 0.7  # default in l/sec\n        volumetricFlow = flowRatePerM2*activeArea * 3600  # in l/h\n        pipeDiameterMM = math.sqrt((4 * volumetricFlow/flowSpeed) / math.pi)  # in mm\n    pipeDiameterMM = math.ceil(pipeDiameterMM*10)/10  # round to 0.1 mm\n    \n    if (pipeInsulationThicknessMM == None) or (pipeInsulationThicknessMM < 0):\n        # based on: EN 12976-2 standard\n        if (pipeDiameterMM <= 22):\n            pipeInsulationThicknessMM = 20\n        elif (pipeDiameterMM > 22) and (pipeDiameterMM <= 28):\n            pipeInsulationThicknessMM = 25\n        elif (pipeDiameterMM > 28) and (pipeDiameterMM <= 42):\n            pipeInsulationThicknessMM = 30\n        elif (pipeDiameterMM > 42) and (pipeDiameterMM <= 100):\n            pipeInsulationThicknessMM = pipeDiameterMM\n        elif (pipeDiameterMM > 100):\n            pipeInsulationThicknessMM = 100\n    pipeInsulationThicknessM = pipeInsulationThicknessMM/1000  # convert to meters\n    pipeDiameterM = pipeDiameterMM/1000  # convert from mm to m\n    \n    if (pumpPower == None) or (pumpPower < 0):\n        # based on: Planning & Installing Solar Thermal Systems, Earthscan, 2nd edition\n        if activeArea < 6:\n            activeAreaCategory = 0\n        elif (activeArea >= 6) and (activeArea < 13):\n            activeAreaCategory = 1\n        elif (activeArea >= 13) and (activeArea < 17):\n            activeAreaCategory = 2\n        elif (activeArea >= 17) and (activeArea < 21):\n            activeAreaCategory = 3\n        elif (activeArea >= 21) and (activeArea < 26):\n            activeAreaCategory = 4\n        elif (activeArea >= 26) and (activeArea < 30):\n            activeAreaCategory = 5\n        # RETscreen recommendation\n        elif (activeArea >= 30) and (activeArea < 35):\n            pumpPower = 185\n        elif (activeArea >= 35) and (activeArea < 60):\n            pumpPower = 205\n        elif (activeArea > 60):\n            pumpPower = 205 + 2*(round(activeArea)-60)\n        \n        if activeArea < 30:\n            pumpPowerFromPipeLengthL = [[30, 36, 42, 49, 55, 55], [32, 39, 46, 53, 60], [37, 43, 49, 54, 60], [45, 49, 53, 57, 60], [45, 50, 56, 61, 67], [61, 67, 75, 82, 90]]\n            pumpPowerFromPipeLengthSubItem = pumpPowerFromPipeLengthL[activeAreaCategory]\n            if (pipeLength <= 10):\n                pipeLengthIndex = 0\n            elif (pipeLength > 10) and (pipeLength <= 20):\n                pipeLengthIndex = 1\n            elif (pipeLength > 20) and (pipeLength <= 30):\n                pipeLengthIndex = 2\n            elif (pipeLength > 30) and (pipeLength <= 40):\n                pipeLengthIndex = 3\n            elif (pipeLength > 40) and (pipeLength <= 50):\n                pipeLengthIndex = 4\n            \n            if pipeLength <= 50:\n                pumpPower = pumpPowerFromPipeLengthSubItem[pipeLengthIndex]\n            else:\n                pumpPower = int(pumpPowerFromPipeLengthSubItem[4] + math.ceil(6*(pipeLength-50)/10))\n    \n    # larger diameters for passive systems\n    elif (pumpPower == 0):\n        pipeDiameterM = 1.5 * pipeDiameterM\n    \n    # tank size based on HWCdailyAveragePerYear\n    HWCL = []\n    for i in range(1,8760):\n        HWC = (heatingLoadPerHourData[i] * 859.8456)/(deliveryWaterTemperature - coldWaterTemperaturePerHour[i])  # in liters/hr\n        HWCL.append(HWC)\n    HWCdailyAveragePerYear = sum(HWCL)/365  # in liters\n    tankSizeLiters_fromHWC = 1.5 * HWCdailyAveragePerYear # default (in liters)\n    tankSizeLiters_fromHWC = math.ceil(tankSizeLiters_fromHWC/10)*10  # round to 10 liters\n    \n    if (tankSizeLiters == None) or (tankSizeLiters <= 0):\n        tankSizeLiters = tankSizeLiters_fromHWC\n    else:\n        # some value has been inputted into the \"tankSize_\" input of the \"SolarWaterHeting system\" component\n        pass\n    \n    if tankSizeLiters < 100:  # 100 liters, minimal tank size\n        tankSizeLiters = 100  # in liters\n    tankSizeM3 = tankSizeLiters/1000  # in m3\n    \n    if tankSizeLiters_fromHWC < 100:  # 100 liters, minimal tank size\n        tankSizeLiters_fromHWC = 100  # in liters\n    sc.sticky[\"swh_tankSizeM3_fromHWC\"] = tankSizeLiters_fromHWC/1000\n    \n    SWHsystemSettings = [collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, workingFluidHeatCapacity, flowRatePerM2, IAMcoefficient, skyViewFactor, beamIndexPerHourData, maxWorkingTemperature, dischargeTemperature, deliveryWaterTemperature, avrJanuaryColdWaterTemperature, mechanicalRoomTemperatureData, pipeLength, pipeDiameterM, pipeInsulationThicknessM, pipeInsulationConductivity, pumpPower, pumpEfficiency, tankSizeM3, tankLoss, heightDiameterTankRatio, heatExchangerEffectiveness]\n    \n    validSWHsystemSettings = True\n    printMsg = \"ok\"\n    \n    return coldWaterTemperaturePerHour, activeArea, nameplateThermalCapacity, SWHsystemSettings, validSWHsystemSettings, printMsg\n\n\ndef checkAnnualHourlyInputData(annualHourlyData):\n    \n    if annualHourlyData == []:\n        annualHourlyDataLists = []\n        annualHourlyDataListsEpwNames = []\n        validAnnualHourlyData = True\n        printMsg = \"ok\"\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\n    elif len(annualHourlyData) % 8767 != 0:\n        annualHourlyDataLists = annualHourlyDataListsEpwNames = None\n        validAnnualHourlyData = False\n        printMsg = \"Your annualHourlyData_ input is not correct. Please input complete 8767 items long list(s) from \\\"Ladybug_Import epw\\\" component\"\n        return annualHourlyDataLists, validAnnualHourlyData, annualHourlyDataListsEpwNames, printMsg\n    else:\n        annualHourlyDataLists = []\n        annualHourlyDataListsEpwNames = []\n        startIndex = 0\n        endIndex = 8767\n        for i in range(int(len(annualHourlyData)/8767)):\n            untrimmedList = annualHourlyData[startIndex:endIndex]\n            trimmedList = untrimmedList[7:]\n            annualHourlyDataListsName = untrimmedList[2]\n            annualHourlyDataLists.append(trimmedList)\n            annualHourlyDataListsEpwNames.append(annualHourlyDataListsName)\n            startIndex += 8767\n            endIndex += 8767\n        \n        validAnnualHourlyData = True\n        printMsg = \"ok\"\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\n\n\ndef checkConditionalStatement(conditionalStatement, annualHourlyDataLists, annualHourlyDataListsEpwNames, weatherPerHourDataSubLists, addZero):\n    \n    if conditionalStatement == None and len(annualHourlyDataLists) > 0: # conditionalStatement_ not inputted, annualHourlyData_ inputted\n        validConditionalStatement = False\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n        printMsg = \"Please supply \\\"conditionalStatement_\\\" for inputted \\\"annualHourlyData_\\\" data.\"\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n    elif conditionalStatement == None and len(annualHourlyDataLists) == 0:  # conditionalStatement_ not inputted, annualHourlyData_ not inputted\n        conditionalStatement = \"True\"\n    else:  # conditionalStatement_ inputted, annualHourlyData_ not\n        if annualHourlyDataLists == []:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"Please supply \\\"annualHourlyData_\\\" data for inputted \\\"conditionalStatement_\\\".\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        else:  # both conditionalStatement_ and annualHourlyData_ inputted\n            conditionalStatement = conditionalStatement.lower()\n            conditionalStatement = re.sub(r\"\\b([a-z])\\b\", r\"\\1[i]\", conditionalStatement)\n    \n    annualHourlyDataListsNames = map(chr, range(97, 123))\n    \n    # finalPrint conditonal statements for \"printOutput\" function\n    if conditionalStatement != \"True\":  # conditionalStatement_ not inputted\n        # replace conditionalStatement annualHourlyDataListsNames[i] names with annualHourlyDataListsEpwNames:\n        conditionalStatementForFinalPrint = conditionalStatement[:]\n        for i in range(len(annualHourlyDataLists)):\n            conditionalStatementForFinalPrint = conditionalStatementForFinalPrint.replace(annualHourlyDataListsNames[i]+\"[i]\", annualHourlyDataListsEpwNames[i])\n    else:\n        conditionalStatementForFinalPrint = \"No condition\"\n    \n    annualHourlyDataListsNames = map(chr, range(97, 123))\n    numberOfLetters = 0\n    \n    for letter in annualHourlyDataListsNames:\n        changedLetter = letter+\"[i]\"\n        if changedLetter in conditionalStatement:\n            numberOfLetters += 1\n    if numberOfLetters > len(annualHourlyDataLists):\n        validConditionalStatement = False\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n        printMsg = \"The number of a,b,c... variables you supplied in \\\"conditionalStatement_\\\" is larger than the number of \\\"annualHourlyData_\\\" lists you inputted. Please make the numbers of these two equal or less.\"\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n    else:\n        for i in range(len(annualHourlyDataLists)):\n            exec(\"%s = %s\" % (annualHourlyDataListsNames[i],annualHourlyDataLists[i]))\n        \n        try:\n            weatherPerHourDataConditionalStatementSubLists = []\n            for i in range(len(weatherPerHourDataSubLists)):\n                weatherPerHourDataConditionalStatementSubLists.append([])\n            for i in range(len(weatherPerHourDataSubLists[0])):\n                exec(\"conditionalSt = %s\" % conditionalStatement)\n                if addZero == True:  # add 0 if conditionalStatement == False\n                    if conditionalSt:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\n                    else:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(0)\n                else:  # skip the value\n                    if conditionalSt:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\n        except Exception, e:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"Your \\\"conditionalStatement_\\\" is incorrect. Please provide a valid conditional statement in Python, such as \\\"a>25 and b<80\\\" (without the quotation marks)\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        \n        if len(weatherPerHourDataConditionalStatementSubLists[0]) == 0:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"No \\\"annualHourlyData_\\\" coresponds to \\\"conditionalStatement_\\\". Please edit your \\\"conditionalStatement_\\\"\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        else:\n            validConditionalStatement = True\n            printMsg = \"ok\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n\n\ndef main(latitude, longitude, timeZone, locationName, years, months, days, hours, heatingLoadPerHour, coldWaterTemperaturePerHour, activeArea, srfTiltD, correctedSrfAzimuthD, dryBulbTemperature, directNormalRadiation, diffuseHorizontalRadiation, albedoL, SWHsystemSettings, conditionalStatementForFinalPrint):\n    \n    Fr, FrUL, dummycollectorActiveAreaPercent, Cp, mDot, bo, SVF, beamIndexPerHourData, TmaxW, TdischargeW, TdeliveryW, TcoldJanuaryW, TmechRoomL, L, Di, insulT, pipeInsulationConductivity, pumpPower, pumpEfficiency, tankSizeM3, tankLoss, heightDiameterTankRatio, epsilon = SWHsystemSettings\n    heatFromTankPerHour = [0]\n    heatFromAuxiliaryHeaterPerHour = [0]\n    dischargedHeatPerHour = [0]\n    pumpEnergyPerHour = [0]\n    tankWaterTemperaturePerHour = [TcoldJanuaryW]\n    beamRadiationPerHour = [0]\n    diffuseRadiationPerHour = [0]\n    groundRadiationPerHour = [0]\n    AOI_RL = []\n    \n    tankArea = 2 * (((tankSizeM3**2)*math.pi*2*heightDiameterTankRatio) ** (1/3)) * (1+1/(2*heightDiameterTankRatio))\n    \n    for i in range(1,8760):\n        sunZenithD, sunAzimuthD, sunAltitudeD = lb_photovoltaics.NRELsunPosition(latitude, longitude, timeZone, years[i], months[i], days[i], hours[i]-1)\n        Epoa_shaded, Eb_shaded, Ed_sky, Eground, AOI_R = lb_photovoltaics.POAirradiance(sunZenithD, sunAzimuthD, srfTiltD, srfAzimuthD, directNormalRadiation[i], diffuseHorizontalRadiation[i], albedoL[i], beamIndexPerHourData[i], SVF)\n        collectorHeatLoss, collectorEfficiency, Qsolar, Qloss, Qsupply, Qaux, Qdis, Qpump, dQ, dt, Tw = lb_photovoltaics.swhdesign(activeArea, srfTiltD, AOI_R, bo, Fr, FrUL, Eb_shaded, Ed_sky, Eground, heatingLoadPerHour[i], Cp, mDot, dryBulbTemperature[i], coldWaterTemperaturePerHour[i], tankWaterTemperaturePerHour[i-1], TdeliveryW, TmaxW, TdischargeW, TmechRoomL[i], L, Di, insulT, pipeInsulationConductivity, pumpPower, pumpEfficiency, tankSizeM3, tankArea, tankLoss, epsilon)\n        heatFromTankPerHour.append(Qsupply)\n        heatFromAuxiliaryHeaterPerHour.append(Qaux)\n        dischargedHeatPerHour.append(Qdis)\n        pumpEnergyPerHour.append(Qpump)\n        tankWaterTemperaturePerHour.append(Tw)\n        beamRadiationPerHour.append(Eb_shaded)\n        diffuseRadiationPerHour.append(Ed_sky)\n        groundRadiationPerHour.append(Eground)\n        AOI_RL.append(AOI_R)\n    \n    heatFromTankPerYear = sum(heatFromTankPerHour)\n    avrDailyheatFromTankPerYear = sum(heatFromTankPerHour)/365\n    \n    # adding headings to hourly and monthly lists\n    heatFromTankPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Thermal energy from storage tank\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)] + heatFromTankPerHour\n    heatFromAuxiliaryHeaterPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Thermal energy from auxiliary heater\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)] + heatFromAuxiliaryHeaterPerHour\n    dischargedHeatPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Discharged thermal energy from storage tank\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)] + dischargedHeatPerHour\n    tankWaterTemperaturePerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Storage tank water temperature\", \"C\", \"Hourly\", (1, 1, 1), (12, 31, 24)] + tankWaterTemperaturePerHour\n    pumpEnergyPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Circulation pumps electricity consumption\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)] + pumpEnergyPerHour\n    \n    # optimal collector area, tank storage volume initial data\n    swh_inputData = [conditionalStatementForFinalPrint, activeArea, srfTiltD, AOI_RL, heatingLoadPerHour, beamRadiationPerHour, diffuseRadiationPerHour, groundRadiationPerHour, dryBulbTemperature, coldWaterTemperaturePerHour]+SWHsystemSettings\n    sc.sticky[\"swh_inputData\"] = swh_inputData\n    \n    return heatFromTankPerHour, heatFromTankPerYear, avrDailyheatFromTankPerYear, heatFromAuxiliaryHeaterPerHour, dischargedHeatPerHour, pumpEnergyPerHour, tankWaterTemperaturePerHour\n\n\ndef printOutput(locationName, latitude, longitude, north, albedoL, heatingLoadPerHourData, SWHsurfacePercent, srfArea, activeArea, nameplateThermalCapacity, srfAzimuthD, srfTiltD, SWHsystemSettings, conditionalStatementForFinalPrint):\n    \n    collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, workingFluidHeatCapacity, flowRatePerM2, IAMcoefficient, skyViewFactor, beamIndexPerHourData, maxWorkingTemperature, dischargeTemperature, deliveryWaterTemperature, avrJanuaryColdWaterTemperature, mechanicalRoomTemperatureData, pipeLength, pipeDiameterM, pipeInsulationThicknessM, pipeInsulationConductivity, pumpPower, pumpEfficiency, tankSizeM3, tankLoss, heightDiameterTankRatio, heatExchangerEffectiveness = SWHsystemSettings\n    resultsCompletedMsg = \"SWHsurface component results successfully completed!\"\n    printOutputMsg = \\\n    \"\"\"\nInput data:\n\nLocation: %s\nLatitude (): %s\nLongitude (): %s\nNorth (): %s\nAverage annual albedo(-): %0.2f\n\nAverage heating load per day (kWh/day): %0.2f\nSurface percentage used for SWH collectors (percent): %0.2f\nSurface area (m2): %0.2f\nSurface active area (m2): %0.2f\nNameplate thermal capacity (kWt): %0.2f\nSurface azimuth angle (): %0.2f\nSurface tilt angle (): %0.2f\n\n\nSWH system:\n\nCollector optical efficiency (-): %0.2f\nCollector thermal loss (W/m2/C): %0.2f\nCollector active area percent (percent): %0.2f\nWorking fluid heat capacity (J/kg/C): %0.2f\nFlow rate per M2 (kg/s/m2): %0.3f\nIAM modifier coefficient (-): %0.2f\nSky View Factor: %0.2f\nAverage annual Transmission index of beam irradiance (-): %0.2f\n-----\nMax working temperature (C): %0.2f\nDischarge temperature (C): %0.2f\nDelivery water temperature (C): %0.2f\nAverage January cold water temperature (C): %0.2f\nAverage mechanical room temperature (C): %0.2f\n-----\nPipe length (m): %0.2f\nPipe diameter (mm): %0.2f\nPipe insulation thickness (mm): %0.2f\nPipe insulation conductivity (W/m/C): %0.2f\nPump power (W): %0.2f\nPump efficiency (-): %0.2f\n-----\nTank size (l): %0.2f\nTank loss (W/m2/C): %0.2f\nHeight-diameter tank ratio (-): %0.2f\nHeat exchanger effectiveness (-): %0.2f\n\nCaclulation based on the following condition:\n%s\n    \"\"\" % (locationName, latitude, longitude, north, sum(albedoL)/8760, sum(heatingLoadPerHourData)/365, SWHsurfacePercent, srfArea, activeArea, nameplateThermalCapacity, srfAzimuthD, srfTiltD, collectorOpticalEfficiency, collectorThermalLoss, collectorActiveAreaPercent, workingFluidHeatCapacity, flowRatePerM2, IAMcoefficient, skyViewFactor, sum(beamIndexPerHourData)/len(beamIndexPerHourData), maxWorkingTemperature, dischargeTemperature, deliveryWaterTemperature, avrJanuaryColdWaterTemperature, sum(mechanicalRoomTemperatureData)/len(mechanicalRoomTemperatureData), pipeLength, pipeDiameterM*1000, pipeInsulationThicknessM, pipeInsulationConductivity, pumpPower, pumpEfficiency, tankSizeM3*1000, tankLoss, heightDiameterTankRatio, heatExchangerEffectiveness, conditionalStatementForFinalPrint)\n    print resultsCompletedMsg\n    print printOutputMsg\n\n\nlevel = gh.GH_RuntimeMessageLevel.Warning\nif sc.sticky.has_key(\"ladybug_release\"):\n    if sc.sticky[\"ladybug_release\"].isCompatible(ghenv.Component):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_photovoltaics = sc.sticky[\"ladybug_Photovoltaics\"]()\n        \n        if _epwFile:\n            locationName, latitude, longitude, timeZone, dryBulbTemperature, directNormalRadiation, diffuseHorizontalRadiation, albedoL, years, months, days, hours, HOYs, validEpwData, printMsg = getEpwData(_epwFile, albedo_)\n            if validEpwData:\n                unitConversionFactor = lb_preparation.checkUnits()\n                unitAreaConversionFactor = unitConversionFactor**2\n                heatingLoadPerHourData, srfArea, SWHsurfacePercent, validHeatingLoadSWHsurface, printMsg = heatingLoadSWHsurfaceInputData(_heatingLoadPerHour, _SWHsurface, SWHsurfacePercent_, unitAreaConversionFactor)\n                if validHeatingLoadSWHsurface:\n                    coldWaterTemperaturePerHour, activeArea, nameplateThermalCapacity, SWHsystemSettings, validSWHsystemSettings, printMsg = SWHsystemSettingsInput(heatingLoadPerHourData, SWHsystemSettings_, srfArea, dryBulbTemperature)\n                    if validSWHsystemSettings:\n                        validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg = checkAnnualHourlyInputData(annualHourlyData_)\n                        if validAnnualHourlyData:\n                            validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg = checkConditionalStatement(conditionalStatement_, annualHourlyDataLists, annualHourlyDataListsEpwNames, [directNormalRadiation, diffuseHorizontalRadiation], True)\n                            if validConditionalStatement:\n                                directNormalRadiationCondStat, diffuseHorizontalRadiationCondStat = weatherPerHourDataConditionalStatementSubLists\n                                # all inputs ok\n                                if _runIt:\n                                    SWHsurfaceTiltAngle_ = None; SWHsurfaceAzimuthAngle_ = None; SWHsurfaceInputType = \"brep\"\n                                    srfAzimuthD, surfaceTiltDCalculated = lb_photovoltaics.srfAzimuthAngle(SWHsurfaceAzimuthAngle_, SWHsurfaceInputType, rs.coercegeometry(_SWHsurface), latitude)\n                                    correctedSrfAzimuthD, northDeg, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(north_, srfAzimuthD)\n                                    srfTiltD = lb_photovoltaics.srfTiltAngle(SWHsurfaceTiltAngle_, surfaceTiltDCalculated, SWHsurfaceInputType, rs.coercegeometry(_SWHsurface), latitude)\n                                    heatFromTankPerHour, heatFromTankPerYear, avrDailyheatFromTankPerYear, heatFromAuxiliaryHeaterPerHour, dischargedHeatPerHour, pumpEnergyPerHour, tankWaterTemperaturePerHour = main(latitude, longitude, timeZone, locationName, years, months, days, hours, heatingLoadPerHourData, coldWaterTemperaturePerHour, activeArea, srfTiltD, correctedSrfAzimuthD, dryBulbTemperature, directNormalRadiationCondStat, diffuseHorizontalRadiationCondStat, albedoL, SWHsystemSettings, conditionalStatementForFinalPrint)\n                                    printOutput(locationName, latitude, longitude, northDeg, albedoL, heatingLoadPerHourData, SWHsurfacePercent, srfArea, activeArea, nameplateThermalCapacity, srfAzimuthD, srfTiltD, SWHsystemSettings, conditionalStatementForFinalPrint)\n                                    SWHsurfaceTiltAngle = srfTiltD; SWHsurfaceAzimuthAngle = correctedSrfAzimuthD; systemSize = nameplateThermalCapacity\n                                else:\n                                    print \"All inputs are ok. Please set the \\\"_runIt\\\" to True, in order to run the Solar water heating surface component\"\n                            else:\n                                print printMsg\n                                ghenv.Component.AddRuntimeMessage(level, printMsg)\n                        else:\n                            print printMsg\n                            ghenv.Component.AddRuntimeMessage(level, printMsg)\n                    else:\n                        print printMsg\n                        ghenv.Component.AddRuntimeMessage(level, printMsg)\n                else:\n                    print printMsg\n                    ghenv.Component.AddRuntimeMessage(level, printMsg)\n            else:\n                print printMsg\n                ghenv.Component.AddRuntimeMessage(level, printMsg)\n        else:\n            printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n            print printMsg\n            ghenv.Component.AddRuntimeMessage(level, printMsg)\n    else:\n        printMsg = \"You need a newer version of Ladybug to use this component.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag the Ladybug_Ladybug component \" + \\\n            \"into the canvas and try again.\"\n        print printMsg\nelse:\n    printMsg = \"First please let the Ladybug fly...\"\n    print printMsg\n    ghenv.Component.AddRuntimeMessage(level, printMsg)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}