{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/trimesh_curvature.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/trimesh_curvature.py",
  "instruction": "Trimesh curvature",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom math import atan2\nfrom math import pi\nfrom math import sqrt\n\nimport clr  # type: ignore\nimport Rhino  # type: ignore\nimport scriptcontext  # type: ignore\nimport System  # type: ignore\n\nfrom compas.plugins import plugin\n\n\n@plugin(category=\"trimesh\", requires=[\"Rhino\"])\ndef trimesh_gaussian_curvature(M):\n    r\"\"\"Compute the discrete Gaussian curvature of a triangle mesh.\n\n    Parameters\n    ----------\n    M : tuple[sequence[[float, float, float] | :class:`compas.geometry.Point`], sequence[[int, int, int]]]\n        A mesh represented by a list of vertices and a list of faces.\n\n    Returns\n    -------\n    list[float]\n        The discrete Gaussian curvature per vertex.\n\n    Notes\n    -----\n    Description: The angle defect at a vertex is used to describe the Gaussian curvature in a neighborhood around a vertex.\n\n    Notation Convention:\n        * :math:`K_{i}` - discrete Gaussian curvature at vertex i\n        * :math:`j,k` - the vertices from the Star of vertex i\n        * :math:`e_{ij},\\, e_{ik}` - the vectors from vertex i to j and i to k\n        * :math:`\\\\theta_{i}^{jk}` - interior angle at vertex i of triangle ijk\n\n    Formula:\n\n    .. math::\n\n        K_{i} = 2\\pi-\\sum\\\\theta_{i}^{jk}\n\n    References\n    ----------\n    .. [1] Formula of Discrete Gaussian Curvature available at Keenan Crane's lecture, 03:16-07:11, at https://youtu.be/sokeN5VxBB8\n\n    Examples\n    --------\n    Make a mesh from scratch\n    >>> from compas.geometry import Sphere\n    >>> sphere = Sphere([1, 1, 1], 1)\n    >>> sphere = Mesh.from_shape(sphere, u=30, v=30)\n    >>> sphere.quads_to_triangles()\n    >>> M = sphere.to_vertices_and_faces()\n\n    Compute the discrete Gaussian curvature\n    >>> K = trimesh_gaussian_curvature(M)\n\n    \"\"\"\n    # (0) see if input is already Rhino.Geometry.Mesh\n    mesh = Rhino.Geometry.Mesh()\n    if not isinstance(M, Rhino.Geometry.Mesh):\n        for x, y, z in M[0]:\n            mesh.Vertices.Add(x, y, z)\n        for face in M[1]:\n            mesh.Faces.AddFace(*face)\n    else:\n        mesh = M\n\n    # (1) check if it is a trimesh\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh is not trimesh.\")\n\n    # (2) Prepare ingredient and return list\n    pi_2 = 2 * pi\n    K = []\n\n    # (3) Main - loop every vertex for angle defect\n    for i in range(mesh.Vertices.Count):\n        vert_neighbors_topo = mesh.TopologyVertices.ConnectedTopologyVertices(mesh.TopologyVertices.TopologyVertexIndex(i), True)\n        vert_neighbors = []\n        if vert_neighbors_topo is None:\n            K.append(None)\n            continue\n        for vert in vert_neighbors_topo:\n            vert_neighbors.extend(mesh.TopologyVertices.MeshVertexIndices(vert))\n        angles = []\n        valence = len(vert_neighbors)\n        v_i = mesh.Vertices[i]\n        # loop every neighbor\n        for j in range(valence):\n            v_j = mesh.Vertices[vert_neighbors[j]]\n            v_k = mesh.Vertices[vert_neighbors[(j + 1) % valence]]\n            e_ij = v_j - v_i\n            e_ik = v_k - v_i\n            angles.append(Rhino.Geometry.Vector3d.VectorAngle(e_ij, e_ik))\n        K.append(pi_2 - sum(angles))\n    # (4) Output\n    return K\n\n\ntrimesh_gaussian_curvature.__plugin__ = True\n\n\n@plugin(category=\"trimesh\", requires=[\"Rhino\"])\ndef trimesh_mean_curvature(M):\n    r\"\"\"Compute the discrete mean curvature of a triangle mesh.\n\n    Parameters\n    ----------\n    M : tuple[sequence[[float, float, float] | :class:`compas.geometry.Point`], sequence[[int, int, int]]]\n        A mesh represented by a list of vertices and a list of faces.\n\n    Returns\n    -------\n    list[float]\n        The discrete mean curvature per vertex.\n\n    Notes\n    -----\n    Description: The discrete mean curvature is computed by edge length and its dihedral angle.\n\n    Notation Convention:\n        * :math:`H_{i}` - discrete mean curvature at vertex i\n        * :math:`E` - all the edges connected to vertex i\n        * :math:`j` - a vertex connected to vertex i\n        * :math:`l_{ij}` - the length of edge ij\n        * :math:`\\phi_{ij}` - the dihedral angle of edge ij\n\n    Formula:\n\n    .. math::\n\n        H_{i} = \\frac{1}{4}\\sum_{ij\\in E}l_{ij}\\phi_{ij}\n\n    References\n    ----------\n    .. [1] Formula of Discrete Mean Curvature available at Keenan Crane's lecture, 03:16-07:11, at https://youtu.be/sokeN5VxBB8\n    .. [2] Formula of dihedral angle available at Keenan Crane's lecture, 04:20-05:43, at https://youtu.be/NlU1m-OfumE\n\n    Examples\n    --------\n    Make a mesh from scratch\n    >>> from compas.geometry import Sphere\n    >>> sphere = Sphere([1, 1, 1], 1)\n    >>> sphere = Mesh.from_shape(sphere, u=30, v=30)\n    >>> sphere.quads_to_triangles()\n    >>> M = sphere.to_vertices_and_faces()\n\n    Compute the discrete mean curvature\n    >>> H = trimesh_mean_curvature(M)\n\n    \"\"\"\n    # (0) see if input is already Rhino.Geometry.Mesh\n    mesh = Rhino.Geometry.Mesh()\n    if not isinstance(M, Rhino.Geometry.Mesh):\n        for x, y, z in M[0]:\n            mesh.Vertices.Add(x, y, z)\n        for face in M[1]:\n            mesh.Faces.AddFace(*face)\n    else:\n        mesh = M\n\n    # (1) check if it is a trimesh\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh is not trimesh.\")\n\n    # (2) Prepare ingredient and return list\n    H = []\n    mesh.FaceNormals.ComputeFaceNormals()\n    faces_normal = mesh.FaceNormals\n\n    # (3) Main - loop over all vertices\n    for i in range(mesh.Vertices.Count):\n        edges = mesh.TopologyVertices.ConnectedEdges(mesh.TopologyVertices.TopologyVertexIndex(i))\n        vertex = Rhino.Geometry.Point3d.FromPoint3f(mesh.Vertices[i])\n        if edges is None:\n            H.append(None)\n            continue\n        x = []\n        # (3.1) loop topology edges of such vertex\n        for edge in edges:\n            l_ij = mesh.TopologyEdges.EdgeLine(edge).Length\n            orientation = clr.StrongBox[System.Array[bool]]()\n            faces = mesh.TopologyEdges.GetConnectedFaces(edge, orientation)\n            if len(faces) != 2:\n                x.append(0)\n                continue\n            # (3.2) to know which face is on left or right\n            orientation = list(orientation.Value)\n            start_pt = mesh.TopologyEdges.EdgeLine(edge).From\n            direction = start_pt.EpsilonEquals(vertex, scriptcontext.doc.ModelAbsoluteTolerance)\n            normals = dict(zip(orientation, [faces_normal[faces[0]], faces_normal[faces[1]]]))\n            e = mesh.TopologyEdges.EdgeLine(edge).Direction\n            e.Unitize()\n            n1 = normals[True]\n            n2 = normals[False]\n            if not direction:\n                e.Reverse()\n                n1, n2 = n2, n1\n            # (3.3) calculate dihedral angle\n            angle = dihedral_angle(e, n1, n2)\n            x.append(l_ij * angle)\n        H.append(1 / 4 * sum(x))\n\n    # (4) Output\n    return H\n\n\ntrimesh_mean_curvature.__plugin__ = True\n\n\n@plugin(category=\"trimesh\", requires=[\"Rhino\"])\ndef trimesh_principal_curvature(M):\n    r\"\"\"Compute the principal curvature of a triangle mesh.\n\n    Parameters\n    ----------\n    M : tuple[sequence[[float, float, float] | :class:`compas.geometry.Point`], sequence[[int, int, int]]]\n        A mesh represented by a list of vertices and a list of faces.\n\n    Returns\n    -------\n    list[float]\n        The max curvature per vertex.\n    list[float]\n        The min curvature per vertex.\n\n    Notes\n    -----\n    Description: The discrete principal curvature is computed by mean curvature, Gaussian curvature, and vertex area.\n\n    Notation Convention:\n        * :math:`\\kappa^1_i, \\kappa^2_i` - The max principal curvature and the min principal curvature at the vertex i\n        * :math:`H_i` - the discrete mean curvature at vertex i\n        * :math:`K_i` - the discrete Gaussian curvature at vertex i\n        * :math:`A_i` - the area of the dual cell centered at vertex i\n\n    Formula:\n\n    .. math::\n\n        \\kappa^1_i, \\kappa^2_i =  \\frac{H_i}{A_i}\\pm\\sqrt{\\left( \\,\\frac{H_i}{A_i}\\right)\\,^2-\\frac{K_i}{A_i}}\n\n    References\n    ----------\n    .. [1] Formula of Discrete Principal Curvature available at Keenan Crane's lecture, 03:16-07:11, at https://youtu.be/sokeN5VxBB8\n\n    Examples\n    --------\n    Make a mesh from scratch\n    >>> from compas.geometry import Sphere\n    >>> sphere = Sphere([1, 1, 1], 1)\n    >>> sphere = Mesh.from_shape(sphere, u=30, v=30)\n    >>> sphere.quads_to_triangles()\n    >>> M = sphere.to_vertices_and_faces()\n\n    Compute the discrete principal curvature\n    >>> H = trimesh_principal_curvature(M)\n\n    \"\"\"\n    # (0) see if input is already Rhino.Geometry.Mesh\n    mesh = Rhino.Geometry.Mesh()\n    if not isinstance(M, Rhino.Geometry.Mesh):\n        for x, y, z in M[0]:\n            mesh.Vertices.Add(x, y, z)\n        for face in M[1]:\n            mesh.Faces.AddFace(*face)\n    else:\n        mesh = M\n\n    # (1) check if it is a trimesh\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh is not trimesh.\")\n\n    # (2) Prepare ingredient and return list\n    k1 = []\n    k2 = []\n    A = trimesh_barycentric_area(mesh)\n    H = trimesh_mean_curvature(mesh)\n    K = trimesh_gaussian_curvature(mesh)\n\n    # (3) Main - loop over all vertices\n    for i in range(mesh.Vertices.Count):\n        if A[i] == 0:\n            k1.append(None)\n            k2.append(None)\n            continue\n        H_ = H[i] / A[i]\n        K_ = K[i] / A[i]\n\n        discriminant = sqrt(max(0, H_ * H_ - K_))\n        k1.append(H_ + discriminant)\n        k2.append(H_ - discriminant)\n\n    # (4) Output\n    return k1, k2\n\n\ntrimesh_principal_curvature.__plugin__ = True\n\n\ndef trimesh_barycentric_area(mesh):\n    # (1) prepare return list\n    areas = [0] * mesh.Vertices.Count\n\n    # (2) Main - loop over mesh faces rather than vertices\n    for i in range(mesh.Faces.Count):\n        # Heron's Formula\n        ptA = mesh.Faces.GetFaceVertices(i)[1]\n        ptB = mesh.Faces.GetFaceVertices(i)[2]\n        ptC = mesh.Faces.GetFaceVertices(i)[3]\n        dA = ptB.DistanceTo(ptC)\n        dB = ptA.DistanceTo(ptC)\n        dC = ptA.DistanceTo(ptB)\n        p = (dA + dB + dC) / 2\n        area = sqrt(p * (p - dA) * (p - dB) * (p - dC)) / 3\n\n        # topology vertices\n        verts_topo = mesh.Faces.GetTopologicalVertices(i)\n        # vertices\n        verts = []\n        for vert_topo in verts_topo:\n            verts.extend(mesh.TopologyVertices.MeshVertexIndices(vert_topo))\n        for vert in verts:\n            areas[vert] += area\n\n    # (3) output\n    return areas\n\n\ndef dihedral_angle(e, n1, n2):\n    # Compute the dihedral angle of an edge\n    # e: the vector from vertex i to j\n    # n1: the normal vector of MeshFace on LEFT side\n    # n2: the normal vector of MeshFace on RIGHT side\n\n    cos_theta = Rhino.Geometry.Vector3d.Multiply(n1, n2)\n    sin_theta = Rhino.Geometry.Vector3d.Multiply(Rhino.Geometry.Vector3d.CrossProduct(n1, n2), e)\n    return atan2(sin_theta, cos_theta)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}