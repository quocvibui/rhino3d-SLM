{
  "source_url": "https://github.com/dhardestylewis/rhino_helper_scripts/blob/1902d7840da7adb94549860d6b6369a4f9856314/ColorWoodhavenByEqMult.py",
  "repo": "dhardestylewis/rhino_helper_scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "ColorWoodhavenByEqMult.py",
  "instruction": "Color woodhaven by eq mult",
  "code": "import rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as rg\r\nimport System.Drawing.Color as Color\r\nimport csv\r\nimport json\r\nimport math\r\n\r\n# Input parameters\r\ncsv_path = r\"C:\\Users\\dhl\\Downloads\\updated_merged_gdf_r1_r5.csv\"\r\n\r\n# Function to read CSV and extract data\r\ndef read_csv(file_path):\r\n    data = []\r\n    with open(file_path, 'r') as f:\r\n        reader = csv.DictReader(f)\r\n        for row in reader:\r\n            data.append(row)\r\n    return data\r\n\r\n# Function to create a spectral colormap\r\ndef spectral_colormap(t):\r\n    # Define control points for the spectral colormap\r\n    colors = [\r\n        (0.0, (0.6, 0.0, 0.0)),  # Dark Red\r\n        (0.25, (0.9, 0.4, 0.0)),  # Orange\r\n        (0.5, (1.0, 1.0, 0.2)),  # Yellow\r\n        (0.75, (0.0, 0.6, 1.0)),  # Light Blue\r\n        (1.0, (0.0, 0.0, 0.4))  # Dark Blue\r\n    ]\r\n    \r\n    # Find the two control points that t falls between\r\n    for i in range(len(colors) - 1):\r\n        t1, c1 = colors[i]\r\n        t2, c2 = colors[i+1]\r\n        if t1 <= t <= t2:\r\n            # Interpolate between the two colors\r\n            f = (t - t1) / (t2 - t1)\r\n            r = c1[0] * (1-f) + c2[0] * f\r\n            g = c1[1] * (1-f) + c2[1] * f\r\n            b = c1[2] * (1-f) + c2[2] * f\r\n            return Color.FromArgb(int(r*255), int(g*255), int(b*255))\r\n    \r\n    # If t is out of range, return the last color\r\n    return Color.FromArgb(int(colors[-1][1][0]*255), int(colors[-1][1][1]*255), int(colors[-1][1][2]*255))\r\n\r\n# Function to find nearest point\r\ndef find_nearest_point(target_point, data_points):\r\n    nearest = min(data_points, key=lambda p: rs.Distance(target_point, p['point']))\r\n    return nearest\r\n\r\n# Function to safely extract coordinates from geometry\r\ndef extract_coordinates(geometry_str):\r\n    try:\r\n        geom = json.loads(geometry_str)\r\n        if geom['type'] == 'Point':\r\n            return geom['coordinates']\r\n        elif geom['type'] == 'Polygon':\r\n            # For polygons, use the first point of the exterior ring\r\n            return geom['coordinates'][0][0]\r\n        else:\r\n            print(\"Unsupported geometry type: \" + geom['type'])\r\n            return None\r\n    except json.JSONDecodeError:\r\n        print(\"Failed to parse geometry: \" + geometry_str)\r\n        return None\r\n    except KeyError:\r\n        print(\"Invalid geometry structure: \" + geometry_str)\r\n        return None\r\n\r\n# Function to get a representative point for an object\r\ndef get_representative_point(obj):\r\n    # Try to get centroid\r\n    centroid = rs.SurfaceAreaCentroid(obj)\r\n    if centroid:\r\n        return centroid[0]\r\n    \r\n    # If centroid fails, try bounding box center\r\n    bbox = rs.BoundingBox(obj)\r\n    if bbox:\r\n        return rs.PointAdd(bbox[0], rs.PointScale(rs.PointSubtract(bbox[6], bbox[0]), 0.5))\r\n    \r\n    # If bounding box fails, try object center\r\n    center = rs.ObjectCenterPoint(obj)\r\n    if center:\r\n        return center\r\n    \r\n    # If all else fails, return None\r\n    return None\r\n\r\n# Main script\r\ndata = read_csv(csv_path)\r\n\r\n# Extract coordinates and mean values\r\nvalid_data = []\r\nfor row in data:\r\n    coords = extract_coordinates(row['geometry'])\r\n    if coords:\r\n        row['point'] = rs.CreatePoint(coords[0], coords[1], 0)  # Assuming 2D points\r\n        try:\r\n            row['equity_multiple_mean'] = float(row['equity_multiple_mean'])\r\n            valid_data.append(row)\r\n        except ValueError:\r\n            print(\"Invalid equity_multiple_mean value: \" + row['equity_multiple_mean'])\r\n\r\nif not valid_data:\r\n    print(\"No valid data found. Please check your CSV file.\")\r\n    import sys\r\n    sys.exit()\r\n\r\n# Get all buildings from the Building_Facade layer\r\nbuilding_objects = rs.ObjectsByLayer(\"Building_Facade\")\r\n\r\nif not building_objects:\r\n    print(\"No objects found in the Building_Facade layer.\")\r\n    import sys\r\n    sys.exit()\r\n\r\n# Process each building and collect values\r\nbuilding_values = []\r\nfor obj in building_objects:\r\n    rep_point = get_representative_point(obj)\r\n    if rep_point is None:\r\n        print(\"Failed to get representative point for object: \" + str(obj))\r\n        print(\"Object type: \" + rs.ObjectType(obj))\r\n        continue\r\n    \r\n    nearest_data = find_nearest_point(rep_point, valid_data)\r\n    mean_value = nearest_data['equity_multiple_mean']\r\n    building_values.append(mean_value)\r\n\r\n# Calculate min and max values from the buildings we're actually processing\r\nmin_value = min(building_values)\r\nmax_value = max(building_values)\r\n\r\n# Process each building again to apply colors\r\nfor obj, value in zip(building_objects, building_values):\r\n    # Normalize the value\r\n    t = (value - min_value) / (max_value - min_value) if max_value != min_value else 0.5\r\n    \r\n    # Get color from spectral colormap\r\n    color = spectral_colormap(t)\r\n    \r\n    # Apply the color to the building in Rhino\r\n    rs.ObjectColor(obj, color)\r\n\r\n    rep_point = get_representative_point(obj)\r\n    print(\"Colored building at ({0}, {1}, {2}) with value {3}\".format(rep_point.X, rep_point.Y, rep_point.Z, value))\r\n\r\n# Output\r\nprint(\"Buildings colored based on equity multiple means\")\r\nprint(\"Value range: {0} to {1}\".format(min_value, max_value))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}