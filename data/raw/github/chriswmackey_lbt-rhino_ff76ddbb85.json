{
  "source_url": "https://github.com/chriswmackey/lbt-rhino/blob/d650b6631f4a5708f4472427d076c2343c569ac2/commands/LBT_DirectSun.py",
  "repo": "chriswmackey/lbt-rhino",
  "repo_stars": 0,
  "repo_description": "A set of Rhino scripts that run Ladybug Tools as commands.",
  "license": "AGPL-3.0",
  "filepath": "commands/LBT_DirectSun.py",
  "instruction": "Lbt direct sun",
  "code": "#! python 2\nimport os\nimport math\n\ntry:\n    from ladybug_geometry.geometry2d import Point2D\n    from ladybug_geometry.geometry3d import Point3D, Vector3D\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_geometry:\\n\\t{}'.format(e))\n\ntry:\n    from ladybug.futil import unzip_file\n    from ladybug.config import folders\n    from ladybug.dt import DateTime\n    from ladybug.color import Colorset\n    from ladybug.legend import LegendParameters\n    from ladybug.epw import EPW\n    from ladybug.sunpath import Sunpath\n    from ladybug.datatype.time import Time\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n\ntry:\n    from ladybug_display.visualization import VisualizationSet, AnalysisGeometry, \\\n        VisualizationData, ContextGeometry\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_geometry:\\n\\t{}'.format(e))\n\ntry:\n    from ladybug_rhino.download import download_file\n    from ladybug_rhino.config import conversion_to_meters, rhino_version\n    from ladybug_rhino.togeometry import to_joined_gridded_mesh3d, to_vector3d\n    from ladybug_rhino.fromgeometry import from_point3d, from_vector3d\n    from ladybug_rhino.intersect import join_geometry_to_mesh, intersect_mesh_rays\n    from ladybug_rhino.preview import VisualizationSetConduit\n    from ladybug_rhino.bakeobjects import bake_visualization_set\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_rhino:\\n\\t{}'.format(e))\n\nimport Rhino\nimport scriptcontext as sc\n\n\nfrom System import Environment\n\ndef local_processor_count():\n    \"\"\"Get an integer for the number of processors on this machine.\n\n    If, for whatever reason, the number of processors could not be sensed,\n    None will be returned.\n    \"\"\"\n    return Environment.ProcessorCount\n\n\ndef recommended_processor_count():\n    \"\"\"Get an integer for the recommended number of processors for parallel calculation.\n\n    This should be one less than the number of processors available on this machine\n    unless the machine has only one processor, in which case 1 will be returned.\n    If, for whatever reason, the number of processors could not be sensed, a value\n    of 1 will be returned.\n    \"\"\"\n    cpu_count = local_processor_count()\n    return 1 if cpu_count is None or cpu_count <= 1 else cpu_count - 1\n\n\ndef run_direct_sun_command():\n    # get the EPW from command line\n    gepw = Rhino.Input.Custom.GetString()\n    gepw.SetCommandPrompt('Select an EPW file path or URL')\n    epw_path = None\n    if 'lbt_epw' in sc.sticky:\n        epw_path = sc.sticky['lbt_epw']\n        gepw.SetDefaultString(epw_path)\n\n    # add all of the options to the command\n    month_i_ = sc.sticky['lbt_sunpath_month'] if 'lbt_sunpath_month' in sc.sticky else 12\n    avail_months = ('All', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')\n    month_list = gepw.AddOptionList('Month', avail_months, month_i_)\n\n    day_ = sc.sticky['lbt_sunpath_day'] if 'lbt_sunpath_day' in sc.sticky else 21\n    day_option = Rhino.Input.Custom.OptionInteger(day_, 0, 31)\n    gepw.AddOptionInteger('Day', day_option)\n\n    hour_ =  sc.sticky['lbt_sunpath_hour'] if 'lbt_sunpath_hour' in sc.sticky else 24\n    hour_option = Rhino.Input.Custom.OptionInteger(hour_, 0, 24)\n    gepw.AddOptionInteger('Hour', hour_option)\n\n    north_ = sc.sticky['lbt_north'] if 'lbt_north' in sc.sticky else 0\n    north_option = Rhino.Input.Custom.OptionDouble(north_, 0, 360)\n    gepw.AddOptionDouble('North', north_option)\n\n    # get the weather file and all options\n    while True:\n        # This will prompt the user to input an EPW and visualization options\n        get_epw = gepw.Get()\n        if get_epw == Rhino.Input.GetResult.String:\n            epw_path = gepw.StringResult()\n            north_ = north_option.CurrentValue\n            day_ = day_option.CurrentValue\n            hour_ = hour_option.CurrentValue\n        elif get_epw == Rhino.Input.GetResult.Option:\n            if gepw.OptionIndex() == month_list:\n                month_i_ = gepw.Option().CurrentListOptionIndex\n        break\n\n    # save all of the options to sticky\n    sc.sticky['lbt_sunpath_month'] = month_i_\n    sc.sticky['lbt_sunpath_day'] = day_\n    sc.sticky['lbt_sunpath_hour'] = hour_\n    sc.sticky['lbt_north'] = north_\n\n    # process the EPW file path or URL\n    if not epw_path:\n        print('No EPW file selected.')\n        return\n    _def_folder = folders.default_epw_folder\n    if epw_path.startswith('http'):  # download the EPW file\n        _weather_URL = epw_path\n        if _weather_URL.lower().endswith('.zip'):  # onebuilding URL type\n            _folder_name = _weather_URL.split('/')[-1][:-4]\n        else:  # dept of energy URL type\n            _folder_name = _weather_URL.split('/')[-2]\n        epw_path = os.path.join(_def_folder, _folder_name, _folder_name + '.epw')\n        if not os.path.isfile(epw_path):\n            zip_file_path = os.path.join(_def_folder, _folder_name, _folder_name + '.zip')\n            download_file(_weather_URL, zip_file_path, True)\n            unzip_file(zip_file_path)\n        sc.sticky['lbt_epw'] = os.path.basename(epw_path)\n    elif not os.path.isfile(epw_path):\n        possible_file = os.path.basename(epw_path)[:-4] \\\n            if epw_path.lower().endswith('.epw') else epw_path\n        epw_path = os.path.join(_def_folder, possible_file, possible_file + '.epw')\n        if not os.path.isfile(epw_path):\n            print('Selected EPW file at does not exist at: {}'.format(epw_path))\n            return\n        sc.sticky['lbt_epw'] = possible_file + '.epw'\n    else:\n        sc.sticky['lbt_epw'] = epw_path\n\n    # compute the sun vectors to be used in the study\n    epw_obj = EPW(epw_path)\n    _location = epw_obj.location\n    sp = Sunpath.from_location(_location, north_)\n    months = [month_i_] if month_i_ != 0 else list(range(1, 13))\n    days = [day_] if day_ != 0 else list(range(1, 32))\n    hours = [hour_] if hour_ != 24 else list(range(0, 24))\n    _vectors, _hoys = [], []\n    for month in months:\n        for day in days:\n            for hour in hours:\n                date_obj = DateTime(month, day, hour)\n                hoy = date_obj.hoy\n                sun = sp.calculate_sun_from_hoy(hoy, False)\n                if sun.is_during_day:\n                    _vectors.append(from_vector3d(sun.sun_vector))\n                    _hoys.append(hoy)\n\n    # make a preview of the suns on the sunpath\n    center_pt3d = sc.sticky['lbt_origin'] if 'lbt_origin' in sc.sticky else Point3D()\n    scale_ = sc.sticky['lbt_sunpath_scale'] if 'lbt_sunpath_scale' in sc.sticky else 1\n    radius = (100 * scale_) / conversion_to_meters()\n    vis_set_args = [_hoys, [], None, radius, center_pt3d]\n    vis_set = sp.to_vis_set(*vis_set_args)\n    conduit = VisualizationSetConduit(vis_set)\n    conduit.Enabled = True\n    sc.doc.Views.Redraw()\n\n    # get the analysis geometry from the scene\n    geo_filter = Rhino.DocObjects.ObjectType.Surface | Rhino.DocObjects.ObjectType.PolysrfFilter | \\\n        Rhino.DocObjects.ObjectType.Mesh\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt('Select surfaces, polysurfaces, or meshes on which Direct Sun will be studied.')\n    go.GeometryFilter = geo_filter\n\n    # add all of the options for the geometry\n    grid_size_ = sc.sticky['lbt_study_grid_size'] if 'lbt_study_grid_size' in sc.sticky \\\n        else int(1 / conversion_to_meters())\n    gs_option = Rhino.Input.Custom.OptionDouble(grid_size_, True, 0)\n    go.AddOptionDouble('GridSize', gs_option)\n\n    offset_dist_ = sc.sticky['lbt_study_offset'] if 'lbt_study_offset' in sc.sticky \\\n        else round((0.1 / conversion_to_meters()), 2)\n    off_option = Rhino.Input.Custom.OptionDouble(offset_dist_, True, 0)\n    go.AddOptionDouble('Offset', off_option)\n\n    # add more attributes related to selection\n    go.GroupSelect = True\n    go.SubObjectSelect = False\n    go.EnableClearObjectsOnEntry(False)\n    go.EnableUnselectObjectsOnExit(False)\n    go.DeselectAllBeforePostSelect = False\n\n    # get the analysis geometries from the scene\n    have_preselected_objects = False\n    while True:\n        res = go.GetMultiple(1, 0)\n        if res == Rhino.Input.GetResult.Option:\n            go.EnablePreSelect(False, True)\n            continue\n        elif res != Rhino.Input.GetResult.Object:\n            return Rhino.Commands.Result.Cancel\n        if go.ObjectsWerePreselected:\n            have_preselected_objects = True\n            go.EnablePreSelect(False, True)\n            continue\n        grid_size_ = gs_option.CurrentValue\n        offset_dist_ = off_option.CurrentValue\n        break\n    if have_preselected_objects:\n        for i in range(0, go.ObjectCount):\n            rhino_obj = go.Object(i).Object()\n            if not rhino_obj is None:\n                rhino_obj.Select(False)\n        sc.doc.Views.Redraw()\n\n    # turn off the preview of the sunpath\n    conduit.Enabled = False\n    sc.doc.Views.Redraw()\n\n    # get the actual geometry from the selection\n    obj_table = Rhino.RhinoDoc.ActiveDoc.Objects\n    geometry_ = []\n    for get_obj in go.Objects():\n        geometry_.append(obj_table.Find(get_obj.ObjectId).Geometry)\n    if len(geometry_) == 0:\n        return\n\n    # save all of the options to sticky\n    sc.sticky['lbt_study_grid_size'] = grid_size_\n    sc.sticky['lbt_study_offset'] = offset_dist_\n\n    # create the gridded mesh from the geometry\n    study_mesh = to_joined_gridded_mesh3d(geometry_, grid_size_)\n    lb_points = [pt.move(vec * offset_dist_) for pt, vec in\n                 zip(study_mesh.face_centroids, study_mesh.face_normals)]\n    points = [from_point3d(pt) for pt in lb_points]\n\n    # display the analysis points in the scene\n    points_context = ContextGeometry('Analysis_Points', lb_points)\n    vis_set = VisualizationSet('Analysis_Preview', [points_context])\n    conduit = VisualizationSetConduit(vis_set)\n    conduit.Enabled = True\n    sc.doc.Views.Redraw()\n\n    # get any context geometry\n    gcon = Rhino.Input.Custom.GetObject()\n    gcon.SetCommandPrompt('Select context surfaces, polysurfaces, or meshes on which block the sun.')\n    gcon.GeometryFilter = geo_filter\n    gcon.GroupSelect = True\n    gcon.SubObjectSelect = False\n    gcon.EnableClearObjectsOnEntry(False)\n    gcon.EnableUnselectObjectsOnExit(False)\n    gcon.DeselectAllBeforePostSelect = False\n\n    # get the analysis geometries from the scene\n    have_preselected_objects = False\n    while True:\n        res = gcon.GetMultiple(1, 0)\n        if res == Rhino.Input.GetResult.Option:\n            gcon.EnablePreSelect(False, True)\n            continue\n        if gcon.ObjectsWerePreselected:\n            have_preselected_objects = True\n            gcon.EnablePreSelect(False, True)\n            continue\n        break\n    if have_preselected_objects:\n        for i in range(0, gcon.ObjectCount):\n            rhino_obj = gcon.Object(i).Object()\n            if not rhino_obj is None:\n                rhino_obj.Select(False)\n        sc.doc.Views.Redraw()\n    \n    # get the actual geometry from the selection\n    obj_table = Rhino.RhinoDoc.ActiveDoc.Objects\n    context_ = []\n    for get_obj in gcon.Objects():\n        context_.append(obj_table.Find(get_obj.ObjectId).Geometry)\n\n    # turn off the preview of the analysis points\n    conduit.Enabled = False\n    sc.doc.Views.Redraw()\n\n    # merge all of the context meshes together\n    shade_mesh = join_geometry_to_mesh(geometry_ + context_)\n\n    # get the study points and reverse the sun vectors (for backward ray-tracting)\n    rev_vec = [from_vector3d(to_vector3d(vec).reverse()) for vec in _vectors]\n    normals = [from_vector3d(vec) for vec in study_mesh.face_normals]\n\n    # intersect the rays with the mesh\n    cpu_count = recommended_processor_count()\n    int_matrix, _ = intersect_mesh_rays(\n        shade_mesh, points, rev_vec, normals, cpu_count=cpu_count)\n    results = [sum(int_list) for int_list in int_matrix]\n\n    # create an result visualization set and display it in the scene\n    vis_set = VisualizationSet('DirectSunStudy', ())\n    vis_set.display_name = 'Direct Sun Study'\n    d_type, unit = Time(), 'hr'\n\n    # create the AnalysisGeometry\n    l_par = LegendParameters()\n    l_par.colors = Colorset.ecotect()\n    vis_data = VisualizationData(results, l_par, d_type, unit)\n    mesh_geo = AnalysisGeometry('Direct_Sun_Data', [study_mesh], [vis_data])\n    mesh_geo.display_name = 'Direct Sun Data'\n    mesh_geo.display_mode = 'Surface'\n    vis_set.add_geometry(mesh_geo)\n\n    # preview the visualization set\n    render_2d_legend = True if rhino_version < (8, 0) else False\n    render_3d_legend = False if rhino_version < (8, 0) else True\n    conduit = VisualizationSetConduit(\n        vis_set, render_2d_legend=render_2d_legend, render_3d_legend=render_3d_legend)\n    conduit.Enabled = True\n    sc.doc.Views.Redraw()\n\n    # finally, let people decide what they want to do with the result\n    gres = Rhino.Input.Custom.GetString()\n    gres.SetCommandPrompt('Would you like to add the Study Geometry to the Document? Hit ENTER when done.')\n    gres.SetDefaultString('Add?')\n    bake_result = False\n    result_option = Rhino.Input.Custom.OptionToggle(False, 'No', 'Yes')\n    gres.AddOptionToggle('AddToDoc', result_option)\n    while True:\n        # This will prompt the user to input an EPW and visualization options\n        get_res = gres.Get()\n        if get_res == Rhino.Input.GetResult.String:\n            bake_result = result_option.CurrentValue\n        else:\n            continue\n        break\n    conduit.Enabled = False\n    sc.doc.Views.Redraw()\n\n    # add the visualization set to the document\n    if bake_result:\n        bake_visualization_set(vis_set, bake_3d_legend=True)\n\n\nrun_direct_sun_command()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": false
}