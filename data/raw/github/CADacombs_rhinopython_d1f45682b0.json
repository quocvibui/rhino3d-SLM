{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrep_mergeAllFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrep_mergeAllFaces.py",
  "instruction": "190424: Started this script as an extract from another.\r\n190426: Improved object selection behavior in getInput.\r\n190428: Minor bug fix.\r\n190502: Improved geometry selection filter.  Renamed an...",
  "code": "\"\"\"\r\n190424: Started this script as an extract from another.\r\n190426: Improved object selection behavior in getInput.\r\n190428: Minor bug fix.\r\n190502: Improved geometry selection filter.  Renamed an import.\r\n190520: Added bProcessAllFaces.  Refactored Opts and getInput.\r\n190524: Import-related updates.\r\n190619: Refactored 1 function into 2.\r\n190719: Minor change while tracking a bug.\r\n190731: Bug fix for when main brep is divided into multiple breps when its faces are extracted.\r\n191031: Import-related update.  Added a function.\r\n191119: Import-related update.\r\n200401: Refactored processBreps.  Simplified printed output.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\nimport xBrep_mergeFace\r\n\r\n\r\nsOpts = (\r\n        'bProcessAllFaces',\r\n        'bTryConvert',\r\n        'fTolerance',\r\n        'bShrinkSrfsOfPrimitives',\r\n        'bExtract',\r\n        'bEcho',\r\n        'bDebug',\r\n)\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    stickyKeys = {}\r\n    \r\n    for key in sOpts:\r\n        keys.append(key)\r\n        names[key] = key[1:] # Overwrite as wanted in the following.\r\n    \r\n    key = 'bProcessAllFaces'\r\n    values[key] = True\r\n    names[key] = \"Process\"\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'OnlyToLargestFace', 'AllFaces')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bTryConvert'\r\n    values[key] = True\r\n    names[key] = 'TryConvertToPrimitive'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'fTolerance'\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bShrinkSrfsOfPrimitives'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bExtract'\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n    \r\n    \r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in sOpts:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                pass\r\n    \r\n    \r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"Get breps with optional input\"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select polyface breps to merge\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.PolysrfFilter\r\n    go.SubObjectSelect = False\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    go.AcceptNumber(True, True)\r\n    \r\n    bPreselectedObjsChecked = False\r\n    \r\n    while True:\r\n        go.AddOptionToggle(Opts.names['bProcessAllFaces'], Opts.riOpts['bProcessAllFaces'])\r\n        go.AddOptionToggle(Opts.names['bTryConvert'], Opts.riOpts['bTryConvert'])\r\n        go.AddOptionDouble(Opts.names['fTolerance'], Opts.riOpts['fTolerance'])\r\n        go.AddOptionToggle(Opts.names['bShrinkSrfsOfPrimitives'], Opts.riOpts['bShrinkSrfsOfPrimitives'])\r\n        go.AddOptionToggle(Opts.names['bExtract'], Opts.riOpts['bExtract'])\r\n        go.AddOptionToggle(Opts.names['bEcho'], Opts.riOpts['bEcho'])\r\n        go.AddOptionToggle(Opts.names['bDebug'], Opts.riOpts['bDebug'])\r\n        \r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n        \r\n        if res == ri.GetResult.Object:\r\n            break\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        else:\r\n            # An option was selected or a number was entered.\r\n            key = 'fTolerance'\r\n            if res == ri.GetResult.Number:\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n            if Opts.riOpts[key].CurrentValue < 0.0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            \r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            #go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            go.ClearCommandOptions()\r\n\r\n    gBreps = [objref.ObjectId for objref in go.Objects()]\r\n    \r\n    go.Dispose()\r\n    \r\n    return (\r\n            gBreps,\r\n            Opts.values['bProcessAllFaces'],\r\n            Opts.values['bTryConvert'],\r\n            Opts.values['fTolerance'],\r\n            Opts.values['bShrinkSrfsOfPrimitives'],\r\n            Opts.values['bExtract'],\r\n            Opts.values['bEcho'],\r\n            Opts.values['bDebug'],\r\n    )\r\n\r\n\r\ndef coerceBrep(rhObj):\r\n    if isinstance(rhObj, rg.Brep):\r\n        return rhObj\r\n    elif isinstance(rhObj, rg.Surface):\r\n        return rhObj.ToBrep()\r\n    elif isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        #print rhObj.GeometryComponentIndex.ComponentIndexType\r\n        geom = rhObj.Geometry()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n    else:\r\n        return\r\n\r\n    if isinstance(geom, rg.Brep):\r\n        return geom\r\n\r\n\r\ndef processAllFacesOfBrepObject(gBrep0, bTryConvert=None, fTolerance=None, bShrinkSrfsOfPrimitives=None, bExtract=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if bTryConvert is None: bTryConvert = bTryConvert\r\n    if fTolerance is None: fTolerance = Opts.values['fTolerance']\r\n    if bShrinkSrfsOfPrimitives is None: bShrinkSrfsOfPrimitives = Opts.values['bShrinkSrfsOfPrimitives']\r\n    if bExtract is None: bExtract = Opts.values['bExtract']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    # Process all remaining faces as Face A.\r\n    \r\n    rgBrep0 = coerceBrep(gBrep0)\r\n    ct_Face_Start = ct_Face_Current = rgBrep0.Faces.Count\r\n    ct_Face_End = None\r\n    \r\n    iCountFromLargest = 0\r\n    fLastAreaForA = None\r\n    \r\n    s = \"Calculating face areas for {} faces ...\".format(\r\n            ct_Face_Current)\r\n    Rhino.RhinoApp.SetCommandPrompt(s)\r\n    \r\n    idx_Faces = []\r\n    fAreas = []\r\n    for rgFace in rgBrep0.Faces:\r\n        rgBrep_1Face = rgFace.DuplicateFace(duplicateMeshes=True)\r\n        fAreas.append(rgBrep_1Face.GetArea())\r\n        idx_Faces.append(rgFace.FaceIndex)\r\n        rgBrep_1Face.Dispose()\r\n    \r\n    zipped = zip(fAreas, idx_Faces)\r\n    zipped.sort(reverse=True)\r\n    \r\n    rgBrep0.Dispose()\r\n    \r\n    while True:\r\n        sc.escape_test()\r\n        \r\n        # Using areas as a measure skip most faces already determine.\r\n        # Most because faces of same areas may be repeated to ensure none are skipped.\r\n        fAreaFaceA = zipped[iCountFromLargest][0]\r\n        if fLastAreaForA is not None:\r\n            while fAreaFaceA > fLastAreaForA:\r\n                iCountFromLargest += 1\r\n                if iCountFromLargest == len(zipped) - 1:\r\n                    break\r\n                fAreaFaceA = zipped[iCountFromLargest][0]\r\n        \r\n        if iCountFromLargest == len(zipped) - 1:\r\n            break\r\n        \r\n        idx_rgFaceA = zipped[iCountFromLargest][1]\r\n        fLastAreaForA = fAreaFaceA\r\n        \r\n        s = \"Processing face {} of {} ...\".format(\r\n                iCountFromLargest+1, len(zipped))\r\n        Rhino.RhinoApp.SetCommandPrompt(s)\r\n        if bDebug: print s + \"  FaceIndex: \" + str(idx_rgFaceA)\r\n        \r\n        rc = xBrep_mergeFace.processBrepObject(\r\n                gBrep0=gBrep0,\r\n                idx_rgFaceA=idx_rgFaceA,\r\n                idx_rgFaces_Filter=None,\r\n                bTryConvert=bTryConvert,\r\n                fTolerance=fTolerance,\r\n                bShrinkSrfsOfPrimitives=bShrinkSrfsOfPrimitives,\r\n                bExtract=bExtract,\r\n                bEcho=False,\r\n                bDebug=bDebug,\r\n        )\r\n        \r\n        if rc is None:\r\n            iCountFromLargest += 1\r\n            if iCountFromLargest >= len(zipped) - 1:\r\n                break\r\n        else:\r\n            if bExtract:\r\n                gBrep_Merged, gBreps1_B0LessFaces = rc\r\n                if not gBreps1_B0LessFaces:\r\n                    ct_Face_End = 1 # Let's see if this always makes sense.\r\n                    break\r\n                elif len(gBreps1_B0LessFaces) > 1:\r\n                    print \"Original Brep has been divided into {} breps.\".format(\r\n                            len(gBreps1_B0LessFaces))\r\n                    print \"Rerun this script on all new polyface breps.\"\r\n                    return\r\n            else:\r\n                pass\r\n            \r\n            iCountFromLargest = 0\r\n            rgBrep0 = coerceBrep(gBrep0)\r\n            if rgBrep0.Faces.Count == 1:\r\n                rgBrep0.Dispose()\r\n                break\r\n            \r\n            ct_Face_Current = rgBrep0.Faces.Count\r\n            \r\n            s = \"Calculating face areas for {} remaining faces ...\".format(\r\n                    ct_Face_Current)\r\n            Rhino.RhinoApp.SetCommandPrompt(s)\r\n            idx_Faces = []\r\n            fAreas = []\r\n            for rgFace in rgBrep0.Faces:\r\n                rgBrep_1Face = rgFace.DuplicateFace(duplicateMeshes=True)\r\n                fAreas.append(rgBrep_1Face.GetArea())\r\n                idx_Faces.append(rgFace.FaceIndex)\r\n                rgBrep_1Face.Dispose()\r\n            \r\n            zipped = zip(fAreas, idx_Faces)\r\n            zipped.sort(reverse=True)\r\n            \r\n            rgBrep0.Dispose()\r\n    \r\n    if ct_Face_End is None:\r\n        rgBrep0 = coerceBrep(gBrep0)\r\n        ct_Face_End = rgBrep0.Faces.Count\r\n        rgBrep0.Dispose()\r\n    \r\n    if ct_Face_Start != ct_Face_End:\r\n        if bDebug:\r\n            print \"Face count changed from {} to {}.\".format(\r\n                ct_Face_Start, ct_Face_End)\r\n    else:\r\n        if bDebug:\r\n            print \"No faces were merged.  Face count remains at {}.\".format(\r\n                ct_Face_Start)\r\n    \r\n    return ct_Face_Start - ct_Face_End\r\n\r\n\r\ndef processOnlyToLargestFaceOfBrepObject(gBrep0, bTryConvert=None, fTolerance=None, bShrinkSrfsOfPrimitives=None, bExtract=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if bTryConvert is None: bTryConvert = bTryConvert\r\n    if fTolerance is None: fTolerance = Opts.values['fTolerance']\r\n    if bShrinkSrfsOfPrimitives is None: bShrinkSrfsOfPrimitives = Opts.values['bShrinkSrfsOfPrimitives']\r\n    if bExtract is None: bExtract = Opts.values['bExtract']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    rgBrep0 = coerceBrep(gBrep0)\r\n    \r\n    # Find largest face in brep.\r\n    fAreas = []\r\n    for rgFace in rgBrep0.Faces:\r\n        rgBrep_1Face = rgFace.DuplicateFace(duplicateMeshes=True)\r\n        fAreas.append(rgBrep_1Face.GetArea())\r\n        rgBrep_1Face.Dispose()\r\n    \r\n    idx_rgFaceA = fAreas.index(max(fAreas))\r\n\r\n    rc = xBrep_mergeFace.processBrepObject(\r\n            gBrep0=gBrep0,\r\n            idx_rgFaceA=idx_rgFaceA,\r\n            idx_rgFaces_Filter=None,\r\n            bTryConvert=bTryConvert,\r\n            fTolerance=fTolerance,\r\n            bShrinkSrfsOfPrimitives=bShrinkSrfsOfPrimitives,\r\n            bExtract=bExtract,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n    )\r\n\r\n    return rc\r\n\r\n\r\ndef processBreps(gBreps0, bProcessAllFaces=None, bTryConvert=None, fTolerance=None, bShrinkSrfsOfPrimitives=None, bExtract=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if bProcessAllFaces is None: bProcessAllFaces = Opts.values['bProcessAllFaces']\r\n    if bTryConvert is None: bTryConvert = Opts.values['bTryConvert']\r\n    if fTolerance is None: fTolerance = Opts.values['fTolerance']\r\n    if bShrinkSrfsOfPrimitives is None: bShrinkSrfsOfPrimitives = Opts.values['bShrinkSrfsOfPrimitives']\r\n    if bExtract is None: bExtract = Opts.values['bExtract']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    if bEcho:\r\n        print \"Maximum simplification tolerance allowed: {}\".format(fTolerance)\r\n    \r\n    \r\n    if bProcessAllFaces:\r\n        iCt_Breps_NoMerge = 0\r\n        iCt_Breps_Merge = 0\r\n        iCt_Faces_Total = 0\r\n        \r\n        for gBrep0 in gBreps0:\r\n            iCt_Faces = processAllFacesOfBrepObject(\r\n                    gBrep0=gBrep0,\r\n                    bTryConvert=bTryConvert,\r\n                    fTolerance=fTolerance,\r\n                    bShrinkSrfsOfPrimitives=bShrinkSrfsOfPrimitives,\r\n                    bExtract=bExtract,\r\n                    bEcho=bEcho,\r\n                    bDebug=bDebug,\r\n            )\r\n            if isinstance(iCt_Faces, int):\r\n                if iCt_Faces:\r\n                    iCt_Breps_Merge += 1\r\n                    iCt_Faces_Total += iCt_Faces\r\n                else:\r\n                    iCt_Breps_NoMerge += 1\r\n        if bEcho:\r\n            s = \"{} breps with merged faces.\".format(iCt_Breps_Merge)\r\n            if iCt_Faces_Total:\r\n                s += \"  Total face count was reduced by {}.\".format(iCt_Faces_Total)\r\n            if iCt_Breps_NoMerge:\r\n                s += \"  No faces were merged in {} breps.\".format(iCt_Breps_NoMerge)\r\n            print s\r\n    else:\r\n        gBreps1 = []\r\n        fTols_used_for_primitive = []\r\n        \r\n        for gBrep0 in gBreps0:\r\n            rc = processOnlyToLargestFaceOfBrepObject(\r\n                    gBrep0=gBrep0,\r\n                    bTryConvert=bTryConvert,\r\n                    fTolerance=fTolerance,\r\n                    bShrinkSrfsOfPrimitives=bShrinkSrfsOfPrimitives,\r\n                    bExtract=bExtract,\r\n                    bEcho=bEcho,\r\n                    bDebug=bDebug,\r\n            )\r\n            if rc is None: continue\r\n            gBrep0, fTol_PrimitiveUsedA = rc\r\n            gBreps1.append(gBrep0)\r\n            if fTol_PrimitiveUsedA is not None:\r\n                fTols_used_for_primitive.append(rc[1])\r\n        \r\n        if bEcho and gBreps1:\r\n            ct_gBreps0 = len(gBreps1)\r\n            if ct_gBreps0 == 1:\r\n                print \"1 brep was merged.\"\r\n            else:\r\n                print \"{} breps were merged.\".format(ct_gBreps0)\r\n            if fTols_used_for_primitive:\r\n                print \"Range of simplification tolerances used to find largest faces: {} to {}\".format(\r\n                        min(fTols_used_for_primitive),\r\n                        max(fTols_used_for_primitive))\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    \r\n    (\r\n            gBreps0,\r\n            bProcessAllFaces,\r\n            bTryConvert,\r\n            fTolerance,\r\n            bShrinkSrfsOfPrimitives,\r\n            bExtract,\r\n            bEcho,\r\n            bDebug,\r\n    ) = rc\r\n    \r\n    if bDebug:\r\n        import sys\r\n        for sModule in list(sys.modules):\r\n            if sModule[0] == 'x':\r\n                try:\r\n                    reload(sys.modules[sModule])\r\n                    print \"{} reloaded.\".format(sys.modules[sModule])\r\n                except:\r\n                    # This is for any module name changes.\r\n                    print \"{} NOT reloaded.\".format(sys.modules[sModule])\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Working ...\")\r\n    \r\n    processBreps(\r\n            gBreps0=gBreps0,\r\n            bProcessAllFaces=bProcessAllFaces,\r\n            bTryConvert=bTryConvert,\r\n            fTolerance=fTolerance,\r\n            bShrinkSrfsOfPrimitives=bShrinkSrfsOfPrimitives,\r\n            bExtract=bExtract,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n    )\r\n        \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}