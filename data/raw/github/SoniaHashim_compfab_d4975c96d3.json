{
  "source_url": "https://github.com/SoniaHashim/compfab/blob/e8a0e2b6f1e15a135e886f6d30608a5e96026502/week4/rings.py",
  "repo": "SoniaHashim/compfab",
  "repo_stars": 3,
  "repo_description": "Sonia's git repo for mat594x computational fabrication taught by Prof. Jennifer Jacobs at UC Santa Barbara Spring 2020. ",
  "license": "unknown",
  "filepath": "week4/rings.py",
  "instruction": "Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable",
  "code": "\"\"\"Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable\"\"\"\n\n__author__ = \"jenniferjacobs\"\n__modifiedby__ = \"soniahashim\"\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as geom\nfrom datetime import datetime\nimport math as math\nimport random\nimport time\n\nrandom.seed(time.time())\n\n# Hard code temperatures\nBedTemp = 60\nNozzleTemp = 205\n\n# Hard code layer height\nLayerHeight = .25\n\ndef makeGcodeInfo(sb):\n    sb.append(\"; \" + datetime.now().strftime(\"%y%m%d_%H%M%S\") + \"\\n\")\n\ndef makeGcodeHeatSettings(sb):\n    sb.append(\"M140 S\" + str(BedTemp) +\" ; Set Bed Temperature\\n\")\n    sb.append(\"M105\\n\")\n    sb.append(\"M190 S\" + str(BedTemp) +\" ; Wait for Bed Temperature\\n\")\n    sb.append(\"M104 S\" + str(NozzleTemp) +\" ; Set Nozzle Temperature\\n\")\n    sb.append(\"M105\\n\")\n    sb.append(\"M109 S\" + str(NozzleTemp) +\" ; Wait for Nozzle Temperature\\n\")\n\ndef makeGcodeStartupSettings(sb):\n    sb.append(\"G28\\n\")\n    sb.append(\"M83\\n\")\n    sb.append(\"G90\\n\")\n    sb.append(\"G1 F300 Z0.1\\n\")\n    sb.append(\"G1 X50 E8 F800\\n\")\n\n\ndef WriteFile(str, path):\n\n    f = open(path, \"w\")\n    f.write(str)\n    f.close()\n\ndef makeRetraction(amount, speed, sign):\n    mes = \"\";\n    if(sign == -1):\n        mes = \" ; Retraction\"\n    else:\n        mes = \" ; Extraction\"\n    return \"G1 F\" + str(speed) + \" E\" + str(sign * amount) + mes + \"\\n\"\n\ndef makeGcodeSpeed(fr, to, speed):\n\n    crvpts.append(to)\n    pts.append(to)\n\n    l = (to - fr).Length\n    numerator = (_NozzleWidth * l * LayerHeight)\n    denominator = (_rfil / 2) * (_rfil / 2) * math.pi\n\n    e = numerator / denominator\n\n    return \"G1 F\" + str(speed) + \" X\" + \"{:.{}f}\".format(to.X,2) + \" Y\" + \"{:.{}f}\".format(to.Y,2) + \" E\" + \"{:.{}f}\".format(e,8) + \"\\n\"\n\ndef makeGcode(to):\n    return \"G0 F9000 X\" + \"{:.{}f}\".format(to.X,2) + \" Y\" + \"{:.{}f}\".format(to.Y,2) + \"\\n\"\n\n\n\ncrvpts = []\n_LayerHeight = LayerHeight;\n_NozzleWidth = 0.4;\n_RetAmount = 6.0;\n_RetSpeed = 1200;\nPrintSpeed = 3000;\nPrintSpeedHigh = 1000;\n_rfil = 1.75\n\n# Params\nheight = 5.7\nnLayers = (int) (height / LayerHeight)\nncore = 21\nr_inner = 33\ntx = r_inner + ncore*_rfil\nty = tx\ns = 300\nstrsb = ''\n\np_switch = 0.5\nap = 0\n\npts = []\napply = True\nif(apply == True):\n    # Set up print\n    sb = []\n    makeGcodeInfo(sb)\n    makeGcodeHeatSettings(sb)\n    makeGcodeStartupSettings(sb)\n    sb.append(makeRetraction(_RetAmount, _RetSpeed, -1))\n    p_last = geom.Point3d.Origin\n\n    # For every height...\n    for k in range(0, nLayers):\n        # Extrude height for new set of rings\n        sb.append(\"G0 F300 Z\" + str(k*LayerHeight) + \"\\n\")\n\n        # For every ring...\n        for i in range(0,ncore):\n\n            # Calculate ring size\n            r = r_inner+i*.5\n            theta = 10\n            npoints = (int)(360/theta)\n\n            # For every point on the ring...\n            for p in range(npoints):\n                a = math.radians(theta)\n                x = r*math.cos(p*a+ap)+tx\n                y = r*math.sin(p*a+ap)+ty\n\n                xn = r*math.cos((p+1)*a+ap)+tx\n                yn = r*math.sin((p+1)*a+ap)+ty\n                p_fr = geom.Point3d(x,y,k)\n                p_to = geom.Point3d(xn,yn,k)\n\n                # If this is the first point in the set of rings and there is\n                # a layer of previous rings, connect the first point to the last\n                # in the old set of rings\n                if k != 0 and i== 0 and p == 0:\n                    p_last.Z = k\n                    sb.append(makeGcodeSpeed(p_last, p_fr, PrintSpeed))\n\n                # If this is the first point in the ring and there is a previous\n                # ring, connect the first point to the last point in the old ring\n                if i != 0 and p == 0:\n                    sb.append(makeGcodeSpeed(p_last, p_fr, PrintSpeed))\n\n                # Extrude filament to make up one side of ring in the print\n                sb.append(makeGcodeSpeed(p_fr, p_to, PrintSpeed))\n                p_last = p_to\n\n                if (i < 14 and p > 5*npoints/6) or (i >= 14 and p > npoints/8):\n                    if random.random() > p_switch:\n                        ap = (p+1)*a+ap\n                        break\n\n\n\n    sb.append(makeRetraction(_RetAmount, _RetSpeed, -1))\n    height += 10;\n    sb.append(\"G1 Z\" + \"{:.{}f}\".format(height*1.0,3) + \"\\n\");\n\n    sb.append(\"M84\");\n    strsb = ''.join(sb)\n    WriteFile(strsb, fname);\n\n\n# print(strsb)\nb = rs.AddInterpCurve(crvpts, degree = 1)\na = pts\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}