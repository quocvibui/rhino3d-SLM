{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_CreateMeshPatch.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_CreateMeshPatch.py",
  "instruction": "Construct a mesh patch from a variety of input geometry. Direct implementation\nof the Rhino.Geometry.Mesh.CreatePatch method.\n    Inputs:\n        OuterBoundary: (optional: can be None) Outer boundary...",
  "code": "\"\"\"\nConstruct a mesh patch from a variety of input geometry. Direct implementation\nof the Rhino.Geometry.Mesh.CreatePatch method.\n    Inputs:\n        OuterBoundary: (optional: can be None) Outer boundary polyline, if \n                       provided this will become the outer boundary of the\n                       resulting mesh. Any of the input that is completely\n                       outside the outer boundary will be ignored and have no\n                       impact on the result. If any of the input intersects the\n                       outer boundary the result will be unpredictable and is\n                       likely to not include the entire outer boundary.\n                       {item, polyline}\n        AngleTolerance: Maximum angle (in radians) between unit tangents and\n                        adjacent verticies. Used to divide curve inputs that\n                        cannot otherwise be represented as a polyline.\n                        {item, float}\n        PullbackSurface: (optional: can be None) Initial surface where 3d input\n                         will be pulled to make a 2d representation used by the\n                         function that generates the mesh. Providing a\n                         PullbackSurface can be helpful when it is similar in\n                         shape to the pattern of the input, the pulled 2d points\n                         will be a better representation of the 3d points. If \n                         all of the input is more or less coplanar to start \n                         with, providing pullbackSurface has no real benefit.\n                         {item, surface)\n        InnerBoundaryCurves: (optional: can be None) Polylines to create holes\n                             in the output mesh. If innerBoundaryCurves are the\n                             only input then the result may be None if trimback\n                             is set to false (see comments for trimback) because\n                             the resulting mesh could be invalid (all faces\n                             created contained vertexes from the perimeter\n                             boundary).\n                             {list, polyline}\n        InnerBothSideCurves: (optional: can be None) These polylines will create\n                             faces on both sides of the edge. If there are only\n                             input points(innerPoints) there is no way to\n                             guarantee a triangulation that will create an edge\n                             between two particular points. Adding a line, or\n                             polyline, to innerBothsideCurves that includes\n                             points from innerPoints will help guide the\n                             triangulation.\n                             {list, polyline}\n        InnerPoints: (optional: can be None) Points to be used to generate the\n                     mesh. If outerBoundary is not null, points outside of that\n                     boundary after it has been pulled to pullbackSurface\n                     (or the best plane through the input if pullbackSurface is\n                     null) will be ignored.\n                     {list, point}\n        TrimBack:  Only used when a outerBoundary has not been provided. When \n                   hat is the case, the function uses the perimeter of the\n                   surface as the outer boundary instead. If true, any face of\n                   the resulting triangulated mesh that contains a vertex of the\n                   perimeter boundary will be removed.\n                   {item, bool}\n        Divisions:  Only used when a outerBoundary has not been provided. When\n                    that is the case, division becomes the number of divisions\n                    each side of the surface's perimeter will be divided into\n                    to create an outer boundary to work with.\n                    {item, int}\n    Output:\n        Mesh: The mesh patch on success; None on failure.\n              {item/list, mesh}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 210105\n\"\"\"\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nghenv.Component.Name = \"CreateMeshPatch\"\nghenv.Component.NickName = \"CMP\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"02 Meshing & Remeshing\"\n\nclass CreateMeshPatch(component):\n    \n    def RunScript(\n    self, OuterBoundary, AngleTolerance, PullbackSurface, InnerBoundaryCurves,\n    InnerBothSideCurves, InnerPoints, TrimBack, Divisions\n    ):\n        if not PullbackSurface or PullbackSurface == []:\n            InnerBoundaryCurves = None\n        if not InnerBoundaryCurves or InnerBoundaryCurves == []:\n            InnerBoundaryCurves = None\n        if not InnerBothSideCurves or InnerBothSideCurves == []:\n            InnerBothSideCurves = None\n        if not InnerPoints or InnerPoints == []:\n            InnerPoints = None\n        \n        if (OuterBoundary or PullbackSurface or InnerBoundaryCurves or \n        InnerBothSideCurves or InnerPoints):\n            try:\n                Mesh = Rhino.Geometry.Mesh.CreatePatch(OuterBoundary,\n                                                AngleTolerance,\n                                                PullbackSurface,\n                                                InnerBoundaryCurves,\n                                                InnerBothSideCurves,\n                                                InnerPoints,\n                                                TrimBack,\n                                                Divisions)\n            except Exception, errMsg:\n                rml = self.RuntimeMessageLevel.Error\n                self.AddRuntimeMessage(rml, str(errMsg))\n                Mesh = Grasshopper.DataTree[object]()\n        else:\n            Mesh = Grasshopper.DataTree[object]()\n        \n        # return outputs if you have them; here I try it for you:\n        return Mesh\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}