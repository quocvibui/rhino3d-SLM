{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/sill_cripples.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/sill_cripples.py",
  "instruction": "File: timber_framing_generator/framing_elements/sill_cripples.py",
  "code": "# File: timber_framing_generator/framing_elements/sill_cripples.py\n\nfrom typing import Dict, List, Any, Tuple, Optional\nimport Rhino.Geometry as rg\nimport math\nfrom src.timber_framing_generator.config.framing import FRAMING_PARAMS, get_framing_param\nfrom src.timber_framing_generator.utils.safe_rhino import safe_get_length, safe_create_extrusion\n\n# Import our custom logging module\nfrom ..utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\n\nclass SillCrippleGenerator:\n    \"\"\"\n    Generates sill cripple studs below window openings.\n\n    Sill cripples are vertical framing members placed between the bottom plate\n    and the sill below a window opening. They transfer loads from the sill to\n    the bottom plate and help support the wall structure below window openings.\n    \"\"\"\n\n    def __init__(self, wall_data: Dict[str, Any]):\n        \"\"\"\n        Initialize the sill cripple generator with wall data.\n\n        Args:\n            wall_data: Dictionary containing wall information including:\n                - base_plane: Reference plane for wall coordinate system\n                - wall_base_elevation: Base elevation of the wall\n                - wall_top_elevation: Top elevation of the wall\n        \"\"\"\n        logger.debug(\"Initializing SillCrippleGenerator\")\n        logger.trace(f\"Wall data: {wall_data}\")\n        \n        # Store the wall data for use throughout the generation process\n        self.wall_data = wall_data\n\n        # Initialize storage for debug geometry\n        self.debug_geometry = {\"points\": [], \"planes\": [], \"profiles\": [], \"paths\": [], \"curves\": []}\n        logger.debug(\"SillCrippleGenerator initialized successfully\")\n\n    def generate_sill_cripples(\n        self,\n        opening_data: Dict[str, Any],\n        sill_data: Dict[str, Any],\n        bottom_plate_data: Dict[str, Any],\n        trimmer_positions: Optional[Tuple[float, float]] = None,\n    ) -> List[rg.Brep]:\n        \"\"\"\n        Generate sill cripple studs below a window opening.\n\n        This method creates a series of sill cripple studs between the bottom plate\n        and the sill below a window opening. The cripples are spaced equidistantly\n        between the trimmers on either side of the opening.\n\n        Args:\n            opening_data: Dictionary with opening information including:\n                - start_u_coordinate: Position along wall where opening starts\n                - rough_width: Width of the rough opening\n                - opening_type: Type of opening (\"window\" or \"door\")\n            sill_data: Dictionary with sill geometry information including:\n                - bottom_elevation: Bottom face elevation of the sill\n            bottom_plate_data: Dictionary with bottom plate information including:\n                - top_elevation: Top face elevation of the bottom plate\n            trimmer_positions: Optional tuple of (left, right) u-coordinates for trimmers\n                               If not provided, calculated from opening dimensions\n\n        Returns:\n            List of sill cripple Brep geometries\n        \"\"\"\n        logger.debug(\"Generating sill cripples\")\n        logger.trace(f\"Opening data: {opening_data}\")\n        logger.trace(f\"Sill data: {sill_data}\")\n        logger.trace(f\"Bottom plate data: {bottom_plate_data}\")\n        logger.trace(f\"Trimmer positions: {trimmer_positions}\")\n        \n        try:\n            # Only create sill cripples for windows, not doors\n            opening_type = opening_data.get(\"opening_type\", \"\").lower()\n            if opening_type != \"window\":\n                logger.info(f\"Opening is not a window (type: {opening_type}) - skipping sill cripples\")\n                return []\n\n            # Extract opening information\n            opening_u_start = opening_data.get(\"start_u_coordinate\")\n            opening_width = opening_data.get(\"rough_width\")\n\n            if None in (opening_u_start, opening_width):\n                logger.warning(\"Missing required opening data for sill cripple generation\")\n                return []\n                \n            logger.trace(f\"Opening parameters - u_start: {opening_u_start}, width: {opening_width}\")\n\n            # Get essential parameters\n            base_plane = self.wall_data.get(\"base_plane\")\n            if base_plane is None:\n                logger.warning(\"No base plane available for sill cripple generation\")\n                return []\n\n            # Calculate sill cripple dimensions from framing parameters\n            # Uses wall_data config if available (for material-specific dimensions)\n            cripple_width = get_framing_param(\n                \"cripple_width\", self.wall_data, 1.5 / 12\n            )  # Typically 1.5 inches\n            cripple_depth = get_framing_param(\n                \"cripple_depth\", self.wall_data, 3.5 / 12\n            )  # Typically 3.5 inches\n            cripple_spacing = get_framing_param(\n                \"cripple_spacing\", self.wall_data, 16 / 12\n            )  # Typically 16 inches\n            \n            logger.trace(f\"Cripple dimensions - width: {cripple_width}, depth: {cripple_depth}, spacing: {cripple_spacing}\")\n\n            # Calculate vertical bounds\n            # BUG FIX: Convert from absolute Z to relative (above base plane origin)\n            # These elevations are absolute, but PointAt/Add adds them to origin.Z\n            base_z = base_plane.Origin.Z if base_plane else 0.0\n            sill_bottom_elevation_abs = sill_data.get(\"bottom_elevation\")\n            sill_bottom_elevation = sill_bottom_elevation_abs - base_z if sill_bottom_elevation_abs is not None else None\n\n            # Try different keys for top elevation of bottom plate\n            bottom_plate_top_elevation_abs = bottom_plate_data.get(\n                \"top_elevation\"\n            ) or bottom_plate_data.get(\"boundary_elevation\")\n            bottom_plate_top_elevation = bottom_plate_top_elevation_abs - base_z if bottom_plate_top_elevation_abs is not None else None\n\n            logger.trace(f\"Sill bottom elevation: {sill_bottom_elevation} (relative), absolute was {sill_bottom_elevation_abs}\")\n            logger.trace(f\"Bottom plate top elevation: {bottom_plate_top_elevation} (relative), absolute was {bottom_plate_top_elevation_abs}\")\n\n            if None in (sill_bottom_elevation, bottom_plate_top_elevation):\n                logger.warning(\"Missing elevation data for sill or bottom plate\")\n                logger.trace(f\"Sill data keys: {sill_data.keys()}\")\n                logger.trace(f\"Bottom plate data keys: {bottom_plate_data.keys()}\")\n                return []\n\n            # Calculate horizontal positions\n            # Offset by half cripple width so outer face aligns with trimmer/opening edge\n            half_cripple_width = cripple_width / 2\n            if trimmer_positions:\n                # Use provided trimmer positions (these are trimmer inner faces)\n                u_left, u_right = trimmer_positions\n\n                u_left_inner = u_left + half_cripple_width\n                u_right_inner = u_right - half_cripple_width\n                logger.trace(f\"Using provided trimmer positions: left={u_left}, right={u_right}\")\n            else:\n                # Calculate positions based on opening with standard offsets\n                # Opening edges define where cripple outer faces should be\n                u_left_inner = opening_u_start + half_cripple_width\n                u_right_inner = opening_u_start + opening_width - half_cripple_width\n                logger.trace(\"Calculating positions based on opening dimensions\")\n\n            # Calculate internal width between inner faces\n            internal_width = u_right_inner - u_left_inner\n            \n            logger.debug(\"Sill cripple calculation details:\")\n            logger.debug(f\"Trimmer positions: left={u_left_inner}, right={u_right_inner}\")\n            logger.debug(f\"Internal width: {internal_width}\")\n            logger.debug(f\"Cripple spacing parameter: {cripple_spacing}\")\n\n            # Check if there's enough space for cripples\n            if internal_width <= 0:\n                logger.warning(\"Insufficient space for sill cripples (internal width <= 0)\")\n                return []\n                \n            # Handle case where there's only space for a single cripple\n            if internal_width < cripple_spacing:\n                logger.info(\"Space smaller than standard spacing, placing single center cripple\")\n                cripple_positions = [u_left_inner + (internal_width / 2)]\n                cripple_count = 1\n                num_spaces = 0\n                actual_spacing = 0\n            else:\n                # Calculate number of spaces based on standard spacing\n                try:\n                    num_spaces = max(1, math.ceil(internal_width / cripple_spacing))\n                    \n                    # Number of cripples is one more than number of spaces\n                    cripple_count = num_spaces + 1\n                    \n                    # Calculate actual spacing with safeguards for division by zero\n                    if num_spaces > 0:\n                        actual_spacing = internal_width / num_spaces\n                    else:\n                        actual_spacing = cripple_spacing\n                        \n                    logger.debug(f\"Number of spaces: {num_spaces}\")\n                    logger.debug(f\"Number of cripples: {cripple_count}\")\n                    logger.debug(f\"Actual spacing: {actual_spacing}\")\n                    \n                    # Generate cripple positions\n                    cripple_positions = []\n                    for i in range(cripple_count):\n                        position = u_left_inner + i * actual_spacing\n                        cripple_positions.append(position)\n                        logger.trace(f\"Cripple {i+1} position: {position}\")\n                except Exception as calc_error:\n                    logger.warning(f\"Error calculating cripple positions: {str(calc_error)}\")\n                    # Fallback: place a single cripple in the center\n                    center_position = u_left_inner + (internal_width / 2)\n                    cripple_positions = [center_position]\n                    logger.info(\"Using fallback: single center cripple\")\n                    \n            # Limit the number of cripples to prevent excessive generation\n            max_cripples = 20  # Reasonable upper limit\n            if len(cripple_positions) > max_cripples:\n                logger.warning(f\"Too many cripples calculated ({len(cripple_positions)}), limiting to {max_cripples}\")\n                # Take evenly distributed subset of positions\n                step = len(cripple_positions) / max_cripples\n                cripple_positions = [cripple_positions[int(i * step)] for i in range(max_cripples)]\n            \n            # Store sill cripples\n            sill_cripples = []\n\n            # Generate cripples at calculated positions\n            for i, u_position in enumerate(cripple_positions):\n                logger.debug(f\"Creating cripple {i+1} at u={u_position}\")\n                # Create the cripple stud\n                cripple = self._create_cripple_geometry(\n                    base_plane,\n                    u_position,\n                    bottom_plate_top_elevation,\n                    sill_bottom_elevation,\n                    cripple_width,\n                    cripple_depth,\n                )\n\n                if cripple is not None:\n                    sill_cripples.append(cripple)\n                    logger.trace(f\"Successfully created cripple at u={u_position}\")\n                else:\n                    logger.warning(f\"Failed to create cripple at u={u_position}\")\n\n            logger.info(f\"Generated {len(sill_cripples)} sill cripples\")\n            return sill_cripples\n\n        except Exception as e:\n            logger.error(f\"Error generating sill cripples: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return []\n\n    def _create_cripple_geometry(\n        self,\n        base_plane: rg.Plane,\n        u_coordinate: float,\n        bottom_v: float,\n        top_v: float,\n        width: float,\n        depth: float,\n    ) -> Optional[rg.Brep]:\n        \"\"\"\n        Create the geometry for a single sill cripple stud.\n\n        This method creates a sill cripple stud by:\n        1. Creating start and end points in the wall's coordinate system\n        2. Creating a profile perpendicular to the stud's centerline\n        3. Extruding the profile along the centerline\n\n        Args:\n            base_plane: Wall's base plane for coordinate system\n            u_coordinate: Position along wall (horizontal)\n            bottom_v: Bottom elevation of cripple (top of bottom plate)\n            top_v: Top elevation of cripple (bottom of sill)\n            width: Width of cripple (perpendicular to wall face)\n            depth: Depth of cripple (parallel to wall length)\n\n        Returns:\n            Brep geometry for the cripple, or None if creation fails\n        \"\"\"\n        logger.trace(f\"Creating cripple geometry at u={u_coordinate}, v range={bottom_v}-{top_v}\")\n        logger.trace(f\"Cripple dimensions - width: {width}, depth: {depth}\")\n\n        try:\n            # 1. Create the centerline endpoints in wall-local coordinates\n            # The wall's base_plane coordinate system is:\n            #   - XAxis = along wall (U direction)\n            #   - YAxis = vertical (V direction) - derived from World Z\n            #   - ZAxis = wall normal (W direction)\n            # Position using wall-local U,V coordinates via base_plane axes\n\n            start_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, bottom_v),\n                ),\n            )\n\n            end_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_coordinate),\n                    rg.Vector3d.Multiply(base_plane.YAxis, top_v),\n                ),\n            )\n\n            logger.trace(f\"Cripple centerline - start: {start_point}, end: {end_point}\")\n\n            # Create centerline (for debugging)\n            centerline = rg.Line(start_point, end_point).ToNurbsCurve()\n            if \"curves\" in self.debug_geometry:\n                self.debug_geometry[\"curves\"].append(centerline)\n            elif \"paths\" in self.debug_geometry:\n                self.debug_geometry[\"paths\"].append(centerline)\n            else:\n                # If neither key exists, create a new list\n                self.debug_geometry[\"paths\"] = [centerline]\n            logger.trace(\"Created cripple centerline\")\n\n            # 2. Create a profile plane at the start point\n            # Correctly orient the profile plane\n            profile_x_axis = base_plane.ZAxis  # Perpendicular to wall face\n            profile_y_axis = base_plane.XAxis  # Horizontal along wall length\n\n            profile_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n            if \"planes\" in self.debug_geometry:\n                self.debug_geometry[\"planes\"].append(profile_plane)\n            else:\n                self.debug_geometry[\"planes\"] = [profile_plane]\n            logger.trace(\"Created profile plane for cripple cross-section\")\n\n            # 3. Create a rectangular profile centered on the plane\n            profile_rect = rg.Rectangle3d(\n                profile_plane,\n                rg.Interval(-width / 2, width / 2),\n                rg.Interval(-depth / 2, depth / 2),\n            )\n\n            if \"profiles\" in self.debug_geometry:\n                self.debug_geometry[\"profiles\"].append(profile_rect)\n            else:\n                self.debug_geometry[\"profiles\"] = [profile_rect]\n            logger.trace(f\"Created profile rectangle - width: {width}, depth: {depth}\")\n\n            # 4. Extrude the profile along the centerline\n            # Calculate the vector from start to end\n            extrusion_vector = rg.Vector3d(end_point - start_point)\n            logger.trace(f\"Extrusion vector: ({extrusion_vector.X}, {extrusion_vector.Y}, {extrusion_vector.Z})\")\n            \n            # Create the extrusion using the safe method\n            brep = safe_create_extrusion(profile_rect.ToNurbsCurve(), extrusion_vector)\n            \n            try:\n                # Primary method: extrusion\n                if brep and hasattr(brep, 'IsValid') and brep.IsValid:\n                    logger.debug(\"Successfully created cripple Brep using extrusion\")\n                    # Check if already a Brep\n                    if hasattr(brep, 'ToBrep'):\n                        return brep.ToBrep()\n                    else:\n                        return brep\n                else:\n                    logger.warning(\"Failed to create cripple Brep from extrusion operation\")\n            except Exception as extrusion_error:\n                logger.warning(f\"Extrusion failed: {str(extrusion_error)}\")\n                \n            # Fallback method 1: box creation\n            try:\n                logger.debug(\"Attempting box creation for cripple\")\n                \n                # Calculate height based on start and end points\n                height = 0\n                if start_point is not None and end_point is not None:\n                    height = start_point.DistanceTo(end_point)\n                    if height <= 0:\n                        height = 1.0  # Default fallback height\n                else:\n                    height = 1.0  # Default fallback height\n                    \n                # Ensure we have valid dimensions\n                if width <= 0:\n                    width = 1.5/12.0  # Default width\n                if depth <= 0:\n                    depth = 3.5/12.0  # Default depth\n                    \n                # Create plane for box\n                if start_point is None:\n                    start_point = rg.Point3d.Origin\n                    \n                box_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n                \n                # Create a box\n                box = rg.Box(\n                    box_plane,\n                    rg.Interval(-width/2, width/2),\n                    rg.Interval(-depth/2, depth/2),\n                    rg.Interval(0, height)\n                )\n                \n                if box and box.IsValid:\n                    box_brep = box.ToBrep()\n                    if box_brep and hasattr(box_brep, 'IsValid') and box_brep.IsValid:\n                        logger.debug(\"Successfully created cripple using box method\")\n                        return box_brep\n            except Exception as box_error:\n                logger.warning(f\"Box creation failed: {str(box_error)}\")\n                \n            # Final fallback: emergency cube\n            try:\n                logger.debug(\"Creating emergency fallback cripple\")\n                \n                # Get dimensions\n                height = 1.0  # Default height\n                if start_point is not None and end_point is not None:\n                    height = start_point.DistanceTo(end_point)\n                    if height <= 0:\n                        height = 1.0\n                \n                # Create a box at origin\n                emergency_box = rg.Box(\n                    rg.Plane.WorldXY,\n                    rg.Interval(-width/2, width/2),\n                    rg.Interval(-depth/2, depth/2),\n                    rg.Interval(0, height)\n                )\n                \n                # Transform to correct position if we have a start point\n                if start_point is not None:\n                    transform = rg.Transform.Translation(\n                        start_point.X,\n                        start_point.Y,\n                        start_point.Z\n                    )\n                    emergency_box.Transform(transform)\n                \n                emergency_brep = emergency_box.ToBrep()\n                if emergency_brep and hasattr(emergency_brep, 'IsValid') and emergency_brep.IsValid:\n                    logger.warning(\"Using emergency fallback geometry for cripple\")\n                    return emergency_brep\n            except Exception as emergency_error:\n                logger.error(f\"Emergency fallback failed: {str(emergency_error)}\")\n                \n            logger.error(\"All cripple creation methods failed\")\n            return None\n            \n        except Exception as e:\n            # Main try-except block for the entire method\n            logger.error(f\"Error creating cripple geometry: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}