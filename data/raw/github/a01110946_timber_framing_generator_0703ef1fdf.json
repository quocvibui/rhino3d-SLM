{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_wall_analyzer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_wall_analyzer.py",
  "instruction": "Wall Analyzer for Grasshopper.",
  "code": "# File: scripts/gh_wall_analyzer.py\n\"\"\"Wall Analyzer for Grasshopper.\n\nExtracts wall data from Revit walls via Rhino.Inside.Revit and serializes\nto JSON format for use by downstream components in the modular framing pipeline.\n\nKey Features:\n1. Revit Data Extraction\n   - Wall geometry (length, height, thickness)\n   - Base plane and orientation\n   - Opening information (doors, windows)\n\n2. JSON Serialization\n   - Converts to standardized WallData schema\n   - Includes level references for RiR baking\n   - Opening data with UVW coordinates\n\n3. Visualization\n   - Wall base curves for preview\n   - Uses RhinoCommonFactory for correct assembly\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n    Rhino.Inside.Revit\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for output organization\n    - RhinoInside.Revit: Revit API access\n    - timber_framing_generator.wall_data: Revit extraction\n\nPerformance Considerations:\n    - Processing time scales with wall complexity\n    - Opening extraction adds overhead\n    - Typical wall processes in < 100ms\n\nUsage:\n    1. Connect Revit walls to 'walls' input\n    2. Set 'run' to True to execute\n    3. Connect 'walls_json' to Panel Decomposer component\n\nInput Requirements:\n    Walls (walls) - list[Revit.Wall]:\n        List of Revit wall elements\n        Required: Yes\n        Access: List\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Walls JSON (walls_json) - str:\n        JSON string containing wall data for all walls\n\n    Wall Curves (wall_curves) - DataTree[Curve]:\n        Wall base curves for visualization\n\n    Debug Info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Uses RhinoInside.Revit for Revit API access\n    - Converts Revit coordinates to Rhino world space\n    - Opening positions in UVW wall-relative coordinates\n\nError Handling:\n    - No Revit document returns error in debug_info\n    - Failed wall extraction logged but doesn't halt\n    - Invalid walls skipped with warning\n\nAuthor: Timber Framing Generator\nVersion: 1.2.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\nfrom dataclasses import asdict\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\nclr.AddReference(\"RhinoInside.Revit\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom RhinoInside.Revit import Revit\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n# Clear timber_framing_generator modules AND the 'src' package itself.\n# Other GH components may have already imported 'src', caching its\n# __path__ to the main repo.  Clearing it forces Python to re-resolve\n# 'src' from the updated sys.path (worktree at index 0).\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path (contains wall_helpers fixes, etc.)\n# Fallback: main repo path (for modules not yet in the worktree)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\n# Ensure worktree path has highest priority (index 0) in sys.path.\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.wall_data.revit_data_extractor import (\n    extract_wall_data_from_revit\n)\nfrom src.timber_framing_generator.core.json_schemas import (\n    WallData, Point3D, Vector3D, PlaneData, OpeningData,\n    serialize_wall_data, FramingJSONEncoder\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Wall Analyzer\"\nCOMPONENT_NICKNAME = \"WallAnalyze\"\nCOMPONENT_MESSAGE = \"v1.2\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Analysis\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Walls\", \"walls\", \"List of Revit wall elements\",\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Walls JSON\", \"walls_json\", \"JSON string containing wall data\"),\n        (\"Wall Curves\", \"wall_curves\", \"Wall base curves for visualization\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        walls: List of Revit wall elements\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not walls:\n        return False, \"No walls provided\"\n\n    return True, None\n\n\ndef convert_wall_data_to_schema(wall_data, wall_id):\n    \"\"\"Convert extracted wall data dict to WallData schema.\n\n    Args:\n        wall_data: Dictionary from extract_wall_data_from_revit()\n        wall_id: Unique wall identifier\n\n    Returns:\n        WallData instance ready for JSON serialization\n    \"\"\"\n    # Extract base plane\n    base_plane = wall_data.get('base_plane')\n    if base_plane:\n        plane_data = PlaneData(\n            origin=Point3D.from_rhino(base_plane.Origin),\n            x_axis=Vector3D.from_rhino(base_plane.XAxis),\n            y_axis=Vector3D.from_rhino(base_plane.YAxis),\n            z_axis=Vector3D.from_rhino(base_plane.ZAxis),\n        )\n    else:\n        plane_data = PlaneData(\n            origin=Point3D(0, 0, 0),\n            x_axis=Vector3D(1, 0, 0),\n            y_axis=Vector3D(0, 1, 0),\n            z_axis=Vector3D(0, 0, 1),\n        )\n\n    # Override z_axis with wall.Orientation (authoritative exterior direction).\n    # wall_helpers.py computes base_plane with a Y-axis safety guard that can\n    # make z_axis differ from (even opposite to) wall.Orientation. Fix it here\n    # at the source so walls_json.base_plane.z_axis is always correct.\n    en = wall_data.get(\"exterior_normal\")\n    if isinstance(en, dict):\n        plane_data.z_axis = Vector3D(\n            x=float(en.get(\"x\", 0)),\n            y=float(en.get(\"y\", 0)),\n            z=float(en.get(\"z\", 0)),\n        )\n\n    # Extract Revit level IDs for RiR baking\n    base_level = wall_data.get('base_level')\n    top_level = wall_data.get('top_level')\n    base_level_id = base_level.Id.IntegerValue if base_level else None\n    top_level_id = top_level.Id.IntegerValue if top_level else None\n\n    # Extract base curve endpoints\n    base_curve = wall_data.get('wall_base_curve')\n    if base_curve:\n        curve_start = Point3D.from_rhino(base_curve.PointAtStart)\n        curve_end = Point3D.from_rhino(base_curve.PointAtEnd)\n    else:\n        curve_start = Point3D(0, 0, 0)\n        curve_end = Point3D(1, 0, 0)\n\n    # Convert openings\n    openings = []\n    wall_length = float(wall_data.get('wall_length', 0))  # NEW CODE: Get wall length for validation\n    for opening in wall_data.get('openings', []):\n        o_type = opening.get('opening_type', opening.get('type', 'window'))\n        u_start = float(opening.get('start_u_coordinate', opening.get('u_start', 0)))\n        width = float(opening.get('rough_width', opening.get('width', 0)))\n        height = float(opening.get('rough_height', opening.get('height', 0)))\n        u_end = float(opening.get('u_end', u_start + width))\n\n        # NEW CODE: Validate opening is within wall bounds\n        if u_start < 0 or u_end > wall_length:\n            print(f\"WARNING: Skipping opening - outside wall bounds \"\n                  f\"(u={u_start:.2f} to {u_end:.2f}, wall_length={wall_length:.2f})\")\n            continue\n\n        sill_height = opening.get('base_elevation_relative_to_wall_base',\n                                  opening.get('sill_height', 0))\n        if sill_height is None:\n            sill_height = 0\n        v_start = float(sill_height)\n        v_end = float(opening.get('v_end', v_start + height))\n\n        opening_data = OpeningData(\n            id=str(opening.get('id', '')),\n            opening_type=o_type,\n            u_start=u_start,\n            u_end=u_end,\n            v_start=v_start,\n            v_end=v_end,\n            width=width,\n            height=height,\n            sill_height=sill_height,\n        )\n        openings.append(opening_data)\n\n    return WallData(\n        wall_id=wall_id,\n        wall_length=float(wall_data.get('wall_length', 0)),\n        wall_height=float(wall_data.get('wall_height', 0)),\n        wall_thickness=float(wall_data.get('wall_thickness', 0.5)),\n        base_elevation=float(wall_data.get('wall_base_elevation', 0)),\n        top_elevation=float(wall_data.get('wall_top_elevation', 0)),\n        base_plane=plane_data,\n        base_curve_start=curve_start,\n        base_curve_end=curve_end,\n        openings=openings,\n        is_exterior=wall_data.get('is_exterior_wall', False),\n        is_flipped=wall_data.get('is_flipped', False),\n        wall_type=wall_data.get('wall_type'),\n        wall_assembly=wall_data.get('wall_assembly'),\n        base_level_id=base_level_id,\n        top_level_id=top_level_id,\n        metadata={\n            'revit_id': wall_id,\n            'has_cells': 'cells' in wall_data,\n        }\n    )\n\n\ndef process_walls(walls_input, doc):\n    \"\"\"Process all walls through extraction.\n\n    Args:\n        walls_input: List of Revit wall elements\n        doc: Revit document\n\n    Returns:\n        Tuple of (wall_data_list, wall_curves_tree, log_lines)\n    \"\"\"\n    wall_data_list = []\n    wall_curves = DataTree[object]()\n    log_lines = [f\"Processing {len(walls_input)} walls...\"]\n    factory = get_factory()\n\n    for i, wall in enumerate(walls_input):\n        try:\n            wall_id = str(wall.Id.IntegerValue)\n            data = extract_wall_data_from_revit(wall, doc)\n\n            if data:\n                wall_data = convert_wall_data_to_schema(data, wall_id)\n                wall_data_list.append(wall_data)\n\n                # Add base curve for visualization\n                base_curve = data.get('wall_base_curve')\n                if base_curve:\n                    start_pt = base_curve.PointAtStart\n                    end_pt = base_curve.PointAtEnd\n                    rc_curve = factory.create_line_curve(\n                        (float(start_pt.X), float(start_pt.Y), float(start_pt.Z)),\n                        (float(end_pt.X), float(end_pt.Y), float(end_pt.Z))\n                    )\n                    if rc_curve:\n                        wall_curves.Add(rc_curve, GH_Path(i))\n\n                log_lines.append(\n                    f\"Wall {i} (ID:{wall_id}): L={wall_data.wall_length:.2f}', \"\n                    f\"H={wall_data.wall_height:.2f}', \"\n                    f\"Openings={len(wall_data.openings)}\"\n                )\n            else:\n                log_lines.append(f\"Wall {i}: FAILED - No data extracted\")\n\n        except Exception as e:\n            log_lines.append(f\"Wall {i}: ERROR - {str(e)}\")\n\n    return wall_data_list, wall_curves, log_lines\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Returns:\n        tuple: (walls_json, wall_curves, debug_info)\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs\n    walls_json = \"[]\"\n    wall_curves = DataTree[object]()\n    log_lines = []\n\n    try:\n        # Ensure walls is a list\n        walls_input = walls\n        if not isinstance(walls, (list, tuple)):\n            walls_input = [walls] if walls else []\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_input, run)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            return walls_json, wall_curves, error_msg\n\n        # Get Revit document\n        doc = Revit.ActiveDBDocument\n        if doc is None:\n            log_error(\"No active Revit document\")\n            return walls_json, wall_curves, \"ERROR: No active Revit document\"\n\n        log_lines.append(f\"Wall Analyzer v1.1\")\n        log_lines.append(f\"Walls: {len(walls_input)}\")\n        log_lines.append(\"\")\n\n        # Process walls\n        wall_data_list, wall_curves, process_log = process_walls(walls_input, doc)\n        log_lines.extend(process_log)\n\n        # Serialize to JSON\n        if wall_data_list:\n            wall_dicts = [asdict(w) for w in wall_data_list]\n            walls_json = json.dumps(wall_dicts, cls=FramingJSONEncoder, indent=2)\n            log_lines.append(\"\")\n            log_lines.append(f\"Success: Serialized {len(wall_data_list)} walls to JSON\")\n        else:\n            log_lines.append(\"\")\n            log_lines.append(\"Warning: No walls were successfully processed\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    return walls_json, wall_curves, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Set default values for optional inputs\ntry:\n    walls\nexcept NameError:\n    walls = None\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Execute main\nif __name__ == \"__main__\":\n    walls_json, wall_curves, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}