{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/archive/clay_bricks/PatternBrickLibrary/patternGenv2_2_1.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/archive/clay_bricks/PatternBrickLibrary/patternGenv2_2_1.py",
  "instruction": "Pattern genv2 2 1",
  "code": "import Rhino.Geometry as rg\nimport math\nimport random\nfrom vertexClass import Vertex\nfrom copy import deepcopy as dc\n\nclass PatternMap:\n\n    DOT_MAP_UV_SHIFT=(0.0,0.0)\n    DOT_MAP_SHIFT=False\n    DOT_MAP_HARD_EASING=False\n    DOT_MAP_RND=False\n    DOT_MAP_RND_SEED=0\n    Y_SPACING_FACTOR=1.0\n\n    def __init__(self, layer_set, set_tuples, periodic = False, other_set = None):\n\n        # set_tuples = (crv_l, div_l, lay_h)\n\n        self.pattern_set = layer_set\n\n        if not(other_set == None):\n\n            self.add_other_set = True\n            self.other_set = other_set\n\n        else:\n            \n            self.add_other_set = False\n\n        self.length, _, self.lay_h = set_tuples\n\n        self.div_c = len(self.pattern_set[0])\n        self.lay_c = len(self.pattern_set)\n\n        self.height = self.lay_c * self.lay_h\n\n        self.periodic = periodic\n\n        self.closed = True\n        self.curved = False\n\n        self.rnd_inout = False\n        self.rnd_cull = False\n        self.rnd_radius = False\n        self.rnd_n_val = False\n\n        self.dir = 1.0\n        \n    def build(self):\n\n        self.surface_set = []\n\n        for pattern_layer in self.pattern_set:\n\n            self.surface_set.extend(pattern_layer)\n\n    def set_random_inout(self, percentage = .5, direction = 1.0):\n\n        self.rnd_inout = True\n        self.rnd_inout_percentage = percentage\n\n    def random_inout(self):\n        if self.rnd_inout_percentage < random.random():\n\n            return -1.0\n\n        else:\n\n            return 1.0\n\n    def set_random_cull(self, cull_val):\n\n        self.rnd_cull = True\n        self.rnd_cull_val = cull_val\n\n    def set_random_radius(self, min_radius, max_radius):\n\n        self.rnd_radius = True\n        self.r_min, self.r_delta = min_radius, max_radius - min_radius\n\n    def random_rad(self):\n\n        return self.r_min + random.random() * self.r_delta\n\n    def set_random_n_val(self, min_n_val, max_n_val):\n\n        self.rnd_n_val = True\n        self.n_min, self.n_delta = min_n_val, max_n_val - min_n_val\n\n    def random_n_val(self):\n\n        return self.n_min + random.random() * self.n_delta\n\n    def edgeEasing(self, zero_length, normal_length):\n\n        ease_delta = normal_length - zero_length\n\n        for pt in self.surface_set:\n\n            if pt.x_val < zero_length or pt.x_val > self.length - zero_length:\n\n                pt.n_scale = 0.0\n\n            elif pt.x_val < normal_length:\n\n                pt.n_scale = abs(pt.x_val - zero_length) / ease_delta\n                \n            elif pt.x_val > self.length - normal_length:\n\n                pt.n_scale = abs(pt.x_val - (self.length - zero_length)) / ease_delta\n\n    def sinWarp(self, period, amplitude, phase_shift, direction = True):\n\n        if self.periodic:\n\n            print(\"sin periodicizing\")\n            print(\"updating the period\")\n            print(\"old period: %s\" %period)\n\n            period_count = math.ceil( self.length / ( 2 * math.pi * period ) )\n\n            period = self.length / (period_count * 2 * math.pi)\n\n            print(\"new period: %s\" %period)\n\n        for pt in self.surface_set:\n\n            local_phase = pt.y_val / self.lay_h * phase_shift\n\n            scale_val = math.sin(pt.x_val / period + local_phase) * amplitude\n\n            pt.warp_pt(scale_val * self.dir)\n\n    def patternGeneration(self, pattern_set, spacing):\n\n        if self.periodic:\n\n            print(\"pattern periodicizing\")\n            print(\"updating the spacing\")\n            print(\"old spacing: %s\" %spacing)\n\n            scaling_int_val = math.ceil(self.length / spacing)\n            spacing = self.length / scaling_int_val\n\n            print(\"new spacing: %s\" %spacing)\n\n        else:\n\n            spacing = spacing\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set = []\n        layer_count = 0\n        layer_length_vals = []\n\n        for pattern in pattern_set:\n\n            start, step, count = pattern[0], pattern[1], pattern[2]\n\n            if count < 1:\n\n                count = 1\n\n            layer_vertexes = []\n            length_vals = []\n            \n            x_val = start\n\n            x_delta = step * spacing\n\n            while x_val < self.length:\n\n                layer_vertexes.append(Vertex(x_val = x_val))\n                length_vals.append(x_val)\n\n                x_val += x_delta\n\n            for i in range(count):\n\n                layer_set.append(layer_vertexes)\n                layer_length_vals.append(length_vals)\n\n            layer_count += count\n\n        return layer_set, layer_length_vals, layer_count\n\n    def curveSplitAtPoints(self, radius, length_vals):\n\n        pass\n\n    def specialLayerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        _, layer_length_vals, layer_count = self.patternGeneration(pattern_set, spacing)\n\n    def modBasedDotMap(self, x_spacing = 20.0, y_spacing = 20.0, max_val = 10.0, ellipsoid = True, direction = True, layer_shift = 2.0, shift_a = 0.0, shift_b = 0.0, rot_alfa = 0.0):\n\n        if self.periodic:\n\n            x_scale_val = 1.0\n            y_scale_val = 1.0\n\n        else:\n\n            x_scale_val = 1.0\n            y_scale_val = 1.0\n\n        for pt in self.surface_set:\n\n            # distance = pt.distance_function(x_spacing, y_spacing, layer_shift, rot_alfa, x_scale_val, y_scale_val)\n            distance = pt.distance_function(x_spacing, y_spacing, layer_shift, rot_alfa)\n\n            # applying shift values if necessary\n            if not(shift_a == 0.0):\n\n                distance *= shift_a\n\n            if not(shift_b == 0.0):\n\n                distance += shift_b\n\n            # curtaling the distances\n            if distance < 0.0:\n\n                scale_val = 0.0\n\n            elif distance > 1.0:\n\n                scale_val = max_val\n\n            else:\n\n                if ellipsoid:\n\n                    distance = (1 - (1 - distance) ** 2.0) ** .5\n\n                scale_val = max_val * distance\n\n            pt.warp_pt(scale_val * self.dir) \n    \n    def layerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set, _, layer_count = self.patternGeneration(pattern_set, spacing)\n\n        # subdividing in layers\n        for pt_i, pt in enumerate(self.surface_set):\n\n            layer_index = (pt_i - pt_i % self.div_c) / self.div_c\n\n            pattern_layer_index = int(layer_index % layer_count)\n\n            dots = layer_set[pattern_layer_index]\n\n            dis_set = []\n\n            for dot in dots:\n\n                dis_set.append(pt.x_distance(dot))\n\n            distance = min(dis_set)\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            pt.warp_pt(scale_val * self.dir)\n\n\n    def dotGen(self, spacing, y_spacing = None, feature_spacing=0.0):\n\n        random.seed(PatternMap.DOT_MAP_RND_SEED)\n\n        count = 0\n\n        x_spacing = 2.0 ** .5 * spacing\n\n        if self.periodic:\n\n            print(\"dotGen periodicizing\")\n            print(\"updating the x_spacing\")\n            print(\"old x_spacing: %s\" %x_spacing)\n\n            x_spacing_int = math.ceil(self.length / (x_spacing * 2.0))\n            x_spacing = (self.length / x_spacing_int) / 2.0\n\n            print(\"new x_spacing: %s\" %x_spacing)\n\n        if y_spacing == None:\n\n            y_spacing = x_spacing * PatternMap.Y_SPACING_FACTOR\n\n        dots = []\n\n        # setting the start and end conditions of the dot_map\n        if PatternMap.DOT_MAP_SHIFT:\n            # print(\"shifting the pattern in the code as well\")\n            x_shift=PatternMap.DOT_MAP_UV_SHIFT[0] % x_spacing\n            y_shift=PatternMap.DOT_MAP_UV_SHIFT[1] % y_spacing\n            x_start=x_shift if x_shift < .5 * x_spacing else x_shift-x_spacing\n            y_start=y_shift if y_shift < .5 * y_spacing else y_shift-y_spacing\n        else:\n            x_start, y_start = 0.0, 0.0\n\n        x_end, y_end=self.length + .5 * x_spacing, self.height + .5 * y_spacing\n\n        if PatternMap.DOT_MAP_HARD_EASING:\n            while (x_start < feature_spacing):\n                x_start += x_spacing\n            while (x_end > self.length - feature_spacing):\n                x_end -= x_spacing\n\n        x_val=x_start\n        y_val=y_start\n\n        while y_val < y_end:\n\n            if count % 2 == 1:\n\n                x_val = x_spacing * .5 + x_start\n\n            else:\n\n                x_val = x_start\n\n            while x_val < x_end + .1:\n\n                loc_vertex = Vertex(x_val = x_val, y_val = y_val)\n\n                dots.append(loc_vertex)\n\n                x_val += x_spacing\n\n            y_val += y_spacing\n            count += 1\n\n        if self.rnd_cull:\n\n            new_dots = []\n\n            for dot in dots:\n\n                if random.random() < self.rnd_cull_val:\n\n                    new_dots.append(dot)\n\n            dots = new_dots\n\n        if self.rnd_inout:\n\n            self.in_out_multi = [self.random_inout() for i in range(len(dots))]\n\n        if self.rnd_radius:\n\n            self.radii = [self.random_rad() for i in range(len(dots))]\n\n        if self.rnd_n_val:\n\n            self.n_vals = [self.random_n_val() for i in range(len(dots))]\n\n        return dots\n\n    def dotMap(self, spacing, radius, max_val, direction = None):\n\n        dots = self.dotGen(spacing, feature_spacing=radius)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            v_i = distance_set.index(distance)\n\n            if self.rnd_radius:\n\n                radius = self.radii[v_i]\n\n            if self.rnd_n_val:\n\n                max_val = radius * self.n_vals[v_i]\n\n            distance -= radius\n\n            if distance < 0:\n\n                scale_val = abs(distance) / radius * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if self.rnd_inout:\n\n                scale_val *= self.in_out_multi[v_i]\n\n            pt.warp_pt(scale_val * self.dir)\n\n\n    def ellipsoidBumpMap(self, spacing, radius, max_val, direction = None):\n\n        dots = self.dotGen(spacing, feature_spacing=radius)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            v_i = distance_set.index(distance)\n\n            if self.rnd_radius:\n\n                radius = self.radii[v_i]\n\n            if self.rnd_n_val:\n\n                max_val = radius * self.n_vals[v_i]\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if self.rnd_inout:\n\n                scale_val *= self.in_out_multi[v_i]\n\n            pt.warp_pt(scale_val * self.dir)\n\n\n    def getKey(self, item):\n\n        return item[0]\n\n    def cylinderMap(self, spacing, height, radius, max_val, radius_bot = None):\n\n        radius_bot=radius if radius_bot == None else radius_bot\n\n        radius_delta = radius - radius_bot\n        \n        radius_f = 1.0 - radius_delta / radius\n\n        dots = self.dotGen(spacing, feature_spacing=max([radius, radius_bot]))\n\n        for pt in self.surface_set:\n\n            # get closest dot\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append((distance, dot))\n\n            distance = min(distance_set)\n\n            v_i = distance_set.index(distance)\n\n            dot = dots[v_i]\n\n            if self.rnd_radius:\n\n                radius = self.radii[v_i]\n                radius_bot = radius * radius_f\n\n            if self.rnd_n_val:\n\n                max_val = radius * self.n_vals[v_i]\n\n            # y_distance calculation    \n\n            y_distance = pt.y_val - dot.y_val\n\n            # x_distance calculation\n\n            x_distance = abs(pt.x_val - dot.x_val)\n\n            if abs(y_distance) + .01 < height * .5 :\n\n                local_radius = radius_bot + radius_delta * (y_distance / height + .5)\n\n            else:\n\n                local_radius = -1\n\n            if x_distance < local_radius:\n\n                scale_val = (1 - (x_distance / local_radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if self.rnd_inout:\n\n                scale_val *= self.in_out_multi[v_i]\n\n            pt.warp_pt(scale_val * self.dir)\n\n\n    def makeCurves(self):\n\n        self.pts_set = []\n        crv_set = []\n\n        for layer_i, layer_set in enumerate(self.pattern_set):\n\n            pt_set = [vertex.v for vertex in layer_set]\n\n            if self.add_other_set:\n\n                pt_set = pt_set + self.other_set[layer_i][1:-1] + [pt_set[0]]\n\n            if self.periodic:\n\n                # print(\"I am giving you a closed polyline\")\n\n                pt_set = pt_set + [pt_set[0]]\n\n            self.pts_set.append(pt_set)\n\n            crv = rg.Polyline(pt_set)\n\n            crv_set.append(crv)\n\n        self.curved = True\n\n        return crv_set\n\n\n    def makeMesh(self, quad = False):\n\n        if not(self.curved):\n\n            self.makeCurves()\n\n        srf_mesh = rg.Mesh()\n\n        lay_c = len(self.pts_set)\n        pt_c = len(self.pts_set[0][:-1])\n\n        # adding the vertices\n\n        [srf_mesh.Vertices.Add(pt) for pt in self.pts_set[0][:-1]]\n\n        for i in range(1, lay_c, 1):\n\n            y = i - 1\n\n            for pt_i, pt in enumerate(self.pts_set[i][:-1]):\n\n                x = pt_i\n\n                srf_mesh.Vertices.Add(pt)\n\n                v_a = y * pt_c + (x - 1)%pt_c\n                v_b = (y + 1) * pt_c + (x - 1)%pt_c\n                v_c = (y + 1) * pt_c + x\n                v_d = y * pt_c + x\n\n                if quad:\n\n                    srf_mesh.Faces.AddFace(v_a, v_b, v_c, v_d)\n\n                else:\n\n                    srf_mesh.Faces.AddFace(v_a, v_b, v_d)\n                    srf_mesh.Faces.AddFace(v_b, v_c, v_d)\n\n\n        # addding the faces\n\n        return srf_mesh",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}