{
  "source_url": "https://github.com/LiorSkoury-git/ITECH_HopsExample/blob/5db89e7e6d437cbb5433d9643b606064d4ea44ee/app.py",
  "repo": "LiorSkoury-git/ITECH_HopsExample",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "app.py",
  "instruction": null,
  "code": "import ghhops_server as hs\nfrom flask import Flask\nimport rhino3dm as rh\nimport joblib\n\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.spatial.transform import Rotation\nimport json\nimport numpy as np\nimport pandas as pd\nimport math\nimport copy\nimport os\nimport re\n\n\nloaded_model = joblib.load('gradient_boosting_model.joblib')\nfiles = os.listdir(\"PredictionModels\\\\\")\nmodel_dict = {}\nfor file in files:\n    name = re.split(r'\\.',file)[0]\n    model = joblib.load('PredictionModels\\\\{}'.format(file))\n    model_dict[name] = model\n\napp = Flask(__name__)\nhops: hs.HopsFlask = hs.Hops(app)\n\n\n\ndef build_frames(data):\n    frames = []\n    for i in range(len(data[\"X\"])):\n        frame = [data[\"X\"][i],data[\"Y\"][i],data[\"Z\"][i],data[\"A\"][i],data[\"B\"][i],data[\"C\"][i]]\n        frames.append(frame)\n    return frames\n\ndef distance(f1,f2):\n    dist = math.sqrt((f2[0]-f1[0])**2 + (f2[1]-f1[1])**2 +(f2[2]-f1[2])**2)\n    return dist \n\ndef angle_difference(frame1, frame2):\n    # Extract Euler angles from each frame\n    euler_angles1 = [float(x) for x in frame1[3:]]\n    euler_angles2 = [float(x) for x in frame2[3:]]\n\n    # Create rotation matrices from Euler angles\n    rotation_matrix1 = Rotation.from_euler('xyz', euler_angles1, degrees=True).as_matrix()\n    rotation_matrix2 = Rotation.from_euler('xyz', euler_angles2, degrees=True).as_matrix()\n\n    # Calculate the rotation matrix that transforms frame1 to frame2\n    relative_rotation_matrix = rotation_matrix2 @ rotation_matrix1.T\n\n    # Convert the rotation matrix to axis-angle representation\n    axis_angle = Rotation.from_matrix(relative_rotation_matrix).as_rotvec()\n\n    # Calculate the angle difference\n    angle_difference = np.linalg.norm(axis_angle)\n\n    return angle_difference\n\ndef calculateTaskDistance(frames,frames2,currentPos):\n    \n    dist = 0\n    angle = 0\n    #this is glue task \n    if frames != None and frames2 != None and frames!=[] and frames2!=[]:\n        #frames = re.split(';',frames)\n        #frames2 = re.split(';',frames2)\n                \n        dist += distance(frames[0],currentPos)\n        angle += abs(angle_difference(currentPos,frames[0]))\n        \n        if len(frames)==1:\n            #print (\"angle---\",angle)\n            return dist,angle,frames2[-1]\n        \n        for i in range(1,len(frames)):\n            dist += distance(frames[i-1],frames2[i-1])\n            dist += distance(frames2[i-1],frames[i])\n            \n            angle += abs(angle_difference(frames[i-1],frames2[i-1]))\n            angle += abs(angle_difference(frames2[i-1],frames[i]))\n            \n            \n            \n        dist += distance(frames[-1],frames2[-1])\n        angle += abs(angle_difference(frames[-1],frames2[-1]))\n        finalPos=frames2[-1]\n        #print (\"angle---\",angle)\n        return dist,angle,finalPos\n        \n    #this is a regular task\n    elif frames != None and frames!=[]:\n        \n        #frames = re.split(';',frames)\n        \n        dist += distance(frames[0],currentPos)\n        angle += abs(angle_difference(frames[0],currentPos))\n        \n        if len(frames)==1: \n            #print (\"angle---\",angle)\n            return dist,angle,frames[0]\n            \n        for i in range(1,len(frames)):\n            dist += distance(frames[i-1],frames[i])\n            angle += abs(angle_difference(frames[i-1],frames[i]))\n    \n        #print (\"angle---\",angle)\n        return dist,angle,frames[-1]\n    \n    #print (\"angle---\",angle)\n    return dist,angle,currentPos\n\n\n\n\n\n\n\n# Define the Objective functions\n# Objective Functions from https://machinelearningmastery.com/curve-fitting-with-python/\ndef objective(x, a, b):\n    return a * x + b\n\ndef objective2(x, a, b, c):\n    return a * x + b * x**2 + c\n\ndef objective3(x, a, b, c, d, e, f):\n    return (a * x) + (b * x**2) + (c * x**3) + (d * x**4) + (e * x**5) + f\n\ndef fit_to_objective(xdata,ydata,obj_fun = 0):\n\n    if obj_fun==0:\n        parameters, _ = curve_fit(objective, xdata, ydata)\n        a,b = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective(x_line, a, b)\n    elif obj_fun==1:\n        parameters, _ = curve_fit(objective2, xdata, ydata)\n        a,b,c = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective2(x_line, a, b, c)\n    elif obj_fun==2:\n        parameters, _ = curve_fit(objective3, xdata, ydata)\n        a, b, c, d, e, f = parameters\n        x_line = np.arange(min(xdata), max(xdata), 1)\n        y_line = objective3(x_line, a, b, c,d,e,f)\n    else:\n        x_line,y_line = [],[]\n    return x_line,y_line\n\n@app.route(\"/index\")\ndef index():\n    return (\"This is my Flask app\")\n\n@hops.component(\n    \"/sum\",\n    name=\"Sum\",\n    description=\"sum of numbers\",\n    inputs=[\n        hs.HopsNumber(\"A\", \"A\", \"First Number\"),\n        hs.HopsNumber(\"B\", \"B\", \"Second Number\")\n    ],\n    outputs=[\n        hs.HopsNumber(\"Sum\", \"Sum\", \"Sum of the numbers\")\n    ]\n)\ndef sum (a:float, b:float):\n    return a+b\n\n@hops.component(\n    \"/plotFit\",\n    name = \"Plt\",\n    description = \"This component plot the point and save the png files\",\n    inputs = [hs.HopsBoolean(\"Plot\",\"Plot\",\"True to Plot\",access=hs.HopsParamAccess.ITEM),\n              hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST),\n              hs.HopsCurve(\"Curve\",\"Curve\",\"Fit curve to plot\",access=hs.HopsParamAccess.ITEM),\n              hs.HopsString(\"File Name\",\"File Name\",\"File Name\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if plotted False if error\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef plotFit(save,pts,crv,file_name):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n\n    crv.Domain = rh.Interval(0.00,1.00)\n    cX = []\n    cY = []\n    for i in range(len(pts)):\n        pt = crv.PointAt(i/len(pts))\n        cX.append(pt.X)\n        cY.append(pt.Y)\n    if save:\n        fig,ax = plt.subplots()\n        ax.plot(X, Y, 'o', label='data')\n        ax.plot(cX, cY, '-', label='fit')\n        ax.legend()\n        name = \"{}.png\".format(file_name)\n        fig.savefig(name)\n        return True\n    \n    return False\n\n@hops.component(\n    \"/fitCurve\",\n    name = \"fit\",\n    description = \"This component fit a curve to a set of points\",\n    inputs = [hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST),\n              hs.HopsNumber(\"Objective\",\"Obj\",\"Objective Type\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if fitted curve\",access=hs.HopsParamAccess.ITEM),\n            hs.HopsCurve(\"fitCurve\",\"CRV\",\"Fitted curve\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef fitCurve(pts,obj):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n    Z = [pt.Z for pt in pts]\n\n    xdata = np.asarray(X)\n    ydata = np.asarray(Y)\n\n    x_line,y_line = fit_to_objective(xdata,ydata,obj_fun=obj)\n\n    newPoints = []\n    if len(x_line)>0:\n        for i in range(len(x_line)):\n            pt = rh.Point3d(x_line[i],y_line[i],0)\n            newPoints.append(pt)\n        crv = rh.Curve.CreateControlPointCurve(newPoints,1)\n        print (\"I'm here now\")\n        return True,crv\n    print (\"lol\")\n    crv = rh.Curve.CreateControlPointCurve(pts,1)\n    print (crv)\n    return False,crv\n\n@hops.component(\n    \"/savePoints\",\n    name = \"savePoints\",\n    description = \"This component save a list of points as json file\",\n    inputs = [hs.HopsPoint(\"Points\",\"Points\",\"Points to plot\",access=hs.HopsParamAccess.LIST)\n    ],\n    outputs=[hs.HopsBoolean(\"Success\",\"Success\",\"True if plotted False if error\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef savePoints(pts):\n    X = [pt.X for pt in pts]\n    Y = [pt.Y for pt in pts]\n    Z = [pt.Z for pt in pts]\n    \n    points_dict = {'X':X,'Y':Y,'Z':Z}\n    \n    file_path = 'points.json'\n\n\n    with open(file_path, 'w') as json_file:\n        json.dump(points_dict, json_file, indent=4)\n\n    print(f\"JSON file saved at: {file_path}\")\n        \n    return True\n\n@hops.component(\n    \"/predictPoint\",\n    name = \"predictPoint\",\n    description = \"This component predict a z value of a point on a surface\",\n    inputs = [hs.HopsPoint(\"Point\",\"Point\",\"Points to test\",access=hs.HopsParamAccess.ITEM)\n    ],\n    outputs=[hs.HopsPoint(\"Point\",\"Point\",\"Point with predicted Z value\",access=hs.HopsParamAccess.ITEM)\n    ]\n)\ndef predictPoint(pt):\n    X = pt.X \n    Y = pt.Y\n    new_data = np.array([[X,Y]])\n    prediction = loaded_model.predict(new_data)\n    new_pt = rh.Point3d(X,Y,prediction)\n    return new_pt\n\n\n@hops.component(\n    \"/tester\",\n    name = \"Tester\",\n    description = \"None\",\n    inputs = [hs.HopsString(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST),\n              hs.HopsString(\"model_name\",\"model\",\"model\",access=hs.HopsParamAccess.ITEM)],\n    outputs = [hs.HopsNumber(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST)]\n)\ndef tester(data,model_name):\n\n    new_data = []\n    \n    HOME = [2316.51,0.08,2961.99,-89.81,-44.85,-90.26]\n    current_pos = copy.deepcopy(HOME)\n    for d in data:\n        data_dict = json.loads(d)\n        \n        name = data_dict[\"type\"]\n        if \"clos\" in name.lower() : name=\"Closing\"\n        if \"init\" in name.lower():name = \"Initiate Tool\"\n        if \"place\" in name.lower(): name = \"Place\"\n        \n        new_dict = {\"names\":name}\n        actor_data = data_dict[\"actors_data\"][data_dict[\"main_actor\"]]\n        \n        new_dict[\"tools\"] = actor_data[\"toolname\"]\n        new_dict[\"operationCount\"] = actor_data[\"actioncount\"]\n        \n        \n        if actor_data[\"movementbasetype\"] == \"axis\":\n            frames = build_frames(actor_data[\"secondaryactionvalues\"])\n            dist,angle,current_pos = calculateTaskDistance(frames,None,current_pos)\n        else:\n            if actor_data[\"actionid\"]==1:\n                dist,angle,current_pos = calculateTaskDistance([HOME],None,current_pos)\n            elif actor_data[\"mainactionvalues\"]==None:\n                dist,angle,current_pos = 0,0,current_pos  \n            elif actor_data[\"secondaryactionvalues\"] != None:\n                frames,frames2 = build_frames(actor_data[\"mainactionvalues\"]),build_frames(actor_data[\"secondaryactionvalues\"])\n                dist,angle,current_pos = calculateTaskDistance(frames,frames2,current_pos)\n            else:\n                frames = build_frames(actor_data[\"mainactionvalues\"])\n                dist,angle,current_pos = calculateTaskDistance(frames,None,current_pos)\n        \n        dist = dist/10000\n        new_dict[\"subOperationDistance\"] = dist/actor_data[\"actioncount\"]\n        new_dict[\"totalDistance\"] = dist\n        new_dict[\"movementAngle\"] = angle\n        \n        new_data.append(new_dict)\n    \n        \n    data_dict = {key: []  for key, value in new_data[0].items()}\n    \n    for d in new_data:\n        dict = d\n        for key,value in dict.items():\n            data_dict[key].append(value)\n    \n    tool_map = {'Nail Gripper':1, 'Vaccuum Gripper':2, 'GlueGun':3}\n    task_map = {'Closing':1,'Gluing':2,'Initiate Tool':3,'Move':4,'Nail':5,'Pick':6,'Place':7,\n                'Spilling':8,'Storing':9,'Take Tool':10,'Travel':11}\n    \n    df = pd.DataFrame(data_dict)\n    df = df.map(lambda s: tool_map.get(s) if s in tool_map else s)\n    df = df.map(lambda s: task_map.get(s) if s in task_map else s)\n    \n    predictions = model_dict[model_name].predict(df)\n    results = [float(p) for p in predictions]\n    #print (results)\n    return (results)\n    \n    \n    return new_data\n\n@hops.component(\n    \"/predict_tester\",\n    name = \"PredictTester\",\n    description = \"None\",\n    inputs = [hs.HopsString(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST),\n              hs.HopsString(\"model_name\",\"model\",\"model\",access=hs.HopsParamAccess.ITEM)],\n    outputs = [hs.HopsNumber(\"data\",\"data\",\"data\",access=hs.HopsParamAccess.LIST)]\n)\ndef predict_tester(data,model_name):\n\n    tool_map = {'Nail Gripper':1, 'Vaccuum Gripper':2, 'GlueGun':3}\n    task_map = {'Closing':1,'Gluing':2,'Initiate Tool':3,'Move':4,'Nail':5,'Pick':6,'Place':7,\n                'Spilling':8,'Storing':9,'Take Tool':10,'Travel':11}\n    \n    dict = json.loads(data[0])\n    data_dict = {key: []  for key, value in dict.items()}\n    \n    for d in data:\n        dict = json.loads(d)\n        for key,value in dict.items():\n            data_dict[key].append(value)\n    \n    df = pd.DataFrame(data_dict)\n    df = df.map(lambda s: tool_map.get(s) if s in tool_map else s)\n    df = df.map(lambda s: task_map.get(s) if s in task_map else s)\n    \n    predictions = model_dict[model_name].predict(df)\n    results = [float(p) for p in predictions]\n    #print (results)\n    return (results)\n    \n    \n        \n\n\nif __name__ == \"__main__\":\n\n    app.run(debug=True)\n\n\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}