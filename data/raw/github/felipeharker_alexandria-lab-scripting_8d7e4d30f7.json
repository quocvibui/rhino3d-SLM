{
  "source_url": "https://github.com/felipeharker/alexandria-lab-scripting/blob/1771434a741c840da1d8ab008876e4866d6fecf3/alexandria-scripts/ghpython/boundary_panel_grid.py",
  "repo": "felipeharker/alexandria-lab-scripting",
  "repo_stars": 0,
  "repo_description": "python, c#, etc. script library for Alexandria Labs",
  "license": "unknown",
  "filepath": "alexandria-scripts/ghpython/boundary_panel_grid.py",
  "instruction": "GhPython: Centered rectangular panelization inside a boundary-aligned bounding box.",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - Boundary (GH: Bnd) | Rhino.Geometry.Curve | Boundary rectangle curve to panelize\n# - SheetWidth (GH: SheetX) | float | Target panel width in X direction\n# - SheetHeight (GH: SheetY) | float | Target panel height in Y direction\n# Outputs:\n# - Panels (GH: Panels) | list[Rhino.Geometry.Curve] | Generated panel outline curves\n\n\"\"\"GhPython: Centered rectangular panelization inside a boundary-aligned bounding box.\n\nThe script fills a rectangular boundary extents with panel rectangles using requested\nsheet sizes. Any leftover length is split into two equal end caps so full-size panels\nremain centered in each axis.\n\"\"\"\n\nimport Rhino\nimport scriptcontext as sc\nfrom Rhino.Geometry import Plane, Rectangle3d, Interval\n\n__author__ = \"Alexandria Labs\"\n__version__ = \"1.0.0\"\n__last_reviewed__ = \"2026-02-19\"\n\n# -----------------------------\n# Constants\n# -----------------------------\nFALLBACK_TOLERANCE = 1e-3\n\n\n# -----------------------------\n# Helper functions\n# -----------------------------\ndef get_document_tolerance():\n    \"\"\"Return active model tolerance with a safe fallback.\"\"\"\n    if sc.doc:\n        return sc.doc.ModelAbsoluteTolerance\n    if Rhino.RhinoDoc.ActiveDoc:\n        return Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    return FALLBACK_TOLERANCE\n\n\ndef centered_segment_sizes(total_length, target_size, tolerance):\n    \"\"\"Build centered segment widths along one axis.\n\n    Behavior:\n    - Use as many full target segments as fit.\n    - Split any remainder into two equal end-cap segments.\n    - If remainder is within tolerance, treat as exact fit.\n    \"\"\"\n    if total_length <= tolerance:\n        return []\n\n    if target_size <= tolerance:\n        return [total_length]\n\n    full_count = int(total_length // target_size)\n    remainder = total_length - (full_count * target_size)\n\n    if abs(remainder) <= tolerance:\n        if full_count <= 0:\n            return [total_length]\n        return [target_size] * full_count\n\n    cap_size = 0.5 * remainder\n    if cap_size <= tolerance:\n        if full_count <= 0:\n            return [total_length]\n        return [target_size] * full_count\n\n    return [cap_size] + ([target_size] * full_count) + [cap_size]\n\n\n# -----------------------------\n# Main execution\n# -----------------------------\nPanels = []\n\nif Bnd is not None:\n    tolerance = get_document_tolerance()\n\n    # Build rectangles in the boundary plane when available.\n    has_plane, boundary_plane = Bnd.TryGetPlane(tolerance)\n    if not has_plane:\n        boundary_plane = Plane.WorldXY\n\n    bounding_box = Bnd.GetBoundingBox(boundary_plane)\n    length_x = bounding_box.Max.X - bounding_box.Min.X\n    length_y = bounding_box.Max.Y - bounding_box.Min.Y\n\n    sheet_x = 0.0 if SheetX is None else float(SheetX)\n    sheet_y = 0.0 if SheetY is None else float(SheetY)\n\n    x_sizes = centered_segment_sizes(length_x, sheet_x, tolerance)\n    y_sizes = centered_segment_sizes(length_y, sheet_y, tolerance)\n\n    x_start = bounding_box.Min.X\n    for x_size in x_sizes:\n        y_start = bounding_box.Min.Y\n        for y_size in y_sizes:\n            panel_rect = Rectangle3d(\n                boundary_plane,\n                Interval(x_start, x_start + x_size),\n                Interval(y_start, y_start + y_size)\n            )\n            Panels.append(panel_rect.ToNurbsCurve())\n            y_start += y_size\n        x_start += x_size\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}