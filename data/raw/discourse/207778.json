{
  "source_url": "https://discourse.mcneel.com/t/c-compiler-cant-find-flowmorph-morph-in-rhino-8-project/207778",
  "topic_id": 207778,
  "title": "C# Compiler Can't Find FlowMorph / .Morph() in Rhino 8 Project",
  "question": "Hello McNeel Forum community,\n\n\nI need some help with developing a plugin for Rhino 8 using C#. Specifically, I’m trying to write a command that will smoothly morph a geometric pattern between two boundary curves. I’m aiming for a result similar to professional shoe design plugins (like Orang or xShoe).\n\n\nHowever, I am constantly getting compilation errors when trying to use modern RhinoCommon commands in my project. Even though I am using Rhino 8, the compiler says it cannot find fundamental classes like \nFlowMorph\n, \nSplineMorph\n, and methods like \nMesh.Morph()\n (errors CS0246, CS1061).\n\n\nHere are the steps we have already tried to solve this issue:\n\n\n\n\nWe created a brand new project from scratch in Visual Studio using the official Rhino 8 plugin template.\n\n\nWe completely removed the RhinoCommon NuGet package from the project and added a manual, direct file reference to \nRhinoCommon.dll\n from the \n\"C:\\Program Files\\Rhino 8\\System\"\n folder.\n\n\nTo bypass this setup problem, we also tried writing numerous manual deformation algorithms (Bounding Box, Centroid-Ray, Barycentric Coordinates) that use only the basic functions found even in older Rhino versions. However, these manual methods did not provide the desired smoothness.\n\n\n\n\nAfter all these steps, what could be the reason the compiler still cannot find the Rhino 8 commands? Could there be an installation detail or project setting that I am missing? Does this point to a deeper issue with Visual Studio or .NET?\n\n\nI can provide my project file (.zip) and the Rhino file (.3dm) I am testing with. The final code block that should work but fails to compile in my environment is attached below.\n\n\nThank you in advance for your help and guidance.\n\n\n\n\n**3. Code Block\n\n\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Geometry.Morphs;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MorphPlusV2\n{\n    public cla...",
  "code_blocks": [
    {
      "code": "REM remove rhino files\n   del /S $(TargetDir)RhinoCommon.dll\n   del /S $(TargetDir)Rhino.UI.dll\n   del /S $(TargetDir)Eto.dll",
      "language": "unknown",
      "author": "david.birch.uk",
      "post_number": 2,
      "is_solution": false
    },
    {
      "code": "using Rhino;\nusing Rhino.Commands;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Geometry.Morphs;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MorphPlusV2\n{\n    public class MorphPlusV2Command : Command\n    {\n        public override string EnglishName => \"MorphPlus\";\n\n        protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n        {\n            #region User Input\n\n            ObjRef[] objectRefs;\n            Result get_obj_rc = RhinoGet.GetMultipleObjects(\"Select objects to morph\", false, ObjectType.Brep | ObjectType.Mesh | ObjectType.Surface | ObjectType.Curve, out objectRefs);\n            if (get_obj_rc != Result.Success) return get_obj_rc;\n            var morphObjects = objectRefs.Select(r => r.Object()).ToList();\n\n            ObjRef oldCurveRef;\n            Result get_old_rc = RhinoGet.GetOneObject(\"Select OLD boundary CURVE\", false, ObjectType.Curve, out oldCurveRef);\n            if (get_old_rc != Result.Success) return get_old_rc;\n            Curve oldBoundaryCurve = oldCurveRef.Curve();\n            if (oldBoundaryCurve == null || !oldBoundaryCurve.IsClosed || !oldBoundaryCurve.IsPlanar()) { RhinoApp.WriteLine(\"Old boundary curve must be closed and planar.\"); return Result.Failure; }\n\n            ObjRef newCurveRef;\n            Result get_new_rc = RhinoGet.GetOneObject(\"Select NEW boundary CURVE\", false, ObjectType.Curve, out newCurveRef);\n            if (get_new_rc != Result.Success) return get_new_rc;\n            Curve newBoundaryCurve = newCurveRef.Curve();\n            if (newBoundaryCurve == null || !newBoundaryCurve.IsClosed || !newBoundaryCurve.IsPlanar()) { RhinoApp.WriteLine(\"New boundary curve must be closed and planar.\"); return Result.Failure; }\n\n            #endregion\n\n            bool deleteOriginal = true;\n\n            NurbsCurve baseCurve = oldBoundaryCurve.ToNurbsCurve();\n            NurbsCurve targetCurve = newBoundaryCurve.ToNurbsCurve();\n\n            int rebuild_point_count = 100;\n            baseCurve.Rebuild(rebuild_point_count, baseCurve.Degree, true);\n            targetCurve.Rebuild(rebuild_point_count, targetCurve.Degree, true);\n\n            var morph = new FlowSpaceMorph(baseCurve, targetCurve, true, true, false);\n\n            doc.Objects.UnselectAll();\n            var newGeometries = new List<GeometryBase>();\n            var newObjectAttributes = new List<ObjectAttributes>();\n\n            foreach (var rhinoObject in morphObjects)\n            {\n                GeometryBase geom = rhinoObject.Geometry.Duplicate();\n\n                if (geom is Curve curve)\n                {\n                    var nurbsCurve = curve.ToNurbsCurve();\n                    if (nurbsCurve != null)\n                    {\n                        for (int i = 0; i < nurbsCurve.Points.Count; i++) { nurbsCurve.Points.SetPoint(i, morph.MorphPoint(nurbsCurve.Points[i].Location)); }\n                        geom = nurbsCurve;\n                    }\n                }\n                else if (geom is Mesh mesh)\n                {\n                    for (int i = 0; i < mesh.Vertices.Count; i++) { mesh.Vertices[i] = (Point3f)morph.MorphPoint(mesh.Vertices[i]); }\n                }\n                else if (geom is Brep brep)\n                {\n                    var fullMesh = new Mesh();\n                    var brepMeshes = Mesh.CreateFromBrep(brep, MeshingParameters.Default);\n                    if (brepMeshes != null)\n                    {\n                        fullMesh.Append(brepMeshes);\n                        for (int i = 0; i < fullMesh.Vertices.Count; i++) { fullMesh.Vertices[i] = (Point3f)morph.MorphPoint(fullMesh.Vertices[i]); }\n                        geom = fullMesh;\n                    }\n                }\n\n                newGeometries.Add(geom);\n                newObjectAttributes.Add(rhinoObject.Attributes.Duplicate());\n            }\n\n            for (int i = 0; i < newGeometries.Count; i++) doc.Objects.Add(newGeometries[i], newObjectAttributes[i]);\n            if (deleteOriginal) foreach (var rhinoObject in morphObjects) doc.Objects.Delete(rhinoObject.Id, true);\n            doc.Views.Redraw();\n            return Result.Success;\n        }\n    }\n}",
      "language": "csharp",
      "author": "eyuperdm",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "geometry",
    "mesh",
    "nurbs",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 2,
  "views": 85
}