{
  "source_url": "https://github.com/Hand-and-Machine/extruder-turtle-Rhino/blob/68b9f4a35b6e2ff867de22a4eb8817569858def9/extruder_turtle/turtle_utilities2.py",
  "repo": "Hand-and-Machine/extruder-turtle-Rhino",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "extruder_turtle/turtle_utilities2.py",
  "instruction": "Turtle utilities2",
  "code": "import copy\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport ExtruderTurtle as e\nimport operator as op\nimport math\nimport random\nimport extruder_turtle\nfrom extruder_turtle import *\n\ndef circle(t, diameter, steps=100, start=0, overlap=1):\n\tr = diameter/2.0\n\tcircumference = math.pi*diameter\n\tdcirc = circumference/steps\n\tif (dcirc<1.0):\n\t\tsteps = int(circumference) # sets step size to 1mm\n\tdtheta = 360.0/steps\n\tfor i in range (start, steps+start+2+overlap):\n\t\tx = r*math.cos(math.radians(i*dtheta))\n\t\ty = r*math.sin(math.radians(i*dtheta))\n\t\tif (i==start):\t\n\t\t\tt.penup()\n\t\t\tt.set_position(x,y)\n\t\t\tt.pendown()\n\t\t\t# print(\"in circle x: \" +str(x))\n\t\t\t# print(\"in circle y: \" +str(y))\n\t\tt.set_position(x,y)\n\n\ndef circular_surface_in_out (t,diameter):\n\tw = t.get_extrude_width()\n\tnumber_circles = int(diameter/(w*2.0))\n\tdelta_d = diameter/number_circles\n\td = w*2.0\n\twhile (d<diameter):\n\t\tcircle(t,d)\n\t\td = d+delta_d\n\tif (d<=diameter):\n\t\tcircle(t,diameter)\n\ndef circular_surface_out_in(t,diameter):\n\tw = t.get_extrude_width()\n\td = diameter\n\twhile (d>=w):\n\t\tcircle(t,d)\n\t\td = d-w*2.0\n\ndef circular_surface_in_out_dual(t,diameter):\n\tw = t.get_extrude_width()\n\tnumber_circles = int(diameter/(w*2.0))\n\tdelta_d = diameter/number_circles\n\td = w*2.0\n\twhile (d<diameter):\n\t\tcircle(t,d)\n\t\td = d+delta_d\n\tif (d<=diameter):\n\t\tcircle(t,diameter)\n\n\t# glass\n\td = diameter-w\n\ti=0\n\tt.swap_extruder()\n\tt.extrude(2)\n\twhile (d>=w):\n\t\td = d-w*2.0\n\t\tif (i%1==0 and d>w):\n\t\t\tcircle(t,d, overlap=3)\n\t\t\tt.extrude(2)\n\t\t\td = d-w*2.0\n\t\ti+=1\n\tt.swap_extruder()\n\ndef circular_surface_out_in_dual(t,diameter):\n\tw = t.get_extrude_width()\n\td = diameter\n\t# primary materail\n\twhile (d>=w):\n\t\tcircle(t,d)\n\t\td = d-w*2.0\n\n\tt.lift(t.get_layer_height()/2.0)\n\n\t# secondary material\n\td = diameter-w\n\ti=0\n\tt.swap_extruder()\n\tt.extrude(2)\n\twhile (d>=w):\n\t\td = d-w*2.0\n\t\tif (i%1==0 and d>w):\n\t\t\tcircle(t,d, overlap=3)\n\t\t\tt.extrude(2)\n\t\t\td = d-w*2.0\n\t\ti+=1\n\tt.swap_extruder()\n\ndef zig_zag_circle(t,diameter,amplitude,period,offset=0):\n\tr = diameter/2.0\n\tsteps = int(360.0/(2*period))\n\tdtheta = 360.0/steps\n\tif (offset>0):\n\t\tamplitude*=-1\n\tfor i in range (0,steps+1):\n\t\tif (i%2==0):\n\t\t\tx = (r+amplitude)*math.cos(math.radians(i*dtheta))\n\t\t\ty = (r+amplitude)*math.sin(math.radians(i*dtheta))\n\n\t\telse:\n\t\t\tx = (r-amplitude)*math.cos(math.radians(i*dtheta))\n\t\t\ty = (r-amplitude)*math.sin(math.radians(i*dtheta))\n\t\tif (i==0):\t\n\t\t\tt.penup()\n\t\t\tt.set_position(x,y)\n\t\t\tt.pendown()\n\t\tt.set_position(x,y)\n\ndef pattern_cylinder(t, b_diameter, height, t_diameter=False, array=False, pattern_amplitude = False, bottom_layers=3, top_layers=3):\n\tbase_amplitude = 0.0\n\tt.set_extrude_rate(2.5)\n\tbase_extrude = t.get_extrude_rate()\n\t\n\tif (pattern_amplitude == False):\n\t\tpattern_amplitude = base_amplitude+4.0\n\tif (t_diameter == False):\n\t\tt_diameter = b_diameter\n\tlayers = int(height/t.get_layer_height())\n\tdiameter_inc = float(t_diameter - b_diameter)/layers\n\textra_bottom_layers = 0 #number of extra layers at the bottom with no pattern\n\tdiameter = b_diameter\n\tdiameter_inc = float(t_diameter - b_diameter)/layers\n\tcircumference = diameter*math.pi\n\n\tif (array):\n\t\tpattern_width = len(array)-1\n\t\tpattern_height = len(array[0])\n\t\tsteps = pattern_width\n\t\tnOscillations = pattern_width\n\t\tdistance_per_oscillation = circumference/nOscillations\n\n\telse:\n\t  print(\"ERROR: you need to give this function an array\")\n\t  return;\n\n\tsteps = pattern_width\n\tdtheta = 360.0/steps\n\n\t#pattern access variables\n\txp = 0\n\typ = 0\n\n\t################################################\n\t# LAYER LOOP\n\t################################################\n\tfor l in range (layers):\n\t\tr = diameter/2.0\n\n\t\t# create bottom layers if relevant\n\t\tif (l < bottom_layers):\n\t\t\tif (l%2==0):\n\t\t\t\tcircular_surface_in_out(t,diameter)\n\t\t\telse:\n\t\t\t\tcircular_surface_out_in(t,diameter)\n\t\t\tt.set_extrude_rate(base_extrude)\n\n\t\t# reset x pattern variable for each layer\n\t\txp = 0\n\t\tif (l%2==0):\n\t\t\tbase_amplitude*=-1\n\n\t\t################################################\n\t\t# MAIN LOOP: STRUCTURE\n\t\t# change to nozzle 0 and build structure\n\t\t################################################\n\t\tif (l>=bottom_layers):\n\t\t\tcircle(t,diameter)\n\t\t\t# circle(t,diameter-2*t.get_extrude_width())\n\t\tt.lift(t.get_layer_height())\n\n\t\t# ###############################################\n\t\t# MAIN LOOP: PATTERN\n\t\t# change to nozzle 1 and apply pattern\n\t\t# ###############################################\n\t\tr_pattern = r-1.0\n\t\tif (l>bottom_layers and l%2==0 and l<= layers-top_layers): # only do the pattern for pattern rows\n\t\t\tt.set_extruder(1)\n\t\t\tt.set_extrude_rate(1.5)\n\t\t\tfirst_flag = True\n\t\t\tfor s in range(0,steps+1):\n\t\t\t\tif (array[s][yp]==1):\n\t\t\t\t\t#inner radius: move nozzle to correct inner position\n\t\t\t\t\tx = r_pattern*math.cos(math.radians(s*dtheta))\n\t\t\t\t\ty = r_pattern*math.sin(math.radians(s*dtheta))\n\t\t\t\t\tt.set_position(x,y)\n\t\t\t\t\tif (first_flag):\n\t\t\t\t\t\tt.extrude(20)\n\t\t\t\t\t\tfirst_flag = False\n\t\t\t\t\t#pattern radius: bump out\n\t\t\t\t\tx = (r+pattern_amplitude)*math.cos(math.radians(s*dtheta))\n\t\t\t\t\ty = (r+pattern_amplitude)*math.sin(math.radians(s*dtheta))\n\t\t\t\t\tt.set_position(x,y)\n\t\t\t\t\t#inner radius: move nozzle back to inner position\n\t\t\t\t\tx = r_pattern*math.cos(math.radians(s*dtheta))\n\t\t\t\t\ty = r_pattern*math.sin(math.radians(s*dtheta))\n\t\t\t\t\tt.set_position(x,y)\n\t\t\t\telse:\n\t\t\t\t\t# don't extrude material where there is no pattern\n\t\t\t\t\tt.penup()\n\t\t\t\t\tx = r_pattern*math.cos(math.radians(s*dtheta))\n\t\t\t\t\ty = r_pattern*math.sin(math.radians(s*dtheta))\n\t\t\t\t\tt.set_position(x,y)\n\t\t\t\t\tt.pendown()\n\t\t\tt.lift(t.get_layer_height()/10.0) # lift up a little to accommodate dense pattern\n\t\tif (l%2==0 and l>=bottom_layers):\n\t\t\typ+=1\n\n\t\tt.set_extruder(0)\n\t\tt.set_extrude_rate(base_extrude)\n\t\tdiameter = diameter + diameter_inc\n\ndef follow_curve(t, curve, double_wall = False, inner_wall=False, steps=100):\n\tpoints = rs.DivideCurve (curve, steps)\n\tdtheta = 360.0/steps\n\n\ti=0\n\tif (inner_wall==False):\n\t\tfor point in points:\n\t\t\tif (i==0):\n\t\t\t\tt.set_position(point.X,point.Y)\n\t\t\t\tt.pendown()\n\t\t\telse:\n\t\t\t\tt.pendown()\n\t\t\tt.set_position(point.X,point.Y)\n\t\t\ti+=1\n\n\tt.set_position(points[0].X,points[0].Y) # close curve\n\tt.set_position(points[1].X,points[1].Y) # close curve\n\n\tif (double_wall or inner_wall):\n\t\tinner_curve = rs.OffsetCurve(curve, [0,0,0], t.get_extrude_width())\n\t\tinner_points = rs.DivideCurve (inner_curve, steps)\n\t\ti=0\n\t\tfor point in inner_points:\n\t\t\tif (i==0):\t\n\t\t\t\tt.set_position(point.X,point.Y)\n\t\t\t\tt.pendown()\n\t\t\tt.set_position(point.X,point.Y)\n\t\t\ti+=1\n\n\t\tt.set_position(inner_points[0].X,inner_points[0].Y) # close curve\n\t\tt.set_position(inner_points[1].X,inner_points[1].Y) # close curve\n\n\n\ndef pattern_along_curve(t, curve, array=False, pattern_amplitude = False, pattern_layer=True, windows=False, support=False):\n\tbase_amplitude = 0.0\n\tt.set_extrude_rate(2.5)\n\tbase_extrude = t.get_extrude_rate()\n\tsteps=100 # gets reset later\n\t\n\tif (pattern_amplitude == False):\n\t\tpattern_amplitude = base_amplitude+6.0\n\n\tif (array):\n\t\tpattern_width = len(array)\n\t\tsteps = pattern_width\n\t\tnOscillations = pattern_width\n\telse:\n\t  print(\"ERROR: you need to give this function an array\")\n\t  return;\n\n\tif (not(curve)):\n\t\tprint(\"ERROR: You need to provide this function a curve\")\n\t\treturn\n\telse:\n\t\tpoints = rs.DivideCurve (curve, steps)\n\n\tdtheta = 360.0/steps\n\n\t#pattern access variables\n\txp = 0\n\n\n\t################################################\n\t# MAIN LOOP: STRUCTURE\n\t# change to nozzle 0 and build structure\n\t################################################\n\ti=0\n\tfor point in points:\n\t\tif (i==0):\n\t\t\tt.penup()\t\n\t\t\tt.set_position(point.X,point.Y)\n\t\tif (array[i]==1 and windows==True and support==False):\n\t\t\tt.penup()\n\t\telse:\n\t\t\tt.pendown()\n\t\tt.set_position(point.X,point.Y)\n\t\ti+=1\n\n\tt.set_position(points[0].X,points[0].Y) # close curve\n\n\tinner_curve = rs.OffsetCurve(curve, [0,0,0], t.get_extrude_width())\n\tinner_points = rs.DivideCurve (inner_curve, steps)\n\ti=0\n\tfor point in inner_points:\n\t\tif (array[i]==1 and windows==True and support==False):\n\t\t\tt.penup()\n\t\telse:\n\t\t\tt.pendown()\n\t\tt.set_position(point.X,point.Y)\n\t\ti+=1\n\n\tt.set_position(inner_points[0].X,inner_points[0].Y) # close curve\n\n\t# ###############################################\n\t# MAIN LOOP: PATTERN\n\t# change to nozzle 1 and apply pattern\n\t# ###############################################\n\tt.lift(t.get_layer_height()/2)\n\tt.penup()\n\tif (pattern_layer):\n\t\tt.set_extruder(1)\n\t\tt.set_extrude_rate(1.5)\n\t\tfirst_flag = True\n\t\ti=0\n\t\tfor point in inner_points:\n\t\t\tif (array[i]==1 or (i<len(inner_points)-1 and array[i+1]==1) or (i>0 and array[i-1]==1)):\n\t\t\t\tt.set_position(point.X,point.Y)\n\t\t\t\tt.pendown()\n\t\t\t\tif (first_flag):\n\t\t\t\t\tt.extrude(15)\n\t\t\t\t\tfirst_flag=False\n\t\t\t\tt.left(90)\n\t\t\t\tt.forward(pattern_amplitude)\n\t\t\t\tt.back(pattern_amplitude)\n\t\t\t\tt.right(90)\n\t\t\telse:\n\t\t\t\t# don't extrude material where there is no pattern\n\t\t\t\tt.penup()\n\t\t\t\t# t.set_position(point.X,point.Y)\n\t\t\ti+=1\n\tt.penup()\n\tt.lift(t.get_layer_height()/2)\n\n\tt.set_extruder(0)\n\tt.set_extrude_rate(base_extrude)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}