{
  "source_url": "https://discourse.mcneel.com/t/silhouette-computedraftcurve-results-not-completely-on-brepface/173071",
  "topic_id": 173071,
  "title": "Silhouette.ComputeDraftCurve results not completely on BrepFace",
  "question": "Sometimes \nSilhouette.ComputeDraftCurve\n creates curves that deviate from a BrepFace more than the \ntolerance\n argument.  For example, the 45Â° draft curve created on the face in\n\n\nSilhouette_ComputeDraftCurve_dist_error.3dm\n (38.0 KB)\n\nwith tolerance=0.001, can be pulled to the same face about 0.055.\n\n\nThis occurs in both V7 and V8.2, and also via _DraftAngleAnalysis.\n\n\n\n\n\nHere is a Python script I've been using to study this.\n\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport Rhino\nimport Rhino.DocObjects as rd\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\n\ndraftAngle = Rhino.RhinoMath.ToRadians(45.0)\ntolerance = sc.doc.ModelAbsoluteTolerance\n\n\ndef doesCurveSelfIntersect(rgC, tolerance=None):\n    if tolerance is None: tolerance = sc.doc.ModelAbsoluteTolerance\n    rc = rg.Intersect.Intersection.CurveSelf(rgC, tolerance)\n    return bool(rc)\n\n\ndef create_hi_def_pull_to_face(face, rgC_on_face, tolerance=1e-6):\n\n    pulled = rgC_on_face.PullToBrepFace(face=face, tolerance=tolerance)\n    if len(pulled) == 1:\n        return pulled[0]\n\n    pullback = face.Pullback(rgC_on_face, tolerance=tolerance)\n    pushup = face.Pushup(pullback, tolerance=tolerance)\n    return pushup\n\n\ndef main():\n    \n    res, objrefs = Rhino.Input.RhinoGet.GetMultipleObjects(\n        prompt=\"Select breps\",\n        acceptNothing=False,\n        filter=rd.ObjectType.Brep)\n    \n    if res != Rhino.Commands.Result.Success: return\n    \n    attr_Red = rd.ObjectAttributes()\n    attr_Red.LayerIndex = sc.doc.Layers.CurrentLayerIndex\n    attr_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\n    attr_Red.ObjectColor = attr_Red.ObjectColor.Red\n    \n    attr_Green = attr_Red.Duplicate()\n    attr_Green.ObjectColor = attr_Green.ObjectColor.Lime\n    \n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\n    \n    print(\"Tolerance: {}\".format(tolerance))\n    \n    for objref in objrefs:\n        face_In = objref.Face()\n        if face_In is None:\n            brep = ob...",
  "code_blocks": [
    {
      "code": "from __future__ import absolute_import, division, print_function, unicode_literals\n\nimport Rhino\nimport Rhino.DocObjects as rd\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\n\n\ndraftAngle = Rhino.RhinoMath.ToRadians(45.0)\ntolerance = sc.doc.ModelAbsoluteTolerance\n\n\ndef doesCurveSelfIntersect(rgC, tolerance=None):\n    if tolerance is None: tolerance = sc.doc.ModelAbsoluteTolerance\n    rc = rg.Intersect.Intersection.CurveSelf(rgC, tolerance)\n    return bool(rc)\n\n\ndef create_hi_def_pull_to_face(face, rgC_on_face, tolerance=1e-6):\n\n    pulled = rgC_on_face.PullToBrepFace(face=face, tolerance=tolerance)\n    if len(pulled) == 1:\n        return pulled[0]\n\n    pullback = face.Pullback(rgC_on_face, tolerance=tolerance)\n    pushup = face.Pushup(pullback, tolerance=tolerance)\n    return pushup\n\n\ndef main():\n    \n    res, objrefs = Rhino.Input.RhinoGet.GetMultipleObjects(\n        prompt=\"Select breps\",\n        acceptNothing=False,\n        filter=rd.ObjectType.Brep)\n    \n    if res != Rhino.Commands.Result.Success: return\n    \n    attr_Red = rd.ObjectAttributes()\n    attr_Red.LayerIndex = sc.doc.Layers.CurrentLayerIndex\n    attr_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\n    attr_Red.ObjectColor = attr_Red.ObjectColor.Red\n    \n    attr_Green = attr_Red.Duplicate()\n    attr_Green.ObjectColor = attr_Green.ObjectColor.Lime\n    \n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\n    \n    print(\"Tolerance: {}\".format(tolerance))\n    \n    for objref in objrefs:\n        face_In = objref.Face()\n        if face_In is None:\n            brep = objref.Brep()\n            faces = brep.Faces\n        else:\n            faces = [face_In]\n        \n        for face in faces:\n            srf = face.UnderlyingSurface()\n\n            ss = []\n\n            silhouettes = rg.Silhouette.ComputeDraftCurve(\n                geometry=face,\n                draftAngle=draftAngle,\n                pullDirection=rg.Vector3d.ZAxis,\n                tolerance=tolerance,\n                angleToleranceRadians=sc.doc.ModelAngleToleranceRadians)\n\n            for silh in silhouettes:\n                if silh.Curve is None: continue\n                if silh.SilhouetteType not in (rg.SilhouetteType.DraftCurve, rg.SilhouetteType.Tangent):\n                    continue\n\n                fLength = silh.Curve.GetLength()\n                if fLength < tolerance:\n                    continue\n\n                if doesCurveSelfIntersect(silh.Curve, tolerance):\n                    continue\n\n                hi_def_pull = create_hi_def_pull_to_face(face, silh.Curve)\n                if doesCurveSelfIntersect(hi_def_pull):\n                    continue\n\n                bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\n                    silh.Curve, hi_def_pull, tolerance=0.1*tolerance)[:2]\n                if not bSuccess:\n                    continue\n\n                ss.append(\"    Max. dist. from face: {}\".format(fDistMax))\n\n                if fDistMax > tolerance:\n                    ss[-1] += \" <-\"\n                    sc.doc.Objects.AddCurve(silh.Curve, attr_Red)\n                    sc.doc.Objects.AddCurve(hi_def_pull, attr_Green)\n            if ss: print('\\n'.join(ss))\n\n    sc.doc.Views.Redraw()\n\n\nif __name__ == '__main__': main()",
      "language": "python",
      "author": "spb",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "layers",
    "python",
    "rhinocommon"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 2,
  "views": 198
}