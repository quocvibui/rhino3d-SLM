{
  "source_url": "https://github.com/arijitaich/2dtocad/blob/f837c55a0c1597a488080ecdc9c5c11a0264d13e/mcp/rhino_mcp_client.py",
  "repo": "arijitaich/2dtocad",
  "repo_stars": 0,
  "repo_description": "A pipeline to create 2d to cad of each and every component required to manufacture an item provided as user input images.",
  "license": "unknown",
  "filepath": "mcp/rhino_mcp_client.py",
  "instruction": "Rhino MCP - Rhino-side Script\nHandles communication with external MCP server and executes Rhino commands.",
  "code": "\"\"\"\nRhino MCP - Rhino-side Script\nHandles communication with external MCP server and executes Rhino commands.\n\"\"\"\n\nimport socket\nimport threading\nimport json\nimport time\nimport System\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport os\nimport platform\nimport traceback\nimport sys\nimport base64\nfrom System.Drawing import Bitmap\nfrom System.Drawing.Imaging import ImageFormat\nfrom System.IO import MemoryStream\nfrom datetime import datetime\n\n# Configuration\nHOST = 'localhost'\nPORT = 9876\n\n# Add constant for annotation layer\nANNOTATION_LAYER = \"MCP_Annotations\"\n\nVALID_METADATA_FIELDS = {\n    'required': ['id', 'name', 'type', 'layer'],\n    'optional': [\n        'short_id',      # Short identifier (DDHHMMSS format)\n        'created_at',    # Timestamp of creation\n        'bbox',          # Bounding box coordinates\n        'description',   # Object description\n        'user_text'      # All user text key-value pairs\n    ]\n}\n\ndef get_log_dir():\n    \"\"\"Get the appropriate log directory based on the platform\"\"\"\n    home_dir = os.path.expanduser(\"~\")\n    \n    # Platform-specific log directory\n    if platform.system() == \"Darwin\":  # macOS\n        log_dir = os.path.join(home_dir, \"Library\", \"Application Support\", \"RhinoMCP\", \"logs\")\n    elif platform.system() == \"Windows\":\n        log_dir = os.path.join(home_dir, \"AppData\", \"Local\", \"RhinoMCP\", \"logs\")\n    else:  # Linux and others\n        log_dir = os.path.join(home_dir, \".rhino_mcp\", \"logs\")\n    \n    return log_dir\n\ndef log_message(message):\n    \"\"\"Log a message to both Rhino's command line and log file\"\"\"\n    # Print to Rhino's command line\n    Rhino.RhinoApp.WriteLine(message)\n    \n    # Log to file\n    try:\n        log_dir = get_log_dir()\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n            \n        log_file = os.path.join(log_dir, \"rhino_mcp.log\")\n        \n        # Log platform info on first run\n        if not os.path.exists(log_file):\n            with open(log_file, \"w\") as f:\n                f.write(\"=== RhinoMCP Log ===\\n\")\n                f.write(\"Platform: {0}\\n\".format(platform.system()))\n                f.write(\"Python Version: {0}\\n\".format(sys.version))\n                f.write(\"Rhino Version: {0}\\n\".format(Rhino.RhinoApp.Version))\n                f.write(\"==================\\n\\n\")\n        \n        with open(log_file, \"a\") as f:\n            timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            f.write(\"[{0}] {1}\\n\".format(timestamp, message))\n    except Exception as e:\n        Rhino.RhinoApp.WriteLine(\"Failed to write to log file: {0}\".format(str(e)))\n\nclass RhinoMCPServer:\n    def __init__(self, host='localhost', port=9876):\n        self.host = host\n        self.port = port\n        self.running = False\n        self.socket = None\n        self.server_thread = None\n    \n    def start(self):\n        if self.running:\n            log_message(\"Server is already running\")\n            return\n            \n        self.running = True\n        \n        try:\n            # Create socket\n            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self.socket.bind((self.host, self.port))\n            self.socket.listen(1)\n            \n            # Start server thread\n            self.server_thread = threading.Thread(target=self._server_loop)\n            self.server_thread.daemon = True\n            self.server_thread.start()\n            \n            log_message(\"RhinoMCP server started on {0}:{1}\".format(self.host, self.port))\n        except Exception as e:\n            log_message(\"Failed to start server: {0}\".format(str(e)))\n            self.stop()\n            \n    def stop(self):\n        self.running = False\n        \n        # Close socket\n        if self.socket:\n            try:\n                self.socket.close()\n            except:\n                pass\n            self.socket = None\n        \n        # Wait for thread to finish\n        if self.server_thread:\n            try:\n                if self.server_thread.is_alive():\n                    self.server_thread.join(timeout=1.0)\n            except:\n                pass\n            self.server_thread = None\n        \n        log_message(\"RhinoMCP server stopped\")\n    \n    def _server_loop(self):\n        \"\"\"Main server loop that accepts connections\"\"\"\n        while self.running:\n            try:\n                client, addr = self.socket.accept()\n                log_message(\"Client connected from {0}:{1}\".format(addr[0], addr[1]))\n                \n                # Handle client in a new thread\n                client_thread = threading.Thread(target=self._handle_client, args=(client,))\n                client_thread.daemon = True\n                client_thread.start()\n                \n            except Exception as e:\n                if self.running:\n                    log_message(\"Error accepting connection: {0}\".format(str(e)))\n                    time.sleep(0.5)\n    \n    def _handle_client(self, client):\n        \"\"\"Handle a client connection\"\"\"\n        try:\n            # Set socket buffer size\n            client.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 14485760)  # 10MB\n            client.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 14485760)  # 10MB\n            \n            while self.running:\n                # Receive command with larger buffer\n                data = client.recv(14485760)  # 10MB buffer\n                if not data:\n                    log_message(\"Client disconnected\")\n                    break\n                    \n                try:\n                    command = json.loads(data.decode('utf-8'))\n                    log_message(\"Received command: {0}\".format(command))\n                    \n                    # Create a closure to capture the client connection\n                    def execute_wrapper():\n                        try:\n                            response = self.execute_command(command)\n                            response_json = json.dumps(response)\n                            # Split large responses into chunks if needed\n                            chunk_size = 14485760  # 10MB chunks\n                            response_bytes = response_json.encode('utf-8')\n                            for i in range(0, len(response_bytes), chunk_size):\n                                chunk = response_bytes[i:i + chunk_size]\n                                client.sendall(chunk)\n                            log_message(\"Response sent successfully\")\n                        except Exception as e:\n                            log_message(\"Error executing command: {0}\".format(str(e)))\n                            traceback.print_exc()\n                            error_response = {\n                                \"status\": \"error\",\n                                \"message\": str(e)\n                            }\n                            try:\n                                client.sendall(json.dumps(error_response).encode('utf-8'))\n                            except Exception as e:\n                                log_message(\"Failed to send error response: {0}\".format(str(e)))\n                                return False  # Signal connection should be closed\n                        return True  # Signal connection should stay open\n                    \n                    # Use RhinoApp.Idle event for IronPython 2.7 compatibility\n                    def idle_handler(sender, e):\n                        if not execute_wrapper():\n                            # If execute_wrapper returns False, close the connection\n                            try:\n                                client.close()\n                            except:\n                                pass\n                        # Remove the handler after execution\n                        Rhino.RhinoApp.Idle -= idle_handler\n                    \n                    Rhino.RhinoApp.Idle += idle_handler\n                    \n                except ValueError as e:\n                    # Handle JSON decode error (IronPython 2.7)\n                    log_message(\"Invalid JSON received: {0}\".format(str(e)))\n                    error_response = {\n                        \"status\": \"error\",\n                        \"message\": \"Invalid JSON format\"\n                    }\n                    try:\n                        client.sendall(json.dumps(error_response).encode('utf-8'))\n                    except:\n                        break  # Close connection on send error\n                \n        except Exception as e:\n            log_message(\"Error handling client: {0}\".format(str(e)))\n            traceback.print_exc()\n        finally:\n            try:\n                client.close()\n            except:\n                pass\n    \n    def execute_command(self, command):\n        \"\"\"Execute a command received from the client\"\"\"\n        try:\n            command_type = command.get(\"type\")\n            params = command.get(\"params\", {})\n            \n            if command_type == \"get_scene_info\":\n                return self._get_scene_info(params)\n            elif command_type == \"create_cube\":\n                return self._create_cube(params)\n            elif command_type == \"get_layers\":\n                return self._get_layers()\n            elif command_type == \"execute_code\":\n                return self._execute_code(params)\n            elif command_type == \"get_objects_with_metadata\":\n                return self._get_objects_with_metadata(params)\n            elif command_type == \"capture_viewport\":\n                return self._capture_viewport(params)\n            elif command_type == \"add_metadata\":\n                return self._add_object_metadata(\n                    params.get(\"object_id\"), \n                    params.get(\"name\"), \n                    params.get(\"description\")\n                )\n            else:\n                return {\"status\": \"error\", \"message\": \"Unknown command type\"}\n                \n        except Exception as e:\n            log_message(\"Error executing command: {0}\".format(str(e)))\n            traceback.print_exc()\n            return {\"status\": \"error\", \"message\": str(e)}\n    \n    def _get_scene_info(self, params=None):\n        \"\"\"Get simplified scene information focusing on layers and example objects\"\"\"\n        try:\n            doc = sc.doc\n            if not doc:\n                return {\n                    \"status\": \"error\",\n                    \"message\": \"No active document\"\n                }\n            \n            log_message(\"Getting simplified scene info...\")\n            layers_info = []\n            \n            for layer in doc.Layers:\n                layer_objects = [obj for obj in doc.Objects if obj.Attributes.LayerIndex == layer.Index]\n                example_objects = []\n                \n                for obj in layer_objects[:5]:  # Limit to 5 example objects per layer\n                    try:\n                        # Convert NameValueCollection to dictionary\n                        user_strings = {}\n                        if obj.Attributes.GetUserStrings():\n                            for key in obj.Attributes.GetUserStrings():\n                                user_strings[key] = obj.Attributes.GetUserString(key)\n                        \n                        obj_info = {\n                            \"id\": str(obj.Id),\n                            \"name\": obj.Name or \"Unnamed\",\n                            \"type\": obj.Geometry.GetType().Name if obj.Geometry else \"Unknown\",\n                            \"metadata\": user_strings  # Now using the converted dictionary\n                        }\n                        example_objects.append(obj_info)\n                    except Exception as e:\n                        log_message(\"Error processing object: {0}\".format(str(e)))\n                        continue\n                \n                layer_info = {\n                    \"full_path\": layer.FullPath,\n                    \"object_count\": len(layer_objects),\n                    \"is_visible\": layer.IsVisible,\n                    \"is_locked\": layer.IsLocked,\n                    \"example_objects\": example_objects\n                }\n                layers_info.append(layer_info)\n            \n            response = {\n                \"status\": \"success\",\n                \"layers\": layers_info\n            }\n            \n            log_message(\"Simplified scene info collected successfully\")\n            return response\n            \n        except Exception as e:\n            log_message(\"Error getting simplified scene info: {0}\".format(str(e)))\n            return {\n                \"status\": \"error\",\n                \"message\": str(e),\n                \"layers\": []\n            }\n    \n    def _create_cube(self, params):\n        \"\"\"Create a cube in the scene\"\"\"\n        try:\n            size = float(params.get(\"size\", 1.0))\n            location = params.get(\"location\", [0, 0, 0])\n            name = params.get(\"name\", \"Cube\")\n            \n            # Create cube using RhinoCommon\n            box = Rhino.Geometry.Box(\n                Rhino.Geometry.Plane.WorldXY,\n                Rhino.Geometry.Interval(0, size),\n                Rhino.Geometry.Interval(0, size),\n                Rhino.Geometry.Interval(0, size)\n            )\n            \n            # Move to specified location\n            transform = Rhino.Geometry.Transform.Translation(\n                location[0] - box.Center.X,\n                location[1] - box.Center.Y,\n                location[2] - box.Center.Z\n            )\n            box.Transform(transform)\n            \n            # Add to document\n            id = sc.doc.Objects.AddBox(box)\n            if id != System.Guid.Empty:\n                obj = sc.doc.Objects.Find(id)\n                if obj:\n                    obj.Name = name\n                    sc.doc.Views.Redraw()\n                    return {\n                        \"status\": \"success\",\n                        \"message\": \"Created cube with size {0}\".format(size),\n                        \"id\": str(id)\n                    }\n            \n            return {\"status\": \"error\", \"message\": \"Failed to create cube\"}\n        except Exception as e:\n            return {\"status\": \"error\", \"message\": str(e)}\n    \n    def _get_layers(self):\n        \"\"\"Get information about all layers\"\"\"\n        try:\n            doc = sc.doc\n            layers = []\n            \n            for layer in doc.Layers:\n                layers.append({\n                    \"id\": layer.Index,\n                    \"name\": layer.Name,\n                    \"object_count\": layer.ObjectCount,\n                    \"is_visible\": layer.IsVisible,\n                    \"is_locked\": layer.IsLocked\n                })\n            \n            return {\n                \"status\": \"success\",\n                \"layers\": layers\n            }\n        except Exception as e:\n            return {\"status\": \"error\", \"message\": str(e)}\n    \n    def _execute_code(self, params):\n        \"\"\"Execute arbitrary Python code\"\"\"\n        try:\n            code = params.get(\"code\", \"\")\n            if not code:\n                return {\"status\": \"error\", \"message\": \"No code provided\"}\n            \n            log_message(\"Executing code: {0}\".format(code))\n            \n            # Create a new scope for code execution\n            local_dict = {}\n            \n            try:\n                # Execute the code\n                exec(code, globals(), local_dict)\n                \n                # Get result from local_dict or use a default message\n                result = local_dict.get(\"result\", \"Code executed successfully\")\n                log_message(\"Code execution completed. Result: {0}\".format(result))\n                \n                response = {\n                    \"status\": \"success\",\n                    \"result\": str(result),\n                    \"variables\": {k: str(v) for k, v in local_dict.items() if not k.startswith('__')}\n                }\n                \n                log_message(\"Sending response: {0}\".format(json.dumps(response)))\n                return response\n                \n            except Exception as e:\n                hint = \"Did you use f-string formatting? You have to use IronPython here that doesn't support this.\"\n                error_response = {\n                    \"status\": \"error\",\n                    \"message\": \"{0} {1}\".format(hint, str(e)),\n                }\n                log_message(\"Error: {0}\".format(error_response))\n                return error_response\n                \n        except Exception as e:\n            hint = \"Did you use f-string formatting? You have to use IronPython here that doesn't support this.\"\n            error_response = {\n                \"status\": \"error\",\n                \"message\": \"{0} {1}\".format(hint, str(e)),\n            }\n            log_message(\"System error: {0}\".format(error_response))\n            return error_response\n\n    def _add_object_metadata(self, obj_id, name=None, description=None):\n        \"\"\"Add standardized metadata to an object\"\"\"\n        try:\n            import json\n            import time\n            from datetime import datetime\n            \n            # Generate short ID\n            short_id = datetime.now().strftime(\"%d%H%M%S\")\n            \n            # Get bounding box\n            bbox = rs.BoundingBox(obj_id)\n            bbox_data = [[p.X, p.Y, p.Z] for p in bbox] if bbox else []\n            \n            # Get object type\n            obj = sc.doc.Objects.Find(obj_id)\n            obj_type = obj.Geometry.GetType().Name if obj else \"Unknown\"\n            \n            # Standard metadata\n            metadata = {\n                \"short_id\": short_id,\n                \"created_at\": time.time(),\n                \"layer\": rs.ObjectLayer(obj_id),\n                \"type\": obj_type,\n                \"bbox\": bbox_data\n            }\n            \n            # User-provided metadata\n            if name:\n                rs.ObjectName(obj_id, name)\n                metadata[\"name\"] = name\n            else:\n                # Auto-generate name if none provided\n                auto_name = \"{0}_{1}\".format(obj_type, short_id)\n                rs.ObjectName(obj_id, auto_name)\n                metadata[\"name\"] = auto_name\n                \n            if description:\n                metadata[\"description\"] = description\n                \n            # Store metadata as user text (convert bbox to string for storage)\n            user_text_data = metadata.copy()\n            user_text_data[\"bbox\"] = json.dumps(bbox_data)\n            \n            # Add all metadata as user text\n            for key, value in user_text_data.items():\n                rs.SetUserText(obj_id, key, str(value))\n                \n            return {\"status\": \"success\"}\n        except Exception as e:\n            log_message(\"Error adding metadata: \" + str(e))\n            return {\"status\": \"error\", \"message\": str(e)}\n\n    def _get_objects_with_metadata(self, params):\n        \"\"\"Get objects with their metadata, with optional filtering\"\"\"\n        try:\n            import re\n            import json\n            \n            filters = params.get(\"filters\", {})\n            metadata_fields = params.get(\"metadata_fields\")\n            layer_filter = filters.get(\"layer\")\n            name_filter = filters.get(\"name\")\n            id_filter = filters.get(\"short_id\")\n            \n            # Validate metadata fields\n            all_fields = VALID_METADATA_FIELDS['required'] + VALID_METADATA_FIELDS['optional']\n            if metadata_fields:\n                invalid_fields = [f for f in metadata_fields if f not in all_fields]\n                if invalid_fields:\n                    return {\n                        \"status\": \"error\",\n                        \"message\": \"Invalid metadata fields: \" + \", \".join(invalid_fields),\n                        \"available_fields\": all_fields\n                    }\n            \n            objects = []\n            \n            for obj in sc.doc.Objects:\n                obj_id = obj.Id\n                \n                # Apply filters\n                if layer_filter:\n                    layer = rs.ObjectLayer(obj_id)\n                    pattern = \"^\" + layer_filter.replace(\"*\", \".*\") + \"$\"\n                    if not re.match(pattern, layer, re.IGNORECASE):\n                        continue\n                    \n                if name_filter:\n                    name = obj.Name or \"\"\n                    pattern = \"^\" + name_filter.replace(\"*\", \".*\") + \"$\"\n                    if not re.match(pattern, name, re.IGNORECASE):\n                        continue\n                    \n                if id_filter:\n                    short_id = rs.GetUserText(obj_id, \"short_id\") or \"\"\n                    if short_id != id_filter:\n                        continue\n                    \n                # Build base object data with required fields\n                obj_data = {\n                    \"id\": str(obj_id),\n                    \"name\": obj.Name or \"Unnamed\",\n                    \"type\": obj.Geometry.GetType().Name,\n                    \"layer\": rs.ObjectLayer(obj_id)\n                }\n                \n                # Get user text data and parse stored values\n                stored_data = {}\n                for key in rs.GetUserText(obj_id):\n                    value = rs.GetUserText(obj_id, key)\n                    if key == \"bbox\":\n                        try:\n                            value = json.loads(value)\n                        except:\n                            value = []\n                    elif key == \"created_at\":\n                        try:\n                            value = float(value)\n                        except:\n                            value = 0\n                    stored_data[key] = value\n                \n                # Build metadata based on requested fields\n                if metadata_fields:\n                    metadata = {k: stored_data[k] for k in metadata_fields if k in stored_data}\n                else:\n                    metadata = {k: v for k, v in stored_data.items() \n                              if k not in VALID_METADATA_FIELDS['required']}\n                \n                # Only include user_text if specifically requested\n                if not metadata_fields or 'user_text' in metadata_fields:\n                    user_text = {k: v for k, v in stored_data.items() \n                               if k not in metadata}\n                    if user_text:\n                        obj_data[\"user_text\"] = user_text\n                \n                # Add metadata if we have any\n                if metadata:\n                    obj_data[\"metadata\"] = metadata\n                    \n                objects.append(obj_data)\n            \n            return {\n                \"status\": \"success\",\n                \"count\": len(objects),\n                \"objects\": objects,\n                \"available_fields\": all_fields\n            }\n            \n        except Exception as e:\n            log_message(\"Error filtering objects: \" + str(e))\n            return {\n                \"status\": \"error\",\n                \"message\": str(e),\n                \"available_fields\": all_fields\n            }\n\n    def _capture_viewport(self, params):\n        \"\"\"Capture viewport with optional annotations and layer filtering\"\"\"\n        try:\n            layer_name = params.get(\"layer\")\n            show_annotations = params.get(\"show_annotations\", True)\n            max_size = params.get(\"max_size\", 800)  # Default max dimension\n            original_layer = rs.CurrentLayer()\n            temp_dots = []\n\n            if show_annotations:\n                # Ensure annotation layer exists and is current\n                if not rs.IsLayer(ANNOTATION_LAYER):\n                    rs.AddLayer(ANNOTATION_LAYER, color=(255, 0, 0))\n                rs.CurrentLayer(ANNOTATION_LAYER)\n                \n                # Create temporary text dots for each object\n                for obj in sc.doc.Objects:\n                    if layer_name and rs.ObjectLayer(obj.Id) != layer_name:\n                        continue\n                        \n                    bbox = rs.BoundingBox(obj.Id)\n                    if bbox:\n                        pt = bbox[1]  # Use top corner of bounding box\n                        short_id = rs.GetUserText(obj.Id, \"short_id\")\n                        if not short_id:\n                            short_id = datetime.now().strftime(\"%d%H%M%S\")\n                            rs.SetUserText(obj.Id, \"short_id\", short_id)\n                        \n                        name = rs.ObjectName(obj.Id) or \"Unnamed\"\n                        text = \"{0}\\n{1}\".format(name, short_id)\n                        \n                        dot_id = rs.AddTextDot(text, pt)\n                        rs.TextDotHeight(dot_id, 8)\n                        temp_dots.append(dot_id)\n            \n            try:\n                view = sc.doc.Views.ActiveView\n                memory_stream = MemoryStream()\n                \n                # Capture to bitmap\n                bitmap = view.CaptureToBitmap()\n                \n                # Calculate new dimensions while maintaining aspect ratio\n                width, height = bitmap.Width, bitmap.Height\n                if width > height:\n                    new_width = max_size\n                    new_height = int(height * (max_size / width))\n                else:\n                    new_height = max_size\n                    new_width = int(width * (max_size / height))\n                \n                # Create resized bitmap\n                resized_bitmap = Bitmap(bitmap, new_width, new_height)\n                \n                # Save as JPEG (IronPython doesn't support quality parameter)\n                resized_bitmap.Save(memory_stream, ImageFormat.Jpeg)\n                \n                bytes_array = memory_stream.ToArray()\n                image_data = base64.b64encode(bytes(bytearray(bytes_array))).decode('utf-8')\n                \n                # Clean up\n                bitmap.Dispose()\n                resized_bitmap.Dispose()\n                memory_stream.Dispose()\n                \n            finally:\n                if temp_dots:\n                    rs.DeleteObjects(temp_dots)\n                rs.CurrentLayer(original_layer)\n            \n            return {\n                \"type\": \"image\",\n                \"source\": {\n                    \"type\": \"base64\",\n                    \"media_type\": \"image/jpeg\",\n                    \"data\": image_data\n                }\n            }\n            \n        except Exception as e:\n            log_message(\"Error capturing viewport: \" + str(e))\n            if 'original_layer' in locals():\n                rs.CurrentLayer(original_layer)\n            return {\n                \"type\": \"text\",\n                \"text\": \"Error capturing viewport: \" + str(e)\n            }\n\n# Create and start server\nserver = RhinoMCPServer(HOST, PORT)\nserver.start()\n\n# Add commands to Rhino\ndef start_server():\n    \"\"\"Start the RhinoMCP server\"\"\"\n    server.start()\n\ndef stop_server():\n    \"\"\"Stop the RhinoMCP server\"\"\"\n    server.stop()\n\n# Automatically start the server when this script is loaded\nstart_server()\nlog_message(\"RhinoMCP script loaded. Server started automatically.\")\nlog_message(\"To stop the server, run: stop_server()\") ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}