{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Tilt%20And%20Orientation%20Factor.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Tilt And Orientation Factor.py",
  "instruction": "This component calculates the Optimal Tilt, Optimal Orientation and TOF (Tilt and Orientation Factor) for PV modules or Solar water heating collectors.\nTOF is a solar radiation at the actual tilt and...",
  "code": "# tilt and orientation factor\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Djordje Spasic <djordjedspasic@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nThis component calculates the Optimal Tilt, Optimal Orientation and TOF (Tilt and Orientation Factor) for PV modules or Solar water heating collectors.\nTOF is a solar radiation at the actual tilt and orientation divided by the solar radiation at the optimum tilt and orientation.\n-\nProvided by Ladybug 0.0.69\n    \n    input:\n        _epwFile: Input .epw file path by using the \"File Path\" parameter, or Ladybug's \"Open EPW And STAT Weather Files\" component.\n        _PV_SWHsurface: - Input planar Grasshopper/Rhino Surface (not a polysurface) on which the PV modules/SWH collectors will be applied. If you have a polysurface, explode it (using \"Deconstruct Brep\" component) and then feed its Faces(F) output to _PV_SWHsurface. Surface normal should be faced towards the sun.\n                        - Or create the Surface based on initial PV/SWH system size by using \"PV SWH system size\" component.\n        annualShading_: Losses due to buildings, structures, trees, mountains or other objects that prevent solar radiation from reaching the PV module/Solar water heating collector.\n                  Input range: 0 to 100(%), 0 being unshaded, and 100 being totally shaded PV module/SWH collector.\n                  -\n                  If not supplied default value of 0(%) will be used.\n        north_: Input a vector to be used as a true North direction, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis.\n                -\n                If not supplied, default North direction will be set to the Y-axis (0 degrees).\n        albedo_: A list of 8767 (with header) or 8760 (without the header) albedo values for each hour during a year.\n                 Albedo (or Reflection coefficient) is an average ratio of the global incident solar radiation reflected from the area surrounding the PV surface.\n                 It ranges from 0 to 1.\n                 -\n                 It depends on the time of the year/day, surface type, temperature, vegetation, presence of water, ice and snow etc.\n                 -\n                 If no list supplied, default value of 0.20 will be used, corrected(increased) for the presence of snow (if any).\n                 -\n                 Unitless.\n        precision_: Represents the square root number of analysis field for the output \"geometry\" mesh. Ranges from 1-100.\n                    Example - precision of 4, would mean that 4 fields in X direction (Azimuth) and 4 fields in Y direction (Tilt) = 16 fields, will be used to calculate the final \"geometry\" mesh.\n                    For lower precision numbers (say < 20) even precision numbers are more accurate.\n                    -\n                    If not supplied, default value of 20 will be used.\n        scale_: Scale of the overall geometry.\n                -\n                If not supplied, default value of 1 will be used.\n        origin_: Origin for the final \"geometry\" output.\n                -\n                If not supplied, default point of (-15,0,0) will be used.\n        legendPar_: Optional legend parameters from the Ladybug \"Legend Parameters\" component.\n        bakeIt_: Set to \"True\" to bake the Tilt and orientation factor results into the Rhino scene.\n                 -\n                 If not supplied default value \"False\" will be used.\n        _runIt: ...\n        \n    output:\n        readMe!: ...\n        TOF: Tilt and Orientation Factor - solar radiation at the actual tilt and azimuth divided by the solar radiation at the optimum tilt and azimuth.\n             In percent(%).\n        TSRF: Total Solar Resource Fraction - the ratio of solar radiation available accounting for both annual shading and TOF, compared to the solar radiation available at a given location at the optimum tilt and azimuth and with no shading.\n              Calculated according to the following equation:\n              TSRF = TOF * (100-annualShading)/100\n              Some USA states, like Oregon and Washington require TSRF to be minimum 75% in order for the PV system to be applicable for incentive programs.\n              -\n              In percent(%).\n        PVsurfaceTilt: Tilt angle of the inputted PV_SWHsurface.\n                       In degrees ().\n        PVsurfaceAzimuth: Orientation angle of the inputted PV_SWHsurface.\n                          In degrees ().\n        optimalTilt: Optimal tilt of the PV_SWHsurface for a given location. Optimal tilt being the one that receives the most annual solar radiation.\n                     In degrees ().\n        optimalAzimuth: Optimal orientation of the PV_SWHsurface for a given location. Optimal azimuth being the one that receives the most annual solar radiation.\n                        In degrees ().\n        optimalRoofPitch: Optimal steepness of the PV_SWHsurface for a given location. Optimal steepness being the one that receives the most annual solar radiation.\n                          In inches/inches\n        optimalRadiation: Total solar radiation per square meter for a whole year received on a PV_SWHsurface of optimal tilt and azimuth, at given location.\n                          In kWh/m2\n        geometry: Geometry of the whole TOF mesh chart.\n                  Connect this output to a Grasshopper's \"Geo\" parameter in order to preview the \"geometry\" separately in the Rhino scene.\n        originPt: The origin point of the \"geometry\" output.\n                  Use this point to move \"geometry\" output around in the Rhino scene with the grasshopper's \"Move\" component.\n        analysisPt: A point indicating inputted PV_SWHsurface's Tilt/Azimuth position on the solar radiation table.\n        legend: A legend for the annual total solar radiation (in kWh/m2). Connect this output to a Grasshopper's \"Geo\" parameter in order to preview the legend separately in the Rhino scene.  \n        legendBasePt: Legend base point, which can be used to move the \"legend\" geometry with grasshopper's \"Move\" component.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Tilt And Orientation Factor\"\nghenv.Component.NickName = \"TOF\"\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"4 | Renewables\"\n#compatibleLBVersion = VER 0.0.64\\nAPR_12_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport System\nimport Rhino\nimport time\nimport math\n\n\ndef getEpwData(epwFile, annualShading, albedo, precision, scale, origin, legendPar, analysisPeriod):\n    \n    if epwFile:\n        try:\n            # location data\n            locationName, latitude, longitude, timeZone, elevation, locationString = lb_preparation.epwLocation(epwFile)\n            # weather data\n            weatherData = lb_preparation.epwDataReader(epwFile, locationName)\n            dryBulbTemperature, dewPointTemperature, relativeHumidity, windSpeed, windDirection, directNormalRadiation, diffuseHorizontalRadiation, globalHorizontalRadiation, directNormalIlluminance, diffuseHorizontalIlluminance, globalHorizontalIlluminance, totalSkyCover, liquidPrecipitationDepth, barometricPressure, modelYear = weatherData\n            Ta = dryBulbTemperature[7:]\n            \n            if (annualShading == None) or (annualShading < 0) or (annualShading > 100):\n                annualShading = 0  # default\n            \n            if (len(albedo) == 0) or (albedo[0] is \"\"):\n                albedoL = lb_photovoltaics.calculateAlbedo(Ta)  # default\n            elif (len(albedo) == 8767):\n                albedoL = albedo[7:]\n            elif (len(albedo) == 8760):\n                albedoL = albedo\n            else:\n                locationName = latitude = longitude = timeZone = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = annualShading = albedoL = precision = scale = origin = originOffset = legendPar = None\n                validEpwData = False\n                printMsg = \"Something is wrong with your \\\"albedo_\\\" list input.\\n\\\"albedo_\\\" input accepts a list of 8767 (with header) or 8760 (without the header) abledo values.\"\n                \n                return locationName, latitude, longitude, timeZone, DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, annualShading, albedoL, precision, scale, origin, originOffset, legendPar, validEpwData, printMsg\n            \n            if (precision == None) or (precision < 1) or (precision > 100):\n                precision = 2  # default\n            \n            if (scale == None) or (scale <= 0):\n                scale = 1\n            \n            if (origin == None):\n                origin = Rhino.Geometry.Point3d(-15, 0, 0)\n                originOffset = Rhino.Geometry.Point3d(origin.X+15, origin.Y, origin.Z)  # default 0,0,0 point\n            else:\n                originOffset = Rhino.Geometry.Point3d(origin.X+15, origin.Y, origin.Z)  # default 0,0,0 point\n            \n            if (len(legendPar) == 0):\n                lowB = None; highB = None; numSeg = None; customColors = [System.Drawing.Color.FromArgb(98,20,0), System.Drawing.Color.FromArgb(204,79,0), System.Drawing.Color.FromArgb(255,174,52), System.Drawing.Color.FromArgb(254,255,255)]; legendBasePoint = None; legendScale = None; legendFont = None; legendFontSize = None; legendBold = None; decimalPlaces = 2; removeLessThan = False\n                legendPar = [lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan]\n            \n            \n            DNI = directNormalRadiation[7:]\n            DHI = diffuseHorizontalRadiation[7:]\n            yearsHOY = modelYear[7:]\n            \n            monthsHOY = [1 for i in range(744)] + [2 for i in range(672)] + [3 for i in range(744)] + [4 for i in range(720)] + [5 for i in range(744)] + [6 for i in range(720)] + [7 for i in range(744)] + [8 for i in range(744)] + [9 for i in range(720)] + [10 for i in range(744)] + [11 for i in range(720)] + [12 for i in range(744)]\n            \n            numberOfDaysMonth = [31,28,31,30,31,30,31,31,30,31,30,31]\n            daysHOY = []\n            day = 1\n            for i,item in enumerate(numberOfDaysMonth):\n                for k in range(item):\n                    for g in range(24):\n                        daysHOY.append(day)\n                    day += 1\n                day = 1\n            \n            hoursHOY = []\n            hour = 1\n            for i in range(365):\n                for k in range(24):\n                    hoursHOY.append(hour)\n                    hour += 1\n                hour = 1\n            \n            \n            # HOYs\n            if (len(analysisPeriod) != 0) and (analysisPeriod[0] != None):\n                # something added to \"analysisPeriod_\" input\n                timeStep = 1\n                HOYs, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriod, timeStep)\n            else:\n                # nothing added to \"analysisPeriod_\" input\n                HOYs = range(1,8761)\n            \n            \n            validEpwData = True\n            printMsg = \"ok\"\n            \n            return locationName, float(latitude), float(longitude), float(timeZone), DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, annualShading, albedoL, precision, scale, origin, originOffset, legendPar, validEpwData, printMsg\n        \n        except Exception, e:\n            print \"e: \", e\n            # something is wrong with \"_epwFile\" input\n            locationName = latitude = longitude = timeZone = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = annualShading = albedoL = precision = scale = origin = originOffset = legendPar = None\n            validEpwData = False\n            printMsg = \"Something is wrong with \\\"_epwFile\\\" input.\"\n    else:\n        locationName = latitude = longitude = timeZone = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = annualShading = albedoL = precision = scale = origin = originOffset = legendPar = None\n        validEpwData = False\n        printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n    \n    return locationName, latitude, longitude, timeZone, DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, annualShading, albedoL, precision, scale, origin, originOffset, legendPar, validEpwData, printMsg\n\n\ndef PVsurfaceInputData(PV_SWHsurface):\n    \n    if (PV_SWHsurface == None):\n        PVsurfaceInputType = srfArea = None\n        validPVsurfaceData = False\n        printMsg = \"Please input a Surface (not polysurface) to \\\"_PV_SWHsurface\\\".\"\n        \n        return PVsurfaceInputType, srfArea, validPVsurfaceData, printMsg\n    \n    # check PV_SWHsurface input\n    PVsurfaceInputType = \"brep\"\n    facesCount = PV_SWHsurface.Faces.Count\n    if facesCount > 1:\n        # inputted polysurface\n        PVsurfaceInputType = srfArea = None\n        validPVsurfaceData = False\n        printMsg = \"The brep you supplied to \\\"_PV_SWHsurface\\\" is a polysurface. Please supply a surface\"\n        \n        return PVsurfaceInputType, srfArea, validPVsurfaceData, printMsg\n    else:\n        # inputted brep with a single surface\n        srfArea = Rhino.Geometry.AreaMassProperties.Compute(PV_SWHsurface).Area  # in m2\n        validPVsurfaceData = True\n        printMsg = \"ok\"\n        \n        return PVsurfaceInputType, srfArea, validPVsurfaceData, printMsg\n\n\ndef main(latitude, longitude, timeZone, locationName, years, months, days, hours, HOYs, srfArea, srfTiltD, srfAzimuthD, correctedSrfAzimuthD, directNormalRadiation, diffuseHorizontalRadiation, albedoL, precision, originOffset):\n    \n    # TOF mesh Tilt, Azimuth values\n    srfTiltTOFList = []\n    srfAzimuthTOFList = []\n    stepSrfTilt = 90/precision\n    stepSrfAzimuth = 180/precision\n    if anglesClockwise == True:  # angles clockwise\n        for i in range(0,precision+1,1):\n            srfTiltTOFList.append(stepSrfTilt*i)\n        if latitude >= 0:\n            for i in range(precision,-1,-1):\n                srfAzimuthTOFList.append(90+stepSrfAzimuth*i)\n        elif latitude < 0:\n            for i in range(0,precision+1,1):\n                srfAzimuth = 270+stepSrfAzimuth*i\n                if srfAzimuth >= 360:\n                    srfAzimuth = srfAzimuth-360\n                srfAzimuthTOFList.append(srfAzimuth)\n    elif anglesClockwise == False:  # angles counterclockwise\n        for i in range(0,precision+1,1):\n            srfTiltTOFList.append(stepSrfTilt*i)\n        if latitude >= 0:\n            for i in range(0,precision+1,1):\n                srfAzimuthTOFList.append(90+stepSrfAzimuth*i)\n        elif latitude < 0:\n            for i in range(precision,-1,-1): \n                srfAzimuth = 270+stepSrfAzimuth*i\n                if srfAzimuth >= 360:\n                    srfAzimuth = srfAzimuth-360\n                srfAzimuthTOFList.append(srfAzimuth)\n    \n    # TOF mesh generation (mesh width = 80, mesh height = 45)\n    meshPtStepU = 80/(len(srfAzimuthTOFList)-1)\n    meshPtStepV = 45/(len(srfTiltTOFList)-1)\n    \n    meshPts = []\n    meshLiftedPts = []\n    totalRadiationPerYearL = []\n    for i,srfTiltTOF in enumerate(srfTiltTOFList):\n        for k,srfAzimuthTOF in enumerate(srfAzimuthTOFList):\n            totalRadiationPerYear = 0\n            for g,hoy in enumerate(HOYs):\n                sunZenithD, sunAzimuthD, sunAltitudeD = lb_photovoltaics.NRELsunPosition(latitude, longitude, timeZone, years[hoy-1], months[hoy-1], days[hoy-1], hours[hoy-1]-1)\n                Epoa, Eb, Ed_sky, Eground, AOI_R = lb_photovoltaics.POAirradiance(sunZenithD, sunAzimuthD, srfTiltTOF, srfAzimuthTOF, directNormalRadiation[hoy-1], diffuseHorizontalRadiation[hoy-1], albedoL[hoy-1])\n                totalRadiationPerYear += Epoa  # in Wh/m2\n            totalRadiationPerYearL.append(totalRadiationPerYear)\n    \n    # iterate \"srfTiltTOFList\" and \"srfAzimuthTOFList\" one more time, now that \"totalRadiationPerYearL\" has been generated: to find \"meshPts\", \"liftedMeshPts\"\n    totalRadiationPerYear_index = 0\n    for i,srfTiltTOF in enumerate(srfTiltTOFList):\n        for k,srfAzimuthTOF in enumerate(srfAzimuthTOFList):\n            normalized_totalRadiationPerYear = (totalRadiationPerYearL[totalRadiationPerYear_index] - min(totalRadiationPerYearL)) / (max(totalRadiationPerYearL) - min(totalRadiationPerYearL))  # normalizes each totalRadiationPerYear value from 0 to 1\n            if anglesClockwise == True:  # angles clockwise\n                meshPt = Rhino.Geometry.Point3d(originOffset.X + meshPtStepU*k, originOffset.Y + meshPtStepV*i, originOffset.Z)\n                liftedMeshPt = Rhino.Geometry.Point3d(originOffset.X + meshPtStepU*k, originOffset.Y + meshPtStepV*i, originOffset.Z + (normalized_totalRadiationPerYear*100))  # lift each meshPt.Z coordinate by \"normalized_totalRadiationPerYear*100\"\n            elif anglesClockwise == False:  # angles counterclockwise\n                meshPt = Rhino.Geometry.Point3d(originOffset.X + meshPtStepU*k, originOffset.Y + meshPtStepV*i, originOffset.Z)\n                liftedMeshPt = Rhino.Geometry.Point3d(originOffset.X + meshPtStepU*k, originOffset.Y + meshPtStepV*i, originOffset.Z + (normalized_totalRadiationPerYear*100))  # lift each meshPt.Z coordinate by \"normalized_totalRadiationPerYear*100\"\n            meshPts.append(meshPt)\n            meshLiftedPts.append(liftedMeshPt)\n            totalRadiationPerYear_index += 1\n    \n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    colors = lb_visualization.gradientColor(totalRadiationPerYearL, lowB, highB, customColors)\n    \n    mesh = lb_meshpreparation.meshFromPoints(precision+1, precision+1, meshPts, colors)\n    meshLifted = lb_meshpreparation.meshFromPoints(precision+1, precision+1, meshLiftedPts, [])\n    \n    maximalTotalRadiationPerYear = max(totalRadiationPerYearL)\n    minimalTotalRadiationPerYear = min(totalRadiationPerYearL)\n    percents = [(totalRadiationPerYear/maximalTotalRadiationPerYear)*100 for totalRadiationPerYear in totalRadiationPerYearL]\n    percentsAndPts = [((totalRadiationPerYear/maximalTotalRadiationPerYear)*100, meshLiftedPts[i]) for i,totalRadiationPerYear in enumerate(totalRadiationPerYearL)]\n    minimalPercent = min(percents)\n    maximalPercent = max(percents)  # always 100\n    percentsAndPts.sort()\n    minimalPt = percentsAndPts[0][1]\n    maximalPt = percentsAndPts[-1][1]\n    \n    \n    # isoCrvs\n    planesAxisLine = Rhino.Geometry.Line(Rhino.Geometry.Point3d(0, 0, minimalPt.Z), Rhino.Geometry.Point3d(0, 0, maximalPt.Z))\n    planesAxisCrv = Rhino.Geometry.Line.ToNurbsCurve(planesAxisLine)\n    newDomain = Rhino.Geometry.Interval(minimalPercent, maximalPercent)\n    planesAxisCrv.Domain = newDomain\n    \n    isoCrvPlanes = []\n    isoCrvPercents = []\n    projectedIsoCrvs = []\n    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    percents10 = [10,20,30,40,50,60,70,80,90,94,96,98,99]\n    for p in percents10:\n        if (p >= minimalPercent) and (p <= maximalPercent):\n            plane = Rhino.Geometry.Plane( Rhino.Geometry.Point3d(planesAxisCrv.PointAt(p)), Rhino.Geometry.Vector3d(0,0,1) )\n            isoCrvPlanes.append(plane)\n            isoCrvPercents.append(p)\n            isoPolylinesSublist = Rhino.Geometry.Intersect.Intersection.MeshPlane(meshLifted, plane)\n            isoCrvsSubList = [Rhino.Geometry.Polyline.ToNurbsCurve(polyline) for polyline in isoPolylinesSublist]\n            joinedIsoCrvsSubList = Rhino.Geometry.Curve.JoinCurves(isoCrvsSubList, tol)\n            projectedIsoCrvsSubList = [Rhino.Geometry.Curve.ProjectToPlane(crv, Rhino.Geometry.Plane(Rhino.Geometry.Point3d(originOffset), Rhino.Geometry.Vector3d(0,0,1))) for crv in joinedIsoCrvsSubList]\n            projectedIsoCrvs.append(projectedIsoCrvsSubList)\n    # last (100%) isoCrv\n    plane = Rhino.Geometry.Plane( Rhino.Geometry.Point3d(planesAxisCrv.PointAt(100-tol)), Rhino.Geometry.Vector3d(0,0,1) )\n    lastIsoPolylines = Rhino.Geometry.Intersect.Intersection.MeshPlane(meshLifted, plane)\n    lastIsoCrvs = [Rhino.Geometry.Polyline.ToNurbsCurve(polyline) for polyline in lastIsoPolylines]\n    joinedLastIsoCrvs = Rhino.Geometry.Curve.JoinCurves(lastIsoCrvs, tol)\n    projectedLastIsoCrvs = [Rhino.Geometry.Curve.ProjectToPlane(crv, Rhino.Geometry.Plane(Rhino.Geometry.Point3d(originOffset), Rhino.Geometry.Vector3d(0,0,1))) for crv in joinedLastIsoCrvs]\n    \n    \n    # optimal Tilt, Azimuth\n    planarMeshAboveLiftedPts = [Rhino.Geometry.Point3d(pt.X, pt.Y, maximalPt.Z+10) for pt in meshLiftedPts]\n    planarMeshAboveLifted = lb_meshpreparation.meshFromPoints(precision+1, precision+1, planarMeshAboveLiftedPts, [])\n    \n    def meshesClosesPts(startingPt, mesh1, mesh2):\n        pt1 = startingPt\n        for k in range(300):\n        #for k in range(3000):\n            pt2 = mesh2.ClosestMeshPoint(pt1,0.0).Point\n            pt1 = mesh1.ClosestMeshPoint(pt2,0.0).Point\n        return pt1\n    \n    if latitude >= 0:\n        azimuthMeshStartValue = 90\n    elif latitude < 0:\n        azimuthMeshStartValue = 270\n    meshLiftedCentroid = Rhino.Geometry.AreaMassProperties.Compute(meshLifted).Centroid\n    optimalPt = meshesClosesPts(meshLiftedCentroid, meshLifted, planarMeshAboveLifted)\n    \n    if anglesClockwise == True:  # clockwise\n        if latitude >= 0:\n            optimalAzimuthD = round( 180-((optimalPt.X-originOffset.X) *180/80)+azimuthMeshStartValue, 1 )\n        elif latitude < 0:\n            optimalAzimuthD = round((180*(optimalPt.X - originOffset.X)/80 + azimuthMeshStartValue), 1)\n            if optimalAzimuthD >= 360:\n                optimalAzimuthD = optimalAzimuthD-360\n    elif anglesClockwise == False:  # counterclockwise\n        if latitude >= 0:\n            optimalAzimuthD = round(((optimalPt.X-originOffset.X) *180/80)+azimuthMeshStartValue, 1 )\n        elif latitude < 0:\n            optimalAzimuthD = round(180-((optimalPt.X-originOffset.X) *180/80)+azimuthMeshStartValue, 1 )\n            if optimalAzimuthD >= 360:\n                optimalAzimuthD = optimalAzimuthD-360\n    optimalTiltD = round(90*(optimalPt.Y - originOffset.Y)/45,1)\n    \n    # optimalRoofPitch\n    optimalTiltTangent = math.tan(math.radians(optimalTiltD))\n    optimalTiltNumerator = round(12*optimalTiltTangent,2)\n    if optimalTiltNumerator % 1 == 0:\n        optimalTiltNumerator = int(optimalTiltNumerator)\n    optimalRoofPitch = \"%s/12\" % optimalTiltNumerator\n    \n    # analysisPt (\"originOffset.Z+tol\" due to overlap with \"mesh\")\n    if anglesClockwise == True:  # clockwise\n        if latitude >= 0:\n            oppositeOriginOffset = Rhino.Geometry.Point3d(originOffset.X+15+80+15, originOffset.Y, originOffset.Z)\n            analysisPt = Rhino.Geometry.Point3d( (oppositeOriginOffset.X-15-15) -((srfAzimuthD-azimuthMeshStartValue)*80/180), originOffset.Y+srfTiltD*45/90, originOffset.Z+tol)\n        elif latitude < 0:\n            if (srfAzimuthD >= 0) and  (srfAzimuthD < 270):\n                srfAzimuthD = srfAzimuthD + 360\n            analysisPt = Rhino.Geometry.Point3d(((srfAzimuthD-azimuthMeshStartValue)*80/180)+originOffset.X, originOffset.Y+srfTiltD*45/90, originOffset.Z+tol)\n    elif anglesClockwise == False:  # counterclockwise\n        if latitude >= 0:\n            analysisPt = Rhino.Geometry.Point3d(((srfAzimuthD-azimuthMeshStartValue)*80/180)+originOffset.X, originOffset.Y+srfTiltD*45/90, originOffset.Z+tol)\n        elif latitude < 0:\n            if (srfAzimuthD >= 0) and  (srfAzimuthD <= 90):\n                srfAzimuthD = srfAzimuthD + 360\n            oppositeOriginOffset = Rhino.Geometry.Point3d(originOffset.X+15+80+15, originOffset.Y, originOffset.Z)\n            analysisPt = Rhino.Geometry.Point3d( (oppositeOriginOffset.X-15-15) -((srfAzimuthD-azimuthMeshStartValue)*80/180), originOffset.Y+srfTiltD*45/90, originOffset.Z+tol)\n    \n    # totalRadiationPerYear of the inputted (analysed) surface\n    totalRadiationPerYear = 0\n    for i,hoy in enumerate(HOYs):\n        sunZenithD, sunAzimuthD, sunAltitudeD = lb_photovoltaics.NRELsunPosition(latitude, longitude, timeZone, years[i], months[i], days[i], hours[i]-1)\n        Epoa, Eb, Ed_sky, Eground, AOI_R = lb_photovoltaics.POAirradiance(sunZenithD, sunAzimuthD, srfTiltD, srfAzimuthD, directNormalRadiation[i], diffuseHorizontalRadiation[i], albedoL[i])\n        totalRadiationPerYear += Epoa  # in Wh/m2\n    \n    # TOF, TSRF of the inputted (analysed) surface\n    TOF = round((totalRadiationPerYear/maximalTotalRadiationPerYear)*100 ,1)  # in percent\n    if TOF > 100:\n        TOF = 100\n    TSRF = round(TOF * ((100-annualShading)/100) ,1)  # in percent\n    \n    return totalRadiationPerYearL, int(maximalTotalRadiationPerYear/1000), int(totalRadiationPerYear/1000), meshPts, mesh, projectedIsoCrvs, projectedLastIsoCrvs, isoCrvPercents, optimalAzimuthD, optimalTiltD, optimalRoofPitch, analysisPt, TOF, TSRF\n\n\ndef createGeometry(totalRadiationPerYearL, totalRadiationPerYear, mesh, optimalTiltD, optimalAzimuthD, TOF, TSRF, projectedIsoCrvs, projectedLastIsoCrvs, isoCrvPercents, originOffset, legendPar, locationName, latitude, longitude):\n    \n    # isoCrvs text values origin points\n    percentTextValuesOrigins = []\n    cuttedProjectedIsoCrvs = []\n    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    for i,p in enumerate(isoCrvPercents):\n        isoCrv = projectedIsoCrvs[i][0]\n        midPt = isoCrv.PointAtLength(isoCrv.GetLength()/2)\n        percentTextValuesOrigins.append(midPt)\n        circleAroundRegionPercValues = Rhino.Geometry.Circle(midPt, 1.4).ToNurbsCurve()\n        interevents = Rhino.Geometry.Intersect.Intersection.CurveCurve(isoCrv, circleAroundRegionPercValues, tol, tol)\n        if len(interevents) != 0:\n            t1 = interevents[0].ParameterA\n            t2 = interevents[1].ParameterA\n            isoCrvDomain = isoCrv.Domain\n            dom1 = Rhino.Geometry.Interval(isoCrvDomain[0],t1)\n            dom2 = Rhino.Geometry.Interval(t2,isoCrvDomain[1])\n            crvBeginningPart = Rhino.Geometry.Curve.Trim(isoCrv,dom1)\n            crvEndingPart = Rhino.Geometry.Curve.Trim(isoCrv,dom2)\n            joinedSplittedIsoCrvs = Rhino.Geometry.Curve.JoinCurves([crvBeginningPart,crvEndingPart], tol)\n            if isoCrv.IsClosed:\n                cuttedProjectedIsoCrvs.append(joinedSplittedIsoCrvs[0])\n            else:\n                cuttedProjectedIsoCrvs.append(joinedSplittedIsoCrvs[0])\n                cuttedProjectedIsoCrvs.append(joinedSplittedIsoCrvs[1])\n            # add second curves, not labeled with isoCrvPercentsStrings\n            if len(projectedIsoCrvs[i]) > 1:\n                cuttedProjectedIsoCrvs.append(projectedIsoCrvs[i][1])\n        else:\n            # add cuttedProjectedIsoCrvs smaller than circleAroundRegionPercValues diameter\n            cuttedProjectedIsoCrvs.append(projectedIsoCrvs[i][0])\n    \n    # xAxis, yAxis NotchValues\n    if anglesClockwise == True:  # clockwise\n        if latitude >= 0:\n            xAxisNotchValues = [\"270\",\"240\",\"210\",\"180\",\"150\",\"120\",\"90\"]\n        elif latitude < 0:\n            xAxisNotchValues = [\"270\",\"300\",\"330\",\"0\",\"30\",\"60\",\"90\"]\n    elif anglesClockwise == False:  # counterclockwise\n        if latitude >= 0:\n            xAxisNotchValues = [\"90\",\"120\",\"150\",\"180\",\"210\",\"240\",\"270\"]\n        elif latitude < 0:\n            xAxisNotchValues = [\"90\",\"60\",\"30\",\"0\",\"330\",\"300\",\"270\"]\n    yAxisNotchValues = [\"0\",\"10\",\"20\",\"30\",\"40\",\"50\",\"60\",\"70\",\"80\",\"90\"]\n    \n    # xAxis, yAxis NotchLines, NotchValuesOrigins\n    xAxisNotchLines = []\n    xAxisNotchValuesOrigins = []\n    stepX = 80/(len(xAxisNotchValues)-1)\n    for i in range(len(xAxisNotchValues)):\n        xNotchLine = Rhino.Geometry.Line( Rhino.Geometry.Point3d(originOffset.X + stepX*i, originOffset.Y, originOffset.Z), Rhino.Geometry.Point3d(originOffset.X + stepX*i, originOffset.Y-2, originOffset.Z) )\n        xNotchValueOrigin = Rhino.Geometry.Point3d(originOffset.X + stepX*i, originOffset.Y-3, originOffset.Z)\n        xAxisNotchLines.append(xNotchLine)\n        xAxisNotchValuesOrigins.append(xNotchValueOrigin)\n    yAxisNotchLines = []\n    yAxisNotchValuesOrigins = []\n    stepY = 45/(len(yAxisNotchValues)-1)\n    for i in range(len(yAxisNotchValues)):\n        yNotchLine = Rhino.Geometry.Line( Rhino.Geometry.Point3d(originOffset.X, originOffset.Y + stepY*i, originOffset.Z), Rhino.Geometry.Point3d(originOffset.X-2, originOffset.Y + stepY*i, originOffset.Z) )\n        yNotchValueOrigin = Rhino.Geometry.Point3d(originOffset.X-3, originOffset.Y + stepY*i, originOffset.Z)\n        yAxisNotchLines.append(yNotchLine)\n        yAxisNotchValuesOrigins.append(yNotchValueOrigin)\n    \n    # y2Axis NotchLines, NotchValuesOrigins\n    y2AxisNotchLines = []\n    y2AxisNotchValuesOrigins = []\n    oddRoofPitchAnglesLabels = []\n    roofPitchAnglesForNotches = [0, 4.5, 9.5, 14, 18.5, 22.5, 26.5, 30.5, 33.75, 37, 40, 42.5, 45, 49.4, 53.13, 56.31, 59.04, 61.39, 63.43]  # 0/12, 1/12, 2/12, 3/12, 4/12, 5/12, 6/12, 7/12, 8/12, 9/12, 10/12, 11/12, 12/12, 14/12, 16/12, 18/12, 20/12, 22/12, 24/12\n    allRoofPitchAnglesLabels = [\"0/12\", \"1/12\", \"2/12\", \"3/12\", \"4/12\", \"5/12\", \"6/12\", \"7/12\", \"8/12\", \"9/12\", \"10/12\", \"11/12\", \"12/12\", \"14/12\", \"16/12\", \"18/12\", \"20/12\", \"22/12\", \"24/12\"]\n    for i,angleD in enumerate(roofPitchAnglesForNotches):\n        if i%2 == 0:\n            y2AxisNotchLine = Rhino.Geometry.Line(Rhino.Geometry.Point3d(originOffset.X + 80, 45/90*angleD+originOffset.Y, originOffset.Z), Rhino.Geometry.Point3d(originOffset.X + 80+2, 45/90*angleD+originOffset.Y, originOffset.Z))\n            y2AxisNotchValuesOrigin = Rhino.Geometry.Point3d(originOffset.X + 80+3, 45/90*angleD+originOffset.Y, originOffset.Z)\n            label = allRoofPitchAnglesLabels[i]\n        else:\n            y2AxisNotchLine = Rhino.Geometry.Line(Rhino.Geometry.Point3d(originOffset.X + 80, 45/90*angleD+originOffset.Y, originOffset.Z), Rhino.Geometry.Point3d(originOffset.X + 80+1, 45/90*angleD+originOffset.Y, originOffset.Z))\n        y2AxisNotchLines.append(y2AxisNotchLine)\n        y2AxisNotchValuesOrigins.append(y2AxisNotchValuesOrigin)\n        oddRoofPitchAnglesLabels.append(label)\n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    if not legendFontSize: legendFontSize = 2\n    \n    # xAxis, yAxis, y2Axis LabelMeshes\n    xAxisNotchValuesMeshes = lb_visualization.text2srf(xAxisNotchValues, xAxisNotchValuesOrigins, legendFont, legendFontSize, legendBold, None, 7)\n    xAxisNotchValuesMeshes = [item for subList in xAxisNotchValuesMeshes for item in subList]\n    yAxisNotchValuesMeshes = lb_visualization.text2srf(yAxisNotchValues, yAxisNotchValuesOrigins, legendFont, legendFontSize, legendBold, None, 5)\n    yAxisNotchValuesMeshes = [item for subList in yAxisNotchValuesMeshes for item in subList]\n    y2AxisNotchValuesMeshes = lb_visualization.text2srf(oddRoofPitchAnglesLabels, y2AxisNotchValuesOrigins, legendFont, legendFontSize*0.7, legendBold, None, 3)\n    y2AxisNotchValuesMeshes = [item for subList in y2AxisNotchValuesMeshes for item in subList]\n    \n    # xAxis, yAxis, y2Axis LabelOrigin\n    xAxisLabelOrigin = Rhino.Geometry.Point3d(originOffset.X+80/2, originOffset.Y-11, originOffset.Z)\n    yAxisLabelOrigin = Rhino.Geometry.Point3d(originOffset.X-10, originOffset.Y + 45/2, originOffset.Z)\n    y2AxisLabelOrigin = Rhino.Geometry.Point3d(originOffset.X + 80+12, originOffset.Y+45/2, originOffset.Z)\n    \n    # xAxis, yAxis, y2Axis LabelMeshes\n    xAxisLabelMeshes = lb_visualization.text2srf([\"Azimuth ()\"], [xAxisLabelOrigin], legendFont, legendFontSize, legendBold, None, 1)[0]\n    yAxisLabelMeshes = lb_visualization.text2srf([\"Tilt ()\"], [yAxisLabelOrigin], legendFont, legendFontSize, legendBold, None, 2)[0]\n    y2AxisLabelMeshes = lb_visualization.text2srf([\"Roof pitch\"], [y2AxisLabelOrigin], legendFont, legendFontSize, legendBold, None, 3)[0]\n    \n    # title LabelOrigin\n    titleLabelOrigin = Rhino.Geometry.Point3d(originOffset.X-6, originOffset.Y-15, originOffset.Z)\n    descriptionLabelOrigin = Rhino.Geometry.Point3d(originOffset.X-6, originOffset.Y-22, originOffset.Z)\n    TOFoptimal = 100  # always 100%\n    TSRFoptimal = 100 # always 100%\n    titleLabelText = \"Solar radiation as a function of panel tilt/orientation\"\n    titleLabelMeshes = lb_visualization.text2srf([titleLabelText], [titleLabelOrigin], legendFont, legendFontSize*1.6, legendBold, None, 6)[0]\n    if (len(analysisPeriod_) != 0) and (analysisPeriod_[0] != None):\n        # something added to \"analysisPeriod_\" input\n        analysisPeriod = \"%s to %s\" % (list(analysisPeriod_[0]), list(analysisPeriod_[1]))\n    else:\n        # nothing added to \"analysisPeriod_\" input\n        analysisPeriod = \"whole year\"\n    descriptionLabelText = \"Location: %s, Latitude: %s, Longitude: %s\\nOptimal: Tilt: %0.1f, Azimuth: %0.1f, Radiation: %s kWh/m2, TOF: %0.1f, TSRF: %0.1f\\nAnalysed: Tilt: %0.1f, Azimuth: %0.1f, Radiation: %s kWh/m2, TOF: %0.1f, TSRF: %0.1f\\nAnalysis period: %s\" %(locationName, latitude, longitude, optimalTiltD, optimalAzimuthD, maximalTotalRadiationPerYear, TOFoptimal, TSRFoptimal, srfTiltD, srfAzimuthD, totalRadiationPerYear, TOF, TSRF, analysisPeriod)\n    descriptionLabelMeshes = lb_visualization.text2srf([descriptionLabelText], [descriptionLabelOrigin], legendFont, legendFontSize*1.3, legendBold, None, 6)[0]\n    \n    # region percent values\n    isoCrvPercentsStrings = [str(p) for p in isoCrvPercents]\n    percentTextValuesOriginsLifted = [Rhino.Geometry.Point3d(pt.X,pt.Y,pt.Z+tol) for pt in percentTextValuesOrigins]  # \"pt.Z+tol\" due to overlap with \"mesh\"\n    regionPercentValuesMeshes = lb_visualization.text2srf(isoCrvPercentsStrings, percentTextValuesOriginsLifted, legendFont, legendFontSize*0.5, legendBold, None, 4)\n    regionPercentValuesMeshes = [item for subList in regionPercentValuesMeshes for item in subList]\n    \n    # last (100%) region percent value\n    lastIsoCrvTextValueOrigin = projectedLastIsoCrvs[0].PointAtLength(projectedLastIsoCrvs[0].GetLength()/2)\n    lastIsoCrvTextValueOriginMoved = Rhino.Geometry.Point3d(lastIsoCrvTextValueOrigin.X+1.5, lastIsoCrvTextValueOrigin.Y, lastIsoCrvTextValueOrigin.Z+tol)\n    lastRegionPercentValuesMeshes = lb_visualization.text2srf([\"100\"], [lastIsoCrvTextValueOriginMoved], legendFont, legendFontSize*0.5, legendBold, None, 4)\n    lastRegionPercentValuesMeshes = [item for subList in lastRegionPercentValuesMeshes for item in subList]\n    \n    \n    meshes = [mesh] + xAxisNotchValuesMeshes + yAxisNotchValuesMeshes + y2AxisNotchValuesMeshes + xAxisLabelMeshes + yAxisLabelMeshes + y2AxisLabelMeshes + titleLabelMeshes + descriptionLabelMeshes + regionPercentValuesMeshes + lastRegionPercentValuesMeshes\n    xAxisNotchCrvs = [line.ToNurbsCurve() for line in xAxisNotchLines]\n    yAxisNotchCrvs = [line.ToNurbsCurve() for line in yAxisNotchLines]\n    y2AxisNotchCrvs = [line.ToNurbsCurve() for line in y2AxisNotchLines]\n    curves = xAxisNotchCrvs + yAxisNotchCrvs + y2AxisNotchCrvs + cuttedProjectedIsoCrvs + projectedLastIsoCrvs\n    geometry = meshes + curves\n    \n    # scaling\n    if scale != 1:\n        plane = sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n        plane.Origin = originOffset\n        tmScale = Rhino.Geometry.Transform.Scale(plane, scale,scale,scale)\n        for item in geometry+[analysisPt]:\n            try:\n                for subitem in item:\n                    subitem.Transform(tmScale)\n            except:\n                item.Transform(tmScale)\n    \n    return geometry\n\n\ndef legendGeometry(legendPar, meshPts, totalRadiationPerYearL):\n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    if legendBasePoint == None:\n        legendBasePoint = Rhino.Geometry.Point3d(meshPts[precision].X+25, meshPts[precision].Y, meshPts[precision].Z)\n    \n    if scale != 1:\n        plane = sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\n        plane.Origin = originOffset\n        tmScale = Rhino.Geometry.Transform.Scale(plane, scale,scale,scale)\n        legendBasePoint.Transform(tmScale)\n    \n    # generate the legend\n    totalRadiationPerYearLint = [annualEpoa/1000 for annualEpoa in totalRadiationPerYearL]\n    lb_visualization.calculateBB([mesh])\n    legendSrfs, legendText, legendTextSrfs, textPt, textSize = lb_visualization.createLegend(totalRadiationPerYearLint, lowB, highB, numSeg, \"Radiation (kWh/m2)\", lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    # generate legend colors\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n    # color legend surfaces\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    legend = [legendSrfs] + lb_preparation.flattenList(legendTextSrfs)\n    legendPlusLegendBasePoint = legend + [legendBasePoint]\n    \n    # hide originPt, legendBasePt outputs\n    ghenv.Component.Params.Output[12].Hidden = True\n    ghenv.Component.Params.Output[15].Hidden = True\n    \n    return legend, legendBasePoint\n\n\ndef bakingGrouping(locationName, geometry, legend, analysisPt, TOF, TSRF):\n    \n    layerName = str(TOF) + \"%_\" + locationName\n    layerIndex, l = lb_visualization.setupLayers(layerName, \"LADYBUG\", \"TOF\", \"PHOTOVOLTAICS\")\n    \n    attr = Rhino.DocObjects.ObjectAttributes()\n    attr.LayerIndex = layerIndex\n    attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n    attr.PlotColorSource = Rhino.DocObjects.ObjectPlotColorSource.PlotColorFromObject\n    \n    geometry = geometry + legend + [Rhino.Geometry.Point(analysisPt)]\n    # bake geometry, legend, analysisPt\n    geometryIds = []\n    for obj in geometry:\n        id = Rhino.RhinoDoc.ActiveDoc.Objects.Add(obj,attr)\n        geometryIds.append(id)\n    \n    # grouping\n    groupIndex = Rhino.RhinoDoc.ActiveDoc.Groups.Add(\"TOF_\" + str(l) + \"_\" + str(time.time()))\n    Rhino.RhinoDoc.ActiveDoc.Groups.AddToGroup(groupIndex, geometryIds)\n\n\ndef printOutput(north, latitude, longitude, locationName, albedoL, srfArea, precision, scale, origin, analysisPeriod):\n    if (len(analysisPeriod) == 0):\n        analysisPeriod = [(1,1,1),(12,31,24)]\n    resultsCompletedMsg = \"Tilt and orientation factor component results successfully completed!\"\n    printOutputMsg = \\\n    \"\"\"\nInput data:\n\nLocation (deg.): %s\nLatitude (deg.): %s\nLongitude (deg.): %s\nNorth (deg.): %s\nAverage annual albedo(-): %0.2f\n\nSurface area (m2): %0.2f\nPrecision: %s\nScale: %s\nOrigin: %0.2f,%0.2f,%0.2f\nAnalysis period: %s to %s\n    \"\"\" % (locationName, latitude, longitude, north, sum(albedoL)/8760, srfArea, precision, scale, origin.X, origin.Y, origin.Z, list(analysisPeriod[0]), list(analysisPeriod[1]))\n    print resultsCompletedMsg\n    print printOutputMsg\n\n\nlevel = gh.GH_RuntimeMessageLevel.Warning\nif sc.sticky.has_key(\"ladybug_release\"):\n    if sc.sticky[\"ladybug_release\"].isCompatible(ghenv.Component):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_meshpreparation = sc.sticky[\"ladybug_Mesh\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        lb_photovoltaics = sc.sticky[\"ladybug_Photovoltaics\"]()\n        \n        if _epwFile:\n            locationName, latitude, longitude, timeZone, directNormalRadiation, diffuseHorizontalRadiation, years, months, days, hours, HOYs, annualShading, albedoL, precision, scale, origin, originOffset, legendPar, validEpwData, printMsg = getEpwData(_epwFile, annualShading_, albedo_, precision_, scale_, origin_, legendPar_, analysisPeriod_)\n            if validEpwData:\n                PVsurfaceInputType, srfArea, validPVsurfaceData, printMsg = PVsurfaceInputData(_PV_SWHsurface)\n                if validPVsurfaceData:\n                    # all inputs ok\n                    if _runIt:\n                        anglesClockwise = True; PVsurfaceTiltAngle_ = None; PVsurfaceAzimuthAngle_ = None\n                        srfAzimuthD, surfaceTiltDCalculated = lb_photovoltaics.srfAzimuthAngle(PVsurfaceAzimuthAngle_, PVsurfaceInputType, _PV_SWHsurface, latitude)\n                        correctedSrfAzimuthD, northDeg, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(north_, srfAzimuthD)\n                        srfTiltD = lb_photovoltaics.srfTiltAngle(PVsurfaceTiltAngle_, surfaceTiltDCalculated, PVsurfaceInputType, _PV_SWHsurface, latitude)\n                        totalRadiationPerYearL, maximalTotalRadiationPerYear, totalRadiationPerYear, meshPts, mesh, projectedIsoCrvs, projectedLastIsoCrvs, isoCrvPercents, optimalAzimuthD, optimalTiltD, optimalRoofPitch, analysisPt, TOF, TSRF = main(latitude, longitude, timeZone, locationName, years, months, days, hours, HOYs, srfArea, srfTiltD, srfAzimuthD, correctedSrfAzimuthD, directNormalRadiation, diffuseHorizontalRadiation, albedoL, precision, originOffset)\n                        geometry = createGeometry(totalRadiationPerYearL, totalRadiationPerYear, mesh, optimalTiltD, optimalAzimuthD, TOF, TSRF, projectedIsoCrvs, projectedLastIsoCrvs, isoCrvPercents, originOffset, legendPar, locationName, latitude, longitude)\n                        legend, legendBasePt = legendGeometry(legendPar, meshPts, totalRadiationPerYearL)\n                        if bakeIt_: bakingGrouping(locationName, geometry, legend, analysisPt, TOF, TSRF)\n                        printOutput(northDeg, latitude, longitude, locationName, albedoL, srfArea, precision, scale, origin, analysisPeriod_)\n                        PVsurfaceTilt = srfTiltD; PVsurfaceAzimuth = srfAzimuthD; optimalTilt = optimalTiltD; optimalAzimuth = optimalAzimuthD; optimalRadiation = maximalTotalRadiationPerYear; originPt = origin\n                        # changing \"optimalAzimuth\" output to account for \"north_\" input\n                        optimalAzimuth = optimalAzimuth + northDeg\n                        if optimalAzimuth > 360:\n                            optimalAzimuth = optimalAzimuth - 360\n                    else:\n                        print \"All inputs are ok. Please set the \\\"_runIt\\\" to True, in order to run the Tilt and orientation factor component.\"\n                else:\n                    print printMsg\n                    ghenv.Component.AddRuntimeMessage(level, printMsg)\n            else:\n                print printMsg\n                ghenv.Component.AddRuntimeMessage(level, printMsg)\n        else:\n            printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n            print printMsg\n            ghenv.Component.AddRuntimeMessage(level, printMsg)\n    else:\n        printMsg = \"You need a newer version of Ladybug to use this component.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag the Ladybug_Ladybug component \" + \\\n            \"into the canvas and try again.\"\n        print printMsg\nelse:\n    printMsg = \"First please let the Ladybug fly...\"\n    print printMsg\n    ghenv.Component.AddRuntimeMessage(level, printMsg)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}