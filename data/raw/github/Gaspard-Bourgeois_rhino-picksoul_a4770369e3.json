{
  "source_url": "https://github.com/Gaspard-Bourgeois/rhino-picksoul/blob/9431b8335b62d43ec3539852d1a1af603f0ce1c5/dev/block/editBlockXform.py",
  "repo": "Gaspard-Bourgeois/rhino-picksoul",
  "repo_stars": 1,
  "repo_description": "Generic plugin to manage blocs, materials and trajectories in rhino.",
  "license": "Apache-2.0",
  "filepath": "dev/block/editBlockXform.py",
  "instruction": "Author: Gaspard BOURGEOIS <gaspard.github.io@free.fr>\nVersion: 1.0\nDate: 22/12/25",
  "code": "\"\"\"\nAuthor: Gaspard BOURGEOIS <gaspard.github.io@free.fr>\nVersion: 1.0\nDate: 22/12/25\n\"\"\"\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport rhinoscript.utility as rhutil\nimport uuid \n\n\n# ----------------------------------------------------------------------\n# Fonctions Utilitaires RhinoCommon/rhinoscriptsyntax\n# ----------------------------------------------------------------------\n\n\ndef _format_xform(x):\n    \"\"\"Retourne une représentation 4x4 d'une transformation.\"\"\"\n    if x is None:\n        return \"<None>\"\n    out_lines = []\n    for i in range(4):\n        row = []\n        for j in range(4):\n            v = x[i, j]\n            row.append(\"%+0.6f\" % (v,))\n        out_lines.append(\" \".join(row))\n    return \"\\n\".join(out_lines)\n\n\ndef update_block_def(sti, xform):\n    \"\"\"\n    Applique 'xform' (X_def) à TOUTE la géométrie interne de la définition\n    via RhinoCommon ModifyGeometry.\n    \"\"\"\n    objref = rs.coercerhinoobject(sti)\n    if objref is None: return False\n    \n    idef = objref.InstanceDefinition\n    idefIndex = idef.Index\n\n\n    idef_obj = sc.doc.InstanceDefinitions[idefIndex]\n    if idef_obj is None: return False\n    \n    block_objects = idef_obj.GetObjects()\n\n\n    newGeometry = []\n    newAttributes = []\n\n\n    for rhino_obj in block_objects:\n        # Dupliquer et transformer la géométrie de l'objet dans la définition\n        geometry = rhino_obj.Geometry.DuplicateShallow() \n        geometry.Transform(xform)\n        attributes = rhino_obj.Attributes.Duplicate()\n        newGeometry.append(geometry)\n        newAttributes.append(attributes)\n\n\n    InstanceDefinitionTable = sc.doc.InstanceDefinitions\n    success = InstanceDefinitionTable.ModifyGeometry(idefIndex, newGeometry, newAttributes)\n    return success\n\n\n\n\ndef selective_update_block_def(definition_name, target_object_id, xform):\n    \"\"\"\n    Applique 'xform' (X_comp) UNIQUEMENT à un objet spécifique (l'instance enfant) \n    à l'intérieur de la définition parente via ModifyGeometry.\n    'target_object_id' doit être l'ID de l'objet tel qu'il est stocké DANS la définition.\n    \"\"\"\n    \n    # Recherche de la définition parente directement par son nom (string)\n    parent_def = sc.doc.InstanceDefinitions.Find(definition_name, False) \n    \n    if parent_def is None: \n        print(\"ATTENTION: Définition parente '%s' introuvable.\" % definition_name)\n        return False\n    \n    idefIndex = parent_def.Index\n    block_objects = parent_def.GetObjects()\n\n\n    newGeometry = []\n    newAttributes = []\n    modified = False\n\n\n    for rhino_obj in block_objects:\n        geometry = rhino_obj.Geometry.DuplicateShallow() \n        attributes = rhino_obj.Attributes.Duplicate()\n\n\n        # Cible l'objet (l'instance de bloc enfant) par son ID interne à la définition\n        if rhino_obj.Id.Equals(target_object_id):\n            # Applique X_comp pour compenser l'effet X_def\n            geometry.Transform(xform) \n            modified = True\n\n\n        newGeometry.append(geometry)\n        newAttributes.append(attributes)\n\n\n    if modified:\n        InstanceDefinitionTable = sc.doc.InstanceDefinitions\n        success = InstanceDefinitionTable.ModifyGeometry(idefIndex, newGeometry, newAttributes)\n        # print(\"DEBUG_UPWARD_MOD: Compensated nested instance %s in def %s. Success: %s\" % (target_object_id, definition_name, success))\n        return success\n    \n    return False\n\n\ndef PropagateUpwardCompensation(child_block_name, xform_compensation, visited_defs=None):\n    \"\"\"\n    RÉCURSIF : applique la compensation (X_comp) à l'instance de bloc enfant\n    à l'intérieur de toutes ses définitions parentes.\n    \"\"\"\n    if visited_defs is None:\n        visited_defs = set()\n\n\n    parent_block_names = rs.BlockContainers(child_block_name)\n    if not parent_block_names:\n        return\n\n\n    for parent_name in parent_block_names:\n        if parent_name in visited_defs:\n            continue  # éviter double propagation\n\n\n        visited_defs.add(parent_name)\n\n\n        # 1. Objets dans la définition parente (GUIDs d'objets internes à la définition)\n        definition_objects = rs.BlockObjects(parent_name) \n\n\n        # 2. Sauvegarder les positions initiales des objets non-blocs (pour debug)\n        pre_positions = {}\n        for obj_id in definition_objects:\n            if not rs.IsBlockInstance(obj_id):\n                bbox = rs.BoundingBox(obj_id)\n                if bbox:\n                    pt = rs.PointCoordinates(bbox[0])\n                    pre_positions[obj_id] = pt\n\n\n        # 3. Identifier uniquement les instances directes de l'enfant dans la définition parente\n        child_instances_in_def = [\n            obj_id for obj_id in definition_objects\n            if rs.IsBlockInstance(obj_id) and rs.BlockInstanceName(obj_id) == child_block_name\n        ]\n\n\n        # 4. Appliquer la compensation (X_comp) à chaque instance enfant interne\n        for inst_id_in_def in child_instances_in_def:\n            selective_update_block_def(parent_name, inst_id_in_def, xform_compensation)\n\n\n        # 5. Vérification debug : s'assurer que les objets non-blocs n'ont pas bougé\n        for obj_id, old_pt in pre_positions.items():\n            bbox = rs.BoundingBox(obj_id)\n            if bbox:\n                new_pt = rs.PointCoordinates(bbox[0])\n                dx, dy, dz = new_pt[0]-old_pt[0], new_pt[1]-old_pt[1], new_pt[2]-old_pt[2]\n                dist = (dx**2 + dy**2 + dz**2)**0.5\n                if dist > 1e-9:  # tolérance minimale\n                    print(\"WARNING: Objet imbriqué %s a bougé de %.9f unités !\" % (obj_id, dist))\n\n\n        # 6. Récursion vers le parent\n        PropagateUpwardCompensation(parent_name, xform_compensation, visited_defs)\n\n\n# ----------------------------------------------------------------------\n\n\n## ⚙️ Fonction Principale d'Exécution (`editBlockXform`)\n\n\ndef editBlockXform():\n    # 1. Sélection de la Cible\n    sel_tar_insts = rs.GetObjects(\"Choisir les instances de bloc cible\", rs.filter.instance, preselect=True)\n    if not sel_tar_insts: return 0\n\n\n    # 2. Sélection de la Source (logique simplifiée)\n    sel_ori_insts = rs.GetObjects(\"Choisir un Bloc Source (ou appuyer sur Entrée pour utiliser l'Origine Mondiale)\", rs.filter.instance, maximum_count=1)\n\n\n    if sel_ori_insts is None or sel_ori_insts is True:\n        soiXform = rs.XformIdentity() # T_source\n    elif isinstance(sel_ori_insts, list) and len(sel_ori_insts) > 0 and rs.IsBlockInstance(sel_ori_insts[0]):\n        soiXform = rs.BlockInstanceXform(sel_ori_insts[0]) # T_source\n    else:\n        return 0\n\n\n    rs.EnableRedraw(False)\n    \n    # 3. Traitement par Définition\n    sel_per_def = {}\n    for sti in sel_tar_insts:\n        objref = rs.coercerhinoobject(sti)\n        idef = objref.InstanceDefinition\n        sel_per_def.setdefault(idef.Index, []).append(sti)\n\n\n    target_defs_to_process = {\n        idef_index: instances[-1]\n        for idef_index, instances in sel_per_def.items()\n    }\n\n\n    for idef_index, sti_for_calc in target_defs_to_process.items():\n        # print(('DEBUG: processing definition index', idef_index, 'using instance', sti_for_calc))\n        \n        stiXform = rs.BlockInstanceXform(sti_for_calc) # T_cible_original\n        if stiXform is None: continue\n        \n        # --- CALCUL DES TRANSFORMATIONS ---\n        \n        # X_def = T_source^-1 * T_cible_original\n        inv_soiXform = rs.XformInverse(soiXform)\n        if inv_soiXform is None: continue\n        def_update = rs.XformMultiply(inv_soiXform, stiXform) # X_def\n\n\n        # X_comp = X_def^-1\n        inv_def = rs.XformInverse(def_update) # X_comp\n        if inv_def is None: continue\n        \n        # 4. Modification de la Définition de la Cible (Def A)\n        ok = update_block_def(sti_for_calc, def_update)\n        if not ok: continue\n        \n        # 5. Compensation Ascendante des Blocs Imbriqués\n        initial_block_name = rs.BlockInstanceName(sti_for_calc)\n        # print(\"DEBUG: Starting UPWARD propagation/compensation (SAFE METHOD) for nested blocks.\")\n        PropagateUpwardCompensation(initial_block_name, inv_def) # inv_def est X_comp\n        # print(\"DEBUG: Upward propagation/compensation complete.\")\n\n\n\n\n        # 6. Compensation des Instances Sœurs (et Cible)\n        blockName = rs.BlockInstanceName(sti_for_calc)\n        bro_tar_insts = rs.BlockInstances(blockName) or []\n        \n        pre_xforms = {}\n        # Récupérer T_old pour toutes les instances (T_old n'est pas affecté par ModifyGeometry)\n        for bti in bro_tar_insts:\n            pre_xforms[bti] = rs.BlockInstanceXform(bti) \n        \n        for bti in bro_tar_insts:\n            T_old = pre_xforms.get(bti)\n            if T_old is None: continue\n\n\n            if bti.Equals(sti_for_calc):\n                # CIBLE : La transformation finale désirée est T_source\n                desired_T = soiXform \n            else:\n                # SŒUR : La transformation finale désirée est T_new = X_comp * T_old\n                desired_T = rs.XformMultiply(T_old, inv_def) \n            \n            # Calcul X_apply : X_apply = desired_T * T_old^-1\n            inv_T_old = rs.XformInverse(T_old)\n            if inv_T_old is None: continue\n\n\n            X_apply = rs.XformMultiply(desired_T, inv_T_old)\n\n\n            if not X_apply.IsIdentity:\n                # Appliquer X_apply à l'instance (False = transformation de l'objet)\n                rs.TransformObject(bti, X_apply, False)\n\n\n\n\n    rs.EnableRedraw(True)\n    return 1\n\n\nif __name__ == '__main__':\n    editBlockXform()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}