{
  "source_url": "https://github.com/dbt-ethz/Axolotl_Python/blob/0938046ecc5e50645d241a330b57734767958b07/code/iOctree.py",
  "repo": "dbt-ethz/Axolotl_Python",
  "repo_stars": 59,
  "repo_description": "Volumetric Modelling components for Rhino Grasshopper.",
  "license": "unknown",
  "filepath": "code/iOctree.py",
  "instruction": "Creates a sparse voxel octree (SVO) subdivision.\n    Inputs:\n        x: the sdf object used for distance calculation\n        p: the center point of the root node (default: 0,0,0)\n        d: the edge...",
  "code": "\"\"\"Creates a sparse voxel octree (SVO) subdivision.\n    Inputs:\n        x: the sdf object used for distance calculation\n        p: the center point of the root node (default: 0,0,0)\n        d: the edge length of the root node (default: 6.0)\n        n: the maximum number of subdivisions (default: 4)\n    Output:\n        t: the octree object, t.leafs is a list of leaf nodes (for MC meshing)\"\"\"\n\n__author__     = ['Mathias Bernhard']\n__copyright__  = 'Copyright 2018 / Digital Building Technologies DBT / ETH Zurich'\n__license__    = 'MIT License'\n__email__      = ['<bernhard@arch.ethz.ch>']\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nfrom math import sqrt\n\nclass OcTree(object):\n    \"\"\"\n    sparse voxel octree (SVO) class for adaptive subdivision\n    \"\"\"\n    def __init__(self, pt, ws):\n        self.worldsize = float(ws)\n        self.maxlevels = 3\n        #self.sqrt2 = sqrt(2.0)\n        self.sqrt3 = sqrt(3.0)\n        self.pos = pt\n        self.rootnode = OctNode(pt.X,pt.Y,pt.Z, ws, 0)\n        self.distobj = None\n        self.leafs = []\n\n    def set_level(self, n):\n        self.maxlevels = int(n)\n\n    def divide(self, node):\n        d = self.distobj.get_distance(node.pos.X, node.pos.Y, node.pos.Z)\n        node.distance = d\n\n        if node.level < self.maxlevels:\n            if abs(d) < self.sqrt3 * node.edge/2.0:\n                node.divide_node()\n                for b in node.branches:\n                    self.divide(b)\n        else:\n            if abs(node.distance) < self.sqrt3 * node.edge/2.0:\n                self.leafs.append(node)\n\nclass OctNode(object):\n    \"\"\"\n    node of octree that is either leaf node\n    or has 8 child nodes as branches\n    \"\"\"\n    def __init__(self, x,y,z, s, l):\n        self.pos = rg.Vector3f(x,y,z)\n        self.edge = s\n        self.level = l\n        self.branches = None\n        self.distance = 0.0\n\n    def divide_node(self):\n        self.branches = []\n        qs = self.edge/4.0\n        nl = self.level + 1\n        self.branches.append(OctNode(self.pos.X-qs, self.pos.Y-qs, self.pos.Z-qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X+qs, self.pos.Y-qs, self.pos.Z-qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X-qs, self.pos.Y+qs, self.pos.Z-qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X+qs, self.pos.Y+qs, self.pos.Z-qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X-qs, self.pos.Y-qs, self.pos.Z+qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X+qs, self.pos.Y-qs, self.pos.Z+qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X-qs, self.pos.Y+qs, self.pos.Z+qs, qs*2, nl))\n        self.branches.append(OctNode(self.pos.X+qs, self.pos.Y+qs, self.pos.Z+qs, qs*2, nl))\n\nif __name__==\"__main__\":\n    if x is not None:\n        if p is None:\n            p = rg.Point3f(0,0,0)\n        if d is None:\n            d = 6.0\n        if n is None:\n            n = 4\n        t = OcTree(p,d)\n        t.distobj = x\n        t.set_level(n)\n        t.divide(t.rootnode)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}