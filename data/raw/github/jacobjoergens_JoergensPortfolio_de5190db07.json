{
  "source_url": "https://github.com/jacobjoergens/JoergensPortfolio/blob/7d291f65cb636ddde424bf5903a949b0770d4d86/joergens-portfolio/app/(categories)/computational-design/min-rect-partition/ingest.py",
  "repo": "jacobjoergens/JoergensPortfolio",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "joergens-portfolio/app/(categories)/computational-design/min-rect-partition/ingest.py",
  "instruction": "Ingest",
  "code": "import compute_rhino3d.Util\nimport compute_rhino3d.AreaMassProperties\nimport numpy as np\nimport rhino3dm as rh\nimport operator\n\ncompute_rhino3d.Util.url = \"http://18.222.210.44:80/\"\ncompute_rhino3d.Util.apiKey = \"TMqHt.2h;4q8cakYAroEMD&KmXUKw5qB\"\n\n\"\"\"\nDescription:\n-a Corner is a data structure that stores information on the vertices between edges of an input curve\n\"\"\"\nclass Corner:\n\n    \"\"\"\n    Description: defines a corner object\n    Parameters: \n        -vertex (Rhino.Geometry.Point3D): a point defined by x, y and z components\n        -leg_a, leg_b (Rhino.Geometry.Line): a line defined by start and end points\n    Assignments: \n        -leg_a: corner's trailing edge\n        -leg_b: corner's forward edge\n        -horizontal/vertical: calculates and stores which leg is which\n        -prev/next (corners): null (by default)\n        -concave: false (by default)\n    \"\"\"\n    #TODO Look into making subclasses for prev and next that store edge and hor/ver info\n    def __init__(self, leg_a, vertex, leg_b):\n        self.prev = None\n        self.vertex = vertex\n        self.next = None\n        self.prev_edge = leg_a\n        self.next_edge = leg_b\n        self.assignLegs(leg_a,leg_b)\n        self.concave = False \n        self.list_index = None\n        self.index = None\n    \"\"\"\n    Description: assigns a pair of edges horizontal/vertical labels, there will always be one of each\n    Parameters: leg_a, leg_b (Rhino.Geometry.Line)\n    Output: vertical, horizontal (Rhino.Geometry.Line) \n    \"\"\"\n    def assignLegs(self,leg_a,leg_b):\n        endpts = [leg_a[0], leg_a[1]]\n        if(endpts[0][0]==endpts[1][0]):\n            vertical = leg_a\n            horizontal = leg_b\n        else: \n            vertical = leg_b \n            horizontal = leg_a\n        self.vertical = vertical\n        self.horizontal = horizontal\n\n\"\"\"\nDescription: a doubly-linked list of Corner objects corresponding to the vertices of a single curve\n\"\"\"\nclass cornerList: \n    \"\"\"\n    Description: initiate an empty doubly-linked list \n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.length = 0\n        self.concave_count = 0 \n        self.exterior = False #true if this corner list represents is an exterior curve\n        self.horizontal_edges = set()\n        self.vertical_edges = set()\n\n    \"\"\"\n    Description: appends a new Corner to the end of the doubly-linked list\n    Parameters: new_corner (Corner)\n    \"\"\"    \n    def make(self, new_corner, list_index): \n        if(self.tail==None):  #if the list is empty set head and tail to new_corner\n            self.head = new_corner\n            self.tail = new_corner\n        else: #otherwise follow logic to insert new_corner at end\n            new_corner.prev = self.tail #link new_corner to current tail\n            self.tail.next = new_corner \n            self.tail = new_corner #update tail to new_corner\n            self.tail.next = self.head #link new_corner to head\n            self.head.prev = self.tail\n        new_corner.index = self.length\n        self.length+=1 \n        self.horizontal_edges.add(new_corner.horizontal)\n        self.vertical_edges.add(new_corner.vertical)\n        new_corner.list_index = list_index\n\n    \"\"\"\n    Description: insert a new Corner between any two extant corners\n    Parameters: \n        -prev_corner (Corner): update the \"next\" attributes of an existing corner to match new_corner's\n        -corner (Corner): a new corner with prev_edge and next_edge predefined\n        -next_corner (Corner): update the \"prev\" attributes of an existing corner to match new_corner's\n    \"\"\"\n    def stitch(self, prev_corner, corner, next_corner, new): \n        #handle horizontal/vertical pointers\n        horver = [\"horizontal\",\"vertical\"] \n        if(getattr(next_corner,horver[0])!=next_corner.prev_edge):\n            horver = horver[::-1]\n        #link next_corner to new_corner\n        next_corner.prev = corner\n        next_corner.prev_edge = corner.next_edge\n        corner.next = next_corner\n        #link prev_corner to new_corner\n        prev_corner.next = corner\n        prev_corner.next_edge = corner.prev_edge\n        corner.prev = prev_corner\n        #update horizontal/vertical attributes\n        # setattr(next_corner,horver[0],new_corner.next_edge)\n        # setattr(prev_corner,horver[1],new_corner.prev_edge)\n        next_corner.assignLegs(next_corner.prev_edge,next_corner.next_edge)\n        prev_corner.assignLegs(prev_corner.prev_edge,prev_corner.next_edge)\n        if(not new):\n            corner.assignLegs(corner.prev_edge, corner.next_edge)\n\n    \"\"\"\n    Description: traverse list and recount/update list-level attributes\n    \"\"\"  \n    def updateState(self,list_index):\n        start = self.head\n        start.index = 0 \n        start.list_index = list_index\n        current_corner = start.next\n        #reset list-level attributes\n        self.length = 1\n        self.concave_count = 1*start.concave\n        self.horizontal_edges = {start.horizontal}\n        self.vertical_edges = {start.vertical}\n        #traverse and update\n        while current_corner != start:\n            self.concave_count+=1*current_corner.concave\n            self.horizontal_edges.add(current_corner.horizontal)\n            self.vertical_edges.add(current_corner.vertical)\n            current_corner.index = self.length\n            current_corner.list_index = list_index\n            self.length+=1\n            current_corner = current_corner.next\n    \n    \"\"\"\n    Description: debugging helper function, traverses a given cornerList and outputs two arrays holding edges and vertices\n    Parameters: \n        -corners (cornerList)\n    Output: \n        -edges (list): array of line segments\n        -vertices (list): array of vertices\n    \"\"\"\n    def iterLoop(self): \n        current_corner = self.head\n        edges = []\n        vertices = []\n        \n        for i in range(self.length):\n            edges.append(current_corner.next_edge)\n            vertices.append(current_corner.vertex)\n            current_corner = current_corner.next\n        return edges, vertices\n    \n    def copyList(self, conversionTable):\n        newList = cornerList()\n        current_corner = self.head\n        for i in range(self.length): \n            new_corner = Corner(current_corner.prev_edge,current_corner.vertex,current_corner.next_edge)\n            new_corner.concave = current_corner.concave\n            newList.make(new_corner,current_corner.list_index)\n            conversionTable[current_corner] = new_corner\n            current_corner = current_corner.next\n        newList.concave_count = self.concave_count\n        return newList\n    \n\nclass Intersection:\n    def __init__(self,point,l1,l2):\n        self.point = point\n        self.l1 = l1\n        self.l2 = l2\n\n\"\"\"\nDescription: get the xy extents of the input geometry\nParameters: vertices (list): a list of vertices from an input curve\nOutputs: \n    -bottom_left_index (number): the index of the input param corresponding to the bottom-left vertex\n    -max_extent (string): indicates which side of a hypothetical bounding rectangle is greatest\n\"\"\"        \ndef calculateExtents(vertices):\n    sorted_indices = [i[0] for i in sorted(enumerate(vertices), key=lambda x:(x[1][0],x[1][1]))]\n    bottom_left_index = sorted_indices[0]\n    return bottom_left_index\n\n\"\"\"\nDescription: build corner_lists from input curves \nParameters: curves (list of Rhino.Geometry.NurbsCurves)\nOutput: \n    -corner_lists (list of cornerLists): \n        I. create a cornerList for each input curve\n            a. construct Corners from each vertex\n                i. determine whether a given vertex is concave\n    -max_extent: prevailing dimension of the input curves\n\"\"\"    \ndef digestCurves(curve_data):\n    curves = []\n    input_vertices = []\n    input_edges = []\n    areas = np.array([])\n    for i in range(len(curve_data)):\n        points = rh.Point3dList(len(curve_data[i]))\n        input_vertices.append([])\n        input_edges.append([])# curves.append(rh.NurbsCurve.Create(False, 1, json_dict[points]))\n        for j in range(len(curve_data[i])):\n            points.Add(*curve_data[i][j])\n            input_vertices[i].append(tuple(curve_data[i][j]))\n            if(j>0):\n                input_edges[i].append((input_vertices[i][j-1],input_vertices[i][j]))\n        curves.append(rh.NurbsCurve.Create(False,1,points))\n        areas = np.append(areas, compute_rhino3d.AreaMassProperties.Compute(curves[i])['Area'])\n    \n\n    corner_lists = []\n    #push largest curve to index 0 \n    if(len(curves)>1):\n        max_area_index = np.argmax(areas)\n        if(max_area_index!=0):\n            curves.insert(0,curves.pop(max_area_index))\n            input_vertices.insert(0,input_vertices.pop(max_area_index))\n            input_edges.insert(0,input_edges.pop(max_area_index))\n\n    for i in range(len(curves)): #loop through curves\n        vertices = input_vertices[i]\n        edges = input_edges[i]\n        corner_lists.append(cornerList()) \n        vertices.pop(-1) #if an input curve is closed (which it must be) then the last vertex is the same as the first\n        \n        #the bottom leftmost vertex must be convex \n        leftmost = calculateExtents(vertices)\n        if(i==0): \n            corner_lists[0].exterior = True #set the curve with greatest area to be an exterior curve\n            # max_extent = extent #set max_extent from prevailing dimension of the largest curve\n\n        #calculate the direction at the bottom leftmost vertex from the input curve \n        trailing = edges[(leftmost-1)%len(vertices)]\n        leading = edges[leftmost%len(vertices)]\n        cross1 = lambda x,y:np.cross(x,y)\n        cross = cross1(np.array(trailing[1])-np.array(trailing[0]),np.array(leading[1])-np.array(leading[0]))[2]\n        rhrule = cross/abs(cross)\n        #set direction conventions \n        if((corner_lists[i].exterior==True and rhrule==-1) or (corner_lists[i].exterior==False and rhrule==1)):\n            flow = -1\n        else: \n            flow = 1\n\n        for j in range(len(vertices)): #loop through vertices in input curve (backwards if flow is -1) \n            V = vertices[(leftmost+j*flow)%len(vertices)] \n            \n            if(flow==-1):\n                next_edge = edges[(leftmost+(j+1)*flow)%len(vertices)]\n                prev_edge = edges[(leftmost+j*flow)%len(vertices)]\n            else:\n                next_edge = edges[(leftmost+j*flow)%len(vertices)]\n                prev_edge = edges[(leftmost+(j-1)*flow)%len(vertices)]\n\n            #perform right-hand rule at each vertex\n            z = cross1(np.array(prev_edge[1])-np.array(prev_edge[0]),np.array(next_edge[1])-np.array(next_edge[0]))\n            z = z/np.linalg.norm(z)\n            dot = np.dot(z,np.array([0,0,1]))\n            # labelled_edges.append(sorted(gh.EndPoints(next_edge),key=lambda coor: (coor[0],coor[1])))\n            new_corner = Corner(prev_edge, V, next_edge)\n            \n            #if the direction is not the same as the first vertex, then this vertex is concave\n            if(dot==-1):\n                # concave.append(V)\n                new_corner.concave=True\n                corner_lists[i].concave_count+=1\n\n            #add new corner to cornerList\n            corner_lists[i].make(new_corner, i)\n    \n    return corner_lists\n\n\"\"\"\nDescription: traverse through corner_lists and append concave corners to output array\nParameters: corner_lists (list of cornerLists)\nOutput: concave_corners (list of Corners)\n\"\"\"\ndef findConcaveVertices(corner_lists):\n    concave_corners = []\n    i = 0\n    for list in corner_lists:\n        current_corner = list.head\n        if(current_corner.concave):\n            concave_corners.append(current_corner)\n        current_corner = current_corner.next\n        while(current_corner!=list.head):\n            if(current_corner.concave):\n                concave_corners.append(current_corner)\n            current_corner = current_corner.next\n        i+=1\n    return concave_corners\n\ndef sortTransverseSegments(corner, corner_lists, dir, oper, strict=False):\n    edges = []\n    opdir = (dir+1)%2\n    intersection_corner = None\n    intersection_list = None\n    ext_length = None\n    for corner_list in corner_lists: \n        if(dir==0): #direction of extension\n            relevant = \"vertical_edges\"\n        else: \n            relevant = \"horizontal_edges\"\n        if(strict):\n            overlap = lambda seg: oper(seg[0][dir],corner.vertex[dir]) and min(seg[0][opdir],seg[1][opdir])<=corner.vertex[opdir]<=max(seg[0][opdir],seg[1][opdir])\n        else: \n            overlap = lambda seg: oper(seg[0][dir],corner.vertex[dir]) and min(seg[0][opdir],seg[1][opdir])<corner.vertex[opdir]<max(seg[0][opdir],seg[1][opdir])\n        \n        edges.extend(list(filter(overlap,list(getattr(corner_list,relevant)))))\n        \n    if(oper==operator.gt):\n        edges.sort(key=lambda seg:seg[0][dir])\n    else:\n        edges.sort(key=lambda seg:-seg[0][dir])\n    if(len(edges)>0):\n        for i in range(len(corner_lists)):\n            if(edges[0] in getattr(corner_lists[i],relevant)):\n                intersection_list=i\n                # #9/13: handle case where nearest edge is not the right one\n                # print('edges[0]:',edges[0][0],edges[0][1],corner.vertex)\n                # if(edges[0][0][opdir]==corner.vertex[opdir] or edges[0][1][opdir]==corner.vertex[opdir]):\n                #     farthest_exact_edge = edges[-1]\n                #     print(farthest_exact_edge)\n                #     while(len(edges)>1):\n                #         if(farthest_exact_edge[0][opdir]==corner.vertex[opdir] or farthest_exact_edge[1][opdir]==corner.vertex[opdir]):\n                #             edges = [farthest_exact_edge]\n                #         else: \n                #             farthest_exact_edge = edges.pop()\n                # print(edges[0])\n                ext_length = abs(corner.vertex[dir]-edges[0][0][dir])\n                break\n        current_corner = corner_lists[intersection_list].head\n        for j in range(corner_lists[intersection_list].length):\n            if(current_corner.next_edge==edges[0]):\n                intersection_corner=current_corner\n                break\n            current_corner = current_corner.next\n    return intersection_corner, ext_length, intersection_list\n\n\"\"\"\nDescription: within a given list of concave vertices, find colinear pairs for degenerate decomposition\nParameters: concave_corners (list of Corners)\nOutput: colinear_pairs (dictionary): colinear pairs stored under appropriate horizontal/vertical key\n\"\"\"\ndef findColinearVertices(corner_lists, concave_corners, dir):\n    opdir = (dir+1)%2\n    horver = ['horizontal','vertical']\n    colinear_chords = []\n    colinear_dict = {}\n    for corner in concave_corners:\n        coor = round(corner.vertex[opdir],6)\n        if(coor not in colinear_dict):\n            colinear_dict[coor]=[]\n        colinear_dict[coor].append(corner)\n\n    while(len(concave_corners)>0):\n        colinear_array = colinear_dict[round(concave_corners[0].vertex[opdir],6)]\n        a_corner = colinear_array[0]\n        if(getattr(a_corner,horver[dir])==a_corner.next_edge):\n            extension = np.array(a_corner.vertex)-np.array(a_corner.next.vertex)\n        else: \n            extension = np.array(a_corner.vertex)-np.array(a_corner.prev.vertex)\n        ext_dot = np.dot(extension,np.array([1,1,1]))\n        if(ext_dot<0):\n            oper = operator.lt\n        else:\n            oper = operator.gt\n        b_corners = list(filter(lambda corner: oper(corner.vertex[dir],a_corner.vertex[dir]),colinear_array[1:]))\n        if(len(b_corners)>0):\n            b_corners = sorted(b_corners, key=lambda corner:(ext_dot/np.linalg.norm(ext_dot))*corner.vertex[dir])\n            b_corner = b_corners[0]\n            pair_vect = np.array(b_corner.vertex)-np.array(a_corner.vertex)\n            __, ext_length, __ = sortTransverseSegments(a_corner, corner_lists, dir, oper, True)\n            \n            if(ext_length and ext_length>=abs(pair_vect[dir])):\n                colinear_chords.append((a_corner,b_corner))\n                colinear_array.remove(a_corner)\n                colinear_array.remove(b_corner)\n                concave_corners.remove(a_corner)\n                concave_corners.remove(b_corner)\n            else:\n                colinear_array.remove(a_corner)\n                concave_corners.remove(a_corner)\n        else: \n            colinear_array.remove(a_corner)\n            concave_corners.remove(a_corner)\n    # print(len(colinear_chords))\n    return colinear_chords\n\ndef findIntersections(horizontal_chords,vertical_chords):\n    intersections = []\n    h_remove = set()\n    v_remove = set()\n    for i in reversed(range(len(horizontal_chords))):\n        iter_pts = [horizontal_chords[i][0].vertex,horizontal_chords[i][1].vertex]\n        iter_pts.sort(key=lambda coor:coor[0])\n        for j in reversed(range(len(vertical_chords))):\n            compare_pts = [vertical_chords[j][0].vertex,vertical_chords[j][1].vertex]\n            compare_pts.sort(key=lambda coor:coor[1])\n            if(round(iter_pts[0][0],6)<=round(compare_pts[0][0],6)<=round(iter_pts[1][0],6)): \n                if(round(compare_pts[0][1],6)<=round(iter_pts[0][1],6)<=round(compare_pts[1][1],6)):\n                    pt = rh.Point3d(compare_pts[0][0],iter_pts[0][1],0)\n                    intersect = [horizontal_chords[i], vertical_chords[j], {\"point\":pt}]\n                    h_remove.add(horizontal_chords[i])\n                    v_remove.add(vertical_chords[j])\n                    intersections.append(intersect)\n\n    for chord in h_remove:\n        horizontal_chords.remove(chord)\n    for chord in v_remove:\n        vertical_chords.remove(chord)\n\n    return intersections",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "rhino3dm"
  ],
  "has_docstring": false
}