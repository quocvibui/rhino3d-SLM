{
  "source_url": "https://github.com/Antonios-M/CORE_2024/blob/066107462de0f0059a77fc480c2f60b22496cf85/src/robotic_assembly/UR5Kinematics.py",
  "repo": "Antonios-M/CORE_2024",
  "repo_stars": 2,
  "repo_description": "CORE 2024",
  "license": "unknown",
  "filepath": "src/robotic_assembly/UR5Kinematics.py",
  "instruction": "Import necessary modules",
  "code": "# Import necessary modules\nimport robolink as rl          # RoboDK API for communication with RoboDK software\nimport robodk as rdk           # RoboDK modeling and simulation library\nimport Rhino.Geometry as rg    # Rhino.Geometry for handling geometric entities in Rhino\nimport math                    # Math module for mathematical functions\nimport numpy as np             # NumPy for numerical computations\n\n# === Inputs ===\n# RobotName: Name of the robot in RoboDK (e.g., \"UR5\")\n\n# Initialize output variables\nRobotPosition = None   # Will store the position of the robot's Tool Center Point (TCP)\nX_Axis = None          # Will store a line representing the robot's TCP X-axis\nY_Axis = None          # Will store a line representing the robot's TCP Y-axis\nZ_Axis = None          # Will store a line representing the robot's TCP Z-axis\nJointPoints = []       # List to store the positions of each joint\nJointLines = []        # List to store lines connecting the joints\nTCPPlane = None        # Plane representing the TCP's orientation\nSuccessMessage = \"\"    # Message indicating success or error\n\n# Initialize a connection to RoboDK\nRDK = rl.Robolink()\n\n# Retrieve the robot item from RoboDK by its name\nrobot = RDK.Item(RobotName, rl.ITEM_TYPE_ROBOT)\n\n# Check if the robot item is valid\nif not robot.Valid():\n    # If the robot is not found, set an error message\n    SuccessMessage = f\"Error: Could not find {RobotName} in RoboDK.\"\nelse:\n    # If the robot is found, set a success message\n    SuccessMessage = f\"Connected to {RobotName} in RoboDK.\"\n\n    # Retrieve the robot's base item (parent item)\n    robot_base = robot.Parent()\n    if robot_base.Valid():\n        # If the base is valid, get its pose (transformation matrix)\n        base_pose = robot_base.Pose()\n    else:\n        # If not, use an identity matrix as the base pose\n        base_pose = rdk.Mat()\n\n    # Get the robot's current joint angles in degrees\n    joints_deg = robot.Joints().list()\n    # Convert joint angles from degrees to radians for computation\n    joints_rad = [math.radians(angle) for angle in joints_deg]\n\n    # Define the UR5 robot's standard Denavit-Hartenberg (DH) parameters in millimeters\n    d1 = 89.159     # Offset along previous Z to the common normal\n    a2 = -425.00    # Length of the common normal (negative due to robot configuration)\n    a3 = -392.25    # Length of the common normal (negative due to robot configuration)\n    d4 = 109.15     # Offset along previous Z to the common normal\n    d5 = 94.65      # Offset along previous Z to the common normal\n    d6 = 82.3       # Offset along previous Z to the end effector\n\n    # DH parameters: alpha (twist angles), a (link lengths), d (link offsets), theta (joint angles)\n    alpha = [math.pi/2, 0, 0, math.pi/2, -math.pi/2, 0]   # Twist angles between links\n    a = [0, a2, a3, 0, 0, 0]                              # Link lengths\n    d = [d1, 0, 0, d4, d5, d6]                            # Link offsets\n    theta = joints_rad                                     # Joint angles from the robot\n\n    # Convert the base pose to a NumPy array for matrix operations\n    T_base = np.array(base_pose.rows)\n    # Ensure that the base transformation matrix is 4x4\n    if T_base.shape != (4, 4):\n        # Append an error message if the matrix is not 4x4\n        SuccessMessage += \" Error: Base pose matrix is not 4x4.\"\n    else:\n        # Initialize the overall transformation matrix with the base pose\n        T = T_base\n\n        # Initialize a list to store the positions of each joint\n        JointPoints = []\n\n        # Initialize a list to store the transformation matrix of each joint\n        T_matrices = []\n\n        # Compute the transformation for each of the six joints using the DH parameters\n        for i in range(6):\n            # Extract DH parameters for the current joint\n            ai = a[i]\n            alphai = alpha[i]\n            di = d[i]\n            thetai = theta[i]\n\n            # Compute trigonometric functions for efficiency\n            cos_theta = math.cos(thetai)\n            sin_theta = math.sin(thetai)\n            cos_alpha = math.cos(alphai)\n            sin_alpha = math.sin(alphai)\n\n            # Create the transformation matrix from the previous joint to the current joint\n            T_joint = np.array([\n                [cos_theta, -sin_theta * cos_alpha,  sin_theta * sin_alpha, ai * cos_theta],\n                [sin_theta,  cos_theta * cos_alpha, -cos_theta * sin_alpha, ai * sin_theta],\n                [0,          sin_alpha,              cos_alpha,             di],\n                [0,          0,                      0,                     1]\n            ])\n\n            # Update the overall transformation matrix by multiplying with the current joint's matrix\n            T = np.dot(T, T_joint)\n\n            # Save the transformation matrix for this joint\n            T_matrices.append(T.copy())\n\n            # Extract the position of the current joint from the transformation matrix\n            position = T[:3, 3]  # Get the x, y, z coordinates\n\n            # Create a Point3d object for the joint position\n            joint_point = rg.Point3d(position[0], position[1], position[2])\n            # Add the joint position to the list\n            JointPoints.append(joint_point)\n\n        # Create lines connecting the joints for visualization\n        JointLines = []\n        for i in range(1, len(JointPoints)):\n            # Create a line from the previous joint to the current joint\n            line = rg.Line(JointPoints[i - 1], JointPoints[i])\n            # Add the line to the list\n            JointLines.append(line)\n\n        # Optionally, connect the robot base to the first joint\n        if JointPoints:\n            # Get the base position from the base transformation matrix\n            base_position = T_base[:3, 3]\n            base_point = rg.Point3d(base_position[0], base_position[1], base_position[2])\n            # Create a line from the base to the first joint\n            line = rg.Line(base_point, JointPoints[0])\n            # Insert the line at the beginning of the JointLines list\n            JointLines.insert(0, line)\n\n        # Retrieve the robot's pose relative to its base (end-effector pose)\n        robot_pose = robot.Pose()\n\n        # Compute the absolute pose of the TCP (Tool Center Point) in the world coordinate system\n        absolute_pose = base_pose * robot_pose\n\n        # Extract the TCP position from the absolute pose\n        position = absolute_pose.Pos()  # Get the x, y, z coordinates\n\n        # Create a Point3d object for the TCP position\n        RobotPosition = rg.Point3d(position[0], position[1], position[2])\n\n        # Extract orientation vectors (axes) from the rotation matrix of the absolute pose\n        x_vector = rg.Vector3d(absolute_pose[0, 0], absolute_pose[1, 0], absolute_pose[2, 0])  # X-axis\n        y_vector = rg.Vector3d(absolute_pose[0, 1], absolute_pose[1, 1], absolute_pose[2, 1])  # Y-axis\n        z_vector = rg.Vector3d(absolute_pose[0, 2], absolute_pose[1, 2], absolute_pose[2, 2])  # Z-axis\n\n        # Create a plane at the TCP position with the extracted orientation vectors\n        TCPPlane = rg.Plane(RobotPosition, x_vector, y_vector)\n\n        # Scale the orientation vectors for visualization purposes\n        scale_factor = 200  # Adjust this value as needed for your visualization\n        x_vector *= scale_factor\n        y_vector *= scale_factor\n        z_vector *= scale_factor\n\n        # Create lines representing the robot's TCP axes\n        X_Axis = rg.Line(RobotPosition, rg.Point3d(RobotPosition + x_vector))\n        Y_Axis = rg.Line(RobotPosition, rg.Point3d(RobotPosition + y_vector))\n        Z_Axis = rg.Line(RobotPosition, rg.Point3d(RobotPosition + z_vector))\n\n        # Optionally, connect the last joint to the TCP position\n        if JointPoints and RobotPosition:\n            # Create a line from the last joint to the TCP\n            line = rg.Line(JointPoints[-1], RobotPosition)\n            # Add the line to the list of joint lines\n            JointLines.append(line)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}