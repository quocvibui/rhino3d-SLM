{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/windows.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/windows.py",
  "instruction": "Windows",
  "code": "import rhinoscriptsyntax as rs\nimport Rhino\nimport ghpythonlib.components as ghc\nimport Grasshopper.Kernel as ghK\nimport json\nimport math\nfrom collections import namedtuple\nfrom itertools import izip\nfrom System import Object\n\nimport LBT2PH\nimport LBT2PH.helpers\nimport LBT2PH.helpers_geometry\nimport LBT2PH.shading\n\nreload(LBT2PH.helpers)\nreload(LBT2PH.helpers_geometry)\nreload( LBT2PH.shading )\n\ntry:  # import the core honeybee dependencies\n    from ladybug_geometry.geometry3d.line import LineSegment3D\n    from ladybug_geometry.geometry3d.face import Face3D\n    from ladybug_rhino.fromgeometry import from_face3d, from_linesegment3d\n    from ladybug_rhino.togeometry import to_face3d, to_point3d    \n    from honeybee.aperture import Aperture\n    from honeybee.typing import clean_and_id_ep_string\n    from honeybee_energy.material.glazing import EnergyWindowMaterialSimpleGlazSys\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\nclass PHPP_Window(Object):\n    '''A PHPP Style 'Window'.\n\n    Args:\n        _aperture: A LadybugTools 'aperture' object\n    Properties:\n        *'quantity'\n        * 'aperture',\n        * '_tolerance'\n        * '_glazing_edge_lengths'\n        * '_window_edges'\n        * '_glazing_surface'\n        * '.UD_glass_Name'\n        * 'UD_frame_Name'\n        * 'variant_type'\n        * '_shading_factor_winter'\n        * '_shading_factor_summer'\n        * 'shading_dimensions'\n        * 'frame'\n        * 'glazing'\n        * 'installs'\n        * 'install_depth' \n    '''\n    __slots__ = ('quantity', 'aperture',\n        '_tolerance', '_glazing_edge_lengths', '_window_edges', '_glazing_surface',\n        '_shading_factor_winter', '_shading_factor_summer', 'shading_dimensions',\n        'name', 'frame', 'glazing', 'installs', 'install_depth', 'UD_glass_Name',\n        'UD_frame_Name', 'variant_type' )\n    \n    Output = namedtuple('Output', ['Left', 'Right', 'Bottom', 'Top'])\n\n    def __init__(self, _aperture=None):\n        self.quantity = 1\n        self.aperture = _aperture\n        self._tolerance = 0.01        \n        self._glazing_edge_lengths = None\n        self._window_edges = None\n        self._glazing_surface = None\n        self.UD_glass_Name = None\n        self.UD_frame_Name = None\n        self.variant_type = None\n        \n        self._shading_factor_winter = None\n        self._shading_factor_summer = None\n        self.shading_dimensions = None\n        \n        self.frame = None\n        self.glazing = None\n        self.installs = None\n        self.install_depth = None\n\n    @property\n    def name(self):\n        return self.aperture.display_name\n\n    @property\n    def window_edges(self):\n        \n        if self._window_edges:\n            return self._window_edges\n        else:\n            # First, try and use the simple Ladubug Veritcal / Horizontal methods\n            # If that doesn't work for any reason, those methods return 'None'\n            # If any are None, use the slower 'edges in order' method\n            result_verticals = self.aperture.geometry.get_left_right_vertical_edges(self._tolerance)\n            result_horizontals = self.aperture.geometry.get_top_bottom_horizontal_edges(self._tolerance)\n            \n            if result_verticals and result_horizontals:\n                window_left, window_right = result_verticals\n                window_top, window_bottom = result_horizontals\n                edges = self.Output(window_left, window_right, window_bottom, window_top)    \n            else:\n                edges = self._get_edges_in_order()\n\n            self._window_edges = edges\n            return edges\n\n    @property\n    def glazing_edge_lengths(self):\n        if self._glazing_edge_lengths:\n            return self._glazing_edge_lengths\n        else:\n            edges = self.window_edges\n            frame = self.frame\n\n            glazing_Left = edges.Left.length - frame.fTop - frame.fBottom\n            glazing_Right = edges.Right.length - frame.fTop - frame.fBottom\n            glazing_Bottom = edges.Bottom.length - frame.fLeft - frame.fRight\n            glazing_Top = edges.Top.length - frame.fLeft - frame.fRight\n\n            edge_lens = self.Output(glazing_Left, glazing_Right, glazing_Bottom, glazing_Top)\n            self._glazing_edge_lengths = edge_lens\n            return edge_lens\n\n    @property\n    def glazing_surface(self):\n        if self._glazing_surface:\n            return self._glazing_surface\n        else:\n            geom = self.inset_window_surface\n\n            frame_width = self.frame.fLeft # assumes all widths are the same!?\n            inset_srfc = LBT2PH.helpers_geometry.inset_rhino_surface(geom, frame_width, self.name)\n            \n            if isinstance(inset_srfc, list):\n                print('ERROR: Cannot properly generate glazing for window {}'.format(self.name))\n                print(\"Check the window's frame-type dimensions to make sure window size is not too small to inset?\")\n\n            self._glazing_surface = inset_srfc\n            \n            return inset_srfc\n\n    @property\n    def u_w_installed(self):\n        \n        frame = self.frame\n        glazing_edge_lens = self.glazing_edge_lengths\n        window_edges = self.window_edges\n        window_area = self.aperture.area\n        glazing_area = glazing_edge_lens.Left * glazing_edge_lens.Bottom\n        \n        # Correct for the corner overlap\n        corner_areas = []\n        corner_areas.append(frame.fLeft * frame.fTop + frame.fLeft * frame.fBottom)\n        corner_areas.append(frame.fRight* frame.fTop + frame.fRight * frame.fBottom)\n        corner_areas.append(frame.fLeft * frame.fBottom + frame.fRight * frame.fBottom)\n        corner_areas.append(frame.fLeft* frame.fTop + frame.fRight * frame.fTop)\n        frame_areas = ((e.length*w)-(0.5*ca) for e, w, ca in izip(window_edges, frame.frameWidths, corner_areas))\n\n        # Calc the heat-loss values for all the elements\n        hl_glazing = glazing_area * self.glazing.uValue\n        hl_frames = sum(a*u for a, u in izip(frame_areas, frame.uValues))\n        hl_glazing_edge = sum(e_len*psi_g for e_len, psi_g in izip(glazing_edge_lens, frame.PsiGVals))\n        hl_install_edge = sum(e.length*psi_i*i for e, psi_i, i in izip(window_edges, frame.PsiInstalls, self.installs))\n\n        u_w_installed = (hl_glazing + hl_frames + hl_glazing_edge + hl_install_edge) / window_area\n\n        return u_w_installed\n    \n    @property\n    def host_surface(self):\n        #return self.aperture.parent.display_name.replace('EXT_', '')\n        return self.aperture.parent.identifier.replace('EXT_', '')\n\n    @property\n    def height(self):\n        if not self._window_edges:\n            self.window_edges()\n        \n        left = self._window_edges.Left\n        return left.length\n\n    @property\n    def width(self):\n        if not self._window_edges:\n            # Build the edges from the aperture geometry\n            self.window_edges\n\n        top = self._window_edges.Top\n        return top.length\n\n    @property\n    def shading_factor_winter(self):\n        try:\n            return float(self._shading_factor_winter)\n        except Exception as e:\n            return 0.75\n\n    @shading_factor_winter.setter\n    def shading_factor_winter(self, _in):\n        try:\n            self._shading_factor_winter = float(_in)\n        except ValueError as e:\n            print(e)\n            print('Shading Factor must be a number.')\n\n    @property\n    def shading_factor_summer(self):\n        try:\n            return float(self._shading_factor_summer)\n        except Exception as e:\n            return 0.75\n    \n    @shading_factor_summer.setter\n    def shading_factor_summer(self, _in):\n        try:\n            self._shading_factor_summer= float(_in)\n        except ValueError as e:\n            print(e)\n            print('Shading Factor must be a number.')\n\n    @property\n    def rh_surface(self):\n        \"\"\"Get the LBT Aperture 'Face3d' as a Rhino surface\"\"\"\n        \n        if self.aperture:\n            lbt_face3d = self.aperture.geometry\n            rh_surface = from_face3d( lbt_face3d )\n            return rh_surface\n        else:\n            return None\n\n    @property\n    def surface_normal(self):\n        \"\"\" Convert the LBT normal to a real Rhino normal \"\"\"\n        \n        lbt_norm = self.aperture.normal\n        x = lbt_norm.x\n        y = lbt_norm.y\n        z = lbt_norm.z\n\n        return Rhino.Geometry.Vector3d(x, y, z)\n\n    @property\n    def reveal_geometry(self):\n        \"\"\"Create reveal (side) geometry for the window edges\"\"\"\n        \n        orientation = -1 # don't rememeber why this is.....\n        window_surface = self.rh_surface\n        if not window_surface:\n            return None\n\n        # ----------------------------------------------------------------------\n        # Get the inputs\n        edges = self._get_edges_in_order()\n        inst_depth = float(self.install_depth)\n        normal = self.surface_normal * orientation\n\n        # ----------------------------------------------------------------------\n        # Create the reveal geom        \n        bottom = self._extrude_reveal_edge(edges.Bottom, normal, inst_depth, self.installs.install_B)\n        left = self._extrude_reveal_edge(edges.Left, normal, inst_depth, self.installs.install_L)\n        top = self._extrude_reveal_edge(edges.Top, normal, inst_depth, self.installs.install_T)\n        right = self._extrude_reveal_edge(edges.Right, normal, inst_depth, self.installs.install_R)\n        \n        # ----------------------------------------------------------------------\n        # Output\n        #RevealGeom = namedtuple('RevealGeom', ['left', 'right', 'bottom', 'top'])\n        #output = RevealGeom( left, right, bottom, top )\n        \n        output = self.Output( left, right, bottom, top  )\n\n        return output\n\n    @property\n    def inset_window_surface(self):\n        \"\"\"Moves the window geometry based on the InstallDepth param \"\"\"\n\n        orientation = -1 # don't remember why this is...\n\n        transform_vector = ghc.Amplitude(self.surface_normal, float(self.install_depth) * orientation)\n        transformed_surface = ghc.Move(self.rh_surface, transform_vector).geometry\n        return transformed_surface\n\n    @staticmethod\n    def _get_vector_from_center_to_edge(_surface, _surface_plane):\n        \"\"\" Find a Vector from center of surface to mid-point on each edge.\n        \n        Arguments:\n            _surface: The Rhino surface to analyze.\n            _surface_plane: A Plane aligned to the surface.\n        Returns:\n            edgeVectors: (List) Vector3D for mid-point on each edge\n        \"\"\"\n        \n        worldOrigin = Rhino.Geometry.Point3d(0,0,0)\n        worldXYPlane = ghc.XYPlane(worldOrigin)\n        geomAtWorldZero = ghc.Orient(_surface, _surface_plane, worldXYPlane).geometry\n        edges = ghc.DeconstructBrep(geomAtWorldZero).edges\n        \n        # Find the mid-point for each edge and create a vector to that midpoint\n        crvMidPoints = [ ghc.CurveMiddle(edge) for edge in edges ]\n        edgeVectors = [ ghc.Vector2Pt(midPt, worldOrigin, False).vector for midPt in crvMidPoints ]\n        \n        return edgeVectors\n\n    @staticmethod\n    def _calc_edge_angle_about_center(_vectorList):\n        \"\"\"Take in a list of vectors. Calculate the Vector angle about the center\n        \n        Note: The 'center' is (0,0,0). Will calculate around 360 degrees (clockwise)\n        and return values in degrees not radians.\n        \n        Arguments:\n            _vectorList: (list) Vectors to the surface's edges\n        Returns:\n            vectorAngles: (List) Float values of Degrees for each Vector input\n        \"\"\"\n        \n        vectorAngles = []\n        \n        refAngle = ghc.UnitY(1)\n        x2 = refAngle.X\n        y2 = refAngle.Y\n        \n        for vector in _vectorList:\n            x1 = vector.X\n            y1 = vector.Y\n            \n            # Calc the angle between\n            angle = math.atan2(y2, x2) - math.atan2(y1, x1)\n            angle = angle * 360 / (2 * math.pi)\n            \n            if angle < 0:\n                angle = angle + 360\n            \n            angle = round(angle, 0)\n            \n            if angle >359.9 or angle < 0.001:\n                angle = 0\n            \n            vectorAngles.append(angle)\n        \n        return vectorAngles\n    \n    @staticmethod\n    def _get_plane_aligned_to_surface(_surface):\n        \"\"\"Finds an Aligned Plane for Surface input\n        \n        Note, will try and correct to make sure the aligned plane's Y-Axis aligns \n        to the surface and goes 'up' (world Z) if it can.\n        \n        Arguments:\n            _surface: The Rhino surface to align with\n        Returns:\n            srfcPlane: A single Plane object, aligned to the surface\n        \"\"\"\n        \n        # Get the UV info for the surface\n        srfcPlane = rs.SurfaceFrame(_surface, [0.5, 0.5])\n        centroid = ghc.Area(_surface).centroid\n        uVector = srfcPlane.XAxis\n        vVector = srfcPlane.YAxis\n        \n        # Create a Plane aligned to the UV of the srfc\n        lineU = ghc.LineSDL(centroid, uVector, 1)\n        lineV = ghc.LineSDL(centroid, vVector, 1)\n        srfcPlane = ghc.Line_Line(lineU, lineV)\n        \n        # Try and make sure its pointing the right directions\n        if abs(round(srfcPlane.XAxis.Z, 2)) != 0:\n            srfcPlane =  ghc.RotatePlane(srfcPlane, ghc.Radians(90))\n        if round(srfcPlane.YAxis.Z, 2) < 0:\n            srfcPlane =  ghc.RotatePlane(srfcPlane, ghc.Radians(180))\n        \n        return srfcPlane\n\n    def _get_edges_in_order(self, analysis_surface=None):\n        \"\"\"Sort the surface edges using the Degree about center as the Key\n        \n        Ordering yields edges in the order Bottom / Left / Top / Right\n        repackege them unto L/R/B/T for output\n\n        Arguments:\n            analysis_surface (Brep): A rectangular Rino surface to perform the analysis on\n        \"\"\"\n        \n        if not analysis_surface:\n            analysis_surface = self.rh_surface\n\n        srfcPlane = self._get_plane_aligned_to_surface( analysis_surface )\n        vectorList = self._get_vector_from_center_to_edge( analysis_surface, srfcPlane)\n        edgeAngleDegrees = self._calc_edge_angle_about_center(vectorList)\n        srfcEdges_Unordered = ghc.DeconstructBrep(analysis_surface).edges\n        srfcEdges_Ordered = ghc.SortList( edgeAngleDegrees, srfcEdges_Unordered).values_a\n        \n        # Convert all the Rhino lines to Ladybug LineSegments before output\n        _bottom, _left, _top, _right = srfcEdges_Ordered\n\n        _left = self._my_lb_line_constructor(_left)\n        _right = self._my_lb_line_constructor(_right)\n        _bottom = self._my_lb_line_constructor(_bottom)\n        _top = self._my_lb_line_constructor(_top)\n\n        output = self.Output(_left, _right, _bottom, _top)\n        return output\n\n    @staticmethod\n    def _my_lb_line_constructor(_line):\n        \"\"\"Cus' the 'to_line_segment' method has an error (thinks second pt is a vector) \"\"\"\n\n        p1 = to_point3d(_line.PointAtStart)\n        p2 = to_point3d(_line.PointAtEnd) \n        line = LineSegment3D.from_end_points(p1, p2)\n        \n        return line\n\n    @staticmethod\n    def _extrude_reveal_edge(_LB_line_segment, _direction, _extrudeDepth, _install):\n        \"\"\"Extrudes edge in some direction, guards against 0 extrude \"\"\"\n        \n        if _install == 0 or _extrudeDepth == 0:\n            return None\n        else:\n            rh_line = from_linesegment3d(_LB_line_segment)\n            return ghc.Extrude( rh_line, ghc.Amplitude(_direction, _extrudeDepth) )\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'quantity':self.quantity} )\n        d.update( {'_tolerance':self._tolerance} )\n        d.update( {'aperture':self.aperture.to_dict()} )\n        d.update( {'_shading_factor_winter':self._shading_factor_winter } )\n        d.update( {'_shading_factor_summer':self._shading_factor_summer} )\n        d.update( {'install_depth':self.install_depth} )\n        d.update( {'variant_type':self.variant_type} )\n\n        _edges = {}\n        for k, v in self.window_edges._asdict().iteritems():\n            _edges.update( {k:v.to_dict()} )\n        d.update( {'_window_edges':_edges} )\n        d.update( {'_glazing_edge_lengths':self.glazing_edge_lengths})\n        \n        _glazing_srfc = to_face3d(self.glazing_surface)\n        if _glazing_srfc:\n            d.update( {'_glazing_surface':_glazing_srfc[0].to_dict()} )\n        \n        if self.frame:\n            d.update( {'_frame':self.frame.to_dict()} )\n\n        if self.glazing:\n            d.update( {'_glazing':self.glazing.to_dict()} )\n        \n        if self.installs:\n            d.update( {'_installs':self.installs.to_dict()} )\n\n        if self.shading_dimensions:\n            d.update( {'shading_dimensions':self.shading_dimensions.to_dict() } )\n\n        return d\n\n    @classmethod\n    def from_aperture(cls, _aperture):\n        \"\"\" Build a new window object from a Honeybee Aperture ONLY, no geom\n            no user-params, etc... \n        \"\"\"\n\n        if not _aperture:\n            return None\n\n        glazing = PHPP_Glazing.from_HB_Const( _aperture.properties.energy.construction )\n        frame = PHPP_Frame.from_HB_Const( _aperture.properties.energy.construction )\n        install = PHPP_Installs()\n\n        window_obj = cls()\n        window_obj.aperture = _aperture\n        window_obj.frame = frame\n        window_obj.glazing = glazing\n        window_obj.installs = install\n        window_obj.install_depth = 0.1\n        window_obj.variant_type = 'a'\n\n        return window_obj\n\n    @classmethod\n    def from_dict(cls, _dict):\n        \n        new_obj = cls()\n        new_obj.quantity = _dict.get('quantity')\n        new_obj._tolerance = _dict.get('_tolerance')\n        new_obj.aperture = Aperture.from_dict( _dict.get('aperture') )\n        new_obj._shading_factor_winter =_dict.get('_shading_factor_winter')\n        new_obj._shading_factor_summer =_dict.get('_shading_factor_summer')\n        new_obj._glazing_edge_lengths = _dict.get('_glazing_edge_lengths')\n        new_obj.variant_type = _dict.get('variant_type')\n        new_obj.install_depth = _dict.get('install_depth')\n\n        #----\n        _edges = _dict.get('_window_edges', {})\n        _left = _edges.get('Left')\n        _left = LineSegment3D.from_dict( _left )\n\n        _right = _edges.get('Right')\n        _right = LineSegment3D.from_dict( _right )\n\n        _bottom = _edges.get('Bottom')\n        _bottom = LineSegment3D.from_dict( _bottom )\n\n        _top = _edges.get('Top')\n        _top = LineSegment3D.from_dict( _top )      \n        \n        new_obj._window_edges = cls.Output(_left, _right, _bottom, _top)\n\n        #----\n        _glazing_surface = _dict.get('_glazing_surface')\n        _glazing_surface = Face3D.from_dict(_glazing_surface)\n        _glazing_surface = from_face3d(_glazing_surface)\n        new_obj._glazing_surface = _glazing_surface\n\n        new_obj.frame = LBT2PH.windows.PHPP_Frame.from_dict( _dict.get('_frame') )\n        new_obj.glazing = LBT2PH.windows.PHPP_Glazing.from_dict( _dict.get('_glazing') )\n        new_obj.installs = LBT2PH.windows.PHPP_Installs.from_dict( _dict.get('_installs') )\n        new_obj.shading_dimensions = LBT2PH.shading.PHPP_Shading_Dims.from_dict( _dict.get('shading_dimensions') )        \n\n        return new_obj\n    \n    def __unicode__(self):\n        return u'A PHPP-Style Window Object: < {} >'.format(self.name)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _aperture={!r})\".format(\n            self.__class__.__name__, self.aperture)\n    def ToString(self):\n        return str(self)\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\nclass PHPP_Frame(Object):\n    ''' For Storing PHPP Style Frame Parameters       \n     Args:\n        _nm (str): The name of the Frame Type\n        _uValues (list): A list of the 4 U-Values (W/m2k) for the frame sides (Left, Right, Bottom, Top)\n        _frameWidths (list): A list of the 4 U-Values (W/m2k) for the frame sides (Left, Right, Bottom, Top)\n        _psiGlazings (list): A list of the 4 Psi-Values (W/mk) for the glazing spacers (Left, Right, Bottom, Top)\n        _psiInstalls (list): A list of the 4 Psi-Values (W/mk) for the frame Installations (Left, Right, Bottom, Top)\n        _chiGlassCarrier (list): A value for the Chi-Value (W/k) of the glass carrier for curtain walls\n    Properties:\n        * name\n        * _uValues\n        * frameWidths\n        * PsiGVals\n        * PsiInstalls\n        * chiGlassCarrier\n        * uValues\n        * display_name\n    '''\n\n    attr_names_u = ['uLeft', 'uRight', 'uBottom', 'uTop']\n    attr_names_f = ['fLeft', 'fRight', 'fBottom', 'fTop']\n    attr_names_psi_g = ['psigLeft', 'psigRight', 'psigBottom', 'psigTop']\n    attr_names_psi_inst = ['psiInstLeft', 'psiInstRight', 'psiInstBottom', 'psiInstTop']\n    \n    def __init__(self, \n                _nm='Default Frame',\n                _uValues=[1.0]*4,\n                _frameWidths=[0.1]*4,\n                _psiGlazings=[0.04]*4,\n                _psiInstalls=[0.04]*4,\n                _chiGlassCarrier=None):\n\n        self._name = _nm\n        self._uValues = _uValues\n        self._frameWidths = _frameWidths\n        self._PsiGVals = _psiGlazings\n        self._PsiInstalls = _psiInstalls\n        self.chiGlassCarrier = _chiGlassCarrier\n        \n        self._setup_attributes(self.attr_names_u, self._uValues)\n        self._setup_attributes(self.attr_names_f, self._frameWidths)\n        self._setup_attributes(self.attr_names_psi_g, self._PsiGVals)\n        self._setup_attributes(self.attr_names_psi_inst, self._PsiInstalls)\n    \n    @property\n    def name(self):\n        nm = self._name\n        nm = nm.replace('PHPP_CONST_', '')\n        nm = nm.replace('PHPP_MAT_', '')\n        return nm\n\n    @name.setter\n    def name(self, _in):\n        if _in:\n            self._name = _in\n\n    @property\n    def uValues(self):\n        d = []\n        for attr in self.attr_names_u:\n            d.append( getattr(self, attr) )\n        \n        return d\n\n    @uValues.setter\n    def uValues(self, _in):\n        clean_input = self._clean_list( _in )\n        \n        if clean_input:\n            self._uValues = clean_input\n            self._setup_attributes(self.attr_names_u, clean_input)\n\n    @property\n    def frameWidths(self):\n        d = []\n        for attr in self.attr_names_f:\n            d.append( getattr(self, attr) )\n\n        return d\n\n    @frameWidths.setter\n    def frameWidths(self, _in):\n        clean_input = self._clean_list( _in )\n        \n        if clean_input:\n            self._frameWidths = clean_input\n            self._setup_attributes(self.attr_names_f, clean_input) \n\n    @property\n    def PsiGVals(self):\n        d = []\n        for attr in self.attr_names_psi_g:\n            d.append( getattr(self, attr) )\n\n        return d\n\n    @PsiGVals.setter\n    def PsiGVals(self, _in):\n        clean_input = self._clean_list( _in )\n        \n        if clean_input:\n            self._PsiGVals = clean_input\n            self._setup_attributes(self.attr_names_psi_g, clean_input) \n\n    @property\n    def PsiInstalls(self):\n        d = []\n        for attr in self.attr_names_psi_inst:\n            d.append( getattr(self, attr) )\n\n        return d\n\n    @PsiInstalls.setter\n    def PsiInstalls(self, _in):\n        clean_input = self._clean_list( _in )\n        \n        if clean_input:\n            self._PsiInstalls = clean_input\n            self._setup_attributes(self.attr_names_psi_inst, clean_input) \n\n    @staticmethod\n    def _clean_list( _in ):\n        try:\n            output = float(_in)\n            return [output]*4\n        except AttributeError:\n            if None in _in:\n                return None\n                \n            if len(_in) == 4:\n                return _in\n            else:\n                return [_in[0]]*4\n        except SystemError:\n            pass\n        except ValueError:\n            pass\n\n    def _setup_attributes(self, _attr_name_list, _value_list):\n        \"\"\"Used to set multiple attributes from a 4-element list \"\"\"\n        \n        for i, attr_name in enumerate(_attr_name_list):\n            val = float(_value_list[i])\n            setattr(self, attr_name, val)\n    \n    def to_dict(self):\n        d = {}\n\n        d.update( {'name':self.name} )\n        d.update( {'uValues':self.uValues} )\n        d.update( {'frameWidths':self.frameWidths} )\n        d.update( {'PsiGVals':self.PsiGVals} )\n        d.update( {'PsiInstalls':self.PsiInstalls} )\n        d.update( {'chiGlassCarrier':self.chiGlassCarrier} )\n        \n        return d\n    \n    @classmethod\n    def from_dict(cls, _dict):\n        new_obj = cls()\n\n        new_obj._name = _dict.get('name')\n        new_obj.uValues = _dict.get('uValues')\n        new_obj.frameWidths = _dict.get('frameWidths')\n        new_obj.PsiGVals = _dict.get('PsiGVals')\n        new_obj.PsiInstalls = _dict.get('PsiInstalls')\n        new_obj.chiGlassCarrier = _dict.get('chiGlassCarrier')\n\n        return new_obj\n    \n    @classmethod\n    def from_HB_Const( cls, _aperture_construction ):\n        new_obj = cls()\n        \n        new_obj.name = _aperture_construction.display_name\n        new_obj.uValues = _aperture_construction.u_factor\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Style Frame Object: < {self.name} >'.format(self=self)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _nm={!r}, _uValues={!r}, _frameWidths={!r}, _psiGlazings={!r}, \"\\\n              \"_psiInstalls={!r}, _chiGlassCarrier={!r} )\".format(\n               self.__class__.__name__,\n               self.name,\n               self.uValues,\n               self.frameWidths,\n               self.PsiGVals,\n               self.PsiInstalls,\n               self.chiGlassCarrier )\n    def ToString(self):\n        return str(self)\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\nclass PHPP_Glazing(Object):\n    \"\"\" For storing PHPP Style Glazing Parameters \"\"\"\n    \n    def __init__(self, _nm='Default Glazing', _gValue=0.4, _uValue=1.0):\n        \"\"\"\n        Args:\n            _nm (str): The name of the glass type\n            _gValue (float): The g-Value (SHGC) value of the glass only as per EN 410 (%)\n            _uValue (float): The Thermal Trasmittance value of the center of glass (W/m2k) as per EN 673\n        \"\"\"\n        self.name = _nm\n        self._gValue = _gValue\n        self._uValue = _uValue\n    \n    @property\n    def gValue(self):\n        return float(self._gValue)\n\n    @gValue.setter\n    def gValue(self, _in):\n        try:\n            if float(_in) is not None:\n                self._gValue = _in\n        except Exception:\n            raise Exception('Error: Enter only numeric input for the g-Value.')\n\n    @property\n    def uValue(self):\n        return float(self._uValue)\n\n    @uValue.setter\n    def uValue(self, _in):\n        try:\n            if float(_in) is not None:\n                self._uValue = _in\n        except Exception:\n            raise Exception('Error: Enter only numeric input for the U-Value.')\n\n    @property\n    def display_name(self):\n        nm = self.name\n        nm = nm.replace('PHPP_CONST_', '')\n        nm = nm.replace('PHPP_MAT_', '')\n        \n        return nm\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'name':self.display_name} )\n        d.update( {'gValue':self.gValue} )\n        d.update( {'uValue':self.uValue} )\n        \n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_obj = cls()\n\n        new_obj.name = _dict.get('name')\n        new_obj._gValue = _dict.get('gValue')\n        new_obj._uValue = _dict.get('uValue')\n\n        return new_obj\n\n    @classmethod\n    def from_HB_Const( cls, _aperture_construction ):\n        new_obj = cls()\n        new_obj.name = _aperture_construction.display_name\n        new_obj.uValue = _aperture_construction.u_factor\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Style Glazing Object: < {} >'.format(self.display_name)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _nm={!r}, _gValue={!r}, _uValue={!r} )\".format(\n               self.__class__.__name__,\n               self.display_name,\n               self.gValue,\n               self.uValue)\n    def ToString(self):\n        return str(self)\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\nclass PHPP_Installs(Object):\n    \"\"\" For storing the install conditions (0|1) of each edge in a window component \"\"\"\n    \n    def __init__(self, _install_L=1, _install_R=1, _install_B=1, _install_T=1 ):\n        \"\"\"\n        Args:\n            _install_L (int: str: bool:): 1 | 0, 'True' | 'False' or True | False\n            _install_R (int: str: bool:): 1 | 0, 'True' | 'False' or True | False\n            _install_B (int: str: bool:): 1 | 0, 'True' | 'False' or True | False\n            _install_T (int: str: bool:): 1 | 0, 'True' | 'False' or True | False\n        \"\"\"\n        self._install_L = _install_L\n        self._install_R = _install_R\n        self._install_T = _install_T\n        self._install_B = _install_B\n\n    @property\n    def install_L(self):\n        return self._install_L\n    \n    @install_L.setter\n    def install_L(self, _in):\n        try:\n            self._install_L = int(_in)\n        except ValueError:\n            if str(_in).upper() == 'FALSE':\n                self._install_L = 0\n            else:\n                self._install_L = 1\n\n    @property\n    def install_R(self):\n        return self._install_R\n    \n    @install_R.setter\n    def install_R(self, _in):\n        try:\n            self._install_R = int(_in)\n        except ValueError:\n            if str(_in).upper() == 'FALSE':\n                self._install_R = 0\n            else:\n                self._install_R = 1\n\n    @property\n    def install_B(self):\n        return self._install_B\n    \n    @install_B.setter\n    def install_B(self, _in):\n        try:\n            self._install_B = int(_in)\n        except ValueError:\n            if str(_in).upper() == 'FALSE':\n                self._install_B = 0\n            else:\n                self._install_B = 1\n\n    @property\n    def install_T(self):\n        return self._install_T\n    \n    @install_T.setter\n    def install_T(self, _in):\n        try:\n            self._install_T = int(_in)\n        except ValueError:\n            if str(_in).upper() == 'FALSE':\n                self._install_T = 0\n            else:\n                self._install_T = 1\n\n    @property\n    def values_as_list(self):\n        return [self.install_L, self.install_R, self.install_B, self.install_T]\n    \n    @property\n    def named_values(self):\n        Output = namedtuple('Output', ['Left', 'Right', 'Bottom', 'Top'])\n        return Output(self.install_L, self.install_R, self.install_B, self.install_T)\n\n    def __iter__(self):\n        return self.values_as_list\n\n    def __len__(self):\n        return len(self.values_as_list)\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'_install_L':self.install_L} )\n        d.update( {'_install_R':self.install_R} )\n        d.update( {'_install_T':self.install_T} )\n        d.update( {'_install_B':self.install_B} )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_obj = cls()\n\n        new_obj._install_L = _dict.get('_install_L')\n        new_obj._install_R = _dict.get('_install_R')\n        new_obj._install_T = _dict.get('_install_T')\n        new_obj._install_B = _dict.get('_install_B')\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Style Window Install Object: < L={self.install_L} | R={self.install_R} | T={self.install_T} | B={self.install_B} >'.format(self=self)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _install_L={!r} )\".format(\n               self.__class__.__name__, self._install_L)\n    def ToString(self):\n        return str(self)\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\ndef create_EP_window_mat(_win_obj):\n    \"\"\" Creates an E+ style material for the window based on the PHPP U-W-Installed\n\n    Args:\n        _win_obj (): The PHPP-Style window object\n    Returns:\n        mat: The window E+ Material\n    \n    \"\"\"\n\n    # Material properties\n    name = 'PHPP_MAT_{}'.format(_win_obj.name)\n    u_factor = _win_obj.u_w_installed\n    shgc = _win_obj.glazing.gValue\n    t_vis = 0.6\n\n    # Create the material\n    mat = EnergyWindowMaterialSimpleGlazSys(\n        clean_and_id_ep_string(name), u_factor, shgc, t_vis)\n    mat.display_name = name\n\n    return mat\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\ndef create_EP_const(_win_EP_material):\n    \"\"\" Creates an 'E+' style construction for the window\n\n    Args:\n        _win_EP_material (): The E+ Material for the window\n    Returns:\n        constr (): The new E+ Construction for the window\n    \"\"\"\n\n    try:  # import the core honeybee dependencies\n        from honeybee.typing import clean_and_id_ep_string\n    except ImportError as e:\n        raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\n    try:  # import the honeybee-energy dependencies\n        from honeybee_energy.construction.window import WindowConstruction\n        from honeybee_energy.lib.materials import window_material_by_identifier\n    except ImportError as e:\n        raise ImportError('\\nFailed to import honeybee_energy:\\n\\t{}'.format(e))\n    \n    material_objs = []\n    for material in [_win_EP_material]:\n        if isinstance(material, str):\n            material = window_material_by_identifier(material)\n        material_objs.append(material)\n    \n    name = 'PHPP_CONST_{}'.format(_win_EP_material.display_name)\n\n    constr = WindowConstruction(clean_and_id_ep_string(name), material_objs)\n    constr.display_name = name\n\n    return constr\n\n\n#-------------------------------------------------------------------------------\n#-------------------------------------------------------------------------------\ndef build_frame_and_glass_objs_from_RH_doc(_ghdoc, _ghenv):\n    \"\"\" Loads window-type entries from DocumentUseText library of the Active Rhino doc.\n\n        Note, it determines if its a 'window-type' entry by looking for the \n        string \"PHPP_lib_Glazing\", \"PHPP_lib_Frame\" or \"_PsiInstall_\" in the key\n         \n    Args:\n        _ghdoc (ghdoc): The 'ghdoc' object from the Grasshopper document.\n    Returns:\n        PHPPLibrary_ (dict): A dictionary of all the window-type entries\n            found with their parameters.\n    \"\"\"\n\n    PHPPLibrary_ = {'lib_GlazingTypes':{}, 'lib_FrameTypes':{}, 'lib_PsiInstalls':{}}\n    lib_GlazingTypes = {}\n    lib_FrameTypes = {}\n    lib_PsiInstalls = {}\n    \n    with LBT2PH.helpers.context_rh_doc(_ghdoc):\n        # First, try and pull in the Rhino Document's PHPP Library\n        # And make new Frame and Glass Objects. Add all of em' to new dictionaries\n        if not rs.IsDocumentUserText():\n            return PHPPLibrary_\n        \n        for eachKey in rs.GetDocumentUserText():\n            if 'PHPP_lib_Glazing' in eachKey:\n                try:\n                    tempDict = json.loads(rs.GetDocumentUserText(eachKey))\n                    newGlazingObject = PHPP_Glazing(\n                                    tempDict['Name'],\n                                    tempDict['gValue'],\n                                    tempDict['uValue']\n                                    )\n                    lib_GlazingTypes[tempDict['Name']] = newGlazingObject\n                except:\n                    msg = 'Something went wrong trying to get the Rhino\\n'\\\n                        'information related to the Glazing? Check your\\n'\\\n                        'input values there and make sure that it is all filled in\\n'\\\n                        'correctly?'\n                    _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Error, msg)\n            elif '_PsiInstall_' in eachKey:\n                try:\n                    tempDict = json.loads(rs.GetDocumentUserText(eachKey))\n                    newPsiInstallObject = PHPP_Installs(\n                                    [\n                                    tempDict['Left'],\n                                    tempDict['Right'],\n                                    tempDict['Bottom'],\n                                    tempDict['Top']\n                                    ]\n                                    )\n                    lib_PsiInstalls[tempDict['Typename']] = newPsiInstallObject\n                except Exception as e:\n                    msg = 'Something went wrong trying to get the Rhino\\n'\\\n                        'information related to the window Psi-Install values? Check your\\n'\\\n                        'input values there and make sure that it is all filled in\\n'\\\n                        'correctly?'\n                    _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Error, msg)\n            elif 'PHPP_lib_Frame' in eachKey:\n                try:\n                    tempDict = json.loads(rs.GetDocumentUserText(eachKey))\n                    newFrameObject = PHPP_Frame()\n                    newFrameObject.name = tempDict.get('Name', 'Unnamed Frame')\n                    newFrameObject.uValues = [\n                                    tempDict.get('uFrame_L', 1.0), tempDict.get('uFrame_R', 1.0),\n                                    tempDict.get('uFrame_B', 1.0), tempDict.get('uFrame_T', 1.0) ]\n                    newFrameObject.frameWidths =[\n                                    tempDict.get('wFrame_L', 0.12), tempDict.get('wFrame_R', 0.12),\n                                    tempDict.get('wFrame_B', 0.12), tempDict.get('wFrame_T', 0.12) ]\n                    newFrameObject.PsiGVals = [\n                                    tempDict.get('psiG_L', 0.04), tempDict.get('psiG_R', 0.04),\n                                    tempDict.get('psiG_B', 0.04), tempDict.get('psiG_T', 0.04) ]\n                    newFrameObject.PsiInstalls = [\n                                    tempDict.get('psiInst_L', 0.04), tempDict.get('psiInst_R', 0.04),\n                                    tempDict.get('psiInst_B', 0.04), tempDict.get('psiInst_T', 0.04) ]\n                    \n                    lib_FrameTypes[ newFrameObject.name ] = newFrameObject\n                except Exception as e:\n                    msg = 'Something went wrong trying to get the Rhino\\n'\\\n                        'information related to the window frames? Check your\\n'\\\n                        'input values there and make sure that it is all filled in\\n'\\\n                        'correctly?'\n                    _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Error, msg)\n                    \n        PHPPLibrary_['lib_GlazingTypes'] = lib_GlazingTypes\n        PHPPLibrary_['lib_FrameTypes'] = lib_FrameTypes\n        PHPPLibrary_['lib_PsiInstalls'] = lib_PsiInstalls\n    \n    return PHPPLibrary_\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}