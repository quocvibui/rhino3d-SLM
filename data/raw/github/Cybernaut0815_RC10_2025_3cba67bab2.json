{
  "source_url": "https://github.com/Cybernaut0815/RC10_2025/blob/0c1b8554be725469968a4a9573e638dc27580dc9/Lesson_1/external_imports/Cube_walk.py",
  "repo": "Cybernaut0815/RC10_2025",
  "repo_stars": 1,
  "repo_description": "Collection of the different scripts for the python and AI class in RC 10.",
  "license": "unknown",
  "filepath": "Lesson_1/external_imports/Cube_walk.py",
  "instruction": "Cube walk",
  "code": "import numpy as np\nimport Rhino.Geometry as rg\n\ndef get_valid_moves(position, grid):\n    \"\"\"Get valid next moves using cross kernel pattern.\"\"\"\n    # 2d kernel\n    kernel = np.array([[0, 1, 0],\n                        [1, 0, 1],\n                        [0, 1, 0]])\n    \n\n    # 3d kernel\n    # kernel3d = np.array([[[0, 0, 0],[0, 1, 0],[0, 0, 0]],\n    #                     [[0, 1, 0],[1, 0, 1],[0, 1, 0]],\n    #                     [[0, 0, 0],[0, 1, 0],[0, 0, 0]]])\n\n    row, col = position\n    rows, cols = grid.shape\n    valid_moves = []\n    \n    # Check all 4 directions (up, down, left, right)\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            # add range for 3d here\n            # for dk in range(-1, 2):\n            if kernel[di + 1, dj + 1] == 1:\n                new_row = row + di\n                new_col = col + dj\n                \n                # Check if in bounds and not visited\n                if 0 <= new_row < rows and 0 <= new_col < cols:\n                    if grid[new_row, new_col] == 0:\n                        valid_moves.append((new_row, new_col))\n    \n    return valid_moves\n\n\ndef choose_next_position(grid, current_position):\n    \"\"\"Choose next random valid position and update grid.\n    \n    Returns:\n        tuple: (success, updated_grid, updated_position)\n        success: True if step was taken, False if game over\n    \"\"\"\n    valid_moves = get_valid_moves(current_position, grid)\n    \n    if len(valid_moves) == 0:\n        return False, grid, current_position  # No valid moves, game over\n    \n    # Randomly choose next position\n    next_position = valid_moves[int(np.random.randint(len(valid_moves)))]\n    \n    # Mark position as visited (create copy to avoid modifying original)\n    new_grid = grid.copy()\n    new_grid[next_position[0], next_position[1]] = 1\n    \n    return True, new_grid, next_position\n\n\ndef initialize_cube_walk(y_size, x_size):\n    \"\"\"Initialize grid with random starting position.\n    \n    Returns:\n        tuple: (grid, current_position, game_over)\n    \"\"\"\n    grid = np.zeros((y_size, x_size), dtype=int)    \n    \n    # Random starting position\n    start_row = np.random.randint(0, y_size)\n    start_col = np.random.randint(0, x_size)\n    current_position = (start_row, start_col)\n\n    # Mark starting position\n    grid[start_row, start_col] = 1\n\n    return grid, current_position, False\n\n\ndef step_cube_walk(grid, current_position, game_over):\n    \"\"\"Advance one step in the cube walk.\n    \n    Args:\n        grid: numpy array representing the grid\n        current_position: tuple (row, col) of current position\n        game_over: boolean indicating if game is over\n    \n    Returns:\n        tuple: (updated_grid, updated_position, updated_game_over)\n    \"\"\"\n    if game_over:\n        return grid, current_position, True\n    \n    if grid is None or current_position is None:\n        return grid, current_position, game_over\n    \n    success, new_grid, new_position = choose_next_position(grid, current_position)\n    \n    if not success:\n        return new_grid, new_position, True\n    \n    return new_grid, new_position, False\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}