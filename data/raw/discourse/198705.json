{
  "source_url": "https://discourse.mcneel.com/t/do-you-know-ways-of-extracting-aligned-edges-loops-from-mesh/198705",
  "topic_id": 198705,
  "title": "Do you know ways of extracting aligned edges loops from mesh?",
  "question": "2025-01-30 03_12_28-Window\n884×519 247 KB\n\n\nmesh sample.stl\n (167.9 KB)\n\nIn a mesh like this ^ we can see some parts being some generic triangulation, but some others being from obvious solid boolean operation from a revolved shape.\n\n\nEdges there have a more coherent structure, if we “pair up” edges around every vector we might able to retrieve “U” and “V” isocurves/polylines of the original revolved shape.\n\n\nDo you know any tool or logic to go in this direction?\n\n\n(A first step would be to quadrangulate the mesh, probably… but maybe not, I might want to avoid the risk of deleting useful edges…)\n\n\nEdit: I need to extract every edge-chain loops.",
  "code_blocks": [
    {
      "code": "#! python 2\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport scriptcontext\nimport System\nimport collections\nfrom math import degrees\n\n# Tolerance for considering edges to be in the same chain\nangle_tol = 3.0  # degrees\nmin_chain_length = 3  # Minimum number of edges in a chain to be considered\n\ndef GetEdgeVector(mesh, edge_index):\n    \"\"\"Get normalized vector for an edge\"\"\"\n    vert_indices = mesh.TopologyEdges.GetTopologyVertices(edge_index)\n    start = mesh.TopologyVertices.Item[vert_indices[0]]\n    end = mesh.TopologyVertices.Item[vert_indices[1]]\n    edge_vector = Rhino.Geometry.Vector3d(end - start)\n    edge_vector.Unitize()\n    return edge_vector, start, end\n\ndef AngleBetweenEdges(vector1, vector2):\n    \"\"\"Compute smallest angle in degrees between two vectors\"\"\"\n    rad_angle = Rhino.Geometry.Vector3d.VectorAngle(vector1, vector2)\n    angle = degrees(rad_angle)\n    # Take the smaller angle (considering that vectors could point in opposite directions)\n    if angle > 90:\n        angle = 180 - angle\n    return angle\n\ndef FindConnectedEdges(mesh, edge_index):\n    \"\"\"Find all edges connected to the endpoints of the given edge\"\"\"\n    edge_vert_indices = mesh.TopologyEdges.GetTopologyVertices(edge_index)\n    connected_edges = set()\n    \n    # For each vertex of the edge\n    for vert_index in edge_vert_indices:\n        # Get all edges connected to this vertex\n        edges = mesh.TopologyVertices.ConnectedEdges(vert_index)\n        for e in edges:\n            if e != edge_index:  # Don't include the original edge\n                connected_edges.add(e)\n    \n    return connected_edges\n\ndef FindNextEdgeInChain(mesh, current_edge, current_vector, visited_edges):\n    \"\"\"Find the next edge in the chain that has the smallest angle difference\"\"\"\n    connected_edges = FindConnectedEdges(mesh, current_edge)\n    best_edge = None\n    best_angle = float('inf')\n    \n    for edge in connected_edges:\n        if edge in visited_edges:\n            continue\n            \n        edge_vector, _, _ = GetEdgeVector(mesh, edge)\n        \n        # Try both directions of the vector\n        angle1 = AngleBetweenEdges(current_vector, edge_vector)\n        angle2 = AngleBetweenEdges(current_vector, -edge_vector)\n        angle = min(angle1, angle2)\n        \n        if angle < angle_tol and angle < best_angle:\n            best_edge = edge\n            best_angle = angle\n    \n    return best_edge\n\ndef FindEdgeChains(mesh, min_length=2):\n    \"\"\"Find all chains of connected edges within the angle tolerance\"\"\"\n    chains = []\n    visited_edges = set()\n    \n    # Try starting from each edge\n    for start_edge in range(mesh.TopologyEdges.Count):\n        if start_edge in visited_edges:\n            continue\n            \n        # Start a new chain\n        current_chain = [start_edge]\n        visited_edges.add(start_edge)\n        \n        # Get the edge vector\n        current_vector, _, _ = GetEdgeVector(mesh, start_edge)\n        \n        # Find the next edge in the chain\n        next_edge = FindNextEdgeInChain(mesh, start_edge, current_vector, visited_edges)\n        \n        # Continue adding edges to the chain\n        while next_edge is not None:\n            current_chain.append(next_edge)\n            visited_edges.add(next_edge)\n            \n            current_vector, _, _ = GetEdgeVector(mesh, next_edge)\n            next_edge = FindNextEdgeInChain(mesh, next_edge, current_vector, visited_edges)\n        \n        # Only consider chains with at least the minimum length\n        if len(current_chain) >= min_length:\n            chains.append(current_chain)\n    \n    return chains\n\ndef FindEdgeLoops(mesh, chains):\n    \"\"\"Try to connect chains to form loops\"\"\"\n    loops = []\n    remaining_chains = chains[:]\n    \n    while remaining_chains:\n        current_loop = remaining_chains.pop(0)\n        \n        # Try to extend the current loop with other chains\n        changed = True\n        while changed:\n            changed = False\n            for i, chain in enumerate(remaining_chains):\n                # Check if the first edge of the chain connects to the last edge of the loop\n                if chain[0] in FindConnectedEdges(mesh, current_loop[-1]):\n                    current_loop.extend(chain)\n                    del remaining_chains[i]\n                    changed = True\n                    break\n                    \n                # Check if the last edge of the chain connects to the first edge of the loop\n                elif chain[-1] in FindConnectedEdges(mesh, current_loop[0]):\n                    current_loop = chain + current_loop\n                    del remaining_chains[i]\n                    changed = True\n                    break\n        \n        # Check if the loop is closed (first and last edges are connected)\n        if current_loop[0] in FindConnectedEdges(mesh, current_loop[-1]):\n            loops.append(current_loop)\n        else:\n            # It's an open chain\n            loops.append(current_loop)\n    \n    return loops\n\ndef VisualizeEdgeChains(mesh, chains):\n    \"\"\"Visualize each edge chain with a different color\"\"\"\n    colors = [\n        System.Drawing.Color.Red,\n        System.Drawing.Color.Blue,\n        System.Drawing.Color.Green,\n        System.Drawing.Color.Yellow,\n        System.Drawing.Color.Magenta,\n        System.Drawing.Color.Cyan,\n        System.Drawing.Color.Orange,\n        System.Drawing.Color.Purple,\n        System.Drawing.Color.Brown,\n        System.Drawing.Color.Pink\n    ]\n    \n    for i, chain in enumerate(chains):\n        color = colors[i % len(colors)]\n        \n        for edge in chain:\n            # Get edge geometry\n            line = mesh.TopologyEdges.EdgeLine(edge)\n            \n            # Add the line to the document with the chain's color\n            attr = Rhino.DocObjects.ObjectAttributes()\n            attr.ColorSource = Rhino.DocObjects.ObjectColorSource.ColorFromObject\n            attr.ObjectColor = color\n            \n            scriptcontext.doc.Objects.AddLine(line, attr)\n    \n    scriptcontext.doc.Views.Redraw()\n\ndef GetMeshEdgeChains():\n    mesh_id = rs.GetObject(\"Mesh\", 32, True, False)\n    if mesh_id is None:\n        return\n        if not rs.IsObject(mesh_id): return\n    \n    mesh_obj = rs.coercerhinoobject(mesh_id)\n    mesh = mesh_obj.Geometry\n    \n    if mesh.Faces.QuadCount != 0: \n        print \"Triangulate mesh first\"\n        return\n    \n    # Let the user input the minimum chain length\n    min_length = rs.GetInteger(\"Minimum number of edges in a chain\", min_chain_length, 2, 100)\n    if min_length is None: min_length = min_chain_length  # Use default if canceled\n    \n    # Let the user input the angle tolerance\n    user_angle_tol = rs.GetReal(\"Angle tolerance in degrees\", angle_tol, 0.1, 45.0)\n    if user_angle_tol is not None: \n        global angle_tol\n        angle_tol = user_angle_tol\n    \n    # Find all edge chains\n    chains = FindEdgeChains(mesh, min_length)\n    \n    # Try to form loops\n    loops = FindEdgeLoops(mesh, chains)\n    \n    print \"Found {} edge chains with at least {} edges (angle tolerance: {:.1f} degrees)\".format(\n        len(chains), min_length, angle_tol)\n    \n    # Visualize the chains\n    VisualizeEdgeChains(mesh, chains)\n    \n    # Optionally, also visualize the loops with different colors\n    print \"Found {} edge loops\".format(len(loops))\n    if loops:\n        # Only visualize loops if they have at least the minimum length\n        filtered_loops = [loop for loop in loops if len(loop) >= min_length]\n        print \"Found {} edge loops with at least {} edges\".format(len(filtered_loops), min_length)\n        if filtered_loops:\n            VisualizeEdgeChains(mesh, filtered_loops)\n    \nGetMeshEdgeChains()",
      "language": "python",
      "author": "michaelvollrath",
      "post_number": 8,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "mesh",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 8,
  "views": 239
}