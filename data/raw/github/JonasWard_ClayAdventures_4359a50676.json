{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/patternGenv1.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/patternGenv1.py",
  "instruction": "Pattern genv1",
  "code": "import Rhino.Geometry as rg\nimport math\n\n# grasshoppper variables\n\n# geometric variables\nbase_crv\norigin\nsub_length\nlayer_count\nlayer_height\n\n# pattern variables\nperiod\nphase_shift\n\n# pattern generation\nedge_easing\nedge_ease_zero\nedge_ease_end\n\npattern_type\n\nperiod\nphase_shift\n\nspacing\nradius\nmax_val\n\nheight\nradius_bot\n\ndirection\n\n\nclass Vertex(object):\n\n    def __init__(self, pt = rg.Point3d(0,0,0), normal = rg.Point3d(1,0,0), x_val = 0, y_val = 0):\n\n        self.o = pt\n        self.v = pt\n        \n        self.n = normal\n        self.n_scale = 1.0\n\n        self.x_val = x_val\n        self.y_val = y_val\n\n\n    def numeric_distance(self, other):\n\n        return ((self.x_val - other.x_val) ** 2 + (self.y_val - other.y_val) ** 2) ** .5\n\n\n    def x_distance(self, other):\n\n        return abs(self.x_val - other.x_val)\n\n\n    def move_pt(self, mv_pt):\n\n        return Vertex(self.o + mv_pt, self.n, self.x_val, self.y_val)\n        \n\n    def warp_pt(self, scale_val = 0):\n\n        self.v = rg.Point3d(self.o + self.n * (scale_val * self.n_scale))\n\n\nclass PatternMap(object):\n\n    def __init__(self, base_crv, origin = rg.Point3d(0,0,0)):\n\n        self.base_crv = base_crv\n\n\n    def subdivide(self, div_length):\n\n        self.length = self.base_crv.GetLength()\n        div_c = int(self.length / div_length)\n        self.div_length = self.length / div_c\n        self.div_c = div_c + 1\n        \n        t_vals = self.base_crv.DivideByLength(self.div_length, True)\n\n        pts = [self.base_crv.PointAt(t) for t in t_vals]\n\n        # getting normals\n\n        tmp_offset_crv_1 = self.base_crv.Offset(rg.Plane.WorldXY, 1.0, .01, rg.CurveOffsetCornerStyle.Sharp)[0]\n        tmp_offset_crv_2 = self.base_crv.Offset(rg.Plane.WorldXY, -1.0, .01, rg.CurveOffsetCornerStyle.Sharp)[0]\n\n        if tmp_offset_crv_1.GetLength() < tmp_offset_crv_2.GetLength():\n\n            offset_crv = tmp_offset_crv_2\n        \n        else:\n\n            offset_crv = tmp_offset_crv_1\n        \n        normals = [(pt - offset_crv.PointAt(offset_crv.ClosestPoint(pt)[1])) for pt in pts]\n\n        self.base_layer = []\n\n        for pt_i, pt in enumerate(pts):\n\n            self.base_layer.append(Vertex(pt, normals[pt_i], x_val = pt_i * self.div_length))\n\n\n    def generate(self, layer_height, layer_count):\n\n        self.lay_h = layer_height\n        self.lay_c = layer_count\n\n        self.height = self.lay_h * self.lay_c\n\n        self.surface_set = []\n\n        for z_in in range(self.lay_c):\n\n            z_val = z_in * self.lay_h\n\n            z_mv_pt = rg.Point3d(0, 0, z_val)\n\n            local_layer = []\n\n            for pt in self.base_layer:\n                \n                tmp_new_pt = pt.move_pt(z_mv_pt)\n                tmp_new_pt.y_val = z_val\n\n                local_layer.append(tmp_new_pt)\n\n            self.surface_set.extend(local_layer)\n\n    def edgeEasing(self, zero_length, normal_length):\n\n        ease_delta = normal_length - zero_length\n\n        for pt in self.surface_set:\n\n            if pt.x_val < zero_length or pt.x_val > self.length - zero_length:\n\n                pt.n_scale = 0.0\n\n            elif pt.x_val < normal_length:\n\n                pt.n_scale = abs(pt.x_val - zero_length) / ease_delta\n                \n            elif pt.x_val > self.length - normal_length:\n\n                pt.n_scale = abs(pt.x_val - (self.length - zero_length)) / ease_delta\n\n\n    def sinWarp(self, period, amplitude, phase_shift, direction = True):\n\n        for pt in self.surface_set:\n\n            local_phase = pt.y_val / self.lay_h * phase_shift\n\n            scale_val = math.sin(pt.x_val / period + local_phase) * amplitude\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def patternGeneration(self, pattern_set, spacing):\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set = []\n        layer_count = 0\n        layer_length_vals = []\n\n        for pattern in pattern_set:\n\n            start, step, count = pattern[0], pattern[1], pattern[2]\n\n            if count < 1:\n\n                count = 1\n\n            layer_vertexes = []\n            length_vals = []\n            \n            x_val = start\n\n            x_delta = step * spacing\n\n            while x_val < self.length:\n\n                layer_vertexes.append(Vertex(x_val = x_val))\n                length_vals.append(x_val)\n\n                x_val += x_delta\n\n            for i in range(count):\n\n                layer_set.append(layer_vertexes)\n                layer_length_vals.append(length_vals)\n\n            layer_count += count\n\n        return layer_set, layer_length_vals, layer_count\n\n    def curveSplitAtPoints(self, radius, length_vals):\n\n        pass\n\n\n    def specialLayerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        _, layer_length_vals, layer_count = self.patternGeneration(pattern_set, spacing)\n\n        \n\n    \n    def layerMap(self, spacing, pattern_set, radius, max_val, direction = True):\n\n        # pattern_map (start, step, count)\n        # only have to consider x distance\n\n        layer_set, _, layer_count = self.patternGeneration(pattern_set, spacing)\n\n        # subdividing in layers\n        for pt_i, pt in enumerate(self.surface_set):\n\n            layer_index = (pt_i - pt_i % self.div_c) / self.div_c\n\n            pattern_layer_index = int(layer_index % layer_count)\n\n            dots = layer_set[pattern_layer_index]\n\n            dis_set = []\n\n            for dot in dots:\n\n                dis_set.append(pt.x_distance(dot))\n\n            distance = min(dis_set)\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def dotGen(self, spacing, y_spacing = None):\n\n        y_val = 0.0\n        count = 0\n\n        x_spacing = 2.0 ** .5 * spacing\n\n        if y_spacing == None:\n\n            y_spacing = x_spacing * .5\n\n        dots = []\n\n        while y_val < self.height:\n\n            if count % 2 == 1:\n\n                x_val = x_spacing * .5\n\n            else:\n\n                x_val = 0.0\n\n            while x_val < self.length:\n\n                print(x_val, y_val)\n\n                dots.append(Vertex(x_val = x_val, y_val = y_val))\n\n                x_val += x_spacing\n\n            y_val += y_spacing\n            count += 1\n\n        return dots\n\n\n    def dotMap(self, spacing, radius, max_val, direction = True):\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            distance -= radius\n\n            if distance < 0:\n\n                scale_val = abs(distance) / radius * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def ellipsoidBumpMap(self, spacing, radius, max_val, direction = True):\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append(distance)\n\n            distance = min(distance_set)\n\n            if distance < radius:\n\n                scale_val = (1 - (distance / radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def getKey(self, item):\n\n        return item[0]\n\n\n    def cylinderMap(self, spacing, height, radius, max_val, radius_bot = None, direction = True):\n\n        if radius_bot == None:\n\n            radius_bot = radius\n            radius_delta = 0\n\n        else:\n\n            radius_delta = radius - radius_bot\n\n        dots = self.dotGen(spacing)\n\n        for pt in self.surface_set:\n\n            # get closest dot\n\n            distance_set = []\n\n            for dot in dots:\n\n                distance = pt.numeric_distance(dot)\n                distance_set.append((distance, dot))\n\n            _, dot = sorted(distance_set, key = self.getKey)[0]\n\n            print(dot)\n\n            # y_distance calculation\n\n            y_distance = pt.y_val - dot.y_val\n\n            # x_distance calculation\n\n            x_distance = abs(pt.x_val - dot.x_val)\n\n            if abs(y_distance) + .01 < height * .5 :\n\n                local_radius = radius_bot + radius_delta * (y_distance / height + .5)\n\n            else:\n\n                local_radius = -1\n\n            if x_distance < local_radius:\n\n                scale_val = (1 - (x_distance / local_radius) ** 2.0) ** .5 * max_val\n\n            else:\n\n                scale_val = 0.0\n\n            if not(direction):\n\n                scale_val = - scale_val\n\n            pt.warp_pt(scale_val)\n\n\n    def makeCurves(self):\n\n        curve_set = []\n        pt_set = []\n\n        for pt_in, pt in enumerate(self.surface_set):\n\n            pt_set.append(pt.v)\n\n            if pt_in % self.div_c == self.div_c - 1:\n\n                crv = rg.Polyline(pt_set).ToNurbsCurve()\n\n                curve_set.append(crv)\n\n                pt_set = []\n\n        return curve_set\n\n\n    def makeMesh(self):\n\n        surface_mesh = rg.Mesh()\n\n        # adding the vertices\n\n        for pt in self.surface_set:\n\n            surface_mesh.Vertices.Add(pt.v)\n\n        # addding the faces\n\n        for y in range(self.lay_c - 1):\n\n            for x in range(self.div_c - 1):\n\n                v_a = y * self.div_c + x\n                v_b = (y + 1) * self.div_c + x\n                v_c = (y + 1) * self.div_c + x + 1\n                v_d = y * self.div_c + x + 1\n\n                surface_mesh.Faces.AddFace(v_a, v_b, v_c, v_d)\n\n        return surface_mesh\n\n\n\npattern_map = PatternMap(base_crv, origin)\npattern_map.subdivide(sub_length)\npattern_map.generate(layer_height, layer_count)\n\nif edge_easing:\n\n    pattern_map.edgeEasing(edge_ease_zero, edge_ease_end)\n\nif pattern_type == 0:\n    \n    pattern_map.dotMap(spacing, radius, max_val, direction)\n\nelif pattern_type == 1:\n\n    pattern_map.ellipsoidBumpMap(spacing, radius, max_val, direction)\n\nelif pattern_type == 2:\n\n    pattern_map.sinWarp(period, max_val, phase_shift, direction)\n\nelif pattern_type == 3:\n\n    if radius_bot < .01:\n\n        radius_bot = radius\n\n    else:\n\n        radius_bot = radius_bot\n\n    pattern_map.cylinderMap(spacing, height, radius, max_val, radius_bot, direction)\n\nelif pattern_type == 4:\n\n    pattern_map.layerMap(spacing, pattern_set, radius, max_val, direction)\n\n\nc = pattern_map.makeMesh()\nb = pattern_map.makeCurves()\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}