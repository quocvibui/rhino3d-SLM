{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/analysis/axis_validator.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/analysis/axis_validator.py",
  "instruction": "Validate discovered axis lines against a reference 3dm file.",
  "code": "\"\"\"Validate discovered axis lines against a reference 3dm file.\"\"\"\n\nfrom __future__ import annotations\n\nimport bisect\nimport logging\nimport math\nfrom collections import defaultdict\nfrom pathlib import Path\n\nimport rhino3dm\n\nfrom structure_aligner.config import AxisLine\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_against_reference(\n    discovered: list[AxisLine],\n    reference_3dm_path: Path,\n    axis: str,\n    tolerance: float = 0.005,\n    min_vertex_count: int = 5,\n) -> dict:\n    \"\"\"Compare discovered axis lines against reference after.3dm.\n\n    Extracts axis-line positions from named objects in the reference file\n    (positions shared by many vertices, indicating structural axis lines)\n    and compares against the discovered axis lines.\n\n    Args:\n        discovered: List of discovered AxisLine objects.\n        reference_3dm_path: Path to the reference .3dm file.\n        axis: \"X\" or \"Y\" - which axis to compare.\n        tolerance: Match tolerance in meters.\n        min_vertex_count: Minimum vertices at a position for it to count\n            as an axis line in the reference.\n\n    Returns:\n        Dict with comparison metrics.\n    \"\"\"\n    reference_positions = _extract_axis_positions(\n        reference_3dm_path, axis, tolerance, min_vertex_count,\n    )\n    discovered_positions = sorted(a.position for a in discovered)\n\n    matched_ref = 0\n    unmatched_reference = []\n    for ref_pos in reference_positions:\n        if _has_match(ref_pos, discovered_positions, tolerance):\n            matched_ref += 1\n        else:\n            unmatched_reference.append(ref_pos)\n\n    matched_disc = 0\n    unmatched_discovered = []\n    ref_sorted = sorted(reference_positions)\n    for disc_pos in discovered_positions:\n        if _has_match(disc_pos, ref_sorted, tolerance):\n            matched_disc += 1\n        else:\n            unmatched_discovered.append(disc_pos)\n\n    ref_count = len(reference_positions)\n    disc_count = len(discovered_positions)\n\n    recall = matched_ref / ref_count if ref_count > 0 else 0.0\n    precision = matched_disc / disc_count if disc_count > 0 else 0.0\n\n    result = {\n        \"axis\": axis,\n        \"discovered_count\": disc_count,\n        \"reference_count\": ref_count,\n        \"matched\": matched_ref,\n        \"recall\": recall,\n        \"precision\": precision,\n        \"unmatched_reference\": unmatched_reference,\n        \"unmatched_discovered\": unmatched_discovered,\n    }\n\n    logger.info(\n        \"%s axis: %d discovered, %d reference, %d matched (recall=%.1f%%, precision=%.1f%%)\",\n        axis, disc_count, ref_count, matched_ref, recall * 100, precision * 100,\n    )\n\n    return result\n\n\ndef _extract_axis_positions(\n    path_3dm: Path,\n    axis: str,\n    dedup_tolerance: float = 0.005,\n    min_vertex_count: int = 5,\n) -> list[float]:\n    \"\"\"Extract axis-line positions from named objects in a 3dm file.\n\n    An axis-line position is one where many vertices sit (>= min_vertex_count).\n    Positions with few vertices are typically from added geometry (consolidated\n    dalles, simplified voiles) and not structural axis lines.\n    \"\"\"\n    model = rhino3dm.File3dm.Read(str(path_3dm))\n    if model is None:\n        raise RuntimeError(f\"Failed to read 3dm file: {path_3dm}\")\n\n    # Count vertices at each position\n    ndigits = max(0, math.ceil(-math.log10(dedup_tolerance)))\n    position_counts: dict[float, int] = defaultdict(int)\n\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if not name:\n            continue\n        geom = obj.Geometry\n        coords = _extract_coords(geom, axis)\n        for c in coords:\n            rounded = round(c, ndigits)\n            position_counts[rounded] += 1\n\n    # Filter by minimum vertex count\n    axis_positions = sorted(\n        pos for pos, count in position_counts.items()\n        if count >= min_vertex_count\n    )\n\n    # Merge nearby positions\n    return _dedup_positions(axis_positions, dedup_tolerance)\n\n\ndef _extract_coords(geom, axis: str) -> list[float]:\n    \"\"\"Extract X or Y coordinates from a geometry object.\"\"\"\n    points = []\n\n    if isinstance(geom, rhino3dm.Brep):\n        for vi in range(len(geom.Vertices)):\n            v = geom.Vertices[vi]\n            loc = v.Location\n            points.append(loc.X if axis == \"X\" else loc.Y)\n\n    elif isinstance(geom, rhino3dm.LineCurve):\n        for p in [geom.PointAtStart, geom.PointAtEnd]:\n            points.append(p.X if axis == \"X\" else p.Y)\n\n    elif isinstance(geom, rhino3dm.PolylineCurve):\n        for pi in range(geom.PointCount):\n            p = geom.Point(pi)\n            points.append(p.X if axis == \"X\" else p.Y)\n\n    elif isinstance(geom, rhino3dm.NurbsCurve):\n        for pi in range(len(geom.Points)):\n            p = geom.Points[pi]\n            points.append(p.X if axis == \"X\" else p.Y)\n\n    elif isinstance(geom, rhino3dm.Point):\n        loc = geom.Location\n        points.append(loc.X if axis == \"X\" else loc.Y)\n\n    return points\n\n\ndef _dedup_positions(sorted_positions: list[float], tolerance: float) -> list[float]:\n    \"\"\"Remove duplicate positions within tolerance, keeping the first.\"\"\"\n    if not sorted_positions:\n        return []\n\n    result = [sorted_positions[0]]\n    for pos in sorted_positions[1:]:\n        if pos - result[-1] > tolerance:\n            result.append(pos)\n    return result\n\n\ndef _has_match(value: float, sorted_list: list[float], tolerance: float) -> bool:\n    \"\"\"Check if value has a match in sorted_list within tolerance.\"\"\"\n    if not sorted_list:\n        return False\n    idx = bisect.bisect_left(sorted_list, value - tolerance)\n    if idx < len(sorted_list) and abs(sorted_list[idx] - value) <= tolerance:\n        return True\n    if idx > 0 and abs(sorted_list[idx - 1] - value) <= tolerance:\n        return True\n    return False\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}