{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/pinLinking.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/pinLinking.py",
  "instruction": "clay printing library - pin connection set",
  "code": "# clay printing library - pin connection set\n\nimport Rhino.Geometry as rg\n# import ghpythonlib.components as gh\n# import math\nfrom generalFunctions import *\n# from simpleStartStop import *\nfrom copy import deepcopy as dc\n\ndef lineInterpolate(pt_0, pt_2, count):\n\n    delta_pt = (pt_2 - pt_0) / float(count + 1.0)\n\n    return [pt_0 + delta_pt * i for i in range(1, count + 1, 1)]\n\n\ndef linkGen(pt_a, pt_b):\n\n    distance = pt_a.DistanceTo(pt_b)\n    \n    end_pt = rg.Point3d((pt_b - pt_a) / distance + pt_a)\n    \n    return rg.Line(pt_a, end_pt), end_pt\n\n\ndef doubleEnd(pt, ref_line, alfa = .5):\n\n    angle = alfa * 3.1415927\n\n    rot_pos = rg.Transform.Rotation(angle, pt)\n    rot_neg = rg.Transform.Rotation(-angle, pt)\n\n    loc_copy_pos = dc(ref_line)\n    loc_copy_neg = dc(ref_line)\n\n    loc_copy_pos.Transform(rot_pos)\n    loc_copy_neg.Transform(rot_neg)\n\n    return loc_copy_pos, loc_copy_neg\n\ndef singleEnd(pt, ref_line, angle = 3.1415927):\n\n    line = dc(ref_line)\n\n    rot = rg.Transform.Rotation(angle, pt)\n\n    line.Transform(rot)\n\n    return line\n\ndef copyTransformSet(geo_set, trans_matrix):\n\n    new_set = []\n\n    for geo in geo_set:\n\n        tmp_geo = dc(geo)\n        tmp_geo.Transform(trans_matrix)\n\n        new_set.append(tmp_geo)\n\n    return new_set\n\ndef circleSegmenter(pt, pt_0, pt_1, items = 1, cutoff = .25):\n\n    _, pt_0 = linkGen(pt, pt_0)\n    _, pt_1 = linkGen(pt, pt_1)\n\n    circle = rg.Circle(pt, 1.0).ToNurbsCurve()\n\n    crvs, _ = layer2ptIntersect(circle, [pt_0, pt_1])\n    crv_0 = crvs[0]\n    crv_1 = crvs[1]\n\n    crv_0_l = crv_0.GetLength()\n    crv_1_l = crv_1.GetLength()\n\n    if items == 1:\n\n        if crv_0_l > crv_1_l :\n\n            crv_0.Domain = rg.Interval(0,1)\n            pt_2 = crv_0.PointAt(.5)\n\n        else:\n\n            crv_1.Domain = rg.Interval(0,1)\n            pt_2 = crv_1.PointAt(.5)\n\n        line_set = [rg.Line(pt, pt_2)]\n\n        return [pt_2], line_set\n\n    elif items == 2:\n\n        crv_0.Domain = rg.Interval(0,1)\n        pt_2 = crv_0.PointAt(.5)\n\n        crv_1.Domain = rg.Interval(0,1)\n        pt_3 = crv_1.PointAt(.5)\n\n        line_set = [rg.Line(pt, pt_2), rg.Line(pt, pt_3)]\n\n        return [pt_2, pt_3], line_set\n\n    else:\n\n        if max(crv_0_l, crv_1_l) < 3.1415927 + cutoff:\n            # as if there are only two\n\n            crv_0.Domain = rg.Interval(0,1)\n            pt_2 = crv_0.PointAt(.5)\n\n            crv_1.Domain = rg.Interval(0,1)\n            pt_3 = crv_1.PointAt(.5)\n\n            line_set = [rg.Line(pt, pt_2), rg.Line(pt, pt_3)]\n\n            return [pt_2, pt_3], line_set\n\n        else:\n\n            if crv_0_l < crv_1_l:\n\n                double_split_crv = crv_1\n                double_crv_l = crv_1_l\n                single_split_crv = crv_0\n            \n            else:\n\n                double_split_crv = crv_0\n                double_crv_l = crv_0_l\n                single_split_crv = crv_1\n\n            double_split_crv.Domain = rg.Interval(0,double_crv_l)\n            single_split_crv.Domain = rg.Interval(0,1.0)\n            \n            pt_2 = single_split_crv.PointAt(.5)\n            \n            pt_3 = double_split_crv.PointAt(.5 * 3.1415927)\n            pt_4 = double_split_crv.PointAt(double_crv_l - .5 * 3.1415927)\n\n            line_set = [rg.Line(pt, pt_2), rg.Line(pt, pt_3), rg.Line(pt, pt_4)]\n\n            return [pt_2, pt_3, pt_4], line_set\n\n        \ndef createPinLinks(pin_points, connection_count = 2, max_main_line = 100.0, alfa = .5):\n\n    pt_count = len(pin_points)\n\n    main_lines = []\n    secundary_lines = []\n\n    # generating the main lines & potential too long ones\n\n    main_link_pts = []\n\n    for i in range(pt_count - 1):\n        \n        pt_0, pt_1 = pin_points[i], pin_points[i + 1]\n        \n        main_link_line, main_link_pt = linkGen(pt_0, pt_1)\n\n        main_link_pts.append(main_link_pt)\n        \n        main_lines.append(dc(main_link_line))\n\n        distance = pt_0.DistanceTo(pt_1)\n\n        if distance > max_main_line:\n\n            # indicating that some extra links should be introduced\n\n            loc_link_set = doubleEnd(pt_0, main_link_line)\n\n            split_count = int(round(distance / max_main_line))\n\n            b_pts = lineInterpolate(pt_0, pt_1, split_count)\n\n            for b_pt in b_pts:\n\n                trans_m = rg.Transform.Translation(rg.Vector3d(b_pt - pt_0))\n\n                secundary_lines.extend(copyTransformSet(loc_link_set, trans_m))\n\n    # generating the main link end pts\n\n    main_link_pts = main_link_pts + [pin_points[-1] + main_link_pts[-1]]\n\n    # generating the \"negative\" pin links - \"end parts\"\n\n    neg_main_pin_pts = []\n\n    for i in range(pt_count - 1):\n        \n        pt_0, pt_1 = pin_points[i + 1], pin_points[i]\n        \n        _, neg_main_link_pt = linkGen(pt_0, pt_1)\n        \n        neg_main_pin_pts.append(neg_main_link_pt)\n\n    neg_main_pin_pts = [pin_points[0] + neg_main_pin_pts[0]] + neg_main_pin_pts\n\n    print(\"main link length: %s\" %len(main_link_pts))\n\n    # generating the point connection_lines\n\n    pin_point_pt_set = [[main_link_pts[i], neg_main_pin_pts[i]] for i in range(pt_count)]\n\n    if connection_count == 1:\n\n        for pt_i, pt in enumerate(pin_points):\n\n            if pt_i == 0:\n\n                tmp_line = singleEnd(pt, main_lines[0])\n\n                secundary_lines.append(tmp_line)\n\n                pin_point_pt_set[0].extend([\n                    tmp_line.PointAt(1.0)\n                ])\n\n            elif pt_i == (pt_count - 1):\n\n                mv = rg.Transform.Translation(pt - pin_points[-2])\n\n                tmp_line = copyTransformSet([main_lines[-1]], mv)[0]\n\n                secundary_lines.append(tmp_line)\n\n                pin_point_pt_set[-1].extend([\n                    tmp_line.PointAt(1.0),\n                ])\n\n            else:\n\n                pt_0 = pin_point_pt_set[pt_i][0]\n                pt_1 = pin_point_pt_set[pt_i][1]\n\n                pts, lines = circleSegmenter(pt, pt_0, pt_1, items = 1, cutoff = .25)\n        \n                secundary_lines.extend(lines)\n\n                pin_point_pt_set[pt_i].extend(pts)\n\n    elif connection_count == 3:\n\n        for pt_i, pt in enumerate(pin_points):\n\n            if pt_i == 0:\n\n                tmp_line = singleEnd(pt, main_lines[0])\n                tmp_lines = doubleEnd(pt, tmp_line)\n\n                x_ls = list(tmp_lines)\n\n                secundary_lines.extend(x_ls)\n\n                pt_set = [l.PointAt(1.0) for l in x_ls]\n\n                pin_point_pt_set[0].extend([l.PointAt(1.0) for l in x_ls])\n\n            elif pt_i == (pt_count - 1):\n\n                mv = rg.Transform.Translation(pt - pin_points[-2])\n\n                tmp_line = copyTransformSet([main_lines[-1]], mv)[0]\n                tmp_lines = doubleEnd(pt, tmp_line)\n\n                x_ls = list(tmp_lines)\n\n                secundary_lines.extend(x_ls)\n\n                pt_set = [l.PointAt(1.0) for l in x_ls]\n\n                pin_point_pt_set[-1].extend(pt_set)\n\n            else:\n\n                pt_0 = pin_point_pt_set[pt_i][0]\n                pt_1 = pin_point_pt_set[pt_i][1]\n\n                pts, lines = circleSegmenter(pt, pt_0, pt_1, items = 3, cutoff = alfa)\n        \n                secundary_lines.extend(lines)\n\n                pin_point_pt_set[pt_i].extend(pts)\n\n        pass\n\n    else:\n\n        for pt_i, pt in enumerate(pin_points):\n\n            if pt_i == 0:\n\n                tmp_lines = doubleEnd(pt, main_lines[0])\n\n                x_ls = tmp_lines\n\n                secundary_lines.extend(x_ls)\n\n                pt_set = [l.PointAt(1.0) for l in x_ls]\n\n                pin_point_pt_set[0].extend([l.PointAt(1.0) for l in x_ls])\n\n            elif pt_i == (pt_count - 1):\n\n                mv = rg.Transform.Translation(pt - pin_points[-2])\n\n                tmp_line = copyTransformSet([main_lines[-1]], mv)[0]\n                tmp_lines = doubleEnd(pt, tmp_line)\n\n                x_ls = tmp_lines\n\n                secundary_lines.extend(x_ls)\n\n                pt_set = [l.PointAt(1.0) for l in x_ls] + [linkGen(pt, pin_points[-2])[1]]\n\n                pin_point_pt_set[-1].extend(pt_set)\n\n            else:\n\n                pt_0 = pin_point_pt_set[pt_i][0]\n                pt_1 = pin_point_pt_set[pt_i][1]\n\n                pts, lines = circleSegmenter(pt, pt_0, pt_1, items = 2, cutoff = alfa)\n        \n                secundary_lines.extend(lines)\n\n                pin_point_pt_set[pt_i].extend(pts)\n\n    return pin_point_pt_set, secundary_lines, main_lines\n\n\ndef longestSegment(pin_point, pin_pt_set):\n\n    c = rg.Circle(pin_point, 1.0).ToNurbsCurve()\n\n    crvs, pts = layer2ptIntersect(c, pin_pt_set)\n\n    longest_crv_length = 0.0\n\n    for crv in crvs:\n\n        loc_crv_length = crv.GetLength()\n\n        if loc_crv_length > longest_crv_length:\n\n            print(longest_crv_length)\n\n            longest_crv_length = loc_crv_length\n            longest_crv = crv\n\n    longest_crv.Domain = rg.Interval(0, 1.0)\n    longest_mid_pt = longest_crv.PointAt(.5)\n\n    split_line = rg.Line(pin_point, longest_mid_pt)\n\n    return split_line\n\n\ndef mainLinkGeneration(pin_main_crvs, main_lines):\n\n    pass",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}