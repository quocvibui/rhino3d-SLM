{
  "source_url": "https://github.com/arijitaich/2dtocad/blob/f837c55a0c1597a488080ecdc9c5c11a0264d13e/mcp/rhino_mcp/rhino_tools.py",
  "repo": "arijitaich/2dtocad",
  "repo_stars": 0,
  "repo_description": "A pipeline to create 2d to cad of each and every component required to manufacture an item provided as user input images.",
  "license": "unknown",
  "filepath": "mcp/rhino_mcp/rhino_tools.py",
  "instruction": "Tools for interacting with Rhino through socket connection.",
  "code": "\"\"\"Tools for interacting with Rhino through socket connection.\"\"\"\nfrom mcp.server.fastmcp import FastMCP, Context, Image\nimport logging\nfrom dataclasses import dataclass\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncIterator, Dict, Any, List, Optional\nimport json\nimport socket\nimport time\nimport base64\nimport io\nfrom PIL import Image as PILImage\n\n\n# Configure logging\nlogger = logging.getLogger(\"RhinoTools\")\n\nclass RhinoConnection:\n    def __init__(self, host='localhost', port=9876):\n        self.host = host\n        self.port = port\n        self.socket = None\n        self.timeout = 30.0  # 30 second timeout\n        self.buffer_size = 14485760  # 10MB buffer size for handling large images\n    \n    def connect(self):\n        \"\"\"Connect to the Rhino script's socket server\"\"\"\n        if self.socket is None:\n            try:\n                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.socket.settimeout(self.timeout)\n                self.socket.connect((self.host, self.port))\n                logger.info(\"Connected to Rhino script\")\n            except Exception as e:\n                logger.error(\"Failed to connect to Rhino script: {0}\".format(str(e)))\n                self.disconnect()\n                raise\n    \n    def disconnect(self):\n        \"\"\"Disconnect from the Rhino script\"\"\"\n        if self.socket:\n            try:\n                self.socket.close()\n            except:\n                pass\n            self.socket = None\n    \n    def send_command(self, command_type: str, params: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Send a command to the Rhino script and wait for response\"\"\"\n        if self.socket is None:\n            self.connect()\n        \n        try:\n            # Prepare command\n            command = {\n                \"type\": command_type,\n                \"params\": params or {}\n            }\n            \n            # Send command\n            command_json = json.dumps(command)\n            logger.info(\"Sending command: {0}\".format(command_json))\n            self.socket.sendall(command_json.encode('utf-8'))\n            \n            # Receive response with timeout and larger buffer\n            buffer = b''\n            start_time = time.time()\n            \n            while True:\n                try:\n                    # Check timeout\n                    if time.time() - start_time > self.timeout:\n                        raise Exception(\"Response timeout after {0} seconds\".format(self.timeout))\n                    \n                    # Receive data\n                    data = self.socket.recv(self.buffer_size)\n                    if not data:\n                        break\n                        \n                    buffer += data\n                    logger.debug(\"Received {0} bytes of data\".format(len(data)))\n                    \n                    # Try to parse JSON\n                    try:\n                        response = json.loads(buffer.decode('utf-8'))\n                        logger.info(\"Received complete response: {0}\".format(response))\n                        \n                        # Check for error response\n                        if response.get(\"status\") == \"error\":\n                            raise Exception(response.get(\"message\", \"Unknown error from Rhino\"))\n                            \n                        return response\n                    except json.JSONDecodeError:\n                        # If we have a complete response, it should be valid JSON\n                        if len(buffer) > 0:\n                            continue\n                        else:\n                            raise Exception(\"Invalid JSON response from Rhino\")\n                            \n                except socket.timeout:\n                    raise Exception(\"Socket timeout while receiving response\")\n                    \n            raise Exception(\"Connection closed by Rhino script\")\n            \n        except Exception as e:\n            logger.error(\"Error communicating with Rhino script: {0}\".format(str(e)))\n            self.disconnect()  # Disconnect on error to force reconnection\n            raise\n\n# Global connection instance\n_rhino_connection = None\n\ndef get_rhino_connection() -> RhinoConnection:\n    \"\"\"Get or create the Rhino connection\"\"\"\n    global _rhino_connection\n    if _rhino_connection is None:\n        _rhino_connection = RhinoConnection()\n    return _rhino_connection\n\nclass RhinoTools:\n    \"\"\"Collection of tools for interacting with Rhino.\"\"\"\n    \n    def __init__(self, app):\n        self.app = app\n        self._register_tools()\n    \n    def _register_tools(self):\n        \"\"\"Register all Rhino tools with the MCP server.\"\"\"\n        self.app.tool()(self.get_scene_info)\n        self.app.tool()(self.get_layers)\n        self.app.tool()(self.get_scene_objects_with_metadata)\n        self.app.tool()(self.capture_viewport)\n        self.app.tool()(self.execute_rhino_code)\n    \n    def get_scene_info(self, ctx: Context) -> str:\n        \"\"\"Get basic information about the current Rhino scene.\n        \n        This is a lightweight function that returns basic scene information:\n        - List of all layers with basic information about the layer and 5 sample objects with their metadata \n        - No metadata or detailed properties\n        - Use this for quick scene overview or when you only need basic object information\n        \n        Returns:\n            JSON string containing basic scene information\n        \"\"\"\n        try:\n            connection = get_rhino_connection()\n            result = connection.send_command(\"get_scene_info\")\n            return json.dumps(result, indent=2)\n        except Exception as e:\n            logger.error(\"Error getting scene info from Rhino: {0}\".format(str(e)))\n            return \"Error getting scene info: {0}\".format(str(e))\n\n    def get_layers(self, ctx: Context) -> str:\n        \"\"\"Get list of layers in Rhino\"\"\"\n        try:\n            connection = get_rhino_connection()\n            result = connection.send_command(\"get_layers\")\n            return json.dumps(result, indent=2)\n        except Exception as e:\n            logger.error(\"Error getting layers from Rhino: {0}\".format(str(e)))\n            return \"Error getting layers: {0}\".format(str(e))\n\n    def get_scene_objects_with_metadata(self, ctx: Context, filters: Optional[Dict[str, Any]] = None, metadata_fields: Optional[List[str]] = None) -> str:\n        \"\"\"Get detailed information about objects in the scene with their metadata.\n        \n        This is a CORE FUNCTION for scene context awareness. It provides:\n        1. Full metadata for each object we created via this mcp connection including:\n           - short_id (DDHHMMSS format), can be dispalyed in the viewport when using capture_viewport, can help yo uto visually identify the a object and find it with this function\n           - created_at timestamp\n           - layer  - layer path\n           - type - geometry type \n           - bbox - the bounding box as lsit of points\n           - name - the name you assigned \n           - description - description yo uasigned \n        \n        2. Advanced filtering capabilities:\n           - layer: Filter by layer name (supports wildcards, e.g., \"Layer*\")\n           - name: Filter by object name (supports wildcards, e.g., \"Cube*\")\n           - short_id: Filter by exact short ID match\n        \n        3. Field selection:\n           - Can specify which metadata fields to return\n           - Useful for reducing response size when only certain fields are needed\n        \n        Args:\n            filters: Optional dictionary of filters to apply\n            metadata_fields: Optional list of specific metadata fields to return\n        \n        Returns:\n            JSON string containing filtered objects with their metadata\n        \"\"\"\n        try:\n            connection = get_rhino_connection()\n            result = connection.send_command(\"get_objects_with_metadata\", {\n                \"filters\": filters or {},\n                \"metadata_fields\": metadata_fields\n            })\n            return json.dumps(result, indent=2)\n        except Exception as e:\n            logger.error(\"Error getting objects with metadata: {0}\".format(str(e)))\n            return \"Error getting objects with metadata: {0}\".format(str(e))\n\n    def capture_viewport(self, ctx: Context, layer: Optional[str] = None, show_annotations: bool = True, max_size: int = 800) -> Image:\n        \"\"\"Capture the current viewport as an image.\n        \n        Args:\n            layer: Optional layer name to filter annotations\n            show_annotations: Whether to show object annotations, this will display the short_id of the object in the viewport you can use the short_id to select specific objects with the get_objects_with_metadata function\n        \n        Returns:\n            An MCP Image object containing the viewport capture\n        \"\"\"\n        try:\n            connection = get_rhino_connection()\n            result = connection.send_command(\"capture_viewport\", {\n                \"layer\": layer,\n                \"show_annotations\": show_annotations,\n                \"max_size\": max_size\n            })\n            \n            if result.get(\"type\") == \"image\":\n                # Get base64 data from Rhino\n                base64_data = result[\"source\"][\"data\"]\n                \n                # Convert base64 to bytes\n                image_bytes = base64.b64decode(base64_data)\n                \n                # Create PIL Image from bytes\n                img = PILImage.open(io.BytesIO(image_bytes))\n                \n                # Convert to PNG format for better quality and consistency\n                png_buffer = io.BytesIO()\n                img.save(png_buffer, format=\"PNG\")\n                png_bytes = png_buffer.getvalue()\n                \n                # Return as MCP Image object\n                return Image(data=png_bytes, format=\"png\")\n                \n            else:\n                raise Exception(result.get(\"text\", \"Failed to capture viewport\"))\n                \n        except Exception as e:\n            logger.error(\"Error capturing viewport: {0}\".format(str(e)))\n            raise\n\n    def execute_rhino_code(self, ctx: Context, code: str) -> str:\n        \"\"\"Execute arbitrary Python code in Rhino.\n        \n        IMPORTANT NOTES FOR CODE EXECUTION:\n        0. DONT FORGET NO f-strings! No f-strings, No f-strings!\n        1. This is Rhino 7 with IronPython 2.7 - no f-strings or modern Python features\n        3. When creating objects, ALWAYS call add_object_metadata(name, description) after creation\n        4. For user interaction, you can use RhinoCommon syntax (selected_objects = rs.GetObjects(\"Please select some objects\") etc.) prompted the suer what to do \n           but prefer automated solutions unless user interaction is specifically requested\n        \n        The add_object_metadata() function is provided in the code context and must be called\n        after creating any object. It adds standardized metadata including:\n        - name (provided by you)\n        - description (provided by you)\n        The metadata helps you to identify and select objects later in the scene and stay organised.\n\n        Common Syntax Errors to Avoid:\n        2. No walrus operator (:=)\n        3. No type hints\n        4. No modern Python features (match/case, etc.)\n        5. No list/dict comprehensions with multiple for clauses\n        6. No assignment expressions in if/while conditions\n\n        Example of proper object creation:\n        <<<python\n        # Create geometry\n        cube_id = rs.AddBox(rs.WorldXYPlane(), 5, 5, 5)\n            # Add metadata - ALWAYS do this after creating an object\n        add_object_metadata(cube_id, \"My Cube\", \"A test cube created via MCP\")\n\n        >>>\n\n        DONT FORGET NO f-strings! No f-strings, No f-strings!\n        \"\"\"\n        try:\n            code_template = \"\"\"\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport json\nimport time\nfrom datetime import datetime\n\ndef add_object_metadata(obj_id, name=None, description=None):\n    \\\"\\\"\\\"Add standardized metadata to an object\\\"\\\"\\\"\n    try:\n        # Generate short ID\n        short_id = datetime.now().strftime(\"%d%H%M%S\")\n        \n        # Get bounding box\n        bbox = rs.BoundingBox(obj_id)\n        bbox_data = [[p.X, p.Y, p.Z] for p in bbox] if bbox else []\n        \n        # Get object type\n        obj = sc.doc.Objects.Find(obj_id)\n        obj_type = obj.Geometry.GetType().Name if obj else \"Unknown\"\n        \n        # Standard metadata\n        metadata = {\n            \"short_id\": short_id,\n            \"created_at\": time.time(),\n            \"layer\": rs.ObjectLayer(obj_id),\n            \"type\": obj_type,\n            \"bbox\": bbox_data\n        }\n        \n        # User-provided metadata\n        if name:\n            rs.ObjectName(obj_id, name)\n            metadata[\"name\"] = name\n        else:\n            auto_name = \"{0}_{1}\".format(obj_type, short_id)\n            rs.ObjectName(obj_id, auto_name)\n            metadata[\"name\"] = auto_name\n            \n        if description:\n            metadata[\"description\"] = description\n            \n        # Store metadata as user text\n        user_text_data = metadata.copy()\n        user_text_data[\"bbox\"] = json.dumps(bbox_data)\n        \n        for key, value in user_text_data.items():\n            rs.SetUserText(obj_id, key, str(value))\n            \n        return {\"status\": \"success\"}\n    except Exception as e:\n        return {\"status\": \"error\", \"message\": str(e)}\n\n\"\"\" + code\n            logger.info(\"Sending code execution request to Rhino\")\n            connection = get_rhino_connection()\n            result = connection.send_command(\"execute_code\", {\"code\": code_template})\n            \n            logger.info(\"Received response from Rhino: {0}\".format(result))\n            \n            # Simplified error handling\n            if result.get(\"status\") == \"error\":\n                error_msg = \"Error: {0}\".format(result.get(\"message\", \"Unknown error\"))\n                logger.error(\"Code execution error: {0}\".format(error_msg))\n                return error_msg\n            else:\n                response = result.get(\"result\", \"Code executed successfully\")\n                logger.info(\"Code execution successful: {0}\".format(response))\n                return response\n                \n        except Exception as e:\n            error_msg = \"Error executing code: {0}\".format(str(e))\n            logger.error(error_msg)\n            return error_msg",
  "language": "python",
  "imports": [
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}