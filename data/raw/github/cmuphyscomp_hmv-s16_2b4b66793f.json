{
  "source_url": "https://github.com/cmuphyscomp/hmv-s16/blob/7863c66ed645b463b72aef98a5c484a18cc9f396/Grasshopper/MocapDemo/pointfilter.py",
  "repo": "cmuphyscomp/hmv-s16",
  "repo_stars": 5,
  "repo_description": "Course resources for the Human-Machine Virtuosity course at Carnegie Mellon University, Spring 2016.",
  "license": "BSD-3-Clause",
  "filepath": "Grasshopper/MocapDemo/pointfilter.py",
  "instruction": "pointfilter.py : filtering operations on Point3d trajectories",
  "code": "# pointfilter.py : filtering operations on Point3d trajectories\n\n# Copyright (c) 2016, Garth Zeglin. All rights reserved. Licensed under the\n# terms of the BSD 3-clause license.\n\n# normal Python packages\nimport math\n\n# use RhinoCommon API\nimport Rhino\n\n# Define a Savitzky-Golay filter for estimating acceleration, assuming a 120Hz sampling rate.\n# See generate_filter_coefficients.py for details.\naccel_filter_coeff = [ 872.727273, 218.181818, -249.350649, -529.870130, -623.376623, -529.870130, -249.350649, 218.181818, 872.727273]\n\nclass Point3dFilter(object):\n\n    def __init__(self, length):\n        # length of the estimation filter\n        self._filter_len = len(accel_filter_coeff)\n\n        # length of the fixed-length history buffer\n        self._buf_len = length\n\n        # Keep track of the number of samples observed.\n        # N.B. the most recent (last) point in the buffer has sample index = self.samples - 1\n        #      the   oldest (first)   point in the buffer has sample index = self.samples - self._buf_len\n        self.samples = 0\n\n        # number of samples to ignore after an event\n        self.blanking = 60\n\n        # sample number for the last 'event' observed\n        self.last_event = None\n\n        # create empty fixed-length data buffers\n        self.reset()\n\n        return\n\n    #================================================================\n    def reset(self):\n        \"\"\"Reset filter state.\"\"\"\n        self._position  = [None] * self._buf_len\n        self._accel     = [None] * self._buf_len\n        self._accel_mag = [None] * self._buf_len\n\n        # reset the blanking interval\n        self.last_event = self.samples - self.blanking\n\n        return\n\n    #================================================================\n    def add_points(self, point_list):\n        \"\"\"Given a list of objects which are either Point3d or None, append them to the\n        fixed-length filter history buffer.  Accelerations are not computed for\n        filter windows including null samples.\n        \"\"\"\n\n        # Compute the pieces of the old and new buffers to concatenate,\n        # considering the possibility there may be an excess of new data.\n        num_new_samples = min(self._buf_len, len(point_list))\n        first_source_sample = len(point_list) - num_new_samples\n        first_new_dest_sample = self._buf_len - num_new_samples\n        self.samples += len(point_list)\n\n        # Construct a new position buffer by concatenating sections of the old\n        # and new lists.  (Note that a ring buffer would be more efficient for a\n        # large buffer size.)\n        self._position = self._position[num_new_samples:] + point_list[first_source_sample:]\n\n        # Compute acceleration vectors for the new data.\n        new_accel = [self._estimate_acceleration(p) for p in range(first_new_dest_sample, self._buf_len)]\n        self._accel = self._accel[num_new_samples:] + new_accel\n\n        # Compute acceleration magnitudes for the new data.\n        new_mag = [(math.sqrt(a*a) if a is not None else None) for a in new_accel]\n        self._accel_mag = self._accel_mag[num_new_samples:] + new_mag\n\n        return\n\n    #================================================================\n    def _estimate_acceleration(self, pos):\n        \"\"\"Estimate the acceleration vector for the given buffer position.  Returns None\n        if acceleration is not computable, either due to missing data, or a\n        position for for which not enough samples are present for the filter\n        length.\n        :param pos:  buffer position for which to compute acceleration, e.g. self._buf_len-1 is the newest data point\n        :return:     Rhino Vector3d object with acceleration, or None if not possible\n        \"\"\"\n\n        # Identify the set of points to filter, returning None if any required\n        # points are out of range.\n        first_datum = pos - self._filter_len + 1\n        if first_datum < 0 or pos >= self._buf_len:\n            return None\n\n        # Check for null values, returning None if any are found\n        pts = self._position[first_datum:first_datum+self._filter_len]\n        if None in pts:\n            return None\n\n        # Compute the dot product of the filter coefficients and the point history.\n        accel = Rhino.Geometry.Point3d(0,0,0)\n        for pt,coeff in zip(pts, accel_filter_coeff):\n            accel = accel + (pt * coeff)\n\n        # A Point multiplied by a scalar is a Point, but the output of the\n        # filter should be interpreted as a Vector.\n        return Rhino.Geometry.Vector3d(accel)\n\n    #================================================================\n    def find_accel_peak(self):\n        \"\"\"Finds the peak acceleration within the current time history.  The\n        offset is the negative time position in samples; 0 is the most\n        current data, -1 one sample prior, etc.\n\n        :return:   (offset, magnitude, acceleration, position) tuple\n        \"\"\"\n\n        maximum = max(self._accel_mag)\n        idx = self._accel_mag.index(maximum)\n        offset = idx - self._buf_len + 1\n        return offset, maximum, self._accel[idx], self._position[idx]\n\n    #================================================================\n    def detect_acceleration_event(self, threshold):\n        \"\"\"Check the point trajectory buffer for a new event in which the acceleration\n        magnitude is greater than a threshold.  A blanking interval is applied\n        after each event to suppress multiple returns from spiky signals.  A\n        sample offset of zero means the most recent point is the peak, other\n        offsets are negative.\n\n        :return: None, or the integer sample offset of the peak\n        \"\"\"\n\n        # check blanking interval to see which samples can be inspected\n        first_buffer_sample = self.samples - self._buf_len\n        after_blanking = self.last_event + self.blanking\n        first_checked_sample = max(first_buffer_sample, after_blanking)\n\n        # if the next data to inspect is still in the future, return False\n        if first_checked_sample >= self.samples:\n            return None\n\n        # Find the maximum within the valid range.  Note that if all values are None this may return None.\n        first_valid_index = first_checked_sample - first_buffer_sample\n        maximum = max(self._accel_mag[first_valid_index:])\n\n        if maximum is not None and maximum > threshold:\n            # compute the offset of the maximum\n            idx = self._accel_mag[first_valid_index:].index(maximum)\n            offset = first_valid_index + idx + 1 - self._buf_len\n\n            # start the blanking interval\n            self.last_event = self.samples - 1 + offset\n\n            # and return a valid peak indication\n            return offset\n\n        else:\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}