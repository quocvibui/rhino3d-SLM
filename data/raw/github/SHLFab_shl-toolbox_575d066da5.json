{
  "source_url": "https://github.com/SHLFab/shl-toolbox/blob/268349a38b254c507c73a5a12f81f05d8af3acfc/command_staging/shlMakeBox.py",
  "repo": "SHLFab/shl-toolbox",
  "repo_stars": 1,
  "repo_description": "SHL Fabrication tools",
  "license": "AGPL-3.0",
  "filepath": "command_staging/shlMakeBox.py",
  "instruction": "SHL Architects 13-06-2019\nSean Lamb (Developer)\n- edits for clarity; fixed global assignment.\nsel@shl.dk",
  "code": "\"\"\"\nSHL Architects 13-06-2019\nSean Lamb (Developer)\n- edits for clarity; fixed global assignment.\nsel@shl.dk\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport System.Drawing as sd\nfrom scriptcontext import doc\nfrom scriptcontext import sticky\n\nimport itertools\n\nimport shl_toolbox_lib.layers as wla\nreload(wla)\n\ndef setGlobals():\n\t#mm.\n\t#default vals\n\tglobal T_IBOX,T_OBOX,J_LEN,LCUT_GAP,TICK_DIST\n\tglobal SELECT_GUIDS\n\t\n\tT_IBOX = 5.5 #inner box thickness (foamcore)\n\tT_OBOX = 2 #outer box thickness (card)\n\tJ_LEN = 20 #joint length\n\tLCUT_GAP = 5 #gap between lasercut curves\n\tTICK_DIST = 10 #length of the guide ticks on the lid\n\n\t#tolerances\n\tglobal TOL_INSIDE,TOL_LID_ABSOLUTE\n\tTOL_INSIDE = 2.5 #\n\tTOL_LID_ABSOLUTE = 0.7 #mm to shave off each dimension in the lid\n\t\n\t#key locations\n\tglobal ORIGIN_IB,ORIGIN_OB\n\tORIGIN_IB = [0,0,0]\n\tORIGIN_OB = [0,100,0]\n\t\n\t#\n\tglobal LCUT_NAMES\n\tlcut_inds = wla.get_lcut_layers()\n\tLCUT_NAMES = wla.ind_to_name(lcut_inds)\n\t\n\tSELECT_GUIDS = []\n\n\n#GENERAL UTILITIES\n#flatten iterables\ndef flatten(lst):\n\tresult = []\n\tfor element in lst:\n\t\tif hasattr(element, '__iter__'):\n\t\t\tresult.extend(flatten(element))\n\t\telse:\n\t\t\tresult.append(element)\n\treturn result\n\n\n#RHINO UTILITIES\ndef add_layer(name,color):\n\tmyLayer = name\n\tlayerInd = doc.Layers.Find(myLayer,False)\n\tif layerInd == -1:\n\t\tlayerInd= doc.Layers.Add(myLayer,color)\n\treturn layerInd\n\n\ndef get_num_joins(dim,J_LEN):\n\tn_joins = int(dim/J_LEN)\n\tif n_joins % 2 == 0:\n\t\tn_joins += 1\n\tif n_joins < 3:\n\t\tn_joins = 3\n\treturn n_joins\n\n#MAIN FUNCTIONS\n#probably easier way to do truncate...\ndef make_join(edge,n_joins,dx,dy,inner,truncate):\n\n\tpts = rs.DivideCurve(edge,n_joins)\n\touter_pts, inner_pts, pairs_ordered = [],[],[]\n\textrapt = None\n\n\touter_pts = rs.AddPoints(pts)\n\tinner_pts = rs.CopyObjects(outer_pts,[dx,dy,0])\n\tif inner == True:\n\t\textrapt = outer_pts[0]\n\t\touter_pts = outer_pts[1:]\n\telse:\n\t\textrapt = inner_pts[0]\n\t\tinner_pts = inner_pts[1:]\n\n\tpairs_o = zip(outer_pts[0::2],outer_pts[1::2])\n\tpairs_i = zip(inner_pts[0::2],inner_pts[1::2])\n\n\tif inner is True:\n\t\tpairs_ordered = flatten(zip(pairs_i,pairs_o))\n\t\tendpts = [inner_pts[-2],inner_pts[-1]]\n\telse:\n\t\tpairs_ordered = flatten(zip(pairs_o,pairs_i))\n\t\tendpts = [outer_pts[-2],outer_pts[-1]]\n\n\tpairs_ordered = pairs_ordered + endpts\n\n\tif truncate is True:\n\t\tv = rs.VectorUnitize(rs.VectorCreate(pairs_ordered[0],pairs_ordered[1]))\n\t\tv = rs.VectorScale(v,T_OBOX)\n\t\trs.MoveObject(pairs_ordered[-1],v)\n\t\trs.MoveObject(pairs_ordered[0],rs.VectorReverse(v))\n\n\n\tpl = rs.AddPolyline(pairs_ordered)\n\trs.DeleteObject(extrapt)\n\trs.DeleteObjects(outer_pts)\n\trs.DeleteObjects(inner_pts)\n\treturn pl\n\n\ndef add_tickmarks(rect,len,offset):\n\n\tc,_ = rs.CurveAreaCentroid(rect)\n\tmirror_v = [c,rs.PointAdd(c,[0,10,0])]\n\tmirror_h = [c,rs.PointAdd(c,[10,0,0])]\n\n\tpts = rs.CurvePoints(rect)\n\tif not pts:\n\t\treturn \"ERROR\"\n\tpts = rs.SortPoints(pts)\n\t# print pts\n\t\n\tt_0 = rs.CopyObject(pts[0],[offset,offset,0])\n\tt_1 = rs.CopyObject(t_0,[len,0,0])\n\tt_2 = rs.CopyObject(t_0,[0,len,0])\n\t\n\ttick = rs.AddPolyline([t_1,t_0,t_2])\n\trs.DeleteObjects([t_0,t_1,t_2])\n\ttick_2 = rs.MirrorObject(tick,mirror_v[0],mirror_v[1],True)\n\tticks_3 = rs.MirrorObjects([tick,tick_2],mirror_h[0],mirror_h[1],True)\n\trs.ObjectLayer([tick,tick_2]+ticks_3,LCUT_NAMES[3])\n\ttick_list = [tick,tick_2]+ticks_3\n\treturn tick_list\n\n\n#make slots and return information for placing them\ndef make_slots(W,L):\n\tg_W = 6\t#20/L or 14/L\n\tg_L = min(W/3,35)\t#3dis\n\n\tgrip = rs.AddRectangle([0,0,0],g_W,g_L)\n\tc,_ = rs.CurveAreaCentroid(grip)\n\treturn [grip,c,g_W,g_L]\n\n#add slots with a specified gap between them\ndef add_slots(rect,grip,gap):\n\tg_crv = grip[0]\n\tg_c = grip[1]\n\tg_W = grip[2]\n\tcenter,_ = rs.CurveAreaCentroid(rect)\n\n\tpr_L = rs.PointAdd(center,[gap/2,0,0])\n\tpr_R = rs.PointAdd(center,[-gap/2,0,0])\n\n\tpg_L = rs.PointAdd(g_c,[-g_W/2,0,0])\n\tpg_R = rs.PointAdd(g_c,[g_W/2,0,0])\n\n\tlgrip = rs.CopyObject(g_crv,rs.VectorCreate(pr_L,pg_L))\n\trgrip = rs.CopyObject(g_crv,rs.VectorCreate(pr_R,pg_R))\n\trs.DeleteObject(g_crv)\n\n\treturn [lgrip,rgrip]\n\n\ndef add_logo(pt_base,W,H):\n\n\t#determine size based on the boxdim. try to do 80mm.\n\thatchdims = (40,14) #WxH\n\tif W > hatchdims[0]*2.2 and H > hatchdims[1]*2.2:\n\t\tscale_factor = 2\n\telse:\n\t\tproportion = 0.5\n\t\tscale_factor = W*(proportion)/40\n\t\tif scale_factor*14*1.05 > H:\n\t\t\tscale_factor = H*0.5/40\n\n\tstr_file = r\"O:\\SHL\\ModelshopCopenhagen\\05_scripting\\Resources\\logo\\shl_logo_40x13_hatch_centered\"\n\tstr_pt = str(pt_base.X) + \",\" + str(pt_base.Y) + \",0\"\n\tstr_scale = str(scale_factor)\n\trs.Command(\"_-Insert _File=_Yes \" + str_file + \" _Block \" + str_pt + \" \" + str_scale + \" _Enter \" , 0)\n\tlogo = rs.LastCreatedObjects()\n\trs.ObjectLayer(logo,LCUT_NAMES[4])\n\tSELECT_GUIDS.extend(logo)\n\n\n#deprecated\ndef add_logo_offcenter(pt_base,W,H):\n\t\"\"\"deprecated\"\"\"\n\tproportion = 0.25\n\tscale_factor = W*(proportion)/40\n\tif scale_factor*14*1.05 > H:\n\t\tscale_factor = H*0.5/40\n\n\tmargin = max(W,H)*0.05+T_OBOX\n\n\tstr_file = r\"O:\\SHL\\ModelshopCopenhagen\\05_scripting\\Resources\\logo\\shl_logo_40x13_hatch_block_centered\"\n\tstr_pt = str(pt_base.X+margin) + \",\" + str(pt_base.Y+margin) + \",0\"\n\tstr_scale = str(scale_factor)\n\t#rs.Command(\"_-Insert _File=_Yes \" + str_file + \" _Block \" + str_pt + \" _Enter _Enter\", 0)\n\trs.Command(\"_-Insert _File=_Yes \" + str_file + \" _Block \" + str_pt + \" \" + str_scale + \" _Enter \" , 0)\n\tlogo = rs.LastCreatedObjects()\n\trs.ObjectLayer(logo,LCUT_NAMES[4])\n\n\n#box functions\ndef get_inner_box(bb_dims, tol, T_IBOX, TOL_INSIDE):\n\t\"\"\"input:\n\tbbdims float(w,l,h). l is longest dimension.\n\ttol float: percentage \"give\" to have\n\tT_IBOX: thickness in mm\n\tT_OBOX: thickness in mm\n\tTOL_INSIDE: additional absolute tolerance added to the inner dimension of the box\n\treturn: \n\tbr: list of four points representing the bounding rectangle of the output.\n\t\"\"\"\n\tW = (1+tol) * bb_dims[0] + T_IBOX*2 + TOL_INSIDE*2\n\tL = (1+tol) * bb_dims[1] + T_IBOX*2 + TOL_INSIDE*2\n\tH = (1+tol) * bb_dims[2] + T_IBOX*2 + TOL_INSIDE*1 - 0.1*T_IBOX\n\t\n\tbottom = rs.AddRectangle(ORIGIN_IB,L-2,W-2)\n\t\n\t# top: overall dim - material + rabet - lid tolerance\n\t# print L - T_IBOX*2 - TOL_LID_ABSOLUTE*2\n\t# print L - T_IBOX*2 - TOL_LID_ABSOLUTE*2\n\ttop = rs.AddRectangle( [0,W+LCUT_GAP,0], L - T_IBOX*2 - TOL_LID_ABSOLUTE*2, W - T_IBOX*2 - TOL_LID_ABSOLUTE*2)\n\t\n\tshort_a = rs.AddRectangle([L+LCUT_GAP, 0, 0], W - 2*T_IBOX, H - T_IBOX)\n\tshort_b = rs.AddRectangle([L+LCUT_GAP, H+LCUT_GAP - T_IBOX ,0], W - 2*T_IBOX, H - T_IBOX)\n\tlong_a = rs.AddRectangle([L+W+LCUT_GAP*2 - 2*T_IBOX, 0, 0], L, H - T_IBOX)\n\tlong_b = rs.AddRectangle([L+W+LCUT_GAP*2 - 2*T_IBOX, H + LCUT_GAP - T_IBOX,0], L, H - T_IBOX)\n\t\n\tgrip_data = make_slots(bb_dims[0],bb_dims[1])\n\tdesired_grip_gap = 130\n\tif bb_dims[1] > desired_grip_gap*1.4:\n\t\tslots = add_slots(top,grip_data,desired_grip_gap)\n\telse:\n\t\tslots = add_slots(top,grip_data,bb_dims[1]/20)\n\trs.ObjectLayer(slots,LCUT_NAMES[1])\n\t\n\tall_geo = [bottom,top,short_a,short_b,long_a,long_b]\n\trs.ObjectLayer(all_geo,LCUT_NAMES[1])\n\t\n\tbr = rs.BoundingBox(all_geo)[:4]\n\t\n\tSELECT_GUIDS.extend(all_geo)\n\tSELECT_GUIDS.extend(slots)\n\treturn br\n\n\ndef get_outer_box(bb_dims, tol, T_IBOX, T_OBOX, TOL_INSIDE, ORIGIN_OB):\n\t\"\"\"input:\n\t\tbbdims float(w,l,h). l is longest dimension.\n\t\ttol float: percentage \"give\" to have\n\t\tT_IBOX: thickness in mm\n\t\tT_OBOX: thickness in mm\n\t\tTOL_INSIDE: additional absolute tolerance added to the inner dimension of the box\n\t\tORIGIN_OB: origin point for placing the curves\n\t\treturn: \n\t\tbr: list of four points representing the bounding rectangle of the output.\n\t\t\"\"\"\n\n\tW = (1+tol) * bb_dims[0] + T_IBOX*2 + T_OBOX*2 + TOL_INSIDE*2\n\tL = (1+tol) * bb_dims[1] + T_IBOX*2 + T_OBOX*2 + TOL_INSIDE*2\n\tH = (1+tol) * bb_dims[2] + T_IBOX*2 + T_OBOX*1 + TOL_INSIDE*1\n\n\tdy = ORIGIN_OB[1] #amount to move everything up by\n\n\tn_joins_W = get_num_joins(W,J_LEN)\n\tn_joins_L = get_num_joins(L,J_LEN)\n\tn_joins_H = get_num_joins(H,J_LEN)\n\t\n\t#get bounding rectangles for each geometry. placeholder; this won't all be necessary\n\tbottom = rs.AddRectangle(ORIGIN_OB, L ,W)\n\ttop = rs.AddRectangle([0,W+LCUT_GAP+dy,0], L, W)\n\tshort_a = rs.AddRectangle([L+LCUT_GAP,dy,0], W, H)\n\tshort_b = rs.AddRectangle([L+LCUT_GAP,H+LCUT_GAP+dy,0], W, H)\n\tlong_a = rs.AddRectangle([L+W+LCUT_GAP*2,dy,0], L, H)\n\tlong_b = rs.AddRectangle([L+W+LCUT_GAP*2,H+LCUT_GAP+dy,0], L, H)\n\n\ttickmarks = add_tickmarks(top,TICK_DIST,T_OBOX+T_IBOX+TOL_LID_ABSOLUTE)\n\tgrip_data = make_slots(bb_dims[0],bb_dims[1])\n\n\tdesired_grip_gap = 130\n\tif bb_dims[1] > desired_grip_gap*1.4:\n\t\tslots = add_slots(top,grip_data,desired_grip_gap)\n\telse:\n\t\tslots = add_slots(top,grip_data,bb_dims[1]/20)\n\n\trs.ObjectLayer(slots,LCUT_NAMES[1])\n\n\t#turn sides into finger joins\n\tsides_b = rs.ExplodeCurves(bottom)\n\tjb_0 = make_join(sides_b[0],n_joins_L,0,T_OBOX,True,True)\n\tjb_2 = make_join(sides_b[2],n_joins_L,0,-T_OBOX,True,True)\n\tjb_1 = make_join(sides_b[1],n_joins_W,-T_OBOX,0,True,True)\n\tjb_3 = make_join(sides_b[3],n_joins_W,T_OBOX,0,True,True)\n\n\tsides_s = rs.ExplodeCurves(short_a)\n\tjs_0 = make_join(sides_s[0],n_joins_W,0,T_OBOX,False,False)\n\tjs_2 = rs.CopyObject(sides_s[2])\n\tjs_1 = make_join(sides_s[1],n_joins_H,-T_OBOX,0,False,False)\n\tjs_3 = make_join(sides_s[3],n_joins_H,T_OBOX,0,False,False)\n\n\tsides_l = rs.ExplodeCurves(long_a)\n\tjl_0 = make_join(sides_l[0],n_joins_L,0,T_OBOX,False,True)\n\tjl_2 = rs.ExtendCurveLength(rs.CopyObject(sides_l[2]),0,2,-T_OBOX)\n\tjl_1 = make_join(sides_l[1],n_joins_H,-T_OBOX,0,True,False)\n\tjl_3 = make_join(sides_l[3],n_joins_H,T_OBOX,0,True,False)\n\n\tsb,ss,sl = rs.JoinCurves([jb_0,jb_1,jb_2,jb_3],True), rs.JoinCurves([js_0,js_1,js_2,js_3],True), rs.JoinCurves([jl_0,jl_1,jl_2,jl_3],True)\n\t\n\tfinal_crvs = sb+ss+sl+[top]\n\trs.ObjectLayer(sb+ss+sl+[top],LCUT_NAMES[1])\n\tfinal_crvs.extend(rs.CopyObjects(ss,[0,H+LCUT_GAP,0]))\n\tfinal_crvs.extend(rs.CopyObjects(sl,[0,H+LCUT_GAP,0]))\n\n\tcenterpt, _ = rs.CurveAreaCentroid(short_a)\n\tadd_logo(centerpt,W,H)\n\n\tall_geo = [bottom,top,short_a,short_b,long_a,long_b]\n\tbr = rs.BoundingBox(all_geo)[:4]\n\t\n\trs.DeleteObjects(sides_b+sides_s+sides_l)\n\trs.DeleteObjects([bottom,short_a,short_b,long_a,long_b])\n\t\n\tSELECT_GUIDS.extend(final_crvs)\n\tSELECT_GUIDS.extend(slots)\n\tSELECT_GUIDS.extend(tickmarks)\n\treturn br\n\n\ndef rc_shl_box():\n\t#get stickies\n\tdefault_inner_thickness = sticky[\"defaultInThickness\"] if sticky.has_key(\"defaultInThickness\") else 5.5\n\tdefault_outer_thickness = sticky[\"defaultOutThickness\"] if sticky.has_key(\"defaultOutThickness\") else 2\n\t\n\tgo = Rhino.Input.Custom.GetObject()\n\tgo.GeometryFilter = Rhino.DocObjects.ObjectType.Brep\n\t\n\topt_inner = Rhino.Input.Custom.OptionDouble(default_inner_thickness,0.2,1000)\n\topt_outer = Rhino.Input.Custom.OptionDouble(default_outer_thickness,0.2,1000)\n\t\n\tgo.SetCommandPrompt(\"Select breps to be boxed or press Enter for manual dimensioning (Suggested: Inner 5.5, Outer 2)\")\n\tgo.AddOptionDouble(\"InnerThickness\", opt_inner)\n\tgo.AddOptionDouble(\"OuterThickness\", opt_outer)\n\t\n\tgo.GroupSelect = True\n\tgo.SubObjectSelect = False\n\tgo.AcceptEnterWhenDone(True)\n\tgo.AcceptNothing(True)\n\tgo.EnableClearObjectsOnEntry(False)\n\tgo.EnableUnselectObjectsOnExit(False)\n\tgo.GroupSelect = True\n\tgo.SubObjectSelect = False\n\tgo.DeselectAllBeforePostSelect = False\n\n\tres = None\n\tbHavePreselectedObjects = False\n\n\tMANUAL = False\n\twhile True:\n\t\tres = go.GetMultiple(1,0)\n\n\t\t#If new option entered, redraw a possible result\n\t\tif res == Rhino.Input.GetResult.Option:\n\t\t\t# print res\n\t\t\tgo.EnablePreSelect(False, True)\n\t\t\tcontinue\n\t\telif res == Rhino.Input.GetResult.Nothing:\n\t\t\tMANUAL = True\n\t\t#If not correct\n\t\telif res != Rhino.Input.GetResult.Object:\n\t\t\treturn Rhino.Commands.Result.Cancel\n\t\t\t\n\t\tif go.ObjectsWerePreselected:\n\t\t\tbHavePreselectedObjects = True\n\t\t\tgo.EnablePreSelect(False, True)\n\t\t\tcontinue\n\t\t\n\t\tbreak\n\t\n\t#set globals according to input\n\tT_IBOX = opt_inner.CurrentValue\n\tT_OBOX = opt_outer.CurrentValue\n\t\n\trs.EnableRedraw(False)\n\t\n\tif MANUAL == False:\n\t\t#Get dimensions from geometry and object lists\n\t\tbrep_obj_list = [] #not used but left in for reference\n\t\tbrep_ids_list = []\n\t\tfor i in xrange(go.ObjectCount):\n\t\t\tb_obj = go.Object(i).Object()\n\t\t\tbrep_obj_list.append(b_obj)\n\t\t\tbrep_ids_list.append(b_obj.Id)\n\t\t\n\t\tbb = rs.BoundingBox(brep_ids_list)\n\t\t\n\t\tbb_x = rs.Distance(bb[0],bb[1])\n\t\tbb_y = rs.Distance(bb[0],bb[3])\n\t\tbb_h = rs.Distance(bb[0],bb[4])\n\t\t\n\telse:\n\t\t#get stickies\n\t\tdefault_x = sticky[\"manualXDim\"] if sticky.has_key(\"manualXDim\") else 200\n\t\tdefault_y = sticky[\"manualYDim\"] if sticky.has_key(\"manualYDim\") else 250\n\t\tdefault_z = sticky[\"manualZDim\"] if sticky.has_key(\"manualZDim\") else 150\n\t\t\n\t\t#Get dimensions manually\n\t\tresult, bb_x = Rhino.Input.RhinoGet.GetNumber(\"X dimension?\",True,default_x)\n\t\tif result != Rhino.Commands.Result.Success: return result\n\t\t\n\t\tresult, bb_y = Rhino.Input.RhinoGet.GetNumber(\"Y dimension?\",True,default_y)\n\t\tif result != Rhino.Commands.Result.Success: return result\n\t\t\n\t\tresult, bb_h = Rhino.Input.RhinoGet.GetNumber(\"Z dimension?\",True,default_z)\n\t\tif result != Rhino.Commands.Result.Success: return result\n\t\n\tbb_w = min(bb_x,bb_y)\n\tbb_l = max(bb_x,bb_y)\n\t\n\tbr = get_inner_box((bb_w,bb_l,bb_h),0,T_IBOX,TOL_INSIDE)\n\tORIGIN_OB = (0,rs.Distance(br[0],br[3]) + LCUT_GAP,0)\n\tget_outer_box((bb_w,bb_l,bb_h),0,T_IBOX,T_OBOX,TOL_INSIDE,ORIGIN_OB)\n\t\n\t#set stickies\n\tsticky[\"defaultInThickness\"] = T_IBOX\n\tsticky[\"defaultOutThickness\"] = T_OBOX\n\tsticky[\"manualXDim\"] = bb_x\n\tsticky[\"manualYDim\"] = bb_y\n\tsticky[\"manualZDim\"] = bb_h\n\t\n\trs.UnselectAllObjects()\n\trs.SelectObjects(SELECT_GUIDS)\n\trs.Redraw()\n\trs.EnableRedraw(True)\n\n\nif __name__ == \"__main__\":\n\tsetGlobals()\n\trc_shl_box()",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}