{
  "source_url": "https://github.com/andrewili/shape-grammar-engine/blob/2859d8021442542561bdd1387deebc85e26f2d03/package_package/package/scripts/layer.py",
  "repo": "andrewili/shape-grammar-engine",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "package_package/package/scripts/layer.py",
  "instruction": null,
  "code": "from package.scripts import frame as f\nimport rhinoscriptsyntax as rs\nfrom package.scripts import settings as s\n\nclass Layer(object):\n    prohibited_characters = [' ', '#']\n\n    def __init__(self):\n        pass\n\n    @classmethod                                ##  done 08-05\n    def new(cls, name_in):\n        \"\"\"Receives:\n            name_in         str. A well-formed and available layer name\n        Adds a layer named <name_in>. Returns:\n            name_out        str. The name of the layer\n        \"\"\"\n        name_out = rs.AddLayer(name_in)\n        return name_out\n\n    @classmethod                                ##  done 08-06\n    def get_layer_name_from_user(cls):\n        \"\"\"Gets a valid name from the user. Returns:\n            name            str. A unique and well-formed layer name\n        \"\"\"\n        message_1 = \"%s %s\" % (\n            \"Enter the layer name.\", \n            \"It must be unique and contain no spaces or '#' characters\")\n        message_2 = \"%s %s %s\" % (\n            \"That name is already in use\",\n            \"or it contains spaces or '#' characters.\",\n            \"Try again\")\n        name = rs.GetString(message_1)\n        while not (\n            cls._is_well_formed(name) and \n            cls._is_available(name)\n        ):\n            name = rs.GetString(message_2)\n        return name\n\n    @classmethod                                ##  called\n    def _is_well_formed(cls, name):\n        \"\"\"Receives:\n            name            str. The name of a layer\n        Returns:\n            boolean         True, if the name is well-formed. False, \n                            otherwise\n        \"\"\"\n        return_value = True\n        for character in cls.prohibited_characters:\n            if character in name:\n                return_value = False\n                break\n        return return_value\n\n    @classmethod                                ##  called\n    def _is_available(cls, name):\n        \"\"\"Receives:\n            name            str. The name of a layer\n        Returns:\n            boolean         True, if the name is available. False, otherwise\n        \"\"\"\n        return_value = not rs.IsLayer(name)\n        return return_value\n\n    @classmethod                                ##  called\n    def get_frame_instance(cls, initial_shape):\n        \"\"\"Receives:\n            initial_shape   str. The name of a layer containing one frame \n                            instance (i.e., an initial shape layer). The value \n                            is guaranteed\n        Returns:\n            frame_instance  guid. The guid of the frame instance on the layer \n                            Isn't this redundant?\n        \"\"\"\n        if not rs.IsLayer(initial_shape):\n            message = \"There is no layer named '%s'\" % initial_shape\n        all_frame_instances = rs.BlockInstances(s.Settings.frame_name)\n        frame_instances_on_layer = []\n        for frame_instance in all_frame_instances:\n            if rs.ObjectLayer(frame_instance) == initial_shape:\n                frame_instances_on_layer.append(frame_instance)\n        n_instances = len(frame_instances_on_layer)\n        if n_instances == 0:\n            message = \"%s %s\" % (\n                \"There is no frame instance\", \n                \"on the layer '%s'\" % initial_shape)\n            return_value = None\n        elif n_instances == 1:\n            message = None\n            return_value = frame_instances_on_layer.pop()\n        else:\n            message = \"%s %s\" % (\n                \"There is more than 1 frame instance\", \n                \"on the layer '%s'\" % initial_shape)\n            return_value = None\n        if message:\n            print(message)\n        return return_value\n\n    @classmethod                                ##  called\n    def get_frame_instance_pair(cls, rule):\n        \"\"\"Receives:\n            rule            str. The name of a layer containing two frame \n                            instances (i.e., a rule layer). The value is \n                            guaranteed\n        Returns:\n            ordered_frame_instance_pair\n                            (guid, guid). A pair of the guids of the two frame \n                            instances on the layer, ordered from left to right \n        \"\"\"\n        all_frame_instances = rs.BlockInstances(s.Settings.frame_name)\n        frame_instances = []\n        for instance_i in all_frame_instances:\n            if rs.ObjectLayer(instance_i) == rule:\n                frame_instances.append(instance_i)\n        p0 = f.Frame.get_instance_position(frame_instances[0])\n        p1 = f.Frame.get_instance_position(frame_instances[1])\n        if p0 < p1:\n            ordered_frame_instance_pair = (\n                frame_instances[0], frame_instances[1])\n        elif p0 > p1:\n            ordered_frame_instance_pair = (\n                frame_instances[1], frame_instances[0])\n        else:\n            pass\n        return ordered_frame_instance_pair\n\n    @classmethod                                ##  called\n    def contains_initial_shape(cls, name):\n        \"\"\"Receives:\n            name            str. The name of the layer\n        Returns:\n            boolean         True, if the layer contains an initial shape. \n                            False, otherwise\n        \"\"\"\n        value = cls._get_number_of_frames(name) == 1\n        return value\n\n    @classmethod                                ##  called\n    def contains_rule(cls, name):\n        \"\"\"Receives:\n            name            str. The name of the layer_name\n        Returns:\n            boolean         True, if the layer contains a rule. False, \n                            otherwise\n        \"\"\"\n        value = cls._get_number_of_frames(name) == 2\n        return value\n\n    @classmethod                                ##  called\n    def _get_number_of_frames(cls, layer_name):\n        \"\"\"Receives:\n            layer_name      str. The name of the layer\n        Returns:\n            n               int. The number of frame instances on the layer\n        \"\"\"\n        frame_name = s.Settings.frame_name\n        if not rs.IsBlock(frame_name):\n            n = 0\n        else:\n            frame_instance_guids = rs.BlockInstances(frame_name)\n            n = 0\n            for guid in frame_instance_guids:\n                if cls._contains_guid(guid, layer_name):\n                    n = n + 1\n        return n\n\n    @classmethod                                ##  called\n    def _contains_guid(cls, frame_guid, layer_name):\n        \"\"\"Receives:\n            frame_guid      The guid of a frame instance\n        Returns:\n            value           boolean. True, if the layer contains the frame \n                            instance. False, otherwise\n        \"\"\"\n        frame_layer_name = rs.ObjectLayer(frame_guid)\n        value = frame_layer_name == layer_name\n        return value\n\n    @classmethod                                ##  called\n    def get_objects_on_layer(cls, frame_instance):\n        \"\"\"Receives:\n            frame_instance  The guid of a frame instance\n        Returns:\n            objects_on_layer\n                            [guid, ...]. A list of the guids of the objects \n                            on the layer containing the frame instance, if \n                            successful\n            None            otherwise\n        \"\"\"\n        layer_name = rs.ObjectLayer(frame_instance)\n        objects_on_layer = rs.ObjectsByLayer(layer_name)\n        return objects_on_layer\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}