{
  "source_url": "https://github.com/AMDlab/TechBlog-Grasshopper-Realtime-Optimization/blob/dafbe7a0cfbd8fc983c053571427049975bee00f/realtime_opt.py",
  "repo": "AMDlab/TechBlog-Grasshopper-Realtime-Optimization",
  "repo_stars": 0,
  "repo_description": "【Grasshopper】SciPyの最適化をリアルタイムで動かそう",
  "license": "MIT",
  "filepath": "realtime_opt.py",
  "instruction": "r: numpy venv: site-packages r: scipy",
  "code": "# r: numpy\n# venv: site-packages\n# r: scipy\nimport scriptcontext as sc\n\nfrom Grasshopper.Kernel.Special import GH_NumberSlider\nfrom System.Threading.Tasks import Task\nfrom System import Decimal\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import Bounds\n\nimport time\nfrom ghpythonlib.treehelpers import list_to_tree\n\nmain_key = \"optimization\"\nstatus_key = \"status\"\nobjective_key = \"objective\"\nobj_der_key = \"obj_der\"\ncons_key = \"cons\"\ncjac_key = \"cjac\"\nparams_key = \"params\"\nsliders_key = \"sliders\"\nresult_key = \"result\"\nstep_key = \"step\"\nhistory_key = \"history\"\n\n\ndef run_process(x):\n    \"\"\"\n    ここでGrasshopperへ処理を流す\n    \"\"\"\n    # 変数が現在のものと一致するか\n    for idx in range(len(x)):\n        if sc.sticky[main_key][params_key][idx] != x[idx]:\n            break\n    else:\n        # 一致する場合、終了する\n        sc.sticky[main_key][status_key] = \"processed\"\n        return\n    # 一致しなかったとき処理を流す\n    sc.sticky[main_key][status_key] = \"processing\"\n    x_list = x.tolist()\n    for idx in range(len(x)):\n        sc.sticky[main_key][sliders_key][idx].SetSliderValue(Decimal(x_list[idx]))\n    for idx in range(len(x)):\n        sc.sticky[main_key][sliders_key][idx].ExpireSolution(True)\n\n    # ここで結果を待つ\n    for i in range(999):\n        time.sleep(0.1)\n        if sc.sticky[main_key][status_key] == \"processed\":\n            break\n    else:\n        # 待てなかったらエラーとして出す\n        sc.sticky[main_key][status_key] = \"processed\"\n        raise Exception(\"loop end\")\n    sc.sticky[main_key][params_key] = np.array(x)\n\n\ndef func(x):\n    run_process(x)\n    obj = sc.sticky[main_key][objective_key]\n    sc.sticky[main_key][step_key] += 1\n    sc.sticky[main_key][history_key][0].append(obj)\n    sc.sticky[main_key][history_key][1].append(x.tolist())\n    return obj\n\n\ndef obj_der_func(x):\n    run_process(x)\n    sc.sticky[main_key][history_key][2].append(x)\n    return sc.sticky[main_key][obj_der_key]\n\n\ndef cons_func(x):\n    run_process(x)\n    sc.sticky[main_key][history_key][3].append(sc.sticky[main_key][cons_key])\n    return sc.sticky[main_key][cons_key]\n\n\ndef cjac_func(x):\n    run_process(x)\n    sc.sticky[main_key][history_key][4].append(x)\n    return sc.sticky[main_key][cjac_key]\n\n\ndef optimization():\n    \"\"\"\n    この関数を別タスクで開いて最適化を動かす。\n    \"\"\"\n    # 制約\n    ineq_cons = {'type': 'ineq',\n                'fun' : lambda x: cons_func(x),\n                'jac' : lambda x: cjac_func(x)}\n\n    # 境界条件\n    bounds = Bounds([0, -0.5], [1.0, 2.0])\n    x0 = np.array([0.5, 0])\n    # すぐに回し始めるとエラーになるため、遅延を挟む\n    time.sleep(0.01)\n    sc.sticky[main_key][result_key] = minimize(func, x0, method='SLSQP', jac=obj_der_func,\n                constraints=[ineq_cons], options={'ftol': 1e-6, 'disp': True},\n                bounds=bounds)\n    sc.sticky[main_key][status_key] = \"complete\"\n    time.sleep(0.01)\n    ghenv.Component.ExpireSolution(True)\n\n\n# 初回とResetが押されたときにリセット\nif not main_key in sc.sticky.keys() or reset:\n    if not run:\n        sc.sticky[main_key] = {}\n        sc.sticky[main_key][step_key] = 0 # ステップ数\n        # 解析の状態を表す。\n        # stop: 待機\n        # processing: GHへ投げて結果待ち\n        # processed: 結果がsc.sticky[main_key][objective_key]に反映された状態\n        # complete: 解析完了\n        sc.sticky[main_key][status_key] = \"stop\"\n        sc.sticky[main_key][objective_key] = 0.\n        sc.sticky[main_key][obj_der_key] = np.zeros(2)\n        sc.sticky[main_key][cons_key] = 0.\n        sc.sticky[main_key][cjac_key] = np.zeros(2)\n        sc.sticky[main_key][params_key] = np.zeros(2)\n        sc.sticky[main_key][sliders_key] = [slider\n            for slider in ghenv.Component.Params.Input[1].Sources\n            if isinstance(slider, GH_NumberSlider)] # 変更するNumberSliderを格納\n        sc.sticky[main_key][result_key] = None # 結果を格納する\n        sc.sticky[main_key][history_key] = [[], [], [], [], []]\n    else:\n        print(\"turn off run.\") # runがTrueの時はリセットされない\n\n\nif run:\n    # processingの場合、数値を渡し、processedにする\n    if sc.sticky[main_key][status_key] == \"processing\":\n        time.sleep(0.01)\n        sc.sticky[main_key][objective_key] = obj\n        sc.sticky[main_key][obj_der_key] = np.array(obj_der)\n        sc.sticky[main_key][cons_key] = cons\n        sc.sticky[main_key][cjac_key] = np.array(cons_jac)\n        sc.sticky[main_key][status_key] = \"processed\"\n\n    # 実行されたとき解析を回す。\n    if sc.sticky[main_key][status_key] == \"stop\":\n        sc.sticky[main_key][step_key] = 0\n        # ここで別タスクとして起動\n        Task.Factory.StartNew(optimization)\n\n    # 解析完了時に結果を返す\n    if sc.sticky[main_key][status_key] == \"complete\":\n        print(sc.sticky[main_key][status_key])\n        print(sc.sticky[main_key][result_key])\n    \nprint(sc.sticky[main_key][status_key])\nprint(sc.sticky[main_key][step_key])\n\nh_obj = sc.sticky[main_key][history_key][0]\nh_x = list_to_tree(sc.sticky[main_key][history_key][1])\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}