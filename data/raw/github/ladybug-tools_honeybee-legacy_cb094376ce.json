{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_ExportEPC.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_ExportEPC.py",
  "instruction": "Export to Energy Performace Calculator (EPC)\n... Add more description here",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, \"Write your names here...\" <\"Write your email address here> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nExport to Energy Performace Calculator (EPC)\n... Add more description here\n\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _HBZones: Honeybee Zones\n    Returns:\n        opaqueSrfsArea: Area of the surfaces for each direction\n        glazedSrfsArea: Area of the glazing surfaces for each direction\n        \n\"\"\"\nghenv.Component.Name = \"Honeybee_ExportEPC\"\nghenv.Component.NickName = 'Export to EPC'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"13 | WIP\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport Grasshopper.Kernel as gh\n\n\ndef main(HBZones):\n    if not sc.sticky.has_key('honeybee_release'):\n        print \"You should first let Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first Honeybee to fly...\")\n        return\n    \n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return\n        \n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    \n    # Call Honeybee zones from the lib\n    HBZones = hb_hive.callFromHoneybeeHive(HBZones)\n    \n    # create an empty dictionary\n    # the structure should be as {type : {construction: { orientation : {area of opaque : area , area of glass : area}}}\n    srfData = {}\n    \n    # produce division angles - keep it to 8 directions for now \n    divisionAngles = rs.frange(0- (360/8), 360 -(360/8), 360/8)\n    \n    # iterate through faces and add them to the dictionary\n    for HBZone in HBZones:\n        for srfCount, HBSrf in enumerate(HBZone.surfaces):\n            # let's add it to the dictionary\n            # I need to know what is the type of the surface (wall, roof, ?)\n            # HBSrf.type will return the type. I'm not sure how much detailed you want the type to be\n            # what is the approach for surfcaes with adjacencies? Here are simple types\n            # srf.type == 0 #wall, # srf.type == 1 #roof, # int(srf.type) == 2 #floor\n            # print \"type: \", HBSrf.type\n            srfType = int(HBSrf.type)\n            \n            # I add the key to the dictionary if it is not there yet\n            if not srfData.has_key(srfType): srfData[srfType] = {}\n            \n            # let's find the construction next as your workflow is based on different construction types\n            # you can get it form a Honeybee surface using HBSrf.EPConstruction\n            # print \"EP construction: \", HBSrf.EPConstruction\n            constr = HBSrf.EPConstruction\n            \n            if not srfData[srfType].has_key(constr):\n                # create a place holder for this construction and put the initial area as 0\n                srfData[srfType][constr] = {}\n            \n            # now let's find the direction of the surface\n            # in case of roof or floor orientation doesn't really matter (or does it?)\n            # so I just add it to dictionary and consider orientation as 0\n            if  srfType!=0:\n                direction = 0\n            else:\n                # otherwise we need to find the direction of the surface\n                # you can use HBSrf.angle2North to get it\n                # print \"angle: \", HBSrf.angle2North\n                # check and see where it stands, 0 will be north, 1 is NE, etc. \n                for direction in range(len(divisionAngles)-1):\n                    if divisionAngles[direction]+(0.5*sc.doc.ModelAngleToleranceDegrees) <= HBSrf.angle2North%360 <= divisionAngles[direction +1]+(0.5*sc.doc.ModelAngleToleranceDegrees):\n                        # here we found the direction\n                        break            \n            # Now that we know direction let's make an empty dictionary for that\n            if not srfData[srfType][constr].has_key(direction):\n                srfData[srfType][constr][direction] = {}\n                srfData[srfType][constr][direction][\"area\"] = 0\n                # in case surface has glazing then create a place holder with\n                # type 5 reperesnts glazing\n                if HBSrf.hasChild:\n                    if not srfData.has_key(5):\n                        srfData[5] = {}\n                    # this is tricky here as I assume that all the glazing in the same wall\n                    # has same construction and I pick the first one - we can change this later if needed\n                    glzConstr = HBSrf.childSrfs[0].EPConstruction\n                    if not srfData[5].has_key(glzConstr):\n                        srfData[5][glzConstr] = {}\n                    if not srfData[5][glzConstr].has_key(direction):\n                        srfData[5][glzConstr][direction] = {}\n                        srfData[5][glzConstr][direction][\"area\"] = 0\n            \n            # add the area to the current area\n            # Honeybee has methods that return area for opaque and glazed area\n            #print \"Opaque area: \", HBSrf.getOpaqueArea()\n            #print \"Glazing area: \", HBSrf.getGlazingArea()\n            srfData[srfType][constr][direction][\"area\"] += HBSrf.getOpaqueArea()\n            if HBSrf.hasChild:\n                srfData[5][HBSrf.childSrfs[0].EPConstruction][direction][\"area\"] += HBSrf.getGlazingArea()\n    # return surface data\n    return srfData\n    # done!\n\n\nsrfTypeDict = {0: \"Wall\", 1 : \"Roof\", 2: \"Floor\", 5 : \"Glazing\"}\ndirectionDict = {0: \"N\", 1 : \"NW\", 2: \"W\", 3: \"SW\", 4 : \"S\", 5 : \"SE\", 6 : \"E\", 7 : \"NE\"}\nprint\nif len(_HBZones)!=0 and _HBZones[0]!=0:\n    srfData = main(_HBZones)\n    if srfData != -1:\n        # now that you have the dictionary you can iterate and produce the lists that you wanted\n        # you only need to remember the structure of dictionary - you can modify the structure to\n        # be easier to iterate but I thought the current structure is easier to read\n        \n        for srfType in srfData.keys():\n            for constr in srfData[srfType].keys():\n                for orientation in range(8):\n                    # if direction is not there it means the area is 0\n                    if not srfData[srfType][constr].has_key(orientation):\n                        continue\n                        print \" surfaces \" + \\\n                              constr + \"; facing \" + \\\n                              directionDict[orientation] + \",\"+ \" 0 \"\n                    else:\n                        if srfType == 1 or srfType == 2:\n                            print constr + \",\"+  \\\n                              str(srfData[srfType][constr][orientation][\"area\"])\n                        else:\n                            print constr + \\\n                              directionDict[orientation] + \",\"+ \\\n                              str(srfData[srfType][constr][orientation][\"area\"])\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}