{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Colored%20Sky%20Visualizer.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Colored Sky Visualizer.py",
  "instruction": "Use this component to visualize a Perez sky as a colored mesh in the Rhino scene using the weather file location, a time and date, and an estimate of turbidity (or amount of particulates in the...",
  "code": "# Visualize a Perez sky\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Trygve Wastvedt <Trygve.Wastvedt@gmail.com>, Chris Mackey <Chris@MackeyArchitecture.com>, and Byron Mardas <byronmardas@gmail.com>\n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to visualize a Perez sky as a colored mesh in the Rhino scene using the weather file location, a time and date, and an estimate of turbidity (or amount of particulates in the atmosphere.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        north_: Input a vector to be used as a true North direction for the sky dome or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n        _location: The output from the importEPW or constructLocation component.  This is essentially a list of text summarizing a location on the earth.\n        --------------- : ...\n        _hour_: A number between 1 and 24 (or a list of numbers) that represent hour(s) of the day to position sun on the sky dome.  The default is 12, which signifies 12:00 PM.\n        _day_: A number between 1 and 31 (or a list of numbers) that represent days(s) of the month to position sun on the sky dome.  The default is 21, which signifies the 21st of the month (when solstices and equinoxes occur).\n        _month_: A number between 1 and 12 (or a list of numbers) that represent months(s) of the year to position sun on the sky dome.  The default is 12, which signifies December.\n        turbidity_: A number between 2 and 15 that represents the level of particulate matter in the atmosphere of the sky.  A rural location might have a low turbidity of 2 while a place like Beijing might have a turbidity as high as 10 or 12.  The default is set to 3 for a relatively clear sky without much pollution.\n        --------------- : ...\n        resolution_: An optional input for the resolution of the generated mesh.  A higher resolution will produce a less-splotchy image but will take longer to calculate.  The default is set to 10 for a realtively quick calculation.\n        scale_: An optional input to scale the dome mesh.  The default is set to 1.\n        centerPt_: An optional point to move the center of the sky dome mesh.  The default is set to the Rhino origin.\n        _projection_: A number to set the projection of the sky hemisphere.  The default is set to draw a 3D hemisphere.  Choose from the following options:\n            0 = 3D hemisphere\n            1 = Orthographic (straight projection to the XY Plane)\n            2 = Stereographic (equi-angular projection to the XY Plane)\n            3 = Cylindrical (unrolled rectangular map of the sky - like a Mercator projection)\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n    Returns:\n        readMe!: ...\n        coloredMesh: A colored mesh of the sky.\n        meshLabels: Time and date lables for the sky mesh.\n        skyColorRGB: The RGB colors that correspond to the vertices of the mesh above.\n        skyColorXYZ: The XYZ colors that correspond to the vertices of the mesh above.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Colored Sky Visualizer\"\nghenv.Component.NickName = 'skyVizualizer'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nJAN_29_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\nimport math\nimport Rhino as rc\nimport scriptcontext as sc\nimport System\nimport Grasshopper.Kernel as gh\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n\ndef checkTheInputs():\n    #Set the Julian year to be used for the analysis.\n    year = 2016\n    \n    #Read out the location data.\n    latitude, longitude, timeZone, elevation = readLocation(_location)\n    \n    #Check if there is a day, month, and hour connected and, if not, set defaults to the winter solstice.\n    checkData1 = True\n    hours = []\n    if _hour_ != []:\n        for hour in _hour_:\n            if hour <= 24 and hour > 0:\n                hours.append(hour)\n            else:\n                checkData1 = False\n        if checkData1 == False:\n            warning = 'Hours must be between 0 and 24.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        hours.append(12)\n    \n    checkData2 = True\n    days = []\n    if _day_ != []:\n        for day in _day_:\n            if day <= 31 and day > 0:\n                days.append(day)\n            else:\n                checkData2 = False\n        if checkData2 == False:\n            warning = 'Days must be between 0 and 31.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        days.append(21)\n    \n    checkData3 = True\n    months = []\n    if _month_ != []:\n        for month in _month_:\n            if month <= 12 and month > 0:\n                months.append(month)\n            else:\n                checkData3 = False\n        if checkData3 == False:\n            warning = 'Months must be between 0 and 12.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        months.append(12)\n    \n    #Caclculate the day of the year for the inputs.\n    doy = []\n    daysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if checkData1 == True and checkData2 == True and checkData3 == True:\n        for month in months:\n            for day in days:\n                doy.append(sum(daysPerMonth[:month-1]) + day-1)\n    \n    #Check the turbidity.\n    checkData4 = True\n    if turbidity_ != None:\n        if turbidity_ <= 15 and turbidity_ > 2:\n            turbidity = turbidity_\n        else:\n            checkData4 = False\n        if checkData4 == False:\n            warning = 'Tubidity must be between 2 and 15.  Otherwise, you are either in outer sapce or on in the atmosphere of Venus.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        turbidity = 3\n    \n    #Check the scale input and set the default to \"True\" if nothing is connected.\n    checkData5 = True\n    if scale_ != None:\n        if scale_ > 0:\n            scale = scale_*20\n        else:\n            checkData5 = False\n        if checkData5 == False:\n            warning = 'Scale must be greater than 0.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else: scale = 20\n    \n    #Check the resolution input and set the default to 10 if nothing is connected.\n    checkData6 = True\n    if resolution_ != None:\n        if resolution_ > 2:\n            resolution = resolution_\n        else:\n            checkData6 = False\n        if checkData6 == False:\n            warning = 'Resolution must be greater than 2.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else: resolution = 10\n    \n    #Check the projection input and set the default to 1 if nothing is connected.\n    if _projection_ != None: projection = _projection_\n    else: projection = 0\n    \n    #Check all of the inputs and return a single value that says whether everything is ok.\n    if checkData1 == True and checkData2 == True and checkData3 == True and checkData4 == True and checkData5 == True and checkData6 == True:\n        checkData = True\n    else: checkData = False\n    \n    \n    return checkData, projection, doy, days, months, year, hours, timeZone, latitude, longitude, turbidity, scale, resolution\n\ndef readLocation(location):\n    locationStr = location.split('\\n')\n    newLocStr = \"\"\n    #clean the idf file\n    for line in locationStr:\n        if '!' in line:\n            line = line.split('!')[0]\n            newLocStr  = newLocStr + line.replace(\" \", \"\")\n        else:\n            newLocStr  = newLocStr + line\n    \n    newLocStr = newLocStr.replace(';', \"\")\n    \n    site, locationName, latitude, longitude, timeZone, elevation = newLocStr.split(',')\n    \n    return float(latitude), float(longitude), float(timeZone), float(elevation)\n\ndef createSkyDomeMesh(basePoint, resolution, scale):\n    #Create a list of altitudes and azimuths based on the resolution.\n    altitudes = []\n    azimuths = []\n    \n    altitudes.append(0)\n    for num in range(resolution):\n        altitudes.append((90/resolution) + num*(90/resolution))\n    \n    azimuths.append(0)\n    for num in range(4*resolution-1):\n        azimuths.append((360/(4*resolution)) + num*(360/(4*resolution)))\n    \n    #Create the vertices of the mesh.\n    meshPts = []\n    startPt = rc.Geometry.Point3d(0, scale*10, 0)\n    for alt in altitudes:\n        for az in azimuths:\n            newPt = rc.Geometry.Point3d(startPt)\n            altRotate = rc.Geometry.Transform.Rotation(math.radians(alt), rc.Geometry.Vector3d.XAxis, rc.Geometry.Point3d.Origin)\n            azRotate = rc.Geometry.Transform.Rotation(-math.radians(az), rc.Geometry.Vector3d.ZAxis, rc.Geometry.Point3d.Origin)\n            newPt.Transform(altRotate)\n            newPt.Transform(azRotate)\n            meshPts.append(newPt)\n    \n    #Create the mesh.\n    uncoloredMesh = rc.Geometry.Mesh()\n    \n    for point in meshPts:\n        uncoloredMesh.Vertices.Add(point)\n    \n    numbersToWatch = range(0, len(meshPts), (resolution*4))\n    for count, point in enumerate(numbersToWatch):\n        numbersToWatch[count] = point -1\n    \n    for pointCount in range(len(meshPts) - (resolution*4)):\n        if pointCount not in numbersToWatch:\n            uncoloredMesh.Faces.AddFace(pointCount, pointCount+1, pointCount+(resolution*4)+1, pointCount+(resolution*4))\n        else:\n            uncoloredMesh.Faces.AddFace(pointCount, pointCount-(resolution*4)+1, pointCount+1, pointCount+(resolution*4))\n    \n    #Move the mesh from the origin to the base point location\n    startPtTransform = rc.Geometry.Transform.Translation(basePoint.X, basePoint.Y, basePoint.Z)\n    uncoloredMesh.Transform(startPtTransform)\n    \n    #Color the mesh with monotone colors.\n    uncoloredMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n    \n    uncoloredMesh.Flip(True, True, True)\n    \n    return uncoloredMesh\n\ndef createRectangularMesh(basePoint, resolution, scale):\n    #Create a list of altitudes and azimuths based on the resolution.\n    altitudes = []\n    azimuths = []\n    \n    altitudes.append(0)\n    for num in range(resolution):\n        altitudes.append((90/resolution) + num*(90/resolution))\n    \n    azimuths.append(0)\n    for num in range(4*resolution-1):\n        azimuths.append((360/(4*resolution)) + num*(360/(4*resolution)))\n    \n    #Create the vertices.\n    meshPts = []\n    startPt = rc.Geometry.Point3d(scale*20, scale*-5, 0)\n    for alt in altitudes:\n        for az in azimuths:\n            newPt = rc.Geometry.Point3d(startPt)\n            altTrans = rc.Geometry.Transform.Translation(0, (alt/9)*scale, 0)\n            azTrans = rc.Geometry.Transform.Translation(-(az/9)*scale, 0, 0)\n            newPt.Transform(altTrans)\n            newPt.Transform(azTrans)\n            meshPts.append(newPt)\n    \n    #Create the mesh.\n    uncoloredMesh = rc.Geometry.Mesh()\n    \n    for point in meshPts:\n        uncoloredMesh.Vertices.Add(point)\n    \n    numbersToWatch = range(0, len(meshPts), (resolution*4))\n    for count, point in enumerate(numbersToWatch):\n        numbersToWatch[count] = point -1\n    \n    for pointCount in range(len(meshPts) - (resolution*4)):\n        if pointCount not in numbersToWatch:\n            uncoloredMesh.Faces.AddFace(pointCount, pointCount+1, pointCount+(resolution*4)+1, pointCount+(resolution*4))\n        else: pass\n    \n    #Move the mesh from the origin to the base point location\n    startPtTransform = rc.Geometry.Transform.Translation(basePoint.X, basePoint.Y, basePoint.Z)\n    uncoloredMesh.Transform(startPtTransform)\n    \n    #Color the mesh with monotone colors.\n    uncoloredMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n    \n    return uncoloredMesh\n\n\ndef main(projection, doy, days, months, year, hours, timeZone, latitude, longitude, turbidity, scale, resolution):\n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_skyColor = sc.sticky[\"ladybug_SkyColor\"]()\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        \n        #Create lists to be output.\n        skyColors = []\n        skyColorsXYZ = []\n        skyMeshes = []\n        skyTextLabels = []\n        allText= []\n        allTextPt = []\n        \n        #Generate a set of base points for the input hours.\n        basePoints = []\n        for dayCount, day in enumerate(doy):\n            for hourCount, hour in enumerate(hours):\n                if projection < 3:\n                    basePoints.append(rc.Geometry.Point3d(hourCount*25*scale, dayCount*25*scale, 0))\n                else:\n                    basePoints.append(rc.Geometry.Point3d(hourCount*45*scale, dayCount*12*scale, 0))\n        \n        #Generate meshes for the base points.\n        uncoloredSkyMeshes = []\n        for point in basePoints:\n            if projection < 3:\n                skyMesh = createSkyDomeMesh(point, resolution, scale)\n                if projection == 1 or projection == 2:\n                    skyMesh = lb_visualization.projectGeo([skyMesh], projection, rc.Geometry.Point3d.Origin, scale*10)[0]\n                uncoloredSkyMeshes.append(skyMesh)\n            else:\n                uncoloredSkyMeshes.append(createRectangularMesh(point, resolution, scale))\n        \n        #If the user has specified a north angle and the visualization is set to dome, rotate the dome.\n        if projection < 3 and north_ != None:\n            northAngle, northVector = lb_preparation.angle2north(north_)\n            for domeCount, dome in enumerate(uncoloredSkyMeshes):\n                northRotation = rc.Geometry.Transform.Rotation(northAngle, rc.Geometry.Vector3d.ZAxis, basePoints[domeCount])\n                dome.Transform(northRotation)\n        \n        #Create a function to split up lists into chunks based on the resolution.\n        def chunks(l, n):\n            if n < 1:\n                n = 1\n            return [l[i:i + n] for i in range(0, len(l), n)]\n        \n        #Create the skies.\n        for dayCount, day in enumerate(doy):\n            for hourCount, hour in enumerate(hours):\n                #Get the color values for the sky and create the mesh.\n                sky = lb_skyColor.createSky(day, year, hour, timeZone, latitude, longitude, turbidity)\n                fullSkyRGB, fullSkyXYZ = lb_skyColor.calcFullSky(int(resolution))\n                fullSkyXYZ = chunks(fullSkyXYZ, resolution+1)\n                fullSkyRGB = chunks(fullSkyRGB, resolution+1)\n                finalFullSkyRGB = []\n                finalFullSkyXYZ = []\n                for count, item in enumerate(fullSkyRGB[0]):\n                    for list in fullSkyRGB:\n                        finalFullSkyRGB.append(list[count])\n                    for list in fullSkyXYZ:\n                        finalFullSkyXYZ.append(list[count])\n                skyColors.append(finalFullSkyRGB)\n                skyColorsXYZ.append(finalFullSkyXYZ)\n                skyMesh = uncoloredSkyMeshes[dayCount*hourCount+hourCount]\n                for vertxCount, color in enumerate(finalFullSkyRGB):\n                    skyMesh.VertexColors[vertxCount] = color\n                skyMeshes.append(skyMesh)\n                \n                #Create the text labels for the sky.\n                legendFont = \"Verdana\"\n                lb_visualization.calculateBB([skyMesh], True)\n                dateText = str(lb_preparation.hour2Date(day*24+hour))\n                textSrf = lb_visualization.text2srf([dateText], [lb_visualization.BoundingBoxPar[5]], legendFont, scale/2.1)\n                skyTextLabels.extend(textSrf)\n                allText.append(dateText)\n                allTextPt.append(lb_visualization.BoundingBoxPar[5])\n                \n                #Print the information for each sky\n                lb_skyColor.info()\n        \n        #If the user has specified a base point, move all of the geometry.\n        if centerPt_ != None:\n            transformMtx = rc.Geometry.Transform.Translation(centerPt_.X, centerPt_.Y, centerPt_.Z)\n            for geo in skyMeshes: geo.Transform(transformMtx)\n            for list in skyTextLabels:\n                for geo in list: geo.Transform(transformMtx)\n        \n        #If the user has set bakeIt to true, bake the geometry.\n        if bakeIt_ > 0:\n            #Make a mesh with all sky domes.\n            totalMesh = rc.Geometry.Mesh()\n            for mesh in skyMeshes: totalMesh.Append(mesh)\n            #Set up the new layer.\n            studyLayerName = 'COLORED_SKIES'\n            placeName = _location.split('\\n')[1]\n            analysisTime = 'DOYs = ' + str(doy) + ', Hours = ' + str(hours)\n            newLayerIndex, l = lb_visualization.setupLayers(analysisTime, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n            #Bake the objects.\n            if bakeIt_ == 1: lb_visualization.bakeObjects(newLayerIndex, totalMesh, None, allText, allTextPt, scale/2.1, legendFont, None, 0, True)\n            else: lb_visualization.bakeObjects(newLayerIndex, totalMesh, None, allText, allTextPt, scale/2.1, legendFont, None, 0, False)\n        \n        \n        return skyMeshes, skyColors, skyColorsXYZ, skyTextLabels\n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return [], [[]], [[]], [[]]\n\n\ncheckData = False\nif _location:\n    checkData, projection, doy, day, month, year, hour, timeZone, latitude,\\\n    longitude, turbidity, scale, resolution = checkTheInputs()\n\nif checkData == True:\n    results = main(projection, doy, day, month, year, hour, timeZone, latitude, longitude, turbidity, scale, resolution)\n    \n    if results!=-1:\n        coloredMesh, colorsRGB, colorXYZ, skyTextLabels = results\n        \n        #Unpack the lists of colors and text surfaces.\n        skyColorRGB = DataTree[Object]()\n        for count, list in enumerate(colorsRGB):\n            for item in list:\n                skyColorRGB.Add(item, GH_Path(count))\n        \n        skyColorXYZ = DataTree[Object]()\n        for count, list in enumerate(colorXYZ):\n            for item in list:\n                skyColorXYZ.Add(item, GH_Path(count))\n        \n        meshLabels = DataTree[Object]()\n        for count, list in enumerate(skyTextLabels):\n            for item in list:\n                meshLabels.Add(item, GH_Path(count))",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}