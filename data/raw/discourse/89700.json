{
  "source_url": "https://discourse.mcneel.com/t/how-to-speed-up-copying-mesh-faces-in-c-api-vs-python-rhinocommon/89700",
  "topic_id": 89700,
  "title": "How to speed up copying mesh faces in C++ API vs Python + Rhinocommon",
  "question": "@dale\n, \n@stevebaer\n,\n\n\nI am trying to improve the performance of my Python script by moving the Python code below, which creates several meshes, into a C++ API DLL.\n\n\nfaces = meshGeo.Faces\n# Make .NET List of all faces to use in AddFaces below.\nfacesL = List[MeshFace](nvert)\n# Add all faces from unified mesh to .NET List for quick access using GetRange.\nfacesL.AddRange(faces)\nlower_index = 0\n# Make duplicate mesh without faces.\ndmesh = meshGeo.DuplicateMesh()\ndmesh.Faces.Clear()\nlast_index = upper_face_index[-1][0]\nfor upper_index, name in upper_face_index:\n\t# If not last mesh, duplicate the no-faces mesh.\n\tif upper_index != last_index: next_meshGeo = dmesh.DuplicateMesh()\n\t# Use dmesh when making the last mesh.\n\telse: next_meshGeo = dmesh\n\t# Copy over the faces used in this mesh.\n\tnext_meshGeo.Faces.AddFaces(facesL.GetRange(lower_index, upper_index - lower_index))\n\t# Use upper_index for lower limit in next range.\n\tlower_index = upper_index\n\t# Compact the mesh to remove unused vertices, colors, textures and normals.\n\tnext_meshGeo.Compact()\n\t# Add mesh to document.\n\tdoc.Objects.AddMesh(next_meshGeo)\n\n\n\nThe corresponding C++ API code is:\n\n\nDLLEXPORT void make_meshes(uint32_t doc_serial_number, uint32_t mesh_serial_number, uint32_t nmi, int32_t* upper_face_indices, uint32_t* mesh_serial_numbers) {\n\t// Get doc from RuntimeSerialNumber passed as uint_32_t.\n\tCRhinoDoc* pDoc = CRhinoDoc::FromRuntimeSerialNumber(doc_serial_number);\n\tconst CRhinoObject* obj = pDoc->LookupObjectByRuntimeSerialNumber(mesh_serial_number);\n\tconst ON_Mesh* mesh = ON_Mesh::Cast(obj->Geometry());\n\t// Make new meshes.\n\tint lower_index = 0;\n\t// Duplicate mesh.\n\tON_Mesh dmesh(*mesh);\n\t// Remove all faces.\n\tdmesh.DeleteComponent(ON_COMPONENT_INDEX(ON_COMPONENT_INDEX::mesh_face, 14));\n\t// Get index of last face.\n\tint32_t last_index = upper_face_indices[nmi-1];\n\tfor (int i = 0; i < nmi; ++i) {\n\t\t// Get upper face index for this mesh.\n\t\tint upper_index = upper_face_indices[i];\n\t\t// Find number of faces i...",
  "code_blocks": [
    {
      "code": "void make_meshes(uint32_t doc_serial_number, uint32_t mesh_serial_number, uint32_t nmi, int32_t* upper_face_indices, uint32_t* mesh_serial_numbers) {\n// Get doc from RuntimeSerialNumber passed as uint_32_t.\nCRhinoDoc* pDoc = CRhinoDoc::FromRuntimeSerialNumber(doc_serial_number);\nconst CRhinoObject* obj = pDoc->LookupObjectByRuntimeSerialNumber(mesh_serial_number);\nconst ON_Mesh* mesh = ON_Mesh::Cast(obj->Geometry());\nON_3dmObjectAttributes attribs;\npDoc->GetDefaultObjectAttributes(attribs);\n// Make new meshes.\nint lower_index = 0;\n// Duplicate mesh.\nON_Mesh *dmesh = mesh->Duplicate();\n// Remove all faces.\ndmesh->m_F.SetCount(0);\n\n// Get index of last face.\nint32_t last_index = upper_face_indices[nmi - 1];\nfor (unsigned int i = 0; i < nmi; ++i) {\n\t// Get upper face index for this mesh.\n\tint upper_index = upper_face_indices[i];\n\t// Find number of faces in this mesh.\n\tint num = upper_index - lower_index;\n\t// If not last mesh, duplicate the no-faces mesh.\n\tif (upper_index != last_index) {\n\t\t// Duplicate no-faces mesh.\n\t\tON_Mesh *new_mesh = dmesh->Duplicate(); // Will be deleted by CRhinoMeshObject\n\t\t// Set capacity of new mesh.  Without this, face copying is 30% slower.\n\t\tnew_mesh->m_F.SetCapacity(num);\n\t\t// Copy over faces used in this mesh.\n\t\tfor (int j = 0; j < num; ++j) {\n\t\t\tauto &face = mesh->m_F[lower_index + j];\n\t\t\tnew_mesh->SetQuad(j, face.vi[0], face.vi[1], face.vi[2], face.vi[3]);\n\t\t}\n\t\tnew_mesh->Compact();\n\n\t\tCRhinoMeshObject *meshObject = new CRhinoMeshObject(attribs);\n\n\t\tmeshObject->SetMesh(new_mesh);\n\n\t\tif (!pDoc->AddObject(meshObject)) {\n\t\t\tdelete meshObject;\n\t\t\tmeshObject = NULL;\n\t\t}\n\n\t\tuint32_t mesh_serialNumber = meshObject ? meshObject->RuntimeSerialNumber() : 0;\n\n\t\tmesh_serial_numbers[i] = mesh_serialNumber;\n\t\t// Use upper_index for lower limit in next range.\n\t\tlower_index = upper_index;\n\t}\n}\n\ndelete dmesh;\n}",
      "language": "csharp",
      "author": "mnewberg",
      "post_number": 3,
      "is_solution": false
    },
    {
      "code": "// This is 275% faster than Python using Rhinocommon and .NET List.\n DLLEXPORT void make_meshes(uint32_t doc_serial_number, uint32_t mesh_serial_number,\n \tint32_t nmi, int32_t* upper_face_indices, uint32_t* mesh_serial_numbers,\n \tint32_t& duration_d1, int32_t& duration_d2, int32_t& duration_d3,\n \tint32_t& duration_d4, int32_t& duration_d5, int32_t& duration_d6, int32_t& duration_d7) {\n \t// Get doc from RuntimeSerialNumber passed as uint_32_t.\n \tCRhinoDoc* pDoc = CRhinoDoc::FromRuntimeSerialNumber(doc_serial_number);\n \t// Get starting mesh from doc using its RuntimeSerialNumber.\n \tconst CRhinoObject* obj = pDoc->LookupObjectByRuntimeSerialNumber(mesh_serial_number);\n \t// Get geometry of starting mesh.\n \tconst ON_Mesh* mesh = ON_Mesh::Cast(obj->Geometry());\n \t// Do something with Attributes.\n \tON_3dmObjectAttributes attribs;\n \tpDoc->GetDefaultObjectAttributes(attribs);\n \t//\n \t// Make sub-meshes based upon face indices in upper_face_indices.\n \t//\n \t// Zero lower_index at start.\n \tint lower_index = 0;\n \tchrono::steady_clock::time_point time1 = chrono::steady_clock::now();\n \tfor (int i = 0; i < nmi; ++i) {\n \t\t// Get upper face index for this mesh.\n \t\tint upper_index = upper_face_indices[i];\n \t\t\tchrono::steady_clock::time_point time2 = chrono::steady_clock::now();\n \t\t\t// Create new mesh for sub-mesh.\n \t\t\tON_Mesh* new_mesh = new ON_Mesh();\n \t\t\t//\n \t\t\t// Copy over vertices.\n \t\t\t//\n \t\t\tint32_t count = mesh->m_V.Count();\n \t\t\tnew_mesh->m_V.SetCapacity(count);\n \t\t\tON_3fPoint* vdest = new_mesh->m_V.Array();\n \t\t\t::memcpy(vdest, mesh->m_V.Array(), count*sizeof(ON_3fPoint));\n \t\t\tnew_mesh->m_V.SetCount(count);\n \t\t\t//\n \t\t\t// Copy over colors.\n \t\t\t//\n \t\t\tchrono::steady_clock::time_point time3 = chrono::steady_clock::now();\n \t\t\tint32_t ccount = mesh->m_C.Count();\n \t\t\tif (ccount) {\n \t\t\t\tnew_mesh->m_C.SetCapacity(ccount);\n \t\t\t\tON_Color* dest = new_mesh->m_C.Array();\n \t\t\t\t::memcpy(dest, mesh->m_C.Array(), ccount*sizeof(uint32_t));\n \t\t\t\tnew_mesh->m_C.SetCount(ccount);\n \t\t\t\tmemset(&(new_mesh->m_Ctag), 0, sizeof(new_mesh->m_Ctag));\n \t\t\t}\n \t\t\t//\n \t\t\t// Copy over textures.\n \t\t\t//\n \t\t\tchrono::steady_clock::time_point time4 = chrono::steady_clock::now();\n \t\t\tint32_t tcount = mesh->m_T.Count();\n \t\t\tif (tcount) {\n \t\t\t\tnew_mesh->m_T.SetCapacity(tcount);\n \t\t\t\tON_2fPoint* dest = new_mesh->m_T.Array();\n \t\t\t\t::memcpy(dest, mesh->m_T.Array(),tcount*sizeof(ON_2fPoint));\n \t\t\t\tnew_mesh->m_T.SetCount(tcount);\n \t\t\t\tmemset(&(new_mesh->m_Ttag), 0, sizeof(new_mesh->m_Ttag));\n \t\t\t}\n \t\t\t//\n \t\t\t// Copy over faces for just this sub-mesh.\n \t\t\t//\n \t\t\tchrono::steady_clock::time_point time5 = chrono::steady_clock::now();\n \t\t\t// Find number of faces in this mesh.\n \t\t\tint num = upper_index - lower_index;\n \t\t\t// Set face capacity of new mesh. Copy 30% slower without this.\n \t\t\tnew_mesh->m_F.SetCapacity(num);\n \t\t\t// Set destination of copy to be start of new mesh-face array.\n \t\t\tON_MeshFace* dest = new_mesh->m_F.Array();\n \t\t\t// Offset source by lower_index into starting-mesh face array.\n \t\t\tconst ON_MeshFace* src = mesh->m_F.Array() + lower_index;\n \t\t\t::memcpy(dest, src, num * sizeof(ON_MeshFace));\n \t\t\tnew_mesh->m_F.SetCount(num);\n \t\t\t//\n \t\t\t// Compact the mesh to remove unused vertices, colors &textures.\n \t\t\t//\n \t\t\tchrono::steady_clock::time_point time6 = chrono::steady_clock::now();\n \t\t\tnew_mesh->Compact();\n \t\t\t//\n \t\t\t// Add new mesh to Rhino document and return its RuntimeSerialNumber.\n \t\t\t//\n \t\t\tchrono::steady_clock::time_point time7 = chrono::steady_clock::now();\n \t\t\tCRhinoMeshObject *meshObject = new CRhinoMeshObject(attribs);\n \t\t\tmeshObject->SetMesh(new_mesh);\n \t\t\tif (new_mesh->IsValid()) {\n \t\t\t\tpDoc->AddObject(meshObject);\n \t\t\t\tmesh_serial_numbers[i] = meshObject ? meshObject->RuntimeSerialNumber() : 0;\n \t\t\t}\n \t\t\t// Use upper_index for lower limit of next sub-mesh..\n \t\t\tlower_index = upper_index;\n \t\t\tchrono::steady_clock::time_point time8 = chrono::steady_clock::now();\n \t\t\tduration_d1 += (int)chrono::duration_cast<chrono::microseconds> (time3 - time2).count();\n \t\t\tduration_d2 += (int)chrono::duration_cast<chrono::microseconds> (time4 - time3).count();\n \t\t\tduration_d3 += (int)chrono::duration_cast<chrono::microseconds> (time5 - time4).count();\n \t\t\tduration_d4 += (int)chrono::duration_cast<chrono::microseconds> (time6 - time5).count();\n \t\t\tduration_d5 += (int)chrono::duration_cast<chrono::microseconds> (time7 - time6).count();\n \t\t\tduration_d6 += (int)chrono::duration_cast<chrono::microseconds> (time8 - time7).count();\n \t}\n \t//RhinoApp().RunScript(pDoc->RuntimeSerialNumber(), L\"_Zoom _All _Extents\", 0);\n \tchrono::steady_clock::time_point time9 = chrono::steady_clock::now();\n \tduration_d7 = (int)chrono::duration_cast<chrono::microseconds> (time9 - time1).count();\n }",
      "language": "csharp",
      "author": "Terry_Chappell",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "faces = meshGeo.Faces\n# Make .NET List of all faces to use in AddFaces below.\nfacesL = List[MeshFace](nvert)\n# Add all faces from unified mesh to .NET List for quick access using GetRange.\nfacesL.AddRange(faces)\nlower_index = 0\n# Make duplicate mesh without faces.\ndmesh = meshGeo.DuplicateMesh()\ndmesh.Faces.Clear()\nlast_index = upper_face_index[-1][0]\nfor upper_index, name in upper_face_index:\n\t# If not last mesh, duplicate the no-faces mesh.\n\tif upper_index != last_index: next_meshGeo = dmesh.DuplicateMesh()\n\t# Use dmesh when making the last mesh.\n\telse: next_meshGeo = dmesh\n\t# Copy over the faces used in this mesh.\n\tnext_meshGeo.Faces.AddFaces(facesL.GetRange(lower_index, upper_index - lower_index))\n\t# Use upper_index for lower limit in next range.\n\tlower_index = upper_index\n\t# Compact the mesh to remove unused vertices, colors, textures and normals.\n\tnext_meshGeo.Compact()\n\t# Add mesh to document.\n\tdoc.Objects.AddMesh(next_meshGeo)",
      "language": "unknown",
      "author": "Terry_Chappell",
      "post_number": 1,
      "is_solution": false
    },
    {
      "code": "DLLEXPORT void make_meshes(uint32_t doc_serial_number, uint32_t mesh_serial_number, uint32_t nmi, int32_t* upper_face_indices, uint32_t* mesh_serial_numbers) {\n\t// Get doc from RuntimeSerialNumber passed as uint_32_t.\n\tCRhinoDoc* pDoc = CRhinoDoc::FromRuntimeSerialNumber(doc_serial_number);\n\tconst CRhinoObject* obj = pDoc->LookupObjectByRuntimeSerialNumber(mesh_serial_number);\n\tconst ON_Mesh* mesh = ON_Mesh::Cast(obj->Geometry());\n\t// Make new meshes.\n\tint lower_index = 0;\n\t// Duplicate mesh.\n\tON_Mesh dmesh(*mesh);\n\t// Remove all faces.\n\tdmesh.DeleteComponent(ON_COMPONENT_INDEX(ON_COMPONENT_INDEX::mesh_face, 14));\n\t// Get index of last face.\n\tint32_t last_index = upper_face_indices[nmi-1];\n\tfor (int i = 0; i < nmi; ++i) {\n\t\t// Get upper face index for this mesh.\n\t\tint upper_index = upper_face_indices[i];\n\t\t// Find number of faces in this mesh.\n\t\tint num = upper_index - lower_index;\n\t\t// If not last mesh, duplicate the no-faces mesh.\n\t\tif (upper_index != last_index) {\n\t\t\t// Duplicate no-faces mesh.\n\t\t\tON_Mesh new_mesh(dmesh);\n\t\t\t// Set capacity of new mesh.  Without this, face copying is 30% slower.\n\t\t\tnew_mesh.m_F.SetCapacity(num);\n\t\t\t// Copy over faces used in this mesh.\n\t\t\tfor (int j = 0; j < num; ++j) {\n\t\t\t\tnew_mesh.m_F[j] = mesh->m_F[lower_index + j];\n\t\t\t}\n\t\t\tnew_mesh.Compact();\n\t\t\t// Add new mesh to Rhino document.\n\t\t\tCRhinoMeshObject* meshObject = pDoc->AddMeshObject(new_mesh);\n\t\t\tmesh_serial_numbers[i] = meshObject ? meshObject->RuntimeSerialNumber() : 0;\n\t\t\t// Use upper_index for lower limit in next range.\n\t\t\tlower_index = upper_index;\n\t\t}",
      "language": "csharp",
      "author": "Terry_Chappell",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "materials",
    "mesh",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 10,
  "views": 1077
}