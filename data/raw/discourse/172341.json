{
  "source_url": "https://discourse.mcneel.com/t/how-can-i-split-mesh-by-edges/172341",
  "topic_id": 172341,
  "title": "How can I split mesh by edges?",
  "question": "Cut Cut V0.gh\n (18.0 KB)\n\n\nSo, I have a Pikachu, I like to split it into two parts, the bun and the body.\n\nNow I have the cutter edges as lines and also indexes of the edges.\n\nHow can I split the mesh with these two data?\n\n\nI can do it in many ways, but I really like to know how to split a mesh with its edges.\n\nThanks!\n\n\n\n\nEdit: This guy is not Pikachu, he is Bulbasaur.\n\n\n\n\nimage\n2079Ã—876 113 KB",
  "code_blocks": [
    {
      "code": "\"\"\"Splits a mesh along an edge loop.\"\"\"\n\n__version__ = \"0.01 (2023-12-29)\"\n__author__ = \"diff-arch (diff-arch.xyz)\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport copy\n\nMTOL = sc.doc.ModelAbsoluteTolerance\n\n\ndef get_topo_vertex_indices_rec(mesh, edge, __vindices=[], __count=0):\n    \"\"\"Returns exactly two indices of topology vertices of the mesh\n        that are closest to the end points of the edge.\"\"\"\n    if len(__vindices) == 2 or __count > 1:\n        return __vindices\n        \n    curr_indices = copy.deepcopy(__vindices)\n    end_pts = [edge.From, edge.To]\n\n    for i in range(M.TopologyVertices.Count):\n        pt = rg.Point3d(M.TopologyVertices[i])\n        if end_pts[len(curr_indices)].DistanceToSquared(pt) < MTOL**2:\n            curr_indices.append(i)\n            return get_topo_vertex_indices_rec(\n                mesh, edge, curr_indices, __count=__count+1\n            )\n\n\nif __name__ == \"__main__\":\n    edge_indices = []\n    loop_segments = L.GetSegments()\n\n    for segment in loop_segments:\n        vertex_indices = get_topo_vertex_indices_rec(M, segment)\n        if len(vertex_indices) != 2:\n            continue\n        \n        v1, v2 = vertex_indices\n        edge_idx = M.TopologyEdges.GetEdgeIndex(v1, v2)\n        edge_indices.append(edge_idx)\n\n    if len(edge_indices) != len(loop_segments):\n        raise RuntimeError(\"Unable to detect all loop edges.\")\n\n    M.UnweldEdge(edge_indices, True)\n\n    F = M.ExplodeAtUnweldedEdges()",
      "language": "python",
      "author": "diff-arch",
      "post_number": 8,
      "is_solution": false
    },
    {
      "code": "\"\"\"Splits a mesh along an edge loop.\"\"\"\n\n__version__ = \"0.25 (2023-12-29)\"\n__author__ = \"diff-arch (diff-arch.xyz)\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport copy\n\nMTOL = sc.doc.ModelAbsoluteTolerance\n\n\ndef get_welding_data(mesh):\n    \"\"\"Returns a dictionary mapping mesh topology edge indices to a boolean,\n        indicating whether the edge at index is welded or not.\"\"\"\n    welds = dict()\n    for i in range(mesh.TopologyEdges.Count):\n        welds[i] = not mesh.TopologyEdges.IsEdgeUnwelded(i)\n    return welds\n\ndef get_welded(mesh):\n    \"\"\"Returns a completely welded copy of the input mesh.\"\"\"\n    new_mesh = rg.Mesh()\n    new_mesh.CopyFrom(mesh)\n\n    rtree = rg.RTree()\n    for i in range(new_mesh.Vertices.Count):\n        rtree.Insert(rg.Point3d(new_mesh.Vertices[i]), i)\n\n    deleted = []\n    for i in range(new_mesh.Vertices.Count):\n        if i in deleted:\n            continue\n        \n        vtx = new_mesh.Vertices[i]\n        pt = rg.Point3d(vtx.X, vtx.Y, vtx.Z)\n        search_sphere = rg.Sphere(pt, MTOL)\n\n        closest = []\n        rtree.Search(\n            search_sphere,\n            lambda sender, args: closest.append(args.Id) if i < args.Id else None\n        )\n        \n        if len(closest) < 1:\n            continue\n            \n        for j in closest:\n            faces = new_mesh.Vertices.GetVertexFaces(j)\n            edited = False\n            for k in faces:\n                face = new_mesh.Faces.GetFace(k)\n                for f in range(4):\n                    if face[f] == j:\n                        face[f] = i\n                        edited = True\n                new_mesh.Faces.SetFace(k, face.A, face.B, face.C, face.D)\n            if edited:\n                deleted.append(j)\n                rtree.Remove(rg.Point3d(new_mesh.Vertices[j]), j)\n    \n    new_mesh.Compact()\n    new_mesh.RebuildNormals()\n    return new_mesh\n\n\ndef get_topo_vertex_indices_rec(mesh, edge, __vindices=[], __count=0):\n    \"\"\"Returns exactly two indices of topology vertices of the mesh\n        that are closest to the end points of the edge.\"\"\"\n    if len(__vindices) == 2 or __count > 1:\n        return __vindices\n        \n    curr_indices = copy.deepcopy(__vindices)\n    end_pts = [edge.From, edge.To]\n\n    for i in range(M.TopologyVertices.Count):\n        pt = rg.Point3d(M.TopologyVertices[i])\n        if end_pts[len(curr_indices)].DistanceToSquared(pt) < MTOL**2:\n            curr_indices.append(i)\n            return get_topo_vertex_indices_rec(\n                mesh, edge, curr_indices, __count=__count+1\n            )\n\n\nif __name__ == \"__main__\":\n    welding_data = get_welding_data(M)\n    welded_mesh = get_welded(M)\n\n    edge_indices = []\n    segment_count = 0\n    for edge_loop in L:\n        loop_segments = edge_loop.GetSegments()\n        segment_count += len(loop_segments)\n        for segment in loop_segments:\n            vertex_indices = get_topo_vertex_indices_rec(welded_mesh, segment)\n            if len(vertex_indices) != 2:\n                continue\n\n            v1, v2 = vertex_indices\n            edge_idx = welded_mesh.TopologyEdges.GetEdgeIndex(v1, v2)\n            edge_indices.append(edge_idx)\n\n    if len(edge_indices) != segment_count:\n        raise RuntimeError(\"Unable to detect all loop edges.\")\n\n    welded_mesh.UnweldEdge(edge_indices, True)\n    \n    prev_unwelded = [k for k, v in welding_data.items() if not v]\n    fragments = welded_mesh.ExplodeAtUnweldedEdges()\n\n    for mesh in fragments:\n        edge_indices = []\n        rtree = rg.RTree()\n        for i in range(mesh.TopologyVertices.Count):\n            rtree.Insert(rg.Point3d(mesh.TopologyVertices[i]), i)\n        \n        for ei in prev_unwelded:\n            indices_pair = M.TopologyEdges.GetTopologyVertices(ei)  # original edge vertex pair indices\n            closest = []\n            for vi in indices_pair:\n                vtx = rg.Point3d(M.TopologyVertices[vi])\n                search_sphere = rg.Sphere(vtx, MTOL)\n            \n                rtree.Search(\n                    search_sphere,\n                    lambda sender, args: closest.append(args.Id)\n                )\n            \n            if len(closest) < 2:\n                continue\n\n            edge_idx = mesh.TopologyEdges.GetEdgeIndex(closest[0], closest[1])\n            if not mesh.TopologyEdges.IsEdgeUnwelded(edge_idx):\n                edge_indices.append(edge_idx)\n\n        mesh.UnweldEdge(edge_indices, True)\n        mesh.UnifyNormals(False)\n\n    F =  fragments",
      "language": "python",
      "author": "diff-arch",
      "post_number": 29,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "mesh",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 2,
  "posts_count": 31,
  "views": 2022
}