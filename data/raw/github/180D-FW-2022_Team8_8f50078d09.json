{
  "source_url": "https://github.com/180D-FW-2022/Team8/blob/68505a639845bc3c19153ea08a121ad9fb546e39/modules/MMM-VoiceControl/wake.py",
  "repo": "180D-FW-2022/Team8",
  "repo_stars": 2,
  "repo_description": null,
  "license": "MIT",
  "filepath": "modules/MMM-VoiceControl/wake.py",
  "instruction": "Copyright 2018-2021 Picovoice Inc. You may not use this file except in compliance with the license. A copy of the license is located in the \"LICENSE\" file accompanying this source. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "code": "#\n# Copyright 2018-2021 Picovoice Inc.\n#\n# You may not use this file except in compliance with the license. A copy of the license is located in the \"LICENSE\"\n# file accompanying this source.\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations under the License.\n#\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"[WARN] Overflow - reader is not reading fast enough.\")\nimport argparse\nimport os\nimport struct\nimport wave\nfrom datetime import datetime\nfrom threading import Thread\n\nimport pvporcupine\nfrom pvrecorder import PvRecorder\nimport rhino_engine as rhino\n\nclass PorcupineDemo(Thread):\n    \"\"\"\n    Microphone Demo for Porcupine wake word engine. It creates an input audio stream from a microphone, monitors it, and\n    upon detecting the specified wake word(s) prints the detection time and wake word on console. It optionally saves\n    the recorded audio into a file for further debugging.\n    \"\"\"\n\n    def __init__(\n            self,\n            access_key,\n            library_path,\n            model_path,\n            keyword_paths,\n            sensitivities,\n            input_device_index=None,\n            output_path=None):\n\n        \"\"\"\n        Constructor.\n\n        :param library_path: Absolute path to Porcupine's dynamic library.\n        :param model_path: Absolute path to the file containing model parameters.\n        :param keyword_paths: Absolute paths to keyword model files.\n        :param sensitivities: Sensitivities for detecting keywords. Each value should be a number within [0, 1]. A\n        higher sensitivity results in fewer misses at the cost of increasing the false alarm rate. If not set 0.5 will\n        be used.\n        :param input_device_index: Optional argument. If provided, audio is recorded from this input device. Otherwise,\n        the default audio input device is used.\n        :param output_path: If provided recorded audio will be stored in this location at the end of the run.\n        \"\"\"\n\n        super(PorcupineDemo, self).__init__()\n\n        self._access_key = access_key\n        self._library_path = library_path\n        self._model_path = model_path\n        self._keyword_paths = keyword_paths\n        self._sensitivities = sensitivities\n        self._input_device_index = input_device_index\n\n        self._output_path = output_path\n\n    def run(self):\n        \"\"\"\n         Creates an input audio stream, instantiates an instance of Porcupine object, and monitors the audio stream for\n         occurrences of the wake word(s). It prints the time of detection for each occurrence and the wake word.\n         \"\"\"\n\n        keywords = list()\n        for x in self._keyword_paths:\n            keyword_phrase_part = os.path.basename(x).replace('.ppn', '').split('_')\n            if len(keyword_phrase_part) > 6:\n                keywords.append(' '.join(keyword_phrase_part[0:-6]))\n            else:\n                keywords.append(keyword_phrase_part[0])\n\n        porcupine = None\n        recorder = None\n        wav_file = None\n        detection = 10\n        wakeReturn = 0\n        try:\n            porcupine = pvporcupine.create(\n                access_key=self._access_key,\n                library_path=self._library_path,\n                model_path=self._model_path,\n                keyword_paths=self._keyword_paths,\n                sensitivities=self._sensitivities)\n\n            recorder = PvRecorder(device_index=self._input_device_index, frame_length=porcupine.frame_length)\n            recorder.start()\n\n            if self._output_path is not None:\n                wav_file = wave.open(self._output_path, \"w\")\n                wav_file.setparams((1, 2, 16000, 512, \"NONE\", \"NONE\"))\n\n            # print('Using device: %s', recorder.selected_device)\n\n            # print('Listening {')\n            # for keyword, sensitivity in zip(keywords, self._sensitivities):\n            #     print('  %s (%.2f)' % (keyword, sensitivity))\n            # print('}')\n            while True:\n                pcm = recorder.read()\n\n                if wav_file is not None:\n                    wav_file.writeframes(struct.pack(\"h\" * len(pcm), *pcm))\n\n                result = porcupine.process(pcm)\n                if result >= 0:\n                    # if we have detected the correct word, then return 1\n                    #print('[%s] Detected %s' % (str(datetime.now()), keywords[result]))\n                    recorder.stop()\n                    wakeReturn = rhino.main()\n                    print(wakeReturn)\n                    recorder.start()\n\n        except pvporcupine.PorcupineInvalidArgumentError as e:\n            args = (\n                self._access_key,\n                self._library_path,\n                self._model_path,\n                self._keyword_paths,\n                self._sensitivities,\n            )\n            print(\"One or more arguments provided to Porcupine is invalid: \", args)\n            print(\"If all other arguments seem valid, ensure that '%s' is a valid AccessKey\" % self._access_key)\n            raise e\n        except pvporcupine.PorcupineActivationError as e:\n            print(\"AccessKey activation error\")\n            raise e\n        except pvporcupine.PorcupineActivationLimitError as e:\n            print(\"AccessKey '%s' has reached it's temporary device limit\" % self._access_key)\n            raise e\n        except pvporcupine.PorcupineActivationRefusedError as e:\n            print(\"AccessKey '%s' refused\" % self._access_key)\n            raise e\n        except pvporcupine.PorcupineActivationThrottledError as e:\n            print(\"AccessKey '%s' has been throttled\" % self._access_key)\n            raise e\n        except pvporcupine.PorcupineError as e:\n            print(\"Failed to initialize Porcupine\")\n            raise e\n        except KeyboardInterrupt:\n            print('Stopping ...')\n        finally:\n            if porcupine is not None:\n                porcupine.delete()\n\n            if recorder is not None:\n                recorder.delete()\n\n            if wav_file is not None:\n                wav_file.close()\n        #return detection\n        #print(\"wake return before returning = \", wakeReturn)\n        return wakeReturn\n    @classmethod\n    def show_audio_devices(cls):\n        devices = PvRecorder.get_audio_devices()\n\n        for i in range(len(devices)):\n            print('index: %d, device name: %s' % (i, devices[i]))\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('--access_key',\n                        help='AccessKey obtained from Picovoice Console (https://console.picovoice.ai/)',\n                        default=\"4n7j8/reOKePM5xXFp+CmSFnBsgRZ5EF2m9bjghxif/OpZCG/LHcnw==\")\n\n    parser.add_argument(\n        '--keywords',\n        nargs='+',\n        help='List of default keywords for detection. Available keywords: %s' % ', '.join(sorted(pvporcupine.KEYWORDS)),\n        choices=sorted(pvporcupine.KEYWORDS),\n        metavar='')\n\n    parser.add_argument(\n        '--keyword_paths',\n        nargs='+',\n        default=[\"/Users/xuan-huongnguyen/Desktop/Team8/MagicMirror/modules/MMM-VoiceControl/engine_training/wake_engine.ppn\"],\n        help=\"Absolute paths to keyword model files. If not set it will be populated from `--keywords` argument\",)\n\n    parser.add_argument('--library_path', help='Absolute path to dynamic library.', default=pvporcupine.LIBRARY_PATH)\n\n    parser.add_argument(\n        '--model_path',\n        help='Absolute path to the file containing model parameters.',\n        default=pvporcupine.MODEL_PATH)\n\n    parser.add_argument(\n        '--sensitivities',\n        nargs='+',\n        help=\"Sensitivities for detecting keywords. Each value should be a number within [0, 1]. A higher \"\n             \"sensitivity results in fewer misses at the cost of increasing the false alarm rate. If not set 0.5 \"\n             \"will be used.\",\n        type=float,\n        default=None)\n\n    parser.add_argument('--audio_device_index', help='Index of input audio device.', type=int, default=-1)\n\n    parser.add_argument('--output_path', help='Absolute path to recorded audio for debugging.', default=None)\n\n    parser.add_argument('--show_audio_devices', action='store_true')\n\n    args = parser.parse_args()\n\n    if args.show_audio_devices:\n        PorcupineDemo.show_audio_devices()\n    else:\n        if args.access_key is None:\n            raise ValueError(\"AccessKey (--access_key) is required\")\n        if args.keyword_paths is None:\n            if args.keywords is None:\n                raise ValueError(\"Either `--keywords` or `--keyword_paths` must be set.\")\n\n            keyword_paths = [pvporcupine.KEYWORD_PATHS[x] for x in args.keywords]\n        else:\n            keyword_paths = args.keyword_paths\n\n        if args.sensitivities is None:\n            args.sensitivities = [0.5] * len(keyword_paths)\n\n        if len(keyword_paths) != len(args.sensitivities):\n            raise ValueError('Number of keywords does not match the number of sensitivities.')\n\n        PorcupineDemo(\n            access_key=args.access_key,\n            library_path=args.library_path,\n            model_path=args.model_path,\n            keyword_paths=keyword_paths,\n            sensitivities=args.sensitivities,\n            output_path=args.output_path,\n            input_device_index=args.audio_device_index).run()\n\n\nif __name__ == '__main__':\n   main()",
  "language": "python",
  "imports": [],
  "has_docstring": true
}