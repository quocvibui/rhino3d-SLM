{
  "source_url": "https://github.com/caseprince/rhino-python-scripts/blob/639ae6ea1dd6cc00408db4f7a97ae689e61fc589/fib-sphere-fdm_mesh.py",
  "repo": "caseprince/rhino-python-scripts",
  "repo_stars": 0,
  "repo_description": "Parametric lampshades for 3D Printing in RhinoScript",
  "license": "unknown",
  "filepath": "fib-sphere-fdm_mesh.py",
  "instruction": "Fib sphere fdm mesh",
  "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport math, random\nfrom utils.easing import easeInSine, easeOutSine, easeInOutSine\n\nphis = []\n\ndef fibonacci_sphere(samples=1, randomize=True, radius=2.5):\n    rnd = 1.\n    if randomize:\n        rnd = random.random() * samples\n\n    points = []\n    offset = 2.0/samples\n    increment = math.pi * (3.0 - math.sqrt(5.0))\n\n    for i in range(samples - 2):\n        # z = (((i * offset) - 1) + (offset / 2))\n        z = easeInOutSine(i+1, -1, 2, samples)\n\n        r = math.sqrt(1 - pow(z,2))\n\n        phi = ((i+1 + rnd) % samples) * increment\n        phis.append(phi % (math.pi*2))\n\n        x = math.cos(phi) * r * radius\n        y = math.sin(phi) * r * radius\n        z *= -radius\n\n        points.append([x,y,z])\n\n    return points\n\ndef addPts(pt1, pt2):\n    return [pt1[0]+pt2[0], pt1[1]+pt2[1], pt1[2]+pt2[2]]\n\ndef box2pt(p1, p2):\n\n    pt0 = p1\n    pt1 = rs.coerce3dpoint([p2[0], p1[1], p1[2]])\n    pt2 = rs.coerce3dpoint([p2[0], p2[1], p1[2]])\n    pt3 = rs.coerce3dpoint([p1[0], p2[1], p1[2]])\n    pt4 = rs.coerce3dpoint([p1[0], p1[1], p2[2]])\n    pt5 = rs.coerce3dpoint([p2[0], p1[1], p2[2]])\n    pt6 = p2\n    pt7 = rs.coerce3dpoint([p1[0], p2[1], p2[2]])\n\n    return rs.AddBox([pt0, pt1, pt2, pt3, pt4, pt5, pt6, pt7])\n\ndef reset():\n    arr1 = rs.AllObjects()\n    if arr1: rs.DeleteObjects(arr1)\n    rs.Command(\"ClearAllMeshes\")\n    rs.Command(\"ClearUndo\")\n\n# reset()\n\n# 12\" w/ larger petals\nradius_mm = 100\nsq_mm_per_petal = 160\ns = 160\n\nsurfaceArea = 4 * math.pi * radius_mm**2\npetals = 512 # int(surfaceArea / sq_mm_per_petal)\npoints = fibonacci_sphere(petals, False, radius_mm)\n\npetal = rs.GetObject(\"Select Petal\")\npetalInner = rs.GetObject(\"Select Petal Inner\")\n\nrMin = .35\nrMax = .9\nrDiff = rMax - rMin\ni = 0\n\naMin = -45\naMax = -90\n\nnumPts = len(points)\n\nboolean = rs.FirstObject()\n\npetals = []\n\nstart = 20\nend = numPts - 10\n\nfor i in range(end): # numPts): # numPts\n\n    # i += 20\n\n    pt = points[i]\n\n    vector = rs.VectorCreate(pt, [0,0,0])\n    newPetal = rs.CopyObject(petal, vector)\n    petalSet = [newPetal]\n    \n    # if len(petals) > 50: \n      #  petals.pop()\n\n    if i > start and i < end:\n        newPetalInner = rs.CopyObject(petalInner, vector)\n        petalSet = [newPetal, newPetalInner]\n\n    angle = easeInSine(i, aMin, aMax - aMin, numPts)\n    rs.RotateObjects(petalSet, pt, angle, [1,0,0], False)\n\n    if i < numPts / 2:\n        scale = easeOutSine(i, rMin, rDiff, numPts / 2)\n    else:\n        scale = easeInSine(i - (numPts / 2), rMax, -rDiff, numPts / 2)\n    rs.ScaleObjects(petalSet, pt, [scale,scale,scale])\n\n    maxTilt = .25\n\n    tilt = 0 # math.sin(((pt[2]/radius_mm) * math.pi) + (phis[i])) * maxTilt\n    # rs.OrientObject(newPetal, [pt, addPts(pt,[0,0,-1]), addPts(pt,[0,1,0])], [pt, [0,0,0], addPts(pt,[0,0,1])])\n    rs.OrientObject(newPetal, [pt, addPts(pt,[tilt,0,-1]), addPts(pt,[0,1,0])], [pt, [0,0,0], addPts(pt,[0,0,1])])\n    if i > start and i < end:\n        rs.OrientObject(newPetalInner, [pt, addPts(pt,[tilt,0,-1]), addPts(pt,[0,1,0])], [pt, [0,0,0], addPts(pt,[0,0,1])])\n\n    # if i == 20:\n    #     boolean = newPetal\n    # elif i > 20: \n    #     boolean = rs.MeshBooleanUnion([boolean, newPetal])\n\n    if i > start and i < end:\n        petals = rs.MeshBooleanDifference(petals, [newPetalInner])\n\n    petals.insert(0, newPetal)\n\n    i = i + 1\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}