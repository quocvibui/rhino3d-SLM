{
  "source_url": "https://github.com/Hand-and-Machine/TRAvel_Slicer/blob/9e76041ef572288b290e12512c7bc7dfbcb0bbe4/src/outer_travel_utils.py",
  "repo": "Hand-and-Machine/TRAvel_Slicer",
  "repo_stars": 6,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/outer_travel_utils.py",
  "instruction": "Outer travel utils",
  "code": "import math\nimport time\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport extruder_turtle  \nimport turtle_utilities as tu\nfrom extruder_turtle import *\n\nimport Node\nfrom Node import *\n\nimport Graph\nfrom Graph import *\n\nimport contour_utils\nfrom contour_utils import *\n\nimport geometry_utils\nfrom geometry_utils import *\n\n\n# Outer-Travel Reduction code\ndef outer_travel_reduction(t, shape, curves, initial_offset=0.5, debug=False):\n    vert_start_time = time.time()\n\n    global nozzle_width\n    nozzle_width = float(t.get_nozzle_width())\n    global nozzle_height\n    nozzle_height = float(t.get_nozzle_height())\n\n    global xy_plane_crvs\n    xy_plane_crvs = {}\n    global path_overlap\n    path_overlap = {}\n    global overlap_above\n    overlap_above = {}\n    global overlap\n    overlap = {}\n\n    total_height = len(curves)*t.get_layer_height()\n    init_tree = build_height_dependence_tree(t, shape, curves, initial_offset=initial_offset, debug=debug)\n    vert_tree = segment_tree_by_height(t, init_tree, total_height, debug=debug)\n    if len(vert_tree.get_all_nodes([])) > len(init_tree.get_all_nodes([])):\n        raise ValueError(\"There should not be more super nodes than nodes\")\n\n    all_nodes = vert_tree.get_all_nodes([])\n\n    # compute bounding boxes and box containing sub_nodes for each node\n    # this is used to avoid collisions between previously printed nodes during travel\n    for node in all_nodes:\n        try:\n            flat = [data for sub in node.sub_nodes for data in sub.data]\n            flat = [f for ff in flat for f in ff]\n            bb = rs.BoundingBox(flat)\n            try:\n                box = rs.AddBox(bb)\n                node.box = box\n            except:\n                # this may be a single layer\n                try:\n                    z = None\n                    minX = None\n                    maxX = None\n                    minY = None\n                    maxY = None\n                    for pnt in bb:\n                        if minX == None or pnt.X < minX:\n                            minX = pnt.X\n                        if maxX == None or pnt.X > maxX:\n                            maxX = pnt.X\n                        if minY == None or pnt.Y < minY:\n                            minY = pnt.Y\n                        if maxY == None or pnt.Y > maxY:\n                            maxY = pnt.Y\n                        if z == None:\n                            z = pnt.Z\n                    bb = [\n                        rs.CreatePoint(minX, minY, z),\n                        rs.CreatePoint(maxX, minY, z),\n                        rs.CreatePoint(maxX, maxY, z),\n                        rs.CreatePoint(minX, maxY, z),\n                        rs.CreatePoint(minX, minY, z+t.get_layer_height()),\n                        rs.CreatePoint(maxX, minY, z+t.get_layer_height()),\n                        rs.CreatePoint(maxX, maxY, z+t.get_layer_height()),\n                        rs.CreatePoint(minX, maxY, z+t.get_layer_height())]\n                    box = rs.AddBox(bb)\n                    node.box = box\n                except:\n                    print(\"Unable to create box from bounding box: \", bb)\n        except:\n            print(\"Could not get bounding box: \", [rs.ObjectType(f) for f in flat])\n\n    if debug: print(\"Size of grouped height tree: \"+str(len(all_nodes)))\n\n    st_time = time.time()\n\n    # edges are used for debugging and visualization rather than further calculations\n    edges = []\n\n    node_path = []\n    for h in range(int(math.floor(total_height / nozzle_height))+1):\n        nodes_at_height = [node for node in all_nodes if node.height == h]\n        if debug: print(\"Nodes at nozzle height \"+str(h)+\": \"+str(len(nodes_at_height)))\n        if len(nodes_at_height) == 0: break\n\n        # create a graph for this height chunk\n        height_graph = Graph()\n        min_height = 1000000000\n        # add nodes to graph for every super node within the height chunk\n        for node in nodes_at_height:\n            graph_node = Graph_Node(node)\n            graph_node.name = node.name\n            height_graph.add_node(graph_node)\n            # add start nodes to the graph\n            if node.min_sub_height <= min_height:\n                min_height = node.min_sub_height\n\n        prev_node = None\n        if len(node_path)>0: prev_node = node_path[-1]\n        for node in height_graph.nodes:\n            if node.data.min_sub_height == min_height:\n                weight = 0\n                if prev_node!=None:\n                    flat = [f for ff in node.data.sub_nodes[0].data for f in ff]\n                    if len(flat) > 1:\n                        closest_pnt_end = rs.PointClosestObject(prev_node.data.sub_nodes[-1].center_point, [f for ff in node.data.sub_nodes[0].data for f in ff])[1]\n                    elif len(flat) == 1:\n                        closest_pnt_end = rs.EvaluateCurve(flat[0], rs.CurveClosestPoint(flat[0], prev_node.data.sub_nodes[-1].center_point))\n                    else:\n                        print(\"That shouldn't be possible\")\n                    weight = rs.Distance(prev_node.data.sub_nodes[-1].center_point, closest_pnt_end)\n\n                height_graph.starts.append((node, weight))\n                node.start = True\n\n        # add edges to graph\n        for graph_node in height_graph.nodes:\n            # edges related to height dependency\n            node1 = graph_node.data\n            for child in node1.children:\n                if child in nodes_at_height and child!=graph_node.data:\n                    height_graph.add_edge(Graph_Edge(graph_node, height_graph.get_node(child), 0))\n\n                    closest_pnt_end = rs.PointClosestObject(node1.sub_nodes[-1].center_point, [f for ff in child.sub_nodes[0].data for f in ff])[1]\n                    edges.append(rs.AddCurve([node1.sub_nodes[-1].center_point, closest_pnt_end]))\n\n            # edges related to travel between nodes\n            direct_relations = node1.get_all_descendants([]) + node1.get_all_ancestors([])\n            siblings_and_counsins = [n for n in nodes_at_height if n not in direct_relations]\n            for node2 in siblings_and_counsins:\n                if node2!=node1:\n                    if (node1.min_sub_height == node2.sub_nodes[-1].height+1):\n                        if is_sub_node_overlapping_above(node1.sub_nodes[0], node2.sub_nodes[-1], 0):\n                            height_graph.add_edge(Graph_Edge(graph_node, height_graph.get_node(node2), 0))\n                    elif check_path(height_graph.get_node(node2), [graph_node]):\n                        # only add edge if node1 does not overlap node2\n                        # compute travel between curves, where weight is set as distance between center of start and end curves within node\n                        closest_pnt_end = rs.PointClosestObject(node1.sub_nodes[-1].center_point, [f for ff in node2.sub_nodes[0].data for f in ff])[1]\n                        weight = rs.Distance(node1.sub_nodes[-1].center_point, closest_pnt_end)\n                        height_graph.add_edge(Graph_Edge(graph_node, height_graph.get_node(node2), weight))\n                        if weight!=0:\n                            edge = rs.AddCurve([node1.sub_nodes[-1].center_point, closest_pnt_end])\n                            edges.append(edge)\n\n        height_graph.print_graph_data()\n        height_graph.path_check = check_path\n\n        start_time = time.time()\n        path_section = height_graph.get_shortest_hamiltonian_path()[0]\n        node_path = node_path + path_section\n        if debug:\n            print(\"Hamiltonian Path Search Time: \"+str(round(time.time() - start_time, 3))+\" seconds\")\n            print('')\n\n    path = []\n    for node in node_path:\n        for sub in node.data.sub_nodes:\n            path.append(sub.data)\n\n    if debug:\n        print(\"Graph construction and all hamiltonian paths search time: \"+str(round(time.time() - st_time, 3))+\" seconds\")\n        print(\"Total Outer Travel Reduction time: \"+str(round(time.time() - vert_start_time, 3))+\" seconds\")\n\n    return vert_tree, node_path, path, edges\n\n\ndef build_height_dependence_tree(t, shape, all_curves, initial_offset=0.5, debug=False):\n    start_time = time.time()\n\n    print('Number of layers: '+str(len(all_curves)))\n\n    root = Node('root')\n    root.name = 'root'\n\n    time1 = 0\n\n    #extrude_width = float(t.get_extrude_width())\n    #initial_offset = extrude_width*initial_offset\n    #gap = extrude_width*0.2\n\n    center_point = rs.CreatePoint(0, 0, 0)\n    previous_nodes = [root]\n    for l in range(len(all_curves)):\n        st_1 = time.time()\n        initial_curves = all_curves[l]\n        curve_groups = get_curves(shape, rs.CurveStartPoint(initial_curves[0]).Z, initial_curves=initial_curves)\n        #curve_groups = connect_curve_groups(curve_groups, gap, initial_offset=initial_offset)\n        #curve_groups = [[crv] for crv in curve_groups]\n        time1 = time1 + time.time()-st_1\n\n        outer_curves = []\n        for crvs in curve_groups:\n            # curve grouping function returns outermost\n            # contour as first curve in curve_group list\n            outer_curve = crvs[0]\n            center_point = rs.PointAdd(center_point, get_area_center(outer_curve))\n            outer_curves.append(outer_curve)\n        center_point = rs.CreatePoint(center_point.X/(len(curve_groups) + 1), center_point.Y/(len(curve_groups) + 1), l*t.get_layer_height())\n\n        # combine separated curves if they are within nozzle_width/2 of one another\n        idx_groups = {c:[c] for c in range(len(outer_curves))}\n        for c1 in range(len(outer_curves)):\n            for c2 in range(c1+1, len(outer_curves)):\n                if dynamic_curve_overlap_check(curve_groups[c1], curve_groups[c2], nozzle_width):\n                    idx_groups[c1].append(c2)\n\n        # iterate through idx_groups\n        connection_found = True\n        while connection_found:\n            connection_found = False\n            for c1 in idx_groups.keys():\n                if idx_groups.get(c1):\n                    for c2 in idx_groups[c1]:\n                        if idx_groups.get(c2):\n                            if c2 != c1:\n                                connection_found = True\n                                for crv3 in idx_groups[c2]:\n                                    if crv3 not in idx_groups[c1]:\n                                        idx_groups[c1].append(crv3)\n                                idx_groups.pop(c2)\n\n        groups = []\n        outer_curve_groups = []\n        for i in idx_groups:\n            idxs = idx_groups[i]\n            groups.append([curve_groups[c] for c in idxs])\n            outer_curve_groups.append([outer_curves[c] for c in idxs])\n\n        new_nodes = []\n        for c in range(len(groups)):\n            node = Node(groups[c])\n            node.name = str(l) + str(c)\n            node.depth = l\n            node.height = l\n            node.center_point = center_point\n            new_nodes.append(node)\n            if root in previous_nodes:\n                node.parent = root\n                root.children.append(node)\n            else:\n                for prev_n in previous_nodes:\n                    if not node.parent and is_sub_node_overlapping_above(node, prev_n, 0):\n                        node.parent = prev_n\n                        prev_n.children.append(node)\n\n            if node.parent == None:\n                print('No parent found')\n                node.needs_support = True\n            else: node.needs_support = False\n\n        previous_nodes = new_nodes\n\n    if debug:\n        print('')\n        print(\"Time to get curves: \"+str(round(time1, 3))+\" seconds\")\n        print('')\n        print(\"Initial treeing time: \"+str(round(time.time() - start_time, 3))+\" seconds\")\n        print(\"Initial height tree size: \"+str(len(root.get_all_nodes([]))))\n\n    return root\n\ndef segment_tree_by_height(t, tree, total_height, offset=0.0, debug=False):\n    limit = nozzle_height / t.get_layer_height()\n    super_root = Node('root')\n    super_root.name = 'root'\n    super_root.depth = 0\n    super_root.height = 0\n    idx = 0\n\n    start_time = time.time()\n    for child in tree.children:\n        group_by_height(child, super_root, limit, offset, idx=idx)\n        idx = idx + 1\n    if debug: print(\"Grouping tree by nozzle height: \"+str(round(time.time() - start_time, 3))+\" seconds\")\n\n    s_t = time.time()\n    divide_by_overlap(super_root, total_height, offset)\n    if debug: print(\"Dividing super tree by overlap: \"+str(round(time.time() - s_t, 3))+\" seconds\")\n    return super_root\n\n\ndef group_by_height(node, super_node, height, offset, idx=0):\n    s_node = super_node\n    if node.height // height == super_node.height:\n        super_node.add_sub_node(node)\n    elif node.height // height > super_node.height:\n        if len(super_node.sub_nodes) > 0:\n            new_super = super_node.add_child(str(super_node.data)+'_'+str(idx))\n            new_super.name = new_super.data\n            new_super.height = node.height // height\n            new_super.add_sub_node(node)\n\n            s_node = new_super\n        else:\n            super_node.add_sub_node(node)\n            super_node.height = node.height // height\n    elif node.height // height < super_node.height:\n        raise ValueError(\"Error, node should not be below current super_node\")\n\n    idx = 0\n    if len(node.children) > 1:\n        for child in node.children:\n            new_new_super = s_node.add_child(str(s_node.data)+'_'+str(idx))\n            new_new_super.name = new_new_super.data\n            new_new_super.height = node.height // height\n            group_by_height(child, new_new_super, height, 0)\n            idx = idx + 1\n    elif len(node.children) == 1:\n        group_by_height(node.children[0], s_node, height, idx)\n        idx = idx + 1\n\n\ndef divide_by_overlap(super_root, total_height, offset):\n    height = int(math.floor(total_height / nozzle_height)) + 1\n    nodes = super_root.get_all_nodes([])\n    for h in range(height):\n        nodes_at_height = [node for node in nodes if node.height == h]\n        subdivide_by_overlap(nodes_at_height)\n\n\ndef subdivide_by_overlap(nodes):\n    # create a DFA (all DFAs are NFAs) with:\n    # States = Above (A), Below (B), Neither (N),\n    # Both (X), starting state (S) (also split state)\n    # Final States = { S }\n    # Alphabet = { a, b, n, x } (above, below, neither, both)\n    # Transitions:\n    # d(S, a) = A, d(S, b) = B, d(S, n) = N, d(S, x) = X\n    # d(A, a) = A, d(A, n) = A, d(A, b) = S, d(A, x) = S\n    # d(B, b) = B, d(B, n) = B, d(B, a) = S, d(B, x) = S\n    # d(X, x) = X, d(X, n) = X, d(X, a) = S, d(X, b) = S\n    # d(N, n) = N, d(N, a) = A, d(N, b) = B, d(N, x) = S\n    dfa = NFA()\n    S = Graph_Node('S')\n    A = Graph_Node('A')\n    B = Graph_Node('B')\n    N = Graph_Node('N')\n    X = Graph_Node('X')\n\n    dfa.add_node(S)\n    dfa.add_node(A)\n    dfa.add_node(B)\n    dfa.add_node(N)\n    dfa.add_node(X)\n\n    dfa.set_start(S)\n    dfa.set_final(S)\n\n    dfa.add_to_alphabet('a')\n    dfa.add_to_alphabet('b')\n    dfa.add_to_alphabet('n')\n    dfa.add_to_alphabet('x')\n\n    dfa.transitions[S] = {'a': A, 'b': B, 'n': N, 'x': X}\n    dfa.transitions[A] = {'a': A, 'b': S, 'n': A, 'x': S}\n    dfa.transitions[B] = {'a': S, 'b': B, 'n': B, 'x': S}\n    dfa.transitions[N] = {'a': A, 'b': B, 'n': N, 'x': S}\n    dfa.transitions[X] = {'a': S, 'b': S, 'n': S, 'x': X}\n\n    splits = {node:[] for node in nodes}\n    for node1 in nodes:\n        # check each sub-layer within the node to see if it overlaps with other\n        # nodes' layers, if those nodes are siblings or cousins of the node\n        for node2 in nodes:\n            other_nodes = node1.get_all_ancestors([]) + node1.get_all_descendants([])\n\n            current = dfa.start\n\n            # if node2 within height chunk is a sibling or cousin\n            if node1 != node2 and node2 not in other_nodes:\n                elem = ''\n\n                for s1 in node1.sub_nodes:\n                    above = False\n                    below = False\n                    for s2 in node2.sub_nodes:\n                        if layer_overlap_check(s1, s2, nozzle_width):\n                            if s1.height > s2.height:\n                                above = True\n                            if s1.height < s2.height:\n                                below = True\n\n                    if above and not below: elem = 'a'\n                    if not above and below: elem = 'b'\n                    if above and below: elem = 'x'\n                    if not above and not below: elem = 'n'\n\n                    # transition in the dfa according element value\n                    current = dfa.transition(current, elem)\n                    if current in dfa.final:\n                        splits[node1].append(s1.height-1)\n\n    for node in splits:\n        for split in splits[node]:\n            split_super_node_at_height(node, split)\n\n\ndef split_super_node_at_height(node, height):\n    subs1 = [s for s in node.sub_nodes if s.height > height]\n    subs2 = [s for s in node.sub_nodes if s.height <= height]\n    if len(subs1) > 0 and len(subs2) > 0:\n        split_node = Node(node.data+'_split_'+str(height))\n        split_node.name = split_node.data\n        split_node.depth = node.depth + 1\n        split_node.height = node.height\n        split_node.children = [child for child in node.children]\n        split_node.parent = node\n        split_node.sub_nodes = subs1\n        split_node.min_sub_height = subs1[0].height\n        split_node.max_sub_height = subs1[-1].height\n\n        node.children = [split_node]\n        node.sub_nodes = subs2\n        node.min_sub_height = subs2[0].height\n        node.max_sub_height = subs2[-1].height\n\n        descendants = split_node.get_all_descendants([])\n        for d in descendants:\n            d.depth = d.depth + 1\n        #print(\"Split node \"+str(node.name)+\" at height \"+str(height)+\": from \"+str(subs2.min_sub_height)+\" to \"+ str(subs1.max_sub_height))\n    else:\n        print(\"Split called on node \"+str(node.name)+\" that divides poorly at height \"+str(height)+\", \"+str(len(node.sub_nodes))+\": from \"+str(node.min_sub_height)+\" to \"+ str(node.max_sub_height))\n\n\ndef union_curves(curves):\n    if curves!=None:\n        if len(curves) > 1:\n            try:\n                return rs.CurveBooleanUnion([curve for curve in curves if rs.IsCurve(curve) and rs.IsCurveClosed(curve)])\n            except Exception as err:\n                for curve in curves:\n                    print(curve, rs.ObjectType(curve))\n                raise ValueError(err)\n        elif len(curves) == 1:\n            return [curve for curve in curves if curve!=None and rs.IsCurve(curve) and rs.IsCurveClosed(curve)]\n        else:\n            raise ValueError(\"Called union_curves with no curves\")\n\n\ndef union_curves_on_xy_plane(curves):\n    if curves!=None:\n        if len(curves) > 1:\n            try:\n                return rs.CurveBooleanUnion([rs.CopyObject(curve, [0, 0, -rs.CurveStartPoint(curve).Z]) for curve in curves if rs.IsCurve(curve) and rs.IsCurveClosed(curve)])\n            except Exception as err:\n                for curve in curves:\n                    print(curve, rs.ObjectType(curve))\n                raise ValueError(err)\n        elif len(curves) == 1:\n            return [rs.CopyObject(curve, [0, 0, -rs.CurveStartPoint(curve).Z]) for curve in curves if curve!=None and rs.IsCurve(curve) and rs.IsCurveClosed(curve)]\n        else:\n            raise ValueError(\"Called union_curves_on_xy_plane with no curves\")\n\n\ndef layer_overlap_check(sub1, sub2, width):\n    if xy_plane_crvs.get(sub1) == None:\n        xy_plane_crvs[sub1] = []\n        for crvs in sub1.data:\n            xy_plane_crvs[sub1].append([rs.CopyObject(curve, [0, 0, -rs.CurveStartPoint(curve).Z]) for curve in crvs if curve!=None and rs.IsCurve(curve) and rs.IsCurveClosed(curve)])\n    if xy_plane_crvs.get(sub2) == None:\n        xy_plane_crvs[sub2] = []\n        for crvs in sub2.data:\n            xy_plane_crvs[sub2].append([rs.CopyObject(curve, [0, 0, -rs.CurveStartPoint(curve).Z]) for curve in crvs if curve!=None and rs.IsCurve(curve) and rs.IsCurveClosed(curve)])\n\n    for curves1 in xy_plane_crvs[sub1]:\n        for curves2 in xy_plane_crvs[sub2]:\n            if dynamic_curve_overlap_check(curves1, curves2, width): return True\n    return False\n\n\ndef dynamic_curve_overlap_check(curves1, curves2, width):\n    if overlap.get(curves1[0]) == None or overlap[curves1[0]].get(curves2[0]) == None or overlap[curves1[0]][curves2[0]].get(width) == None:\n        if overlap.get(curves1[0]) == None: overlap[curves1[0]] = {}\n        if overlap[curves1[0]].get(curves2[0]) == None: overlap[curves1[0]][curves2[0]] = {}\n        overlap[curves1[0]][curves2[0]][width] = curve_overlap_check(curves1, curves2, width)\n\n        if overlap.get(curves2[0]) == None: overlap[curves2[0]] = {}\n        if overlap[curves2[0]].get(curves1[0]) == None: overlap[curves2[0]][curves1[0]] = {}\n        overlap[curves2[0]][curves1[0]][width] = overlap[curves1[0]][curves2[0]][width]\n\n    return overlap[curves1[0]][curves2[0]][width]\n\n\ndef curve_overlap_check(curves1, curves2, width):\n    outer1 = curves1[0]\n    inners1 = curves1[1:]\n\n    outer2 = curves2[0]\n    inners2 = curves2[1:]\n    intersection = rs.PlanarClosedCurveContainment(outer1, outer2, tolerance=width/2)\n    if intersection == 1:\n        # curve 1 intersects curve 2\n        return True\n    elif intersection > 1:\n        if intersection == 2:\n            # outer curve 1 is in outer curve 2\n            outer = outer1\n            inners = inners2\n        if intersection == 3:\n            # outer curve 2 is in outer curve 1\n            outer = outer2\n            inners = inners1\n\n        for inner in inners:\n            if xy_bbox_overlap(outer, inner):\n                intersection = rs.PlanarClosedCurveContainment(outer, inner, tolerance=width/2)\n                if intersection == 1 or intersection==3:\n                    return True\n                elif intersection == 2:\n                    # outer curve is inside an inner curve\n                    return False\n        return True\n    return False\n\n\n# check that no node in path overlaps next_node\ndef check_path(next_node, path, graph=None):\n    # first check that the node preceding next_node has been printed\n    if graph and not next_node.start and graph.get_node(next_node.data.parent) not in path:\n        return False\n\n    for node in path:\n        if path_overlap.get(next_node) == None or path_overlap[next_node].get(node) == None:\n            if path_overlap.get(next_node) == None:\n                path_overlap[next_node] = {}\n            path_overlap[next_node][node] = check_layers_for_overlap(node.data.sub_nodes, next_node.data.sub_nodes)\n\n        if path_overlap[next_node][node]==True:\n            return False\n    return True\n\n\n# if any node in sub_nodes1 overlaps sub_nodes2, return true\ndef check_layers_for_overlap(sub_nodes1, sub_nodes2):\n    # check if sub_nodes1 are all above or on par with sub_nodes2\n    if sub_nodes1[-1].height >= sub_nodes2[0].height:\n        for sub1 in sub_nodes1:\n            for sub2 in sub_nodes2:\n                if is_sub_node_overlapping_above(sub1, sub2, nozzle_width):\n                    return True\n    return False\n\n\n# is sub1 overlapping sub2?\ndef is_sub_node_overlapping_above(sub1, sub2, width):\n    if overlap_above.get(sub1) == None or overlap_above[sub1].get(sub2) == None or overlap_above[sub1][sub2].get(width) == None:\n        if overlap_above.get(sub1) == None:\n            overlap_above[sub1] = {}\n        if overlap_above[sub1].get(sub2) == None:\n            overlap_above[sub1][sub2] = {}\n        overlap_above[sub1][sub2][width] = (sub1.height > sub2.height) and layer_overlap_check(sub1, sub2, width)\n    return overlap_above[sub1][sub2][width]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}