{
  "source_url": "https://github.com/halaaro/ironpython-stubs-solidworks/blob/049d6e8ad0392db80ace54d15be4c3ff840292d2/release/stubs/Rhino/Geometry/Collections.py",
  "repo": "halaaro/ironpython-stubs-solidworks",
  "repo_stars": 2,
  "repo_description": null,
  "license": "NOASSERTION",
  "filepath": "release/stubs/Rhino/Geometry/Collections.py",
  "instruction": "NamespaceTracker represent a CLS namespace.",
  "code": "# encoding: utf-8\r\n# module Rhino.Geometry.Collections calls itself Collections\r\n# from RhinoCommon, Version=5.1.30000.16, Culture=neutral, PublicKeyToken=552281e97c755530\r\n# by generator 1.145\r\n\"\"\" NamespaceTracker represent a CLS namespace. \"\"\"\r\n# no imports\r\n\r\n# no functions\r\n# classes\r\n\r\nclass BrepCurveList(object, IEnumerable[Curve], IEnumerable, IRhinoTable[Curve]):\r\n    \"\"\" Provides access to all the underlying curves in a Brep object. \"\"\"\r\n    def Add(self, curve):\r\n        \"\"\"\r\n        Add(self: BrepCurveList, curve: Curve) -> int\r\r\n        \r\r\n            Adds a curve\r\r\n        \r\r\n            curve: A copy of the curve is added to this brep\r\r\n            Returns: Index that should be used to reference the geometry.\r\r\n                    -1 is returned if the input is \r\r\n             not acceptable.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepCurveList) -> IEnumerator[Curve]\r\r\n        \r\r\n            Get an enumerator that visits all curves.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Curve](enumerable: IEnumerable[Curve], value: Curve) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of curves in this list.\r\r\n\r\r\nGet: Count(self: BrepCurveList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepEdgeList(object, IEnumerable[BrepEdge], IEnumerable, IRhinoTable[BrepEdge]):\r\n    \"\"\" Provides access to all the Edges in a Brep object. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: BrepEdgeList, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, subDomain: Interval, edgeTolerance: float) -> BrepEdge\r\r\n        \r\r\n            Create and add a new edge to this list\r\r\n        Add(self: BrepEdgeList, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, edgeTolerance: float) -> BrepEdge\r\r\n        \r\r\n            Create and add a new edge to this list\r\r\n        Add(self: BrepEdgeList, startVertex: BrepVertex, endVertex: BrepVertex, curve3dIndex: int, edgeTolerance: float) -> BrepEdge\r\r\n        \r\r\n            Create and add a new edge to this list\r\r\n        Add(self: BrepEdgeList, curve3dIndex: int) -> BrepEdge\r\r\n        \r\r\n            Create and add a new edge to this list\r\r\n        Add(self: BrepEdgeList, startVertex: BrepVertex, endVertex: BrepVertex, curve3dIndex: int, subDomain: Interval, edgeTolerance: float) -> BrepEdge\r\r\n        \r\r\n            Create and add a new edge to this list\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepEdgeList) -> IEnumerator[BrepEdge]\r\r\n        \r\r\n            Gets an enumerator that visits all edges.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitEdgeAtParameters(self, edgeIndex, edgeParameters):\r\n        \"\"\" SplitEdgeAtParameters(self: BrepEdgeList, edgeIndex: int, edgeParameters: IEnumerable[float]) -> int \"\"\"\r\n        pass\r\n\r\n    def SplitKinkyEdge(self, edgeIndex, kinkToleranceRadians):\r\n        \"\"\"\r\n        SplitKinkyEdge(self: BrepEdgeList, edgeIndex: int, kinkToleranceRadians: float) -> bool\r\r\n        \r\r\n            Splits the edge into G1 pieces.\r\r\n        \r\r\n            edgeIndex: Index of edge to test and split.\r\r\n            kinkToleranceRadians: The split tolerance in radians.\r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[BrepEdge](enumerable: IEnumerable[BrepEdge], value: BrepEdge) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of brep edges.\r\r\n\r\r\nGet: Count(self: BrepEdgeList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepFaceList(object, IEnumerable[BrepFace], IEnumerable, IRhinoTable[BrepFace]):\r\n    \"\"\" Provides access to all the Faces in a Brep object. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: BrepFaceList, surface: Surface) -> BrepFace\r\r\n        \r\r\n            Add a new face to a brep.  This creates a complete face with\r\r\n                    new vertices at the \r\r\n             surface corners, new edges along the surface\r\r\n                    boundary, etc.  The loop of the \r\r\n             returned face has four trims that\r\r\n                    correspond to the south, east, north, and west \r\r\n             side of the \r\r\n                    surface in that order.  If you use this version of Add to\r\r\n                    \r\r\n             add an exiting brep, then you are responsible for using a tool\r\r\n                    like JoinEdges() to \r\r\n             hook the new face to its neighbors.\r\r\n        \r\r\n        \r\r\n            surface: surface is copied\r\r\n        Add(self: BrepFaceList, surfaceIndex: int) -> BrepFace\r\r\n        \r\r\n            Create and add a new face to this list. An incomplete face is added.\r\r\n                    The caller \r\r\n             must create and fill in the loops used by the face.\r\r\n        \r\r\n        \r\r\n            surfaceIndex: index of surface in brep's Surfaces list\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddConeFace(self, vertex, edge, revEdge):\r\n        \"\"\"\r\n        AddConeFace(self: BrepFaceList, vertex: BrepVertex, edge: BrepEdge, revEdge: bool) -> BrepFace\r\r\n        \r\r\n            Add a new face to the brep whose surface geometry is a \r\r\n                    ruled cone with the edge as \r\r\n             the base and the vertex as\r\r\n                    the apex point.\r\r\n        \r\r\n        \r\r\n            vertex: The apex of the cone will be at this vertex.\r\r\n                    The north side of the surface's \r\r\n             parameter\r\r\n                    space will be a singular point at the vertex.\r\r\n        \r\r\n            edge: The south side of the face's surface will run along this edge.\r\r\n            revEdge: true if the new face's outer boundary orientation along\r\r\n                    the edge is opposite the \r\r\n             orientation of edge.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddRuledFace(self, edgeA, revEdgeA, edgeB, revEdgeB):\r\n        \"\"\"\r\n        AddRuledFace(self: BrepFaceList, edgeA: BrepEdge, revEdgeA: bool, edgeB: BrepEdge, revEdgeB: bool) -> BrepFace\r\r\n        \r\r\n            Add a new face to the brep whose surface geometry is a \r\r\n                    ruled surface between two \r\r\n             edges.\r\r\n        \r\r\n        \r\r\n            edgeA: The south side of the face's surface will run along edgeA.\r\r\n            revEdgeA: true if the new face's outer boundary orientation along\r\r\n                    edgeA is opposite the \r\r\n             orientation of edgeA.\r\r\n        \r\r\n            edgeB: The north side of the face's surface will run along edgeA\r\r\n            revEdgeB: true if the new face's outer boundary orientation along\r\r\n                    edgeB is opposite the \r\r\n             orientation of edgeB\r\n        \"\"\"\r\n        pass\r\n\r\n    def ExtractFace(self, faceIndex):\r\n        \"\"\"\r\n        ExtractFace(self: BrepFaceList, faceIndex: int) -> Brep\r\r\n        \r\r\n            Extracts a face from a Brep.\r\r\n        \r\r\n            faceIndex: A face index\r\r\n            Returns: A brep. This can be null.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Flip(self, onlyReversedFaces):\r\n        \"\"\"\r\n        Flip(self: BrepFaceList, onlyReversedFaces: bool)\r\r\n            Flips the orientation of faces.\r\r\n        \r\r\n            onlyReversedFaces: If true, clears all BrepFace.OrientationIsReversed flags by calling BrepFace.Transpose()\r\r\n               \r\r\n                  on each face with a true OrientationIsReversed setting.\r\r\n                    If false, all of the \r\r\n             faces are flipped regardless of their orientation.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepFaceList) -> IEnumerator[BrepFace]\r\r\n        \r\r\n            Gets an enumerators that yields Rhino.Geometry.BrepFace objects.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def RemoveAt(self, faceIndex):\r\n        \"\"\"\r\n        RemoveAt(self: BrepFaceList, faceIndex: int)\r\r\n            Deletes a face at a specified index.\r\r\n        \r\r\n            faceIndex: The index of the mesh face.\r\n        \"\"\"\r\n        pass\r\n\r\n    def RemoveSlits(self):\r\n        \"\"\"\r\n        RemoveSlits(self: BrepFaceList) -> bool\r\r\n        \r\r\n            Remove slit trims and slit boundaries from each face.\r\r\n            Returns: true if any slits were removed\r\n        \"\"\"\r\n        pass\r\n\r\n    def ShrinkFaces(self):\r\n        \"\"\"\r\n        ShrinkFaces(self: BrepFaceList) -> bool\r\r\n        \r\r\n            Shrinks all the faces in this Brep. Sometimes the surfaces extend far beyond the trimming \r\r\n             \r\r\n                    boundaries of the Brep Face. This function will remove those portions of the surfaces \r\r\n          \r\r\n                       that are not used.\r\r\n        \r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitBipolarFaces(self):\r\n        \"\"\"\r\n        SplitBipolarFaces(self: BrepFaceList) -> bool\r\r\n        \r\r\n            Splits surfaces with two singularities, like spheres, so the results\r\r\n                    have at most \r\r\n             one singularity.\r\r\n        \r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitClosedFaces(self, minimumDegree):\r\n        \"\"\"\r\n        SplitClosedFaces(self: BrepFaceList, minimumDegree: int) -> bool\r\r\n        \r\r\n            Splits closed surfaces so they are not closed.\r\r\n        \r\r\n            minimumDegree: If the degree of the surface < min_degree, the surface is not split.\r\r\n                    In some cases, \r\r\n             minimumDegree = 2 is useful to preserve piecewise linear\r\r\n                    surfaces.\r\r\n        \r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitKinkyFace(self, faceIndex, kinkTolerance):\r\n        \"\"\"\r\n        SplitKinkyFace(self: BrepFaceList, faceIndex: int, kinkTolerance: float) -> bool\r\r\n        \r\r\n            Splits a single face into G1 pieces.\r\r\n        \r\r\n            faceIndex: The index of the face to split.\r\r\n            kinkTolerance: Tolerance (in radians) to use for crease detection.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitKinkyFaces(self, kinkTolerance=None, compact=None):\r\n        \"\"\"\r\n        SplitKinkyFaces(self: BrepFaceList, kinkTolerance: float, compact: bool) -> bool\r\r\n        \r\r\n            Splits any faces with creases into G1 pieces.\r\r\n        \r\r\n            kinkTolerance: Tolerance (in radians) to use for crease detection.\r\r\n            compact: If true, the Brep will be compacted if possible.\r\r\n            Returns: true on success, false on failure.\r\r\n        SplitKinkyFaces(self: BrepFaceList, kinkTolerance: float) -> bool\r\r\n        \r\r\n            Splits any faces with creases into G1 pieces.\r\r\n        \r\r\n            kinkTolerance: Tolerance (in radians) to use for crease detection.\r\r\n            Returns: true on success, false on failure.\r\r\n        SplitKinkyFaces(self: BrepFaceList) -> bool\r\r\n        \r\r\n            Splits any faces with creases into G1 pieces.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def StandardizeFaceSurface(self, faceIndex):\r\n        \"\"\"\r\n        StandardizeFaceSurface(self: BrepFaceList, faceIndex: int) -> bool\r\r\n        \r\r\n            Standardizes the relationship between a BrepFace and the 3d surface it\r\r\n                    uses.  When \r\r\n             done, the face will be the only face that references its 3d\r\r\n                    surface, and the \r\r\n             orientations of the face and 3d surface will be the same.\r\r\n        \r\r\n        \r\r\n            faceIndex: The index of the face.\r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    def StandardizeFaceSurfaces(self):\r\n        \"\"\"\r\n        StandardizeFaceSurfaces(self: BrepFaceList)\r\r\n            Standardize all faces in the brep.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[BrepFace](enumerable: IEnumerable[BrepFace], value: BrepFace) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of brep faces.\r\r\n\r\r\nGet: Count(self: BrepFaceList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepLoopList(object, IEnumerable[BrepLoop], IEnumerable, IRhinoTable[BrepLoop]):\r\n    \"\"\" Provides access to all the Loops in a Brep object. \"\"\"\r\n    def Add(self, loopType, face=None):\r\n        \"\"\"\r\n        Add(self: BrepLoopList, loopType: BrepLoopType, face: BrepFace) -> BrepLoop\r\r\n        \r\r\n            Create a new boundary loop on a face.  After you get this\r\r\n                    BrepLoop, you still need \r\r\n             to create the vertices, edges, \r\r\n                    and trims that define the loop.\r\r\n        \r\r\n            Returns: New loop that needs to be filled in\r\r\n        Add(self: BrepLoopList, loopType: BrepLoopType) -> BrepLoop\r\r\n        \r\r\n            Create a new outer boundary loop that runs along the edges\r\r\n                    of the underlying \r\r\n             surface.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddOuterLoop(self, faceIndex):\r\n        \"\"\"\r\n        AddOuterLoop(self: BrepLoopList, faceIndex: int) -> BrepLoop\r\r\n        \r\r\n            Create a new outer boundary loop that runs along the sides\r\r\n                    of the face's surface.  \r\r\n             All the necessary trims, edges,\r\r\n                    and vertices are created and added to the brep.\r\r\n        \r\r\n        \r\r\n            faceIndex: index of face that needs an outer boundary\r\r\n                    that runs along the sides of its surface.\r\r\n            Returns: New outer boundary loop that is complete.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddPlanarFaceLoop(self, faceIndex, loopType, boundaryCurves):\r\n        \"\"\" AddPlanarFaceLoop(self: BrepLoopList, faceIndex: int, loopType: BrepLoopType, boundaryCurves: IEnumerable[Curve]) -> BrepLoop \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepLoopList) -> IEnumerator[BrepLoop]\r\r\n        \r\r\n            Gets an enumerator that visits all edges.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[BrepLoop](enumerable: IEnumerable[BrepLoop], value: BrepLoop) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of brep loops.\r\r\n\r\r\nGet: Count(self: BrepLoopList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepSurfaceList(object, IEnumerable[Surface], IEnumerable, IRhinoTable[Surface]):\r\n    \"\"\" Provides access to all the underlying surfaces in a Brep object. \"\"\"\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepSurfaceList) -> IEnumerator[Surface]\r\r\n        \r\r\n            Gets an enumerator that visits all surfaces.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Surface](enumerable: IEnumerable[Surface], value: Surface) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of surfaces in a brep.\r\r\n\r\r\nGet: Count(self: BrepSurfaceList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepTrimList(object, IEnumerable[BrepTrim], IEnumerable, IRhinoTable[BrepTrim]):\r\n    \"\"\" Provides access to all the Trims in a Brep object \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: BrepTrimList, rev3d: bool, edge: BrepEdge, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new trim that will be part of an inner, outer, or slit loop\r\r\n                    to the brep\r\r\n        \r\r\n            rev3d: true if the edge and trim have opposite directions\r\r\n            edge: 3d edge associated with this trim\r\r\n            curve2dIndex: index of 2d trimming curve\r\r\n            Returns: new trim\r\r\n        Add(self: BrepTrimList, edge: BrepEdge, rev3d: bool, loop: BrepLoop, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new trim that will be part of an inner, outer, or slit loop\r\r\n                    to the brep.\r\r\n        \r\r\n            edge: 3d edge associated with this trim\r\r\n            rev3d: true if the edge and trim have opposite directions\r\r\n            loop: trim is appended to this loop\r\r\n            curve2dIndex: index of 2d trimming curve\r\r\n            Returns: new trim\r\r\n        Add(self: BrepTrimList, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new trim that will be part of an inner, outer, or slit loop\r\r\n                    to the brep.\r\r\n        \r\r\n            curve2dIndex: index of 2d trimming curve\r\r\n            Returns: New Trim\r\r\n        Add(self: BrepTrimList, rev3d: bool, loop: BrepLoop, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new trim that will be part of an inner, outer, or slit loop\r\r\n                    to the brep\r\r\n        \r\r\n            rev3d: true if the edge and trim have opposite directions\r\r\n            loop: trim is appended to this loop\r\r\n            curve2dIndex: index of 2d trimming curve\r\r\n            Returns: new trim\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddCurveOnFace(self, face, edge, rev3d, curve2dIndex):\r\n        \"\"\"\r\n        AddCurveOnFace(self: BrepTrimList, face: BrepFace, edge: BrepEdge, rev3d: bool, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new curve on face to the brep\r\r\n        \r\r\n            face: face that curve lies on\r\r\n            edge: 3d edge associated with this curve on surface\r\r\n            rev3d: true if the 3d edge and the 2d parameter space curve have opposite directions.\r\r\n            curve2dIndex: index of 2d curve in face's parameter space\r\r\n            Returns: new trim that represents the curve on surface\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddSingularTrim(self, vertex, loop, iso, curve2dIndex):\r\n        \"\"\"\r\n        AddSingularTrim(self: BrepTrimList, vertex: BrepVertex, loop: BrepLoop, iso: IsoStatus, curve2dIndex: int) -> BrepTrim\r\r\n        \r\r\n            Add a new singular trim to the brep.\r\r\n        \r\r\n            vertex: vertex along collapsed surface edge\r\r\n            loop: trim is appended to this loop\r\r\n            curve2dIndex: index of 2d trimming curve\r\r\n            Returns: new trim\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepTrimList) -> IEnumerator[BrepTrim]\r\r\n        \r\r\n            Gets an enumerator that visits all edges.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[BrepTrim](enumerable: IEnumerable[BrepTrim], value: BrepTrim) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of brep trims.\r\r\n\r\r\nGet: Count(self: BrepTrimList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass BrepVertexList(object, IEnumerable[BrepVertex], IEnumerable, IRhinoTable[BrepVertex]):\r\n    \"\"\" Provides access to all the Vertices in a Brep object \"\"\"\r\n    def Add(self, point=None, vertexTolerance=None):\r\n        \"\"\"\r\n        Add(self: BrepVertexList, point: Point3d, vertexTolerance: float) -> BrepVertex\r\r\n        \r\r\n            Create and add a new vertex to this list\r\r\n        \r\r\n            vertexTolerance: Use RhinoMath.UnsetTolerance if you are unsure\r\r\n        Add(self: BrepVertexList) -> BrepVertex\r\r\n        \r\r\n            Create and add a new vertex to this list\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddPointOnFace(self, face, s, t):\r\n        \"\"\"\r\n        AddPointOnFace(self: BrepVertexList, face: BrepFace, s: float, t: float) -> BrepVertex\r\r\n        \r\r\n            Adds a new point on face to the brep\r\r\n        \r\r\n            face: face that vertex lies on\r\r\n            s: surface parameters\r\r\n            t: surface parameters\r\r\n            Returns: new vertex that represents the point on face\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: BrepVertexList) -> IEnumerator[BrepVertex]\r\r\n        \r\r\n            Gets an enumerator that visits all surfaces.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[BrepVertex](enumerable: IEnumerable[BrepVertex], value: BrepVertex) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of brep vertices.\r\r\n\r\r\nGet: Count(self: BrepVertexList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshFaceList(object, IEnumerable[MeshFace], IEnumerable, IRhinoTable[MeshFace]):\r\n    \"\"\" Provides access to the faces and Face related functionality of a Mesh. \"\"\"\r\n    def AddFace(self, *__args):\r\n        \"\"\"\r\n        AddFace(self: MeshFaceList, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> int\r\r\n        \r\r\n            Appends a new quadragular face to the end of the mesh face list.\r\r\n        \r\r\n            vertex1: Index of first face corner.\r\r\n            vertex2: Index of second face corner.\r\r\n            vertex3: Index of third face corner.\r\r\n            vertex4: Index of fourth face corner.\r\r\n            Returns: The index of the newly added quad.\r\r\n        AddFace(self: MeshFaceList, vertex1: int, vertex2: int, vertex3: int) -> int\r\r\n        \r\r\n            Appends a new triangular face to the end of the mesh face list.\r\r\n        \r\r\n            vertex1: Index of first face corner.\r\r\n            vertex2: Index of second face corner.\r\r\n            vertex3: Index of third face corner.\r\r\n            Returns: The index of the newly added triangle.\r\r\n        AddFace(self: MeshFaceList, face: MeshFace) -> int\r\r\n        \r\r\n            Appends a new mesh face to the end of the mesh face list.\r\r\n        \r\r\n            face: Face to add.\r\r\n            Returns: The index of the newly added face.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddFaces(self, faces):\r\n        \"\"\" AddFaces(self: MeshFaceList, faces: IEnumerable[MeshFace]) -> Array[int] \"\"\"\r\n        pass\r\n\r\n    def AdjacentFaces(self, faceIndex):\r\n        \"\"\"\r\n        AdjacentFaces(self: MeshFaceList, faceIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets all faces that share a topological edge with a given face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: All indices that share an edge.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshFaceList)\r\r\n            Clears the Face list on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ConvertQuadsToTriangles(self):\r\n        \"\"\"\r\n        ConvertQuadsToTriangles(self: MeshFaceList) -> bool\r\r\n        \r\r\n            Splits all quads along the short diagonal.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ConvertTrianglesToQuads(self, angleToleranceRadians, minimumDiagonalLengthRatio):\r\n        \"\"\"\r\n        ConvertTrianglesToQuads(self: MeshFaceList, angleToleranceRadians: float, minimumDiagonalLengthRatio: float) -> bool\r\r\n        \r\r\n            Joins adjacent triangles into quads if the resulting quad is 'nice'.\r\r\n        \r\r\n            angleToleranceRadians: Used to compare adjacent triangles' face normals. For two triangles \r\r\n                    to be \r\r\n             considered, the angle between their face normals has to \r\r\n                    be <= \r\r\n             angleToleranceRadians. When in doubt use RhinoMath.PI/90.0 (2 degrees).\r\r\n        \r\r\n            minimumDiagonalLengthRatio: ( <= 1.0) For two triangles to be considered the ratio of the \r\r\n                    resulting quad's \r\r\n             diagonals \r\r\n                    (length of the shortest diagonal)/(length of longest diagonal). \r\r\n               \r\r\n                  has to be >= minimumDiagonalLengthRatio. When in doubt us .875.\r\r\n        \r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CullDegenerateFaces(self):\r\n        \"\"\"\r\n        CullDegenerateFaces(self: MeshFaceList) -> int\r\r\n        \r\r\n            Attempts to removes degenerate faces from the mesh.\r\r\n                    Degenerate faces are faces that \r\r\n             contains such a combination of indices,\r\r\n                    that their final shape collapsed in a line \r\r\n             or point.Before returning, this method also attempts to repair faces by juggling\r\r\n                    \r\r\n             vertex indices.\r\r\n        \r\r\n            Returns: The number of degenerate faces that were removed.\r\n        \"\"\"\r\n        pass\r\n\r\n    def DeleteFaces(self, faceIndexes):\r\n        \"\"\" DeleteFaces(self: MeshFaceList, faceIndexes: IEnumerable[int]) -> int \"\"\"\r\n        pass\r\n\r\n    def GetConnectedFaces(self, faceIndex, angleRadians, greaterThanAngle):\r\n        \"\"\"\r\n        GetConnectedFaces(self: MeshFaceList, faceIndex: int, angleRadians: float, greaterThanAngle: bool) -> Array[int]\r\r\n        \r\r\n            Find all connected face indices where adjacent face normals meet\r\r\n                    the criteria of \r\r\n             angleRadians and greaterThanAngle\r\r\n        \r\r\n        \r\r\n            faceIndex: face index to start from\r\r\n            angleRadians: angle to use for comparison of what is connected\r\r\n            greaterThanAngle: If true angles greater than or equal to are considered connected.\r\r\n                    If false, angles \r\r\n             less than or equal to are considerd connected.\r\r\n        \r\r\n            Returns: list of connected face indices\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetConnectedFacesToEdges(self, startFaceIndex, treatNonmanifoldLikeUnwelded):\r\n        \"\"\"\r\n        GetConnectedFacesToEdges(self: MeshFaceList, startFaceIndex: int, treatNonmanifoldLikeUnwelded: bool) -> Array[int]\r\r\n        \r\r\n            Uses startFaceIndex and finds all connected face indexes up to unwelded\r\r\n                    or naked \r\r\n             edges. If treatNonmanifoldLikeUnwelded is true then non-manifold\r\r\n                    edges will be \r\r\n             considered as unwelded or naked\r\r\n        \r\r\n        \r\r\n            startFaceIndex: Initial face index\r\r\n            treatNonmanifoldLikeUnwelded: True means non-manifold edges will be handled like unwelded edges, \r\r\n                    False means \r\r\n             they aren't considered\r\r\n        \r\r\n            Returns: Array of connected face indexes\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshFaceList) -> IEnumerator[MeshFace]\r\r\n        \r\r\n            Gets an enumerator that yields all faces in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetFace(self, index):\r\n        \"\"\"\r\n        GetFace(self: MeshFaceList, index: int) -> MeshFace\r\r\n        \r\r\n            Returns the mesh face at the given index.\r\r\n        \r\r\n            index: Index of face to get. Must be larger than or equal to zero and \r\r\n                    smaller than the \r\r\n             Face Count of the mesh.\r\r\n        \r\r\n            Returns: The mesh face at the given index on success or MeshFace.Unset if the index is out of range.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetFaceBoundingBox(self, faceIndex):\r\n        \"\"\"\r\n        GetFaceBoundingBox(self: MeshFaceList, faceIndex: int) -> BoundingBox\r\r\n        \r\r\n            Gets the bounding box of a face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: A new bounding box, or Rhino.Geometry.BoundingBox.Empty on error.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetFaceCenter(self, faceIndex):\r\n        \"\"\"\r\n        GetFaceCenter(self: MeshFaceList, faceIndex: int) -> Point3d\r\r\n        \r\r\n            Gets the center point of a face.\r\r\n                    For a triangular face, this is considered the \r\r\n             centroid or barycenter.For a quad, this is considered the bimedians intersection\r\r\n                    \r\r\n             (the avarage of four points).\r\r\n        \r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: The center point.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetFaceVertices(self, faceIndex, a, b, c, d):\r\n        \"\"\"\r\n        GetFaceVertices(self: MeshFaceList, faceIndex: int) -> (bool, Point3f, Point3f, Point3f, Point3f)\r\r\n        \r\r\n            Gets the 3D location of the vertices forming a face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: true if the operation succeeded, otherwise false.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetTopologicalVertices(self, faceIndex):\r\n        \"\"\"\r\n        GetTopologicalVertices(self: MeshFaceList, faceIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets the topology vertex indices of a face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: An array of integers.\r\n        \"\"\"\r\n        pass\r\n\r\n    def HasNakedEdges(self, faceIndex):\r\n        \"\"\"\r\n        HasNakedEdges(self: MeshFaceList, faceIndex: int) -> bool\r\r\n        \r\r\n            Returns true if at least one of the face edges are not topologically\r\r\n                    connected to \r\r\n             any other faces.\r\r\n        \r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: true if that face makes the mesh open, otherwise false.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Insert(self, index, face):\r\n        \"\"\"\r\n        Insert(self: MeshFaceList, index: int, face: MeshFace)\r\r\n            Inserts a mesh face at a defined index in this list.\r\r\n        \r\r\n            index: An index.\r\r\n            face: A face.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IsHidden(self, faceIndex):\r\n        \"\"\"\r\n        IsHidden(self: MeshFaceList, faceIndex: int) -> bool\r\r\n        \r\r\n            Gets a value indicating whether a face is hidden.\r\r\n                    A face is hidden if, and only if, \r\r\n             at least one of its vertices is hidden.\r\r\n        \r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: true if hidden, false if fully visible.\r\n        \"\"\"\r\n        pass\r\n\r\n    def RemoveAt(self, index):\r\n        \"\"\"\r\n        RemoveAt(self: MeshFaceList, index: int)\r\r\n            Removes a face from the mesh.\r\r\n        \r\r\n            index: The index of the face that will be removed.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetFace(self, index, *__args):\r\n        \"\"\"\r\n        SetFace(self: MeshFaceList, index: int, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> bool\r\r\n        \r\r\n            Sets a quadrangular face at a specific index of the mesh.\r\r\n        \r\r\n            index: A position in the list.\r\r\n            vertex1: The first vertex index.\r\r\n            vertex2: The second vertex index.\r\r\n            vertex3: The third vertex index.\r\r\n            vertex4: The fourth vertex index.\r\r\n            Returns: true if the operation succeeded, otherwise false.\r\r\n        SetFace(self: MeshFaceList, index: int, vertex1: int, vertex2: int, vertex3: int) -> bool\r\r\n        \r\r\n            Sets a triangular face at a specific index of the mesh.\r\r\n        \r\r\n            index: A position in the list.\r\r\n            vertex1: The first vertex index.\r\r\n            vertex2: The second vertex index.\r\r\n            vertex3: The third vertex index.\r\r\n            Returns: true if the operation succeeded, otherwise false.\r\r\n        SetFace(self: MeshFaceList, index: int, face: MeshFace) -> bool\r\r\n        \r\r\n            Sets a face at a specific index of the mesh.\r\r\n        \r\r\n            index: A position in the list.\r\r\n            face: A face.\r\r\n            Returns: true if the operation succeeded, otherwise false.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ToIntArray(self, asTriangles):\r\n        \"\"\"\r\n        ToIntArray(self: MeshFaceList, asTriangles: bool) -> Array[int]\r\r\n        \r\r\n            Copies all of the faces to a linear integer of indices\r\r\n        \r\r\n            asTriangles: If set to true as triangles.\r\r\n            Returns: The int array.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[MeshFace](enumerable: IEnumerable[MeshFace], value: MeshFace) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh faces.\r\r\n\r\r\nGet: Count(self: MeshFaceList) -> int\r\r\n\r\r\nSet: Count(self: MeshFaceList) = value\r\r\n\"\"\"\r\n\r\n    QuadCount = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of faces that are quads (4 corners).\r\r\n\r\r\nGet: QuadCount(self: MeshFaceList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n    TriangleCount = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of faces that are triangles (3 corners).\r\r\n\r\r\nGet: TriangleCount(self: MeshFaceList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshFaceNormalList(object, IEnumerable[Vector3f], IEnumerable, IRhinoTable[Vector3f]):\r\n    \"\"\" Provides access to the Face normals of a Mesh. \"\"\"\r\n    def AddFaceNormal(self, *__args):\r\n        \"\"\"\r\n        AddFaceNormal(self: MeshFaceNormalList, normal: Vector3d) -> int\r\r\n        \r\r\n            Appends a face normal to the list of mesh face normals.\r\r\n        \r\r\n            normal: New face normal.\r\r\n            Returns: The index of the newly added face normal.\r\r\n        AddFaceNormal(self: MeshFaceNormalList, normal: Vector3f) -> int\r\r\n        \r\r\n            Appends a face normal to the list of mesh face normals.\r\r\n        \r\r\n            normal: New face normal.\r\r\n            Returns: The index of the newly added face normal.\r\r\n        AddFaceNormal(self: MeshFaceNormalList, x: Single, y: Single, z: Single) -> int\r\r\n        \r\r\n            Appends a face normal to the list of mesh face normals.\r\r\n        \r\r\n            x: X component of face normal.\r\r\n            y: Y component of face normal.\r\r\n            z: Z component of face normal.\r\r\n            Returns: The index of the newly added face normal.\r\r\n        AddFaceNormal(self: MeshFaceNormalList, x: float, y: float, z: float) -> int\r\r\n        \r\r\n            Appends a face normal to the list of mesh face normals.\r\r\n        \r\r\n            x: X component of face normal.\r\r\n            y: Y component of face normal.\r\r\n            z: Z component of face normal.\r\r\n            Returns: The index of the newly added face normal.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshFaceNormalList)\r\r\n            Clears the Face Normal list on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ComputeFaceNormals(self):\r\n        \"\"\"\r\n        ComputeFaceNormals(self: MeshFaceNormalList) -> bool\r\r\n        \r\r\n            Computes all the face normals for this mesh based on the physical shape of the mesh.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshFaceNormalList) -> IEnumerator[Vector3f]\r\r\n        \r\r\n            Gets an enumerator that yields all normals in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetFaceNormal(self, index, *__args):\r\n        \"\"\"\r\n        SetFaceNormal(self: MeshFaceNormalList, index: int, normal: Vector3d) -> bool\r\r\n        \r\r\n            Sets a face normal vector at an index using a single-precision vector.\r\r\n        \r\r\n            index: An index.\r\r\n            normal: A normal vector.\r\r\n            Returns: true on success; false on error.\r\r\n        SetFaceNormal(self: MeshFaceNormalList, index: int, normal: Vector3f) -> bool\r\r\n        \r\r\n            Sets a face normal vector at an index using a single-precision vector.\r\r\n        \r\r\n            index: An index.\r\r\n            normal: A normal vector.\r\r\n            Returns: true on success; false on error.\r\r\n        SetFaceNormal(self: MeshFaceNormalList, index: int, x: Single, y: Single, z: Single) -> bool\r\r\n        \r\r\n            Sets a face normal vector at an index using three single-precision numbers.\r\r\n        \r\r\n            index: An index.\r\r\n            x: A x component.\r\r\n            y: A y component.\r\r\n            z: A z component.\r\r\n            Returns: true on success; false on error.\r\r\n        SetFaceNormal(self: MeshFaceNormalList, index: int, x: float, y: float, z: float) -> bool\r\r\n        \r\r\n            Sets a face normal vector at an index using three double-precision numbers.\r\r\n        \r\r\n            index: An index.\r\r\n            x: A x component.\r\r\n            y: A y component.\r\r\n            z: A z component.\r\r\n            Returns: true on success; false on error.\r\n        \"\"\"\r\n        pass\r\n\r\n    def UnitizeFaceNormals(self):\r\n        \"\"\"\r\n        UnitizeFaceNormals(self: MeshFaceNormalList) -> bool\r\r\n        \r\r\n            Unitizes all the existing face normals.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Vector3f](enumerable: IEnumerable[Vector3f], value: Vector3f) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh face normals.\r\r\n\r\r\nGet: Count(self: MeshFaceNormalList) -> int\r\r\n\r\r\nSet: Count(self: MeshFaceNormalList) = value\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshTextureCoordinateList(object, IEnumerable[Point2f], IEnumerable, IRhinoTable[Point2f]):\r\n    \"\"\" Provides access to the Vertex Texture coordinates of a Mesh. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: MeshTextureCoordinateList, tc: Point2f) -> int\r\r\n        \r\r\n            Adds a new texture coordinate to the end of the Texture list.\r\r\n        \r\r\n            tc: Texture coordinate to add.\r\r\n            Returns: The index of the newly added texture coordinate.\r\r\n        Add(self: MeshTextureCoordinateList, tc: Point3d) -> int\r\r\n        \r\r\n            Adds a new texture coordinate to the end of the Texture list.\r\r\n        \r\r\n            tc: Texture coordinate to add.\r\r\n            Returns: The index of the newly added texture coordinate.\r\r\n        Add(self: MeshTextureCoordinateList, s: Single, t: Single) -> int\r\r\n        \r\r\n            Adds a new texture coordinate to the end of the Texture list.\r\r\n        \r\r\n            s: S component of new texture coordinate.\r\r\n            t: T component of new texture coordinate.\r\r\n            Returns: The index of the newly added texture coordinate.\r\r\n        Add(self: MeshTextureCoordinateList, s: float, t: float) -> int\r\r\n        \r\r\n            Adds a new texture coordinate to the end of the Texture list.\r\r\n        \r\r\n            s: S component of new texture coordinate.\r\r\n            t: T component of new texture coordinate.\r\r\n            Returns: The index of the newly added texture coordinate.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddRange(self, textureCoordinates):\r\n        \"\"\"\r\n        AddRange(self: MeshTextureCoordinateList, textureCoordinates: Array[Point2f]) -> bool\r\r\n        \r\r\n            Appends an array of texture coordinates.\r\r\n        \r\r\n            textureCoordinates: Texture coordinates to append.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshTextureCoordinateList)\r\r\n            Clears the Texture Coordinate list on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshTextureCoordinateList) -> IEnumerator[Point2f]\r\r\n        \r\r\n            Gets an enumerator that yields all texture coordinates in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def NormalizeTextureCoordinates(self):\r\n        \"\"\"\r\n        NormalizeTextureCoordinates(self: MeshTextureCoordinateList) -> bool\r\r\n        \r\r\n            Scales the texture coordinates so the texture domains are [0,1] \r\r\n                    and eliminate any \r\r\n             texture rotations.\r\r\n        \r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ReverseTextureCoordinates(self, direction):\r\n        \"\"\"\r\n        ReverseTextureCoordinates(self: MeshTextureCoordinateList, direction: int) -> bool\r\r\n        \r\r\n            Reverses one coordinate direction of the texture coordinates.\r\r\n                    The region of the \r\r\n             bitmap the texture uses does not change.\r\r\n                    Either Us or Vs direction is flipped.\r\r\n        \r\r\n        \r\r\n            direction: 0 = first texture coordinate is reversed.1 = second texture coordinate is reversed.\r\r\n            Returns: true if operation succeeded; otherwise, false.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetTextureCoordinate(self, index, *__args):\r\n        \"\"\"\r\n        SetTextureCoordinate(self: MeshTextureCoordinateList, index: int, tc: Point2f) -> bool\r\r\n        \r\r\n            Sets or adds a texture coordinate to the Texture Coordinate List.\r\r\n                    If [index] is \r\r\n             less than [Count], the existing coordinate at [index] will be modified.If [index] equals \r\r\n             [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger \r\r\n             than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of texture coordinate to set.\r\r\n            tc: Texture coordinate point.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetTextureCoordinate(self: MeshTextureCoordinateList, index: int, tc: Point3f) -> bool\r\r\n        \r\r\n            Sets or adds a texture coordinate to the Texture Coordinate List.\r\r\n                    If [index] is \r\r\n             less than [Count], the existing coordinate at [index] will be modified.If [index] equals \r\r\n             [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger \r\r\n             than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of texture coordinate to set.\r\r\n            tc: Texture coordinate point.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetTextureCoordinate(self: MeshTextureCoordinateList, index: int, s: Single, t: Single) -> bool\r\r\n        \r\r\n            Sets or adds a texture coordinate to the Texture Coordinate List.\r\r\n                    If [index] is \r\r\n             less than [Count], the existing coordinate at [index] will be modified.If [index] equals \r\r\n             [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger \r\r\n             than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of texture coordinate to set.\r\r\n            s: S component of texture coordinate.\r\r\n            t: T component of texture coordinate.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetTextureCoordinate(self: MeshTextureCoordinateList, index: int, s: float, t: float) -> bool\r\r\n        \r\r\n            Sets or adds a texture coordinate to the Texture Coordinate List.\r\r\n                    If [index] is \r\r\n             less than [Count], the existing coordinate at [index] will be modified.If [index] equals \r\r\n             [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger \r\r\n             than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of texture coordinate to set.\r\r\n            s: S component of texture coordinate.\r\r\n            t: T component of texture coordinate.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetTextureCoordinates(self, *__args):\r\n        \"\"\"\r\n        SetTextureCoordinates(self: MeshTextureCoordinateList, mapping: TextureMapping) -> bool\r\r\n        \r\r\n            Set all texture coordinates based on a texture mapping function\r\r\n        \r\r\n            mapping: The new mapping type.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetTextureCoordinates(self: MeshTextureCoordinateList, textureCoordinates: Array[Point2f]) -> bool\r\r\n        \r\r\n            Sets all texture coordinates in one go.\r\r\n        \r\r\n            textureCoordinates: Texture coordinates to assign to the mesh.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def TransposeTextureCoordinates(self):\r\n        \"\"\"\r\n        TransposeTextureCoordinates(self: MeshTextureCoordinateList) -> bool\r\r\n        \r\r\n            Transposes texture coordinates.\r\r\n                    The region of the bitmap the texture uses does not \r\r\n             change.\r\r\n                    All texture coordinates rows (Us) become columns (Vs), and vice versa.\r\r\n        \r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Point2f](enumerable: IEnumerable[Point2f], value: Point2f) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of texture coordinates.\r\r\n\r\r\nGet: Count(self: MeshTextureCoordinateList) -> int\r\r\n\r\r\nSet: Count(self: MeshTextureCoordinateList) = value\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshTopologyEdgeList(object):\r\n    \"\"\" Represents an entry point to the list of edges in a mesh topology. \"\"\"\r\n    def CollapseEdge(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        CollapseEdge(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> bool\r\r\n        \r\r\n            Replaces a mesh edge with a vertex at its center and update adjacent faces as needed.\r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge in Rhino.Geometry.Mesh.TopologyEdges.\r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EdgeLine(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        EdgeLine(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> Line\r\r\n        \r\r\n            Gets the 3d line along an edge.\r\r\n        \r\r\n            topologyEdgeIndex: The topology edge index.\r\r\n            Returns: Line along edge. If input is not valid, an Invalid Line is returned.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetConnectedFaces(self, topologyEdgeIndex, faceOrientationMatchesEdgeDirection=None):\r\n        \"\"\"\r\n        GetConnectedFaces(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> (Array[int], Array[bool])\r\r\n        \r\r\n            Gets indices of faces connected to an edge.\r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge that is queried.\r\r\n            Returns: An array of face indices the edge borders. This might be empty on error.\r\r\n        GetConnectedFaces(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets indices of faces connected to an edge.\r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge that is queried.\r\r\n            Returns: An array of face indices the edge borders. This might be empty on error.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEdgeIndex(self, topologyVertex1, topologyVertex2):\r\n        \"\"\"\r\n        GetEdgeIndex(self: MeshTopologyEdgeList, topologyVertex1: int, topologyVertex2: int) -> int\r\r\n        \r\r\n            Returns index of edge that connects topological vertices. \r\r\n                    returns -1 if no edge is \r\r\n             found.\r\r\n        \r\r\n        \r\r\n            topologyVertex1: The first topology vertex index.\r\r\n            topologyVertex2: The second topology vertex index.\r\r\n            Returns: The edge index.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEdgesForFace(self, faceIndex, sameOrientation=None):\r\n        \"\"\"\r\n        GetEdgesForFace(self: MeshTopologyEdgeList, faceIndex: int) -> (Array[int], Array[bool])\r\r\n        \r\r\n            Gets indices of edges that surround a given face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: A new array of indices to the topological edges that are connected with the specified face.\r\r\n        GetEdgesForFace(self: MeshTopologyEdgeList, faceIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets indices of edges that surround a given face.\r\r\n        \r\r\n            faceIndex: A face index.\r\r\n            Returns: A new array of indices to the topological edges that are connected with the specified face.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetTopologyVertices(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        GetTopologyVertices(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> IndexPair\r\r\n        \r\r\n            Gets the two topology vertices for a given topology edge.\r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge.\r\r\n            Returns: The pair of vertex indices the edge connects.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IsHidden(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        IsHidden(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> bool\r\r\n        \r\r\n            Returns true if the topological edge is hidden. The mesh topology\r\r\n                    edge is hidden \r\r\n             only if either of its mesh topology vertices is hidden.\r\r\n        \r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge in Rhino.Geometry.Mesh.TopologyEdges.\r\r\n            Returns: true if mesh topology edge is hidden.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IsSwappableEdge(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        IsSwappableEdge(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> bool\r\r\n        \r\r\n            Determines if a mesh edge index is valid input for \r\r\n             Rhino.Geometry.Collections.MeshTopologyEdgeList.SwapEdge(System.Int32).\r\r\n        \r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge in Rhino.Geometry.Mesh.TopologyEdges.\r\r\n            Returns: true if edge can be swapped.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SplitEdge(self, topologyEdgeIndex, *__args):\r\n        \"\"\"\r\n        SplitEdge(self: MeshTopologyEdgeList, topologyEdgeIndex: int, point: Point3d) -> bool\r\r\n        \r\r\n            Divides a mesh edge to create two or more triangles\r\r\n        \r\r\n            topologyEdgeIndex: Edge to divide\r\r\n            point: Location to perform the split\r\r\n            Returns: true if successful\r\r\n        SplitEdge(self: MeshTopologyEdgeList, topologyEdgeIndex: int, t: float) -> bool\r\r\n        \r\r\n            Divides a mesh edge to create two or more triangles\r\r\n        \r\r\n            topologyEdgeIndex: Edge to divide\r\r\n            t: Parameter along edge. This is the same as getting an EdgeLine and calling PointAt(t) on that line\r\r\n            Returns: true if successful\r\n        \"\"\"\r\n        pass\r\n\r\n    def SwapEdge(self, topologyEdgeIndex):\r\n        \"\"\"\r\n        SwapEdge(self: MeshTopologyEdgeList, topologyEdgeIndex: int) -> bool\r\r\n        \r\r\n            If the edge is shared by two triangular face, then the edge is swapped.\r\r\n        \r\r\n            topologyEdgeIndex: An index of a topology edge in Rhino.Geometry.Mesh.TopologyEdges.\r\r\n            Returns: true if successful.\r\n        \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the amount of edges in this list.\r\r\n\r\r\nGet: Count(self: MeshTopologyEdgeList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshTopologyVertexList(object, IEnumerable[Point3f], IEnumerable, IRhinoTable[Point3f]):\r\n    \"\"\"\r\n    Provides access to the mesh topology vertices of a mesh. Topology vertices are\r\r\n                sets of vertices in the MeshVertexList that can topologically be considered the\r\r\n                same vertex.\r\n    \"\"\"\r\n    def ConnectedFaces(self, topologyVertexIndex):\r\n        \"\"\"\r\n        ConnectedFaces(self: MeshTopologyVertexList, topologyVertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets all faces that are connected to a given vertex.\r\r\n        \r\r\n            topologyVertexIndex: Index of a topology vertex in Mesh.TopologyVertices.\r\r\n            Returns: Indices of all faces in Mesh.Faces that are connected to this topological vertex.\r\r\n                    \r\r\n             null if no faces are connected to this vertex.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ConnectedTopologyVertices(self, topologyVertexIndex, sorted=None):\r\n        \"\"\"\r\n        ConnectedTopologyVertices(self: MeshTopologyVertexList, topologyVertexIndex: int, sorted: bool) -> Array[int]\r\r\n        \r\r\n            Gets all topological vertices that are connected to a given vertex.\r\r\n        \r\r\n            topologyVertexIndex: index of a topology vertex in Mesh.TopologyVertices.\r\r\n            sorted: if true, thr vertices are returned in a radially sorted order.\r\r\n            Returns: Indices of all topological vertices that are connected to this topological vertex.\r\r\n                    \r\r\n             null if no vertices are connected to this vertex.\r\r\n        \r\r\n        ConnectedTopologyVertices(self: MeshTopologyVertexList, topologyVertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets all topological vertices that are connected to a given vertex.\r\r\n        \r\r\n            topologyVertexIndex: index of a topology vertex in Mesh.TopologyVertices.\r\r\n            Returns: Indices of all topological vertices that are connected to this topological vertex.\r\r\n                    \r\r\n             null if no vertices are connected to this vertex.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshTopologyVertexList) -> IEnumerator[Point3f]\r\r\n        \r\r\n            Gets an enumerator that yields all topology vertices in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IndicesFromFace(self, faceIndex):\r\n        \"\"\"\r\n        IndicesFromFace(self: MeshTopologyVertexList, faceIndex: int) -> Array[int]\r\r\n        \r\r\n            Returns TopologyVertexIndices for a given mesh face index.\r\r\n        \r\r\n            faceIndex: The index of a face to query.\r\r\n            Returns: An array of vertex indices.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IsHidden(self, topologyVertexIndex):\r\n        \"\"\"\r\n        IsHidden(self: MeshTopologyVertexList, topologyVertexIndex: int) -> bool\r\r\n        \r\r\n            Returns true if the topological vertex is hidden. The mesh topology\r\r\n                    vertex is \r\r\n             hidden if and only if all the ON_Mesh vertices it represents is hidden.\r\r\n        \r\r\n        \r\r\n            topologyVertexIndex: index of a topology vertex in Mesh.TopologyVertices.\r\r\n            Returns: true if mesh topology vertex is hidden.\r\n        \"\"\"\r\n        pass\r\n\r\n    def MeshVertexIndices(self, topologyVertexIndex):\r\n        \"\"\"\r\n        MeshVertexIndices(self: MeshTopologyVertexList, topologyVertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets all indices of the mesh vertices that a given topology vertex represents.\r\r\n        \r\r\n            topologyVertexIndex: Index of a topology vertex in Mesh.TopologyVertices to query.\r\r\n            Returns: Indices of all vertices that in Mesh.Vertices that a topology vertex represents.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SortEdges(self, topologyVertexIndex=None):\r\n        \"\"\"\r\n        SortEdges(self: MeshTopologyVertexList, topologyVertexIndex: int) -> bool\r\r\n        \r\r\n            Sorts the edge list for as single mesh topology vertex so that\r\r\n                    the edges are in \r\r\n             radial order when you call ConnectedTopologyVertices.\r\r\n                    A nonmanifold edge is treated \r\r\n             as a boundary edge with respect\r\r\n                    to sorting.  If any boundary or nonmanifold edges \r\r\n             end at the\r\r\n                    vertex, then the first edge will be a boundary or nonmanifold edge.\r\r\n        \r\r\n        \r\r\n            topologyVertexIndex: index of a topology vertex in Mesh.TopologyVertices>\r\r\n            Returns: true on success.\r\r\n        SortEdges(self: MeshTopologyVertexList) -> bool\r\r\n        \r\r\n            Sorts the edge list for the mesh topology vertex list so that\r\r\n                    the edges are in \r\r\n             radial order when you call ConnectedTopologyVertices.\r\r\n                    A nonmanifold edge is treated \r\r\n             as a boundary edge with respect\r\r\n                    to sorting.  If any boundary or nonmanifold edges \r\r\n             end at the\r\r\n                    vertex, then the first edge will be a boundary or nonmanifold edge.\r\r\n        \r\r\n            Returns: true on success.\r\n        \"\"\"\r\n        pass\r\n\r\n    def TopologyVertexIndex(self, vertexIndex):\r\n        \"\"\"\r\n        TopologyVertexIndex(self: MeshTopologyVertexList, vertexIndex: int) -> int\r\r\n        \r\r\n            Gets the topology vertex index for an existing mesh vertex in the mesh's\r\r\n                    VertexList.\r\r\n        \r\r\n            vertexIndex: Index of a vertex in the Mesh.Vertices.\r\r\n            Returns: Index of a topology vertex in the Mesh.TopologyVertices.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Point3f](enumerable: IEnumerable[Point3f], value: Point3f) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh topology vertices.\r\r\n\r\r\nGet: Count(self: MeshTopologyVertexList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshVertexColorList(object, IEnumerable[Color], IEnumerable, IRhinoTable[Color]):\r\n    \"\"\" Provides access to the vertex colors of a mesh object. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: MeshVertexColorList, color: Color) -> int\r\r\n        \r\r\n            Adds a new vertex color to the end of the color list.\r\r\n        \r\r\n            color: Color to append, Alpha channels will be ignored.\r\r\n            Returns: The index of the newly added color.\r\r\n        Add(self: MeshVertexColorList, red: int, green: int, blue: int) -> int\r\r\n        \r\r\n            Adds a new vertex color to the end of the color list.\r\r\n        \r\r\n            red: Red component of color, must be in the 0~255 range.\r\r\n            green: Green component of color, must be in the 0~255 range.\r\r\n            blue: Blue component of color, must be in the 0~255 range.\r\r\n            Returns: The index of the newly added color.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AppendColors(self, colors):\r\n        \"\"\"\r\n        AppendColors(self: MeshVertexColorList, colors: Array[Color]) -> bool\r\r\n        \r\r\n            Appends a collection of colors to the vertex color list. \r\r\n                    For the Mesh to be valid, \r\r\n             the number of colors must match the number of vertices.\r\r\n        \r\r\n        \r\r\n            colors: Colors to append.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshVertexColorList)\r\r\n            Clears the vertex color list on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CreateMonotoneMesh(self, baseColor):\r\n        \"\"\"\r\n        CreateMonotoneMesh(self: MeshVertexColorList, baseColor: Color) -> bool\r\r\n        \r\r\n            Constructs a valid vertex color list consisting of a single color.\r\r\n        \r\r\n            baseColor: Color to apply to every vertex.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshVertexColorList) -> IEnumerator[Color]\r\r\n        \r\r\n            Gets an enumerator that yields all colors in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetColor(self, *__args):\r\n        \"\"\"\r\n        SetColor(self: MeshVertexColorList, face: MeshFace, color: Color) -> bool\r\r\n        \r\r\n            Sets a color at the three or four vertex indices of a specified face.\r\r\n        \r\r\n            face: A face to use to retrieve indices.\r\r\n            color: A color.\r\r\n            Returns: true on success; false on error.\r\r\n        SetColor(self: MeshVertexColorList, index: int, color: Color) -> bool\r\r\n        \r\r\n            Sets or adds a vertex to the Vertex List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex color to set. \r\r\n                    If index equals Count, then the color will be \r\r\n             appended.\r\r\n        \r\r\n            color: Color to set, Alpha channels will be ignored.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetColor(self: MeshVertexColorList, index: int, red: int, green: int, blue: int) -> bool\r\r\n        \r\r\n            Sets or adds a vertex color to the color List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex color to set. \r\r\n                    If index equals Count, then the color will be \r\r\n             appended.\r\r\n        \r\r\n            red: Red component of vertex color. Value must be in the 0~255 range.\r\r\n            green: Green component of vertex color. Value must be in the 0~255 range.\r\r\n            blue: Blue component of vertex color. Value must be in the 0~255 range.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetColors(self, colors):\r\n        \"\"\"\r\n        SetColors(self: MeshVertexColorList, colors: Array[Color]) -> bool\r\r\n        \r\r\n            Sets all the vertex colors in one go. For the Mesh to be valid, the number \r\r\n                    of \r\r\n             colors must match the number of vertices.\r\r\n        \r\r\n        \r\r\n            colors: Colors to set.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Color](enumerable: IEnumerable[Color], value: Color) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh colors.\r\r\n\r\r\nGet: Count(self: MeshVertexColorList) -> int\r\r\n\r\r\nSet: Count(self: MeshVertexColorList) = value\r\r\n\"\"\"\r\n\r\n    Tag = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets a mapping information for the mesh associated with these vertex colors.\r\r\n\r\r\nGet: Tag(self: MeshVertexColorList) -> MappingTag\r\r\n\r\r\nSet: Tag(self: MeshVertexColorList) = value\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshVertexList(object, IEnumerable[Point3f], IEnumerable, IRhinoTable[Point3f]):\r\n    \"\"\" Provides access to the vertices and vertex-related functionality of a mesh. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: MeshVertexList, vertex: Point3f) -> int\r\r\n        \r\r\n            Adds a new vertex to the end of the Vertex list.\r\r\n        \r\r\n            vertex: Location of new vertex.\r\r\n            Returns: The index of the newly added vertex.\r\r\n        Add(self: MeshVertexList, vertex: Point3d) -> int\r\r\n        \r\r\n            Adds a new vertex to the end of the Vertex list.\r\r\n        \r\r\n            vertex: Location of new vertex.\r\r\n            Returns: The index of the newly added vertex.\r\r\n        Add(self: MeshVertexList, x: Single, y: Single, z: Single) -> int\r\r\n        \r\r\n            Adds a new vertex to the end of the Vertex list.\r\r\n        \r\r\n            x: X component of new vertex coordinate.\r\r\n            y: Y component of new vertex coordinate.\r\r\n            z: Z component of new vertex coordinate.\r\r\n            Returns: The index of the newly added vertex.\r\r\n        Add(self: MeshVertexList, x: float, y: float, z: float) -> int\r\r\n        \r\r\n            Adds a new vertex to the end of the Vertex list.\r\r\n        \r\r\n            x: X component of new vertex coordinate.\r\r\n            y: Y component of new vertex coordinate.\r\r\n            z: Z component of new vertex coordinate.\r\r\n            Returns: The index of the newly added vertex.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddVertices(self, vertices):\r\n        \"\"\" AddVertices(self: MeshVertexList, vertices: IEnumerable[Point3f])AddVertices(self: MeshVertexList, vertices: IEnumerable[Point3d]) \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshVertexList)\r\r\n            Clear the Vertex list on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CombineIdentical(self, ignoreNormals, ignoreAdditional):\r\n        \"\"\"\r\n        CombineIdentical(self: MeshVertexList, ignoreNormals: bool, ignoreAdditional: bool) -> bool\r\r\n        \r\r\n            Merges identical vertices.\r\r\n        \r\r\n            ignoreNormals: If true, vertex normals will not be taken into consideration when comparing vertices.\r\r\n            ignoreAdditional: If true, texture coordinates, colors, and principal curvatures \r\r\n                    will not be taken \r\r\n             into consideration when comparing vertices.\r\r\n        \r\r\n            Returns: true if the mesh is changed, in which case the mesh will have fewer vertices than before.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CullUnused(self):\r\n        \"\"\"\r\n        CullUnused(self: MeshVertexList) -> int\r\r\n        \r\r\n            Removes all vertices that are currently not used by the Face list.\r\r\n            Returns: The number of unused vertices that were removed.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetConnectedVertices(self, vertexIndex):\r\n        \"\"\"\r\n        GetConnectedVertices(self: MeshVertexList, vertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets indices of all vertices that form \"edges\" with a given vertex index.\r\r\n        \r\r\n            vertexIndex: The index of a vertex to query.\r\r\n            Returns: An array of vertex indices that are connected with the specified vertex.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshVertexList) -> IEnumerator[Point3f]\r\r\n        \r\r\n            Gets an enumerator that yields all mesh vertices (points) in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetTopologicalIndenticalVertices(self, vertexIndex):\r\n        \"\"\"\r\n        GetTopologicalIndenticalVertices(self: MeshVertexList, vertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets a list of other vertices which are \"topologically\" identical\r\r\n                    to this vertex.\r\r\n        \r\r\n            vertexIndex: A vertex index in the mesh.\r\r\n            Returns: Array of indices of vertices that are topoligically the same as this vertex. The\r\r\n                    \r\r\n             array includes vertexIndex. Returns null on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetVertexFaces(self, vertexIndex):\r\n        \"\"\"\r\n        GetVertexFaces(self: MeshVertexList, vertexIndex: int) -> Array[int]\r\r\n        \r\r\n            Gets a list of all of the faces that share a given vertex.\r\r\n        \r\r\n            vertexIndex: The index of a vertex in the mesh.\r\r\n            Returns: An array of indices of faces on success, null on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Hide(self, vertexIndex):\r\n        \"\"\"\r\n        Hide(self: MeshVertexList, vertexIndex: int)\r\r\n            Hides the vertex at the given index.\r\r\n        \r\r\n            vertexIndex: Index of vertex to hide.\r\n        \"\"\"\r\n        pass\r\n\r\n    def HideAll(self):\r\n        \"\"\"\r\n        HideAll(self: MeshVertexList)\r\r\n            Hides all vertices in the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def IsHidden(self, vertexIndex):\r\n        \"\"\"\r\n        IsHidden(self: MeshVertexList, vertexIndex: int) -> bool\r\r\n        \r\r\n            Gets a value indicating whether or not a vertex is hidden.\r\r\n        \r\r\n            vertexIndex: Index of vertex to query.\r\r\n            Returns: true if the vertex is hidden, false if it is not.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Remove(self, *__args):\r\n        \"\"\"\r\n        Remove(self: MeshVertexList, indices: IEnumerable[int], shrinkFaces: bool) -> bool\r\r\n        Remove(self: MeshVertexList, index: int, shrinkFaces: bool) -> bool\r\r\n        \r\r\n            Removes the vertex at the given index and all faces that reference that index.\r\r\n        \r\r\n            index: Index of vertex to remove.\r\r\n            shrinkFaces: If true, quads that reference the deleted vertex will be converted to triangles.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetVertex(self, index, *__args):\r\n        \"\"\"\r\n        SetVertex(self: MeshVertexList, index: int, vertex: Point3f) -> bool\r\r\n        \r\r\n            Sets or adds a vertex to the Vertex List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex to set.\r\r\n            vertex: Vertex location.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetVertex(self: MeshVertexList, index: int, vertex: Point3d) -> bool\r\r\n        \r\r\n            Sets or adds a vertex to the Vertex List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex to set.\r\r\n            vertex: Vertex location.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetVertex(self: MeshVertexList, index: int, x: Single, y: Single, z: Single) -> bool\r\r\n        \r\r\n            Sets or adds a vertex to the Vertex List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex to set.\r\r\n            x: X component of vertex location.\r\r\n            y: Y component of vertex location.\r\r\n            z: Z component of vertex location.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetVertex(self: MeshVertexList, index: int, x: float, y: float, z: float) -> bool\r\r\n        \r\r\n            Sets or adds a vertex to the Vertex List.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended \r\r\n             to the end of the vertex list.If [index] is larger than [Count], the function will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex to set.\r\r\n            x: X component of vertex location.\r\r\n            y: Y component of vertex location.\r\r\n            z: Z component of vertex location.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Show(self, vertexIndex):\r\n        \"\"\"\r\n        Show(self: MeshVertexList, vertexIndex: int)\r\r\n            Shows the vertex at the given index.\r\r\n        \r\r\n            vertexIndex: Index of vertex to show.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ShowAll(self):\r\n        \"\"\"\r\n        ShowAll(self: MeshVertexList)\r\r\n            Shows all vertices in the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ToFloatArray(self):\r\n        \"\"\"\r\n        ToFloatArray(self: MeshVertexList) -> Array[Single]\r\r\n        \r\r\n            Copies all vertices to a linear array of float in x,y,z order\r\r\n            Returns: The float array.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ToPoint3dArray(self):\r\n        \"\"\"\r\n        ToPoint3dArray(self: MeshVertexList) -> Array[Point3d]\r\r\n        \r\r\n            Copies all vertices to a new array of Rhino.Geometry.Point3d.\r\r\n            Returns: A new array.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ToPoint3fArray(self):\r\n        \"\"\"\r\n        ToPoint3fArray(self: MeshVertexList) -> Array[Point3f]\r\r\n        \r\r\n            Copies all vertices to a new array of Rhino.Geometry.Point3f.\r\r\n            Returns: A new array.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Point3f](enumerable: IEnumerable[Point3f], value: Point3f) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh vertices.\r\r\n\r\r\nGet: Count(self: MeshVertexList) -> int\r\r\n\r\r\nSet: Count(self: MeshVertexList) = value\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass MeshVertexNormalList(object, IEnumerable[Vector3f], IEnumerable, IRhinoTable[Vector3f]):\r\n    \"\"\" Provides access to the Vertex Normals of a Mesh. \"\"\"\r\n    def Add(self, *__args):\r\n        \"\"\"\r\n        Add(self: MeshVertexNormalList, normal: Vector3f) -> int\r\r\n        \r\r\n            Adds a new vertex normal at the end of the list.\r\r\n        \r\r\n            normal: new vertex normal.\r\r\n            Returns: The index of the newly added vertex normal.\r\r\n        Add(self: MeshVertexNormalList, normal: Vector3d) -> int\r\r\n        \r\r\n            Adds a new vertex normal at the end of the list.\r\r\n        \r\r\n            normal: new vertex normal.\r\r\n            Returns: The index of the newly added vertex normal.\r\r\n        Add(self: MeshVertexNormalList, x: Single, y: Single, z: Single) -> int\r\r\n        \r\r\n            Adds a new vertex normal at the end of the list.\r\r\n        \r\r\n            x: X component of new vertex normal.\r\r\n            y: Y component of new vertex normal.\r\r\n            z: Z component of new vertex normal.\r\r\n            Returns: The index of the newly added vertex normal.\r\r\n        Add(self: MeshVertexNormalList, x: float, y: float, z: float) -> int\r\r\n        \r\r\n            Adds a new vertex normal at the end of the list.\r\r\n        \r\r\n            x: X component of new vertex normal.\r\r\n            y: Y component of new vertex normal.\r\r\n            z: Z component of new vertex normal.\r\r\n            Returns: The index of the newly added vertex normal.\r\n        \"\"\"\r\n        pass\r\n\r\n    def AddRange(self, normals):\r\n        \"\"\"\r\n        AddRange(self: MeshVertexNormalList, normals: Array[Vector3f]) -> bool\r\r\n        \r\r\n            Appends a collection of normal vectors.\r\r\n        \r\r\n            normals: Normals to append.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Clear(self):\r\n        \"\"\"\r\n        Clear(self: MeshVertexNormalList)\r\r\n            Clears the vertex normal collection on the mesh.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ComputeNormals(self):\r\n        \"\"\"\r\n        ComputeNormals(self: MeshVertexNormalList) -> bool\r\r\n        \r\r\n            Computes the vertex normals based on the physical shape of the mesh.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def Flip(self):\r\n        \"\"\"\r\n        Flip(self: MeshVertexNormalList)\r\r\n            Reverses direction of all vertex normals\r\r\n                    This is the same as Mesh.Flip(true, false, \r\r\n             false)\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetEnumerator(self):\r\n        \"\"\"\r\n        GetEnumerator(self: MeshVertexNormalList) -> IEnumerator[Vector3f]\r\r\n        \r\r\n            Gets an enumerator that yields all normals (vectors) in this collection.\r\r\n            Returns: The enumerator.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetNormal(self, index, *__args):\r\n        \"\"\"\r\n        SetNormal(self: MeshVertexNormalList, index: int, normal: Vector3f) -> bool\r\r\n        \r\r\n            Sets or adds a vertex normal to the list.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex \r\r\n             normal is appended to the end of the vertex list.If [index] is larger than [Count], the function \r\r\n             will return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex normal to set.\r\r\n            normal: The new normal at the index.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetNormal(self: MeshVertexNormalList, index: int, normal: Vector3d) -> bool\r\r\n        \r\r\n            Sets or adds a vertex normal to the list.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex \r\r\n             normal is appended to the end of the list.If [index] is larger than [Count], the function will \r\r\n             return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex normal to set.\r\r\n            normal: The new normal at the index.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetNormal(self: MeshVertexNormalList, index: int, x: Single, y: Single, z: Single) -> bool\r\r\n        \r\r\n            Sets or adds a normal to the list.\r\r\n                    If [index] is less than [Count], the existing \r\r\n             vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is \r\r\n             appended to the end of the list.If [index] is larger than [Count], the function will return \r\r\n             false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex normal to set.\r\r\n            x: X component of vertex normal.\r\r\n            y: Y component of vertex normal.\r\r\n            z: Z component of vertex normal.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetNormal(self: MeshVertexNormalList, index: int, x: float, y: float, z: float) -> bool\r\r\n        \r\r\n            Sets or adds a vertex normal to the list.\r\r\n                    If [index] is less than [Count], the \r\r\n             existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex \r\r\n             normal is appended to the end of the list.If [index] is larger than [Count], the function will \r\r\n             return false.\r\r\n        \r\r\n        \r\r\n            index: Index of vertex normal to set.\r\r\n            x: X component of vertex normal.\r\r\n            y: Y component of vertex normal.\r\r\n            z: Z component of vertex normal.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetNormals(self, normals):\r\n        \"\"\"\r\n        SetNormals(self: MeshVertexNormalList, normals: Array[Vector3f]) -> bool\r\r\n        \r\r\n            Sets all normal vectors in one go. This method destroys the current normal array if it exists.\r\r\n        \r\r\n            normals: Normals for the entire mesh.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def UnitizeNormals(self):\r\n        \"\"\"\r\n        UnitizeNormals(self: MeshVertexNormalList) -> bool\r\r\n        \r\r\n            Unitizes all vertex normals.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __add__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+yx.__add__(y) <==> x+y \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[Vector3f](enumerable: IEnumerable[Vector3f], value: Vector3f) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets or sets the number of mesh vertex normals.\r\r\n\r\r\nGet: Count(self: MeshVertexNormalList) -> int\r\r\n\r\r\nSet: Count(self: MeshVertexNormalList) = value\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass NurbsCurveKnotList(object, IEnumerable[float], IEnumerable, IRhinoTable[float], IEpsilonComparable[NurbsCurveKnotList]):\r\n    \"\"\" Provides access to the knot vector of a nurbs curve. \"\"\"\r\n    def ClampEnd(self, end):\r\n        \"\"\"\r\n        ClampEnd(self: NurbsCurveKnotList, end: CurveEnd) -> bool\r\r\n        \r\r\n            Clamp end knots. Does not modify control point locations.\r\r\n        \r\r\n            end: Curve end to clamp.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CreatePeriodicKnots(self, knotSpacing):\r\n        \"\"\"\r\n        CreatePeriodicKnots(self: NurbsCurveKnotList, knotSpacing: float) -> bool\r\r\n        \r\r\n            Compute a clamped, uniform, periodic knot vector based on the current\r\r\n                    degree and \r\r\n             control point count. Does not change values of control\r\r\n                    vertices.\r\r\n        \r\r\n        \r\r\n            knotSpacing: Spacing of subsequent knots.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CreateUniformKnots(self, knotSpacing):\r\n        \"\"\"\r\n        CreateUniformKnots(self: NurbsCurveKnotList, knotSpacing: float) -> bool\r\r\n        \r\r\n            Compute a clamped, uniform knot vector based on the current\r\r\n                    degree and control \r\r\n             point count. Does not change values of control\r\r\n                    vertices.\r\r\n        \r\r\n        \r\r\n            knotSpacing: Spacing of subsequent knots.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EnsurePrivateCopy(self):\r\n        \"\"\"\r\n        EnsurePrivateCopy(self: NurbsCurveKnotList)\r\r\n            If you want to keep a copy of this class around by holding onto it in a variable after a command\r\r\r\n             \r\n                    completes, call EnsurePrivateCopy to make sure that this class is not tied to the \r\r\n             document. You can\r\r\n                    call this function as many times as you want.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EpsilonEquals(self, other, epsilon):\r\n        \"\"\"\r\n        EpsilonEquals(self: NurbsCurveKnotList, other: NurbsCurveKnotList, epsilon: float) -> bool\r\r\n        \r\r\n            Check that all values in other are within epsilon of the values in this\r\n        \"\"\"\r\n        pass\r\n\r\n    def InsertKnot(self, value, multiplicity=None):\r\n        \"\"\"\r\n        InsertKnot(self: NurbsCurveKnotList, value: float, multiplicity: int) -> bool\r\r\n        \r\r\n            Inserts a knot and update control point locations.\r\r\n                    Does not change parameterization \r\r\n             or locus of curve.\r\r\n        \r\r\n        \r\r\n            value: Knot value to insert.\r\r\n            multiplicity: Multiplicity of knot to insert.\r\r\n            Returns: true on success, false on failure.\r\r\n        InsertKnot(self: NurbsCurveKnotList, value: float) -> bool\r\r\n        \r\r\n            Inserts a knot and update control point locations.\r\r\n                    Does not change parameterization \r\r\n             or locus of curve.\r\r\n        \r\r\n        \r\r\n            value: Knot value to insert.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def KnotMultiplicity(self, index):\r\n        \"\"\"\r\n        KnotMultiplicity(self: NurbsCurveKnotList, index: int) -> int\r\r\n        \r\r\n            Get knot multiplicity.\r\r\n        \r\r\n            index: Index of knot to query.\r\r\n            Returns: The multiplicity (valence) of the knot.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SuperfluousKnot(self, start):\r\n        \"\"\"\r\n        SuperfluousKnot(self: NurbsCurveKnotList, start: bool) -> float\r\r\n        \r\r\n            Computes the knots that are superfluous because they are not used in NURBs evaluation.\r\r\n                 \r\r\n                These make it appear so that the first and last curve spans are different from interior \r\r\n             spans.\r\r\n                    http://wiki.mcneel.com/developer/onsuperfluousknot\r\r\n        \r\r\n        \r\r\n            start: true if the query targets the first knot. Otherwise, the last knot.\r\r\n            Returns: A component.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[float](enumerable: IEnumerable[float], value: float) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Total number of knots in this curve.\r\r\n\r\r\nGet: Count(self: NurbsCurveKnotList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n    IsClampedEnd = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets a value indicating whether or not the knot vector is clamped at the end of the curve. \r\r\n            Clamped curves are coincident with the first and last control-point. This requires fully multiple knots.\r\r\n\r\r\nGet: IsClampedEnd(self: NurbsCurveKnotList) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n    IsClampedStart = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets a value indicating whether or not the knot vector is clamped at the start of the curve. \r\r\n            Clamped curves start at the first control-point. This requires fully multiple knots.\r\r\n\r\r\nGet: IsClampedStart(self: NurbsCurveKnotList) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass NurbsCurvePointList(object, IEnumerable[ControlPoint], IEnumerable, IRhinoTable[ControlPoint], IEpsilonComparable[NurbsCurvePointList]):\r\n    \"\"\" Provides access to the control points of a nurbs curve. \"\"\"\r\n    def ChangeEndWeights(self, w0, w1):\r\n        \"\"\"\r\n        ChangeEndWeights(self: NurbsCurvePointList, w0: float, w1: float) -> bool\r\r\n        \r\r\n            Use a combination of scaling and reparameterization to change the end weights to the specified \r\r\n             values.\r\r\n        \r\r\n        \r\r\n            w0: Weight for first control point.\r\r\n            w1: Weight for last control point.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def ControlPolygon(self):\r\n        \"\"\"\r\n        ControlPolygon(self: NurbsCurvePointList) -> Polyline\r\r\n        \r\r\n            Constructs a polyline through all the control points. \r\r\n                    Note that periodic curves \r\r\n             generate a closed polyline with fewer \r\r\n                    points than control-points.\r\r\n        \r\r\n            Returns: A polyline connecting all control points.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EnsurePrivateCopy(self):\r\n        \"\"\"\r\n        EnsurePrivateCopy(self: NurbsCurvePointList)\r\r\n            If you want to keep a copy of this class around by holding onto it in a variable after a command\r\r\r\n             \r\n                    completes, call EnsurePrivateCopy to make sure that this class is not tied to the \r\r\n             document. You can\r\r\n                    call this function as many times as you want.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EpsilonEquals(self, other, epsilon):\r\n        \"\"\"\r\n        EpsilonEquals(self: NurbsCurvePointList, other: NurbsCurvePointList, epsilon: float) -> bool\r\r\n        \r\r\n            Check that all values in other are within epsilon of the values in this\r\n        \"\"\"\r\n        pass\r\n\r\n    def MakeNonRational(self):\r\n        \"\"\"\r\n        MakeNonRational(self: NurbsCurvePointList) -> bool\r\r\n        \r\r\n            Sets all the control points to 1.0.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def MakeRational(self):\r\n        \"\"\"\r\n        MakeRational(self: NurbsCurvePointList) -> bool\r\r\n        \r\r\n            Turns the curve into a Rational nurbs curve.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetPoint(self, index, *__args):\r\n        \"\"\"\r\n        SetPoint(self: NurbsCurvePointList, index: int, point: Point4d) -> bool\r\r\n        \r\r\n            Sets a specific weighted control-point.\r\r\n        \r\r\n            index: Index of control-point to set.\r\r\n            point: Coordinate and weight of control-point.\r\r\n        SetPoint(self: NurbsCurvePointList, index: int, point: Point3d) -> bool\r\r\n        \r\r\n            Sets a specific control-point.\r\r\n        \r\r\n            index: Index of control-point to set.\r\r\n            point: Coordinate of control-point.\r\r\n        SetPoint(self: NurbsCurvePointList, index: int, x: float, y: float, z: float, weight: float) -> bool\r\r\n        \r\r\n            Sets a specific control-point.\r\r\n        \r\r\n            index: Index of control-point to set.\r\r\n            x: X coordinate of control-point.\r\r\n            y: Y coordinate of control-point.\r\r\n            z: Z coordinate of control-point.\r\r\n            weight: Weight of control-point.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[ControlPoint](enumerable: IEnumerable[ControlPoint], value: ControlPoint) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    ControlPolygonLength = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the length of the polyline connecting all control points.\r\r\n\r\r\nGet: ControlPolygonLength(self: NurbsCurvePointList) -> float\r\r\n\r\r\n\"\"\"\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of control points in this curve.\r\r\n\r\r\nGet: Count(self: NurbsCurvePointList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass NurbsSurfaceKnotList(object, IEnumerable[float], IEnumerable, IRhinoTable[float], IEpsilonComparable[NurbsSurfaceKnotList]):\r\n    \"\"\" Provides access to the knot vector of a nurbs surface. \"\"\"\r\n    def CreatePeriodicKnots(self, knotSpacing):\r\n        \"\"\"\r\n        CreatePeriodicKnots(self: NurbsSurfaceKnotList, knotSpacing: float) -> bool\r\r\n        \r\r\n            Compute a clamped, uniform, periodic knot vector based on the current\r\r\n                    degree and \r\r\n             control point count. Does not change values of control\r\r\n                    vertices.\r\r\n        \r\r\n        \r\r\n            knotSpacing: Spacing of subsequent knots.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def CreateUniformKnots(self, knotSpacing):\r\n        \"\"\"\r\n        CreateUniformKnots(self: NurbsSurfaceKnotList, knotSpacing: float) -> bool\r\r\n        \r\r\n            Compute a clamped, uniform knot vector based on the current\r\r\n                    degree and control \r\r\n             point count. Does not change values of control\r\r\n                    vertices.\r\r\n        \r\r\n        \r\r\n            knotSpacing: Spacing of subsequent knots.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EnsurePrivateCopy(self):\r\n        \"\"\"\r\n        EnsurePrivateCopy(self: NurbsSurfaceKnotList)\r\r\n            If you want to keep a copy of this class around by holding onto it in a variable after a command\r\r\r\n             \r\n                    completes, call EnsurePrivateCopy to make sure that this class is not tied to the \r\r\n             document. You can\r\r\n                    call this function as many times as you want.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EpsilonEquals(self, other, epsilon):\r\n        \"\"\"\r\n        EpsilonEquals(self: NurbsSurfaceKnotList, other: NurbsSurfaceKnotList, epsilon: float) -> bool\r\r\n        \r\r\n            Check that all values in other are within epsilon of the values in this\r\n        \"\"\"\r\n        pass\r\n\r\n    def InsertKnot(self, value, multiplicity=None):\r\n        \"\"\"\r\n        InsertKnot(self: NurbsSurfaceKnotList, value: float, multiplicity: int) -> bool\r\r\n        \r\r\n            Inserts a knot and update control point locations.\r\r\n                    Does not change parameterization \r\r\n             or locus of curve.\r\r\n        \r\r\n        \r\r\n            value: Knot value to insert.\r\r\n            multiplicity: Multiplicity of knot to insert.\r\r\n            Returns: true on success, false on failure.\r\r\n        InsertKnot(self: NurbsSurfaceKnotList, value: float) -> bool\r\r\n        \r\r\n            Inserts a knot and update control point locations.\r\r\n                    Does not change parameterization \r\r\n             or locus of curve.\r\r\n        \r\r\n        \r\r\n            value: Knot value to insert.\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def KnotMultiplicity(self, index):\r\n        \"\"\"\r\n        KnotMultiplicity(self: NurbsSurfaceKnotList, index: int) -> int\r\r\n        \r\r\n            Get knot multiplicity.\r\r\n        \r\r\n            index: Index of knot to query.\r\r\n            Returns: The multiplicity (valence) of the knot.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SuperfluousKnot(self, start):\r\n        \"\"\"\r\n        SuperfluousKnot(self: NurbsSurfaceKnotList, start: bool) -> float\r\r\n        \r\r\n            Computes the knots that are superfluous because they are not used in NURBs evaluation.\r\r\n                 \r\r\n                These make it appear so that the first and last surface spans are different from interior \r\r\n             spans.\r\r\n                    http://wiki.mcneel.com/developer/onsuperfluousknot\r\r\n        \r\r\n        \r\r\n            start: true if the query targets the first knot. Otherwise, the last knot.\r\r\n            Returns: A component.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[float](enumerable: IEnumerable[float], value: float) -> bool \"\"\"\r\n        pass\r\n\r\n    def __getitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__getitem__(y) <==> x[y] \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    def __setitem__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__setitem__(i, y) <==> x[i]= \"\"\"\r\n        pass\r\n\r\n    ClampedAtEnd = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Determines if a knot vector is clamped.\r\r\n\r\r\nGet: ClampedAtEnd(self: NurbsSurfaceKnotList) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n    ClampedAtStart = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Determines if a knot vector is clamped.\r\r\n\r\r\nGet: ClampedAtStart(self: NurbsSurfaceKnotList) -> bool\r\r\n\r\r\n\"\"\"\r\n\r\n    Count = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the total number of knots in this curve.\r\r\n\r\r\nGet: Count(self: NurbsSurfaceKnotList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\nclass NurbsSurfacePointList(object, IEnumerable[ControlPoint], IEnumerable, IEpsilonComparable[NurbsSurfacePointList]):\r\n    \"\"\" Provides access to the control points of a nurbs surface. \"\"\"\r\n    def EnsurePrivateCopy(self):\r\n        \"\"\"\r\n        EnsurePrivateCopy(self: NurbsSurfacePointList)\r\r\n            If you want to keep a copy of this class around by holding onto it in a variable after a command\r\r\r\n             \r\n                    completes, call EnsurePrivateCopy to make sure that this class is not tied to the \r\r\n             document. You can\r\r\n                    call this function as many times as you want.\r\n        \"\"\"\r\n        pass\r\n\r\n    def EpsilonEquals(self, other, epsilon):\r\n        \"\"\"\r\n        EpsilonEquals(self: NurbsSurfacePointList, other: NurbsSurfacePointList, epsilon: float) -> bool\r\r\n        \r\r\n            Check that all values in other are within epsilon of the values in this\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetControlPoint(self, u, v):\r\n        \"\"\"\r\n        GetControlPoint(self: NurbsSurfacePointList, u: int, v: int) -> ControlPoint\r\r\n        \r\r\n            Gets the control point at the given (u, v) index.\r\r\n        \r\r\n            u: Index of control-point along surface U direction.\r\r\n            v: Index of control-point along surface V direction.\r\r\n            Returns: The control point at the given (u, v) index.\r\n        \"\"\"\r\n        pass\r\n\r\n    def GetGrevillePoint(self, u, v):\r\n        \"\"\"\r\n        GetGrevillePoint(self: NurbsSurfacePointList, u: int, v: int) -> Point2d\r\r\n        \r\r\n            Gets the Greville point (u, v) coordinates associated with the control point at the given \r\r\n             indices.\r\r\n        \r\r\n        \r\r\n            u: Index of control-point along surface U direction.\r\r\n            v: Index of control-point along surface V direction.\r\r\n            Returns: A Surface UV coordinate on success, Point2d.Unset on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def SetControlPoint(self, u, v, cp):\r\n        \"\"\"\r\n        SetControlPoint(self: NurbsSurfacePointList, u: int, v: int, cp: ControlPoint) -> bool\r\r\n        \r\r\n            Sets the control point at the given (u, v) index.\r\r\n        \r\r\n            u: Index of control-point along surface U direction.\r\r\n            v: Index of control-point along surface V direction.\r\r\n            cp: The control point to set.\r\r\n            Returns: true on success, false on failure.\r\r\n        SetControlPoint(self: NurbsSurfacePointList, u: int, v: int, cp: Point3d) -> bool\r\r\n        \r\r\n            Sets the control point at the given (u, v) index.\r\r\n        \r\r\n            u: Index of control-point along surface U direction.\r\r\n            v: Index of control-point along surface V direction.\r\r\n            cp: The control point location to set (weight is assumed to be 1.0).\r\r\n            Returns: true on success, false on failure.\r\n        \"\"\"\r\n        pass\r\n\r\n    def __contains__(self, *args): #cannot find CLR method\r\n        \"\"\" __contains__[ControlPoint](enumerable: IEnumerable[ControlPoint], value: ControlPoint) -> bool \"\"\"\r\n        pass\r\n\r\n    def __init__(self, *args): #cannot find CLR method\r\n        \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\r\n        pass\r\n\r\n    def __iter__(self, *args): #cannot find CLR method\r\n        \"\"\" __iter__(self: IEnumerable) -> object \"\"\"\r\n        pass\r\n\r\n    def __repr__(self, *args): #cannot find CLR method\r\n        \"\"\" __repr__(self: object) -> str \"\"\"\r\n        pass\r\n\r\n    CountU = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of control points in the U direction of this surface.\r\r\n\r\r\nGet: CountU(self: NurbsSurfacePointList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n    CountV = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\r\n    \"\"\"Gets the number of control points in the V direction of this surface.\r\r\n\r\r\nGet: CountV(self: NurbsSurfacePointList) -> int\r\r\n\r\r\n\"\"\"\r\n\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}