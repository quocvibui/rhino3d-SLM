{
  "source_url": "https://github.com/gramaziokohler/tolerance_analysis/blob/b44750676e3422a0d6938daad691728e3a78e2a3/directed_graph_pringle_180902.py",
  "repo": "gramaziokohler/tolerance_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "directed_graph_pringle_180902.py",
  "instruction": "Directed graph pringle 180902",
  "code": "from compas.datastructures.network import Network\r\nfrom compas_fab.fab.geometry import Frame, Transformation, Translation, Rotation\r\nfrom compas.geometry.elements import Line, Point\r\nfrom compas.geometry import distance_point_point\r\nfrom compas.geometry import project_point_plane\r\nfrom compas.geometry import intersection_line_plane\r\nfrom compas_fab.fab.grasshopper.utilities.drawing import xdraw_frame\r\nfrom collections import deque\r\nimport random as r\r\nfrom graphviz import Digraph\r\nfrom heap import Heap\r\nimport random\r\nimport operator\r\nimport itertools\r\nimport math\r\nfrom compas.geometry.elements import Vector, Line\r\nimport Rhino.Geometry as rg\r\nimport rhinoscriptsyntax as rs\r\n\r\nr.seed(1)\r\n\r\n__author__     = 'Augusto Gandia'\r\n__copyright__  = 'Copyright 2018, Gramazio Kohler Research - ETH Zurich'\r\n__license__    = 'MIT'\r\n__email__      = 'gandia@arch.ethz.ch'\r\n\r\ndef setup(rawData):\r\n        cities = list()\r\n        #Create and return sorted data in list\r\n        data = list() \r\n        for line in rawData:\r\n            item = list()\r\n            temp = line.split()\r\n            item.extend([temp[0],temp[1],int(temp[2])])\r\n            cities.extend([temp[0],temp[1]])\r\n            data.append(item)\r\n        return sorted(data, key=operator.itemgetter(2)),sorted(set(cities))\r\n\r\ndef init(E):\r\n    nodes = {}\r\n    for e in E:\r\n        nodes[e] = None\r\n    return nodes\r\n\r\ndef find(nodes, U):\r\n    if U not in nodes:\r\n        print('Find failed: ' + str(U) + ' not found')\r\n        return None\r\n    if nodes[U] == None:\r\n        return U\r\n    return find(nodes,nodes[U])\r\n\r\ndef union(nodes,U0,U1):\r\n    U1_temp = find(nodes,U1)\r\n    U0_temp = find(nodes,U0)\r\n    if U1_temp == None or U0_temp == None:\r\n        failed = []\r\n        if U0_temp == None:\r\n            failed.append(U0)\r\n        if U1_temp == None:\r\n            failed.append(U1)\r\n        print('\\nUnion failed: Element(s) ' + str(failed) + ' not found\\n')\r\n        return None\r\n    if U0_temp != U1_temp:\r\n        nodes[U0_temp] = U1_temp\r\n    return U1_temp\r\n\r\ndef check_connectivity(current_beam, adjacency, beams_geometry, result, count):\r\n    #Type of beam (0 = bottom beams, 1 = middle beams, 2 = upper beams) \r\n    beams_type={0:1, 1:1, 2:0, 3:2, 4:1, 5:1, 6:0, 7:2, 8:1, 9:1, 10:0, 11:2, 12:1, 13:1, 14:0, 15:2, 16:1, \r\n    17:1, 18:0, 19:2, 20:1, 21:1, 22:0, 23:2, 24:1, 25:0, 26:2, 27:1, 28:0 ,29:2, 30:1, 31:0, 32:2, 33:1,\r\n    34:1, 35:0, 36:2, 37:1, 38:1, 39:0 ,40:2 ,41:1, 42:1, 43:1, 44:0, 45:2, 46:1, 47:1, 48:0, 49:2, 50:1,\r\n    51:1, 52:0, 53:2, 54:1, 55:1, 56:1, 57:0, 58:2, 59:1, 60:1, 61:0, 62:2, 63:1, 64:1, 65:0, 66:2, 67:1,\r\n    68:1, 69:1, 70:0, 71:2}\r\n\r\n    #List to store values for the second iteration, restore every second iteration\r\n    if count==None or count==0:\r\n        global temporary_result\r\n        temporary_result=[]\r\n    \r\n    print \"current_beam:\", current_beam\r\n\r\n    check=False\r\n    nbrs=set(adjacency[current_beam])\r\n\r\n    #if beam is 0 and it is the first one, just place it (this could be better)\r\n    if beams_type[current_beam]==0 and count==None:\r\n        temporary_result.append(str(current_beam))\r\n        check=True\r\n\r\n    elif beams_type[current_beam]==0:\r\n        for nbr_node in set(nbrs):\r\n            nbr_node_type=beams_type[nbr_node]\r\n            if nbr_node_type==0 and str(nbr_node) in result:\r\n                temporary_result.append(str(current_beam))\r\n                check=True\r\n\r\n    elif beams_type[current_beam]==1:\r\n        for nbr_node in set(nbrs):\r\n            nbr_node_type=beams_type[nbr_node]\r\n            if nbr_node_type==0:\r\n                if str(nbr_node) in result or str(nbr_node) in temporary_result:\r\n                    check=True\r\n\r\n    #If beam is a top beam\r\n    elif beams_type[current_beam]==2:\r\n        print \"type 2, current_beam\", current_beam\r\n        counter=0\r\n        middle_nbrs=0\r\n        #Iterate nbrs\r\n        for nbr_node in set(nbrs):\r\n            #Get nbr type\r\n            nbr_node_type=beams_type[nbr_node]\r\n            #If nbr is middle beam\r\n            print \"nbrs and type\", nbr_node, nbr_node_type\r\n            if nbr_node_type==1:\r\n                #Count how many nbrs are middle beams\r\n                middle_nbrs+=1\r\n                #Count built nbr middle beams\r\n                if str(nbr_node) in result:\r\n                    counter+=1\r\n        if counter==middle_nbrs:\r\n            print \"counter\", counter, \"middle_nbrs counter\", middle_nbrs\r\n            check=True\r\n    \r\n    return check\r\n\r\n    \"\"\"\r\n    if beam is 0 and it is the first one, just place it\r\n    if beam is 0 and it is not the first one, check if any nbr was placed\r\n    if beam is 1 check if its nbr 0 was placed\r\n    if beam is 2 check if 2 nbrs 2 were placed\r\n    \"\"\"\r\n\r\n# Method to perform Kruskal's Algorithm    \r\ndef kruskal(data,nodes,adjacency_dictionary,beams_geometry):\r\n\r\n    distance = 0\r\n    result = list()\r\n    nodes = init(nodes)\r\n    forward_counters={}\r\n    beams_propagation_path={}\r\n    stored_goal=[]\r\n    predecessors=[]\r\n\r\n    escape_count = 0\r\n\r\n    while len(data):\r\n        counter_1=0\r\n        counter_2=1\r\n        escape_count += 1\r\n        if escape_count > 100000:\r\n            raise Exception('Probably in an infinity loop, Aborting')\r\n        if escape_count==1:\r\n            counter_1=None\r\n        weighted_edge = data.pop(0)\r\n        if find(nodes, weighted_edge[0]) != find(nodes, weighted_edge[1]):\r\n            if not check_connectivity (int(weighted_edge[0]), adjacency_dictionary, beams_geometry, result, counter_1) or not check_connectivity (int(weighted_edge[1]), adjacency_dictionary, beams_geometry, result, counter_2):\r\n                key = '%s-%s' % (weighted_edge[0], weighted_edge[1])\r\n                if key in forward_counters:\r\n                    forward_counters[key]+=1\r\n                else:\r\n                    forward_counters[key]=1\r\n                forward_count=forward_counters[key]\r\n                data.insert(forward_count, weighted_edge)\r\n                continue\r\n            forward_counters = {}\r\n            union(nodes, weighted_edge[0], weighted_edge[1])\r\n            beam_1=weighted_edge[0]\r\n            beam_2=weighted_edge[1]\r\n            print \"weights 1 and 2\",weighted_edge[0], weighted_edge[1] \r\n            print \"=============================================================================>add beams 1 and 2:\",beam_1,beam_2\r\n            result.append(beam_1)\r\n            result.append(beam_2)\r\n            print \"result\", result\r\n            #Store parent of each beam according to fabrication sequence\r\n            #Remove duplicates from result\r\n            seen = set()\r\n            cleaned_result=[x for x in result if not (x in seen or seen.add(x))]\r\n            #Build an adjacency dictionary for each assembly step\r\n            beams_parent={}\r\n            #Iterate already assembled beams\r\n            for assembled_beam in cleaned_result:\r\n                #Get current beam nbrs\r\n                beam_nbrs=adjacency_dictionary[int(assembled_beam)]\r\n                #Check if any assembled beam is neighbour of current beam\r\n                for beam in cleaned_result:\r\n                    if int(beam) in beam_nbrs:\r\n                        #if key exists\r\n                        if int(assembled_beam) not in beams_parent:\r\n                            beams_parent.update({int(assembled_beam):[int(beam)]})\r\n\r\n    return cleaned_result, beams_parent\r\n\r\ndef midpoint_point_point(a, b):\r\n    return [0.5 * (a[0] + b[0]),\r\n            0.5 * (a[1] + b[1]),\r\n            0.5 * (a[2] + b[2])]\r\n\r\ndef midpoint_line(line):\r\n    return midpoint_point_point(*line)\r\n    \r\ndef vertex_neighbours(self,key):\r\n    \"\"\"Return the neighbours of a vertex.\"\"\"\r\n    return list(self.halfedge[key])\r\n\r\ndef edge_connected_edges(self, u, v):\r\n    edges = []\r\n    for nbr in vertex_neighbours(self,u):\r\n        if nbr in self.edge[u]:\r\n            edges.append((u, nbr))\r\n        else:\r\n            edges.append((nbr, u))\r\n    for nbr in vertex_neighbours(self,v):\r\n        if nbr in self.edge[v]:\r\n            edges.append((v, nbr))\r\n        else:\r\n            edges.append((nbr, v))\r\n    return edges\r\n\r\ndef delete_vertex(self, key): #This could be removed in newer versions of compas\r\n    for nbr in self.vertex_neighbours(key):\r\n        del self.halfedge[key][nbr]\r\n        del self.halfedge[nbr][key]\r\n        if key in self.edge and nbr in self.edge[key]:\r\n            del self.edge[key][nbr]\r\n        else:\r\n            del self.edge[nbr][key]\r\n    del self.vertex[key]\r\n    del self.halfedge[key]\r\n    del self.edge[key]\r\n\r\ndef translate_frame_own_xyz(transformation,x_dist, y_dist, z_dist):\r\n    x_transform = [[1, 0, 0, (transformation[0, 0] * x_dist)],\r\n                   [0, 1, 0, (transformation[1, 0] * x_dist)],\r\n                   [0, 0, 1, (transformation[2, 0] * x_dist)],\r\n                   [0, 0, 0, 1]]\r\n    y_transform = [[1, 0, 0, (transformation[0, 1]*y_dist)],\r\n                   [0, 1, 0, (transformation[1, 1]*y_dist)],\r\n                   [0, 0, 1, (transformation[2, 1]*y_dist)],\r\n                   [0, 0, 0, 1]]\r\n    z_transform = [[1, 0, 0, (transformation[0, 2]*z_dist)],\r\n                   [0, 1, 0, (transformation[1, 2]*z_dist)],\r\n                   [0, 0, 1, (transformation[2, 2]*z_dist)],\r\n                   [0, 0, 0, 0]]\r\n\r\n    return Translation.from_matrix(z_transform)*Translation.from_matrix(y_transform)*Translation.from_matrix(x_transform)\r\n    \r\n\r\nclass ToleranceNetwork(Network):\r\n    #General Network required to 1) generate assembly sequence to 2) perform tolerance analysis\r\n    def __init__(self, joint_edges, beam_edges, ordered_beams, weights_list):\r\n        super(ToleranceNetwork, self).__init__() \r\n        input_dict = {'joint_edges': joint_edges, 'beam_edges': beam_edges, 'ordered_beams': ordered_beams}\r\n        self.attributes.update(input_dict)\r\n        self.build_geometry_network()\r\n        self.build_topology_network (weights_list)\r\n        self.assembly_sequence_search()\r\n\r\n    def build_geometry_network(self):\r\n        #add vertices of beam_edges to Tolerance Network(vertices same as Geometry network)\r\n        #iterate beam_edges indexes\r\n        for index in range(len(self.attributes ['beam_edges'])):\r\n            #get vertex coordinates \r\n            position = self.attributes['beam_edges'][index][0]\r\n            #generate vertex u, add coordinates and vertex type as attribute\r\n            u=self.add_vertex(attr_dict={'x': position[0], 'y' : position[1], 'z' : position[2], 'vertex_type': 'member'})\r\n            #get vertex coordinates \r\n            position = self.attributes ['beam_edges'][index][1]\r\n            #generate vertex v, add coordinates and vertex type as attribute\r\n            v=self.add_vertex(attr_dict={'x': position[0], 'y' : position[1], 'z' : position[2], 'vertex_type': 'member'})\r\n            #add beam edge, beam object, edge_type, u_coordinate , v_coordinate\r\n            self.add_edge(u,v, {'edge_type': 'member','beam': self.attributes ['ordered_beams'][index], 'u_coordinate':self.vertex_coordinates(u), 'v_coordinate': self.vertex_coordinates(v), 'member_edge_nbrs': []})\r\n        \r\n        # BUILD GEOMETRY NETWORK\r\n        #compare joint edges and beam edges\r\n        store_joint_new_u=[]\r\n        store_joint_new_v=[]\r\n        #iterate joint edges\r\n        for index in range (len(self.attributes['joint_edges'])):\r\n            #get joint_vertices coordinates\r\n            joint_u_coordinate=self.attributes ['joint_edges'][index][0] \r\n            joint_v_coordinate=self.attributes ['joint_edges'][index][1]\r\n            #iterate beam edges\r\n            corresponding_joint_u_index=None #this can be revised\r\n            corresponding_joint_v_index=None\r\n            for u,v,attr in self.edges(data=True):\r\n                #get beam_vertices coordinates\r\n                beam_u_coordinate=attr['u_coordinate']\r\n                beam_v_coordinate=attr['v_coordinate']\r\n                #compare joint vertex u and beam vertex u\r\n                if distance_point_point(joint_u_coordinate,beam_u_coordinate) < 0.5:\r\n                    global corresponding_joint_u_index\r\n                    corresponding_joint_u_index=u\r\n                #compare joint vertex u and beam vertex v\r\n                elif distance_point_point(joint_u_coordinate,beam_v_coordinate) < 0.5:\r\n                    global corresponding_joint_u_index\r\n                    corresponding_joint_u_index=v\r\n                #compare joint vertex v and beam vertex u\r\n                elif distance_point_point(joint_v_coordinate,beam_u_coordinate) < 0.5:\r\n                    global corresponding_joint_v_index\r\n                    corresponding_joint_v_index=u\r\n                #compare joint vertex v and beam vertex v\r\n                elif distance_point_point(joint_v_coordinate,beam_v_coordinate) < 0.5:\r\n                    global corresponding_joint_v_index\r\n                    corresponding_joint_v_index=v\r\n            #store corresponding joint v index\r\n            store_joint_new_u.append(corresponding_joint_u_index)\r\n            #store corresponding joint u index\r\n            store_joint_new_v.append(corresponding_joint_v_index)\r\n        for index in range(len(store_joint_new_v)):\r\n            self.add_edge(store_joint_new_u[index], store_joint_new_v[index], {'edge_type': 'joint', 'beam': None})\r\n        \r\n        # STORE CONNECTIVITY IN EDGE MEMBERS\r\n        #iterate edges\r\n        for u,v,attr in self.edges(data=True):\r\n            #filter joint edges\r\n            if attr['edge_type']=='joint':\r\n                #edges connected to joint edge\r\n                connected_edges=edge_connected_edges(self,u,v) \r\n                connected_member_edges=[]\r\n                #filter connected member edges and store connected member edges\r\n                for connected_edge in connected_edges:\r\n                    #if edge is beam edge\r\n                    if self.get_edge_attribute(connected_edge[0],connected_edge[1],'edge_type')=='member':\r\n                        #store it (two members per joint)   \r\n                        connected_member_edges.append((connected_edge[0],connected_edge[1])) \r\n                #get existing neighbours from first edge\r\n                first_member_edge_neighbours=self.get_edge_attribute(connected_member_edges[0][0],connected_member_edges[0][1],'member_edge_nbrs')\r\n                #(by appending them they get included in the attribute)\r\n                first_member_edge_neighbours.append(connected_member_edges[1]) \r\n                #get existing neighbours from second edge \r\n                sec_member_edge_neighbours=self.get_edge_attribute(connected_member_edges[1][0],connected_member_edges[1][1],'member_edge_nbrs')\r\n                #(by appending them they get included in the attribute)\r\n                sec_member_edge_neighbours.append(connected_member_edges[0])\r\n\r\n    # GENERATE ASSEMBLY SEQUENCE NETWORK (beams=nodes and connections=edges)\r\n    def build_topology_network(self, weights_list):\r\n        beams_geometry=self.attributes['ordered_beams']\r\n        #this \"topology network\" is an inversion of the \"geometry_network\" by turning beams into vertices\r\n        self.assembly_sequence_network=AssemblySequenceNetwork(self, weights_list, beams_geometry)\r\n\r\n    def assembly_sequence_search(self):\r\n        #Adjacency dictionary for COMPAS deph_first_tree\r\n        adjacency_dictionary=self.assembly_sequence_network.adjacency_dictionary\r\n        beams_geometry=self.assembly_sequence_network.beams_geometry\r\n        #Create a list that represents the relations for a directed graph\r\n        #List with weighted edges (a, b, c) a=start vertex b=end vertex c=weight\r\n        directed_edges=[]\r\n        #Iterate nodes\r\n        for node in adjacency_dictionary:\r\n            parent_weight = self.assembly_sequence_network.get_vertex_attribute(node, 'weight')\r\n            #Iterate neighbours of each node\r\n            for nbr in adjacency_dictionary[node]:\r\n                child_weight = self.assembly_sequence_network.get_vertex_attribute(nbr, 'weight') \r\n                parent = [str(nbr), str(node), parent_weight]\r\n                child = [str(node), str(nbr), child_weight]\r\n\r\n                if parent_weight > child_weight:\r\n                    directed_edges.append(parent)\r\n                    if child in directed_edges:\r\n                        directed_edges.remove(child)\r\n                else:\r\n                    directed_edges.append(child)\r\n                    if parent in directed_edges:\r\n                        directed_edges.remove(parent)\r\n\r\n        sorted_directed_edges = sorted(directed_edges, key=operator.itemgetter(2))\r\n        self.sorted_directed_edges = sorted_directed_edges[:]\r\n        nodes = map(str, self.assembly_sequence_network.vertices())\r\n        result, beams_parent = kruskal(sorted_directed_edges,nodes,adjacency_dictionary,beams_geometry)\r\n        self.result=result\r\n        print result\r\n        self.beams_parent=beams_parent\r\n\r\n        # It may be needed!!!\r\n        \"\"\"\r\n        #Correct first values (To be fixed)\r\n        building_sequence.insert(0,[building_sequence[0][0]])\r\n        building_sequence.insert(2,[building_sequence[2][0], building_sequence[2][1], building_sequence[2][2]])\r\n        building_sequence.pop(3)\r\n        self.building_sequence=building_sequence \r\n        \"\"\"   \r\n\r\n#Network to generate assembly sequence\r\nclass AssemblySequenceNetwork (Network):\r\n    def __init__(self, geometry_network, weights_list, beams_geometry):\r\n        super(AssemblySequenceNetwork, self).__init__() \r\n        input_dict = {'edges': geometry_network.edges(data=True)}\r\n        self.attributes.update(input_dict)\r\n        self.beams_geometry=beams_geometry\r\n        self.invert_network(weights_list)\r\n\r\n    def invert_network (self, weights_list):\r\n        #to translate from member being an edge to member being a vertex \r\n        #only the u value of each member is used and divided by 2.\r\n        #thus it turns from being (u=0,u=2,u=4...) to (u=0,u=1,u=2...) \r\n        #iter member edges of geometry network\r\n        for u,v,attr in self.attributes['edges']:\r\n            if attr['edge_type']=='member':\r\n                #get midpoint for each member edge of geometry network\r\n                beam_edge_mid=midpoint_line((attr['u_coordinate'],attr['v_coordinate']))\r\n                #create new vertex and use as coordinate the midpoint of u and v\r\n                self.add_vertex(attr_dict={'x': beam_edge_mid[0], 'y' : beam_edge_mid[1], 'z' : beam_edge_mid[2]})#add beam_vertex\r\n        #create adjacency dictionary\r\n        adjacency_dict={}\r\n        for u,v,attr in self.attributes['edges']:\r\n            if attr['edge_type']=='member':\r\n                temp_connected_vertex=[]\r\n                #iter connected member edges of geometry network\r\n                for connected_vertices in attr['member_edge_nbrs']:\r\n                    #store connected member as its u value divided by 2 \r\n                    temp_connected_vertex.append(connected_vertices[0]/2)\r\n                adjacency_dict[u/2]=temp_connected_vertex\r\n        #prepare adjacency dictionary for COMPAS traverse\r\n        self.adjacency_dictionary=adjacency_dict\r\n        #add adjacency and weight attribute to vertices\r\n        for u, attr in self.vertices(data=True):\r\n            self.set_vertex_attribute(u,'weight', weights_list[u])\r\n            self.set_vertex_attribute(u,'connected_vertices', adjacency_dict[u])\r\n\r\nif __name__ == \"__main__\":\r\n    temp_frames_array = [] \r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}