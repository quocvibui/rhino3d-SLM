{
  "source_url": "https://discourse.mcneel.com/t/using-gui-from-python-with-sharpdev-question/12266",
  "topic_id": 12266,
  "title": "Using GUI from python with SharpDev Question:",
  "question": "I have a question about how to interact with iron python code that SharpDevelop creates.  I have been going through the code Steve Baer posted here: \nhttp://stevebaer.wordpress.com/2010/07/22/starmaker-an-advanced-sample/\n\n\n& My question really is around how to deal with event classes, like this:\n\n\ndef OnDrawForeground(self, sender, e):\n    # This function is called while updating viewports. Try not to perform\n    # too many calculations in here to minimize display performance hit.\n    # Draw each temp_curve in red and a \"control\" polygon in feedback color\n    curve_color = System.Drawing.Color.Red\n    feedback_color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    for points, curve in self.__temp_curves:\n        e.Display.DrawCurve(curve, curve_color, 1)\n        e.Display.DrawDottedPolyline( points, feedback_color, True )\n        e.Display.DrawPoints(points, Rhino.Display.PointStyle.ControlPoint, 2, feedback_color)\n\n\n\nMy question is 1, is there a way to use gui elements like this, & interact with them using rhino script syntax or rhino common?  I’m having a hard time understanding where I can find the different functions inside of what e (DrawEventArgs?)  is this accessing rhino common’s DrawEventArgs, inside of Rhino.Display?\n\n\nIs there anyone who can further explain what is happening here? I should also maybe explain what we are trying to do more, & that is: being able to use a slider to move an object & then run some code on that new objects position…\n\n\nTHANK YOU!\n\n\nBradley",
  "code_blocks": [
    {
      "code": "def __init__(self, curve_ids, dialog):\n    # tell the SliderForm about a function to call when the slider values change\n    dialog.SetValueChangedCallback(self.UpdateTempCurves)\n    # Set up display conduit events to allow drawing of temporary preview\n    # geometry while the values are being adjusted by the user\n    #\n    # CalculateBoundingBox event is used to adjust the view's clipped bounds.\n    # Preview geometry may be outside the area of the bounding box of geometry\n    # in the document and therefore may be clipped if we don't adjust the bbox\n    Rhino.Display.DisplayPipeline.CalculateBoundingBox += self.OnCalcBoundingBox\n    # DrawForeground event is used to actually draw some temporary geometry on top\n    # of everything else. Depth writing/testing are off at this stage so all\n    # geometry is drawn on top\n    Rhino.Display.DisplayPipeline.DrawForeground += self.OnDrawForeground\n    # Get notified of when the form closes so we can remove our conduits\n    dialog.FormClosed += self.OnSliderFormClosed\n    \n    # temp_curves and temp_curves_bbox are used for dynamic display\n    self.__temp_curves = []\n    self.__temp_curves_bbox = None\n    # original_curves is a list of (id, centroid, points) for each curve\n    # provided in the constructor. This is the information we need to\n    # quickly construct our temp_curves\n    self.__original_curves = []\n    for curve_id in curve_ids:\n        # curve_id is a Guid. Try to get the Curve geometry from this Guid\n        objref = Rhino.DocObjects.ObjRef(curve_id)\n        curve_geometry = objref.Curve()\n        objref.Dispose()\n        if( curve_geometry!=None and curve_geometry.IsClosed ):\n            mp = Rhino.Geometry.AreaMassProperties.Compute(curve_geometry)\n            rc, points = curve_geometry.TryGetPolyline()\n            if( rc ): self.__original_curves.append( (curve_id, mp.Centroid, points) )\n\ndef OnSliderFormClosed(self, sender, e):\n    # Form has closed. Remove our display conduit\n    Rhino.Display.DisplayPipeline.DrawForeground -= self.OnDrawForeground\n    Rhino.Display.DisplayPipeline.CalculateBoundingBox -= self.OnCalcBoundingBox\n    scriptcontext.doc.Views.Redraw()\n\ndef OnDrawForeground(self, sender, e):\n    # This function is called while updating viewports. Try not to perform\n    # too many calculations in here to minimize display performance hit.\n    # Draw each temp_curve in red and a \"control\" polygon in feedback color\n    curve_color = System.Drawing.Color.Red\n    feedback_color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    for points, curve in self.__temp_curves:\n        e.Display.DrawCurve(curve, curve_color, 1)\n        e.Display.DrawDottedPolyline( points, feedback_color, True )\n        e.Display.DrawPoints(points, Rhino.Display.PointStyle.ControlPoint, 2, feedback_color)\n\ndef OnCalcBoundingBox(self, sender, e):\n    # Update the boundingbox to include our temporary curves\n    if(self.__temp_curves_bbox!=None):\n        e.IncludeBoundingBox(self.__temp_curves_bbox)\n    \ndef UpdateTempCurves(self, ratio_offset_even, ratio_offset_odd):\n    self.__temp_curves = []\n    self.__temp_curves_bbox=None\n    for id, centroid, cvs in self.__original_curves:\n        # \"cook\" up a temp_curve from the original curve data\n        temp_points = []\n        count = len(cvs)\n        for index, cv in enumerate(cvs):\n            vector = cv - centroid\n            # use %2 for even/odd test\n            if( index%2 == 0 or index==(count-1)):\n                vector *= ratio_offset_even\n            else:\n                vector *= ratio_offset_odd\n            point = centroid + vector\n            temp_points.append(point)\n        temp_curve = Rhino.Geometry.Curve.CreateControlPointCurve(temp_points, 3)\n        if( temp_curve!=None ):\n            self.__temp_curves.append((temp_points,temp_curve))\n            if( self.__temp_curves_bbox==None ):\n                self.__temp_curves_bbox = temp_curve.GetBoundingBox(False)\n            else:\n                self.__temp_curves_bbox = Rhino.Geometry.BoundingBox.Union( self.__temp_curves_bbox, temp_curve.GetBoundingBox(False))\n    scriptcontext.doc.Views.Redraw()\n\ndef AddCurvesToDocument(self):\n    # add the temp_curves to the document so they become \"real\" Rhino geometry\n    for points, curve in self.__temp_curves:\n        scriptcontext.doc.Objects.AddCurve(curve)\n    scriptcontext.doc.Views.Redraw()",
      "language": "python",
      "author": "bradrothenberg",
      "post_number": 2,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "geometry",
    "nurbs",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 3,
  "views": 1232
}