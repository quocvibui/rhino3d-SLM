{
  "source_url": "https://github.com/969flash/LausLecture/blob/004c0a8938bf805b8d70c744ddf5eb911fd4277f/Lecture4/utils.py",
  "repo": "969flash/LausLecture",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Lecture4/utils.py",
  "instruction": null,
  "code": "from typing import List, Tuple, Any, Optional, Union\nimport Rhino.Geometry as geo\nimport Rhino\nimport functools\n\nimport ghpythonlib.components as ghcomp\n\nTOL = 0.01  # 기본 허용 오차\nDIST_TOL = 0.01\nAREA_TOL = 0.1\nOP_TOL = 0.00001\nCLIPPER_TOL = 0.0000000001\nBIGNUM = 100000\nROUNDING_PRECISION = 6  # 반올림 소수점 자리수\n\n\ndef get_dist_between_pts(\n    pt_a: geo.Point3d, pt_b: geo.Point3d, rounding_precision=ROUNDING_PRECISION\n):\n    \"\"\"\n    두 점 사이의 거리 계산\n    :param pt_a: Rhino.Geometry.Point3d 객체\n    :param pt_b: Rhino.Geometry.Point3d 객체\n    :param rounding_precision: 거리 반올림 소수점 자리수\n    :return: 거리 (float)\n    \"\"\"\n    return round(pt_a.DistanceTo(pt_b), rounding_precision)\n\n\ndef has_intersection(\n    crv_a: geo.Curve, crv_b: geo.Curve, plane=geo.Plane.WorldXY, tol=TOL\n):\n    \"\"\"\n    두 커브가 교차하는지 여부를 확인\n    :param curve_a: Rhino.Geometry.Curve 객체\n    :param curve_b: Rhino.Geometry.Curve 객체\n    :return: 교차 여부 (bool)\n    \"\"\"\n    return geo.Curve.PlanarCurveCollision(crv_a, crv_b, plane, tol)\n\n\n## 커브간의 교차 점 생성\ndef get_intersection_from_crvs(crv_a: geo.Curve, crv_b: geo.Curve, tol=TOL):\n    \"\"\"\n    두 커브 사이의 교차점 계산\n    :param curve_a: Rhino.Geometry.Curve 객체\n    :param curve_b: Rhino.Geometry.Curve 객체\n    :param tol: 허용 오차\n    :return: 교차점 리스트 (list of Point3d)\n    \"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(crv_a, crv_b, tol, tol)\n\n    # 교차점이 없을 경우 빈 리스트 반환\n    if not intersections:\n        return []\n\n    return [pt.PointA for pt in intersections if pt.IsPointAValid]\n\n\n## 커브간의 점간의 거리 계산\ndef get_dist_between_crvs(\n    crv_a: geo.Curve, crv_b: geo.Curve, rounding_precision=ROUNDING_PRECISION\n):\n    \"\"\"\n    두 커브 사이의 최소 거리 계산\n    :param curve_a: Rhino.Geometry.Curve 객체\n    :param curve_b: Rhino.Geometry.Curve 객체\n    :param rounding_precision: 거리 반올림 소수점 자리수\n    :return: 최소 거리 (float)\n    \"\"\"\n    _, a, b = crv_a.ClosestPoints(crv_b)\n    dist = a.DistanceTo(b)\n    return round(dist, rounding_precision)\n\n\ndef explode_curve(crv: geo.Curve) -> List[geo.Curve]:\n    \"\"\"\n    커브를 분할하여 개별 세그먼트로 나눈다.\n    :param curve: Rhino.Geometry.Curve 객체\n    :return: 분할된 커브 리스트 (list of Curve)\n    \"\"\"\n    if not crv:\n        return []\n\n    # span이 1개면 추가적인 연산 필요 없다.\n    if crv.SpanCount == 1:\n        return [crv]\n\n    segments = []\n    for i in range(crv.SpanCount):\n        param_start, param_end = crv.SpanDomain(i)\n        pt_seg_start = crv.PointAt(param_start)\n        pt_seg_end = crv.PointAt(param_end)\n        segments.append(geo.LineCurve(pt_seg_start, pt_seg_end))\n\n    return segments\n\n\ndef has_region_intersection(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"영역 커브와 다른 영역 커브가 교차하는지 확인한다.\n    Args:\n        region: 영역 커브\n        other_regions: 다른 영역 커브 리스트\n        tol: tolerance\n\n    Returns:\n        bool: 교차 여부\n    \"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    # 완전히 떨어져 있는 경우. 닿은 부분 없이.\n    if relationship == geo.RegionContainment.Disjoint:\n        return False\n    return True\n\n\ndef get_dist_between_pt_and_crv(\n    pt: geo.Point3d, crv: geo.Curve, rounding_precision=ROUNDING_PRECISION\n) -> float:\n    \"\"\"\n    주어진 점과 커브 사이의 거리 계산\n    :param pt: Rhino.Geometry.Point3d 객체\n    :param crv: Rhino.Geometry.Curve 객체\n    :param rounding_precision: 거리 반올림 소수점 자리수\n    :return: 거리 (float)\n    \"\"\"\n    dist = pt.DistanceTo(crv.PointAt(crv.ClosestPoint(pt)[1]))\n    dist = round(dist, rounding_precision)\n    return dist\n\n\ndef is_region_inside_region(\n    region: geo.Curve, other_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"영역 커브가 다른 영역 커브 내부에 있는지 확인한다.\n    Args:\n        region: 영역 커브\n        other_region: 다른 영역 커브\n        tol: tolerance\n    Returns:\n        bool: 내부 여부\n    \"\"\"\n\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region, other_region, geo.Plane.WorldXY, tol\n    )\n    # region이 other_region 내부에 있는 경우\n    if relationship == geo.RegionContainment.AInsideB:\n        return True\n    return False\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    return Offset().polyline_offset(regions, dist, miter).holes\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\ndef get_outside_perp_vec_from_pt(pt: geo.Point3d, region: geo.Curve) -> geo.Vector3d:\n    _, param = region.ClosestPoint(pt)\n    vec_perp_outer = region.PerpendicularFrameAt(param)[1].XAxis\n\n    if region.ClosedCurveOrientation() != geo.CurveOrientation.Clockwise:\n        vec_perp_outer = -vec_perp_outer\n\n    return vec_perp_outer\n\n\ndef get_pt_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"커브를 주어진 길이로 나누는 점을 구한다.\"\"\"\n    params = crv.DivideByLength(length, include_start)\n\n    # crv가 length보다 짧은 경우\n    if not params:\n        return []\n\n    return [crv.PointAt(param) for param in params]\n\n\ndef move_curve(crv: geo.Curve, vec: geo.Vector3d):\n    \"\"\"커브를 주어진 벡터로 이동시킨다.\"\"\"\n    moved_crv = crv.Duplicate()\n    moved_crv.Translate(vec)\n    return moved_crv\n\n\ndef get_bounding_box_crv(curve: geo.Curve, plane: geo.Plane) -> geo.PolylineCurve:\n    \"\"\"주어진 커브의 바운딩 박스를 구한다.\"\"\"\n    bbox = curve.GetBoundingBox(plane)\n\n    corners = list(bbox.GetCorners())[:4]  # type: List[geo.Point3d]\n    for corner in corners:\n        corner.Transform(geo.Transform.ChangeBasis(plane, geo.Plane.WorldXY))\n\n    return geo.PolylineCurve(corners + [corners[0]])\n\n\ndef convert_io_to_list(func):\n    \"\"\"인풋과 아웃풋을 리스트로 만들어주는 데코레이터\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\nclass Offset:\n    class _PolylineOffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _PolylineOffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _PolylineOffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._PolylineOffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}