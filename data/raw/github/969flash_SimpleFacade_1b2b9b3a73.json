{
  "source_url": "https://github.com/969flash/SimpleFacade/blob/6c7fecac5a2905e174905fc57fab87d40de0cc3e/.old/builder.py",
  "repo": "969flash/SimpleFacade",
  "repo_stars": 1,
  "repo_description": "Make Facade From Building Mass",
  "license": "unknown",
  "filepath": ".old/builder.py",
  "instruction": "Builder",
  "code": "import ghpythonlib.components as ghcomp\nimport Rhino.Geometry as geo\nimport Rhino\nimport scriptcontext as sc\nimport random\nimport rhinoscriptsyntax as rs\n\n\nclass Floor:\n    def __init__(self, brep):\n        self.height = 0.0\n        self.brep = brep\n        self.faces = None\n        self.floor = None\n        self.ceiling = None\n        self.glass = None\n        self.glass_frames = None\n        self.core = None\n        self.slab = None\n        self._initialize()\n\n    def _initialize(self):\n        def get_max_z(brep):\n            return max(pt.Location.Z for pt in brep.Vertices)\n\n        def get_min_z(brep):\n            return min(pt.Location.Z for pt in brep.Vertices)\n\n        self.breps = ghcomp.DeconstructBrep(self.brep)[0]\n        self.floor = min(self.breps, key=lambda brep: get_max_z(brep))\n        self.ceiling = max(self.breps, key=lambda brep: get_min_z(brep))\n        self.glass = [\n            face for face in self.breps if face != self.floor and face != self.ceiling\n        ]\n        self.height = (\n            self.ceiling.Vertices[0].Location.Z - self.floor.Vertices[0].Location.Z\n        )\n\n    def set_glass_frames(self, distance, frame_distance):\n        if self.glass is None:\n            return\n        glass_frames = []\n        edges = self.floor.DuplicateEdgeCurves()\n        for edge in edges:\n            params = edge.DivideByLength(distance, True)\n            if not params:\n                continue\n            for i in range(len(params) - 1):\n                segment = edge.Trim(params[i], params[i + 1])\n\n                if segment:\n                    frame_curve = segment.DuplicateCurve()\n                    frame_curve = trim_crv_from_length(frame_curve, frame_distance)\n\n                    if not frame_curve:\n                        continue\n                    frame_surface = geo.Extrusion.Create(\n                        frame_curve, self.height, False\n                    )\n                    glass_frames.append(frame_surface)\n\n        self.glass_frames = glass_frames\n\n    def _get_core(self, offset_distance, reverse=False, height=None):\n        if self.ceiling is None:\n            return\n        if height is None:\n            height = self.height\n        ceiling_edges = self.ceiling.DuplicateEdgeCurves()\n        ceiling_edge = ghcomp.JoinCurves(ceiling_edges, True)\n        core_edge = ghcomp.OffsetCurve(ceiling_edge, -offset_distance, corners=1)\n\n        if isinstance(core_edge, geo.Curve):\n            # 플리커링 방지를 위해 0.1 빼줌\n            height_to_extrude = height - 0.1\n            if reverse:\n                height_to_extrude = -height_to_extrude\n\n            return geo.Extrusion.Create(core_edge, height_to_extrude, True)\n        return None\n\n    def set_core(self, offset_distance, reverse=False):\n        if self.floor is None:\n            return\n        self.core = self._get_core(offset_distance, reverse)\n\n    def set_slab(self, thickness):\n        if self.floor is None:\n            return\n        ceiling_edges = self.ceiling.DuplicateEdgeCurves()\n        ceiling_edge = ghcomp.JoinCurves(ceiling_edges, True)\n        self.slab = geo.Extrusion.Create(ceiling_edge, -thickness, True)\n\n\nclass RoofFloor(Floor):\n    def __init__(self, brep):\n        super().__init__(brep)\n        random_height = random.uniform(1.2, 3.6)\n        self.top_cores = self._get_core(random.uniform(6, 11), height=random_height)\n        self.railing = self._get_railing()\n\n    def _get_railing(self):\n        if self.ceiling is None:\n            return\n        edges = self.ceiling.DuplicateEdgeCurves()\n        edge = ghcomp.JoinCurves(edges, True)\n        inward_edge = ghcomp.OffsetCurve(edge, -random.uniform(0.2, 0.5), corners=1)\n        if isinstance(inward_edge, list):\n            inward_edge = inward_edge[0]\n        # loft_option = ghcomp.LoftOptions(True, True, 0, 0, 3)\n        # loft = ghcomp.Loft([edge, inward_edge], loft_option)\n\n        loft = ghcomp.Loft([edge, inward_edge])\n        extrusion = ghcomp.Extrude(loft, -geo.Vector3d.ZAxis * random.uniform(0.5, 1.5))\n        extrusion = ghcomp.Extrude(loft, geo.Vector3d.ZAxis * random.uniform(0.5, 1.5))\n        return extrusion\n\n\nclass BottomFloor(Floor):\n    def __init__(self, brep):\n        super().__init__(brep)\n        self._additional_bottom_setup()\n\n    def _additional_bottom_setup(self):\n        # Add any additional setup for BottomFloor here\n        print(\"Additional setup for BottomFloor\")\n\n\ndef trim_crv_from_length(crv, length, reverse=False):\n    # type: (geo.Curve, float, bool) -> geo.Curve\n    \"\"\"crv의 시작점부터 lenth까지의 커브를 구한다.\"\"\"\n    is_len_possible, param = crv.LengthParameter(length)\n    if not is_len_possible:\n        return crv\n\n    ## for Rhino 8, REMOVE FOR RHINO7 !!!##\n    param = float(param)\n    ########################################\n\n    if reverse:\n        return crv.Trim(param, crv.Domain.Max)\n\n    return crv.Trim(0.0, param)\n\n\ndef cluster_breps(breps, threshold=0.5):\n\n    def are_breps_touching(brep1, brep2, threshold):\n        for vertex in brep1.Vertices:\n            point = vertex.Location\n            closest_point = brep2.ClosestPoint(point)\n            distance = point.DistanceTo(closest_point)\n            if distance < threshold:\n                return True\n        return False\n\n    def get_all_linked_breps(brep, breps, threshold):\n        linked_breps = [brep]\n        queue = [brep]\n        while queue:\n            current_brep = queue.pop(0)\n            for other_brep in breps:\n                if other_brep not in linked_breps and are_breps_touching(\n                    current_brep, other_brep, threshold\n                ):\n                    linked_breps.append(other_brep)\n                    queue.append(other_brep)\n        return linked_breps\n\n    clusters = []\n    for brep in breps:\n        if any(brep in cluster for cluster in clusters):\n            continue\n\n        breps_not_in_clusters = [\n            b for b in breps if not any(b in cluster for cluster in clusters)\n        ]\n        cluster = get_all_linked_breps(brep, breps_not_in_clusters, threshold)\n\n        clusters.append(cluster)\n    return clusters\n\n\ndef bake_to_layer(objects, layer_name):\n    # TODO: 같은 클러스터 별로 라이노 도큐먼트 생성싱 그룹핑 해야함\n    if not objects:\n        return\n    if not isinstance(objects, list):\n        objects = [objects]\n    ghdoc = sc.doc\n    sc.doc = Rhino.RhinoDoc.ActiveDoc\n    try:\n        if not rs.IsLayer(layer_name):\n            rs.AddLayer(layer_name)\n        for obj in objects:\n            if not obj:\n                continue\n            if not isinstance(obj, geo.Brep):\n                obj = obj.ToBrep()\n            obj_id = sc.doc.Objects.AddBrep(obj)\n            obj_ref = sc.doc.Objects.Find(obj_id)\n            # obj_id로 FioreObject를 찾을 수 없을 때가 있음\n            if not obj_ref:\n                continue\n            attributes = obj_ref.Attributes\n            attributes.LayerIndex = sc.doc.Layers.FindByFullPath(layer_name, True)\n            sc.doc.Objects.ModifyAttributes(obj_id, attributes, True)\n        sc.doc.Views.Redraw()\n    finally:\n        sc.doc = ghdoc\n\n\ndef get_top_brep(cluster):\n    if not cluster:\n        return None\n    return max(cluster, key=lambda brep: brep.GetBoundingBox(True).Max.Z)\n\n\ndef get_bottom_brep(cluster):\n    if not cluster:\n        return None\n    return min(cluster, key=lambda brep: brep.GetBoundingBox(True).Min.Z)\n\n\nprint(\"TEST 1\", len(breps))\n\n### input = breps, glass_dist, frame_dist, core_dist, slab_thick\nclusters = cluster_breps(breps)\n\n###### COMMON OUTPUT ######\nglasses = []\nglass_frames = []\ncores = []\nslabs = []\n\n\n###### TOP FLOOR OUTPUT ######\nrailings = []\ntop_cores = []\n\n###### BOTTOM FLOOR OUTPUT ######\nbottom_walls = []\nbottoms = []\n\nfloors = []\nceilings = []\n\nornaments = []\nfor cluster in clusters:\n    print(\"====================\")\n    print(\"    cluster : \", len(cluster))\n    _glass_dist = glass_dist * random.uniform(0.8, 2.4)\n    _frame_dist = frame_dist * random.uniform(0.8, 1.8)\n    _core_dist = core_dist * random.uniform(0.8, 1.2)\n    _slab_thick = slab_thick * random.uniform(0.8, 1.2)\n\n    # Add to bottom floor output\n    bottom_brep = get_bottom_brep(cluster)\n    if bottom_brep:\n        print(\"bottom_brep Succed\", bottom_brep)\n        cluster.remove(bottom_brep)\n        bottom_floor = BottomFloor(bottom_brep)\n        bottom_walls.extend(bottom_floor.glass)\n        bottoms.append(bottom_floor)\n\n    # Add to top floor output\n    top_brep = get_top_brep(cluster)\n    if top_brep:\n        print(\"top_brep Succed\", top_brep)\n        # TOP FLOOR 은 옥상을 추가적으로 생성하는 방식이라  층 생성을 제거하지 않는다.\n        # cluster.remove(top_brep)\n        roof_floor = RoofFloor(top_brep)\n        railings.append(roof_floor.railing)\n        top_cores.append(roof_floor.top_cores)\n\n    bldg_glasses = []\n    bldg_glass_frames = []\n    bldg_cores = []\n    bldg_slabs = []\n    bldg_floors = []\n    bldg_ceilings = []\n    bldg_ornaments = []\n    for brep in cluster:\n\n        try:\n            floor = Floor(brep)\n            floor.set_glass_frames(_glass_dist, _frame_dist)\n            floor.set_core(_core_dist, True)\n            floor.set_slab(_slab_thick)\n\n            # Add to common output\n            bldg_glasses.extend(floor.glass)\n            bldg_glass_frames.extend(floor.glass_frames)\n            bldg_cores.append(floor.core)\n            bldg_slabs.append(floor.slab)\n\n            bldg_floors.append(floor.floor)\n            bldg_ceilings.append(floor.ceiling)\n\n        except Exception as e:\n            print(f\"Error processing brep: {e}\")\n            continue\n\n    # 1 : No Ornament, 2 : Vertical Ornament, 3 : Horizontal Ornament, 4 : Both\n    random_value = random.choice([1, 2, 3, 4])\n    if random_value == 1:\n        pass\n    # Vertical Ornament : 창문 프레임으로 부터 생성\n    elif random_value == 2:\n        for brep in bldg_glass_frames:\n            ornament = ghcomp.OffsetSurface(brep, random.uniform(0.1, 0.3))\n            if ornament:\n                bldg_ornaments.append(ornament)\n    # Horizontal Ornament : slab옆면으로 부터 생성\n    elif random_value == 3:\n        for brep in bldg_slabs:\n            ornament = ghcomp.OffsetSurface(brep, random.uniform(0.1, 0.3))\n            if ornament:\n                bldg_ornaments.append(ornament)\n    elif random_value == 4:\n        for brep in bldg_glass_frames:\n            ornament = ghcomp.OffsetSurface(brep, random.uniform(0.1, 0.3))\n            if ornament:\n                bldg_ornaments.append(ornament)\n        for brep in bldg_slabs:\n            ornament = ghcomp.OffsetSurface(brep, random.uniform(0.1, 0.3))\n            if ornament:\n                bldg_ornaments.append(ornament)\n\n    glasses.extend(bldg_glasses)\n    glass_frames.extend(bldg_glass_frames)\n    cores.extend(bldg_cores)\n    slabs.extend(bldg_slabs)\n    floors.extend(bldg_floors)\n    ceilings.extend(bldg_ceilings)\n    ornaments.extend(bldg_ornaments)\n\n\n### TEST CODE ###\n# sc.sticky[\"floors\"] = floors\n# sc.sticky[\"ceilings\"] = ceilings\n\n# sc.sticky[\"glasses\"] = glasses\n# sc.sticky[\"glass_frames\"] = glass_frames\n# sc.sticky[\"cores\"] = cores\n# sc.sticky[\"slabs\"] = slabs\n# sc.sticky[\"railings\"] = railings\n# sc.sticky[\"top_cores\"] = top_cores\n# sc.sticky[\"bottom_walls\"] = bottom_walls\n# sc.sticky[\"bottoms\"] = bottoms\n\n#################\n\nif bake:\n    # Bake to Rhino\n    # Common output\n    bake_to_layer(glasses, \"bake::glasses\")\n    bake_to_layer(glass_frames, \"bake::glass_frames\")\n    bake_to_layer(cores, \"bake::cores\")\n    bake_to_layer(slabs, \"bake::slabs\")\n    # Top floor output\n    bake_to_layer(railings, \"bake::railings\")\n    bake_to_layer(top_cores, \"bake::top_cores\")\n    # Bottom floor output\n    bake_to_layer(bottom_walls, \"bake::bottom_walls\")\n    # ornaments output\n    bake_to_layer(ornaments, \"bake::ornaments\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}