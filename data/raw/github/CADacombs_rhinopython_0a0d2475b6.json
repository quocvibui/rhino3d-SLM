{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_contiguousTangentFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_contiguousTangentFaces.py",
  "instruction": "170704-05: Created, starting with extractContiguousFacesOfDraftAngle.\r\n171016: For faster extraction of faces, addBrepWithSubsetOfFaces was split into\r\n        addBrepOfSubsetOfFaces_JoinBreps and...",
  "code": "\"\"\"\r\n170704-05: Created, starting with extractContiguousFacesOfDraftAngle.\r\n171016: For faster extraction of faces, addBrepWithSubsetOfFaces was split into\r\n        addBrepOfSubsetOfFaces_JoinBreps and addBrepOfSubsetOfFaces_RemoveAt.\r\n...\r\n180608: Now when all faces of brep are contiguous tangent, the brep is post-selected and layer and color are set to their relevant options.\r\n180716: Now monoface breps are allowed as input.  This makes it easier when the brep's attributes are changed to current settings.\r\n...\r\n190808: Added bOnlyFirstAdj.\r\n191010: Replaced an option with bRetainLayer and bRetainColor.\r\n191101, 200701: Import-related update.\r\n210429: Updated fAngleTol_Deg key for sc.sticky so the value will remain the same during this Rhino session.\r\n\r\nWIP: bCopy option.\r\n\r\nTODO: indicesOfContiguousTangentFaces: Check all edges of each face passing tangency so that no faces are marked as failing.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nimport xBrepObject\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\nfrom System.Diagnostics import Stopwatch\r\n\r\n\r\nsOpts = (\r\n        'fAngleTol_Deg',\r\n        'bOnlyFirstAdj',\r\n        'bRetainLayer',\r\n        'bRetainColor',\r\n        'bCopy',\r\n        'bEcho',\r\n        'bDebug',\r\n)\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    stickyKeys = {}\r\n    \r\n    for key in sOpts:\r\n        keys.append(key)\r\n        names[key] = key[1:] # Overwrite as wanted in the following.\r\n    \r\n    key = 'fAngleTol_Deg'\r\n    values[key] = 50.0 * sc.doc.ModelAngleToleranceDegrees\r\n    names[key] = 'AngleTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bOnlyFirstAdj'\r\n    values[key] = False\r\n    names[key] = 'ContiguousDepth'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Unlimited', 'One')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bRetainLayer'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bRetainColor'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bCopy'\r\n    values[key] = False\r\n    names[key] = 'Copy'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'\r\n    values[key] = True\r\n    names[key] = 'Echo'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'\r\n    values[key] = False\r\n    names[key] = 'Debug'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n    \r\n    \r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                pass\r\n    \r\n    \r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get face with optional input.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select starting face\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.EnableHighlight(False)\r\n    \r\n    \r\n    idxsOpts_Main = {}\r\n\r\n    while True:\r\n        go.AddOptionDouble(Opts.names['fAngleTol_Deg'], Opts.riOpts['fAngleTol_Deg'])\r\n        go.AddOptionToggle(Opts.names['bOnlyFirstAdj'], Opts.riOpts['bOnlyFirstAdj'])\r\n        go.AddOptionToggle(Opts.names['bRetainLayer'], Opts.riOpts['bRetainLayer'])\r\n        go.AddOptionToggle(Opts.names['bRetainColor'], Opts.riOpts['bRetainColor'])\r\n        go.AddOptionToggle(Opts.names['bCopy'], Opts.riOpts['bCopy'])\r\n        go.AddOptionToggle(Opts.names['bEcho'], Opts.riOpts['bEcho'])\r\n        go.AddOptionToggle(Opts.names['bDebug'], Opts.riOpts['bDebug'])\r\n        \r\n        res = go.Get()\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            return tuple([objref] + [Opts.values[key] for key in Opts.keys])\r\n            #rgFace = getBrepFaceFromGetObject(objref)\r\n            #if rgFace is not None:\r\n            #    go.Dispose()\r\n            #    return tuple([objref, rgFace] + [Opts.values[key] for key in sOpts])\r\n            #sc.doc.Objects.UnselectAll() # Prepare for repeat of go.Get().\r\n            #sc.doc.Views.Redraw()\r\n        elif res == ri.GetResult.Cancel:\r\n            return # Esc key was pressed.\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        res = go.Result()\r\n        \r\n        key = 'fAngleTol_Deg'\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n        if Opts.riOpts[key].CurrentValue < 0.0:\r\n            Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef indicesOfContiguousTangentFaces(rgBrep, idxFace0, fAngleTol_Deg, bOnlyFirstAdj=False):\r\n    \r\n    idxFaces_Pass = [idxFace0]\r\n    idxFace_LastAdded = [idxFace0]\r\n    idxEdges_Pass = []\r\n    idxEdges_Fail = []\r\n    idxEdges_ToCheck = list(rgBrep.Faces[idxFace0].AdjacentEdges())\r\n    \r\n    for iE in idxEdges_ToCheck:\r\n        if sc.escape_test(False):\r\n            print \"Script stopped in main edges to check loop.\"\r\n            return\r\n        \r\n        if iE in idxEdges_Pass or iE in idxEdges_Fail:\r\n            continue\r\n        \r\n        if rgBrep.Edges[iE].Valence != rg.EdgeAdjacency.Interior:\r\n            idxEdges_Fail.append(iE)\r\n            continue\r\n        \r\n        if rgBrep.Edges[iE].IsSmoothManifoldEdge(\r\n                Rhino.RhinoMath.ToRadians(fAngleTol_Deg)):\r\n            idxEdges_Pass.append(iE)\r\n            for iF in rgBrep.Edges[iE].AdjacentFaces():\r\n                if sc.escape_test(False):\r\n                    print \"Script stopped in adjacent face loop.\"\r\n                    return\r\n                \r\n                if iF not in idxFaces_Pass:\r\n                    idxFaces_Pass.append(iF)\r\n                    if not bOnlyFirstAdj:\r\n                        for iEPF in rgBrep.Faces[iF].AdjacentEdges():\r\n                            if sc.escape_test(False):\r\n                                print \"Script stopped in adjacent edge loop.\"\r\n                                return\r\n                        \r\n                            if iEPF not in (idxEdges_Pass + idxEdges_Fail):\r\n                                idxEdges_ToCheck.append(iEPF)\r\n        else:\r\n            idxEdges_Fail.append(iE)\r\n    \r\n    return idxFaces_Pass\r\n\r\n\r\ndef main(bDebug=False):\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n            objref,\r\n            fAngleTol_Deg,\r\n            bOnlyFirstAdj,\r\n            bRetainLayer,\r\n            bRetainColor,\r\n            bCopy,\r\n            bEcho,\r\n            bDebug,\r\n    ) = rc\r\n    \r\n    rdBrep0 = objref.Object()\r\n    rgFace = objref.Face()\r\n    \r\n    stopwatch = Stopwatch()\r\n    \r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Working ...\")\r\n    \r\n    rgBrep0 = rdBrep0.BrepGeometry\r\n    \r\n    idxFaces_Pass = indicesOfContiguousTangentFaces(\r\n            rgBrep0,\r\n            rgFace.FaceIndex,\r\n            fAngleTol_Deg,\r\n            bOnlyFirstAdj=bOnlyFirstAdj)\r\n    if idxFaces_Pass is None: return\r\n    \r\n    if len(idxFaces_Pass) == 0:\r\n        print \"No faces found.\"\r\n        return\r\n    \r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n    \r\n    if len(idxFaces_Pass) == rgBrep0.Faces.Count:\r\n        print \"All faces of brep are contiguous tangent.\"\r\n    \r\n    rgBrep0.Dispose()\r\n    \r\n    rc = xBrepObject.extractFaces(\r\n            rdBrep0,\r\n            idxFaces_Pass,\r\n            bAddOnlyMonofaces=False,\r\n            bRetainLayer=bRetainLayer,\r\n            bRetainColor=bRetainColor,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n    )\r\n    if rc is None:\r\n        print \"Faces could not be extracted.\"\r\n        return\r\n\r\n    gExtracted = rc[0]\r\n\r\n    nSel = rs.SelectObjects(gExtracted)\r\n    if nSel == 0:\r\n        print \"Error none of the breps are selected!\"\r\n    else:\r\n        print \"{} brep{} selected.\".format(\r\n                    nSel,\r\n                    (' is', 's are')[bool(nSel-1)])\r\n    \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main(bDebug=bool(0))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}