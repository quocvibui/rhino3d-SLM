{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/utility.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/utility.py",
  "instruction": "Utility",
  "code": "import os\n\nimport compas\nimport compas_bootstrapper\nimport compas_fab\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc  # type: ignore\n\nfrom integral_timber_joints.process import RobotClampAssemblyProcess\n\n\n# This is a duplicate from integral_timber_joints.rhino.load to avoid circular referencing\ndef get_process_artist():\n    if \"itj_process_artist\" in sc.sticky:\n        return sc.sticky[\"itj_process_artist\"]\n    else:\n        return None\n\n\ndef print_package_info():\n    compas_version = compas.__version__\n    compas_path = os.path.abspath(compas.__file__)\n\n    compas_fab_version = compas_fab.__version__\n    compas_fab_path = os.path.abspath(compas_fab.__file__)\n\n    conda_env_name = compas_bootstrapper.ENVIRONMENT_NAME\n    python_directory = compas_bootstrapper.PYTHON_DIRECTORY\n\n    print('compas_version = %s' % compas_version)\n    print('compas_path = %s' % compas_path)\n    print('compas_fab_version = %s' % compas_fab_version)\n    print('compas_fab_path = %s' % compas_fab_path)\n    print('conda_env_name = %s' % conda_env_name)\n    print('python_directory = %s' % python_directory)\n    return (\n        compas_version, compas_path,\n        compas_fab_version, compas_fab_path,\n        conda_env_name, python_directory,\n    )\n\n\ndef recompute_dependent_solutions(process, beam_id):\n    # type: (RobotClampAssemblyProcess, str) -> bool\n    \"\"\" Recompute the downstrem computation of a beam after chaning something upstream.\n    \"\"\"\n    assembly = process.assembly\n    if assembly.get_beam_attribute(beam_id, 'assembly_wcf_final') is None:\n        assembly.compute_beam_assembly_direction_from_joints_and_sequence(beam_id)\n    if assembly.get_beam_attribute(beam_id, 'assembly_wcf_inclamp') is None:\n        assembly.compute_beam_assembly_direction_from_joints_and_sequence(beam_id)\n\n\ndef get_existing_beams_filter(process, exclude_beam_ids=[]):\n    # type: (RobotClampAssemblyProcess, list[str]) -> None\n    # Create beam guids for filtering\n    artist = get_process_artist()\n    beam_guids = []\n    for beam_id in process.assembly.beam_ids():\n        if beam_id not in exclude_beam_ids:\n            beam_guids.extend(artist.interactive_beam_guid(beam_id))\n    # print('guids of beams: %s (%i)' % (beam_guids, len(beam_guids)))\n\n    def existing_beams_filter(rhino_object, geometry, component_index):\n        if rhino_object.Attributes.ObjectId in beam_guids:\n            return True\n        return False\n\n    return existing_beams_filter\n\n\n# Importing sc functions for purge_objects\ntry:\n    purge_object = sc.doc.Objects.Purge\nexcept AttributeError:\n    purge_object = None\n\nfind_object = sc.doc.Objects.Find\n\n\ndef purge_objects(guids, redraw=True):\n    \"\"\"Purge objects from memory.\n    Adapted from compas_rhino.utilities\n\n    Parameters\n    ----------\n    guids : list of GUID\n    \"\"\"\n    if not purge_object:\n        raise RuntimeError('Cannot purge outside Rhino script context')\n    rs.EnableRedraw(False)\n    for guid in guids:\n        if rs.IsObject(guid):\n            if rs.IsObjectHidden(guid):\n                rs.ShowObject(guid)\n            o = find_object(guid)\n            purge_object(o.RuntimeSerialNumber)\n    if redraw:\n        rs.EnableRedraw(True)\n        sc.doc.Views.Redraw()\n\n\nif __name__ == \"__main__\":\n    print_package_info()\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}