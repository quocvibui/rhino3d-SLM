{
  "source_url": "https://github.com/maxcollombin/rhino3dm-gltf/blob/99c024d44323eaede67c6c09845ac8ddb9318981/scripts/exportRhinoLocalRef2CityJSON.py",
  "repo": "maxcollombin/rhino3dm-gltf",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "scripts/exportRhinoLocalRef2CityJSON.py",
  "instruction": "Export rhino local ref2city json",
  "code": "import os\nimport json\nimport uuid\nimport rhino3dm\nimport numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.cluster import DBSCAN\n\ninput_file = \"./R21_3d.3dm\"\noutput_cityjson = \"./output/NouveauxBatiments.city.json\"\n\nmodel = rhino3dm.File3dm.Read(input_file)\nif not model:\n    raise ValueError(f\"Erreur : Impossible de charger {input_file}\")\nprint(f\" Modèle chargé : {input_file}\")\n\n# ------------------------------\n# Fonctions utilitaires\n# ------------------------------\ndef remove_consecutive_duplicates(ring):\n    if len(ring) < 3:\n        return []\n    cleaned = []\n    for i, vertex in enumerate(ring):\n        next_vertex = ring[(i + 1) % len(ring)]\n        if vertex != next_vertex:\n            cleaned.append(vertex)\n    if len(cleaned) >= 3 and cleaned[0] == cleaned[-1]:\n        cleaned = cleaned[:-1]\n    return cleaned if len(cleaned) >= 3 else []\n\ndef validate_face(ring):\n    if len(ring) < 3:\n        return False\n    for i in range(len(ring)):\n        if ring[i] == ring[(i + 1) % len(ring)]:\n            return False\n    return True\n\ndef project_to_plane(vertices_coords):\n    if len(vertices_coords) < 4:\n        return vertices_coords\n    points = np.array(vertices_coords)\n    centroid = np.mean(points, axis=0)\n    centered_points = points - centroid\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    normal = pca.components_[2]\n    projected_centered = centered_points - np.outer(np.dot(centered_points, normal), normal)\n    return (projected_centered + centroid).tolist()\n\ndef convert_to_mesh(geometry):\n    if isinstance(geometry, rhino3dm.Mesh):\n        return geometry\n    if isinstance(geometry, rhino3dm.Extrusion):\n        for mesh_type in (rhino3dm.MeshType.Render, rhino3dm.MeshType.Default):\n            mesh = geometry.GetMesh(mesh_type)\n            if mesh and len(mesh.Vertices) and len(mesh.Faces):\n                mesh.Normals.ComputeNormals()\n                mesh.Compact()\n                return mesh\n        brep = geometry.ToBrep(True) or geometry.ToBrep(False)\n        if brep:\n            return convert_to_mesh(brep)\n        return None\n    if isinstance(geometry, rhino3dm.Brep):\n        meshes = []\n        for face in geometry.Faces:\n            mesh = face.GetMesh(rhino3dm.MeshType.Default)\n            if mesh and len(mesh.Vertices) and len(mesh.Faces):\n                meshes.append(mesh)\n        if meshes:\n            combined = rhino3dm.Mesh()\n            for m in meshes:\n                combined.Append(m)\n            combined.Normals.ComputeNormals()\n            combined.Compact()\n            return combined\n    return None\n\ndef classify_surface(vertices_coords):\n    points = np.array(vertices_coords)\n    if len(points) < 3:\n        return \"WallSurface\"  # Fallback conforme à CityJSON 2.0\n    centroid = np.mean(points, axis=0)\n    centered_points = points - centroid\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    normal = pca.components_[2]\n    z_axis = np.array([0,0,1])\n    vertical = np.abs(np.dot(normal, z_axis)) < 0.5\n    horizontal = np.abs(np.dot(normal, z_axis)) > 0.9\n    if horizontal:\n        z_mean = np.mean(points[:,2])\n        if z_mean < centroid[2]:\n            return \"GroundSurface\"\n        else:\n            return \"RoofSurface\"\n    elif vertical:\n        return \"WallSurface\"\n    else:\n        return \"ClosureSurface\"  # Conforme à CityJSON 2.0\n\n# ------------------------------\n# Gestion des sommets et bâtiments\n# ------------------------------\nvertices_global = []\nvertex_index_map = {}\n\ndef add_vertex(v):\n    key = (round(v.X,6), round(v.Y,6), round(v.Z,6))\n    if key in vertex_index_map:\n        return vertex_index_map[key]\n    idx = len(vertices_global)\n    vertices_global.append([v.X, v.Y, v.Z])\n    vertex_index_map[key] = idx\n    return idx\n\n# Collecte des meshes et calcul des barycentres\nmeshes_all = []\nbarycentres = []\nfor obj in model.Objects:\n    layer = model.Layers[obj.Attributes.LayerIndex]\n    full_path = layer.FullPath\n    if not full_path.startswith(\"Bâtiments Nouveaux\"):\n        continue\n    if \"EXISTANT\" in full_path or \"DEMOLITION\" in full_path:\n        continue\n    mesh = convert_to_mesh(obj.Geometry)\n    if mesh:\n        meshes_all.append(mesh)\n        # Calcul barycentre\n        verts = np.array([[v.X, v.Y, v.Z] for v in mesh.Vertices])\n        bary = np.mean(verts, axis=0)\n        barycentres.append(bary)\n\nprint(f\"{len(meshes_all)} meshes collectés.\")\n\n# Clustering spatial des barycentres\nif len(barycentres) == 0:\n    raise ValueError(\"Aucun mesh détecté.\")\n\nbarycentres_np = np.array(barycentres)\nclustering = DBSCAN(eps=10.0, min_samples=1).fit(barycentres_np)  # eps=10m, à ajuster selon la densité\nlabels = clustering.labels_\nprint(f\"{len(set(labels))} bâtiments détectés par clustering spatial.\")\n\n# Regroupement des meshes par cluster\nbuildings = {}\nfor mesh, label in zip(meshes_all, labels):\n    buildings.setdefault(label, []).append(mesh)\n\nprint(f\" {len(buildings)} bâtiments détectés.\")\n\n# ------------------------------\n# Fonction de traitement des faces\n# ------------------------------\ndef process_mesh_faces(mesh):\n    shells = []\n    semantics_values = []\n    semantics_faces = []\n    mesh.Normals.ComputeNormals()\n    for face in mesh.Faces:\n        face_vertices = list(face) if len(face)==4 else list(face[:3])\n        ring = [add_vertex(mesh.Vertices[j]) for j in face_vertices]\n        cleaned_ring = remove_consecutive_duplicates(ring)\n        if not validate_face(cleaned_ring):\n            continue\n        vertices_coords = [vertices_global[idx] for idx in cleaned_ring]\n        projected_coords = project_to_plane(vertices_coords)\n        # classification\n        v1, v2, v3 = np.array(projected_coords[:3])\n        normal = np.cross(v2 - v1, v3 - v1)\n        normal = normal / (np.linalg.norm(normal)+1e-9)\n        nz = normal[2]\n        if abs(nz) > 0.9:\n            face_type = \"RoofSurface\" if nz>0 else \"GroundSurface\"\n        else:\n            face_type = \"WallSurface\"\n        semantics_values.append(face_type)\n        semantics_faces.append(len(shells))\n        shells.append([[add_vertex(rhino3dm.Point3d(*c)) for c in projected_coords]])\n    return shells, semantics_values, semantics_faces\n\n# ------------------------------\n# Construction du CityJSON\n# ------------------------------\ncityobjects = {}\nfor building_label, meshes in buildings.items():\n    building_id = str(uuid.uuid4())\n    print(f\"Création du bâtiment cluster {building_label} avec UUID {building_id}\")\n    child_ids = []\n    # --- Building ---\n    all_shells = []\n    all_semantics_values = []\n    all_semantics_faces = []\n    for mesh in meshes:\n        shells, s_values, s_faces = process_mesh_faces(mesh)\n        all_shells.extend(shells)\n        all_semantics_values.extend(s_values)\n        all_semantics_faces.extend(s_faces)\n    # --- BuildingParts ---\n    mesh_data = []\n    for i, mesh in enumerate(meshes):\n        z_coords = [vertex.Z for vertex in mesh.Vertices]\n        avg_z = sum(z_coords) / len(z_coords) if z_coords else 0\n        mesh_data.append((mesh, avg_z, i))\n    mesh_data.sort(key=lambda x: x[1])\n    total_floors = len(mesh_data)\n    all_z_coords = []\n    for mesh, _, _ in mesh_data:\n        all_z_coords.extend([vertex.Z for vertex in mesh.Vertices])\n    min_z = min(all_z_coords) if all_z_coords else 0\n    max_z = max(all_z_coords) if all_z_coords else 0\n    building_height = max_z - min_z\n    cityobjects[building_id] = {\n        \"type\": \"Building\",\n        \"attributes\": {\n            \"buildingStatus\": \"planned\",\n            \"developmentPhase\": 0,\n            \"storeysAboveGround\": total_floors,\n            \"computedHeight\": int(round(building_height))\n        },\n        \"geometry\": [{\n            \"type\": \"MultiSurface\",\n            \"lod\": \"2.0\",\n            \"boundaries\": all_shells,\n            \"semantics\": {\n                \"surfaces\": [{\"type\": s} for s in all_semantics_values],\n                \"values\": all_semantics_faces\n            }\n        }],\n        \"children\": []\n    }\n    for order_index, (mesh, avg_z, original_index) in enumerate(mesh_data):\n        part_id = str(uuid.uuid4())\n        print(f\"  Création étage {order_index+1} pour bâtiment cluster {building_label} (parent: {building_id})\")\n        child_ids.append(part_id)\n        shells, s_values, s_faces = process_mesh_faces(mesh)\n        cityobjects[part_id] = {\n            \"type\": \"BuildingPart\",\n            \"attributes\": {\n                \"floorOrder\": order_index + 1\n            },\n            \"geometry\": [{\n                \"type\": \"MultiSurface\",\n                \"lod\": \"2.0\",\n                \"boundaries\": shells,\n                \"semantics\": {\n                    \"surfaces\": [{\"type\": s} for s in s_values],\n                    \"values\": s_faces\n                }\n            }],\n            \"parents\": [building_id]\n        }\n    cityobjects[building_id][\"children\"] = child_ids\n\n# ------------------------------\n# Nettoyage des vertices non utilisés\n# ------------------------------\ndef clean_unused_vertices(cityobjects, vertices_global):\n    \"\"\"Supprime les vertices non utilisés et réindexe les géométries\"\"\"\n    used_vertices = set()\n    \n    # Collecter tous les indices de vertices utilisés\n    for city_obj in cityobjects.values():\n        if \"geometry\" in city_obj:\n            for geom in city_obj[\"geometry\"]:\n                if \"boundaries\" in geom:\n                    for shell in geom[\"boundaries\"]:\n                        for ring in shell:\n                            for vertex_idx in ring:\n                                used_vertices.add(vertex_idx)\n    \n    # Créer la nouvelle liste de vertices et le mapping\n    old_to_new = {}\n    new_vertices = []\n    new_idx = 0\n    \n    for old_idx in range(len(vertices_global)):\n        if old_idx in used_vertices:\n            old_to_new[old_idx] = new_idx\n            new_vertices.append(vertices_global[old_idx])\n            new_idx += 1\n    \n    # Réindexer toutes les géométries\n    for city_obj in cityobjects.values():\n        if \"geometry\" in city_obj:\n            for geom in city_obj[\"geometry\"]:\n                if \"boundaries\" in geom:\n                    for shell in geom[\"boundaries\"]:\n                        for ring in shell:\n                            for i in range(len(ring)):\n                                ring[i] = old_to_new[ring[i]]\n    \n    return new_vertices\n\n# Nettoyer les vertices non utilisés\nvertices_cleaned = clean_unused_vertices(cityobjects, vertices_global)\n\n# Appliquer la transformation locale aux vertices nettoyés\ntranslate_x = 2592980.685\ntranslate_y = 1119281.703\ntranslate_z = 483.8\n\nvertices_local = []\nfor vertex in vertices_cleaned:\n    # Les coordonnées Rhino sont déjà locales, nous les gardons telles quelles\n    # et ajustons seulement l'altitude par rapport à la référence\n    x_local = vertex[0]  # Garder tel quel\n    y_local = vertex[1]  # Garder tel quel  \n    z_local = vertex[2] - translate_z  # Soustraire la référence d'altitude\n    vertices_local.append([x_local, y_local, z_local])\n\n# ------------------------------\n# Écriture CityJSON\n# ------------------------------\nxs, ys, zs = zip(*vertices_local)\ngeographical_extent = [min(xs), min(ys), min(zs), max(xs), max(ys), max(zs)]\n\ncityjson = {\n    \"type\": \"CityJSON\",\n    \"version\": \"2.0\",\n    \"CityObjects\": cityobjects,\n    \"vertices\": vertices_local,\n    \"metadata\": {\n        \"referenceSystem\": \"https://www.opengis.net/def/crs/EPSG/0/2056\",\n        \"geographicalExtent\": geographical_extent,\n        \"presentLoDs\": [\"2.0\"],\n        \"datasetTitle\": \"Planned buildings\"\n    },\n    \"transform\": {\n        \"scale\":[1.0,1.0,1.0],\n        \"translate\":[2592980.685,1119281.703,483.8]\n    }\n}\n\nos.makedirs(os.path.dirname(output_cityjson), exist_ok=True)\nwith open(output_cityjson, \"w\", encoding=\"utf-8\") as f:\n    json.dump(cityjson, f, indent=2)\n\nprint(f\"CityJSON exporté avec {len(cityobjects)} objets et {len(vertices_local)} sommets (nettoyés et transformés localement).\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}