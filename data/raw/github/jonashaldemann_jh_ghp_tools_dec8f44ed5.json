{
  "source_url": "https://github.com/jonashaldemann/jh_ghp_tools/blob/3f6fad9b1d6b94b1382000d2d9bd27952269a19d/src/jh_ghp_tools/apply_box_mapping.py",
  "repo": "jonashaldemann/jh_ghp_tools",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/jh_ghp_tools/apply_box_mapping.py",
  "instruction": "Apply box mapping",
  "code": "import Rhino\nimport Rhino.Geometry as rg\nimport System\nfrom Rhino.Render import TextureMapping\nfrom typing import List, Any\n\n\ndef _extract_guid(guid: Any) -> System.Guid:\n    if isinstance(guid, System.Guid):\n        return guid\n    if hasattr(guid, \"Id\") and isinstance(guid.Id, System.Guid):\n        return guid.Id\n    if hasattr(guid, \"Value\") and isinstance(guid.Value, System.Guid):\n        return guid.Value\n    return None\n\n\ndef apply_box_mapping(\n    geometries: List[Any],\n    guids: List[Any],\n    x_dim: float,\n    y_dim: float,\n    z_dim: float,\n    update: bool = False,\n) -> List[rg.Box]:\n    x_interval = rg.Interval(-x_dim / 2, x_dim / 2)\n    y_interval = rg.Interval(-y_dim / 2, y_dim / 2)\n    z_interval = rg.Interval(-z_dim / 2, z_dim / 2)\n\n    boxes = []\n\n    for geom, guid in zip(geometries, guids):\n        rhino_guid = _extract_guid(guid)\n        if not rhino_guid:\n            continue\n\n        plane = None\n\n        # Für Breps\n        print(geom)\n        if isinstance(geom, rg.Brep) or isinstance(geom, rg.Extrusion):\n            # Falls es eine Extrusion ist, in Brep umwandeln\n            if isinstance(geom, rg.Extrusion):\n                geom = geom.ToBrep()\n                if geom is None:\n                    continue\n            print(\"is brep\")\n            face_areas = [\n                rg.AreaMassProperties.Compute(face).Area for face in geom.Faces\n            ]\n            max_area_index, _ = max(enumerate(face_areas), key=lambda x: x[1])\n            face = geom.Faces[max_area_index]\n            face_brep = face.DuplicateFace(False)\n            edge_curves = [edge.EdgeCurve for edge in face_brep.Edges]\n            if not edge_curves:\n                continue\n            longest = max(edge_curves, key=lambda crv: crv.GetLength())\n            start, end = longest.PointAtStart, longest.PointAtEnd\n            y_vector = end - start\n            face_normal = face_brep.Faces[0].NormalAt(0.5, 0.5)\n            x_vector = rg.Vector3d.CrossProduct(y_vector, face_normal)\n            plane = rg.Plane(start, x_vector, y_vector)\n\n        # Für Meshes\n        elif isinstance(geom, rg.Mesh):\n            max_area = 0\n            max_face_index = -1\n\n            for i in range(geom.Faces.Count):\n                face = geom.Faces[i]\n                pts = []\n                for idx in (face.A, face.B, face.C):\n                    v = geom.Vertices[idx]\n                    # Falls v kein Point3d ist, explizit erzeugen\n                    pt = rg.Point3d(v.X, v.Y, v.Z)\n                    pts.append(pt)\n\n                polyline = rg.Polyline()\n                for pt in pts:\n                    polyline.Add(pt)\n                polyline.Add(pts[0])\n                area_props = rg.AreaMassProperties.Compute(polyline.ToNurbsCurve())\n                area = area_props.Area if area_props else 0\n\n                if area > max_area:\n                    max_area = area\n                    max_face_index = i\n\n            if max_face_index < 0:\n                continue\n\n            face = geom.Faces[max_face_index]\n\n            pts = [\n                rg.Point3d(\n                    geom.Vertices[face.A].X,\n                    geom.Vertices[face.A].Y,\n                    geom.Vertices[face.A].Z,\n                ),\n                rg.Point3d(\n                    geom.Vertices[face.B].X,\n                    geom.Vertices[face.B].Y,\n                    geom.Vertices[face.B].Z,\n                ),\n                rg.Point3d(\n                    geom.Vertices[face.C].X,\n                    geom.Vertices[face.C].Y,\n                    geom.Vertices[face.C].Z,\n                ),\n            ]\n\n            edges = [\n                (pts[0], pts[1]),\n                (pts[1], pts[2]),\n                (pts[2], pts[0]),\n            ]\n\n            longest_edge = max(edges, key=lambda e: e[0].DistanceTo(e[1]))\n            start, end = longest_edge\n            y_vector = end - start\n\n            v1 = pts[1] - pts[0]\n            v2 = pts[2] - pts[0]\n            face_normal = rg.Vector3d.CrossProduct(v1, v2)\n            face_normal.Unitize()\n\n            x_vector = rg.Vector3d.CrossProduct(y_vector, face_normal)\n            x_vector.Unitize()\n            y_vector.Unitize()\n\n            plane = rg.Plane(start, x_vector, y_vector)\n\n        else:\n            print(\"is none\")\n            continue\n\n        box = rg.Box(plane, x_interval, y_interval, z_interval)\n        boxes.append(box)\n\n        if update:\n            obj_ref = Rhino.RhinoDoc.ActiveDoc.Objects.Find(rhino_guid)\n            print(obj_ref)\n            if obj_ref:\n                mapping = TextureMapping.CreateBoxMapping(\n                    plane, x_interval, y_interval, z_interval, True\n                )\n                mapping_channel = 1\n                Rhino.RhinoDoc.ActiveDoc.Objects.ModifyTextureMapping(\n                    obj_ref.Id, mapping_channel, mapping\n                )\n                attr = obj_ref.Attributes\n                attr.MaterialSource = (\n                    Rhino.DocObjects.ObjectMaterialSource.MaterialFromObject\n                )\n                attr.MappingChannel = mapping_channel\n                Rhino.RhinoDoc.ActiveDoc.Objects.ModifyAttributes(obj_ref, attr, True)\n\n    return boxes\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}