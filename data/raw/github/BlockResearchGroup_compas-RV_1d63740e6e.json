{
  "source_url": "https://github.com/BlockResearchGroup/compas-RV/blob/6764c66911729f5ca48f1ea8a714e297980622c5/gitbook/.gitbook/assets/workshop_calgary2025_scaffolding.py",
  "repo": "BlockResearchGroup/compas-RV",
  "repo_stars": 14,
  "repo_description": "Rhino plugin for form finding of spatial networks of compression forces in equilibrium with vertical loads using two-dimensional, reciprocal form and force diagrams.",
  "license": "NOASSERTION",
  "filepath": "gitbook/.gitbook/assets/workshop_calgary2025_scaffolding.py",
  "instruction": "venv: brg-csd",
  "code": "#! python3\n# venv: brg-csd\n\nfrom math import ceil\n\nimport rhinoscriptsyntax as rs\n\nimport compas_rhino.conversions\nimport compas_rhino.objects\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Box\nfrom compas.geometry import Frame\nfrom compas.geometry import Line\nfrom compas.geometry import Plane\nfrom compas.geometry import Point\nfrom compas.geometry import Polygon\nfrom compas.geometry import Polyline\nfrom compas.geometry import Transformation\nfrom compas.geometry import Translation\nfrom compas.geometry import Vector\nfrom compas.geometry import bounding_box\nfrom compas.geometry import intersection_polyline_plane\nfrom compas.geometry import midpoint_point_point\nfrom compas.geometry import trimesh_slice\nfrom compas.scene import Scene\n\nDIVISION_DISTANCE_U = 50\nDIVISION_DISTANCE_V = 50\nTHICKNESS = 2\nGAP_JOINT = 1\nZ_OFFSET = -40\n\n\n# Select Mesh\nguids = compas_rhino.objects.select_meshes()\npolygons = []\nfor guid in guids:\n    mesh = compas_rhino.conversions.meshobject_to_compas(guid)\n    polygons.extend(mesh.to_polygons())\n\nmesh = Mesh.from_polygons(polygons)\n\n# Select Boundary Polygon\nguid = rs.GetObject(\"Select a polyline as a region.\", rs.filter.curve)\nrh_pline = obj = compas_rhino.objects.find_object(guid).Geometry.ToPolyline()\npolyline = compas_rhino.conversions.polyline_to_compas(rh_pline)\n\n# Select Primary Direction\nguid = rs.GetObject(\"Select a line as a direction.\", rs.filter.curve)\nrh_line = compas_rhino.objects.find_object(guid).Geometry\nline = Line([rh_line.PointAtStart.X, rh_line.PointAtStart.Y, rh_line.PointAtStart.Z], [rh_line.PointAtEnd.X, rh_line.PointAtEnd.Y, rh_line.PointAtEnd.Z])\n\n\nclass Waffle:\n    def __init__(self, mesh: Mesh, region: Polyline, direction: line, zoffset: float = 40):\n        self.mesh = mesh\n        self.region = region\n        self.direction = line\n        self.proces_region()\n\n        aabb_mesh = self.mesh.aabb()\n        aabb_region = Box.from_points(bounding_box(self.region.points))\n        aabb_direction = Box.from_points(bounding_box([self.direction.start, self.direction.end]))\n        self.region.transform(Translation.from_vector([0, 0, aabb_mesh.zmin - aabb_region.zmin + zoffset]))\n        self.direction.transform(Translation.from_vector([0, 0, aabb_mesh.zmin - aabb_direction.zmin + zoffset]))\n\n        self.planes_u = []\n        self.planes_v = []\n\n        self.bottom_lines_u: list[list[Line]] = []\n        self.bottom_lines_v: list[list[Line]] = []\n\n        self.top_polylines_u: list[list[Polyline]] = []\n        self.top_polylines_v: list[list[Polyline]] = []\n\n        self.polygons_u: list[Polygon] = []\n        self.polygons_v: list[Polygon] = []\n\n        self.polylines_u_with_cuts: list[Polyline] = []\n        self.polylines_v_with_cuts: list[Polyline] = []\n        self.frames_u_with_cuts: list[Frame] = []\n        self.frames_v_with_cuts: list[Frame] = []\n\n        self.oriented_polylines_u: list[Polyline] = []\n        self.oriented_polylines_v: list[Polyline] = []\n\n    @property\n    def transformation(self):\n        \"\"\"\n        Compute the transformation needed to align the cutting direction.\n        This transformation is required to adjust the mesh and region.\n        Cutting planes will be aligned to the x and y axes based on the region's AABB.\n        \"\"\"\n        mesh_aabb = self.mesh.aabb()\n        origin = self.direction.start\n        origin = Point(origin[0], origin[1], origin[2] + mesh_aabb.zmin)\n        x_axis = self.direction.direction\n        y_axis = x_axis.cross(Vector(0, 0, -1))  # Ensure perpendicular vector in the XY plane\n        frame = Frame(origin, x_axis, y_axis)\n\n        return Transformation.from_frame_to_frame(frame, Frame.worldXY())\n\n    def proces_region(self):\n        \n        points = []\n        for vertex in self.mesh.vertices_on_boundary():\n            p = self.mesh.vertex_point(vertex)\n            points.append(Point(p[0], p[1], 0))\n        polygon = Polygon(points)\n\n        result = Polygon(self.region.points[:-1]).boolean_intersection(polygon)\n        self.region = Polyline(result.points + [result[0]])     \n\n    def get_cut_planes(self, distance_u: float, distance_v: float):\n        \"\"\"\n        From the oriented region bounding-box and division distances construct the cutting frames.\n        \"\"\"\n        T = self.transformation\n        region_transformed = self.region.transformed(T)\n\n        aabb = Box.from_points(bounding_box(region_transformed))\n        origin = aabb.corner(0)\n\n        def generate_planes(distance, divisions, axis):\n            return [Plane(origin + axis * i * distance, axis) for i in range(divisions)]\n\n        self.planes_u = generate_planes(distance_u, ceil(aabb.xsize / distance_u), Vector.Xaxis())\n        self.planes_v = generate_planes(distance_v, ceil(aabb.ysize / distance_v), Vector.Yaxis())\n\n    def section_region(self, tolerance=0.01):\n        \"\"\"\n        Intersections of region and cut planes with the transformed region.\n        \"\"\"\n\n\n\n        T = self.transformation\n\n        region_transformed = self.region.transformed(T)\n\n        polygon = Polygon(region_transformed.points[:-1])\n\n        def process_cut_planes(cut_planes, bottom_lines, sort_coordinate):\n            for plane in cut_planes:\n                points = intersection_polyline_plane(region_transformed, plane)\n                points = sorted(points, key=lambda p: p[sort_coordinate])\n                lines = []\n                for i in range(len(points) - 1):\n                    p0 = Point(*points[i])\n                    p1 = Point(*points[i + 1])\n                    pmid = Point(*midpoint_point_point(p0, p1))\n                    if pmid.in_polygon(polygon):\n                        # if p0.distance_to_point(p1) > tolerance:\n                        lines.append(Line(p0, p1))\n                bottom_lines.append(lines)\n\n        process_cut_planes(self.planes_u, self.bottom_lines_u, 1)\n        process_cut_planes(self.planes_v, self.bottom_lines_v, 0)\n\n    def section_mesh(self):\n        \"\"\"\n        Compute intersections of the mesh and cut planes with the transformed region.\n        \"\"\"\n        T = self.transformation\n        V, F = self.mesh.transformed(T).to_vertices_and_faces()\n\n        def extract_polylines(coordinates):\n            return [Polyline([Point(*point) for point in polyline]) for polyline in coordinates]\n\n        for plane in self.planes_u:\n            \n            try:\n                result = trimesh_slice((V, F), [plane])\n                if result:\n                    self.top_polylines_u.append(extract_polylines(result))\n            except:\n                self.top_polylines_u.append([])\n                \n                print(\"section_mesh error u-direction\")\n                pass\n\n        for plane in self.planes_v:\n           \n            try:\n                result = trimesh_slice((V, F), [plane])\n                if result:\n                    self.top_polylines_v.append(extract_polylines(result))\n            except:\n                self.top_polylines_v.append([])\n                \n                print(\"section_mesh error v-direction\")\n                pass\n\n    def clip_polyline(self):\n        \"\"\"\n        Cut the mesh polylines by the bottom lines' end points in both U and V directions.\n        \"\"\"\n\n        def process_direction(bottom_lines, top_polylines, closed_polylines, tol = 0.01):\n\n            \n\n         \n                \n            for i in range(len(bottom_lines)):\n\n                lines = bottom_lines[i]\n                polylines = top_polylines[i]\n\n                for line in lines:\n                    plane0 = Plane(line.start, -line.direction)\n                    plane1 = Plane(line.end, line.direction)\n\n\n                    points = []\n                    for polyline in polylines:\n\n                        points0 = []\n                        points1 = []\n\n                        # End points of lines as planes are intersected with polyline.\n                        # COMPAS bug: when end points of polyline and line have the same position, intersection is not found.\n                        # This border cases is handled in if and elif statements below.\n                        if(abs(polyline[0][0]-line.start[0]) < tol and abs(polyline[0][1]-line.start[1]) < tol):\n                            points0 = [polyline[0]]\n                        elif(abs(polyline[-1][0]-line.start[0]) < tol and abs(polyline[-1][1]-line.start[1]) < tol):\n                            points0 = [polyline[-1]]\n                        else:\n                            points0 = intersection_polyline_plane(polyline, plane0)\n\n                        if(abs(polyline[0][0]-line.end[0]) < tol and abs(polyline[0][1]-line.end[1]) < tol):\n                            points1 = [polyline[0]]\n                        elif(abs(polyline[-1][0]-line.end[0]) < tol and abs(polyline[-1][1]-line.end[1]) < tol):\n                            points1 = [polyline[-1]]\n                        else:\n                            points1 = intersection_polyline_plane(polyline, plane1)\n\n                    \n\n                        if len(points0) > 1 and len(points1) > 1:\n                            # print(\"Waffle.clip_polyline: more than one intersection point per line and polyline pair, skipping this case.\")\n                            continue\n                        elif len(points0) > 0 or len(points1) > 0:\n                            # print(\"Waffle.clip_polyline: two points\")\n\n                            p2, p3 = line.end, line.start\n\n                            distances_to_first_plane = []\n                            for p in polyline:\n                                distance0 = plane0.normal.dot(plane0.point - p)\n                                distance1 = plane1.normal.dot(plane1.point - p)\n                                if distance0 > 0 and distance1 > 0:\n                                    distances_to_first_plane.append(abs(distance0))\n                                    points.append(p)\n\n                            if distances_to_first_plane and distances_to_first_plane[0] > distances_to_first_plane[-1]:\n                                points.reverse()\n\n                            p0 = Point(*points0[0]) if points0 else points[0]\n                            p1 = Point(*points1[0]) if points1 else points[-1]\n                            p2, p3 = Point(p1[0], p1[1], p2[2]), Point(p0[0], p0[1], p3[2])\n\n                            if points0:\n                                points.insert(0, p0)\n                            if points1:\n                                points.append(p1)\n\n                            points.extend([p2, p3])\n                            closed_polylines.append(Polygon(points))\n                            # scene.add(closed_polylines[-1])\n                        else:\n                            print(points0, points1)\n                            scene.add(line)\n                            scene.add(polyline)\n                            scene.add(plane0)\n                            scene.add(plane1)\n                            \n\n\n        # Process both U and V directions using the helper function\n        process_direction(self.bottom_lines_u, self.top_polylines_u, self.polygons_u)\n        process_direction(self.bottom_lines_v, self.top_polylines_v, self.polygons_v)\n\n    def create_cross_joint(self, gap_joint: float, thickness: float):\n        # Process data\n        polylines_u_vertical = []\n        polylines_u_vertical_planes = []\n        polylines_u_vertical_cuts = {}\n\n        polylines_v_vertical = []\n        polylines_v_vertical_planes = []\n        polylines_v_vertical_cuts = {}\n\n        counter = 0\n        for idx, polygon in enumerate(self.polygons_u):\n            if len(polygon.points) > 2:\n                polylines_u_vertical.append(Polyline(polygon.points))\n                polylines_u_vertical_planes.append(polygon.plane)\n                polylines_u_vertical_cuts[counter] = []\n                counter = counter + 1\n\n        counter = 0\n        for idx, polygon in enumerate(self.polygons_v):\n            if len(polygon.points) > 2:\n                polylines_v_vertical.append(Polyline(polygon.points))\n                polylines_v_vertical_planes.append(polygon.plane)\n                polylines_v_vertical_cuts[counter] = []\n                counter = counter + 1\n\n        # Intersection Polygons\n        boolean_offset_vector = Vector(0, 0, max(self.mesh.transformed(self.transformation).aabb().zsize, 1))\n        gap_vector = Vector(0, 0, gap_joint * 0.5)\n\n        for i in range(len(polylines_u_vertical)):\n            for j in range(len(polylines_v_vertical)):\n                result = intersection_polyline_plane(polylines_u_vertical[i], polylines_v_vertical_planes[j])\n                if not result:\n                    continue\n                if len(result) != 2:\n                    continue\n\n                if result[0][2] > result[1][2]:\n                    result[0], result[1] = result[1], result[0]\n\n                p0 = Point(*result[0]) - boolean_offset_vector\n                p1 = Point(*result[1]) + boolean_offset_vector\n\n                pmid = Point((result[0][0] + result[1][0]) * 0.5, (result[0][1] + result[1][1]) * 0.5, (result[0][2] + result[1][2]) * 0.5)\n\n                offset_dir = (p0 - pmid).cross(polylines_u_vertical_planes[i].normal).unitized()\n\n                polyline_u = Polyline(\n                    [\n                        p0 + offset_dir * thickness * 0.5,\n                        pmid + offset_dir * thickness * 0.5 + gap_vector * 0.5,\n                        pmid - offset_dir * thickness * 0.5 + gap_vector * 0.5,\n                        p0 - offset_dir * thickness * 0.5,\n                    ]\n                )\n\n                offset_dir = (p1 - pmid).cross(polylines_v_vertical_planes[j].normal).unitized()\n                polyline_v = Polyline(\n                    [\n                        p1 + offset_dir * thickness * 0.5,\n                        pmid + offset_dir * thickness * 0.5 - gap_vector * 0.5,\n                        pmid - offset_dir * thickness * 0.5 - gap_vector * 0.5,\n                        p1 - offset_dir * thickness * 0.5,\n                    ]\n                )\n                polylines_u_vertical_cuts[i].append(polyline_u)\n                polylines_v_vertical_cuts[j].append(polyline_v)\n\n        # =============================================================================\n        # Boolean Difference the Cuts\n        # =============================================================================\n\n        X = self.transformation.inverse()\n\n        for key, value in polylines_u_vertical_cuts.items():\n            if len(value) == 0:\n                continue\n\n            a = Polygon(polylines_u_vertical[key])\n            frame = a.frame\n            T = Transformation.from_frame_to_frame(frame, Frame.worldXY())\n            T_I = Transformation.from_frame_to_frame(Frame.worldXY(), frame)\n            a.transform(T)\n\n            for o in value:\n                b = Polygon(o.points)\n                c = a.boolean_difference(b.transformed(T))\n                a = c\n\n            a.transform(T_I)\n            self.polylines_u_with_cuts.append(Polyline(a.points + [a.points[0]]))\n            self.polylines_u_with_cuts[-1].transform(X)\n            self.frames_u_with_cuts.append(frame.transformed(X))\n\n        for key, value in polylines_v_vertical_cuts.items():\n            if len(value) == 0:\n                continue\n\n            a = Polygon(polylines_v_vertical[key])\n            frame = a.frame\n\n            T = Transformation.from_frame_to_frame(frame, Frame.worldXY())\n            T_I = Transformation.from_frame_to_frame(Frame.worldXY(), frame)\n            a.transform(T)\n\n            for o in value:\n                b = Polygon(o.points)\n                a = a.boolean_difference(b.transformed(T))\n\n            a.transform(T_I)\n            self.polylines_v_with_cuts.append(Polyline(a.points + [a.points[0]]))\n            self.polylines_v_with_cuts[-1].transform(X)\n            self.frames_v_with_cuts.append(frame.transformed(X))\n\n        # for polyline in self.polygons_u:\n        #     scene.add(polyline)\n\n        # for polyline in self.polygons_v:\n        #     scene.add(polyline)\n\n    def low_res_font(self):\n        \"\"\"\n        Returns a dictionary of polylines representing low-resolution characters (A-Z, 0-9).\n        \"\"\"\n        font = {\n            \"A\": [Polyline([Point(0, 0, 0), Point(0.5, 2, 0), Point(1, 0, 0), Point(0.75, 1, 0), Point(0.25, 1, 0), Point(0, 0, 0)])],\n            \"B\": [Polyline([Point(0, 2, 0), Point(0.5, 2, 0), Point(1, 1.5, 0), Point(0.5, 1, 0), Point(1, 0.5, 0), Point(0.5, 0, 0), Point(0, 0, 0), Point(0, 2, 0)])],\n            \"0\": [Polyline([Point(0, 0, 0), Point(0, 2, 0), Point(1, 2, 0), Point(1, 0, 0), Point(0, 0, 0)])],\n            \"1\": [Polyline([Point(0.5, 0, 0), Point(0.5, 2, 0)])],\n            \"2\": [Polyline([Point(0, 2, 0), Point(1, 2, 0), Point(1, 1, 0), Point(0, 0, 0), Point(1, 0, 0)])],\n            \"3\": [Polyline([Point(0, 2, 0), Point(1, 2, 0), Point(1, 1, 0), Point(0.5, 1, 0), Point(1, 1, 0), Point(1, 0, 0), Point(0, 0, 0)])],\n            \"4\": [Polyline([Point(0, 2, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 2, 0), Point(1, 0, 0)])],\n            \"5\": [Polyline([Point(1, 2, 0), Point(0, 2, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 0, 0), Point(0, 0, 0)])],\n            \"6\": [Polyline([Point(1, 2, 0), Point(0, 2, 0), Point(0, 0, 0), Point(1, 0, 0), Point(1, 1, 0), Point(0, 1, 0)])],\n            \"7\": [Polyline([Point(0, 2, 0), Point(1, 2, 0), Point(0.5, 0, 0)])],\n            \"8\": [Polyline([Point(0, 0, 0), Point(0, 2, 0), Point(1, 2, 0), Point(1, 0, 0), Point(0, 0, 0), Point(0, 1, 0), Point(1, 1, 0)])],\n            \"9\": [Polyline([Point(1, 0, 0), Point(1, 2, 0), Point(0, 2, 0), Point(0, 1, 0), Point(1, 1, 0)])],\n        }\n        return font\n\n    def string_to_geometry(self, text, frame, size, offset):\n        \"\"\"\n        Converts a string into a list of polylines representing characters.\n        \"\"\"\n        font = self.low_res_font()\n        geometry = []\n        x_offset = 0\n\n        for char in text.upper():\n            if char in font:\n                for polyline in font[char]:\n                    moved_polyline = Polyline([Point(p.x + x_offset, p.y, p.z) for p in polyline.points])\n                    geometry.append(moved_polyline)\n                x_offset += 2  # Spacing between characters\n\n        T = Translation.from_vector(offset)\n        X = Transformation.from_frame_to_frame(Frame.worldXY(), frame)\n        for g in geometry:\n            g.scale(size * 0.5)\n            g.transform(X)\n            g.transform(T)\n\n        return geometry\n\n    def add_numbers_and_orient_to_grid(self, gap: float = 10):\n        width = 0\n        max_height = 0\n        for idx, polyline in enumerate(self.polylines_u_with_cuts):\n            box = Box.from_points(bounding_box(polyline.points))\n            frame = self.frames_u_with_cuts[idx]\n            frame.point = Point(frame.point[0], frame.point[1], box.zmin)\n            T = Transformation.from_frame_to_frame(frame, Frame.worldXY())\n            T_I = Transformation.from_frame_to_frame(Frame.worldXY(), frame)\n            xy_polyline = polyline.transformed(T)\n            xy_frame = Frame.worldXY()\n\n            box = Box.from_points(bounding_box(xy_polyline.points))\n            T = Translation.from_vector([-box.xmin + width, 0, 0])\n            xy_polyline = xy_polyline.transformed(T)\n            T = Translation.from_vector([width, 0, 0])\n            xy_frame.transform(T)\n            width = width + box.xsize + gap\n\n            if box.ysize > max_height:\n                max_height = box.ysize\n\n            text_xy = self.string_to_geometry(\"A\" + str(idx), xy_frame, 10, Vector(5, 5, 0))\n            for t in text_xy:\n                self.oriented_polylines_u.append(t)\n                self.oriented_polylines_u.append(t.transformed(T_I * T.inverse() * Translation.from_vector([box.xmin, 0, 0])))\n\n            self.oriented_polylines_u.append(xy_polyline)\n\n        width = 0\n        for idx, polyline in enumerate(self.polylines_v_with_cuts):\n            box = Box.from_points(bounding_box(polyline.points))\n            frame = self.frames_v_with_cuts[idx]\n            frame.point = Point(frame.point[0], frame.point[1], box.zmin)\n            T = Transformation.from_frame_to_frame(frame, Frame.worldXY())\n            T_I = Transformation.from_frame_to_frame(Frame.worldXY(), frame)\n            xy_polyline = polyline.transformed(T)\n            xy_frame = Frame.worldXY()\n\n            box = Box.from_points(bounding_box(xy_polyline.points))\n            T = Translation.from_vector([-box.xmin + width, max_height + gap, 0])\n            xy_polyline = xy_polyline.transformed(T)\n            T = Translation.from_vector([width, max_height + gap, 0])\n            xy_frame.transform(T)\n            width = width + box.xsize + gap\n\n            if box.ysize > max_height:\n                max_height = box.ysize\n\n            text_xy = self.string_to_geometry(\"B\" + str(idx), xy_frame, 10, Vector(5, 5, 0))\n            for t in text_xy:\n                self.oriented_polylines_v.append(t)\n                self.oriented_polylines_v.append(t.transformed(T_I * T.inverse() * Translation.from_vector([box.xmin, 0, 0])))\n\n            self.oriented_polylines_v.append(xy_polyline)\n\nscene = Scene()\n\nwaffle = Waffle(mesh, polyline, line, Z_OFFSET)\nwaffle.get_cut_planes(DIVISION_DISTANCE_U, DIVISION_DISTANCE_V)\nwaffle.section_region()\nwaffle.section_mesh()\nwaffle.clip_polyline()\nwaffle.create_cross_joint(GAP_JOINT, THICKNESS)\nwaffle.add_numbers_and_orient_to_grid()\n\nfor polyline in waffle.polylines_u_with_cuts:\n    scene.add(polyline)\n\nfor polyline in waffle.polylines_v_with_cuts:\n    scene.add(polyline)\n\nfor polyline in waffle.oriented_polylines_u:\n    scene.add(polyline)\n\nfor polyline in waffle.oriented_polylines_v:\n    scene.add(polyline)\n\nscene.clear_context()\nscene.draw()\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}