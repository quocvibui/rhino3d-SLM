{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_edgesWithMaxTolerance.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_edgesWithMaxTolerance.py",
  "instruction": "An alternative to _testMarkOTEdges, this script has more options.",
  "code": "\"\"\"\r\nAn alternative to _testMarkOTEdges, this script has more options.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n191102-04: Created.\r\n...\r\n191107: Bug fix.  Added printed feedback.\r\n...\r\n231110: Now dots the edges with maximum tolerance per all input breps regardless of tolerance.\r\n240802: Modified an option default. Modified some printed output.\r\n241124: Added and modified some options.\r\n241125: Refactored.\r\n241128: Modified some printed output.\r\n250223-24: Now, only the absolute maximum is the target, whether it be the single maximum of all or each of the input breps.\r\n250304: Modified an option default.\r\n250826: Modified some printed output.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bPerBrep'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'MaxTol'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'OfAllBreps', 'PerBrep')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bOnlyOutOfSearchTol'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSearchTol'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDupCrv'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotHeight'; keys.append(key)\r\n    values[key] = 11\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        _debug = sc.sticky\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fSearchTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getAllNormalBreps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.NormalObjects = True\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.IncludeLights = False\r\n    oes.IncludeGrips = False\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get Breps with optional input\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    go.SubObjectSelect = False\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    #sc.doc.Views.Redraw()\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('bPerBrep')\r\n        addOption('bOnlyOutOfSearchTol')\r\n        if Opts.values['bOnlyOutOfSearchTol']:\r\n            addOption('fSearchTol')\r\n        addOption('bDupCrv')\r\n        addOption('bDot')\r\n        if Opts.values['bDot']:\r\n            addOption('iDotHeight')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return getAllNormalBreps()\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            if 'fSearchTol' not in idxs_Opts:\r\n                print(\"Numerical input was not applied.\")\r\n                continue\r\n            key = 'fSearchTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef coerceBrep(rhObj):\r\n    if isinstance(rhObj, rg.Brep):\r\n        return rhObj\r\n    elif isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n    elif isinstance(rhObj, rd.BrepObject):\r\n        return rhObj.BrepGeometry\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        #print(rhObj.GeometryComponentIndex.ComponentIndexType\r\n        geom = rhObj.Geometry()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n    else:\r\n        return\r\n\r\n    if isinstance(geom, rg.Brep):\r\n        return geom\r\n\r\n\r\ndef _formatDistance(fDistance):\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance == 0.0:\r\n        return \"0\"\r\n\r\n    if fDistance < 10**(-sc.doc.ModelDistanceDisplayPrecision):\r\n        return \"{:.2e}\".format(fDistance)\r\n\r\n    return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef _addDot(edge, iDotHeight, attr_Out):\r\n    # Dot edge at midpoint.\r\n    ts = edge.DivideByCount(2, includeEnds=False)\r\n    pt = edge.PointAtStart if ts is None else edge.PointAt(ts[0])\r\n\r\n    rgDot = rg.TextDot(\r\n        text='e[{}]\\nTol={}'.format(\r\n            edge.EdgeIndex, _formatDistance(edge.Tolerance)),\r\n        location=pt)\r\n    rgDot.FontHeight = iDotHeight\r\n    return sc.doc.Objects.AddTextDot(rgDot, attr_Out)\r\n\r\n\r\ndef processBreps(rhBreps, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bPerBrep = getOpt('bPerBrep')\r\n    bOnlyOutOfSearchTol = getOpt('bOnlyOutOfSearchTol')\r\n    fSearchTol = getOpt('fSearchTol')\r\n    bDupCrv = getOpt('bDupCrv')\r\n    bDot = getOpt('bDot')\r\n    iDotHeight = getOpt('iDotHeight')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if bDupCrv or bDot:\r\n        attr_Out = rd.ObjectAttributes()\r\n        attr_Out.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n        attr_Out.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        attr_Out.ObjectColor = Color.FromArgb(255,0,0)\r\n\r\n    rgB_maxTol_AllBs = []\r\n    fTols_Max_AllBs = []\r\n    idxEs_Maxima_AllBs = []\r\n\r\n    iCt_Found = 0\r\n\r\n    sLogs = []\r\n\r\n    gCrvs_Out = []\r\n    gDots_Out = []\r\n\r\n    for rhBrep in rhBreps:\r\n        rgB = coerceBrep(rhBrep)\r\n\r\n        if not rgB.IsValid:\r\n            sLogs.append(\"Warning: Brep is invalid but will still be processed. \")\r\n\r\n        tols = [edge.Tolerance for edge in rgB.Edges]\r\n        maxTol_ThisB = max(tols)\r\n\r\n        if (\r\n            bOnlyOutOfSearchTol and\r\n            (round(maxTol_ThisB, sc.doc.ModelDistanceDisplayPrecision) <=\r\n                round(fSearchTol, sc.doc.ModelDistanceDisplayPrecision))\r\n        ):\r\n            sTol = _formatDistance(maxTol_ThisB)\r\n\r\n            if len(rhBreps) == 1:\r\n                if sTol == '0':\r\n                    sLogs.append(\"0 max. Edge.Tolerance.\")\r\n                else:\r\n                    sLogs.append(\"maximum Edge.Tolerance is {} ({} less than search tol.).\".format(\r\n                            sTol,\r\n                            _formatDistance(fSearchTol-maxTol_ThisB)))\r\n            else:\r\n                if sTol == '0':\r\n                    sLogs.append(\"0 max. Edge.Tolerance.\")\r\n                else:\r\n                    sLogs.append(\r\n                        \"maximum Edge.Tolerance of the brep <= {} (search tol.).\".format(\r\n                            fSearchTol))\r\n            continue # to next brep.\r\n\r\n        fTols_Max_AllBs.append(maxTol_ThisB)\r\n\r\n        rgB_maxTol_AllBs.append(rgB)\r\n\r\n        idxEs_Maxima = []\r\n        for edge in rgB.Edges:\r\n            if round(edge.Tolerance, sc.doc.ModelDistanceDisplayPrecision) == round(maxTol_ThisB, sc.doc.ModelDistanceDisplayPrecision):\r\n                idxEs_Maxima.append(edge.EdgeIndex)\r\n\r\n        idxEs_Maxima_AllBs.append(idxEs_Maxima)\r\n\r\n        bOutOfTolFound = maxTol_ThisB > fSearchTol\r\n\r\n        if not bOutOfTolFound:\r\n            if len(rhBreps) == 1:\r\n                sLogs.append(\"maximum Edge.Tolerance is {} ({} less than search tol.).\".format(\r\n                        _formatDistance(maxTol_ThisB),\r\n                        _formatDistance(fSearchTol-maxTol_ThisB)))\r\n            else:\r\n                sLogs.append(\r\n                    \"maximum Edge.Tolerance <= {} (search tol.).\".format(\r\n                        fSearchTol))\r\n\r\n            continue # to next brep.\r\n\r\n    if bEcho and sLogs:\r\n        print(\"\\n\".join(\"{} breps with {}\".format(sLogs.count(sLog), sLog) for sLog in set(sLogs)))\r\n\r\n    if bPerBrep:\r\n        if bOnlyOutOfSearchTol and not rgB_maxTol_AllBs:\r\n            if bEcho:\r\n                print(\"No edges tolerances are greater than the search tolerance.\")\r\n            return\r\n\r\n        iCt_Found = 0\r\n        for rgB, idxs_E in zip(rgB_maxTol_AllBs, idxEs_Maxima_AllBs):\r\n            for idx_E in idxs_E:\r\n                edge = rgB.Edges[idx_E]\r\n                iCt_Found += 1\r\n                if bDupCrv:\r\n                    gCrv_Out = sc.doc.Objects.AddCurve(edge, attr_Out)\r\n                    if gCrv_Out != gCrv_Out.Empty:\r\n                        gCrvs_Out.append(gCrv_Out)\r\n                if bDot:\r\n                    gDot_Out = _addDot(edge, iDotHeight, attr_Out)\r\n                    if gDot_Out != gDot_Out.Empty:\r\n                        gDots_Out.append(gDot_Out)\r\n        if bEcho:\r\n            s = \"{} edges within {} of max. edge tol. per Brep.\".format(\r\n                iCt_Found, 10**-sc.doc.ModelDistanceDisplayPrecision)\r\n    else:\r\n        if bOnlyOutOfSearchTol and not fTols_Max_AllBs:\r\n            if bEcho:\r\n                print(\"No edges tolerances are greater than the search tolerance.\")\r\n            return\r\n\r\n        fTol_Max_All = max(fTols_Max_AllBs)\r\n        iCt_Found = 0\r\n        for rgB, idxs_E in zip(rgB_maxTol_AllBs, idxEs_Maxima_AllBs):\r\n            for idx_E in idxs_E:\r\n                edge = rgB.Edges[idx_E]\r\n                if round(edge.Tolerance, sc.doc.ModelDistanceDisplayPrecision) >= round(fTol_Max_All, sc.doc.ModelDistanceDisplayPrecision):\r\n                    iCt_Found += 1\r\n                    if bDupCrv:\r\n                        gCrv_Out = sc.doc.Objects.AddCurve(edge, attr_Out)\r\n                        if gCrv_Out != gCrv_Out.Empty:\r\n                            gCrvs_Out.append(gCrv_Out)\r\n                    if bDot:\r\n                        gDot_Out = _addDot(edge, iDotHeight, attr_Out)\r\n                        if gDot_Out != gDot_Out.Empty:\r\n                            gDots_Out.append(gDot_Out)\r\n\r\n        if bEcho:\r\n            if iCt_Found:\r\n                s = \"{} edges found within {} of {}.\".format(\r\n                    iCt_Found, 10.0**-sc.doc.ModelDistanceDisplayPrecision, _formatDistance(fTol_Max_All))\r\n            else:\r\n                s = \" Max. tol. of all edges is {}.\".format(\r\n                    _formatDistance(max(fTols_Max_AllBs)))\r\n\r\n    if bEcho:\r\n        if bDupCrv:\r\n            s += \" {} curves added.\".format(len(gCrvs_Out))\r\n        if bDot:\r\n            s += \" {} dots added.\".format(len(gDots_Out))\r\n\r\n        print(s)\r\n\r\n\r\ndef main():\r\n\r\n    rhObjs = getInput()\r\n    if not rhObjs: return\r\n\r\n    bPerBrep = Opts.values['bPerBrep']\r\n    bOnlyOutOfSearchTol = Opts.values['bOnlyOutOfSearchTol']\r\n    fSearchTol = Opts.values['fSearchTol']\r\n    bDupCrv = Opts.values['bDupCrv']\r\n    bDot = Opts.values['bDot']\r\n    iDotHeight = Opts.values['iDotHeight']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    processBreps(\r\n        rhObjs,\r\n        bPerBrep=bPerBrep,\r\n        bOnlyOutOfSearchTol=bOnlyOutOfSearchTol,\r\n        fSearchTol=fSearchTol,\r\n        bDupCrv=bDupCrv,\r\n        bDot=bDot,\r\n        iDotHeight=iDotHeight,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}