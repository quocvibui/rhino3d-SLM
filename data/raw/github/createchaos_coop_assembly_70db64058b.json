{
  "source_url": "https://github.com/createchaos/coop_assembly/blob/71108b0639323cf3d996d63b0f702d45f4d60d67/src/coop_assembly/help_functions/drawing.py",
  "repo": "createchaos/coop_assembly",
  "repo_stars": 4,
  "repo_description": "Geometry generation of robotically assembled spatial structures ",
  "license": "MIT",
  "filepath": "src/coop_assembly/help_functions/drawing.py",
  "instruction": "****       *****       ******       ****       ******  ******          **           **       \n   **  **      **  **      **          **  **        **    **              **           **       \n   **  ...",
  "code": "\n'''\n                                                                                                 \n    ****       *****       ******       ****       ******  ******          **           **       \n   **  **      **  **      **          **  **        **    **              **           **       \n   **          *****       ****        ******        **    ****            **   *****   *****    \n   **  **      **  **      **          **  **        **    **              **  **  **   **  **   \n    ****   **  **  **  **  ******  **  **  **  **    **    ******          **   ******  *****    \n                           \n                                           \ncreated on 28.06.2019\nauthor: stefanaparascho\n'''\n\nfrom compas.utilities.colors import color_to_colordict\nfrom compas.geometry.basic import add_vectors, scale_vector\n\nfrom coop_assembly.help_functions.helpers_geometry import dropped_perpendicular_points\n\ndef draw(b_struct, o_struct, j, colors_b=(None, None), colors_o=(None, None)):\n\n    # from draw_compas import draw_network_inv\n    # from compas_rhino.helpers.network import draw_network\n    from compas_rhino.artists import NetworkArtist\n    import rhinoscriptsyntax as rs\n    import Rhino\n    import time\n\n    bool_export = False\n    bool_debug = False\n\n    Rhino.RhinoApp.Wait()\n    draw_network_inv(b_struct, None, False, vertexcolor=colors_b[0], edgecolor=colors_b[1])\n    Rhino.RhinoApp.Wait()\n    artist = NetworkArtist(o_struct)\n    # draw_network(o_struct, None, False, vertexcolor=colors_o[0], edgecolor=colors_o[1])\n    rs.Redraw()\n    Rhino.RhinoApp.Wait()\n    # if bool_export:\n    #     capture_to_file(\"C:\\Users\\Stefana\\Documents\\imgs_lws\\img9999_\" + str(j) + \".jpg\",  \"network_1\", 1)\n    \n    if bool_debug:\n        for b in b_struct.edge:\n            for c in b_struct.edge[b]:\n                key     = b_struct.edge[b][c][\"endpoints\"].keys()[0]\n                pt_0    = b_struct.edge[b][c][\"endpoints\"][key][0]\n                pt_1    = b_struct.edge[b][c][\"endpoints\"][key][1]\n                pt_0    = Rhino.Geometry.Point3d(pt_0[0], pt_0[1], pt_0[2])\n                pt_1    = Rhino.Geometry.Point3d(pt_1[0], pt_1[1], pt_1[2])\n                rs.AddSphere(pt_0, 10)\n                rs.AddSphere(pt_1, 10)\n\n\ndef draw_network_inv(network,\n                     layer=None,\n                     clear_layer=False,\n                     vertexcolor=None,\n                     edgecolor=None):\n  \n\n    import compas_rhino\n    from compas_rhino.artists import Artist\n\n    artist = Artist()\n\n    vertexcolor = color_to_colordict(vertexcolor,\n                                     network.vertices(),\n                                     default=network.attributes['color.vertex'],\n                                     colorformat='rgb',\n                                     normalize=False)\n\n    edgecolor = color_to_colordict(edgecolor,\n                                   network.edges(),\n                                   default=network.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    points = []\n    for key, attr in network.vertices(True):\n        points.append({\n            \"pos\": network.vertex[key][\"axis_endpoints\"][0],\n            \"name\": '{0}.vertex.{1}'.format(network.attributes['name'], key),\n            \"color\": vertexcolor[key]\n        })\n        points.append({\n            \"pos\": network.vertex[key][\"axis_endpoints\"][1],\n            \"name\": '{0}.vertex.{1}'.format(network.attributes['name'], key),\n            \"color\": vertexcolor[key]\n        })\n\n    lines = []\n    for key, attr in network.vertices(True):\n        lines.append({\n            \"start\": network.vertex[key][\"axis_endpoints\"][0],\n            \"end\": network.vertex[key][\"axis_endpoints\"][1],\n            \"name\": '{0}.vertex.{1}'.format(network.attributes['name'], key),\n            \"color\": vertexcolor[(key)]\n        })\n\n    for u, v, attr in network.edges(True):\n\n        dpp = dropped_perpendicular_points(network.vertex[u][\"axis_endpoints\"][0],\n                                               network.vertex[u][\"axis_endpoints\"][1],\n                                               network.vertex[v][\"axis_endpoints\"][0],\n                                               network.vertex[v][\"axis_endpoints\"][1])\n        lines.append({\n            \"start\": dpp[0],\n            \"end\": dpp[1],\n            \"name\": '{0}.edge.{1}-{2}'.format(network.attributes['name'], u, v),\n            \"color\": edgecolor[(u, v)]\n        })\n\n    lines_n = []\n    for v in network.vertex:\n        if \"gripping_plane\" in network.vertex[v].keys():\n            st_p = network.vertex[v][\"gripping_plane\"][0]\n            end_p = add_vectors(network.vertex[v][\"gripping_plane\"][0], scale_vector(\n                network.vertex[v][\"gripping_plane\"][1], 100))\n            lines_n.append({\n                \"start\": st_p,\n                \"end\": end_p,\n                \"name\": '{0}.gripping.{1}'.format(network.attributes['name'], v),\n                \"color\": (255, 0, 0)\n            })\n\n            st_p = network.vertex[v][\"gripping_plane\"][0]\n            end_p = add_vectors(network.vertex[v][\"gripping_plane\"][0], scale_vector(\n                network.vertex[v][\"gripping_plane\"][3], 100))\n            lines_n.append({\n                \"start\": st_p,\n                \"end\": end_p,\n                \"name\": '{0}.gripping.{1}'.format(network.attributes['name'], v),\n                \"color\": (255, 0, 0)\n            })\n\n    guids = compas_rhino.get_objects(\n        name='{0}.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    # compas_rhino.xdraw_points(\n    #     points,\n    #     layer=layer,\n    #     clear=clear_layer,\n    #     redraw=False\n    # )\n\n    artist.draw_points(\n        points,\n        layer=layer,\n        clear_layer=False,\n        redraw=True\n    )\n\n    # compas_rhino.xdraw_lines(\n    #     lines,\n    #     layer=layer,\n    #     clear=False,\n    #     redraw=True\n    # )\n\n    artist.draw_lines(\n        lines,\n        layer=layer,\n        clear_layer=False,\n        redraw=True\n    )\n\n    # compas_rhino.xdraw_lines(\n    #     lines_n,\n    #     layer=layer,\n    #     clear=False,\n    #     redraw=True\n    # )\n\n    artist.draw_lines(\n        lines_n,\n        layer=layer,\n        clear_layer=False,\n        redraw=True\n    )\n\n\ndef draw_network_inv_gh(network):\n    \"\"\"Draw a network data structure in Grasshopper.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 7\n\n            import compas\n            from compas.datastructures.network import Network\n            import compas_rhino\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            compas_rhino.draw_network(network)\n\n    \"\"\"\n\n    from compas_ghpython.utilities import draw_points, draw_lines\n\n    points = []\n    for key, attr in network.vertices(True):\n        points.append({\n            \"pos\": network.vertex[key][\"axis_endpoints\"][0]\n        })\n        points.append({\n            \"pos\": network.vertex[key][\"axis_endpoints\"][1]\n        })\n\n    lines = []\n    for key, attr in network.vertices(True):\n        lines.append({\n            \"start\": network.vertex[key][\"axis_endpoints\"][0],\n            \"end\": network.vertex[key][\"axis_endpoints\"][1]\n        })\n\n    lines_c = []\n    for u, v, attr in network.edges(True):\n\n        # dpp = dropped_perpendicular_points_ipy(network.vertex[u][\"axis_endpoints\"][0],\n        #                              network.vertex[u][\"axis_endpoints\"][1],\n        #                              network.vertex[v][\"axis_endpoints\"][0],\n        #                              network.vertex[v][\"axis_endpoints\"][1])\n        if network.edge[u][v]:\n            # print(\"u, v\", u, v)\n            # print(network.edge[u][v])\n            try:\n                network.edge[u][v][\"endpoints\"][0]\n                dpp = network.edge[u][v][\"endpoints\"][0]\n            except:\n                dpp = network.edge[u][v][\"endpoints\"][\"0\"]\n        else:\n            try:\n                network.edge[u][v][\"endpoints\"][0]\n                dpp = network.edge[v][u][\"endpoints\"][0]\n            except:\n                dpp = network.edge[u][v][\"endpoints\"][\"0\"]\n        \n        if dpp != []:\n            lines_c.append({\n                \"start\": dpp[0],\n                \"end\": dpp[1]\n            })\n\n    lines_n = []\n    for v in network.vertex:\n        if \"gripping_plane\" in network.vertex[v].keys():\n            st_p = network.vertex[v][\"gripping_plane\"][0]\n            end_p = add_vectors(network.vertex[v][\"gripping_plane\"][0], scale_vector(\n                network.vertex[v][\"gripping_plane\"][1], 100))\n            lines_n.append({\n                \"start\": st_p,\n                \"end\": end_p\n            })\n\n            st_p = network.vertex[v][\"gripping_plane\"][0]\n            end_p = add_vectors(network.vertex[v][\"gripping_plane\"][0], scale_vector(\n                network.vertex[v][\"gripping_plane\"][3], 100))\n            lines_n.append({\n                \"start\": st_p,\n                \"end\": end_p\n            })\n\n    points_gh = draw_points(points)\n    lines_gh = draw_lines(lines)\n    lines_c_gh = draw_lines(lines_c)\n    return points_gh, lines_gh, lines_c_gh\n\n\ndef create_rhino_mesh(vertices, faces):\n    from Rhino.Geometry import Mesh as RhinoMesh\n    # print vertices\n\n    mesh = RhinoMesh()\n    for a, b, c in vertices:\n        mesh.Vertices.Add(a, b, c)\n    for face in faces:\n        mesh.Faces.AddFace(face[0], face[1], face[2])\n\n    return mesh\n\n\ndef draw_robots(structure, building_member, rob_num, rob_num_b, path, config_b, pick_up_config):\n    raise DeprecationWarning('needs update on compas / compas_fab old function calls')\n\n    import compas_rhino.helpers\n    import scriptcontext\n\n    # print \"structure\", structure\n\n    r_m = []\n    for m in structure:\n        # compas_rhino.helpers.mesh.draw_mesh(m)\n        vertices_m, faces_m = m.to_vertices_and_faces()\n        r_m.append(create_rhino_mesh(vertices_m, faces_m))\n\n    from compas_fab.fabrication.grasshopper.path_planning import PathVisualizer\n    vertices_m, faces_m = building_member.to_vertices_and_faces()\n    bm = create_rhino_mesh(vertices_m, faces_m)\n\n    with Simulator(debug=True) as simulator:\n        robot = Robot(rob_num, client=simulator)\n        rob_11 = Robot(11, client=simulator)\n        rob_12 = Robot(12, client=simulator)\n        robot_b = Robot(rob_num_b, client=simulator)\n\n        start_config_11 = Configuration.from_joints_and_external_axes(\n            [0, 0, 0, 0, 0, 0], [0, -1000, -3500])\n        start_config_12 = Configuration.from_joints_and_external_axes(\n            [0, 0, 0, 0, 0, 0], [0, -10000, -3500])\n\n        simulator.set_robot_config(rob_11, start_config_11)\n        simulator.set_robot_config(rob_12, start_config_12)\n        simulator.set_robot_config(robot_b, config_b)\n        # simulator.add_meshes(structure)\n\n        pv = PathVisualizer(simulator, robot, bm, pick_up_config)\n        meshes = pv.get_frame_meshes(path, len(path)-1, {})\n\n    for m in meshes:\n        scriptcontext.doc.Objects.AddMesh(m)\n\n    for m in r_m:\n        scriptcontext.doc.Objects.AddMesh(m)\n    scriptcontext.doc.Views.Redraw()\n\n\ndef draw_structure(network, r, values=\"stresses\"):\n    from compas_rhino.utilities import draw_cylinders\n    from spatial_structures.rhino_visualization import draw_inner_forces_bar,\\\n    get_inner_force_value_points, draw_force_line, get_inner_force_line_points\n\n    cylinders = []\n    for key, attr in network.vertices_iter(True):\n        if values == \"stresses\":\n            # print \"utils draw\", max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])\n            if max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"]) < 1:\n                color_struct = (max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])\n                                * 255, 0, (1 - max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])) * 255)\n            else:\n                color_struct = (255, 0, 0)\n        elif values == \"deformations\":\n            # print \"utils draw\", max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])\n            if max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"]) < 1:\n                color_struct = (max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])\n                                * 255, 0, (1 - max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])) * 255)\n            else:\n                color_struct = (255, 0, 0)\n        if values == \"stresses\" or values == \"deformations\":\n            cylinders.append({\n                \"start\": network.vertex[key][\"axis_endpoints\"][0],\n                \"end\": network.vertex[key][\"axis_endpoints\"][1],\n                \"name\": '{0}.vertex_pipe.{1}'.format(network.attributes['name'], key),\n                \"radius\": r,\n                \"color\": color_struct\n            })\n\n    if values == \"stresses\":\n        for key1, key2, attr in network.edges_iter(True):\n            # print network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"]\n            # print \"utils draw\", max(network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"])\n            if max(network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"]) < 1:\n                color_struct = (max(network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"])\n                                * 255, 0, (1 - max(network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"])) * 255)\n            else:\n                color_struct = (255, 0, 0)\n\n            cylinders.append({\n                \"start\": network.edge[key1][key2][\"endpoints\"][0][0],\n                \"end\": network.edge[key1][key2][\"endpoints\"][0][1],\n                \"name\": '{0}:{1}.edge_pipe.{2}'.format(network.attributes['name'], key1, key2),\n                \"radius\": r,\n                \"color\": color_struct\n            })\n\n    if values == \"stresses\" or values == \"deformations\":\n        draw_cylinders(cylinders, cap=True)\n    elif values == \"forces\":\n        for v in network.vertex:\n            forces = network.vertex[v][\"exchange_values\"][\"forces\"]\n            #draw_inner_forces_bar(sBar, 0)\n            draw_forces_bar(forces, force_scale=0.0001, index_force=0)\n\n\ndef draw_structure_gh(network, r, values=\"stresses\"):\n    from compas_ghpython.utilities import draw_cylinders\n\n    cylinders = []\n    colours = []\n    for key, attr in network.vertices(True):\n        if values == \"stresses\":\n            # print \"utils draw\", max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])\n            if network.vertex[key][\"exchange_values\"][\"utils_stresses\"] == []:\n                color_struct = (255, 255, 255)\n            elif max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"]) < 0.5:\n                color_struct = (0, (1 - 2*max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])) * 255, 2*max(\n                    network.vertex[key][\"exchange_values\"][\"utils_stresses\"])\n                    * 255)\n            elif max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"]) < 1.0:\n                color_struct = (2*(max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])-0.5)\n                                * 255, 0, (1 - 2*(max(network.vertex[key][\"exchange_values\"][\"utils_stresses\"])-0.5)) * 255)\n            else:\n                color_struct = (255, 0, 0)\n            colours.append(color_struct)\n        elif values == \"deformations\":\n            max_val = 20\n            # print \"utils draw\", max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])\n            if max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"]) < max_val/2:\n                # color_struct = (max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])\n                #                 * 255, 0, (1 - max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])) * 255)\n                color_struct = (0, (1 - max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])/(\n                    max_val/2)) * 255, max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])/(max_val/2) * 255)\n            elif max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"]) < max_val:\n                color_struct = (((max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"]) - max_val/2)/(\n                    max_val/2)) * 255, 0, (1 - (max(network.vertex[key][\"exchange_values\"][\"utils_deformation\"])-max_val/2)/(max_val/2)) * 255)\n            else:\n                color_struct = (255, 0, 0)\n            colours.append(color_struct)\n        if values == \"stresses\" or values == \"deformations\":\n            cylinders.append({\n                \"start\": network.vertex[key][\"axis_endpoints\"][0],\n                \"end\": network.vertex[key][\"axis_endpoints\"][1],\n                \"name\": '{0}.vertex_pipe.{1}'.format(network.attributes['name'], key),\n                \"radius\": r\n            })\n\n    # if values == \"stresses\":\n    #     for key1, key2, attr in network.edges_iter(True):\n    #         # print network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"]\n    #         # print \"utils draw\", max(network.edge[key1][key2][\"exchange_values\"][0][\"utils_stresses\"])\n    #         key_e = network.edge[key1][key2][\"exchange_values\"].keys()[0]\n    #         if max(network.edge[key1][key2][\"exchange_values\"][key_e][\"utils_stresses\"]) < 1:\n    #             color_struct = (max(network.edge[key1][key2][\"exchange_values\"][key_e][\"utils_stresses\"])\n    #                             * 255, 0, (1 - max(network.edge[key1][key2][\"exchange_values\"][key_e][\"utils_stresses\"])) * 255)\n    #         else:\n    #             color_struct = (255, 0, 0)\n    #         colours.append(color_struct)\n    #         cylinders.append({\n    #             \"start\": network.edge[key1][key2][\"endpoints\"][key_e][0],\n    #             \"end\": network.edge[key1][key2][\"endpoints\"][key_e][1],\n    #             \"radius\": r\n    #         })\n\n    if values == \"stresses\" or values == \"deformations\":\n        cylinders_gh = draw_cylinders(cylinders, cap=True)\n    elif values == \"forces\":\n        for v in network.vertex:\n            forces = network.vertex[v][\"exchange_values\"][\"forces\"]\n            #draw_inner_forces_bar(sBar, 0)\n            #draw_forces_bar(forces, force_scale=0.0001, index_force=0)\n    # print \"cylinders\", cylinders_gh\n\n    return cylinders_gh, colours\n\n\ndef draw_forces_bar(forces, index_force=0, mVect=(0.0, 0.0, 0.0), bar_scale=1000.0, force_scale=1.0, color_pos=(226, 0, 26), color_neg=(0, 118, 189)):\n    dirIndexes = [2, 1, 2, 2, 2, 1]\n#     for iStates in sBar.iStatesMembers:\n#         for i in range(len(iStates)-1):\n#             istat_p1 = iStates[i]\n#             istat_p2 = iStates[i+1]\n#             fline_tupel1 = get_inner_force_value_points(istat_p1.abs_Pos, force_scale*istat_p1.iForceList[iForceIndex], istat_p1.basis[dirIndexes[iForceIndex]])\n#             fline_tupel2 = get_inner_force_value_points(istat_p2.abs_Pos, force_scale*istat_p2.iForceList[iForceIndex], istat_p2.basis[dirIndexes[iForceIndex]])\n#             sline = draw_force_line(fline_tupel1, mVect, bar_scale, color_pos, color_neg)\n#             eline = draw_force_line(fline_tupel2, mVect, bar_scale, color_pos, color_neg)\n#             if sline or eline:\n#                 for flt in get_inner_force_line_points(fline_tupel1, fline_tupel2): draw_force_line(flt, mVect, bar_scale, color_pos, color_neg)\n#\n    for i in range(len(forces.keys())-1):\n        f1 = forces.keys()[i]\n        f2 = forces.keys()[i+1]\n        fline_tupel1 = get_inner_force_value_points(\n            forces[f1][0], force_scale*forces[f1][1][index_force], forces[f1][2][index_force])\n        fline_tupel2 = get_inner_force_value_points(\n            forces[f2][0], force_scale*forces[f2][1][index_force], forces[f2][2][index_force])\n        sline = draw_force_line(fline_tupel1, mVect,\n                                bar_scale, color_pos, color_neg)\n        eline = draw_force_line(fline_tupel2, mVect,\n                                bar_scale, color_pos, color_neg)\n        if sline or eline:\n            for flt in get_inner_force_line_points(fline_tupel1, fline_tupel2):\n                draw_force_line(flt, mVect, bar_scale, color_pos, color_neg)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}