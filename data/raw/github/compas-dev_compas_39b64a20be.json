{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/surfaces/surface.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/surfaces/surface.py",
  "instruction": "Surface",
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import Surface\nfrom compas_rhino.conversions import box_to_compas\nfrom compas_rhino.conversions import plane_to_compas_frame\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import transformation_to_rhino\nfrom compas_rhino.conversions import vector_to_compas\nfrom compas_rhino.geometry.curves import RhinoCurve\n\n\nclass RhinoSurface(Surface):\n    \"\"\"Class representing a general surface object.\n\n    Parameters\n    ----------\n    native_surface : :rhino:`Surface`\n        A Rhino surface.\n    name : str, optional\n        The name of the surface.\n\n    Attributes\n    ----------\n    domain_u: tuple[float, float]\n        The parameter domain in the U direction.\n    domain_v: tuple[float, float]\n        The parameter domain in the V direction.\n    is_periodic_u: bool\n        True if the surface is periodic in the U direction.\n    is_periodic_v: bool\n        True if the surface is periodic in the V direction.\n\n    \"\"\"\n\n    def __init__(self, native_surface, name=None):\n        super(RhinoSurface, self).__init__(name=name)\n        self._native_surface = native_surface\n\n    @property\n    def rhino_surface(self):\n        return self._native_surface\n\n    @property\n    def native_surface(self):\n        return self._native_surface\n\n    @native_surface.setter\n    def native_surface(self, surface):\n        self._native_surface = surface\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def domain_u(self):\n        if self.native_surface:\n            return self.native_surface.Domain(0)\n\n    @property\n    def domain_v(self):\n        if self.native_surface:\n            return self.native_surface.Domain(1)\n\n    @property\n    def is_periodic_u(self):\n        if self.native_surface:\n            return self.native_surface.IsPeriodic(0)\n\n    @property\n    def is_periodic_v(self):\n        if self.native_surface:\n            return self.native_surface.IsPeriodic(1)\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_native(cls, native_surface):\n        \"\"\"Construct a surface from an existing Rhino surface.\n\n        Parameters\n        ----------\n        native_surface : :rhino:`Rhino.Geometry.Surface`\n            A Rhino surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoSurface`\n\n        \"\"\"\n        return cls(native_surface)\n\n    @classmethod\n    def from_rhino(cls, native_surface):\n        \"\"\"Construct a surface from an existing Rhino surface.\n\n        Parameters\n        ----------\n        native_surface : :rhino:`Rhino.Geometry.Surface`\n            A Rhino surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoSurface`\n\n        Warnings\n        --------\n        .. deprecated:: 2.3\n            Use `from_native` instead.\n\n        \"\"\"\n        return cls(native_surface)\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def copy(self):\n        \"\"\"Make an independent copy of the current surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoSurface`\n\n        \"\"\"\n        cls = type(self)\n        return cls(self.native_surface.Duplicate())\n\n    def transform(self, T):\n        \"\"\"Transform this surface.\n\n        Parameters\n        ----------\n        T : :class:`compas.geometry.Transformation`\n            A COMPAS transformation.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.native_surface.Transform(transformation_to_rhino(T))  # type: ignore\n\n    def isocurve_u(self, u):\n        \"\"\"Compute the isoparametric curve at parameter u.\n\n        Parameters\n        ----------\n        u : float\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        curve = self.native_surface.IsoCurve(1, u)  # type: ignore\n        return RhinoCurve.from_rhino(curve)\n\n    def isocurve_v(self, v):\n        \"\"\"Compute the isoparametric curve at parameter v.\n\n        Parameters\n        ----------\n        v : float\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoCurve`\n\n        \"\"\"\n        curve = self.native_surface.IsoCurve(0, v)  # type: ignore\n        return RhinoCurve.from_rhino(curve)\n\n    def point_at(self, u, v):\n        \"\"\"Compute a point on the surface.\n\n        Parameters\n        ----------\n        u : float\n        v : float\n\n        Returns\n        -------\n        :class:`compas.geometry.Point`\n\n        \"\"\"\n        point = self.native_surface.PointAt(u, v)  # type: ignore\n        return point_to_compas(point)\n\n    def curvature_at(self, u, v):\n        \"\"\"Compute the curvature at a point on the surface.\n\n        Parameters\n        ----------\n        u : float\n        v : float\n\n        Returns\n        -------\n        tuple[[float, float, float], [float, float, float], float, [float, float, float], float, [float, float, float], float, float] | None\n            A tuple containing the point, normal vector, maximum principal curvature value, maximum principal curvature direction,\n            minimun principal curvature value, minimun principal curvature direction, gaussian curvature value and mean curvature\n            value for the point at UV. None at failure.\n\n        \"\"\"\n        surface_curvature = self.native_surface.CurvatureAt(u, v)  # type: ignore\n        if surface_curvature:\n            point, normal, kappa_u, direction_u, kappa_v, direction_v, gaussian, mean = surface_curvature\n            cpoint = point_to_compas(point)\n            cnormal = vector_to_compas(normal)\n            cdirection_u = vector_to_compas(direction_u)\n            cdirection_v = vector_to_compas(direction_v)\n            return (cpoint, cnormal, kappa_u, cdirection_u, kappa_v, cdirection_v, gaussian, mean)\n\n    def frame_at(self, u, v):\n        \"\"\"Compute the local frame at a point on the curve.\n\n        Parameters\n        ----------\n        u : float\n        v : float\n\n        Returns\n        -------\n        :class:`compas.geometry.Frame`\n\n        \"\"\"\n        result, plane = self.native_surface.FrameAt(u, v)  # type: ignore\n        if result:\n            return plane_to_compas_frame(plane)\n\n    # ==============================================================================\n    # Methods continued\n    # ==============================================================================\n\n    def closest_point(self, point, return_parameters=False):\n        \"\"\"Compute the closest point on the curve to a given point.\n\n        Parameters\n        ----------\n        point : :class:`compas.geometry.Point`\n            The test point.\n        return_parameters : bool, optional\n            If True, return the UV parameters of the closest point as tuple in addition to the point location.\n\n        Returns\n        -------\n        :class:`compas.geometry.Point`\n            If `return_parameters` is False.\n        :class:`compas.geometry.Point`, (float, float)\n            If `return_parameters` is True.\n\n        \"\"\"\n        result, u, v = self.native_surface.ClosestPoint(point_to_rhino(point))  # type: ignore\n        if not result:\n            return\n        point = self.point_at(u, v)\n        if return_parameters:\n            return point, (u, v)\n        return point\n\n    def aabb(self, precision=0.0, optimal=False):\n        \"\"\"Compute the axis aligned bounding box of the surface.\n\n        Parameters\n        ----------\n        precision : float, optional\n        optimal : float, optional\n            Flag indicating that the box should be precise.\n\n        Returns\n        -------\n        :class:`compas.geometry.Box`\n\n        \"\"\"\n        box = self.native_surface.GetBoundingBox(optimal)  # type: ignore\n        return box_to_compas(Rhino.Geometry.Box(box))\n\n    def intersections_with_curve(self, curve, tolerance=1e-3, overlap=1e-3):\n        \"\"\"Compute the intersections with a curve.\n\n        Parameters\n        ----------\n        line : :class:`compas.geometry.Curve`\n\n        Returns\n        -------\n        list[:class:`compas.geometry.Point`]\n\n        \"\"\"\n        intersections = Rhino.Geometry.Intersect.Intersection.CurveSurface(curve.rhino_curve, self.native_surface, tolerance, overlap)\n        points = []\n        for event in intersections:\n            if event.IsPoint:\n                point = point_to_compas(event.PointA)\n                points.append(point)\n        return points\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}