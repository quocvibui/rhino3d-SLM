{
  "source_url": "https://github.com/ksobon/MantisShrimp/blob/9b3d1ef747a04f75f3542c38550c4e29b9d08c8f/Dynamo/src/Read%20GH%20File.py",
  "repo": "ksobon/MantisShrimp",
  "repo_stars": 39,
  "repo_description": "A interop project for bridging the gap between Rhino/Grasshopper and Revit/Dynamo",
  "license": "unknown",
  "filepath": "Dynamo/src/Read GH File.py",
  "instruction": "Copyright(c) 2015, Konrad Sobon @arch_laboratory, http://archi-lab.net",
  "code": "#Copyright(c) 2015, Konrad Sobon\n# @arch_laboratory, http://archi-lab.net\n\nimport clr\nimport sys\nclr.AddReference('ProtoGeometry')\n\npyt_path = r'C:\\Program Files (x86)\\IronPython 2.7\\Lib'\nsys.path.append(pyt_path)\n\nimport os\nappDataPath = os.getenv('APPDATA')\nmsPath = appDataPath + r\"\\Dynamo\\0.8\\packages\\Mantis Shrimp\\extra\"\nif msPath not in sys.path:\n\tsys.path.append(msPath)\ntxtFilePath = appDataPath + r\"\\Dynamo\\0.8\\packages\\Mantis Shrimp\\extra\\rhPath.txt\"\nif not os.path.isfile(txtFilePath):\n\tmessage = \"Provide valid RhinoCommon.dll path.\"\nelse:\n\tfile = open(txtFilePath, 'r+')\n\trhDllPath = file.readline()\n\tclr.AddReferenceToFileAndPath(rhDllPath)\n\tfile.close()\n\nfrom Autodesk.DesignScript.Geometry import *\nfrom System import Array\nfrom System.Collections.Generic import *\nimport Rhino as rc\nimport pickle\nfrom mantisshrimp import *\n\n#The inputs to this node will be stored as a list in the IN variable.\ndataEnteringNode = IN\nfilePath = str(IN[0])\n_import = IN[1]\n\nclass SerializeObjects(object):\n\tdef __init__(self, filePath, data = None):\n\t\tself.filePath = filePath\n\t\tself.data = data\n\n\tdef saveToFile(self):\n\t\twith open(self.filePath, 'wb') as outf:\n\t\t\tpickle.dump(self.data, outf)\n\n\tdef readFromFile(self):\n\t\twith open(self.filePath, 'rb') as inf:\n\t\t\tself.data = pickle.load(inf)\n\nserializer = SerializeObjects(filePath)\nserializer.readFromFile()\n\ndef ProcessList(_func, _list):\n    return map( lambda x: ProcessList(_func, x) if type(x)==list else _func(x), _list)\n    \ndef toDSObject(item):\n\tif type(item) == MSPoint:\n\t\treturn item.toDSPoint()\n\telif type(item) == MSLine:\n\t\treturn item.toDSLine()\n\telif type(item) == MSPolyLine:\n\t\treturn item.toDSPolyCurve()\n\telif type(item) == MSEllipse:\n\t\treturn item.toDSEllipse()\n\telif type(item) == MSCircle:\n\t\treturn item.toDSCircle()\n\telif type(item) == MSArc:\n\t\treturn item.toDSArc()\n\telif type(item) == MSNurbsCurve:\n\t\treturn item.toDSNurbsCurve()\n\telif type(item) == MSMultiSpanNurbsCurve:\n\t\treturn item.toDSPolyCurve()\n\telif type(item) == MSPolyCurve:\n\t\treturn item.toDSPolyCurve()\n\telif type(item) == MSMesh:\n\t\treturn item.toDSMesh()\n\telif type(item) == MSNurbsSurface:\n\t\treturn item.toDSNurbsSurface()\n\telif type(item) == MSBrep:\n\t\treturn item.toDSPolySurface()\n\telif type(item) == MSData:\n\t\treturn item.data\n\telse:\n\t\tmessage = \"Geometry type not yet supported\"\n\t\treturn message\n\nmessage = None\nif _import:\n\tserializedData = serializer.data\n\tif type(serializedData) == MSData:\n\t\tgeometryOut = serializedData.data\n\telse:\n\t\tgeometryOut = ProcessList(toDSObject, serializedData)\nelse:\n\tmessage = \"Import set to false\"\n\n#Assign your output to the OUT variable\nif message == None:\n\tOUT = geometryOut\nelse:\n\tOUT = '\\n'.join('{:^35}'.format(s) for s in message.split('\\n'))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon"
  ],
  "has_docstring": true
}