{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_BrepEdge_splitAtDiscontinuities.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_BrepEdge_splitAtDiscontinuities.py",
  "instruction": "This script will split edges of Breps at G1- or G2-discontinuous knots.\r\nIt can be used after a _MergeAllEdges so that G1 maximum continuities,\r\nhave vertices.\r\n\r\nFor G2 disontinuities, a choice of...",
  "code": "\"\"\"\r\nThis script will split edges of Breps at G1- or G2-discontinuous knots.\r\nIt can be used after a _MergeAllEdges so that G1 maximum continuities,\r\nhave vertices.\r\n\r\nFor G2 disontinuities, a choice of two routines are available.\r\n\r\n1. Mine\r\n   It allows input of a tolerance for absolute radius difference.\r\n   It also uses angle tolerance for the difference in curvature vector\r\n   directions.  ( _GCon also uses the same tolerance for both.)\r\n2. RhinoCommmon's Curve.GetNextDiscontinuity\r\n    Its default value to find G2 discontinuities where at least one\r\n    of the following is true:\r\n        1. abs(k0-k1) / max(k0,k1) > 0.05,\r\n        where k0 and k1 are magnitudes of the curvature vectors\r\n        before and after the knot.\r\n        2. The difference in curvature vectors is > 2.0 degrees.\r\n    Using a different value has a limited effect.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n211119: Created.\r\n221027: Removed requiring trim selection during mated edge selection.\r\n221223-24: Added options to control G2 discontinuity search.\r\n230601: Now will process all breps when none are selected.  Bug fix in processing all edges of breps.\r\n\r\nTODO: Add absolute curvature difference tolerance at least for RC method?\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Math\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAllowBrepSelection'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'SelectionMode'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'EdgesOnly', 'EdgesandBreps')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bIncludeMated'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'IncludeMated'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fAngleTol_Deg'; keys.append(key)\r\n    values[key] = sc.doc.ModelAngleToleranceDegrees\r\n    names[key] = 'AngleTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bG2_NotG1'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Discont'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'G1', 'G2')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUseSPB_NotRC'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'G2Method'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'RC', 'SPB')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fRadiusTol'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fRCCrvtrTol'; keys.append(key)\r\n    values[key] = Rhino.RhinoMath.SqrtEpsilon\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddRefs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fAngleTol_Deg':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-3:\r\n                cls.riOpts[key].CurrentValue = 1e-3\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fRadiusTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fRCCrvtrTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        if Opts.values['bAllowBrepSelection']:\r\n            go.SetCommandPrompt(\"Select breps and/or edges\")\r\n            go.SetCommandPromptDefault(\"All normal breps when none are selected\")\r\n            go.GeometryFilter = rd.ObjectType.Brep | rd.ObjectType.Curve\r\n            go.AcceptNothing(True)\r\n        else:\r\n            go.SetCommandPrompt(\"Select edges\")\r\n            go.GeometryFilter = rd.ObjectType.Curve\r\n            go.AcceptNothing(False)\r\n\r\n        go.GeometryAttributeFilter = (\r\n            ri.Custom.GeometryAttributeFilter.EdgeCurve |\r\n            ri.Custom.GeometryAttributeFilter.BoundaryEdge)\r\n\r\n        if Opts.values['bIncludeMated']:\r\n            go.GeometryAttributeFilter |= (\r\n                ri.Custom.GeometryAttributeFilter.MatedEdge)\r\n\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bAllowBrepSelection')\r\n        addOption('bIncludeMated')\r\n        addOption('fAngleTol_Deg')\r\n        addOption('bG2_NotG1')\r\n        if Opts.values['bG2_NotG1']:\r\n            addOption('bUseSPB_NotRC')\r\n            if Opts.values['bUseSPB_NotRC']:\r\n                addOption('fRadiusTol')\r\n            else:\r\n                addOption('fRCCrvtrTol')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n        if Opts.values['bDebug']:\r\n            addOption('bAddRefs')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            oes = rd.ObjectEnumeratorSettings()\r\n            oes.NormalObjects = True\r\n            oes.LockedObjects = False\r\n            oes.IncludeLights = False\r\n            oes.IncludeGrips = False\r\n            oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n\r\n            rdBs = list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n            go.Dispose()\r\n\r\n            if len(rdBs) == 0: return\r\n\r\n            return rdBs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fAngleTol_Deg'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef groupObjrefsPerBrep_OLD(objrefs):\r\n    \"\"\" Returns nested list per Brep. \"\"\"\r\n    gBs = []\r\n    objrefs_PerB = []\r\n\r\n    for objref in objrefs:\r\n        if objref.ObjectId in gBs:\r\n            objrefs_PerB[gBs.index(objref.ObjectId)].append(objref)\r\n        else:\r\n            gBs.append(objref.ObjectId)\r\n            objrefs_PerB.append([objref])\r\n\r\n    return objrefs_PerB\r\n\r\n\r\ndef createSortedBrepsAndEdges_FromDocObjs(rdObjs, bIncludeMated):\r\n    \"\"\"\r\n    Parameters:\r\n        ObjRefs of Breps or Edges\r\n    Returns on success:\r\n        list(GUIDs of breps) and list(list(Edge indices) per brep)\r\n    \"\"\"\r\n\r\n    rdBs = []\r\n    gBs = []\r\n    idxEs = []\r\n\r\n   # Organize input into synchronized lists of brep ids and edge indices.\r\n    for rdObj in rdObjs:\r\n        if isinstance(rdObj, rd.BrepObject):\r\n            rdB = rdObj\r\n            gB = rdObj.Id\r\n            rgE = None\r\n            idxE = None\r\n        elif isinstance(rdObj, rd.ObjRef):\r\n            objref = rdObj\r\n            rdB = objref.Object()\r\n            gB = objref.ObjectId\r\n            if objref.GeometryComponentIndex.ComponentIndexType == rg.ComponentIndexType.InvalidType:\r\n                rgE = None\r\n                idxE = None\r\n            else:\r\n                rgE = objref.Edge()\r\n                idxE = rgE.EdgeIndex if rgE else None\r\n        else:\r\n            raise Exception(\"{} not valid input for createSortedBrepsAndEdges_FromDocObjs.\".format(\r\n                rdObj.GetType().Name))\r\n\r\n\r\n        rgB = rdB.BrepGeometry\r\n\r\n\r\n        if gB not in gBs:\r\n            # Brep not in list, so add it as well as objref's edge.\r\n            rdBs.append(rdB)\r\n            gBs.append(gB)\r\n            idxEs.append([])\r\n            iB = len(gBs) - 1\r\n        else:\r\n            # Brep already in list.\r\n            iB = gBs.index(gB)\r\n\r\n\r\n        # 4 states: idxE is None or int, bIncludeMated is True or False.\r\n\r\n        if (idxE is None) and bIncludeMated:\r\n            idxEs[iB] = range(rgB.Edges.Count)\r\n        elif (idxE is None) and not bIncludeMated:\r\n            for idxE in xrange(rgB.Edges.Count):\r\n                rgE = rgB.Edges[idxE]\r\n                if rgE.Valence == rg.EdgeAdjacency.Interior:\r\n                    continue\r\n                idxEs[iB].append(idxE)\r\n            if len(idxEs[iB]) == 0:\r\n                print(\"This brep has no valid edges.  Add code to handle this?\")\r\n        elif (idxE is not None) and bIncludeMated:\r\n            if idxE not in idxEs[iB]:\r\n                idxEs[iB].append(idxE)\r\n        elif (\r\n            (idxE is not None) and\r\n            (rgB.Edges[idxE].Valence == rg.EdgeAdjacency.Naked)\r\n            ):\r\n            if idxE not in idxEs[iB]:\r\n                idxEs[iB].append(idxE)\r\n\r\n    return rdBs, idxEs\r\n\r\n\r\ndef _continuityVectorsAtCurveParameter(nc, t, side=rg.CurveEvaluationSide.Default):\r\n    \"\"\"\r\n    Returns: Tuple of these 4 items:\r\n        3D point as a vector,\r\n        Unit tangent vector,\r\n        Curvature vector,\r\n        Vector for comparing G3 continuity, not the G3 vector itself\r\n        \r\n        None for any of aforementioned vectors on fail.\r\n    \"\"\"\r\n    \r\n    if not isinstance(nc, rg.NurbsCurve): return\r\n    \r\n    vs = nc.DerivativeAt(\r\n            t,\r\n            derivativeCount=3,\r\n            side=side)\r\n    \r\n    # Not using rg.Curve.TangentAt since it doesn't take into account CurveEvaluationSide.\r\n    vTangency = vs[1]/vs[1].Length\r\n    \r\n    cross = rg.Vector3d.CrossProduct\r\n    \r\n    # For R3\r\n    vCurvature = (\r\n        cross(cross(vs[1], vs[2]), vs[1])\r\n        /\r\n        vs[1].Length**4)\r\n\r\n    #sEval='vCurvature_A_Formula'; print(sEval+': ',eval(sEval)\r\n    #sc.doc.Objects.AddLine(rg.Line(start=rg.Point3d(vs[0]), span=vCurvature_A_Formula))\r\n\r\n    # For R2\r\n    #vCurvature_A = (\r\n    #            cross(vs[1], vs[2]) /\r\n    #            vs[1].Length**3)\r\n\r\n\r\n    # From Eq. 3.5 in CAN A CUBIC SPLINE CURVE BE G3\r\n    # in Journal of Computational Mathematics:\r\n    vG3_Condition = (\r\n        (\r\n            -3.0*(vs[1] * vs[2])*(cross(vs[1], vs[2]))\r\n            /\r\n            (vs[1] * vs[1])**3.0\r\n        )\r\n        +\r\n        cross(vs[1], vs[3]) / (vs[1] * vs[1])**2.0\r\n        )\r\n    \r\n    return vs[0], vTangency, vCurvature, vG3_Condition\r\n\r\n\r\ndef getGeometricDiscontinuities_MyTake(rgCrv_In, bG2_NotG1, fAngleTol_Deg, fRadiusTol, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    fAngleTol_Rad = Rhino.RhinoMath.ToRadians(fAngleTol_Deg)\r\n    if bDebug: print(\"fAngleTol_Rad: {}\".format(fAngleTol_Rad))\r\n\r\n    nc = rgCrv_In.ToNurbsCurve()\r\n\r\n    t0 = nc.Domain.T0\r\n    t1 = nc.Domain.T1\r\n\r\n    ts_discontinuities = []\r\n\r\n    bG3_discontinuousFound = False\r\n\r\n    # This will also skip simple knot overlaps of Periodic curves.\r\n    if nc.IsClosed and not nc.IsPeriodic:\r\n        iK = 0\r\n    else:\r\n        iK = nc.Degree\r\n    iK_Stop = nc.Knots.Count - nc.Degree\r\n\r\n    while iK < iK_Stop:\r\n        sc.escape_test()\r\n\r\n        m = nc.Knots.KnotMultiplicity(iK)\r\n\r\n        if m <= nc.Degree - 3:\r\n            # Continuity at this knot is at least G3.\r\n            iK += m\r\n            continue\r\n\r\n        if bDebug:\r\n            print('-'*20)\r\n            sEval='nc.Knots[iK]'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n        if iK == 0:\r\n            (\r\n                vG0_Below,\r\n                vG1_Below,\r\n                vG2_Below,\r\n                vG3_Below,\r\n                ) = _continuityVectorsAtCurveParameter(\r\n                    nc,\r\n                    nc.Knots[nc.Knots.Count - 1],\r\n                    rg.CurveEvaluationSide.Below)\r\n        else:\r\n            (\r\n                vG0_Below,\r\n                vG1_Below,\r\n                vG2_Below,\r\n                vG3_Below,\r\n                ) = _continuityVectorsAtCurveParameter(\r\n                    nc,\r\n                    nc.Knots[iK],\r\n                    rg.CurveEvaluationSide.Below)\r\n\r\n\r\n        (\r\n            vG0_Above,\r\n            vG1_Above,\r\n            vG2_Above,\r\n            vG3_Above,\r\n            ) = _continuityVectorsAtCurveParameter(\r\n                nc,\r\n                nc.Knots[iK],\r\n                rg.CurveEvaluationSide.Above)\r\n\r\n\r\n        if bDebug:\r\n            sEval='vG0_Below'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG0_Above'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG1_Below'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG1_Above'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG2_Below'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG2_Below.IsTiny()'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG2_Above'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG2_Above.IsTiny()'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG3_Below'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval='vG3_Above'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n        # G1.\r\n\r\n        if m > nc.Degree - 1:\r\n\r\n            iParallel = vG1_Below.IsParallelTo(\r\n                other=vG1_Above, angleTolerance=fAngleTol_Rad)\r\n\r\n            fTanDelta_Degrees = Rhino.RhinoMath.ToDegrees(\r\n                rg.Vector3d.VectorAngle(vG1_Below, vG1_Above))\r\n\r\n            if iParallel == 1:\r\n                if bDebug:\r\n                    print(\"Are G1 with tangent vector difference of {:.2f} degrees.\".format(\r\n                        fTanDelta_Degrees))\r\n            else:\r\n                print(\"Not G1 at {} per tangent vector difference of {:.2f} degrees.\".format(\r\n                    nc.Knots[iK],\r\n                    fTanDelta_Degrees))\r\n                ts_discontinuities.append(nc.Knots[iK])\r\n                iK += m\r\n                continue\r\n\r\n        if not bG2_NotG1:\r\n            # If only checking G1.\r\n            iK += m\r\n            continue\r\n\r\n        #sc.doc.Objects.AddLine(rg.Line(rg.Point3d(vG0_Below), vG1_Below))\r\n        #sc.doc.Objects.AddLine(rg.Line(rg.Point3d(vG0_Above), vG1_Above))\r\n\r\n\r\n\r\n        # G2.\r\n\r\n        if m > nc.Degree - 2:\r\n\r\n            if vG2_Below.IsTiny() and vG2_Above.IsTiny():\r\n                # Linear.\r\n                pass\r\n            else:\r\n\r\n                iParallel = vG2_Below.IsParallelTo(\r\n                    other=vG2_Above, angleTolerance=fAngleTol_Rad)\r\n\r\n                if bDebug: sEval='iParallel'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n                fCrvDelta_Degrees = Rhino.RhinoMath.ToDegrees(\r\n                    rg.Vector3d.VectorAngle(vG2_Below, vG2_Above))\r\n\r\n                if iParallel != 1:\r\n                    if bDebug:\r\n                        print(\"Not G2 at {} per curvature vector difference of {:.2f} degrees.\".format(\r\n                            nc.Knots[iK],\r\n                            fCrvDelta_Degrees))\r\n                    ts_discontinuities.append(nc.Knots[iK])\r\n                    iK += m\r\n                    continue\r\n                else:\r\n                    kappa_Below = vG2_Below.Length\r\n                    kappa_Above = vG2_Above.Length\r\n                    ratio_of_curvature = (abs(kappa_Below-kappa_Above) /\r\n                                        max(kappa_Below, kappa_Above))\r\n                    if bDebug:\r\n                        print(\"Ratio of curvature: {:.2f} % \".format(100.0*ratio_of_curvature))\r\n                    delta_radius = abs(1.0/kappa_Below-1.0/kappa_Above)\r\n                    #if ratio_of_curvature > 0.02:\r\n                    if delta_radius > fRadiusTol:\r\n                        #print(\"Not G2 at {} per relative difference of curvature vector magnitudes being {:.2f} %.  (2% is the tolerance.)\".format(\r\n                        #    nc.Knots[iK],\r\n                        #    100.0*ratio_of_curvature))\r\n                        if bDebug:\r\n                            print(\"{:.{}f} radius difference.\".format((\r\n                                delta_radius, sc.doc.ModelDistanceDisplayPrecision)))\r\n                        ts_discontinuities.append(nc.Knots[iK])\r\n                        iK += m\r\n                        continue\r\n                    else:\r\n                        if bDebug: print(\"Are G2.\")\r\n\r\n                    #sc.doc.Objects.AddLine(rg.Line(rg.Point3d(vG0_Below), vG2_Below))\r\n                    #sc.doc.Objects.AddLine(rg.Line(rg.Point3d(vG0_Above), vG2_Above))\r\n\r\n\r\n\r\n        # G3.\r\n\r\n        if bG3_discontinuousFound:\r\n            iK += m\r\n            continue\r\n\r\n        iParallel = vG3_Below.IsParallelTo(\r\n            other=vG3_Above, angleTolerance=Rhino.RhinoMath.ToRadians(1.0))\r\n        fG3Delta_Degrees = Rhino.RhinoMath.ToDegrees(\r\n            rg.Vector3d.VectorAngle(vG3_Below, vG3_Above))\r\n        if iParallel == 1:\r\n            if bDebug:\r\n                print(\"Are G3 with G3 component vector difference of {:.2f} degrees.\".format(\r\n                    fG3Delta_Degrees))\r\n        else:\r\n            bG3_discontinuousFound = True\r\n            if bDebug:\r\n                print(\"Not G3 at {} per G3 component vector difference of {:.2f} degrees.\".format(\r\n                    nc.Knots[iK],\r\n                    fG3Delta_Degrees))\r\n    #            sc.doc.Objects.AddPoint(rg.Point3d(vG0_Below))\r\n    #            #ts_discontinuities.append(nc.Knots[iK])\r\n\r\n\r\n        iK += m\r\n\r\n    nc.Dispose()\r\n\r\n    return ts_discontinuities\r\n\r\n\r\ndef getGeometricDiscontinuities_UsingRhinoCommonMethod(rgCrv, bG2_NotG1=True, fAngleTol_Deg=None, fRCCrvtrTol=Rhino.RhinoMath.SqrtEpsilon):\r\n    \"\"\"\r\n    Returns: list(float(parameters of discontinuities))\r\n    \"\"\"\r\n\r\n    if fAngleTol_Deg is None: fAngleTol_Deg = sc.doc.ModelAngleToleranceDegrees\r\n\r\n    cosAngleTolerance = Math.Cos(Rhino.RhinoMath.ToRadians(fAngleTol_Deg))\r\n\r\n    curvatureTolerance = fRCCrvtrTol\r\n\r\n    t0 = rgCrv.Domain.Min\r\n    t1 = rgCrv.Domain.Max\r\n\r\n    if rgCrv.IsClosed:\r\n        if bG2_NotG1:\r\n            continuityType = rg.Continuity.G2_locus_continuous\r\n        else:\r\n            continuityType = rg.Continuity.G1_locus_continuous\r\n    else:\r\n        if bG2_NotG1:\r\n            continuityType = rg.Continuity.G2_continuous\r\n        else:\r\n            continuityType = rg.Continuity.G1_continuous\r\n\r\n    ts = []\r\n\r\n    get_next = True\r\n\r\n    while get_next:\r\n        sc.escape_test()\r\n\r\n        get_next, t = rg.Curve.GetNextDiscontinuity(\r\n            rgCrv,\r\n            continuityType,\r\n            t0,\r\n            t1,\r\n            cosAngleTolerance,\r\n            curvatureTolerance)\r\n\r\n        if get_next:\r\n            ts.append(t)\r\n            t0 = t # Advance to the next parameter.\r\n\r\n    return ts\r\n\r\n\r\ndef processDocObjs(rdObjs, **kwargs):\r\n    \"\"\"\r\n    rdObjs: rd.BrepObjects or rd.ObjRefs\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fAngleTol_Deg = getOpt('fAngleTol_Deg')\r\n    bG2_NotG1 = getOpt('bG2_NotG1')\r\n    bUseSPB_NotRC = getOpt('bUseSPB_NotRC')\r\n    fRadiusTol = getOpt('fRadiusTol')\r\n    fRCCrvtrTol = getOpt('fRCCrvtrTol')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n    bAddRefs = getOpt('bAddRefs')\r\n\r\n\r\n\r\n    rc = createSortedBrepsAndEdges_FromDocObjs(rdObjs, Opts.values['bIncludeMated'])\r\n    if rc is None: return\r\n\r\n    rdBs, idxEs_PerB = rc\r\n\r\n    iCt_EdgeIncr = 0\r\n    iCt_Breps_Mod = 0\r\n\r\n    #objrefs_per_B = groupObjrefsPerBrep_OLD(objrefs)\r\n\r\n    #for objrefs_same_B in objrefs_per_B:\r\n\r\n    #    edges_In_SameB = [o.Edge() for o in objrefs_same_B]\r\n    #    idxs_Es = [e.EdgeIndex for e in edges_In_SameB]\r\n\r\n    #    # Sort in reverse EdgeIndex order.\r\n    #    edges_In_SameB = [e for i,e in sorted(zip(idxs_Es, edges_In_SameB), reverse=True)]\r\n\r\n    #    rgB_Start = edges_In_SameB[0].Brep\r\n\r\n    #    rgB_WIP = rgB_Start.DuplicateBrep()\r\n\r\n    #    edge_count_Start = rgB_WIP.Edges.Count\r\n\r\n    #    for edge in edges_In_SameB:\r\n\r\n    #        crv_Start = edge.DuplicateCurve()\r\n\r\n    #        if bG2_NotG1 and bUseSPB_NotRC:\r\n    #            ts = getGeometricDiscontinuities_MyTake(\r\n    #                crv_Start, bG2_NotG1, fAngleTol_Deg, fRadiusTol, bDebug)\r\n    #        else:\r\n    #            ts = getGeometricDiscontinuities_UsingRhinoCommonMethod(\r\n    #                crv_Start, bG2_NotG1, fAngleTol_Deg, fRCCrvtrTol)\r\n\r\n    #        rgB_WIP.Edges.SplitEdgeAtParameters(\r\n    #            edgeIndex=edge.EdgeIndex,\r\n    #            edgeParameters=ts)\r\n\r\n    #    rgB_WIP.Compact()\r\n\r\n    #    if rgB_WIP.Edges.Count != edge_count_Start:\r\n    #        iCt_EdgeIncr += rgB_WIP.Edges.Count - edge_count_Start\r\n\r\n    #        bReplaced = sc.doc.Objects.Replace(\r\n    #            objectId=objrefs_same_B[0].ObjectId,\r\n    #            brep=rgB_WIP)\r\n\r\n    #        iCt_Breps_Mod += 1\r\n\r\n\r\n\r\n    for rdB, idxEs in zip(rdBs, idxEs_PerB):\r\n\r\n        rgB_WIP = rdB.BrepGeometry.DuplicateBrep()\r\n\r\n        edge_count_Start = rgB_WIP.Edges.Count\r\n\r\n        for idxE in idxEs:\r\n\r\n            edge = rgB_WIP.Edges[idxE]\r\n\r\n            crv_Start = edge.DuplicateCurve()\r\n\r\n            if bG2_NotG1 and bUseSPB_NotRC:\r\n                ts = getGeometricDiscontinuities_MyTake(\r\n                    crv_Start, bG2_NotG1, fAngleTol_Deg, fRadiusTol, bDebug)\r\n            else:\r\n                ts = getGeometricDiscontinuities_UsingRhinoCommonMethod(\r\n                    crv_Start, bG2_NotG1, fAngleTol_Deg, fRCCrvtrTol)\r\n\r\n            rgB_WIP.Edges.SplitEdgeAtParameters(\r\n                edgeIndex=edge.EdgeIndex,\r\n                edgeParameters=ts)\r\n\r\n        rgB_WIP.Compact()\r\n\r\n        if rgB_WIP.Edges.Count != edge_count_Start:\r\n            iCt_EdgeIncr += rgB_WIP.Edges.Count - edge_count_Start\r\n\r\n            bReplaced = sc.doc.Objects.Replace(\r\n                objectId=rdB.Id,\r\n                brep=rgB_WIP)\r\n\r\n            iCt_Breps_Mod += 1\r\n\r\n    if iCt_EdgeIncr == 0:\r\n        print(\"No edges were split.\")\r\n    else:\r\n        print(\"Edge count of {} breps increased by {}.\".format(\r\n            iCt_Breps_Mod, iCt_EdgeIncr))\r\n\r\n\r\ndef main():\r\n\r\n    rdObjs = getInput()\r\n    if rdObjs is None: return\r\n\r\n    fAngleTol_Deg = Opts.values['fAngleTol_Deg']\r\n    bG2_NotG1 = Opts.values['bG2_NotG1']\r\n    bUseSPB_NotRC = Opts.values['bUseSPB_NotRC']\r\n    fRadiusTol = Opts.values['fRadiusTol']\r\n    fRCCrvtrTol = Opts.values['fRCCrvtrTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n    bAddRefs = Opts.values['bAddRefs']\r\n\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    gBrep_Ret = processDocObjs(\r\n        rdObjs,\r\n        fAngleTol_Deg=fAngleTol_Deg,\r\n        bG2_NotG1=bG2_NotG1,\r\n        bUseSPB_NotRC=bUseSPB_NotRC,\r\n        fRadiusTol=fRadiusTol,\r\n        fRCCrvtrTol=fRCCrvtrTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        bAddRefs=bAddRefs,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}