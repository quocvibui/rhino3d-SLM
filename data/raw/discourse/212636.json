{
  "source_url": "https://discourse.mcneel.com/t/embeddingrhinoview-in-wpf-problem/212636",
  "topic_id": 212636,
  "title": "EmbeddingRhinoView in WPF Problem",
  "question": "Hi Everyone,\n\n\nI am developing a RhinoCommon plugin where I need to embed a \nfully interactive native Rhino Viewport\n into a WPF window (using \nHwndHost\n).\n\n\nI cannot use \nRhino.UI.Controls.ViewportControl\n because I need full native navigation behavior, context menus, and standard object interaction, which the lightweight control lacks.\n\n\nMy Approach:\n\n\n\n\n\n\nCreate a new view using \nRhinoDoc.ActiveDoc.Views.Add(...)\n.\n\n\n\n\n\n\nUse P/Invoke \nSetParent\n to re-parent the native Rhino View handle into a WPF \nHwndHost\n.\n\n\n\n\n\n\nStrip the window styles (\nWS_CAPTION\n, \nWS_THICKFRAME\n, etc.) to make it look like a control.\n\n\n\n\n\n\nThe Problem:\n\nThe embedding works perfectly (rendering and interaction are fine). However, \ndestroying the WPF window\n causes severe stability issues:\n\n\n\n\n\n\nBlack Screen on New File:\n After closing the WPF window (and the embedded view), if I open a new file or create a new document, all Rhino viewports turn completely \nblack\n. It seems the OpenGL/Display Pipeline context is corrupted or lost.\n\n\n\n\n\n\nProcess Deadlock:\n Often, Rhino cannot be closed normally after this operation and must be terminated via Task Manager.\n\n\n\n\n\n\nWhat I have tried (but failed):\n\nI implemented a “Safe Cleanup” logic in the \nDestroyWindowCore\n of the \nHwndHost\n:\n\n\n\n\n\n\nDeactivate View:\n Switched \nActiveView\n to a different safe viewport and forced \nRedraw()\n.\n\n\n\n\n\n\nReparenting:\n Before calling \nClose()\n, I used \nSetParent\n to move the view handle back to its original parent (or the main Rhino window) to detach it from WPF.\n\n\n\n\n\n\nDeferred Close:\n I used \nRhinoApp.Idle\n to delay the \nRhinoView.Close()\n call to avoid conflict with the WPF destruction cycle.\n\n\n\n\n\n\nDespite these efforts, the display pipeline still breaks (Black Screen) upon loading a new document.\n\n\nusing System;\nusing System.Runtime.InteropServices;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.Display;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\nusing Rhino.UI;\nusing Sy...",
  "code_blocks": [
    {
      "code": "using System;\nusing System.Runtime.InteropServices;\nusing Rhino;\nusing Rhino.Commands;\nusing Rhino.Display;\nusing Rhino.DocObjects;\nusing Rhino.Geometry;\nusing Rhino.Input;\nusing Rhino.Input.Custom;\nusing Rhino.UI;\nusing System.Windows;\nusing System.Windows.Interop;\nusing System.Windows.Controls;\nusing System.Windows.Media;\nusing Label = System.Windows.Controls.Label;\n\nnamespace Test\n{\n    public class TestWpfEmbeddedView : Command\n    {\n        public override string EnglishName => \"TestWpfEmbeddedView\";\n\n        protected override Result RunCommand(RhinoDoc doc, RunMode mode)\n        {\n            var wpfWindow = new MyWpfWindow();\n       \n            new System.Windows.Interop.WindowInteropHelper(wpfWindow).Owner = RhinoApp.MainWindowHandle();\n            wpfWindow.Show();\n            return Result.Success;\n        }\n    }\n\n    public class MyWpfWindow : System.Windows.Window\n    {\n        private RhinoViewportHost _rhinoHost;\n\n        private SimplePreviewConduit _conduit;\n\n        private ViewportInteraction _mouseHandler;\n\n        private Brep _sphere;\n\n        private void InitLayout()\n        {\n            var grid = new Grid();\n            grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(30) });\n            grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(1, GridUnitType.Star) });\n\n            var label = new Label { Content = \"WPF Window\", HorizontalAlignment = System.Windows.HorizontalAlignment.Center };\n            Grid.SetRow(label, 0);\n            grid.Children.Add(label);\n\n            _rhinoHost = new RhinoViewportHost();\n            Grid.SetRow(_rhinoHost, 1);\n            grid.Children.Add(_rhinoHost);\n\n            this.Content = grid;\n        }\n\n        private void OnWindowLoaded(object sender, RoutedEventArgs e)\n        {\n            if (_rhinoHost.RhinoView != null)\n            {\n                var viewId = _rhinoHost.RhinoView.ActiveViewportID;\n                _conduit.TargetViewportId = viewId;\n                _rhinoHost.RhinoView.ActiveViewport.ZoomBoundingBox(_conduit.ContentBoundingBox);\n                _rhinoHost.RhinoView.Redraw();\n\n                _mouseHandler = new ViewportInteraction(viewId, _sphere, _conduit);\n                _mouseHandler.Enabled = true;\n            }\n        }\n\n        private void OnWindowClosed(object sender, EventArgs e)\n        {\n            _conduit.Enabled = false;\n            if (_mouseHandler != null) _mouseHandler.Enabled = false;\n        }\n\n        public MyWpfWindow()\n        {\n            Title = \"WPF Embed Fixed\";\n            Width = 800;\n            Height = 600;\n            WindowStartupLocation = WindowStartupLocation.CenterOwner;\n\n            _sphere = new Sphere(Point3d.Origin, 15).ToBrep();\n            _conduit = new SimplePreviewConduit(_sphere, System.Drawing.Color.Red);\n            _conduit.Enabled = true;\n\n            InitLayout();\n\n            this.Loaded += OnWindowLoaded;\n            this.Closed += OnWindowClosed;\n        }\n    }\n\n    public class RhinoViewportHost : HwndHost\n    {\n        private const int GWL_STYLE = -16;\n\n        private const int WS_CHILD = 0x40000000;\n\n        private const int WS_VISIBLE = 0x10000000;\n\n        private const int WS_CAPTION = 0xC00000;\n\n        private const int WS_THICKFRAME = 0x40000;\n\n        private const int WS_POPUP = unchecked((int)0x80000000);\n\n        private const int SW_HIDE = 0;\n\n        private const uint SWP_FRAMECHANGED = 0x0020;\n\n        private const uint SWP_NOMOVE = 0x0002;\n\n        private const uint SWP_NOSIZE = 0x0001;\n\n        private const uint SWP_NOZORDER = 0x0004;\n\n        private const uint SWP_SHOWWINDOW = 0x0040;\n\n        private IntPtr _originalParent = IntPtr.Zero;\n\n        private bool _isClosing = false;\n\n        public RhinoView RhinoView { get; private set; }\n\n        protected override HandleRef BuildWindowCore(HandleRef hwndParent)\n        {\n            string viewName = \"Embedded_\" + Guid.NewGuid().ToString();\n            var bounds = new System.Drawing.Rectangle(0, 0, 100, 100);\n            RhinoView = RhinoDoc.ActiveDoc.Views.Add(viewName, DefinedViewportProjection.Perspective, bounds, true);\n\n            if (RhinoView == null) throw new Exception(\"Create View Failed\");\n            IntPtr viewHandle = RhinoView.Handle;\n\n            _originalParent = GetParent(viewHandle);\n            if (_originalParent != IntPtr.Zero) ShowWindow(_originalParent, SW_HIDE);\n\n            int style = GetWindowLong(viewHandle, GWL_STYLE);\n            style = (style & ~WS_POPUP & ~WS_CAPTION & ~WS_THICKFRAME) | WS_CHILD | WS_VISIBLE;\n            SetWindowLong(viewHandle, GWL_STYLE, style);\n\n            SetParent(viewHandle, hwndParent.Handle);\n            SetWindowPos(viewHandle, IntPtr.Zero, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW);\n\n            RhinoView.ActiveViewport.DisplayMode = DisplayModeDescription.FindByName(\"Shaded\");\n            return new HandleRef(this, viewHandle);\n        }\n\n        protected override void DestroyWindowCore(HandleRef hwnd)\n        {\n            SafeDestroy();\n        }\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        private static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);\n\n        [DllImport(\"user32.dll\")]\n        private static extern IntPtr GetParent(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n\n        [DllImport(\"user32.dll\")]\n        private static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);\n\n        [DllImport(\"user32.dll\")]\n        private static extern int GetWindowLong(IntPtr hWnd, int nIndex);\n\n        [DllImport(\"user32.dll\")]\n        private static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);\n\n        private void SafeDestroy()\n        {\n            if (RhinoView == null || _isClosing) return;\n            _isClosing = true;\n\n            try\n            {\n                var doc = RhinoDoc.ActiveDoc;\n                var viewToClose = RhinoView;\n\n                if (doc.Views.ActiveView.ActiveViewportID == viewToClose.ActiveViewportID)\n                {\n                    var safeView = System.Linq.Enumerable.FirstOrDefault(doc.Views, v => v.ActiveViewportID != viewToClose.ActiveViewportID);\n                    if (safeView != null)\n                    {\n                        doc.Views.ActiveView = safeView;\n                    }\n\n                    doc.Views.Redraw();\n                    RhinoApp.Wait();\n                }\n\n                if (_originalParent != IntPtr.Zero)\n                {\n                    SetParent(viewToClose.Handle, _originalParent);\n                }\n                else\n                {\n                    SetParent(viewToClose.Handle, RhinoApp.MainWindowHandle());\n                }\n\n                RhinoApp.Idle += OnIdleCloseView;\n            }\n            catch (Exception ex)\n            {\n                RhinoApp.WriteLine($\"SafeDestroy Error: {ex.Message}\");\n            }\n        }\n\n        private void OnIdleCloseView(object sender, EventArgs e)\n        {\n            RhinoApp.Idle -= OnIdleCloseView;\n\n            try\n            {\n                if (RhinoView != null)\n                {\n                    RhinoView.Close();\n                }\n\n                RhinoDoc.ActiveDoc?.Views.Redraw();\n            }\n            catch\n            {\n            }\n            finally\n            {\n                RhinoView = null;\n                _originalParent = IntPtr.Zero;\n            }\n        }\n    }\n\n    public class ViewportInteraction : Rhino.UI.MouseCallback\n    {\n        private readonly Guid _targetViewportId;\n\n        private readonly Brep _targetGeometry;\n\n        private readonly SimplePreviewConduit _conduit;\n\n        protected override void OnMouseDown(Rhino.UI.MouseCallbackEventArgs e)\n        {\n            if (e.View.ActiveViewportID != _targetViewportId) return;\n            if (e.Button != System.Windows.Forms.MouseButtons.Left) return;\n\n            var line = e.View.ActiveViewport.ClientToWorld(e.ViewportPoint);\n            var intersection = Rhino.Geometry.Intersect.Intersection.RayShoot(\n                new Ray3d(line.From, line.Direction), new[] { _targetGeometry }, 1\n            );\n\n            if (intersection != null && intersection.Length > 0)\n            {\n                _conduit.Highlight = !_conduit.Highlight;\n                e.View.Redraw();\n            }\n        }\n\n        public ViewportInteraction(Guid viewId, Brep geo, SimplePreviewConduit conduit)\n        {\n            _targetViewportId = viewId;\n            _targetGeometry = geo;\n            _conduit = conduit;\n        }\n    }\n\n    public class SimplePreviewConduit : Rhino.Display.DisplayConduit\n    {\n        private readonly Brep _geometry;\n\n        private readonly DisplayMaterial _normalMat;\n\n        private readonly DisplayMaterial _highlightMat;\n\n        public bool Highlight { get; set; } = false;\n\n        public Guid TargetViewportId { get; set; } = Guid.Empty;\n\n        public BoundingBox ContentBoundingBox => _geometry.GetBoundingBox(true);\n\n        protected override void ObjectCulling(CullObjectEventArgs e)\n        {\n            if (TargetViewportId != Guid.Empty && e.Viewport.Id != TargetViewportId) { base.ObjectCulling(e); return; }\n            if (e.RhinoObject != null) e.CullObject = true;\n        }\n\n        protected override void PostDrawObjects(DrawEventArgs e)\n        {\n            if (TargetViewportId != Guid.Empty && e.Viewport.Id != TargetViewportId) return;\n            var mat = Highlight ? _highlightMat : _normalMat;\n            e.Display.DrawBrepShaded(_geometry, mat);\n            e.Display.DrawBrepWires(_geometry, System.Drawing.Color.Black, 1);\n        }\n\n        protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)\n        {\n            if (TargetViewportId != Guid.Empty && e.Viewport.Id != TargetViewportId) return;\n            e.IncludeBoundingBox(ContentBoundingBox);\n        }\n\n        public SimplePreviewConduit(Brep geometry, System.Drawing.Color color)\n        {\n            _geometry = geometry;\n            _normalMat = new DisplayMaterial(color);\n            _highlightMat = new DisplayMaterial(System.Drawing.Color.Yellow);\n        }\n    }\n}",
      "language": "csharp",
      "author": "yangf85",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "materials",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 3,
  "posts_count": 1,
  "views": 37
}