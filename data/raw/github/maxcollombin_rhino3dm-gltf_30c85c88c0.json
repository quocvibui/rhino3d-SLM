{
  "source_url": "https://github.com/maxcollombin/rhino3dm-gltf/blob/99c024d44323eaede67c6c09845ac8ddb9318981/scripts/exportRhinoLocalRef2CityJSONFME.py",
  "repo": "maxcollombin/rhino3dm-gltf",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "scripts/exportRhinoLocalRef2CityJSONFME.py",
  "instruction": "Export rhino local ref2city jsonfme",
  "code": "import os\nimport json\nimport uuid\nimport rhino3dm\nimport numpy as np\nfrom sklearn.decomposition import PCA\n\n# ------------------------------\n# 1. Fichiers\n# ------------------------------\ninput_file = \"./R21_3d.3dm\"\noutput_cityjson = \"./output/NouveauxBatiments_FME.city.json\"\n\n# ------------------------------\n# 2. Charger le modèle\n# ------------------------------\nmodel = rhino3dm.File3dm.Read(input_file)\nif not model:\n    raise ValueError(f\"Erreur : Impossible de charger {input_file}\")\nprint(f\" Modèle chargé : {input_file}\")\n\n# ------------------------------\n# 3. Fonctions utilitaires\n# ------------------------------\ndef remove_consecutive_duplicates(ring):\n    if len(ring) < 3: return []\n    cleaned = []\n    for i, vertex in enumerate(ring):\n        next_vertex = ring[(i + 1) % len(ring)]\n        if vertex != next_vertex:\n            cleaned.append(vertex)\n    if len(cleaned) >= 3 and cleaned[0] == cleaned[-1]:\n        cleaned = cleaned[:-1]\n    return cleaned if len(cleaned) >= 3 else []\n\ndef validate_face(ring):\n    if len(ring) < 3: return False\n    for i in range(len(ring)):\n        if ring[i] == ring[(i + 1) % len(ring)]:\n            return False\n    return True\n\ndef project_to_plane(vertices_coords):\n    if len(vertices_coords) < 4: return vertices_coords\n    points = np.array(vertices_coords)\n    centroid = np.mean(points, axis=0)\n    centered = points - centroid\n    pca = PCA(n_components=3)\n    pca.fit(centered)\n    normal = pca.components_[2]\n    projected_centered = centered - np.outer(np.dot(centered, normal), normal)\n    return (projected_centered + centroid).tolist()\n\ndef convert_to_mesh(geometry):\n    if isinstance(geometry, rhino3dm.Mesh):\n        return geometry\n    if isinstance(geometry, rhino3dm.Extrusion):\n        for mesh_type in (rhino3dm.MeshType.Render, rhino3dm.MeshType.Default):\n            mesh = geometry.GetMesh(mesh_type)\n            if mesh and len(mesh.Vertices) and len(mesh.Faces):\n                mesh.Normals.ComputeNormals()\n                mesh.Compact()\n                return mesh\n        brep = geometry.ToBrep(True) or geometry.ToBrep(False)\n        if brep:\n            return convert_to_mesh(brep)\n        return None\n    if isinstance(geometry, rhino3dm.Brep):\n        meshes = []\n        for face in geometry.Faces:\n            mesh = face.GetMesh(rhino3dm.MeshType.Default)\n            if mesh and len(mesh.Vertices) and len(mesh.Faces):\n                meshes.append(mesh)\n        if meshes:\n            combined = rhino3dm.Mesh()\n            for m in meshes:\n                combined.Append(m)\n            combined.Normals.ComputeNormals()\n            combined.Compact()\n            return combined\n    return None\n\ndef classify_surface(vertices_coords):\n    points = np.array(vertices_coords)\n    if len(points) < 3: return \"UndefinedSurface\"\n    centroid = np.mean(points, axis=0)\n    centered_points = points - centroid\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    normal = pca.components_[2]\n    z_axis = np.array([0,0,1])\n    vertical = np.abs(np.dot(normal, z_axis)) < 0.5\n    horizontal = np.abs(np.dot(normal, z_axis)) > 0.9\n    if horizontal:\n        z_mean = np.mean(points[:,2])\n        return \"GroundSurface\" if z_mean < centroid[2] else \"RoofSurface\"\n    elif vertical:\n        return \"WallSurface\"\n    else:\n        return \"ClosureSurface\"\n\n# ------------------------------\n# 4. Collecte des bâtiments\n# ------------------------------\nvertices_global = []\nvertex_index_map = {}\n\ndef add_vertex(v):\n    key = (round(v.X,6), round(v.Y,6), round(v.Z,6))\n    if key in vertex_index_map:\n        return vertex_index_map[key]\n    idx = len(vertices_global)\n    vertices_global.append([v.X, v.Y, v.Z])\n    vertex_index_map[key] = idx\n    return idx\n\nbuildings = {}\nfor obj in model.Objects:\n    layer = model.Layers[obj.Attributes.LayerIndex]\n    full_path = layer.FullPath\n    if not full_path.startswith(\"Bâtiments Nouveaux\"): continue\n    if \"EXISTANT\" in full_path or \"DEMOLITION\" in full_path: continue\n    parts = full_path.split(\"::\")\n    if len(parts) < 5: continue\n    building_name = parts[-1]\n    mesh = convert_to_mesh(obj.Geometry)\n    if mesh:\n        buildings.setdefault(building_name, []).append(mesh)\n\nprint(f\" {len(buildings)} bâtiments détectés.\")\n\n# ------------------------------\n# 5. Construction CityJSON FME-ready\n# ------------------------------\ncityobjects = {}\n\nfor building_name, meshes in buildings.items():\n    building_uuid = str(uuid.uuid4())\n    all_shells = []\n    semantics_values = []\n    semantics_faces = []\n\n    for mesh in meshes:\n        mesh.Normals.ComputeNormals()\n        for face in mesh.Faces:\n            face_vertices = list(face) if len(face)==4 else list(face[:3])\n            ring = [add_vertex(mesh.Vertices[j]) for j in face_vertices]\n            cleaned = remove_consecutive_duplicates(ring)\n            if not validate_face(cleaned): continue\n            coords = [vertices_global[idx] for idx in cleaned]\n            projected = project_to_plane(coords)\n\n            # Classification\n            v1,v2,v3 = np.array(projected[:3])\n            normal = np.cross(v2-v1, v3-v1)\n            normal /= (np.linalg.norm(normal)+1e-9)\n            nz = normal[2]\n            face_type = \"RoofSurface\" if nz>0.9 else (\"GroundSurface\" if nz<-0.9 else \"WallSurface\")\n\n            semantics_values.append(face_type)\n            semantics_faces.append(len(all_shells))\n\n            all_shells.append([[add_vertex(rhino3dm.Point3d(*c)) for c in projected]])\n\n    if all_shells:\n        cityobjects[building_uuid] = {\n            \"type\": \"Building\",\n            \"attributes\": {\"buildingID\": building_name},\n            \"geometry\": [{\n                \"type\": \"MultiSurface\",\n                \"lod\": 2.0,\n                \"boundaries\": all_shells,\n                \"semantics\": {\n                    \"surfaces\":[{\"type\":s} for s in semantics_values],\n                    \"values\": semantics_faces\n                }\n            }]\n        }\n\n# ------------------------------\n# 6. Écriture CityJSON\n# ------------------------------\nscale = [1.0,1.0,1.0]\ntranslate = [2592980.685,1119281.703,0.0]\n\nxs, ys, zs = zip(*vertices_global)\nxs_t = [x*scale[0]+translate[0] for x in xs]\nys_t = [y*scale[1]+translate[1] for y in ys]\nzs_t = [z*scale[2]+translate[2] for z in zs]\ngeographical_extent = [min(xs_t), min(ys_t), min(zs_t), max(xs_t), max(ys_t), max(zs_t)]\n\ncityjson = {\n    \"type\": \"CityJSON\",\n    \"version\": \"2.0\",\n    \"CityObjects\": cityobjects,\n    \"vertices\": vertices_global,\n    \"metadata\": {\n        \"referenceSystem\": \"EPSG:2056\",\n        \"geographicalExtent\": geographical_extent,\n        \"presentLoDs\": [2.0],\n        \"datasetTitle\": \"Nouveaux bâtiments exportés depuis Rhino3dm pour FME\"\n    },\n    \"transform\": {\"scale\": scale, \"translate\": translate}\n}\n\nos.makedirs(os.path.dirname(output_cityjson), exist_ok=True)\nwith open(output_cityjson,\"w\",encoding=\"utf-8\") as f:\n    json.dump(cityjson,f,indent=2)\n\nprint(f\" CityJSON FME-ready exporté avec {len(cityobjects)} bâtiments et {len(vertices_global)} sommets.\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}