{
  "source_url": "https://github.com/McoVale/TSAgriPV/blob/706b3ff31447356205fa650c6b0afbf771c9f599/source_py/Rhino/rhino_geom.py",
  "repo": "McoVale/TSAgriPV",
  "repo_stars": 1,
  "repo_description": "Data process from crop orientation and PVP geometry to electrical production and agricultural yield.",
  "license": "GPL-3.0",
  "filepath": "source_py/Rhino/rhino_geom.py",
  "instruction": "Rhino geom",
  "code": "from __future__ import division\n\nimport array\nimport math\nimport os\nimport shutil\nimport numpy as np\nimport pandas as pd\n\n\nimport rhinoinside\nrhinoinside.load()\n\nimport clr\nclr.AddReference(\"Grasshopper\")\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path as Path\nimport System\nimport Rhino.Geometry as rg\nfrom Rhino.Geometry import Point3d, Vector3d, Transform\nfrom honeybee.model import Model\nfrom honeybee.face import Face\nfrom ladybug_geometry.geometry3d.face import Face3D\nfrom ladybug_geometry.geometry3d.mesh import Mesh3D\nfrom ladybug_geometry.geometry3d.plane import Plane\nfrom ladybug_rhino.togeometry import to_mesh3d, to_face3d, to_vector3d\nfrom honeybee_radiance.sensorgrid import SensorGrid\nfrom honeybee.typing import clean_and_id_string\nfrom lbt_recipes.settings import RecipeSettings\n\nfrom .rhino_func import longest_list, to_gridded_mesh3d_perso\nfrom .rhino_irr import annual_irradiance\n\nfrom lbt_recipes.version import check_radiance_date\n# check the installed Radiance date and get the path to the gemdaymtx executable\ncheck_radiance_date()\n\ndef create_surface(x, y, width, length):\n    \"\"\"\n    Create a simple NURBS Rhino Surface from one of its four corners and its dimensions (width, length).\n\n    Args:\n        x (float): X-coordinate of origin corner\n        y (float): Y-coordinate of origin corner\n        width (float): Width of the surface\n        length (float): Length of the surface\n\n    Returns:\n        surface : Rhino.Geometry.NurbsSurface, the created surface\n    \"\"\"\n    pt1 = rg.Point3d(x, y, 0)\n    pt2 = rg.Point3d(x, y + width, 0)\n    pt3 = rg.Point3d(x + length, y + width, 0)\n    pt4 = rg.Point3d(x + length, y, 0)\n    \n    # Create a surface from the previous point list, and return it\n    surface = rg.NurbsSurface.CreateFromCorners(pt1, pt2, pt3, pt4)\n\n    return surface\n\ndef create_panel_grid(grid_size, nb_rangs, nb_pvp_rangs, width, length, height, column_spacing, row_spacing, angle_orientation, angle_variable, semi_transp=False, bande=None, void_space=None):\n    \"\"\"\n    According to the parameters, creates a grid of surfaces, later converted into Breps, representing the solar panels.\n\n    Args:\n        grid_size (float): Total size of the panel grid for simulation (can and will differ from the actual solar panel field)\n        nb_rangs (int): Number of PVP per row\n        nb_pvp_rangs (int): Number of rows\n        width (float): Width of a PVP\n        length (float): Length of a PVP\n        column_spacing (float): Distance between two PVP rows (forced value (= ENTRAXE))\n        row_spacing (float): Distance between two PVPs inside a row (can be equals to 0, forced value (=grid_size/nb_rangs))\n        angle_orientation (int): Difference between the field axis (PVP supports' axis) and the North-South axis\n        angle_variable (int): Tilt of the PVPs\n        semi_transp (bool): False = classic PV Panel, one surface\n                            True = Semi-transparent PV panel, composed of 4 strips of PV cells and 3 strips of space in between the cells.\n        bande (float): Width of the PV cells strip, in case of semi-transparent panel\n        void_space (float): Width of the void between PV cells strip, in case of semi-transparent panel\n\n    Returns:\n        Rhino.Geometry.Brep: Brep containing all the PVPs\n    \"\"\"\n    final_brep = rg.Brep()\n\n    for i in range(nb_rangs):\n        for j in range(nb_pvp_rangs):\n            # (x; y) are the coordinates of the current panel created\n            x = (j * column_spacing) - grid_size / 2\n            y = (i * row_spacing) - grid_size / 2\n            surface = []\n\n            if semi_transp:\n                for h in range(4):\n                    strip_x = x + h * (bande + void_space)\n                    surface.append(create_surface(strip_x, y, bande, length))\n            else:    \n                surface.append(create_surface(x, y, width, length))\n                \n            # Rotation around the Y axis for each Brep individually\n            center_of_surface = Point3d(x + width / 2, y + length / 2, 0)\n            rotation_x = Transform.Rotation(angle_variable * (System.Math.PI / 180), Vector3d.YAxis, center_of_surface)\n            for surf in surface:\n                surf.Transform(rotation_x)\n                # Adding it to the final returned brep\n                final_brep.Append(surf.ToBrep())       \n\n    # Global rotation around the Z axis at the center of the grid (origin)\n    rotation_z = Transform.Rotation(-angle_orientation * (System.Math.PI / 180), Vector3d.ZAxis, rg.Point3d.Origin)\n    final_brep.Transform(rotation_z)\n\n    # Global translation on the Z axis, equivalent to the panel rotation axis height\n    translation_z = Transform.Translation(0, 0, height)\n    final_brep.Transform(translation_z)\n\n    # Inversion of the orientation of the normals for proper operation of the Incident Radiation function\n    final_brep.Flip()\n\n    return final_brep\n\ndef create_sensor_grid(land_orientation, x, y, culture=False, entraxe=None, rampant=None, nb_lignes=None, grid_size=None):\n    \"\"\"\n    Creates the surface from which the Incident Radiation will measure the ground irradiance.\n\n    Args:\n        land_orientation (int): Difference between the field axis (PVP supports' axis) and the North-South axis.\n        culture (bool): If True, the measure surface will correspond to a rectangle that will fit under an arboriculture solar panel (used in vine for now).\n                        If False, it will correspond to a square, that we could use in field crops.\n        x (float): X-coordinate of the area of measures.\n        y (float): Y-coordinate of the area of measures.\n        entraxe (float): Distance between 2 rows of panels supports. None if culture is not arboriculture.\n        rampant (float): Width of a PVP panel. None if culture is not arboriculture.\n        nb_lignes (int): Number of PVP panels rows (= int(GRID_SIZE / ENTRAXE), calculated in settings).\n        grid_size (float): Size of the grid.\n        \n    Returns:\n        sensor_brep_list: List containing the created surfaces as Breps, which are then rotated and translated in the case of arboriculture.\n    \"\"\"\n    brep_gen = rg.Brep()\n    sensor_brep_list = []\n    _TAILLE_SENSOR = 5  # Sensor side length = 5 meters\n\n    if culture:\n        # Create the coordinates of the first point of a measure grid that fits under an arboriculture PVP\n        # (irradiance is not interesting in between vine rows)\n        if x is None:\n            x_arbo = math.floor(nb_lignes / 2) * entraxe + rampant / 2 - 0.5 - grid_size / 2\n            y_arbo = -2.5\n        else:\n            x_arbo, y_arbo = x, y\n\n        # Create a surface at the calculated center of the grid UNDER a panel, length = 5 and width = 1 m\n        s = create_surface(x_arbo, y_arbo, _TAILLE_SENSOR, 1)\n        brep_gen.Append(s.ToBrep())\n        \n        # Rotate the measure area to align it with the panels, using the same method and geometry references (ZAxis and Origin)\n        rotation_z = rg.Transform.Rotation(-land_orientation * (math.pi / 180), Vector3d.ZAxis, rg.Point3d.Origin)\n        brep_gen.Transform(rotation_z)\n\n    else:\n        # Create a square with TAILLE_SENSOR as the size of a side, center of the square is the origin of the Rhino Environment\n        surface_brep = create_surface(-_TAILLE_SENSOR / 2, -_TAILLE_SENSOR / 2, _TAILLE_SENSOR, _TAILLE_SENSOR)\n        brep_gen.Append(surface_brep.ToBrep())\n    \n    brep_gen.Flip()\n    sensor_brep_list.append(brep_gen)\n\n    return sensor_brep_list\n\ndef combine_grid_model(_model, grids_, views_=[]):\n    \"\"\"\n    Add Radiance Sensor Grids and/or Views to a Honeybee Model.\n\n    This assignment is necessary for any Radiance study, though whether a grid or a\n    view is required for a particular type of study depends upon the recipe used.\n\n    Multiple copies of this component can be used in series and each will add the\n    grids or views to any that already exist.\n\n    Args:\n        _model (Model): A Honeybee Model to which the input grids_ and views_ will be assigned.\n        grids_ (list): A list of Honeybee-Radiance SensorGrids, which will be assigned to the input _model.\n        views_ (list): A list of Honeybee-Radiance Views, which will be assigned to the input _model.\n\n    Returns:\n        Model: The input Honeybee Model with the grids_ and views_ assigned to it.\n    \"\"\"\n    assert isinstance(_model, Model), \\\n        'Expected Honeybee Model. Got {}.'.format(type(_model))\n    \n    # Duplicate the model to avoid modifying the input model\n    model = _model.duplicate()\n    \n    # Add grids if the list is not empty\n    if len(grids_) != 0:\n        model.properties.radiance.add_sensor_grids(grids_)\n    \n    # Add views if the list is not empty\n    if len(views_) != 0:\n        model.properties.radiance.add_views(views_)\n\n    return model\n\ndef convert_to_model(faces_, rooms_=None, shades_=None, apertures_=None, doors_=None, _name_=\"Grille\"):\n    \"\"\"\n    Create a Honeybee Model, which can be sent for simulation.\n\n    Args:\n        faces_ (list): A list of Honeybee Faces to be added to the Model. Note that\n            faces without a parent Room are not allowed for energy models.\n        rooms_ (list, optional): A list of Honeybee Rooms to be added to the Model. Note that at\n            least one Room is necessary to make a simulate-able energy model.\n        shades_ (list, optional): A list of Honeybee Shades to be added to the Model.\n        apertures_ (list, optional): A list of Honeybee Apertures to be added to the Model. Note\n            that apertures without a parent Face are not allowed for energy models.\n        doors_ (list, optional): A list of Honeybee Doors to be added to the Model. Note\n            that doors without a parent Face are not allowed for energy models.\n        _name_ (str, optional): Text to be used for the Model name and to be incorporated into a unique\n            model identifier. If no name is provided, it will be \"unnamed\" and\n            a unique model identifier will be auto-generated.\n\n    Returns:\n        Model: A Honeybee Model object possessing all of the input geometry\n            objects.\n    \"\"\"\n    try:  # Import the ladybug_rhino dependencies\n        from ladybug_rhino.config import units_system, tolerance, angle_tolerance\n        from honeybee.typing import clean_string, clean_and_id_string\n    except ImportError as e:\n        raise ImportError('\\nFailed to import ladybug_rhino:\\n\\t{}'.format(e))\n    \n    # Set a default name and get the Rhino Model units\n    name = clean_string(_name_) if _name_ is not None else clean_and_id_string('unnamed')\n    units = units_system()\n\n    # Create the model\n    model = Model(name, rooms_, faces_, shades_, apertures_, doors_,\n                  units=units, tolerance=tolerance, angle_tolerance=angle_tolerance)\n\n    return model\n\ndef brep_to_face(_geo, _name_ = [], _type_ = None, _bc_ = None):\n    \"\"\"\n    Create Honeybee Face.\n\n    Args:\n        _geo: Rhino Brep or Mesh geometry.\n        _name_ (list, optional): Text to set the name for the Face and to be incorporated into\n            unique Face identifier. If the name is not provided, a random name\n            will be assigned.\n        _type_ (str, optional): Text for the face type. The face type will be used to set the\n            material and construction for the surface if they are not assigned\n            through the inputs below. The default is automatically set based\n            on the normal direction of the Face (up being RoofCeiling, down\n            being Floor and vertically-oriented being Wall).\n            Choose from the following:\n                - Wall\n                - RoofCeiling\n                - Floor\n                - AirBoundary\n        _bc_ (str, optional): Text for the boundary condition of the face. The boundary condition\n            is also used to assign default materials and constructions as well as\n            the nature of heat exchange across the face in energy simulation.\n            Default is Outdoors unless all vertices of the geometry lie below\n            the XY plane, in which case it will be set to Ground.\n            Choose from the following:\n                - Outdoors\n                - Ground\n                - Adiabatic\n\n    Returns:\n        list: A list of Honeybee Faces. These can be used directly in radiance simulations\n              or can be added to a Honeybee room for energy simulation.\n    \"\"\"\n    faces = []  # list of faces that will be returned\n    for j, geo in enumerate(_geo):\n        # Set a default Face name if not provided\n        if len(_name_) == 0:\n            name = display_name = clean_and_id_string('Face')\n        else:\n            display_name = '{}_{}'.format(longest_list(_name_, j), j + 1) \\\n                if len(_name_) != len(_geo) else longest_list(_name_, j)\n            name = clean_and_id_string(display_name)\n        typ = _type_\n        bc = _bc_\n        \n        # Convert geometry to Face3D\n        lb_faces = to_face3d(geo)\n        for i, lb_face in enumerate(lb_faces):\n            face_name = '{}_{}'.format(name, i) if len(lb_faces) > 1 else name\n            hb_face = Face(face_name, lb_face, typ, bc)\n            hb_face.display_name = display_name\n\n            faces.append(hb_face)  # Collect the final Faces\n        \n    return faces\n\ndef brep_to_pts_mesh(_geometry, _grid_size, _offset_dist_ = 1, quad_only_ = False):\n    \"\"\"\n    Generate a mesh with corresponding test points from a Rhino Brep (or Mesh).\n\n    Args:\n        _geometry: Brep or Mesh from which to generate the points and grid.\n        _grid_size: Number for the size of the test grid.\n        _offset_dist_: Number for the distance to move points from the surfaces\n            of the input _geometry. Typically, this should be a small positive\n            number to ensure points are not blocked by the mesh. (Default: 0).\n        quad_only_: Boolean to note whether meshing should be done using Rhino's\n            defaults (False), which fills the entire _geometry to the edges\n            with both quad and tringulated faces, or a mesh with only quad\n            faces should be generated.\n            FOR ADVANCED USERS: This input can also be a vector object that will\n            be used to set the orientation of the quad-only grid. Note that,\n            if a vector is input here that is not aligned with the plane of\n            the input _geometry, an error will be raised.\n\n    Returns:\n        points: Test points at the center of each mesh face.\n    \"\"\"\n    # check the input and generate the mesh.\n    _offset_dist_ = _offset_dist_ or 0\n    if quad_only_:  # use Ladybug's built-in meshing methods\n        lb_faces = to_face3d(_geometry)\n        try:\n            x_axis = to_vector3d(quad_only_)\n            lb_faces = [Face3D(f.boundary, Plane(f.normal, f[0], x_axis), f.holes)\n                        for f in lb_faces]\n        except AttributeError:\n            pass  # no plane connected; just use default orientation\n        lb_meshes = []\n        for geo in lb_faces:\n            try:\n                lb_meshes.append(geo.mesh_grid(_grid_size, offset=_offset_dist_))\n            except AssertionError:  # tiny geometry not compatible with quad faces\n                continue\n        if len(lb_meshes) == 0:\n            lb_mesh = None\n        elif len(lb_meshes) == 1:\n            lb_mesh = lb_meshes[0]\n        elif len(lb_meshes) > 1:\n            lb_mesh = Mesh3D.join_meshes(lb_meshes)\n    else:  # use Rhino's default meshing\n        lb_mesh = to_gridded_mesh3d_perso(_geometry, _grid_size, _offset_dist_)\n    \n    # generate the test points, vectors, and areas.\n    if lb_mesh is not None:\n        points = [pt for pt in lb_mesh.face_centroids]\n\n    return points\n\ndef convert_to_grid(_positions, _name_ = '', _directions_ = [], mesh_ = None, base_geo_ = None):\n    \"\"\"\n    Create a Sensor Grid object that can be used in a grid-based recipe.\n\n    Args:\n        _name_: A name for this sensor grid.\n        _positions: A list or a datatree of points with one point for the position\n            of each sensor. Each branch of the datatree will be considered as a\n            separate sensor grid.\n        _directions_: A list or a datatree of vectors with one vector for the\n            direction of each sensor. The input here MUST therefore align with\n            the input _positions. If no value is provided (0, 0, 1) will be\n            assigned for all the sensors.\n        mesh_: An optional mesh that aligns with the sensors. This is useful for\n            generating visualizations of the sensor grid beyond the sensor\n            positions. Note that the number of sensors in the grid must match\n            the number of faces or the number of vertices within the mesh.\n        base_geo_: An optional Brep for the geometry used to make the grid. There are\n            no restrictions on how this brep relates to the sensors and it is\n            provided only to assist with the display of the grid when the number\n            of sensors or the mesh is too large to be practically visualized.\n\n    Returns:\n        grid: A SensorGrid object that can be used in a grid-based recipe.\n    \"\"\"\n    # Set the default name and process the points to tuples\n    pts = []\n    for pt in _positions:\n        pts.append((pt.x, pt.y, pt.z))\n\n    # Create the sensor grid object\n    id = _name_\n    if len(_directions_) == 0:\n        grid = SensorGrid.from_planar_positions(id, pts, (0, 0, 1))\n    else:\n        vecs = [(vec.X, vec.Y, vec.Z) for vec in _directions_]\n        grid = SensorGrid.from_position_and_direction(id, pts, vecs)\n        \n    if mesh_ is not None:\n        grid.mesh = to_mesh3d(mesh_)\n    if base_geo_ is not None:\n        grid.base_geometry = to_face3d(base_geo_)\n\n    return grid\n\ndef run_annual_irradiance_simulation(angles, wea, bdd_irr, hoys, output_path, FINESSE, GRID_SIZE, ENTRAXE, RAMPANT, NB_PVP_RANGS, ANGLE_ORIENTATION, TYPE_PANEL, LARGEUR_BANDE, LARGEUR_AVIDE, LONGUEUR_PVP, HAUTEUR, cult):\n    \"\"\"\n    Run annual irradiance simulations for a range of panel tilt angles and export the results to an Excel file.\n    \n    Args:\n        angles: List of tilt angles to simulate.\n        wea: A Wea object or path to a .wea or .epw file.\n        bdd_irr: DataFrame to store the results.\n        hoys: List of hours of the year to be considered in the results.\n        output_path: Path to the output Excel file where results will be saved.\n        FINESSE: Grid size for mesh resolution.\n        GRID_SIZE: Grid size for panel creation.\n        ENTRAXE: Distance between rows of panels.\n        RAMPANT: Inclination of the panels.\n        NB_PVP_RANGS: Number of panels per row.\n        ANGLE_ORIENTATION: Orientation angle of the panels.\n        TYPE_PANEL: Type of panels to be used.\n        LARGEUR_BANDE: Width of the panel band.\n        LARGEUR_AVIDE: Width of the panel slot.\n        LONGUEUR_PVP: Length of the panels.\n        HAUTEUR: Height of the panels.\n        cult: Type of culture studied\n    \n    Returns:\n        None\n    \"\"\"\n    cultBool = True\n    if cult == 3:\n        cultBool = False\n    # Paths and settings\n    path_resultsHB_AI = os.path.join(os.getcwd(),'Annual_Irr_Results')\n    settings_HB_AI = RecipeSettings(path_resultsHB_AI)\n    settings_HB_AI_CT = RecipeSettings(path_resultsHB_AI+'_CT')\n    print(settings_HB_AI_CT)\n\n    ### Run simulation with CONTROL area -------------------------------------------\n    # Create classic geometry\n    panels_CT = rg.Brep()\n    panels_CT.Append(create_surface(40, 40, 0.1, 0.1).ToBrep())\n    ground_CT = create_sensor_grid(ANGLE_ORIENTATION, 40, 40, culture=cultBool)\n\n    # Convert to Model for control area\n    panels_CT_faces = brep_to_face([panels_CT])\n    panel_CT_model = convert_to_model(panels_CT_faces)\n    ground_CT_grid = brep_to_pts_mesh(ground_CT[0], _grid_size=FINESSE)  # BREP TO POINTS\n    ground_CT_grid_sensor = convert_to_grid(ground_CT_grid, 'ID_CT')\n    panel_CT_model_gridded = combine_grid_model(panel_CT_model, [ground_CT_grid_sensor])  # MODEL COMBINED WITH GRID\n\n    # Run annual irradiance function\n    annual_irradiance(_model=panel_CT_model_gridded, _wea=wea, run_settings_=settings_HB_AI_CT) \n\n    ### Run simulation with STUDY area -------------------------------------------\n    # Create measurement grid\n    ground = create_sensor_grid(ANGLE_ORIENTATION, None, None, culture=cultBool, \n                                    entraxe=ENTRAXE, rampant=RAMPANT, nb_lignes=NB_PVP_RANGS, grid_size=GRID_SIZE)\n    ground_grid = brep_to_pts_mesh(ground[0], _grid_size=FINESSE)  # BREP TO POINTS\n    ground_grid_sensor = convert_to_grid(ground_grid, 'ID_1')\n\n    # Loop over angles and run simulations\n    for index, angle in enumerate(angles):\n        # Create panel geometry\n        print(\"Boucle simulation, angle numéro :\",index+1)\n        final_rotated_brep = create_panel_grid(GRID_SIZE, NB_PVP_RANGS, NB_PVP_RANGS, RAMPANT, LONGUEUR_PVP, HAUTEUR, ENTRAXE, LONGUEUR_PVP, ANGLE_ORIENTATION, angle,\n                                               TYPE_PANEL, LARGEUR_BANDE, LARGEUR_AVIDE)\n\n        # Convert to Model\n        panel_faces = brep_to_face([final_rotated_brep])\n        panel_model = convert_to_model(panel_faces)\n        panel_model_gridded = combine_grid_model(panel_model, [ground_grid_sensor])  # MODEL COMBINED WITH GRID\n\n        # Run annual irradiance\n        annual_irradiance(_model=panel_model_gridded, _wea=wea, run_settings_=settings_HB_AI)\n        print(\"irr\")\n\n        # Export data to container\n        sun_up_hours = pd.read_csv('Annual_Irr_Results/annual_irradiance/results/total/sun-up-hours.txt', header=None).squeeze()\n        sun_up_hours = sun_up_hours - 0.5\n\n        ill_data = pd.read_csv('Annual_Irr_Results/annual_irradiance/results/total/ID_1.ill', delim_whitespace=True, header=None)\n        ill_data_mean = ill_data.mean()\n\n        angle_txt = str(angle)\n        bdd_irr[angle_txt] = 0\n        for hour in hoys:\n            if hour in sun_up_hours.values:\n                index = sun_up_hours[sun_up_hours == hour].index[0]\n                bdd_irr.at[hour, angle_txt] = ill_data_mean[index]\n\n        # Clean up\n        if os.path.exists(path_resultsHB_AI):\n            shutil.rmtree(path_resultsHB_AI)\n            print(f\"Le dossier '{path_resultsHB_AI}' a été supprimé avec succès.\")\n        else:\n            print(f\"Le dossier '{path_resultsHB_AI}' n'existe pas.\")\n\n    # Add control light simulation results to table\n    sun_up_hours = pd.read_csv('Annual_Irr_Results_CT/annual_irradiance/results/total/sun-up-hours.txt', header=None).squeeze()\n    sun_up_hours = sun_up_hours - 0.5\n\n    ill_data = pd.read_csv('Annual_Irr_Results_CT/annual_irradiance/results/total/ID_CT.ill', delim_whitespace=True, header=None)\n    ill_data_mean = ill_data.mean()\n\n    CT_txt = 'temoin'\n    bdd_irr[CT_txt] = 0\n    for hour in hoys:\n        if hour in sun_up_hours.values:\n            index = sun_up_hours[sun_up_hours == hour].index[0]\n            bdd_irr.at[hour, CT_txt] = ill_data_mean[index]\n\n    # Clean up control area folder\n    if os.path.exists(path_resultsHB_AI + '_CT'):\n        shutil.rmtree(path_resultsHB_AI + '_CT')\n        print(f\"Le dossier '{path_resultsHB_AI + '_CT'}' a été supprimé avec succès.\")\n    else:\n        print(f\"Le dossier '{path_resultsHB_AI + '_CT'}' n'existe pas.\")\n\n    # Export results to Excel\n    print(output_path)\n    bdd_irr.to_excel(output_path, index=False, header=True)\n##",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}