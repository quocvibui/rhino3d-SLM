{
  "source_url": "https://discourse.mcneel.com/t/does-not-exist-in-objecttable/166046",
  "topic_id": 166046,
  "title": "Does not exist in ObjectTable...?",
  "question": "I don’t understand why my script does work now… it was working, but since, two weeks… on one moment it return:\n\n\nMessage: 461ae419-8c00-4a18-9184-1d51dbc5b53f does not exist in ObjectTable\n\n\nTraceback:\n\nline 1065, in coercerhinoobject, “C:\\Users\\Franck\\AppData\\Roaming\\McNeel\\Rhinoceros\\7.0\\Plug-ins\\IronPython (814d908a-e25c-493d-97e9-ee3861957f49)\\settings\\lib\\rhinoscript\\utility.py”\n\nline 1569, in SelectObject, “C:\\Users\\Franck\\AppData\\Roaming\\McNeel\\Rhinoceros\\7.0\\Plug-ins\\IronPython (814d908a-e25c-493d-97e9-ee3861957f49)\\settings\\lib\\rhinoscript\\object.py”\n\nline 275, in OrientedBox, “S:\\SCRIPT\\Python\\X_PSEAPLAT.py”\n\nline 60, in PseAPlat, “S:\\SCRIPT\\Python\\X_PSEAPLAT.py”\n\nline 312, in , “S:\\SCRIPT\\Python\\X_PSEAPLAT.py”\n\n\ni don’t know why this object does not exist in the ObjectTable… is it possible to find an object by this id?\n\n\nthanks!!\n\nFranck",
  "code_blocks": [
    {
      "code": "# coding: utf-8\n#triblocpypse02\nimport rhinoscriptsyntax as rs\nfrom collections import Counter\n\n\ndef NbAngleDroit(cont):\n    points=rs.CurvePoints(cont)\n    lp = len(points)-1\n    count=0\n    for i in range(lp):\n        angle=rs.Angle2( [points[i] , points[(i+1)%lp] ], [points[(i+1)%lp] , points[(i+2)%lp]])\n        #print (angle)\n        if round(angle[0])==90:count+=1\n    #print count\n    return count\n\ndef PseAPlat():\n    ep_std=(400,200,100)\n    tol=0.00001\n    stop=False\n    origine=rs.coerce3dpoint([0,0,0])\n    blocs=rs.GetObjects('selectionne les blocs à trier',16)\n    if not blocs : return\n    #Test NOM de chaque Blocs\n    rs.EnableRedraw(False)\n    for bloc in blocs:\n        if not rs.IsPolysurfaceClosed(bloc):\n            rs.ObjectColor(bloc,(0,127,0))\n            stop=True\n        if not rs.ObjectName(bloc):\n            rs.ObjectColor(bloc,(0,0,255))\n            stop=True\n        else:\n            try:\n                name=int(rs.ObjectName(bloc))\n            except:\n                rs.ObjectColor(bloc,(250,0,0))\n                stop=True\n    if stop:\n        print('les verts ne sont pas fermés,les bleus n\\'ont pas de nom et les rouges sont només n\\'importe comment')\n        return\n    \n    #tri par numero\n    sorted_blocs=TriBlocParNum(blocs)\n    ep400=[]\n    ep200=[]\n    ep100=[]\n    epother=[]\n    second_passage=False\n    \n    for bloc in sorted_blocs:\n        if second_passage:\n            decal= bboxdecal[1].X-bboxdecal[0].X+500\n            origine.X+=decal\n            \n        second_passage=True\n        \n    #trouve la boite orientée sur le bloc\n        orientedbox=OrientedBox(bloc,ep_std)\n        #if not orientedbox:\n            #second_passage=False\n            #continue\n\n        pt1=orientedbox[0]\n        pt2=orientedbox[1]\n        pt3=orientedbox[2]\n        \n        newbloc=BlocAPlat(bloc,pt1,pt2,pt3,origine)\n        bboxdecal=rs.BoundingBox(newbloc)\n        \n        rs.AddLayer('PSE à PLAT')\n        rs.AddLayer('PSE à PLAT::400',(123, 38, 205))\n        rs.AddLayer('PSE à PLAT::200',(123, 138, 205))\n        rs.AddLayer('PSE à PLAT::100',(123, 238, 205))\n        rs.AddLayer('PSE à PLAT::Hors Std',(0,100,180))\n        if orientedbox[5]== 400:\n            rs.ObjectLayer(newbloc[0],'PSE à PLAT::400')\n        elif orientedbox[5]== 200:\n            rs.ObjectLayer(newbloc[0],'PSE à PLAT::200')\n        elif orientedbox[5]== 100:\n            rs.ObjectLayer(newbloc[0],'PSE à PLAT::100')\n        else:\n            rs.ObjectLayer(newbloc[0],'PSE à PLAT::Hors Std')\n        #ajout de l'annotation\n        ptnote=rs.coerce3dpoint((origine.X+50,4,420))\n        note='Bloc' + rs.ObjectName(bloc)+' ep '+str(int(orientedbox[5]))+' '+str(int(orientedbox[3]))+' x '+str(int(orientedbox[4]))\n        textnote=rs.AddText(note,ptnote,100)\n        if orientedbox[3]==1200 and orientedbox[4]==3000:\n            if orientedbox[5]== 400:\n                rs.ObjectColor(textnote,(0,0,255))\n            elif orientedbox[5]== 200:\n                rs.ObjectColor(textnote,(255,0,0))\n            else:\n                rs.ObjectColor(textnote,(0,255,0))\n        rs.RotateObject(textnote,ptnote,90)\n        rs.ObjectLayer(textnote,'PSE à PLAT')\n        \n        objs=rs.ObjectsByLayer('PSE à PLAT::400')\n        if not objs:\n            rs.DeleteLayer('PSE à PLAT::400')\n            \n        objs=rs.ObjectsByLayer('PSE à PLAT::200')\n        if not objs:\n            rs.DeleteLayer('PSE à PLAT::200')\n            \n        objs=rs.ObjectsByLayer('PSE à PLAT::100')\n        if not objs:\n            rs.DeleteLayer('PSE à PLAT::100')\n            \n        objs=rs.ObjectsByLayer('PSE à PLAT::Hors Std')\n        if not objs:\n            rs.DeleteLayer('PSE à PLAT::Hors Std')\n\n            \n    rs.EnableRedraw(True)\n    pass\n\n\ndef BlocAPlat(bloc,pt1,pt2,pt3,origine):\n    ref=(pt1,pt2,pt3)\n    t1=origine\n    t2=rs.coerce3dpoint((1,0,0))\n    t2.X=t1.X+1\n    t3=rs.coerce3dpoint((0,0,1))\n    t3.X=t1.X\n    targ=(t1,t2,t3)\n    bloc_a_plat=rs.OrientObject(bloc,ref,targ,1)\n    box=rs.BoundingBox(bloc_a_plat)\n    return (bloc_a_plat,box[1])\n\ndef TriBlocParNum(blocs):\n    lstnum=[]\n    for i in range (0,len(blocs)):\n        name=int(rs.ObjectName(blocs[i]))\n        lstnum.append((blocs[i],name))\n    lst_sort=sorted(lstnum,key=lambda s:s[1])\n    return [item[0] for item in lst_sort]\n    pass\n\ndef TriSurf (Surfs):\n    Surfs=sorted([(rs.SurfaceArea(Surf)[0],Surf) for Surf in Surfs])\n    return [item[1] for item in Surfs]\n\ndef CenterPoint(surf):\n    Usurfdomain=rs.SurfaceDomain(surf,0)\n    Vsurfdomain=rs.SurfaceDomain(surf,1)\n    u=(Usurfdomain[0]+Usurfdomain[1])/2\n    v=(Vsurfdomain[0]+Vsurfdomain[1])/2\n    ctpt=rs.EvaluateSurface(surf,u,v)\n    return ctpt\n\ndef Plan(surf):\n    contour=rs.DuplicateSurfaceBorder(surf,type=1)\n    edges=rs.ExplodeCurves(contour)\n    sorted_edges=sorted([(rs.CurveLength(edge),edge)for edge in edges])\n    pt1=rs.CurveStartPoint(sorted_edges[1][1])\n    pt2=rs.CurveEndPoint(sorted_edges[1][1])\n    Xvect=rs.VectorCreate(pt2,pt1)\n    Usurfdomain=rs.SurfaceDomain(surf,0)\n    Vsurfdomain=rs.SurfaceDomain(surf,1)\n    u=(Usurfdomain[0]+Usurfdomain[1])/2\n    v=(Vsurfdomain[0]+Vsurfdomain[1])/2\n    eval=rs.EvaluateSurface(surf,u,v)\n    vect=rs.SurfaceNormal(surf,[u,v])\n    plan=rs.PlaneFromNormal(CenterPoint(surf),vect,Xvect)\n    rs.DeleteObject(contour)\n    rs.DeleteObjects(edges)\n    return plan\n\n\n\ndef OrientedBox(bloc,ep_std):\n    #Bloc rectangulaire ou pas?\n    first_pass=True\n    if first_pass:\n        vbloc=rs.SurfaceVolume(bloc)\n        box=rs.BoundingBox(bloc)\n        vbbox=(rs.Distance(box[0],box[1]))*(rs.Distance(box[0],box[3]))*(rs.Distance(box[0],box[4]))\n        blocpp=False\n\n        if round(vbbox/1000)==round(vbloc[0]/1000):\n            blocpp=True\n        first_pass=False\n        \n    surfs=rs.ExplodePolysurfaces(bloc)\n    sorted_surfs=sorted([(rs.SurfaceArea(surf)[0],surf) for surf in surfs],reverse=True)\n    \n    \n    if blocpp:#si le bloc est parallelepipedique\n        for epindex in range(0,len(ep_std)):\n            for i in range (0 , len(sorted_surfs)):\n                rs.SelectObject(sorted_surfs[i][1])\n                bplane=Plan(sorted_surfs[i][1])\n                rs.UnselectAllObjects()\n                box=rs.BoundingBox(bloc,bplane,in_world_coords=True)\n                Xtest=rs.Distance(box[0],box[1])\n                Ytest=rs.Distance(box[0],box[3])\n                Ztest=rs.Distance(box[0],box[4])\n                pass\n\n                if round(Ztest)== ep_std[epindex] and round(Xtest)==1200:\n                    rs.DeleteObjects(surfs)\n                    return ((box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest)))\n                    \n                elif round(Ztest)== ep_std[epindex] and Xtest<Ytest:\n                    rs.DeleteObjects(surfs)\n                    return ((box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest)))\n                    \n                elif round(Ztest)== ep_std[epindex] and Xtest > Ytest:\n                    rs.DeleteObjects(surfs)\n                    return((box[1],box[2],box[5],round(Ytest),round(Xtest),round(Ztest)))\n                    \n                elif Ztest < Xtest and Xtest < Ytest :\n                    #rs.DeleteObjects(surfs)\n                    boxtemp=(box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest))\n                    \n                elif Ztest < Xtest and Xtest > Ytest :\n                    boxtemp=(box[1],box[2],box[5],round(Xtest),round(Ytest),round(Ztest))\n    else:# si le bloc n'est pas parrellepidedeic\n        surfdec=[]\n        for surf in sorted_surfs:\n            pass\n            cont=rs.DuplicateSurfaceBorder(surf[1],1)\n            nb_angledroit=NbAngleDroit(cont)\n            if nb_angledroit<=3: surfdec.append(surf[1])\n            rs.DeleteObject(cont)\n            \n        #print (surfdec)\n        for surf in surfdec:\n            cont=rs.DuplicateSurfaceBorder(surf)\n            nb_angledroit=NbAngleDroit(cont)\n            points=rs.CurvePoints(cont)\n            rs.DeleteObject(cont)\n            lp = len(points)-1\n            if nb_angledroit != 0:\n                for i in range (lp):\n                    angle=rs.Angle2( [points[i] , points[(i+1)%lp] ], [points[(i+1)%lp] , points[(i+2)%lp]])\n                    distx=rs.Distance(points[(i+1)%lp] , points[(i+2)%lp])\n                    disty=rs.Distance(points[i] , points[(i+1)%lp])\n                    if angle[0]==90 and distx<disty:\n                        bplane=rs.PlaneFromPoints(points[(i+1)%lp],points[(i+2)%lp],points[i])\n                        box=rs.BoundingBox(bloc,bplane,in_world_coords=True)\n                        Xtest=rs.Distance(box[0],box[1])\n                        Ytest=rs.Distance(box[0],box[3])\n                        Ztest=rs.Distance(box[0],box[4])\n                        rs.DeleteObjects(surfs)\n                        return ((box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest)))\n                    elif angle[0]==90 and disty<distx:\n                        bplane=rs.PlaneFromPoints(points[(i+1)%lp],points[(i+2)%lp],points[i])\n                        box=rs.BoundingBox(bloc,bplane,in_world_coords=True)\n                        Xtest=rs.Distance(box[0],box[1])\n                        Ytest=rs.Distance(box[0],box[3])\n                        Ztest=rs.Distance(box[0],box[4])\n                        rs.DeleteObjects(surfs)\n                        return ((box[1],box[2],box[5],round(Xtest),round(Ytest),round(Ztest)))\n            else:\n                for i in range (lp):\n                    vect1=rs.VectorCreate(points[(i+1)%lp],points[i] )\n                    vect2=rs.VectorCreate(points[(i+3)%lp],points[(i+2)%lp])\n                    if rs.IsVectorParallelTo(vect1,vect2)!=0:\n                        bplane=rs.PlaneFromPoints(points[i],points[(i+1)%lp],points[(i+3)%lp])\n                        box=rs.BoundingBox(bloc,bplane,in_world_coords=True)\n                        Xtest=rs.Distance(box[0],box[1])\n                        Ytest=rs.Distance(box[0],box[3])\n                        Ztest=rs.Distance(box[0],box[4])\n                        rs.DeleteObjects(surfs)\n                        return ((box[1],box[2],box[5],round(Xtest),round(Ytest),round(Ztest)))\n    # en dernier recour\n    for epindex in range(0,len(ep_std)):\n        for i in range (0 , len(sorted_surfs)):\n            rs.SelectObject(sorted_surfs[i][1])\n            bplane=Plan(sorted_surfs[i][1])\n            rs.UnselectAllObjects()\n            box=rs.BoundingBox(bloc,bplane,in_world_coords=True)\n            Xtest=rs.Distance(box[0],box[1])\n            Ytest=rs.Distance(box[0],box[3])\n            Ztest=rs.Distance(box[0],box[4])\n            pass\n\n            if round(Ztest)== ep_std[epindex] and round(Xtest)==1200:\n                rs.DeleteObjects(surfs)\n                return ((box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest)))\n                \n            elif round(Ztest)== ep_std[epindex] and Xtest<Ytest:\n                rs.DeleteObjects(surfs)\n                return ((box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest)))\n                \n            elif round(Ztest)== ep_std[epindex] and Xtest > Ytest:\n                rs.DeleteObjects(surfs)\n                return((box[1],box[2],box[5],round(Ytest),round(Xtest),round(Ztest)))\n                \n            elif Ztest < Xtest and Xtest < Ytest :\n                #rs.DeleteObjects(surfs)\n                boxtemp=(box[0],box[1],box[4],round(Xtest),round(Ytest),round(Ztest))\n                \n            elif Ztest < Xtest and Xtest > Ytest :\n                boxtemp=(box[1],box[2],box[5],round(Xtest),round(Ytest),round(Ztest))\n\n\n\n    rs.DeleteObjects(surfs)\n    \n    return boxtemp\n\n\n\nPseAPlat()",
      "language": "python",
      "author": "farouk.serragedine",
      "post_number": 6,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "layers",
    "python",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 11,
  "posts_count": 9,
  "views": 325
}