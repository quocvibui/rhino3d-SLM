{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/clients/if_robot/communication/communication.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "clients/if_robot/communication/communication.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << >< > ><  <<  <<><><>   .  \n.   <<  ><  ><  <<  ><  ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 02.11.2016\n\n@author: kathrind\n'''\n\nfrom ifmm_lib.geometry import Frame\n\nfrom client_container import ClientContainer\nfrom messages.messagetypes import MSG_CURRENT_POSE_CARTESIAN, MSG_CURRENT_POSE_JOINT, MSG_COMMAND, MSG_STOP\nfrom messages.messagetypes import CMD_GO_TO_TASKTARGET, CMD_GO_TO_JOINTTARGET_ABS, CMD_GO_TO_JOINTTARGET_REL, CMD_PICK_BRICK, CMD_PLACE_BRICK, CMD_PICK_BRICK_FROM_POSE\n\nimport time\n\nimport Rhino.Geometry as rg\nimport math as m\n\n\n\nclass ABBCommunication(ClientContainer):\n    \"\"\" The class ABBComm extends the Clientcontainer class. \n    It can send and receive data from the ABB arm\n    \n    \"\"\"\n    \n    def __init__(self, identifier, host='127.0.0.1', port_snd=30003, port_rcv=30004, ghenv = None):\n        ClientContainer.__init__(self,  identifier, host, port_snd, port_rcv, ghenv = ghenv)\n        \n        \" create \"\n        self.tool_frame = Frame(draw_geo = True)\n        \n        # init values for command messages\n        self.int_speed = 0 # speed: 0 = slow, 1 = mid, 2 = fast\n        self.float_duration = 0 #duration is not used, use velocity instead\n        self.int_zonedata = 10 # zonedata: in mm\n        self.int_tool = 1 # toolnumber: 0 = tool0, 1 = mesh mould tool, 2 = mesh mould tool with bending pin, 3 = mtip\n        self.float_arbitrary = 0 #spare field for any kind of input\n        \n        # home positions cartesian\n        self.tool_plane_home_mid = rg.Plane(rg.Point3d(1000,0,650), rg.Vector3d(1,0,0), rg.Vector3d(0,-1,0))\n        self.tool_plane_home_left = rg.Plane(rg.Point3d(-665.507, 629.086, 720.0), rg.Vector3d(-1,0,0), rg.Vector3d(0,1,0))\n        \n        # home positions joint targets\n        self.jointtarget_home_zero = [0,0,0,0,0,0]\n        self.jointtarget_home_pickbrick = [130.9, -56.8, 58.3, 7.4, 30.1, 51.9]\n        \n        self.current_joint_values = [0,0,0,0,0,0]\n        self.current_tool0_pose = [0,0,0,0,0,0,0]\n        #self.ghComp = None\n\n    # =================================================================================    \n    # robot tool\n    # =================================================================================     \n    # =================================================================================        \n    def set_tool_to_plane(self, plane):\n        \"\"\" move the base to a plane position \"\"\"\n        self.tool_frame.set_to_plane(plane)\n    # =================================================================================        \n    def get_tool_plane(self):\n        \"\"\" return the plane of the baseframe \"\"\"\n        return self.tool_frame.plane\n    # =================================================================================    \n    def get_tool_tmatrix_from(self):\n        \"\"\" return the transformation matrix (Transform class of Rhino) of the baseframe to the origin \"\"\"\n        return self.tool_frame.get_tmatrix_from()\n    # =================================================================================    \n    def get_tool_tmatrix_to(self):\n        \"\"\" return the transformation matrix (Transform class of Rhino) of the origin to the baseframe \"\"\"\n        return self.tool_frame.get_tmatrix_to()\n    \n    # =================================================================================    \n    # receive robot info from queues\n    # =================================================================================    \n    # =================================================================================               \n    def get_current_pose_cartesian(self):\n        \"\"\" get the current tool pose from the queue and set the tool_frame according to the pose \"\"\"\n        msg_current_pose_cart = self.get_from_rcv_queue(MSG_CURRENT_POSE_CARTESIAN)\n        if msg_current_pose_cart <> None:\n            pose = msg_current_pose_cart[1]\n            self.current_tool0_pose = pose\n            #self.tool_frame.set_to_pose(pose)\n            return pose\n        else: \n            return None \n        \n    # =================================================================================               \n    def get_current_pose_joint(self):\n        \"\"\" get the current tool pose from the queue and set the tool_frame according to the pose \"\"\"\n        msg_current_pose_joint = self.get_from_rcv_queue(MSG_CURRENT_POSE_JOINT)\n        if msg_current_pose_joint <> None:\n            pose_joint = msg_current_pose_joint[1]\n            self.current_joint_values = [m.degrees(pj) for pj in pose_joint]\n            return pose_joint\n        else: \n            return None\n    \n    # =================================================================================    \n    # send robot commands\n    # =================================================================================\n    # =================================================================================           \n    def send_stop(self):\n        \"\"\" send stop to robot \"\"\"\n        #TODO: implement on Rapid side\n        self.send(MSG_STOP)\n            \n    # =================================================================================       \n    def send_pose_cartesian(self, plane, int_arr=None):\n        \"\"\" create command from plane and send task target to robot, \n        int_arr can be defined outside, or if None, default values are sent. \n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] \"\"\"\n        \n        frame = Frame(plane)\n        pose = frame.get_pose_quaternion() # pose = [x,y,z,qw,qx,qy,qz]\n        if int_arr == None:\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary]\n        else:\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + int_arr\n        \n        self.send(MSG_COMMAND, cmd)\n        \n    # =================================================================================           \n    def send_pose_cartesian_list(self, planes, int_arr=None):\n        \"\"\" create command from planes and send task targets to robot, \n        int_arr can be defined outside, or if None, default values are sent. \n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] \"\"\"   \n        for plane in planes:\n            self.send_pose_cartesian(plane, int_arr)\n    \n        # =================================================================================           \n    def send_axes_relative(self, axes, int_arr=None):\n        \"\"\" relative joint axes commands for the abb arm \"\"\"\n        if int_arr:\n            cmd = [CMD_GO_TO_JOINTTARGET_REL] + axes + [0] + int_arr\n        else:\n            cmd = [CMD_GO_TO_JOINTTARGET_REL] + axes + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, 1]\n        self.send(MSG_COMMAND, cmd)\n    \n    # =================================================================================           \n    def send_axes_absolute(self, axes, int_arr=None):\n        \"\"\" absolute joint axes commands for the abb arm \"\"\"   \n        if int_arr:\n            cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + int_arr\n        else:\n            cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, 1]\n        self.send(MSG_COMMAND, cmd) \n    \n    # =================================================================================           \n    def send_pose_cartesian_home(self, int_arr=None):\n        \"\"\" send the \"home\" position as task target as defined in init \"\"\"\n        self.send_pose_cartesian(self.tool_plane_home_mid, int_arr)\n        \n    # =================================================================================           \n    def send_pose_joint_home(self, int_arr=None):\n        \"\"\" send the \"home\" position as jointtarget as defined in init \"\"\"\n        self.send_axes_absolute(self.jointtarget_home_zero, int_arr)\n    \n    # =================================================================================           \n    def send_pose_joint_pick_brick(self, int_arr=None):\n        \"\"\" send the \"home\" position as jointtarget as defined in init \"\"\"\n        self.send_axes_absolute(self.jointtarget_home_pickbrick, int_arr)\n        \n    # =================================================================================               \n    def send_pick_brick_from_pose(self, plane, int_arr=None):\n        \"\"\" send a command for picking up the material and go to the given plane \n        sequence: \n        1. drive from actual pos to pick up the brick at the given plane\n        (== >> this routine is defined in RobotStudio, the command consist only out of the pick-up plane.\n        \"\"\"    \n        frame = Frame(plane)\n        pose = frame.get_pose_quaternion() # pose = [x,y,z,qw,qx,qy,qz]\n        if int_arr == None:\n            cmd = [CMD_PICK_BRICK_FROM_POSE] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary]\n        else:\n            cmd = [CMD_PICK_BRICK_FROM_POSE] + pose + int_arr\n        self.send(MSG_COMMAND, cmd)\n        \n    # =================================================================================               \n    def send_pick_brick_from_feed(self, fullbrick = True, int_arr=None):\n        \"\"\" send a command for picking up the material and go to the given plane sequence: \n        1. drive from actual pos to the homeposition, defined as jointtarget, on the left side of the robot.\n        2. go on the trajectory to pick up a brick from the feeder and drive back to the homeposition\n        == >> this routine is defined in RobotStudio, the command consist only out of the homeposition.\n        cmd = [CMD_PICK_BRICK, joints, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] float_arbitrary => 0 = fullbrick  / 1 = halfbrick\n        \"\"\" \n        \n        jointpose = self.jointtarget_home_pickbrick \n        float_arbitrary = 0 if fullbrick == True else 1 #this parameter has to read in Rapid, to either pick a fullbrick or a halfbrick\n        \n        if int_arr == None:\n            cmd = [CMD_PICK_BRICK] + jointpose + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, float_arbitrary]\n        else:\n            cmd = [CMD_PICK_BRICK] + jointpose + [0] + int_arr\n        \n        self.send(MSG_COMMAND, cmd)\n\n    # =================================================================================\n    def send_place_brick(self, plane, send_pick_brick_from_feed = True, fullbrick = True, int_arr = None):\n        \"\"\" send a command for placing the material at the given plane \n        sequence: \n        1. drive to home_pos, pick a brick and drive back to homepos\n        1. drive from home pos to the a point 20 cm above the given plane\n        2. go on the trajectory to place the brick and drive back to a point 20 cm above the given plane\n        == >> this routine is defined in RobotStudio, and is defined \n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 3 = place the brick\n        \n        cmd = [CMD_PICK_BRICK, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\n        \"\"\"\n        if send_pick_brick_from_feed:\n            self.send_pick_brick_from_feed(fullbrick, int_arr)\n        \n        frame = Frame(plane)\n        pose = frame.get_pose_quaternion() # pose = [x,y,z,qw,qx,qy,qz]\n        \n        if int_arr == None:\n            cmd = [CMD_PLACE_BRICK] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary]\n        else:\n            cmd = [CMD_PLACE_BRICK] + pose + int_arr\n        \n        self.send(MSG_COMMAND, cmd)\n\n    # =================================================================================\n    def set_home_pos_left_to_origin(self):\n        self.tool_plane_home_left = rg.Plane(rg.Point3d(-665.507, 629.086, 720.0), rg.Vector3d(-1,0,0), rg.Vector3d(0,1,0))\n        \n    # =================================================================================\n    def get_home_pos_left(self):\n        return self.tool_plane_home_left\n    \n    # =================================================================================\n    def get_home_pos_left_for_180(self):\n        plane = rg.Plane(self.get_home_pos_left())\n        plane.Translate(rg.Vector3d(1200,0,0))\n        plane.Rotate(m.radians(180), plane.ZAxis, plane.Origin)\n        return plane\n    \n    # =================================================================================    \n    # set command parameters (for int_arr)\n    # =================================================================================   \n    # =================================================================================\n    def set_speed_fast(self):\n        self.int_speed = 2\n        self.int_zonedata = 100\n    # =================================================================================\n    def set_speed_mid(self):\n        self.int_speed = 1\n        self.int_zonedata = 20\n    # =================================================================================\n    def set_speed_slow(self):\n        self.int_speed = 0\n        self.int_zonedata = 10 \n    # =================================================================================\n    def set_tool0(self):\n        # toolnumber: 0 = tool0, 1 = vacgrip_vert, 2 = hokuyo\n        self.int_tool = 0\n    # =================================================================================\n    def set_tool_meshmould(self):\n        # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo\n        self.int_tool = 1\n    # =================================================================================\n    def set_tool_meshmould_withbendingpin(self):\n        # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo\n        self.int_tool = 2\n    # =================================================================================\n    def set_tool_mtip(self):\n        # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo\n        self.int_tool = 3\n    \n    \"\"\"\n    # =================================================================================\n    def set_tool_vakgrip(self):\n        # toolnumber: 0 = tool0, 1 = vacgrip_vert, 2 = hokuyo\n        self.int_tool = 1\n    \"\"\"\n    \"\"\"\n    # =================================================================================\n    def set_tool_concrete_surface(self, ttype=\"puncher\"):\n        # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo, 3 = puncher, 4 = roller, 5 = sweeper\n        if ttype == \"puncher\":\n            self.int_tool = 4\n        elif ttype == \"roller\":\n            self.int_tool = 5\n        else: # ttype = \"sweeper\"\n            self.int_tool = 6\n    \"\"\"\n        \n    \nif __name__ == '__main__':\n    robot = ABBCommunication(\"ABB\", '192.168.125.1')\n    robot.start()\n    time.sleep(1)\n    \n    robot.set_speed_slow()\n    print robot.get_state()\n    \n    robot.send_pose_joint_pick_brick()\n    \n    time.sleep(0.1)\n    print robot.get_state()\n    \n    while robot.get_state() <> 1:\n        \n        #robot.send_pose_joint_home()\n        #time.sleep(0.2)\n        #robot.send_pose_joints_pick_brick()\n        time.sleep(0.01)\n        current_pose_joints = robot.get_current_pose_joint()\n        print current_pose_joints\n        print robot.cmd_exec_counter_from_client\n        print robot.cmd_counter_to_client\n    \n    print \"comd sent: \", robot.cmd_counter_to_client\n    print \"cmd exec: \", robot.cmd_exec_counter_from_client\n    print \"state: \", robot.get_state()\n    \"\"\"\n    robot.send_pose_joint_home()\n    \n    \n    time.sleep(0.1)\n    \n    print robot.get_state()\n    \n    while robot.get_state() <> 1:\n        \n        #robot.send_pose_joint_home()\n        #time.sleep(0.2)\n        #robot.send_pose_joints_pick_brick()\n        time.sleep(0.01)\n        current_pose_joints = robot.get_current_pose_joint()\n        print current_pose_joints\n    \n    robot.wait_for_state_ready(0.0)   \n        \n    robot.set_speed_slow()\"\"\"\n    \n    print \"ready\"\n    robot.close()\n    print \"closed\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}