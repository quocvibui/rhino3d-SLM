{
  "source_url": "https://github.com/jmuozan/AI_3D_Models_Grasshopper/blob/78dd4b9f2e516663e222b8d83085bcce27541137/SCRIPTS/V1.0.0/AI_generated_breps.py",
  "repo": "jmuozan/AI_3D_Models_Grasshopper",
  "repo_stars": 31,
  "repo_description": "Set of AI Tools for Grasshopper in Rhino 8",
  "license": "MIT",
  "filepath": "SCRIPTS/V1.0.0/AI_generated_breps.py",
  "instruction": "Ai generated breps",
  "code": "import time\nimport os\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport shutil\nimport scriptcontext as sc\nfrom datetime import datetime\nfrom kittycad.api.ai import create_text_to_cad, get_text_to_cad_model_for_user\nfrom kittycad.client import Client\nfrom kittycad.models.api_call_status import ApiCallStatus\nfrom kittycad.models.file_export_format import FileExportFormat\nfrom kittycad.models.text_to_cad_create_body import TextToCadCreateBody\n\nAPI_KEY = api\nclient = Client(token=API_KEY)\n\noutput_dir = path\n\n# Ensure directory exists\nos.makedirs(output_dir, exist_ok=True)\na = 2  # 'a' to determine the output format (Delete this option when I have time). Change this value to 1, 2, or 3 to get .stl, .step, or .obj. Better leave it as step. it has way better topology\n\n# 'run_code' controls whether the script should run or not\nrun_code = generate \n\nif run_code:\n    if a == 1:\n        output_format = FileExportFormat.STL\n        file_extension = \"stl\"\n    elif a == 2:\n        output_format = FileExportFormat.STEP\n        file_extension = \"step\"\n    elif a == 3:\n        output_format = FileExportFormat.OBJ\n        file_extension = \"obj\"\n    else:\n        raise ValueError(\"Invalid value for 'a'. Choose 1 for .stl, 2 for .step, or 3 for .obj.\")\n\n    # Prompt to generate a 3D mode\n    response = create_text_to_cad.sync(\n        client=client,\n        output_format=output_format,\n        body=TextToCadCreateBody(\n            prompt=prompt,\n        ),\n    )\n\n    # Check if the task is complete\n    while response.completed_at is None:\n        time.sleep(5)\n\n        response = get_text_to_cad_model_for_user.sync(\n            client=client,\n            id=response.id,\n        )\n\n    if response.status == ApiCallStatus.FAILED:\n        print(f\"Text-to-CAD failed: {response.error}\")\n\n    elif response.status == ApiCallStatus.COMPLETED:\n        # Print out generated files\n        print(f\"Text-to-CAD completed and returned {len(response.outputs)} files:\")\n        for name in response.outputs:\n            print(f\"  * {name}\")\n\n        # Saving data\n        final_result = response.outputs[f\"source.{file_extension}\"]\n        output_file_path = os.path.join(output_dir, f\"text-to-cad-output.{file_extension}\")\n        with open(output_file_path, \"w\", encoding=\"utf-8\") as output_file:\n            output_file.write(final_result.get_decoded().decode(\"utf-8\"))\n            print(f\"Saved to {output_file_path}\")\nelse:\n    print(\"Script execution skipped as run_code False.\")\n\n\ndef import_step_file(step_file_path):\n    # Ensure the file path is a string\n    if not isinstance(step_file_path, str):\n        print(\"Invalid path:\", step_file_path)\n        return []\n\n    # Ensure the file exists\n    if not os.path.exists(step_file_path):\n        print(\"File does not exist:\", step_file_path)\n        return []\n\n    rs.Command(f\"_-Import \\\"{step_file_path}\\\" _Enter\", False)\n\n    # Delay\n    time.sleep(2)  \n    sc.doc.Views.Redraw()\n\n    # RhinoCommon\n    from Rhino.DocObjects import ObjectEnumeratorSettings\n\n    settings = ObjectEnumeratorSettings()\n    settings.IncludeLights = False\n    settings.IncludeGrips = False\n    settings.IncludeAnnotations = False\n    settings.IncludeInstances = False\n    settings.IncludeDetails = False\n    settings.IncludeHatchPatterns = False\n    settings.IncludeMeshes = False\n    settings.IncludeCurves = False\n    settings.IncludePoints = False\n    settings.IncludeSurfaces = False\n    settings.IncludeBrep = True  \n\n    # Retrieve all objects\n    imported_objects = list(Rhino.RhinoDoc.ActiveDoc.Objects.GetObjectList(settings))\n    \n    print(f\"Found {len(imported_objects)} objects in the document.\")\n\n    # Delete objects\n    for obj in imported_objects:\n        Rhino.RhinoDoc.ActiveDoc.Objects.Delete(obj, True)  \n\n    return imported_objects\n\n\ndef get_breps_from_objects(object_list):\n    if object_list is None:\n        return []\n\n    breps = []\n    for obj in object_list:\n        if isinstance(obj.Geometry, Rhino.Geometry.Brep):\n            breps.append(obj.Geometry)\n        else:\n            print(f\"Object ID {obj.Id} no Brep, is {type(obj.Geometry)}\")\n    return breps\n\ndef move_and_rename_file(step_file_path):\n    main_directory = os.path.dirname(step_file_path)\n\n    models_folder = os.path.join(main_directory, \"MODELS\")\n\n    # Check if the 'MODELS' folder exists, if not, create\n    if not os.path.exists(models_folder):\n        os.makedirs(models_folder)\n        print(f\"Created folder: {models_folder}\")\n\n    # Count the number of existing files in 'MODELS'\n    existing_files = [f for f in os.listdir(models_folder) if f.endswith('.step') or f.endswith('.stp')]\n    model_number = len(existing_files) + 1\n\n    current_time = datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n    file_name = f\"model-{model_number}_{current_time}.step\"\n\n    destination_path = os.path.join(models_folder, file_name)\n\n    # Move and rename\n    shutil.move(step_file_path, destination_path)\n    print(f\"Moved and renamed file to: {destination_path}\")\n\nstep_file_path = output_file_path\n\n# Import the file\nimported_objects = import_step_file(step_file_path)\n\n# Get Breps from imported objects\nbreps = get_breps_from_objects(imported_objects)\n\n# Output Breps\nif breps:\n    a = breps\n    print(f\"Output {len(breps)} Breps.\")\nelse:\n    a = \"No Breps imported\"\n    print(\"No Breps were imported.\")\n\n# Move and rename\nmove_and_rename_file(step_file_path)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}