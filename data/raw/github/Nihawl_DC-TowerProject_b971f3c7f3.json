{
  "source_url": "https://github.com/Nihawl/DC-TowerProject/blob/c7c313efa7c772023ea11650ad3fe5b7f14b282c/Tower-Project-Module05.py",
  "repo": "Nihawl/DC-TowerProject",
  "repo_stars": 0,
  "repo_description": "Tower Skin 3D Model in Python - Part of \"Design Computing\" Course in Coursera ",
  "license": "MIT",
  "filepath": "Tower-Project-Module05.py",
  "instruction": "3D SURFACE MATRIX import modules",
  "code": "#3D SURFACE MATRIX\r\n#import modules\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\ndef SurfacePoints(STRSRF, INTU, INTV):\r\n    #create empty dictionary\r\n    ptMTX = {}\r\n    srfNorm01 = {}\r\n    srfNorm02 = {}\r\n    \r\n    #find surface domain\r\n    Udomain = rs.SurfaceDomain(STRSRF,0)\r\n    Vdomain = rs.SurfaceDomain(STRSRF,1)\r\n    \r\n    #find step size\r\n    UStep = (Udomain[1] - Udomain[0])/ INTU\r\n    VStep = (Vdomain[1] - Vdomain[0])/ INTV\r\n    \r\n    #find exponential step value\r\n    expStep = DivideExponentially((Udomain[1]-Udomain[0]), INTU)\r\n    \r\n    #PLOT POINTS ON SURFACE\r\n    for i in range(INTU+1):\r\n        for j in range(INTV+1):\r\n            #define u and v in terms of i and j\r\n            #u = Udomain[0] + UStep*i\r\n            u = expStep[i]\r\n            v = Vdomain[0] + VStep*j\r\n            \r\n            #evaluate surface\r\n            point = rs.EvaluateSurface(STRSRF, u,v)\r\n            #print point\r\n            ptMTX[(i,j)] = point\r\n            \r\n            #find surface normals\r\n            vecNorm = rs.SurfaceNormal(STRSRF, (u,v))\r\n            print vecNorm\r\n            #unitize vector for scaling\r\n            vecNorm = rs.VectorUnitize(vecNorm)\r\n            #make scale a factor of distance from plane\r\n            plane = rs.WorldXYPlane()\r\n            distance = rs.DistanceToPlane(plane, point)\r\n            vecNorm = rs.VectorScale(vecNorm, 1.4)\r\n            #add to srfNorm01\r\n            srfNorm01[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            #unitize and scale vector\r\n            vecNorm= rs.VectorUnitize(vecNorm)\r\n            vecNorm = rs.VectorScale(vecNorm, 1)\r\n            #add to srfNorm02\r\n            srfNorm02[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            \r\n    #call function to generate geometry\r\n    GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV)\r\n\r\ndef   GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV):\r\n    #LOOP TO GENERATE GEOMETRY\r\n        for i in range(INTU + 1):\r\n            for j in range(INTV + 1):\r\n                if i > 0 and  j > 0 :\r\n                    ### Create Back Curve ### \r\n                    backCrv = rs.AddCurve((ptMTX[(i,j-1)],ptMTX[(i,j)],ptMTX[(i-1,j)],\r\n                    ptMTX[(i-1,j-1)],ptMTX[(i,j-1)]),1)\r\n                    \r\n                    ###Create Back Points###\r\n                    #create centre lines from midpoints\r\n                    lines = []\r\n                    midPts = []\r\n                    midpoint01 = MidPt(ptMTX[(i,j-1)],ptMTX[(i,j)])\r\n                    midpoint02 = MidPt(ptMTX[(i,j)],ptMTX[(i-1,j)])\r\n                    midpoint03 = MidPt(ptMTX[(i-1,j)],ptMTX[(i-1,j-1)])\r\n                    midpoint04 = MidPt(ptMTX[(i-1,j-1)],ptMTX[(i,j-1)])\r\n                    lines.append(rs.AddLine(midpoint01,midpoint02))\r\n                    lines.append(rs.AddLine(midpoint02,midpoint03))\r\n                    lines.append(rs.AddLine(midpoint03,midpoint04))\r\n                    lines.append(rs.AddLine(midpoint04,midpoint01))\r\n                    centroidBack= MidPt(ptMTX[(i,j-1)],ptMTX[(i-1,j)])\r\n                    rs.AddPoint(centroidBack)\r\n                    #find points for each line at parameter t \r\n                    for line in lines:\r\n                        t = 0.2\r\n                        t01 = rs.CurveParameter(line, t)\r\n                        t02 = rs.CurveParameter(line, 1-t)\r\n                        midPts.append(rs.AddPoint(rs.EvaluateCurve(line, t01)))\r\n                        midPts.append(rs.AddPoint(rs.EvaluateCurve(line, t02)))\r\n                        print midPts\r\n                    #find mid point on normSrf01\r\n                    centroidFront = MidPt(srfNorm01[(i,j-1)],srfNorm01[(i-1,j)])\r\n                    #Create Surfaces\r\n                    srf01 = rs.AddSrfPt((srfNorm01[(i,j)], midPts[1],centroidFront))\r\n                    srf02 = rs.AddSrfPt((centroidFront, midPts[0],srfNorm01[(i,j)],))\r\n                    srf03 = rs.AddSrfPt((centroidFront, midPts[2],srfNorm01[(i-1,j)]))\r\n                    srf04 = rs.AddSrfPt((srfNorm01[(i-1,j)], midPts[3],centroidFront))\r\n                    srf05 = rs.AddSrfPt((centroidFront, midPts[4],srfNorm01[(i-1,j-1)]))\r\n                    srf06 = rs.AddSrfPt((srfNorm01[(i-1,j-1)], midPts[5],centroidFront))\r\n                    srf07 = rs.AddSrfPt((centroidFront, midPts[6],srfNorm01[(i,j-1)]))\r\n                    srf08 = rs.AddSrfPt((srfNorm01[(i,j-1)], midPts[7],centroidFront))\r\n\r\n\r\n\r\n\r\n\r\n\r\ndef MidPt(PT01, PT02):\r\n    \r\n    point = None\r\n    point = [(PT01[0] + PT02[0])/2,(PT01[1] + PT02[1])/2,(PT01[2] + PT02[2])/2]\r\n    return point\r\n\r\ndef DivideExponentially(maxLength, Divisions):\r\n    #set-up lists\r\n    point = []\r\n    yVal = []\r\n    \r\n    #create point where x is .72 of Vdomain and y and z are 0 (point[0])\r\n    pt = ([(maxLength*.72), 0, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where x and y are .12 of model curve length and z is 0 (point[1])\r\n    pt = ([(maxLength*.12), (maxLength*.12), 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where y is model curve length and x and z are 0 (point[2])\r\n    pt = ([0, maxLength, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #draw a curve between the three points (GRAPHcrvGUID)\r\n    GRAPHcrvGUID = rs.AddCurve(point)\r\n    \r\n    #divide (GRAPHcrvGUID)\r\n    GRAPHpoints = rs.DivideCurve(GRAPHcrvGUID, Divisions, False, True)\r\n    \r\n    #delete curve\r\n    rs.DeleteObject(GRAPHcrvGUID)\r\n    \r\n    #collect y values in a list\r\n    for i in range(len(GRAPHpoints)):\r\n        yVal.append(GRAPHpoints[i][1])\r\n        \r\n    return yVal\r\n                  \r\ndef main():\r\n    #collect data\r\n    #strSRF = rs.GetObject('select surface', rs.filter.surface)\r\n    strSRFs = rs.GetObjects('select surfaces', rs.filter.surface)\r\n    intU = rs.GetInteger('how many U intervals?', 8)\r\n    intV = rs.GetInteger('how many V intervals?', 2)\r\n    #    rs.HideObject(strSRF)\r\n    #    #call function\r\n    #    rs.EnableRedraw(False)\r\n    #    SurfacePoints(strSRF, intU, intV)\r\n    #    rs.EnableRedraw(True)\r\n    \r\n    #call function with multiple surfaces\r\n    rs.EnableRedraw(False)\r\n    for strSRF in strSRFs:\r\n        rs.HideObject(strSRF)\r\n        #call function\r\n        SurfacePoints(strSRF, intU, intV)\r\n    rs.EnableRedraw(True)\r\n\r\nmain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}