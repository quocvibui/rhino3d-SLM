{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_fitRebuildSet_SpanCount.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_fitRebuildSet_SpanCount.py",
  "instruction": "Spb crv fit rebuild set span count",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n221221-22: Created, starting with another script.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bPreserveEndG1'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDegree'; keys.append(key)\r\n    values[key] = 3\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=2)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iPowerOf2ForMaxKnotSpanCt'; keys.append(key)\r\n    values[key] = 6\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-9:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = 1e-9\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fDevTol')\r\n        addOption('bPreserveEndG1')\r\n        addOption('iDegree')\r\n        addOption('iPowerOf2ForMaxKnotSpanCt')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDevTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getMaximumDeviation(rgCrvA, rgCrvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            rgCrvA,\r\n            rgCrvB,\r\n            tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n    if rc[0]:\r\n        return rc[1]\r\n\r\n\r\ndef rebuildFit(rgCrv_In, spanCount, degree, preserveTangents, tolerance):\r\n    \"\"\"\r\n    Returns on success:\r\n        rg.NurbsCurve,\r\n        fDeviation\r\n    Returns on fail:\r\n        None\r\n    \"\"\"\r\n\r\n    pointCount = degree + spanCount\r\n\r\n    nc_Res = rgCrv_In.Rebuild(pointCount, degree, preserveTangents)\r\n\r\n    if nc_Res is None: return\r\n\r\n    dev = getMaximumDeviation(nc_Res, rgCrv_In)\r\n    if dev is None or dev > tolerance:\r\n        nc_Res.Dispose()\r\n        return\r\n\r\n    return nc_Res, dev\r\n\r\n\r\ndef processCurves(rgCrvs_In, **kwargs):\r\n    \"\"\"\r\n    rgCrvs_In = rg.Curve\r\n    fDevTol\r\n    iDegree\r\n    bPreserv\r\n    iPowerOf2ForMaxKnotSpanCt\r\n    bEcho\r\n    bDebug\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    bPreserveEndG1 = getOpt('bPreserveEndG1')\r\n    iDegree = getOpt('iDegree')\r\n    iPowerOf2ForMaxKnotSpanCt = getOpt('iPowerOf2ForMaxKnotSpanCt')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    ncs_Out = []\r\n    devs_Out = []\r\n\r\n\r\n    iPossibleKnotCts = [2**p for p in range(iPowerOf2ForMaxKnotSpanCt+1)]\r\n\r\n\r\n    for i, nc0 in enumerate(rgCrvs_In):\r\n\r\n        if isinstance(nc0, rg.NurbsCurve):\r\n            if nc0.SpanCount == 1:\r\n                ncs_Out.append(nc0)\r\n                devs_Out.append(0.0)\r\n                continue # to next curve.\r\n\r\n        # Try single knot span count.\r\n        rc = rebuildFit(nc0, 1, iDegree, bPreserveEndG1, fDevTol)\r\n        if rc is not None:\r\n            nc_Res, dev = rc\r\n            ncs_Out.append(nc_Res)\r\n            devs_Out.append(dev)\r\n            continue # to next curve.\r\n\r\n        # Try maximum knot span counts.  Failure results in failure for all.\r\n        rc = rebuildFit(nc0, iPossibleKnotCts[-1], iDegree, bPreserveEndG1, fDevTol)\r\n        if rc is None:\r\n            print(\"Need more than {} knot spans for curve[{}].\".format(\r\n                iPossibleKnotCts[-1], i))\r\n            return\r\n\r\n        nc_Res, dev = rc\r\n\r\n\r\n        # Binary search\r\n        nc_Hi = nc_Res\r\n        dev_Hi = dev\r\n\r\n        # Po2 == Power of 2\r\n\r\n        iPo2_SpanCt_Lo = 0\r\n        iPo2_SpanCt_Hi = iPowerOf2ForMaxKnotSpanCt\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            iPo2_SpanCt_Md = (iPo2_SpanCt_Hi + iPo2_SpanCt_Lo) // 2\r\n\r\n            if iPo2_SpanCt_Md in (iPo2_SpanCt_Lo, iPo2_SpanCt_Hi):\r\n                ncs_Out.append(nc_Hi)\r\n                devs_Out.append(dev_Hi)\r\n                break # out of while loop.\r\n\r\n            rc = rebuildFit(nc0, 2**iPo2_SpanCt_Md, iDegree, bPreserveEndG1, fDevTol)\r\n            if rc is None:\r\n                iPo2_SpanCt_Lo = iPo2_SpanCt_Md\r\n                continue\r\n\r\n            nc_Res, dev = rc\r\n\r\n            nc_Hi.Dispose()\r\n            nc_Hi = nc_Res\r\n            dev_Hi = dev\r\n            iPo2_SpanCt_Hi = iPo2_SpanCt_Md\r\n\r\n    return ncs_Out, devs_Out\r\n\r\n\r\ndef processCurveObjects(curvesAndEdges0, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    bPreserveEndG1 = getOpt('bPreserveEndG1')\r\n    iDegree = getOpt('iDegree')\r\n    iPowerOf2ForMaxKnotSpanCt = getOpt('iPowerOf2ForMaxKnotSpanCt')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    list_bIsWire = []\r\n    gObjs_In = []\r\n    rgCrvs_In = []\r\n\r\n\r\n    for curveOrEdge0 in curvesAndEdges0:\r\n        rdObj_In = rs.coercerhinoobject(curveOrEdge0)\r\n        if isinstance(rdObj_In, rd.CurveObject):\r\n            list_bIsWire.append(True)\r\n        elif isinstance(rdObj_In, rd.BrepObject):\r\n            list_bIsWire.append(False)\r\n        else:\r\n            raise ValueError(\"Invalid input: {}\".format(rdObj_In))\r\n        \r\n        gObjs_In.append(rdObj_In.Id)\r\n        \r\n        rgCrvs_In.append(rs.coercecurve(curveOrEdge0))\r\n\r\n\r\n    rc = processCurves(\r\n        rgCrvs_In=rgCrvs_In,\r\n        fDevTol=fDevTol,\r\n        bPreserveEndG1=bPreserveEndG1,\r\n        iDegree=iDegree,\r\n        iPowerOf2ForMaxKnotSpanCt=iPowerOf2ForMaxKnotSpanCt,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n\r\n    if rc is None: return\r\n\r\n    ncs_Res, devs_Res = rc\r\n\r\n\r\n    ct_Replaced = 0\r\n    ct_Added = 0\r\n\r\n    for gObj_In, nc2, bIsWire in zip(gObjs_In, ncs_Res, list_bIsWire):\r\n        if bReplace and bIsWire:\r\n            if sc.doc.Objects.Replace(gObj_In, nc2):\r\n                ct_Replaced += 1\r\n        else:\r\n            gCrv1 = sc.doc.Objects.AddCurve(nc2)\r\n            if gCrv1 != gCrv1.Empty:\r\n                ct_Added += 1\r\n\r\n    s = \"\"\r\n\r\n    if bReplace and any(list_bIsWire):\r\n        if ct_Replaced == 0:\r\n            s += \"No wires were replaced.\".format(ct_Replaced)\r\n        elif ct_Replaced == len(gObjs_In):\r\n            s += \"All {} wires were replaced.\".format(ct_Replaced)\r\n        else:\r\n            s +=  \"Only {} out of {} wires were replaced.\".format(ct_Replaced, len(gObjs_In))\r\n\r\n    if ct_Added == len(gObjs_In):\r\n        s += \"All {} curves were added.\".format(ct_Added)\r\n    elif not all(list_bIsWire):\r\n        s += \"Only {} out of {} curves were added.\".format(ct_Added, len(gObjs_In))\r\n\r\n    s += \"  Degree: {}\".format(nc2.Degree)\r\n    s += \"  CpCt: {}\".format(nc2.Points.Count)\r\n    s += \"  Maximum deviation: {0:.{1}f}\".format(\r\n            max(devs_Res), sc.doc.ModelDistanceDisplayPrecision)\r\n    \r\n    print(s)\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n\r\n    fDevTol = Opts.values['fDevTol']\r\n    bPreserveEndG1 = Opts.values['bPreserveEndG1']\r\n    iDegree = Opts.values['iDegree']\r\n    iPowerOf2ForMaxKnotSpanCt = Opts.values['iPowerOf2ForMaxKnotSpanCt']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Working ...\")\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    processCurveObjects(\r\n        curvesAndEdges0=objrefs,\r\n        fDevTol=fDevTol,\r\n        bPreserveEndG1=bPreserveEndG1,\r\n        iDegree=iDegree,\r\n        iPowerOf2ForMaxKnotSpanCt=iPowerOf2ForMaxKnotSpanCt,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}