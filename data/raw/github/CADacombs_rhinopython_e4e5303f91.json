{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_OffsetNormal.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_OffsetNormal.py",
  "instruction": "This script is an alternative to _OffsetNormal in that it:\r\n    1. Has options on how to prepare the input curves.\r\n    2. Will offset within an input tolerance (Loose=No).\r\n\r\nSend any questions,...",
  "code": "\"\"\"\r\nThis script is an alternative to _OffsetNormal in that it:\r\n    1. Has options on how to prepare the input curves.\r\n    2. Will offset within an input tolerance (Loose=No).\r\n\r\nSend any questions, comments, or script development service needs to @spb on the McNeel Forums:\r\nhttps://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n231227-240101: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom clr import StrongBox\r\nfrom System import Array\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bUseFaceOfSelNakedEdge'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLoose'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExplodePolyCrv'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bRebuild'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'TryToRebuild'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSplitAtNonG2Knots'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDistance'; keys.append(key)\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n        values[key] = 1.0\r\n    else:\r\n        values[key] = 10.0 * Rhino.RhinoMath.UnitScale(\r\n            Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fTol'; keys.append(key)\r\n    # 1/3 for offset, 1/3 for pipe, 1/3 for pipe trim.\r\n    values[key] = max((0.33*sc.doc.ModelAbsoluteTolerance, 1e-6))\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAlignEndDirs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLoft'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'AlsoAddFin'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _addCommonOptions(go):\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    addOption('bExplodePolyCrv')\r\n    addOption('bRebuild')\r\n    addOption('bSplitAtNonG2Knots')\r\n    addOption('fDistance')\r\n    addOption('bAlignEndDirs')\r\n    addOption('bLoose')\r\n    if not Opts.values['bLoose']:\r\n        addOption('fTol')\r\n    addOption('bLoft')\r\n    addOption('bEcho')\r\n    addOption('bDebug')\r\n\r\n    return idxs_Opt\r\n\r\n\r\ndef _getInput_Curve():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curve on face\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    #bPreselectedObjsChecked = False\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        addOption('bUseFaceOfSelNakedEdge')\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_CrvOnFace = go.Object(0)\r\n            go.Dispose()\r\n\r\n            return objref_CrvOnFace\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDistance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Face():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select base face\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_Face = go.Object(0)\r\n\r\n            go.Dispose()\r\n    \r\n            return objref_Face\r\n\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDistance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Click():\r\n    \"\"\"\r\n    Click to toggle angle and/or direction with optional input.\r\n\r\n    Returns:\r\n        True: To recalculate and reloop\r\n        False: To not recalculate and break out of loop with current output.\r\n        None: To not recalculate and return without output.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetPoint()\r\n\r\n    go.SetCommandPrompt(\"Left click to flip direction\")\r\n\r\n    go.SetCommandPromptDefault(\"Accept result\")\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    key = 'FlipDir'; idxs_Opt[key] = go.AddOption(key)\r\n\r\n    idxs_Opt.update(_addCommonOptions(go))\r\n\r\n    res = go.Get()\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        go.Dispose()\r\n        return\r\n\r\n    if res == ri.GetResult.Nothing:\r\n        go.Dispose()\r\n        return False\r\n\r\n    if res == ri.GetResult.Point:\r\n        Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n        Opts.setValue('fDistance')\r\n        go.Dispose()\r\n        return True\r\n\r\n    if res == ri.GetResult.Number:\r\n        key = 'fDistance'\r\n        Opts.riOpts[key].CurrentValue = go.Number()\r\n        Opts.setValue(key)\r\n        go.Dispose()\r\n        return True\r\n\r\n    # An option was selected.\r\n\r\n    if go.OptionIndex() == idxs_Opt['FlipDir']:\r\n        Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n        Opts.setValue('fDistance')\r\n        go.Dispose()\r\n        return True\r\n\r\n    for key in idxs_Opt:\r\n        if go.Option().Index == idxs_Opt[key]:\r\n            Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n            break\r\n\r\n    go.Dispose()\r\n    return True\r\n\r\n\r\ndef crvWithSpansCompletelyOnFace(rgCrv, rgFace, t_Crv_Pick, fTol, bDebug=False):\r\n    \"\"\"\r\n    Only process spans of the curve whose spans start and ends are on the Face.\r\n    \"\"\"\r\n    iSpans_OnFace = []\r\n    for iSpan in xrange(rgCrv.SpanCount):\r\n        t = rgCrv.SpanDomain(iSpan).T0\r\n        pt_OnCrv = rgCrv.PointAt(t)\r\n        bSuccess, u, v = rgFace.ClosestPoint(pt_OnCrv)\r\n        if not bSuccess: continue\r\n        pt_OnFace = rgFace.PointAt(u,v)\r\n        dist = pt_OnFace.DistanceTo(pt_OnCrv)\r\n        if dist > fTol:\r\n            if bDebug:\r\n                sEval='dist'; print(sEval+': ',eval(sEval))\r\n                print(\"PointAtStart not on underlying surface.\")\r\n            continue\r\n        \r\n        t = rgCrv.SpanDomain(iSpan).T1\r\n        pt_OnCrv = rgCrv.PointAt(t)\r\n        bSuccess, u, v = rgFace.ClosestPoint(pt_OnCrv)\r\n        if not bSuccess: continue\r\n        pt_OnFace = rgFace.PointAt(u,v)\r\n        dist = pt_OnFace.DistanceTo(pt_OnCrv)\r\n        if dist > fTol:\r\n            if bDebug:\r\n                #sc.doc.Objects.AddPoint(pt_OnFace)\r\n                sEval='dist'; print(sEval+': ',eval(sEval))\r\n                print(\"PointAtEnd not on underlying surface.\")\r\n            continue\r\n        \r\n        iSpans_OnFace.append(iSpan)\r\n    \r\n    if not iSpans_OnFace:\r\n        print(\"None of the spans of the curve are completely on the face.\")\r\n        rgFace.Brep.Dispose()\r\n        return\r\n\r\n    if len(iSpans_OnFace) == rgCrv.SpanCount:\r\n        return rgCrv.Duplicate()\r\n\r\n    if len(iSpans_OnFace) == 1:\r\n        return rgCrv.Trim(\r\n            rgCrv.SpanDomain(iSpans_OnFace[0]).T0,\r\n            rgCrv.SpanDomain(iSpans_OnFace[0]).T1)\r\n\r\n    # Create nested lists of contiguous spans so that curves that go off and\r\n    # on the face can be correctly processed.\r\n    iSpans_Contiguous_nests = [[iSpans_OnFace[0]]]\r\n    for iSpan in iSpans_OnFace[1:]:\r\n        if iSpan == iSpans_Contiguous_nests[-1][-1] + 1:\r\n            iSpans_Contiguous_nests[-1].append(iSpan)\r\n        else:\r\n            iSpans_Contiguous_nests.append([iSpan])\r\n        \r\n    if rgCrv.IsClosed and len(iSpans_Contiguous_nests) > 1:\r\n        if (\r\n                iSpans_Contiguous_nests[0][0] == 0 and\r\n                iSpans_Contiguous_nests[-1][-1] == rgCrv.SpanCount-1\r\n        ):\r\n            iSpans_Contiguous_nests[0] = iSpans_Contiguous_nests[-1] + iSpans_Contiguous_nests[0]\r\n            iSpans_Contiguous_nests.pop()\r\n    \r\n    if len(iSpans_Contiguous_nests) == 1:\r\n        rgC_Out = rgCrv.Trim(\r\n                rgCrv.SpanDomain(iSpans_Contiguous_nests[0][0]).T0,\r\n                rgCrv.SpanDomain(iSpans_Contiguous_nests[0][-1]).T1)\r\n    elif len(iSpans_Contiguous_nests) > 1:\r\n        for iSpan_NestIndex, iSpans_Contiguous in enumerate(iSpans_Contiguous_nests):\r\n            for iSpan in iSpans_Contiguous:\r\n                if rgCrv.SpanDomain(iSpan).T0 <= t_Crv_Pick <= rgCrv.SpanDomain(iSpan).T1:\r\n                    rgC_Out = rgCrv.Trim(\r\n                            rgCrv.SpanDomain(iSpans_Contiguous_nests[iSpan_NestIndex][0]).T0,\r\n                            rgCrv.SpanDomain(iSpans_Contiguous_nests[iSpan_NestIndex][-1]).T1)\r\n                else:\r\n                    print(\"Curve was not picked within the face.\")\r\n                    rgCrv.Dispose()\r\n                    return\r\n        \r\n    if bDebug:\r\n        sc.doc.Objects.AddCurve(rgC_Out)\r\n\r\n    return rgC_Out\r\n\r\n\r\ndef _getOffsetDeviation(crvA, crvB, fTarget):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    if not rc[0]:\r\n        print(\"GetDistancesBetweenCurves returned None.  The offset may be inverted to reference.\")\r\n        return None\r\n\r\n    fDev_Max = rc[1]\r\n    fDev_Min = rc[4]\r\n\r\n    return max((abs(abs(fTarget)-fDev_Max), abs(abs(fTarget)-fDev_Min)))\r\n\r\n\r\ndef _do_curves_deviate_within_tolerance(crvA, crvB, fTarget, fTol, fSamplingDist=None, bDebug=False):\r\n    \"\"\"\r\n    Uses Curve.ClosestPoint instead of Curve.GetDistancesBetweenCurves.\r\n    \"\"\"\r\n\r\n    if fSamplingDist is None:\r\n        fSamplingDist = 10.0 * fTol\r\n\r\n    fLimit_Min = abs(fTarget) - fTol\r\n    fLimit_Max = abs(fTarget) + fTol\r\n\r\n    strongBox_points = StrongBox[Array[rg.Point3d]]()\r\n\r\n    rc = crvA.DivideByLength(\r\n        segmentLength=fSamplingDist,\r\n        includeEnds=True,\r\n        points=strongBox_points)\r\n\r\n    pts = list(strongBox_points.Value)\r\n    if bDebug: sEval = \"len(pts)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    devs = []\r\n\r\n    for ptA in pts:\r\n        bSuccess, t = crvB.ClosestPoint(ptA)\r\n        if not bSuccess:\r\n            raise ValueError(\"Curve.ClosestPoint failed.\")\r\n        ptB = rg.Curve.PointAt(crvB, t)\r\n        dev = ptA.DistanceTo(ptB)\r\n        devs.append(dev)\r\n        #if bDebug: sc.doc.Objects.AddLine(ptA, ptB)\r\n        if dev < fLimit_Min:\r\n            return False\r\n        if dev > fLimit_Max:\r\n            return False\r\n\r\n    #sEval = \"rg.Curve.GetDistancesBetweenCurves(crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\"\r\n    #print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    # For debugging.\r\n    if bDebug:\r\n        #fDev_Min = min(devs)\r\n        sEval = \"min(devs)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        #fDev_Max = max(devs)\r\n        sEval = \"max(devs)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    return True\r\n\r\n\r\ndef _getDistancesBetweenCurves(crvA, crvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    if not rc[0]:\r\n        raise Exception(\"GetDistancesBetweenCurves returned None.\")\r\n        return None\r\n\r\n    return rc[1]\r\n\r\n\r\ndef _matchCrvEndDirs(nc_ToMod, nc_Ref):\r\n    \"\"\"\r\n    nc_ToMod is modified.\r\n    \"\"\"\r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=False,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtStart,\r\n        tangent=nc_Ref.TangentAtStart)\r\n    if not bSuccess:\r\n        print(\"SetEndCondition failed.\")\r\n        return False\r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=True,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtEnd,\r\n        tangent=nc_Ref.TangentAtEnd)\r\n    if not bSuccess:\r\n        print(\"SetEndCondition failed.\")\r\n        return False\r\n\r\n    return True\r\n\r\n\r\ndef _rebuildCrv(rgCrv_In, fTol_Simplify, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        Curve, float(deviation)\r\n        None for no rebuild within tolerance.\r\n    \"\"\"\r\n\r\n    #if isinstance(rgCrv_In, rg.PolylineCurve):\r\n    #    raise Exception(\"PolylineCurve is not supported.\")\r\n    if isinstance(rgCrv_In, (rg.LineCurve, rg.ArcCurve)):\r\n        return\r\n\r\n    nc_WIP = rgCrv_In.ToNurbsCurve()\r\n\r\n    if nc_WIP.SpanCount == 1:\r\n        if bDebug: print(\"Curve already has only 1 span.\")\r\n        return\r\n\r\n\r\n    if nc_WIP.IsPeriodic and (nc_WIP.Knots.KnotStyle == rg.KnotStyle.Uniform):\r\n        if bDebug:\r\n            sEval = \"nc_WIP.Knots.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            print(\"Curve is already periodic and uniform.\")\r\n        return\r\n\r\n\r\n    # Try to rebuild as a Bezier.\r\n    for degree in 1,2,3,5:\r\n        nc_Rebuilt = nc_WIP.Rebuild(\r\n            pointCount=degree+1,\r\n            degree=degree,\r\n            preserveTangents=True)\r\n\r\n        dev = _getDistancesBetweenCurves(nc_WIP, nc_Rebuilt)\r\n        if dev <= fTol_Simplify:\r\n            nc_WIP.Dispose()\r\n            return nc_Rebuilt, dev\r\n\r\n        nc_Rebuilt.Dispose()\r\n\r\n\r\n    if nc_WIP.Degree != 3:\r\n        return\r\n\r\n    if (nc_WIP.Knots.KnotStyle in (\r\n        rg.KnotStyle.QuasiUniform,\r\n        rg.KnotStyle.Uniform)\r\n    ):\r\n        if bDebug: print(\"Curve is already {}.\".format(nc_WIP.Knots.KnotStyle))\r\n        return\r\n\r\n\r\n    # Try to rebuild as degree-3 uniform.\r\n    pointcount = 5\r\n    while True:\r\n        nc_Rebuilt = nc_WIP.Rebuild(\r\n            pointCount=pointcount,\r\n            degree=3,\r\n            preserveTangents=True)\r\n\r\n        dev = _getDistancesBetweenCurves(nc_WIP, nc_Rebuilt)\r\n        if dev <= fTol_Simplify:\r\n            nc_WIP.Dispose()\r\n            return nc_Rebuilt, dev\r\n\r\n        nc_Rebuilt.Dispose()\r\n\r\n        pointcount += 1\r\n        if pointcount > 103:\r\n            return\r\n\r\n\r\ndef _split_NurbsCrv_at_nonG2_knots(nc_In):\r\n    \"\"\"\r\n    Always returns a list of curves.\r\n    \"\"\"\r\n\r\n    if not isinstance(nc_In, rg.NurbsCurve):\r\n        return [nc_In]\r\n\r\n    ts_polyknots = []\r\n\r\n    if nc_In.IsPeriodic:\r\n        iKs = range(nc_In.Knots.Count)\r\n    elif nc_In.IsClosed:\r\n        iKs = range(nc_In.Knots.Count - nc_In.Degree)\r\n    else:\r\n        iKs = range(nc_In.Degree, nc_In.Knots.Count - nc_In.Degree)\r\n\r\n    for iK in iKs:\r\n        if nc_In.Knots.KnotMultiplicity(iK) > (nc_In.Degree-2):\r\n            ts_polyknots.append(nc_In.Knots[iK])\r\n\r\n    if not ts_polyknots:\r\n        return [nc_In.DuplicateCurve()]\r\n\r\n    rc = nc_In.Split(ts_polyknots)\r\n\r\n    if not rc:\r\n        print(\"Splitting at non-G2 knots failed.  Check input.\")\r\n        return [nc_In]\r\n\r\n    return rc\r\n\r\n\r\ndef prepareCrvToOffset(rgCrv_In, bExplodePolyCrv, bRebuild, bSplitAtNonG2Knots, bMakeDeformable, fTol, bDebug=False):\r\n\r\n    if bRebuild:\r\n        # Attempt to rebuild to the full tolerance.\r\n        rc = _rebuildCrv(rgCrv_In, fTol_Simplify=fTol, bDebug=bDebug)\r\n        if rc:\r\n            return [rc[0]], rc[1]\r\n\r\n    if bExplodePolyCrv and isinstance(rgCrv_In, rg.PolyCurve):\r\n        ncs_WIP = [_.ToNurbsCurve() for _ in rgCrv_In.Explode()]\r\n    else:\r\n        ncs_WIP = [rgCrv_In.ToNurbsCurve()]\r\n\r\n    fDev = 0.0\r\n\r\n    if bRebuild:\r\n        # Rebuilding to a smaller tolerance to reduce tolerance stackup.\r\n        fTol_Simplify = max((0.5*fTol, 1e-4))\r\n        if bDebug: sEval = \"fTol_Simplify\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        ncs_Simplified = []\r\n        fDevs_thisRebuild = []\r\n        for nc_WIP in ncs_WIP:\r\n            rc = _rebuildCrv(nc_WIP, fTol_Simplify=fTol_Simplify, bDebug=bDebug)\r\n            if rc:\r\n                nc_WIP.Dispose()\r\n                ncs_Simplified.append(rc[0])\r\n                fDevs_thisRebuild.append(rc[1])\r\n            else:\r\n                ncs_Simplified.append(nc_WIP)\r\n        ncs_WIP = ncs_Simplified\r\n        if fDevs_thisRebuild:\r\n            fDev = max(fDevs_thisRebuild)\r\n\r\n    if bSplitAtNonG2Knots:\r\n        ncs_Split = []\r\n        for nc_WIP in ncs_WIP:\r\n            rc = _split_NurbsCrv_at_nonG2_knots(nc_WIP)\r\n            ncs_Split.extend(rc)\r\n            nc_WIP.Dispose()\r\n        ncs_WIP = ncs_Split\r\n\r\n    if bRebuild:\r\n        ncs_Simplified = []\r\n        fDevs_thisRebuild = []\r\n        for nc_WIP in ncs_WIP:\r\n            rc = _rebuildCrv(nc_WIP, fTol_Simplify=fTol_Simplify, bDebug=bDebug)\r\n            if rc:\r\n                nc_WIP.Dispose()\r\n                ncs_Simplified.append(rc[0])\r\n                fDevs_thisRebuild.append(rc[1])\r\n            else:\r\n                ncs_Simplified.append(nc_WIP)\r\n        ncs_WIP = ncs_Simplified\r\n        if fDevs_thisRebuild:\r\n            fDev += max(fDevs_thisRebuild)\r\n\r\n    if bMakeDeformable:\r\n        for i in range(len(ncs_WIP)):\r\n            if ncs_WIP[i].Degree < 3 and ncs_WIP[i].Points.Count < 4:\r\n                ncs_WIP[i].IncreaseDegree(3)\r\n\r\n    return ncs_WIP, fDev\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.crvs = []\r\n        self.breps = []\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        for crv in self.crvs:\r\n            bbox = crv.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n        for brep in self.breps:\r\n            bbox = brep.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        color = sc.doc.Layers.CurrentLayer.Color\r\n\r\n        for crv in self.crvs:\r\n            drawEventArgs.Display.DrawCurve(\r\n                curve=crv,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n        for brep in self.breps:\r\n\r\n            displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n            da = displayMode.DisplayAttributes\r\n            if da.ShadingEnabled:\r\n                drawEventArgs.Display.DrawBrepShaded(\r\n                    brep=brep,\r\n                    material=Rhino.Display.DisplayMaterial(diffuse=color))\r\n            drawEventArgs.Display.DrawBrepWires(\r\n                brep=brep,\r\n                color=color,\r\n                wireDensity=1)\r\n\r\n\r\ndef _createNurbsCurve_with_more_knots(nc_In, iQtyToAddInEachSpan):\r\n    \"\"\"\r\n    Knots are added uniformly with each span.\r\n\r\n    Parameters:\r\n        nc_In: rg.NurbsSurface,\r\n        iQtyToAddInEachSpan: int\r\n\r\n    Returns: rg.NurbsSurface\r\n    \"\"\"\r\n\r\n    if iQtyToAddInEachSpan < 1:\r\n        return\r\n\r\n    nc_Out = nc_In.ToNurbsCurve()\r\n\r\n    # Add knots from Domain end to beginning.\r\n\r\n    for iK in range(nc_In.Knots.Count-1, 0, -1):\r\n\r\n        k_R = nc_In.Knots[iK]\r\n        k_L = nc_In.Knots[iK-1]\r\n\r\n        for i in range(iQtyToAddInEachSpan):\r\n            fraction_from_R = float(i+1) / float(iQtyToAddInEachSpan+1)\r\n            k_M = fraction_from_R*k_R + (1.0-fraction_from_R)*k_L\r\n            nc_Out.Knots.InsertKnot(k_M)\r\n\r\n    return nc_Out\r\n\r\n\r\ndef createOffsetCurve(rgCrv_In, rgSrf, bLoose, bAlignEndDirs, fDistance, fTol, fSamplingDist, bDebug):\r\n\r\n    if bDebug:\r\n        sEval = \"fTol\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    if isinstance(rgSrf, rg.BrepFace) and rgSrf.OrientationIsReversed:\r\n        height = -fDistance\r\n    else:\r\n        height = fDistance\r\n\r\n    nc_Offset = rgCrv_In.OffsetNormalToSurface(\r\n        surface=rgSrf, height=height)\r\n\r\n    if (bAlignEndDirs and\r\n        not _matchCrvEndDirs(nc_Offset, rgCrv_In)\r\n    ):\r\n        raise Exception(\"Alignment of end tangent failed.\")\r\n\r\n    dev = _getOffsetDeviation(rgCrv_In, nc_Offset, height)\r\n    if bDebug: sEval = \"dev\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    if bLoose:\r\n        return nc_Offset, dev\r\n\r\n    if dev is None:\r\n        return\r\n\r\n    if dev <= fTol:\r\n        if rgCrv_In.Degree == 3 and nc_Offset.Degree == 3:\r\n            rc = _rebuildCrv(nc_Offset, fTol_Simplify=fTol-dev, bDebug=bDebug)\r\n            if rc:\r\n                nc_Offset.Dispose()\r\n                nc_Offset, dev_Rebuild = rc\r\n                dev += dev_Rebuild\r\n\r\n        return nc_Offset, dev\r\n\r\n    #if _do_curves_deviate_within_tolerance(rgCrv_In, nc_Offset, height, fTol, fSamplingDist, bDebug=bDebug):\r\n    #    return nc_Offset\r\n\r\n    nc_Offset.Dispose()\r\n\r\n    # Add knots and try again.\r\n    i = 0\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        i += 1\r\n        if i == 51:\r\n            return\r\n\r\n        if bDebug: sEval = \"i\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        nc_ToOffset = _createNurbsCurve_with_more_knots(\r\n            rgCrv_In,\r\n            iQtyToAddInEachSpan=i)\r\n\r\n        nc_Offset = nc_ToOffset.OffsetNormalToSurface(\r\n            surface=rgSrf, height=height)\r\n\r\n        if (bAlignEndDirs and\r\n            not _matchCrvEndDirs(nc_Offset, rgCrv_In)\r\n        ):\r\n            raise Exception(\"Alignment of end tangent failed.\")\r\n\r\n        dev = _getOffsetDeviation(rgCrv_In, nc_Offset, height)\r\n        if bDebug: sEval = \"dev\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if (dev is not None) and (dev <= fTol):\r\n            print(\"Added {} knots between spans.\".format(i))\r\n            print(\"But attempting to rebuild ...\")\r\n\r\n            if rgCrv_In.Degree == 3 and nc_Offset.Degree == 3:\r\n                rc = _rebuildCrv(nc_Offset, fTol_Simplify=fTol-dev, bDebug=bDebug)\r\n                if rc:\r\n                    nc_Offset.Dispose()\r\n                    nc_Offset, dev_Rebuild = rc\r\n                    dev += dev_Rebuild\r\n\r\n            return nc_Offset, dev\r\n\r\n        #if _do_curves_deviate_within_tolerance(\r\n        #    rgCrv_In, nc_Offset, height, fTol, fSamplingDist,\r\n        #    bDebug=bDebug\r\n        #):\r\n        #    return nc_Offset\r\n\r\n        nc_ToOffset.Dispose()\r\n        nc_Offset.Dispose()\r\n\r\n\r\ndef _createGeometryInteractively():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    objref_CrvToOffset = _getInput_Curve()\r\n    if objref_CrvToOffset is None: return\r\n\r\n\r\n    bUseFaceOfSelNakedEdge = Opts.values['bUseFaceOfSelNakedEdge']\r\n\r\n\r\n    rgEdge = objref_CrvToOffset.Edge()\r\n\r\n    if rgEdge and bUseFaceOfSelNakedEdge and rgEdge.Valence == rg.EdgeAdjacency.Naked:\r\n        idxF = objref_CrvToOffset.Edge().AdjacentFaces()[0]\r\n        rgF_In = rgEdge.Brep.Faces[idxF]\r\n    else:\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n        objref_Face = _getInput_Face()\r\n        if objref_Face is None: return\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n\r\n        rgF_In = objref_Face.Face()\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    bLoose = Opts.values['bLoose']\r\n    bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n    bExplodePolyCrv = Opts.values['bExplodePolyCrv']\r\n    bSplitAtNonG2Knots = Opts.values['bSplitAtNonG2Knots']\r\n    bRebuild = Opts.values['bRebuild']\r\n    fDistance = Opts.values['fDistance']\r\n    fTol = Opts.values['fTol']\r\n    bLoft = Opts.values['bLoft']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    rgC_In, t_Crv0_Pick = objref_CrvToOffset.CurveParameter()\r\n\r\n\r\n    if isinstance(rgC_In, rg.PolyCurve):\r\n        rgC_In.RemoveNesting()\r\n\r\n\r\n    rgC_In_TrimmedToFace = crvWithSpansCompletelyOnFace(\r\n        rgC_In, rgF_In, t_Crv0_Pick, 0.1*fTol, bDebug)\r\n    if rgC_In_TrimmedToFace is None: return\r\n\r\n    if (\r\n        bDebug and\r\n        isinstance(rgC_In, rg.NurbsCurve) and\r\n        isinstance(rgC_In_TrimmedToFace, rg.NurbsCurve)\r\n    ):\r\n        sEval = \"rgC_In.EpsilonEquals(rgC_In_TrimmedToFace, 1e-6)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    if rgC_In_TrimmedToFace.IsClosed and fAngle_End_Deg:\r\n        fAngle_End_Deg = Opts.values['fAngle_End_Deg'] = sc.sticky[Opts.stickyKeys['fAngle_End_Deg']] = None\r\n        bVariableAngle = Opts.values['bVariableAngle'] = sc.sticky[Opts.stickyKeys['bVariableAngle']] = False\r\n\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__) # StickyKey\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n        conduit.Enabled = False\r\n    else:\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n    fSamplingDist = 100.0*sc.doc.ModelAbsoluteTolerance\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        ncs_toOffset, fDev_fromRebuilds = prepareCrvToOffset(\r\n            rgC_In_TrimmedToFace,\r\n            bExplodePolyCrv=bExplodePolyCrv,\r\n            bRebuild=bRebuild,\r\n            bSplitAtNonG2Knots=bSplitAtNonG2Knots,\r\n            bMakeDeformable=bAlignEndDirs,\r\n            fTol=0.5*fTol,\r\n            bDebug=bDebug)\r\n\r\n        if bDebug and bRebuild:\r\n            sEval = \"fDev_fromRebuilds\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n        ncs_Offset = []\r\n        rgBs_Loft = []\r\n\r\n\r\n        for nc_toOffset in ncs_toOffset:\r\n\r\n            if bDebug: sEval = \"nc_toOffset.SpanCount\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            rc = createOffsetCurve(\r\n                rgCrv_In=nc_toOffset,\r\n                rgSrf=rgF_In,\r\n                bLoose=bLoose,\r\n                bAlignEndDirs=bAlignEndDirs,\r\n                fDistance=fDistance,\r\n                fTol=fTol-fDev_fromRebuilds,\r\n                fSamplingDist=fSamplingDist,\r\n                bDebug=bDebug)\r\n            if rc is None:\r\n                if bEcho: print(\"No solution found.\")\r\n                return\r\n\r\n            nc_Offset, dev_Offset = rc\r\n\r\n            ncs_Offset.append(nc_Offset)\r\n\r\n            if bLoft:\r\n                rgB_Loft = rg.Brep.CreateFromLoft(\r\n                    [nc_toOffset, nc_Offset],\r\n                    start=rg.Point3d.Unset,\r\n                    end=rg.Point3d.Unset,\r\n                    loftType=rg.LoftType.Straight,\r\n                    closed=nc_Offset.IsClosed)\r\n                if rgB_Loft:\r\n                    rgBs_Loft.extend(rgB_Loft)\r\n\r\n\r\n            nc_toOffset.Dispose()\r\n\r\n\r\n\r\n        conduit.crvs = ncs_Offset\r\n        conduit.breps = rgBs_Loft\r\n\r\n        conduit.Enabled = True\r\n\r\n        sc.doc.Views.Redraw()\r\n\r\n        if bEcho:\r\n            sOut = []\r\n            if len(ncs_Offset) > 1: sOut.append(\"{} curves\".format(len(ncs_Offset)))\r\n            if sOut:\r\n                print(\"Calculated {}.\".format(\", \".join(sOut)))\r\n\r\n\r\n        rc = _getInput_Click()\r\n\r\n        conduit.Enabled = False\r\n\r\n        if rc is None:\r\n            for _ in ncs_Offset: _.Dispose()\r\n            for _ in rgBs_Loft: _.Dispose()\r\n            return\r\n\r\n        if not rc:\r\n            return (\r\n                ncs_Offset,\r\n                rgBs_Loft,\r\n                bEcho)\r\n\r\n        for _ in ncs_Offset: _.Dispose()\r\n        for _ in rgBs_Loft: _.Dispose()\r\n\r\n\r\n\r\n        bLoose = Opts.values['bLoose']\r\n        bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n        bExplodePolyCrv = Opts.values['bExplodePolyCrv']\r\n        bRebuild = Opts.values['bRebuild']\r\n        bSplitAtNonG2Knots = Opts.values['bSplitAtNonG2Knots']\r\n        fDistance = Opts.values['fDistance']\r\n        fTol = Opts.values['fTol']\r\n        bLoft = Opts.values['bLoft']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n\r\ndef main():\r\n\r\n    while True:\r\n        rc = _createGeometryInteractively()\r\n        if rc is None: return\r\n\r\n        rgCs, rgBs_Out, bEcho = rc\r\n\r\n        gCs_OneIteration = []\r\n        for rgC in rgCs:\r\n            gC = sc.doc.Objects.AddCurve(rgC)\r\n            if gC != gC.Empty:\r\n                gCs_OneIteration.append(gC)\r\n\r\n        gBs_OneIteration = []\r\n        for rgB in rgBs_Out:\r\n            gB = sc.doc.Objects.AddBrep(rgB)\r\n            if gB != gB.Empty:\r\n                gBs_OneIteration.append(gB)\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n        if bEcho:\r\n            sOut = []\r\n            if gCs_OneIteration: sOut.append(\"{} offset curves\".format(len(gCs_OneIteration)))\r\n            if gBs_OneIteration: sOut.append(\"{} lofts\".format(len(gBs_OneIteration)))\r\n            print(\"Added {}\".format(\", \".join(sOut)))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}