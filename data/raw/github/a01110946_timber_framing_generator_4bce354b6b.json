{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_revit_pipe_creator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_revit_pipe_creator.py",
  "instruction": "Revit Pipe Creator for Grasshopper.",
  "code": "# File: scripts/gh_revit_pipe_creator.py\n\"\"\"Revit Pipe Creator for Grasshopper.\n\nCreates Revit Pipe elements from calculated pipe routes using RhinoInside.Revit.\nThis is the third step in the MEP integration pipeline.\n\nKey Features:\n1. Pipe Creation\n   - Creates Revit Pipe elements from route segments\n   - Handles branch/trunk topology for merged routes\n   - Assigns correct piping system types\n\n2. Fitting Creation\n   - Creates elbow fittings at 90-degree corners\n   - Creates tee fittings at merge points (e.g., double sink drains)\n\n3. Transaction Management\n   - Groups all creation in a single transaction\n   - Rollback on critical errors\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    RhinoInside.Revit\n    Python component (CPython 3)\n\nDependencies:\n    - RhinoInside.Revit: Document access\n    - Autodesk.Revit.DB: Revit API\n    - timber_framing_generator.mep.plumbing: Pipe creation logic\n\nInput Requirements:\n    routes_json (routes_json) - str:\n        JSON from Pipe Router component\n        Required: Yes\n        Access: Item\n\n    pipe_type (pipe_type) - Revit PipeType:\n        Pipe type from RiR Type Picker.\n        IMPORTANT: This must be a PipeType (physical pipe configuration like\n        \"Standard\", \"Copper\", \"PVC\"), NOT a PipingSystemType (like \"Domestic\n        Cold Water\" or \"Sanitary\").\n        Use: Element Type Picker > Category: Pipe Types\n        Required: No (will use first available if not provided)\n        Access: Item\n\n    level (level) - Revit Level:\n        Reference level for pipes\n        Required: Yes\n        Access: Item\n\n    create_fittings (fittings) - bool:\n        Create elbows at corners (default: False)\n        WARNING: Fitting creation can cause Revit errors due to pipe\n        direction/flow issues. Leave False until pipes are verified.\n        Required: No\n        Access: Item\n\n    run (run) - bool:\n        Execute toggle\n        Required: Yes\n        Access: Item\n\nOutputs:\n    created_pipes (pipes) - list:\n        Created Revit Pipe elements\n\n    created_fittings (fits) - list:\n        Created Revit Fitting elements\n\n    creation_json (json) - str:\n        JSON log with element IDs and statistics\n\n    debug_info (info) - str:\n        Processing summary and diagnostics\n\nAuthor: Claude AI Assistant\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# Force reload of project modules (development only)\nFORCE_RELOAD = True\nif FORCE_RELOAD:\n    modules_to_reload = [k for k in sys.modules.keys()\n                         if 'timber_framing_generator' in k]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Revit Pipe Creator\"\nCOMPONENT_NICKNAME = \"PipeCrt\"\nCOMPONENT_MESSAGE = \"v1.0\"\n\n# Project path\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\n# =============================================================================\n# Project Imports\n# =============================================================================\n\ntry:\n    from src.timber_framing_generator.mep.plumbing import (\n        build_all_pipe_networks,\n        get_networks_summary,\n        get_revit_system_type_name,\n        PipeNetwork,\n        PipeSegment,\n        MergePointInfo,\n    )\n    PROJECT_AVAILABLE = True\n    PROJECT_ERROR = None\nexcept ImportError as e:\n    PROJECT_AVAILABLE = False\n    PROJECT_ERROR = str(e)\n\n# =============================================================================\n# Revit API Imports\n# =============================================================================\n\nREVIT_AVAILABLE = False\nREVIT_ERROR = None\n\ntry:\n    clr.AddReference(\"RevitAPI\")\n    clr.AddReference(\"RevitAPIUI\")\n    from Autodesk.Revit.DB import (\n        Transaction,\n        XYZ,\n        ElementId,\n        FilteredElementCollector,\n        BuiltInCategory,\n        BuiltInParameter,\n    )\n    from Autodesk.Revit.DB.Plumbing import (\n        Pipe,\n        PipingSystemType,\n    )\n    from RhinoInside.Revit import Revit\n    REVIT_AVAILABLE = True\nexcept ImportError as e:\n    REVIT_ERROR = str(e)\nexcept Exception as e:\n    REVIT_ERROR = str(e)\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n\n# =============================================================================\n# Revit Helper Functions\n# =============================================================================\n\ndef get_available_pipe_types(doc):\n    \"\"\"Get all available PipeType elements in the document.\n\n    Returns:\n        List of (name, ElementId) tuples\n    \"\"\"\n    from Autodesk.Revit.DB.Plumbing import PipeType\n\n    collector = FilteredElementCollector(doc)\n    pipe_types = collector.OfClass(PipeType).ToElements()\n\n    return [(pt.Name, pt.Id) for pt in pipe_types]\n\n\ndef validate_pipe_type(doc, pipe_type_element):\n    \"\"\"Validate that the input is actually a PipeType.\n\n    Args:\n        doc: Revit document\n        pipe_type_element: Element from RiR Type Picker\n\n    Returns:\n        tuple: (is_valid, error_message, pipe_type_id)\n    \"\"\"\n    from Autodesk.Revit.DB.Plumbing import PipeType\n\n    if pipe_type_element is None:\n        return False, \"No pipe_type provided\", None\n\n    # Debug: show what type we received\n    element_clr_type = pipe_type_element.GetType()\n    log_info(f\"pipe_type input CLR type: {element_clr_type.FullName}\")\n\n    # Get the actual element from document to verify\n    try:\n        element_id = pipe_type_element.Id\n        log_info(f\"pipe_type.Id = {element_id.IntegerValue}\")\n\n        element = doc.GetElement(element_id)\n\n        if element is None:\n            return False, f\"Could not find element with Id {element_id.IntegerValue}\", None\n\n        element_type_name = element.GetType().Name\n        log_info(f\"Element from doc: {element_type_name}\")\n\n        # Check if it's a PipeType\n        if isinstance(element, PipeType):\n            log_info(f\"Validated as PipeType: {element.Name}\")\n            return True, None, element_id\n\n        # It's not a PipeType - provide helpful error\n        actual_type = element.GetType().Name\n        available = get_available_pipe_types(doc)\n        available_names = [name for name, _ in available]\n\n        error_msg = (\n            f\"Input is a {actual_type}, not a PipeType.\\n\"\n            f\"Element name: {pipe_type_element.Name}\\n\"\n            f\"Available PipeTypes in document: {', '.join(available_names)}\\n\"\n            f\"Use a Type Picker filtered to 'Pipe Types' category.\"\n        )\n        return False, error_msg, None\n\n    except Exception as e:\n        import traceback\n        return False, f\"Error validating pipe type: {e}\\n{traceback.format_exc()}\", None\n\n\ndef get_piping_system_type(doc, system_type_name):\n    \"\"\"Get PipingSystemType by name.\n\n    Args:\n        doc: Revit document\n        system_type_name: System type name (e.g., \"Sanitary\", \"Domestic Cold Water\")\n\n    Returns:\n        PipingSystemType element or None\n    \"\"\"\n    collector = FilteredElementCollector(doc)\n    system_types = collector.OfClass(PipingSystemType).ToElements()\n\n    for st in system_types:\n        if st.Name == system_type_name:\n            return st\n\n    # Try partial match\n    for st in system_types:\n        if system_type_name.lower() in st.Name.lower():\n            return st\n\n    return None\n\n\ndef get_pipe_end_connector(pipe, at_end=True):\n    \"\"\"Get connector at start or end of pipe.\n\n    Args:\n        pipe: Revit Pipe element\n        at_end: If True, get end connector; if False, get start connector\n\n    Returns:\n        Connector or None\n    \"\"\"\n    try:\n        conn_manager = pipe.ConnectorManager\n        if conn_manager is None:\n            log_info(f\"    Pipe {pipe.Id.IntegerValue} has no ConnectorManager\")\n            return None\n\n        connectors = conn_manager.Connectors\n        if connectors is None:\n            log_info(f\"    Pipe {pipe.Id.IntegerValue} has no Connectors\")\n            return None\n\n        # Get pipe curve to determine start/end\n        location = pipe.Location\n        if location is None:\n            log_info(f\"    Pipe {pipe.Id.IntegerValue} has no Location\")\n            return None\n\n        curve = location.Curve\n        if curve is None:\n            log_info(f\"    Pipe {pipe.Id.IntegerValue} has no Curve\")\n            return None\n\n        target_point = curve.GetEndPoint(1) if at_end else curve.GetEndPoint(0)\n\n        closest_conn = None\n        closest_dist = float('inf')\n\n        for conn in connectors:\n            dist = conn.Origin.DistanceTo(target_point)\n            if dist < closest_dist:\n                closest_dist = dist\n                closest_conn = conn\n\n        return closest_conn\n\n    except Exception as e:\n        log_info(f\"    get_pipe_end_connector error: {e}\")\n        return None\n\n\ndef create_pipe_element(doc, segment, pipe_type_id, system_type_id, level_id):\n    \"\"\"Create a single Revit Pipe element.\n\n    Args:\n        doc: Revit document\n        segment: PipeSegment with start/end points and pipe_size\n        pipe_type_id: ElementId of PipeType\n        system_type_id: ElementId of PipingSystemType\n        level_id: ElementId of Level\n\n    Returns:\n        Pipe element or None\n    \"\"\"\n    try:\n        start_xyz = XYZ(\n            segment.start_point[0],\n            segment.start_point[1],\n            segment.start_point[2]\n        )\n        end_xyz = XYZ(\n            segment.end_point[0],\n            segment.end_point[1],\n            segment.end_point[2]\n        )\n\n        # Check for zero-length pipe\n        length = start_xyz.DistanceTo(end_xyz)\n        if length < 0.01:  # Less than 0.01 ft\n            log_warning(f\"Skipping zero-length segment in route {segment.route_id}\")\n            return None\n\n        # Get pipe size (in feet) - use segment's pipe_size which has system-appropriate defaults\n        pipe_diameter = segment.pipe_size if segment.pipe_size and segment.pipe_size > 0 else 0.0417  # 0.5\" fallback\n        pipe_diameter_inches = pipe_diameter * 12\n\n        log_info(f\"Creating pipe: len={length:.3f}ft, dia={pipe_diameter_inches:.2f}in ({segment.system_type})\")\n        log_info(f\"  system_type_id={system_type_id.IntegerValue}, pipe_type_id={pipe_type_id.IntegerValue}, level_id={level_id.IntegerValue}\")\n\n        pipe = Pipe.Create(\n            doc,\n            system_type_id,\n            pipe_type_id,\n            level_id,\n            start_xyz,\n            end_xyz\n        )\n\n        # Set the pipe diameter\n        # The diameter parameter is RBS_PIPE_DIAMETER_PARAM\n        diameter_param = pipe.get_Parameter(BuiltInParameter.RBS_PIPE_DIAMETER_PARAM)\n        if diameter_param is not None and not diameter_param.IsReadOnly:\n            diameter_param.Set(pipe_diameter)\n            log_info(f\"  Set diameter to {pipe_diameter:.4f} ft ({pipe_diameter * 12:.2f} in)\")\n        else:\n            # Try setting via LookupParameter\n            diameter_param2 = pipe.LookupParameter(\"Diameter\")\n            if diameter_param2 is not None and not diameter_param2.IsReadOnly:\n                diameter_param2.Set(pipe_diameter)\n                log_info(f\"  Set diameter via LookupParameter to {pipe_diameter:.4f} ft\")\n            else:\n                log_info(f\"  Could not set diameter - parameter is read-only or not found\")\n\n        log_info(f\"  Created pipe Id: {pipe.Id.IntegerValue}\")\n        return pipe\n\n    except Exception as e:\n        log_warning(f\"Failed to create pipe segment: {e}\")\n        log_info(f\"  Segment: {segment.start_point} -> {segment.end_point}\")\n        log_info(f\"  IDs: system={system_type_id.IntegerValue}, pipe={pipe_type_id.IntegerValue}, level={level_id.IntegerValue}\")\n        return None\n\n\ndef create_elbow_fitting(doc, pipe1, pipe2):\n    \"\"\"Create elbow fitting between two pipes.\n\n    Args:\n        doc: Revit document\n        pipe1: First pipe (get end connector)\n        pipe2: Second pipe (get start connector)\n\n    Returns:\n        Fitting element or None\n\n    Note:\n        Tries multiple approaches:\n        1. NewElbowFitting - requires fitting families loaded\n        2. Connector.ConnectTo - may auto-insert fittings\n    \"\"\"\n    try:\n        conn1 = get_pipe_end_connector(pipe1, at_end=True)\n        conn2 = get_pipe_end_connector(pipe2, at_end=False)\n\n        if conn1 is None or conn2 is None:\n            log_info(f\"  Elbow: Could not find connectors (conn1={conn1}, conn2={conn2})\")\n            return None\n\n        # Check if connectors are already connected\n        if conn1.IsConnected:\n            log_info(f\"  Elbow: conn1 already connected\")\n            return None\n        if conn2.IsConnected:\n            log_info(f\"  Elbow: conn2 already connected\")\n            return None\n\n        # Log connector info for debugging\n        dist = conn1.Origin.DistanceTo(conn2.Origin)\n        log_info(f\"  Elbow: Pipes {pipe1.Id.IntegerValue} -> {pipe2.Id.IntegerValue}, dist={dist:.4f}\")\n\n        # Try Method 1: NewElbowFitting\n        try:\n            fitting = doc.Create.NewElbowFitting(conn1, conn2)\n            if fitting is not None:\n                log_info(f\"  Elbow: Created fitting Id {fitting.Id.IntegerValue}\")\n                return fitting\n        except Exception as e1:\n            log_info(f\"  Elbow: NewElbowFitting failed - {e1}\")\n\n        # Try Method 2: Direct connector connection\n        # This may auto-insert a fitting if routing preferences allow\n        try:\n            conn1.ConnectTo(conn2)\n            if conn1.IsConnected:\n                log_info(f\"  Elbow: Connected via ConnectTo (fitting may be auto-inserted)\")\n                return \"connected\"  # Return non-None to indicate success\n        except Exception as e2:\n            log_info(f\"  Elbow: ConnectTo failed - {e2}\")\n\n        return None\n\n    except Exception as e:\n        log_info(f\"  Elbow: FAILED - {e}\")\n        return None\n\n\ndef create_tee_fitting(doc, branch_pipe, trunk_pipe, merge_point, all_trunk_pipes=None):\n    \"\"\"Connect branch pipe to trunk at merge point.\n\n    Args:\n        doc: Revit document\n        branch_pipe: Branch pipe connecting to trunk\n        trunk_pipe: First trunk pipe (merge point is at its start)\n        merge_point: (x, y, z) tuple where branch meets trunk\n        all_trunk_pipes: List of all trunk pipes (to find connectors)\n\n    Returns:\n        Fitting element, \"connected\" string, or None\n\n    Note:\n        The merge point is at the START of the trunk pipes (not middle).\n        Multiple branches may connect to the same point - we need to find\n        any available connector near the merge point.\n    \"\"\"\n    try:\n        # Get end connector of branch (the end that meets the trunk)\n        branch_conn = get_pipe_end_connector(branch_pipe, at_end=True)\n\n        if branch_conn is None:\n            log_info(f\"  Tee: Could not find branch connector\")\n            return None\n\n        if branch_conn.IsConnected:\n            log_info(f\"  Tee: Branch connector already connected\")\n            return None\n\n        merge_xyz = XYZ(merge_point[0], merge_point[1], merge_point[2])\n        log_info(f\"  Tee: Branch {branch_pipe.Id.IntegerValue} seeking connection at ({merge_point[0]:.2f}, {merge_point[1]:.2f}, {merge_point[2]:.2f})\")\n\n        # Collect all pipes to search for connectors\n        pipes_to_check = [trunk_pipe]\n        if all_trunk_pipes:\n            pipes_to_check = list(all_trunk_pipes)\n\n        # Find any unconnected connector near the merge point\n        best_conn = None\n        best_dist = float('inf')\n\n        for pipe in pipes_to_check:\n            if pipe is None:\n                continue\n            try:\n                for conn in pipe.ConnectorManager.Connectors:\n                    if not conn.IsConnected:\n                        dist = conn.Origin.DistanceTo(branch_conn.Origin)\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_conn = conn\n            except:\n                pass\n\n        if best_conn is not None and best_dist < 0.1:  # Within 0.1 ft tolerance\n            try:\n                branch_conn.ConnectTo(best_conn)\n                if branch_conn.IsConnected:\n                    log_info(f\"  Tee: Connected branch to trunk (dist={best_dist:.4f})\")\n                    return \"connected\"\n            except Exception as e_connect:\n                log_info(f\"  Tee: ConnectTo failed - {e_connect}\")\n\n        # If no direct connection possible, the user needs to manually add fitting\n        # This happens when multiple branches meet at one point (need a cross/wye)\n        if best_dist >= 0.1:\n            log_info(f\"  Tee: No connector found near merge point (closest={best_dist:.2f}ft)\")\n        else:\n            log_info(f\"  Tee: Could not connect - connector may already be used\")\n            log_info(f\"  Tee: Note: Multiple branches at same point need manual wye/cross fitting\")\n\n        return None\n\n    except Exception as e:\n        log_info(f\"  Tee: FAILED - {e}\")\n        return None\n\n\ndef create_wye_fitting(doc, all_branch_pipes, trunk_pipes, merge_info):\n    \"\"\"Create wye fitting connecting branches to trunk at merge point.\n\n    Uses Revit's NewTeeFitting(conn1, conn2, conn3) which requires 3 connectors\n    from 3 different pipe elements. The trimmed pipe ends provide these connectors.\n\n    For 2 branches:\n        - conn1: End of branch 1 (becomes \"run in\")\n        - conn2: Start of trunk (becomes \"run out\")\n        - conn3: End of branch 2 (becomes \"branch\")\n\n    Args:\n        doc: Revit document\n        all_branch_pipes: List of lists of branch pipes [[branch1_pipes], [branch2_pipes], ...]\n        trunk_pipes: List of trunk pipe elements\n        merge_info: MergePointInfo with trimmed coordinates\n\n    Returns:\n        Fitting element, \"connected\" string, or None\n    \"\"\"\n    if len(all_branch_pipes) < 2:\n        log_info(\"  Wye: Need at least 2 branches\")\n        return None\n\n    if not trunk_pipes:\n        log_info(\"  Wye: No trunk pipes available\")\n        return None\n\n    # Get the last pipe of each branch (these have ends near merge point)\n    branch1_pipes = all_branch_pipes[0] if all_branch_pipes[0] else []\n    branch2_pipes = all_branch_pipes[1] if len(all_branch_pipes) > 1 and all_branch_pipes[1] else []\n\n    if not branch1_pipes or not branch2_pipes:\n        log_info(\"  Wye: One or both branches have no pipes\")\n        return None\n\n    branch1_last = branch1_pipes[-1]\n    branch2_last = branch2_pipes[-1]\n    trunk_first = trunk_pipes[0]\n\n    log_info(f\"  Wye: Connecting branch1={branch1_last.Id.IntegerValue}, branch2={branch2_last.Id.IntegerValue}, trunk={trunk_first.Id.IntegerValue}\")\n\n    # Get connectors (end of branches, start of trunk)\n    branch1_conn = get_pipe_end_connector(branch1_last, at_end=True)\n    branch2_conn = get_pipe_end_connector(branch2_last, at_end=True)\n    trunk_conn = get_pipe_end_connector(trunk_first, at_end=False)  # START of trunk\n\n    # Validate all connectors exist\n    if branch1_conn is None:\n        log_info(\"  Wye: Branch 1 end connector not found\")\n        return None\n    if branch2_conn is None:\n        log_info(\"  Wye: Branch 2 end connector not found\")\n        return None\n    if trunk_conn is None:\n        log_info(\"  Wye: Trunk start connector not found\")\n        return None\n\n    # Check if connectors are already connected\n    if branch1_conn.IsConnected:\n        log_info(\"  Wye: Branch 1 connector already connected\")\n        return None\n    if branch2_conn.IsConnected:\n        log_info(\"  Wye: Branch 2 connector already connected\")\n        return None\n    if trunk_conn.IsConnected:\n        log_info(\"  Wye: Trunk connector already connected\")\n        return None\n\n    # Log connector positions for debugging\n    log_info(f\"  Wye: Branch1 conn at ({branch1_conn.Origin.X:.3f}, {branch1_conn.Origin.Y:.3f}, {branch1_conn.Origin.Z:.3f})\")\n    log_info(f\"  Wye: Branch2 conn at ({branch2_conn.Origin.X:.3f}, {branch2_conn.Origin.Y:.3f}, {branch2_conn.Origin.Z:.3f})\")\n    log_info(f\"  Wye: Trunk conn at ({trunk_conn.Origin.X:.3f}, {trunk_conn.Origin.Y:.3f}, {trunk_conn.Origin.Z:.3f})\")\n\n    # For NewTeeFitting: conn1 and conn2 form the \"run\" (straight through), conn3 is the \"branch\"\n    # Based on geometry: Branch1 (left) → Branch2 (right) = horizontal run, Trunk = perpendicular branch\n\n    # Try Method 1: Branch1-Branch2 as run, Trunk as branch (most likely correct for this geometry)\n    try:\n        fitting = doc.Create.NewTeeFitting(branch1_conn, branch2_conn, trunk_conn)\n        if fitting is not None:\n            log_info(f\"  Wye: Created tee fitting (b1-b2 run, trunk branch) Id {fitting.Id.IntegerValue}\")\n            return fitting\n    except Exception as e1:\n        log_info(f\"  Wye: NewTeeFitting(b1, b2, trunk) failed - {e1}\")\n\n    # Try Method 2: Reverse the run direction\n    try:\n        fitting = doc.Create.NewTeeFitting(branch2_conn, branch1_conn, trunk_conn)\n        if fitting is not None:\n            log_info(f\"  Wye: Created tee fitting (b2-b1 run, trunk branch) Id {fitting.Id.IntegerValue}\")\n            return fitting\n    except Exception as e2:\n        log_info(f\"  Wye: NewTeeFitting(b2, b1, trunk) failed - {e2}\")\n\n    # Try Method 3: Trunk as part of run (less likely but worth trying)\n    try:\n        fitting = doc.Create.NewTeeFitting(branch1_conn, trunk_conn, branch2_conn)\n        if fitting is not None:\n            log_info(f\"  Wye: Created tee fitting (b1-trunk run) Id {fitting.Id.IntegerValue}\")\n            return fitting\n    except Exception as e3:\n        log_info(f\"  Wye: NewTeeFitting(b1, trunk, b2) failed - {e3}\")\n\n    # Try Method 4: Other combinations\n    try:\n        fitting = doc.Create.NewTeeFitting(trunk_conn, branch1_conn, branch2_conn)\n        if fitting is not None:\n            log_info(f\"  Wye: Created tee fitting (trunk-b1 run) Id {fitting.Id.IntegerValue}\")\n            return fitting\n    except Exception as e4:\n        log_info(f\"  Wye: NewTeeFitting(trunk, b1, b2) failed - {e4}\")\n\n    log_info(\"  Wye: All NewTeeFitting attempts failed - connectors may need to be at exact same point\")\n\n    # Fallback: Connect branches directly to trunk\n    # When ConnectTo is used, Revit may auto-insert fittings based on routing preferences\n    log_info(\"  Wye: All NewTeeFitting attempts failed, trying direct connections\")\n    connected_count = 0\n\n    # Connect branch1 to trunk\n    try:\n        branch1_conn.ConnectTo(trunk_conn)\n        if branch1_conn.IsConnected:\n            log_info(\"  Wye: Connected branch1 to trunk via ConnectTo\")\n            connected_count += 1\n    except Exception as e:\n        log_info(f\"  Wye: branch1→trunk ConnectTo failed - {e}\")\n\n    # Try to connect branch2 - need to find an available connector\n    # IMPORTANT: After ConnectTo, Revit may have modified the document, invalidating connector references.\n    # We need to re-fetch branch2's connector to get a fresh reference.\n    if connected_count > 0:\n        # Re-fetch branch2 connector (original may be stale after document modification)\n        try:\n            branch2_conn = get_pipe_end_connector(branch2_last, at_end=True)\n            if branch2_conn is None:\n                log_info(\"  Wye: Could not re-fetch branch2 connector\")\n            elif branch2_conn.IsConnected:\n                log_info(\"  Wye: branch2 already connected\")\n                connected_count += 1\n        except Exception as e:\n            log_info(f\"  Wye: Error re-fetching branch2 connector - {e}\")\n            branch2_conn = None\n\n    if connected_count > 0 and branch2_conn is not None and not branch2_conn.IsConnected:\n        fitting_found = False\n\n        # Re-fetch branch1 connector too (needed to access AllRefs after document modification)\n        try:\n            branch1_conn = get_pipe_end_connector(branch1_last, at_end=True)\n        except Exception as e:\n            log_info(f\"  Wye: Error re-fetching branch1 connector - {e}\")\n            branch1_conn = None\n\n        # Strategy 1: Find the fitting that branch1 is now connected to\n        if branch1_conn is not None:\n            try:\n                log_info(\"  Wye: Looking for fitting connected to branch1...\")\n                for ref in branch1_conn.AllRefs:\n                    if ref is None:\n                        continue\n                    owner = ref.Owner\n                    if owner is None:\n                        continue\n\n                    # Check if this is a fitting (has MEPModel)\n                    owner_type = owner.GetType().Name\n                    log_info(f\"  Wye: branch1 connected to {owner_type} Id={owner.Id.IntegerValue}\")\n\n                    if hasattr(owner, 'MEPModel') and owner.MEPModel is not None:\n                        # This is a fitting - find available connectors\n                        try:\n                            fitting_connectors = owner.MEPModel.ConnectorManager.Connectors\n                            log_info(f\"  Wye: Fitting has {fitting_connectors.Size} connectors\")\n\n                            for fc in fitting_connectors:\n                                try:\n                                    if not fc.IsConnected:\n                                        log_info(f\"  Wye: Found unconnected fitting connector, attempting branch2 connection...\")\n                                        branch2_conn.ConnectTo(fc)\n                                        if branch2_conn.IsConnected:\n                                            log_info(f\"  Wye: Connected branch2 to fitting {owner.Id.IntegerValue}\")\n                                            connected_count += 1\n                                            fitting_found = True\n                                            break\n                                except Exception as fc_err:\n                                    log_info(f\"  Wye: Fitting connector error - {fc_err}\")\n                        except Exception as mep_err:\n                            log_info(f\"  Wye: MEPModel access error - {mep_err}\")\n\n                    if fitting_found:\n                        break\n            except Exception as e:\n                log_info(f\"  Wye: Strategy 1 (fitting search) failed - {e}\")\n\n        # Strategy 2: If no fitting found, try using PlumbingUtils to break the pipe\n        # and insert a tee (this requires the trunk pipe to still be valid)\n        if not fitting_found and connected_count < 2:\n            log_info(\"  Wye: No fitting connector found for branch2\")\n            # At this point, branch1 is connected but branch2 isn't.\n            # The user will need to manually add a cross fitting or adjust the connection.\n\n    if connected_count >= 2:\n        log_info(f\"  Wye: Successfully connected {connected_count} branches\")\n        return \"connected\"\n    elif connected_count == 1:\n        log_info(\"  Wye: Only 1 branch connected - second branch needs manual connection\")\n        return \"partial\"\n\n    log_info(\"  Wye: All connection attempts failed - manual wye/cross fitting needed\")\n    return None\n\n\n# =============================================================================\n# Main Processing\n# =============================================================================\n\ndef create_pipes_from_network(doc, network, pipe_type_id, level_id, do_fittings):\n    \"\"\"Create pipes and fittings from a single PipeNetwork.\n\n    Args:\n        doc: Revit document\n        network: PipeNetwork object\n        pipe_type_id: ElementId of PipeType\n        level_id: ElementId of Level\n        do_fittings: Create fittings at corners\n\n    Returns:\n        tuple: (pipes list, fittings list, debug messages list)\n    \"\"\"\n    pipes = []\n    fittings = []\n    debug = []\n\n    # Get system type\n    revit_system_name = get_revit_system_type_name(network.system_type)\n    system_type = get_piping_system_type(doc, revit_system_name)\n\n    if system_type is None:\n        debug.append(f\"WARNING: System type '{revit_system_name}' not found\")\n        return pipes, fittings, debug\n\n    system_type_id = system_type.Id\n    debug.append(f\"Using system type: {system_type.Name}\")\n\n    # Create trunk pipes first (shared segments)\n    trunk_pipes = []\n    for segment in network.trunk:\n        pipe = create_pipe_element(doc, segment, pipe_type_id, system_type_id, level_id)\n        if pipe is not None:\n            pipes.append(pipe)\n            trunk_pipes.append(pipe)\n\n    debug.append(f\"Created {len(trunk_pipes)} trunk pipes\")\n\n    # Create elbows between trunk segments\n    if do_fittings and len(trunk_pipes) > 1:\n        debug.append(f\"Attempting {len(trunk_pipes)-1} trunk elbows...\")\n        for i in range(len(trunk_pipes) - 1):\n            try:\n                fitting = create_elbow_fitting(doc, trunk_pipes[i], trunk_pipes[i+1])\n                if fitting is not None:\n                    fittings.append(fitting)\n            except Exception as e:\n                debug.append(f\"  Trunk elbow {i} failed: {e}\")\n\n    # Create branch pipes (unique per connector)\n    all_branch_pipes = []\n    for branch_idx, branch_segments in enumerate(network.branches):\n        branch_pipes = []\n        for segment in branch_segments:\n            pipe = create_pipe_element(doc, segment, pipe_type_id, system_type_id, level_id)\n            if pipe is not None:\n                pipes.append(pipe)\n                branch_pipes.append(pipe)\n\n        all_branch_pipes.append(branch_pipes)\n        debug.append(f\"Created {len(branch_pipes)} pipes for branch {branch_idx}\")\n\n        # Create elbows between branch segments\n        if do_fittings and len(branch_pipes) > 1:\n            debug.append(f\"  Attempting {len(branch_pipes)-1} branch elbows...\")\n            for i in range(len(branch_pipes) - 1):\n                try:\n                    fitting = create_elbow_fitting(doc, branch_pipes[i], branch_pipes[i+1])\n                    if fitting is not None:\n                        fittings.append(fitting)\n                except Exception as e:\n                    debug.append(f\"    Branch elbow {i} failed: {e}\")\n\n    # Debug: Show merge info state\n    log_info(f\"Merge point check: merge_point={network.merge_point is not None}, merge_info={network.merge_info is not None}\")\n    log_info(f\"  branches={len(all_branch_pipes)}, trunk_pipes={len(trunk_pipes)}\")\n    if network.merge_info:\n        log_info(f\"  merge_info.branch_endpoints={len(network.merge_info.branch_endpoints)}\")\n    else:\n        log_info(f\"  merge_info is None - will use legacy fallback\")\n\n    # Create wye fitting at merge point (for 2+ branches with merge_info)\n    if do_fittings and network.merge_info is not None and len(all_branch_pipes) >= 2 and len(trunk_pipes) > 0:\n        merge_info = network.merge_info\n        debug.append(f\"Creating wye fitting at merge point\")\n        debug.append(f\"  Original merge: {merge_info.original_point}\")\n        debug.append(f\"  Trimmed trunk start: {merge_info.trunk_startpoint}\")\n        debug.append(f\"  {len(merge_info.branch_endpoints)} branch endpoints trimmed\")\n\n        try:\n            fitting = create_wye_fitting(doc, all_branch_pipes, trunk_pipes, merge_info)\n            if fitting is not None:\n                fittings.append(fitting)\n                debug.append(\"  Wye fitting created successfully\")\n            else:\n                debug.append(\"  Wye fitting failed - manual connection needed\")\n        except Exception as e:\n            debug.append(f\"  Wye fitting error: {e}\")\n\n    # For single branch, use simple tee fitting at merge point\n    elif do_fittings and network.needs_tee_fitting() and len(trunk_pipes) > 0 and len(all_branch_pipes) == 1:\n        merge_point = network.merge_point\n        debug.append(f\"Attempting single branch tee fitting at: {merge_point}\")\n        first_trunk_pipe = trunk_pipes[0]\n        branch_pipes_list = all_branch_pipes[0]\n        if len(branch_pipes_list) > 0:\n            try:\n                last_branch_pipe = branch_pipes_list[-1]\n                fitting = create_tee_fitting(doc, last_branch_pipe, first_trunk_pipe, merge_point, trunk_pipes)\n                if fitting is not None:\n                    fittings.append(fitting)\n                    debug.append(\"  Connected branch to trunk\")\n                else:\n                    debug.append(\"  Branch: Manual connection needed\")\n            except Exception as e:\n                debug.append(f\"  Tee fitting failed: {e}\")\n\n    # Fallback for merge point without merge_info (shouldn't happen with new code)\n    elif do_fittings and network.merge_point is not None and len(all_branch_pipes) >= 2 and len(trunk_pipes) > 0:\n        merge_point = network.merge_point\n        debug.append(f\"Attempting tee fittings at merge point (legacy): {merge_point}\")\n        debug.append(f\"  {len(all_branch_pipes)} branches need to connect to trunk\")\n        first_trunk_pipe = trunk_pipes[0]\n        for bi, branch_pipes_list in enumerate(all_branch_pipes):\n            if len(branch_pipes_list) > 0:\n                try:\n                    last_branch_pipe = branch_pipes_list[-1]\n                    fitting = create_tee_fitting(doc, last_branch_pipe, first_trunk_pipe, merge_point, trunk_pipes)\n                    if fitting is not None:\n                        fittings.append(fitting)\n                        debug.append(f\"  Connected branch {bi} to trunk\")\n                    else:\n                        debug.append(f\"  Branch {bi}: Manual connection needed (wye/cross fitting)\")\n                except Exception as e:\n                    debug.append(f\"  Tee fitting for branch {bi} failed: {e}\")\n\n    return pipes, fittings, debug\n\n\ndef validate_inputs():\n    \"\"\"Validate component inputs.\"\"\"\n    if not PROJECT_AVAILABLE:\n        return False, f\"Project import error: {PROJECT_ERROR}\"\n\n    if not REVIT_AVAILABLE:\n        return False, f\"Revit API not available: {REVIT_ERROR}\"\n\n    if not run:\n        return False, \"Toggle 'run' to True to execute\"\n\n    if not routes_json:\n        return False, \"No routes_json provided\"\n\n    # pipe_type is optional - will use first available if not provided\n\n    if level is None:\n        return False, \"No level provided (use RiR Level Picker)\"\n\n    return True, None\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize outputs\n    created_pipes = []\n    created_fittings = []\n    creation_json = \"{}\"\n    debug_lines = []\n\n    debug_lines.append(\"=\" * 50)\n    debug_lines.append(\"REVIT PIPE CREATOR\")\n    debug_lines.append(\"=\" * 50)\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs()\n        if not is_valid:\n            debug_lines.append(error_msg)\n            return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n        # Get Revit document\n        doc = Revit.ActiveDBDocument\n        if doc is None:\n            debug_lines.append(\"ERROR: No active Revit document\")\n            return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n        debug_lines.append(f\"Document: {doc.Title}\")\n\n        # Show available pipe types for debugging\n        available_pipe_types = get_available_pipe_types(doc)\n        debug_lines.append(\"\")\n        debug_lines.append(f\"Available PipeTypes in document: {len(available_pipe_types)}\")\n        for pt_name, pt_id in available_pipe_types:\n            debug_lines.append(f\"  - {pt_name} (Id: {pt_id.IntegerValue})\")\n\n        # Validate pipe type input\n        pipe_type_name = \"Unknown\"\n        if pipe_type is not None:\n            is_valid_type, type_error, pipe_type_id = validate_pipe_type(doc, pipe_type)\n            if not is_valid_type:\n                debug_lines.append(\"\")\n                debug_lines.append(f\"ERROR: Invalid pipe_type input\")\n                debug_lines.append(type_error)\n                log_error(type_error)\n                return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n            pipe_type_name = pipe_type.Name\n        else:\n            # No pipe_type provided - use first available\n            if len(available_pipe_types) > 0:\n                pipe_type_name, pipe_type_id = available_pipe_types[0]\n                debug_lines.append(\"\")\n                debug_lines.append(f\"No pipe_type input - using first available: {pipe_type_name}\")\n            else:\n                debug_lines.append(\"\")\n                debug_lines.append(\"ERROR: No pipe_type provided and no PipeTypes found in document\")\n                return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n        level_id = level.Id\n\n        debug_lines.append(\"\")\n        debug_lines.append(f\"Using Pipe Type: {pipe_type_name} (Id: {pipe_type_id.IntegerValue})\")\n        debug_lines.append(f\"Level: {level.Name}\")\n        debug_lines.append(f\"Create Fittings: {create_fittings}\")\n\n        # Build pipe networks from routes\n        debug_lines.append(\"\")\n        debug_lines.append(\"Building pipe networks...\")\n        networks = build_all_pipe_networks(routes_json)\n\n        if not networks:\n            debug_lines.append(\"No pipe networks could be built from routes\")\n            return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n        # Show network summary\n        summary = get_networks_summary(networks)\n        debug_lines.append(f\"Networks: {summary['total_networks']}\")\n        debug_lines.append(f\"Total segments: {summary['total_segments']}\")\n        debug_lines.append(f\"Tee fittings needed: {summary['tee_fittings_needed']}\")\n\n        # Start transaction\n        debug_lines.append(\"\")\n        debug_lines.append(\"Creating pipes in Revit...\")\n        debug_lines.append(f\"Fittings enabled: {create_fittings}\")\n\n        t = Transaction(doc, \"Create Plumbing Pipes\")\n        t.Start()\n\n        networks_succeeded = 0\n        networks_failed = 0\n\n        try:\n            # Process each network with individual error handling\n            for network in networks:\n                debug_lines.append(\"\")\n                debug_lines.append(f\"Network: Fixture {network.fixture_id} - {network.system_type}\")\n\n                try:\n                    pipes, fittings, net_debug = create_pipes_from_network(\n                        doc, network, pipe_type_id, level_id, create_fittings\n                    )\n\n                    created_pipes.extend(pipes)\n                    created_fittings.extend(fittings)\n                    debug_lines.extend(net_debug)\n\n                    if len(pipes) > 0:\n                        networks_succeeded += 1\n                    else:\n                        networks_failed += 1\n                        debug_lines.append(\"  No pipes created for this network\")\n\n                except Exception as net_error:\n                    networks_failed += 1\n                    debug_lines.append(f\"  ERROR processing network: {net_error}\")\n                    log_warning(f\"Network {network.fixture_id} {network.system_type} failed: {net_error}\")\n                    # Continue with other networks\n\n            # Only commit if we created something\n            if len(created_pipes) > 0:\n                t.Commit()\n                debug_lines.append(\"\")\n                debug_lines.append(\"Transaction committed successfully\")\n            else:\n                t.RollBack()\n                debug_lines.append(\"\")\n                debug_lines.append(\"Transaction rolled back - no pipes created\")\n\n        except Exception as e:\n            if t.HasStarted():\n                t.RollBack()\n            debug_lines.append(f\"ERROR: Transaction rolled back: {e}\")\n            debug_lines.append(traceback.format_exc())\n            return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n        debug_lines.append(f\"Networks succeeded: {networks_succeeded}\")\n        debug_lines.append(f\"Networks failed: {networks_failed}\")\n\n        # Build output JSON\n        # Filter out string placeholders from fittings (ConnectTo returns \"connected\" not an element)\n        actual_fittings = [f for f in created_fittings if hasattr(f, 'Id')]\n        output_data = {\n            \"pipes_created\": len(created_pipes),\n            \"fittings_created\": len(actual_fittings),\n            \"connections_made\": len(created_fittings) - len(actual_fittings),\n            \"pipe_ids\": [p.Id.IntegerValue for p in created_pipes],\n            \"fitting_ids\": [f.Id.IntegerValue for f in actual_fittings],\n            \"networks_processed\": len(networks),\n            \"source\": \"gh_revit_pipe_creator\",\n        }\n        creation_json = json.dumps(output_data, indent=2)\n\n        # Summary\n        debug_lines.append(\"\")\n        debug_lines.append(\"=\" * 50)\n        debug_lines.append(\"CREATION COMPLETE\")\n        debug_lines.append(f\"Pipes created: {len(created_pipes)}\")\n        debug_lines.append(f\"Fittings created: {len(created_fittings)}\")\n        debug_lines.append(\"=\" * 50)\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return created_pipes, created_fittings, creation_json, \"\\n\".join(debug_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Define default input values if not provided by Grasshopper\nif 'run' not in dir():\n    run = False\n\nif 'routes_json' not in dir():\n    routes_json = \"\"\n\nif 'pipe_type' not in dir():\n    pipe_type = None\n\nif 'level' not in dir():\n    level = None\n\nif 'create_fittings' not in dir():\n    create_fittings = False  # Disabled by default - can cause Revit crashes\n\n# Execute main and assign to output variables\ncreated_pipes, created_fittings, creation_json, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}