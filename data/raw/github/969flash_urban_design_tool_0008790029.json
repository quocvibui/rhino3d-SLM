{
  "source_url": "https://github.com/969flash/urban_design_tool/blob/0a891333039b4d06213c16f2d4b6bb12b02f2ad1/src/road_detail_builder.py",
  "repo": "969flash/urban_design_tool",
  "repo_stars": 0,
  "repo_description": "urban_design_tool",
  "license": "unknown",
  "filepath": "src/road_detail_builder.py",
  "instruction": "RoadDetailBuilder main entry for Grasshopper (Rhino 8 / Python 3).",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"RoadDetailBuilder main entry for Grasshopper (Rhino 8 / Python 3).\n\n본 스크립트는 Rhino 문서 내 레이어에서 도로 중심선을 읽어 상세 라인 요소\n(중앙선, 차선, 가장자리 선)을 생성합니다. utils.py의 컨벤션(타입 힌트,\nGoogle 스타일 Docstring, snake_case, geo 별칭)을 따릅니다.\n\n주의:\n- Grasshopper Python 3 컴포넌트에서 실행을 가정합니다.\n- 프로젝트의 constants.py가 없을 경우 안전한 기본값으로 대체합니다.\n\"\"\"\n\nfrom typing import List, Tuple, Optional, Union, Any\nimport math\n\nimport Rhino\nimport Rhino.Geometry as geo\nimport scriptcontext as sc\nimport ghpythonlib.components as ghcomp\nimport System\n\n# constants.py의 모든 상수 임포트 (단일 소스 관리)\nfrom constants import *  # type: ignore  # noqa: F401,F403\n\n# 프로젝트 유틸 전부 임포트\nfrom utils import *  # noqa: F401,F403\n\n# 디버그 플래그 (GH 실행부에서 설정)\n_DEBUG: bool = True\n\n\ndef debug_print(*args: Any) -> None:\n    \"\"\"디버그가 활성화된 경우에만 메시지를 출력합니다.\"\"\"\n    if _DEBUG:\n        try:\n            print(*args)\n        except Exception:\n            pass\n\n\n# ==============================================================================\n# 내부 유틸리티 (레이어/오프셋/로프트 헬퍼)\n# ==============================================================================\n\n\ndef _get_model_tol(doc: Optional[Rhino.RhinoDoc]) -> float:\n    \"\"\"문서 공차를 반환합니다.\n\n    Args:\n        doc (Optional[Rhino.RhinoDoc]): Rhino 문서.\n\n    Returns:\n        float: 사용 가능한 공차 값.\n    \"\"\"\n    try:\n        if doc and hasattr(doc, \"ModelAbsoluteTolerance\"):\n            return float(doc.ModelAbsoluteTolerance)\n    except Exception:\n        pass\n    try:\n        # constants.TOL 이 존재하는 경우\n        from constants import TOL as _TOL  # type: ignore\n\n        return float(_TOL)\n    except Exception:\n        return 1e-3\n\n\ndef _ensure_layer(doc: Rhino.RhinoDoc, full_layer_name: str) -> int:\n    \"\"\"전체 경로 기반 레이어를 보장 생성하고 인덱스를 반환합니다.\n\n    'A::B::C' 형식의 레이어 경로를 지원합니다.\n\n    Args:\n        doc (Rhino.RhinoDoc): 문서.\n        full_layer_name (str): 전체 경로 레이어 이름.\n\n    Returns:\n        int: 생성/존재 레이어의 인덱스. 실패 시 -1.\n    \"\"\"\n    try:\n        if not full_layer_name:\n            return -1\n        # 이미 존재하면 즉시 반환\n        idx = doc.Layers.FindByFullPath(full_layer_name, -1)\n        if idx != -1:\n            debug_print(\"[layer] exists:\", full_layer_name, \"index=\", idx)\n            return idx\n\n        parts = [p for p in full_layer_name.split(\"::\") if p]\n        parent_id = None\n        current_path = \"\"\n        for part in parts:\n            current_path = part if not current_path else current_path + \"::\" + part\n            existing = doc.Layers.FindByFullPath(current_path, -1)\n            if existing != -1:\n                parent_id = doc.Layers[existing].Id\n                debug_print(\"[layer] found part:\", current_path)\n                continue\n\n            layer = Rhino.DocObjects.Layer()\n            layer.Name = part\n            if parent_id is not None:\n                layer.ParentLayerId = parent_id\n            new_index = doc.Layers.Add(layer)\n            if new_index < 0:\n                return -1\n            parent_id = doc.Layers[new_index].Id\n            debug_print(\"[layer] created part:\", current_path, \"index=\", new_index)\n        final_idx = doc.Layers.FindByFullPath(full_layer_name, -1)\n        debug_print(\"[layer] ready:\", full_layer_name, \"index=\", final_idx)\n        return final_idx\n    except Exception:\n        return -1\n\n\ndef _add_geometry(doc: Rhino.RhinoDoc, geom: Any, layer_index: int) -> bool:\n    \"\"\"지오메트리를 지정 레이어에 추가(bake)합니다.\n\n    Args:\n        doc (Rhino.RhinoDoc): Rhino 문서.\n        geom (Any): 추가할 지오메트리.\n        layer_index (int): 대상 레이어 인덱스.\n\n    Returns:\n        bool: 성공 여부.\n    \"\"\"\n    try:\n        if geom is None:\n            return False\n        attr = Rhino.DocObjects.ObjectAttributes()\n        attr.LayerIndex = layer_index\n\n        # 타입별로 안전하게 추가\n        if isinstance(geom, geo.Brep):\n            return doc.Objects.AddBrep(geom, attr) != System.Guid.Empty  # type: ignore\n        if isinstance(geom, geo.Surface):\n            brep = geom.ToBrep()\n            return doc.Objects.AddBrep(brep, attr) != System.Guid.Empty  # type: ignore\n        if isinstance(geom, geo.Curve):\n            return doc.Objects.AddCurve(geom, attr) != System.Guid.Empty  # type: ignore\n        if isinstance(geom, geo.Mesh):\n            return doc.Objects.AddMesh(geom, attr) != System.Guid.Empty  # type: ignore\n        # 그 외 시도: ToBrep 보유 시\n        if hasattr(geom, \"ToBrep\"):\n            try:\n                brep = geom.ToBrep()\n                return doc.Objects.AddBrep(brep, attr) != System.Guid.Empty  # type: ignore\n            except Exception:\n                pass\n        return False\n    except Exception:\n        return False\n\n\n# ==============================================================================\n# 0. Bake 헬퍼\n# ==============================================================================\n\n\ndef bake_geometry_to_layer(\n    geometry_list: List[Any], layer_name: str, doc: Rhino.RhinoDoc\n) -> None:\n    \"\"\"지정 레이어로 지오메트리 리스트를 Bake 합니다.\n\n    레이어가 없으면 '::' 기준으로 상위-하위 레이어를 생성합니다.\n\n    Args:\n        geometry_list (List[Any]): Bake할 지오메트리 목록.\n        layer_name (str): 대상 레이어 이름(전체 경로).\n        doc (Rhino.RhinoDoc): 대상 문서.\n    \"\"\"\n    try:\n        if not geometry_list or not doc:\n            return\n        layer_index = _ensure_layer(doc, layer_name)\n        if layer_index < 0:\n            return\n        success = 0\n        total = len(geometry_list)\n        for g in geometry_list:\n            if _add_geometry(doc, g, layer_index):\n                success += 1\n        doc.Views.Redraw()\n        debug_print(\"[bake] layer=\", layer_name, \"total=\", total, \"added=\", success)\n    except Exception:\n        # 조용히 실패 허용 (GH 컴포넌트 안정성 우선)\n        pass\n\n\n# ==============================================================================\n# 1. 데이터 입력 (Source Centerlines)\n# ==============================================================================\n\n\ndef get_source_centerlines(doc: Rhino.RhinoDoc) -> List[Tuple[geo.Curve, float]]:\n    \"\"\"문서에서 Road::Centerline 하위 레이어의 중심선과 총 폭을 수집합니다.\n\n    레이어명 형식: 'Road::Centerline::{TotalWidth}'\n\n    Args:\n        doc (Rhino.RhinoDoc): Rhino 문서.\n\n    Returns:\n        List[Tuple[geo.Curve, float]]: (중심선 커브, 도로 총 폭) 튜플 리스트.\n    \"\"\"\n    results: List[Tuple[geo.Curve, float]] = []\n    try:\n        if doc is None:\n            return results\n\n        # 문서 공차 및 폴리라인 근사에 사용할 세그먼트 길이 결정\n        tol = _get_model_tol(doc)\n        default_seg_len = max(0.5, float(tol) * 10.0)\n\n        parent_idx = doc.Layers.FindByFullPath(LAYER_SRC_CENTERLINE_PARENT, -1)\n        parent_layer_id = None if parent_idx == -1 else doc.Layers[parent_idx].Id\n        debug_print(\n            \"[source] parent=\",\n            LAYER_SRC_CENTERLINE_PARENT,\n            \"found_index=\",\n            parent_idx,\n        )\n\n        for layer in doc.Layers:\n            try:\n                # 부모 체크: 부모가 명시되어 있다면 ParentLayerId 매칭,\n                # 아니면 FullPath 기반 접두사로 필터링\n                if parent_layer_id:\n                    if layer.ParentLayerId != parent_layer_id:\n                        continue\n                else:\n                    full_path = getattr(layer, \"FullPath\", layer.Name)\n                    if not full_path.startswith(LAYER_SRC_CENTERLINE_PARENT + \"::\"):\n                        continue\n\n                # 이름에서 총 폭 파싱\n                full_path = getattr(layer, \"FullPath\", layer.Name)\n                try:\n                    total_width_str = full_path.split(\"::\")[-1]\n                    total_width = float(total_width_str)\n                except Exception:\n                    debug_print(\"[source] skip (parse fail):\", full_path)\n                    continue\n\n                # 레이어의 커브 수집\n                layer_objects = list(doc.Objects.FindByLayer(layer))\n                if not layer_objects:\n                    debug_print(\"[source] no objects:\", full_path)\n                    continue\n\n                valid_found = False\n                added_count = 0\n                for obj_ref in layer_objects:\n                    try:\n                        geom = obj_ref.Geometry\n                        if isinstance(geom, geo.Curve) and geom.IsValid:\n                            # 커브를 폴리라인 근사로 변환하여 처리 (곡선에서 확장 이슈 방지)\n                            poly_crv = None\n                            try:\n                                poly_crv = _to_polyline_curve(\n                                    geom, default_seg_len, tol\n                                )\n                            except Exception:\n                                poly_crv = None\n\n                            if poly_crv and getattr(poly_crv, \"IsValid\", True):\n                                print(\"SUCCEEDED POLY CONVERT\")\n                                results.append((poly_crv, total_width))\n                                valid_found = True\n                                added_count += 1\n                                continue\n\n                            # 폴리라인 변환이 실패하면 원본 커브의 복제본을 사용\n                            try:\n                                results.append((geom.DuplicateCurve(), total_width))\n                                print(\"FAIL POLY CONVERT\")\n                                valid_found = True\n                                added_count += 1\n                            except Exception:\n                                continue\n                    except Exception:\n                        continue\n\n                if not valid_found:\n                    # 유효 커브가 없으면 스킵\n                    continue\n                debug_print(\n                    \"[source] layer=\",\n                    full_path,\n                    \"total_width=\",\n                    total_width,\n                    \"curves_added=\",\n                    added_count,\n                )\n            except Exception:\n                continue\n    except Exception:\n        return results\n\n    return results\n\n\n# ==============================================================================\n# 2. 지오메트리 생성 헬퍼\n# ==============================================================================\n\n\ndef _pick_offset_curve(curves: List[geo.Curve]) -> Optional[geo.Curve]:\n    \"\"\"Offset 결과 곡선 리스트에서 가장 적합한 하나를 선택합니다.\n\n    기본 전략: 가장 긴 커브를 선택.\n    \"\"\"\n    if not curves:\n        return None\n    try:\n        curves = [c for c in curves if isinstance(c, geo.Curve) and c.IsValid]\n        if not curves:\n            return None\n        curves.sort(key=lambda c: c.GetLength() if c.IsValid else 0.0, reverse=True)\n        return curves[0]\n    except Exception:\n        return curves[0]\n\n\ndef _get_curve_plane(curve: geo.Curve) -> geo.Plane:\n    \"\"\"커브의 적절한 평면을 추정합니다. 실패 시 WorldXY.\"\"\"\n    try:\n        ok, pl = curve.TryGetPlane()\n        if ok:\n            return pl\n    except Exception:\n        pass\n    return geo.Plane.WorldXY\n\n\ndef _offset_curve(curve: geo.Curve, dist: float, tol: float) -> Optional[geo.Curve]:\n    \"\"\"커브를 주어진 거리만큼 오프셋한 결과 중 대표 커브를 반환합니다.\"\"\"\n    if not curve:\n        return None\n    if dist == 0.0:\n        # 0 오프셋은 원 커브의 복제본을 반환하여 부작용을 피합니다.\n        try:\n            return curve.DuplicateCurve()\n        except Exception:\n            return curve\n    try:\n        plane = _get_curve_plane(curve)\n        # RhinoCommon Offset은 List[Curve] 반환\n        crvs = curve.Offset(plane, dist, tol, geo.CurveOffsetCornerStyle.Sharp)\n        return _pick_offset_curve(list(crvs) if crvs else [])\n    except Exception:\n        # ghcomponents Offset 시도 (Polyline에 강함)\n        try:\n            res = ghcomp.OffsetCurve(curve, dist)\n            if isinstance(res, list) and res:\n                return _pick_offset_curve(res)\n            if isinstance(res, geo.Curve):\n                return res\n        except Exception:\n            pass\n    return None\n\n\ndef _loft_between(curve_a: geo.Curve, curve_b: geo.Curve) -> Optional[geo.Surface]:\n    \"\"\"두 커브 사이를 Loft하여 Surface를 생성합니다.\n\n    Returns:\n        Optional[geo.Surface]: 성공 시 Surface, 실패 시 None.\n    \"\"\"\n    try:\n        breps = geo.Brep.CreateFromLoft(\n            [curve_a, curve_b],\n            geo.Point3d.Unset,\n            geo.Point3d.Unset,\n            geo.LoftType.Straight,\n            False,\n        )\n        if breps:\n            brep = breps[0]\n            if brep and brep.Faces.Count > 0:\n                return brep.Faces[0].DuplicateSurface()\n    except Exception:\n        pass\n\n    # gh Loft 폴백\n    try:\n        loft_res = ghcomp.Loft([curve_a, curve_b])\n        if isinstance(loft_res, list) and loft_res:\n            brep = loft_res[0]\n        else:\n            brep = loft_res\n        if isinstance(brep, geo.Brep) and brep.Faces.Count > 0:\n            return brep.Faces[0].DuplicateSurface()\n    except Exception:\n        pass\n\n    return None\n\n\ndef create_band_surface(\n    center_curve: geo.Curve, dist_a: float, dist_b: float, tol: float\n) -> Optional[geo.Surface]:\n    \"\"\"원본 중심선으로부터 두 거리 구간 [dist_a, dist_b] 사이의 띠(밴드) Surface 생성.\n\n    dist_a, dist_b는 원본 중심선 기준의 오프셋 거리입니다. 예:\n    - 단일 중앙선: [-w/2, +w/2]\n    - 이중 중앙선(3차선 이상): [0, +w], [-w, 0]\n\n    Args:\n        center_curve (geo.Curve): 기준 중심선.\n        dist_a (float): 첫 번째 오프셋 거리(원본 기준). 0이면 원 커브 사용.\n        dist_b (float): 두 번째 오프셋 거리(원본 기준). 0이면 원 커브 사용.\n        tol (float): 문서 공차.\n\n    Returns:\n        Optional[geo.Surface]: 생성된 Surface. 실패 시 None.\n    \"\"\"\n    if not center_curve:\n        return None\n\n    try:\n        crv_a = _offset_curve(center_curve, float(dist_a), tol)\n        crv_b = _offset_curve(center_curve, float(dist_b), tol)\n        if not crv_a or not crv_b:\n            return None\n        return _loft_between(crv_a, crv_b)\n    except Exception:\n        return None\n\n\ndef _to_polyline_curve(\n    curve: geo.Curve, segment_length: float, tol: float\n) -> Optional[geo.Curve]:\n    \"\"\"커브를 PolylineCurve로 안정적으로 근사합니다.\n\n    - 과도한 세그먼트 길이로 인해 형태가 뻥튀기(과대)되는 문제를 줄이기 위해\n      세그먼트 개수를 길이에 따라 적절히 제한/보정합니다.\n    - 닫힌 커브의 경우 시작/끝 포인트 중복으로 긴 세그먼트가 생기지 않도록 처리합니다.\n\n    Args:\n        curve (geo.Curve): 입력 커브.\n        segment_length (float): 목표 세그먼트 길이(상한/하한으로만 사용될 수 있음).\n        tol (float): 문서 공차(포인트 비교 등 기준).\n\n    Returns:\n        Optional[geo.PolylineCurve]: 근사된 폴리라인 커브. 실패 시 원본 복제 또는 None.\n    \"\"\"\n    if curve is None:\n        return None\n\n    try:\n        # 이미 폴리라인이면 복제 반환\n        if isinstance(curve, geo.PolylineCurve):\n            return curve.DuplicateCurve()\n\n        length = curve.GetLength()\n        if not length or length <= 0.0:\n            return curve.DuplicateCurve()\n\n        # 샘플 개수 계산: 길이에 비례, 과소/과대 샘플링 방지\n        # - segment_length가 크면 과도 단순화되어 offset 시 부풀어 보이는 문제 발생 가능\n        # - 최소/최대 세그먼트 개수 클램핑으로 안정화\n        base_seg_len = (\n            float(segment_length)\n            if segment_length and segment_length > 0\n            else max(0.25, tol * 10.0)\n        )\n        est_count = max(2, int(math.ceil(length / base_seg_len)))\n        count = max(32, min(est_count, 512))  # [32, 512]로 제한\n\n        # 파라미터 샘플 (양 끝 포함)\n        params = curve.DivideByCount(count, True)\n        if not params or len(params) < 2:\n            # DivideByLength 폴백\n            params = curve.DivideByLength(base_seg_len, True)\n\n        if not params:\n            return curve.DuplicateCurve()\n\n        # 포인트 생성\n        pts = []\n        for t in params:\n            try:\n                pts.append(curve.PointAt(float(t)))\n            except Exception:\n                continue\n\n        if len(pts) < 2:\n            return curve.DuplicateCurve()\n\n        # 닫힌 커브 처리: 끝점을 시작점과 강제로 일치시켜 불필요한 장거리 세그먼트 방지\n        is_closed = False\n        try:\n            is_closed = bool(curve.IsClosed)\n        except Exception:\n            is_closed = False\n\n        if is_closed:\n            # 첫/끝 점이 충분히 가까우면 끝 점을 첫 점으로 스냅\n            if pts[0].DistanceTo(pts[-1]) <= max(tol, 1e-6):\n                pts[-1] = geo.Point3d(pts[0])\n\n        pl = geo.Polyline(pts)\n\n        # 닫힌 상태 보정 (PolylineCurve에서 닫힘 성질 유지)\n        try:\n            if is_closed and not pl.IsClosed:\n                pl.Add(pl[0])\n        except Exception:\n            pass\n\n        if pl.IsValid:\n            plc = geo.PolylineCurve(pl)\n            if getattr(plc, \"IsValid\", False):\n                return plc\n    except Exception:\n        pass\n\n    # 최종 폴백: 원본 복제\n    try:\n        return curve.DuplicateCurve()\n    except Exception:\n        return None\n\n\ndef create_line_surface(\n    center_curve: geo.Curve, line_width: float\n) -> Optional[geo.Surface]:\n    \"\"\"중심 커브 기준으로 폭이 line_width인 선 도색 Surface를 생성합니다.\n\n    center_curve를 양측으로 line_width/2만큼 오프셋해 서로를 Loft합니다.\n\n    Args:\n        center_curve (geo.Curve): 기준 커브.\n        line_width (float): 선 폭.\n\n    Returns:\n        Optional[geo.Surface]: 생성된 Surface. 실패 시 None.\n    \"\"\"\n    if center_curve is None or line_width is None or line_width <= 0.0:\n        return None\n\n    tol = _get_model_tol(sc.doc if hasattr(sc, \"doc\") else None)\n\n    half = 0.5 * float(line_width)\n    try:\n        c1 = _offset_curve(center_curve, +half, tol)\n        c2 = _offset_curve(center_curve, -half, tol)\n        if not c1 or not c2:\n            debug_print(\"[line] offset failed: half=\", half)\n            return None\n        srf = _loft_between(c1, c2)\n        if srf is None:\n            debug_print(\"[line] loft failed\")\n        return srf\n    except Exception:\n        return None\n\n\ndef create_centerlines(\n    centerline_curve: geo.Curve, num_lanes: int, line_width: float\n) -> List[geo.Surface]:\n    \"\"\"중앙선 Surface 생성.\n\n    - 2차선: 입력 커브에 대해 1개의 실선 Surface 생성.\n    - 3차선 이상: 입력 커브를 line_width/2 만큼 좌우 오프셋한 두 커브 각각에 대해\n      실선 Surface 생성하여 2개 반환.\n\n    Args:\n        centerline_curve (geo.Curve): 중심 커브.\n        num_lanes (int): 차선 수.\n        line_width (float): 선 폭.\n\n    Returns:\n        List[geo.Surface]: 생성된 중앙선 Surface 리스트.\n    \"\"\"\n    out: List[geo.Surface] = []\n    if not centerline_curve or num_lanes is None or line_width is None:\n        return out\n    if line_width <= 0.0:\n        return out\n\n    tol = _get_model_tol(sc.doc if hasattr(sc, \"doc\") else None)\n\n    try:\n        half = 0.5 * float(line_width)\n        if num_lanes == 2:\n            # 원본 중심선을 정확히 중심으로 하는 단일 밴드 [-w/2, +w/2]\n            srf = create_band_surface(centerline_curve, -half, +half, tol)\n            if srf:\n                out.append(srf)\n            debug_print(\"[centerline] lanes=2 surfaces=\", len(out))\n            return out\n\n        if num_lanes > 2:\n            # 원본 중심선과 정확히 일치하는 경계(중앙선)를 기준으로 좌/우 밴드 생성\n            left_band = create_band_surface(\n                centerline_curve, 0.0, float(line_width), tol\n            )\n            right_band = create_band_surface(\n                centerline_curve, -float(line_width), 0.0, tol\n            )\n            for srf in (left_band, right_band):\n                if srf:\n                    out.append(srf)\n            debug_print(\"[centerline] lanes=\", num_lanes, \"surfaces=\", len(out))\n    except Exception:\n        return out\n\n    return out\n\n\ndef create_lanelines(\n    centerline_curve: geo.Curve,\n    total_width: float,\n    lane_width: float,\n    line_width: float,\n    num_lanes: int,\n) -> List[geo.Surface]:\n    \"\"\"차선(Laneline) Surface들을 생성합니다.\n\n    - 차선 수가 n이면 차선은 n-1개 생성.\n    - 각 차선은 Paint(5m) + Gap(8m) 패턴으로 분절된 Surface들의 집합.\n\n    Args:\n        centerline_curve (geo.Curve): 기준 중심선 커브.\n        total_width (float): 도로 총 폭.\n        lane_width (float): 개별 차선 폭.\n        line_width (float): 선 도색 폭.\n        num_lanes (int): 차선 수.\n\n    Returns:\n        List[geo.Surface]: 생성된 차선 Surface 리스트.\n    \"\"\"\n    out: List[geo.Surface] = []\n    if (\n        not centerline_curve\n        or total_width is None\n        or lane_width is None\n        or line_width is None\n        or num_lanes is None\n    ):\n        return out\n    if lane_width <= 0.0 or line_width <= 0.0 or num_lanes < 2:\n        return out\n\n    tol = _get_model_tol(sc.doc if hasattr(sc, \"doc\") else None)\n    segment_span = float(LANE_PAINT_LENGTH) + float(LANE_GAP_LENGTH)\n\n    try:\n        for i in range(1, int(num_lanes)):\n            if i >= num_lanes:\n                break\n            # 기준선에서 i번째 차선 위치의 기준 커브 생성\n            offset_dist = (i * lane_width) - (total_width * 0.5)\n            lane_base = _offset_curve(centerline_curve, offset_dist, tol)\n            if not lane_base:\n                debug_print(\"[laneline] offset fail i=\", i, \"dist=\", offset_dist)\n                continue\n\n            # 분절 기준 파라미터 획득 (각 주기 시작점들)\n            params = lane_base.DivideByLength(segment_span, True)\n            if not params:\n                debug_print(\"[laneline] no params i=\", i, \"span=\", segment_span)\n                continue\n\n            # 각 시작 파라미터에서 Paint 길이만큼 트림\n            made_segments = 0\n            for t in params:\n                try:\n                    # t에서부터 LANE_PAINT_LENGTH 만큼 떨어진 파라미터 계산\n                    # 1) 시작까지의 누적 길이\n                    dom = lane_base.Domain\n                    length_to_t = lane_base.GetLength(geo.Interval(dom.Min, float(t)))\n                    if length_to_t is None:\n                        continue\n                    target_from_start = float(length_to_t) + float(LANE_PAINT_LENGTH)\n\n                    ok, t_end = lane_base.LengthParameter(target_from_start)\n                    if not ok:\n                        # 범위를 벗어나면 스킵\n                        continue\n\n                    seg = lane_base.Trim(float(t), float(t_end))\n                    if not seg or not seg.IsValid:\n                        continue\n\n                    srf = create_line_surface(seg, line_width)\n                    if srf:\n                        out.append(srf)\n                        made_segments += 1\n                except Exception:\n                    continue\n            debug_print(\n                \"[laneline] i=\", i, \"params=\", len(params), \"segments=\", made_segments\n            )\n    except Exception:\n        return out\n\n    debug_print(\"[laneline] total surfaces=\", len(out))\n    return out\n\n\ness_create_edgelines_doc = (\n    \"\"\"도로 가장자리 선은 도로 폭의 절반에서 선폭*2 만큼 안쪽으로 생성됩니다.\"\"\"\n)\n\n\ndef create_edgelines_from_regions(\n    road_regions: List[geo.Curve], line_width: float, inset: Optional[float] = None\n) -> List[geo.Surface]:\n    \"\"\"도로 영역(road_regions) 경계로부터 안쪽으로 inset만큼 오프셋한 경로를 기준으로 EdgeLine 생성.\n\n    - 기존 방식(중심선 기준) 대신, 이미 생성된 도로 영역의 외곽 경계를 신뢰 소스로 사용합니다.\n    - 각 경계 커브를 내부로 inset만큼 오프셋한 커브를 중심 커브로 삼아 폭 line_width의 띠 Surface를 만듭니다.\n\n    Args:\n        road_regions (List[geo.Curve]): 도로 영역 경계 커브 리스트(닫힌 커브 권장).\n        line_width (float): EdgeLine의 폭.\n        inset (Optional[float]): 외곽에서 내부로 떨어질 거리. 기본값은 2*line_width.\n\n    Returns:\n        List[geo.Surface]: 생성된 EdgeLine Surface 리스트.\n    \"\"\"\n    out: List[geo.Surface] = []\n    if not road_regions or line_width is None or line_width <= 0.0:\n        return out\n\n    tol = _get_model_tol(sc.doc if hasattr(sc, \"doc\") else None)\n    d_inset = float(inset) if inset is not None else 2.0 * float(line_width)\n    if d_inset <= 0.0:\n        d_inset = 2.0 * float(line_width)\n\n    try:\n        for region in road_regions:\n            if not isinstance(region, geo.Curve):\n                continue\n            if not getattr(region, \"IsClosed\", False):\n                # 폐곡선이 아니면 스킵\n                continue\n\n            # 내부로 inset + (line_width/2)를 이동한 '중심 경로'를 만들고, 그 경로 기준 폭 line_width로 띠를 생성\n            center_offset = d_inset + 0.5 * float(line_width)\n            try:\n                inner_paths = offset_regions_outward(\n                    region, center_offset\n                )  # from utils\n            except Exception:\n                inner_paths = None\n\n            if not inner_paths:\n                # 영역이 너무 좁아 오프셋 불가한 경우\n                continue\n\n            # 가장 긴 내부 경로를 대표로 선택\n            try:\n                inner_paths = [c for c in inner_paths if isinstance(c, geo.Curve)]\n                inner_paths.sort(\n                    key=lambda c: c.GetLength() if c.IsValid else 0.0, reverse=True\n                )\n            except Exception:\n                pass\n\n            for path in inner_paths:\n                try:\n                    if not path or not getattr(path, \"IsValid\", True):\n                        continue\n                    srf = create_line_surface(path, line_width)\n                    if srf:\n                        out.append(srf)\n                except Exception:\n                    continue\n        debug_print(\"[edgeline] from regions: inset=\", d_inset, \"surfaces=\", len(out))\n    except Exception:\n        return out\n\n    return out\n\n\n# ==============================================================================\n# 3. 메인 실행 (Orchestrator)\n# ==============================================================================\n\n\ndef run_road_builder(\n    Run: bool, Bake: bool, lane_width: float, line_width: float\n) -> Tuple[List[geo.Surface], List[geo.Surface], List[geo.Surface]]:\n    \"\"\"RoadDetailBuilder 오케스트레이터.\n\n    Args:\n        Run (bool): 실행 여부.\n        Bake (bool): 결과 Bake 여부.\n        lane_width (float): 차선 폭.\n        line_width (float): 선 도색 폭.\n\n    Returns:\n        Tuple[List[geo.Surface], List[geo.Surface], List[geo.Surface]]: (center, lane, edge)\n    \"\"\"\n    if not Run:\n        return [], [], []\n    if lane_width is None or line_width is None:\n        return [], [], []\n    if lane_width <= 0.0 or line_width <= 0.0:\n        return [], [], []\n\n    prev_doc = getattr(sc, \"doc\", None)\n    try:\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n    except Exception:\n        # GH 외부 환경 대비\n        sc.doc = prev_doc\n\n    try:\n        source_data = get_source_centerlines(sc.doc)\n\n        all_centerlines: List[geo.Surface] = []\n        all_lanelines: List[geo.Surface] = []\n        all_edgelines: List[geo.Surface] = []\n\n        # 선택 입력: road_regions (GH에서 직접 입력되는 경우 우선 사용)\n        try:\n            rr_input = list(globals().get(\"road_regions\", []))\n        except Exception:\n            rr_input = []\n\n        debug_print(\n            \"[run] inputs:\",\n            {\"lane_width\": lane_width, \"line_width\": line_width, \"Bake\": Bake},\n        )\n        debug_print(\"[run] sources:\", len(source_data))\n\n        for center_crv, total_width in source_data:\n            try:\n                if total_width is None or lane_width <= 0.0:\n                    continue\n                num_lanes = int(round(float(total_width) / float(lane_width)))\n                if num_lanes < 2:\n                    continue\n\n                # 생성\n                cs = create_centerlines(center_crv, num_lanes, line_width)\n                ls = create_lanelines(\n                    center_crv, total_width, lane_width, line_width, num_lanes\n                )\n                # 에지라인: road_regions 입력이 없을 때만 기존 방식으로 생성 (중심선 기반)\n                if not rr_input:\n                    es_local: List[geo.Surface] = []\n                    try:\n                        tol_local = _get_model_tol(\n                            sc.doc if hasattr(sc, \"doc\") else None\n                        )\n                        edge_offset = 0.5 * float(total_width)\n                        inset_val = 2.0 * float(line_width)\n                        final_offset = edge_offset - inset_val\n                        if final_offset > 0.0:\n                            left = _offset_curve(center_crv, +final_offset, tol_local)\n                            right = _offset_curve(center_crv, -final_offset, tol_local)\n                            for crv in (left, right):\n                                if crv:\n                                    srf = create_line_surface(crv, line_width)\n                                    if srf:\n                                        es_local.append(srf)\n                    except Exception:\n                        es_local = []\n                    all_edgelines.extend(es_local)\n\n                all_centerlines.extend(cs)\n                all_lanelines.extend(ls)\n\n                debug_print(\n                    \"[run] total_width=\",\n                    total_width,\n                    \"num_lanes=\",\n                    num_lanes,\n                    \"center=\",\n                    len(cs),\n                    \"lane=\",\n                    len(ls),\n                    \"edge=\",\n                    (len(es_local) if not rr_input else 0),\n                )\n            except Exception:\n                continue\n\n        # road_regions 입력이 있는 경우: 영역 기반으로 edgelines 생성 (기존 방식 대체)\n        if rr_input:\n            try:\n                all_edgelines = create_edgelines_from_regions(\n                    rr_input, line_width, inset=2.0 * float(line_width)\n                )\n            except Exception:\n                pass\n\n        if Bake and sc.doc is not None:\n            try:\n                bake_geometry_to_layer(all_centerlines, LAYER_BAKE_CENTERLINE, sc.doc)\n                bake_geometry_to_layer(all_lanelines, LAYER_BAKE_LANELINE, sc.doc)\n                bake_geometry_to_layer(all_edgelines, LAYER_BAKE_EDGELINE, sc.doc)\n            except Exception:\n                pass\n\n        debug_print(\n            \"[run] result counts:\",\n            {\n                \"centerlines\": len(all_centerlines),\n                \"lanelines\": len(all_lanelines),\n                \"edgelines\": len(all_edgelines),\n            },\n        )\n        return all_centerlines, all_lanelines, all_edgelines\n    finally:\n        # 컨텍스트 복원 (GH 컴포넌트에서는 ghdoc가 prev_doc로 설정되어 있음)\n        try:\n            sc.doc = prev_doc\n        except Exception:\n            pass\n\n\n# ==============================================================================\n# 4. GH 컴포넌트 실행부 (입출력 바인딩)\n# ==============================================================================\n# 아래 코드는 Grasshopper Python 컴포넌트의 입력 변수를 가정합니다:\n# - Run (bool), Bake (bool), lane_width (float), line_width (float)\n# 출력:\n# - centerlines, lanelines, edgelines\ntry:\n    _Run = bool(globals().get(\"Run\", False))\n    _Bake = bool(globals().get(\"Bake\", False))\n    _lane_width = float(globals().get(\"lane_width\", 0.0))\n    _line_width = float(globals().get(\"line_width\", 0.0))\n    _DEBUG = bool(globals().get(\"Debug\", True))\n\n    if _DEBUG:\n        debug_print(\n            \"[inputs] Run=\",\n            _Run,\n            \"Bake=\",\n            _Bake,\n            \"lane_width=\",\n            _lane_width,\n            \"line_width=\",\n            _line_width,\n        )\n    if _Run:\n        centerlines, lanelines, edgelines = run_road_builder(\n            _Run, _Bake, _lane_width, _line_width\n        )\n    else:\n        centerlines, lanelines, edgelines = [], [], []\nexcept Exception:\n    # 컴포넌트 입력 미정의/외부 실행 대비\n    centerlines, lanelines, edgelines = [], [], []\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}