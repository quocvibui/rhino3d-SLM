{
  "source_url": "https://github.com/led-ufc/carcara/blob/f1238d304b65c989cc2af829bc49fc5a2fe589eb/carcara/modules/carcara_dataviz.py",
  "repo": "led-ufc/carcara",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "carcara/modules/carcara_dataviz.py",
  "instruction": "Carcara DataViz - SVG Generation and Export Module\r\n\r\nThis module provides utilities for creating and saving SVG (Scalable Vector Graphics)\r\nfiles from Grasshopper/Rhino geometry. Includes functions...",
  "code": "\"\"\"Carcara DataViz - SVG Generation and Export Module\r\n\r\nThis module provides utilities for creating and saving SVG (Scalable Vector Graphics)\r\nfiles from Grasshopper/Rhino geometry. Includes functions for canvas management,\r\nSVG document construction, geometry extraction, coordinate transformation, color\r\nconversion, and file export.\r\n\r\nCore Functions:\r\n    - canvas_origin_info: Extract dimensions from canvas geometry\r\n    - bounding_box_info: Compute bounding box from geometries\r\n    - combine_svg: Build complete SVG document\r\n    - save_svg: Save SVG string to file\r\n\r\nGrasshopper Integration Helpers:\r\n    - normalize_input_list: Convert input to list format\r\n    - get_indexed_value: Get value from list with fallback logic\r\n    - convert_color_to_svg: Convert .NET Color to SVG format\r\n    - get_canvas_dimensions: Get canvas info from canvas or geometries\r\n    - transform_point_to_svg: Transform Rhino to SVG coordinates\r\n\r\nGeometry Extraction:\r\n    - extract_circle_parameters: Get circle center and radius\r\n    - extract_polyline_points: Get polyline points with transformation\r\n    - extract_nurbs_path_data: Sample NURBS curve for SVG path\r\n\r\nSVG Element Generation:\r\n    - svg_circle: Generate circle element\r\n    - svg_polyline: Generate polyline/polygon element\r\n    - svg_polygon: Generate polygon element (always closed)\r\n    - svg_path: Generate path element\r\n    - svg_text: Generate text element with alignment\r\n    - svg_rect: Generate rectangle element\r\n\r\nVersion: 2.0\r\nDate: 2025/11/14\r\n\"\"\"\r\n\r\nimport os\r\nimport Rhino.Geometry as rg\r\n\r\n\r\n###############################################################################\r\n# CANVAS AND BOUNDING BOX FUNCTIONS\r\n###############################################################################\r\n\r\ndef canvas_origin_info(canvas):\r\n    \"\"\"\r\n    Extract origin point and dimensions from canvas rectangle geometry.\r\n    \r\n    Args:\r\n        canvas: Rectangle geometry (Rectangle3d, Curve, or similar)\r\n    \r\n    Returns:\r\n        tuple: (anchor_point, width, height)\r\n    \r\n    Raises:\r\n        ValueError: If canvas is not a valid rectangle\r\n    \"\"\"\r\n    try:\r\n        if isinstance(canvas, rg.Rectangle3d):\r\n            anchor_point = canvas.Corner(0)\r\n            width = canvas.Width\r\n            height = canvas.Height\r\n            return anchor_point, width, height\r\n        \r\n        elif isinstance(canvas, (rg.Curve, rg.PolylineCurve)):\r\n            bbox = canvas.GetBoundingBox(True)\r\n            width = bbox.Max.X - bbox.Min.X\r\n            height = bbox.Max.Y - bbox.Min.Y\r\n            anchor_point = rg.Point3d(bbox.Min.X, bbox.Min.Y, bbox.Min.Z)\r\n            return anchor_point, width, height\r\n        \r\n        else:\r\n            raise ValueError(\"Canvas must be Rectangle3d or Curve geometry\")\r\n    \r\n    except Exception as e:\r\n        raise ValueError(\"Error extracting canvas info: {}\".format(e))\r\n\r\n\r\ndef bounding_box_info(geometries):\r\n    \"\"\"\r\n    Compute bounding box anchor point and dimensions from geometries.\r\n    \r\n    Args:\r\n        geometries (list): List of geometry objects\r\n    \r\n    Returns:\r\n        tuple: (anchor_point, width, height)\r\n    \"\"\"\r\n    if not geometries:\r\n        return rg.Point3d(0, 0, 0), 0, 0\r\n    \r\n    bbox = rg.BoundingBox.Empty\r\n    valid_count = 0\r\n    \r\n    for geom in geometries:\r\n        if geom is None:\r\n            continue\r\n        \r\n        try:\r\n            geom_bbox = None\r\n            \r\n            if isinstance(geom, rg.Point3d):\r\n                geom_bbox = rg.BoundingBox(geom, geom)\r\n            \r\n            elif isinstance(geom, rg.Circle):\r\n                center = geom.Center\r\n                radius = geom.Radius\r\n                geom_bbox = rg.BoundingBox(\r\n                    rg.Point3d(center.X - radius, center.Y - radius, center.Z),\r\n                    rg.Point3d(center.X + radius, center.Y + radius, center.Z)\r\n                )\r\n            \r\n            elif isinstance(geom, rg.Polyline):\r\n                geom_bbox = geom.BoundingBox\r\n            \r\n            elif hasattr(geom, 'GetBoundingBox'):\r\n                geom_bbox = geom.GetBoundingBox(True)\r\n            \r\n            elif hasattr(geom, 'BoundingBox'):\r\n                geom_bbox = geom.BoundingBox\r\n            \r\n            if geom_bbox and geom_bbox.IsValid:\r\n                bbox.Union(geom_bbox)\r\n                valid_count += 1\r\n        \r\n        except Exception:\r\n            continue\r\n    \r\n    if bbox.IsValid and valid_count > 0:\r\n        anchor_point = rg.Point3d(bbox.Min.X, bbox.Min.Y, bbox.Min.Z)\r\n        width = bbox.Max.X - bbox.Min.X\r\n        height = bbox.Max.Y - bbox.Min.Y\r\n        return anchor_point, width, height\r\n    else:\r\n        return rg.Point3d(0, 0, 0), 0, 0\r\n\r\n\r\n###############################################################################\r\n# GRASSHOPPER INTEGRATION HELPERS\r\n###############################################################################\r\n\r\ndef normalize_input_list(data):\r\n    \"\"\"\r\n    Normalize input to list format.\r\n    \r\n    Converts single items or iterables to a standard list format.\r\n    Returns empty list if input is None.\r\n    \r\n    Args:\r\n        data: Single item, iterable, or None\r\n    \r\n    Returns:\r\n        list: List of items or empty list if None\r\n    \r\n    Examples:\r\n        >>> normalize_input_list(5)\r\n        [5]\r\n        >>> normalize_input_list([1, 2, 3])\r\n        [1, 2, 3]\r\n        >>> normalize_input_list(None)\r\n        []\r\n    \"\"\"\r\n    if data is None:\r\n        return []\r\n    if not hasattr(data, '__iter__'):\r\n        return [data]\r\n    return list(data)\r\n\r\n\r\ndef get_indexed_value(value_list, index, default):\r\n    \"\"\"\r\n    Get value from list by index with intelligent fallback logic.\r\n    \r\n    Fallback rules:\r\n    - Single value: applies to all indices\r\n    - List shorter than index: uses last value\r\n    - None value at index: uses default\r\n    - Empty list: uses default\r\n    \r\n    Args:\r\n        value_list: Single value, list of values, or None\r\n        index (int): Current item index\r\n        default: Default value if value_list is None or empty\r\n    \r\n    Returns:\r\n        Value for this index (any type)\r\n    \r\n    Examples:\r\n        >>> get_indexed_value(5, 0, 0)\r\n        5  # Single value applies to all\r\n        >>> get_indexed_value([10, 20, 30], 1, 0)\r\n        20\r\n        >>> get_indexed_value([10, 20], 5, 0)\r\n        20  # Uses last value for out-of-range index\r\n        >>> get_indexed_value(None, 0, 99)\r\n        99  # Uses default\r\n    \"\"\"\r\n    if value_list is None:\r\n        return default\r\n    \r\n    if not hasattr(value_list, '__iter__'):\r\n        # Single value - apply to all indices\r\n        return value_list\r\n    elif index < len(value_list):\r\n        # Get value at index\r\n        value = value_list[index]\r\n        return value if value is not None else default\r\n    elif len(value_list) > 0:\r\n        # Use last value for out-of-range indices\r\n        value = value_list[-1]\r\n        return value if value is not None else default\r\n    else:\r\n        # Empty list\r\n        return default\r\n\r\n\r\ndef convert_color_to_svg(color_input):\r\n    \"\"\"\r\n    Convert Grasshopper/System.Drawing.Color to SVG format.\r\n    \r\n    Args:\r\n        color_input: System.Drawing.Color object or string\r\n    \r\n    Returns:\r\n        tuple: (color_string, opacity)\r\n            color_string: Hex color like \"#FF0000\"\r\n            opacity: Float 0-1 (default 1.0 if not specified)\r\n    \"\"\"\r\n    # Handle None\r\n    if color_input is None:\r\n        return \"#000000\", 1.0  # Black, fully opaque\r\n    \r\n    # Handle string input\r\n    if isinstance(color_input, str):\r\n        return color_input, 1.0\r\n    \r\n    # Handle System.Drawing.Color\r\n    try:\r\n        if hasattr(color_input, 'R') and hasattr(color_input, 'G') and hasattr(color_input, 'B'):\r\n            r = color_input.R\r\n            g = color_input.G\r\n            b = color_input.B\r\n            \r\n            # Get alpha if available\r\n            if hasattr(color_input, 'A'):\r\n                opacity = color_input.A / 255.0\r\n            else:\r\n                opacity = 1.0\r\n            \r\n            # Convert to hex\r\n            hex_color = \"#{:02X}{:02X}{:02X}\".format(r, g, b)\r\n            return hex_color, opacity\r\n    except:\r\n        pass\r\n    \r\n    # Fallback\r\n    return \"#000000\", 1.0\r\n\r\n\r\n\r\ndef get_canvas_dimensions(canvas, geometries):\r\n    \"\"\"\r\n    Get canvas anchor point and dimensions.\r\n    \r\n    Uses provided canvas if available, otherwise computes bounding box\r\n    from geometries.\r\n    \r\n    Args:\r\n        canvas: Canvas rectangle geometry or None\r\n        geometries (list): List of geometry objects (used if canvas is None)\r\n    \r\n    Returns:\r\n        tuple: (anchor_point, width, height)\r\n    \r\n    Examples:\r\n        >>> anchor, w, h = get_canvas_dimensions(canvas_rect, None)\r\n        >>> anchor, w, h = get_canvas_dimensions(None, [circle1, circle2])\r\n    \"\"\"\r\n    if canvas is not None:\r\n        return canvas_origin_info(canvas)\r\n    else:\r\n        return bounding_box_info(geometries)\r\n\r\n\r\ndef transform_point_to_svg(x, y, anchor_point, canvas_height):\r\n    \"\"\"\r\n    Transform Rhino coordinates to SVG coordinates.\r\n    \r\n    Performs two transformations:\r\n    1. Translation: Makes coordinates relative to canvas anchor point\r\n    2. Y-axis flip: Converts from Rhino Y-up to SVG Y-down coordinate system\r\n    \r\n    Args:\r\n        x (float): Rhino X coordinate\r\n        y (float): Rhino Y coordinate\r\n        anchor_point (Point3d): Canvas anchor point\r\n        canvas_height (float): Canvas height for Y-axis flip\r\n    \r\n    Returns:\r\n        tuple: (svg_x, svg_y) in SVG coordinate system\r\n    \r\n    Examples:\r\n        >>> transform_point_to_svg(5, 10, Point3d(0, 0, 0), 100)\r\n        (5.0, 90.0)  # Y flipped: 100 - 10 = 90\r\n        >>> transform_point_to_svg(15, 5, Point3d(10, 0, 0), 50)\r\n        (5.0, 45.0)  # X translated: 15-10=5, Y flipped: 50-5=45\r\n    \"\"\"\r\n    svg_x = x - anchor_point.X\r\n    svg_y = y - anchor_point.Y\r\n    svg_y = canvas_height - svg_y  # Flip Y-axis\r\n    return svg_x, svg_y\r\n\r\ndef extract_plane_transform(plane, anchor_pt=None, canvas_height=0):\r\n    \"\"\"\r\n    Extract position and rotation from a Rhino Plane for SVG.\r\n    \r\n    Converts Rhino plane to SVG coordinates with rotation.\r\n    Returns position and rotation angle for SVG transform attribute.\r\n    \r\n    Args:\r\n        plane (Plane): Rhino.Geometry.Plane object\r\n        anchor_pt (Point3d): Canvas anchor point for offset (optional)\r\n        canvas_height (float): Canvas height for Y-flip (optional)\r\n    \r\n    Returns:\r\n        tuple: (x, y, rotation_degrees)\r\n            x, y: SVG coordinates\r\n            rotation_degrees: Rotation in degrees (counterclockwise in SVG)\r\n    \r\n    Example:\r\n        >>> x, y, rot = extract_plane_transform(plane, anchor, height)\r\n        >>> transform = \"translate({},{}) rotate({})\".format(x, y, rot)\r\n    \"\"\"\r\n    import math\r\n    \r\n    # Get origin point\r\n    origin = plane.Origin\r\n    \r\n    # Transform to SVG coordinates\r\n    if anchor_pt and canvas_height > 0:\r\n        x, y = transform_point_to_svg(origin.X, origin.Y, anchor_pt, canvas_height)\r\n    else:\r\n        x, y = origin.X, origin.Y\r\n    \r\n    # Calculate rotation from plane's X-axis\r\n    # In Rhino: X-axis is the \"forward\" direction\r\n    x_axis = plane.XAxis\r\n    \r\n    # Calculate angle in radians (atan2 gives angle from positive X-axis)\r\n    angle_radians = math.atan2(x_axis.Y, x_axis.X)\r\n    \r\n    # Convert to degrees\r\n    angle_degrees = math.degrees(angle_radians)\r\n    \r\n    # SVG uses counterclockwise rotation, but we need to flip for Y-down\r\n    # Negate the angle to account for Y-axis flip\r\n    svg_rotation = -angle_degrees\r\n    \r\n    return x, y, svg_rotation\r\n\r\n\r\ndef svg_text_with_transform(x, y, text, rotation=0, font_family=\"Arial\", \r\n                           font_size=12, fill=\"black\", text_anchor=\"start\",\r\n                           dominant_baseline=\"auto\", fill_opacity=1.0):\r\n    \"\"\"Generate SVG text element with position and rotation transform.\"\"\"\r\n    \r\n    # Escape text for XML\r\n    escaped_text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\r\n    \r\n    # Build transform attribute\r\n    if rotation != 0:\r\n        transform = ' transform=\"translate({},{}) rotate({})\"'.format(x, y, rotation)\r\n        x_attr = 0\r\n        y_attr = 0\r\n    else:\r\n        transform = ''\r\n        x_attr = x\r\n        y_attr = y\r\n    \r\n    # Build opacity attribute - FIX HERE\r\n    # Handle None opacity (default to 1.0)\r\n    if fill_opacity is None:\r\n        fill_opacity = 1.0\r\n    \r\n    opacity_attr = '' if fill_opacity >= 1.0 else ' fill-opacity=\"{}\"'.format(fill_opacity)\r\n    \r\n    # Also handle None font_family - FIX HERE\r\n    if font_family is None:\r\n        font_family = \"Arial\"\r\n    \r\n    return '<text x=\"{}\" y=\"{}\" font-family=\"{}\" font-size=\"{}\" fill=\"{}\" text-anchor=\"{}\" dominant-baseline=\"{}\"{}{}>{}</text>\\n'.format(\r\n        x_attr, y_attr, font_family, font_size, fill, text_anchor, dominant_baseline, opacity_attr, transform, escaped_text\r\n    )\r\n\r\n\r\n\r\n###############################################################################\r\n# GEOMETRY EXTRACTION FUNCTIONS\r\n###############################################################################\r\n\r\ndef extract_circle_parameters(circle):\r\n    \"\"\"\r\n    Extract center coordinates and radius from circle geometry.\r\n    \r\n    Returns raw Rhino coordinates - transformation should be done separately\r\n    using transform_point_to_svg().\r\n    \r\n    Args:\r\n        circle: Circle geometry object\r\n    \r\n    Returns:\r\n        tuple: (cx, cy, radius) in Rhino coordinates\r\n    \r\n    Raises:\r\n        ValueError: If geometry is not a valid circle\r\n    \"\"\"\r\n    try:\r\n        if isinstance(circle, rg.Circle):\r\n            return circle.Center.X, circle.Center.Y, circle.Radius\r\n        \r\n        elif isinstance(circle, rg.ArcCurve):\r\n            if circle.IsCircle():\r\n                arc_circle = circle.Arc\r\n                if abs(arc_circle.AngleDegrees - 360.0) < 0.01:\r\n                    return arc_circle.Center.X, arc_circle.Center.Y, arc_circle.Radius\r\n                else:\r\n                    raise ValueError(\"ArcCurve is not a complete circle (angle: {:.2f}Â°)\".format(\r\n                        arc_circle.AngleDegrees))\r\n            else:\r\n                raise ValueError(\"ArcCurve is not circular\")\r\n        \r\n        elif isinstance(circle, rg.NurbsCurve):\r\n            success, circle_geom = circle.TryGetCircle()\r\n            if success:\r\n                return circle_geom.Center.X, circle_geom.Center.Y, circle_geom.Radius\r\n            else:\r\n                raise ValueError(\"NurbsCurve cannot be converted to circle\")\r\n        \r\n        elif isinstance(circle, rg.Curve):\r\n            nurbs = circle.ToNurbsCurve()\r\n            if nurbs:\r\n                success, circle_geom = nurbs.TryGetCircle()\r\n                if success:\r\n                    return circle_geom.Center.X, circle_geom.Center.Y, circle_geom.Radius\r\n            raise ValueError(\"Curve cannot be converted to circle\")\r\n        \r\n        else:\r\n            raise TypeError(\"Unsupported circle type: {}\".format(type(circle).__name__))\r\n    \r\n    except (ValueError, TypeError) as e:\r\n        raise e\r\n    except Exception as e:\r\n        raise ValueError(\"Error extracting circle parameters: {}\".format(e))\r\n\r\n\r\ndef extract_polyline_points(polyline, anchor_point, canvas_height):\r\n    \"\"\"\r\n    Extract point coordinates from polyline geometry with coordinate transformation.\r\n    \r\n    Handles transformation from Rhino (Y-up) to SVG (Y-down) coordinate systems.\r\n    \r\n    Args:\r\n        polyline: Polyline geometry object\r\n        anchor_point (Point3d): Canvas anchor for translation\r\n        canvas_height (float): Canvas height for Y-axis flip\r\n    \r\n    Returns:\r\n        list: List of (x, y) coordinate tuples in SVG coordinates\r\n    \r\n    Raises:\r\n        ValueError: If geometry cannot be converted to polyline\r\n    \"\"\"\r\n    points = []\r\n    \r\n    try:\r\n        # Extract raw points first\r\n        raw_points = []\r\n        \r\n        if isinstance(polyline, rg.Polyline):\r\n            raw_points = [(pt.X, pt.Y) for pt in polyline]\r\n        \r\n        elif isinstance(polyline, rg.PolylineCurve):\r\n            success, pline = polyline.TryGetPolyline()\r\n            if success:\r\n                raw_points = [(pt.X, pt.Y) for pt in pline]\r\n            else:\r\n                for i in range(polyline.PointCount):\r\n                    pt = polyline.Point(i)\r\n                    raw_points.append((pt.X, pt.Y))\r\n        \r\n        elif isinstance(polyline, rg.Curve):\r\n            success, pline = polyline.TryGetPolyline()\r\n            if success:\r\n                raw_points = [(pt.X, pt.Y) for pt in pline]\r\n            else:\r\n                nurbs = polyline.ToNurbsCurve()\r\n                if nurbs:\r\n                    for i in range(nurbs.Points.Count):\r\n                        pt = nurbs.Points[i].Location\r\n                        raw_points.append((pt.X, pt.Y))\r\n                else:\r\n                    raise ValueError(\"Curve cannot be converted to polyline points\")\r\n        \r\n        elif hasattr(polyline, '__iter__'):\r\n            for pt in polyline:\r\n                if isinstance(pt, rg.Point3d):\r\n                    raw_points.append((pt.X, pt.Y))\r\n                elif hasattr(pt, 'X') and hasattr(pt, 'Y'):\r\n                    raw_points.append((pt.X, pt.Y))\r\n                elif isinstance(pt, (list, tuple)) and len(pt) >= 2:\r\n                    raw_points.append((pt[0], pt[1]))\r\n        \r\n        else:\r\n            raise ValueError(\"Unsupported polyline type: {}\".format(type(polyline)))\r\n        \r\n        if not raw_points or len(raw_points) < 2:\r\n            raise ValueError(\"Polyline has insufficient points (need at least 2)\")\r\n        \r\n        # Transform all points to SVG coordinates\r\n        for x, y in raw_points:\r\n            svg_x, svg_y = transform_point_to_svg(x, y, anchor_point, canvas_height)\r\n            points.append((svg_x, svg_y))\r\n        \r\n        return points\r\n        \r\n    except Exception as e:\r\n        raise ValueError(\"Error extracting polyline points: {}\".format(e))\r\n\r\n\r\ndef extract_nurbs_path_data(curve, sample_count, anchor_point, canvas_height):\r\n    \"\"\"\r\n    Extract SVG path data from NURBS curve using linear approximation.\r\n    \r\n    Handles coordinate transformation from Rhino (Y-up) to SVG (Y-down).\r\n    \r\n    Args:\r\n        curve: NURBS curve geometry\r\n        sample_count (int): Number of sample points\r\n        anchor_point (Point3d): Canvas anchor for coordinate transformation\r\n        canvas_height (float): Canvas height for Y-axis flip\r\n    \r\n    Returns:\r\n        str: SVG path data string (e.g., \"M 10 20 L 30 40 L 50 60\")\r\n    \r\n    Raises:\r\n        ValueError: If curve or sample_count is invalid\r\n    \"\"\"\r\n    if curve is None or sample_count < 2:\r\n        return \"\"\r\n    \r\n    try:\r\n        domain = curve.Domain\r\n        t_values = [domain.T0 + (domain.T1 - domain.T0) * i / (sample_count - 1) \r\n                   for i in range(sample_count)]\r\n        \r\n        path_commands = []\r\n        \r\n        for i, t in enumerate(t_values):\r\n            pt = curve.PointAt(t)\r\n            \r\n            # Transform to SVG coordinates\r\n            svg_x, svg_y = transform_point_to_svg(pt.X, pt.Y, anchor_point, canvas_height)\r\n            \r\n            command = \"M\" if i == 0 else \"L\"\r\n            path_commands.append(\"{} {:.2f} {:.2f}\".format(command, svg_x, svg_y))\r\n        \r\n        return \" \".join(path_commands)\r\n    \r\n    except Exception as e:\r\n        raise ValueError(\"Error extracting path data: {}\".format(e))\r\n\r\n\r\n###############################################################################\r\n# SVG DOCUMENT FUNCTIONS\r\n###############################################################################\r\n\r\ndef combine_svg(elements, width=\"800px\", height=\"600px\", viewBox=\"0 0 800 600\", \r\n                xmlns=\"http://www.w3.org/2000/svg\", version=\"1.1\"):\r\n    \"\"\"\r\n    Combine SVG elements into complete SVG document with proper headers.\r\n    \r\n    Args:\r\n        elements (list[str]): List of SVG element strings\r\n        width (str, optional): SVG width attribute\r\n        height (str, optional): SVG height attribute\r\n        viewBox (str, optional): SVG viewBox attribute\r\n        xmlns (str, optional): XML namespace\r\n        version (str, optional): SVG version\r\n    \r\n    Returns:\r\n        str: Complete SVG document as string\r\n    \"\"\"\r\n    svg_body = \"\\n\".join(elements)\r\n    \r\n    svg_document = '''<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n<svg xmlns=\"{xmlns}\" version=\"{version}\" width=\"{width}\" height=\"{height}\" viewBox=\"{viewBox}\">\r\n{body}\r\n</svg>'''.format(\r\n        xmlns=xmlns,\r\n        version=version,\r\n        width=width,\r\n        height=height,\r\n        viewBox=viewBox,\r\n        body=svg_body\r\n    )\r\n    \r\n    return svg_document\r\n\r\n\r\ndef save_svg(svg_content, file_path):\r\n    \"\"\"\r\n    Save SVG content to file.\r\n    \r\n    Args:\r\n        svg_content (str): Complete SVG document as string\r\n        file_path (str): Absolute or relative file path for output\r\n    \r\n    Raises:\r\n        IOError: If file cannot be written\r\n        OSError: If directory cannot be created\r\n    \"\"\"\r\n    try:\r\n        directory = os.path.dirname(file_path)\r\n        if directory and not os.path.exists(directory):\r\n            os.makedirs(directory)\r\n        \r\n        with open(file_path, 'w', encoding='utf-8') as f:\r\n            f.write(svg_content)\r\n    \r\n    except IOError as e:\r\n        raise IOError(\"Error writing SVG file to {}: {}\".format(file_path, e))\r\n    except OSError as e:\r\n        raise OSError(\"Error creating directory for {}: {}\".format(file_path, e))\r\n\r\n\r\n###############################################################################\r\n# SVG ELEMENT GENERATION FUNCTIONS\r\n###############################################################################\r\n\r\ndef svg_circle(cx, cy, r, stroke=\"none\", fill=\"none\", stroke_width=0, \r\n               fill_opacity=None, stroke_opacity=None):\r\n    \"\"\"\r\n    Generate SVG circle element string with Illustrator-compatible opacity.\r\n    \r\n    Args:\r\n        cx (float): Center X coordinate (in SVG coordinates)\r\n        cy (float): Center Y coordinate (in SVG coordinates)\r\n        r (float): Radius\r\n        stroke (str): Stroke color (RGB hex or color name)\r\n        fill (str): Fill color (RGB hex or color name)\r\n        stroke_width (float): Stroke width\r\n        fill_opacity (float, optional): Fill opacity (0.0-1.0)\r\n        stroke_opacity (float, optional): Stroke opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG circle element\r\n    \"\"\"\r\n    if r <= 0:\r\n        return \"\"\r\n    \r\n    attrs = [\r\n        'cx=\"{}\"'.format(cx),\r\n        'cy=\"{}\"'.format(cy),\r\n        'r=\"{}\"'.format(r),\r\n        'fill=\"{}\"'.format(fill),\r\n        'stroke=\"{}\"'.format(stroke),\r\n        'stroke-width=\"{}\"'.format(stroke_width)\r\n    ]\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    if stroke_opacity is not None and stroke_opacity < 1.0:\r\n        attrs.append('stroke-opacity=\"{:.2f}\"'.format(stroke_opacity))\r\n    \r\n    return '<circle {}/>'.format(\" \".join(attrs))\r\n\r\n\r\ndef svg_polyline(points, stroke=\"none\", fill=\"none\", stroke_width=0, dash=\"\",\r\n                 fill_opacity=None, stroke_opacity=None):\r\n    \"\"\"\r\n    Generate SVG polyline or polygon element string.\r\n    \r\n    Automatically detects if polyline is closed (first and last points match)\r\n    and generates polygon element accordingly.\r\n    \r\n    Args:\r\n        points (list): List of (x, y) coordinate tuples (in SVG coordinates)\r\n        stroke (str): Stroke color (RGB hex or color name)\r\n        fill (str): Fill color (RGB hex or color name)\r\n        stroke_width (float): Stroke width\r\n        dash (str): Stroke dash pattern\r\n        fill_opacity (float, optional): Fill opacity (0.0-1.0)\r\n        stroke_opacity (float, optional): Stroke opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG polyline or polygon element\r\n    \"\"\"\r\n    if not points or len(points) < 2:\r\n        return \"\"\r\n    \r\n    is_closed = False\r\n    if len(points) >= 3:\r\n        tolerance = 0.001\r\n        first = points[0]\r\n        last = points[-1]\r\n        if abs(first[0] - last[0]) < tolerance and abs(first[1] - last[1]) < tolerance:\r\n            is_closed = True\r\n    \r\n    points_str = \" \".join([\"{},{}\".format(x, y) for x, y in points])\r\n    element_type = \"polygon\" if is_closed else \"polyline\"\r\n    \r\n    attrs = [\r\n        'points=\"{}\"'.format(points_str),\r\n        'fill=\"{}\"'.format(fill),\r\n        'stroke=\"{}\"'.format(stroke),\r\n        'stroke-width=\"{}\"'.format(stroke_width)\r\n    ]\r\n    \r\n    if dash and dash.strip():\r\n        attrs.append('stroke-dasharray=\"{}\"'.format(dash))\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    if stroke_opacity is not None and stroke_opacity < 1.0:\r\n        attrs.append('stroke-opacity=\"{:.2f}\"'.format(stroke_opacity))\r\n    \r\n    return '<{} {}/>'.format(element_type, \" \".join(attrs))\r\n\r\n\r\ndef svg_polygon(points, stroke=\"none\", fill=\"none\", stroke_width=0, dash=\"\",\r\n                fill_opacity=None, stroke_opacity=None):\r\n    \"\"\"\r\n    Generate SVG polygon element (always closed).\r\n    \r\n    Args:\r\n        points (list): List of (x, y) coordinate tuples (in SVG coordinates)\r\n        stroke (str): Stroke color (RGB hex or color name)\r\n        fill (str): Fill color (RGB hex or color name)\r\n        stroke_width (float): Stroke width\r\n        dash (str): Stroke dash pattern\r\n        fill_opacity (float, optional): Fill opacity (0.0-1.0)\r\n        stroke_opacity (float, optional): Stroke opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG polygon element\r\n    \"\"\"\r\n    if not points or len(points) < 3:\r\n        return \"\"\r\n    \r\n    points_str = \" \".join([\"{},{}\".format(x, y) for x, y in points])\r\n    \r\n    attrs = [\r\n        'points=\"{}\"'.format(points_str),\r\n        'fill=\"{}\"'.format(fill),\r\n        'stroke=\"{}\"'.format(stroke),\r\n        'stroke-width=\"{}\"'.format(stroke_width)\r\n    ]\r\n    \r\n    if dash and dash.strip():\r\n        attrs.append('stroke-dasharray=\"{}\"'.format(dash))\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    if stroke_opacity is not None and stroke_opacity < 1.0:\r\n        attrs.append('stroke-opacity=\"{:.2f}\"'.format(stroke_opacity))\r\n    \r\n    return '<polygon {}/>'.format(\" \".join(attrs))\r\n\r\n\r\ndef svg_path(path_data, stroke=\"none\", fill=\"none\", stroke_width=0, dash=\"\",\r\n             fill_opacity=None, stroke_opacity=None):\r\n    \"\"\"\r\n    Generate SVG path element string with Illustrator-compatible opacity.\r\n    \r\n    Args:\r\n        path_data (str): SVG path data (already transformed to SVG coordinates)\r\n        stroke (str): Stroke color (RGB hex or color name)\r\n        fill (str): Fill color (RGB hex or color name)\r\n        stroke_width (float): Stroke width\r\n        dash (str): Stroke dash pattern\r\n        fill_opacity (float, optional): Fill opacity (0.0-1.0)\r\n        stroke_opacity (float, optional): Stroke opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG path element\r\n    \"\"\"\r\n    if not path_data or not path_data.strip():\r\n        return \"\"\r\n    \r\n    attrs = [\r\n        'd=\"{}\"'.format(path_data),\r\n        'fill=\"{}\"'.format(fill),\r\n        'stroke=\"{}\"'.format(stroke),\r\n        'stroke-width=\"{}\"'.format(stroke_width)\r\n    ]\r\n    \r\n    if dash and dash.strip():\r\n        attrs.append('stroke-dasharray=\"{}\"'.format(dash))\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    if stroke_opacity is not None and stroke_opacity < 1.0:\r\n        attrs.append('stroke-opacity=\"{:.2f}\"'.format(stroke_opacity))\r\n    \r\n    return '<path {}/>'.format(\" \".join(attrs))\r\n\r\n\r\ndef svg_text(x, y, text, font_family=\"Arial\", font_size=12, fill=\"black\",\r\n            text_anchor=\"start\", dominant_baseline=\"auto\", fill_opacity=None):\r\n    \"\"\"\r\n    Generate SVG text element with alignment and optional opacity.\r\n    \r\n    Args:\r\n        x (float): X coordinate (in SVG coordinates)\r\n        y (float): Y coordinate (in SVG coordinates)\r\n        text (str): Text content\r\n        font_family (str): Font family name\r\n        font_size (int): Font size in pixels\r\n        fill (str): Text color (RGB hex or color name)\r\n        text_anchor (str): Horizontal alignment (\"start\", \"middle\", \"end\")\r\n        dominant_baseline (str): Vertical alignment (\"auto\", \"middle\", \"hanging\")\r\n        fill_opacity (float, optional): Text opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG text element\r\n    \"\"\"\r\n    attrs = [\r\n        'x=\"{}\"'.format(x),\r\n        'y=\"{}\"'.format(y),\r\n        'font-family=\"{}\"'.format(font_family),\r\n        'font-size=\"{}px\"'.format(font_size),\r\n        'fill=\"{}\"'.format(fill),\r\n        'text-anchor=\"{}\"'.format(text_anchor),\r\n        'dominant-baseline=\"{}\"'.format(dominant_baseline)\r\n    ]\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    return '<text {}>{}</text>'.format(\" \".join(attrs), text)\r\n\r\n\r\ndef svg_rect(x, y, width, height, fill=\"black\", stroke=\"none\", stroke_width=1,\r\n             fill_opacity=None, stroke_opacity=None):\r\n    \"\"\"\r\n    Generate SVG rectangle element with optional opacity.\r\n    \r\n    Args:\r\n        x (float): Top-left X coordinate (in SVG coordinates)\r\n        y (float): Top-left Y coordinate (in SVG coordinates)\r\n        width (float): Rectangle width\r\n        height (float): Rectangle height\r\n        fill (str): Fill color (RGB hex or color name)\r\n        stroke (str): Stroke color (RGB hex or color name)\r\n        stroke_width (float): Stroke width\r\n        fill_opacity (float, optional): Fill opacity (0.0-1.0)\r\n        stroke_opacity (float, optional): Stroke opacity (0.0-1.0)\r\n    \r\n    Returns:\r\n        str: SVG rectangle element\r\n    \"\"\"\r\n    attrs = [\r\n        'x=\"{}\"'.format(x),\r\n        'y=\"{}\"'.format(y),\r\n        'width=\"{}\"'.format(width),\r\n        'height=\"{}\"'.format(height),\r\n        'fill=\"{}\"'.format(fill),\r\n        'stroke=\"{}\"'.format(stroke),\r\n        'stroke-width=\"{}\"'.format(stroke_width)\r\n    ]\r\n    \r\n    if fill_opacity is not None and fill_opacity < 1.0:\r\n        attrs.append('fill-opacity=\"{:.2f}\"'.format(fill_opacity))\r\n    \r\n    if stroke_opacity is not None and stroke_opacity < 1.0:\r\n        attrs.append('stroke-opacity=\"{:.2f}\"'.format(stroke_opacity))\r\n    \r\n    return '<rect {}/>'.format(\" \".join(attrs))\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}