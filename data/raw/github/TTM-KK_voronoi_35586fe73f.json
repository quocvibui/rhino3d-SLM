{
  "source_url": "https://github.com/TTM-KK/voronoi/blob/fbd950eda81840c343df12d2c568719577652364/voronoi_module/Tetrahedron.py",
  "repo": "TTM-KK/voronoi",
  "repo_stars": 1,
  "repo_description": "voronoi & GA",
  "license": "unknown",
  "filepath": "voronoi_module/Tetrahedron.py",
  "instruction": "coding: utf-8",
  "code": "# coding: utf-8\nimport math\nimport scriptcontext\nimport Rhino\n\n\nclass Tetrahedron:\n\n    def __init__(self, p1, p2, p3, p4):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n        self.p4 = p4\n        self.radius = None\n        self.center_p = None\n\n    def cul_center_p_and_radius(self):\n        '''外接球の中心点と半径を計算'''\n\n        a = [\n            [self.p1.x, self.p1.y, self.p1.z, 1],\n            [self.p2.x, self.p2.y, self.p2.z, 1],\n            [self.p3.x, self.p3.y, self.p3.z, 1],\n            [self.p4.x, self.p4.y, self.p4.z, 1]\n        ]\n\n        d_x = [\n            [pow(self.p1.x, 2) + pow(self.p1.y, 2) + pow(self.p1.z, 2), self.p1.y, self.p1.z, 1],\n            [pow(self.p2.x, 2) + pow(self.p2.y, 2) + pow(self.p2.z, 2), self.p2.y, self.p2.z, 1],\n            [pow(self.p3.x, 2) + pow(self.p3.y, 2) + pow(self.p3.z, 2), self.p3.y, self.p3.z, 1],\n            [pow(self.p4.x, 2) + pow(self.p4.y, 2) + pow(self.p4.z, 2), self.p4.y, self.p4.z, 1]\n        ]\n\n        d_y = [\n            [pow(self.p1.x, 2) + pow(self.p1.y, 2) + pow(self.p1.z, 2), self.p1.x, self.p1.z, 1],\n            [pow(self.p2.x, 2) + pow(self.p2.y, 2) + pow(self.p2.z, 2), self.p2.x, self.p2.z, 1],\n            [pow(self.p3.x, 2) + pow(self.p3.y, 2) + pow(self.p3.z, 2), self.p3.x, self.p3.z, 1],\n            [pow(self.p4.x, 2) + pow(self.p4.y, 2) + pow(self.p4.z, 2), self.p4.x, self.p4.z, 1]\n        ]\n\n        d_z = [\n            [pow(self.p1.x, 2) + pow(self.p1.y, 2) + pow(self.p1.z, 2), self.p1.x, self.p1.y, 1],\n            [pow(self.p2.x, 2) + pow(self.p2.y, 2) + pow(self.p2.z, 2), self.p2.x, self.p2.y, 1],\n            [pow(self.p3.x, 2) + pow(self.p3.y, 2) + pow(self.p3.z, 2), self.p3.x, self.p3.y, 1],\n            [pow(self.p4.x, 2) + pow(self.p4.y, 2) + pow(self.p4.z, 2), self.p4.x, self.p4.y, 1]\n        ]\n\n        a = dit_4(a)\n        d_x = dit_4(d_x)\n        d_y = -(dit_4(d_y))\n        d_z = dit_4(d_z)\n\n        center_p_x = d_x / (2 * a)\n        center_p_y = d_y / (2 * a)\n        center_p_z = d_z / (2 * a)\n\n        self.center_p = [float(center_p_x), float(center_p_y), float(center_p_z)]\n\n        distance = math.sqrt(\n            pow((self.p1.x - self.center_p[0]), 2) + pow((self.p1.y - self.center_p[1]), 2) + pow((self.p1.z - self.center_p[2]), 2))\n\n        self.radius = float(distance)\n\n    def draw_divide_tetrahedron(self):\n        '''分割四面体をRhinoに描画するためのメソッド'''\n        line1 = Rhino.Geometry.Line(self.p1.x, self.p1.y, self.p1.z, self.p2.x, self.p2.y, self.p2.z)\n        line2 = Rhino.Geometry.Line(self.p1.x, self.p1.y, self.p1.z, self.p3.x, self.p3.y, self.p3.z)\n        line3 = Rhino.Geometry.Line(self.p1.x, self.p1.y, self.p1.z, self.p4.x, self.p4.y, self.p4.z)\n        line4 = Rhino.Geometry.Line(self.p2.x, self.p2.y, self.p2.z, self.p3.x, self.p3.y, self.p3.z)\n        line5 = Rhino.Geometry.Line(self.p2.x, self.p2.y, self.p2.z, self.p4.x, self.p4.y, self.p4.z)\n        line6 = Rhino.Geometry.Line(self.p3.x, self.p3.y, self.p3.z, self.p4.x, self.p4.y, self.p4.z)\n\n        scriptcontext.doc.Objects.AddLine(line1)\n        scriptcontext.doc.Objects.AddLine(line2)\n        scriptcontext.doc.Objects.AddLine(line3)\n        scriptcontext.doc.Objects.AddLine(line4)\n        scriptcontext.doc.Objects.AddLine(line5)\n        scriptcontext.doc.Objects.AddLine(line6)\n\n    def check_point_include_circumsphere(self, check_p):\n        '''外接球に任意の点が内包されているかどうか判定'''\n\n        distance = math.sqrt(pow((check_p.x - self.center_p[0]), 2) + pow(\n            (check_p.y - self.center_p[1]), 2) + pow((check_p.z - self.center_p[2]), 2))\n\n        if distance < self.radius:\n            return True\n        else:\n            return False\n\n\ndef dit_2(dit):\n    '''二次元行列の計算'''\n    cul = (dit[0][0] * dit[1][1]) - (dit[0][1] * dit[1][0])\n\n    return cul\n\n\ndef dit_3(dit):\n    '''三次行列の計算'''\n    a = [\n        [dit[1][1], dit[1][2]],\n        [dit[2][1], dit[2][2]]\n    ]\n\n    b = [\n        [dit[0][1], dit[0][2]],\n        [dit[2][1], dit[2][2]]\n    ]\n\n    c = [\n        [dit[0][1], dit[0][2]],\n        [dit[1][1], dit[1][2]]\n    ]\n\n    cul = (dit[0][0] * dit_2(a)) - (dit[1][0] * dit_2(b)) + (dit[2][0] * dit_2(c))\n\n    return cul\n\n\ndef dit_4(dit):\n    '''4次元の行列'''\n    a = [\n        [dit[1][1], dit[1][2], dit[1][3]],\n        [dit[2][1], dit[2][2], dit[2][3]],\n        [dit[3][1], dit[3][2], dit[3][3]]\n    ]\n\n    b = [\n        [dit[0][1], dit[0][2], dit[0][3]],\n        [dit[2][1], dit[2][2], dit[2][3]],\n        [dit[3][1], dit[3][2], dit[3][3]]\n    ]\n\n    c = [\n        [dit[0][1], dit[0][2], dit[0][3]],\n        [dit[1][1], dit[1][2], dit[1][3]],\n        [dit[3][1], dit[3][2], dit[3][3]]\n    ]\n\n    d = [\n        [dit[0][1], dit[0][2], dit[0][3]],\n        [dit[1][1], dit[1][2], dit[1][3]],\n        [dit[2][1], dit[2][2], dit[2][3]]\n    ]\n\n    cul = (dit[0][0] * dit_3(a)) - (dit[1][0] * dit_3(b)) + (dit[2][0] * dit_3(c)) - (dit[3][0] * dit_3(d))\n\n    return cul\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}