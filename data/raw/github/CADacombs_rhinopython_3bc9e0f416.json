{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_RebuildCrvNonUniform.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_RebuildCrvNonUniform.py",
  "instruction": "This script uses the UI's _RebuildCrvNonUniform since an equivalent method is\r\nnot available in RhinoCommon as least up through 8.2.\r\n\r\n_RebuildCrvNonUniform only returns degree-3 NURBS...",
  "code": "\"\"\"\r\nThis script uses the UI's _RebuildCrvNonUniform since an equivalent method is\r\nnot available in RhinoCommon as least up through 8.2.\r\n\r\n_RebuildCrvNonUniform only returns degree-3 NURBS curves.\r\n\r\nReasons why this script was created\r\n1.  _RebuildCrvNonUniform complies with the MaxPointCount option at the expense \r\n    of the RequestedTolerance option.  This script outputs curves only within the \r\n    requested tolerance / curve deviation.\r\n2.  _RebuildCrvNonUniform works best on one curve at a time since it applies the \r\n    same number of control points to all input curves when multiple curves are \r\n    selected.  This script applies _RebuildCrvNonUniform to one curve at a time.\r\n3.  Deviation reported by _RebuildCrvNonUniform has been found to be erroneous\r\n    as compared to _CrvDeviation.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n170807-08: Created.\r\n...\r\n240105: Refactored. Now, skips uniform curve input. Changed an option.\r\n        Added span count to printed report.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iMaxPointCount'; keys.append(key)\r\n    values[key] = 103\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=5)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iPolyCrv_Opp'; keys.append(key)\r\n    listValues[key] = 'No', 'InWhole' #, 'PerCrv' # All items must be strings.\r\n    values[key] = 1\r\n    names[key] = 'PolyCrv'\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            print(\"Why is key, {}, here?  Value was not set or sticky-saved.\".format(key))\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve wires with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    #go.EnableHighlight(False)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('fDevTol')\r\n        addOption('iMaxPointCount')\r\n        addOption('iPolyCrv_Opp')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDevTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    elif fDistance == 0.0:\r\n        return \"exactly 0\".format(fDistance)\r\n    elif fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-2)):\r\n        return \"{:.1e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef processNurbsCurve(nc, fDevTol, iMaxPointCount, bDebug=False):\r\n    \"\"\"\r\n    Returns on success: rg.NurbsCurve, float(deviation)\r\n    Returns on fail: None, str(log)\r\n    \"\"\"\r\n    \r\n    nc_In = nc\r\n    \r\n    if not isinstance(nc_In, rg.NurbsCurve):\r\n        return None, \"{} not processed.\".format(nc_In.GetType().Name)\r\n\r\n    if nc_In.SpanCount == 1:\r\n        return None, \"Bezier curve skipped.\".format(nc_In.GetType().Name)\r\n\r\n    if nc_In.Knots.KnotStyle in (rg.KnotStyle.Uniform, rg.KnotStyle.QuasiUniform):\r\n        return None, \"Uniform NURBS curve skipped.\".format(nc_In.GetType().Name)\r\n\r\n    fTol_WIP = fDevTol\r\n\r\n    fDev_Min = None\r\n\r\n    while fTol_WIP >= 1e-6:\r\n        sc.escape_test()\r\n\r\n        if bDebug:\r\n            print('-'*80)\r\n            sEval = \"fTol_WIP\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        gC_Out = sc.doc.Objects.AddCurve(nc_In)\r\n        if gC_Out == gC_Out.Empty:\r\n            return None, \"Could not add starting curve to document.\"\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n    \r\n        if not sc.doc.Objects.Select(objectId=gC_Out, select=True):\r\n            raise ValueError(\"Could not select WIP curve.\")\r\n    \r\n        sCmd  = \"_-RebuildCrvNonUniform \"\r\n        sCmd += \"_RequestedTolerance={} \".format(fTol_WIP)\r\n        sCmd += \"_MaxPointCount={} \".format(iMaxPointCount)\r\n        sCmd += \"_Quarters=No \"\r\n        sCmd += \"_DeleteInput=Yes \"\r\n        sCmd += \"_EnterEnd\"\r\n\r\n        sc.doc.UndoRecordingEnabled = False\r\n\r\n        Rhino.RhinoApp.RunScript(script=sCmd, echo=bDebug)\r\n\r\n        rdC_Out = sc.doc.Objects.FindId(gC_Out)\r\n        nc_Out = rdC_Out.Geometry\r\n\r\n        sc.doc.Objects.Delete(objectId=gC_Out, quiet=False)\r\n\r\n        sc.doc.UndoRecordingEnabled = True\r\n\r\n        bEqual = nc_Out.EpsilonEquals(other=nc_In, epsilon=Rhino.RhinoMath.ZeroTolerance)\r\n\r\n        if bEqual:\r\n            return None, \"Input and output are identical.\"\r\n\r\n        rc = rg.Curve.GetDistancesBetweenCurves(\r\n            nc_In, nc_Out, 0.1*min((fDevTol, sc.doc.ModelAbsoluteTolerance)))\r\n\r\n        if bDebug:\r\n            sPrint = 'nc_Out.Points.Count'; print(sPrint + ':', eval(sPrint))\r\n            sPrint = 'nc_Out.Degree'; print(sPrint + ':', eval(sPrint))\r\n    \r\n        if not rc[0]:\r\n            return None, \"Curve deviation could not be determined.\"\r\n\r\n        fDev = rc[1]\r\n\r\n        if bDebug:\r\n            sPrint = 'fDev'; print(sPrint + ':', eval(sPrint))\r\n\r\n        if fDev <= fDevTol:\r\n            return nc_Out, fDev\r\n\r\n        if fDev_Min is None:\r\n            fDev_Min = fDev\r\n        else:\r\n            if fDev > fDev_Min:\r\n                if bDebug: print(\"Deviation started to increase.\")\r\n                break\r\n\r\n        fTol_WIP /= 2.0\r\n\r\n\r\n    return None, \"Curve could not be rebuilt within tolerance.\"\r\n\r\n\r\n\r\ndef processCurveObjects(objrefs_In, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    iMaxPointCount = getOpt('iMaxPointCount')\r\n    iPolyCrv_Opp = getOpt('iPolyCrv_Opp')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    gCs_Out = []\r\n    sLogs = []\r\n\r\n\r\n    def isKnotVectorUniform(knots):\r\n        return (\r\n            (knots.KnotStyle == rg.KnotStyle.Uniform) or\r\n            (knots.KnotStyle == rg.KnotStyle.QuasiUniform) or\r\n            (\r\n                (knots.KnotStyle == rg.KnotStyle.PiecewiseBezier) and\r\n                knots.Count == knots.KnotMultiplicity(0) * 2)\r\n            )\r\n\r\n\r\n    for objref_In in objrefs_In:\r\n        rdObj_In = objref_In.Object()\r\n\r\n        rgC_In = objref_In.Curve()\r\n        if rgC_In is None:\r\n            sLogs.append(\"{} skipped.\".format(rdObj_In.ObjectType.Name))\r\n            continue # to next object.\r\n\r\n        if isinstance(rgC_In, rg.PolyCurve):\r\n            if iPolyCrv_Opp == 0:\r\n                sLogs.append(\"PolyCurve skipped.\")\r\n                continue # to next curve.\r\n            elif iPolyCrv_Opp == 1:\r\n                nc_In = rgC_In.ToNurbsCurve()\r\n            else:\r\n                # TODO:\r\n                sLogs.append(\"Processing subcurves of PolyCurves is not yet supported.\")\r\n                continue # to next curve.\r\n        else:\r\n            nc_In = rgC_In.ToNurbsCurve() # Regardless if rgC_In is already a NurbsCurve since it needs to be duplicated anyway.\r\n\r\n        rc = processNurbsCurve(\r\n            nc=nc_In,\r\n            fDevTol=fDevTol,\r\n            iMaxPointCount=iMaxPointCount,\r\n            bDebug=bDebug)\r\n\r\n        if rc[0] is None:\r\n            sLogs.append(rc[1])\r\n            continue\r\n\r\n        nc_Ret, fDev = rc\r\n\r\n        if bReplace and rdObj_In.ObjectType == rd.ObjectType.Curve:\r\n            if not sc.doc.Objects.Replace(rdObj_In.Id, nc_Ret):\r\n                raise ValueError(\"Curve could not be replaced!\")\r\n            gCs_Out.append(rdObj_In.Id)\r\n        else:\r\n            # This includes objrefs of Edges.\r\n            gC_Out = sc.doc.Objects.AddCurve(nc_Ret)\r\n            if gC_Out == gC_Out.Empty:\r\n                raise ValueError(\"Curve could not be added!\")\r\n            gCs_Out.append(gC_Out)\r\n        \r\n        if len(objrefs_In) == 1:\r\n            s = \"Prop:I->O\"\r\n            s += \"  {}:{}->{}\".format(\"PtCt\", nc_In.Points.Count, nc_Ret.Points.Count)\r\n            s += \"  {}:{}->{}\".format(\"SpanCt\", nc_In.SpanCount, nc_Ret.SpanCount)\r\n            if Rhino.RhinoApp.ExeVersion >= 7:\r\n                s += \"  {}:{}->{}\".format(\"IsUniform\",\r\n                        str(isKnotVectorUniform(nc_In.Knots))[0],\r\n                        str(isKnotVectorUniform(nc_Ret.Knots))[0])\r\n            s += \"  {}:{}->{}\".format(\"IsPeriodic\",\r\n                    str(nc_In.IsPeriodic)[0],\r\n                    str(nc_Ret.IsPeriodic)[0])\r\n            s += \"\\nDeviation: {}\".format(formatDistance(fDev))\r\n\r\n            print(s)\r\n\r\n        nc_In.Dispose()\r\n        nc_Ret.Dispose()\r\n\r\n    if sLogs and len(objrefs_In) == 1:\r\n        print(sLogs[0])\r\n    else:\r\n        for sLog in set(sLogs):\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n    \r\n    if len(objrefs_In) > 1:\r\n        print(\"{} curves were successfully processed.\".format(len(gCs_Out)))\r\n\r\n    return gCs_Out\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_In = getInput()\r\n    if objrefs_In is None: return\r\n\r\n    fDevTol = Opts.values['fDevTol']\r\n    iMaxPointCount = Opts.values['iMaxPointCount']\r\n    iPolyCrv_Opp = Opts.values['iPolyCrv_Opp']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    processCurveObjects(\r\n        objrefs_In,\r\n        fDevTol=fDevTol,\r\n        iMaxPointCount=iMaxPointCount,\r\n        iPolyCrv_Opp=iPolyCrv_Opp,\r\n        bReplace=bReplace,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}