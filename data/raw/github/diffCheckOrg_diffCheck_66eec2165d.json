{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/components/DF_icp_registration/code.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/components/DF_icp_registration/code.py",
  "instruction": null,
  "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\n\nclass DFICPRegistration(component):\n    def RunScript(self,\n            i_use_generalized_icp: bool,\n            i_cloud_source: Rhino.Geometry.PointCloud,\n            i_cloud_target: Rhino.Geometry.PointCloud,\n            i_max_corrspondence_dist: float,\n            i_max_iteration: int,\n            is_t_estimate_pt2pt: bool,\n            i_use_point_to_plane: bool) -> Rhino.Geometry.Transform:\n        if i_cloud_source is None or i_cloud_target is None:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Please provide both objects of type point clouds to align\")  # noqa: F821\n            return None\n        if not i_cloud_source.ContainsNormals or not i_cloud_target.ContainsNormals:\n            ghenv.Component.AddRuntimeMessage(RML.Error, \"Please compute cloud's normals with a component before\")  # noqa: F821\n\n        # set default values\n        if i_use_generalized_icp is None:\n            i_use_generalized_icp = True\n        if i_max_corrspondence_dist is None:\n            i_max_corrspondence_dist = 5\n        if i_max_iteration is None:\n            i_max_iteration = 50\n\n        # conversion\n        df_cloud_source = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_source)\n        df_cloud_target = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud_target)\n\n        # fast registration\n        # these are the only hardcoded values since it will get the best result\n        RELATIVE_FITNESS = 1e-6\n        RELATIVE_RMSE = 1e-6\n\n        df_xform = None\n        if i_use_generalized_icp:\n            df_xform = diffcheck_bindings.dfb_registrations.DFRefinedRegistration.O3DGeneralizedICP(\n                source=df_cloud_source,\n                target=df_cloud_target,\n                max_correspondence_distance=i_max_corrspondence_dist,\n                max_iteration=i_max_iteration,\n                relative_fitness=RELATIVE_FITNESS,\n                relative_rmse=RELATIVE_RMSE\n            )\n        else:\n            df_xform = diffcheck_bindings.dfb_registrations.DFRefinedRegistration.O3DICP(\n                source=df_cloud_source,\n                target=df_cloud_target,\n                max_correspondence_distance=i_max_corrspondence_dist,\n                is_t_estimate_pt2pt=is_t_estimate_pt2pt,\n                relative_fitness=RELATIVE_FITNESS,\n                relative_rmse=RELATIVE_RMSE,\n                max_iteration=i_max_iteration,\n                use_point_to_plane=i_use_point_to_plane\n            )\n        print(\"-------------------\")\n        print(\"Estimated transformation matrix:\")\n        print(df_xform.transformation_matrix)\n        print(\"-------------------\")\n\n        # cvt df xform to rhino xform\n        df_xform_matrix = df_xform.transformation_matrix\n        rh_form = Rhino.Geometry.Transform()\n        for i in range(4):\n            for j in range(4):\n                rh_form[i, j] = df_xform_matrix[i, j]\n        if rh_form == Rhino.Geometry.Transform.Identity:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"The transformation matrix is identity, no transformation is applied\")  # noqa: F821\n            return None\n\n        o_x_form = rh_form\n\n        return o_x_form\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}