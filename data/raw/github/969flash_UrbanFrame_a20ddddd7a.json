{
  "source_url": "https://github.com/969flash/UrbanFrame/blob/0f253b7a73233f7217608b7815c1a99f71e14f35/units.py",
  "repo": "969flash/UrbanFrame",
  "repo_stars": 0,
  "repo_description": "Generate Urban Frame",
  "license": "unknown",
  "filepath": "units.py",
  "instruction": null,
  "code": "try:\n    from typing import List, Tuple\nexcept ImportError:\n    pass\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport utils\nimport importlib\nimport networkx as nx\nimport scriptcontext as sc\n\nimportlib.reload(utils)\nTOL = 5\nNODE_TOL = 0.5\n\n\nclass Edge:\n    def __init__(self, curve: geo.Curve, width: float):\n        self.curve = curve  # type: geo.Curve\n        self.width = width  # type: float\n\n    def is_at(self, node: \"Node\") -> bool:\n        return node == self.curve.PointAtStart or node == self.curve.PointAtEnd\n\n\nclass Node:\n    def __init__(self, point: geo.Point3d):\n        self.point = point\n        self.edges = []  # type: List[Edge]\n\n    def add_edges(self, edges: List[Edge]) -> None:\n        self.edges.extend(edges)\n\n    @staticmethod\n    def point_to_key(p: geo.Point3d):\n        \"\"\"Public: Quantize a point to TOL-sized grid for stable equality/hash.\"\"\"\n        q = TOL\n        return (\n            int(round(p.X / q)),\n            int(round(p.Y / q)),\n            int(round(p.Z / q)),\n        )\n\n    def __eq__(self, other):\n        # Allow positional tolerance of NODE_TOL\n        if isinstance(other, Node):\n            return self.point.DistanceTo(other.point) <= NODE_TOL\n        if isinstance(other, geo.Point3d):\n            return self.point.DistanceTo(other) <= NODE_TOL\n        return NotImplemented\n\n    def __hash__(self):\n        # Hash derived from the same quantized key used in __eq__\n        return hash(Node.point_to_key(self.point))\n\n\nclass Road:\n    def __init__(self, region: geo.Curve, edge: Edge):\n        self.region = region\n        self.edge = edge\n\n\nclass Junction:\n    def __init__(self, region, node: Node):\n        self.region = region\n        self.node = node\n        self.connected_roads = []  # type: List[Road]\n\n\nclass RoadNetwork:\n    def __init__(\n        self,\n        roads: List[Road],\n        junctions: List[Junction],\n        nodes: List[Node],\n        edges: List[Edge],\n    ):\n        self.nodes = nodes\n        self.edges = edges\n        self.roads = roads\n        self.junctions = junctions\n\n        self.graph = self._get_graph()\n\n    def _get_graph(self):\n        G = nx.Graph()\n\n        # TOL 기반 좌표 양자화 키: Node.point_to_key / Node.point_key 재사용\n        key = Node.point_to_key\n        nodes_by_key = {key(n.point): n for n in self.nodes}\n\n        # 노드 추가 + 속성\n        for n in self.nodes:\n            G.add_node(n, point=n.point, degree=len(n.edges))\n\n        # 엣지 추가: 키 매핑 + 안전한 fallback\n        for e in self.edges:\n            n1 = nodes_by_key.get(key(e.curve.PointAtStart))\n            n2 = nodes_by_key.get(key(e.curve.PointAtEnd))\n            if not n1:\n                n1 = next((n for n in self.nodes if n == e.curve.PointAtStart), None)\n            if not n2:\n                n2 = next((n for n in self.nodes if n == e.curve.PointAtEnd), None)\n            if not n1 or not n2:\n                continue\n            G.add_edge(\n                n1,\n                n2,\n                object=e,\n                width=getattr(e, \"width\", None),\n                length=e.curve.GetLength() if e.curve else None,\n                curve=e.curve,\n            )\n        return G\n\n\nclass BlockInfo:\n    \"\"\"Configuration holder for initializing Block objects.\n\n    Attributes:\n        block_ids: List of target block ids this config applies to.\n        gfa: Floor area ratio (용적률).\n        bcr: Building coverage ratio (건폐율).\n        landuses: List of landuse labels.\n        pedestrian_width: Width of pedestrian zone (m).\n    \"\"\"\n\n    def __init__(\n        self,\n        block_ids,  # type: List[int]\n        gfa=None,  # type: float\n        bcr=None,  # type: float\n        landuses=None,  # type: List[str]\n        pedestrian_width=None,  # type: float\n    ):\n        self.block_ids = block_ids\n        self.gfa = gfa\n        self.bcr = bcr\n        self.landuses = landuses\n        self.pedestrian_width = pedestrian_width\n\n\nclass Block:\n    def __init__(self, region: geo.Curve, block_id: int = None):\n        self.block_id = block_id\n        self.region = region\n        self.buildable_region = region  # type: geo.Curve\n        self.roads = []  # type: List[Road]\n        self.junctions = []  # type: List[Junction]\n\n        # landuse/building defaults\n        self.landuses = []  # type: List[str]\n        self.gfa = 0.0  # 용적률\n        self.bcr = 0.0  # 건폐율\n        self.pedestrian_width = 0.0\n\n        # placeholders for downstream\n        self.pedestrian = []  # type: List[geo.Surface]\n        self.buildings = []  # type: List[Building]\n\n    def initialize(self, block_info: BlockInfo):\n        \"\"\"block_info의 설정으로 블록 초기화.\"\"\"\n        # gfa and bcr\n        self.gfa = block_info.gfa\n        self.bcr = block_info.bcr\n\n        # landuses\n        self.landuses = block_info.landuses\n\n        # pedestrian width\n        self.pedestrian_width = block_info.pedestrian_width\n\n        self.buildable_region = utils.offset_regions_inward(\n            self.region, self.pedestrian_width\n        )[0]\n\n        self.pedestrian = ghcomp.BoundarySurfaces([self.buildable_region, self.region])\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}