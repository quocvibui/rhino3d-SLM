{
  "source_url": "https://github.com/Payette/SkinDesigner/blob/f53b5e9262a1e7a3da19c58d90c773e7cdb953d6/src/SkinDesigner_Data_Pattern2.py",
  "repo": "Payette/SkinDesigner",
  "repo_stars": 9,
  "repo_description": "SkinDesigner facade panelization tool for Grasshopper",
  "license": "GPL-3.0",
  "filepath": "src/SkinDesigner_Data_Pattern2.py",
  "instruction": "Use this component to apply a specific pattern panel layout algorithm to a Design Function. \nDattaPattern2 places each pattern on different rows: pattern_1 will be used on the 1st row of the facade,...",
  "code": "# SkinDesigner: A Plugin for Building Skin Design (GPL) started by Santiago Garay\n\n# This file is part of SkinDesigner.\n# \n# Copyright (c) 2017, Santiago Garay <sgaray1970@gmail.com> \n# SkinDesigner is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# SkinDesigner is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with SkinDesigner; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n# Data_Pattern2\n\"\"\"\nUse this component to apply a specific pattern panel layout algorithm to a Design Function. \nDattaPattern2 places each pattern on different rows: pattern_1 will be used on the 1st row of the facade, pattern_2 on the second, etc., repeating the sequence of patterns to complete all the rows if neccesary.\n\n    Args:\n        pattern_1: (pattern_2, etc.) A list of integers represetning the the sequence of panel bay IDs to be used in the pattern algorithm.\n                    Addtitional patterns can be aded with the '+' sign to be used on the subsequent levels.\n   Returns:\n        dataFunction: A DataFunction object that inputs into a Design Function component.\n\n\"\"\"\n\nghenv.Component.Name = \"SkinDesigner_Data_Pattern2\"\nghenv.Component.NickName = 'Data_Pattern2'\nghenv.Component.Message = 'VER 0.1.16\\nSep_22_2017'\nghenv.Component.Category = \"SkinDesigner\"\nghenv.Component.SubCategory = \"03 | Functions\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\n# automnatically set the right input names and types (when using + icon) \nimport Grasshopper.Kernel as gh\nimport GhPython\nimport scriptcontext as sc\n\nnumInputs = ghenv.Component.Params.Input.Count\naccessList = ghenv.Component.Params.Input[0].Access.list\ntypeInt = gh.Parameters.Hints.GH_IntegerHint_CS()\n\n\nfor input in range(numInputs):\n    access = accessList\n    inputName = 'pattern_' + str(input+1)\n\n    ghenv.Component.Params.Input[input].NickName = inputName\n    ghenv.Component.Params.Input[input].Name = inputName\n    ghenv.Component.Params.Input[input].Access = accessList\n    ghenv.Component.Params.Input[input].TypeHint = typeInt\n    \nghenv.Component.Attributes.Owner.OnPingDocument()\n\nimport Grasshopper.Kernel as gh\n#import rhinoscriptsyntax as rs\n#import Rhino\n#import scriptcontext as sc\nfrom types import *\nimport random\nimport copy\nimport math\n\n\n\nclass LayoutDataFunction:\n    \n    __m_patterns = []\n    __m_Skip_X = 0\n    __m_Skip_Y = 0\n    warningData = []\n    #CONSTRUCTOR -------------------------------------------------------------------------------------------\n    def __init__(self):\n        \n        self.__m_Skip_X= 0\n        self.__m_Skip_Y= 0\n        \n        for input in range(numInputs):\n            list = eval('pattern_'+str(input+1))\n            if list <> []: self.__m_patterns.append(list)\n        if self.__m_patterns <> []:\n            if  len(self.__m_patterns) > 1:\n                    newLength = 1\n                    for list in self.__m_patterns : newLength *= len(list)\n                    newPattern = []\n                    for entry in range(newLength):\n                        for list in self.__m_patterns:\n                            index = int(math.fmod(entry,len(list)))\n                            newPattern.append(list[index])\n                            \n                    self.__m_Skip_X = len(self.__m_patterns)-1\n                    self.__m_Skip_Y= 1\n                    self.__m_patterns = newPattern\n            else: self.__m_patterns = self.__m_patterns[0]\n        else:\n            self.warningData.append(\"Provide at least one pattern\") \n        print \"Compiled pattern=\"+ str(self.__m_patterns)\n        print \"SkipX=\" + str(self.__m_Skip_X)\n        print \"SkipY=\"+ str(self.__m_Skip_Y)\n            \n    def GetParameter(self, strParam):\n        \n        return None   \n        \n    #Selection of panel bay based on pattern/panel location\n    def Run(self, PanelBay_List, pattern, level, inLevelIndex, defaultBayList, randomObj, bayIndex, panelPlane) :\n        \n        if pattern == []:\n            if  self.__m_patterns<>[]: pattern =  self.__m_patterns\n            else: pattern = range(1,len(PanelBay_List)+1)\n        \n        skipX = self.__m_Skip_X; skipY = self.__m_Skip_Y\n        \n        #bayList = copy.deepcopy(defaultBayList)\n        bayList = pattern\n        skipX+=1\n        levelPair = math.modf(level/len(bayList)) # relationship between floor number and bay number\n        levelShift = (level - levelPair[1] * len(bayList)) * skipY # number of shifts based on current level\n        newInLevelIndex = inLevelIndex * skipX + levelShift\n        floorPair = math.modf(newInLevelIndex/len(bayList)) # curent index in list based on bay location\n        defBayIndex = newInLevelIndex - floorPair[1]*len(bayList)\n        bayIndex  = bayList[int(defBayIndex)]-1\n\n        return bayIndex\n        \n        \n\n            \n        \n\n\n\ndataFunctionL = LayoutDataFunction()\nif dataFunctionL.warningData <> []: \n    for warning in dataFunctionL.warningData: ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, str(warning))\n\nprint \"Done\"\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}