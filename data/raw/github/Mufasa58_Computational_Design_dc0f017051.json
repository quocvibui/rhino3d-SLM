{
  "source_url": "https://github.com/Mufasa58/Computational_Design/blob/9a751b01687073e7aa4b4314128501cb7ddb6225/bismuth_pattern.py",
  "repo": "Mufasa58/Computational_Design",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "bismuth_pattern.py",
  "instruction": "Bismuth pattern",
  "code": "import Rhino.Geometry as rg\nimport math\nimport random\n\n\n\n# --- 2. THE REUSABLE FUNCTION ---\ndef grow_three_segments(start_pt, start_dir, length, shrink_factor, is_clockwise):\n    lines = []\n    curr_pos = start_pt\n    curr_dir = rg.Vector3d(start_dir)\n    curr_len = length\n    \n    # Toggle rotation: -90 for CW, +90 for CCW\n    angle = -math.pi / 2 if is_clockwise else math.pi / 2 \n    \n    for i in range(9):\n        curr_len *= shrink_factor\n        curr_dir.Rotate(angle, rg.Vector3d.ZAxis)\n        \n        new_p = curr_pos + (curr_dir * curr_len)\n        lines.append(rg.Line(curr_pos, new_p))\n       \n        curr_pos = new_p\n    #    if distance(curr_pos, new_p) >\n    #        angle = -math.pi / 2 if is_clockwise else math.pi / 2\n        \n    return lines\n\ndef run():\n        \n       import Rhino.Geometry as rg\nimport random\nimport math\n\n# ------------------------------------------------------------\n# Inputs expected (make GH inputs with these names):\n# S (Point or list[Point]), cell (float), steps (int),\n# vertical_every (int), branch_p (float),\n# min_dist (int), seed (int),\n# size_jitter (float), age_penalty (float),\n# nutrient_init (float), nutrient_consume (float), nutrient_diffuse (float)\n# Outputs: B, P, L\n# ------------------------------------------------------------\n\n# ---------- input hygiene ----------\ndef as_points(x):\n    if x is None: return []\n    if isinstance(x, list) or isinstance(x, tuple): return list(x)\n    return [x]\n\nS = as_points(S)\n\nif not S:\n    # default seed\n    S = [rg.Point3d(0,0,0)]\n\ncell = float(cell) if cell else 1.0\nsteps = int(steps) if steps else 3000\nvertical_every = max(1, int(vertical_every) if vertical_every else 4)\nbranch_p = float(branch_p) if branch_p is not None else 0.22\nmin_dist = int(min_dist) if min_dist is not None else 1\nseed = int(seed) if seed is not None else 1\nsize_jitter = float(size_jitter) if size_jitter is not None else 0.15\nage_penalty = float(age_penalty) if age_penalty is not None else 0.015\nnutrient_init = float(nutrient_init) if nutrient_init is not None else 1.0\nnutrient_consume = float(nutrient_consume) if nutrient_consume is not None else 0.08\nnutrient_diffuse = float(nutrient_diffuse) if nutrient_diffuse is not None else 0.06\n\nrandom.seed(seed)\n\n# ---------- grid utils ----------\ndef to_grid(pt):\n    # snap world point to integer cell coords\n    return (int(round(pt.X / cell)), int(round(pt.Y / cell)), int(round(pt.Z / cell)))\n\ndef to_world(g):\n    return rg.Point3d(g[0]*cell, g[1]*cell, g[2]*cell)\n\n# 6-neighborhood\nDIRS = [\n    ( 1, 0, 0),\n    (-1, 0, 0),\n    ( 0, 1, 0),\n    ( 0,-1, 0),\n    ( 0, 0, 1),\n    ( 0, 0,-1),\n]\n\n# anisotropic base weights (tune these)\nBASE_W = {\n    ( 1, 0, 0): 0.36,\n    ( 0, 1, 0): 0.26,\n    ( 0, 0, 1): 0.18,\n    (-1, 0, 0): 0.10,\n    ( 0,-1, 0): 0.07,\n    ( 0, 0,-1): 0.03,\n}\n\ndef weighted_choice(items, weights):\n    s = sum(weights)\n    if s <= 1e-12:\n        return None\n    r = random.random() * s\n    acc = 0.0\n    for it, w in zip(items, weights):\n        acc += w\n        if r <= acc:\n            return it\n    return items[-1]\n\n# ---------- occupancy + neighbor inhibition ----------\nocc = set()                # occupied grid cells\nage = {}                   # cell -> age int\nnutr = {}                  # cell -> nutrient float\nparent = {}                # cell -> parent cell\nactive_front = set()       # subset of occ; candidates to grow from\n\ndef near_occupied(g, r):\n    # Chebyshev ball for speed; \"good enough\" for inhibition\n    gx,gy,gz = g\n    for dx in range(-r, r+1):\n        for dy in range(-r, r+1):\n            for dz in range(-r, r+1):\n                if (gx+dx, gy+dy, gz+dz) in occ:\n                    return True\n    return False\n\n# ---------- initialize seeds ----------\nfor pt in S:\n    g0 = to_grid(pt)\n    if g0 not in occ:\n        occ.add(g0)\n        age[g0] = 0\n        nutr[g0] = nutrient_init\n        parent[g0] = None\n        active_front.add(g0)\n\n# ---------- growth scoring ----------\ndef dir_allowed(d, step_idx):\n    # vertical lag: only allow +Z and -Z every N steps\n    if d == (0,0,1) or d == (0,0,-1):\n        return (step_idx % vertical_every) == 0\n    return True\n\ndef exposed_faces(g):\n    # a cell is a \"front\" if it has at least one empty neighbor\n    gx,gy,gz = g\n    for d in DIRS:\n        ng = (gx+d[0], gy+d[1], gz+d[2])\n        if ng not in occ:\n            return True\n    return False\n\ndef score_dir(src, d, step_idx):\n    # Weight components:\n    # - base anisotropy\n    # - nutrient at source\n    # - age penalty (older grows less)\n    # - inhibition (avoid crowding)\n    w = BASE_W.get(d, 0.0)\n\n    n = nutr.get(src, 0.0)\n    a = age.get(src, 0)\n\n    # aging reduces likelihood gradually\n    w *= max(0.0, (1.0 - a * age_penalty))\n\n    # nutrient scales growth capacity\n    w *= max(0.0, n)\n\n    # vertical lag already handled outside\n    # inhibition: penalize growth into crowded space\n    gx,gy,gz = src\n    tgt = (gx+d[0], gy+d[1], gz+d[2])\n    if tgt in occ:\n        return 0.0\n    if min_dist > 0 and near_occupied(tgt, min_dist):\n        w *= 0.12  # strong penalty, but not zero â†’ keeps terraces dense\n    return w\n\n# ---------- main loop ----------\nlinks = []  # (src_world, tgt_world)\n\nfor step_idx in range(steps):\n    if not active_front:\n        break\n\n    # pick a source from active fronts, biased by nutrient (more alive grows more)\n    fronts = list(active_front)\n    fw = [max(1e-6, nutr.get(f, 0.0)) for f in fronts]\n    src = weighted_choice(fronts, fw)\n    if src is None:\n        break\n\n    # if src isn't actually exposed anymore, drop it\n    if not exposed_faces(src):\n        if src in active_front: active_front.remove(src)\n        continue\n\n    # choose direction\n    dirs = []\n    ws = []\n    for d in DIRS:\n        if not dir_allowed(d, step_idx):\n            continue\n        dirs.append(d)\n        ws.append(score_dir(src, d, step_idx))\n\n    dsel = weighted_choice(dirs, ws)\n    if dsel is None:\n        # src is starved or blocked\n        nutr[src] = max(0.0, nutr.get(src, 0.0) - nutrient_consume*0.5)\n        if nutr[src] <= 1e-3:\n            active_front.discard(src)\n        continue\n\n    gx,gy,gz = src\n    tgt = (gx+dsel[0], gy+dsel[1], gz+dsel[2])\n\n    # place new cell\n    if tgt not in occ:\n        occ.add(tgt)\n        age[tgt] = 0\n        parent[tgt] = src\n        nutr[tgt] = nutr.get(src, nutrient_init) * 0.85  # inherit but slightly reduced\n\n        # consume nutrient at source (starvation mechanism)\n        nutr[src] = max(0.0, nutr.get(src, 0.0) - nutrient_consume)\n\n        # aging update\n        age[src] = age.get(src, 0) + 1\n\n        # diffusion: gently share nutrient to neighbors (creates terrace continuity)\n        if nutrient_diffuse > 0:\n            share = nutr[tgt] * nutrient_diffuse\n            nutr[tgt] -= share\n            # distribute to any occupied neighbors\n            neigh = []\n            for d in DIRS:\n                ng = (tgt[0]+d[0], tgt[1]+d[1], tgt[2]+d[2])\n                if ng in occ:\n                    neigh.append(ng)\n            if neigh:\n                per = share / float(len(neigh))\n                for ng in neigh:\n                    nutr[ng] = nutr.get(ng, 0.0) + per\n\n        # keep new cell active; source might remain active depending on nutrient\n        active_front.add(tgt)\n        if nutr[src] <= 1e-3:\n            active_front.discard(src)\n\n        links.append((to_world(src), to_world(tgt)))\n\n        # branching: occasionally re-activate src to sprout multiple terraces\n        if random.random() < branch_p and nutr.get(src, 0.0) > 0.15:\n            active_front.add(src)\n\n# ---------- build geometry ----------\nB = []\nP = []\nL = []\n\n# create jittered boxes for the iridescent \"stepped plate\" feel\n# IMPORTANT: still snapped to grid; jitter only changes box size slightly\nfor g in occ:\n    cpt = to_world(g)\n    P.append(cpt)\n\n    j = 1.0 + (random.random()*2.0 - 1.0) * size_jitter\n    sx = cell * j\n    sy = cell * j\n    sz = cell * j\n\n    # box aligned to world axes\n    x = rg.Interval(cpt.X - sx*0.5, cpt.X + sx*0.5)\n    y = rg.Interval(cpt.Y - sy*0.5, cpt.Y + sy*0.5)\n    z = rg.Interval(cpt.Z - sz*0.5, cpt.Z + sz*0.5)\n    box = rg.Box(rg.Plane.WorldXY, x, y, z)\n    brep = box.ToBrep()\n    if brep:\n        B.append(brep)\n\nfor a,b in links:\n    L.append(rg.Line(a,b))\n    \n    # return outputs\n    # return B, P, L\n\n\n        if __name__ == \"__main__\":\n            t = run(seed=1)\n            print(f\"terraces: {len(t)}\")\n            \n            \n         ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}