{
  "source_url": "https://github.com/gbjun7333/P_max_calculator/blob/8844e2d7a8f3bd7c387827d6a834114aa901129d/grasshopper/parking_calculator_gh.py",
  "repo": "gbjun7333/P_max_calculator",
  "repo_stars": 0,
  "repo_description": "parking capacity calculation system",
  "license": "MIT",
  "filepath": "grasshopper/parking_calculator_gh.py",
  "instruction": "P_max 주차대수 계산기 - Grasshopper Native Version",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"\nP_max 주차대수 계산기 - Grasshopper Native Version\n\n외부 패키지 없이 순수 Rhino.Geometry만 사용합니다.\nHeron 플러그인으로 Shapefile을 읽어서 입력으로 전달하세요.\n\n=== 입력 (Grasshopper 컴포넌트에서) ===\n- LotCurves: List[Curve] - 대지 경계 커브들\n- LotPNUs: List[str] - 대지 PNU 리스트\n- RoadCurves: List[Curve] - 도로 경계 커브들\n- BuildingPNUs: List[str] - 건물 PNU (대지와 매칭용)\n- BuildingA32: List[str] - 주용도\n- BuildingA33: List[str] - 상세용도\n- BuildingA39: List[int] - 기존 주차대수\n- BuildingA50: List[str] - 사용승인일 (YYYYMMDD)\n- BuildingA77: List[int] - 승강기 수\n\n=== 출력 ===\n- Results: List[str] - \"PNU,P_MAX,P_EXISTING,P_DIFF,TANDEM_MODE\" 형식\n- ResultCurves: List[Curve] - 계산된 대지들\n- ResultColors: List[Color] - P_max 기반 색상\n\"\"\"\n\nimport clr\nclr.AddReference(\"RhinoCommon\")\nimport Rhino.Geometry as rg\nfrom System.Drawing import Color\n\n# ==============================================================================\n# 상수 정의\n# ==============================================================================\nTOL = 0.0001\n\n# 건축선/인접대지경계선 (m)\nSMALL_SETBACK = 1.0\nLARGE_SETBACK = 2.0\nSMALL_ADJ_OFFSET = 0.5\nLARGE_ADJ_OFFSET = 1.5\n\n# 건축물 제약\nMIN_BUILDING_WIDTH = 4.0\nLARGE_LOT_AREA = 660.0  # ㎡\n\n# 주차 관련\nPARKING_WIDTH_OLD = 2.3  # 2019.3 이전\nPARKING_WIDTH_NEW = 2.5  # 2019.3 이후\nPARKING_DATE_THRESHOLD = \"2019-03-01\"\nPARKING_SPACE_DEPTH = 5.0\nMIN_CLUSTER_GAP = 2.5\nMAX_CLUSTER_SIZE = 5\nMAX_TANDEM_ALLOWED = 8\nELEVATOR_CORE_SIZE = 5.0\nMIN_ROAD_WIDTH_FOR_PARKING = 6.0\n\n# 필터링 키워드\nDROP_KEYWORDS = [\n    '아파트', '공장', '창고시설', '노유자시설', '자동차관련시설',\n    '경로당', '관리사무소', '주민회의실', '무인택배', '경비실',\n    '위험물', '분뇨', '쓰레기', '동물', '식물', '발전시설',\n    '교정', '군사', '방송통신'\n]\n\n\n# ==============================================================================\n# 기하학 유틸리티 (순수 Rhino.Geometry)\n# ==============================================================================\n\ndef get_area(curve):\n    \"\"\"커브의 면적 계산\"\"\"\n    if not curve or not curve.IsValid:\n        return 0.0\n    try:\n        amp = rg.AreaMassProperties.Compute(curve)\n        return amp.Area if amp else 0.0\n    except:\n        return 0.0\n\n\ndef get_curve_length(curve):\n    \"\"\"커브의 길이 계산\"\"\"\n    if not curve or not curve.IsValid:\n        return 0.0\n    try:\n        return curve.GetLength()\n    except:\n        return 0.0\n\n\ndef offset_curve_inward(curve, distance):\n    \"\"\"커브를 안쪽으로 offset (단일 커브 반환)\"\"\"\n    if not curve or not curve.IsValid or distance <= 0:\n        return None\n\n    try:\n        # Offset 방향 결정 (안쪽)\n        plane = rg.Plane.WorldXY\n        offset_curves = curve.Offset(plane, -distance, TOL, rg.CurveOffsetCornerStyle.Sharp)\n\n        if not offset_curves or len(offset_curves) == 0:\n            # 반대 방향 시도\n            offset_curves = curve.Offset(plane, distance, TOL, rg.CurveOffsetCornerStyle.Sharp)\n\n        if offset_curves and len(offset_curves) > 0:\n            # 가장 큰 면적의 커브 선택\n            best_curve = None\n            best_area = 0\n            for oc in offset_curves:\n                if oc.IsClosed:\n                    area = get_area(oc)\n                    if area > best_area:\n                        best_area = area\n                        best_curve = oc\n\n            # 원본보다 작은지 확인 (안쪽 offset)\n            if best_curve and best_area < get_area(curve):\n                return best_curve\n\n        return None\n    except:\n        return None\n\n\ndef get_bounding_box(curve):\n    \"\"\"커브의 BoundingBox 반환\"\"\"\n    if not curve:\n        return None\n    try:\n        return curve.GetBoundingBox(True)\n    except:\n        return None\n\n\ndef curves_are_adjacent(curve_a, curve_b, threshold=0.5):\n    \"\"\"두 커브가 인접한지 확인\"\"\"\n    if not curve_a or not curve_b:\n        return False\n\n    try:\n        # 최근접점 거리 계산\n        result = curve_a.ClosestPoints(curve_b)\n        if result[0]:  # success\n            pt_a, pt_b = result[1], result[2]\n            distance = pt_a.DistanceTo(pt_b)\n            return distance <= threshold\n        return False\n    except:\n        return False\n\n\ndef estimate_road_width(road_curve):\n    \"\"\"도로 폭 추정 (면적/둘레 기반)\"\"\"\n    if not road_curve:\n        return 6.0  # 기본값\n\n    try:\n        area = get_area(road_curve)\n        perimeter = get_curve_length(road_curve)\n\n        if perimeter <= 0:\n            return 6.0\n\n        width = (2.0 * area) / perimeter\n        return max(2.0, min(width, 50.0))\n    except:\n        return 6.0\n\n\n# ==============================================================================\n# 건물 필터링 로직\n# ==============================================================================\n\ndef should_drop_building(a32, a33):\n    \"\"\"건물 제외 여부 판정\"\"\"\n    a32_str = str(a32).lower() if a32 else \"\"\n    a33_str = str(a33).lower() if a33 else \"\"\n\n    for keyword in DROP_KEYWORDS:\n        if keyword in a33_str:\n            return True\n\n    if '업무시설' in a32_str and '오피스텔' not in a33_str:\n        return True\n\n    return False\n\n\ndef determine_tandem_mode(a33):\n    \"\"\"연접주차 허용 여부 결정\"\"\"\n    a33_str = str(a33) if a33 else \"\"\n\n    if '다가구' in a33_str:\n        return 'ALLOW_TANDEM'\n\n    if any(kw in a33_str for kw in ['다세대', '연립', '도시형']):\n        return 'DISALLOW_TANDEM'\n\n    return 'DISALLOW_TANDEM'\n\n\n# ==============================================================================\n# P_max 계산 로직\n# ==============================================================================\n\ndef determine_parking_width(approval_date):\n    \"\"\"사용승인일 기준 주차폭 결정\"\"\"\n    try:\n        date_str = str(approval_date) if approval_date else \"\"\n\n        if len(date_str) == 8:\n            date_str = \"{}-{}-{}\".format(date_str[:4], date_str[4:6], date_str[6:8])\n\n        if date_str < PARKING_DATE_THRESHOLD:\n            return PARKING_WIDTH_OLD\n        else:\n            return PARKING_WIDTH_NEW\n    except:\n        return PARKING_WIDTH_NEW\n\n\ndef get_buildable_region(lot_curve):\n    \"\"\"건축가능영역 계산\"\"\"\n    if not lot_curve or not lot_curve.IsValid:\n        return None\n\n    try:\n        lot_area = get_area(lot_curve)\n\n        # 면적 기준 분기\n        if lot_area < LARGE_LOT_AREA:\n            setback = SMALL_SETBACK\n            adj_offset = SMALL_ADJ_OFFSET\n        else:\n            setback = LARGE_SETBACK\n            adj_offset = LARGE_ADJ_OFFSET\n\n        # 1단계: 건축선 적용\n        region = offset_curve_inward(lot_curve, setback)\n        if not region:\n            return None\n\n        # 2단계: 인접대지경계선 추가 적용\n        region = offset_curve_inward(region, adj_offset)\n        if not region:\n            return None\n\n        # 3단계: 최소 건축물 폭 적용 (offset in-out)\n        half_width = MIN_BUILDING_WIDTH / 2.0\n        inner = offset_curve_inward(region, half_width)\n        if inner:\n            # 다시 바깥으로\n            plane = rg.Plane.WorldXY\n            outer = inner.Offset(plane, half_width, TOL, rg.CurveOffsetCornerStyle.Sharp)\n            if outer and len(outer) > 0:\n                region = outer[0]\n\n        return region\n    except:\n        return None\n\n\ndef compute_pmax(lot_curve, building_info, road_width):\n    \"\"\"\n    P_max 계산 메인 함수\n\n    Args:\n        lot_curve: 대지 경계 커브\n        building_info: dict with keys (a32, a33, a39, a50, a77, tandem_mode)\n        road_width: 접한 도로 폭 (m)\n\n    Returns:\n        dict: 계산 결과\n    \"\"\"\n    pnu = building_info.get('pnu', 'UNKNOWN')\n    tandem_mode = building_info.get('tandem_mode', 'DISALLOW_TANDEM')\n    elevator_cnt = int(building_info.get('a77', 0) or 0)\n    p_existing = int(building_info.get('a39', 0) or 0)\n    approval_date = str(building_info.get('a50', ''))\n\n    # 1. 건축가능영역 계산\n    buildable_region = get_buildable_region(lot_curve)\n\n    if not buildable_region:\n        return {\n            'pnu': pnu,\n            'p_max': 0,\n            'p_existing': p_existing,\n            'p_diff': -p_existing,\n            'tandem_mode': tandem_mode,\n            'error': 'NO_BUILDABLE_REGION'\n        }\n\n    # 2. 주차폭 결정\n    parking_width = determine_parking_width(approval_date)\n\n    # 3. BoundingBox로 접도길이/깊이 추정\n    bbox = get_bounding_box(buildable_region)\n    if not bbox:\n        return {\n            'pnu': pnu,\n            'p_max': 0,\n            'p_existing': p_existing,\n            'p_diff': -p_existing,\n            'tandem_mode': tandem_mode,\n            'error': 'NO_BBOX'\n        }\n\n    width = bbox.Max.X - bbox.Min.X\n    height = bbox.Max.Y - bbox.Min.Y\n\n    frontage_length = min(width, height)\n    depth = max(width, height)\n\n    # 4. 도로폭에 따른 깊이 조정\n    effective_depth = depth\n    if road_width < MIN_ROAD_WIDTH_FOR_PARKING:\n        setback = MIN_ROAD_WIDTH_FOR_PARKING - road_width\n        effective_depth = max(0, depth - setback)\n\n    # 5. 승강기 코어 반영\n    effective_frontage = frontage_length\n    if elevator_cnt > 0:\n        core_width = ELEVATOR_CORE_SIZE * elevator_cnt\n        effective_frontage = max(0, frontage_length - core_width)\n\n    # 6. 1열 주차 가능 대수\n    n_cols_raw = int(effective_frontage / parking_width)\n    n_gaps = max(0, (n_cols_raw - 1) // MAX_CLUSTER_SIZE)\n    n_cols = max(0, n_cols_raw - n_gaps)\n\n    # 7. 연접 가능 여부\n    n_rows = 1\n    if tandem_mode == 'ALLOW_TANDEM' and effective_depth >= 10.0:\n        n_rows = 2\n\n    # 8. 기본 주차대수\n    p_calc = n_cols * n_rows\n\n    # 9. 8대 이하 특례\n    if p_calc > MAX_TANDEM_ALLOWED and tandem_mode == 'ALLOW_TANDEM':\n        p_calc = n_cols\n\n    p_max = max(0, p_calc)\n\n    return {\n        'pnu': pnu,\n        'p_max': p_max,\n        'p_existing': p_existing,\n        'p_diff': p_max - p_existing,\n        'tandem_mode': tandem_mode,\n        'parking_width': parking_width,\n        'frontage': round(effective_frontage, 2),\n        'depth': round(effective_depth, 2),\n        'road_width': road_width\n    }\n\n\n# ==============================================================================\n# 시각화 헬퍼\n# ==============================================================================\n\ndef get_color_by_pmax(p_max, max_pmax=10):\n    \"\"\"P_max 값에 따른 색상 반환 (파랑→빨강 그라데이션)\"\"\"\n    if p_max <= 0:\n        return Color.FromArgb(200, 200, 200)  # 회색\n\n    ratio = min(1.0, p_max / float(max_pmax))\n\n    # 파랑(0) → 노랑(0.5) → 빨강(1.0)\n    if ratio < 0.5:\n        r = int(255 * (ratio * 2))\n        g = int(255 * (ratio * 2))\n        b = int(255 * (1 - ratio * 2))\n    else:\n        r = 255\n        g = int(255 * (1 - (ratio - 0.5) * 2))\n        b = 0\n\n    return Color.FromArgb(r, g, b)\n\n\ndef create_surface_from_curve(curve, tolerance=0.01):\n    \"\"\"커브에서 Surface 생성\"\"\"\n    if not curve or not curve.IsValid:\n        return None\n\n    try:\n        if not curve.IsClosed:\n            if not curve.MakeClosed(tolerance):\n                return None\n\n        breps = rg.Brep.CreatePlanarBreps(curve, tolerance)\n        if breps and len(breps) > 0:\n            return breps[0]\n        return None\n    except:\n        return None\n\n\n# ==============================================================================\n# 메인 실행 (Grasshopper에서 호출)\n# ==============================================================================\n\ndef run_parking_calculator(\n    lot_curves, lot_pnus,\n    road_curves,\n    building_pnus, building_a32, building_a33,\n    building_a39, building_a50, building_a77\n):\n    \"\"\"\n    메인 실행 함수\n\n    Returns:\n        results: List[str] - CSV 형식 결과\n        result_curves: List[Curve] - 대지 커브들\n        result_colors: List[Color] - 색상들\n    \"\"\"\n\n    results = []\n    result_curves = []\n    result_colors = []\n\n    # 헤더\n    results.append(\"PNU,P_MAX,P_EXISTING,P_DIFF,TANDEM_MODE,FRONTAGE,DEPTH,ROAD_WIDTH\")\n\n    # 건물 정보를 PNU로 인덱싱\n    building_dict = {}\n    for i, bpnu in enumerate(building_pnus):\n        if not bpnu:\n            continue\n\n        a32 = building_a32[i] if i < len(building_a32) else \"\"\n        a33 = building_a33[i] if i < len(building_a33) else \"\"\n        a39 = building_a39[i] if i < len(building_a39) else 0\n        a50 = building_a50[i] if i < len(building_a50) else \"\"\n        a77 = building_a77[i] if i < len(building_a77) else 0\n\n        # 필터링\n        if should_drop_building(a32, a33):\n            continue\n\n        tandem_mode = determine_tandem_mode(a33)\n\n        building_dict[str(bpnu)] = {\n            'pnu': str(bpnu),\n            'a32': a32,\n            'a33': a33,\n            'a39': a39,\n            'a50': a50,\n            'a77': a77,\n            'tandem_mode': tandem_mode\n        }\n\n    print(\"필터링 후 건물 수: {}\".format(len(building_dict)))\n\n    # 대지별 계산\n    success_count = 0\n    max_pmax = 1\n\n    for i, lot_curve in enumerate(lot_curves):\n        pnu = lot_pnus[i] if i < len(lot_pnus) else \"\"\n        pnu_str = str(pnu)\n\n        if pnu_str not in building_dict:\n            continue\n\n        building_info = building_dict[pnu_str]\n\n        # 인접 도로 찾기 및 도로폭 계산\n        road_width = 6.0  # 기본값\n        for road_curve in road_curves:\n            if curves_are_adjacent(lot_curve, road_curve):\n                rw = estimate_road_width(road_curve)\n                if rw > road_width:\n                    road_width = rw\n\n        # P_max 계산\n        result = compute_pmax(lot_curve, building_info, road_width)\n\n        if result['p_max'] > 0:\n            success_count += 1\n            if result['p_max'] > max_pmax:\n                max_pmax = result['p_max']\n\n        # 결과 저장\n        line = \"{},{},{},{},{},{},{},{}\".format(\n            result['pnu'],\n            result['p_max'],\n            result['p_existing'],\n            result['p_diff'],\n            result['tandem_mode'],\n            result.get('frontage', 0),\n            result.get('depth', 0),\n            result.get('road_width', 0)\n        )\n        results.append(line)\n        result_curves.append(lot_curve)\n\n    # 색상 할당\n    for i, curve in enumerate(result_curves):\n        if i + 1 < len(results):  # 헤더 제외\n            parts = results[i + 1].split(',')\n            p_max = int(parts[1]) if len(parts) > 1 else 0\n            result_colors.append(get_color_by_pmax(p_max, max_pmax))\n\n    print(\"=\"*50)\n    print(\"P_max 계산 완료\")\n    print(\"  총 대지: {}\".format(len(lot_curves)))\n    print(\"  매칭된 건물: {}\".format(len(building_dict)))\n    print(\"  계산 성공: {}\".format(success_count))\n    print(\"  최대 P_max: {}\".format(max_pmax))\n    print(\"=\"*50)\n\n    return results, result_curves, result_colors\n\n\n# ==============================================================================\n# Grasshopper 실행 진입점\n# ==============================================================================\n\n# 입력 변수들이 Grasshopper에서 정의되어 있다고 가정\n# LotCurves, LotPNUs, RoadCurves, BuildingPNUs, BuildingA32, BuildingA33, BuildingA39, BuildingA50, BuildingA77\n\ntry:\n    # 입력 검증\n    if 'LotCurves' in dir() and LotCurves:\n        print(\"입력 확인:\")\n        print(\"  LotCurves: {}개\".format(len(LotCurves) if LotCurves else 0))\n        print(\"  LotPNUs: {}개\".format(len(LotPNUs) if 'LotPNUs' in dir() and LotPNUs else 0))\n        print(\"  RoadCurves: {}개\".format(len(RoadCurves) if 'RoadCurves' in dir() and RoadCurves else 0))\n        print(\"  BuildingPNUs: {}개\".format(len(BuildingPNUs) if 'BuildingPNUs' in dir() and BuildingPNUs else 0))\n\n        Results, ResultCurves, ResultColors = run_parking_calculator(\n            LotCurves if 'LotCurves' in dir() else [],\n            LotPNUs if 'LotPNUs' in dir() else [],\n            RoadCurves if 'RoadCurves' in dir() else [],\n            BuildingPNUs if 'BuildingPNUs' in dir() else [],\n            BuildingA32 if 'BuildingA32' in dir() else [],\n            BuildingA33 if 'BuildingA33' in dir() else [],\n            BuildingA39 if 'BuildingA39' in dir() else [],\n            BuildingA50 if 'BuildingA50' in dir() else [],\n            BuildingA77 if 'BuildingA77' in dir() else []\n        )\n    else:\n        print(\"입력 없음 - LotCurves를 연결해주세요\")\n        Results = []\n        ResultCurves = []\n        ResultColors = []\n\nexcept Exception as e:\n    print(\"오류 발생: {}\".format(str(e)))\n    import traceback\n    traceback.print_exc()\n    Results = []\n    ResultCurves = []\n    ResultColors = []\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}