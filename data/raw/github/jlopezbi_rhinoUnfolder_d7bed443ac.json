{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/meshUtils/mesh.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/meshUtils/mesh.py",
  "instruction": null,
  "code": "from rhino_unwrapper import visualization as vis\nfrom rhino_unwrapper import rhino_helpers as helpers\nfrom rhino_unwrapper import transformations as trans\nreload(vis)\nreload(helpers)\nreload(trans)\n\nimport scriptcontext\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as geom\nimport System\nimport clr\n\ndef make_test_mesh():\n    '''\n    returns an instance of myMesh and adds the rhinoMesh to the document\n    '''\n    vertices = []\n    vertices.append((0.0,0.0,0.0))\n    vertices.append((5.0, 0.0, 0.0))\n    vertices.append((10.0, 0.0, 0.0))\n    vertices.append((0.0, 5.0, 0.0))\n    vertices.append((5.0, 5.0, 0.0))\n    vertices.append((10.0, 5.0, 0.0))\n    vertices.append((0.0, 10.0, 0.0))\n    vertices.append((5.0, 10.0, 0.0))\n    vertices.append((10.0, 10.0, 0.0))\n    faceVertices = []\n    faceVertices.append((0,1,4,4))\n    faceVertices.append((2,4,1,1))\n    faceVertices.append((0,4,3,3))\n    faceVertices.append((2,5,4,4))\n    faceVertices.append((3,4,6,6))\n    faceVertices.append((5,8,4,4))\n    faceVertices.append((6,4,7,7))\n    faceVertices.append((8,7,4,4))\n    return get_myMesh(vertices,faceVertices)\n\ndef make_upright_mesh():\n    verts = []\n    verts.append((0.0,0.0,0.0))\n    verts.append((5.0,0.0,0.0))\n    verts.append((5.0,0.0,5.0))\n    verts.append((0.0,0.0,5.0))\n    face_verts = []\n    face_verts.append((0,1,3,3))\n    face_verts.append((1,2,3,3))\n    return get_myMesh(verts,face_verts)\n\ndef make_cube_mesh():\n    vertices = []\n    vertices.append((0.0,0.0,0.0)) #0\n    vertices.append((5.0,0.0,0.0)) #1\n    vertices.append((5.0,5.0,0.0)) #2\n    vertices.append((0.0,5.0,0.0)) #3\n    vertices.append((0.0,0.0,5.0)) #4\n    vertices.append((5.0,0.0,5.0)) #5\n    vertices.append((5.0,5.0,5.0)) #6\n    vertices.append((0.0,5.0,5.0)) #7\n    faceVertices = []\n    faceVertices.append((3,2,1,0)) #bottom face\n    faceVertices.append((4,5,6,7)) #top face\n    faceVertices.append((0,1,5,4)) #front face\n    faceVertices.append((4,7,3,0)) #left face\n    faceVertices.append((1,2,6,5)) #right face\n    faceVertices.append((2,3,7,6)) #back face\n    return get_myMesh(vertices,faceVertices)\n\ndef get_myMesh(vertices,face_vertices):\n    '''add a mesh to doc and get the Rhino.Geometry.Mesh object''' \n    mesh_GUID = rs.AddMesh( vertices, face_vertices )\n    obj = scriptcontext.doc.Objects.Find(mesh_GUID)\n    return Mesh(obj.Geometry)\n\n#NOTE: even more hierarchical:\n# Mesh.\n#     .elements\n#     .display\n#     .select\n#     .unfold <=!?\n\n#NOTE: what if did something like:\n# Mesh.\n#     .vertexQuiery\n#     .edgeQuiery\n#     .faceQuiery\n#     .special\n\n#or mabe:\n# mesh.Vertices\n# mesh.Edges\n# mesh.Faces\n# mesh.Special\n# ex: mesh.Vertices.get_\n# ex: mesh.Speical.get_frame_asdfsdf()\n\nclass Mesh(object): \n    \"\"\"\n    better names?\n    MeshQuieryer\n    MeshFinder\n    MeshElementFinder\n    MeshElementGetter\n    PythonMesh\n    MyMesh\n\n    Does custom queiries on a Rhino mesh that make layout easy\n    see http://4.rhino3d.com/5/rhinocommon/ for rhino mesh class members\n    - queries\n    - visualizing info\n    \"\"\"\n\n    def __init__(self,mesh):\n        self.mesh = mesh\n        #NOTE: the below line seems to wipe the UserDictionary for later access\n        #self.mesh.FaceNormals.ComputeFaceNormals()\n        self.cut_key = 'cuts'\n        if not self.mesh.UserDictionary.ContainsKey(self.cut_key):\n            self.set_cuts([])\n\n    ### GENERAL\n\n    def edge_indices(self):\n        pass\n\n    def face_indices(self):\n        return range(self.mesh.Faces.Count)\n\n    def get_set_of_edges(self):\n        count = self.mesh.TopologyEdges.Count\n        return set(range(count))\n\n    def get_set_of_face_idxs(self):\n        return set(self.face_indices())\n\n    def get_mesh_faces(self):\n        \"\"\"\n        returns list of MeshFace instances that make up mesh\n        \"\"\"\n        return (self.mesh.Faces.GetFace(i) for i in xrange(self.mesh.Faces.Count))\n\n    def meshTVerts(self):\n        return xrange(self.mesh.TopologyVertices.Count)\n\n    ### SPECIAL, ie requires more than one extra index\n\n    def get_frame_oriented_with_face_normal(self,edge,face):\n        '''\n        an edge and a face (meshLoc) imply a unique frame, \n        since the edge can be oriented according the the face's normal (right hand rule)\n        '''\n        face_edges = self.getFaceEdges(face)\n        assert (edge in face_edges), \"edge {} not in face {}\".format(edge,face)\n        basePoint,endPoint = self.get_oriented_points_for_edge(edge,face)\n        normal = self.get_face_normal(face)\n        xVec = helpers.getVectorForPoints(basePoint,endPoint)\n        return trans.Frame.create_frame_from_normal_and_x(basePoint,normal,xVec)\n\n    def getOtherFaceIdx(self,edgeIdx, faceIdx):\n        connectedFaces = self.getFacesForEdge(edgeIdx)\n        assert(faceIdx in connectedFaces), \"faceIdx not in faces associated with edge\"\n\n        if len(connectedFaces) != 2:\n            # This is a naked edge\n            #print(\"did not find two connected faces for edgeIdx %i, \" %(edgeIdx))\n            return None\n\n        newFaceIdx = None\n        if (connectedFaces[0] == faceIdx):\n            newFaceIdx = connectedFaces[1]\n        elif (connectedFaces[1] == faceIdx):\n            newFaceIdx = connectedFaces[0]\n        else:\n            print \"problem in getOtherFaceIdx: edgeIdx not in faceIdx,assert should have caught error\"\n            return None\n\n        assert(newFaceIdx != faceIdx), \"getOtherFaceIdx(): newFaceIdx == faceIdx!\"\n        return newFaceIdx\n\n    ### QUIRED OBJECT IS VERTEX\n\n    def get_point_for_tVert(self,tVert):\n        '''\n        Note: convertes Point3f to Point3d!\n        '''\n        return geom.Point3d(self.mesh.TopologyVertices.Item[tVert])\n\n    def get_point3f_for_tVert(self,vert):\n        return self.mesh.TopologyVertices.Item[vert]\n\n    def getTVertsForVert(self,tVert):\n        arrTVerts = self.mesh.TopologyVertices.ConnectedTopologyVertices(tVert)\n        listVerts = vis.convertArray(arrTVerts)\n        if tVert in listVerts:\n            listVerts = listVerts.remove(tVert)\n        return listVerts\n\n    def getEdgesForVert(self,tVert):\n        # not implimented in rhinoCommon! ::::(\n        # rather inefficient\n        neighVerts = self.getTVertsForVert(tVert)\n        facesVert = set(self.getFacesForVert(tVert))\n        edges = []\n        for neighVert in neighVerts:\n\n            edge = self.get_edge_for_vert_pair(tVert, neighVert)\n            if edge:\n                edges.append(edge)\n        return edges\n\n    def get_edge_for_vert_pair(self,vertA,vertB):\n        return self.mesh.TopologyEdges.GetEdgeIndex(vertA,vertB)\n\n    def getEdgeForTVertPair(self,tVertA, tVertB, facesVertA=None):\n        ''' Depricated, use get_edge_for_vert_pair() '''\n        if facesVertA is None:\n            facesVertA = self.getFacesForVert(tVertA)\n        facesVertB = set(self.getFacesForVert(tVertB))\n        facePair = list(facesVertA.intersection(facesVertB))\n        if len(facePair) == 2:\n            edgesA = set(self.getFaceEdges(facePair[0]))\n            edgesB = set(self.getFaceEdges(facePair[1]))\n            edge = edgesA.intersection(edgesB)\n            if len(edge) == 0:\n                print \"probably encountered naked edge in chain selection\"\n                return\n            return list(edge)[0]\n        elif len(facePair) == 1:\n            # naked edge\n            edges = self.getFaceEdges(facePair[0], self.mesh)\n            for edge in edges:\n                tVerts = self.getTVertsForEdge(edge)\n                if tVertB in tVerts and tVertA in tVerts:\n                    return edge\n        return      \n\n    def getFacesForVert(self,tVert):\n        arrfaces = self.mesh.TopologyVertices.ConnectedFaces(tVert)\n        return vis.convertArray(arrfaces)\n    \n    def getOtherTVert(self,edge, tVert):\n        tVerts = self.getTVertsForEdge(edge)\n        tVerts.remove(tVert)\n        return tVerts[0]\n\n    ### SPECIAL EDGE\n    def get_aligned_points(self,orientedEdge):\n        '''\n        get points ordered according to orientation \n        '''\n        edge, aligned_with_face = orientedEdge\n        points = self.getPointsForEdge(edge)\n        if not aligned_with_face:\n            points.reverse()\n        return points\n\n    ### STUFF FOR LAYOUT\n\n    def set_cuts(self,cutList):\n        edges = self.get_set_of_edges()\n        assert (edges.issuperset(set(cutList))), \"cutList {} was not a subset of mesh edges\".format(cutList)\n        did_set = self.mesh.UserDictionary.Set(self.cut_key, System.Array[int](cutList))\n        return did_set\n\n    def get_cuts(self):\n        return list(self.mesh.UserDictionary[self.cut_key])\n\n    def is_cut_edge(self,edge):\n        return edge in self.get_cuts()\n\n    def is_fold_edge(self,edge):\n        return edge not in self.get_cuts() and not self.is_naked_edge(edge)\n\n    def is_naked_edge(self,edge):\n        faces = self.getFacesForEdge(edge)\n        nFaces = len(faces)\n        assert (nFaces >0), \"did not get any faces for edge {}\".format(edge)\n        if nFaces== 1:\n            return True\n        return False\n\n    ### Main OBJECT IS EDGE\n\n    def getTangentEdge(self,edge, tVert, angleTolerance, chain):\n        '''\n        return edge that is closest in angle, or none if none\n        of the edges are within angleTolerance\n        '''\n        edges = self.getEdgesForVert( tVert)\n        if edge in edges:\n            edges.remove(edge)\n        winEdge = (None, angleTolerance)\n        for neighEdge in edges:\n            angle = self.compareEdgeAngle(edge, tVert, neighEdge)\n            if angle < angleTolerance and angle < winEdge[1]:\n                winEdge = (neighEdge, angle)\n\n        newEdge = winEdge[0]\n        if newEdge is None:\n            return chain\n        if newEdge in chain:\n            return chain\n        else:\n            chain.append(newEdge)\n            nextTVert = self.getOtherTVert( newEdge, tVert)\n            return self.getTangentEdge(newEdge, nextTVert, angleTolerance, chain)\n\n    def getChain(self,edge, angleTolerance):\n        '''\n        gets chains extending from both ends of a given edge,\n        using angleTolerance as stopping criterion\n        '''\n        chain = []\n        tVerts = self.getTVertsForEdge(edge)\n        for tVert in tVerts:\n            subChain = self.getTangentEdge(edge, tVert, angleTolerance, [])\n            chain.extend(subChain)\n        chain.append(edge)\n        return chain\n\n    def getFacesForEdge(self,edge):\n        '''\n        returns an array of indices of the faces connected to a given edge\n        if the array has only one face this indicates it is a naked edge\n        '''\n        return list(self.mesh.TopologyEdges.GetConnectedFaces(edge))\n\n    def getTVertsForEdge(self,edge):\n        vertPair = self.mesh.TopologyEdges.GetTopologyVertices(edge)\n        return [vertPair.I, vertPair.J]\n\n    def getEdgeAngle(self,edge):\n        '''\n        get dihedral angle, in radians of a given edge in the mesh\n        '''\n        faceIdxs = self.getFacesForEdge(edge)\n        if (len(faceIdxs)==2):\n            faceNormA = self.get_face_normal(faceIdxs[0])\n            faceNormB = self.get_face_normal(faceIdxs[1])\n            return geom.Vector3d.VectorAngle(faceNormA,faceNormB)\n        else:\n            return None\n\n    def getDistanceToEdge(self,edge, point):\n        '''\n        edge = Topology edgeIdx in mesh\n        point = Point3d to get distance to edge\n        '''\n        edgeLine = self.mesh.TopologyEdges.EdgeLine(edge)\n        return edgeLine.DistanceTo(point, True)\n\n    def getEdgeVector(self,edgeIdx): \n        edgeLine = self.mesh.TopologyEdges.EdgeLine(edgeIdx)\n        # Vector3d\n        vec = edgeLine.Direction\n        return vec\n    \n    def get_edge_vec_oriented(self,edgeIdx,faceIdx):\n        tVerts = self.get_oriented_TVerts_for_edge(edgeIdx,faceIdx)\n        pntA,pntB = self._get_points_for_tVerts(tVerts)\n        return helpers.getVectorForPoints(pntA,pntB)\n\n    def get_oriented_points_for_edge(self,edgIdx,faceIdx):\n        tVerts = self.get_oriented_TVerts_for_edge(edgIdx,faceIdx)\n        return self._get_points_for_tVerts(tVerts)\n\n    def _get_points_for_tVerts(self,verts):\n        points = []\n        for vert in verts:\n            points.append(self.mesh.TopologyVertices.Item[vert])\n        return points\n\n    def getPointsForEdge(self,edgeIdx):\n        tVertI, tVertJ = self.getTVertsForEdge(edgeIdx)\n        pntI = self.mesh.TopologyVertices.Item[tVertI]\n        pntJ = self.mesh.TopologyVertices.Item[tVertJ]\n        return [pntI, pntJ]\n     \n    def get_oriented_TVerts_for_edge(self,edgeIdx,faceIdx):\n        \"\"\"\n        using the right-hand rule for face normals, each edge has a specific\n        direction, given one of its ajoining faces. Returns the TVerts of that\n        edge in that order.\n        \"\"\"\n        correct_list = self.getTVertsForFace(faceIdx)\n        edge_IJ = self.getTVertsForEdge(edgeIdx)\n        assert set(edge_IJ).issubset(set(correct_list)), \\\n        \"edge {} does not belong to face {}\".format(edgeIdx,faceIdx)\n        ordered_IJ = sorted(edge_IJ,key=lambda x:correct_list.index(x))\n        if ordered_IJ[0]== correct_list[0] and ordered_IJ[-1] == correct_list[-1]:\n            ordered_IJ.reverse()\n        return ordered_IJ\n\n    def get_edge_line(self,edgeIdx):\n        return self.mesh.TopologyEdges.EdgeLine(edgeIdx)\n    \n    def getEdgeLen(self,edgIdx):\n        edgeLine = self.get_edge_line(edgeIdx)\n        return edgeLine.Length\n    \n    def get_edge_center_point(self,edgeIdx):\n        line = self.get_edge_line(edgeIdx)\n        cenX = (line.FromX + line.ToX) / 2.0\n        cenY = (line.FromY + line.ToY) / 2.0\n        cenZ = (line.FromZ + line.ToZ) / 2.0\n        point =  geom.Point3d(cenX, cenY, cenZ)\n        return point\n\n    def compareEdgeAngle(self,edge, tVert, neighEdge):\n        vecBase = self._getOrientedVector(edge, tVert, True)\n        vecCompare = self._getOrientedVector(neighEdge, tVert, False)\n        angle = geom.Vector3d.VectorAngle(vecBase, vecCompare)\n        return angle\n\n    def _getOrientedVector(self,edgeIdx, tVert, isEnd):\n        '''\n        tVert is the end point of this vector\n        '''\n        tVerts = self.getTVertsForEdge(edgeIdx)\n        assert(tVert in tVerts)\n        tVerts.remove(tVert)\n        otherVert = tVerts[0]\n        if isEnd:\n            pntB = self.mesh.TopologyVertices.Item[tVert]\n            pntA = self.mesh.TopologyVertices.Item[otherVert]\n        else:\n            pntA = self.mesh.TopologyVertices.Item[tVert]\n            pntB = self.mesh.TopologyVertices.Item[otherVert]\n        vecPnt = pntB - pntA\n        vec = geom.Vector3d(vecPnt)\n        return vec\n\n    def getEdgeLengths(self):\n        edgeLens = []\n        for i in range(self.mesh.TopologyEdges.Count):\n            edgeLine = self.mesh.TopologyEdges.EdgeLine(i)\n            edgeLen = edgeLine.Length\n            edgeLens.append(edgeLen)\n        return edgeLens\n\n    def getMedianEdgeLen(self):\n        edgeLens = self.getEdgeLengths(self.mesh)\n        return getMedian(edgeLens)\n\n    ### Main OBJECT IS FACE\n    def get_adjacent_faces(self,faceIdx):\n        return list(self.mesh.Faces.AdjacentFaces(faceIdx))\n\n    def getTVertsForFace(self,faceIdx):\n        '''\n        list of 4 values if quad, 3 values if triangle\n        '''\n        arrTVerts = self.mesh.Faces.GetTopologicalVertices(faceIdx)\n        tVerts = list(arrTVerts)\n        return helpers.uniqueList(tVerts)\n    \n    def get_points_for_face(self,faceIdx):\n        '''\n        Note: converts TopologyVertices as Point3f to Point3d\n        '''\n        tVerts = self.getTVertsForFace(faceIdx)\n        points = []\n        for tVert in tVerts:\n            points.append(geom.Point3d(self.mesh.TopologyVertices.Item[tVert]))\n        return points\n\n    def getFaceEdges(self,faceIdx):\n        arrFaceEdges = self.mesh.TopologyEdges.GetEdgesForFace(faceIdx)\n        return list(arrFaceEdges)\n\n    def get_edges_ccw_besides_base(self,baseEdge=None,face=None):\n        '''\n        get the edges for the face, except the baseEdges, ordered\n        ccw around face, startin with the edge after the baseEdge\n        '''\n        #TODO: do assertion check that baseEdge belongs to the face\n        edges,orientations = self.get_edges_and_orientation_for_face(face)\n        index = edges.index(baseEdge)\n        edges = helpers.rotate_and_remove(edges,index)\n        orientations = helpers.rotate_and_remove(orientations,index)\n        return zip(edges,orientations)\n\n    def get_edges_and_orientation_for_face(self,faceIdx):\n        orientations = clr.StrongBox[System.Array[bool]]()\n        edges =  self.mesh.TopologyEdges.GetEdgesForFace(faceIdx,orientations)\n        edges = list(edges)\n        orientations = list(orientations.Value)\n        #edges_with_orientations = zip(edges,orientations)\n        return edges,orientations\n\n    def get_edges_except(self,faceIdx,edgeIdx):\n        face_edges = self.getFaceEdges(faceIdx)\n        return face_edges.remove(edgeIdx)\n\n    def face_normal(self,face):\n        '''\n        wrap the FaceNormals.Item method to provide usefull error message\n        '''\n        face_normal_command = \"RebuildMeshNormals\"\n        assert self.mesh.FaceNormals.Count > 0, \"the FaceNormals have not been computed for this mesh. Try running {}\".format(face_normal_command)\n        return self.mesh.FaceNormals.Item[face]\n\n\n    def get_face_normal(self,face):\n        '''\n        rhinocommon returns Vector3f, but most other rhioncommon\n        stuff uses vector3d, so returns vector3d\n        '''\n        return geom.Vector3d(self.face_normal(face))\n\n    def get_naked_or_cut_edge_from_candidate_faces(self,canditate_faces):\n        assert self.get_cuts() , \"Mesh has no cuts set. Make sure to assign cuts first\"\n        for face in canditate_faces:\n            edges = self.getFaceEdges(face)\n            for edge in edges:\n                if self.is_cut_edge(edge) or self.is_naked_edge(edge):\n                    return edge,face\n        assert False, \"unable to find valid face\"\n\n    def get_face_next_to_a_cut(self): \n        cuts = self.get_cuts()\n        arbitrary_cut_edge = cuts[0]\n        faces = self.getFacesForEdge(arbitrary_cut_edge)\n        arbitrary_face = faces[0]\n        return arbitrary_face\n\nclass MeshDisplayer(object):\n\n    def __init__(self,meshElementFinder):\n        self.meshElementFinder = meshElementFinder\n\n    def displayTVertsIdx(self):\n        for vert in self.meshElementFinder.meshTVerts():\n            self.displayTVertIdx(vert)\n\n    def displayTVertIdx(self,vert, disp=None, color=(0, 255, 0, 255)):\n        if disp is None:\n           disp = vert\n        point = self.meshElementFinder.mesh.TopologyVertices.Item[vert]\n        vis.drawTextDot(point, str(disp), color)\n\n    def displayEdgesIdx(self):\n        for edge in self.meshElementFinder.get_set_of_edges():\n            self.displayEdgeIdx(edge)\n\n    def displayEdgeIdx(self,edgeIdx,color=(0,0,255,0)):\n        point = self.meshElementFinder.get_edge_center_point(edgeIdx)\n        return vis.drawTextDot(point, str(edgeIdx), color)\n\n    def displayIJEdge(self, edgeIdx):\n        pntI,pntJ = self.meshElementFinder.getPointsForEdge(edgeIdx)\n        rs.AddTextDot('I', pntI)\n        rs.AddTextDot('J', pntJ)\n\n    def displayFacesIdx(self):\n        for i,face in enumerate(self.meshElementFinder.get_set_of_face_idxs()):\n            self.displayFaceIdx(i)\n\n    def displayFaceIdx(self, face):\n        centerPnt = self.meshElementFinder.mesh.Faces.GetFaceCenter(face)\n        rs.AddTextDot(str(face), centerPnt)\n\n    def displayNormals(self):\n        normLines = []\n        for i in range(self.meshElementFinder.mesh.FaceNormals.Count):\n            pntCenter = self.meshElementFinder.mesh.Faces.GetFaceCenter(i)  # Point3d\n            posVecCenter = geom.Vector3d(pntCenter)\n            vecNormal = self.meshElementFinder.mesh.FaceNormals.Item[i]  # Vector3f\n            vecNormal.Unitize()\n            lineGuid = vis.drawVector(vecNormal, pntCenter)\n            normLines.append(lineGuid)\n\n    def display_face_vert_ordering(self,faceIdx):\n        points = self.meshElementFinder.get_points_for_face(faceIdx)\n        points.append(points[0])\n        vis.drawPolyline(points,arrowType='end')\n\n    def display_all_face_vert_ordering(self):\n        faces = self.meshElementFinder.get_set_of_face_idxs()\n        for face in faces:\n            self.display_face_vert_ordering(face)\n\n    def display_edge_direction_IJ(self,edgeIdx):\n        pnts = self.meshElementFinder.getPointsForEdge(edgeIdx)\n        vis.show_line_from_points(pnts,color=(0,0,0,255),arrowType='end')\n\n    def display_all_edges_direction_IJ(self):\n        for i in self.meshElementFinder.get_set_of_edges():\n            self.display_edge_direction_IJ(i)\n        \n    def display_edge_direction(self,edgeIdx):\n        line = self.meshElementFinder.get_edge_line(edgeIdx)\n        vis.draw_arrow(line,color=(0,255,0,255))\n\n    def display_all_edges_direction(self):\n        for edge in self.meshElementFinder.get_set_of_edges():\n            self.display_edge_direction(edge)\n\n    def display_all_elements(self):\n        self.displayFacesIdx()\n        self.displayEdgesIdx()\n        self.displayTVertsIdx()\n\n    def display_edges(self, edgeIdxs,color=(0,255,0,255)):\n        drawnEdges = {}\n        if edgeIdxs:\n            for edgeIdx in edgeIdxs:\n                points = self.meshElementFinder.getPointsForEdge(edgeIdx)\n                lineGuid, line = vis.show_line_from_points(points, color, 'none')\n                drawnEdges[edgeIdx] = lineGuid\n        return drawnEdges\n\nif __name__ == \"__main__\":\n    mesh = make_test_mesh()\n    displayer = MeshDisplayer(mesh)\n    displayer.display_all_elements()\n    for i in mesh.get_set_of_face_idxs():\n        print \"face {} has edges: {}\".format(i,mesh.getFaceEdges(i))\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}