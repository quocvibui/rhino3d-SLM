{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/vertexClass_patternV2_3.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/vertexClass_patternV2_3.py",
  "instruction": "Vertex class pattern v2 3",
  "code": "import Rhino.Geometry as rg\nimport math\n\nclass Vertex(object):\n\n    def __init__(self, pt = rg.Point3d(0,0,0), normal = rg.Point3d(0,0,0), rel_loc = rg.Point3d(0,0,0), is_neg = False):\n\n        self.o = pt\n        self.v = pt\n        \n        self.n = normal\n        self.n_scale = 1.0\n\n        self.rel_loc = rel_loc\n\n        self.vec_version = rg.Point3d(x_val, y_val, 0.0)\n\n        self.is_neg = is_neg\n\n\n    def numeric_distance(self, other, radius = 0.0):\n\n        # return ((self.x_val - other.x_val) ** 2 + (self.y_val - other.y_val) ** 2) ** .5\n\n        return self.vec_version.DistanceTo(other.vec_version)\n\n\n    def x_distance(self, other):\n\n        return abs(self.x_val - other.x_val)\n\n\n    def move_pt(self, mv_pt):\n\n        return Vertex(self.o + mv_pt, self.n, self.x_val, self.y_val)\n        \n\n    def warp_pt(self, scale_val = 0):\n\n        self.v = rg.Point3d(self.o + self.n * (scale_val * self.n_scale))\n\n    def distance_function(self, x_spacing = 20.0, y_spacing = 20.0, layer_shift = 2.0, rot_alfa = 0.0, x_scale_val = 1.0):\n        \n        x, y = self.x_val, self.y_val\n\n        if not(rot_alfa == 0.0):\n            \n            x_new = math.cos(rot_alfa) * x - math.sin(rot_alfa) * y\n            y_new = math.sin(rot_alfa) * x + math.cos(rot_alfa) * y\n            \n            x, y = x_new, y_new\n        \n        layer_shift = float(layer_shift)\n        \n        abs_loc_y = y % y_spacing\n        layer_count = float(math.floor((y - abs_loc_y) / y_spacing))\n        \n        # print(\"layer_count %s\" % layer_count)\n        # print(\"layer_shift %s\" % layer_shift)\n        \n        x_shift = (layer_count / layer_shift) * x_spacing\n        \n        # print(\"x_shift %s\" % x_shift)\n        \n        loc_x = ((x + x_shift) % x_spacing) / x_spacing\n        loc_y = abs_loc_y / y_spacing\n        \n        distance = math.sqrt((loc_x - .5) ** 2 + (loc_y - .5) ** 2)\n        \n        return distance\n\n\ndef moveSet(layer_set, reference_set, pattern_set = [1], div_l = 3.0, direction_val = -1, item = 0):\n\n    crv_l = layer_set[0][item].GetLength()\n    div_c = int(crv_l / div_l)\n    div_l = crv_l / float(div_c)\n    lay_h = float(reference_set[1].PointAt(0.0).Z - reference_set[0].PointAt(0.0).Z)\n\n    pattern_part = []\n    other_part = []\n\n    offset_crvs = []\n\n    for ref_i, layer in enumerate(layer_set):\n        \n        a_crv = layer[item]\n        b_crv = layer[(item + 1) % 2]\n        c_crv = reference_set[ref_i]\n\n        local_l_a = a_crv.GetLength()\n        local_l_b = b_crv.GetLength()\n        \n        local_div_l_a = local_l_a / div_c\n        local_div_l_b = local_l_b / div_c\n        \n        t_vals_a = a_crv.DivideByLength(local_div_l_a, True)\n        t_vals_b = b_crv.DivideByLength(local_div_l_b, True)[1:-1]\n\n        pts_a = [a_crv.PointAt(t) for t in t_vals_a]\n        local_other_part = [b_crv.PointAt(t) for t in t_vals_b]\n\n        pln = rg.Plane(c_crv.PointAt(0.0), rg.Vector3d(0,0,1))\n\n        # getting normals\n\n        tmp_offset_crv_1 = c_crv.Offset(pln, 1.0, .01, rg.CurveOffsetCornerStyle.Round)[0]\n        tmp_offset_crv_2 = c_crv.Offset(pln, -1.0, .01, rg.CurveOffsetCornerStyle.Round)[0]\n\n        if tmp_offset_crv_1.GetLength() < tmp_offset_crv_2.GetLength():\n\n            offset_crv = tmp_offset_crv_2\n        \n        else:\n\n            offset_crv = tmp_offset_crv_1\n        \n        normals_a = [(pt - offset_crv.PointAt(offset_crv.ClosestPoint(pt)[1])) for pt in pts_a]\n        normals_a = [n * (1.0 / rg.Point3d(0,0,0).DistanceTo(rg.Point3d(n))) for n in normals_a]\n\n        loc_pattern_part = []\n\n        for pt_i, pt in enumerate(pts_a):\n\n            loc_pattern_part.append(Vertex(pt, normals_a[pt_i], x_val = pt_i * div_l, y_val = ref_i * lay_h))\n\n        pattern_part.append(loc_pattern_part)\n        other_part.append(local_other_part)\n\n        offset_crvs.append(offset_crv)\n\n    output_layers = [pattern_part, other_part]\n\n    return output_layers, (crv_l, div_l, lay_h), offset_crvs",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}