{
  "source_url": "https://github.com/choras-org/backend/blob/83981cdf4fc703fdcefe1b8c57625423a98db039/app/factory/geometry_converter_factory/DxfConversion.py",
  "repo": "choras-org/backend",
  "repo_stars": 6,
  "repo_description": "CHORAS backend",
  "license": "unknown",
  "filepath": "app/factory/geometry_converter_factory/DxfConversion.py",
  "instruction": "Dxf conversion",
  "code": "import logging\nimport os\n\nimport ezdxf\nimport numpy as np\nimport rhino3dm\n\nfrom app.factory.geometry_converter_factory.GeometryConversionStrategy import GeometryConversionStrategy\n\n\nclass DxfConversion(GeometryConversionStrategy):\n    # Create logger for this module\n    logger = logging.getLogger(__name__)\n\n    def generate_3dm(self, dxf_file_path, rhino_path):\n        \"\"\"\n        This method converts a DXF file to 3DM format.\n        The original DXF file is preserved.\n\n        :param dxf_file_path: Path to the original DXF file\n        :param rhino_path: Path to save the converted 3DM file\n        :return: Path to the converted 3DM file if successful, otherwise None\n        \"\"\"\n        # Validate input file exists\n        if not os.path.exists(dxf_file_path):\n            self.logger.error(f\"DXF file not found: {dxf_file_path}\")\n            return None\n\n        # Ensure output directory exists\n        output_dir = os.path.dirname(rhino_path)\n        if output_dir and not os.path.exists(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n        try:\n            # Analyze the reference 3DM file structure if provided\n            reference_structure = self._analyze_reference_structure()\n\n            # Pass the reference structure to guide the conversion process\n            return self._convert_dxf_to_3dm(dxf_file_path, rhino_path, reference_structure)\n        except Exception as ex:\n            self.logger.error(f\"Error processing DXF to 3DM: {ex}\")\n            return None\n\n    def _analyze_reference_structure(self):\n        \"\"\"\n        Analyze a reference 3DM file to guide the conversion process.\n\n        :return: Dictionary with reference structure information\n        \"\"\"\n        # This method can be expanded to analyze any reference 3DM files\n        # For now, we'll return a static structure based on our analysis\n        return {\n            \"units\": \"meters\",\n            \"coordinate_format\": \"fixed_point_2_decimal\",\n            \"mesh_count\": 6,\n            \"materials\": [\"M_3\", \"M_18\", \"M_2\"],\n            \"coordinate_ranges\": {\n                \"x\": [33.3, 33.3 * 1.1],  # Example range based on reference file\n                \"y\": [33.3, 33.3 * 1.1],\n                \"z\": [33.3, 33.3 * 1.1],\n            },\n        }\n\n    def _convert_dxf_to_3dm(self, dxf_file_path, rhino_path, reference_structure=None):\n        \"\"\"\n        Converts a DXF file to 3DM format.\n\n        :param dxf_file_path: Path to the DXF file\n        :param rhino_path: Path to save the converted 3DM file\n        :param reference_structure: Optional structure information to guide conversion\n        :return: Path to the 3DM file\n        \"\"\"\n        # Create a new 3dm file\n        model = rhino3dm.File3dm()\n        dxf = None\n\n        try:\n            # Load the DXF file with careful error handling\n            try:\n                dxf = ezdxf.readfile(dxf_file_path)\n            except IOError as e:\n                self.logger.error(f\"Cannot open DXF file: {e}\")\n                raise ValueError(f\"Cannot open DXF file: {e}\")\n            except ezdxf.DXFStructureError as e:\n                self.logger.error(f\"Invalid or corrupted DXF file: {e}\")\n                raise ValueError(f\"Invalid or corrupted DXF file: {e}\")\n\n            # Set document properties from DXF if available\n            if hasattr(dxf, \"header\"):\n                # Try to set some basic document properties\n                try:\n                    if \"$FINGNAME\" in dxf.header:\n                        model.Notes = f\"Converted from: {dxf.header['$FINGNAME']}\"\n\n                    # Add any other relevant metadata\n                except Exception as e:\n                    self.logger.warning(f\"Error setting document properties: {e}\")\n\n            # Define a 90-degree rotation matrix around the X-axis (similar to OBJ conversion)\n            rotation_matrix = np.array([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n\n            # First pass: Process blocks and store them for later reference\n            self.logger.info(\"Processing block definitions\")\n            block_entities = {}\n\n            if hasattr(dxf, \"blocks\"):\n                for block in dxf.blocks:\n                    # Skip special blocks like *Model_Space\n                    if block.name.startswith(\"*\"):\n                        continue\n\n                    # Store entities for this block\n                    block_entities[block.name] = list(block)\n                    self.logger.info(f\"Stored block '{block.name}' with {len(block_entities[block.name])} entities\")\n\n            # Get the modelspace\n            msp = dxf.modelspace()\n\n            # Keep track of stats for reporting\n            entity_counts = {}\n\n            # Process DXF entities in batches to improve memory efficiency\n            batch_size = 1000  # Adjust based on your typical file size\n            entity_batch = []\n\n            # For very large files, this prevents loading everything into memory at once\n            for entity in msp:\n                entity_type = entity.dxftype()\n                entity_counts[entity_type] = entity_counts.get(entity_type, 0) + 1\n\n                entity_batch.append(entity)\n\n                # Process in batches\n                if len(entity_batch) >= batch_size:\n                    self._process_entity_batch(entity_batch, model, rotation_matrix, block_entities)\n                    entity_batch = []  # Clear batch after processing\n\n            # Process any remaining entities\n            if entity_batch:\n                self._process_entity_batch(entity_batch, model, rotation_matrix, block_entities)\n\n            # Log processing statistics\n            self.logger.info(f\"Processed DXF entities: {entity_counts}\")\n\n            # Save the 3dm file\n            model.Write(rhino_path)\n            return rhino_path\n\n        finally:\n            # Clean up resources\n            if dxf is not None:\n                dxf = None  # Help garbage collection\n\n    def _process_entity_batch(self, entities, model, rotation_matrix, block_entities=None):\n        \"\"\"\n        Process a batch of DXF entities to improve memory efficiency.\n\n        :param entities: List of DXF entities\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        :param block_entities: Dictionary of block entities for INSERT handling\n        \"\"\"\n        if block_entities is None:\n            block_entities = {}\n\n        for entity in entities:\n            try:\n                entity_type = entity.dxftype()\n\n                # Handle different entity types\n                if entity_type == \"LINE\":\n                    self._add_line_to_model(entity, model, rotation_matrix)\n                elif entity_type == \"CIRCLE\":\n                    self._add_circle_to_model(entity, model, rotation_matrix)\n                elif entity_type == \"ARC\":\n                    self._add_arc_to_model(entity, model, rotation_matrix)\n                elif entity_type in (\"POLYLINE\", \"LWPOLYLINE\"):\n                    self._add_polyline_to_model(entity, model, rotation_matrix)\n                elif entity_type == \"3DFACE\":\n                    self._add_3dface_to_model(entity, model, rotation_matrix)\n                elif entity_type == \"MESH\":\n                    self._add_mesh_to_model(entity, model, rotation_matrix)\n                elif entity_type == \"POINT\":\n                    # Add point handling\n                    point = self._rotate_point(entity.dxf.location, rotation_matrix)\n                    model.Objects.AddPoint(rhino3dm.Point3d(point[0], point[1], point[2]))\n                elif entity_type == \"ELLIPSE\":\n                    # Basic ellipse support\n                    self._handle_ellipse(entity, model, rotation_matrix)\n                elif entity_type == \"SPLINE\":\n                    # Basic spline support\n                    self._handle_spline(entity, model, rotation_matrix)\n                elif entity_type == \"INSERT\":\n                    # Handle block insertions\n                    self._add_insert_to_model(entity, model, rotation_matrix, block_entities)\n                # Additional entity types can be added as needed\n\n            except Exception as e:\n                # Log error but continue processing other entities\n                self.logger.warning(f\"Error processing {entity.dxftype()} entity: {e}\")\n\n    def _add_insert_to_model(self, entity, model, rotation_matrix, block_entities):\n        \"\"\"\n        Handle INSERT entity by instantiating the referenced block.\n\n        :param entity: DXF INSERT entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        :param block_entities: Dictionary of block entities\n        \"\"\"\n        try:\n            # Get block name\n            block_name = entity.dxf.name\n\n            # Check if we have this block\n            if block_name not in block_entities:\n                self.logger.warning(f\"Block '{block_name}' referenced by INSERT not found\")\n                return\n\n            # Get transformation parameters\n            position = self._rotate_point(entity.dxf.insert, rotation_matrix)\n\n            # Get scaling factors (default to 1 if not present)\n            scale_x = getattr(entity.dxf, \"xscale\", 1.0)\n            scale_y = getattr(entity.dxf, \"yscale\", 1.0)\n            scale_z = getattr(entity.dxf, \"zscale\", 1.0)\n\n            # Get rotation angle (default to 0 if not present)\n            rotation_z = getattr(entity.dxf, \"rotation\", 0.0)\n\n            # Get entities from the block\n            block_entity_list = block_entities[block_name]\n\n            # Process each entity in the block\n            for block_entity in block_entity_list:\n                try:\n                    # Skip non-graphical entities\n                    if not hasattr(block_entity, \"dxftype\"):\n                        continue\n\n                    # Create a copy of the entity with transformation applied\n                    entity_type = block_entity.dxftype()\n\n                    # Apply transformations based on entity type\n                    if entity_type == \"3DFACE\":\n                        self._add_transformed_3dface(\n                            block_entity,\n                            model,\n                            rotation_matrix,\n                            position,\n                            (scale_x, scale_y, scale_z),\n                            rotation_z,\n                        )\n                    elif entity_type == \"LINE\":\n                        self._add_transformed_line(\n                            block_entity,\n                            model,\n                            rotation_matrix,\n                            position,\n                            (scale_x, scale_y, scale_z),\n                            rotation_z,\n                        )\n                    # Add more entity types as needed\n\n                except Exception as e:\n                    self.logger.warning(f\"Error processing block entity {block_entity.dxftype()}: {e}\")\n\n        except Exception as e:\n            self.logger.warning(f\"Error processing INSERT entity: {e}\")\n\n    def _add_transformed_3dface(self, entity, model, rotation_matrix, position, scale, rotation_z):\n        \"\"\"\n        Add a transformed 3DFACE entity from a block to the model.\n\n        :param entity: DXF 3DFACE entity from a block\n        :param model: 3DM model\n        :param rotation_matrix: Global rotation matrix\n        :param position: Position of the INSERT\n        :param scale: Scale factors (x, y, z)\n        :param rotation_z: Rotation angle around Z axis in degrees\n        \"\"\"\n        # Create a mesh to represent the 3DFACE\n        mesh = rhino3dm.Mesh()\n\n        # Get the four vertices of the 3DFACE\n        p1 = self._transform_point(entity.dxf.vtx0, rotation_matrix, position, scale, rotation_z)\n        p2 = self._transform_point(entity.dxf.vtx1, rotation_matrix, position, scale, rotation_z)\n        p3 = self._transform_point(entity.dxf.vtx2, rotation_matrix, position, scale, rotation_z)\n        p4 = self._transform_point(entity.dxf.vtx3, rotation_matrix, position, scale, rotation_z)\n\n        # Add vertices to the mesh\n        mesh.Vertices.Add(p1[0], p1[1], p1[2])\n        mesh.Vertices.Add(p2[0], p2[1], p2[2])\n        mesh.Vertices.Add(p3[0], p3[1], p3[2])\n\n        # Check if this is a triangular or quadrilateral face\n        if not np.array_equal(entity.dxf.vtx2, entity.dxf.vtx3):\n            mesh.Vertices.Add(p4[0], p4[1], p4[2])\n            mesh.Faces.AddFace(0, 1, 2, 3)\n        else:\n            mesh.Faces.AddFace(0, 1, 2)\n\n        # Get material info if available\n        material_name = self._get_entity_material(entity)\n        if material_name:\n            mesh.SetUserString(\"material_name\", material_name)\n\n        model.Objects.AddMesh(mesh)\n\n    def _get_entity_material(self, entity):\n        \"\"\"\n        Get material name from entity if available.\n\n        :param entity: DXF entity\n        :return: Material name or None\n        \"\"\"\n        # Check common attributes where material information might be stored\n        if hasattr(entity, \"dxf\") and hasattr(entity.dxf, \"layer\"):\n            return entity.dxf.layer\n        return None\n\n    def _add_transformed_line(self, entity, model, rotation_matrix, position, scale, rotation_z):\n        \"\"\"\n        Add a transformed LINE entity from a block to the model.\n\n        :param entity: DXF LINE entity from a block\n        :param model: 3DM model\n        :param rotation_matrix: Global rotation matrix\n        :param position: Position of the INSERT\n        :param scale: Scale factors (x, y, z)\n        :param rotation_z: Rotation angle around Z axis in degrees\n        \"\"\"\n        # Get the start and end points of the line\n        start_point = self._transform_point(entity.dxf.start, rotation_matrix, position, scale, rotation_z)\n        end_point = self._transform_point(entity.dxf.end, rotation_matrix, position, scale, rotation_z)\n\n        # Create a line object\n        line = rhino3dm.Line(\n            rhino3dm.Point3d(start_point[0], start_point[1], start_point[2]),\n            rhino3dm.Point3d(end_point[0], end_point[1], end_point[2]),\n        )\n\n        model.Objects.AddLine(line)\n\n    def _transform_point(self, point, rotation_matrix, position, scale, rotation_z):\n        \"\"\"\n        Apply a full transformation to a point including:\n        - Scaling\n        - Z-axis rotation\n        - Translation\n        - Global rotation matrix\n\n        :param point: Original point\n        :param rotation_matrix: Global rotation matrix\n        :param position: Translation offset\n        :param scale: Scale factors (x, y, z)\n        :param rotation_z: Rotation angle around Z axis in degrees\n        :return: Transformed point as numpy array\n        \"\"\"\n        # Convert point to proper format\n        point_array = self._point_to_array(point)\n\n        # Apply scaling\n        scaled_point = np.array(\n            [\n                point_array[0] * scale[0],\n                point_array[1] * scale[1],\n                point_array[2] * scale[2],\n            ]\n        )\n\n        # Apply Z rotation if needed\n        if rotation_z != 0:\n            rad_angle = np.radians(rotation_z)\n            cos_angle = np.cos(rad_angle)\n            sin_angle = np.sin(rad_angle)\n\n            # Create rotation matrix for Z axis\n            z_rotation = np.array([[cos_angle, -sin_angle, 0], [sin_angle, cos_angle, 0], [0, 0, 1]])\n\n            scaled_point = np.dot(z_rotation, scaled_point)\n\n        # Apply translation (adding the INSERT position)\n        translated_point = scaled_point + np.array([position[0], position[1], position[2]])\n\n        # Apply global rotation matrix\n        transformed = np.dot(rotation_matrix, translated_point)\n\n        # Apply any additional transformations needed to match the expected output format\n        # For example, scaling to match units, rounding to specific decimal places, etc.\n        normalized = [\n            round(transformed[0] * 100) / 100,  # Scale and round X\n            round(transformed[1] * 100) / 100,  # Scale and round Y\n            round(transformed[2] * 100) / 100,  # Scale and round Z\n        ]\n\n        return normalized\n\n    def _point_to_array(self, point):\n        \"\"\"\n        Convert a point in any format to a numpy array.\n\n        :param point: Point in any format\n        :return: Numpy array [x, y, z]\n        \"\"\"\n        # Handle different point formats\n        if hasattr(point, \"x\") and hasattr(point, \"y\") and hasattr(point, \"z\"):\n            # It's likely a Vector or Point object with x, y, z attributes\n            return np.array([point.x, point.y, point.z])\n        elif hasattr(point, \"x\") and hasattr(point, \"y\"):\n            # It's a 2D point object\n            return np.array([point.x, point.y, 0])\n        elif isinstance(point, (list, tuple)):\n            # It's a list or tuple\n            if len(point) == 2:  # 2D point\n                return np.array([point[0], point[1], 0])\n            else:  # 3D point\n                return np.array([point[0], point[1], point[2]])\n        else:\n            # Try to convert to numpy array\n            try:\n                point_array = np.array(point)\n                if point_array.size == 2:\n                    return np.append(point_array, 0)  # Add z=0 for 2D points\n                return point_array\n            except:  # noqa: E722\n                # Last resort fallback\n                self.logger.warning(f\"Could not parse point format: {type(point)}\")\n                return np.array([0, 0, 0])  # Return origin as fallback\n\n    def _handle_ellipse(self, entity, model, rotation_matrix):\n        \"\"\"\n        Handle ELLIPSE entity - basic implementation.\n\n        :param entity: DXF ELLIPSE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        try:\n            # Get ellipse parameters\n            center = self._rotate_point(entity.dxf.center, rotation_matrix)\n            major_axis = np.array(entity.dxf.major_axis)\n\n            # Calculate the major radius (length of major axis)\n            major_radius = np.linalg.norm(major_axis)\n\n            # Use a simplified circle if the conversion is too complex\n            plane = rhino3dm.Plane(\n                rhino3dm.Point3d(center[0], center[1], center[2]),\n                rhino3dm.Vector3d(0, 0, 1),\n            )\n\n            circle = rhino3dm.Circle(plane, major_radius)\n            model.Objects.AddCircle(circle)\n\n        except Exception as e:\n            self.logger.warning(f\"Error processing ellipse: {e}\")\n\n    def _handle_spline(self, entity, model, rotation_matrix):\n        \"\"\"\n        Handle SPLINE entity - basic implementation.\n\n        :param entity: DXF SPLINE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        try:\n            # Get control points\n            control_points = []\n            for point in entity.control_points:\n                rotated_point = self._rotate_point(point, rotation_matrix)\n                control_points.append(rhino3dm.Point3d(rotated_point[0], rotated_point[1], rotated_point[2]))\n\n            # If we have at least 2 control points, create a polyline as a simple representation\n            if len(control_points) >= 2:\n                # For simplicity, convert to polyline (a more accurate NURBS conversion would be complex)\n                polyline = rhino3dm.Polyline()\n                for point in control_points:\n                    polyline.Add(point.X, point.Y, point.Z)\n\n                model.Objects.AddPolyline(polyline)\n        except Exception as e:\n            self.logger.warning(f\"Error processing spline: {e}\")\n\n    def _rotate_point(self, point, rotation_matrix):\n        \"\"\"\n        Rotate a point using the rotation matrix.\n\n        :param point: Point coordinates (can be tuple, list, Vector, etc.)\n        :param rotation_matrix: Rotation matrix\n        :return: Rotated point as numpy array\n        \"\"\"\n        # Handle different point formats\n        if hasattr(point, \"x\") and hasattr(point, \"y\") and hasattr(point, \"z\"):\n            # It's likely a Vector or Point object with x, y, z attributes\n            point_array = np.array([point.x, point.y, point.z])\n        elif hasattr(point, \"x\") and hasattr(point, \"y\"):\n            # It's a 2D point object\n            point_array = np.array([point.x, point.y, 0])\n        elif isinstance(point, (list, tuple)):\n            # It's a list or tuple\n            if len(point) == 2:  # 2D point\n                point_array = np.array([point[0], point[1], 0])\n            else:  # 3D point\n                point_array = np.array([point[0], point[1], point[2]])\n        else:\n            # Unknown format, try to convert to numpy array and handle\n            try:\n                point_array = np.array(point)\n                if point_array.size == 2:\n                    point_array = np.append(point_array, 0)  # Add z=0 for 2D points\n            except:  # noqa: E722\n                # Last resort fallback\n                self.logger.warning(f\"Could not parse point format: {type(point)}\")\n                return np.array([0, 0, 0])  # Return origin as fallback\n\n        # Apply rotation\n        return np.dot(rotation_matrix, point_array)\n\n    def _add_line_to_model(self, entity, model, rotation_matrix):\n        \"\"\"\n        Add a LINE entity to the 3DM model.\n\n        :param entity: DXF LINE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        start_point = self._rotate_point(entity.dxf.start, rotation_matrix)\n        end_point = self._rotate_point(entity.dxf.end, rotation_matrix)\n\n        line = rhino3dm.Line(\n            rhino3dm.Point3d(start_point[0], start_point[1], start_point[2]),\n            rhino3dm.Point3d(end_point[0], end_point[1], end_point[2]),\n        )\n\n        model.Objects.AddLine(line)\n\n    def _add_circle_to_model(self, entity, model, rotation_matrix):\n        \"\"\"\n        Add a CIRCLE entity to the 3DM model.\n\n        :param entity: DXF CIRCLE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        center = self._rotate_point(entity.dxf.center, rotation_matrix)\n        radius = entity.dxf.radius\n\n        # Create a circle using a plane and radius\n        plane = rhino3dm.Plane(\n            rhino3dm.Point3d(center[0], center[1], center[2]),\n            rhino3dm.Vector3d(0, 0, 1),  # Normal vector for the plane\n        )\n\n        circle = rhino3dm.Circle(plane, radius)\n        model.Objects.AddCircle(circle)\n\n    def _add_arc_to_model(self, entity, model, rotation_matrix):\n        \"\"\"\n        Add an ARC entity to the 3DM model.\n\n        :param entity: DXF ARC entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        center = self._rotate_point(entity.dxf.center, rotation_matrix)\n        radius = entity.dxf.radius\n        start_angle = entity.dxf.start_angle * (np.pi / 180.0)  # Convert to radians\n        end_angle = entity.dxf.end_angle * (np.pi / 180.0)  # Convert to radians\n\n        # Handle angle progression (DXF uses CCW, ensure proper mapping)\n        if end_angle < start_angle:\n            end_angle += 2 * np.pi\n\n        # Create points for start, end and middle of the arc\n        start_point = np.array(\n            [\n                center[0] + radius * np.cos(start_angle),\n                center[1] + radius * np.sin(start_angle),\n                center[2],\n            ]\n        )\n\n        end_point = np.array(\n            [\n                center[0] + radius * np.cos(end_angle),\n                center[1] + radius * np.sin(end_angle),\n                center[2],\n            ]\n        )\n\n        # Calculate a point in the middle of the arc for reliable arc creation\n        mid_angle = (start_angle + end_angle) / 2\n        mid_point = np.array(\n            [\n                center[0] + radius * np.cos(mid_angle),\n                center[1] + radius * np.sin(mid_angle),\n                center[2],\n            ]\n        )\n\n        # Create the arc using 3 points\n        arc = rhino3dm.Arc(\n            rhino3dm.Point3d(start_point[0], start_point[1], start_point[2]),\n            rhino3dm.Point3d(mid_point[0], mid_point[1], mid_point[2]),\n            rhino3dm.Point3d(end_point[0], end_point[1], end_point[2]),\n        )\n\n        model.Objects.AddArc(arc)\n\n    def _add_polyline_to_model(self, entity, model, rotation_matrix):\n        \"\"\"\n        Add a POLYLINE or LWPOLYLINE entity to the 3DM model.\n\n        :param entity: DXF POLYLINE or LWPOLYLINE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        # For LWPOLYLINE with bulges (curved segments), we need special handling\n        if entity.dxftype() == \"LWPOLYLINE\" and any(bulge != 0 for _, _, _, bulge, _ in entity.lwpoints):\n            self._add_lwpolyline_with_bulges(entity, model, rotation_matrix)\n            return\n\n        # Create a polyline for straight segments\n        polyline = rhino3dm.Polyline()\n\n        # Get vertices based on entity type\n        if entity.dxftype() == \"LWPOLYLINE\":\n            # LWPOLYLINE has points as a sequence of (x, y) coordinates\n            vertices = list(entity.vertices())\n            for vertex in vertices:\n                point = self._rotate_point((vertex[0], vertex[1]), rotation_matrix)\n                polyline.Add(point[0], point[1], point[2])\n\n            # Close the polyline if it's closed\n            if entity.closed:  # Using the property directly for clarity\n                polyline.Add(polyline[0])\n        else:  # Regular POLYLINE\n            for vertex in entity.vertices:\n                point = self._rotate_point(\n                    (\n                        vertex.dxf.location.x,\n                        vertex.dxf.location.y,\n                        vertex.dxf.location.z,\n                    ),\n                    rotation_matrix,\n                )\n                polyline.Add(point[0], point[1], point[2])\n\n            # Close the polyline if it's closed\n            if entity.is_closed:\n                polyline.Add(polyline[0])\n\n        # Add the polyline to the model if it has at least 2 points\n        if polyline.Count > 1:\n            model.Objects.AddPolyline(polyline)\n\n    def _add_lwpolyline_with_bulges(self, entity, model, rotation_matrix):\n        \"\"\"\n        Add an LWPOLYLINE with bulges (curved segments) to the 3DM model.\n\n        :param entity: DXF LWPOLYLINE entity\n        :param model: 3DM model\n        :param rotation_matrix: Rotation matrix\n        \"\"\"\n        # Get all points with their bulges\n        points = list(entity.lwpoints)\n        count = len(points)\n\n        if count < 2:\n            return\n\n        # Process each segment\n        for i in range(count):\n            # Get current point and next point (accounting for closed polylines)\n            curr_idx = i\n            next_idx = (i + 1) % count if entity.closed else (i + 1)\n\n            # If we're at the last point and the polyline is not closed, break\n            if next_idx >= count:\n                break\n\n            # Extract points and bulge\n            x1, y1, _, bulge, _ = points[curr_idx]\n            x2, y2, _, _, _ = points[next_idx]\n\n            p1 = self._rotate_point((x1, y1), rotation_matrix)\n            p2 = self._rotate_point((x2, y2), rotation_matrix)\n\n            # Create a straight line if bulge is zero\n            if bulge == 0:\n                line = rhino3dm.Line(\n                    rhino3dm.Point3d(p1[0], p1[1], p1[2]),\n                    rhino3dm.Point3d(p2[0], p2[1], p2[2]),\n                )\n                model.Objects.AddLine(line)\n            else:\n                # Convert bulge to arc parameters\n                # Bulge is the tangent of 1/4 of the included angle\n                # angle = 4 * np.arctan(bulge)\n\n                # Calculate center and radius\n                dx, dy = x2 - x1, y2 - y1\n                dist = np.sqrt(dx * dx + dy * dy)\n\n                if abs(dist) < 1e-10:\n                    continue  # Skip degenerate segments\n\n                # Calculate perpendicular distance from chord to arc center\n                h = (bulge * dist) / 2\n\n                # Calculate center of arc\n                cx = (x1 + x2) / 2 - h * (dy / dist)\n                cy = (y1 + y2) / 2 + h * (dx / dist)\n\n                # Calculate radius\n                radius = np.sqrt((dist / 2) ** 2 + h**2)\n\n                # Convert to 3D points and center\n                # center = self._rotate_point((cx, cy), rotation_matrix)\n\n                # Calculate start and end angles\n                start_angle = np.arctan2(y1 - cy, x1 - cx)\n                end_angle = np.arctan2(y2 - cy, x2 - cx)\n\n                # Ensure angles are properly ordered based on bulge sign\n                if bulge < 0:\n                    # Swap for clockwise\n                    start_angle, end_angle = end_angle, start_angle  # Fixed swap syntax\n\n                # Calculate a middle point for the arc\n                mid_angle = (start_angle + end_angle) / 2\n                if bulge < 0 and end_angle > start_angle:\n                    mid_angle -= np.pi\n                elif bulge > 0 and start_angle > end_angle:\n                    mid_angle += np.pi\n\n                mx = cx + radius * np.cos(mid_angle)\n                my = cy + radius * np.sin(mid_angle)\n                mid_point = self._rotate_point((mx, my), rotation_matrix)\n\n                # Create the arc\n                arc = rhino3dm.Arc(\n                    rhino3dm.Point3d(p1[0], p1[1], p1[2]),\n                    rhino3dm.Point3d(mid_point[0], mid_point[1], mid_point[2]),\n                    rhino3dm.Point3d(p2[0], p2[1], p2[2]),\n                )\n                model.Objects.AddArc(arc)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}