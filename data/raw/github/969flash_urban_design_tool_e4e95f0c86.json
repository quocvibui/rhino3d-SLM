{
  "source_url": "https://github.com/969flash/urban_design_tool/blob/0a891333039b4d06213c16f2d4b6bb12b02f2ad1/src/utils.py",
  "repo": "969flash/urban_design_tool",
  "repo_stars": 0,
  "repo_description": "urban_design_tool",
  "license": "unknown",
  "filepath": "src/utils.py",
  "instruction": "프로젝트 전반에서 사용하는 Rhino/Grasshopper 공용 유틸리티입니다.",
  "code": "# -*- coding: utf-8 -*-\n\"\"\"\n프로젝트 전반에서 사용하는 Rhino/Grasshopper 공용 유틸리티입니다.\n\n이 모듈은 특정 프로젝트 영역에 종속되지 않도록 설계되었습니다. 함수들은 '어디서 쓰이는지'가 아니라\n'무엇을 하는지' 기준으로 분류되어, 어느 위치에서든 자유롭게 가져다 쓸 수 있습니다.\n\n구성\n- 코어 지오메트리: 거리/벡터/정점/기본 커브 연산\n- 고급 지오메트리: 교차, 겹침, 영역 포함 관계\n- 단순화: 폴리라인 계열 세그먼트 감소 기반 단순화\n- 변환/윤곽: Brep 이동, 윤곽/법선 헬퍼\n- 레이어/문서: 레이어 조회/생성/정리\n- 서피스/Brep: Extrude, Face 샘플링, 평면 Face 재구성\n\"\"\"\nfrom typing import List, Tuple, Any, Optional, Union\nimport math\nimport functools\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\nfrom constants import TOL, ROUNDING_PRECISION, BIGNUM, OP_TOL, CLIPPER_TOL\n\n# Type Hinting\nCurveLike = Union[geo.Curve, List[geo.Curve]]\n\n\ndef convert_io_to_list(func):\n    \"\"\"단일 Curve 인/아웃을 리스트 형태로 표준화하는 데코레이터입니다.\n\n    함수가 단일 Curve와 Curve 리스트를 모두 받아야 하고,\n    반환도 일관된 리스트 형태로 맞추고 싶을 때 사용하세요.\n    커브가 아닌 값은 그대로 통과합니다.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\n# ==============================================================================\n# 1. 코어 지오메트리 유틸리티 (Core Geometry Utilities)\n# ==============================================================================\n\n\ndef get_distance_between_points(point_a: geo.Point3d, point_b: geo.Point3d) -> float:\n    \"\"\"두 점 사이의 거리를 계산합니다.\"\"\"\n    return round(point_a.DistanceTo(point_b), ROUNDING_PRECISION)\n\n\ndef get_distance_between_point_and_curve(point: geo.Point3d, curve: geo.Curve) -> float:\n    \"\"\"점과 커브 사이의 최단 거리를 계산합니다.\"\"\"\n    _, param = curve.ClosestPoint(point)\n    dist = point.DistanceTo(curve.PointAt(param))\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_distance_between_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브 사이의 최소 거리를 계산합니다.\"\"\"\n    _, pt_a, pt_b = curve_a.ClosestPoints(curve_b)\n    dist = pt_a.DistanceTo(pt_b)\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_vector_from_pts(pt_a: geo.Point3d, pt_b: geo.Point3d) -> geo.Vector3d:\n    \"\"\"두 점 사이의 벡터를 계산합니다.\"\"\"\n    return geo.Vector3d(pt_b.X - pt_a.X, pt_b.Y - pt_a.Y, pt_b.Z - pt_a.Z)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 모든 정점(Vertex)들을 추출합니다.\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef move_curve(curve: geo.Curve, vector: geo.Vector3d) -> geo.Curve:\n    \"\"\"커브를 주어진 벡터만큼 이동시킨 복사본을 반환합니다.\"\"\"\n    moved_curve = curve.Duplicate()\n    moved_curve.Translate(vector)\n    return moved_curve\n\n\ndef explode_curve(curve: geo.Curve) -> List[geo.Curve]:\n    \"\"\"커브를 분할하여 개별 세그먼트 리스트로 반환합니다.\"\"\"\n    if not curve:\n        return []\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n\n    segments = []\n    if curve.SpanCount > 0:\n        for i in range(curve.SpanCount):\n            sub_curve = curve.Trim(curve.SpanDomain(i))\n            if sub_curve:\n                segments.append(sub_curve)\n    elif curve.IsLinear():\n        segments.append(curve.Duplicate())\n\n    return segments\n\n\ndef get_pts_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"커브를 주어진 길이로 나누는 점들을 구합니다.\"\"\"\n    params = crv.DivideByLength(length, include_start)\n    if not params:\n        return []\n    return [crv.PointAt(param) for param in params]\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"영역 커브의 면적을 계산합니다.\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, ROUNDING_PRECISION)\n\n\n# ==============================================================================\n# 2. 고급 지오메트리 연산 (Advanced Geometry Operations)\n# ==============================================================================\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"두 커브가 교차하는지 여부를 확인합니다.\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"두 커브 사이의 교차점을 계산합니다.\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections if event.IsPointAValid]\n\n\ndef has_region_intersection(\n    region_a: geo.Curve, region_b: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"두 닫힌 영역 커브가 교차(겹침 포함)하는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region_a, region_b, geo.Plane.WorldXY, tol\n    )\n    return relationship != geo.RegionContainment.Disjoint\n\n\ndef is_region_inside(\n    inner_region: geo.Curve, outer_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"내부 영역이 외부 영역에 포함되는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        inner_region, outer_region, geo.Plane.WorldXY, tol\n    )\n\n    return relationship == geo.RegionContainment.AInsideB\n\n\ndef get_overlapped_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"두 커브가 겹치는 구간의 커브들을 반환합니다.\"\"\"\n    if not has_intersection(curve_a, curve_b) or not ghcomp:\n        return []\n\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    explode_result = ghcomp.Explode(curve_a, True)\n    explode_points = (\n        explode_result.vertices + intersection_points\n        if explode_result\n        else intersection_points\n    )\n\n    if not explode_points:\n        return []\n\n    params = [ghcomp.CurveClosestPoint(pt, curve_a).parameter for pt in explode_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [\n        seg for seg in shatter_result if has_intersection(seg, curve_b)\n    ]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브가 겹치는 총 길이를 계산합니다.\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\nclass Offset:\n    class _OffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _OffsetResult:\n        \"\"\"Clipper 컴포넌트를 이용한 폴리라인 오프셋.\n\n        입력 폴리라인(유사) 커브를 2D 평면에서 오프셋하고,\n        바깥 윤곽(contour)과 내부 공백(holes)을 각각의 리스트로 반환합니다.\n\n        Args:\n            crvs (List[geo.Curve]): 오프셋할(폴리라인 호환) 커브들.\n            dists (List[float]): 오프셋 거리. 양수는 바깥 윤곽을 생성하며,\n                대응되는 안쪽 결과는 holes에 위치합니다.\n            miter (int): 날카로운 코너를 위한 마이터 제한.\n            closed_fillet (int): 닫힌 형태의 코너 스타일\n                (0=round, 1=square, 2=miter).\n            open_fillet (int): 열린 세그먼트의 끝 처리\n                (0=round, 1=square, 2=butt).\n            tol (float): 연산에 사용할 공차.\n\n        Returns:\n            Offset._OffsetResult: 다음 필드를 포함합니다.\n                - contour: List[Curve] 바깥쪽 오프셋 결과\n                - holes: List[Curve] 안쪽 오프셋 결과\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._OffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    result = Offset().polyline_offset(regions, dist, miter).holes\n\n    if not result:\n        return []\n\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    if len(result) < 2:\n        return result\n\n    filtered = [\n        crv for crv in result if any(is_region_inside(crv, reg) for reg in regions)\n    ]\n    return filtered\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef simplify_regions_with_offset(\n    regions: List[geo.Curve], dist: float, miter: int = BIGNUM\n) -> Union[List[geo.Curve], geo.Curve]:\n    \"\"\"영역 커브를 안팎으로 offset 하여 단순화한다.\n    이로인해 dist 미만의 폭을 가진 영역이 사라진다.\n    Args:\n        region: 단순화할 대상 커브\n        dist: 안팎으로 offset할 거리\n\n    Returns:\n        단순화된 커브 리스트\n    \"\"\"\n    if not regions:\n        return []\n\n    if dist <= 0.0:\n        return regions\n\n    inner = offset_regions_inward(regions, dist * 0.5, miter)\n    if not inner:\n        return []\n\n    outer = offset_regions_outward(inner, dist * 0.5, miter)\n\n    return outer\n\n\n# ==============================================================================\n# 2.1 폴리라인 기반 세그먼트 감소형 Simplify (전처리 친화)\n# ==============================================================================\n\n\ndef simplify_crv_by_reducing_segments(\n    crv: geo.Curve,\n    tol: float = TOL,\n    angle_tol: Optional[float] = None,\n) -> geo.Curve:\n    \"\"\"MergeColinearSegments + ReduceSegments 기반 단순화.\n\n    - colinear(동일선상) 세그먼트 병합 후, 길이/변화가 tol 이내인 세그먼트 제거로 안정화.\n    - 닫힌 커브의 시작/끝 점 처리 보정 포함.\n    - 실패/과도 단순화 시 원본 반환.\n    \"\"\"\n    if crv is None:\n        return crv\n\n    if angle_tol is None:\n        # 가능하면 constants.ANGLE_TOL 사용, 없으면 약 1도(라디안)\n        try:\n            from constants import ANGLE_TOL as _ANGLE_TOL  # type: ignore\n\n            angle_tol = float(_ANGLE_TOL)\n        except Exception:\n            angle_tol = math.radians(1.0)\n\n    # vertices 기반 polyline 작성\n    pts = get_vertices(crv)\n    if not pts:\n        return crv\n    if crv.IsClosed:\n        pts.append(pts[0])\n\n    pl = geo.Polyline(pts)\n\n    # colinear 병합 및 세그먼트 감소\n    try:\n        pl.MergeColinearSegments(angle_tol, True)\n    except Exception:\n        pass\n    try:\n        pl.ReduceSegments(tol)\n    except Exception:\n        pass\n\n    # 닫힌 커브의 시작점 보정(일부 케이스에서 ReduceSegments가 시작점에 동작하지 않음)\n    try:\n        if pl.IsClosed and pl.Count > 3:\n            pt_items = list(pl.Item)\n            pt_first = pt_items[0]\n            pt1 = pt_items[1]\n            pt2 = pt_items[pl.Count - 2]\n            if geo.Line(pt1, pt2).DistanceTo(pt_first, True) <= tol:\n                pl.RemoveAt(0)\n                pl.RemoveAt(pl.Count - 1)\n                pl.Add(pl.First)\n    except Exception:\n        pass\n\n    polycrv = pl.ToPolylineCurve()\n    if not getattr(polycrv, \"IsValid\", False):\n        # 너무 작은/불안정한 경우 원본 유지\n        return crv\n    return polycrv\n\n\ndef simplify_crvs_by_reducing_segments(\n    crvs: List[geo.Curve], tol: float = TOL, angle_tol: Optional[float] = None\n) -> List[geo.Curve]:\n    \"\"\"여러 커브에 대해 세그먼트 감소형 단순화를 일괄 적용\"\"\"\n    if not crvs:\n        return []\n    out: List[geo.Curve] = []\n    for r in crvs:\n        try:\n            out.append(simplify_crv_by_reducing_segments(r, tol, angle_tol))\n        except Exception:\n            out.append(r)\n    return out\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\nclass RegionBool:\n    @convert_io_to_list\n    def _polyline_boolean(\n        self, crvs0, crvs1, boolean_type=None, plane=None, tol=CLIPPER_TOL\n    ):\n        \"\"\"Clipper 기반 폴리라인 불리언 연산을 래핑하는 내부 헬퍼입니다.\n\n        boolean_type: 0=교집합, 1=합집합, 2=차집합.\n        결과 커브 리스트를 반환합니다(결과가 없으면 빈 리스트).\n        \"\"\"\n        # type: (List[geo.Curve], List[geo.Curve], int, geo.Plane, float) -> List[geo.Curve]\n        if not crvs0 or not crvs1:\n            raise ValueError(\"Check input values\")\n        result = ghcomp.ClipperComponents.PolylineBoolean(\n            crvs0, crvs1, boolean_type, plane, tol\n        )\n\n        # 결과는 IronPython.Runtime.List (파이썬 list처럼 동작) 이거나 단일 커브일 수 있으므로 통일해서 list로 반환\n        if not result:\n            return []\n\n        # IronPython.Runtime.List, System.Collections.Generic.List, tuple 등 반복 가능한 결과를 모두 처리\n        if isinstance(result, geo.Curve):\n            # 단일 커브 객체\n            result = [result]\n        else:\n            try:\n                # IEnumerable / IronPython.Runtime.List / tuple / System.Collections.Generic.List 모두 list() 시도로 통일\n                result = [crv for crv in list(result) if crv]\n            except TypeError:\n                # 반복 불가능한 단일 객체인 예외 상황\n                result = [result]\n\n        return result\n\n    def polyline_boolean_intersection(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 0, plane, tol)\n\n    def polyline_boolean_union(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 1, plane, tol)\n\n    def polyline_boolean_difference(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 2, plane, tol)\n\n\ndef get_intersection_regions(\n    regions_a: List[geo.Curve], regions_b: List[geo.Curve]\n) -> List[geo.Curve]:\n    \"\"\"두 영역 커브 리스트의 교집합을 구합니다.\n    Args:\n        regions_a: 첫 번째 영역 커브 리스트\n        regions_b: 두 번째 영역 커브 리스트\n    Returns:\n        교집합 결과 커브들\n    \"\"\"\n    if not regions_a or not regions_b:\n        return []\n    intersection_result = RegionBool().polyline_boolean_intersection(\n        regions_a, regions_b\n    )\n    return intersection_result\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"주어진 영역 커브들의 합집합을 구합니다.\n    Args:\n        regions: 합집합을 구할 영역 커브들\n    Returns:\n        합집합 결과 커브들\n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    union_result = list(geo.Curve.CreateBooleanUnion(regions, TOL))\n    if union_result:\n        return union_result\n\n    union_result = regions[0]\n    for region in regions[1:]:\n        union_result = RegionBool().polyline_boolean_union(union_result, region)\n\n    if not isinstance(union_result, list):\n        union_result = [union_result]\n\n    return union_result\n\n\n# ============================================================================\n# 3. 변환/문서/레이어 유틸리티 (project-agnostic)\n# ============================================================================\n\n\ndef move_brep(brep: geo.Brep, vector: geo.Vector3d) -> geo.Brep:\n    \"\"\"Brep를 주어진 벡터만큼 이동시킨 복사본을 반환합니다.\n\n    Args:\n        brep (geo.Brep): 이동할 원본 Brep.\n        vector (geo.Vector3d): 이동 벡터.\n\n    Returns:\n        geo.Brep: 이동된 Brep 복사본.\n    \"\"\"\n    moved_brep = brep.Duplicate()\n    moved_brep.Translate(vector)\n    return moved_brep\n\n\ndef get_outside_perp_vec_from_pt(pt: geo.Point3d, region: geo.Curve) -> geo.Vector3d:\n    \"\"\"영역 커브에서 특정 점의 외곽 방향 수직 벡터를 반환합니다.\n\n    Args:\n        pt (geo.Point3d): 기준 점.\n        region (geo.Curve): 기준 영역 커브(닫힌 커브 권장).\n\n    Returns:\n        geo.Vector3d: 외곽 방향 법선 벡터.\n    \"\"\"\n    _, param = region.ClosestPoint(pt)\n    vec_perp_outer = region.PerpendicularFrameAt(param)[1].XAxis\n    # 시계/반시계 방향에 따라 외곽 방향 부호 보정\n    if region.ClosedCurveOrientation() != geo.CurveOrientation.Clockwise:\n        vec_perp_outer = -vec_perp_outer\n    return vec_perp_outer\n\n\ndef get_outline_from_closed_brep(\n    brep: geo.Brep, plane: geo.Plane\n) -> Optional[geo.Curve]:\n    \"\"\"닫힌 폴리서페이스(Brep)의 투영 윤곽선(가장 낮은 Z)을 반환합니다.\n\n    Args:\n        brep (geo.Brep): 닫힌 Brep.\n        plane (geo.Plane): 기준 평면.\n\n    Returns:\n        Optional[geo.Curve]: 윤곽 PolylineCurve, 실패 시 None.\n    \"\"\"\n    if not isinstance(brep, geo.Brep) or not getattr(brep, \"IsSolid\", False):\n        raise TypeError(\"입력은 닫힌 Brep(폴리서페이스)만 허용됩니다.\")\n    bbox = brep.GetBoundingBox(True)\n    contour_start = geo.Point3d(0, 0, bbox.Min.Z)\n    contour_end = geo.Point3d(0, 0, bbox.Max.Z)\n    curves = geo.Brep.CreateContourCurves(\n        brep, contour_start, contour_end, (bbox.Max.Z - bbox.Min.Z)\n    )\n    if not curves:\n        return None\n\n    def _avg_z(curve: geo.Curve) -> float:\n        return curve.PointAtStart.Z\n\n    return min(curves, key=_avg_z)\n\n\n# ============================================================================\n# 4. Surface/Brep 유틸리티\n# ============================================================================\n\n\ndef extrude_srf(srf: geo.Surface, height: float) -> Optional[geo.Brep]:\n    \"\"\"Surface/Brep를 z축 방향으로 height만큼 Extrude한 Brep을 반환합니다.\n\n    Args:\n        srf (geo.Surface|geo.Brep): 입력 서피스/Brep.\n        height (float): 압출 높이.\n\n    Returns:\n        Optional[geo.Brep]: 캡 처리된 Brep. 실패 시 None.\n    \"\"\"\n    try:\n        extrusion = ghcomp.Extrude(srf, geo.Vector3d(0, 0, height))\n        return ghcomp.CapHoles(extrusion)\n    except Exception:\n        return None\n\n\ndef is_point_on_srf(pt: geo.Point3d, srf: geo.Surface, tol: float = TOL) -> bool:\n    \"\"\"점이 서피스 위에 있는지 근사적으로 판정합니다.\n\n    Args:\n        pt (geo.Point3d): 테스트할 점.\n        srf (geo.Surface): 대상 서피스.\n        tol (float): 허용 오차.\n\n    Returns:\n        bool: 서피스 위에 있으면 True.\n    \"\"\"\n    try:\n        pt_on_srf = ghcomp.SurfaceClosestPoint(pt, srf).point\n        return pt_on_srf.DistanceTo(pt) < max(0.01, tol)\n    except Exception:\n        return False\n\n\ndef get_point_inside_face(face: geo.BrepFace) -> Optional[geo.Point3d]:\n    \"\"\"BrepFace의 내부 임의 점(삼각형 무게중심 기반)을 반환합니다.\n\n    Args:\n        face (geo.BrepFace): 대상 Face.\n\n    Returns:\n        Optional[geo.Point3d]: 내부 점. 실패 시 None.\n    \"\"\"\n    try:\n        meshes = geo.Mesh.CreateFromBrep(face.Brep, geo.MeshingParameters.Default)\n        if not meshes:\n            return None\n        mesh = meshes[0]\n        idx = mesh.Faces[0]\n        p0 = mesh.Vertices[idx.A]\n        p1 = mesh.Vertices[idx.B]\n        p2 = mesh.Vertices[idx.C]\n        return geo.Point3d(\n            (p0.X + p1.X + p2.X) / 3.0,\n            (p0.Y + p1.Y + p2.Y) / 3.0,\n            (p0.Z + p1.Z + p2.Z) / 3.0,\n        )\n    except Exception:\n        return None\n\n\ndef get_layer_surfaces(doc: Rhino.RhinoDoc, parent_name: str) -> dict:\n    \"\"\"부모 레이어 아래의 각 자식 레이어에서 Surface/Brep 객체를 수집합니다.\n\n    Args:\n        doc (Rhino.RhinoDoc): Rhino 문서 객체.\n        parent_name (str): 부모 레이어 이름.\n\n    Returns:\n        dict: {자식레이어명: [Brep, ...]} 매핑.\n    \"\"\"\n    layer_dict = {}\n    for layer in doc.Layers:\n        if not layer.IsVisible:\n            continue\n        full_path = getattr(layer, \"FullPath\", layer.Name)\n        parts = full_path.split(\"::\") if full_path else []\n        if len(parts) >= 2 and parts[0] == parent_name:\n            child_name = parts[1]\n            objs = list(doc.Objects.FindByLayer(layer))\n            srfs = []\n            for obj in objs:\n                geo_obj = obj.Geometry\n                if isinstance(geo_obj, geo.Surface):\n                    srfs.append(geo.Brep.CreateFromSurface(geo_obj))\n                elif isinstance(geo_obj, geo.Brep):\n                    srfs.append(geo_obj)\n            layer_dict.setdefault(child_name, []).extend(srfs)\n    return layer_dict\n\n\ndef find_layer_by_fullpath(doc: Rhino.RhinoDoc, fullpath: str):\n    \"\"\"FullPath 문자열(예: \"Parent::Child\")로 레이어를 찾습니다.\"\"\"\n    for ly in doc.Layers:\n        fp = getattr(ly, \"FullPath\", None) or ly.Name or \"\"\n        if fp == fullpath:\n            return ly\n    return None\n\n\ndef ensure_layer(doc: Rhino.RhinoDoc, name: str, parent_id=None):\n    \"\"\"레이어가 존재하도록 보장합니다(필요 시 생성; 선택적으로 부모 아래 생성).\n\n    기존 또는 새 레이어 객체를 반환합니다.\n    \"\"\"\n    import System\n\n    if parent_id:\n        parent = doc.Layers.FindId(parent_id)\n        parent_path = getattr(parent, \"FullPath\", parent.Name) if parent else None\n        target_path = (parent_path + \"::\" + name) if parent_path else name\n        found = find_layer_by_fullpath(doc, target_path)\n        if found:\n            return found\n    else:\n        for ly in doc.Layers:\n            if ly.ParentLayerId == System.Guid.Empty and ly.Name == name:\n                return ly\n\n    layer = Rhino.DocObjects.Layer()\n    layer.Name = name\n    if parent_id:\n        layer.ParentLayerId = parent_id\n        try:\n            parent_layer = doc.Layers.FindId(parent_id)\n            if parent_layer:\n                layer.Color = parent_layer.Color\n        except Exception:\n            pass\n    idx = doc.Layers.Add(layer)\n    return doc.Layers[idx] if idx >= 0 else None\n\n\ndef clear_layer_tree(doc: Rhino.RhinoDoc, parent_name: str) -> int:\n    \"\"\"지정한 최상위 부모 레이어 트리(부모 포함) 아래의 모든 객체를 삭제합니다.\n\n    Returns:\n        int: 삭제된 객체 수.\n    \"\"\"\n    import System\n\n    parent = None\n    for ly in doc.Layers:\n        if ly.Name == parent_name and (ly.ParentLayerId == System.Guid.Empty):\n            parent = ly\n            break\n    if not parent:\n        return 0\n    parent_path = getattr(parent, \"FullPath\", None) or parent.Name or \"\"\n    deleted = 0\n    for ly in doc.Layers:\n        fp = getattr(ly, \"FullPath\", None) or ly.Name or \"\"\n        if parent_path and (fp == parent_path or fp.startswith(parent_path + \"::\")):\n            objs = doc.Objects.FindByLayer(ly) or []\n            for obj in objs:\n                if doc.Objects.Delete(obj, True):\n                    deleted += 1\n    return deleted\n\n\ndef planar_breps_from_face(\n    doc: Rhino.RhinoDoc, face: geo.BrepFace, tol: float = TOL\n) -> List[geo.Brep]:\n    \"\"\"하나의 BrepFace에서 평면 Brep들을 신뢰성 있게 재구성합니다.\n\n    전략:\n    1) 먼저 DuplicateFace(True)을 시도합니다.\n    2) 실패 시 루프를 3D 커브로 변환해 CreatePlanarBreps를 수행합니다.\n    \"\"\"\n    breps: List[geo.Brep] = []\n    try:\n        fb = face.DuplicateFace(True)\n        if fb and fb.IsValid:\n            breps.append(fb)\n    except Exception:\n        fb = None\n    if not breps:\n        try:\n            crvs: List[geo.Curve] = []\n            for loop in face.Loops:\n                try:\n                    crv = loop.To3dCurve()\n                    if crv and crv.IsClosed:\n                        crvs.append(crv)\n                except Exception:\n                    pass\n            if crvs:\n                made = geo.Brep.CreatePlanarBreps(crvs, tol)\n                if made:\n                    breps.extend([b for b in made if b and b.IsValid])\n        except Exception:\n            pass\n    return breps\n\n\n# Backward-compat alias (legacy name)\nis_region_inside_region = is_region_inside\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}