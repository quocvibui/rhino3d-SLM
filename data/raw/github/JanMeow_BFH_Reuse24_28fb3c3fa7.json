{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/demoSeries/demo_wallSystem_02032024/py/wallDefinition3.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/demoSeries/demo_wallSystem_02032024/py/wallDefinition3.py",
  "instruction": "Wall definition3",
  "code": "import Rhino.Geometry as rg\nimport ghpythonlib.treehelpers as th\nimport Grasshopper.Kernel as ghkernel\nimport ghpythonlib.components as ghcomp\nimport Grasshopper as gh\nfrom Grasshopper.Kernel.Data import GH_Path\nimport System.Array as array\nfrom Grasshopper import DataTree\n\nimport sys\nimport os\n\npath = ghenv.Component.OnPingDocument().FilePath\nparentdir = os.path.dirname(path)\ngrandparentdir = os.path.dirname(parentdir)\ndire = os.path.join(grandparentdir, 'py')\nif dire not in sys.path:\n    sys.path.append(dire)\n\n# Import modules\nimport compoundMaterial \nimport innerMaterialGenerate\nimport generateCladding\nimport normalFacade\n\n# Reload the modules\nreload(compoundMaterial)\nreload(innerMaterialGenerate)\nreload(generateCladding)\nreload(normalFacade)\n\nfrom compoundMaterial import CompoundMaterial\nfrom innerMaterialGenerate import InnerMaterialGenerate\nfrom generateCladding import GenerateCladding\nfrom normalFacade import NormalFacade\n\nimport uuid\n\n\nclass Empty:\n    def __init__(self, thickness, attrList):\n        self.materialType = \"paint\"\n        self.thickness = thickness\n        self.attrList = attrList\n        self.empty = \"empty\"\nclass ObjFromRH:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\nattr_dict = {\n'bauteil_obergruppe': 'other_' + str(uuid.uuid4()),\n'bauteil_gruner': 'other_' + str(uuid.uuid4()),\n'uuid': 'paint_uuid_' + str(uuid.uuid4()),\n'kosten': 'unknown',\n'zustand': 'unknown',\n'material': 'unknown',\n'ref_gebauede_geschoss': 'unknown',\n'breite': 'unknown',\n'hoehe': 'unknown',\n'tiefe': 'unknown',\n'flaeche': 'unknown',\n'masse': 'unknown',\n'anzahl': 'unknown',\n'foto1': 'unknown',\n'foto2': 'unknown',\n'co2': 'unknown',\n'url': 'unknown'}\nnewObj = ObjFromRH(**attr_dict)\npaintObj = Empty(0.1, newObj)\n\nclass classForOutput:\n    def __init__(self):\n        pass\n\nemptyData = classForOutput()\nemptyData.paintData= paintObj\nemptyData.identity = \"innerMaterial\"\n\n\n\n\n\ndef initialize_globals():\n    global initial_data\n    initial_data = initial_data if 'initial_data' in globals() else {}\n\ndef offset_brep(brep, distances, plane, tolerance=0.01):\n    all_offset_breps = []\n    \n    if brep.Faces.Count > 0:\n        face_normal = brep.Faces[0].NormalAt(0.5, 0.5)\n        dot_product = plane.ZAxis * face_normal\n        \n        for distance in distances:\n            # If the dot product is negative, reverse the distance to align with the plane's Z-axis\n            if dot_product >= 0:\n                adjusted_distance = distance\n            else:\n                adjusted_distance = -distance\n            \n            # adjusted_distance = distance\n            \n            offset_breps = rg.Brep.CreateOffsetBrep(brep, adjusted_distance, solid=False, extend=False, tolerance=tolerance)\n            if offset_breps[0]:  # Check if the offset operation was successful\n                all_offset_breps.append(offset_breps[0][0])\n            else:\n                print(\"Offset operation failed for distance.\")\n                all_offset_breps.append(None)\n    else:\n        print(\"Brep has no faces to determine normal.\")\n    \n    return all_offset_breps\n\ndef changePath(dataModified, dataSource):\n    pathList = dataSource.Paths\n\n    layerTree = DataTree[object]()\n    dataList = dataModified.Branches\n\n    for data, path in zip(dataList, pathList):\n        layerTree.AddRange(data, path)\n    return layerTree\n\ndef flattenBrep(oBrep):\n    # Assume oBrep has only one face, get the first face\n    face = oBrep.Faces[0]\n    \n    # Get the outer boundary of the face as a curve\n    outerLoop = face.OuterLoop.To3dCurve()\n    \n    # Fit a plane through the Brep vertices to find the best fit plane\n    vertices = [v.Location for v in oBrep.Vertices]\n    plane_success, pl = rg.Plane.FitPlaneToPoints(vertices)\n    \n    # Get the area and centroid of the Brep\n    area_mass_properties = rg.AreaMassProperties.Compute(oBrep)\n    centroid = area_mass_properties.Centroid\n    \n    # Orient the plane to have its origin at the centroid\n    orientPl = rg.Plane(pl.Origin, pl.XAxis, pl.YAxis)\n    orientPl.Origin = centroid\n    \n    # Create target plane by rotating the oriented plane around its X-axis by 90 degrees\n    targetPlane = rg.Plane(orientPl)\n    \n    # Project the outer loop curve to the target plane\n    projected_outerLoop = rg.Curve.ProjectToPlane(outerLoop, targetPlane)\n    \n    # Project any inner loops (holes) if they exist\n    projected_innerLoops = []\n    for loop in face.Loops:\n        if loop.LoopType == rg.BrepLoopType.Inner:\n            innerLoopCurve = loop.To3dCurve()\n            projected_innerLoop = rg.Curve.ProjectToPlane(innerLoopCurve, targetPlane)\n            projected_innerLoops.append(projected_innerLoop)\n    \n    # Create a planar surface from the projected outer loop\n    if projected_outerLoop.IsClosed:\n        planarFace = rg.Brep.CreatePlanarBreps([projected_outerLoop] + projected_innerLoops, 0.01)\n        if planarFace:\n            return planarFace[0] # Return the first Brep if creation was successful\n    \n    return None\n\ndef categorize(carrierList, windowList, doorList, crvList):\n    tolerDist = 100\n    carrierTree = DataTree[object]()\n    windowTree = DataTree[object]()\n    doorTree = DataTree[object]()\n    crvTree = DataTree[object]()\n\n    carrierList = [carrier.Faces[0] for carrier in carrierList]\n\n    windowTreeIndex = []\n    windowDist = []\n    if len(windowList) != 0:\n        for window in windowList:\n            if isinstance(window, rg.Brep):\n                windowGeo = window.Faces[0]\n            else:\n                windowGeo = window.geo.Faces[0]\n            \n            area_properties = rg.AreaMassProperties.Compute(windowGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n                minDist = None\n                minId = None\n                for cId, carrier in enumerate(carrierList):\n                    success, uvPU, uvPV = carrier.ClosestPoint(centroid)\n                    if success:\n                        pt = carrier.PointAt(uvPU, uvPV)\n                        dist = pt.DistanceTo(centroid)\n                        if minDist == None:\n                            minDist = dist\n                            minId = cId\n                        elif dist < minDist:\n                            minDist = dist\n                            minId = cId\n                windowTreeIndex.append(minId)\n                windowDist.append(minDist)\n\n\n    doorTreeIndex = []\n    doorDist = []\n    if len(doorList) != 0:\n        for door in doorList:\n            if isinstance(door, rg.Brep):\n                doorGeo = door.Faces[0]\n            else:\n                doorGeo = door.geo.Faces[0]\n            \n            area_properties = rg.AreaMassProperties.Compute(doorGeo)\n            if area_properties is not None:\n                centroid = area_properties.Centroid\n\n                minDist = None\n                minId = None\n                for cId, carrier in enumerate(carrierList):\n                    success, uvPU, uvPV = carrier.ClosestPoint(centroid)\n                    if success:\n                        pt = carrier.PointAt(uvPU, uvPV)\n                        dist = pt.DistanceTo(centroid)\n                        if minDist == None:\n                            minDist = dist\n                            minId = cId\n                        elif dist < minDist:\n                            minDist = dist\n                            minId = cId\n                doorTreeIndex.append(minId)\n                doorDist.append(minDist)\n\n\n    crvTreeIndex = []\n    crvDist = []\n    if len(crvList) != 0:\n        for crv in crvList:\n            if isinstance(crv, rg.Curve):\n                centroid = crv.PointAtNormalizedLength(0.5)\n                \n                minDist = None\n                minId = None\n                for cId, carrier in enumerate(carrierList):\n                    success, uvPU, uvPV = carrier.ClosestPoint(centroid)\n                    if success:\n                        pt = carrier.PointAt(uvPU, uvPV)\n                        dist = pt.DistanceTo(centroid)\n                        if minDist == None:\n                            minDist = dist\n                            minId = cId\n                        elif dist < minDist:\n                            minDist = dist\n                            minId = cId\n                crvTreeIndex.append(minId)\n                crvDist.append(minDist)\n    \n    # path = GH_Path(array[int]([0,0,self.layerId]))\n\n    for cId, carrier in enumerate(carrierList):\n        path = GH_Path(array[int]([cId]))\n        carrierTree.AddRange([carrier], path)\n    \n    for wId, window, wDist in zip(windowTreeIndex, windowList, windowDist):\n        if wDist < tolerDist:\n            path = GH_Path(array[int]([wId]))\n            windowTree.AddRange([window], path)\n    \n    for dId, door, dDist in zip(doorTreeIndex, doorList, doorDist):\n        if dDist < tolerDist:\n            path = GH_Path(array[int]([dId]))\n            doorTree.AddRange([door], path)\n\n    for dId, crv, cDist in zip(crvTreeIndex, crvList, crvDist):\n        if cDist < tolerDist:\n            path = GH_Path(array[int]([dId]))\n            crvTree.AddRange([crv], path)\n        \n    \n    return (carrierTree, windowTree, doorTree, crvTree)\n\n# Check input of this component getting value\ngoExecute = True\nif Database_collection == None:\n    ghenv.Component.AddRuntimeMessage(ghkernel.GH_RuntimeMessageLevel.Warning, \"Database_collection is empty.\")\n    goExecute = False\n# ==============================================================================\n# Check if carrier, window and door is flatten geometry\nif len(Carrier_Geometry) != 0:\n    if isinstance(Carrier_Geometry[0], rg.Brep):\n        carrierGeoFlat = [flattenBrep(carrier) for carrier in Carrier_Geometry]\nelse:\n    ghenv.Component.AddRuntimeMessage(ghkernel.GH_RuntimeMessageLevel.Warning, \"Carrier is empty.\")\n    goExecute = False\n\n# ==============================================================================\nif len(setTile) == 0:\n    ghenv.Component.AddRuntimeMessage(ghkernel.GH_RuntimeMessageLevel.Warning, \"setTile is empty.\")\n    goExecute = False\n# ==============================================================================\ninput_collection = {\"setTile\":None, \"claddingDirection\":True, \"horiOverlap\":1, \"vertiOverlap\":0, \"horiAngle\":0.5, \"vertiAngle\":0, \"substructWidth\":4, \"substructThickness\":2, \"moduleDistance\":None, \"moduleCurve\":None, \"moduleCrvDist\":10, \"init\":False}\n\nfor name in input_collection:\n    if name not in globals() or globals()[name]== None:\n        globals()[name] = input_collection[name]\n\nvisualEmpty = False\nif len(material_collection) == 0:\n    material_collection = [emptyData]\n    visualEmpty = True\n    # ghenv.Component.AddRuntimeMessage(ghkernel.GH_RuntimeMessageLevel.Warning, \"inner material is empty.\")\n    # goExecute = False\n# ==============================================================================\ninputs = ghenv.Component.Params.Input\noutputs = ghenv.Component.Params.Output\n\nfor input in inputs:\n    iName = input.Name\n    if iName == \"Database_collection\":\n        input.Description = \"Input a database collection (DB_Collection) to access the material database\"\n    elif iName == \"Carrier_Geometry\":\n        input.Description = \"Geometry for carriers. You need to input geometry (Brep) of walls or roofs\"\n    elif iName == \"Window_Geometry\":\n        input.Description = \"Input window geometry (Brep) or Rhino objects (newObj from windowFromRH)\"\n    elif iName == \"Door_Geometry\":\n        input.Description = \"Input door geometry (Brep) or Rhino objects (newObj from doorFromRH)\"\n    elif iName == \"setTile\":\n        input.Description = \"Configure settings for tiles or facades. Input customized tiles (customizeTile), database tiles (searchDBTile) for tile mode, or material collections for facade mode\"\n    elif iName == \"claddingDirection\":\n        input.Description = \"Boolean to determine the direction of cladding\"\n    elif iName == \"horiOverlap\":\n        input.Description = \"Specify the horizontal overlap distance for wall cladding\"\n    elif iName == \"vertiOverlap\":\n        input.Description = \"Specify the vertical overlap distance for wall cladding\"\n    elif iName == \"horiAngle\":\n        input.Description = \"Set the rotation angle of tiles around the horizontal axis\"\n    elif iName == \"vertiAngle\":\n        input.Description = \"Set the rotation angle of tiles around the vertical axis\"\n    elif iName == \"substructWidth\":\n        input.Description = \"Define the width of the cladding's substructure\"\n    elif iName == \"substructThickness\":\n        input.Description = \"Define the thickness of the cladding's substructure\"\n    elif iName == \"material_collection\":\n        input.Description = \"Input the collection of materials for the interior\"\n    elif iName == \"moduleDistance\":\n        input.Description = \"Specify the module width to determine intervals for wall segmentation.\"\n    elif iName == \"moduleCurve\":\n        input.Description = \"Input curves to define how walls are segmented into modules\"\n    elif iName == \"moduleCrvDist\":\n        input.Description = \"Specify the seam width for walls segmented into modules\"\n\nfor output in outputs:\n    oName = output.Name\n    if oName == \"visualObj\":\n        output.Description = \"Visual representation of wall geometries. Connect this output to either tileFacadeViewer or normalFacadeViewer for display\"\n    elif oName == \"allTypeMaterialModule\":\n        output.Description = \"Visual representation of wall modules. Connect this output to the module visualization component\"\n    elif oName == \"matRecordObj\":\n        output.Description = \"Output object containing detailed records of materials used, including quantities and relevant details\"\n    elif oName == \"ruler\":\n        output.Description = \"Curve used as a guide for aligning openings within a 10cm tolerance\"\n# ==============================================================================\n\n\nif goExecute:\n    carrierTree, windowTree, doorTree, crvTree = categorize(carrierGeoFlat, Window_Geometry, Door_Geometry, moduleCurve)\n    if init:\n        # initial_data is for tile calculation\n        initial_data = {}\n    else:\n        initialize_globals()\n        inputDB = Database_collection.all_DB\n\n        # Start execute main function\n        compoundMaterialObj = CompoundMaterial(material_collection, DB = inputDB)\n        materialList = compoundMaterialObj.new_materialList\n        material_thickness = compoundMaterialObj.thicknessList\n\n        offsetList = []\n        total = 0\n        for num in material_thickness:\n            total += num\n            offsetList.append(total)\n\n        offsetCladdingDist = sum(material_thickness)\n        offsetList = offsetList[:-1]\n        offsetList.insert(0,0)\n\n##################################################################\n        rulerTree = DataTree[object]()\n        visualObjTree = DataTree[object]()\n        allTypeMaterialModuleTree = DataTree[object]()\n        matRecordObjTree = DataTree[object]()\n\n        for pathId, path in enumerate(carrierTree.Paths):\n            print(\"Start wall_\" + str(pathId))\n            carrier = carrierTree.Branch(path)[0].Brep\n\n            windowData = windowTree.Branch(path)\n            window = windowData if not windowData==None else []\n            # window = [win.ToBrep() for win in window]\n\n            doorData = doorTree.Branch(path)\n            door = doorData if not doorData==None else []\n\n            crvData = crvTree.Branch(path)\n            moduleCrv = crvData if not crvData==None else []\n##################################################################\n            \n\n\n            if setTile[0].identity == \"customizedTile\":\n                print(\"Go into customizeTile\")\n                claddingObj = GenerateCladding(DB = inputDB, wallGeo=carrier, windowGeo=window, doorGeo=door, claddingDirection = claddingDirection, horizontalOverlap=horiOverlap, verticalOverlap=vertiOverlap, horizontalAngle=horiAngle, verticalAngle=vertiAngle, substructWidth=substructWidth, substructThickness=substructThickness, offsetDist=offsetCladdingDist, tileDimension = setTile)\n                offsetCladdingDistView = offsetCladdingDist\n                \n            elif setTile[0].identity == \"searchTile\":\n                print(\"Go into searchTile\")\n                tileSetting = setTile[0].searchTileData\n                claddingWidth = tileSetting[\"claddingWidth\"]\n                claddingLength = tileSetting[\"claddingLength\"]\n                kindNum = tileSetting[\"kindNum\"]\n                wWeight = tileSetting[\"wWeight\"]\n                lWeight = tileSetting[\"lWeight\"]\n\n                claddingObj = GenerateCladding(DB=inputDB, wallGeo=carrier, windowGeo=window, doorGeo=door, claddingWidth=claddingWidth, claddingLength=claddingLength, kindNum=kindNum, wWeight=wWeight, lWeight=lWeight, claddingDirection = claddingDirection, horizontalOverlap=horiOverlap, verticalOverlap=vertiOverlap, horizontalAngle=horiAngle, verticalAngle=vertiAngle, substructWidth=substructWidth, substructThickness=substructThickness, offsetDist=offsetCladdingDist)\n                offsetCladdingDistView = offsetCladdingDist\n            \n            else:\n                print(\"Go into Board Facade Process\")\n                claddingObj = NormalFacade(DB=inputDB, wallGeo=carrier, windowGeo=window, doorGeo=door, claddingDirection = claddingDirection, offsetDist=offsetCladdingDist, claddingMaterial=setTile)\n                facadeMaterial = claddingObj.facadeMaterial\n                offsetCladdingDistView = offsetCladdingDist + claddingObj.normalOffsetDist\n\n                ruler = claddingObj.ruler\n                rulerTree.AddRange(ruler, path)\n\n            # a = claddingObj.check\n            # b = claddingObj.check2\n\n\n            if setTile[0].identity == \"customizedTile\" or setTile[0].identity == \"searchTile\":\n                facadeType = 'tile'\n                # Output claddingObj\n                comb = th.list_to_tree(claddingObj.combinationGraph)\n                tileGeometry = th.list_to_tree(claddingObj.originalCoTileGeo)\n                substructureGeo = claddingObj.substructureGeo #\n                claddingInfo = claddingObj.tileAttrDict\n            else:\n                facadeType = 'normal'\n                comb = None\n                tileGeometry = facadeMaterial\n                substructureGeo = None\n                claddingInfo = claddingObj.claddingInfo\n            \n            # Common Attribute\n            wallFrame = claddingObj.wallFrame\n            wallForInnerMaterial = claddingObj.wallForInnerGeo\n            windowForFinalList = claddingObj.windowForFinalList \n            doorForFinalList = claddingObj.doorForFinalList \n            openingInfo = claddingObj.chosenDoorAttr\n\n\n            # Calculate innerMaterial Part\n            offsetted_surface = offset_brep(wallForInnerMaterial, offsetList, wallFrame)\n            wallObj = InnerMaterialGenerate(inputDB, offsetted_surface, materialList, material_thickness, moduleDistance, wallFrame, claddingDirection, moduleCrv, moduleCrvDist, True)\n            allTypeMaterial = wallObj.allTypeMaterial\n            allTypeMaterialModule = wallObj.allTypeMaterialModule\n\n\n            class matClass:\n                def __init__(self):\n                    pass\n\n            \n            usedMatDict = {}\n            usedMatDict['innerMaterial'] = wallObj.materialInfoDict\n            usedMatDict['window'] = claddingObj.chosenWindowAttr\n            usedMatDict['door'] = claddingObj.chosenDoorAttr\n\n            usedMatDict['outerMaterial'] = {}\n            if facadeType == 'tile':\n                usedMatDict['outerMaterial']['type'] = 'tile'\n            else:\n                usedMatDict['outerMaterial']['type'] = 'normal'\n            usedMatDict['outerMaterial']['matInfo'] = claddingInfo\n\n\n            matRecordObj = matClass()\n            matRecordObj.usedMatDict = usedMatDict\n\n            matRecordObjTree.AddRange([matRecordObj], path)\n\n            class visualClass:\n                def __init__(self):\n                    pass\n            \n            visualObj = visualClass()\n            visualObj.comb = comb\n            visualObj.tileGeometry = tileGeometry\n            visualObj.allTypeMaterial = allTypeMaterial\n            visualObj.substructureGeo = substructureGeo\n            visualObj.wallFrame = wallFrame\n            visualObj.offsetCladdingDist = offsetCladdingDistView\n            # print(offsetCladdingDist)\n            visualObj.windowGeo = windowForFinalList\n            visualObj.doorGeo = doorForFinalList\n            visualObj.usedMatDict = usedMatDict\n\n            visualObj.visualEmpty = True if visualEmpty else False\n\n\n            visualObjTree.AddRange([visualObj], path)\n\n            \n            data = th.list_to_tree(allTypeMaterialModule.Branches)\n            allTypeMaterialModule = changePath(data, allTypeMaterialModule)\n\n\n        oRuler = rulerTree\n        oVisualObj = visualObjTree\n        oMatRecordObj = matRecordObjTree\n\n\n\n\nelse:\n    ghenv.Component.AddRuntimeMessage(ghkernel.GH_RuntimeMessageLevel.Warning, \"Check necessary input.\")\n\n \n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}