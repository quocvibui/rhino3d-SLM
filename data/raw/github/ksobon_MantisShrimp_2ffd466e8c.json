{
  "source_url": "https://github.com/ksobon/MantisShrimp/blob/9b3d1ef747a04f75f3542c38550c4e29b9d08c8f/Grasshopper/src/Mantis%20Shrimp%20-%20Export.py",
  "repo": "ksobon/MantisShrimp",
  "repo_stars": 39,
  "repo_description": "A interop project for bridging the gap between Rhino/Grasshopper and Revit/Dynamo",
  "license": "unknown",
  "filepath": "Grasshopper/src/Mantis Shrimp - Export.py",
  "instruction": "This component exports serialized geometry to specified location. Thank you to Mostapha Sadeghipour Roudsari\nfor providing invaluable help with this project.",
  "code": "#Copyright(c) 2015, Konrad K Sobon\n#@arch_laboratory, http://archi-lab.net\n\n\"\"\"\nThis component exports serialized geometry to specified location. Thank you to Mostapha Sadeghipour Roudsari\nfor providing invaluable help with this project. \n\n    Args:\n        _geometry: any GH/or rhino referenced geometry\n        _filePath: A local folder with file name and extension ex. C:\\test.geo\n        _export: Set Boolean to True to export geometry to destination folder\n\"\"\"\n\nghenv.Component.Name = \"Mantis Shrimp - Export\"\nghenv.Component.NickName = 'exportMantisShrimp'\nghenv.Component.Category = \"Mantis Shrimp\"\n\nimport sys\nimport os\nappDataPath = os.getenv('APPDATA')\nmsPath = appDataPath + r\"\\Dynamo\\0.8\\packages\\Mantis Shrimp\\extra\"\nif msPath not in sys.path:\n    sys.path.append(msPath)\n    \nfrom mantisshrimp import *\nimport Rhino as rc\nimport cPickle as pickle\nimport Grasshopper.Kernel as gh\nimport scriptcontext as sc\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\nclass SerializeObjects(object):\n    \n    def __init__(self, filePath, data = None):\n        \n        # create directory if it is not created\n        folder, fileName = os.path.split(filePath)\n        if not os.path.isdir(folder):\n            os.mkdir(folder)\n        \n        self.filePath = filePath\n        self.data = data\n        \n    def saveToFile(self):\n        with open(self.filePath, 'wb') as outf:\n            pickle.dump(self.data, outf)\n            \n    def readFromFile(self):\n        with open(self.filePath, 'rb') as inf:\n            self.data = pickle.load(inf)\n\n# written by Giulio Piacentino, giulio@mcneel.com\ndef TreeToList(input, RetrieveBase = lambda x: x[0]):\n    \"\"\"Returns a list representation of a Grasshopper DataTree\"\"\"\n    def extend_at(path, index, simple_input, rest_list):\n        target = path[index]\n        if len(rest_list) <= target: rest_list.extend([None]*(target-len(rest_list)+1))\n        if index == path.Length - 1:\n            rest_list[target] = list(simple_input)\n        else:\n            if rest_list[target] is None: rest_list[target] = []\n            extend_at(path, index+1, simple_input, rest_list[target])\n    all = []\n    for i in range(input.BranchCount):\n        path = input.Path(i)\n        extend_at(path, 0, input.Branch(path), all)\n    return RetrieveBase(all)\n\ndef process_list(_func, _list):\n    return map( lambda x: process_list(_func, x) if type(x)==list else _func(x), _list )\n\ndef rhLineCurveToMSLine(item):\n    if type(item) == rc.Geometry.LineCurve:\n        item = item.Line\n    msStartPt = MSPoint(item.FromX, item.FromY, item.FromZ)\n    msEndPt = MSPoint(item.ToX, item.ToY, item.ToZ)\n    return MSLine(msStartPt, msEndPt)\n\ndef rhPolyLineToMSPolyLine(item):\n    if type(item) == rc.Geometry.PolylineCurve or type(item) == rc.Geometry.PolyCurve:\n        if item.IsPolyline():\n            item = item.TryGetPolyline()[1]\n    segments = []\n    for i in range(0, item.SegmentCount,1):\n        line = item.SegmentAt(i)\n        segments.append(rhLineCurveToMSLine(line))\n    return MSPolyLine(segments)\n\ndef rhArcCurveToMSArc(item):\n    if type(item) == rc.Geometry.ArcCurve:\n        item = item.Arc\n    startPoint = MSPoint(item.StartPoint.X, item.StartPoint.Y, item.StartPoint.Z)\n    centerPoint = MSPoint(item.Center.X, item.Center.Y, item.Center.Z)\n    endPoint = MSPoint(item.EndPoint.X, item.EndPoint.Y, item.EndPoint.Z)\n    return MSArc(startPoint, centerPoint, endPoint)\n\ndef rhNurbsCurveToMSNurbsCurve(item):\n    msControlPoints = []\n    for pt in item.Points:\n        msControlPoints.append(MSPoint4d(pt.Location.X, pt.Location.Y, pt.Location.Z, pt.Weight))\n    knots = []\n    for i in range(0, item.Knots.Count, 1):\n        knots.append(item.Knots[i])\n    weights = None\n    return MSNurbsCurve(msControlPoints, weights, knots, item.Degree)\n\ndef rhMultiSpanNurbsCurveToMSNurbsCurve(item):\n    rhSubCurve = []\n    msCurves = []\n    for i in range(0, item.SpanCount, 1):\n        rhCurveSubdomain = item.SpanDomain(i)\n        rhSubCurve.append(item.ToNurbsCurve(rhCurveSubdomain))\n    for curve in rhSubCurve:\n        msCurves.append(rhNurbsCurveToMSNurbsCurve(curve))\n    return MSMultiSpanNurbsCurve(msCurves)\n\ndef rhPointToMSPoint(item):\n    if type(item) == rc.Geometry.Point:\n        return MSPoint(item.Location.X, item.Location.Y, item.Location.Z)\n    elif type(item) == rc.Geometry.Point3d:\n        return MSPoint(item.X, item.Y, item.Z)\n\ndef rhEllipseToMSEllipse(item):\n    #msVector = MSVector(item.Plane.Normal.X,item.Plane.Normal.Y, item.Plane.Normal.Z) \n    msOrigin = MSPoint(item.Plane.Origin.X, item.Plane.Origin.Y, item.Plane.Origin.Z)\n    ptX = rc.Geometry.Point3d.Multiply(item.Radius1, item.Plane.Origin)\n    ptY = rc.Geometry.Point3d.Multiply(item.Radius2, item.Plane.Origin)\n    msPointX = MSPoint(ptX.X, ptX.Y, ptX.Z)\n    msPointY = MSPoint(ptY.X, ptY.Y, ptY.Z)\n    #msPlane = MSPlane(msOrigin, msVector)\n    return MSEllipse(msOrigin, msPointX, msPointY, None, None, None)\n\ndef rhCircleToMSCircle(item):\n    msVector = MSVector(item.Normal.X,item.Normal.Y, item.Normal.Z)\n    msOrigin = MSPoint(item.Center.X, item.Center.Y, item.Center.Z)\n    msPlane = MSPlane(msOrigin, msVector)\n    return MSCircle(msPlane, item.Radius)\n\ndef rhPolyCurveToMSPolyCurve(item):\n    msSubCurves = []\n    segmentCount = item.SegmentCount\n    for i in range(0, segmentCount):\n        curve = item.SegmentCurve(i)\n        if type(curve) == rc.Geometry.LineCurve or type(curve) == rc.Geometry.Line:\n            msSubCurves.append(rhLineCurveToMSLine(curve))\n        elif type(curve) == rc.Geometry.Arc:\n            msSubCurves.append(rhArcCurveToMSArc(curve))\n        elif type(curve) == rc.Geometry.ArcCurve and curve.IsArc() == True:\n            msSubCurves.append(rhArcCurveToMSArc(curve))\n        elif type(curve) == rc.Geometry.PolylineCurve or type(curve) == rc.Geometry.Polyline:\n            msSubCurves.append(rhPolyLineToMSPolyLine(curve))\n        elif type(curve) == rc.Geometry.NurbsCurve:\n            msSubCurves.append(rhNurbsCurveToMSNurbsCurve(curve))\n    msPolyCurve = MSPolyCurve(msSubCurves)\n    return msPolyCurve\n\ndef rhMeshToMSMesh(item):\n    faceTopology, points = [], []\n    faces = item.Faces\n    tvList = item.TopologyVertices\n    for i in range(0, item.Faces.Count, 1):\n        faceTopology.append(faces.GetTopologicalVertices(i))\n    for i in range(0, tvList.Count, 1):\n        points.append(MSPoint(tvList.Item[i].X, tvList.Item[i].Y, tvList.Item[i].Z))\n    return MSMesh(points, faceTopology)\n\ndef rhNurbsSurfaceToMSNurbsSurface(item):\n    msControlPoints = []\n    for pt in item.Points:\n        msControlPoints.append(MSPoint4d(pt.Location.X, pt.Location.Y, pt.Location.Z, pt.Weight))\n    weights = None\n    knotsU = []\n    for i in range(0, item.KnotsU.Count, 1):\n        knotsU.append(item.KnotsU[i])\n    knotsV = []\n    for i in range(0, item.KnotsV.Count, 1):\n        knotsV.append(item.KnotsV[i])\n    return MSNurbsSurface(msControlPoints, weights, knotsU, knotsV, item.OrderU, item.OrderV, item.SpanCount(0), item.SpanCount(1), item.IsRational)\n\ndef tryExplode(item):\n    try:\n        return list(item.Explode())\n    except:\n        return [item]\n\ndef rhBrepToMsBrep(item):\n    if item.Faces.Count == 1:\n        return rhNurbsSurfaceToMSNurbsSurface(item.Faces.Item[0].ToNurbsSurface())\n    msFaces = []\n    faces = item.Faces\n    joinedCurves = [[] for i in range(faces.Count)]\n    for index, face in enumerate(faces):\n        if face.IsSurface:\n            msFaces.append(rhNurbsSurfaceToMSNurbsSurface(face.ToNurbsSurface()))\n        else:\n            msFaces.append(rhNurbsSurfaceToMSNurbsSurface(face.UnderlyingSurface().ToNurbsSurface()))\n            faceLoops = face.Loops\n            for loop in faceLoops:\n                trims = loop.Trims\n                trimLoop = []\n                for trim in trims:\n                    if trim.TrimType != rc.Geometry.BrepTrimType.Seam:\n                        edgeIndex = trim.Edge.EdgeIndex\n                        edge = item.Edges.Item[edgeIndex]\n                        trimLoop.append(edge.DuplicateCurve())\n                joinedCurves[index].extend(rc.Geometry.Curve.JoinCurves(trimLoop))\n    explodedCrvs = process_list(tryExplode, joinedCurves)\n    msTrimCurves = process_list(toMSObject, explodedCrvs)\n    msBrep = MSBrep(msFaces,msTrimCurves)\n    return msBrep\n\ndef toMSObject(item):\n    if type(item) == rc.Geometry.Point3d or type(item) == rc.Geometry.Point:\n        return rhPointToMSPoint(item)\n    elif type(item) == rc.Geometry.LineCurve or type(item) == rc.Geometry.Line:\n        return rhLineCurveToMSLine(item)\n    elif type(item) == rc.Geometry.PolyCurve and item.IsPolyline() == True:\n        return rhPolyLineToMSPolyLine(item)\n    elif type(item) == rc.Geometry.Polyline:\n        return rhPolyLineToMSPolyLine(item)\n    elif type(item) == rc.Geometry.NurbsCurve and item.IsClosed == True:\n        if item.IsEllipse() == True:\n            item = item.TryGetEllipse()[1]\n            return rhEllipseToMSEllipse(item)\n        elif item.IsCircle() == True or item.IsPeriodic:\n            item = item.TryGetCircle()[1]\n            return rhCircleToMSCircle(item)\n        elif not item.IsPeriodic and item.IsRational:\n            item = item.TryGetEllipse()[1]\n            return rhEllipseToMSEllipse(item)\n        else:\n            pass\n    if type(item) == rc.Geometry.ArcCurve and item.IsCircle() == True:\n        item = item.TryGetCircle()[1]\n        return rhCircleToMSCircle(item)\n    elif type(item) == rc.Geometry.ArcCurve and item.IsArc() == True:\n        item = item.TryGetArc()[1]\n        return rhArcCurveToMSArc(item)\n    elif type(item) == rc.Geometry.NurbsCurve and item.SpanCount == 1:\n        return rhNurbsCurveToMSNurbsCurve(item)\n    elif type(item) == rc.Geometry.NurbsCurve and item.SpanCount > 1:\n        return rhMultiSpanNurbsCurveToMSNurbsCurve(item)\n    elif type(item) == rc.Geometry.PolyCurve:\n        return rhPolyCurveToMSPolyCurve(item)\n    elif type(item) == rc.Geometry.Mesh:\n        return rhMeshToMSMesh(item)\n    if type(item) == rc.Geometry.Brep:\n        return rhBrepToMsBrep(item)\n    elif type(item) == rc.Geometry.Brep and item.IsSurface == True:\n        item = item.Faces[0].ToNurbsSurface()\n        return rhNurbsSurfaceToMSNurbsSurface(item)\n    else:\n        return MSData(item)\n\nif _export:\n    # make sure data tree paths are correct format\n    # huge thanks to djordje for help with implementing this method\n    _geometry.SimplifyPaths()\n    branches = _geometry.Branches\n    paths = _geometry.Paths\n    if len(paths) != 1:\n        newPaths = [i.PrependElement(0) for i in paths]\n        newTree = DataTree[object]()\n        for i in range(_geometry.BranchCount):\n            newTree.AddRange(branches[i], newPaths[i])\n        geometryList = TreeToList(newTree)\n    else:\n        geometryList = TreeToList(_geometry)\n    geometryOut = process_list(toMSObject, geometryList)\n    try:\n        serializer = SerializeObjects(_filePath, geometryOut)\n        serializer.saveToFile()\n        warnType = gh.GH_RuntimeMessageLevel.Remark\n        msg = \"File is exported to \" + _filePath + \"Now you can use Dynamo to import the file.\"\n        ghenv.Component.AddRuntimeMessage(warnType, msg)\n    except Exception, e:\n        warnType = gh.GH_RuntimeMessageLevel.Warning\n        msg = \"Failed to export: \\n\" + `e`\n        ghenv.Component.AddRuntimeMessage(warnType, msg)\nelse:\n    msg = \"Export set to false.\"\n\nfor i in geometryOut:\n    print(i.plane)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}