{
  "source_url": "https://github.com/ChanYenFen/00_WinterSchool_EarthToEarth/blob/03f0f28eb67b6de613776969259533281c1be83b/02_src/e2e_pathSlicer.py",
  "repo": "ChanYenFen/00_WinterSchool_EarthToEarth",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "02_src/e2e_pathSlicer.py",
  "instruction": "E2e path slicer",
  "code": "import os\nimport json\nimport csv\nimport Rhino.Geometry as rg\nimport math as m\n\ndef calc_blendRadius(new_pts, buffer=0.001):\n    blend_radiuses = []\n    for i in range(len (new_pts)-1):\n        pt = new_pts[i]\n        pt_1 = new_pts[i+1]\n        dist = pt.DistanceTo(pt_1)\n        blend_radius = dist*buffer\n        blend_radiuses.append(blend_radius)\n        if i == len (new_pts)-1:\n            blend_radiuses.append(blend_radius)\n\n    #blend_radiuses.append(blend_radiuses[-1]*0.4)\n    return blend_radiuses\n\ndef divide_crv(crv, seg_len, endInc):\n    crv_length = crv.GetLength()\n    count = crv_length/seg_len\n    params = crv.DivideByCount(count, endInc)\n    points = [crv.PointAt(p) for p in params]\n    \n    tangents = [crv.TangentAt(p) for p in params]\n    normals = [rg.Vector3d.CrossProduct(t, rg.Vector3d.ZAxis) for t in tangents]\n    return points, normals\n\ndef divide_crvs(crvs, seg_len, endInc, returnNest):\n    counts = [crv.GetLength() / seg_len for crv in crvs]\n    param_nList =[]\n    param_nList.append([crv.DivideByCount(count, endInc) for (crv,count) in zip(crvs,counts)])\n\n    wayPoints_nList = []\n    for crv, params in zip(crvs,*param_nList):\n        points = [crv.PointAt(p) for p in params]\n        if returnNest:\n            wayPoints_nList.append(points)\n        else:\n            wayPoints_nList.extend(points)\n    return wayPoints_nList \n\ndef rhino_to_robot_space(plane, rhino_centerPt, robot_centerPt):\n    rhino_centerPlane = rg.Plane(rhino_centerPt, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n    robot_centerPlane = rg.Plane(robot_centerPt, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n    T = rg.Transform.PlaneToPlane(rhino_centerPlane, robot_centerPlane)\n    plane.Transform(T)\n    return plane\n\ndef contour_XY(brep, layer_height, simplify):\n    contour_crvs =[]\n    bbox = rg.Brep.GetBoundingBox(brep, rg.Plane.WorldXY)\n    lowest_pt = bbox.Min\n    highest_pt = bbox.Max\n    contour_range = int((highest_pt.Z-lowest_pt.Z)/layer_height) +1\n    for i in range(contour_range):\n        plane_ori = lowest_pt + rg.Vector3d(0,0,1)*layer_height*i\n        intersection_plane = rg.Plane(plane_ori, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n        intersection_events = rg.Intersect.Intersection.BrepPlane(brep, intersection_plane,0.01)\n        if intersection_events[0]:\n            layer_crvs = intersection_events[1]\n            if len(layer_crvs)>1:\n                layer_crvs = rg.Curve.JoinCurves(layer_crvs)\n            for crv in layer_crvs:\n                if simplify:\n                    crv.Simplify(rg.CurveSimplifyOptions.All, distanceTolerance=0.01, angleToleranceRadians=0.01)\n                contour_crvs.append(crv)\n    return contour_crvs\n    \ndef contour(srf, inter_origin, normal, layer_height, simplify):\n    contour_crvs =[]\n    for i in range(1000):\n        intersection_plane = rg.Plane(inter_origin+normal*i, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n        intersection_events = rg.Intersect.Intersection.BrepPlane(srf, intersection_plane,0.01)\n\n        if intersection_events[0]:\n            layer_crvs = intersection_events[1]\n            if len(layer_crvs)>1:\n                layer_crvs = rg.Curve.JoinCurves(layer_crvs)\n            for crv in layer_crvs:\n                if simplify:\n                    crv.Simplify(rg.CurveSimplifyOptions.All, distanceTolerance=0.01, angleToleranceRadians=0.01)\n                contour_crvs.append(crv)\n    return contour_crvs\n\ndef find_offset_distance(interval):\n    return m.sin(m.radians(60))*interval\n\ndef offset_crv(crv, base_pt, distance):\n    offset_crv = rg.Curve.Offset(crv, base_pt, rg.Vector3d.ZAxis, distance, 0.01, 0.01, True, rg.CurveOffsetCornerStyle.None, rg.CurveOffsetEndStyle.None)\n    return offset_crv\n\ndef offset_crvs(crv, distance, seg_len, bothSides, side, offset_layers):\n    \"\"\"\n    This function return a list of offset curves form an input curve.\n    Seg is about the precision of the results which suggested set to 10.0\n    If it is a closed curve,\n    set side = 0 to get offset curves outside,\n    set side = 1 to get offset curves inside.\n    \"\"\"\n    params = crv.DivideByLength(seg_len, True)\n    points = [crv.PointAt(p) for p in params]\n    tangents = [crv.TangentAt(p) for p in params]\n    normals = [rg.Vector3d.CrossProduct(t, rg.Vector3d.ZAxis) for t in tangents]\n    \n    pts_nlists =[]\n    if bothSides:\n        side = None\n        for i in range(1,offset_layers+1):\n            side_0_pts =[]\n            side_1_pts =[]\n            for pt,nor in zip(points,normals):\n                side_0 = rg.Transform.Translation(nor*i*distance)\n                side_1 = rg.Transform.Translation(nor*i*distance *-1)\n                pt_0 = pt.Clone()\n                pt_0.Transform(side_0)\n                side_0_pts.append(pt_0)\n                pt_1 = pt.Clone()\n                pt_1.Transform(side_1)\n                side_1_pts.append(pt_1)\n            pts_nlists.append(side_0_pts)\n            pts_nlists.append(side_1_pts)\n    if not bothSides:\n        if side ==0:\n            dir = 1\n        elif side ==1:\n            dir = -1\n        for i in range(1,offset_layers+1):\n                side_0_pts =[]\n                for pt,nor in zip(points,normals):\n                    side_0 = rg.Transform.Translation(nor*i*distance*dir)\n                    pt_0 = pt.Clone()\n                    pt_0.Transform(side_0)\n                    side_0_pts.append(pt_0)\n                pts_nlists.append(side_0_pts)\n    offset_crvs= []\n    for pts in pts_nlists:\n        if crv.IsClosed:\n            pts.append(pts[0].Clone())\n            offset_crv = rg.Curve.CreateInterpolatedCurve(pts, degree=3, knots=rg.CurveKnotStyle.Uniform)\n            offset_crv.MakeClosed(0.001)\n            offset_crvs.append(offset_crv)\n        else:\n            offset_crv = rg.Curve.CreateInterpolatedCurve(pts, degree=3, knots=rg.CurveKnotStyle.Chord)\n            offset_crvs.append(offset_crv)      \n    return offset_crvs\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}