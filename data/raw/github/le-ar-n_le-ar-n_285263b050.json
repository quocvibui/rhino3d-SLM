{
  "source_url": "https://github.com/le-ar-n/le-ar-n/blob/64600ee3bbe7e42f87f28442923b216cc565cf24/code/02_geometry/libraries/algorithms/dendrite_system/dendrite_sys_from_pts.py",
  "repo": "le-ar-n/le-ar-n",
  "repo_stars": 9,
  "repo_description": null,
  "license": "unknown",
  "filepath": "code/02_geometry/libraries/algorithms/dendrite_system/dendrite_sys_from_pts.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 27.09.2016\n\n@author: kathrind\n'''\n\nimport Rhino.Geometry as rg\nimport random as rnd\nimport math\n\nimport ghpythonlib.components as ghcomp\nfrom libraries.useful.useful_functions import map_range\n\n\n#===============================================================================\n# \n#===============================================================================\nclass Node:\n    def __init__(self, position, node_size, kill_distance):\n        \n        self.position = position\n        self.sources = []\n        self.direction = rg.Vector3d(0,0,0)\n        self.distance = node_size\n        self.kill_distance = kill_distance\n        self.active = False\n        self.energy = 1 # this should be decreased by each new branch\n        self.is_end = False\n\n#===============================================================================\n# \n#===============================================================================\nclass Source:\n    def __init__(self, position):\n        self.position = position\n        self.node = None\n\n\n#===============================================================================\n# \n#===============================================================================\nclass DendriteSystemPts:\n\n    #===========================================================================\n    def __init__(self, image_file=None):\n        self.sources = []\n        self.nodes = []\n        \n        self.node_size = 10\n        self.kill_distance = 20\n        self.node_radius = 35\n        self.new_sources_per_radius = 3\n        self.width = 1000\n        self.height = 1000\n        \n        if image_file:\n            #load image and overwrite width and height\n            self.load_image(image_file)     \n    \n\n    #===========================================================================\n    def create_sources(self, num_sources):\n        sources = []\n        for i in range(num_sources):\n            # dart-throwing algorithm\n            position = rg.Point3d(rnd.randrange(self.width), rnd.randrange(self.height), 0)\n            while self.has_overlay(position, self.sources) == True:\n                position = rg.Point3d(rnd.randrange(self.width), rnd.randrange(self.height), 0)\n            sources.append(Source(position))\n        return sources\n     \n    #===========================================================================\n    def create_sources_around(self, position, radius, number):\n        \"\"\" create sources around a given node \"\"\"\n        \n        for i in range(number):\n            rand_rad = rnd.randrange(self.node_size, radius)\n            rand_vector = rg.Vector3d(rnd.uniform(-1, 1), rnd.uniform(-1, 1), 0)\n            rand_vector.Unitize()\n            sourcepos = position + rand_vector * rand_rad\n            \n            max_count = 1000\n            counter = 0\n            while self.has_overlay(sourcepos, self.sources) == True and counter < max_count:\n                counter += 1\n                rand_rad = rnd.randrange(self.node_size, radius)\n                rand_vector = rg.Vector3d(rnd.uniform(-1, 1), rnd.uniform(-1, 1), 0)\n                rand_vector.Unitize()\n                sourcepos = position + rand_vector * rand_rad\n                \n            if 0 < sourcepos.X < self.width and 0 < sourcepos.Y < self.height:\n                self.sources.append(Source(sourcepos))\n    \n    #===========================================================================\n    def create_sources_around_nodes(self, nodes):\n        for node in nodes:\n            self.create_sources_around(node.position, self.node_radius, self.new_sources_per_radius)\n\n    #===========================================================================\n    def has_overlay(self, position, sources):\n        for s in sources:\n            if (s.position - position).Length <= self.node_size:\n                return True\n        return False\n    \n    #===========================================================================\n    def get_active_nodes(self):\n        return [node for node in self.nodes if node.active==True]\n    \n    #===========================================================================\n    def get_end_nodes(self):\n        return [node for node in self.nodes if node.is_end==True]\n    \n    #===========================================================================\n    def create_node(self, position):\n        node = Node(position, self.node_size, self.kill_distance)\n        node.is_end = True\n        self.nodes.append(node)\n        self.create_sources_around(position, self.node_radius, self.new_sources_per_radius)\n     \n    #===========================================================================\n    def step(self):\n        '''\n        0. kill sources that are too close.\n        1. calculate the distance of each source to the nodes, and assign the source to the closest node.\n        2. calculate for each active node the average direction where to put the next vein node.\n        3. add vein node at the right place.\n        '''\n              \n        self.kill_sources_and_assign_nodes_to_sources()      \n        new_nodes = self.calc_direction_and_add_nodes() \n        node_ends = self.get_end_nodes()\n        self.create_sources_around_nodes(node_ends)\n        \n    #===========================================================================\n    def kill_sources_and_assign_nodes_to_sources(self):\n        # clear all sources to calculate new ones\n        for node in self.nodes:\n            del node.sources[:]\n            node.active = False\n        \n        sources = []\n        for s in self.sources:\n            mindistance_node, mindistance = self.calc_min_dist_to_node(s)\n            if mindistance > mindistance_node.kill_distance:\n                mindistance_node.active = True\n                mindistance_node.sources.append(s)\n                s.node = mindistance_node\n                sources.append(s)\n                \n        del self.sources[:]\n        self.sources = sources\n     \n    #===========================================================================\n    def calc_min_dist_to_node(self, source):\n        mindistance_node = self.nodes[0]\n        mindistance = (mindistance_node.position - source.position).Length\n        for node in self.nodes:\n            dist = rg.Vector3d(node.position - source.position).Length\n            if dist < mindistance:\n                mindistance_node = node\n                mindistance = dist\n        return(mindistance_node, mindistance)\n    \n    #===========================================================================\n    def calc_direction_and_add_nodes(self):\n        new_nodes = []\n        for node in self.nodes:\n            if node.active == True:\n                node.is_end = False\n                average_vel = rg.Vector3d(0,0,0)\n                for s in node.sources:\n                    average_vel += rg.Vector3d(s.position - node.position)\n                average_vel /= len(node.sources)\n                average_vel.Unitize()\n                node.direction = average_vel\n                position = node.position + node.distance * node.direction\n                vein = Node(position, self.node_size, self.kill_distance)\n                vein.energy = node.energy * 0.98\n                vein.dist = node.distance * 1.02\n                vein.kill_distance = node.kill_distance * 1.02\n                vein.is_end = True\n                self.nodes.append(vein)\n                new_nodes.append(vein)\n        return new_nodes\n    \n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}