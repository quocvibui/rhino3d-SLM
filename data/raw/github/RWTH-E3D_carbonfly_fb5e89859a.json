{
  "source_url": "https://github.com/RWTH-E3D/carbonfly/blob/1b1001000e4cc0277af5eb359b9172a24b53acfd/grasshopper/CreateCFCase.py",
  "repo": "RWTH-E3D/carbonfly",
  "repo_stars": 19,
  "repo_description": "An easy-to-use Python library and Grasshopper toolbox for indoor CO2 CFD simulation",
  "license": "LGPL-3.0",
  "filepath": "grasshopper/CreateCFCase.py",
  "instruction": "GH inputs: case_dir (Text) case_name (Text) CF_geo (List) unit (Text)     # optional, m / cm / mm controlDict fvSchemes_path fvSolution_path residual insidePoint     # optional, reference point inside mesh internalFields run (Boolean) GH outputs: log (Text) case_path (Text)",
  "code": "# GH inputs:\n#   case_dir (Text)\n#   case_name (Text)\n#   CF_geo (List)\n#   unit (Text)     # optional, m / cm / mm\n#   controlDict\n#   fvSchemes_path\n#   fvSolution_path\n#   residual\n#   insidePoint     # optional, reference point inside mesh\n#   internalFields\n#   run (Boolean)\n# GH outputs:\n#   log (Text)\n#   case_path (Text)\n\nimport re\nimport json\nfrom collections.abc import Sequence\nfrom pathlib import Path\nimport carbonfly.case as cfcase\nimport carbonfly.control_dict as cfdict\nfrom carbonfly.utils import unit_scale_to_m\nfrom carbonfly.fv_writer import copy_fv_templates_to_case, patch_fvSolution_pimple\n\ndef _safe_name(s):\n    s = (s or \"unnamed\").strip()\n    s = re.sub(r\"[^\\w\\-]+\", \"_\", s)\n    return s or \"unnamed\"\n\ndef _norm_unit(u):\n    u = (u or \"mm\").strip().lower()\n    if u not in (\"mm\", \"cm\", \"m\"):\n        raise ValueError(\"unit must be 'mm', 'cm', or 'm'\")\n    return u\n\ndef _norm_path(p):\n    if not p:\n        return None\n    s = str(p).strip()\n    return Path(s) if s else None\n\n\ndef _norm_residual(v):\n    if v is None:\n        return None\n    if isinstance(v, (int, float)):\n        return float(v)\n    s = str(v).strip()\n    if s == \"\":\n        return None\n    return float(s)\n\ndef _parse_inside_point(p):\n    \"\"\"\n    Accepts: Rhino Point3d / Vector3d / GH_Point(.Value) / [x, y, z] / (possibly [point]).\n    Returns (x, y, z) or None if not parseable.\n    \"\"\"\n    if p is None:\n        return None\n\n    # Unwrap singletons like [point]\n    if isinstance(p, (list, tuple)) and len(p) == 1:\n        p = p[0]\n\n    # RhinoCommon Point3d / Vector3d or any object with X/Y/Z attrs\n    if hasattr(p, \"X\") and hasattr(p, \"Y\") and hasattr(p, \"Z\"):\n        try:\n            return (float(p.X), float(p.Y), float(p.Z))\n        except Exception:\n            pass\n\n    v = getattr(p, \"Value\", None) or getattr(p, \"Location\", None)\n    if v is not None and hasattr(v, \"X\") and hasattr(v, \"Y\") and hasattr(v, \"Z\"):\n        try:\n            return (float(v.X), float(v.Y), float(v.Z))\n        except Exception:\n            pass\n\n    # Generic sequence [x, y, z]\n    if isinstance(p, Sequence) and not isinstance(p, (str, bytes)):\n        if len(p) >= 3:\n            try:\n                return (float(p[0]), float(p[1]), float(p[2]))\n            except Exception:\n                pass\n\n    return None\n\nlogs = []\ntry:\n    # validations\n    if not case_dir or not str(case_dir).strip():\n        raise ValueError(\"case_dir is required.\")\n    if not CF_geo or len(CF_geo) == 0:\n        raise ValueError(\"CF_geo is empty, please connect the output from CreateCFGeometry.\")\n\n    base_dir   = Path(str(case_dir)).expanduser()\n    folder     = _safe_name(case_name)\n    target_dir = base_dir / folder\n    case_path  = str(target_dir)\n\n    stl_name = \"model.stl\"\n    unit_in  = _norm_unit(unit)\n    scale_to_m = unit_scale_to_m(unit_in)\n\n    # blockMesh settings\n    pad_m = 1.0\n    cell_m = 0.25\n\n    # insidePoint\n    inside_pt_model = _parse_inside_point(insidePoint)  # in model units\n    inside_pt = tuple(c * scale_to_m for c in inside_pt_model) if inside_pt_model else None\n\n    # default internalFields if not given\n    U_internal      = [0.0, 0.0, 0.0]\n    T_internal      = 295.15\n    CO2_internal    = 0.000400\n    P_internal      = 100_000.0\n    P_rgh_internal  = 0\n    alphat_internal = 0\n    epsilon_internal= 0.01\n    G_internal      = 0\n    k_internal      = 0.1\n    nut_internal    = 0\n    Ydefault_internal   = 0\n\n    fields = None\n    if internalFields:\n        fields = json.loads(internalFields)\n                        \n    if isinstance(fields, dict):\n        U_internal      = fields.get(\"U\",   U_internal)\n        T_internal      = fields.get(\"T\",   T_internal)\n        CO2_internal    = fields.get(\"CO2\", CO2_internal)\n        P_internal      = fields.get(\"p\",   P_internal)\n        P_rgh_internal  = fields.get(\"p_rgh\",   P_rgh_internal)\n        alphat_internal = fields.get(\"alphat\",   alphat_internal)\n        epsilon_internal= fields.get(\"epsilon\",   epsilon_internal)\n        G_internal      = fields.get(\"G\",   G_internal)\n        k_internal      = fields.get(\"k\",   k_internal)\n        nut_internal    = fields.get(\"nut\",   nut_internal)\n        Ydefault_internal   = fields.get(\"Ydefault\",   Ydefault_internal)\n\n    # unpack controlDict\n    cdict_json = None\n    if controlDict:\n        cdict_json = json.loads(controlDict)\n\n    # fvSchemes & fvSolution\n    fvSchemes_src = _norm_path(fvSchemes_path)\n    fvSolution_src = _norm_path(fvSolution_path)\n\n    # PIMPLE settings\n    rv = _norm_residual(residual)\n\n    if not run:\n        # dry-run: no filesystem writes\n        logs.append(f\"Case will be created at: {target_dir}\")\n        logs.append(f\"STL file: {stl_name}, unit: {unit_in}\")\n        logs.append(f\"CF_geo count: {len(CF_geo)}\")\n        logs.append(f\"blockMesh: padding_m={pad_m}, cell_size_m={cell_m}\")\n        logs.append(\"U_internal: \" + (f\"{U_internal} m/s\" if U_internal else \"None\"))\n        logs.append(\"T_internal: \" + (f\"{T_internal} K\" if (T_internal is not None) else \"None\"))\n        logs.append(\"CO2_internal: \" + (f\"{CO2_internal*1e6} ppm\" if (CO2_internal is not None) else \"None\"))\n        logs.append(\"P_internal: \" + (f\"{P_internal} Pa\" if (P_internal is not None) else \"None\"))\n\n        logs.append(\"P_rgh_internal: \" + (f\"{P_rgh_internal}\" if (P_rgh_internal is not None) else \"None\"))\n        logs.append(\"alphat_internal: \" + (f\"{alphat_internal}\" if (alphat_internal is not None) else \"None\"))\n        logs.append(\"epsilon_internal: \" + (f\"{epsilon_internal}\" if (epsilon_internal is not None) else \"None\"))\n        logs.append(\"G_internal: \" + (f\"{G_internal}\" if (G_internal is not None) else \"None\"))\n        logs.append(\"k_internal: \" + (f\"{k_internal}\" if (k_internal is not None) else \"None\"))\n        logs.append(\"nut_internal: \" + (f\"{nut_internal}\" if (nut_internal is not None) else \"None\"))\n        logs.append(\"Ydefault_internal: \" + (f\"{Ydefault_internal}\" if (Ydefault_internal is not None) else \"None\"))\n        if inside_pt is not None:\n            logs.append(f\"insidePoint (model units): {inside_pt_model}\")\n        else:\n            logs.append(\"insidePoint: Default (Warning: may cause error))\")\n        if fvSchemes_src:\n            logs.append(f\"fvSchemes template: {fvSchemes_src}\")\n        else:\n            logs.append(\"fvSchemes template not provided\")\n        if fvSolution_src:\n            logs.append(f\"fvSolution template: {fvSolution_src}\")\n        else:\n            logs.append(\"fvSolution template not provided\")\n        logs.append(f\"Residual: {rv if rv is not None else '(not provided)'}\")\n\n        logs.append(\"\\n=== Click RUN to generate files ===\")\n        log = \"\\n\".join(logs)\n    else:\n        # real writes\n        logs.append(f\"[Run] Creating case at: {target_dir}\")\n        # build case\n        lgs, paths = cfcase.build_case(\n            case_root=target_dir,\n            cfgeos=CF_geo,\n            stl_file_name=stl_name,\n            unit=unit_in,\n            internal_U=U_internal,\n            internal_T=T_internal,\n            internal_CO2=CO2_internal,\n            internal_P=P_internal,\n            internal_P_rgh=P_rgh_internal,\n            internal_alphat=alphat_internal,\n            internal_epsilon=epsilon_internal,\n            internal_k=k_internal,\n            internal_nut=nut_internal,\n            internal_G=G_internal,\n            internal_Ydefault=Ydefault_internal,\n            write_blockmesh=True,\n            padding_m=pad_m,\n            cell_size_m=cell_m,\n            write_snappy=True,\n            inside_point=inside_pt,\n            write_constant=True,\n            write_fv=True,\n            fvSchemes_path=fvSchemes_src,\n            fvSolution_path=fvSolution_src\n        )\n        \n        # controDict\n        if cdict_json:\n            cpath = cfdict.write_control_dict_from_json(target_dir, json.dumps(cdict_json))\n            logs.append(f\"controlDict written: {cpath}\")\n        \n        # patch PIMPLE settings in fvSolution\n        patched_path = patch_fvSolution_pimple(\n            fvsolution_path=paths[\"fvSolution\"],\n            pRefPoint=inside_pt,\n            residual_value=rv\n        )\n        logs.append(f\"fvSolution patched: {patched_path}\")\n\n        # summary\n        logs.append(\"\\n==== summary ====\\n\")\n        if 'stl' in paths:       logs.append(f\"STL:               {paths.get('stl')}\")\n        if 'blockMesh' in paths: logs.append(f\"blockMeshDict:     {paths.get('blockMesh')}\")\n        if 'snappy' in paths:    logs.append(f\"snappyHexMeshDict: {paths.get('snappy')}\")\n        if 'U' in paths:         logs.append(f\"0/U:               {paths['U']}\")\n        if 'T' in paths:         logs.append(f\"0/T:               {paths['T']}\")\n        if 'CO2' in paths:       logs.append(f\"0/CO2:             {paths['CO2']}\")\n        if 'p' in paths:         logs.append(f\"0/p:               {paths['p']}\")\n        if 'p_rgh' in paths:     logs.append(f\"0/p_rgh:           {paths['p_rgh']}\")\n        if 'alphat' in paths:    logs.append(f\"0/alphat:          {paths['alphat']}\")\n        if 'epsilon' in paths:   logs.append(f\"0/epsilon:         {paths['epsilon']}\")\n        if 'k' in paths:         logs.append(f\"0/k:               {paths['k']}\")\n        if 'nut' in paths:       logs.append(f\"0/nut:             {paths['nut']}\")\n        if 'G' in paths:         logs.append(f\"0/G:               {paths['G']}\")\n        if 'Ydefault' in paths:  logs.append(f\"0/Ydefault:        {paths['Ydefault']}\")\n\n        if inside_pt is not None:\n            logs.append(f\"insidePoint used: {inside_pt}\")\n        if 'fvSchemes' in paths:  logs.append(f\"fvSchemes:         {paths['fvSchemes']}\")\n        if 'fvSolution' in paths: logs.append(f\"fvSolution:         {paths['fvSolution']}\")\n        logs += lgs\n        log = \"\\n\".join(logs)\n\nexcept Exception as e:\n    case_path = \"\"\n    log = f\"[Error] {e}\"\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}