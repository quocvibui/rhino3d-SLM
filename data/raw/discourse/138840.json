{
  "source_url": "https://discourse.mcneel.com/t/mesh-extrusion-not-working-as-expected/138840",
  "topic_id": 138840,
  "title": "Mesh Extrusion not working as expected",
  "question": "Iâ€™m using the Rhino.Geometry.Mesh.CreateFromCurveExtrusion Method, like this:\n\n\n  private void RunScript(DataTree<Curve> crv_Profile, DataTree<Polyline> poly_Profile1, DataTree<Polyline> poly_Profile2, Vector3d extr_Vec, DataTree<Point3d> in_BboxPts, ref object A)\n  {\n    List<Mesh> output = new List<Mesh>();\n    var mesh_Params = Rhino.Geometry.MeshingParameters.QualityRenderMesh;\n\n    for (int i = 0; i < crv_Profile.BranchCount; i++){\n      for (int j = 0; j < crv_Profile.Branch(i).Count; j++){\n        Rhino.Geometry.BoundingBox box = new Rhino.Geometry.BoundingBox(in_BboxPts.Branch(i, j)[0], in_BboxPts.Branch(i, j)[1]);\n        Mesh out_Mesh = Rhino.Geometry.Mesh.CreateFromCurveExtrusion(crv_Profile.Branch(i)[j], extr_Vec, mesh_Params, box);\n        Mesh mesh_Pline1 = Rhino.Geometry.Mesh.CreateFromClosedPolyline(poly_Profile1.Branch(i)[j]);\n        Mesh mesh_Pline2 = Rhino.Geometry.Mesh.CreateFromClosedPolyline(poly_Profile2.Branch(i)[j]);\n        out_Mesh.Append(mesh_Pline1);\n        out_Mesh.Append(mesh_Pline2);\n        output.Add(out_Mesh);\n      }\n    }\n    A = output;\n\n\n\nThe result has the mesh going past the expected top and bottom. If I change the extrusion vector length to very small 0.01, there are still two parts sticking out of the top and bottom. Does anyone know what is going on here? Here are some pictures to describe the problem:\n\n\n\nAmplitude is 8.5\n\n\n\nAmplitude 0.01",
  "code_blocks": [
    {
      "code": "\"\"\"Create a lofted mesh through a set of section polylines.\"\"\"\n\n__author__ = \"diff-arch (https://diff-arch.xyz)\"\n__version__ = \"1.2.1 (2021-10-16)\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport Grasshopper as gh\nimport math\n\n\nclass MeshLoft:\n    \"\"\"Creates a lofted mesh through a set of section polylines.\n    \n    Attributes:\n        polylines (list): Valid, closed or open polylines to loft\n        close_loft (bool): Optional, if True the loft will be closed\n        cap_loft (bool): Optional, if True the loft will be capped\n    \n    To use:\n        >>> ml = MeshLoft(polylines)\n        >>> loft = ml.mesh\n    \"\"\"\n    def __init__(self, polylines, close_loft=None, cap_loft=None):\n        \"\"\"Inits this mesh loft.\"\"\"\n        self.polylines = polylines\n        self.close_loft = close_loft\n        self.cap_loft = cap_loft\n        self.vertices = self.get_vertices()\n        self.faces = self.construct_faces()\n        self.mesh = self.construct_mesh()\n        \n        \n    def get_vertices(self):\n        \"\"\"Gets the vertices for each polyline in self.polylines.\n        \n        Returns:\n          The new nested list of vertices per polyline.\n        \"\"\"\n        pline_vertices = []\n        for pline in self.polylines:\n            vertices = []\n            for i in xrange(len(pline)):\n                vertices.append(pline[i])\n            pline_vertices.append(vertices)\n        return pline_vertices\n    \n    \n    def index_vertices(self):\n        \"\"\"Indexes the vertices of each polyline with integer numbers,\n            that are necessary to later assign the vertices to mesh faces.\n        \n        Returns:\n          The nested list of vertex indices (e.g. [[0,1,2], [3,4,5], ..]).\n        \"\"\"\n        vtx_indices = [] \n        for i in xrange(len(self.vertices)):\n            indices = []\n            for j in xrange(len(self.vertices[i])):\n                indices.append(i * len(self.vertices[i]) + j)\n            vtx_indices.append(indices)\n        return vtx_indices\n    \n    \n    def construct_faces(self):\n        \"\"\"Constructs quad faces between all adjacent polyline pairs.       \n        \n        Returns:\n          The nested list of face tuples (e.g. [(0,1,7,6), ...]).\n        \"\"\"\n        vtx_indices = self.index_vertices()\n        faces = []\n        for i in xrange(len(vtx_indices)):\n            if i < len(vtx_indices) - 1: \n                # Loop the polyline vertex indices up to the last curve\n                for j in xrange(len(vtx_indices[i])-1): # vertices\n                    v1 = j + (i * len(vtx_indices[i]))\n                    v2 = j + (i * len(vtx_indices[i])) + 1\n                    v3 = j + ((i + 1) * len(vtx_indices[i])) + 1\n                    v4 = j + ((i + 1) * len(vtx_indices[i]))\n                    faces.append((v1, v2, v3, v4))\n            else:\n                # Loop the polyline vertex indices of the last curve\n                if self.close_loft:\n                    for j in xrange(len(vtx_indices[i])-1): # vertices\n                        v1 = j + (i * len(vtx_indices[i]))\n                        v2 = j + (i * len(vtx_indices[i])) + 1\n                        v3 = j + 1\n                        v4 = j\n                        faces.append((v1, v2, v3, v4))\n        return faces\n    \n    \n    def construct_mesh(self, angle_tolerance=-1.0):\n        \"\"\"Constructs a lofted mesh from self.vertices and self.faces\n            and adds caps to it, if necessary.\n        \n        Args:\n          angle_tol (float): An optional angle tolerance for vertex welding\n        \n        Returns:\n          The new mesh loft.\n        \"\"\"\n        if angle_tolerance == None or angle_tolerance <= 0:\n            angle_tol = sc.doc.ModelAngleToleranceRadians\n        \n        mesh = rg.Mesh()\n\n        # Add the mesh loft vertices\n        for pline_vertices in self.vertices:\n            for vertex in pline_vertices:\n                mesh.Vertices.Add(vertex)\n        # Add the mesh loft faces\n        for face in self.faces:\n            v0, v1, v2, v3 = face\n            mesh.Faces.AddFace(v0, v1, v2, v3)\n        # Add the mesh caps\n        if self.cap_loft != None and self.cap_loft > 0:\n            end_curves = [self.polylines[0], self.polylines[-1]]\n            if self.cap_loft == 1: # flat cap\n                mesh_caps = [self.construct_flat_cap(c) for c in end_curves]\n            cap_fails = 0    \n            for cap in mesh_caps:\n                if cap != None:\n                    mesh.Append(cap)\n                    mesh.Weld(angle_tolerance)\n                    mesh.Vertices.CombineIdentical(False, False)\n                else:\n                    cap_fails += 1\n            if cap_fails == len(end_curves):\n                err = \"Both caps failed.\"\n                ghenv.Component.AddRuntimeMessage(\\\n                    gh.Kernel.GH_RuntimeMessageLevel.Error, err)\n            if cap_fails == len(end_curves) - 1:\n                err = \"One cap failed.\"\n                ghenv.Component.AddRuntimeMessage(\\\n                    gh.Kernel.GH_RuntimeMessageLevel.Error, err)\n        # Compute the normals and compact the mesh\n        mesh.Normals.ComputeNormals()\n        mesh.Compact()\n        return mesh\n    \n    \n    def construct_flat_cap(self, edge, tolerance=None):\n        \"\"\"Constructs a flat mesh cap for a closed, naked mesh edge.\n        \n            Edge polylines with a count of 4 or 5 vertices produce single,\n            triangular or quad faces. A count of more than 5 edge vertices\n            results in a triangulated mesh. If these edge vertices share a\n            center vertex contained inside the naked edge, the face count\n            equals the number of edge segments, and the faces are radially\n            oriented around this center vertex. If the center vertex lies \n            outside the closed mesh edge, the triangulated mesh is produced\n            from the edge polyline itself.\n        \n        Args:\n          edge (Rhino.Geometry.Polyline): A polyline representing a \n            closed, naked mesh edge\n          tolerance (float): An optional tolerance for planar projection\n        \n        Returns:\n          The new mesh cap on success, or None.\n        \"\"\"\n        if tolerance == None or tolerance <= 0:\n            tolerance = sc.doc.ModelAbsoluteTolerance\n        \n        mesh_cap = rg.Mesh()\n        # Test for planarity of the mesh edge polyline\n        pcurve = rg.PolylineCurve(edge)\n        is_planar, plane = pcurve.TryGetPlane()\n        if not is_planar:\n            # Construct a planar test edge from the non-planar one\n            rc, plane = rg.Plane.FitPlaneToPoints(edge)\n            proj_pts = [plane.ClosestPoint(pt) for pt in edge]\n            pcurve = rg.PolylineCurve(proj_pts)\n        # Find the center vertex of the naked mesh edge\n        center_vtx = edge.CenterPoint()\n        # Test for center vertex mesh edge containment\n        rc = pcurve.Contains(center_vtx, plane, tolerance)\n        if rc == rg.PointContainment.Outside \\\n            or rc == rg.PointContainment.Coincident:\n            # Mesh cap corresponds to a triangulated polyline\n            mesh_cap = rg.Mesh.CreateFromClosedPolyline(edge)\n        if rc == rg.PointContainment.Inside:\n            if edge.Count - 1 == 3:\n                # Mesh cap is composed of a single tri face\n                for i in xrange(edge.Count - 1):\n                    mesh_cap.Vertices.Add(edge[i])\n                mesh_cap.Faces.AddFace(0, 1, 2) \n            if edge.Count - 1 == 4:\n                # Mesh cap is composed of a single quad face\n                for i in xrange(edge.Count - 1):\n                    mesh_cap.Vertices.Add(edge[i])\n                mesh_cap.Faces.AddFace(0, 1, 2, 3)\n            if edge.Count > 5:\n                fragments = shatter_at_kinks(edge)\n                \n                if all(s.SegmentCount == 2 for s in fragments):\n                    # Mesh cap is radially quad-ed around the center vertex\n                    discs = get_discontinuities(edge)\n                    closest_disc_idx, closest_dist_sq = find_closest_point(edge.First, discs)\n                    \n                    if closest_dist_sq > sc.doc.ModelAbsoluteTolerance:\n                        # Adjust the edge start vertex to a discontinuity one\n                        closest_vtx_idx, _ = closest_point(discs[closest_disc_idx], edge)\n                        edge = adjust_seam(edge, closest_vtx_idx)\n\n                    for i in xrange(edge.Count):\n                        mesh_cap.Vertices.Add(edge[i])\n                    mesh_cap.Vertices.Add(center_vtx)\n                    for i in xrange(0, edge.Count - 1, 2):\n                        v0 = i\n                        v1 = i + 1\n                        v2 = edge.Count\n                        v3 = edge.Count-2 if i == 0 else i - 1\n                        mesh_cap.Faces.AddFace(v0, v1, v2, v3)\n                        \n                else:\n                    # Mesh cap is radially triangulated around the center vertex\n                    for i in xrange(edge.Count):\n                        mesh_cap.Vertices.Add(edge[i])\n                    mesh_cap.Vertices.Add(center_vtx)\n                    for i in xrange(edge.Count - 1):\n                        v0 = i\n                        v1 = i + 1\n                        v2 = edge.Count\n                        mesh_cap.Faces.AddFace(v0, v1, v2)\n                \n        if rc == rg.PointContainment.Unset:\n            err = \"Open polylines can't produce capped mesh lofts.\"\n            ghenv.Component.AddRuntimeMessage(\\\n                gh.Kernel.GH_RuntimeMessageLevel.Warning, err)\n            return\n        # Compute the normals and compact the mesh\n        mesh_cap.Normals.ComputeNormals()\n        mesh_cap.Compact()\n        return mesh_cap\n\n\n######################## UTILITY FUNCTIONS #########################  \n\n\ndef align_polylines(polylines, guide_idx=None):\n    \"\"\"Aligns closed polylines so that their start/end vertices fall inline.\n        If the optional guide index is not defined, the polylines align to \n        the start/end vertex of the first polyline. \n    \n    Args:\n      polylines (list): A list of closed polylines\n      guide_idx (int): An optional guide index for the polylines to align to\n    \n    Returns:\n      The list of aligned polylines on success, or the unaltered polylines.\n    \"\"\"\n    if any([True for p in polylines if not p.IsClosed]):\n        err = \"Open polylines can't be aligned.\"\n        ghenv.Component.AddRuntimeMessage(\\\n            gh.Kernel.GH_RuntimeMessageLevel.Warning, err)\n        return polylines\n    \n    if guide_idx == None or guide_idx < 0:\n        guide_idx = 0\n    elif guide_idx > len(polylines[0]):\n        guide_idx = 0\n    \n    aligned_polylines = [polylines[guide_idx]]\n    for i in range(1, len(polylines)):\n        # Get the guide vertex of the previous polyline\n        guide_vtx = polylines[i-1][guide_idx]\n        # Get the closest index of a vertex of the current polyline\n        closest_idx = polylines[i].ClosestIndex(guide_vtx) # -1 on error\n        if closest_idx < 0:\n            return\n        # Get a list of indices of the current polyline\n        indices = range(len(polylines[i])-1)\n        # Restructure the polyline indices to align them\n        align_indices = indices[closest_idx:] + indices[:closest_idx]\n        align_vertices = [polylines[i][j] for j in align_indices]\n        align_vertices.append(align_vertices[0])\n        aligned_polylines.append(rg.Polyline(align_vertices))\n        # Update the guide index\n        guide_idx = closest_idx\n    return aligned_polylines\n\n\ndef shatter_at_kinks(pline, tol=sc.doc.ModelAngleToleranceRadians):\n    \"\"\"Shatters a polyline into sections at sharp kinks.\n    \n    Args:\n      pline (Rhino.Geometry.Polyline): A polyline to shatter\n      tol (float): An angle tolerance (in radians) between adjacent segment \n        for a break to happen, by default the document angle tolerence\n    \n    Returns: \n      A list of polyline segments.\n    \"\"\"\n    segments = pline.GetSegments()\n    fragments = [rg.Polyline()]\n    for i in xrange(pline.SegmentCount):\n        current_seg = segments[i]\n        next_seg = segments[0] if i == pline.SegmentCount-1 else segments[i+1]\n        angle = rg.Vector3d.VectorAngle(\n            current_seg.UnitTangent, \n            next_seg.UnitTangent\n        )\n        fragments[-1].Add(current_seg.From)\n        if angle < tol:\n            if i == pline.SegmentCount-1:\n                if pline.IsClosed:\n                    fragments[0].Insert(0, current_seg.From)\n                    fragments.pop()\n                else:\n                    fragments[-1].Add(current_seg.To)\n            continue\n        fragments[-1].Add(current_seg.To)\n        if i < pline.SegmentCount - 1:\n            fragments.append(rg.Polyline())\n    return fragments\n    \n\ndef get_discontinuities(pline, tol=sc.doc.ModelAngleToleranceRadians):\n    \"\"\"Returns all discontinuities along a polyline.\"\"\"\n    fragments = shatter_at_kinks(pline, tol)\n    vertices = []\n    for frag in fragments:\n        vertices.append(frag.First)\n    if not pline.IsClosed:\n        vertices.append(fragments[-1].Last)\n    return vertices\n    \n\ndef find_closest_point(test_pt, points):\n    \"\"\"Finds the closest point to a test point in a list of points.\n    \n    Args:\n      test_pt (Rhino.Geometry.Point3d): Point to search from\n      points (list): Collection of points to search\n      \n    Returns:\n      The index of the closest point [0] and the squared distance [1]\n        between it and the test point.\n    \"\"\"\n    min_dist_sq = float(\"inf\")\n    closest_idx = None\n    for i, pt in enumerate(points):\n        dd = test_pt.DistanceToSquared(pt)\n        if dd < min_dist_sq:\n            min_dist_sq = dd\n            closest_idx = i\n    return closest_idx, min_dist_sq\n\n\ndef adjust_seam(pline, index):\n    \"\"\"Adjusts the seam or start point of a closed polyline.\n    \n    Args:\n      pline (Rhino.Geometry.Polyline): A polyline to adjust\n      index (int): Index of a polyline vertex to move the seam to\n    \n    Returns:\n      The adjusted polyline.\n    \"\"\"\n    if not pline.IsClosed():\n        return pline\n    new_pline = rg.Polyline()\n    for i in xrange(index, pline.Count, 1):\n        new_pline.Add(pline[i])\n    for i in xrange(1, index+1):\n        new_pline.Add(pline[i])\n    return new_pline",
      "language": "python",
      "author": "diff-arch",
      "post_number": 3,
      "is_solution": false
    },
    {
      "code": "private void RunScript(DataTree<Curve> crv_Profile, DataTree<Polyline> poly_Profile1, DataTree<Polyline> poly_Profile2, Vector3d extr_Vec, DataTree<Point3d> in_BboxPts, ref object A)\n  {\n    List<Mesh> output = new List<Mesh>();\n    var mesh_Params = Rhino.Geometry.MeshingParameters.QualityRenderMesh;\n\n    for (int i = 0; i < crv_Profile.BranchCount; i++){\n      for (int j = 0; j < crv_Profile.Branch(i).Count; j++){\n        Rhino.Geometry.BoundingBox box = new Rhino.Geometry.BoundingBox(in_BboxPts.Branch(i, j)[0], in_BboxPts.Branch(i, j)[1]);\n        Mesh out_Mesh = Rhino.Geometry.Mesh.CreateFromCurveExtrusion(crv_Profile.Branch(i)[j], extr_Vec, mesh_Params, box);\n        Mesh mesh_Pline1 = Rhino.Geometry.Mesh.CreateFromClosedPolyline(poly_Profile1.Branch(i)[j]);\n        Mesh mesh_Pline2 = Rhino.Geometry.Mesh.CreateFromClosedPolyline(poly_Profile2.Branch(i)[j]);\n        out_Mesh.Append(mesh_Pline1);\n        out_Mesh.Append(mesh_Pline2);\n        output.Add(out_Mesh);\n      }\n    }\n    A = output;",
      "language": "csharp",
      "author": "devin_jernigan",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "materials",
    "mesh",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 8,
  "posts_count": 9,
  "views": 1287
}