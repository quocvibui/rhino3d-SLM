{
  "source_url": "https://github.com/TheoArchi/EsquisSons/blob/00d1b02f7ce3e190b5c4c3429d3e84756c29bfdb/Components_Uncompiled_for%20ghpython/VisualizeReflections.py",
  "repo": "TheoArchi/EsquisSons",
  "repo_stars": 3,
  "repo_description": "Esquissons is a grasshopper plugin which help you to design with sound ;)",
  "license": "NOASSERTION",
  "filepath": "Components_Uncompiled_for ghpython/VisualizeReflections.py",
  "instruction": "Visualize Reflexion close to listener.\nUse Visualize Output of \"EsquisSons Main engine\" :)\n<WORKS ONLY WITH UNTRIMMED BREP OR SURFACES / You may encounter some bugs in semi-closed volumes>\n-\nAAU /...",
  "code": "\n\"\"\"Visualize Reflexion close to listener.\nUse Visualize Output of \"EsquisSons Main engine\" :)\n<WORKS ONLY WITH UNTRIMMED BREP OR SURFACES / You may encounter some bugs in semi-closed volumes>\n-\nAAU / Theo Marchal / BETA VERSION / MARS2020\"\"\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\nclass MyComponent(component):\n    \n    def RunScript(self, Vi, NmbrOfRay, NmbrOfRef, Tolerance):\n        \n        __author__ = \"theomarchal\"\n        self.Params.Input[0].Description = \"Visualize (from esquissons main engine)\"\n        self.Params.Input[1].Description = \"Definition/number of ray (1-100)<default=10>\"\n        self.Params.Input[2].Description = \"Level of reflexion/number of bounces(1-10)<default=2>\"\n        self.Params.Input[3].Description = \"Ray Distance to listener tolerance (0.1-1.0)<default=0.5>\"\n        self.Params.Output[0].Description = \"Reflexion Rays\"\n        self.Name = \"Visualize Reflections\"\n        self.NickName = \"Visualize Rays\" \n        self.Message = \"EsquisSons V3\"\n        self.Category = \"EsquisSons\"\n        self.SubCategory = \"2/ Visualization\"\n        Def = NmbrOfRay\n        Level = NmbrOfRef\n        Dist = Tolerance\n        import rhinoscriptsyntax as rs\n        import Grasshopper.Kernel as gh\n        \n        rem = gh.GH_RuntimeMessageLevel.Remark\n        ero = gh.GH_RuntimeMessageLevel.Error\n        war = gh.GH_RuntimeMessageLevel.Warning\n        \n        \n        if Def == None :\n            Def = 10\n        if Level == None :\n            Level =2\n        if Dist == None :\n            Dist = 0.5\n        try:\n            Ge =Vi[0]\n        except:\n            self.AddRuntimeMessage(ero, 'A \"Vi\" ouptut from main engine must be connected !')\n            raise Exception('noInput')\n        Lis =Vi[1]\n        Src =Vi[2]\n        udiv = Def\n        vdiv = Def\n        Pt_L = Lis [0][0]\n        Pt_R = Lis [0][2]\n        srf = []\n        FirstRay = []\n        SecondRay = []\n        First_RefPoint = []\n        drawray =[]\n        for i in Ge :\n            srf.append(i[0])\n        for i in Src :\n            sph =(rs.AddSphere(i[1],i[2]))\n            Src_pt =(i[1])\n            u = rs.SurfaceDomain(sph,0)\n            v = rs.SurfaceDomain(sph,1)\n            pts = []\n            for i in range(0, udiv+1, 1):\n                for j in range(0, vdiv+1, 1):\n                    pt = (i/udiv,j/vdiv,0)\n                    sphP = rs.SurfaceParameter(sph,pt)\n                    newpt = rs.EvaluateSurface(sph,sphP[0],sphP[1])\n                    pts.append(rs.AddPoint(newpt))\n            Dir = []\n            for p in pts:\n                Dir.append(rs.VectorCreate(p,Src_pt))\n            Reflexion = []\n            for d in Dir :\n                Reflexion.append(rs.ShootRay(srf,Src_pt,d,reflections=Level))\n            SourceRay = []\n            for v in Reflexion :\n                Cl_Pt = []\n                Ray_v = []\n                try :\n                    Ray_v.append(rs.AddPolyline(v))\n                except :\n                    pass\n                for u in Ray_v :\n                    pt_on = rs.CurveClosestPoint (u,Pt_L)\n                    cl = rs.EvaluateCurve(u,pt_on)\n                    Dicl = (rs.Distance(Pt_L,cl))\n                    if Dicl <= ((Lis [0])[3])*Dist:\n                        try:\n                            drawray.append(u)\n                        except:\n                            pass\n        if len(drawray) == 0 :\n            self.AddRuntimeMessage(war, 'No ray, please be sure Geometries are connected to main engine and placed to create reflexions')\n            self.AddRuntimeMessage(war, 'Change parameters to generate more rays')\n            Rays = None\n        else : \n            Rays = drawray\n        return Rays\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}