{
  "source_url": "https://github.com/ChristopherVoltl/Functionally-Graded-Spatial-Printing/blob/6b41d41d74c4e17e284adb2d04fbdaa7bf061c01/voxel/voxelGeneration.py",
  "repo": "ChristopherVoltl/Functionally-Graded-Spatial-Printing",
  "repo_stars": 2,
  "repo_description": "a computational method for 3D printing functionally graded lattice structures using an industrial robotic arm and finite element analysis, optimizing toolpaths to create lightweight, high-performance parts with varying densities.",
  "license": "MIT",
  "filepath": "voxel/voxelGeneration.py",
  "instruction": "Voxel generation",
  "code": "import rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Rhino.Geometry as rg\r\nimport Rhino.DocObjects as rd\r\nimport math\r\n\r\ndef voxelize_brep(brep, z , points_guid):\r\n    bbox = rs.BoundingBox(brep)\r\n    if bbox is None:  # Check if bounding box exists\r\n        return None\r\n\r\n    min_pt, max_pt = bbox[0], bbox[6]\r\n    x_span = max_pt.X - min_pt.X\r\n    y_span = max_pt.Y - min_pt.Y\r\n    z_span = max_pt.Z - min_pt.Z\r\n\r\n    x_voxels = int(x_span / voxel_size) + 1\r\n    y_voxels = int(y_span / voxel_size) + 1\r\n    z_voxels = int(z_span / voxel_size) + 1\r\n\r\n    voxels = []\r\n\r\n    for i in range(x_voxels):\r\n        for j in range(y_voxels):\r\n            for k in range(z_voxels):\r\n                x = min_pt.X + i * voxel_size\r\n                y = min_pt.Y + j * voxel_size\r\n                z = min_pt.Z + k * voxel_size\r\n                voxel = rg.Box(rg.Plane.WorldXY, rg.Interval(x, x + voxel_size), rg.Interval(y, y + voxel_size), rg.Interval(z, z + voxel_size))\r\n                voxel_guid = sc.doc.Objects.AddBrep(voxel.ToBrep())\r\n                intersect = rg.Intersect.Intersection.BrepBrep(brep, voxel.ToBrep(), sc.doc.ModelAbsoluteTolerance)\r\n                voxel_brep = voxel.ToBrep()\r\n                \r\n                #calculate the closest point in the to the voxel\r\n                voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n                #closest_point = brep.ClosestPoint(rs.coercebrep(brep_guid))\r\n                coordinates = []\r\n                \r\n                for point in points_guid:\r\n                    coordinates.append(rs.PointCoordinates(point))\r\n                #use that infor to extract the info of the point to get the color\r\n                closest_point, point_index = find_closest_point(voxel_centroid, coordinates)\r\n                point_property = get_point_property(points_guid[point_index])\r\n                \r\n                if len(intersect[1]) > 0:\r\n                    rs.ObjectColor(voxel_guid, point_property)\r\n                    voxels.append(voxel_guid)\r\n                else: \r\n                    rs.DeleteObject(voxel_guid)\r\n\r\n    return voxels\r\n\r\ndef get_point_property(point):\r\n    \r\n    #If ColorSource is ON::color_from_object, then value of m_color is used.\r\n    color = rs.ObjectColor(point)\r\n    return color\r\n    \r\ndef find_closest_point(target_point, point_set):\r\n    closest_point = None\r\n    closest_point_index = None\r\n    min_distance = float('inf')\r\n\r\n    for i in range(len(point_set)):\r\n        distance = target_point.DistanceTo(point_set[i])\r\n        if distance < min_distance:\r\n            min_distance = distance\r\n            closest_point = point_set[i]\r\n            closest_point_index = i\r\n\r\n    return closest_point, closest_point_index\r\n    \r\nbrep_guid = rs.GetObject(\"Select a Brep\", rs.filter.surface | rs.filter.polysurface)\r\npoints_guid = rs.GetObjects(\"Select points\", rs.filter.point)\r\n\r\n\r\n#points = [rs.coerce3dpoint(points_guid) for point_guid in point_guids]\r\n\r\n\r\nvoxel_size = rs.GetReal(\"Enter voxel size\", 2.0)\r\nvoxels = voxelize_brep(rs.coercebrep(brep_guid), voxel_size, points_guid)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}