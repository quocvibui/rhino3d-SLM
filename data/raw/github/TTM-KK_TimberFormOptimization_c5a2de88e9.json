{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/temp/TestBridge.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "temp/TestBridge.py",
  "instruction": "Test bridge",
  "code": "# -*- coding:utf-8 -*-\nfrom Generate import Generate\nimport rhinoscriptsyntax as rs\nimport time\nimport sys\nimport Sort as sort\nimport Instance as inst\nimport MoveObject as move\nfrom GA import Evaluation as eva\n\n#-----------------------------------------------------------------------------------------------------------------------\n# variable\nnum_timber = 5         # timberの総本数\nconnect_count = 10      # 接合制約数\ncantilever_num = 3      # 全体の中でのcantileverの数\nopt_tolerance = 1000    # 点接合への近似化の際の許容値\ndete_tolerance = 1000   # 他材との接触許容値\nname_list = []          # timberの名前\nprototype_ID = 0        # 試作個体の番号\npop_num = 1             # 初期個体数。世代ごとの個体数　ttm add 181003\npop_size = 1           # 交叉時に生成する個体数\ngenerate_range = 3000   # 生成可能範囲を指定。（現在は立方体） TODO 立方体以外にも対応したいところ。\ntournament_size = 3     # トーナメントサイズ\ngeneration_num = 1\n\n# temp_center_line = []   # 複製した中心線のリスト\n# temp_surface = []       # 複製したサーフェスのリスト\n# temp_mark = []\ntimber_num = []         # Timberクラスの各インスタンスの通し番号を格納するリスト\nnew_gene_num_list = []\n\n#-----------------------------------------------------------------------------------------------------------------------\n\n\n# Step0: rhino上のオブジェクトを取得。また通し番号を作成する。\n#-----------------------------------------------------------------------------------------------------------------------\n# centerLine = []\n# all_surface = []\n# all_mark = []\nget_center_line = rs.GetObjects(\"select %s lines\" % num_timber, rs.filter.curve)\nget_surface = rs.GetObjects(\"Select %s Surfaces\" % num_timber, rs.filter.surface)\nget_mark_line = rs.GetObjects(\"Select %s mark line\" % num_timber, rs.filter.curve)\n\nget_obj = sort.scanObjectSort(num_timber, get_center_line, get_surface, get_mark_line)\n\n# メンバ変数に格納する\ncenter_line = get_obj[0]\nall_surface = get_obj[1]\nall_mark = get_obj[2]\n\nfor i in range(0, num_timber):\n    name_list.append(i)  # リスト内包表記に書き換える\n\n\n# Step1: サーフィスと中心線を（個体数*Timberの種類）だけ複製。後でインスタンス変数に取り込むため、リストに格納する\n#-----------------------------------------------------------------------------------------------------------------------\ntemp_center_line = inst.axis_instance(pop_num, center_line)\ntemp_surface = inst.surface_instance(pop_num, all_surface)\ntemp_mark = inst.mark_instance(pop_num, all_mark)\n\n\n# Step2: Generateクラスのインスタンスを個体数だけ作成\n#-----------------------------------------------------------------------------------------------------------------------\ndic = {}\nfor foo in range(pop_num):\n    dic['generate' + str(foo)] = foo\n\nfor i in range(pop_num):\n    timber_num.append(i)\n\nfor i in range(pop_num):  # スキャンデータを生成クラスに渡す\n    dic['generate' + str(i)] = Generate(temp_center_line[i], temp_surface[i], temp_mark[i], name_list, num_timber, prototype_ID, timber_num[i])\n\n\n# Step3: 各Generateクラスのインスタンス毎にTimberクラスのインスタンスを作成\n#-----------------------------------------------------------------------------------------------------------------------\nfor j in range(pop_num):\n    dic['generate' + str(j)].objectTimber_1()  # Timberクラスのインスタンスを作成するGenerateクラスのメソッド\n\n\n# Step4 初期生成\n#-----------------------------------------------------------------------------------------------------------------------\nt1 = time.time()\nrs.EnableRedraw(False)\nfor i in range(pop_num):\n\n    dic['generate' + str(i)].cantilever(connect_count, opt_tolerance, dete_tolerance)  # Initial Generate Method.\n\n    tim1 = dic['generate' + str(i)].used_list[0]\n    tim2 = dic['generate' + str(i)].used_list[1]\n\n    copy_from = (0, 0, 0)\n    copy_to = ((generate_range * 2) * i, - generate_range * 2, 0)\n    vec_move = rs.VectorCreate(copy_to, copy_from)\n\n    move.MoveTimberObjects(tim1, tim2, vec_move)  # Moving Objects method for tim1,tim2\n\n    if cantilever_num   > num_timber - 2:  # if cantilever_num is not good, stop python script\n        sys.exit(\"cantilever_num is not suitable for num_timber\")\n\n    cantilever_start = time.time()  # Initial Cantilever generate part\n    for j in range(cantilever_num - 2):\n        dic['generate' + str(i)].cantilever(connect_count, opt_tolerance, dete_tolerance)\n    cantilever_end = time.time()\n    print(\"Initial Cantilever Method end time: %s this is num %s population\" %(cantilever_end - cantilever_start, i))\n\n    bridge_start = time.time()  # Initial Bridge generate part\n    for j in range(num_timber - (cantilever_num)):\n        dic['generate' + str(i)].bridge(connect_count, opt_tolerance, dete_tolerance)\n    bridge_end = time.time()\n    print(\"Initial Bridge Method end time: %s this is num %s population\" %(bridge_end - bridge_start, i))\n\n# t1_2 = time.time()\n# if t1_2 - t1 < 300:\n#     input(\"Initial generate is finished. if you want to continue, please type'1'.\")\n\nt2 = time.time()\n\ninit_generation_time = t2 - t1  # time of Initial Generate\nprint(\"\\n\")\nprint(\"init generation time: %s\"%(init_generation_time))\n\n# for i in range(num_timber):\n#     print(\"timber name of generate0\", dic['generate' + str(0)].used_list[i].partner_tim)\n\n\n# Step5: Gene information Generate\n#-----------------------------------------------------------------------------------------------------------------------\nall_gene_info = []\nfor i in range(pop_num):\n    gene_info = []\n    for j in range(num_timber):\n        gene_info.append(dic['generate' + str(i)].used_list[j].name)\n    all_gene_info.append(gene_info)\nprint(\"all gene information\", all_gene_info)\n\nfor i in range(pop_num):\n    for j in range(num_timber):\n        dic['generate' + str(i)].gene_information.append(dic['generate' + str(i)].used_list[j].name)\n\n    print(\"Gene information Pop: %s : %s\"%(i, dic['generate' + str(i)].gene_information))\n\n\n# Step6:  # Evaluate Process\n#-----------------------------------------------------------------------------------------------------------------------\nevaluation_value = []\nt3 = time.time()\nfor i in range(pop_num):\n    instance_pop = dic['generate' + str(i)]\n    evaluate_value = eva.overlap_num(num_timber, instance_pop)\n    dic['generate' + str(i)].evaluation = evaluate_value\n\n    evaluation_value.append(dic['generate' + str(i)].evaluation)\n    # print('evaluation value Pop: %s : value is %s'%(i, dic['generate' + str(i)].evaluation))\n\nt4 = time.time()\nprint(evaluation_value)\nprint(\"Evaluation Time: %s\"%(t4- t3))\n\n\n# Step7:  # Selection\n#-----------------------------------------------------------------------------------------------------------------------\nsort_generate_instance_list = []  # Genarateクラスインスタンスのリストを作成する。\nfor i in range(pop_num):\n    sort_generate_instance_list.append(dic['generate' + str(i)])\n\nprint(\"sort Generate Instance List\", sort_generate_instance_list)\n\n# リスト内のクラスインスタンスの保持する評価値に従いソートを行う。\nflag = True\nwhile flag:\n    counter = 0\n    for i in range(len(sort_generate_instance_list)):\n        value_a = sort_generate_instance_list[i].evaluation\n        if i == len(sort_generate_instance_list) - 1:\n            value_b = sort_generate_instance_list[0].evaluation\n        else:\n            value_b = sort_generate_instance_list[i + 1].evaluation\n\n        # TODO valueA と valueBを比較して両者を入れ替えるかそのまま保持するかを決定していく。\n        if i == len(sort_generate_instance_list) - 1:\n            if value_a > value_b:\n                sort_generate_instance_list[i], sort_generate_instance_list[0] = sort_generate_instance_list[0], sort_generate_instance_list[i]\n            else:\n                counter = counter + 1\n                continue\n        elif i != len(sort_generate_instance_list) - 1:\n            if value_a < value_b:\n                sort_generate_instance_list[i], sort_generate_instance_list[i + 1] = sort_generate_instance_list[i + 1], sort_generate_instance_list[i]\n            else:\n                counter = counter + 1\n                continue\n\n    if counter == len(sort_generate_instance_list):\n        flag = False\n\nprint(\"sort_generate_instance_list\", sort_generate_instance_list)\n\n# ソートしたリストから上位2個体を選択肢次世代に継承する。エリート選択\n# トーナメント選択のメソッドを作成する。\n# select_elite = []\n# elite_num = 2\n# flag = True\n# for i in range(elite_num):\n#     select = sort_generate_instance_list[i]\n#     select_elite.append(select)\n# if flag:\n#     for j in range(elite_num):\n#         del sort_generate_instance_list[0]\n#\n# print(\"select_elite\", select_elite)\n# print(\"sort_generate_instance_list\", sort_generate_instance_list)\n#\n#\n# tournament_list = []\n# tournament_size = 2\n# tournament_num = 3\n# for i in range(tournament_num):\n#     choices = rnd.sample(sort_generate_instance_list, tournament_size)\n#     print(\"choices\", choices)\n#     rnd_para = rnd.randint(0, tournament_size - 1)\n#     tournament_list.append(choices[rnd_para])\n#\n# print(\"tournament_list\", tournament_list)\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}