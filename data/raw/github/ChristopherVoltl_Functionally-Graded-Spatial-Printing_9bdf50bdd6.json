{
  "source_url": "https://github.com/ChristopherVoltl/Functionally-Graded-Spatial-Printing/blob/6b41d41d74c4e17e284adb2d04fbdaa7bf061c01/FEA/convert_data_Version2.py",
  "repo": "ChristopherVoltl/Functionally-Graded-Spatial-Printing",
  "repo_stars": 2,
  "repo_description": "a computational method for 3D printing functionally graded lattice structures using an industrial robotic arm and finite element analysis, optimizing toolpaths to create lightweight, high-performance parts with varying densities.",
  "license": "MIT",
  "filepath": "FEA/convert_data_Version2.py",
  "instruction": "Convert data version2",
  "code": "import json\r\nimport csv\r\n\r\nclass StructuralData:\r\n    \"\"\"Represents a the node data extracted from Ansys Discovery.\r\n\r\n    Attributes:\r\n        node (str): node number\r\n        point location (tuple): (x, y, z) \r\n        stress (float): stress data for each node\r\n\r\n    Methods:\r\n        jsonable: return JSON-friendly dict representation of the object\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize an instance.\"\"\"\r\n\r\n        self.node = []\r\n        self.coordinates = []\r\n        self.stress = []\r\n\r\n    def __str__(self):\r\n        \"\"\"Return a string representation of the object.\"\"\"\r\n\r\n        return self.type\r\n\r\n    def jsonable(self):\r\n\r\n        return {\r\n            'Node': self.node,\r\n            'coordinates': self.coordinates,\r\n            'stress': self.stress,\r\n        }\r\n\r\ndef convert_to_float(value):\r\n    \"\"\"Attempts to convert a string or a number < value > to a float. If unsuccessful or an\r\n    exception is encountered returns the < value > unchanged. Note that this function will\r\n    return True for boolean values, faux string boolean values (e.g., \"true\"), \"NaN\", exponential\r\n    notation, etc.\r\n\r\n    Parameters:\r\n        value (obj): string or number to be converted\r\n\r\n    Returns:\r\n        float: if value successfully converted; otherwise returns value unchanged\r\n    \"\"\"\r\n\r\n    if type(value) is list:\r\n        for item in value:\r\n            if type(item) is str:\r\n                try:\r\n                    float(item)\r\n                except:\r\n                    continue\r\n        return value\r\n\r\n    elif type(value) is str:\r\n        try:\r\n            value = float(value)\r\n            return value\r\n        except:\r\n            return value\r\n    else:\r\n        return value\r\n\r\n\r\ndef convert_to_int(value):\r\n    \"\"\"Attempts to convert a string or a number < value > to an int. If unsuccessful or an\r\n    exception is encountered returns the < value > unchanged. Note that this function will return\r\n    True for boolean values, faux string boolean values (e.g., \"true\"), \"NaN\", exponential\r\n    notation, etc.\r\n\r\n    Parameters:\r\n        value (obj): string or number to be converted\r\n\r\n    Returns:\r\n        int: if value successfully converted; otherwise returns value unchanged\r\n    \"\"\"\r\n    if type(value) is list:\r\n        for item in value:\r\n            if type(item) is str:\r\n                try:\r\n                    int(item)\r\n                except:\r\n                    continue\r\n        return value\r\n\r\n    elif type(value) is str:\r\n        try:\r\n            value = int(value)\r\n            return value\r\n        except:\r\n            return value\r\n    \r\n    else:\r\n        return value\r\n\r\ndef read_csv(filepath, encoding='utf-8', newline='', delimiter=','):\r\n    \"\"\"\r\n    Reads a CSV file, parsing row values per the provided delimiter. Returns a list of lists,\r\n    wherein each nested list represents a single row from the input file.\r\n\r\n    WARN: If a byte order mark (BOM) is encountered at the beginning of the first line of decoded\r\n    text, call < read_csv > and pass 'utf-8-sig' as the < encoding > argument.\r\n\r\n    WARN: If newline='' is not specified, newlines '\\n' or '\\r\\n' embedded inside quoted fields\r\n    may not be interpreted correctly by the csv.reader.\r\n\r\n    Parameters:\r\n        filepath (str): The location of the file to read\r\n        encoding (str): name of encoding used to decode the file\r\n        newline (str): specifies replacement value for newline '\\n'\r\n                       or '\\r\\n' (Windows) character sequences\r\n        delimiter (str): delimiter that separates the row values\r\n\r\n    Returns:\r\n        list: a list of nested \"row\" lists\r\n    \"\"\"\r\n\r\n    with open(filepath, 'r', encoding=encoding, newline=newline) as file_obj:\r\n        data = []\r\n        reader = csv.reader(file_obj, delimiter=delimiter)\r\n        for row in reader:\r\n            data.append(row)\r\n\r\n        return data\r\n    \r\ndef text_to_csv(input_file, output_file):\r\n    with open(input_file, 'r') as file:\r\n        lines = file.readlines()\r\n        lines = [line.strip() for line in lines if line.strip()] # Remove empty lines and leading/trailing whitespace\r\n\r\n\r\n    with open(output_file, 'w', newline='') as file:\r\n        writer = csv.writer(file)\r\n        for line in lines:\r\n            values = line.split()\r\n            writer.writerow(values)\r\n\r\ndef delete_rows_with_header(csv_file, header_text):\r\n    matching_indices = []\r\n    with open(csv_file, 'r') as file:\r\n        reader = csv.reader(file)\r\n        rows = list(reader)\r\n        for i, row in enumerate(rows[1:], start=1):\r\n            if header_text in row:\r\n                matching_indices.append(i)\r\n    for index in reversed(matching_indices):\r\n        del rows[index]\r\n    with open(csv_file, 'w', newline='') as file:\r\n        writer = csv.writer(file)\r\n        writer.writerows(rows)\r\n\r\ndef read_csv_to_dicts(filepath, encoding='utf-8', newline='', delimiter=','):\r\n    \"\"\"Accepts a file path, creates a file object, and returns a list of dictionaries that\r\n    represent the row values using the cvs.DictReader().\r\n\r\n    Parameters:\r\n        filepath (str): path to file\r\n        encoding (str): name of encoding used to decode the file\r\n        newline (str): specifies replacement value for newline '\\n'\r\n                       or '\\r\\n' (Windows) character sequences\r\n        delimiter (str): delimiter that separates the row values\r\n\r\n    Returns:\r\n        list: nested dictionaries representing the file contents\r\n     \"\"\"\r\n\r\n    with open(filepath, 'r', newline=newline, encoding=encoding) as file_obj:\r\n        data = []\r\n        reader = csv.DictReader(file_obj, delimiter=delimiter)\r\n        for line in reader:\r\n            data.append(line) # OrderedDict()\r\n            # data.append(dict(line)) # convert OrderedDict() to dict\r\n\r\n        return data\r\n\r\ndef read_json(filepath, encoding='utf-8'):\r\n    \"\"\"Reads a JSON document, decodes the file content, and returns a list or dictionary if\r\n    provided with a valid filepath.\r\n\r\n    Parameters:\r\n        filepath (str): path to file\r\n        encoding (str): name of encoding used to decode the file\r\n\r\n    Returns:\r\n        dict/list: dict or list representations of the decoded JSON document\r\n    \"\"\"\r\n\r\n    with open(filepath, 'r', encoding=encoding) as file_obj:\r\n        return json.load(file_obj)\r\n\r\n\r\ndef write_json(filepath, data, encoding='utf-8', ensure_ascii=False, indent=2):\r\n    \"\"\"Serializes object as JSON. Writes content to the provided filepath.\r\n\r\n    Parameters:\r\n        filepath (str): the path to the file\r\n        data (dict)/(list): the data to be encoded as JSON and written to the file\r\n        encoding (str): name of encoding used to encode the file\r\n        ensure_ascii (str): if False non-ASCII characters are printed as is; otherwise\r\n                            non-ASCII characters are escaped.\r\n        indent (int): number of \"pretty printed\" indention spaces applied to encoded JSON\r\n\r\n    Returns:\r\n        None\r\n    \"\"\"\r\n\r\n    with open(filepath, 'w', encoding=encoding) as file_obj:\r\n        json.dump(data, file_obj, ensure_ascii=ensure_ascii, indent=indent)\r\n\r\n\r\n\r\ndef create_point(data):\r\n\r\n    newpoint = {}\r\n\r\n    for key, value in data.items():\r\n        if key == \"LOCX (m)\":\r\n            value = convert_to_float(value)\r\n            newpoint.update({'coordinate': value})\r\n\r\ndef main():\r\n    print(\"meow\")\r\n    \r\n    '''\r\n    #convert text file into a dict\r\n    pt_data = 'fea/data/wall004NLIST.txt'\r\n\r\n    pt_csv = 'fea/data/pt_data.csv'\r\n\r\n    text_to_csv(pt_data, pt_csv)\r\n\r\n    delete_rows_with_header(pt_csv, \"NODE\")\r\n\r\n    pt_data = read_csv_to_dicts(pt_csv, delimiter=',')\r\n    write_json('pt_data.json', pt_data)\r\n\r\n    pt_json = './pt_data.json'\r\n\r\n    pt_json = read_json(pt_json, encoding='utf-8')\r\n    ansys = StructuralData()\r\n\r\n    for i in range(len(pt_json)):\r\n        #print(type(x_json[i]))\r\n        for key, value in pt_json[i].items():\r\n            if key == \"X\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                if type(value) is float:\r\n                    value = value*39.3701\r\n                    ansys.coordinates.append([value, 'none' , 'none'])\r\n\r\n    for i in range(len(pt_json)):\r\n        #print(type(y_json[i]))\r\n        for key, value in pt_json[i].items():\r\n            if key == \"Y\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                if type(value) is float:\r\n                    value = value*39.3701\r\n                    ansys.coordinates[i][1] = value\r\n\r\n    for i in range(len(pt_json)):\r\n        #print(type(z_json[i]))\r\n        for key, value in pt_json[i].items():\r\n            if key == \"Z\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                if type(value) is float:\r\n                    value = value*39.3701\r\n                    ansys.coordinates[i][2] = value '''\r\n\r\n\r\n    #convert text file into a dict\r\n    x_data = 'fea/data/LOCX.txt'\r\n\r\n    x_csv = 'fea/data/x_data.csv'\r\n\r\n    x_data = read_csv_to_dicts(x_data, delimiter='\\t')\r\n    write_json('Cx_data.json', x_data)\r\n\r\n    x_json = './Cx_data.json'\r\n\r\n    x_json = read_json(x_json, encoding='utf-8')\r\n    ansys = StructuralData()\r\n\r\n    for i in range(len(x_json)):\r\n        #print(type(x_json[i]))\r\n        for key, value in x_json[i].items():\r\n            if key == \"LOCX (m)\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                value = value*39.3701\r\n                ansys.coordinates.append([value, 'none' , 'none'])\r\n\r\n    y_data = 'fea/data/LOCY.txt'\r\n\r\n    y_csv = 'fea/data/y_data.csv'\r\n\r\n    y_data = read_csv_to_dicts(y_data, delimiter='\\t')\r\n    write_json('Cy_data.json', y_data)\r\n\r\n    y_json = './Cy_data.json'\r\n\r\n    y_json = read_json(y_json, encoding='utf-8')\r\n\r\n    for i in range(len(y_json)):\r\n        #print(type(y_json[i]))\r\n        for key, value in y_json[i].items():\r\n            if key == \"LOCY (m)\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                value = value*39.3701\r\n                ansys.coordinates[i][1] = value\r\n\r\n    z_data = 'fea/data/LOCZ.txt'\r\n\r\n    z_csv = 'fea/data/z_data.csv'\r\n\r\n    z_data = read_csv_to_dicts(z_data, delimiter='\\t')\r\n    write_json('Cz_data.json', z_data)\r\n\r\n    z_json = './Cz_data.json'\r\n\r\n    z_json = read_json(z_json, encoding='utf-8')\r\n\r\n    for i in range(len(z_json)):\r\n        #print(type(z_json[i]))\r\n        for key, value in z_json[i].items():\r\n            if key == \"LOCZ (m)\":\r\n                value = convert_to_float(value)\r\n                #convert to inch\r\n                value = value*39.3701\r\n                ansys.coordinates[i][2] = value \r\n\r\n    #stress data \r\n    stress_data = 'fea/data/stress.txt'\r\n\r\n    stress_csv = 'fea/data/stress_data.csv'\r\n\r\n    text_to_csv(stress_data, stress_csv)\r\n\r\n    stress_data = read_csv_to_dicts(stress_csv, encoding='unicode_escape', delimiter=',')\r\n    write_json('stress_data.json', stress_data)\r\n\r\n    stress_json = './stress_data.json'\r\n\r\n    stress_json = read_json(stress_json, encoding='unicode_escape')\r\n\r\n    for i in range(len(stress_json)):\r\n        #print(type(z_json[i]))\r\n        for key, value in stress_json[i].items():\r\n            if key == \"Number\":\r\n                value = convert_to_float(value)\r\n\r\n                ansys.stress.append(value)\r\n\r\n    #start rhino and add poionts to document\r\n\r\n    import rhinoinside\r\n    rhinoinside.load()\r\n    import System\r\n\r\n\r\n    import rhino3dm\r\n    #import System\r\n    from Rhino import RhinoDoc\r\n    from Rhino import DocObjects\r\n    from Rhino import Geometry\r\n    \r\n    model = rhino3dm.File3dm()   \r\n    low_stress_attr = rhino3dm.ObjectAttributes()\r\n    medium_stress_attr = rhino3dm.ObjectAttributes()\r\n    high_stress_attr = rhino3dm.ObjectAttributes()\r\n\r\n    # Create a new point with custom attrs.\r\n\r\n    # create and add layer\r\n    low_stress = rhino3dm.Layer()\r\n    medium_stress = rhino3dm.Layer()\r\n    high_stress = rhino3dm.Layer()\r\n\r\n\r\n    pts = ansys.coordinates\r\n    stress = ansys.stress\r\n    count_low = 0\r\n    pt_low = []\r\n    count_med = 0\r\n    pt_med = []\r\n    count_high = 0\r\n    pt_high = []\r\n\r\n\r\n    model.Layers.AddLayer('low_stress', (190, 255, 72, 255))\r\n\r\n    model.Layers.AddLayer('medium_stress', (255, 242, 161, 255))\r\n\r\n    model.Layers.AddLayer('high_stress', (255, 0, 118, 255))\r\n\r\n    low_stress_attr.Name = 'low_stress'\r\n    low_stress_attr.ObjectColor = (190, 255, 72, 255)\r\n\r\n\r\n\r\n    medium_stress_attr.Name = 'medium_stress'\r\n    medium_stress_attr.ObjectColor = (255, 242, 161, 255)\r\n\r\n\r\n\r\n    high_stress_attr.Name = 'high_stress'\r\n    high_stress_attr.ObjectColor = (255, 0, 118, 255)\r\n\r\n\r\n\r\n    doc = RhinoDoc.CreateHeadless(\"\")\r\n\r\n    file = RhinoDoc.Path\r\n\r\n\r\n    rhinofile = 'C:/Users/Chris/desktop/rhinopy.3dm'\r\n\r\n    #doc.Import(rhinofile)\r\n    #pts = System.Collections.Generic.List[Geometry.Point3d]()\r\n\r\n\r\n\r\n    for i in range(len(pts)):\r\n        #pt = tuple(pt)     \r\n        print(stress[i]) \r\n        stress_value = stress[i] \r\n        if stress_value < 80000:\r\n            attrs = DocObjects.ObjectAttributes()\r\n            attrs.LayerIndex = 0\r\n            attrs = DocObjects.ObjectAttributes()\r\n            attrs.ColorSource = DocObjects.ObjectColorSource.ColorFromObject\r\n            attrs.ObjectColor = System.Drawing.Color.Green\r\n            pt = doc.Objects.AddPoint(Geometry.Point3d(pts[i][0], pts[i][1], pts[i][2]), attrs)\r\n            #pt_low.append(new_pt.urn[9:])\r\n            count_low = count_low + 1\r\n            \r\n    \r\n            \r\n\r\n        elif  120000 < stress_value:\r\n            attrs = DocObjects.ObjectAttributes()\r\n            attrs.LayerIndex = 2\r\n            attrs.ColorSource = DocObjects.ObjectColorSource.ColorFromObject\r\n            attrs.ObjectColor = System.Drawing.Color.Red\r\n            pt = doc.Objects.AddPoint(Geometry.Point3d(pts[i][0], pts[i][1], pts[i][2]), attrs)\r\n            #pt_high.append(new_pt.urn[9:])\r\n            count_high = count_high + 1\r\n\r\n            \r\n\r\n        else:\r\n            attrs = DocObjects.ObjectAttributes()\r\n            attrs.LayerIndex = 1\r\n            attrs.ColorSource = DocObjects.ObjectColorSource.ColorFromObject\r\n            attrs.ObjectColor = System.Drawing.Color.Yellow\r\n            pt = doc.Objects.AddPoint(Geometry.Point3d(pts[i][0], pts[i][1], pts[i][2]), attrs)\r\n            #pt_med.append(new_pt.urn[9:])\r\n            count_med = count_med + 1\r\n\r\n    #doc.Views.ActiveView.Redraw()\r\n\r\n\r\n\r\n\r\n    for layer in model.Layers:\r\n        print('Name = {0}, Id = {1}'.format(layer.Name, layer.Id))\r\n\r\n    print (count_low, count_med, count_high)\r\n\r\n    rhVersion = 7\r\n    #model.Write(rhinofile, rhVersion)\r\n    doc.Export(rhinofile)\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhino3dm"
  ],
  "has_docstring": false
}