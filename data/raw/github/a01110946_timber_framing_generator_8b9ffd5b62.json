{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/utils/serialization.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/utils/serialization.py",
  "instruction": "Script: serialization.py\nLocation: src/timber_framing_generator/utils/serialization.py\nAuthor: Timber Framing Generator Team\nDate Created: 2025-03-24\nLast Modified: 2025-03-24",
  "code": "# File: src/timber_framing_generator/utils/serialization.py\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nScript: serialization.py\nLocation: src/timber_framing_generator/utils/serialization.py\nAuthor: Timber Framing Generator Team\nDate Created: 2025-03-24\nLast Modified: 2025-03-24\n\nDescription:\n    Contains custom classes for serializing and deserializing timber framing \n    results, including Rhino geometry objects. This module provides a unified \n    structure for storing, transmitting, and retrieving framing results.\n\nUsage:\n    from src.timber_framing_generator.utils.serialization import (\n        TimberFramingResults, DebugGeometry, \n        serialize_results, deserialize_results\n    )\n    \n    # Create and populate a results object\n    results = TimberFramingResults(wall_id=\"Wall_1\")\n    results.add_element(\"studs\", stud_object)\n    \n    # Serialize to JSON\n    json_str = serialize_results(results)\n    \n    # Deserialize from JSON\n    recovered_results = deserialize_results(json_str)\n\nDependencies:\n    - Rhino.Geometry\n    - System\n    - json\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional, Union\nimport json\nimport Rhino.Geometry as rg\nimport System\n\n\nclass DebugGeometry:\n    \"\"\"\n    Container for debug geometry elements used during framing generation.\n    \n    This class stores geometric elements used for debugging and visualization,\n    such as points, planes, profiles, and paths.\n    \"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize empty collections for debug geometry.\"\"\"\n        self.points: List[rg.Point3d] = []\n        self.planes: List[rg.Plane] = []\n        self.profiles: List[rg.GeometryBase] = []\n        self.paths: List[rg.Curve] = []\n\n\nclass TimberFramingResults:\n    \"\"\"\n    Container for all wall framing results.\n    \n    This class organizes framing elements by type and provides methods for\n    accessing and manipulating them. It can be serialized to JSON for\n    storage or transmission over API endpoints.\n    \n    Attributes:\n        wall_id: Unique identifier for the wall\n        bottom_plates: List of bottom plate geometry\n        top_plates: List of top plate geometry\n        king_studs: List of king stud geometry\n        studs: List of standard stud geometry\n        headers: List of header geometry\n        sills: List of sill geometry\n        trimmers: List of trimmer geometry\n        header_cripples: List of header cripple geometry\n        sill_cripples: List of sill cripple geometry\n        row_blocking: List of row blocking geometry\n        cells: List of cell data dictionaries\n        debug_geometry: DebugGeometry object containing debug elements\n        base_plane: Wall base plane for reference\n    \"\"\"\n    \n    def __init__(self, wall_id: Optional[str] = None) -> None:\n        \"\"\"\n        Initialize a TimberFramingResults container.\n        \n        Args:\n            wall_id: Optional unique identifier for the wall\n        \"\"\"\n        self.wall_id: Optional[str] = wall_id\n        self.bottom_plates: List[rg.GeometryBase] = []\n        self.top_plates: List[rg.GeometryBase] = []\n        self.king_studs: List[rg.GeometryBase] = []\n        self.studs: List[rg.GeometryBase] = []\n        self.headers: List[rg.GeometryBase] = []\n        self.sills: List[rg.GeometryBase] = []\n        self.trimmers: List[rg.GeometryBase] = []\n        self.header_cripples: List[rg.GeometryBase] = []\n        self.sill_cripples: List[rg.GeometryBase] = []\n        self.row_blocking: List[rg.GeometryBase] = []\n        self.cells: List[Dict[str, Any]] = []\n        self.debug_geometry: DebugGeometry = DebugGeometry()\n        self.base_plane: Optional[rg.Plane] = None\n        \n    def add_element(self, element_type: str, element: rg.GeometryBase) -> None:\n        \"\"\"\n        Add an element to the appropriate collection.\n        \n        Args:\n            element_type: Type of element (e.g., \"studs\", \"bottom_plates\")\n            element: Geometric element to add\n        \"\"\"\n        if hasattr(self, element_type):\n            getattr(self, element_type).append(element)\n            \n    def get_all_geometry(self) -> List[rg.GeometryBase]:\n        \"\"\"\n        Return all geometric elements as a single list.\n        \n        Returns:\n            Combined list of all framing elements\n        \"\"\"\n        return (self.bottom_plates + self.top_plates + self.king_studs + \n                self.studs + self.headers + self.sills + self.trimmers +\n                self.header_cripples + self.sill_cripples + self.row_blocking)\n    \n    def element_count(self, element_type: str) -> int:\n        \"\"\"\n        Return count of elements by type.\n        \n        Args:\n            element_type: Type of element to count\n            \n        Returns:\n            Number of elements of the specified type\n        \"\"\"\n        if hasattr(self, element_type):\n            return len(getattr(self, element_type))\n        return 0\n\n\nclass RhinoEncoder(json.JSONEncoder):\n    \"\"\"\n    Custom JSON encoder for Rhino geometry.\n    \n    This encoder handles serialization of Rhino geometry objects\n    by encoding them as Base64 strings with appropriate type information.\n    \"\"\"\n    \n    def default(self, obj: Any) -> Any:\n        \"\"\"\n        Custom encoding for special types.\n        \n        Args:\n            obj: Object to encode\n            \n        Returns:\n            JSON-serializable representation of the object\n        \"\"\"\n        # Handle Rhino geometry types\n        if isinstance(obj, rg.GeometryBase):\n            # Serialize to Base64 encoded string\n            return {\n                \"___rhino_geometry___\": True,\n                \"type\": obj.GetType().Name,\n                \"data\": System.Convert.ToBase64String(obj.Encode())\n            }\n        elif isinstance(obj, TimberFramingResults):\n            return {k: v for k, v in obj.__dict__.items() if not k.startswith('_')}\n        elif isinstance(obj, DebugGeometry):\n            return obj.__dict__\n        return super().default(obj)\n\ndef rhino_object_hook(dct: Dict[str, Any]) -> Union[Dict[str, Any], rg.GeometryBase]:\n    \"\"\"\n    Hook to decode serialized Rhino geometry.\n    \n    Args:\n        dct: Dictionary that might contain serialized Rhino geometry\n        \n    Returns:\n        Deserialized Rhino geometry object or the original dictionary\n    \"\"\"\n    if \"___rhino_geometry___\" in dct:\n        try:\n            data = System.Convert.FromBase64String(dct[\"data\"])\n            return rg.GeometryBase.Decode(data)\n        except Exception:\n            # If decoding fails, return the original dictionary\n            return dct\n    return dct\n\ndef serialize_results(results: Union[TimberFramingResults, List[TimberFramingResults]]) -> str:\n    \"\"\"\n    Serialize TimberFramingResults to JSON string.\n    \n    Args:\n        results: Single result object or list of result objects\n        \n    Returns:\n        JSON string representation\n    \"\"\"\n    encoder = RhinoEncoder()\n    return json.dumps(results, cls=encoder)\n\ndef deserialize_results(json_string: str) -> Union[TimberFramingResults, List[TimberFramingResults]]:\n    \"\"\"\n    Deserialize JSON string to TimberFramingResults objects.\n    \n    Args:\n        json_string: JSON string to deserialize\n        \n    Returns:\n        Deserialized TimberFramingResults object(s)\n    \"\"\"\n    return json.loads(json_string, object_hook=rhino_object_hook)\n\ndef get_property(obj: Any, property_path: str) -> Any:\n    \"\"\"\n    Get property value by path (e.g., 'debug_geometry.points')\n    \n    Args:\n        obj: Object to get property from\n        property_path: Dot-separated path to the property\n        \n    Returns:\n        Property value or None if not found\n    \"\"\"\n    if obj is None:\n        return None\n        \n    parts = property_path.split('.')\n    value = obj\n    \n    for part in parts:\n        if hasattr(value, part):\n            value = getattr(value, part)\n        else:\n            return None\n            \n    return value\n\ndef inspect_framing_results(framing_object):\n    \"\"\"\n    Inspect and print details of a TimberFramingResults object.\n    \"\"\"\n    print(f\"Framing object type: {type(framing_object).__name__}\")\n    \n    # Check wall data\n    if hasattr(framing_object, 'wall_data') and framing_object.wall_data:\n        print(\"\\nWall properties:\")\n        for key in ['wall_type', 'wall_length', 'wall_height', 'is_exterior_wall']:\n            if key in framing_object.wall_data:\n                print(f\"  {key}: {framing_object.wall_data.get(key)}\")\n    \n    # Print count of each framing element type\n    print(\"\\nFraming element counts:\")\n    for prop in [\n        'bottom_plates', 'top_plates', 'king_studs', 'headers', \n        'sills', 'trimmers', 'header_cripples', 'sill_cripples', \n        'studs', 'row_blocking'\n    ]:\n        if hasattr(framing_object, prop):\n            elements = getattr(framing_object, prop)\n            if isinstance(elements, list):\n                print(f\"  {prop}: {len(elements)} elements\")\n                \n                # Print details about the first element if available\n                if elements:\n                    first_elem = elements[0]\n                    print(f\"    First element type: {type(first_elem).__name__}\")\n                    \n                    # Get bounding box if available\n                    if hasattr(first_elem, 'GetBoundingBox'):\n                        try:\n                            bbox = first_elem.GetBoundingBox(True)\n                            if bbox.IsValid:\n                                print(f\"    Dimensions: W={bbox.Max.X-bbox.Min.X:.2f}, D={bbox.Max.Y-bbox.Min.Y:.2f}, H={bbox.Max.Z-bbox.Min.Z:.2f}\")\n                        except:\n                            print(\"    Could not get bounding box\")",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}