{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/gh_out.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/gh_out.py",
  "instruction": "Gh out",
  "code": "from .. import *\nfrom ..core import *\nfrom ..core import dc_base, dc_vec, dc_point, dc_cs, dc_line, dc_pline, dc_mesh, dc_pgon\nfrom .rhino_out import *\nfrom . import outie\nif VERBOSE_FS: print(\"gh_out loaded\")\n\nimport clr, collections\nimport Rhino.Geometry as rg\n\n#TODO: check at end of script if the user overwrote the established 'outie' with either a singleton, a list of sc.Geoms, or something else, and act accordingly (raising the appropriate warnings) \n\nclass GrasshopperOut(outie.Outie):\n    \"\"\"outie for pushing stuff to grasshopper\"\"\"\n    raw_types = [\"Curve\",\"Surface\"]\n\n    def __init__(self, name):\n        super(GrasshopperOut,self).__init__()\n        self._allow_foreign = True\n        self.name = name\n        \n    def extract_tree(self):\n        #creates a grasshopper data tree\n        #calls the draw function for each geometric object\n        #returns a list of whatever these draw functions return\n        clr.AddReference(\"Grasshopper\")\n        from Grasshopper import DataTree\n        from Grasshopper.Kernel.Data import GH_Path\n        clr.AddReference(\"DcPython\")\n        from DcPython import Decodes as dcp\n        \n        tree = DataTree[object]()\n        tree_p = DataTree[object]()\n        is_leaf = self._is_leaf(self.geom)\n        for n,g in enumerate(self.geom): \n            if is_leaf : \n                path = GH_Path(0)\n                self._add_branch(g, tree,tree_p,path)\n            else :\n                path = GH_Path(n)\n                self._add_branch(g, tree,tree_p,path)\n        \n        \n        self.clear() #empty the outie after each draw\n        return tree, tree_p\n        \n    def _is_leaf(self, items): return not any(self._should_iterate(item) for item in items)\n\n    def _should_iterate(self, item): return isinstance(item, collections.Iterable) and not isinstance(item,str)\n    \n    def _add_branch(self, g, tree, tree_p, path):\n        # here we sort out what type of geometry we're dealing with, and call the proper draw functions\n        # MUST LOOK FOR CHILD CLASSES BEFORE PARENT CLASSES (points before vecs)\n        \n        if isinstance(g, Geometry) and not g.do_translate:\n            tree.Add(g,path)\n            return True\n\n        # treat Tris as PGons\n        if isinstance(g, Tri):  g = PGon([g.pa,g.pb,g.pc])\n            \n        def extract_props(g):\n            from DcPython import Decodes as dcp\n            att = dcp.Decodes_Attributes()\n            att.layer = self.name\n            if not hasattr(g, 'props') : return att\n            #return \"::\".join([\"{0}={1}\".format(k,v) for (k, v) in g.props.items()])\n            if \"name\" in g.props : att.name = g.props[\"name\"]\n            if \"weight\" in g.props : att.weight = g.props[\"weight\"]\n            if \"color\" in g.props : att.setColor( g.props[\"color\"].r, g.props[\"color\"].g, g.props[\"color\"].b )\n            return att\n        \n        if self._should_iterate(g) :\n            is_leaf = self._is_leaf(g)\n            for n,i in enumerate(g): \n                npath = path.AppendElement(n)\n                if is_leaf : self._add_branch(i,tree,tree_p, path)\n                else : self._add_branch(i,tree,tree_p, npath)\n            return True\n        \n        # ADD ANY RAW TYPES DIRECTLY\n        if any(p in str(type(g)) for p in GrasshopperOut.raw_types) : \n            tree.Add(g,path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g, Point) : \n            tree.Add(self._drawPoint(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n        if isinstance(g, Vec) : \n            tree.Add(self._drawVec(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n        if isinstance(g, Mesh) : \n            tree.Add(self._drawMesh(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n        if isinstance(g, LinearEntity) : \n            rh_geom = self._drawLinearEntity(g)\n            props = extract_props(g)\n            if type(rh_geom) is list: \n                tree.AddRange(rh_geom,path)\n                for item in rh_geom: tree_p.Add(props, path)\n            else: \n                tree.Add(rh_geom,path)\n                tree_p.Add(props, path)\n            return True\n        \n        if isinstance(g, PLine) : \n            tree.Add(self._drawPLine(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g, Circle) : \n            tree.Add(self._drawCircle(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n            \n        if isinstance(g, Arc) : \n            tree.Add(self._drawArc(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g, Plane) : \n            tree.Add(self._drawPlane(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g, PGon): \n            tree.Add(self._drawPGon(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g,Curve): \n            tree.Add(self._drawCurve(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n\n        if isinstance(g, CS) : \n            tree.Add(self._drawCS(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n        if isinstance(g, Color) : \n            tree.Add(self._drawColor(g),path)\n            tree_p.Add(extract_props(g), path)\n            return True\n        \n        if isinstance(g, (Geometry) ) : raise NotImplementedError(\"i do not have a translation for that decodes geometry type in GrasshopperOut\")\n        tree.Add(g,path)\n        tree_p.Add(None, path)        \n\n    def _drawVec(self, vec): \n        return rg.Vector3d(vec.x,vec.y,vec.z)\n\n    def _drawPoint(self, pt):\n        return rg.Point3d(pt.x,pt.y,pt.z)\n        \n    def _drawPlane(self, pln):\n        o = rg.Point3d(pln.origin.x,pln.origin.y,pln.origin.z)\n        n = rg.Vector3d(pln.normal.x,pln.normal.y,pln.normal.z) \n        return rg.Plane(o,n)\n\n    def _drawMesh(self, mesh):\n        rh_mesh = rg.Mesh()\n        for v in mesh.pts: rh_mesh.Vertices.Add(v.x,v.y,v.z)\n        for f in mesh.faces: \n            if len(f)==3 : rh_mesh.Faces.AddFace(f[0], f[1], f[2])\n            if len(f)==4 : rh_mesh.Faces.AddFace(f[0], f[1], f[2], f[3])\n        rh_mesh.Normals.ComputeNormals()\n        rh_mesh.Compact()\n        return rh_mesh\n    \n    def _drawLinearEntity(self, ln):\n        if isinstance(ln, Segment) : return rg.Line(rg.Point3d(ln.spt.x,ln.spt.y,ln.spt.z),rg.Point3d(ln.ept.x,ln.ept.y,ln.ept.z))\n        if isinstance(ln, Line) :\n            ept = ln.spt + ln.vec\n            return rg.Line(rg.Point3d(ln.spt.x,ln.spt.y,ln.spt.z),rg.Point3d(ept.x,ept.y,ept.z))\n        if isinstance(ln, Ray) : \n            rh_spt = rg.Point3d(ln.spt.x,ln.spt.y,ln.spt.z)\n            ept = ln.spt + ln.vec\n            rh_ept = rg.Point3d(ept.x,ept.y,ept.z)\n            return [rh_spt,rg.Line(rh_spt,rh_ept)]\n    \n    def _drawPLine(self, pline):\n        return to_rgpolyline(pline)\n\n    def _drawCircle(self, circ):\n        return to_rgcircle(circ)\n        \n    def _drawArc(self, circ):\n        return to_rgarc(circ)\n            \n    def _drawPGon(self, pgon):\n        return to_rgpolyline(pgon)\n\n    def _drawCurve(self, curve):\n        return interpolated_curve(curve.surrogate.pts)\n\n    def _drawCS(self, cs):\n        o = rg.Point3d(cs.origin.x,cs.origin.y,cs.origin.z)\n        x = rg.Vector3d(cs.x_axis.x,cs.x_axis.y,cs.x_axis.z) \n        y = rg.Vector3d(cs.y_axis.x,cs.y_axis.y,cs.y_axis.z) \n        return rg.Plane(o,x,y)\n\n    def _drawColor(self, c): \n        import Grasshopper.GUI.GH_GraphicsUtil as gh_gutil\n        return gh_gutil.ColourARGB(c.r,c.g,c.b)\n\n\n\n\n\n\n\n'''\nfor reference: the following code is injected before and after a user's script in grasshopper components\n## -- BEGIN DECODES HEADER -- ##\nimport decodes as dc\nfrom decodes.core import *\nfrom decodes.io.gh_in import *\nfrom decodes.io.gh_out import *\nexec(io.gh_in.component_header_code)\nexec(io.gh_out.component_header_code)\n## -- END DECODES HEADER -- ##\n\n## -- BEGIN DECODES FOOTER -- ##\nexec(io.gh_in.component_footer_code)\nexec(io.gh_out.component_footer_code)\n## -- END DECODES FOOTER -- ##\n'''\n\n\ncomponent_header_code = \"\"\"\noutputs = ghenv.Component.Params.Output\ngh_outies = []\nfor output in outputs :\n        if output.Name != \"console\":\n                if not \"_prop\" in output.NickName :\n                    vars()[output.NickName] = make_out(Outies.Grasshopper,output.NickName)\n                    gh_outies.append(vars()[output.NickName])\n\t\t\n\"\"\"\n\n#TODO, check if an output variable is fieldpack geometry or a list of fieldpack geometry\n# if so, translate apprpiately\n\ncomponent_footer_code = \"\"\"\nfor gh_outie in gh_outies :\n                if not isinstance(vars()[gh_outie.name], io.gh_out.GrasshopperOut) : \n                                print \"Bad User!    It looks like you assigned to the output '{0}' using the equals operator like so: {0}=something.\\\\nYou should have used the 'put' method instead, like so: {0}.put(something)\\\\nYou may also use the '+=' operator, like so: {0} += something\".format(gh_outie.name)\n                vars()[gh_outie.name], vars()[gh_outie.name+\"_props\"] = gh_outie.extract_tree()\n\"\"\"\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}