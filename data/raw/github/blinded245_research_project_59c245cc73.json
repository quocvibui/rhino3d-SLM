{
  "source_url": "https://github.com/blinded245/research_project/blob/5c85b1b9058e9b7cc4d37291caad2ed7bbc849aa/src/research_project/motion_planning/ik_tools.py",
  "repo": "blinded245/research_project",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/research_project/motion_planning/ik_tools.py",
  "instruction": "plan_tree.py - A module for generating and manipulating robot motion plans.",
  "code": "\"\"\"\nplan_tree.py - A module for generating and manipulating robot motion plans.\n\"\"\"\n\nimport inspect\nimport math\nimport time\nimport Rhino.Geometry as rg\nfrom Rhino.Geometry import Plane, Transform, Point3d\n\nfrom research_project.utilities.utils import dprint\n\nimport compas_rhino.conversions as conv\n\nfrom compas.geometry import Transformation\nfrom compas.geometry import Frame\nfrom ur_fabrication_control.kinematics.ur_kinematics import inverse_kinematics\nfrom ur_fabrication_control.kinematics.ur_params import ur_params\nfrom compas_robots import Configuration\n\n\ninputs = [\"robot\", \"target_planes_WCS\", \"start_configuration\", \"group\", \"rotation\"]\n\n\nclass IK_TOOLS:\n    \"\"\"A class for generating robot motion plans.\"\"\"\n\n    def free_rotation_planes(self, target_planes_wcs):\n        target_planes_wcs_out = []\n        if self.free_rotation == \"False\":\n            target_planes_wcs_out = target_planes_wcs\n            return target_planes_wcs_out\n\n        if self.free_rotation == \"n_steps\":  # full rotation divided into n steps\n            for plane in target_planes_wcs:\n                transformed = []\n                self.rotation_deg = 360 / self.rotation_steps\n                for i in range(self.rotation_steps):\n                    new_plane = rg.Plane(plane)\n                    transformation_plus = Transform.Rotation(\n                        i * self.rotation_deg * math.pi / 180,\n                        new_plane.Normal,\n                        new_plane.Origin,\n                    )\n                    new_plane.Transform(transformation_plus)\n                    transformed.append(new_plane)\n                target_planes_wcs_out.append(transformed)\n            return target_planes_wcs_out\n        if (\n            self.free_rotation == \"step_angle\"\n        ):  # rotation by a fixed angle starting from -angle_ccw to angle_cw\n            for plane in target_planes_wcs:\n                transformed = []\n                for i in range(-1 * self.angle_ccw, self.angle_cw, self.rotation_deg):\n                    # for i in range(-1 * self.rotation_steps, self.rotation_steps + 1):\n                    new_plane = rg.Plane(plane)\n                    transformation_plus = Transform.Rotation(\n                        i * math.pi / 180,\n                        new_plane.Normal,\n                        new_plane.Origin,\n                    )\n                    new_plane.Transform(transformation_plus)\n                    transformed.append(new_plane)\n                target_planes_wcs_out.append(transformed)\n            return target_planes_wcs_out\n\n    def __init__(\n        self,\n        robot,\n        target_planes_wcs,\n        group=None,\n        free_rotation=\"False\",\n        rotation_angle=5,\n        rotation_steps=35,\n        angle_cw=0,\n        angle_ccw=0,\n    ):\n\n        self.robot = robot\n        self.lift = robot.lift_height\n        self.arm_base_frame = robot.RCF.translated([0, 0, self.lift])\n        print(\"lift\", self.lift)\n        self.free_rotation = free_rotation\n        self.rotation_steps = rotation_steps\n        if self.free_rotation == \"n_steps\":\n            self.rotation_deg = 360 / self.rotation_steps\n        else:\n            self.rotation_deg = rotation_angle\n        self.angle_cw = angle_cw\n        self.angle_ccw = angle_ccw\n        self.target_planes_wcs = self.free_rotation_planes(target_planes_wcs)\n        self.group = group\n\n    def ik_analytical_solution(self, target_plane_wcs):\n        \"\"\"Does the cartesian Conversions and then calls the inverse kinematics\n        function for a single target plane.\n\n        Args:\n            target_plane_WCS (Plane): The target plane in world coordinate system.\n\n        Returns:\n            A list of all possible solutions for the target plane.\n\n        \"\"\"\n        if not self.check_requirements([\"self.robot\"]):\n            return None\n        # print(\"target_plane_wcs\", target_plane_wcs)\n        origin_point = Point3d(\n            target_plane_wcs.OriginX, target_plane_wcs.OriginY, target_plane_wcs.OriginZ\n        )\n        frame_wcs = Frame(origin_point, target_plane_wcs.XAxis, target_plane_wcs.YAxis)\n        # frame_rcs = self.robot.from_WCF_to_RCF(frame_wcs)\n        frame_bcs = self.robot.from_WCF_to_BCF(frame_wcs)\n        T = Transformation.from_frame_to_frame(self.arm_base_frame, self.robot.BCF)\n        frame_rcs = frame_bcs.transformed(T)\n        T2 = Transformation.from_frame_to_frame(self.robot.BCF, Frame.worldXY())\n        frame_rcs_ = frame_rcs.transformed(T2)\n        if self.robot.attached_tool:\n            tool0_rcs = self.robot.from_tcf_to_t0cf([frame_rcs_])[0]\n        else:\n            tool0_rcs = frame_rcs\n        # plane_tool0_RCS = draw_frame(tool0_RCS)\n        # plane_RCS = draw_frame(frame_RCS)\n\n        ur_params_specific = ur_params[\"ur20\"]\n        ik = inverse_kinematics(tool0_rcs, ur_params_specific)\n        ik_shoulder_positive = self.check_shoulder_positive(ik)\n        return ik_shoulder_positive\n\n    def check_duplicate_solutions(self, solutions):\n        \"\"\"Checks for duplicate solutions in a list of joint values.\n\n        Args:\n            solutions (list): A list of joint values.\n\n        Returns:\n            A list of unique joint values.\n\n        \"\"\"\n        # TODO: Make sure this function also finds duplicates that have round-off errors\n        unique_solutions = []\n        for solution in solutions:\n            if solution not in unique_solutions:\n                unique_solutions.append(solution)\n        return unique_solutions\n\n    def check_shoulder_positive(self, joint_values):\n        updated_joint_values = []\n        for values in joint_values:\n            updated_values = list(values)  # Create a copy of the joint values\n            if updated_values[0] < 0:\n                updated_values[0] += 2 * math.pi\n            updated_joint_values.append(updated_values)\n\n        unique_solutions = self.check_duplicate_solutions(updated_joint_values)\n        return unique_solutions\n\n    def ik_moveit(self, plane, start_configuration=None, group=None):\n        \"\"\"Does the cartesian Conversions and then calls the inverse kinematics\"\"\"\n        if not self.check_requirements(\n            [\n                \"robot\",\n                \"robot.client\",\n                \"robot.client.is_connected\",\n                \"plane\",\n            ],\n            plane=plane,\n        ):\n            return None\n\n        frame = conv.plane_to_compas_frame(plane)\n        dprint(\n            {\"frame\": frame, \"start_configuration\": start_configuration, \"group\": group}\n        )\n        configuration = self.robot.iter_inverse_kinematics(\n            frame, start_configuration, group, options={\"max_results\": 100}\n        )\n        return configuration\n\n    def ik_analytical_list_input(self, target_planes_wcs=None):\n        \"\"\"wrapper function for inverse_kinematics_all_solutions that takes a list of target planes\n        as input and returns a list of solutions for each target plane.\"\"\"\n        if target_planes_wcs is None:\n            target_planes_wcs = self.target_planes_wcs\n        output = []\n        if self.free_rotation == \"n_steps\" or self.free_rotation == \"step_angle\":\n            for i, point in enumerate(self.target_planes_wcs):\n                point_solutions = []\n                for j, plane in enumerate(point):\n                    point_solutions.extend(self.ik_analytical_solution(plane))\n                output.append(point_solutions)\n\n        else:\n            if isinstance(target_planes_wcs, list):\n                for plane in target_planes_wcs:\n                    output.append(self.ik_analytical_solution(plane))\n            elif isinstance(target_planes_wcs, Plane):\n                output.append(self.ik_analytical_solution(target_planes_wcs))\n        return output\n\n    def check_requirements(self, checks, plane=None):\n        for check in checks:\n            if eval(check) is None:\n                print(\"Check failed: \" + check + \"in \" + inspect.stack()[1][3])\n                return False\n        return True\n\n\nif __name__ == \"<module>\" or __name__ == \"__main__\":\n\n    inst = IK_TOOLS(\n        robot,  # noqa: F821\n        target_planes_WCS,  # noqa: F821\n        group,  # noqa: F821\n        free_rotation=rotation,  # noqa: F821\n        rotation_angle=angle_per_step,  # noqa: F821\n        rotation_steps=steps,  # noqa: F821\n        angle_cw=angle_clockwise,  # noqa: F821\n        angle_ccw=angle_countercw,  # noqa: F821\n    )\n\n    # rotated_target_planes = th.list_to_tree(inst.free_rotation_planes(target_planes_WCS))\n    planes = inst.target_planes_wcs\n    flattened_planes = [plane for sublist in planes for plane in sublist]\n    solutions_net = inst.ik_analytical_list_input()\n    solutions = [\n        [[joint_value for joint_value in item] for item in solution]\n        for solution in solutions_net\n    ]\n    flattened_solutions = [solution for sublist in solutions for solution in sublist]\n    flattened_solutions = [\n        Configuration.from_prismatic_and_revolute_values([0], config[0:6])\n        for config in flattened_solutions\n    ]\n    # sol=solutions[549][1]\n\n    shape = [len(solutions_net[i]) for i in range(len(solutions_net))]\n    # solutions = th.list_to_tree(solutions)\n    print(shape)\n    time_out = time.strftime(\"%H:%M:%S\", time.localtime(time.time()))\n\nunreachable = [pl for pl, num in zip(planes, shape) if num == 0]\n\n\n# sol = ik_test(target_planes_WCS[549], robot)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}