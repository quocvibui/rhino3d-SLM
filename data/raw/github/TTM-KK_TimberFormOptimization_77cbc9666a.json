{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/GA/Evaluation.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "GA/Evaluation.py",
  "instruction": "Evaluation",
  "code": "# -*- coding:utf-8 -*-\n\nimport rhinoscriptsyntax as rs\n# import time\n# import copy\n# import random as rnd\n# import sys\nimport Rhino\nimport scriptcontext\n\n\ndef pop_evaluation(tim_number, instance_pop, generation_count, generate_range, generation_num):\n    '''\n    使用する評価関数を埋め込む用の関数\n    :param tim_number: 個体に使用している部材の数\n    :param instance_pop: Generateクラスのインスタンス\n    :param generation_count: 現在の世代数\n    :param generation_num: 全体の個体数\n    :return:　評価値\n    '''\n    evaluate_value = pop_dome_evaluate(tim_number, instance_pop, generation_count, generate_range, generation_num)\n    # evaluate_value = partner_num_evaluate(tim_number, instance_pop, 2, 8)\n    return evaluate_value\n\n\ndef overlap_num2(tim_number, instance_pop):\n    '''\n    intersectionを使用していないため実行速度は早い。精度に問題はある。\n    :param tim_number:\n    :param instance_pop:\n    :return:\n    '''\n    intersect_num = 0\n    for i in range(tim_number):\n        tim = instance_pop.used_list[i].center_line\n        tim_end_1 = tim.PointAtEnd\n        tim_start_1 = tim.PointAtStart\n        tim_line = Rhino.Geometry.Line(tim_end_1, tim_start_1)\n        for j in range(tim_number):\n            if j == i:\n                continue\n            else:\n                tim_other = instance_pop.used_list[j].center_line\n                tim_end = tim_other.PointAtEnd\n                tim_start = tim_other.PointAtStart\n                tim_other_line = Rhino.Geometry.Line(tim_end, tim_start)\n\n                distance = tim_line.MinimumDistanceTo(tim_other_line)\n\n                if distance < instance_pop.used_list[i].section_length/2 + instance_pop.used_list[j]\\\n                        .section_length/2 + 50:\n                    intersect_num = intersect_num + 1\n                else:\n                    # intersect_num = intersect_num + 1\n                    continue\n\n    return intersect_num\n\n\ndef partner_num_evaluate(tim_number, instance_pop, num_partner_low, num_partner_high):\n    \"\"\"\n    partner_timの数が指定された領域内にあれば点数を与える評価関数。\n    :param tim_number:\n    :param instance_pop:\n    :param num_partner_low:\n    :param num_partner_high:\n    :return:\n    \"\"\"\n    evaluate_point = 0\n    for i in range(tim_number):\n        tim_partner_num = len(instance_pop.used_list[i].partner_tim)\n        if num_partner_low <= tim_partner_num <= num_partner_high:\n            evaluate_point = evaluate_point + 1\n\n    return evaluate_point\n\n\ndef pop_height_evaluate(tim_number, instance_pop):\n    '''\n    個体の高さを評価値として算出する。\n    :param tim_number:\n    :param instance_pop:\n    :return: 高さの最大値\n    '''\n    tim_height = []\n    for i in range(tim_number):\n        center_line = instance_pop.used_list[i].center_line\n        end_p = center_line.PointAtEnd\n        str_p = center_line.PointAtStart\n        if end_p[2] > str_p[2]:\n            tim_height.append(end_p[2])\n        else:\n            tim_height.append(str_p[2])\n\n    most_height_value = max(tim_height)\n\n    return most_height_value\n\n\ndef pop_dome_evaluate(tim_number, instance_pop, generation_count, generate_range, generation_num):\n    '''\n\n    :param tim_number: timberの数\n    :param instance_pop:  Generateクラスのインスタンス\n    :param generation_count: 現在の世代。\n    :param generate_range: 個体間の距離。\n    :param generation_num: 全体の個体数。\n    :return: 範囲に入っていない部材の数。\n    '''\n\n    p = {}\n    p[0] = Rhino.Geometry.Point3d(750, 750, 0)\n    p[1] = Rhino.Geometry.Point3d(2250, 750, 0)\n    p[2] = Rhino.Geometry.Point3d(2250, 2250, 0)\n    p[3] = Rhino.Geometry.Point3d(750, 2250, 0)\n\n    p[4] = Rhino.Geometry.Point3d(750, 750, 1500)\n    p[5] = Rhino.Geometry.Point3d(2250, 750, 1500)\n    p[6] = Rhino.Geometry.Point3d(2250, 2250, 1500)\n    p[7] = Rhino.Geometry.Point3d(750, 2250, 1500)\n\n    points_list = []\n    for i in range(8):\n        points_list.append(p[i])\n\n    brep = Rhino.Geometry.Brep.CreateFromBox(points_list)\n\n    copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n    copy_to = Rhino.Geometry.Point3d((generate_range * 2) * instance_pop.population_id,\n                                     (-generate_range * 2) * (generation_count + 1), 0)\n    vec_move = copy_to - copy_from\n\n    xf = Rhino.Geometry.Transform.Translation(vec_move)\n    brep.Transform(xf)\n\n    if generation_num == generation_count:\n        rs.AddLayer('dome_box')\n        box = scriptcontext.doc.Objects.AddBrep(brep)\n        rs.ObjectLayer(box, 'dome_box')\n\n    evaluate_point = 0\n    for i in range(tim_number):\n        curve = instance_pop.used_list[i].center_line\n\n        curve = rs.coercecurve(curve)\n\n        end = curve.PointAtEnd\n        start = curve.PointAtStart\n\n        rc, mid_parameter = curve.NormalizedLengthParameter(0.5)\n\n        mid = curve.PointAt(mid_parameter)\n\n        end_p_check = brep.IsPointInside(end, Rhino.RhinoMath.SqrtEpsilon, True)\n        start_p_check = brep.IsPointInside(start, Rhino.RhinoMath.SqrtEpsilon, True)\n        mid_p_check = brep.IsPointInside(mid, Rhino.RhinoMath.SqrtEpsilon, True)\n\n        if end_p_check or start_p_check or mid_p_check:\n            pass\n        else:\n            evaluate_point += 1\n\n    return evaluate_point\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}