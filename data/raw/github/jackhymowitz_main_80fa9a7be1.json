{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_GetSurfaceParams.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_GetSurfaceParams.py",
  "instruction": "Use this before a Honeybee 'createHBSrfs' component to pull geometry and relevant surface parameters\r\r\nfrom the Rhino scene rather than setting them in GH. This component tries to read data from...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nUse this before a Honeybee 'createHBSrfs' component to pull geometry and relevant surface parameters\r\r\nfrom the Rhino scene rather than setting them in GH. This component tries to read data from each\r\r\nsurface's 'Attribute User Text'. Use the Rhino-scene Set Params tool to set surface data before\r\r\ntrying to import it here. \r\r\n-\r\r\nEM July 31, 2020\r\r\n    Args:\r\r\n        _srfcs: The Zone's Opaque surfaces as a list (walls, floors, ceilings, etc...). By Default Type-Hint is set to 'GUID' in order to get geom data parameters from the Rhino scene. If passing in Grasshopper generated surfaces be sure to set Type-Hint to 'No Type Hint'.\r\r\n        autoOrientation_: (bool Default='False') Set to 'True' to have this component automatically assign surface type ('wall', 'floor', 'roof'). useful if you are testing massings / geometry and don't want to assign explicit type everytime. If you have already assigned the surface type in Rhino, leave this set to False. If 'True' this will override any values found in the Rhino scene.\r\r\n    Returns:\r\r\n        srfcGeometry_: Connect to the '_geometry' Input on a Honeybee 'createHBSrfs' component\r\r\n        srfcNames_: Connect to the 'srfName_' Input on a Honeybee 'createHBSrfs' component\r\r\n        srfcTypes_: Connect to the 'srfType' Input on a Honeybee 'createHBSrfs' component\r\r\n        srfcEPBCs_: Connect to the 'EPBC_' Input on a Honeybee 'createHBSrfs' component\r\r\n        srfcEPConstructions_: Connect to the '_EPConstruction' Input on a Honeybee 'createHBSrfs' component. If blank or any Null values pased, will use HB defaults as usual.\r\r\n        srfcRADMaterials_: Connect to the '_RADMaterial' Input on a Honeybee 'createHBSrfs' component\r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_GetSurfaceParams\"\r\r\nghenv.Component.NickName = \"Get Surface Params\"\r\r\nghenv.Component.Message = 'JUL_31_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"01 | Model\"\r\r\n\r\r\nimport Rhino\r\r\nimport scriptcontext as sc\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport json\r\r\nimport Grasshopper.Kernel as ghK\r\r\nimport System\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport re\r\r\nimport math\r\r\nimport ghpythonlib.components as ghc\r\r\n\r\r\n# Defs and Classes\r\r\nhb_hive = sc.sticky[\"honeybee_Hive\"]()\r\r\nhb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\r\r\n\r\r\nphpp_makeHBMaterial_NoMass = sc.sticky['phpp_makeHBMaterial_NoMass']\r\r\nphpp_makeHBMaterial_Opaque = sc.sticky['phpp_makeHBMaterial_Opaque']\r\r\nphpp_makeHBConstruction = sc.sticky['phpp_makeHBConstruction']\r\r\nphpp_createSrfcHBMatAndConst = sc.sticky['phpp_createSrfcHBMatAndConst']\r\r\nidf2ph_rhDoc = sc.sticky['idf2ph_rhDoc']\r\r\n\r\r\n#################################################################\r\r\nclass Outputs:\r\r\n    \"\"\" Temporary object to store and manage the output values of the component\r\r\n    \"\"\"\r\r\n    \r\r\n    __srfcGeom = None\r\r\n    __srfcNames = None\r\r\n    __srfcTypes = None\r\r\n    __srfcEPBCs = None\r\r\n    __EPConsts = None\r\r\n    __RADMats = None\r\r\n    \r\r\n    @staticmethod\r\r\n    def getSrfcGeom():\r\r\n        if Outputs.__srfcGeom == None:\r\r\n            Outputs.__srfcGeom = []\r\r\n        return Outputs.__srfcGeom\r\r\n    \r\r\n    @staticmethod\r\r\n    def getSrfcNames():\r\r\n        if Outputs.__srfcNames == None:\r\r\n            Outputs.__srfcNames = []\r\r\n        return Outputs.__srfcNames\r\r\n    \r\r\n    @staticmethod\r\r\n    def getSrfcTypes():\r\r\n        if Outputs.__srfcTypes == None:\r\r\n            Outputs.__srfcTypes = []\r\r\n        return Outputs.__srfcTypes\r\r\n        \r\r\n    @staticmethod\r\r\n    def getSrfcEPBCs():\r\r\n        if Outputs.__srfcEPBCs == None:\r\r\n            Outputs.__srfcEPBCs = []\r\r\n        return Outputs.__srfcEPBCs\r\r\n        \r\r\n    @staticmethod\r\r\n    def getEPConstructions():\r\r\n        if Outputs.__EPConsts == None:\r\r\n            Outputs.__EPConsts = []\r\r\n        return Outputs.__EPConsts\r\r\n    \r\r\n    @staticmethod\r\r\n    def getRADMaterials():\r\r\n        if Outputs.__RADMats == None:\r\r\n            Outputs.__RADMats = []\r\r\n        return Outputs.__RADMats\r\r\n\r\r\ndef HB_addToEPLibrary(EPObject, overwrite, printLog=False):\r\r\n    \"\"\" This definition is take right from the Honeybee 'addToEPLibrary' Component\r\r\n    \r\r\n    Takes in the EP Object (material or construction) and writes it out to the\r\r\n    'Hive' so it can be used / access later when writing the IDF file. \r\r\n    Arguments:\r\r\n        EPObject: The EP Material or EP Construction to write to the Hive\r\r\n        overwrite: True / False to overwright existing values with same name in the Hive\r\r\n        printLog: True / False to print to log what this is doing / succes or not. \r\r\n    Returns:\r\r\n        None\r\r\n    \"\"\"\r\r\n    hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\r\r\n    added, name = hb_EPObjectsAux.addEPObjectToLib(EPObject, overwrite)\r\r\n    \r\r\n    if not added:\r\r\n        msg = name + \" is not added to the project library!\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, msg)\r\r\n        if printLog: print msg\r\r\n    else:\r\r\n        if printLog: print name + \" is added to this project library!\"\r\r\n\r\r\ndef getAllUserText(_GUID):\r\r\n    \"\"\" Takes in an objects GUID and returns the full dictionary of\r\r\n    Attribute UserText Key and Value pairs. Cleans up a bit as well.\r\r\n    \r\r\n    Arguments:\r\r\n        _GUID: the Rhino GUID of the surface object to try and read from\r\r\n    Returns:\r\r\n        dict: a dictionary object with all the keys / values found in the Object's UserText\r\r\n    \"\"\"\r\r\n    dict = {}\r\r\n    \r\r\n    if not _GUID.GetType() == System.Guid:\r\r\n        remark = \"Unable to get parameter data for the surface? If trying to pull data\\n\"\\\r\r\n        \"from Rhino, be sure the '_srfc' input Type Hint is set to 'Guid'\\n\"\\\r\r\n        \"For now, using default values for all surface parameter values.\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, remark)\r\r\n        return dict\r\r\n    \r\r\n    with idf2ph_rhDoc():\r\r\n        dict['Object Name'] = rs.ObjectName(_GUID) # Always get the name\r\r\n        \r\r\n        for eachKey in rs.GetUserText(_GUID):\r\r\n            if 'Object Name' not in eachKey:\r\r\n                val =  rs.GetUserText(_GUID, eachKey)\r\r\n                if val != 'None':\r\r\n                    dict[eachKey] = val\r\r\n                else:\r\r\n                    dict[eachKey] = None\r\r\n    \r\r\n    return dict\r\r\n\r\r\ndef warnNoName(_dict):\r\r\n    \"\"\" Gives warning if there isn't any name found in the UserText for the surface\r\r\n    \r\r\n    Arguments:\r\r\n        dict: the Dictionary with the UserText keys / values\r\r\n    Returns:\r\r\n        srfcName: 'NoName' if none found, otherwise the user-determined name\r\r\n    \"\"\"\r\r\n    \r\r\n    srfcName = _dict.get(\"Object Name\", \"NoName\")\r\r\n    if srfcName == 'None' or srfcName == None:\r\r\n        warning = \"Warning: Some Surfaces look like they are missing names? It is likely that\\n\"\\\r\r\n        \"the Honeybee solveAdjc component will not work correctly without names.\\n\"\\\r\r\n        \"This is especially true for 'interior' surfaces up against other thermal zones.\\n\"\\\r\r\n        \"Please apply a unique name to all surfaces before proceeding. Use the\\n\"\\\r\r\n        \"IDF2PH 'Set Window Names' tool to do this automatically (works on regular srfcs too)\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n    return srfcName\r\r\n\r\r\ndef addEPMatAndEPConstToLib(_thisConst, _HBMaterials, _EPConstructions, _HBConstructions, _udConstDict):\r\r\n    \"\"\" Creates and adds new HB Material and Constructions to the master output lists\r\r\n    \r\r\n    Arguments:\r\r\n        _thisConst: The name of the Construction found on the Surface's UserText\r\r\n        _HBMaterials: A List of the Honeybee Material Objects\r\r\n        _EPConstructions: A List of the EnergyPlus Construction Objects\r\r\n        _HBConstructions: A List of the Honeybee Construction Objects\r\r\n        _udConstDict: The dictionary of Assembly Parameters from the Rhino DocumentUserText\r\r\n    Returns:\r\r\n        _HBMaterials: A List of the Honeybee Material Objects\r\r\n        _EPConstructions A List of the EnergyPlus Construction Objects\r\r\n        _HBConstructions: A List of the Honeybee Construction Objects\r\r\n    \"\"\"\r\r\n    \r\r\n    if _thisConst == None:\r\r\n        return _HBMaterials, _EPConstructions, _HBConstructions\r\r\n    \r\r\n    # Get the UD Assembly dict parameter values, depending on type\r\r\n    if isinstance(_udConstDict, str):\r\r\n        vals = json.loads(_udConstDict.get(_thisConst, {}))\r\r\n    elif isinstance(_udConstDict, dict):\r\r\n        vals = _udConstDict.get(_thisConst, {})\r\r\n    else:\r\r\n        vals = dict()\r\r\n    \r\r\n    # Create a new EP Material and EP Construction from the read-in values\r\r\n    try:\r\r\n        nm = vals.get('Name','NO_NAME').upper()\r\r\n        uval = float(vals.get('uValue',1))\r\r\n        intInsul = float(vals.get('intInsulation',0))\r\r\n    except:\r\r\n        nm = vals.get('Name','NO_NAME').upper()\r\r\n        uval = 1\r\r\n        intInsul = 0\r\r\n        warning = 'Something went wrong getting the Construction Assembly info for the Assembly type: \"{}\" from the Rhino Library?\\n'\\\r\r\n        'No assembly by that name, or a non-numeric entry found in the Library? Please check the Library File inputs.\\n'\\\r\r\n        'For now, I will assign a U-Value of 1.0 W/m2k to this assembly as a default value.'.format(_thisConst.upper())\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n    \r\r\n    new_HBMat, new_HBMat_Mass, constructionName, new_EPConstruction = phpp_createSrfcHBMatAndConst(nm, uval, intInsul)\r\r\n    \r\r\n    _HBMaterials.append(new_HBMat) # The full txt to write to IDF\r\r\n    _HBMaterials.append(new_HBMat_Mass)\r\r\n    _EPConstructions.append(constructionName)\r\r\n    _HBConstructions.append(new_EPConstruction) # The full txt to write to IDF\r\r\n        \r\r\n    return _HBMaterials, _EPConstructions, _HBConstructions\r\r\n\r\r\ndef getSurfaceParams(_srfc):\r\r\n    \"\"\" Takes in a GUID of a surface and reads UserText, bundles output\r\r\n    \r\r\n    This will log all the geom and parameters it finds to the master 'output' object\r\r\n    \r\r\n    Arguments:\r\r\n        _srfc: The surface GUID\r\r\n    Returns:\r\r\n        None\r\r\n    \"\"\"\r\r\n    # Check in the inputs\r\r\n    if _srfc == None:\r\r\n        warning = \"Warning: Inputs should be Surface objects.\\n\"\\\r\r\n        \"If you are passing in Grasshopper generated surfaces, (rather than\\n\"\\\r\r\n        \"referenced surfaces from Rhino scene) be sure to set the 'Type Hint'\\n\"\\\r\r\n        \"for the '_srfcs' input on this component to 'No Type Hint'\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n        return\r\r\n    \r\r\n    # Get access to the output lists\r\r\n    srfcGeom = outputs.getSrfcGeom()\r\r\n    srfcNames = outputs.getSrfcNames()\r\r\n    srfcTypes = outputs.getSrfcTypes()\r\r\n    srfcEPBCs = outputs.getSrfcEPBCs()\r\r\n    srfcEPConstructions = outputs.getEPConstructions()\r\r\n    srfcRADMaterials = outputs.getRADMaterials()\r\r\n    \r\r\n    # Bring in the Attribute UserText from Rhino\r\r\n    dict = getAllUserText(_srfc)\r\r\n    \r\r\n    # Add the new Geom and Params to the output lists\r\r\n    with idf2ph_rhDoc(): srfcGeom.append( rs.coercebrep(_srfc) )\r\r\n    \r\r\n    srfcNames.append(  warnNoName(dict)  )\r\r\n    srfcEPConstructions.append( cleanGet(dict, 'EPConstruction', None) )\r\r\n    srfcRADMaterials.append( cleanGet(dict, 'RADMaterial', None) )\r\r\n    \r\r\n    # Fix for the UndergroundSlab issue\r\r\n    srfcTypeval = srfcTypeCodes.get( cleanGet(dict, 'srfType', 'WALL') )\r\r\n    srfcTypes.append( srfcTypeval )\r\r\n    if srfcTypeval == 2.25:\r\r\n        srfcEPBCs.append( None )\r\r\n    else:\r\r\n        srfcEPBCs.append( cleanGet(dict, 'EPBC', 'Outdoors') )\r\r\n\r\r\ndef cleanGet(_dict, _k, _default=None):\r\r\n    \"\"\" Protects against None or space(s) (' ') accidental inputs \"\"\"\r\r\n    if _k == None or _dict==None:\r\r\n        return None\r\r\n    \r\r\n    v = _dict.get(_k, _default)\r\r\n    \r\r\n    # re will return None if v == only one or more spaces (no alph numeric)\r\r\n    if v == None or re.search('\\S+', v) == None:\r\r\n        return None\r\r\n    else:\r\r\n        return v\r\r\n\r\r\ndef cleanSrfcInput(_srfcsInput):\r\r\n    \"\"\"If Brep or Polysrfc are input, explode them\"\"\"\r\r\n    \r\r\n    outputSrfcs = []\r\r\n    \r\r\n    with idf2ph_rhDoc():\r\r\n        for inputObj in _srfcsInput:\r\r\n            if isinstance(rs.coercesurface(inputObj), Rhino.Geometry.BrepFace):\r\r\n                # Catches Bare surfaces\r\r\n                outputSrfcs.append(inputObj)\r\r\n            elif isinstance(rs.coercebrep(inputObj), Rhino.Geometry.Brep):\r\r\n                # Catches Polysurfaces / Extrusions or other Masses\r\r\n                faces = ghc.DeconstructBrep(rs.coercebrep(inputObj)).faces\r\r\n                if isinstance(faces, list):\r\r\n                    for face in faces:\r\r\n                        outputSrfcs.append(face)\r\r\n            elif isinstance(rs.coercegeometry(inputObj), Rhino.Geometry.PolylineCurve):\r\r\n                # Catches PolylineCurves\r\r\n                if not rs.coercegeometry(inputObj).IsClosed:\r\r\n                    warn = 'Non-Closed Polyline Curves found. Make sure all curves are closed.'\r\r\n                    ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, warn)\r\r\n                else:\r\r\n                    faces = ghc.DeconstructBrep(rs.coercegeometry(inputObj)).faces\r\r\n                    if isinstance(faces, list):\r\r\n                        for face in faces:\r\r\n                            outputSrfcs.append(face)\r\r\n                    else:\r\r\n                        outputSrfcs.append(faces)\r\r\n        \r\r\n        return outputSrfcs\r\r\n\r\r\ndef determineSurfaceType(_srfc):\r\r\n    # Code here adapted from Honeybee 'decomposeZone' method\r\r\n    # Checks the surface normal and depending on the direction, \r\r\n    # assigns it as a 'wall', 'floor' or 'roof'\r\r\n    \r\r\n    def getGHSrfNormal(GHSrf):\r\r\n        centroid = ghc.Area(GHSrf).centroid\r\r\n        normalVector = ghc.EvaluateSurface(GHSrf, centroid).normal\r\r\n        return normalVector, GHSrf\r\r\n    \r\r\n    maximumRoofAngle = 30\r\r\n    # check surface Normal\r\r\n    try:\r\r\n        normal, surface = getGHSrfNormal(_srfc)\r\r\n    except:\r\r\n        print('Failed to find surface normal. Are you sure it is a surface?')\r\r\n        return 0\r\r\n    \r\r\n    angle2Z = math.degrees(Rhino.Geometry.Vector3d.VectorAngle(normal, Rhino.Geometry.Vector3d.ZAxis))\r\r\n    \r\r\n    if  angle2Z < maximumRoofAngle or angle2Z > 360 - maximumRoofAngle:\r\r\n        return 1 #roof\r\r\n    elif  160 < angle2Z <200:\r\r\n        return 2 # floor\r\r\n    else: \r\r\n        return 0 #wall\r\r\n\r\r\n# Surface Type Schema\r\r\nsrfcTypeCodes = {'WALL':0,\r\r\n    'UndergroundWall':0.5,\r\r\n    'ROOF':1,\r\r\n    'UndergroundCeiling':1.5,\r\r\n    'FLOOR':2,\r\r\n    'UndergroundSlab':2.25,\r\r\n    'SlabOnGrade':2.5,\r\r\n    'ExposedFloor':2.75,\r\r\n    'CEILING':3,\r\r\n    'AIRWALL':4,\r\r\n    'WINDOW': 5,\r\r\n    'SHADING': 6\r\r\n    }\r\r\n\r\r\n# Master Output class obj\r\r\noutputs = Outputs()\r\r\n\r\r\n#################################################################\r\r\n# Pull the geometry and params for each Surface in the input set\r\r\nsrfcsToUse = cleanSrfcInput(_srfcs)\r\r\nfor srfc in srfcsToUse:\r\r\n    getSurfaceParams( srfc )\r\r\n\r\r\n# Pass along the Component Outputs\r\r\nsrfcGeometry_ = outputs.getSrfcGeom() \r\r\nsrfcNames_ = outputs.getSrfcNames()\r\r\nsrfcTypes_ = outputs.getSrfcTypes()\r\r\nsrfcEPBCs_ = outputs.getSrfcEPBCs()\r\r\nsrfcEPConstructions_ =  outputs.getEPConstructions()\r\r\nsrfcRADMaterials_ =  outputs.getRADMaterials()\r\r\n\r\r\n# Get the Library of EP Construction Params from the Rhino Document User Text dictionary\r\r\nudConstParams = {}\r\r\nwith idf2ph_rhDoc():\r\r\n    if rs.IsDocumentUserText():\r\r\n        for eachKey in rs.GetDocumentUserText():\r\r\n            if 'PHPP_lib_Assmbly_' in eachKey:\r\r\n                assmblyName = json.loads(rs.GetDocumentUserText(eachKey)).get('Name')\r\r\n                udConstParams[assmblyName] = json.loads(rs.GetDocumentUserText(eachKey))\r\r\n\r\r\n#################################################################\r\r\n# For each construction, make a new EP Material for it, then a new EP Construction\r\r\nHBMaterials_ = []\r\r\nEPConstructions_ = []\r\r\nHBConstructions_ = []\r\r\n\r\r\nuniqueEPConstTypes = list(set(srfcEPConstructions_))\r\r\nfor eachConst in uniqueEPConstTypes:\r\r\n    HBMaterials_, EPConstructions_, HBConstructions_  = addEPMatAndEPConstToLib(eachConst, HBMaterials_, EPConstructions_, HBConstructions_, udConstParams)\r\r\n\r\r\n# Find the right Surface Construction Name to pass\r\r\nfor i, srfcEPConst in enumerate(srfcEPConstructions_):\r\r\n    if srfcEPConst == None:\r\r\n        continue\r\r\n    thisSrfcName = srfcEPConst.upper().replace(\" \", \"_\")\r\r\n    for epConstrName in EPConstructions_:\r\r\n        if thisSrfcName in epConstrName:\r\r\n            srfcEPConstructions_[i] = epConstrName\r\r\n\r\r\n#################################################################\r\r\n# Check if there are NO floors in the set, if there are not any, try and \r\r\n# make one or another surface the floor as default\r\r\nif autoOrientation_:\r\r\n    for i, srfc in enumerate(srfcGeometry_):\r\r\n        srfcTypes_[i] = determineSurfaceType(srfc)\r\r\nelse:\r\r\n    if not any(item in srfcTypes_ for item in [2, 2.25, 2.5, 2.75]):\r\r\n        warn = 'No \"Floor\" type surfaces found? Note that if you try and pass\\n'\\\r\r\n        \"a Honeybee zone to the OpenStudio exporter without a floor it will cause\\n\"\\\r\r\n        \"an error. Either add a floor surface, or set 'autoOrientation_' to TRUE\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, warn)\r\r\n\r\r\n#################################################################\r\r\n# Add the HB Materials and Constructions to the HB Library\r\r\naddToHBLib_ = True\r\r\nshowLog = True #For debugging\r\r\n\r\r\nif addToHBLib_ and HBConstructions_ and HBMaterials_:\r\r\n    for eachMat in HBMaterials_:\r\r\n        HB_addToEPLibrary(eachMat, overwrite=True, printLog=showLog)\r\r\n    print '----------'\r\r\n    for eachConst in HBConstructions_:\r\r\n        HB_addToEPLibrary(eachConst, overwrite=True, printLog=showLog)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}