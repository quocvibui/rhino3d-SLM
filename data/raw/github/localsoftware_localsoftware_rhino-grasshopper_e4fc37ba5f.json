{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/plugin_files/Read_Shapefile.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "plugin_files/Read_Shapefile.py",
  "instruction": "Read shapefile",
  "code": "ï»¿from ghpythonlib.componentbase import dotnetcompiledcomponent as component\nimport Grasshopper, GhPython, System, Rhino, os, sys, System.Text\nimport struct, datetime, decimal, itertools\nimport rhinoscriptsyntax as rs\nfrom struct import unpack\nbodyname = System.Text.Encoding.Default.BodyName\nsys.setdefaultencoding(bodyname)\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nclass MyComponent(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\n            \"ReadShapefile\", \"ReadShapeFile\", \"\"\"Imports geometry from shapefile.\nDirectly imports SHP files and turns them into Grasshopper geometries.\nTheir GIS attributes are stored as User Strings in the geometry.\nBased on the work of Jackie Berry.\n    Typical usage:\nGet the location (Flie Path) of the SHPfile you want to import. The file path should include the name of the .shp file.\nAdd two Boolean toggles. Plug them into the 'Read' and 'move To Center' inputs.\nWhen Read is set to True, the component will load the SHP file into GH. When moveToCenter is set to true, the SHP file geometries will be moved to the center of the Rhino Workspace, otherwise they'll be imported into their global projection.\"\"\", \"Extra\", \"LocalCode\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"b8d4f6d9-a167-4e3c-a5fa-15c0109f8bbb\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"shapefile\", \"shapefile\", \"path to shapefile\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"read\", \"Read\", \"boolean to run script\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = GhPython.Assemblies.MarshalParam()\n        self.SetUpParam(p, \"moveToCenter\", \"moveToCenter\", \"boolean to center imported geometry at origin\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"geometry\", \"geometry\", \"imported geometry from shapefile\")\n        self.Params.Output.Add(p)\n        \n    \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        p1 = self.marshal.GetInput(DA, 1)\n        p2 = self.marshal.GetInput(DA, 2)\n        result = self.RunScript(p0, p1, p2)\n\n        if result is not None:\n            self.marshal.SetOutput(result, DA, 0, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY/l8WUAAAOWSURBVEhLxVX5S5RRFB3NZchlGqUFKycdnZncJpdqHLXRmqn+gKIgCuoH+8GCCooKIVpoI6J9oRy0aFooCtI02jfEbKWFzBZo32jPyrFO575JxbIFpuWDw/e++96c8949797R/KvHQkz9C7AR6hkzZWIs9u/PQtWePv6jKhOL55lA3nk+eo1mxLYyC4DBRP4fwCDUHs8SgZk+egq415o4MRB4k+c/KHJkX/r/EngnCwp8408O4DW/BRJrHOAbN/At30L2QcZcq8CYV75/JtDgwLLFJhQV9sCl0/0owpyScEtJCurO9yehA8/v2lGyJgmfKfagPhvLFpmwZH4i1i034369XfEcrmhXYDDmFBtlgghAREQIntzJUT/o1jUMbpKKgZdqMhAUHATviwE4VK6IWhBnCIP3XQFOHsiQ71aBsvUi4ET3mI5Yv8KCZ0/yER0VioWzjYy70Nus4ymSlcDVM5no0kWrBCp3W2HoGYabdTbUnuyL0JAgHNxrxcXqvm0FNm8wA00Okmpx/YKNREMxa4YRC2ZT+LMTFpMOe7amMj4E9+r6tQiU77Ii0RjJuHjggt0WhdVLzbjM9JK3VaB0nS9Fyb0jkWPTo+YU88/dKqMb85GarMPUSXGo3Jelct25sxZNLymw0wpzgghIDTkRHxcOjzuJafxGwOeBCweUOYEyiVEjY+Cl6fhUwJ3pVawZ0dFa3iKHMjM8LBjDh8UgLzuKcwF4dNuO00czZV2rQMkaEZBjOlF/JRtF42MV0colTB2FU5M7YfoUA9tJOjauSmw5wbGqDAQGBkAX2YH+abFqqXQE5/fX1OM24/HdXEwoNCgv5MiTiwxw5EYpATF599Y0jtt6UEEPEuIj0MTTtNRHe3WwrdTC+53DYCAJsrloKO+2CXl2vRJIsrR/i0Qg0RhBn0gsRfejSi5V19TF3YQr0k2lVnTShWBucbyKy03ZvMEncKU2E3p9qBLYS5N7xYZz9yxI6QI/bxUuHGFOg1lEjCEtRYdXT/kDmpxu1WN7WYoSuHYuCwYpKApIe05N0v2ugJicj4c37Kg+nIGPz3nkRub2bR4e37Kh4SmrmmPvi1w8uslaIdmHZ7lqTuKK/JcCsuBrw8J7vqW5SUwanZgoYyETYRnLrpvHzfilgL9oT2DHpuZ/NLlm/sKJsyfa/qONLhzXHR5PH2xxp/gNjycNxdNUV57ro9do4ohxxNg/CPJp0r4Ax1LBybCguwwAAAAASUVORK5CYII=\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n\n    def RunScript(self, shapefile, Read, moveToCenter):\n        if shapefile == None:\n            self.AddRuntimeMessage(RML.Warning, \"Add a shapefile.\")\n        if Read == None:\n            self.AddRuntimeMessage(RML.Warning, \"Add a boolean toggle in the read input.\")\n        geometry=None\n\n        def dbfreader(f):\n            \"\"\"Returns an iterator over records in a Xbase DBF file.\n\n            The first row returned contains the field names.\n            The second row contains field specs: (type, size, decimal places).\n            Subsequent rows contain the data records.\n            If a record is marked as deleted, it is skipped.\n\n            File should be opened for binary reads.\n\n            \"\"\"\n            # See DBF format spec at:\n            #     http://www.pgts.com.au/download/public/xbase.htm#DBF_STRUCT\n\n            numrec, lenheader = struct.unpack('<xxxxLH22x', f.read(32))\n            numfields = (lenheader - 33) // 32\n\n            fields = []\n            for fieldno in xrange(numfields):\n                name, typ, size, deci = struct.unpack('<11sc4xBB14x', f.read(32))\n                name = name.replace('\\0', '')       # eliminate NULs from string\n                fields.append((name, typ, size, deci))\n            yield [field[0] for field in fields]\n            yield [tuple(field[1:]) for field in fields]\n\n            terminator = f.read(1)\n            assert terminator == '\\r'\n\n            fields.insert(0, ('DeletionFlag', 'C', 1, 0))\n            fmt = ''.join(['%ds' % fieldinfo[2] for fieldinfo in fields])\n            fmtsiz = struct.calcsize(fmt)\n            for i in xrange(numrec):\n                record = struct.unpack(fmt, f.read(fmtsiz))\n                #print record#[:4]\n                if record[0] != ' ':\n                    continue                        # deleted record\n                result = []\n                for (name, typ, size, deci), value in itertools.izip(fields, record):\n                    if name == 'DeletionFlag':\n                        continue\n                    if typ == \"N\":\n                        value = value.replace('\\0', '').lstrip()\n                        if value == '':\n                            value = 0\n                        elif deci:\n                            value = decimal.Decimal(value)\n                        else:\n                            value = int(value)\n                    elif typ == 'D':\n                        #print type(value[:4]), type(value[4:6]), type(value[6:8])\n                        try:\n                            y, m, d = int(value[:4]), int(value[4:6]), int(value[6:8])\n                            value = datetime.date(y, m, d)\n                            print value\n                        except:\n                            value = datetime.date(1,1,1)\n                            print \"We couldn't get a date for a geometry in your dbf\"\n                            self.AddRuntimeMessage(RML.Warning,\"We couldn't get a date for a geometry in your dbf\")\n                    elif typ == 'L':\n                        value = (value in 'YyTt' and 'T') or (value in 'NnFf' and 'F') or '?'\n                    result.append(value)\n                yield result\n\n        ##########################################################################\n\n        class ShpFeature(object):\n            \"\"\"\n            This is a base class for each record in a shapefile.\n            each record corresponds to one row in the shapefile's dbf table.\n            To clarify the distinction between a feature and a record:\n            the record is the feature + the dbf data associated with the feature\n            the feature is shape (or multi-shape)\n            In this class, I attach the dbf data for each record to it's feature.\n            \"\"\"\n\n            def __init__(self, shpFile, recordNumber):\n                self.shpFile = shpFile\n                self.recordNumber = recordNumber\n                self.shapeType = shpFile.shapeType\n                self.dbfData = self.readDbfData()\n\n            def readDbfData(self):\n                db = self.shpFile.dbfTable\n                dbfData = {}\n                for i in range(len(db[0])): # for each column\n                        dbfData[db[0][i]] = db[self.recordNumber + 2][i]\n                return dbfData\n\n            def make3D(self, zVals=None):\n                \"\"\"\n                This method will take a list of z values and use them to create a new\n                attribute called points3D, which contains 3d points. ESRI shapefiles\n                place z values in a separate list form x and y values for each point,\n                so this essentially integrates those values to make full 3d points.\n                If the number of z values does not match the number of points,\n                then this method will not work.\n                This method will overwrite the points3d attribute if it already exists.\n                \"\"\"\n                # if there's not enough z values for the number of points\n                # or not enough points for the number of z values\n                if not zVals:\n                    zVals = [0 for i in range(self.numPoints)]\n                if len(zVals) != self.numPoints:\n                    print \"The number of Z values does not correspond to the number of points.\"\n                    self.AddRuntimeMessage(RML.Warning,\"The number of Z values does not correspond to the number of points.\")\n                    return\n                # clear points3D\n                self.points3D = []\n                for i in range(len(zVals)):\n                    z = zVals[i]\n                    x = self.points[i][0]\n                    y = self.points[i][1]\n                    point3d = (x,y,z)\n                    self.points3D.append(point3d)\n\n            def chopParts(self, partlist, pointlist):\n                if type(partlist) == tuple:\n                    indexSpread = list(partlist)\n                elif type(partlist) == list:\n                    indexSpread = partlist\n                else:\n                    indexSpread = [partlist]\n                indexSpread.append(len(pointlist))\n                chunks = []\n                for i in range(len(indexSpread) - 1):\n                    chunks.append(pointlist[indexSpread[i]:indexSpread[i+1]])\n                return chunks\n\n        class ShpPoint(ShpFeature):\n\n            def __init__(self, ShpFile, recordNumber):\n                ShpFeature.__init__(self, ShpFile, recordNumber)\n                self.parts = [0]\n                self.numParts = 1\n                self.numPoints = 1\n                self.points = [self.shpFile._readPoint()]\n                self.x = self.points[0][0]\n                self.y = self.points[0][1]\n                self.make3D()\n\n        class ShpPointM(ShpPoint):\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPoint.__init__(self, ShpFile, recordNumber)\n\n                self.m = self.shpFile._readZ()\n                self.make3D()\n\n        class ShpPointZ(ShpPoint):\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPoint.__init__(self, ShpFile, recordNumber)\n\n                self.z = self.shpFile._readZ()\n                self.m = self.shpFile._readZ()\n                self.make3D([self.z])\n\n        class ShpMultiPoint(ShpFeature):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpFeature.__init__(self, ShpFile, recordNumber)\n                self.parts[0]\n                self.numParts = 1\n                self.boundingBox = self.shpFile._readBoundingBox()\n                self.numPoints = self.shpFile._readNumPoints()\n                self.points = self.shpFile._readPoints(self.numPoints)\n                self.make3D()\n\n        class ShpMultiPointM(ShpMultiPoint):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpMultiPoint.__init__(self, ShpFile, recordNumber)\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D()\n\n        class ShpMultiPointZ(ShpMultiPoint):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpMultiPoint.__init__(self, ShpFile, recordNumber)\n                self.zBounds = self.shpFile._readZBounds()\n                self.zArray = self.shpFile._readZArray(self.numPoints)\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D(self.zArray)\n\n        class ShpPolyLine(ShpFeature):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpFeature.__init__(self, ShpFile, recordNumber)\n\n                self.boundingBox = self.shpFile._readBoundingBox()\n                self.numParts = self.shpFile._readNumParts()\n                self.numPoints = self.shpFile._readNumPoints()\n                self.parts = self.shpFile._readParts(self.numParts)\n                self.points = self.shpFile._readPoints(self.numPoints)\n                self.make3D()\n\n        class ShpPolyLineM(ShpPolyLine):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPolyLine.__init__(self, ShpFile, recordNumber)\n\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D()\n\n        class ShpPolyLineZ(ShpPolyLine):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPolyLine.__init__(self, ShpFile, recordNumber)\n\n                self.zBounds = self.shpFile._readZBounds()\n                self.zArray = self.shpFile._readZArray(self.numPoints)\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D(self.zArray)\n\n        class ShpPolygon(ShpFeature):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpFeature.__init__(self, ShpFile, recordNumber)\n\n                self.boundingBox = self.shpFile._readBoundingBox()\n                self.numParts = self.shpFile._readNumParts()\n                self.numPoints = self.shpFile._readNumPoints()\n                self.parts = self.shpFile._readParts(self.numParts)\n                self.points = self.shpFile._readPoints(self.numPoints)\n                self.make3D()\n\n        class ShpPolygonM(ShpPolygon):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPolygon.__init__(self, ShpFile, recordNumber)\n\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D()\n\n        class ShpPolygonZ(ShpPolygon):\n\n            def __init__(self,ShpFile, recordNumber):\n\n                ShpPolygon.__init__(self, ShpFile, recordNumber)\n\n                self.zBounds = self.shpFile._readZBounds()\n                self.zArray = self.shpFile._readZArray(self.numPoints)\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D(self.zArray)\n\n        class ShpMultiPatch(ShpFeature):\n\n            def __init__(self, ShpFile, recordNumber):\n\n                ShpFeature.__init__(self, ShpFile, recordNumber)\n\n                self.boundingBox = self.shpFile._readBoundingBox()\n                self.numParts = self.shpFile._readNumParts()\n                self.numPoints = self.shpFile._readNumPoints()\n                self.parts = self.shpFile._readParts(self.numParts)\n                self.partTypes = self.shpFile._readParts(self.numParts)\n                self.points = self.shpFile._readPoints(self.numPoints)\n                self.zBounds = self.shpFile._readZBounds()\n                self.zArray = self.shpFile._readZArray(self.numPoints)\n                self.mBounds = self.shpFile._readZBounds()\n                self.mArray = self.shpFile._readZArray(self.numPoints)\n                self.make3D(self.zArray)\n                #self.points = [self.shpFile._readPoint()]\n\n        ##################################################\n\n        def readAndUnpack(type, data):\n            if data=='': return data\n            return unpack(type, data)[0]\n\n        shapeTypeDict = {\n                         0:'Null Shape',\n                         1:'Point',\n                         3:'PolyLine',\n                         5:'Polygon',\n                         8:'MultiPoint',\n                         11:'PointZ',\n                         13:'PolyLineZ',\n                         15:'PolygonZ',\n                         18:'MultiPointZ',\n                         21:'PointM',\n                         23:'PolyLineM',\n                         25:'PolygonM',\n                         28:'MultiPointM',\n                         31:'MultiPatch'\n                         }\n\n        classTypeDict = {\n                        'Point':ShpPoint,\n                        'PointM':ShpPointM,\n                        'PointZ':ShpPointZ,\n                        'MultiPoint':ShpMultiPoint,\n                        'MultiPointM':ShpMultiPointM,\n                        'MultiPointZ':ShpMultiPointZ,\n                        'PolyLine':ShpPolyLine,\n                        'PolyLineM':ShpPolyLineM,\n                        'PolyLineZ':ShpPolyLineZ,\n                        'Polygon':ShpPolygon,\n                        'PolygonM':ShpPolygonM,\n                        'PolygonZ':ShpPolygonZ,\n                        'MultiPatch':ShpMultiPatch\n                        }\n\n\n        class ShpFile(object):\n            \"\"\"\n            This class is instantiated using the file path to a shapefile (must contain the .shp file extension), and as soon as it is instantiated, it reads the entire shapefile.\n            Once instantiated, it contains objects for each feature based on shape type (the objects are accessible using the\n            .records attribute), and allows access to the shapefile data at multiple levels.\n            \"\"\"\n\n            def __init__(self,filePath):\n                self.filePath = filePath\n                self.proj = self._readProjText()\n                self.dbfTable = self._readDbfTable()\n                self.f = open(self.filePath, 'rb')\n                header = self._readFileHeader()\n                self.shapeType = header[0]\n                self.boundingBox = header[1]\n                self.records = self._readRecords()\n                self.f.close()\n\n            def _readBoundingBox(self):\n                xMin = readAndUnpack('d', self.f.read(8))\n                yMin = readAndUnpack('d', self.f.read(8))\n                xMax = readAndUnpack('d', self.f.read(8))\n                yMax = readAndUnpack('d', self.f.read(8))\n                bbox = (xMin, yMin, xMax, yMax)\n                return bbox\n\n            def _readProjText(self):\n                projPath = self.filePath[0:-4] + '.prj'\n                f = open(projPath, 'r')\n                s = f.read()\n                return s\n\n\n            def _readFileHeader(self):\n                self.f.seek(32)\n                shapeKey = readAndUnpack('i', self.f.read(4))\n                shapeType = shapeTypeDict[shapeKey]\n                boundingBox = self._readBoundingBox()\n                return (shapeType, boundingBox)\n\n            def _readPoint(self):\n                x = readAndUnpack('d', self.f.read(8))\n                y = readAndUnpack('d', self.f.read(8))\n                return (x,y)\n\n            def _readNumParts(self):\n                return readAndUnpack('i', self.f.read(4))\n\n            def _readNumPoints(self):\n                return readAndUnpack('i', self.f.read(4))\n\n            def _readParts(self, numParts):\n                partIndices = []\n                for i in range(numParts):\n                    partIndex = readAndUnpack('i', self.f.read(4))\n                    partIndices.append(partIndex)\n                return partIndices\n\n            def _readPoints(self, numPoints):\n                points = []\n                # I removed a short chunk of code here\n                # that was used to remove any two identical\n                # consecutive points. Such a check is only relevant if\n                # each part is being checked separately, otherwise\n                # a part that begins where the other left off would be\n                # messed up.\n                for i in range(numPoints):\n                    point = self._readPoint()\n                    points.append(point)\n                return points\n\n            def _readZ(self):\n                z = readAndUnpack('d', self.f.read(8))\n                return z\n\n            def _readZBounds(self):\n                zMin = self._readZ()\n                zMax = self._readZ()\n                return (zMin,zMax)\n\n            def _readZArray(self, numPoints):\n                zArray = []\n                for i in range(numPoints):\n                    z = self._readZ()\n                    zArray.append(z)\n                return zArray\n\n            def setZfield(self, fieldKey=None, zValue=0.0):\n                # this method will erase any existing\n                # z data of the geometry\n                # and will replace it with values\n                # from the field designated\n                # by the fieldKey\n                zValue = 0.0\n                for record in self.records:\n                    if fieldKey != None:\n                        try:\n                            zValue = float(record.dbfData[fieldKey])\n                        except:\n                            print 'There is no field by that name in the table'\n                            self.AddRuntimeMessage(RML.Warning,\"There is no field by that name in the table\")\n                            return\n                    zArray = []\n                    for each in range(record.numPoints):\n                        zArray.append(zValue)\n                    record.make3D(zArray)\n\n            def _readDbfTable(self):\n                dbfFile = self.filePath[0:-4] + '.dbf'\n                dbf = open(dbfFile, 'rb')\n                db = list(dbfreader(dbf))\n                dbf.close()\n                return db\n\n            def _readRecords(self):\n                records = []\n                self.f.seek(100)\n                iterator = 0\n                while True:\n                    record = self._readFeature(iterator)\n                    if record == False:\n                            break\n                    records.append(record)\n                    iterator += 1\n                return records\n\n            def _readFeature(self, iterator):\n                # the next 12 bytes are simply passed over, though they contain:\n                # a record number: which doesn't seem to correspond to the dbf\n                # a content length integer\n                # a shapeType integer, which is never different form the shapeType of the file\n                read = self.f.read(12)\n                if read == '':\n                        # signifies end of shapefile\n                        return False\n                else:\n                    # get shapeType and creates appropriate feature\n                    feature = classTypeDict[self.shapeType](self,iterator)\n                    return feature\n\n        ##################################################\n\n        def addUserStrings(feature, geom):\n            data = feature.dbfData\n            for k in data:\n                geom.SetUserString(k, str(data[k]))\n            return geom\n\n        def tVect(geom, vector):\n            geom.Translate(vector)\n            geom.SetUserString('TranslationVector', str(vector) )\n            return geom\n\n        def transVectorFromBBox(shpFile):\n            \"\"\"Uses the bounding box of a shapefile to make a vector moving Rhino geometry to the origin. The translation vector\n            can also be stored as a user string the Rhino geometry, for later conversion back into geospatial data.\"\"\"\n            b = shpFile.boundingBox\n            originalCenterPoint = ((b[0]+b[2])/2, (b[1]+b[3])/2, 0.0)\n            translationVectr = Rhino.Geometry.Vector3d((b[0]+b[2])/-2.0, (b[1]+b[3])/-2.0, 0.0)\n            return translationVectr\n\n        def chop(indices, someList):\n            for i in range(len(indices)-1):\n                idx1, idx2 = indices[i], indices[i+1]\n                yield someList[idx1:idx2]\n\n        def chopPoints( feature ):\n            if feature.numParts > 1:\n                return [p for p in chop(feature.parts, feature.points3D)]\n            else:\n                return [feature.points3D]\n\n        def shpToPoints( feature, translationVector=None ):\n            # You can't set user strings to Point3d so for now lets skip it.\n            #points = [addUserStrings(feature, Rhino.Geometry.Point3d(*p)) for p in feature.points3D]\n            points = [Rhino.Geometry.Point3d(p[0],p[1],p[2]) for p in feature.points3D]\n            if translationVector:\n                points = [p.Add(p, translationVector) for p in points]\n            return points\n\n        def shpToCurve( feature, translationVector=None, degree=1):\n            parts = chopPoints( feature )\n            crvs = []\n            for part in parts:\n                points = []\n                for pt in part:\n                    rhPoint = Rhino.Geometry.Point3d( *pt )\n                    points.append( rhPoint )\n                crv = Rhino.Geometry.Curve.CreateControlPointCurve( points, degree )\n                if translationVector:\n                    crv = tVect(crv, translationVector )\n                crvs.append( addUserStrings(feature, crv) )\n            return crvs\n\n        def shpToMesh( multiPatchFeature, translationVector=None ):\n            m = multiPatchFeature\n            parts = chopPoints(m)\n            mesh = Rhino.Geometry.Mesh()\n            for i, points in enumerate(parts):\n                if m.partTypes[i] == 0: # it's a a triangle strip\n                    submesh = Rhino.Geometry.Mesh()\n                    for j, pt in enumerate(points): # build vertices\n                        rhPoint = Rhino.Geometry.Point3d(*pt)\n                        submesh.Vertices.Add(rhPoint)\n                    for n in range(len(points)-1):\n                        submesh.Faces.AddFace(n, n +1, n +2 )\n                    submesh.Normals.ComputeNormals()\n                    submesh.Compact()\n                    mesh.Append(submesh)\n                else: # it's some other geometry\n                    self.AddRuntimeMessage(RML.Error,\"This geometry type is not yet supported, sorry.\")\n                    return 'This geometry type is not yet supported, sorry.'\n            mesh.UnifyNormals()\n            mesh.Normals.ComputeNormals()\n            mesh.Compact() # mesh all fresh and ready!\n            if translationVector:\n                mesh = tVect( mesh, translationVector)\n            return [ addUserStrings(m, mesh) ]\n\n\n\n        translationDict = {\n                           'Point':shpToPoints,\n                           'Polygon':shpToCurve,\n                           'PolyLine':shpToCurve,\n                           'PolyLineZ':shpToCurve,\n                           'PolygonZ':shpToCurve,\n                           'MultiPatch':shpToMesh\n                           }\n\n        def ShpFileToRhino( filepath, zero=True, tVect=None ):\n            shpfile = ShpFile( filepath )\n            if zero:\n                tVect = transVectorFromBBox( shpfile )\n            records = shpfile.records\n            geoms = []\n            for r in records:\n                geoms.extend( translationDict[ shpfile.shapeType ]( r, tVect ) )\n            return geoms\n\n        ##################################################\n\n        if Read:\n            if shapefile:\n                if not os.path.exists(shapefile):\n                    self.AddRuntimeMessage(RML.Error,\"The shapefile you gave me does not exist.\\nDouble check the path: '%s'\" % shapefile)\n                    print 'The shapefile you gave me does not exist.\\nDouble check the path: \"%s\"' % shapefile\n                # import stuff\n                out = ShpFileToRhino( shapefile, moveToCenter )\n                print out\n                geometry = out\n            else:\n                print 'no shapefile supplied'\n\n        # return outputs if you have them; here I try it for you:\n        return geometry\n\n\nimport GhPython\nimport System\n\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\n    def get_AssemblyName(self):\n        return \"ReadShapefile\"\n    \n    def get_AssemblyDescription(self):\n        return \"\"\"\"\"\"\n\n    def get_AssemblyVersion(self):\n        return \"0.1\"\n\n    def get_AuthorName(self):\n        return \"\"\n    \n    def get_Id(self):\n        return System.Guid(\"40a03f13-7f52-4d8e-b833-adfc75546908\")",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}