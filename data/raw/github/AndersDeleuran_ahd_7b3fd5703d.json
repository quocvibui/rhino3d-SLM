{
  "source_url": "https://github.com/AndersDeleuran/ahd/blob/0b48d7581ee980c31b1d3a773e9b2adc03b8acf9/ahd.py",
  "repo": "AndersDeleuran/ahd",
  "repo_stars": 11,
  "repo_description": "Utility functions for writing GHPython scripts",
  "license": "Apache-2.0",
  "filepath": "ahd.py",
  "instruction": "Utility functions for writing GHPython scripts\r\nAuthor: Anders Holden Deleuran\r\nVersion: 250108",
  "code": "\"\"\"\r\nUtility functions for writing GHPython scripts\r\nAuthor: Anders Holden Deleuran\r\nVersion: 250108\r\n\"\"\"\r\n\r\nimport time\r\nimport math\r\nfrom scriptcontext import sticky as st\r\nimport Rhino as rc\r\nimport Grasshopper as gh\r\nimport GhPython\r\nimport datetime\r\nimport rhinoscriptsyntax as rs\r\nimport System.Drawing as sd\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Timer(object):\r\n    \r\n    \"\"\" A simple profiler \"\"\"\r\n    \r\n    def start(self):\r\n\r\n        # Start the timer\r\n        self.startTime = time.time()\r\n        \r\n    def stop(self):\r\n        \r\n        # Print and return elapsed time\r\n        elapsedSeconds = time.time() - self.startTime\r\n        elapsedMilliseconds = elapsedSeconds*1000\r\n        print str(round(elapsedMilliseconds,3)) + \" ms\"\r\n        return elapsedMilliseconds\r\n\r\ndef listToTree(nestedList):\r\n    \r\n    \"\"\" Convert a nested python iterable to a datatree \"\"\"\r\n    \r\n    dt = gh.DataTree[object]()\r\n    for i,l in enumerate(nestedList):\r\n        dt.AddRange(l,gh.Kernel.Data.GH_Path(i))\r\n        \r\n    return dt\r\n\r\ndef customDisplay(toggle,component):\r\n    \r\n    \"\"\" Make a custom display which is unique to the component and lives in sticky \"\"\"\r\n    \r\n    # Make unique name and custom display\r\n    displayGuid = \"customDisplay_\" + str(component.InstanceGuid)\r\n    if displayGuid not in st:\r\n        st[displayGuid] = rc.Display.CustomDisplay(True)\r\n        \r\n    # Clear display each time component runs\r\n    st[displayGuid].Clear()\r\n    \r\n    # Return the display or get rid of it\r\n    if toggle:\r\n        return st[displayGuid]\r\n    else:\r\n        st[displayGuid].Dispose()\r\n        del st[displayGuid]\r\n        return None\r\n\r\ndef killCustomDisplays():\r\n    \r\n    \"\"\" Clear any custom displays living in the Python sticky dictionary \"\"\"\r\n    \r\n    for k,v in st.items():\r\n        if type(v) is rc.Display.CustomDisplay:\r\n            v.Dispose()\r\n            del st[k]\r\n\r\ndef remapValues(values,targetMin,targetMax,srcMin,srcMax):\r\n    \r\n    \"\"\" Remaps a list of values to the new domain targetMin-targetMax \"\"\"\r\n    \r\n    #srcMin = min(values)\r\n    #srcMax = max(values)\r\n    \r\n    if srcMax-srcMin > 0:\r\n        remappedValues = []\r\n        for v in values:\r\n            rv = ((v-srcMin)/(srcMax-srcMin))*(targetMax-targetMin)+targetMin\r\n            remappedValues.append(rv)\r\n    else:\r\n        meanVal = (targetMin+targetMax)/2\r\n        remappedValues = [meanVal for i in range(len(values))]\r\n        \r\n    return remappedValues\r\n\r\ndef valuesToColors(values):\r\n    \r\n    \"\"\" Make a list of HSL colors, meaning that 0.0: red and 0.6: blue \"\"\"\r\n    \r\n    colors = []\r\n    for v in values:\r\n        rcColor = rc.Display.ColorHSL(v,1.0,0.5)\r\n        colors.append(rcColor)\r\n        \r\n    return colors\r\n\r\ndef sampleColorSpectrum(colors,t,smooth):\r\n    \r\n    \"\"\" Interpolate along multiple colors by 0.00-1.00 parameter t \"\"\"\r\n    \r\n    if t <= 0.0:\r\n        return colors[0]\r\n    elif t >= 1.0:\r\n        return colors[-1]\r\n    else:\r\n        \r\n        # Compute spectrum t, starting color, and local t\r\n        tSpectrum = t * (len(colors)-1)\r\n        colorID = int(math.floor(tSpectrum))\r\n        tLocal = tSpectrum-colorID\r\n        \r\n        # Use cosine interpolation (see paulbourke.net/miscellaneous/interpolation)\r\n        if smooth:\r\n            tLocal = (1-math.cos(tLocal*math.pi))/2\r\n            \r\n        # Blend colors\r\n        cA = rc.Display.Color4f(colors[colorID])\r\n        cB = rc.Display.Color4f(colors[colorID+1])\r\n        cC = cA.BlendTo(tLocal,cB)\r\n        blendColor = cC.AsSystemColor()\r\n        \r\n        return blendColor\r\n\r\ndef colorMeshFaces_V5(mesh,colors):\r\n    \r\n    \"\"\" Unwelds and color the faces of a mesh \"\"\"\r\n    \r\n    # Get faces/vertices\r\n    faces = mesh.Faces\r\n    vertices = mesh.Vertices\r\n    \r\n    # Make empty mesh and face-vertex ID counter \r\n    cMesh = rc.Geometry.Mesh()\r\n    fID = 0\r\n    for i in range(faces.Count):\r\n        \r\n        # Get face and color\r\n        f = faces[i]\r\n        c = colors[i]\r\n        \r\n        # Add face vertices and colors to empty cMesh\r\n        cMesh.Vertices.Add(vertices[f.A])\r\n        cMesh.Vertices.Add(vertices[f.B])\r\n        cMesh.Vertices.Add(vertices[f.C])\r\n        cMesh.VertexColors.Add(c)\r\n        cMesh.VertexColors.Add(c)\r\n        cMesh.VertexColors.Add(c)\r\n        if f.IsQuad:\r\n            cMesh.Vertices.Add(vertices[f.D])\r\n            cMesh.VertexColors.Add(c)\r\n            \r\n       # Add face\r\n        if f.IsQuad:\r\n            cMesh.Faces.AddFace(fID,fID+1,fID+2,fID+3)\r\n            fID += 4\r\n        elif f.IsTriangle:\r\n            cMesh.Faces.AddFace(fID,fID+1,fID+2)\r\n            fID += 3\r\n            \r\n    return cMesh\r\n\r\ndef colorMeshFaces_V6(mesh,colors):\r\n    \r\n    \"\"\" Unwelds and color the faces of the mesh in place \"\"\"\r\n    \r\n    mesh.VertexColors.CreateMonotoneMesh(sd.Color.Black)\r\n    mesh.Unweld(0,False)\r\n    for i in range(mesh.Faces.Count):\r\n        mesh.VertexColors.SetColor(mesh.Faces[i],colors[i])\r\n\r\ndef makeLegendParams(capLower,capUpper,hueLower,hueUpper,count):\r\n    \r\n    \"\"\" Make a list of data following the Ladybug format,\r\n    used for generating a CustomVectorLegend \"\"\"\r\n    \r\n    hues = floatRange(hueLower,hueUpper,count-1)\r\n    colors = valuesToColors(hues)\r\n    lp = [capLower,capUpper,None,colors]\r\n    return lp\r\n\r\ndef updateComponent(ghenv,interval):\r\n    \r\n    \"\"\" Updates this component, similar to using a grasshopper timer \"\"\"\r\n    \r\n    # Define callback action\r\n    def callBack(e):\r\n        ghenv.Component.ExpireSolution(False)\r\n        \r\n    # Get grasshopper document\r\n    ghDoc = ghenv.Component.OnPingDocument()\r\n    \r\n    # Schedule this component to expire\r\n    ghDoc.ScheduleSolution(interval,gh.Kernel.GH_Document.GH_ScheduleDelegate(callBack))\r\n\r\ndef buildDocString_LEGACY(ghenv):\r\n    \r\n    \"\"\" Builds a documentation string by iterating the component\r\n    (i.e. ghenv.Component) input and outputs parameters \"\"\"\r\n    \r\n    # Add component description string\r\n    ds = '\"\"\"\\n'\r\n    ds += \"Write main component documentation here.\\n\"\r\n    \r\n    # Add input parameter type properties\r\n    ds += \"    Inputs:\\n\"\r\n    for v in ghenv.Component.Params.Input:\r\n        dataType = str(v.TypeHint.TypeName).lower()\r\n        vd = list(v.VolatileData.AllData(False))\r\n        if vd and dataType == \"system.object\":\r\n            vdType = str(vd[0].GetType())\r\n            vdType = vdType.split(\".\")[-1]\r\n            dataType = vdType.strip(\"GH_\").lower()\r\n        ds += \"        \" + v.Name + \": {\" + str(v.Access).lower() + \",\" + dataType + \"}\\n\"\r\n        \r\n    # Add output parameter type properties\r\n    ds += \"    Outputs:\\n\"\r\n    for v in ghenv.Component.Params.Output:\r\n        ds += \"        \" + v.Name + \": \\n\"\r\n        # print globals()[v.Name]\r\n        \r\n    # Add author, Rhino, and script version\r\n    ds += \"    Remarks:\\n\"\r\n    ds += \"        Author: Anders Holden Deleuran (BIG IDEAS)\\n\"\r\n    ds += \"        Rhino: \" + str(rc.RhinoApp.Version) + \"\\n\"\r\n    ds += \"        Version: \" + str(datetime.date.today()).replace(\"-\",\"\")[2:] + \"\\n\"\r\n    ds += '\"\"\"'\r\n    \r\n    print ds\r\n    return ds\r\n\r\ndef getParameterProperties(p,globalsDict):\r\n    \r\n    \"\"\" Extract a component parameter name, access, and data type \"\"\"\r\n\r\n    # Get name, data and set initial type\r\n    pName = p.Name\r\n    pData = globalsDict[pName]\r\n    pDataType = None\r\n\r\n    # Determine access and data type\r\n    if type(pData) is list:\r\n        pAccess = \"list\"\r\n        if pData:\r\n            pDataType = type(pData[0])\r\n    elif type(pData) is gh.DataTree[object]:\r\n        pAccess = \"tree\"\r\n        if pData: \r\n            pDataType = type(pData.AllData()[0])\r\n    else:\r\n        pAccess = \"item\"\r\n        if pData is not None:\r\n            pDataType = type(pData)\r\n        \r\n    # Format data type string\r\n    if pDataType:\r\n        pDataType = pDataType.__name__.lower()\r\n    else:\r\n        pDataType = \"?\"\r\n    \r\n    return pName,pAccess,pDataType\r\n\r\ndef buildDocString(globalsDict):\r\n    \r\n    \"\"\" Builds a documentation string by iterating the ghenv.Component input\r\n    and outputs parameters. Call with globals() as input at very end of script \"\"\"\r\n\r\n    # Get ghenv\r\n    ghenv = globalsDict[\"ghenv\"]\r\n    \r\n    # Add component description string\r\n    ds = '\"\"\"\\n'\r\n    ds += \"Write main component documentation here.\\n\"\r\n    \r\n    # Add input parameter type properties\r\n    ds += \"    Inputs:\\n\"\r\n    for p in ghenv.Component.Params.Input:\r\n        pName,pAccess,pDataType = getParameterProperties(p,globalsDict)\r\n        ds += \"        \" + pName + \": {\" + pAccess + \",\" + pDataType + \"}\\n\"\r\n        \r\n    # Add output parameter type properties\r\n    ds += \"    Outputs:\\n\"\r\n    for p in ghenv.Component.Params.Output:\r\n        pName,pAccess,pDataType = getParameterProperties(p,globalsDict)\r\n        ds += \"        \" + pName + \": {\" + pAccess + \",\" + pDataType + \"}\\n\"\r\n        \r\n    # Add author, Rhino, and script version\r\n    ds += \"    Remarks:\\n\"\r\n    ds += \"        Author: Anders Holden Deleuran (BIG CPH)\\n\"\r\n    ds += \"        Rhino: \" + str(rc.RhinoApp.Version) + \"\\n\"\r\n    ds += \"        Version: \" + str(datetime.date.today()).replace(\"-\",\"\")[2:] + \"\\n\"\r\n    ds += '\"\"\"\\n'\r\n    \r\n    # Add names\r\n    ds += \"\\n\"\r\n    ds += 'ghenv.Component.Name = \"FooBar\"\\n'\r\n    ds += 'ghenv.Component.NickName = \"FB\"\\n'\r\n\r\n    print ds\r\n    return ds\r\n\r\ndef setParametersToDrawName():\r\n    \r\n    \"\"\" Set all canvas parameters to always draw name \"\"\"\r\n    \r\n    for obj in gh.Instances.ActiveCanvas.Document.Objects:\r\n        if obj.GetType().Namespace == \"Grasshopper.Kernel.Parameters\":\r\n            obj.IconDisplayMode = gh.Kernel.GH_IconDisplayMode.name\r\n            obj.ExpireSolution(True)\r\n\r\ndef setNoTypeHint(ghenv):\r\n    \r\n    \"\"\" Set all input parameters to No Type Hint, DO NOT USE YET!!\"\"\"\r\n    \r\n    for v in ghenv.Component.Params.Input:\r\n        v.TypeHint = GhPython.Component.NoChangeHint()\r\n    ghenv.Component.ExpireSolution(False)\r\n\r\n\r\ndef capValues(values,lower,upper):\r\n    \r\n    \"\"\" Cap values that are smaller than lower and larger than upper \"\"\"\r\n    \r\n    capped = []\r\n    for v in values:\r\n        if v < lower:\r\n            capped.append(lower)\r\n        elif v > upper:\r\n            capped.append(upper)\r\n        else:\r\n            capped.append(v)\r\n            \r\n    return capped\r\n\r\ndef floatRange(start,stop,steps):\r\n    \r\n    \"\"\" Generate a range of floats, similar to Grasshoppers Range \"\"\"\r\n    \r\n    stepSize = (stop-start)/steps\r\n    values = [start]\r\n    for i in range(1,steps):\r\n        values.append(i*stepSize+start)\r\n    values.append(stop)\r\n    \r\n    return values\r\n\r\ndef closestValue(v,values):\r\n    \r\n    \"\"\" Find the value that is closest to v in values \"\"\"\r\n    \r\n    i = bisect.bisect_left(values,v)\r\n    if i == len(values):\r\n        return i-1\r\n    elif values[i] == v:\r\n        return i\r\n    elif i > 0:\r\n        j = i-1\r\n        if values[i] - v > v - values[j]:\r\n            return j\r\n    return i\r\n\r\ndef discretiseValues(values,steps):\r\n    \r\n    \"\"\" Bin/bucket/discretise a list of values into N steps \"\"\"\r\n    \r\n    # Calculate the bin values\r\n    bins = floatRange(min(values),max(values),int(Steps))\r\n    bins.sort()\r\n    \r\n    # Find the closest bin for each value\r\n    closestBins = [closestValue(v,bins) for v in values]\r\n    \r\n    return closestBins\r\n\r\ndef meshGrid(points,ptsU,ptsV):\r\n    \r\n    \"\"\" Make a quad mesh from a grid of points \"\"\" \r\n    \r\n    if len(points) == ptsU*ptsV:\r\n        \r\n        # Make mesh and add vertices\r\n        mesh = rc.Geometry.Mesh()\r\n        mesh.Vertices.AddVertices(rc.Collections.Point3dList(points))\r\n        \r\n        # Add faces\r\n        for i in range(ptsU-1):\r\n            for j in range(0,ptsU*(ptsV-1),ptsU):\r\n                ij = i+j\r\n                mesh.Faces.AddFace(ij, ij+ptsU, ij+ptsU+1, ij+1)\r\n                \r\n        # Compute normals and return\r\n        mesh.Normals.ComputeNormals()\r\n        \r\n        return mesh\r\n\r\ndef ghSolutionRecompute(ghenv):\r\n    \r\n    \"\"\" Recomputes the Grasshopper solution (ala pressing F5) \"\"\"\r\n    \r\n    def expireAllComponentsButThis(e):\r\n        for obj in ghenv.Component.OnPingDocument().Objects:\r\n            if not obj.InstanceGuid == ghenv.Component.InstanceGuid:\r\n                obj.ExpireSolution(False)\r\n                \r\n    ghenv.Component.OnPingDocument().ScheduleSolution(1000,expireAllComponentsButThis)\r\n\r\ndef getNeighbourIndex(indices,i,n):\r\n    \r\n    \"\"\" Get index n indices (can be negative) from i, wraps around start \"\"\"\r\n    \r\n    if i+n > indices-1:\r\n        nID = i+n-indices\r\n    elif i+n < 0:\r\n        nID = i+n+indices\r\n    else:\r\n        nID = i+n\r\n        \r\n    return nID\r\n\r\ndef schlickFalloff(x,a):\r\n    \r\n    \"\"\" Christophe Schlick's bias function (a = 0.0-1.0, 0.5 is linear) \"\"\"\r\n    \r\n    y = x/((1/a-2)*(1-x)+1)\r\n    \r\n    return y\r\n\r\ndef interpolateVectors(vecA,vecB,t):\r\n    \r\n    \"\"\" Interpolate between two vectors by 0.00-1.00 parameter \"\"\"\r\n    \r\n    # Lerp components\r\n    x = t*(vecB.X-vecA.X)+vecA.X\r\n    y = t*(vecB.Y-vecA.Y)+vecA.Y\r\n    z = t*(vecB.Z-vecA.Z)+vecA.Z\r\n    \r\n    # Make and unitize vector \r\n    vecAB = rc.Geometry.Vector3d(x,y,z)\r\n    vecAB.Unitize()\r\n    \r\n    # Lerp length\r\n    lenAB = t*(vecB.Length-vecA.Length)+vecA.Length\r\n    vecAB *= lenAB\r\n    \r\n    return vecAB\r\n\r\n\r\ndef lerp(a,b,t):\r\n    \r\n    \"\"\" Linear interpolate a and b by t \"\"\"\r\n    \r\n    return t*(b-a)+a\r\n\r\n\r\ndef minimiseSliders():\r\n    \r\n    \"\"\" Minimise width of all sliders on active canvas \"\"\"\r\n    \r\n    for obj in gh.Instances.ActiveCanvas.Document.Objects:\r\n        if type(obj) is gh.Kernel.Special.GH_NumberSlider:\r\n            b = obj.Attributes.Bounds\r\n            b.Width = 0\r\n            obj.Attributes.Bounds = b\r\n            obj.ExpireSolution(True)\r\n\r\ndef setScribbleFont():\r\n    \r\n    \"\"\" Set font name and size of all scribbles \"\"\"\r\n    \r\n    for obj in gh.Instances.ActiveCanvas.Document.Objects:\r\n        if type(obj) is gh.Kernel.Special.GH_Scribble:\r\n            obj.Font = sd.Font(\"Arial\",int(20))\r\n            obj.ExpireSolution(False)\r\n\r\ndef flipRhinoBackgroundColor():\r\n    \r\n    \"\"\" Flip Rhino viewport background color between light and dark \"\"\"\r\n    \r\n    bv = 30\r\n    lv = 255\r\n    dark = sd.Color.FromArgb(255,bv,bv,bv)\r\n    light = sd.Color.FromArgb(255,lv,lv,lv)\r\n    if rc.ApplicationSettings.AppearanceSettings.ViewportBackgroundColor == dark:\r\n        rc.ApplicationSettings.AppearanceSettings.ViewportBackgroundColor = light\r\n    elif rc.ApplicationSettings.AppearanceSettings.ViewportBackgroundColor == light:\r\n        rc.ApplicationSettings.AppearanceSettings.ViewportBackgroundColor = dark\r\n\r\ndef getRhinoBackgroundTopColor():\r\n    \r\n    \"\"\" Get active Rhino viewport display top left background color \"\"\"\r\n    \r\n    # Get active Rhino document, display and fill modes\r\n    doc = rc.RhinoDoc.ActiveDoc\r\n    dim = doc.Views.ActiveView.ActiveViewport.DisplayMode\r\n    fim = dim.DisplayAttributes.FillMode\r\n    fbf = rc.Display.DisplayPipelineAttributes.FrameBufferFillMode\r\n    \r\n    # Get top left background color for default, render and solid/gradient modes\r\n    if fim == fbf.DefaultColor:\r\n        return rc.ApplicationSettings.AppearanceSettings.ViewportBackgroundColor\r\n    elif fim == fbf.Renderer:\r\n        return doc.RenderSettings.BackgroundColorTop\r\n    else:\r\n        return dim.DisplayAttributes.GetFill()[0]\r\n\r\ndef setTemplateLayerColors():\r\n\r\n    \"\"\" Set Rhino layer colors to the AHD style \"\"\"\r\n\r\n    # Set context to Rhino document and disable redraw\r\n    sc.doc = rc.RhinoDoc.ActiveDoc\r\n    rs.EnableRedraw(False)\r\n\r\n    # Set layer colors\r\n    for i,l in enumerate(rs.LayerNames()):\r\n        if i == 0:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,105,105,105))   \r\n        elif i == 1:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,255,0,90))    \r\n        elif i == 2:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,70,190,190))   \r\n        elif i == 3:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,0,85,255))\r\n        elif i == 4:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,130,255,0))\r\n        elif i == 5:\r\n            rs.LayerColor (l,sd.Color.FromArgb(255,190,190,190))\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}