{
  "source_url": "https://github.com/guillermodoghel/toroide/blob/443b5d9df776869b4b235a942c4ec26de022e9da/generate_3d_views.py",
  "repo": "guillermodoghel/toroide",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "generate_3d_views.py",
  "instruction": "3D Model View Generator for Rhino .3dm files\nGenerates orthographic and isometric wireframe views from actual 3DM geometry",
  "code": "#!/usr/bin/env python3\n\"\"\"\n3D Model View Generator for Rhino .3dm files\nGenerates orthographic and isometric wireframe views from actual 3DM geometry\n\"\"\"\n\nimport matplotlib\nmatplotlib.use('Agg')  # Set backend before importing pyplot\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport sys\nimport argparse\nfrom pathlib import Path\n\ndef find_3dm_file(directory='.'):\n    \"\"\"Find the first .3dm file in the specified directory\"\"\"\n    for file in Path(directory).glob('*.3dm'):\n        return str(file)\n    return None\n\ndef sample_curve_points(curve, count=50):\n    \"\"\"Sample points along a curve\"\"\"\n    points = []\n    try:\n        # Try multiple approaches for different curve types\n        if hasattr(curve, 'Domain'):\n            domain = curve.Domain\n            # Fix: Use T0 and T1 instead of Min and Max for rhino3dm intervals\n            t_start = domain.T0\n            t_end = domain.T1\n            for i in range(count):\n                t = t_start + (t_end - t_start) * i / (count - 1)\n                if hasattr(curve, 'PointAt'):\n                    pt = curve.PointAt(t)\n                    if pt:\n                        points.append([pt.X, pt.Y, pt.Z])\n                        \n        elif hasattr(curve, 'Points') and hasattr(curve.Points, 'Count'):\n            # NURBS curve with control points\n            point_count = curve.Points.Count\n            step = max(1, point_count // count)\n            for i in range(0, point_count, step):\n                pt = curve.Points[i].Location\n                points.append([pt.X, pt.Y, pt.Z])\n        \n        # Alternative: try direct point access for PolylineCurves\n        elif hasattr(curve, 'PointCount'):\n            point_count = curve.PointCount\n            step = max(1, point_count // count)\n            for i in range(0, point_count, step):\n                if hasattr(curve, 'Point'):\n                    pt = curve.Point(i)\n                    if pt:\n                        points.append([pt.X, pt.Y, pt.Z])\n        \n        # For PolylineCurves, try accessing points directly\n        elif hasattr(curve, 'GetPoints'):\n            curve_points = curve.GetPoints()\n            if curve_points:\n                step = max(1, len(curve_points) // count)\n                for i in range(0, len(curve_points), step):\n                    pt = curve_points[i]\n                    points.append([pt.X, pt.Y, pt.Z])\n                        \n    except Exception as e:\n        print(f\"    ‚ùå Error sampling curve: {e}\")\n        \n    return points\n\ndef extract_actual_geometry_from_3dm(model_file):\n    \"\"\"Extract real geometry from 3DM file - filtered by specific layers\"\"\"\n    try:\n        import rhino3dm as rhino\n        print(f\"üìñ Reading 3DM file: {model_file}\")\n        \n        model = rhino.File3dm.Read(model_file)\n        if not model:\n            print(\"‚ùå Failed to read 3DM file\")\n            return None\n        \n        print(f\"üìã Found {len(model.Objects)} objects in the model\")\n        \n        # Get layer information\n        layers_by_index = {}\n        if hasattr(model, 'Layers'):\n            for layer in model.Layers:\n                layers_by_index[layer.Index] = layer.Name\n                print(f\"  Layer {layer.Index}: '{layer.Name}'\")\n        \n        # Target layers to extract\n        target_layers = [\"Costilla\", \"Vertebra\", \"Vias\"]\n        print(f\"üéØ Target layers: {target_layers}\")\n        \n        # Print object info for debugging with layer information\n        relevant_objects = []\n        for i, obj in enumerate(model.Objects):\n            geom = obj.Geometry\n            geom_type = type(geom).__name__ if geom else \"None\"\n            \n            # Get layer name\n            layer_name = \"Unknown\"\n            if hasattr(obj, 'Attributes') and hasattr(obj.Attributes, 'LayerIndex'):\n                layer_index = obj.Attributes.LayerIndex\n                layer_name = layers_by_index.get(layer_index, f\"Layer_{layer_index}\")\n            \n            print(f\"  Object {i}: {geom_type} on layer '{layer_name}'\")\n            \n            # Filter by target layers\n            if layer_name in target_layers:\n                relevant_objects.append((i, obj))\n                print(f\"    ‚úÖ Will process this object\")\n        \n        print(f\"üîç Found {len(relevant_objects)} objects on target layers\")\n        \n        if len(relevant_objects) == 0:\n            print(\"‚ùå No objects found on target layers\")\n            return None\n        \n        all_curves_with_layers = []\n        \n        # Process only objects on target layers\n        for i, obj in relevant_objects:\n            geom = obj.Geometry\n            if not geom:\n                continue\n                \n            # Get layer name for this object\n            layer_name = \"Unknown\"\n            if hasattr(obj, 'Attributes') and hasattr(obj.Attributes, 'LayerIndex'):\n                layer_index = obj.Attributes.LayerIndex\n                layer_name = layers_by_index.get(layer_index, f\"Layer_{layer_index}\")\n                \n            print(f\"üîç Processing object {i} ({type(geom).__name__}) on layer '{layer_name}'\")\n            \n            try:\n                # Handle different geometry types\n                if hasattr(geom, 'Faces') and len(geom.Faces) > 0:\n                    # It's a Brep/Surface - extract edge curves\n                    print(f\"  üìê Brep with {len(geom.Faces)} faces\")\n                    \n                    # Try multiple approaches for Brep edge extraction\n                    edges_extracted = 0\n                    \n                    # Method 1: Extract from Brep.Edges\n                    if hasattr(geom, 'Edges'):\n                        print(f\"    üîç Found {len(geom.Edges)} edges in Brep\")\n                        for edge_idx, edge in enumerate(geom.Edges):\n                            try:\n                                # Try different ways to get curve from edge\n                                curve = None\n                                \n                                # Try various rhino3dm edge curve access methods\n                                if hasattr(edge, 'EdgeCurve') and edge.EdgeCurve:\n                                    curve = edge.EdgeCurve\n                                elif hasattr(edge, 'Curve') and edge.Curve:\n                                    curve = edge.Curve\n                                elif hasattr(edge, 'DuplicateCurve'):\n                                    curve = edge.DuplicateCurve()\n                                elif hasattr(edge, 'ToNurbsCurve'):\n                                    curve = edge.ToNurbsCurve()\n                                \n                                if curve:\n                                    points = sample_curve_points(curve)\n                                    if len(points) > 1:\n                                        all_curves_with_layers.append((points, layer_name))\n                                        edges_extracted += 1\n                                        print(f\"    ‚úÖ Extracted edge {edge_idx} with {len(points)} points\")\n                                else:\n                                    # Debug: print edge properties\n                                    if edge_idx < 3:  # Only print for first few edges to avoid spam\n                                        edge_props = [attr for attr in dir(edge) if not attr.startswith('_')]\n                                        print(f\"    üîç Edge {edge_idx} properties: {edge_props[:10]}...\")\n                                    \n                            except Exception as e:\n                                print(f\"    ‚ö†Ô∏è Edge {edge_idx} error: {e}\")\n                                if edge_idx < 3:  # Only print details for first few\n                                    import traceback\n                                    traceback.print_exc()\n                    \n                    # Method 2: Extract from Face loops if edges didn't work\n                    if edges_extracted == 0:\n                        print(f\"    üîç Trying face loop extraction...\")\n                        for face_idx, face in enumerate(geom.Faces):\n                            try:\n                                # Try different face boundary extraction methods\n                                extracted_from_face = False\n                                \n                                # Method 2a: OuterLoop.To3dCurve()\n                                if hasattr(face, 'OuterLoop'):\n                                    loop = face.OuterLoop\n                                    if hasattr(loop, 'To3dCurve'):\n                                        curve = loop.To3dCurve()\n                                        if curve:\n                                            points = sample_curve_points(curve)\n                                            if len(points) > 1:\n                                                all_curves_with_layers.append((points, layer_name))\n                                                edges_extracted += 1\n                                                extracted_from_face = True\n                                                print(f\"    ‚úÖ Extracted face {face_idx} outer loop with {len(points)} points\")\n                                \n                                # Method 2b: Try getting surface boundary\n                                if not extracted_from_face and hasattr(face, 'ToBrep'):\n                                    try:\n                                        face_brep = face.ToBrep()\n                                        if face_brep and hasattr(face_brep, 'Edges'):\n                                            for edge in face_brep.Edges:\n                                                if hasattr(edge, 'DuplicateCurve'):\n                                                    curve = edge.DuplicateCurve()\n                                                    if curve:\n                                                        points = sample_curve_points(curve)\n                                                        if len(points) > 1:\n                                                            all_curves_with_layers.append((points, layer_name))\n                                                            edges_extracted += 1\n                                                            extracted_from_face = True\n                                                            break\n                                    except:\n                                        pass\n                                \n                                # Method 2c: Extract all loops\n                                if not extracted_from_face and hasattr(face, 'Loops'):\n                                    for loop_idx, loop in enumerate(face.Loops):\n                                        if hasattr(loop, 'To3dCurve'):\n                                            curve = loop.To3dCurve()\n                                            if curve:\n                                                points = sample_curve_points(curve)\n                                                if len(points) > 1:\n                                                    all_curves_with_layers.append((points, layer_name))\n                                                    edges_extracted += 1\n                                                    extracted_from_face = True\n                                                    print(f\"    ‚úÖ Extracted face {face_idx} loop {loop_idx} with {len(points)} points\")\n                                \n                                # Debug: print face properties if nothing worked\n                                if not extracted_from_face and face_idx < 2:\n                                    face_props = [attr for attr in dir(face) if not attr.startswith('_')]\n                                    print(f\"    üîç Face {face_idx} properties: {face_props[:10]}...\")\n                                    \n                            except Exception as e:\n                                print(f\"    ‚ö†Ô∏è Face {face_idx} error: {e}\")\n                                if face_idx < 2:\n                                    import traceback\n                                    traceback.print_exc()\n                    \n                    print(f\"    üìä Total extracted from Brep: {edges_extracted} curves\")\n                \n                elif hasattr(geom, 'ToBrep') or 'Extrusion' in type(geom).__name__:\n                    # It's an Extrusion - extract profile curves using Profile3d method\n                    print(f\"  üèóÔ∏è Extrusion object - extracting profile curves\")\n                    edges_extracted = 0\n                    try:\n                        # Extract profile curves using Profile3d method\n                        if hasattr(geom, 'Profile3d'):\n                            try:\n                                # Extract profile curves with different indices (start and end of extrusion)\n                                for profile_idx in range(5):  # Try first few profiles\n                                    try:\n                                        # Get profile curve at parameter s=0.0 (start of extrusion)\n                                        profile_curve = geom.Profile3d(profile_idx, 0.0)\n                                        if profile_curve:\n                                            points = sample_curve_points(profile_curve)\n                                            if len(points) > 1:\n                                                all_curves_with_layers.append((points, layer_name))\n                                                edges_extracted += 1\n                                        \n                                        # Also try at parameter s=1.0 (end of extrusion) \n                                        profile_curve_end = geom.Profile3d(profile_idx, 1.0)\n                                        if profile_curve_end:\n                                            points_end = sample_curve_points(profile_curve_end)\n                                            if len(points_end) > 1:\n                                                all_curves_with_layers.append((points_end, layer_name))\n                                                edges_extracted += 1\n                                                \n                                    except Exception:\n                                        # Expected to fail when we run out of valid profiles\n                                        break\n                                        \n                            except Exception as e:\n                                print(f\"    ‚ùå Profile3d access failed: {e}\")\n                        \n                        # Try to extract path curves if available\n                        for method in ['PathCurve', 'GetPath']:\n                            if hasattr(geom, method):\n                                try:\n                                    value = getattr(geom, method)\n                                    if callable(value):\n                                        result = value()\n                                        if result and not hasattr(result, 'X'):  # Not a point, try as curve\n                                            points = sample_curve_points(result)\n                                            if len(points) > 1:\n                                                all_curves_with_layers.append((points, layer_name))\n                                                edges_extracted += 1\n                                except Exception:\n                                    continue\n                        \n                        \n                        # If direct access doesn't work, try converting to Brep as fallback\n                        if edges_extracted == 0:\n                            print(f\"    üîÑ Profile curves not found, trying Brep conversion\")\n                            brep = geom.ToBrep(True)\n                            if brep and hasattr(brep, 'Edges'):\n                                print(f\"    üîç Found {len(brep.Edges)} edges in Extrusion Brep\")\n                                \n                                for edge_idx, edge in enumerate(brep.Edges):\n                                    try:\n                                        curve = None\n                                        # Try alternative edge curve extraction methods\n                                        if hasattr(edge, 'TryGetPlane'):\n                                            # Skip planar edges for cleaner wireframes\n                                            continue\n                                        \n                                        # Try direct curve access\n                                        for method in ['DuplicateCurve', 'EdgeCurve', 'Curve']:\n                                            if hasattr(edge, method):\n                                                curve = getattr(edge, method)\n                                                if callable(curve):\n                                                    curve = curve()\n                                                if curve:\n                                                    break\n                                        \n                                        if curve:\n                                            points = sample_curve_points(curve)\n                                            if len(points) > 1:\n                                                all_curves_with_layers.append((points, layer_name))\n                                                edges_extracted += 1\n                                                print(f\"    ‚úÖ Extracted edge {edge_idx} with {len(points)} points\")\n                                    except Exception as edge_e:\n                                        continue\n                        \n                        print(f\"    üìä Total extracted from Extrusion: {edges_extracted} curves\")\n                        \n                    except Exception as extrusion_e:\n                        print(f\"  ‚ùå Error processing Extrusion: {extrusion_e}\")\n                        \n                elif hasattr(geom, 'ToNurbsCurve') or 'Curve' in type(geom).__name__:\n                    # It's a curve - sample it directly\n                    points = sample_curve_points(geom)\n                    if len(points) > 1:\n                        all_curves_with_layers.append((points, layer_name))\n                        print(f\"  ‚úÖ Extracted curve with {len(points)} points\")\n                \n                elif hasattr(geom, 'Vertices'):\n                    # It's a mesh\n                    print(f\"  üìê Mesh with {len(geom.Vertices)} vertices\")\n                    # Extract mesh edges as wireframe\n                    mesh_curves = extract_mesh_edges(geom)\n                    # Add layer info to mesh curves\n                    for curve in mesh_curves:\n                        all_curves_with_layers.append((curve, layer_name))\n                    print(f\"  ‚úÖ Extracted {len(mesh_curves)} mesh edge curves\")\n                \n            except Exception as e:\n                print(f\"  ‚ùå Error processing object {i}: {e}\")\n                continue\n        \n        if len(all_curves_with_layers) > 0:\n            print(f\"üéâ Successfully extracted {len(all_curves_with_layers)} curves from target layers\")\n            return all_curves_with_layers\n        else:\n            print(\"‚ùå No curves could be extracted from target layers\")\n            print(\"üí° This could mean:\")\n            print(\"   - Layer names don't match exactly\")\n            print(\"   - Objects don't have extractable geometry\")\n            print(\"   - API calls are failing\")\n            return None\n            \n    except ImportError:\n        print(\"‚ùå rhino3dm library not available\")\n        return None\n    except Exception as e:\n        print(\"‚ùå Error reading 3DM file: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n\ndef extract_mesh_edges(mesh):\n    \"\"\"Extract edge curves from mesh\"\"\"\n    curves = []\n    try:\n        if hasattr(mesh, 'Faces') and hasattr(mesh, 'Vertices'):\n            # Simple approach: extract face boundaries\n            for face in mesh.Faces:\n                if hasattr(face, 'IsQuad') and face.IsQuad:\n                    # Quad face\n                    indices = [face.A, face.B, face.C, face.D, face.A]  # Close the loop\n                else:\n                    # Triangle face\n                    indices = [face.A, face.B, face.C, face.A]  # Close the loop\n                \n                points = []\n                for idx in indices:\n                    if idx < len(mesh.Vertices):\n                        v = mesh.Vertices[idx]\n                        points.append([v.X, v.Y, v.Z])\n                \n                if len(points) > 1:\n                    curves.append(points)\n                    \n    except Exception as e:\n        print(f\"    ‚ùå Error extracting mesh edges: {e}\")\n        \n    return curves\n\ndef calculate_bounds(wireframe_lines_with_layers):\n    \"\"\"Calculate bounding box from wireframe curves with layer info\"\"\"\n    all_points = []\n    for line_data in wireframe_lines_with_layers:\n        if isinstance(line_data, tuple):\n            line, layer_name = line_data\n        else:\n            # Backward compatibility\n            line = line_data\n        all_points.extend(line)\n    \n    if not all_points:\n        return (-35, -35, -12, 35, 35, 12)  # Default bounds\n    \n    points_array = np.array(all_points)\n    padding = 5  # Add some padding\n    \n    return (\n        points_array[:, 0].min() - padding, \n        points_array[:, 1].min() - padding, \n        points_array[:, 2].min() - padding,\n        points_array[:, 0].max() + padding, \n        points_array[:, 1].max() + padding, \n        points_array[:, 2].max() + padding\n    )\n\ndef create_wireframe_view(wireframe_lines_with_layers, view_name, bounds, output_dir='images'):\n    \"\"\"Create CAD-style wireframe view with layer colors\"\"\"\n    print(f\"üñºÔ∏è  Creating {view_name} view with {len(wireframe_lines_with_layers)} curves...\")\n    \n    min_x, min_y, min_z, max_x, max_y, max_z = bounds\n    \n    # Define colors for each layer\n    layer_colors = {\n        'Costilla': '#2E86AB',    # Professional blue\n        'Vertebra': '#A23B72',    # Deep magenta/red\n        'Vias': '#F18F01'        # Professional orange\n    }\n    \n    # Create figure\n    fig, ax = plt.subplots(figsize=(10, 7.5), dpi=150)\n    ax.set_facecolor('white')\n    \n    # Plot each wireframe curve with layer-specific color\n    for line_data in wireframe_lines_with_layers:\n        if isinstance(line_data, tuple):\n            line, layer_name = line_data\n            color = layer_colors.get(layer_name, '#333333')  # Default gray\n        else:\n            # Backward compatibility for old format\n            line = line_data\n            color = '#333333'\n            \n        if len(line) < 2:\n            continue\n            \n        line_array = np.array(line)\n        \n        # Project onto appropriate plane\n        if view_name == 'top':\n            x, y = line_array[:, 0], line_array[:, 1]\n            ax.plot(x, y, color=color, linewidth=1.2, alpha=0.85)\n            \n        elif view_name == 'front':\n            x, y = line_array[:, 0], line_array[:, 2]\n            ax.plot(x, y, color=color, linewidth=1.2, alpha=0.85)\n            \n        elif view_name == 'right':\n            x, y = line_array[:, 1], line_array[:, 2]\n            ax.plot(x, y, color=color, linewidth=1.2, alpha=0.85)\n            \n        elif view_name == 'isometric':\n            # Isometric projection with clean wireframes and depth styling\n            iso_x = line_array[:, 0] - line_array[:, 1] * 0.5\n            iso_y = line_array[:, 2] + (line_array[:, 0] + line_array[:, 1]) * 0.25\n\n            # Calculate depth for clean wireframe styling\n            depth = line_array[:, 2] + line_array[:, 1] * 0.3\n            depth_normalized = (depth - np.min(depth)) / (np.max(depth) - np.min(depth) + 1e-10)\n\n            # Varying line width and alpha based on depth for clean 3D effect\n            base_alpha = 0.9\n            depth_alpha = base_alpha - depth_normalized * 0.3  # Front lines more opaque\n            avg_alpha = np.mean(depth_alpha)\n\n            base_width = 1.0\n            depth_width = base_width + (1 - depth_normalized) * 0.5  # Front lines thicker\n            avg_width = np.mean(depth_width)\n\n            ax.plot(iso_x, iso_y, color=color, linewidth=avg_width, alpha=avg_alpha)\n    \n    # Technical CAD-style wireframe views with layer colors\n    \n    # Set view-specific properties with grids and axes (no titles)\n    if view_name == 'top':\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_y, max_y)\n        ax.set_xlabel('X', fontsize=12, fontweight='bold')\n        ax.set_ylabel('Y', fontsize=12, fontweight='bold')\n        \n    elif view_name == 'front':\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_z, max_z)\n        ax.set_xlabel('X', fontsize=12, fontweight='bold')\n        ax.set_ylabel('Z', fontsize=12, fontweight='bold')\n        \n    elif view_name == 'right':\n        ax.set_xlim(min_y, max_y)\n        ax.set_ylim(min_z, max_z)\n        ax.set_xlabel('Y', fontsize=12, fontweight='bold')\n        ax.set_ylabel('Z', fontsize=12, fontweight='bold')\n        \n    elif view_name == 'isometric':\n        # Calculate bounds for isometric view with more padding (zoom out)\n        iso_bounds_x = []\n        iso_bounds_y = []\n        for line_data in wireframe_lines_with_layers:\n            if isinstance(line_data, tuple):\n                line, layer_name = line_data\n            else:\n                line = line_data\n            if len(line) >= 2:\n                line_array = np.array(line)\n                iso_x = line_array[:, 0] - line_array[:, 1] * 0.5\n                iso_y = line_array[:, 2] + (line_array[:, 0] + line_array[:, 1]) * 0.25\n                iso_bounds_x.extend(iso_x)\n                iso_bounds_y.extend(iso_y)\n        \n        if iso_bounds_x and iso_bounds_y:\n            padding = 25  # Increased padding for zoom out effect\n            ax.set_xlim(min(iso_bounds_x) - padding, max(iso_bounds_x) + padding)\n            ax.set_ylim(min(iso_bounds_y) - padding, max(iso_bounds_y) + padding)\n        \n        ax.set_xlabel('X-Y', fontsize=12, fontweight='bold')\n        ax.set_ylabel('Z+(X+Y)/4', fontsize=12, fontweight='bold')\n    \n    # Professional CAD-style appearance\n    ax.set_aspect('equal', adjustable='box')\n    \n    # Add grid and centerlines for technical drawings\n    ax.grid(True, alpha=0.3, linewidth=0.5, color='gray')\n    \n    # Add centerlines for all views except isometric\n    if view_name != 'isometric':\n        ax.axhline(0, color='red', linestyle='--', alpha=0.4, linewidth=1)\n        ax.axvline(0, color='red', linestyle='--', alpha=0.4, linewidth=1)\n    \n    # Professional axis styling\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_color('gray')\n    ax.spines['bottom'].set_color('gray')\n    \n    # Save\n    os.makedirs(output_dir, exist_ok=True)\n    output_path = os.path.join(output_dir, f'{view_name}.png')\n    plt.tight_layout()\n    plt.savefig(output_path, dpi=150, bbox_inches='tight', \n               facecolor='white', edgecolor='none', format='png')\n    plt.close()\n    print(f\"‚úÖ Saved {view_name} view to {output_path}\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Generate 3D views from Rhino 3DM files')\n    parser.add_argument('--input', '-i', help='Input 3DM file path')\n    parser.add_argument('--output', '-o', default='images', help='Output directory for images')\n    parser.add_argument('--debug', action='store_true', help='Enable debug output')\n    \n    args = parser.parse_args()\n    \n    print(\"üöÄ Starting 3D view generation...\")\n    \n    # Find 3DM file\n    if args.input:\n        model_file = args.input\n        if not os.path.exists(model_file):\n            print(f\"‚ùå Input file not found: {model_file}\")\n            return False\n    else:\n        model_file = find_3dm_file()\n        if not model_file:\n            print(\"‚ùå No .3dm file found in current directory\")\n            return False\n    \n    print(f\"üìÅ Using 3DM file: {model_file}\")\n    \n    # Extract geometry from specific layers only\n    wireframe_lines = extract_actual_geometry_from_3dm(model_file)\n    \n    # Fail if no geometry was extracted\n    if wireframe_lines is None or len(wireframe_lines) == 0:\n        print(\"üí• FAILED: No geometry could be extracted from the 3DM file\")\n        print(\"üîç Check:\")\n        print(\"   1. Layer names match exactly: 'Costilla' 'Vertebra' and 'Vias'\")\n        print(\"   2. Objects on those layers have valid geometry\")\n        print(\"   3. rhino3dm library can access the geometry\")\n        return False\n    \n    # Calculate bounds\n    bounds = calculate_bounds(wireframe_lines)\n    print(f\"üìè Geometry bounds: {bounds}\")\n    \n    # Generate views\n    views = ['top', 'front', 'right', 'isometric']\n    for view in views:\n        create_wireframe_view(wireframe_lines, view, bounds, args.output)\n    \n    print(\"üéâ All views generated successfully from real geometry!\")\n    return True\n\nif __name__ == \"__main__\":\n    try:\n        success = main()\n        sys.exit(0 if success else 1)\n    except Exception as e:\n        print(f\"üí• Fatal error: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1) ",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}