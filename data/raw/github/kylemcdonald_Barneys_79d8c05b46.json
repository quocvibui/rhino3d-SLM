{
  "source_url": "https://github.com/kylemcdonald/Barneys/blob/8e1f48b60c3ca0c5459db657a110c4a72d4d6c69/rhino/Centerpiece.py",
  "repo": "kylemcdonald/Barneys",
  "repo_stars": 11,
  "repo_description": "Work on a custom 4m sculpture designed to scatter light in every direction.",
  "license": "NOASSERTION",
  "filepath": "rhino/Centerpiece.py",
  "instruction": "Centerpiece",
  "code": "import rhinoscriptsyntax as rs\nimport random\nimport math\n\ndef rand(min, max):\n\treturn random.uniform(min, max)\n\ndef lerp(a, b, t):\n\treturn a * (1 - t) + (b * t)\n\ndef map(x, inmin, inmax, outmin, outmax):\n\tif inmin == inmax:\n\t\treturn outmax\n\telse:\n\t\treturn ((x - inmin) / (inmax - inmin)) * (outmax - outmin) + outmin\n\ncomplete = True\nlayerHeight = 2.95\n\nbuildScaffolding = False\nscaffoldSide = .75\n\nplacement = (0, 0)#(60/3, 35/3)\nicicleCount = 1#int(rand(6, 20))\nlayerRange = (15, 15)#(60,40)#(60, rand(10, 50))\nmaxScaleRange = (60, 60)#(10,20)#(rand(10, 15), rand(10, 35)) # (10, 20)\nminScale = 0.8#rand(0, .9) # 0\nouterReduce = .09#rand(.01, .06) # .03\nwiggle = .04#rand(.01, .1) # .05\nsmoothAmount = .3#rand(.1, .9) # .1\ncount = 60#int(rand(30, 120)) # 60\n\ndownwards = True\ndownwardsLayers = 25\ndownwardsReduce = .06\n\nhollow = False\nshrinkPasses = 5\ninnerReduce = .04\n\ndef smooth(x, amount):\n\tfor i in range(len(x)):\n\t\tnext = x[(i + 1) % count]\n\t\tprevious = x[(i - 1 + count) % count]\n\t\tcur = x[i]\n\t\ttarget = (next + previous) / 2\n\t\tx[i] = lerp(cur, target, smoothAmount)\n\ndef shrink(x, reduce):\n\tfor i in range(len(x)):\n\t\tx[i] *= random.uniform(1 - reduce, 1)\n\t\tx[i] = max(x[i], 0)\n\ndef scale(x, amount):\n\tfor i in range(len(x)):\n\t\tx[i] *= amount\n\ndef upwardsShaping(x):\n\treturn 1 - math.pow(x * .5, 2)\n\t# return 1 - ((1 - math.cos(x * math.pi)) / 2) * .15\n\ndef downwardsShaping(x):\n\treturn 1 - math.pow(x * .9, 8)\n\ndef piece(layers, maxScale):\n\tcurves = []\n\tinitialRadii = []\n\tresults = []\n\tfor i in range(count):\n\t\tinitialRadii.append(random.uniform(minScale * maxScale, maxScale))\n\n\t# outerExtrusions\n\touterExtrusions = []\n\tradii = initialRadii[:]\n\tfor layer in range(layers):\n\t\theight = layer * layerHeight\n\t\tsmooth(radii, smoothAmount)\n\t\tshrink(radii, outerReduce)\n\t\tscale(radii, random.uniform(1 - wiggle, 1 + wiggle))\n\t\tscale(radii, upwardsShaping(layer / (layers - 1)))\n\t\tvertices = []\n\t\tfor i in range(count):\n\t\t\ttheta = 2 * math.pi * i / count\n\t\t\tvertices.append((math.sin(theta) * radii[i], math.cos(theta) * radii[i], height))\n\t\tvertices.append(vertices[0])\n\t\tcurve = rs.AddCurve(vertices, 5)\n\t\tcurves.append(curve)\n\t\tif complete:\n\t\t\textrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, layerHeight))\n\t\t\trs.CapPlanarHoles(extrusion)\n\t\t\touterExtrusions.append(extrusion)\n\t\t\tif not hollow:\n\t\t\t\tresults.append(extrusion)\n\n\tif hollow:\n\t\tfor i in range(shrinkPasses):\n\t\t\tshrink(radii, innerReduce)\n\n\t\t# innerExtrusions\n\t\tfor layer in range(layers):\n\t\t\tactualLayer = layers - layer - 1\n\t\t\theight = actualLayer * layerHeight\n\t\t\tsmooth(radii, smoothAmount)\n\t\t\tshrink(radii, innerReduce)\n\t\t\tvertices = []\n\t\t\tfor i in range(count):\n\t\t\t\ttheta = 2 * math.pi * i / count\n\t\t\t\tvertices.append((math.sin(theta) * radii[i], math.cos(theta) * radii[i], height))\n\t\t\tvertices.append(vertices[0])\n\t\t\tcurve = rs.AddCurve(vertices, 5)\n\t\t\tcurves.append(curve)\n\t\t\tif complete:\n\t\t\t\textrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, layerHeight))\n\t\t\t\trs.CapPlanarHoles(extrusion)\n\t\t\t\tresult = rs.BooleanDifference(outerExtrusions[actualLayer], extrusion)\n\t\t\t\tresults.append(result)\n\t\n\tif downwards:\n\t\tradii = initialRadii[:]\n\t\tfor layer in range(downwardsLayers):\n\t\t\theight = -(layer + 1) * layerHeight\n\t\t\tsmooth(radii, smoothAmount)\n\t\t\tshrink(radii, downwardsReduce)\n\t\t\tscale(radii, random.uniform(1 - wiggle, 1 + wiggle))\n\t\t\tscale(radii, downwardsShaping(layer / (downwardsLayers - 1)))\n\t\t\tvertices = []\n\t\t\tfor i in range(count):\n\t\t\t\ttheta = 2 * math.pi * i / count\n\t\t\t\tvertices.append((math.sin(theta) * radii[i], math.cos(theta) * radii[i], height))\n\t\t\tvertices.append(vertices[0])\n\t\t\tcurve = rs.AddCurve(vertices, 5)\n\t\t\tcurves.append(curve)\n\t\t\tif complete:\n\t\t\t\textrusion = rs.ExtrudeCurveStraight(curve, (0, 0, 0), (0, 0, layerHeight))\n\t\t\t\trs.CapPlanarHoles(extrusion)\n\t\t\t\touterExtrusions.append(extrusion)\n\t\t\t\tif not hollow:\n\t\t\t\t\tresults.append(extrusion)\n\n\tif buildScaffolding:\n\t\tscaffoldBase = rs.AddRectangle((-scaffoldSide/2, -scaffoldSide/2, 0), scaffoldSide, scaffoldSide)\n\t\tscaffold = rs.ExtrudeCurveStraight(scaffoldBase, (0, 0, 0), (0, 0, (layers - 1) * layerHeight))\n\t\trs.CapPlanarHoles(scaffold)\n\t\trs.DeleteObject(scaffoldBase)\n\t\tresults.append(scaffold)\n\n\tif complete:\n\t\trs.DeleteObjects(curves)\n\t\trs.AddObjectsToGroup(results, rs.AddGroup())\n\t\treturn results\n\telse:\n\t\trs.AddObjectsToGroup(curves, rs.AddGroup())\n\t\treturn curves\n\nfor i in range(icicleCount):\n\ttranslation = (random.gauss(0, placement[0]), random.gauss(0, placement[1]), 0)\n\tdistance = rs.VectorLength(translation)\n\tlayers = int(map(distance, 0, placement[0], layerRange[0], layerRange[1]))\n\tmaxScale = map(i, 0, placement[0], maxScaleRange[0], maxScaleRange[1])\n\tobjects = piece(layers, maxScale)\n\trs.MoveObject(objects, translation)\n\t# rs.RotateObject(objects, (0, 0, 0), 60 * i)",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}