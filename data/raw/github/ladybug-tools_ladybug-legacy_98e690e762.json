{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Sunlight%20Hours%20Analysis.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Sunlight Hours Analysis.py",
  "instruction": "This component calculates the number of hours of direct sunlight received by input geometry using sun vectors from the sunPath component.\r\nThis component can be used to evaluate the number of hours...",
  "code": "# This script used to be ladybug all in one\r\n# I separated them into three parts before distribution which made it such a mess\r\n#\r\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\r\n# \r\n# This file is part of Ladybug.\r\n# \r\n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \r\n# Ladybug is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# Ladybug is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# You should have received a copy of the GNU General Public License\r\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n\r\n\r\n\"\"\"\r\nThis component calculates the number of hours of direct sunlight received by input geometry using sun vectors from the sunPath component.\r\nThis component can be used to evaluate the number of hours of sunlight received by vegetation in a park or the hours where direct sunlight might make a certain outdoor space comfortable or uncomfortable.\r\nIt can also be used for coarsely-gridded shadow studies in the Rhino scene .  For finer and more detailed shadow studies with simple input geometry, the Ladybug ShadowStudy component can be used.  For detailed shadow studies with complex geometry, the Honeybee daylight tools are recommended.\r\n\r\n-\r\nProvided by Ladybug 0.0.69\r\n    \r\n    Args:\r\n        north_: Input a vector to be used as a true North direction for the sun path or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees). In case you have provided rotation value for the North in the Sunpath component, there's no need to provide the same rotation value here. Doing this will give you erroneous results.\r\n        _geometry: Geometry for which sunlight hours analysis will be conducted.  Geometry must be either a Brep, a Mesh or a list of Breps or Meshes.\r\n        context_: Context geometry that could block sunlight to the test _geometry.  Conext geometry must be either a Brep, a Mesh or a list of Breps or Meshes.\r\n        _gridSize_: A number in Rhino model units that represents the average size of a grid cell for sunlight hours analysis on the test _geometry.  This value should be smaller than the smallest dimension of the test _geometry for meaningful results.  Note that, the smaller the grid size, the higher the resolution of the analysis and the longer the calculation will take.\r\n        _disFromBase: A number in Rhino model units that represents the offset distance of the test point grid from the input test _geometry.  Usually, the test point grid is offset by a small amount from the test _geometry in order to ensure that sunlight hours analysis is done for the correct side of the test _geometry.  If the resulting testPts of this component are offset to the wrong side of test _geometry, you should use the \"Flip\" Rhino command on the test _geometry before inputting it to this component.\r\n        orientationStudyP_: Optional output from the \"Orientation Study Parameter\" component.\r\n        _sunVectors: Sun vectors from the sunPath component, which will be used to determine the number of hours of direct sunlight received by the test _geometry.\r\n        _timeStep_: The number of timesteps per hour used by the sunPath component that generated the sun vectors. This number should be smaller than 60 and divisible by 60. The default is set to 1 such that one ssun vector is generated for each hour.\r\n        ___________________: ...\r\n        legendPar_: Optional output from the \"Orientation Study Parameter\" component.  You can use an Orientation Study input here to answer questions like \"What orientation of my building will give me the highest or lowest hours of direct sunlight for my analysis period?\"  An Orientation Study will automatically rotate your input _geometry around several times and record the sunlight hours results each time in order to output a list of values for totalSunlightHours and a grafted data stream for sunlightHoursResult.\r\n        parallel_: Set to \"True\" to run the sunlight hours analysis using multiple CPUs.  This can dramatically decrease calculation time but can interfere with other intense computational processes that might be running on your machine.\r\n        _runIt: Set to \"True\" to run the component and perform sunlight hours analysis on the input _geometry.\r\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\r\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\r\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \r\n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\r\n        workingDir_: Use this input to change the working directory of the sunlight hours analysis on your system. Input here must be a valid file path location on your computer.  The default is set to \"C:\\Ladybug\" and it is from this file location that sunlight hours results are loaded into grasshopper after the analysis is done.\r\n        projectName_: Use this input to change the project name of the files generated in the working directory.  Input here must be a string without special characters.  If \"bakeIt_\" is set to \"True\", the result will be baked into a layer with this project name.\r\n    Returns:\r\n        readMe!: ...\r\n        contextMesh: An uncolored mesh representing the context_ geometry that was input to this component. Connect this output to a \"Mesh\" grasshopper component to preview this output seperately from the others of this component. Note that this mesh is generated before the analysis is run, allowing you to be sure that the right geometry will be run through the analysis before running this component.\r\n        analysisMesh: An uncolored mesh representing the test _geometry that will be analyzed.  Connect this output to a \"Mesh\" grasshopper component to preview this output seperately from the others of this component. Note that this mesh is generated before the analysis is run, allowing you to be sure that the right geometry will be run through the analysis before running this component.\r\n        testPts: The grid of test points on the test _geometry that will be used to perform the sunlight hours analysis.  Note that these points are generated before the analysis is run, allowing you to preview the resolution of the result before you run the component.\r\n        testVec: Vectors for each of the test points on the test _geometry, which indicate the direction for which sunlight hours analysis is performed.  Hook this and the test points up to a Grasshopper \"Vector Display\" component to see how analysis is performed on the test _geometry.\r\n        _____________________: ...\r\n        sunlightHoursResult: The number of hours of direct sunlight received by each of the test points of the input test _geometry.  Note that is is the number of hours out of the total number of connected _sunVectors.\r\n        sunlightHoursMesh: A colored mesh of the test _geometry representing the hours of direct sunlight received by this input _geometry for the input sunVectors.\r\n        sunlightHoursLegend: A legend for the sunlight hours study showing the number of hours that correspond to the colors of the sunlightHoursMesh. Connect this output to a grasshopper \"Geo\" component in order to preview the legend separately in the Rhino scene.  \r\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the sunlight hours mesh with the grasshopper \"move\" component.\r\n        totalSunlightHours: The average number of hours of direct sunlight received by the test _geometry.\r\n        sunIsVisible: A grafted data stream for each test point with a \"1\" for each hour of the sunVectors that the sun is visible and a \"0\" for each hour of the sunVectors when the sun is blocked.\r\n\"\"\"\r\n\r\nghenv.Component.Name = \"Ladybug_Sunlight Hours Analysis\"\r\nghenv.Component.NickName = 'sunlightHoursAnalysis'\r\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\nghenv.Component.Category = \"LB-Legacy\"\r\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\r\n#compatibleLBVersion = VER 0.0.59\\nJAN_24_2016\r\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\r\nexcept: pass\r\n\r\n\r\nimport rhinoscriptsyntax as rs\r\nfrom clr import AddReference\r\nAddReference('Grasshopper')\r\nimport Grasshopper.Kernel as gh\r\nimport math\r\nimport Rhino as rc\r\nimport sys\r\nimport scriptcontext as sc\r\nimport System.Threading.Tasks as tasks\r\nimport System\r\nimport time\r\nfrom Grasshopper import DataTree\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\n\r\nif len(_sunVectors)!=0: sunVectors_sunlightHour = _sunVectors\r\nelse: sunVectors_sunlightHour = []\r\n\r\ndef main(north, geometry, context, gridSize, disFromBase, orientationStudyP,\r\n                    sunVectors_sunlightHour, timeStep, legendPar, parallel, bakeIt,\r\n                    workingDir, projectName):\r\n    # import the classes\r\n    if sc.sticky.has_key('ladybug_release'):\r\n        try:\r\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\r\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\r\n        except:\r\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\r\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\r\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\r\n            \"into canvas and try again.\"\r\n            w = gh.GH_RuntimeMessageLevel.Warning\r\n            ghenv.Component.AddRuntimeMessage(w, warning)\r\n            return -1\r\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\r\n        lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\r\n        lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\r\n        lb_runStudy_RAD = sc.sticky[\"ladybug_Export2Radiance\"]()\r\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\r\n        \r\n    else:\r\n        print \"You should first let the Ladybug fly...\"\r\n        w = gh.GH_RuntimeMessageLevel.Warning\r\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\r\n        return -1\r\n    \r\n    conversionFac = lb_preparation.checkUnits()\r\n    \r\n    # north direction\r\n    northAngle, northVector = lb_preparation.angle2north(north)\r\n    \r\n    # read orientation study parameters\r\n    runOrientation, rotateContext, rotationBasePt, angles = lb_preparation.readOrientationParameters(orientationStudyP)\r\n    \r\n    # mesh the test buildings\r\n    if (len(geometry)!=0 and disFromBase):\r\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\r\n        analysisMesh, analysisBrep = lb_preparation.cleanAndCoerceList(geometry)\r\n        \r\n        #if len(analysisBrep)!=0 and gridSize == None: return -1\r\n        \r\n        if gridSize == None:\r\n            gridSize = 4/conversionFac\r\n            originalTestPoints = []\r\n            \r\n        \r\n        ## mesh Brep\r\n        analysisMeshedBrep = lb_mesh.parallel_makeSurfaceMesh(analysisBrep, float(gridSize))\r\n        \r\n        ## Flatten the list of surfaces\r\n        analysisMeshedBrep = lb_preparation.flattenList(analysisMeshedBrep)\r\n        analysisSrfs = analysisMesh + analysisMeshedBrep\r\n        \r\n        ## extract test points\r\n        #if not testPts or testPts[0] == None:\r\n        testPoints, ptsNormals, meshSrfAreas = lb_mesh.parallel_testPointCalculator(analysisSrfs, float(disFromBase), parallel)\r\n        originalTestPoints = testPoints\r\n        testPoints = lb_preparation.flattenList(testPoints)\r\n        ptsNormals = lb_preparation.flattenList(ptsNormals)\r\n        meshSrfAreas = lb_preparation.flattenList(meshSrfAreas)\r\n        #else:\r\n        #    testPoints = testPts\r\n        #    if not len(testVec)==0:\r\n        #        print 'this is a place holder...'\r\n    else:\r\n        print \"Please connect the geometry and set up both the gridSize and the distance from base surface...\"\r\n        analysisSrfs = testPoints = ptsNormals = meshSrfAreas = []\r\n        return -1, -1, -1\r\n    \r\n    ## mesh context\r\n    if len(context)!=0 and gridSize and disFromBase:\r\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\r\n        contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(context)\r\n        \r\n        ## mesh Brep\r\n        contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\r\n        \r\n        ## Flatten the list of surfaces\r\n        contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\r\n        contextSrfs = contextMesh + contextMeshedBrep\r\n    else: contextSrfs = []\r\n\r\n\r\n    def runAnalyses(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs, parallel, cumSky_radiationStudy, viewPoints_viewStudy, viewFields_Angles_D, sunVectors_sunlightHour, conversionFac):\r\n        RADIANCE_radiationStudy =[]\r\n        if len(RADIANCE_radiationStudy)!=0:\r\n            pass\r\n        elif cumSky_radiationStudy != None and len(cumSky_radiationStudy) == 146:\r\n            radResults, totalRadResults = lb_runStudy_GH.parallel_radCalculator(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs,\r\n                                        parallel, cumSky_radiationStudy, lb_preparation.TregenzaPatchesNormalVectors, conversionFac, 2200000000000000, northVector)\r\n        else:\r\n            #print \"No radiation study!\"\r\n            radResults = totalRadResults = None\r\n        \r\n        if len(viewPoints_viewStudy)!= 0:\r\n            viewResults, totalViewResults = lb_runStudy_GH.parallel_viewCalculator(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs, parallel, viewPoints_viewStudy, viewFields_Angles_D, conversionFac)\r\n        else:\r\n            #print \"No view study!\"\r\n            viewResults = totalViewResults = None\r\n    \r\n        if len(sunVectors_sunlightHour)!= 0:\r\n            listInfo = ['key:location/dataType/units/frequency/startsAt/endsAt', 'City/Latitude', 'Sunlight Hours', 'Hour', 'NA', (1, 1, 1), (12, 31, 24)]\r\n            if parallel:\r\n                try:\r\n                    for geo in analysisSrfs + contextSrfs: geo.EnsurePrivateCopy()\r\n                except:\r\n                    pass\r\n            \r\n            # join the meshes\r\n            joinedAnalysisMesh = lb_mesh.joinMesh(analysisSrfs)\r\n            if contextSrfs: joinedContext = lb_mesh.joinMesh(contextSrfs)\r\n            else: joinedContext = None\r\n\r\n            hoursResults, totalHoursResults, sunVisibility = lb_runStudy_GH.parallel_sunlightHoursCalculator(testPoints, ptsNormals, meshSrfAreas, joinedAnalysisMesh, joinedContext,\r\n                                            parallel, sunVectors_sunlightHour, conversionFac, northVector, timeStep)\r\n        else:\r\n            print \"Sun vectors should be provided... No sunlight hours study!\"\r\n            hoursResults = totalHoursResults = None\r\n            return [contextSrfs, analysisSrfs, testPoints, ptsNormals], -1, -1, -1\r\n        \r\n        #results = range(len(testPoints))\r\n        results = radResults, hoursResults, viewResults\r\n        totalResults = totalRadResults, totalHoursResults, totalViewResults\r\n        \r\n        return results, totalResults, listInfo, sunVisibility\r\n    \r\n    def resultVisualization(contextSrfs, analysisSrfs, results, totalResults, legendPar, legendTitle, studyLayerName, bakeIt, checkTheName, l, angle, listInfo):\r\n        \r\n        lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\r\n        if len(legendPar_) == 0: customColors = lb_visualization.gradientLibrary[6]\r\n        elif legendPar_[3] == []: customColors = lb_visualization.gradientLibrary[6]\r\n        \r\n        colors = lb_visualization.gradientColor(results, lowB, highB, customColors)\r\n        \r\n        # color mesh surfaces\r\n        analysisSrfs = lb_visualization.colorMesh(colors, analysisSrfs)\r\n        \r\n        ## generate legend\r\n        # calculate the boundingbox to find the legendPosition\r\n        if not (runOrientation and legendBasePoint==None):\r\n            lb_visualization.calculateBB([analysisSrfs, contextSrfs])\r\n        # legend geometry\r\n        legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(results, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\r\n        \r\n        # legend colors\r\n        legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\r\n        # color legend surfaces\r\n        legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\r\n        \r\n        customHeading = '\\n\\nSunlightHours Analysis'\r\n        if runOrientation:\r\n            try: customHeading = customHeading + '\\nRotation Angle: ' + `angle` + ' Degrees'\r\n            except: pass\r\n        titleTextCurve, titleStr, titlebasePt = lb_visualization.createTitle([listInfo], lb_visualization.BoundingBoxPar, legendScale, customHeading, True, legendFont, legendFontSize, legendBold)\r\n        \r\n        # calculate the boundingbox to find the legendPosition\r\n        if not (runOrientation and legendBasePoint==None):\r\n            if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\r\n        \r\n        if bakeIt:\r\n            legendText.append(titleStr)\r\n            textPt.append(titlebasePt)\r\n            # check the study type\r\n            newLayerIndex, l = lb_visualization.setupLayers(totalResults, 'LADYBUG', projectName,\r\n                                                            studyLayerName, checkTheName,\r\n                                                            runOrientation, angle, l)\r\n            if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, analysisSrfs, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, True)\r\n            else: lb_visualization.bakeObjects(newLayerIndex, analysisSrfs, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, False)\r\n        \r\n        return analysisSrfs, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], l, legendBasePoint\r\n\r\n\r\n    ## data for visualization\r\n    legendTitles = ['kWh/m2', 'Hours', '%']\r\n    studyLayerNames = ['RADIATION_STUDIES', 'SUNLIGHTHOURS_STUDIES', 'VIEW_STUDIES']\r\n    CheckTheName = True\r\n    resV = 0 # Result visualization\r\n    ## check for orientation Study\r\n    l = [0, 0, 0] # layer name indicator\r\n    if runOrientation and len(sunVectors_sunlightHour)!= 0:\r\n        if not isinstance(rotateContext, System.Boolean):\r\n            #inputs are geometries and should be set as the context to be rotated\r\n            rContextMesh, rContextBrep = rotateContext\r\n            \r\n            ## mesh Brep\r\n            rContextMeshedBrep = lb_mesh.parallel_makeContextMesh(rContextBrep)\r\n            \r\n            ## Flatten the list of surfaces\r\n            rContextMeshedBrep = lb_preparation.flattenList(rContextMeshedBrep)\r\n            rContextSrfs = rContextMesh + rContextMeshedBrep\r\n            rotateContext = \"Partial\"\r\n        elif rotateContext == True:\r\n            rContextSrfs = contextSrfs\r\n        else:\r\n            rContextSrfs = None\r\n            \r\n        # create rotation base point\r\n        if rotationBasePt == 'set2center'and rotateContext==\"Partial\":\r\n            # find the bounding box for the test geometry and context\r\n            lb_visualization.calculateBB([analysisSrfs, rContextSrfs])\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n        elif rotationBasePt == 'set2center'and rotateContext:\r\n            # find the bounding box for the test geometry and context\r\n            lb_visualization.calculateBB([analysisSrfs, rContextSrfs])\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n        elif rotationBasePt == 'set2center'and not rotateContext:\r\n            lb_visualization.calculateBB(analysisSrfs)\r\n            rotationBasePt = rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[4])\r\n            # this is stupid and should be fixed later but for now I let it be!\r\n            lb_visualization.calculateBB([analysisSrfs, contextSrfs])\r\n            \r\n        # total result is a list of lists\r\n        orirntationStudyRes = {}\r\n        totalResults = []\r\n        angleCount = 0\r\n        for angle in range(len(angles) - 1):\r\n            rotationT = (rc.Geometry.Transform.Rotation(math.radians(angles[angle + 1] - angles[angle]) , rc.Geometry.Vector3d.ZAxis, rotationBasePt))\r\n            # rotate the geometry, and points (and maybe the context)\r\n            # print angles[angle + 1] - angles[angle] # there is a bug here!\r\n            [srf.Transform(rotationT) for srf in analysisSrfs]\r\n            [p.Transform(rotationT) for p in testPoints]\r\n            [n.Transform(rotationT) for n in  ptsNormals]\r\n            if rotateContext == \"Partial\":\r\n                [msh.Transform(rotationT) for msh in rContextSrfs]\r\n                # put the rotated mesh next to the rest of the context\r\n                mergedContextSrfs = rContextSrfs + contextSrfs\r\n            elif rotateContext:\r\n                [msh.Transform(rotationT) for msh in rContextSrfs]\r\n                mergedContextSrfs = rContextSrfs\r\n            else:\r\n                mergedContextSrfs = contextSrfs\r\n            \r\n            cumSky_radiationStudy = [];\r\n            viewPoints_viewStudy = [];\r\n            viewFields_Angles_D = [];\r\n            ## run the analysis\r\n            \r\n            results, eachTotalResult, listInfo, sunVisibility = runAnalyses(testPoints, ptsNormals, meshSrfAreas,\r\n                                        analysisSrfs, mergedContextSrfs, parallel, cumSky_radiationStudy,\r\n                                        viewPoints_viewStudy, viewFields_Angles_D,\r\n                                        sunVectors_sunlightHour, conversionFac)\r\n            \r\n            #collect surfaces, results, and values\r\n            orirntationStudyRes[angle] = {\"angle\" : angle,\r\n                                          \"totalResult\": eachTotalResult,\r\n                                          \"results\": results,\r\n                                          \"listInfo\": listInfo,\r\n                                          \"contextSrf\" : lb_mesh.joinMesh(mergedContextSrfs),\r\n                                          \"analysisSrf\": lb_mesh.joinMesh(analysisSrfs)\r\n                                          }\r\n            \r\n            totalResults.append(eachTotalResult)\r\n            angleCount += 1\r\n            \r\n        if legendPar== [] or (legendPar[0] == None and legendPar[1] == None):\r\n            # find max and min for the legend\r\n            minValue = float(\"inf\") \r\n            maxValue = 0\r\n            allBuildingsAndContext = []\r\n            for key in orirntationStudyRes.keys():\r\n                # results is a nested list because the component used to be all in one\r\n                # I should re-write this component at some point\r\n                listMin = min(orirntationStudyRes[key][\"results\"][1])\r\n                listMax = max(orirntationStudyRes[key][\"results\"][1])\r\n                if  listMin < minValue: minValue = listMin\r\n                if  listMax > maxValue: maxValue = listMax\r\n                \r\n                if legendPar== [] or legendPar[4] == None:\r\n                    allBuildingsAndContext.extend([orirntationStudyRes[key][\"analysisSrf\"], orirntationStudyRes[key][\"contextSrf\"]])\r\n            \r\n            # find the collective bounding box\r\n            if legendPar== [] or legendPar[4] == None:\r\n                lb_visualization.calculateBB(allBuildingsAndContext)\r\n            \r\n            # preset the legend parameters if it is not set by the user\r\n            if legendPar== []:\r\n                legendPar = [minValue, maxValue, None, [], lb_visualization.BoundingBoxPar, 1, 'Verdana', None, False, 2, False]\r\n            else:\r\n                if legendPar[0] == None: legendPar[0] = minValue\r\n                if legendPar[1] == None: legendPar[1] = maxValue\r\n                if legendPar[4] == None: legendPar[4] = lb_visualization.BoundingBoxPar\r\n                if legendPar[5] == None or float(legendPar[5])==0: legendPar[5] = 1\r\n                if legendPar[6] == None: legendPar[6] = 'Verdana'\r\n                if legendPar[7] == None: legendPar[7] = None\r\n                if legendPar[8] == None: legendPar[8] = False\r\n                if legendPar[9] == None: legendPar[9] = 2\r\n                if legendPar[10] == None: legendPar[10] = False\r\n                \r\n        for angleCount, angle in enumerate(range(len(angles) - 1)):\r\n            if (bakeIt != 0 or angles[angle + 1] == angles[-1]) and results!=-1:\r\n                \r\n                # read the values for each angle from the dictionary\r\n                eachTotalResult = orirntationStudyRes[angle][\"totalResult\"]\r\n                mergedContextSrfs = orirntationStudyRes[angle][\"contextSrf\"]\r\n                analysisSrfs = orirntationStudyRes[angle][\"analysisSrf\"]\r\n                listInfo = orirntationStudyRes[angle][\"listInfo\"]\r\n                results = orirntationStudyRes[angle][\"results\"]\r\n                \r\n                \r\n                resultColored = [[] for x in range(len(results))]\r\n                legendColored = [[] for x in range(len(results))]\r\n                if angleCount > 0: CheckTheName = False\r\n                \r\n                for i in range(len(results)):\r\n                    if results[0]!=[] and results[i]!= None:\r\n                        # Add an option for orientation study\r\n                        # The i is a reminder from the time that all the analysis components was a single component\r\n                        # so confusing!\r\n                        resultColored[i], legendColored[i], l[i], legendBasePoint = resultVisualization(mergedContextSrfs, analysisSrfs,\r\n                                          results[i], eachTotalResult[i], legendPar, legendTitles[i],\r\n                                          studyLayerNames[i], bakeIt, CheckTheName, l[i], angles[angle + 1], listInfo)\r\n                        resV += 1\r\n            \r\n    else:\r\n        # no orientation study\r\n        angle = 0; l = [0, 0, 0]\r\n        cumSky_radiationStudy = []; viewPoints_viewStudy =[]; viewFields_Angles_D = [];\r\n        results, totalResults, listInfo, sunVisibility = runAnalyses(testPoints, ptsNormals, meshSrfAreas,\r\n                                analysisSrfs, contextSrfs, parallel, cumSky_radiationStudy,\r\n                                viewPoints_viewStudy, viewFields_Angles_D,\r\n                                sunVectors_sunlightHour, conversionFac)\r\n                                \r\n    if results!=-1 and len(results) == 4:\r\n        contextSrfs, analysisSrfs, testPoints, ptsNormals = results\r\n        return contextSrfs, analysisSrfs, testPoints, ptsNormals, originalTestPoints\r\n    \r\n    elif results != -1:\r\n        if not runOrientation:\r\n            totalResults = [totalResults] # make a list of the list so the same process can be applied to orientation study and normal run\r\n        else:\r\n            bakeIt = 0\r\n        \r\n        resultColored = []\r\n        legendColored = []\r\n        [resultColored.append([]) for x in range(len(results))]\r\n        [legendColored.append([]) for x in range(len(results))]\r\n        for i in range(len(results)):\r\n            if results[i]!= None:\r\n                # Add an option for orientation study\r\n                resultColored[i], legendColored[i], l[i], legendBasePoint = resultVisualization(contextSrfs, analysisSrfs,\r\n                                  results[i], totalResults[0][i], legendPar, legendTitles[i],\r\n                                  studyLayerNames[i], bakeIt, CheckTheName, 0, angles[-1], listInfo)\r\n                resV += 1\r\n    \r\n        # return outputs\r\n        if runOrientation: contextSrfs = mergedContextSrfs\r\n        if resV != 0: return contextSrfs, analysisSrfs, testPoints, ptsNormals, results, resultColored, legendColored, totalResults, legendBasePoint, originalTestPoints, sunVisibility\r\n        else: return -1\r\n    else:\r\n        return -1\r\n\r\nif _runIt:\r\n    if (len(_geometry)!=0 and _geometry[0] != None and _disFromBase):\r\n        if sunVectors_sunlightHour:\r\n            for vector in sunVectors_sunlightHour: vector.Reverse()\r\n        \r\n        #check the input for timeStep\r\n        try: _timeStep_ = int(_timeStep_)\r\n        except: _timeStep_ = 1\r\n        \r\n        result = main(north_, _geometry, context_, _gridSize_, _disFromBase, orientationStudyP_,\r\n                    sunVectors_sunlightHour, _timeStep_, legendPar_, parallel_, bakeIt_,\r\n                    workingDir_, projectName_)\r\n        \r\n        if result!= -1 and len(result) > 5:\r\n            def openLegend(legendRes):\r\n                if len(legendRes)!=0:\r\n                    meshAndCrv = []\r\n                    meshAndCrv.append(legendRes[0])\r\n                    [meshAndCrv.append(c) for c in legendRes[1]]\r\n                    return meshAndCrv\r\n                else: return\r\n            \r\n            # Assign the result to GH component outputs\r\n            contextMesh, analysisMesh, testPts_flatten, testVec_flatten = result[0], result[1], result[2], result[3]\r\n            \r\n            # radiation\r\n            radiationResult = result[4][0]\r\n            radiationMesh = result[5][0]\r\n            radiationLegend = openLegend(result[6][0])\r\n            \r\n            # sunlightHours\r\n            sunlightHoursResult_flatten = result[4][1]\r\n            sunlightHoursMesh = result[5][1]\r\n            sunlightHoursLegend = openLegend(result[6][1])\r\n            \r\n            # sunlightHours\r\n            viewStudyResult = result[4][2]\r\n            viewStudyMesh = result[5][2]\r\n            viewStudyLegend = openLegend(result[6][2])\r\n            \r\n            # total results\r\n            totalRadiation = []; totalSunlightHours = []; totalView = []\r\n            for res in result[7]:\r\n                totalRadiation.append(res[0])\r\n                totalSunlightHours.append(res[1])\r\n                totalView.append(res[2])\r\n            \r\n            legendBasePt = result[-3]\r\n            originalTestPoints = result[-2]\r\n            sunVisibility = result[-1]\r\n            \r\n        elif result!= -1 and len(result) == 5:\r\n            contextMesh, analysisMesh, testPts_flatten, testVec_flatten, originalTestPoints = result\r\n        \r\n        testPts = DataTree[System.Object]()\r\n        testVec = DataTree[System.Object]() \r\n        sunIsVisible = DataTree[System.Object]()\r\n        \r\n        if result!= -1:\r\n            sunlightHoursResult = DataTree[System.Object]()\r\n        \r\n            # graft test points\r\n            ptCount = 0\r\n            for i, ptList in enumerate(originalTestPoints):\r\n                p = GH_Path(i)\r\n                for pCount, pt in enumerate(ptList):\r\n                    testPts.Add(pt, p)\r\n                    testVec.Add(testVec_flatten[ptCount], p)\r\n                    if result!= -1 and len(result) != 5:\r\n                        #try:\r\n                        q = GH_Path(i, pCount)\r\n                        sunlightHoursResult.Add(sunlightHoursResult_flatten[ptCount], p)\r\n                        sunIsVisible.AddRange(sunVisibility[ptCount], q)\r\n                        #except: pass\r\n                    ptCount += 1\r\n        \r\n        ghenv.Component.Params.Output[1].Hidden= True\r\n        ghenv.Component.Params.Output[2].Hidden= True\r\n        ghenv.Component.Params.Output[3].Hidden= True\r\n        ghenv.Component.Params.Output[9].Hidden= True\r\n    else:\r\n        result = -1\r\n    \r\n    if result == -1 and not (len(_geometry)!=0 and _geometry[0] != None and _disFromBase):\r\n        warnM = \"Please connect the geometry or the context and set up both the gridSize and the distance from base surface...\"\r\n        print warnM\r\n        w = gh.GH_RuntimeMessageLevel.Warning\r\n        ghenv.Component.AddRuntimeMessage(w, warnM)\r\n    elif result == -1 and sc.sticky.has_key('ladybug_release'):\r\n        print \"Canceled by user!\"\r\n    \r\nelse:\r\n    print 'Set runIt to True!'\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}