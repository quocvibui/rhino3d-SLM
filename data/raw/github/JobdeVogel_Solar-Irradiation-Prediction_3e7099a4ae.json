{
  "source_url": "https://github.com/JobdeVogel/Solar-Irradiation-Prediction/blob/ce25b61727edaaaeb0e965bb821506de01cb0dcc/dataset/load_3dbag/outlines.py",
  "repo": "JobdeVogel/Solar-Irradiation-Prediction",
  "repo_stars": 0,
  "repo_description": "Graduation repository for Master Building Technology",
  "license": "unknown",
  "filepath": "dataset/load_3dbag/outlines.py",
  "instruction": "This module contains all functions regarding flat polylines, curves and rectangles",
  "code": "\"\"\"\nThis module contains all functions regarding flat polylines, curves and rectangles\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport System\nimport sys\n\nfrom parameters.params import TRANSLATE_TO_ORIGIN, GSI, _SPLIT_TOLERANCE, MIN_AREA\n\n# Get the x,y domain of a bbox\ndef get_domain(bbox):\n    \"\"\"Get the x and y domain from a boundingbox\n\n    Args:\n        bbox (rg.BoundingBox): boundingbox\n\n    Returns:\n        domains: two tuples containing minima and maxima for x and y\n    \"\"\"\n    x = []\n    y = []\n    \n    for point in bbox.GetCorners():\n        x.append(point.X)\n        y.append(point.Y)\n    \n    min_x = min(x)\n    min_y = min(y)\n    max_x = max(x)\n    max_y = max(y)\n    \n    return (min_x, max_x), (min_y, max_y)\n\n# Divide main domain into sub domains\ndef divide_domain(domain, size, min_coverage):\n    \"\"\"Divide a domain in subdomains\n\n    Args:\n        domain (tuple): domain in shape min, max\n        size (float): size of the subdomains height and width\n        min_coverage (float): minimum overlap between subdomains\n\n    Returns:\n        sub_domains (list[tuple]): divided domains\n    \"\"\"\n    # Extract the minimum and maximum from the original domain\n    min_x, max_x = domain[0]\n    min_y, max_y = domain[1]\n    \n    # Compute the distance between minima and maxima for the domain\n    x_size = abs(min_x) + abs(max_x)\n    y_size = abs(min_y) + abs(max_y)\n    \n    # Compute the step size\n    step_size = size * min_coverage / 100\n    \n    # Compute number of steps in x and y direction\n    x_steps = (x_size // step_size)\n    y_steps = (y_size // step_size)\n    \n    # Store the new subdivide domains\n    sub_domains = []\n    for i in range(int(x_steps)):\n        for j in range(int(y_steps)):\n            # Compute a new domain\n            x_domain = (min_x + i * step_size, min_x + i * step_size + size)\n            y_domain = (min_y + j * step_size, min_y + j * step_size + size)\n            \n            # Append the new domain to the returned domains\n            sub_domains.append((x_domain, y_domain))\n    \n    return sub_domains\n\ndef generate_outlines_from_bbox(bbox, size, min_coverage):\n    \"\"\"Generate a set of patch outlines that are used to indicate which meshes\n    should be extracted per sample\n\n    Args:\n        bbox (rg.BoundingBox): boundingbox of the entire mesh\n        size (float): width and height of the patches\n        min_coverage (float): factor indicating how much area may be repeated in sequential patches\n\n    Returns:\n        outlines (list[rg.Rectangle3d]): oulines of bbox as rectangles \n    \"\"\"\n    \n    #Get the domain of a boundingbox\n    main_domain = get_domain(bbox)\n    \n    #Divide the main domain to subdomains\n    sub_domains = divide_domain(main_domain, size, min_coverage)\n    \n    #Generate a rectangle based on the subdomains\n    outlines = []\n    for domain in sub_domains:\n        corner_0 = rg.Point3d(domain[0][0], domain[1][0], 0)\n        corner_1 = rg.Point3d(domain[0][1], domain[1][1], 0)\n        outlines.append(rg.Rectangle3d(rg.Plane.WorldXY, corner_0, corner_1))\n\n    return outlines\n\ndef includes_ground_outline(ground_outline, building_outline):\n    \"\"\"Check if a building outline is inside a ground outline rectangle\n\n    Args:\n        ground_outline (rg.Rectange3d): Rectangle outline for the ground patch\n        building_outline (rg.Polyline): Polyline outline for a building\n\n    Returns:\n        int: -1 if outside, 1 if inside, 0 i intersecting, else None\n    \"\"\"\n    # Boolean indicating if points are outside and inside\n    outside = False\n    inside = False\n    \n    # Base relation is unset\n    relation = rg.PointContainment.Unset\n    \n    # Transform the ground outline polyline to Nurbscurve\n    curve = ground_outline.ToNurbsCurve()\n    \n    # For each point in the polyline\n    for point in building_outline:\n        # Compute the relation with the ground outline\n        relation = curve.Contains(point)\n        \n        # Set the relations\n        if relation == rg.PointContainment.Inside:\n            inside = True\n        elif relation == rg.PointContainment.Outside:\n            outside = True\n        \n        if outside and inside:\n            return 0\n    \n    # If not intersecting, check the new relation\n    if outside and not inside:\n        return -1\n    elif inside and not outside:\n        return 1\n    else:\n        return None\n\ndef extract_building_outlines(wall_meshes, roof_meshes, tolerance=_SPLIT_TOLERANCE, logger=False):\n    \"\"\"Extract polyline building outlines from wall and roof meshes\n\n    Args:\n        wall_meshes (list[rg.Mesh]): list of wall meshes\n        roof_meshes (list[rg.Mesh]): list of roof meshes\n        tolerance (float, optional): Tolerance for adding naked edges to the outlines list. Defaults to _SPLIT_TOLERANCE.\n\n    Returns:\n        building_outlines (list[list[rg.Polyline]]): building outlines\n        building_heights (list[float]): heights individual buildings\n    \"\"\"\n    \n    # Store the building outlines and heihgts\n    building_outlines = []\n    building_heights = []\n    \n    # Iterate over both walls and roofs\n    for i, (wall, roof) in enumerate(zip(wall_meshes, roof_meshes)):\n        # Store temporary outlines for a specific building\n        outlines = []\n        \n        # Get the naked edges from the wall\n        lines = wall.GetNakedEdges()\n        \n        # If the extractionn succeeded\n        if lines != None:       \n            # Iterate over the naked lines\n            for naked in lines:\n                # Check the height of the naked line\n                height = naked.CenterPoint().Z\n                \n                # If the height is lower than the tolerance, add the naked line to the outlines\n                if height < tolerance:\n                    outlines.append(naked)\n            \n            # Reduce the number of segments in the outlines\n            for outline in outlines:\n                outline.ReduceSegments(tolerance)\n            \n            # Check if the building is not floating above the ground\n            if len(outlines) != 0:\n                # If not, append the outlines and the building height\n                building_outlines.append(outlines)\n                try:\n                    building_heights.append(roof.Faces.GetFaceCenter(0).Z)\n                except:\n                    building_heights.append(max([vertex.Z for vertex in wall.Vertices]))\n            else:\n                if logger:\n                    print('Mesh ' + str(i) + ' does not have naked edges with height lower than tolerance ' + str(tolerance) + '. This building if floating above the ground.')\n        else:\n            if logger:\n                print('Mesh ' + str(i) + ' naked edges extraction failed. This mesh is most likely closed.')\n    \n    return building_outlines, building_heights\n\n# Find which polyline is the outer polyline of a mesh surface\ndef find_outer_polyline(polylines):\n    \"\"\"Given multiple polylines, find which polyline has the longest length, and is most likely  the outer polyline\n    \n    # ! IMPROVE: This assumption is theoratically not always correct\n\n    Args:\n        polylines (list[rg.Polyline]): list of polylines\n\n    Returns:\n        outer + inner (list[rg.Polyline]): ordered list of polylines\n    \"\"\"\n    # Store the lengths of the polylines and which polylines are inner polylines\n    outers = []\n    inners = []\n    \n    curves = [polyline.ToNurbsCurve() for polyline in polylines]\n    \n    for inner in polylines:\n        \n        inside_any = False\n        for outer in curves:\n            is_inside = []\n            for point in inner:\n                \n                if outer.Contains(point, rg.Plane.WorldXY) == rg.PointContainment.Inside:\n                    is_inside.append(True)\n                else:\n                    is_inside.append(False)\n         \n            if all(is_inside):\n                # The inner is inside this outside\n                inside_any = True\n                break\n        if inside_any:\n            inners.append(inner)\n        else:\n            outers.append(inner)\n\n    return outers, inners\n\ndef find_segments(segments, base_curve):\n    \"\"\"Find which segments from a segmented curve should be kept and which\n    should be deleted.\n    Inputs:\n        segments: The segments as polylines\n        base_curve: The curve used for containment\n    Output:\n        polylines: the segments that should be kept\"\"\"\n    \n    #Store the polylines that should be kept    \n    polylines = []\n    for segment in segments:\n        #Transform the segment from rg.Polyline to rg.NurbsCurve\n        segment = segment.ToNurbsCurve()\n        \n        #Get \n        domain = segment.Domain\n        midpoint_parameter = domain.Mid\n        \n        midpoint = segment.PointAt(midpoint_parameter)\n        \n        if base_curve.Contains(midpoint, rg.Plane.WorldXY) == rg.PointContainment.Inside:\n            polylines.append(segment)\n        elif base_curve.Contains(midpoint, rg.Plane.WorldXY) == rg.PointContainment.Coincident:\n            polylines.append(segment)\n\n    return polylines\n    \ndef cut_polyline(ground_outline, building_outline, tolerance=_SPLIT_TOLERANCE, min_area=MIN_AREA, logger=False):\n    # Transform polylines to curves\n    ground_curve = ground_outline.ToNurbsCurve()\n    building_curve = building_outline.ToNurbsCurve()\n    \n    # Compute intersection between building and ground outline curve\n    intersection_events = rg.Intersect.Intersection.CurveCurve(building_curve, ground_curve, tolerance, tolerance)\n    \n    # Store the parameter lengths for building and ground curve\n    parameters_ground = []\n    parameters_building = []\n    for event in intersection_events:\n        if event.IsPoint:\n            \n            # Compute the points for the building intersection\n            parameter_building = building_curve.ClosestPoint(event.PointA)[1]\n            parameters_building.append(parameter_building)\n\n            # Compute the points for the ground intersection\n            parameter_ground = ground_curve.ClosestPoint(event.PointB)[1]\n            parameters_ground.append(parameter_ground)\n    \n    parameters_building = System.Array[System.Double](parameters_building)\n    parameters_ground = System.Array[System.Double](parameters_ground)\n    \n    # Compute the segments for the ground and building outlines\n    ground_segments = ground_curve.Split(parameters_ground)\n    building_segments = building_curve.Split(parameters_building)\n    \n    # Get the inner building segment\n    building_segments = find_segments(building_segments, ground_curve)\n\n    # Get the ground segment\n    ground_polylines = [segment.TryGetPolyline()[1] for segment in ground_segments]\n    ground_segments = find_segments(ground_polylines, building_curve)\n\n    new_building_curves = System.Array[rg.NurbsCurve](building_segments + ground_segments)\n    joined_building_curve = rg.Curve.JoinCurves(new_building_curves, tolerance)\n    \n    projections = [rg.Curve.ProjectToPlane(curve, rg.Plane.WorldXY) for curve in joined_building_curve]\n    polylines = [curve.TryGetPolyline()[1] for curve in projections]\n    \n    if len(polylines) == 0:\n        if logger:\n            print(\"cut_polyline() was not able to extract polylines\")\n    \n    valid_polylines = []\n    for polyline in polylines:\n        template = polyline.Duplicate()\n        \n        try:\n            if polyline.IsClosed:\n                area = rg.AreaMassProperties.Compute(template.ToNurbsCurve()).Area       \n            \n                if area > min_area:\n                    valid_polylines.append(polyline)\n            else:\n                points = [point for point in polyline]\n                points += [points[0]]\n                template = rg.Polyline(System.Array[rg.Point3d](points))\n                \n                area = rg.AreaMassProperties.Compute(template.ToNurbsCurve()).Area  \n                \n                if area > min_area:\n                    valid_polylines.append(polyline)\n        except AttributeError:\n            # Area computation returns None\n            valid_polylines.append(polyline)\n                \n    return valid_polylines\n\n# Translate objects to origin\ndef translate(outline, ground_outline, height=0):\n    # Compute center of bbox\n    center = ground_outline.Center\n    x, y = center.X, center.Y\n    translation = rg.Transform.Translation(-x, -y, height)\n    outline.Transform(translation)\n\ndef compute_GSI(ground_outline, building_outlines, logger=False):\n    ground_area = rg.AreaMassProperties.Compute(ground_outline.ToNurbsCurve()).Area\n    \n    building_areas = []\n    for outlines in building_outlines:\n        if len(outlines) > 0:\n            try:            \n                building_areas.append(\n                    rg.AreaMassProperties.Compute(outlines[0].ToNurbsCurve()).Area\n                    )\n            except:\n                if logger:\n                    print(\"RESOLVE: Polyline was not closed so area not added to GSI\")\n    \n    return sum(building_areas) / ground_area, ground_area, building_areas\n\ndef fix_self_intersections(polyline):\n    curve = polyline.ToPolylineCurve()\n    intersections = rg.Intersect.Intersection.CurveSelf(curve, 0.001)\n    \n    if intersections > 0:\n        intersect = True\n    else:\n        intersect = False\n    \n    parameters = []\n    for event in intersections:\n        event_parameters = System.Array[float]([event.ParameterA, event.ParameterB])\n        \n        parameters += event_parameters\n    \n    curve_segments = curve.Split(parameters)\n    \n    polyline_segments = []\n    polyline_lengths = []\n    for curve in curve_segments:\n        polyline = curve.TryGetPolyline()[1]\n        polyline_segments.append(polyline)\n        polyline_lengths.append(polyline.Length)\n    \n    polylines_sorted = [pl for _, pl  in sorted(zip(polyline_lengths, polyline_segments))]\n    \n    if len(intersections) == 0:\n        polyline = polyline\n    if len(intersections) == 1:\n        polyline = polylines_sorted[-1]\n        \n        # CHECK IF CLOSED!!!\n    elif len(intersections) > 1:\n        polylines_sorted_inv = polylines_sorted[::-1]\n        \n        curves = System.Array[rg.Curve](\n            [polylines_sorted_inv[i].ToNurbsCurve() for i in range(0, len(intersections))]\n            )\n        \n        polyline = rg.NurbsCurve.JoinCurves(curves)[0].TryGetPolyline()[1]\n    \n    return polyline, intersect\n\n\ndef generate_building_outlines(ground_outline, all_building_outlines, heights, translate_to_origin=TRANSLATE_TO_ORIGIN, gsi=GSI, logger=False):    \n    \"\"\"Compute the building outlines that are inside a ground outline. If a building polyline intersects\n    with the ground outline, the building outlines are splitted in multiple segmenets and then closed.\n\n    Args:\n        ground_outline (rg.Rectangle3d): ground rectangle outline\n        all_building_outlines (list[list[rg,Polyline]]): all building outlines\n        heights (listt[float]): all heights of the buildings\n        translate_to_origin (bool, optional): indicates if outlines should be moved to origin. Defaults to TRANSLATE_TO_ORIGIN.\n        gsi (bool, optional): Indicates if gsi should be computed. Defaults to GSI.\n\n    Returns:\n        building_outlines (list[list[rg.Polyline]]): outlines for the buildings (including splitted intersecting building outlines)\n        courtyard_outlines (list[list[rg.Polyline]]): outlines for the courtyards, empty if no courtyard available\n        building_heights (list[float]): heights of the included buildings\n        GSI_score (float): gsi score, None if not computed\n        envelope_area (float): area of envelope in m2, None if not computed \n        building_area (float): area of all building, courtyards included in m2, None if not computed\n    \"\"\"\n    \n    # Store the polylines and heights\n    included_polylines = []\n    courtyards = []\n    building_heights = []\n    num_of_courtyards = 0\n    \n    # Iterate over all outlines and the corresponding heights\n    for polylines, height in zip(all_building_outlines, heights):\n        # The outer polyline of the building\n        outer = polylines[0]\n        \n        # There is only one polyline, so there is no courtyard\n        if len(polylines) == 1:\n            # Check if outer polyline inside the ground_outline\n            relation = includes_ground_outline(ground_outline, outer)\n            \n            # This building is inside the ground outline\n            if relation == 1:\n                included_polylines.append([outer])\n                building_heights.append(height)\n                \n                # No courtyards are available, so add empty list\n                courtyards.append([])\n            \n            # This building is intersecting with the ground outline\n            elif relation == 0:\n                # Cut the polyline and add it to included_polylines\n                polylines = cut_polyline(ground_outline, outer)\n                               \n                if len(polylines) > 0:                   \n                    # if smallest_area > min_area:\n                    included_polylines.append(polylines)\n                    building_heights.append(height)\n            \n                    # No courtyards are available, so add empty list\n                    courtyards.append([])\n        \n        # There are polylines, so there is at least one courtyard\n        else:\n            # First find the courtyards\n            temp_courtyard_polylines = []\n            \n            # Check if the courtyard outlines are inside the ground outline\n            for inner in polylines[1:]:\n                # These are the couryards!\n                relation = includes_ground_outline(ground_outline, inner)\n                \n                # Courtyards do NOT have to agree with minimum area\n                if relation == 1:\n                    temp_courtyard_polylines.append(inner)\n                    num_of_courtyards += 1\n                    \n            # Check if the outer polyline is inside the groundline\n            relation = includes_ground_outline(ground_outline, outer)\n            \n            # The outer polyline is inside the ground polyline\n            if relation == 1:\n                included_polylines.append([outer])\n                building_heights.append(height)\n                \n                # Outer was inside ground_outline, so all courtyards too\n                courtyards.append(temp_courtyard_polylines)\n            \n            # The outer polyline intersects the ground polyline\n            elif relation == 0:\n                polylines = cut_polyline(ground_outline, outer)\n                included_polylines.append(polylines)\n                \n                building_heights.append(height)\n                \n                # Check if any courtyard_outlines are inside the ground outline\n                if len(temp_courtyard_polylines) > 0:\n                    courtyards.append(temp_courtyard_polylines)\n                else:\n                    # Add an empty list\n                    courtyards.append([])\n     \n    # Translate all outlines to the origin\n    if translate_to_origin:\n        for outlines in included_polylines:\n            for polyline in outlines:\n                translate(polyline, ground_outline)\n        \n        for outlines in courtyards:\n            for outline in outlines:\n                translate(outline, ground_outline)        \n        \n        # Translate the ground outline to the origin    \n        translate(ground_outline, ground_outline)\n    \n    if gsi:\n        GSI_score, envelope_area, building_area = compute_GSI(ground_outline, included_polylines)\n    else:\n        GSI_score = None\n        envelope_area = None\n        building_area = None\n\n    building_outlines = included_polylines\n    courtyard_outlines = courtyards\n\n    if logger:\n        logger.debug(f'Generated {len(building_outlines)} building_outlines and {num_of_courtyards} courtyards with GSI {round(GSI_score, 2)}.')\n    \n    building_curves = []\n    for outlines in building_outlines:\n        building_curves.append([out.ToNurbsCurve() for out in outlines])\n    \n    # Sometimes a building outline is accidently a courtyard, this is fixed here:\n    pops = []\n    # Iterate over potential courtyards\n    for i, potential_courtyards in enumerate(building_outlines):\n        for potential_courtyard in potential_courtyards:\n            \n            # Iterate over buildings\n            for j, curves in enumerate(building_curves):\n                for curve in curves:\n                    inside = []\n                    \n                    for point in potential_courtyard:\n                        if curve.Contains(point, rg.Plane.WorldXY) == rg.PointContainment.Inside:\n                            inside.append(True)\n                        else:\n                            #This is not a potential courtyard for this building\n                            inside.append(False)\n                            break\n                    \n                    if all(inside):\n                        courtyard_outlines[j].append(potential_courtyard)\n                        pops.append(i)\n    \n    building_outlines = [i for j, i in enumerate(building_outlines) if j not in pops]\n    courtyard_outlines = [i for j, i in enumerate(courtyard_outlines) if j not in pops]\n    building_heights = [i for j, i in enumerate(building_heights) if j not in pops]\n    \n    return building_outlines, courtyard_outlines, building_heights, GSI_score, envelope_area, building_area",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}