{
  "source_url": "https://github.com/ibois-epfl/augmented-carpentry/blob/414eeb93984fad40a4e57daa60e1bb268cbd406c/py/pypi/ACPy/replayer/ttool_loader.py",
  "repo": "ibois-epfl/augmented-carpentry",
  "repo_stars": 15,
  "repo_description": "Main repository hosting the main AR software developed for Augmented Carpentry rersearch at Ibois, Epfl.",
  "license": "GPL-3.0",
  "filepath": "py/pypi/ACPy/replayer/ttool_loader.py",
  "instruction": "Ttool loader",
  "code": "import os\nimport json\nimport subprocess\nimport zipfile\nfrom glob import glob\n\nimport xml.etree.ElementTree as ET\n\nimport Rhino\nimport ghpythonlib\n\n\ndef unzip_file(zip_file_path, dest_folder):\n    \"\"\"Unzip a file to a destination folder.\"\"\"\n    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:\n        zip_ref.extractall(dest_folder)\n\n    return True\n\n\ndef download_file(url, dest_path):\n    \"\"\"Download a file to a destination path.\"\"\"\n    curl_command = [\"curl\", \"-o\", dest_path, url]\n    result = subprocess.run(curl_command)\n\n    if result.returncode != 0:\n        Rhino.RhinoApp.WriteLine(f\"Error downloading {url} to {dest_path}\")\n        return False\n    else:\n        return True\n\n\ndef download_and_unzip_zenodo_file(url, dest_folder, filename):\n    \"\"\"Download an individual zip file in a zenodo dataset and unzip.\"\"\"\n    if not os.path.exists(dest_folder):\n        os.makedirs(dest_folder)\n    \n    dest_path = os.path.join(dest_folder, filename)\n\n    if not download_file(url, dest_path):\n        return False\n    \n    if not unzip_file(dest_path, dest_folder):\n        return False   \n\n    return True\n\n\ndef download_ttool_model(ttool_zenodo_version, download_root_path):\n    \"\"\"Download all the TTool models of a specific version from Zenodo.\"\"\"\n\n    # Rhino.RhinoApp.WriteLine(\"Downloading TTool models...\")\n\n    metadata_url = \"https://zenodo.org/api/records/\" + ttool_zenodo_version\n    curl_command = [\"curl\", metadata_url]\n    metadata_raw_str = (subprocess.run(curl_command, stdout=subprocess.PIPE, text=True)).stdout\n\n    metadata = json.loads(metadata_raw_str)\n    for file in metadata[\"files\"]:\n        filename = file[\"key\"]\n        url = file[\"links\"][\"self\"]\n\n        download_and_unzip_zenodo_file(url, download_root_path, filename)\n\n\ndef _parse_position(positionString):\n    \"\"\"\n    As the acit stores the position according to a Y-up coordinate system,\n    we need to convert it to a Z-up system by swapping the Y and Z values.\n    \"\"\"\n\n    positionString = positionString.strip()\n    x, z, y = tuple(map(float, positionString.split(\" \")))\n    return Rhino.Geometry.Point3d(x, y, z)\n\n\ndef parse_acit(acit_path, scale):\n    \"\"\"Parse the ACIT file and return the data in a dictionary.\"\"\"\n    tree = ET.parse(acit_path)\n    acit = tree.getroot()\n\n    toolhead = acit.find(\"toolhead\")\n    tool_type = toolhead.attrib[\"type\"].strip()\n    if tool_type == \"circularsaw\":\n        center = _parse_position(toolhead.find(\"center\").text) * scale\n        normal_start = _parse_position(toolhead.find(\"normalstart\").text) * scale\n        normal_end = _parse_position(toolhead.find(\"normalend\").text) * scale\n        radius = float(toolhead.find(\"radius\").text) * scale\n        blade_thickness = float(toolhead.find(\"bladeThickness\").text) * scale\n        blade_overhang = float(toolhead.find(\"bladeOverhang\").text) * scale\n\n        normal = normal_end - normal_start\n        normal.Unitize()\n\n        data = {\n            \"type\": \"circularsaw\",\n            \"center\": center,\n            \"normal\": normal,\n            \"radius\": radius,\n            \"blade_thickness\": blade_thickness,\n            \"blade_overhang\": blade_overhang\n        }\n\n        return data\n\n    elif tool_type == \"drillbit\":\n        tool_base = _parse_position(toolhead.find(\"toolbase\").text) * scale\n        tip = _parse_position(toolhead.find(\"tooltip\").text) * scale\n        eat_tip = _parse_position(toolhead.find(\"eattip\").text) * scale\n        chuck_tip = _parse_position(toolhead.find(\"chucktip\").text) * scale\n        radius = float(toolhead.find(\"radius\").text) * scale\n        \n        normal = chuck_tip - eat_tip\n        length = normal.Length\n        normal.Unitize()\n\n        data = {\n            \"type\": \"drillbit\",\n            \"tool_base\": tool_base,\n            \"tip\": tip,\n            \"eat_tip\": eat_tip,\n            \"chuck_tip\": chuck_tip,\n            \"radius\": radius,\n            \"normal\": normal,\n            \"length\": length\n        }\n\n        return data\n    \n    elif tool_type == \"chainsaw\":\n        chain_base = _parse_position(toolhead.find(\"chainbase\").text) * scale\n        chain_mid = _parse_position(toolhead.find(\"chainmid\").text) * scale\n        chain_end = _parse_position(toolhead.find(\"chainend\").text) * scale\n        normal_start = _parse_position(toolhead.find(\"normalstart\").text) * scale\n        normal_end = _parse_position(toolhead.find(\"normalend\").text) * scale\n        width = float(toolhead.find(\"width\").text) * scale\n        blade_thickness = float(toolhead.find(\"bladeThickness\").text) * scale\n        blade_overhang = float(toolhead.find(\"bladeOverhang\").text) * scale\n\n        normal = normal_end - normal_start\n        normal.Unitize()\n\n        data = {\n            \"type\": \"chainsaw\",\n            \"chain_base\": chain_base,\n            \"chain_mid\": chain_mid,\n            \"chain_end\": chain_end,\n            \"normal\": normal,\n            \"width\": width,\n            \"blade_thickness\": blade_thickness,\n            \"blade_overhang\": blade_overhang\n        }\n\n        return data\n\n    elif tool_type == \"sabersaw\":\n        pass\n\n    else:\n        raise ValueError(f\"Unknown toolhead type {toolhead.attrib['type']}\")\n\n\ndef construct_drillbit_primitive_model(acit_data):\n    \"\"\"Construct a primitive model of the drillbit from the ACIT file.\"\"\"\n    \n    base_plane = Rhino.Geometry.Plane(acit_data[\"chuck_tip\"], acit_data[\"normal\"])\n    base_circle = Rhino.Geometry.Circle(base_plane, acit_data[\"radius\"])\n    primitive_cylinder = Rhino.Geometry.Cylinder(base_circle, acit_data[\"length\"])\n    brep = primitive_cylinder.ToBrep(True, True)\n\n    return brep\n\n\ndef construct_circularsaw_primitive_model(acit_data):\n    \"\"\"Construct a primitive model of the circularsaw from the ACIT file.\"\"\"\n    \n    # the normal will facing the outside of the blade (facing the camera), thus * -1\n    base_plane = Rhino.Geometry.Plane(acit_data[\"center\"], -acit_data[\"normal\"])\n    base_circle = Rhino.Geometry.Circle(base_plane, acit_data[\"radius\"])\n    primitive_cylinder = Rhino.Geometry.Cylinder(base_circle, acit_data[\"blade_thickness\"])\n    brep = primitive_cylinder.ToBrep(True, True)\n\n    return brep\n\n\ndef construct_chainsaw_primitive_model(acit_data):\n    \"\"\"Construct a primitive model of the chainsaw from the ACIT file.\"\"\"\n    # The primitive model for chainsaw can just take the normal rebuilt model\n    return None\n\n\ndef construct_primitive_model(acit_data):\n    \"\"\"Construct a primitive model from the ACIT file.\"\"\"\n    \n    if acit_data[\"type\"] == \"drillbit\":\n        return construct_drillbit_primitive_model(acit_data)\n    elif acit_data[\"type\"] == \"circularsaw\":\n        return construct_circularsaw_primitive_model(acit_data)\n    elif acit_data[\"type\"] == \"chainsaw\":\n        return construct_chainsaw_primitive_model(acit_data)\n    else:\n        raise ValueError(\"Unknown toolhead type\")\n\n\ndef rebuild_saw_blade_model(raw_mesh_model, acit_data):\n    \"\"\"Rebuild the model to give it thickness.\"\"\"\n    normal = acit_data[\"normal\"]\n    normal.Unitize()\n    # the normal will facing the outside of the blade (facing the camera), thus * -1\n    extrude_vec = -normal * acit_data[\"blade_thickness\"]\n    \n    naked_edges = raw_mesh_model.GetNakedEdges()\n    sorted_edges = sorted(naked_edges, key=lambda e: e.Length, reverse=True)\n\n    # the longest edge is the blade edge\n    boundary = sorted_edges[0]\n    blade_face_1 = ghpythonlib.components.FragmentPatch(boundary)\n    blade_face_2 = blade_face_1.Duplicate()\n    blade_face_2.Translate(extrude_vec)\n    extrusion = Rhino.Geometry.Extrusion.CreateExtrusion(boundary.ToNurbsCurve(), extrude_vec).ToBrep()\n\n    model = Rhino.Geometry.Brep.JoinBreps(\n        [blade_face_1, blade_face_2, extrusion],\n        Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance,\n        Rhino.RhinoDoc.ActiveDoc.ModelAngleToleranceRadians,\n    )[0]\n    \n    return model\n\n\ndef load(ttool_model_root_path, ttool_zenodo_version_url, scale=50):\n    \"\"\"\n    Load the TTool models of a specific version from the given root path.\n    Returns a dictionary of \n    {\n        model_names: {\n            \"model\": Rhino.Geometry.Brep (the detailed model),\n            \"primitive\": Rhino.Geometry.Brep (the representative cylinder model)\n        },\n        ...\n    }.\n    \"\"\"\n\n    zenodo_version = ttool_zenodo_version_url.split(\"/\")[-1]\n    \n    ttool_model_version_path = os.path.join(ttool_model_root_path, zenodo_version)\n\n    if not os.path.exists(ttool_model_version_path):\n        os.makedirs(ttool_model_version_path)\n        download_ttool_model(zenodo_version, ttool_model_version_path)\n\n    # load all the mesh files\n    ttool_model_paths = glob(os.path.join(ttool_model_version_path, \"*\"))\n\n    ttool_models = {}\n    for path in ttool_model_paths:\n        if path.endswith(\".zip\"):\n            continue\n        \n        if \"saber\" in path:\n            # TODO: skip those that are not in used at the moment\n            continue\n\n        model_name = os.path.basename(path)\n        ttool_models[model_name] = {}\n\n        # create a primitive model\n        acit_path = os.path.join(path, \"metadata.acit\")\n        acit_data = parse_acit(acit_path, scale)\n        primitive_model = construct_primitive_model(acit_data)\n\n        # load the model\n        model_path = os.path.join(path, \"model.obj\")\n\n        raw_model = ghpythonlib.components.Import3DM(model_path, \"*\", \"*\")\n        if raw_model is None:\n            Rhino.RhinoApp.WriteLine(f\"Error loading {model_path}\")\n            raise ValueError(f\"Error loading .obj file. If the file exists, try re-open Rhino.\")\n\n        raw_model.Scale(scale)\n        saw_blade_type_to_rebuild = [\"circularsaw\", \"chainsaw\"]\n        if acit_data[\"type\"] in saw_blade_type_to_rebuild:\n            fine_model = rebuild_saw_blade_model(raw_model, acit_data)\n        else:\n            fine_model = Rhino.Geometry.Brep.CreateFromMesh(raw_model, True)\n        \n        # export the data\n        ttool_models[model_name][\"type\"] = acit_data[\"type\"]\n        ttool_models[model_name][\"raw_model\"] = raw_model\n        ttool_models[model_name][\"model\"] = fine_model\n        ttool_models[model_name][\"primitive_model\"] = primitive_model\n\n    return ttool_models\n\n\nif __name__ == \"__main__\":\n    ttool_model_root_path = \"C:\\\\Users\\\\localuser\\\\Documents\\\\hong-bin\\\\replayer\\\\ttool_dataset_new\"\n    ttool_zenodo_version_url = \"https://zenodo.org/record/12578820\"\n    ttool_models = load(ttool_model_root_path, ttool_zenodo_version_url)\n    \n    # a = ttool_models[\"circular_saw_blade_mafel_237\"]",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}