{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import Rhino as rc\nimport collections\nimport scriptcontext as sc\n\n\nclass Plant3d(object):\n\n    def __init__(self, geometry, material):\n        self.geometry = geometry\n\n        idAndDescription = material.split(',')\n        self.materialId = idAndDescription[0]\n        self.materialDescrition = idAndDescription[1]\n\n\n    def threeDimensionalPlants(self, grid):\n        nestedMatrix = []\n        unit = 1\n\n        curves = [c for c in self.geometry.DuplicateEdgeCurves()]\n        closedCrv = [crv for crv in rc.Geometry.Curve.JoinCurves(curves)][0]\n\n        for j in range(grid.numY + unit):\n            for i in range(grid.numX + unit):\n                point = rc.Geometry.Point3d((i * grid.dimX) + grid.minX, (j * grid.dimY) + grid.minY, grid.zHeight[0])\n                if rc.Geometry.Curve.Contains(closedCrv, point, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance) == rc.Geometry.PointContainment.Inside:\n                    nestedMatrix.append([str(i + unit), str(j + unit),'0', self.materialId, self.materialDescrition, '0'])\n\n        return nestedMatrix\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "point", "dimension", "curve", "functions"], "original_file": "AntonelloDN_lb_envimet_b2f73f4e17.json", "repo": "AntonelloDN/lb_envimet"}
{"instruction": "Implement the function 'meshFromPoints' for Rhino scripting", "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm \n\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n\n@hops.component(\n    \"/meshFromPoints\",\n    name = \"meshFromPoints\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"Some Points\", hs.HopsParamAccess.LIST)\n\n\n    ],\n\n    outputs=[\n        hs.HopsMesh(\"Mesh\",\"M\",\"A simple rhino3dm mesh\"),\n\n    ]\n)\ndef meshFromPoints(pts):\n\n    m = rhino3dm.Mesh()\n\n    for p in pts:\n        m.Vertices.Add(p.X, p.Y, p.Z)\n\n    \n    m.Faces.AddFace(0,1,2,2)\n    m.Faces.AddFace(3,4,5,5) #triangular meshes repeat the last number!\n\n    print (m.Faces[0])\n    print (m.Faces.TriangleCount)\n\n\n    return m\n\n\n\n@hops.component(\n    \"/gridMesh\",\n    name = \"gridMesh\",\n    outputs=[\n        hs.HopsMesh(\"Mesh\",\"M\",\"A simple rhino3dm mesh\"),\n\n    ]\n)\ndef gridMesh():\n\n\n    U = 5\n    V = 5\n\n    #creating a simple mesh from a grid of points\n    grid = []\n    mesh = rhino3dm.Mesh()\n    \n    for i in range(U):\n        for j in range(V):\n            p = rhino3dm.Point3d(i,j,0)\n            grid.append(p)\n            mesh.Vertices.Add(p.X, p.Y, p.Z) \n            \n    for i in range(len(grid)-(V)):\n        if ( i % V != V -1 ):\n            mesh.Faces.AddFace(i,i+1, i+V+1,i+V)\n\n    print(mesh.Faces.Count)\n\n    for i in range(mesh.Faces.Count):\n        print(mesh.Faces[i])\n\n    return mesh\n\n\n\nif __name__== \"__main__\":\n    app.run(debug=True)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["mesh", "functions", "point"], "original_file": "Eridaa_1_RhinoGH--Python-hops-examples_0564ae0bc8.json", "repo": "Eridaa/1.RhinoGH--Python-hops-examples"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import Rhino\nimport rhinoscriptsyntax as rs\n\n# Grid Class\nclass Grid:\n    def __init__(self, points, width):\n        bbox = rs.BoundingBox(points)\n        self.minX = bbox[0].X - width\n        self.minY = bbox[0].Y - width\n        self.width = float(width)\n\n        self.max_x_idx = int((bbox[2].X - self.minX) // self.width) + 1\n        self.max_y_idx = int((bbox[2].Y - self.minY) // self.width) + 1\n\n        self.grid = [[[] for _ in range(self.max_y_idx+1)] for _ in range(self.max_x_idx+1)]\n\n        for point in points:\n            x_idx = int((point.X - self.minX) // self.width)\n            y_idx = int((point.Y - self.minY) // self.width)\n\n            self.grid[x_idx][y_idx].append(point)\n\n    def get_neighbors(self, point, neighborhood=1):\n        x_idx = max(min(int((point.X - self.minX) // self.width), self.max_x_idx), 0)\n        y_idx = max(min(int((point.Y - self.minY) // self.width), self.max_y_idx), 0)\n\n        # start with center\n        points = self.grid[x_idx][y_idx]\n\n        # retrieve neighbors\n        for x in range(max(0, x_idx-neighborhood), min(self.max_x_idx, x_idx+neighborhood+1)):\n            for y in range(max(0, y_idx-neighborhood), min(self.max_y_idx, y_idx+neighborhood)+1):\n                if not (x==x_idx and y==y_idx):\n                    points = points + self.grid[x][y]\n        \n        return points\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "functions", "point"], "original_file": "Hand-and-Machine_TRAvel_Slicer_c25f5f9a5b.json", "repo": "Hand-and-Machine/TRAvel_Slicer"}
{"instruction": "Implement the function 'join_meshes' for Rhino scripting", "code": "import Rhino.Geometry as rg\n\ndef join_meshes(meshes):\n    joined_meshes = rg.Mesh()\n    for mesh in meshes:\n        joined_meshes.Append(mesh)\n    \n    return joined_meshes\n\ndef get_face_vertices(face, mesh):\n    # vertex_0 = rg.Point3d(mesh.Vertices[face.A].X, mesh.Vertices[face.A].Y, mesh.Vertices[face.A].Z)\n    # vertex_1 = rg.Point3d(mesh.Vertices[face.B].X, mesh.Vertices[face.B].Y, mesh.Vertices[face.B].Z)\n    # vertex_2 = rg.Point3d(mesh.Vertices[face.C].X, mesh.Vertices[face.C].Y, mesh.Vertices[face.C].Z)\n    # vertex_3 = rg.Point3d(mesh.Vertices[face.D].X, mesh.Vertices[face.D].Y, mesh.Vertices[face.D].Z)\n    \n    vertices = [rg.Point3d(mesh.Vertices[vertex].X, mesh.Vertices[vertex].Y, mesh.Vertices[vertex].Z)\n                for vertex in (face.A, face.B, face.C, face.D)]\n    \n    if face.IsQuad:\n        return vertices[:4]\n    else:\n        return vertices[:3]", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "mesh", "functions", "RhinoCommon"], "original_file": "JobdeVogel_Solar-Irradiation-Prediction_403b26334f.json", "repo": "JobdeVogel/Solar-Irradiation-Prediction"}
{"instruction": "Implement the function 'load_mesh_from_json' for Rhino scripting", "code": "import Rhino.Geometry as rg\n\nimport Rhino\nimport json\nimport numpy as np\nimport pickle\n\n# Honeybee Core dependencies\nfrom honeybee.model import Model\n\n# Load a mesh from a json file\ndef load_mesh_from_json(name, folder, mesh_types):\n    path = folder + \"/\" + name + \".json\"\n\n    with open(path, \"r\") as file:\n        data = json.load(file)\n\n    if isinstance(mesh_types, str):\n        if mesh_types == 'meta':\n            return data['meta']\n        else:\n            return [rg.Mesh.FromJSON(data[mesh_types])], data['meta']\n    else:\n        meta = data['meta']\n        data.pop('meta')\n        meshes = []\n        \n        for key in data.keys():\n            meshes.append(rg.Mesh.FromJSON(data[key]))\n        \n        return meshes, meta\n\n# Load a mesh from a json file\ndef load_outlines_from_json(name, folder):\n    path = folder + \"/\" + name + \".json\"\n\n    with open(path, \"r\") as file:\n        data = json.load(file)\n\n    curves = []\n    for key in data.keys():\n        curves.append(rg.NurbsCurve.FromJSON(data[key]))\n        \n    return data\n\ndef load_array(file):\n     return np.load(file)\n\ndef load_array_as_list(name, folder):\n    path = folder + \"/\" + name + \".json\"\n    \n    with open(path, 'r') as file:\n        data = json.load(file)\n    \n    data = json.loads(data)\n        \n    # with open(file, 'rb') as file:\n    #     data = pickle.load(file)\n    \n    return data\n\n# Load an HB model from a file\ndef load_hbjson(name, folder):\n    path = folder + \"/\" + name + \".hbjson\"\n    model = Model.from_file(path)\n    \n    return model", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["line", "curve", "functions", "mesh", "RhinoCommon"], "original_file": "JobdeVogel_Solar-Irradiation-Prediction_43e2c3624f.json", "repo": "JobdeVogel/Solar-Irradiation-Prediction"}
{"instruction": "Implement the function 'legend' for Rhino scripting", "code": "import Rhino.Geometry as rg\nimport System\nimport time\n\nfrom ladybug.graphic import GraphicContainer\nfrom ladybug_rhino.togeometry import to_mesh3d\nfrom ladybug_rhino.fromgeometry import from_mesh3d\nfrom ladybug_rhino.color import color_to_color\n\nfrom ladybug.legend import LegendParameters\nfrom ladybug_rhino.togeometry import to_plane\n\ndef legend(colors=[(134, 144, 252), (247, 228, 10), (189, 88, 51), (212, 49, 0)], seg_count=20):\n    colors = [System.Drawing.Color.FromArgb(System.Int32(color[0]), System.Int32(color[1]), System.Int32(color[2])) for color in colors]\n\n    base_plane_ = to_plane(rg.Plane.WorldXY)\n\n    leg_par = LegendParameters(segment_count=seg_count, colors=colors, base_plane=base_plane_)\n\n    leg_par.continuous_legend = True\n    leg_par.decimal_count = 0\n    \n    return leg_par\n    \ndef generate_colored_mesh(mesh, values, legend_par, legend_title='(kWh/m2)', title='Solar Irradiance Simulation'):\n    # generate Ladybug objects\n    lb_mesh = to_mesh3d(mesh)\n    \n    graphic = GraphicContainer(values, lb_mesh.min, lb_mesh.max, legend_par)\n\n    # generate titles\n    graphic.legend_parameters.title = legend_title\n\n    # draw rhino objects # ! Most time consuming!\n    lb_mesh.colors = graphic.value_colors\n    mesh = from_mesh3d(lb_mesh)\n    \n    return mesh\n    \n    \n    \n    ", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["mesh", "functions", "RhinoCommon"], "original_file": "JobdeVogel_Solar-Irradiation-Prediction_6807169ef3.json", "repo": "JobdeVogel/Solar-Irradiation-Prediction"}
{"instruction": "Implement the function 'read_root' for Rhino scripting", "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport compute_rhino3d.Util as rc\nimport rhino3dm\nimport os\nfrom dotenv import load_dotenv\nimport requests\nfrom routes.geometry import router as geometry_router\nfrom routes.export import router as export_router\nfrom routes.grasshopper import router as grasshopper_router\nfrom models.models import SphereParams\nfrom utils.strings import API_KEY, BASE_URL\n\n# Initialize FastAPI application once\napp = FastAPI()\n\n# Load environment variables\nload_dotenv()\n\n# Include routers before starting FastAPI\napp.include_router(geometry_router, prefix=\"/geometry\", tags=[\"Geometry\"])\napp.include_router(export_router, prefix=\"/export\", tags=[\"Export\"])\napp.include_router(grasshopper_router, prefix=\"/grasshopper\", tags=[\"Grasshopper\"])\n\n# Initialize Rhino.Compute\nif not API_KEY:\n    raise ValueError(\"API Key not found! Set RHINO_COMPUTE_API_KEY in your environment.\")\nrc.apiKey = API_KEY\nrc.url = f\"{BASE_URL}\"\n\n# Base Route\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the Mubiyn's Compute API\"}\n\n# Healthcheck endpoint\n@app.get(\"/healthcheck\")\ndef rhino_compute_healthcheck():\n    try:\n        # Send an HTTP GET request to the Rhino.Compute server's healthcheck endpoint\n        response = requests.get(f\"{BASE_URL}healthcheck\")\n        \n        # Check the status code\n        if response.status_code == 200:\n            return {\"message\": \"Mubiyn's Rhino.Compute Wrapper is running\", \"status\": response.content}\n        else:\n            raise HTTPException(status_code=response.status_code, detail=\"Rhino.Compute is not healthy\")\n    except requests.exceptions.RequestException as e:\n        raise HTTPException(status_code=500, detail=f\"Error connecting to Rhino.Compute: {e}\")\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["functions", "point"], "original_file": "Mubiyn_gh_5bc02cefb3.json", "repo": "Mubiyn/gh"}
{"instruction": "Implement the function 'current_folder' for Rhino scripting", "code": "import os\r\nfrom conf import CAD_TYPES, IMG_TYPES\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino\r\n\r\ndef current_folder():\r\n    return Rhino.ApplicationSettings.FileSettings.WorkingFolder\r\n\r\n\r\ndef get_files_recursive(folder, filetypes):\r\n    result = []\r\n\r\n    for root, _, files in os.walk(folder):\r\n        for file in files:\r\n            for ext in filetypes:\r\n                if file.lower().endswith(\".\" + ext):\r\n                    result.append(os.path.join(root, file))\r\n                    break\r\n    return result\r\n\r\n\r\ndef get_imgs_recursive(folder):\r\n    img_types = IMG_TYPES\r\n    return get_files_recursive(folder, img_types)\r\n\r\n\r\ndef get_dxfs_recursive(folder):\r\n    return get_files_recursive(folder, CAD_TYPES)\r\n\r\n\r\ndef name(file):\r\n    return file.split(\"\\\\\")[-1]\r\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "functions"], "original_file": "Teakomatic_RETools-6d40c603-c950-4785-9bb8-cc46930ae150-_fe6163d406.json", "repo": "Teakomatic/RETools-6d40c603-c950-4785-9bb8-cc46930ae150-"}
{"instruction": "Implement the function 'run' for Rhino scripting", "code": "from .api.scriptctx import ScriptContext\nfrom .parsemodule import recurse_pgx\nfrom .exceptions import InvalidAppException, InvalidAttributeException\nfrom .parseval import parse_size\nfrom .api import PGXApp\nfrom domapi import Element\nimport os\nimport pygame as pg\nimport lxml.etree as etree\n\ndef run(filename: str):\n\tos.chdir(os.path.dirname(filename))\n\t\n\tdocument: etree._ElementTree = etree.parse(os.path.basename(filename))\n\n\tdoctype: str = document.docinfo.internalDTD.name\n\n\tif doctype != \"pygame-pgx\":\n\t\traise InvalidAppException(\n\t\t\t\"Invalid doctype (must be pygame-pgx)!\"\n\t\t)\n\t\t\n\troot: etree._Element = document.getroot()\n\n\tif root.tag != \"app\":\n\t\traise InvalidAppException(\n\t\t\t\"Root element is not <app>\"\n\t\t)\n\n\tdoc = Element(root)\n\n\tif doc.getAttribute(\"size\") is None:\n\t\traise InvalidAppException(\n\t\t\t\"No size specified on <app>\"\n\t\t)\n\t\n\tpg.init()\n\n\ttry: framerate = int(doc.getAttribute(\"framerate\"))\n\texcept TypeError: framerate = 60\n\texcept ValueError: raise InvalidAttributeException(\"Invalid value for framerate (must be int)\")\n\n\tapp = PGXApp(parse_size(doc.getAttribute(\"size\")), framerate)\n\tdeferred_scripts: list[tuple[str, ScriptContext]] = []\n\n\tscreen = pg.display.set_mode(app.size)\n\n\tapp.root_elements, _ = recurse_pgx(app, deferred_scripts, doc)\n\n\tfor (script_text, context) in deferred_scripts:\n\t\texec(script_text, { **app.global_namespace, \"current_script\": context })\t\n\n\tapp.app_update = getattr(app.global_namespace[\"exports\"], \"pgx_update\", lambda: None)\n\n\twhile 1:\n\t\tfor event in pg.event.get(): # TODO: have a separate event thread that calls event handlers\n\t\t\tif event.type == pg.QUIT:\n\t\t\t\tpg.quit()\n\t\t\t\texit(0)\n\n\t\tapp.render_to(screen)\n\n\t\tapp.update()\n\t\t\t\t\n\t\tpg.display.update()\n\nif __name__ == \"__main__\":\n\trun()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["functions"], "original_file": "User0332_pygame-pgfiles_40fc8c88f7.json", "repo": "User0332/pygame-pgfiles"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport ghpythonlib.componentbase\nimport math\nimport time\nimport System.Drawing as sd\nimport random\nimport json\n\n\n\nclass Room:\n    def __init__ (self, room_name, depth, width, location):\n        self.room_name = room_name\n        self.depth = depth\n        self.width = width\n        self.location = location\n\n    def area(self):\n        return self.depth * self.width\n    \n    def visual_3d(self):\n        crv = rg.Rectangle3d(self.location,rg.Interval(-self.width/2, self.width/2), rg.Interval(-self.depth/2, self.depth/2))\n        crv = crv.ToNurbsCurve()\n        height = 12\n        result = rg.Extrusion.Create(crv, height, True)\n        return result, crv\n       \n\nroom = Room\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "classes", "curve", "functions", "RhinoCommon"], "original_file": "bic98_AI-based-Architectural-Design-Automation_52ff9dd855.json", "repo": "bic98/AI-based-Architectural-Design-Automation"}
{"instruction": "Implement the function 'TSVtoCSV' for Rhino scripting", "code": "import csv\nimport sys\nimport random\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.treehelpers as th\nimport math\n\ndef TSVtoCSV(fileName, fileDestination):\n    tabin = csv.reader(open(fileName), dialect=csv.excel_tab)\n    commaout = csv.writer(open(fileDestination, 'wb'), dialect=csv.excel)\n    for row in tabin:\n        commaout.writerow(row)\n       \ndef inputToDimension(input):\n    # return int(math.sqrt(float(input)))\n    return float(input)**(1./8.)\n\ndef buildCSV(fileName):\n    chain = []\n\n    with open(fileName) as csvFile:\n        reader = csv.reader(csvFile)\n        next(reader, None)  # skip the header\n\n        prev = None\n        block = []\n        maxList = []\n        maxValue = 0\n\n        for row in reader:\n\n            if prev is not None and prev!=row[0]:\n                maxList.append(maxValue)\n                chain.append(block)\n                block = []\n                maxValue = 0\n            # 0- block index, 1 - hash, 12 - input_total (USD)\n            headersWeWant =[0, 1, 12]\n\n            row[12] = inputToDimension(row[12])\n            if (row[12]) > 0:\n               \n                # editedRow = [ row[h] for h in headersWeWant ]\n                editedRow = row[12]\n                block.append(editedRow)\n                if row[12] > maxValue:\n                    maxValue = row[12]\n\n            prev = row[0]\n\n    return (chain, maxList)\n\n\nfileName = r'C:\\Users\\ko Yiu Chung\\Desktop\\blockchain morphologies\\blockchair2012.csv'\nchain, maxList = buildCSV(fileName)\nmaxTree = th.list_to_tree(maxList)\ntree = th.list_to_tree(chain)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["block", "dimension", "rhinoscriptsyntax", "functions"], "original_file": "bicep_M_Arch2021_12e6e151f9.json", "repo": "bicep/M.Arch2021"}
{"instruction": "Implement the function 'UP3' for Rhino scripting", "code": "import rhinoscriptsyntax as rs\n\n#written by Clark Cheng\n#email: ccheng@clarkcheng.design\n\n\ndef UP3():\n    obj=rs.GetObjects(\"Select object to scale\", preselect=True)\n    if not obj:\n        print(\"None selected\")\n        return\n    if obj:\n        origin=rs.GetPoint(\"Origin\")\n    if origin:\n        \n        #create toggle for scale\n        copy=rs.GetBoolean(\"Copy\",(\"Copy\", \"No\", \"Yes\"),False)\n        print(copy)\n        \n        #extract value from list\n        copy=copy[0]\n        \n        #scale object\n        rs.ScaleObject(obj,origin, (1.03,1.03,1.03),copy)\n        #origin=rs.AddPoint(0,0,0)\n\nUP3()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "functions", "point"], "original_file": "ccheng-design_Ptarmigan_2577143c67.json", "repo": "ccheng-design/Ptarmigan"}
{"instruction": "Implement the function 'guid_to_compas_curve' for Rhino scripting", "code": "import compas_rhino.conversions\nimport compas_rhino.objects\nimport rhinoscriptsyntax as rs  # type: ignore\nfrom compas.geometry import Curve\n\n\ndef guid_to_compas_curve(guid) -> Curve:\n    return compas_rhino.conversions.curveobject_to_compas(compas_rhino.objects.find_object(guid))\n\n\ndef discretise_boundary(guids, length):\n    boundary = []\n    for guid in guids:\n        rs.EnableRedraw(False)\n\n        segments = rs.ExplodeCurves(guid)\n        for segment in segments:\n            curve: Curve = guid_to_compas_curve(segment)\n            N = int(curve.length() / length)\n            _, points = curve.divide_by_count(N, return_points=True)\n            boundary.extend(points)\n\n        rs.DeleteObjects(segments)\n        rs.EnableRedraw(True)\n    return boundary\n\n\ndef discretise_constraints(guids, length):\n    polylines = []\n    if guids:\n        for guid in guids:\n            curve: Curve = guid_to_compas_curve(guid)\n            N = int(curve.length() / length)\n            _, points = curve.divide_by_count(N, return_points=True)\n            polylines.append(points)\n    return polylines\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["rhinoscriptsyntax", "point", "line", "curve", "functions"], "original_file": "compas-dev_compas_triangle_8435945bda.json", "repo": "compas-dev/compas_triangle"}
{"instruction": "Implement the function 'readrhino' for Rhino scripting", "code": "import json\n\nimport rhino3dm\nfrom rhino3dm import _rhino3dm as rh\nimport cadexchanger.CadExCore as cadex\nimport cadexchanger.CadExRhino as rhino\n\n\ndef readrhino(sorce_path):\n    aReader = rhino.Rhino_Reader()\n    aReader.ReadFile(cadex.Base_UTF16String(sorce_path))\n    return aReader\n\n\ndef to_cadex_viewer(reader,\n                          target_path=\"/home/sthv/cadexchanger-web-toolkit-examples/public/assets/models/native/PNL_all_Arc.cdxfb\"):\n    aModel = cadex.ModelData_Model()\n    reader.Transfer(aModel)\n    aWriter = cadex.ModelData_ModelWriter()\n    # params\n    aParams = cadex.ModelData_WriterParameters()\n    aParams.SetFileFormat(cadex.ModelData_WriterParameters.Cdxfb)\n    aParams.SetWriteBRepRepresentation(True)\n    aParams.SetWritePolyRepresentation(True)\n    aParams.SetPreferredLOD(cadex.ModelData_RM_FineLOD)\n    aParams.SetWriteTextures(False)\n    aParams.SetWritePMI(True)\n\n    aWriter.SetWriterParameters(aParams)\n    # wright model\n    res = aWriter.Write(aModel, cadex.Base_UTF16String(target_path))\n    if res:\n        return True\n    else:\n        print(res)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["brep", "functions"], "original_file": "contextmachine_mmodel_36b863235b.json", "repo": "contextmachine/mmodel"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck import df_cvt_bindings\n\nclass DFCloudVoxelDownsample(component):\n    def RunScript(self,\n        i_cloud: Rhino.Geometry.PointCloud,\n        i_voxel_size: float) -> Rhino.Geometry.PointCloud:\n        if i_cloud is None or i_voxel_size is None:\n            return None\n        df_cloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n        df_cloud.voxel_downsample(i_voxel_size)\n        o_cloud = df_cvt_bindings.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        return [o_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_10df3fe048.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nclass DFRemoveBeam(component):\n    def RunScript(self,\n            i_assembly,\n            i_idx_2_remove: System.Collections.Generic.List[int]):\n\n        if i_assembly is None or i_idx_2_remove is None:\n            return None\n\n        o_assembly = i_assembly.deepcopy()\n        for idx in i_idx_2_remove:\n            o_assembly.remove_beam(idx)\n\n        return o_assembly\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_23a6b10012.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nimport diffCheck\nimport diffCheck.df_cvt_bindings\n\n\n\nclass DFMeshToCloud(component):\n    def RunScript(self,\n            i_meshes: System.Collections.Generic.List[Rhino.Geometry.Mesh],\n            i_points: int) -> Rhino.Geometry.PointCloud:\n\n        if i_meshes is None:\n            return None\n\n        if i_points is None:\n            i_points = 1000\n\n        rh_mesh = i_meshes[0]\n        for i  in range(1, len(i_meshes)):\n            if i_meshes[i] is None:\n                return None\n            rh_mesh.Append(i_meshes[i])\n        rh_mesh.Faces.ConvertQuadsToTriangles()\n\n        df_mesh = diffCheck.df_cvt_bindings.cvt_rhmesh_2_dfmesh(rh_mesh)\n        df_cloud = df_mesh.sample_points_uniformly(i_points)\n        rgpoints = [Rhino.Geometry.Point3d(p[0], p[1], p[2]) for p in df_cloud.points]\n        # convert the df_cloud to a rhino cloud\n        rh_cloud = Rhino.Geometry.PointCloud(rgpoints)\n\n        return [rh_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "functions", "mesh", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_351791d55e.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport Rhino.Geometry as rg\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\nclass DFLoadCloudFromFile(component):\n    def RunScript(self,\n        i_path: str,\n        i_scalef: float) -> rg.PointCloud:\n        if i_path is None:\n            return None\n        if i_scalef is None:\n            i_scalef = 1.0\n\n        df_cloud = diffcheck_bindings.dfb_geometry.DFPointCloud()\n        df_cloud.load_from_PLY(i_path)\n        rh_cloud = df_cvt_bindings.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        # scale  if needed\n        centroid = rh_cloud.GetBoundingBox(True).Center\n        x_form_scale = rg.Transform.Scale(centroid, i_scalef)\n        rh_cloud.Transform(x_form_scale)\n\n        return [rh_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_4fabc05128.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck import df_cvt_bindings\n\nclass DFCloudSizeDownsample(component):\n    def RunScript(self,\n        i_cloud: Rhino.Geometry.PointCloud,\n        i_size: float) -> Rhino.Geometry.PointCloud:\n        if i_cloud is None or i_size is None:\n            return None\n        df_cloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n        df_cloud.downsample_by_size(i_size)\n        o_cloud = df_cvt_bindings.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        return [o_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_53bcc1195f.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nclass DFInspectResults(component):\n    def RunScript(self, i_results):\n        if i_results is None:\n            return None\n\n        return i_results.assembly, \\\n            i_results.source, \\\n            i_results.target, \\\n            i_results.distances_mean, \\\n            i_results.distances_rmse, \\\n            i_results.distances_max_deviation, \\\n            i_results.distances_min_deviation, \\\n            i_results.distances_sd_deviation, \\\n            i_results.distances\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_572e325ecd.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom diffCheck.df_error_estimation import DFVizResults\n\n\nclass DFImportResults(component):\n    def RunScript(self, i_import_path: str):\n        if i_import_path is None:\n            return None\n\n        o_results = DFVizResults.load_serialization(i_import_path)\n\n        return o_results\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_61d2f1c04d.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\nimport typing\n\nimport Rhino\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom diffCheck.df_geometries import DFBeam, DFAssembly\n\n\nclass DFBuildAssembly(component):\n    def RunScript(self,\n            i_assembly_name,\n            i_breps : System.Collections.Generic.IList[Rhino.Geometry.Brep],\n            i_is_roundwood : bool):\n        beams: typing.List[DFBeam] = []\n\n        if i_assembly_name is None or i_breps is None:\n            return None\n\n        if i_is_roundwood is None:\n            i_is_roundwood = False\n\n        for brep in i_breps:\n            beam = DFBeam.from_brep_face(brep, i_is_roundwood)\n            beams.append(beam)\n\n        o_assembly = DFAssembly(beams, i_assembly_name)\n\n        return o_assembly\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["brep", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_7026ff3ef3.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nclass DFXMLExporter(component):\n    def RunScript(self,\n            i_dump: bool,\n            i_export_dir,\n            i_assembly):\n        # dump the xml\n        o_xml = None\n        xml: str = i_assembly.to_xml()\n        if i_dump:\n            i_assembly.dump_xml(xml, i_export_dir)\n        o_xml = xml\n\n        return o_xml\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_98ff0d4868.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino.Geometry as rg\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck import diffcheck_bindings\nfrom diffCheck import df_cvt_bindings\n\nclass DFLoadMeshFromFile(component):\n    def RunScript(self,\n        i_path: str,\n        i_scalef: float) -> rg.Mesh:\n        # import and convert to Rhino Mesh\n        df_mesh = diffcheck_bindings.dfb_geometry.DFMesh()\n        df_mesh.load_from_PLY(i_path)\n        rh_mesh = df_cvt_bindings.cvt_dfmesh_2_rhmesh(df_mesh)\n\n        # scale  if needed\n        centroid = rh_mesh.GetBoundingBox(True).Center\n        x_form_scale = rg.Transform.Scale(centroid, i_scalef)\n        rh_mesh.Transform(x_form_scale)\n\n        return [rh_mesh]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["mesh", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_9d1a30585a.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nimport numpy as np\n\n\nclass DFColorizeCloud(component):\n    def RunScript(self, i_clouds: System.Collections.Generic.List[Rhino.Geometry.PointCloud]):\n\n        if i_clouds is None:\n            return None\n\n        for cloud in i_clouds:\n            random_color = System.Drawing.Color.FromArgb(\n                np.random.randint(0, 255),\n                np.random.randint(0, 255),\n                np.random.randint(0, 255))\n            for j in range(cloud.Count):\n                cloud[j].Color = random_color\n        return i_clouds\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_af8d177853.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nimport diffCheck.df_cvt_bindings as cvt\n\nclass DFRemoveStatisticalOutliers(component):\n    def RunScript(self, i_cloud: Rhino.Geometry.PointCloud, i_knn : int, i_ratio : float):\n        if i_cloud is None or i_ratio is None or i_knn is None:\n            return None\n\n        df_cloud = cvt.cvt_rhcloud_2_dfcloud(i_cloud)\n        df_cloud.remove_statistical_outliers(nb_neighbors=i_knn, std_ratio=i_ratio)\n        o_cloud = cvt.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        return o_cloud\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_b7841e9feb.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom diffCheck import df_cvt_bindings\n\nclass DFCloudNormalEstimator(component):\n    def RunScript(self,\n            i_cloud: Rhino.Geometry.PointCloud,\n            i_knn: int,\n            i_radius: int,\n            i_switch_mode: bool):\n        o_cloud = Rhino.Geometry.PointCloud()\n\n        if i_cloud is None:\n            return None\n\n        df_cloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n\n        if i_knn is None:\n            i_knn = 100\n\n        if i_switch_mode is None:\n            i_switch_mode = False\n\n        df_cloud.estimate_normals(\n            use_cilantro_evaluator=i_switch_mode,\n            knn=i_knn,\n            search_radius=i_radius\n            )\n\n        o_cloud = df_cvt_bindings.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        return [o_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_bdf3b2dd0d.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck import df_cvt_bindings\n\nclass DFCloudUniformDownsample(component):\n    def RunScript(self,\n        i_cloud: Rhino.Geometry.PointCloud,\n        i_every_k_points: int) -> Rhino.Geometry.PointCloud:\n        if i_cloud is None or i_every_k_points is None:\n            return None\n        df_cloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n        df_cloud.uniform_downsample(i_every_k_points)\n        o_cloud = df_cvt_bindings.cvt_dfcloud_2_rhcloud(df_cloud)\n\n        return [o_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_c4e802429c.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\n\nclass DFDeconstructAssembly(component):\n    def RunScript(self,\n            i_assembly):\n        o_beams = i_assembly.beams\n        return o_beams\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_cc3c15403e.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nfrom diffCheck import df_cvt_bindings\nimport System\n\n\nclass DFBrepToCloud(component):\n    def RunScript(self,\n            i_breps: System.Collections.Generic.IList[Rhino.Geometry.Brep],\n            i_num_points: int):\n        self.meshing_parameters = Rhino.Geometry.MeshingParameters.DefaultAnalysisMesh\n\n        mesh_versions = []\n\n        if i_breps is None or i_num_points is None:\n            return None\n\n        for i_brep in i_breps:\n            if not isinstance(i_brep, Rhino.Geometry.Brep):\n                self.AddRuntimeMessage(RML.Warning, \"Please provide a brep to convert to a cloud\")\n                return None\n            meshes = Rhino.Geometry.Mesh.CreateFromBrep(i_brep, self.meshing_parameters)\n            for mesh in meshes:\n                mesh_versions.append(mesh)\n\n        unified_mesh = mesh_versions[0]\n        unified_mesh.Append(mesh_versions)\n        unified_mesh.Faces.ConvertQuadsToTriangles()\n        df_mesh = df_cvt_bindings.cvt_rhmesh_2_dfmesh(unified_mesh)\n        df_cloud = df_mesh.sample_points_uniformly(i_num_points)\n        rgpoints = [Rhino.Geometry.Point3d(pt[0], pt[1], pt[2]) for pt in df_cloud.points]\n        rh_cloud = Rhino.Geometry.PointCloud(rgpoints)\n        print(rh_cloud)\n        return [rh_cloud]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["classes", "point", "brep", "functions", "mesh", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_ccf997f1a0.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\n\nimport diffCheck\nimport diffCheck.df_cvt_bindings\nimport diffCheck.df_util\nfrom diffCheck import diffcheck_bindings\n\nclass DFTester(component):\n    def RunScript(self):\n        # version\n        ghenv.Component.Message = f\"diffCheck v: {diffCheck.__version__}\"  # noqa: F821\n\n        # bindings\n        is_binding_imported = diffcheck_bindings.dfb_test.test()\n        if not is_binding_imported:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Bindings not imported.\")  # noqa: F821\n        else:\n            ghenv.Component.AddRuntimeMessage(RML.Remark, \"Bindings imported.\")  # noqa: F821\n        print(f\"diffCheck test: {diffCheck.df_cvt_bindings.test_bindings()}\")\n\n        # workspace unit\n        scalef = diffCheck.df_util.get_doc_2_meters_unitf()\n        if scalef != 1.0:\n            ghenv.Component.AddRuntimeMessage(RML.Warning, \"Workspace unit is not in meters.\")  # noqa: F821\n        else:\n            ghenv.Component.AddRuntimeMessage(RML.Remark, \"Workspace unit is in meters.\")  # noqa: F821\n\n        return is_binding_imported\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_d0575cfc59.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\n\nimport Rhino\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nfrom diffCheck.diffcheck_bindings import dfb_segmentation\n\nfrom diffCheck import df_cvt_bindings\n\n\nclass DFCloudNormalSegmentator(component):\n    def RunScript(self,\n        i_cloud: Rhino.Geometry.PointCloud,\n        i_normal_threshold_degree=None,\n        i_min_cluster_size=None,\n        i_use_knn_neighborhood=None,\n        i_knn_neighborhood_size=None,\n        i_radius_neighborhood_size=None\n    ) -> Rhino.Geometry.PointCloud:\n\n        if i_cloud is None:\n            return None\n\n        o_clusters = []\n        df_cloud = df_cvt_bindings.cvt_rhcloud_2_dfcloud(i_cloud)\n\n        if i_normal_threshold_degree is None:\n            i_normal_threshold_degree = 20\n        if i_min_cluster_size is None:\n            i_min_cluster_size = 10\n        if i_use_knn_neighborhood is None:\n            i_use_knn_neighborhood = True\n        if i_knn_neighborhood_size is None:\n            i_knn_neighborhood_size = 30\n        if i_radius_neighborhood_size is None:\n            i_radius_neighborhood_size = 0.1\n\n        o_clusters = dfb_segmentation.DFSegmentation.segment_by_normal(\n            point_cloud=df_cloud,\n\n            normal_threshold_degree=i_normal_threshold_degree,\n            min_cluster_size=i_min_cluster_size,\n            use_knn_neighborhood=i_use_knn_neighborhood,\n            knn_neighborhood_size=i_knn_neighborhood_size,\n            radius_neighborhood_size=i_radius_neighborhood_size\n        )\n\n        return [df_cvt_bindings.cvt_dfcloud_2_rhcloud(cluster) for cluster in o_clusters]\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["point", "classes", "functions", "RhinoCommon"], "original_file": "diffCheckOrg_diffCheck_d94cc825d7.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport System\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\n\nclass DFDeconstructBeam(component):\n    def RunScript(self, i_beams: System.Collections.Generic.List[object]):\n        o_side_faces, o_joint_faces, o_joint_ids = [], [], []\n\n        for i_b in i_beams:\n            o_side_faces = [f.to_brep_face() for f in i_b.side_faces]\n            o_joint_faces = [f.to_brep_face() for f in i_b.joint_faces]\n            o_joint_ids = [f.joint_id for f in i_b.joint_faces]\n\n        return o_side_faces, o_joint_faces, o_joint_ids\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["brep", "classes", "functions"], "original_file": "diffCheckOrg_diffCheck_e11acdecd6.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'RunScript' for Rhino scripting", "code": "#! python3\n\nimport diffCheck\nfrom diffCheck.df_geometries import DFBeam, DFAssembly\n\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nimport System\n\nclass DFMergeAssemblies(component):\n    def RunScript(self,\n                  i_new_name: str,\n                  i_assemblies: System.Collections.Generic.IList[diffCheck.df_geometries.DFAssembly]\n                  ) -> diffCheck.df_geometries.DFAssembly:\n\n        beams = System.Collections.Generic.List[DFBeam]()\n        for assembly in i_assemblies:\n            for beam in assembly.beams:\n                beams.Add(beam)\n\n        o_assembly = DFAssembly(beams, i_new_name)\n\n        return o_assembly\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "diffCheckOrg_diffCheck_ffc95fc4c6.json", "repo": "diffCheckOrg/diffCheck"}
{"instruction": "Implement the function 'ml_prediction3' for Rhino scripting", "code": "from flask import Flask\r\nimport ghhops_server as hs\r\nimport rhino3dm\r\nimport myml\r\n\r\napp = Flask(__name__)\r\nhops = hs.Hops(app)\r\n\r\n@hops.component(\r\n     \"/ml_prediction3\",\r\n     name=\"ML_prediction\",\r\n     description=\"Get the features, output the predictions\",\r\n     icon=\"smaller.png\",\r\n     inputs=[\r\n         hs.HopsNumber(\"Min_Depth\", \"Min_Depth\", \"First Metric\"),\r\n         hs.HopsNumber(\"Max_Depth\", \"Max_Depth\", \"Second Metric\"),\r\n         hs.HopsNumber(\"Min_Heigth\", \"Min_Heigth\", \"Second Metric\"),\r\n         hs.HopsNumber(\"Max_Heigth\", \"Max_Heigth\", \"Second Metric\"),\r\n         hs.HopsNumber(\"Volume\", \"Volume\", \"Second Metric\"),\r\n         hs.HopsNumber(\"Area\", \"Area\", \"Second Metric\"),\r\n         hs.HopsNumber(\"Green_area\", \"Green_area\", \"Second Metric\"),\r\n         hs.HopsNumber(\"FAR\", \"FAR\", \"Second Metric\"),\r\n     ],\r\n     outputs=[\r\n         hs.HopsNumber(\"radiation\", \"radiation\", \"ml pedricted values\"),\r\n         hs.HopsNumber(\"green_comfort\", \"green_comfort\", \"ml pedricted values\"),\r\n         hs.HopsNumber(\"energy\", \"energy\", \"ml pedricted values\"),\r\n     ]\r\n)\r\n\r\ndef ml_prediction3(Min_Depth, Max_Depth, Min_Heigth, Max_Heigth, Volume, Area, Green_area, FAR):\r\n    prediction = myml.predictions(Min_Depth, Max_Depth, Min_Heigth, Max_Heigth, Volume, Area, Green_area, FAR)\r\n\r\n    radiation = prediction[0]\r\n    green_comfort = prediction[1]\r\n    energy = prediction[2]\r\n\r\n    return radiation, green_comfort, energy\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app.run()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["functions"], "original_file": "germanbodenbender_MACAD-AIA-COM_VISION-URBANAI_cafa148e59.json", "repo": "germanbodenbender/MACAD-AIA-COM_VISION-URBANAI"}
{"instruction": "Implement the function 'pointat' for Rhino scripting", "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm\nimport numpy as np\n\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n\n@hops.component(\n    \"/pointat\",\n    name=\"PointAt\",\n    description=\"Get point along curve\",\n    icon=\"examples/pointat.png\",\n    inputs=[\n        hs.HopsCurve(\"Curve\", \"C\", \"Curve to evaluate\"),\n        hs.HopsNumber(\"t\", \"t\", \"Parameter on Curve to evaluate\"),\n    ],\n    outputs=[\n        hs.HopsPoint(\"P\", \"P\", \"Point on curve at t\")\n    ]\n)\ndef pointat(curve, t):\n    return curve.PointAt(t)\n\npython runPyrhon.py\n\nif __name__ == \"__main__\":\n    app.run()", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["curve", "functions", "point"], "original_file": "germanbodenbender_MACAD-AIA-GEO_OPT_601328be99.json", "repo": "germanbodenbender/MACAD-AIA-GEO_OPT"}
{"instruction": "Implement the function 'run_grasshopper' for Rhino scripting", "code": "import viktor as vkt\nimport json\nimport rhino3dm\nfrom pathlib import Path\n\n\nclass Parametrization(vkt.Parametrization):\n    intro = vkt.Text(\"## Grasshopper app \\n This app parametrically generates and visualizes a 3D model of a box using a Grasshopper script. \\n\\n Please fill in the following parameters:\")\n\n    # Input fields\n    width = vkt.NumberField('Width', default=5)\n    length = vkt.NumberField('Length', default=6)\n    height = vkt.NumberField('Height', default=7)\n\n\nclass Controller(vkt.Controller):\n    parametrization = Parametrization\n\n    @vkt.GeometryView(\"Geometry\", duration_guess=10, x_axis_to_right=True, update_label='Run Grasshopper')\n    def run_grasshopper(self, params, **kwargs):\n        grasshopper_script_path = Path(__file__).parent / \"sample_box_grasshopper.gh\"\n        script = vkt.File.from_path(grasshopper_script_path)\n        input_parameters = dict(params)\n\n        # Run the Grasshopper analysis and obtain the output data\n        analysis = vkt.grasshopper.GrasshopperAnalysis(script=script, input_parameters=input_parameters)\n        analysis.execute(timeout=30)\n        output = analysis.get_output()\n        \n        # Convert output data to mesh\n        file3dm = rhino3dm.File3dm()\n        obj = rhino3dm.CommonObject.Decode(json.loads(output[\"values\"][0][\"InnerTree\"]['{0}'][0][\"data\"]))\n        file3dm.Objects.Add(obj)\n        \n        # Write to geometry_file\n        geometry_file = vkt.File()\n        file3dm.Write(geometry_file.source, version=7)\n        return vkt.GeometryResult(geometry=geometry_file, geometry_type=\"3dm\")\n        ", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["mesh", "classes", "functions"], "original_file": "hezronkimutai_editor_3f41e54689.json", "repo": "hezronkimutai/editor"}
{"instruction": "Implement the function 'pointat' for Rhino scripting", "code": "from flask import Flask\nimport ghhops_server as hs\nimport rhino3dm\n\n# register hops app as middleware\napp = Flask(__name__)\nhops = hs.Hops(app)\n\n@hops.component(\n    \"/pointat\",\n    name=\"PointAt\",\n    description=\"Get point along curve\",\n    inputs=[\n        hs.HopsCurve(\"Curve\", \"C\", \"Curve to evaluate\"),\n        hs.HopsNumber(\"t\", \"t\", \"Parameter on Curve to evaluate\", default=2.0),\n    ],\n    outputs=[\n        hs.HopsPoint(\"P\", \"P\", \"Point on curve at t\")\n    ],\n)\ndef pointat(curve:rhino3dm.Curve, t:float):\n    return curve.PointAt(t)\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhino3dm", "tags": ["curve", "functions", "point"], "original_file": "hrntsm_study-language_634bb34446.json", "repo": "hrntsm/study-language"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "#! python3\n\nimport sys\nimport os\nimport time\nimport io\n\nimport System\n\nimport Grasshopper\nimport Grasshopper as gh\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nfrom ghpythonlib.componentbase import executingcomponent as component\n\nimport Rhino\nimport Rhino.Geometry as rg\n\nimport typing\n\nimport ACPy\nimport ACPy.ac_util\n\n\nTOL_DOC = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\nACTIVE_DOC = Rhino.RhinoDoc.ActiveDoc\n\n\nclass ACPyBeamFinder(component):\n    def __init__(self):\n        super(ACPyBeamFinder, self).__init__()\n        self._var_output = []\n\n    def RunScript(self,\n        i_beam_name : str = \"\",\n    ):\n        ghenv.Component.Message = f\"ACPyApp v{ACPy.__version__}\"\n\n        # retrieve the beams\n        found_breps = ACPy.ac_util.find_beam_by_name(i_beam_name)\n        ghdoc = ACTIVE_DOC\n\n        # scale the beams for visualization\n        for brep in found_breps:\n            centroid = brep.GetBoundingBox(True).Center\n            scale = rg.Transform.Scale(centroid, 1.1)\n            brep.Transform(scale)\n\n        o_found = found_breps\n\n        return o_found\n\n############################################################################################\n## only for DEBUG: erase before componentize\n############################################################################################\nif __name__ == \"__main__\":\n    \n    comp = ACPyBeamFinder()\n    o_found = comp.RunScript(\n        i_beam_name\n    )\n", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "RhinoCommon", "tags": ["brep", "classes", "functions", "RhinoCommon"], "original_file": "ibois-epfl_augmented-carpentry_b728c7ff1e.json", "repo": "ibois-epfl/augmented-carpentry"}
{"instruction": "Implement the function '__init__' for Rhino scripting", "code": "import time\n\nimport rhinoscript as rs\nimport scriptcontext as sc\n\nimport Rhino as r\n\n\nclass Loop(object):\n    def __init__(self, fps=25):\n        self.callbacks = []\n        self.delta = 1.0 / fps\n        self.running = False\n\n    def update(self):\n        td = time.time() - self.time\n        if td > self.delta:\n            self.time = time.time()\n            [callback(td) for callback in self.callbacks]\n            self.redraw()\n\n    def add_callback(self, callback):\n        self.callbacks.append(callback)\n\n    def remove_callback(self, callback):\n        try:\n            self.callbacks.remove(callback)\n        except ValueError:\n            return False\n\n        return True\n\n    def start(self):\n        self.running = True\n        self.time = time.time()\n        while True:\n            if not self.running:\n                return\n\n            self.update()\n\n    def stop(self):\n        self.running = False\n        self.redraw()\n\n    def redraw(self):\n        rs.document.EnableRedraw()\n        sc.doc.Views.Redraw()\n        r.RhinoApp.Wait()\n        rs.document.EnableRedraw(False)", "source": "backlabeled", "category": "backlabeled", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["classes", "functions"], "original_file": "matthiasbreuer_rhino-animation_082a184b3d.json", "repo": "matthiasbreuer/rhino-animation"}
