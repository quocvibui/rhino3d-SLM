{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Condensation%20calculator.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Condensation calculator.py",
  "instruction": "Use this component to calculate the Dew Point, Relative Humidity and Condensation on each layer of a wall. It accounts the air films (internal and...",
  "code": "# Condensation calculator\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2017, Abraham Yezioro <ayez@technion.ac.il> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to calculate the Dew Point, Relative Humidity and Condensation on each layer of a wall. It accounts the air films (internal and external).\nSources:\nhttp://andrew.rsmas.miami.edu/bmcnoldy/Humidity.html\nhttp://www.ajdesigner.com/phphumidity/dewpoint_equation_dewpoint_temperature.php#ajscroll\nhttp://forums.finehomebuilding.com/breaktime/energy-heating-insulation/dewpoint-spreadsheet\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _cnstrName: EnergyPlus construction name\n        surfaceType_: An integer value from 0 to 3 that represents one of the following surface types:\n                       0 - Exterior Wall/Window\n                       1 - Exterior Roof\n                       2 - Exposed Floor\n        _internalTemp: Indoors temperature of room\n        _outTemp: Outdoors temperature of room\n        _internalRelativeHumidity: Indoors relative humidity\n        _basePoint_: An optional point with which to locate the 3D chart in the Rhino Model.  The default is set to the Rhino origin at (0,0,0).\n        _scale_: The scale of the surface type section. The default is set to 1.\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        layerName_: If bakeIt_ is set to \"True\", input Text here corresponding to the Rhino layer onto which the resulting mesh and legend should be baked.\n\n    Returns:\n        readMe!: ...\n        materials: List of materials (from outside to inside). Includes film Air layers. Ordered from Inside to Outside layers. They include Air Films.\n        comments: Comments for each layer of materials if any. Ordered from Inside to Outside layers\n        rWall: \n        tempWall: temperature for each layer in wall (outter edge of layer). Ordered from Inside to Outside layers\n        rhWall: relative humdity for each layer in wall (outter edge of layer). Ordered from Inside to Outside layers\n        dewPointWall: Dew Point for each layer in wall (outter edge of layer). Ordered from Inside to Outside layers\n        condensationWall: State the status of condensation on wall (Yes or No). Ordered from Inside to Outside layers\n        ::::::::::::::::::::::::::::::::::::::\n        layersWallGeo: \n        resultLines: \n        resultLinesColors: \n        scaleRH_TempGeo: \n        allLabels: \n        ::::::::::::::::::::::::::::::::::::::\n        finalJoinedMesh: \n        legend: \n        allLabels: \n        wallLegendCoord: \n        allDataCurves: \n        textSize: \n        decimalPlaces: \n\"\"\"\n#\nghenv.Component.Name = \"Honeybee_Condensation calculator\"\nghenv.Component.NickName = 'HB_CondensationCalculator'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"13 | WIP\"\n#compatibleHBVersion = VER 0.0.56\\nFEB_01_2015\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport ghpythonlib.components as ghc\nimport math\nimport System\nfrom System import Object\n\nmeshingP = rc.Geometry.MeshingParameters.Coarse\nmeshingP.SimplePlanes = True\nlb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nlb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n\n\nimport Grasshopper.Kernel as gh\nw = gh.GH_RuntimeMessageLevel.Warning\n\n\ndef checkInputs():\n    checkData = False\n    surfaceType = 0\n    if surfaceType_:\n        try:\n            surfaceType = surfaceType_\n        except:\n            surfaceType = 0\n    \n    checkData1 = False\n    checkData2 = False\n    checkData3 = False\n    checkData4 = False\n    if _cnstrName:\n        try: \n            checkData1 = True\n        except: pass\n    else:\n        warning = \"Connect a valid Construction.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    if _internalTemp:\n        try: checkData2 = True\n        except: pass\n    else:\n        warning = \"Connect a value for indoor temperature.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    if _outTemp != None:\n        try: checkData3 = True\n        except: pass\n    else:\n        warning = \"Connect a value for outdoor temperature.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    if _internalRelativeHumidity != None:\n        try: checkData4 = True\n        except: pass\n    else:\n        warning = \"Connect a value for indoor relative humidity.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    if checkData1 and checkData2 and checkData3 and checkData4:\n        checkData = True\n    return checkData, surfaceType\n\ndef getConstructionName(cnstrName):\n    # Make sure Honeybee is flying\n    if not sc.sticky.has_key('honeybee_release'):\n        print \"You should first let Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee to fly...\")\n        return -1\n\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \" Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    try:\n        hb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\n    except:\n        msg = \"Failed to load EP constructions!\"\n        ghenv.Component.AddRuntimeMessage(w, msg)\n        return -1\n    \n    return hb_EPMaterialAUX.decomposeEPCnstr(cnstrName.upper())\n    \ndef getMaterial(matName):\n    if not sc.sticky[\"honeybee_release\"]:\n        print \"You should first let Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee to fly...\")\n        return -1\n\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \" Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    # get the constuction\n    try:\n        hb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\n    except:\n        msg = \"Failed to load EP constructions!\"\n        ghenv.Component.AddRuntimeMessage(w, msg)\n        return -1\n    \n    if sc.sticky.has_key(\"honeybee_materialLib\"):\n        result = hb_EPMaterialAUX.decomposeMaterial(matName.upper(), ghenv.Component)\n        if result == -1:\n            warning = \"Failed to find \" + matName + \" in the Honeybee material library.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        return result\n\n#def calculateData():\ndef main(surfaceType, layerColors, sectHeight):\n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n            \n        # Create an instance of the lb_preparation class \n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n    \n    nameMaterial_rev    = None\n    thicknessMat_rev    = None\n    conductivityMat_rev = None\n    rMaterial_rev       = None\n    rWall_rev           = None\n    newRValue           = None\n    rWallCumulPerc      = None\n    tempOuterEdge       = None\n    dpTemp              = None\n    rhOutter            = None\n    condensation        = None\n    \n    try:  \n        if surfaceType == None or surfaceType == 0 or surfaceType == 1 or surfaceType == 2:\n            #Get the value of R-Value added to the air film.\n            addedRout = 0.04   # Exterior wall (0.04 + 0.13)\n            if surfaceType == None:    \n                addedRin  = 0.13   # Exterior wall (0.04 + 0.13)\n                print \"Default surface type set to an exterior wall.\"\n            elif surfaceType == 0:     addedRin  = 0.13   # Exterior wall (0.04 + 0.13)\n            elif surfaceType == 1:     addedRin  = 0.10   # Roof          (0.04 + 0.10)\n            elif surfaceType == 2:     addedRin  = 0.17   # Roof          (0.04 + 0.17)\n\n        else:\n            msg = \"surfaceType_ must be an integer between 0 and 2.\"\n            ghenv.Component.AddRuntimeMessage(w, msg)\n            return -1\n    except:\n        msg = \"Failed to calculate UValue and R-Value with air films.\"\n        ghenv.Component.AddRuntimeMessage(w, msg)\n        return -1\n        \n    if _cnstrName != None:\n        data = getConstructionName(_cnstrName)                  #Call getConstructionName and get the data cor this CONSTRUCTION\n        \n        if data!=-1:\n            materials, comments, UValue_SI, UValue_IP = data    #Separate the data\n            \n            if UValue_SI and UValue_IP:\n                R_WallValue_SI = 1/UValue_SI                    #This is the r value (no air films) for the wall\n                R_WallValue_IP = 1/UValue_IP\n    \n            thicknessMat    = []\n            conductivityMat = []\n            nameMaterial    = []\n            rMaterial       = []\n            rWall           = []\n            thicknessMat.append(0.01)\n            conductivityMat.append(1 / addedRout)\n            nameMaterial.append('Air Film  Out')\n            rWall.append(addedRout)\n            for materialName in materials:\n                matData = getMaterial(materialName)\n                nameMaterial.append(materialName)\n        \n                if matData != -1:\n                    values, comments, UValue_SI, UValue_IP = matData\n                    thicknessMat.append(float(values[2]))\n                    conductivityMat.append(float(values[3]))\n                    \n                    names = materialName\n                    if UValue_SI and UValue_IP:\n                        RValue_SI = 1 / UValue_SI               #This is the r value (no air films) for the material layer\n                        RValue_IP = 1 / UValue_IP\n                        rMaterial.append(RValue_SI)\n                        rWall.append(RValue_SI)\n    \n            thicknessMat.append(0.01)\n            conductivityMat.append(1 / addedRin)\n            nameMaterial.append('Air Film In')\n            rWall.append(addedRin)\n            newRValue = addedRout + R_WallValue_SI + addedRin\n            \n            ############################################    There is a need to reverse the lists becouse the calculations go from the hotter side to the cooler one (inside to outside)\n            rWall_rev           = rWall[::-1]\n            thicknessMat_rev    = thicknessMat[::-1]\n            conductivityMat_rev = conductivityMat[::-1]\n            nameMaterial_rev    = nameMaterial[::-1]\n            rMaterial_rev       = rMaterial[::-1]\n            ############################################\n            \n            deltaTemp      = _internalTemp - _outTemp\n            rWallPerc      = []                                 #Percentage of influence of each wall layer according to it's r value in ralation to the r of the whole wall\n            rWallCumulPerc = []                                 #Cumulative Percentage of influence of each wall layer, starting from the outside layer\n            tempOuterEdge  = []                                 #Temperature of each wall layer on it's outter edge\n            \n            #for m in rWall:\n            for m in rWall_rev:\n                rWallPerc.append(m / newRValue)\n            rWallCumulPerc.append(rWallPerc[0])\n            tempOuterEdge.append(_internalTemp - (rWallCumulPerc[0] * deltaTemp))\n            \n            for y in range(1, len(rWall)):\n                rWallCumulPerc.append(rWallCumulPerc[y - 1] + rWallPerc[y])\n                tempOuterEdge.append(_internalTemp - (rWallCumulPerc[y] * deltaTemp))\n            \n            dpTemp   =     []    # Dew Point Temperature\n            rhOutter =     []    # Relative Humidity Outter edge of layer\n            condensation = []    # Condensation Outter edge of layer\n            \n            #firstDewPoint = (math.pow(_internalRelativeHumidity / 100, 1/8) * (112 + 0.9 * _internalTemp) + 0.1* _internalTemp - 112) # Other option for equation\n            firstDewPoint = (243.04 * (math.log(_internalRelativeHumidity / 100) + ((17.625 * _internalTemp) / (243.04 + _internalTemp))) / \\\n                             (17.625 - math.log(_internalRelativeHumidity / 100) - ((17.625 * _internalTemp) / (243.04 + _internalTemp))))\n            \n            #for y in range(len(rWall)):\n            for y in range(len(rWall_rev)):\n                if y == 0:\n                    rh = 100*(math.exp((17.625 * firstDewPoint) / (243.04 + firstDewPoint)) / math.exp((17.625 * tempOuterEdge[0]) / (243.04 + tempOuterEdge[0])))\n                else:\n                    rh = 100*(math.exp((17.625 * dpTemp[y - 1]) / (243.04 + dpTemp[y - 1])) / math.exp((17.625 * tempOuterEdge[y]) / (243.04 + tempOuterEdge[y])))\n                if rh > 100: \n                    rh = 100\n                    condensation.append('YES')\n                else: \n                    condensation.append('NO')\n                    \n                rhOutter.append(rh)\n                dpTemp.append(243.04 * (math.log(rhOutter[y] / 100) + ((17.625 * tempOuterEdge[y]) / (243.04 + tempOuterEdge[y]))) / \\\n                              (17.625 - math.log(rhOutter[y] / 100) - ((17.625 * tempOuterEdge[y]) / (243.04 + tempOuterEdge[y]))))\n                              \n    layersWallGeo, onlyMesh, resultLines, resultLinesColors, titleCoord, wallSectCoord, wallLegendCoord = \\\n                    drawSection(surfaceType, nameMaterial_rev, thicknessMat_rev, conductivityMat_rev, rWall_rev, newRValue, rWallCumulPerc, tempOuterEdge, dpTemp, \\\n                    rhOutter, condensation, layerColors, sectHeight)\n\n    return layersWallGeo, onlyMesh, resultLines, resultLinesColors, titleCoord, wallSectCoord, wallLegendCoord, \\\n           nameMaterial_rev, thicknessMat_rev, conductivityMat_rev, rWall_rev, newRValue, rWallCumulPerc, tempOuterEdge, dpTemp, rhOutter, condensation, \\\n           lb_visualization, lb_preparation\n\ndef calcSectCoords(surfaceType, materials, thicknessMat, conductivityMat, rWall, newRValue, rWallCumulPerc, tempWall, dewPointWall, rhWall, condensationWall, layerColors, invWall, wFactor, sectHeight):\n    vertColor       = []\n    layersWallMesh  = []\n    initX           = 0.0\n    initY           = -(sectHeight / 4)\n    vertLinks       = [(0,1,2,3)] # list of vertices order for linking into one mesh\n    colMesh         = []\n    onlyMesh        = []\n    wallSectCoord   = []\n    wallLegendCoord = []\n    delta           = sectHeight / len(materials)\n    titleCoord      = rc.Geometry.Point3d( invWall * initX, sectHeight + sectHeight / 15., 0.)\n\n    for layerInd in range(len(materials)):\n        vertColor.append([])\n        vertColor[layerInd].append([])\n        \n        if conductivityMat[layerInd] < 0.09:\n            tmpColor = layerColors[0] #Insulation\n        elif conductivityMat[layerInd] > 5.0:\n            tmpColor = layerColors[3] #AirFilm\n        else:\n            tmpColor = layerColors[2] #Opaque\n        \n        vCoord = []\n        vCoord.append(rc.Geometry.Point3d( invWall * initX,                                      0.,         0.))\n        vCoord.append(rc.Geometry.Point3d( invWall * (initX + thicknessMat[layerInd] * wFactor), 0.,         0.))\n        vCoord.append(rc.Geometry.Point3d( invWall * (initX + thicknessMat[layerInd] * wFactor), sectHeight, 0.))\n        vCoord.append(rc.Geometry.Point3d( invWall * initX,                                      sectHeight, 0.))\n        vCoord.append(rc.Geometry.Point3d( invWall * initX,                                      0.,         0.))\n        \n        p1 = invWall * initX\n        p2 = invWall * (initX + thicknessMat[layerInd] * wFactor)\n        p3 = (p2 - p1) / 3.\n        p4 = p1 + p3\n        wallSectCoord.append(rc.Geometry.Point3d( p4, -(sectHeight / 15.), 0.))\n        wallLegendCoord.append(rc.Geometry.Point3d( 0., initY, 0.))\n        \n        initX += thicknessMat[layerInd] * wFactor   # Advance the initX for next iteration\n        initY -= delta                              # Advance the initY for next iteration\n        # Wall layers mesh #########################################\n        dataPolyline = rc.Geometry.PolylineCurve(vCoord)\n        meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n        # Generate the color list for all the vertices on the wall layer\n        repeatedColors = []\n        for face in range(meshedC.Faces.Count):\n            repeatedColors.append(tmpColor)\n    \n        # Use ladybug functions to color the mesh\n        onlyMesh.append(lb_visualization.colorMesh(repeatedColors, meshedC))\n        colMesh.append( lb_visualization.colorMesh(repeatedColors, meshedC))\n        colMesh.append( dataPolyline)        # This is the colored mesh for each wall layer\n        ############################################################\n\n        #Wall layers contour #######################################\n        dataPolyline = rc.Geometry.PolylineCurve(vCoord)\n        meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n\n        # Will offset the contour of the layers so they can be colored in black, also they will have some thickness.\n        layerContour = outlineCurve(dataPolyline, wFactor)\n        comfortMesh = rc.Geometry.Mesh()\n        comfortMesh.Append(rc.Geometry.Mesh.CreateFromBrep(layerContour)[0])\n        comfortMesh.VertexColors.CreateMonotoneMesh(layerColors[4])        # This is the colored line for each wall layer\n        colMesh.append(comfortMesh)\n        ############################################################\n        \n    return colMesh, onlyMesh, titleCoord, wallSectCoord, wallLegendCoord\n\ndef calcRHCoords(surfaceType, rhWall, invWall, wFactor, sectHeight, thicknessMat):\n    vertColor      = []\n    layersWallMesh = []\n    initX          = 0.0\n    vertLinks      = [(0,1,2,3)] # list of vertices order for linking into one mesh\n    colMesh        = []\n    sclRH          = sectHeight / 105     # Giving 105 just in case 100%RH\n    vCoord = []\n    vCoord.append(rc.Geometry.Point3d( (invWall * initX) - 0.10, _internalRelativeHumidity * sclRH, 0.))    # Point for initial RH given at the input\n    vCoord.append(rc.Geometry.Point3d( (invWall * initX),        _internalRelativeHumidity * sclRH, 0.))    # Point for first RH on wall\n    for layerInd in range(len(rhWall)):\n        vCoord.append(rc.Geometry.Point3d( invWall * (initX + thicknessMat[layerInd] * wFactor), rhWall[layerInd] * sclRH, 0.))\n        initX += thicknessMat[layerInd] * wFactor   # Advance the initX for next iteration\n\n    return vCoord\n    \ndef calcTemp_DPCoords(surfaceType, data, invWall, wFactor, sectHeight, thicknessMat):\n    vertColor      = []\n    layersWallMesh = []\n    initX          = 0.0\n    vertLinks      = [(0,1,2,3)] # list of vertices order for linking into one mesh\n    colMesh        = []\n    #tempDiff       = _internalTemp + abs(_outTemp) + 1\n    tempDiff       = _internalTemp - _outTemp + 1\n    \n    sclTemp        = sectHeight / tempDiff     # Takes the difference between inside and outside temperatures\n    \n    outTempFix = (_internalTemp + 1) * sclTemp\n    if outTempFix >= 1.: outTempFix = outTempFix - 1.0\n    else: outTempFix = -(1 - outTempFix)\n    \n    vCoord = []\n    vCoord.append(rc.Geometry.Point3d( (invWall * initX) - 0.10, _internalTemp * sclTemp - outTempFix, 0.))    # Point for initial Temp/DP given at the input\n    vCoord.append(rc.Geometry.Point3d( (invWall * initX),        _internalTemp * sclTemp - outTempFix, 0.))    # Point for first Temp/DP on wall\n    \n    for layerInd in range(len(data)):\n        vCoord.append(rc.Geometry.Point3d( invWall * (initX + thicknessMat[layerInd] * wFactor), data[layerInd] * sclTemp - outTempFix, 0.))\n        initX += thicknessMat[layerInd] * wFactor   # Advance the initX for next iteration\n        \n    return vCoord\n    \ndef drawLines(vCoord, wFactor, indRes):\n    #Wall layers contour #######################################\n    colMesh        = []\n    dataPolyline = rc.Geometry.PolylineCurve(vCoord)\n    #meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n    #print meshedC\n    colMesh.append(dataPolyline)        # This is the colored mesh for each wall layer\n    \n    \"\"\"\n    # Will offset the contour of the layers so they can be colored in black, also they will have some thickness.\n    layerContour = outlineCurve(dataPolyline, wFactor)\n    comfortMesh = rc.Geometry.Mesh()\n    comfortMesh.Append(rc.Geometry.Mesh.CreateFromBrep(layerContour)[0])\n    comfortMesh.VertexColors.CreateMonotoneMesh(layerColors[4])        # This is the colored line for each wall layer\n    colMesh.append(comfortMesh)\n    ############################################################\n    \"\"\"\n    \n    #return colMesh\n    return dataPolyline\n\ndef drawSection(surfaceType, materials, thicknessMat, conductivityMat, rWall, newRValue, rWallCumulPerc, tempWall, dewPointWall, rhWall, condensationWall, layerColors, sectHeight):\n    minTemp    = min(tempWall)\n    maxTemp    = max(tempWall)\n    minRH      = min(rhWall)\n    maxRH      = max(rhWall)\n    invWall    = 1          # -(1) To draw the wall while indoors is at the right of the section. Check whay happens with Roof/Floor\n    wFactor    = 4          # To change the width of the section ... Check if needed???\n    #sectHeight = 1.0        # Set the height of the section\n    #print 'minTemp = %.2f \\tmaxTemp = %.2f ' % (minTemp, maxTemp)\n    #print 'minRH = %.2f \\tmaxRH = %.2f '     % (minRH, maxRH)\n    #print 'internalTemp = %.1f \\toutTemp = %.1f \\tinternalRelativeHumidity = %.1f' % (_internalTemp, _outTemp, _internalRelativeHumidity)\n    layersWallGeo, onlyMesh, titleCoord, wallSectCoord, wallLegendCoord = calcSectCoords(surfaceType, materials, thicknessMat, conductivityMat, rWall, newRValue, rWallCumulPerc, tempWall, dewPointWall, rhWall, condensationWall, layerColors, invWall, wFactor, sectHeight)\n    wallRH        = calcRHCoords(surfaceType,      rhWall,       invWall, wFactor, sectHeight, thicknessMat)\n    wallTemp      = calcTemp_DPCoords(surfaceType, tempWall,     invWall, wFactor, sectHeight, thicknessMat)\n    wallDP        = calcTemp_DPCoords(surfaceType, dewPointWall, invWall, wFactor, sectHeight, thicknessMat)\n    \n    resLines     = []\n    resLinesCols = []\n    resLines.append(drawLines(wallRH, wFactor,   1))\n    resLinesCols.append(layerColors[6])\n    resLines.append(drawLines(wallTemp, wFactor,   1))\n    resLinesCols.append(layerColors[5])\n    resLines.append(drawLines(wallDP, wFactor,   1))\n    resLinesCols.append(layerColors[7])\n\n    return layersWallGeo, onlyMesh, resLines, resLinesCols, titleCoord, wallSectCoord, wallLegendCoord #linesRH\n\ndef outlineCurve(curve, wFactor):\n    offsetFactor = 0.002 * wFactor\n    offsetCrv = curve.Offset(rc.Geometry.Plane.WorldXY, offsetFactor, sc.doc.ModelAbsoluteTolerance, rc.Geometry.CurveOffsetCornerStyle.Sharp)[0]\n    layerContour = (rc.Geometry.Brep.CreatePlanarBreps([curve, offsetCrv])[0])\n\n    return layerContour\n\ndef colors():\n    layerColors = [System.Drawing.Color.FromArgb(200, 200, 0),   # Insulation Materials - 0\n                   System.Drawing.Color.FromArgb(50, 50, 150),   # Glass Materials      - 1\n                   System.Drawing.Color.FromArgb(150, 150, 150), # Opaque Materials     - 2\n                   System.Drawing.Color.FromArgb(120, 120, 220), # AirFilms             - 3\n                   System.Drawing.Color.FromArgb(0, 0, 0),       # Lines                - 4\n                   System.Drawing.Color.FromArgb(255, 0, 0),     # Red for temperature  - 5\n                   System.Drawing.Color.FromArgb(0, 0, 255),     # Blue for RH          - 6\n                   System.Drawing.Color.FromArgb(255, 153, 0)]   # Orange for DewPoint  - 7\n    return layerColors\n    \ndef drawText(titleCoord, wallSectCoord, wallLegendCoord, materials, thicknessMat, surfaceType, lb_visualization, lb_preparation):\n    allLabels = []\n    \n    textPlane = rc.Geometry.Plane(titleCoord, rc.Geometry.Vector3d(1,0,0),  rc.Geometry.Vector3d(0,1,0))\n    textSrfs = lb_visualization.text2srf([_cnstrName], [titleCoord], 'Verdana', 0.07, False, textPlane)\n    for txt in textSrfs:\n        allLabels.extend(txt)\n        \n    for i in range(len(thicknessMat)):\n        textPlane = rc.Geometry.Plane(wallSectCoord[i], rc.Geometry.Vector3d(1,0,0),  rc.Geometry.Vector3d(0,1,0))\n        textSrfs = lb_visualization.text2srf([str(i)], [wallSectCoord[i]], 'Verdana', 0.05, False, textPlane)\n        for txt in textSrfs:\n            allLabels.extend(txt)\n\n    for i in range(len(thicknessMat)):\n        textPlane = rc.Geometry.Plane(wallLegendCoord[i], rc.Geometry.Vector3d(1,0,0),  rc.Geometry.Vector3d(0,1,0))\n        textSrfs = lb_visualization.text2srf([str(i) + '. ' + materials[i]], [wallLegendCoord[i]], 'Verdana', 0.05, False, textPlane)\n        for txt in textSrfs:\n            allLabels.extend(txt)\n    return allLabels\n\ndef rhText(text, textPts, allLabels, surfaceType, textSize, lb_visualization, lb_preparation):\n    for i in range(len(text)):\n        textPlane = rc.Geometry.Plane(textPts[i], rc.Geometry.Vector3d(1,0,0),  rc.Geometry.Vector3d(0,1,0))\n        textSrfs = lb_visualization.text2srf([text[i]], [textPts[i]], 'Verdana', textSize, False, textPlane)\n        for txt in textSrfs:\n            allLabels.extend(txt)\n    return allLabels\n\ndef scaleRH_Temp(surfaceType, sectHeight, layerColors):\n    scaleRH_TempGeo      = []\n    scaleRH_TempGeoColor = []\n    scaleRH_Text         = []\n    scaleTemp_Text       = []\n    scaleRH_TextPts      = []\n    scaleTemp_TextPts    = []\n    #Create a line that represents the RH/Temp axis.\n    pt1 = rc.Geometry.Point3d(-0.35, 0.,         0.)\n    pt2 = rc.Geometry.Point3d(-0.35, sectHeight, 0.)\n    axisRH = rc.Geometry.LineCurve(pt1, pt2) # Draw a line between these two points making the horizontail axis\n    scaleRH_TempGeo.append(axisRH)\n    scaleRH_TempGeoColor.append(layerColors[6])\n    sclRH = sectHeight / 105     # Giving 105 just in case 100%RH\n    \n    #Piece for Temp scale calcs\n    tempDiff       = _internalTemp - _outTemp + 1\n    sclTemp        = sectHeight / tempDiff     # Takes the difference between inside and outside temperatures\n    outTempFix = (_internalTemp + 1) * sclTemp\n    if outTempFix   >= 1.: outTempFix = outTempFix - 1.0\n    else:                  outTempFix = -(1 - outTempFix)\n    \n    scaleRH_Text.append('RH')\n    scaleTemp_Text.append('Tmp')\n    scaleRH_TextPts.append( rc.Geometry.Point3d(-0.29, sectHeight + 0.015, 0.) )\n    scaleTemp_TextPts.append( rc.Geometry.Point3d(-0.5, sectHeight + 0.015, 0.) )\n    \n    text = 0\n    scRH = rc.Geometry.Curve.DivideByLength(axisRH,sclRH*10, True)\n    for pt in scRH:\n        pt1 = rc.Geometry.Point3d(-0.37, pt, 0.)\n        pt2 = rc.Geometry.Point3d(-0.33, pt, 0.)\n        scaleRH_TempGeo.append(rc.Geometry.LineCurve(pt1, pt2))\n        scaleRH_TempGeoColor.append(layerColors[6])\n        \n        txtTemp = (pt + outTempFix) / sclTemp\n        scaleTemp_Text.append( str( round(txtTemp) ) )\n        \n        scaleRH_Text.append(str(text) + '%')\n        scaleRH_TextPts.append(     rc.Geometry.Point3d(-0.3, pt - 0.015, 0.)   )\n        scaleTemp_TextPts.append(   rc.Geometry.Point3d(-0.52, pt - 0.015, 0.)   )\n        text += 10\n    return scaleRH_TempGeo, scaleRH_TempGeoColor, scaleRH_Text, scaleTemp_Text, scaleRH_TextPts, scaleTemp_TextPts\n\n###########################################################################################\n#Check the inputs.\ncheckData, surfaceType = checkInputs()\n\n#If the inputs are good, GO and do your think\nif checkData == True:\n    layerColors = colors()\n    sectHeight  = 1.0        # Set the height of the section\n    textSize    = 0.04\n    layersWallGeo, onlyMesh, resultLines, resultLinesColors, titleCoord, wallSectCoord, wallLegendCoord, \\\n                   materials, thicknessMat, conductivityMat, rWall, newRValue, rWallCumulPerc, tempWall, dewPointWall, rhWall, condensationWall, \\\n                   lb_visualization, lb_preparation = \\\n                   main(surfaceType, layerColors, sectHeight)\n    \n    allLabels = drawText(titleCoord, wallSectCoord, wallLegendCoord, materials, thicknessMat, surfaceType, lb_visualization, lb_preparation)\n    \n    scaleRH_TempGeo, scaleRH_TempGeoColor, scaleRH_Text, scaleTemp_Text, scaleRH_TextPts, scaleTemp_TextPts = \\\n                scaleRH_Temp(surfaceType, sectHeight, layerColors)      # Draw the scales of RH and Temperature/DewPoint\n    allLabels = rhText(scaleRH_Text,   scaleRH_TextPts,   allLabels, surfaceType, textSize, lb_visualization, lb_preparation)\n    allLabels = rhText(scaleTemp_Text, scaleTemp_TextPts, allLabels, surfaceType, textSize, lb_visualization, lb_preparation)\n    \n    #print 'Construction = ', _cnstrName\n    ##for i in range(len(materials)):\n    ##    print 'Thickness = %.3f \\ttempWall = %.2f \\tDewPoint = %.2f \\ttrhOutter = %.2f \\tcondensation = %s  \\tLayer-%d = %s' % \\\n    ##    (thicknessMat[i], tempWall[i], dewPointWall[i], rhWall[i], condensationWall[i], i, materials[i])\n        \n    #Transform the geometry according to the base point and scale provided on input items.\n    if _scale_ != None:\n        scale = _scale_\n    else: scale = 1\n    if _basePoint_ != None:\n        basePoint = _basePoint_\n    else:\n        basePoint = rc.Geometry.Point3d.Origin\n\n    scaleFinal = rc.Geometry.Transform.Scale(basePoint, scale)\n    move = rc.Geometry.Transform.Translation(basePoint.X, basePoint.Y, basePoint.Z)\n    transformMtx = scaleFinal * move\n    for geo in resultLines:     geo.Transform(transformMtx)\n    for geo in onlyMesh:        geo.Transform(transformMtx)   # This is only for BAKE. Need to find how to check if a geometry is a mesh\n    for geo in layersWallGeo:   geo.Transform(transformMtx)\n    for geo in wallSectCoord:   geo.Transform(transformMtx)   # For numbering the wall layers (1, 2, 3 ..., n) below the wall section geometry\n    for geo in wallLegendCoord: geo.Transform(transformMtx)   # For wall legend. One  below the other for wall section members (Name and results)\n    for geo in allLabels:       geo.Transform(transformMtx)   # For wall legend. One  below the other for wall section members (Name and results)\n    for geo in scaleRH_TempGeo: geo.Transform(transformMtx)   # For wall legend. One  below the other for wall section members (Name and results)\n    titleCoord.Transform(transformMtx)                        # For the Construction Name\n\n\n    #\"\"\"\n    if bakeIt_ > 0:\n        decimalPlaces = 1\n        legend = None\n        allLines = []\n        allLines.extend(resultLines)\n        allLines.extend(scaleRH_TempGeo)\n        print len(resultLines), len(scaleRH_TempGeo), len(allLines)\n        #Make a single mesh for all data.\n        finalJoinedMesh = rc.Geometry.Mesh()\n        ##for meshList in layersWallGeo:\n        ##    for mesh in meshList: finalJoinedMesh.Append(mesh)\n        #$#$for mesh in layersWallGeo:\n        for mesh in onlyMesh:\n            finalJoinedMesh.Append(mesh)\n            #if mesh == rc.DocObjects.ObjectType.Mesh(32):\n            #print type(mesh), mesh\n            #if type(mesh) == 'Mesh':\n            ###print type(mesh)\n            pass\n            #if mesh.IsMesh():\n            #if rc.Geometry.Mesh.IsClosed(mesh):\n            #    finalJoinedMesh.Append(mesh)\n        #Make a single list of curves for all data.\n        allDataCurves = []\n        #for crvList in dataCurves:\n        #    for crv in crvList: allDataCurves.append(crv)\n        #    studyLayerName = 'WallSection'  #'MONTHLY_CHARTS'\n        for crv in allLines: allDataCurves.append(crv)\n        print len(allDataCurves)\n        studyLayerName = 'Wall_Sections'\n        # check the study type\n        try:\n            #if 'key:location/dataType/units/frequency/startsAt/endsAt' in _inputData[0]: placeName = _inputData[1]\n            #else: placeName = _cnstrName        #'alternateLayerName'\n            placeName     = _cnstrName        #'alternateLayerName'\n        except: placeName = _cnstrName        #\n        newLayerIndex, l = lb_visualization.setupLayers(None, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n        #print newLayerIndex, l\n        \n        #@#@if bakeIt_ == 1:   lb_visualization.bakeObjects(newLayerIndex, finalJoinedMesh, legend, allLabels, wallLegendCoord, textSize, 'Verdana', allDataCurves, decimalPlaces, 2)\n        \n        #if bakeIt_ == 1:   lb_visualization.bakeObjects(newLayerIndex, finalJoinedMesh, legend[-1], allLabels, wallLegendCoord, textSize, 'Verdana', graphAxes+allDataCurves, decimalPlaces, 2)\n        #else:              lb_visualization.bakeObjects(newLayerIndex, finalJoinedMesh, legend[-1], allLabels, wallLegendCoord, textSize, 'Verdana', graphAxes+allDataCurves, decimalPlaces, 2, False)\n    #\"\"\"\n\n\"\"\"    \n#Hide(True)/Show(False) outputs\nghenv.Component.Params.Output[1].Hidden   = True     # materials\nghenv.Component.Params.Output[2].Hidden   = True     # comments\nghenv.Component.Params.Output[3].Hidden   = True     # rWall\nghenv.Component.Params.Output[4].Hidden   = True     # tempWall\nghenv.Component.Params.Output[5].Hidden   = False    # rhWall\nghenv.Component.Params.Output[6].Hidden   = False    # dewPointWall\nghenv.Component.Params.Output[7].Hidden   = False    # condensationWall\nghenv.Component.Params.Output[8].Hidden   = False    # ::::::::::::::::::::::::::::::::::::::\nghenv.Component.Params.Output[9].Hidden   = False    # layersWallGeo\nghenv.Component.Params.Output[10].Hidden   = False    # resultLines\nghenv.Component.Params.Output[11].Hidden   = False    # resultLinesColors\nghenv.Component.Params.Output[12].Hidden   = False    # scaleRH_TempGeo\nghenv.Component.Params.Output[13].Hidden   = False    # allLabels\nghenv.Component.Params.Output[14].Hidden   = False    # ::::::::::::::::::::::::::::::::::::::\nghenv.Component.Params.Output[15].Hidden   = False    # finalJoinedMesh\nghenv.Component.Params.Output[16].Hidden   = False    # legend\nghenv.Component.Params.Output[17].Hidden   = False    # allLabels\nghenv.Component.Params.Output[18].Hidden   = False    # wallLegendCoord\nghenv.Component.Params.Output[19].Hidden   = False    # allDataCurves\nghenv.Component.Params.Output[20].Hidden   = False    # textSize\nghenv.Component.Params.Output[21].Hidden   = False    # decimalPlaces\n\"\"\"\nghenv.Component.Params.Output[9].Hidden   = False    # layersWallGeo\nghenv.Component.Params.Output[10].Hidden   = False    # resultLines\nghenv.Component.Params.Output[12].Hidden   = False    # scaleRH_TempGeo\nghenv.Component.Params.Output[13].Hidden   = False    # allLabels\nghenv.Component.Params.Output[15].Hidden   = False    # finalJoinedMesh\nghenv.Component.Params.Output[16].Hidden   = True    # legend\nghenv.Component.Params.Output[17].Hidden   = False    # allLabels\nghenv.Component.Params.Output[18].Hidden   = True    # wallLegendCoord\nghenv.Component.Params.Output[19].Hidden   = False    # allDataCurves\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}