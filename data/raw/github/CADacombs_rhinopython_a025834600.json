{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_createFilletEdges.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_createFilletEdges.py",
  "instruction": "This script is an alternative to _FilletEdge, using RhinoCommon's\r\nBrep.CreateFilletEdges with flexibility in tolerance.\r\n\r\nAdvantage:\r\n    Not only can a start tolerance be specified, but when the...",
  "code": "\"\"\"\r\nThis script is an alternative to _FilletEdge, using RhinoCommon's\r\nBrep.CreateFilletEdges with flexibility in tolerance.\r\n\r\nAdvantage:\r\n    Not only can a start tolerance be specified, but when the main method,\r\n    Brep.CreateFilletEdges, fails, it is recalled with smaller, then optionally,\r\n    larger tolerances.\r\n\r\nLimitations:\r\n    All fillets are constant.\r\n    Fillets are not editable, i.e, _FilletEdge _Edit .\r\n\r\nTo minimize variation from the starting tolerance, it is recommended to fillet\r\neach chain of fillets separately.\r\n\r\nSend any questions, comments, or script development service needs to @spb on\r\nthe McNeel Forums ( https://discourse.mcneel.com/ )\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190903: Created.\r\n191209: Modified an option default value.\r\n221105: Bug fix.  Refactored.\r\n        Disabled bConstantRadius option until UI is updated to better accomodate it.\r\n221108: Bug fix.\r\n221111: Now filters interior edges in main function since GetObject.EnablePreSelect doesn't do this for BrepEdges(/subobjects?).\r\n221112: Added option to increase tolerance when others fillet result fails with other tolerances.\r\n        Now allows input of different size fillets.\r\n\r\nTODO:\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Enum\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadius'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    #key = 'bConstantRadius'; keys.append(key)\r\n    #values[key] = True\r\n    #riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    #stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    #key = 'fRadius_End'; keys.append(key)\r\n    #values[key] = 1.0\r\n    #names[key] = 'EndRadius'\r\n    #riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    #stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iRailType'; keys.append(key)\r\n    values[key] = 1\r\n    listValues[key] = Enum.GetNames(rg.RailType)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_Start'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'StartingTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fTol_Min'; keys.append(key)\r\n    values[key] = 0.0001\r\n    names[key] = 'MinTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bIncrTolOnFail'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol_Max'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'MaxTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadius':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                print(\"Invalid radius input ignored.\")\r\n                return\r\n\r\n            value = 4.0*sc.doc.ModelAbsoluteTolerance\r\n            if cls.riOpts[key].CurrentValue < value:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = value\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                print(\"Radius input was too small and therefore adjusted.\")\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fRadius_End':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                print(\"Invalid radius input ignored.\")\r\n                return\r\n\r\n            value = 4.0*sc.doc.ModelAbsoluteTolerance\r\n            if cls.riOpts[key].CurrentValue < value:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = value\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                print(\"Radius input was too small and therefore adjusted.\")\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fTol_Start':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n                print(\"Tolerance input was too small and therefore adjusted.\")\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fTol_Min':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n                print(\"MinTol input was too small and therefore adjusted.\")\r\n\r\n            if cls.riOpts[key].CurrentValue > cls.riOpts['fTol_Start'].CurrentValue:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts['fTol_Start'].CurrentValue\r\n                print(\"MinTol input was too small and therefore adjusted.\")\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key == 'fTol_Max':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n                print(\"MaxTol input was too small and therefore adjusted.\")\r\n\r\n            if cls.riOpts[key].CurrentValue < cls.riOpts['fTol_Start'].CurrentValue:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts['fTol_Start'].CurrentValue\r\n                print(\"MaxTol input was too small and therefore adjusted.\")\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef getInput(bPrevBrepsArePresent):\r\n    \"\"\"\r\n    Get BrepEdges with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edges to fillet\")\r\n    go.SetCommandPromptDefault(\"Confirm edges & radius\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    go.GeometryAttributeFilter = (\r\n            ri.Custom.GeometryAttributeFilter.MatedEdge |\r\n            ri.Custom.GeometryAttributeFilter.EdgeCurve)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go_Main on repeats of While loop.\r\n    go.EnablePreSelect(True, ignoreUnacceptablePreselectedObjects=True) # This doesn't work for edges.  Maybe it doesn't work for subobjects.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        #Opts.names['fRadius'] = 'Radius' if Opts.values['bConstantRadius'] else 'StartRadius'\r\n        addOption('fRadius')\r\n        #addOption('bConstantRadius')\r\n        #if not Opts.values['bConstantRadius']:\r\n        #    addOption('fRadius_End')\r\n        addOption('iRailType')\r\n        addOption('fTol_Start')\r\n        addOption('fTol_Min')\r\n        addOption('bIncrTolOnFail')\r\n        if Opts.values['bIncrTolOnFail']:\r\n            addOption('fTol_Max')\r\n        if bPrevBrepsArePresent:\r\n            idxs_Opts['UsePrevInput'] = go.AddOption('UsePrevInput')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return []\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = abs(go.Number())\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        if go.Option().Index == idxs_Opts['UsePrevInput']:\r\n            go.Dispose()\r\n            return 'UsePrevInput'\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\nclass DrawRadiusDotsConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.prs = None\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n\r\n    def PostDrawObjects(self, drawEventArgs):\r\n        if not self.prs: return\r\n\r\n        for pt, rad in self.prs:\r\n\r\n            if rad == 0.0:\r\n                continue\r\n\r\n            rc = drawEventArgs.Display.DrawDot(\r\n                worldPosition=pt,\r\n                text=\"{:.{}f}\".format(rad, sc.doc.ModelDistanceDisplayPrecision),\r\n                dotColor=sc.doc.Layers.CurrentLayer.Color,\r\n                textColor=Color.Black if sc.doc.Layers.CurrentLayer.Color != Color.Black else Color.White)\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=None):\r\n    if iPrecision is None:\r\n        iPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n    if fDistance is None:\r\n        return \"(No value provided)\"\r\n    if fDistance == 0.0:\r\n        return \"0\"\r\n    if fDistance < 0.01:\r\n        return \"{:.2e}\".format(fDistance)\r\n    return \"{:.{}g}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef processBrep(rgBrep_In, idxs_rgEdges_In, fRadii_In, bConstantRadius=True, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep_In\r\n        idxs_rgEdges_In\r\n        fRadii\r\n        bConstantRadius\r\n        fRadius_End\r\n        iRailType\r\n        fTol_Start\r\n        fTol_Min\r\n        fTol_Max\r\n        bEcho\r\n        bDebug\r\n\r\n\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    #fRadius_End = getOpt('fRadius_End')\r\n    iRailType = getOpt('iRailType')\r\n    fTol_Start = getOpt('fTol_Start')\r\n    fTol_Min = getOpt('fTol_Min')\r\n    fTol_Max = getOpt('fTol_Max')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if fTol_Min > fTol_Start: fTol_Min = fTol_Start\r\n    if fTol_Max < fTol_Start: fTol_Max = fTol_Start\r\n\r\n\r\n    def filterInteriorEdges(idxs_rgEdges_In, fRadii_In, bEcho=True):\r\n        idxs_rgEs_Out = []\r\n        idxs_Ignored = []\r\n        fRadii_Out = []\r\n        for idxE, fRadius in zip(idxs_rgEdges_In, fRadii_In):\r\n            if rgBrep_In.Edges[idxE].Valence == rg.EdgeAdjacency.Interior:\r\n                idxs_rgEs_Out.append(idxE)\r\n                fRadii_Out.append(fRadius)\r\n            else:\r\n                idxs_Ignored.append(idxE)\r\n        if bEcho and idxs_Ignored:\r\n            print(\"{} non-interior edges are ignored.\".format(len(idxs_Ignored)))\r\n        return idxs_rgEs_Out, fRadii_Out\r\n\r\n\r\n    idxs_rgEdges_WIP, fRadii_WIP = filterInteriorEdges(idxs_rgEdges_In, fRadii_In, bEcho)\r\n\r\n\r\n    def nakedBorderCount(rgBrep):\r\n        necs = rgBrep.DuplicateNakedEdgeCurves(nakedOuter=True, nakedInner=False)\r\n        if necs.Count == 0: return 0\r\n        jcs = rg.Curve.JoinCurves(necs, joinTolerance=1e-7)\r\n        for nec in necs: nec.Dispose()\r\n        ct_Open = [jc.IsClosed for jc in jcs].count(False)\r\n        if ct_Open:\r\n            raise Exception(\"{} border curves are open after JoinCurves.\".format(len(ct_Open)))\r\n        len_jcs = len(jcs)\r\n        for jc in jcs: jc.Dispose()\r\n        return len_jcs\r\n\r\n    ct_Naked_In = nakedBorderCount(rgBrep_In)\r\n\r\n\r\n    def maxEdgeTol(rgBrep):\r\n        return max([edge.Tolerance for edge in rgBrep.Edges])\r\n\r\n    maxEdgeTol_In = maxEdgeTol(rgBrep_In)\r\n\r\n\r\n    fTol_WIP = fTol_Start\r\n    bDecreasingTol = True\r\n\r\n\r\n    def getNextTolerance(fTol_In, fTol_Start, fTol_Min, fTol_Max, bEcho):\r\n\r\n        if fTol_In == fTol_Min:\r\n            if fTol_Max is None or fTol_Max == fTol_Start:\r\n                if bEcho: print(\"Fillet could not be created.\")\r\n                return\r\n            fTol_Out = fTol_Start * 2.0\r\n\r\n            if fTol_Out > fTol_Max:\r\n                return fTol_Max\r\n\r\n            return fTol_Out\r\n\r\n        if fTol_In <= fTol_Start:\r\n            fTol_Out = fTol_In / 2.0\r\n\r\n            if fTol_Out < fTol_Min:\r\n                return fTol_Min\r\n\r\n            return fTol_Out\r\n\r\n        if fTol_In == fTol_Max:\r\n            if bEcho: print(\"Fillet could not be created.\")\r\n            return\r\n\r\n        fTol_Out = fTol_In * 2.0\r\n\r\n        if fTol_Out > fTol_Max:\r\n            return fTol_Max\r\n\r\n        return fTol_Out\r\n\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n\r\n        rgBs_Out = rg.Brep.CreateFilletEdges(\r\n            brep=rgBrep_In,\r\n            edgeIndices=idxs_rgEdges_WIP,\r\n            startRadii=fRadii_WIP,\r\n            endRadii=fRadii_WIP, # if bConstantRadius else TBD,\r\n            blendType=rg.BlendType.Fillet,\r\n            railType=Enum.ToObject(rg.RailType, iRailType),\r\n            tolerance=fTol_WIP)\r\n\r\n        if rgBs_Out.Count == 0:\r\n            # rgBs_Out does not return None.\r\n\r\n            print(\"At {} tolerance, CreateFilletEdges returned an empty array.\".format(\r\n                fTol_WIP))\r\n\r\n            fTol_WIP = getNextTolerance(fTol_WIP, fTol_Start, fTol_Min, fTol_Max, bEcho)\r\n            if fTol_WIP is None: return\r\n\r\n            continue\r\n\r\n\r\n        if rgBs_Out.Count != 1:\r\n            raise Exception(\"{} breps resulted from CreateFilletEdges.\".format(rgBs_Out.Count))\r\n\r\n        rgB_Out = rgBs_Out[0]\r\n\r\n        ct_Naked_Out = nakedBorderCount(rgB_Out)\r\n\r\n        if ct_Naked_Out > ct_Naked_In:\r\n            print(\"At {} tolerance, naked border count change: {} -> {}.\".format(\r\n                fTol_WIP,\r\n                ct_Naked_In,\r\n                ct_Naked_Out))\r\n\r\n            fTol_WIP = getNextTolerance(fTol_WIP, fTol_Start, fTol_Min, fTol_Max, bEcho)\r\n            if fTol_WIP is None: return\r\n\r\n            rgB_Out.Dispose()\r\n\r\n            continue\r\n\r\n        # No increase in naked border count.\r\n\r\n        print(\"Fillet created at {} tolerance.\".format(fTol_WIP))\r\n\r\n        maxEdgeTol_Out = maxEdgeTol(rgB_Out)\r\n        if maxEdgeTol_Out == maxEdgeTol_In:\r\n            print(\"No change in maximum edge tolerance, {}.\".format(\r\n                formatDistance(maxEdgeTol_Out)))\r\n        else:\r\n            print(\"Maximum edge tolerance change: {} -> {}.\".format(\r\n                formatDistance(maxEdgeTol_In),\r\n                formatDistance(maxEdgeTol_Out)))\r\n        if bEcho and fTol_WIP != fTol_Start:\r\n            print(\"To obtain filleted brep, tolerance was {} to {}.\".format(\r\n                'increased' if fTol_WIP > fTol_Start else 'decreased',\r\n                fTol_WIP))\r\n        return rgB_Out\r\n\r\n\r\ndef processBrepObject(rhBrep_In, idxs_rgEdges, fRadii, bConstantRadius=True, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBrep_In\r\n        fRadius\r\n        bConstantRadius\r\n        fRadius_End\r\n        iRailType\r\n        fTol_Start\r\n        fTol_Min\r\n        fTol_Max\r\n        bReplace\r\n        bEcho\r\n        bDebug\r\n    Return on success: GUID of resultant brep.\r\n    Return on fail: None\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    #fRadius_End = getOpt('fRadius_End')\r\n    iRailType = getOpt('iRailType')\r\n    fTol_Start = getOpt('fTol_Start')\r\n    fTol_Min = getOpt('fTol_Min')\r\n    fTol_Max = getOpt('fTol_Max')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rdB_In = None\r\n    if isinstance(rhBrep_In, Guid):\r\n        gB_In = rhBrep_In\r\n        rdB_In = sc.doc.Objects.FindId(gB_In)\r\n    elif isinstance(rhBrep_In, rd.BrepObject):\r\n        rdB_In = rhBrep_In\r\n        gB_In = rdB_In.Id\r\n    if not rdB_In: return\r\n\r\n\r\n    rgB_In = rdB_In.BrepGeometry\r\n\r\n    if not rgB_In.IsValid:\r\n        print(\"Brep {} is invalid.  Fix and rerun this script.\".format(gB_In))\r\n        return\r\n\r\n\r\n    rgB_Res = processBrep(\r\n        rgB_In,\r\n        idxs_rgEdges,\r\n        fRadii,\r\n        bConstantRadius=bConstantRadius,\r\n        #fRadius_End=fRadius_End,\r\n        iRailType=iRailType,\r\n        fTol_Start=fTol_Start,\r\n        fTol_Min=fTol_Min,\r\n        fTol_Max=fTol_Max,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n        \r\n    if rgB_Res is None: return\r\n\r\n    if bReplace:\r\n        if sc.doc.Objects.Replace(objectId=rdB_In.Id, brep=rgB_Res):\r\n            print(\"Replaced brep.\")\r\n            rgB_Res.Dispose()\r\n            return gB_In\r\n        else:\r\n            if bEcho: print(\"Failed replacing brep.\")\r\n            rgB_Res.Dispose()\r\n            return\r\n    else:\r\n        gB_Out = sc.doc.Objects.AddBrep(rgB_Res, rdB_In.Attributes)\r\n        if gB_Out != gBrep1.Empty:\r\n            if bEcho: print(\"Added brep.\")\r\n            rgB_Res.Dispose()\r\n            return gB_Out\r\n        else:\r\n            if bEcho: print(\"Failed adding brep.  Is it invalid?\")\r\n            rgB_Res.Dispose()\r\n            return\r\n\r\n\r\ndef main():\r\n\r\n    gBs_In = []\r\n    idx_rgEdges_PerBrep = []\r\n    rads_for_idxEs_PerBrep = []\r\n\r\n\r\n    prevSels_Present = []\r\n    skey_prevSels = 'prevSels({})'.format(__file__)\r\n    if skey_prevSels in sc.sticky:\r\n        prevSels_Saved = sc.sticky[skey_prevSels]\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n        iter.ObjectTypeFilter = rd.ObjectType.Brep\r\n        gBs_Saved = [d.Id for d in sc.doc.Objects.GetObjectList(iter)]\r\n        for gB, pts, rads in prevSels_Saved:\r\n            if gB in  gBs_Saved:\r\n                prevSels_Present.append((gB, pts, rads))\r\n\r\n\r\n    skey_conduit = 'conduit({})'.format(__file__)\r\n    if (skey_conduit in sc.sticky) and sc.sticky[skey_conduit]:\r\n        conduit = sc.sticky[skey_conduit]\r\n    else:\r\n        conduit = DrawRadiusDotsConduit()\r\n        sc.sticky[skey_conduit] = conduit\r\n\r\n    conduit.Enabled = False # Turns off the conduit if left on from a previous execution of this script.\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n\r\n    def get_BE_FromInput(rhObj):\r\n        if not hasattr(rhObj, '__iter__'):\r\n            if not isinstance(rhObj, rd.ObjRef): return\r\n\r\n            objref = rhObj\r\n\r\n            gB = objref.ObjectId\r\n            idxE = objref.Edge().EdgeIndex\r\n\r\n            return gB, idxE\r\n\r\n        if len(rhObj) != 2: return\r\n        rhB, idxE = rhObj\r\n        if not isinstance(idxE, int): return\r\n\r\n        if isinstance(rhB, rd.BrepObject):\r\n            rdB = rhB\r\n            gB = rdB.Id\r\n        elif isinstance(rhB, Guid):\r\n            gB = rhB\r\n\r\n        return gB, idxE\r\n\r\n\r\n    def sortInputPerBrep(rhObjs_In):\r\n\r\n        for rhObj in rhObjs_In:\r\n\r\n            rc = get_BE_FromInput(rhObj)\r\n            if not rc: return\r\n\r\n            gB, idxE = rc\r\n\r\n            if gB in gBs_In:\r\n                if idxE in idx_rgEdges_PerBrep[gBs_In.index(gB)]:\r\n                    # Modify radius value.\r\n                    idxEperB = idx_rgEdges_PerBrep[gBs_In.index(gB)].index(idxE)\r\n                    rads_for_idxEs_PerBrep[gBs_In.index(gB)][idxEperB] = fRadius\r\n                    continue\r\n\r\n                idx_rgEdges_PerBrep[gBs_In.index(gB)].append(idxE)\r\n                rads_for_idxEs_PerBrep[gBs_In.index(gB)].append(fRadius)\r\n                continue\r\n\r\n            gBs_In.append(gB)\r\n            idx_rgEdges_PerBrep.append([idxE])\r\n            rads_for_idxEs_PerBrep.append([fRadius])\r\n\r\n\r\n    def getEdgeIndex_MatchingMidPoint(rgBrep, midpt):\r\n        for edge in rgBrep.Edges:\r\n            ts = list(edge.DivideByCount(2, includeEnds=False))\r\n            if not ts:\r\n                print(\"Midpoint of edge[{}] not found.\".format(edge.EdgeIndex))\r\n                return\r\n            if edge.PointAt(ts[0]).DistanceTo(midpt) < 0.1 * sc.doc.ModelAbsoluteTolerance:\r\n                return edge.EdgeIndex\r\n\r\n\r\n    def prepareDataForPreviewAndSticky():\r\n        zipped = zip(gBs_In, idx_rgEdges_PerBrep, rads_for_idxEs_PerBrep)\r\n\r\n\r\n        rgBs = []\r\n        pts_Mids_All = [] # Won't include matching radius of 0.0.\r\n        rads_All = [] # Won't include radius of 0.0.\r\n        \r\n        bprs = [] # list of tuples of (GUID, pts, radii) for saving input for future use of script.\r\n\r\n        for gB_In, idxs_Es, rads_for_idxEs in zipped:\r\n            rdB = sc.doc.Objects.FindId(gB_In)\r\n            rgB = rdB.Geometry\r\n            rgBs.append(rgB)\r\n            pts_Mids_ThisB = [] # Won't include matching radius of 0.0.\r\n            rads_ThisB = [] # Won't include radius of 0.0.\r\n\r\n            for i, rad in enumerate(rads_for_idxEs):\r\n                if rad == 0.0:\r\n                    continue\r\n                iE = idxs_Es[i]\r\n                ts = list(rgB.Edges[iE].DivideByCount(2, includeEnds=False))\r\n                if not ts:\r\n                    print(\"Midpoint of edge[{}] not found.\".format(iE))\r\n                    return\r\n                pt = rgB.Edges[iE].PointAt(ts[0])\r\n                pts_Mids_ThisB.append(pt)\r\n                rads_ThisB.append(rad)\r\n\r\n            if not pts_Mids_ThisB: continue\r\n            bprs.append((rdB.Id, pts_Mids_ThisB, rads_ThisB))\r\n            pts_Mids_All.extend(pts_Mids_ThisB)\r\n            rads_All.extend(rads_ThisB)\r\n\r\n        sc.sticky[skey_prevSels] = bprs\r\n\r\n        if not rgBs: return\r\n\r\n        return pts_Mids_All, rads_All\r\n\r\n\r\n\r\n    while True:\r\n        rc = getInput(bool(prevSels_Present))\r\n\r\n        if rc is None:\r\n            conduit.Enabled = False\r\n            del conduit\r\n            del sc.sticky[skey_conduit]\r\n            sc.sticky[skey_conduit] = None\r\n            return\r\n\r\n        if rc == 'UsePrevInput':\r\n            sc.doc.Objects.UnselectAll()\r\n            gBs_In = []\r\n            idx_rgEdges_PerBrep = []\r\n            rads_for_idxEs_PerBrep = []\r\n            for gB, pts, rads in prevSels_Present:\r\n                rgB = sc.doc.Objects.FindId(gB).BrepGeometry\r\n                idx_rgEdges_ThisB = []\r\n                rads_for_idxEs_ThisB = []\r\n                for i, pt in enumerate(pts):\r\n                    idxE = getEdgeIndex_MatchingMidPoint(rgB, pt)\r\n                    if idxE is None: continue\r\n                    idx_rgEdges_ThisB.append(idxE)\r\n                    rads_for_idxEs_ThisB.append(rads[i])\r\n                if idx_rgEdges_ThisB:\r\n                    gBs_In.append(gB)\r\n                    idx_rgEdges_PerBrep.append(idx_rgEdges_ThisB)\r\n                    rads_for_idxEs_PerBrep.append(rads_for_idxEs_ThisB)\r\n\r\n            rc = prepareDataForPreviewAndSticky()\r\n            if not rc: continue\r\n            pts_Mids_All, rads_All = rc\r\n\r\n            conduit.prs = zip(pts_Mids_All, rads_All)\r\n\r\n            conduit.Enabled = True\r\n            sc.doc.Views.Redraw()\r\n\r\n            continue\r\n\r\n\r\n        fRadius = Opts.values['fRadius']\r\n        #bConstantRadius = Opts.values['bConstantRadius']\r\n        #fRadius_End = Opts.values['fRadius_End']\r\n        iRailType = Opts.values['iRailType']\r\n        fTol_Start = Opts.values['fTol_Start']\r\n        fTol_Min = Opts.values['fTol_Min']\r\n        fTol_Max = Opts.values['fTol_Max'] if Opts.values['bIncrTolOnFail'] else None\r\n        bReplace = Opts.values['bReplace']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n        if not rc:\r\n            conduit.Enabled = False\r\n            del conduit\r\n            break\r\n\r\n        objrefs = rc\r\n\r\n        sortInputPerBrep(objrefs)\r\n\r\n        rc = prepareDataForPreviewAndSticky()\r\n        if not rc: continue\r\n        pts_Mids_All, rads_All = rc\r\n\r\n        conduit.prs = zip(pts_Mids_All, rads_All)\r\n\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    gBreps_Res_All = []\r\n\r\n    zipped = zip(gBs_In, idx_rgEdges_PerBrep, rads_for_idxEs_PerBrep)\r\n\r\n    for iB, (gB_In, idxs_Es, rads_for_idxEs) in enumerate(zipped):\r\n\r\n        sCmdPrompt = \"Processing brep {} of {}\".format(iB+1, len(gBs_In))\r\n        Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt)\r\n\r\n        gB_Ret = processBrepObject(\r\n            rhBrep_In=gB_In,\r\n            idxs_rgEdges=idxs_Es,\r\n            fRadii=rads_for_idxEs,\r\n            bConstantRadius=True,\r\n            #fRadius_End=fRadius_End,\r\n            iRailType=iRailType,\r\n            fTol_Start=fTol_Start,\r\n            fTol_Min=fTol_Min,\r\n            fTol_Max=fTol_Max,\r\n            bReplace=bReplace,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n        if gB_Ret:\r\n            gBreps_Res_All.append(gB_Ret)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}