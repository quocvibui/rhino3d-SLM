{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/mmmesh/archive/mmfabmesh.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "mmmesh/archive/mmfabmesh.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 21.01.2017\n\n@author: kathrind\n'''\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\nfrom System.Collections.Generic import IEnumerable, List\nfrom mmmesh import MMMesh\nfrom node import Node\n\n# globals\ndiscrete_insertion_offset = 34\ndiscrete_insertion_bending_offset = 8\n\nclass MMFabMesh(MMMesh):\n    \n    def __init__(self):\n        MMMesh.__init__(self)\n    \n    def generate_fab_mesh(self, row_from, row_to):\n        ''' generate the mesh node topology of the intersection pts grid'''\n        self.generate_node_grid(row_from, row_to)\n        self.calc_lines_in_cont_dir_and_bending_angles_abs() # calculate the absolute bending angles of the individual nodes\n        self.calc_node_indices() # calculate the node indices\n        #self.calc_neighbor_nodes_for_line_estimation() # calculate the neighbor nodes for the line estimation\n    \n    def generate_node_grid(self, row_from, row_to):\n        ''' now the individual nodes are generated from the point grid according to certain conditions\n        \n        the sequence (from bottom to top) always consists of: exterior_srf1, exterior_srf2, interior\n        \n        nodes can be of:\n        - node_type: \"exterior_srf1\" / \"exterior_srf2\" / \"interior\"\n        - special nodes are created: for the lead in / lead out sequence\n        '''\n        \n        print \"generating fabrication sequence\"\n\n        # mesh nodes\n        self.nodes_in_layers = [] #layer based structure [[[nodes_interior],[nodes_exterior],[nodes_exterior]],[[.],[.],[.]],...]\n        self.nodes = [] #shallow list of nodes \n\n        # now loop through the point grid\n        for row in range(self.rows):\n\n            if row > 0 and row > row_from and row < row_to: # only start with the second layer\n                \n                row_srf1_nodes = []\n                row_srf2_nodes = []\n                row_interior_nodes = []\n                current_layer = [] # into the current layer: even: [interior, exterior_srf2, exterior_srf1], odd: [interior, exterior_srf1, exterior_srf2]\n                \n                # even layers\n                if row % 2 == 0:\n                   \n                    # srf1\n                    for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=\"srf1\")): # start with srf1\n                        if col % 2 == 1: # just take every 5th plane\n                            nodes_srf1 = self.generate_nodes(row, col, \"srf1\", \"exterior_srf1\", \"even\")\n                            row_srf1_nodes += nodes_srf1\n                            self.nodes += nodes_srf1\n                    \n                    # srf2\n                    for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=\"srf2\")):\n                        if col % 2 == 1: # just take every 5th plane\n                            nodes_srf2 = self.generate_nodes(row, col, \"srf2\", \"exterior_srf2\", \"even\")\n                            row_srf2_nodes += nodes_srf2\n                            self.nodes += nodes_srf2       \n\n                    # store into the rows\n                    if len(row_interior_nodes) > 0: current_layer.append(row_interior_nodes)                       \n                    if len(row_srf1_nodes) > 0: current_layer.append(row_srf1_nodes)\n                    if len(row_srf2_nodes) > 0: current_layer.append(row_srf2_nodes)\n                \n                # odd layers\n                if row % 2 == 1:\n                            \n                    # srf1\n                    for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=\"srf1\")): # start with srf1\n                        if col % 2 == 0: # just take every 3rd plane\n                            nodes_srf1 = self.generate_nodes(row, col, \"srf1\", \"exterior_srf1\", \"odd\")\n                            row_srf1_nodes += nodes_srf1\n                            self.nodes += nodes_srf1\n                    \n                    # srf2\n                    for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=\"srf2\")): # start with srf1\n                        if col % 2 == 0: # just take every 3rd plane\n                            nodes_srf2 = self.generate_nodes(row, col, \"srf2\", \"exterior_srf2\", \"odd\")\n                            row_srf2_nodes += nodes_srf2\n                            self.nodes += nodes_srf2\n                    \n                    # store into the rows\n                    if len(row_interior_nodes) > 0: current_layer.append(row_interior_nodes)\n                    if len(row_srf1_nodes) > 0: current_layer.append(row_srf1_nodes)\n                    if len(row_srf2_nodes) > 0: current_layer.append(row_srf2_nodes)\n                    \n                if len(current_layer) > 0: self.nodes_in_layers.append(current_layer)\n    \n             \n    def generate_nodes(self, row, col, srf, node_type, layer_type):\n        ''' generating a node according to its node_type (exterior/interior) and layer_type (even/odd) '''\n        \n        nodes = []\n        \n        \"\"\"\n        if col < 3: # lead in nodes\n            nodes.append(self.generate_node_exterior_lead_in(row, col, node_type, srf, insert_discrete_element = False, layer_type = layer_type))\n        elif col < self.u-3: # regular node\n            nodes.append(self.generate_node_exterior(row, col, node_type, srf, insert_discrete_element = True, layer_type = layer_type))\n        else: # lead out nodes\n            nodes += self.generate_nodes_exterior_lead_out(row, col, node_type, srf, insert_discrete_element = True, layer_type = layer_type)\n        \"\"\"\n        if col >= 2:\n            nodes.append(self.generate_node_exterior(row, col, node_type, srf, insert_discrete_element = True, layer_type = layer_type))\n            \n        if node_type == \"interior\":\n            pass\n                    \n        return nodes\n    \n    def get_pt_in_row_rgmesh_fab(self, row, col, srf):\n        '''return the point of the point grid given column and row and surface 1 or surface 2'''    \n        #return self.intersection_pts_in_layers_srf1[row][col] if srf == 1 else self.intersection_pts_in_layers_srf2[row][col]\n        return self.get_pt_row_col_rgmesh_fab(row, col, srf = srf)\n    \n    def get_node_in_row(self, row, col, srf = \"srf1\"):\n        ''' return the node given by row and column and side of the mesh '''\n        srf_idx = 0 if srf == \"srf1\" else 1\n        list_length = len(self.nodes_in_layers[row][srf_idx])\n        col = min(list_length-1, col)\n        return self.nodes_in_layers[row][srf_idx][col]\n    \n    def get_plane_from_srf(self, pt, srf):\n        '''get the srf plane closest tot the input point'''\n        \n        s = self.srf1_rebuilt if srf == 1 else self.srf2_rebuilt\n        \n        srf_param = s.ClosestPoint(pt)\n        srf_plane = s.FrameAt(srf_param[1], srf_param[2])[1]\n        \n        return srf_plane\n    \n    def generate_node_exterior(self, row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\"):\n        ''' creating an exterior node '''\n        \n        node = Node(node_type, layer_type, row) # create one instance of the class node\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n        \n        # get the corner points of the current square of planes\n        pt_current = self.get_pt_in_row_rgmesh_fab(row, col, srf=srf)\n        pt_before = self.get_pt_in_row_rgmesh_fab(row, col-2, srf=srf)\n        pt_under_current = self.get_pt_in_row_rgmesh_fab(row-1, col, srf=srf)\n        pt_under_before = self.get_pt_in_row_rgmesh_fab(row-1, col-2, srf=srf)\n        \n        axis = rg.Vector3d(pt_current-pt_before)\n        axis.Unitize()\n        \n        if insert_discrete_element == True:\n            \n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            \n            wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)\n            \n            T_offset = rg.Transform.Translation(wrist_plane_for_bending.YAxis * -5)\n            line_discrete_element.Transform(T_offset)\n            \n            scale_plane = rg.Plane(line_discrete_element.PointAt(0.5), wrist_plane_for_inserting_tilted.XAxis, wrist_plane_for_inserting_tilted.YAxis)\n            T_scale = rg.Transform.Scale(scale_plane, 1, 1, 1.5)\n            line_discrete_element.Transform(T_scale)\n            \n        else:\n            \n            line_discrete_element = None\n            \n            wrist_plane_for_bending = rg.Plane(wrist_plane)\n            wrist_plane_for_bending.Origin = pt_current\n            wrist_plane_for_inserting, wrist_plane_for_inserting_tilted = (None, None)\n            \n        \n        node.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element)  \n        \n        return node\n\n    def generate_node_exterior_lead_in(self, row, col, node_type, srf, insert_discrete_element = False, layer_type = \"even\"):\n        ''' creating the exterior node for lead in '''\n        \n        # get the wrist_xy_plane from the cutting plane list\n        wrist_plane = self.cutting_planes[row]\n\n        node_lead_in_0 = Node(node_type, layer_type, row) # create one instance of the class node\n        wrist_plane_for_bending = rg.Plane(wrist_plane)\n        wrist_plane_for_bending.Origin = self.get_pt_in_row(row, 0, srf=srf)\n        node_lead_in_0.fill_params(wrist_plane_for_bending)  \n        \n        node_lead_in_0.estimate_with_eeff_cam = False\n        return node_lead_in_0\n    \n    def generate_nodes_exterior_lead_out(self, row, col, node_type, srf, insert_discrete_element = True, layer_type = \"even\"):\n        ''' creating the exterior node for lead in '''\n        \n        lead_out_nodes = []\n\n        if layer_type == \"even\":\n            \n            node_lead_out_0 = self.generate_node_exterior(row, self.u, node_type, srf, insert_discrete_element = True, layer_type = layer_type)\n            lead_out_nodes.append(node_lead_out_0)\n        \n            node_lead_out_1 = Node(node_type, layer_type, row) # create one instance of the class node\n            \n            # get the wrist_xy_plane from the cutting plane list\n            wrist_plane = self.cutting_planes[row]\n            \n            # get the corner points of the current square of planes\n            pt_before = self.get_pt_in_row(row, self.u, srf=srf)\n            pt_under_before = self.get_pt_in_row(row-2, self.u, srf=srf)\n            \n            pt_current = pt_before + self.get_plane_from_srf(pt_before, srf).YAxis * 100\n            pt_under_current = pt_under_before + self.get_plane_from_srf(pt_under_before, srf).YAxis * 100\n            \n            '''\n            pt_current = pt_before + wrist_plane.YAxis * 100\n            pt_under_current = pt_under_before + wrist_plane.YAxis * 100'''\n            \n            axis = rg.Vector3d(pt_current-pt_before)\n            axis.Unitize()\n\n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            \n            wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)   \n            \n            node_lead_out_1.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element)  \n           \n            node_lead_out_1.line_for_estimation = rg.Line(pt_under_before, pt_under_current)\n            \n            lead_out_nodes.append(node_lead_out_1)\n        \n        else: # layer type == \"odd\"\n            print \"odd layer\"\n            \n            node_lead_out_0 = self.generate_node_exterior(row, col, node_type, srf, insert_discrete_element = True, layer_type = layer_type)\n            lead_out_nodes.append(node_lead_out_0)\n            \n            node_lead_out_1 = Node(node_type, layer_type, row) # create one instance of the class node\n            \n            # get the wrist_xy_plane from the cutting plane list\n            wrist_plane = self.cutting_planes[row]\n            \n            # get the corner points of the current square of planes\n            pt_before = self.get_pt_in_row(row, self.u-2, srf=srf)\n            pt_under_before = self.get_pt_in_row(row-2, self.u-2, srf=srf)\n            pt_current = self.get_pt_in_row(row, self.u, srf=srf)\n            pt_under_current = self.get_pt_in_row(row-2, self.u, srf=srf)\n\n            axis = rg.Vector3d(pt_current-pt_before)\n            axis.Unitize()\n\n            line_discrete_element = rg.Line(pt_before, pt_under_before)\n            \n            wrist_plane_for_bending, wrist_plane_for_inserting = self.get_wrist_planes(wrist_plane, pt_before, axis)\n            wrist_plane_for_inserting_tilted = self.get_wrist_plane_for_inserting_tilted(wrist_plane_for_inserting, line_discrete_element, axis)   \n            \n            node_lead_out_1.fill_params(wrist_plane_for_bending, axis, insert_discrete_element, wrist_plane_for_inserting, wrist_plane_for_inserting_tilted, line_discrete_element)  \n           \n            node_lead_out_1.line_for_estimation = rg.Line(pt_under_before, pt_under_current)\n            \n            lead_out_nodes.append(node_lead_out_1)\n        \n        \n        node_lead_out_2 = Node(node_type, layer_type, row)\n        \n        wrist_plane_for_bending = rg.Plane(node_lead_out_1.wrist_plane_for_bending)\n        T = rg.Transform.Translation(node_lead_out_1.axis * self.offset_lead_out)\n        wrist_plane_for_bending.Transform(T)\n        \n        node_lead_out_2.fill_params(wrist_plane_for_bending)  \n        lead_out_nodes.append(node_lead_out_2)\n        \n        return lead_out_nodes\n    \n    def get_wrist_planes(self, wrist_plane, pt_before, axis):\n        ''' the wrist planes have an offset to the inserted vertical, given the vertical insertion offset and the additional offset for bending'''\n\n        wrist_plane_for_bending, wrist_plane_for_inserting = (rg.Plane(wrist_plane), rg.Plane(wrist_plane))\n        wrist_plane_for_bending.Origin = rg.Point3d.Add(pt_before, axis * (discrete_insertion_offset + discrete_insertion_bending_offset))\n        wrist_plane_for_inserting.Origin = rg.Point3d.Add(pt_before, axis * discrete_insertion_offset)\n        return wrist_plane_for_bending, wrist_plane_for_inserting\n    \n    def get_wrist_plane_for_inserting_tilted(self, wrist_plane_for_inserting, line_discrete_element, axis):\n        '''return xy plane tilted according to the angle of the vertical wire (= rg.Line)'''\n        \n        wrist_plane_for_inserting_tilted = rg.Plane(wrist_plane_for_inserting)\n        angle = self.get_angle(rg.Vector3d(line_discrete_element.From - line_discrete_element.To), wrist_plane_for_inserting.ZAxis, axis)\n        wrist_plane_for_inserting_tilted.Rotate(angle, axis,  wrist_plane_for_inserting_tilted.Origin)\n        \n        return wrist_plane_for_inserting_tilted\n    \n    def get_angle(self,n1,n2,axis): \n        ''' get the angle for the tilted plane for inserting the discrete rebar element'''\n        \n        #________________check for the rotation direction_______________________\n        #angle           = rs.VectorAngle (n1,n2) # rotation angle\n        angle           = rg.Vector3d.VectorAngle(rg.Vector3d(n1), rg.Vector3d(n2))\n         \n        #print \"angle: \", angle\n        test_vec_clw = rg.Vector3d(n1)\n        test_vec_clw.Rotate(angle, axis)\n        \n        sub_vec_clw = rg.Vector3d.Subtract(test_vec_clw,n2)\n        length_clw = sub_vec_clw.Length\n        test_vec_aclw = rg.Vector3d(n1)\n        test_vec_aclw.Rotate(angle*-1, axis)       \n        sub_vec_aclw = rg.Vector3d.Subtract(test_vec_aclw, n2)\n        length_aclw = sub_vec_aclw.Length\n        \n        if angle == 0 or length_clw < length_aclw:\n            rot_angle = angle * -1\n        else:\n            rot_angle = angle \n   \n        return rot_angle\n    \n    def calc_lines_in_cont_dir_and_bending_angles_abs(self):\n        '''this methods takes the existing nodes and calculates the lines incontiuous direction and bending angles for the MM Tool. \n        The values are absolute in relation to the X axis of the current wrist plane of each layer '''\n        \n        print \"calculating absolute bending angles\"\n        \n        for layer in self.nodes_in_layers:\n            for row in layer:\n                for i in range(1, len(row)):\n                    node_current = row[i]\n                    node_before = row[i-1]\n                    node_current.line_continuous_element = rg.Line(node_current.wrist_plane_for_bending.Origin, node_before.wrist_plane_for_bending.Origin)\n                    \n        for layer in self.nodes_in_layers:\n            for row in layer:\n                for i in range(len(row)-1):\n                    \n                    if row[i+1].line_continuous_element:\n                        vec = rg.Vector3d(row[i+1].line_continuous_element.From - row[i+1].line_continuous_element.To)\n                        angle = rg.Vector3d.VectorAngle(row[i].wrist_plane_for_bending.XAxis, vec, row[i].wrist_plane_for_bending)\n                        \n                        try: angle = m.degrees(angle) # needs to be done because of a math overflow error\n                        except: angle = 0\n                        \n                        if angle > 180:\n                            angle = (360-angle)*-1\n\n                        row[i].absolute_bending_angle = angle\n                        \n\n    def calc_node_indices(self):\n        \n        print \"calculating node indices\"\n        self.nodes = []\n        index_counter = 0\n        \n        for l, layer in enumerate(self.nodes_in_layers):\n            node_list_counter = 0 \n            for j, node_list in enumerate(layer):\n                 \n                for i, node in enumerate(node_list):\n                    \n                    node.index = index_counter # index running\n                    index_counter += 1\n                    \n                    node.index_row = l \n                    node.index_col = i\n                    node.index_layer_list = node_list_counter\n                    \n                    \n                    if i >= 1 and i < (len(node_list)-1):\n                        node.is_for_bending = True\n\n                node_list_counter += 1\n                \n                \"\"\"\n                # only put the nodes into the nodes list from on the second layer, first layer is built already\n                if l<1:\n                    #print l\n                    #print \"groundlayer\"\n                    self.nodes_groundlayer += [node for node in node_list]\n                else:\n                    #print \"regular layers\"\n                    self.nodes += [node for node in node_list]\"\"\"\n                \n                self.nodes += [node for node in node_list]\n                    \n    def calc_neighbor_nodes_for_line_estimation(self):\n        for i, layer in enumerate(self.nodes_in_layers[1:]):\n            i = i+1 # because we start only from the second layer\n            for j, node_list in enumerate(layer):\n                for k, node in enumerate(node_list):\n                    if k > 0 and k < len(node_list)-1:\n                        node_current = self.nodes_in_layers[i][j][k]\n                        if node_current.layer_type == \"odd\":\n                            #print node_current.layer_type\n                            node_current.neighbor_node_for_est_01 = self.nodes_in_layers[i-1][j][k+1] if self.nodes_in_layers[i-1][j][k+1].insert_discrete_element else None\n                            node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k] if self.nodes_in_layers[i-1][j][k].insert_discrete_element else None\n                        else: #node.layer_type == \"even\"\n                            #print node_current.layer_type \n                            if k < len(self.nodes_in_layers[i-1][j]):\n                                node_current.neighbor_node_for_est_01 = self.nodes_in_layers[i-1][j][k] if self.nodes_in_layers[i-1][j][k].insert_discrete_element else None\n                                node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k-1] if self.nodes_in_layers[i-1][j][k-1].insert_discrete_element else None\n                            else:\n                                node_current.neighbor_node_for_est_01 = None\n                                node_current.neighbor_node_for_est_02 = self.nodes_in_layers[i-1][j][k-1]\n                        \n                        # now define which type of estimation is necessary, depending on which discrete element exists\n                        if node_current.neighbor_node_for_est_01 and node_current.neighbor_node_for_est_02 == None:\n                            node_current.estimation_type = 1\n                            node_current.estimate_with_eeff_cam = True\n                        elif node_current.neighbor_node_for_est_02 and node_current.neighbor_node_for_est_01 == None:\n                            node_current.estimation_type = 2\n                            node_current.estimate_with_eeff_cam = True\n                        elif node_current.neighbor_node_for_est_01 and node_current.neighbor_node_for_est_02:\n                            node_current.estimation_type = 2\n                            node_current.estimate_with_eeff_cam = True\n                        else:\n                            node_current.estimate_with_eeff_cam = False\n    \n    \n    def generate_fab_mesh_new(self, row_from, row_to):\n        ''' generate the mesh node topology of the intersection pts grid'''\n        self.nodes_in_layers = self.generate_nodes_in_rows(row_from, row_to)\n        #self.nodes = self.get_flat_list_from_2dlist([j for i in self.nodes_in_layers for j in i])\n        self.calc_node_indices_from_nodes_in_layers()\n    \n    def calc_node_indices_from_nodes_in_layers(self):\n        \n        print \"calculating node indices\"\n        self.nodes = []\n        index_counter = 0\n        \n        for l, layer in enumerate(self.nodes_in_layers):\n            node_list_counter = 0 \n            for j, node_list in enumerate(layer):\n                 \n                for i, node in enumerate(node_list):\n                    \n                    node.index = index_counter # index running\n                    index_counter += 1\n                    \n                    node.index_row = l \n                    node.index_col = i\n                    node.index_layer_list = node_list_counter\n                    \n                    \n                    if i >= 1 and i < (len(node_list)-1):\n                        node.is_for_bending = True\n\n                node_list_counter += 1\n                self.nodes += [node for node in node_list]   \n        \n        \n    def generate_nodes_in_rows(self, row_from, row_to):\n        \n        nodes_in_row_srf1 = [self.get_fab_nodes_row(row, \"srf1\") for row in range(max(row_from,1), row_to)]\n        nodes_in_row_srf2 = [self.get_fab_nodes_row(row, \"srf2\") for row in range(max(row_from,1), row_to)]\n        \n        return zip(nodes_in_row_srf1, nodes_in_row_srf2)\n    \n    #===================================================\n    # maybe as an extension --> only get fab nodes for one row\n    #===================================================\n    def get_fab_nodes_row(self, row, srf = \"srf1\"):\n        \"return nodes of one row\"\n        \n        layer_type = \"even\" if row%2 == 0 else \"odd\"\n        node_type = \"ext_srf1\" if srf== \"srf1\" else \"ext_srf2\"\n        \n        nodes_in_row = []\n        \n        if layer_type == \"even\":\n        \n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                elif col==self.cols: # lead out nodes\n                    pass \n                else:\n                    if col % 2 == 0: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type)\n                        nodes_in_row.append(node)\n        \n        else: #layer_type == \"odd\":\n            #for col, pt in enumerate(self.get_pts_in_row_rgmesh_fab(row, srf=srf)):\n            for col in range(2, self.cols):\n                if col==0: # lead in nodes\n                    pass\n                elif col==self.cols: # lead out nodes\n                    pass \n                else:\n                    if col % 2 == 1: #and col >= 2: # just take every 3rd plane\n                        node = self.generate_node_exterior(row, col, node_type = node_type, srf = srf, insert_discrete_element = True, layer_type = layer_type)\n                        nodes_in_row.append(node)\n        \n        self.calc_lines_in_cont_dir_row(nodes_in_row) # calculate the continuous members\n        self.calc_bending_angles_row(nodes_in_row) # calculate the absolute bending angles of the individual nodes\n        \n        return nodes_in_row\n    \n    def calc_lines_in_cont_dir_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the line members in contiuous direction '''\n\n        for i in range(1, len(nodes_in_row)):\n            node_current = nodes_in_row[i]\n            node_before = nodes_in_row[i-1]\n            node_current.line_continuous_element = rg.Line(node_current.wrist_plane_for_bending.Origin, node_before.wrist_plane_for_bending.Origin)\n                \n    def calc_bending_angles_row(self, nodes_in_row):\n        '''this methods takes a row of nodes and calculates the bending angles for the MM Tool. \n        The values are absolute in relation to the X axis of the current wrist plane of each layer '''             \n\n        for i in range(len(nodes_in_row)-1):\n            \n            if nodes_in_row[i+1].line_continuous_element:\n                vec = rg.Vector3d(nodes_in_row[i+1].line_continuous_element.From - nodes_in_row[i+1].line_continuous_element.To)\n                angle = rg.Vector3d.VectorAngle(nodes_in_row[i].wrist_plane_for_bending.XAxis, vec, nodes_in_row[i].wrist_plane_for_bending)\n                \n                try: angle = m.degrees(angle) # needs to be done because of a math overflow error\n                except: angle = 0\n                \n                if angle > 180:\n                    angle = (360-angle)*-1\n\n                nodes_in_row[i].absolute_bending_angle = angle",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}