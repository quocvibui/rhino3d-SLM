{
  "source_url": "https://github.com/contextmachine/mmodel/blob/0545e5c2a11c641fc54e91f603e709d3dea549f3/panels_gh/main_niche.py",
  "repo": "contextmachine/mmodel",
  "repo_stars": 0,
  "repo_description": "Deployment branch",
  "license": "Apache-2.0",
  "filepath": "panels_gh/main_niche.py",
  "instruction": "Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable",
  "code": "\"\"\"Provides a scripting component.\n    Inputs:\n        x: The x script variable\n        y: The y script variable\n    Output:\n        a: The a output variable\"\"\"\n\n__author__ = \"sofyadobycina\"\ntry:\n    rs = __import__(\"rhinoscriptsyntax\")\nexcept:\n    import rhinoscript as rs\nimport copy\nimport os\nimport sys\n\nimport Rhino.Geometry as rh\nimport math\n\nif os.getenv(\"USER\") == \"sofyadobycina\":\n    PWD = os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\"\n    sys.path.extend([os.getenv(\"HOME\") + \"/Documents/GitHub/mmodel/panels_gh\",\n                     os.getenv(\"HOME\") + \"Documents/GitHub/mmodel/panels_gh/cogs\"])\nelse:\n    os.environ[\"MMODEL_DIR\"] = \"/Users/andrewastakhov/PycharmProjects/mmodel\"\n    PWD = os.getenv(\"MMODEL_DIR\") + \"/panels_gh\"\n    sys.path.extend(\n        [os.getenv(\"MMODEL_DIR\") + \"/panels_gh\", os.getenv(\"MMODEL_DIR\") + \"/panels_gh/cogs\",\n         os.getenv(\"MMODEL_DIR\") + \"/panels_gh/tagging\"])\n\n\ndef plane(edge, target, param, param_val):\n    ptt2 = edge.PointAt(edge.ClosestPoint(param)[1])\n    vec = rh.Vector3d(ptt2.X - param.X, ptt2.Y - param.Y, ptt2.Z - param.Z)\n\n    xvec = rh.Vector3d.CrossProduct(target.TangentAt(target.NormalizedLengthParameter(param_val)[1]), vec)\n    frame = rh.Plane(param, vec, xvec)\n    return frame\n\n\ndef angle_ofs(angle, side, met_left):\n    ang = math.radians(90 / 2)\n    rad = ((side / 2) / math.cos(ang)) + met_left\n    return rad / math.tan(math.radians(angle / 2))\n\n\ndef right_angle_ofs(side, met_left):\n    ang = math.radians(90 / 2)\n    rad = ((side / 2) / math.cos(ang)) + met_left\n    return rad\n\n\ndef niche_offset(angle, side, met_left):\n    d = angle_ofs(angle, side, met_left) - right_angle_ofs(side, met_left)\n    return d * math.tan(math.radians(angle))\n\n\nclass BendSide(object):\n    angle = 90\n    side = 0.3\n    met_left = 0.5\n    side_offset = 0.5 + right_angle_ofs(side, met_left)\n    otgib = otgib_niche\n\n    def __init__(self, edge, base_surf, type):\n        object.__init__(self)\n        self.base_surf = base_surf  # type: rh.Brep\n        self.edge = self.curve_offset(edge)\n        self.type = type\n\n    @property\n    def eval_frame(self):\n\n        t = 0.0001\n        ptt = self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1])\n\n        if self.type == 0:\n            r2 = self.base_surf.Edges[0].ToNurbsCurve()\n        else:\n            r2 = self.base_surf.Edges[2].ToNurbsCurve()\n\n        ptt2 = r2.PointAt(r2.ClosestPoint(ptt)[1])\n        vec = rh.Vector3d(ptt2.X - ptt.X, ptt2.Y - ptt.Y, ptt2.Z - ptt.Z)\n        xvec = rh.Vector3d.CrossProduct(self.edge.TangentAt(self.edge.NormalizedLengthParameter(t)[1]), vec)\n\n        if self.type == 0:\n            frame = rh.Plane(self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1]), -vec, -xvec)\n            fr = copy.deepcopy(frame)\n            fr.Flip()\n            fr.Rotate(math.pi * 0.5, frame.Normal)\n        else:\n            frame = rh.Plane(self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1]), -vec, -xvec)\n            fr = copy.deepcopy(frame)\n            #fr.Flip()\n            #fr.Rotate(math.pi * 0.5, frame.Normal)\n\n\n\n        self._eval_frame = fr\n\n        return self._eval_frame\n\n    @property\n    def surf_otgib(self):\n        if self.otgib is not None:\n            otg = self.transpose_otgib()\n\n            swp = rh.SweepOneRail()\n            #self.edge.Reverse()\n            extr, = swp.PerformSweep(self.edge, otg)\n\n            self._surf_otgib = extr.CapPlanarHoles(0.1)\n        else:\n            self._surf_otgib = None\n        return self._surf_otgib\n\n    def curve_offset(self, curve):\n        # type: (rh.Curve) -> rh.NurbsCurve\n        if self.side_offset is not None:\n            nrb = curve.ToNurbsCurve()\n            nrb.Reparameterize(1.0)\n            crv = nrb.OffsetOnSurface(self.base_surf.Faces[0], self.side_offset, 0.01)\n            nrbc = crv[0].ToNurbsCurve()\n\n            return nrbc\n        else:\n            nrb = curve.ToNurbsCurve()\n            nrb.Reparameterize(1.0)\n            return nrb\n\n    def transpose_otgib(self):\n\n        tr = rh.Transform.PlaneToPlane(rh.Plane.WorldXY, self.eval_frame)\n        otg = copy.deepcopy(self.otgib)\n        otg.Transform(tr)\n        surf_otgib = rh.Brep.CreateContourCurves(otg, self.eval_frame)[0]\n\n        return surf_otgib\n\n\nclass Niche(BendSide):\n    angle = 45\n    side = 0.3\n    met_left = 0.5\n    side_offset = niche_offset(angle, side, met_left) + angle_ofs(angle, side, met_left)\n    otgib = otgib_niche\n\n    @property\n    def trim_otgib(self):\n        param_st = self.edge.PointAt(self.edge.NormalizedLengthParameter(0.0001)[1])\n        param_e = self.edge.PointAt(self.edge.NormalizedLengthParameter(0.9999)[1])\n\n        if self.type == 0:\n            r2 = self.base_surf.Edges[0].ToNurbsCurve()\n        else:\n            r2 = self.base_surf.Edges[2].ToNurbsCurve()\n\n        one = rh.Curve.DuplicateCurve(self.edge)\n        frame_one = plane(r2, one, param_st, 0.0001)\n        frame_two = plane(r2, one, param_e, 0.9999)\n\n        tr = rh.Transform.Rotation(math.radians(120), frame_one.XAxis, frame_one.Origin)\n        frame_one.Transform(tr)\n        tr = rh.Transform.Rotation(math.radians(60), frame_two.XAxis, frame_two.Origin)\n        frame_two.Transform(tr)\n\n        trim_planes = self.surf_otgib.Trim(frame_one, 0.1)[0]\n        trim_otgib = trim_planes.Trim(frame_two, 0.1)[0]\n        self._trim_otgib = trim_otgib.CapPlanarHoles(0.1)\n\n        return self._trim_otgib\n\n    def __init__(self, edge, base_surf, type):\n        BendSide.__init__(self, edge, base_surf, type)\n\n\nclass Bottom(BendSide):\n    side_offset = None\n    otgib = None\n\n    def __init__(self, edge, base_surf, type):\n        BendSide.__init__(self, edge, base_surf, type)\n\n\nclass Side(BendSide):\n    angle = 90\n    side = 0.3\n    met_left = 0.5\n    side_offset = 0.5 + right_angle_ofs(side, met_left)\n    otgib = otgib_side\n\n    @property\n    def eval_frame(self):\n\n        t = 0.0001\n        ptt = self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1])\n        if self.side == 'right':\n            r2 = self.base_surf.Edges[3].ToNurbsCurve()\n        else:\n            r2 = self.base_surf.Edges[1].ToNurbsCurve()\n\n        ptt2 = r2.PointAt(r2.ClosestPoint(ptt)[1])\n        vec = rh.Vector3d(ptt2.X - ptt.X, ptt2.Y - ptt.Y, ptt2.Z - ptt.Z)\n\n        xvec = rh.Vector3d.CrossProduct(self.edge.TangentAt(self.edge.NormalizedLengthParameter(t)[1]), vec)\n        if self.type == 0:\n            frame = rh.Plane(self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1]), -vec, -xvec)\n            fr = copy.deepcopy(frame)\n\n            fr.Flip()\n            fr.Rotate(math.pi * 0.5, frame.Normal)\n        else:\n            frame = rh.Plane(self.edge.PointAt(self.edge.NormalizedLengthParameter(t)[1]), -vec, -xvec)\n            fr = copy.deepcopy(frame)\n\n            #fr.Flip()\n            #fr.Rotate(math.pi * 0.5, frame.Normal)\n\n\n        self._eval_frame = fr\n\n        return self._eval_frame\n\n    @property\n    def trim_otgib(self):\n        param_st = self.edge.PointAt(self.edge.NormalizedLengthParameter(0.0001)[1])\n        param_e = self.edge.PointAt(self.edge.NormalizedLengthParameter(0.9999)[1])\n\n        if self.side == 'right':\n            r2 = self.base_surf.Edges[3].ToNurbsCurve()\n        else:\n            r2 = self.base_surf.Edges[1].ToNurbsCurve()\n\n        frame_one = plane(r2, self.edge, param_st, 0.0001)\n        frame_two = plane(r2, self.edge, param_e, 0.9999)\n\n\n        tr = rh.Transform.Rotation(math.radians(120), frame_one.XAxis, frame_one.Origin)\n        frame_one.Transform(tr)\n\n        tr = rh.Transform.Rotation(math.radians(60), frame_two.XAxis, frame_two.Origin)\n        frame_two.Transform(tr)\n\n\n\n        trim_otgib = self.surf_otgib.Trim(frame_one, 0.1)[0]\n        trim_otgib = trim_otgib.Trim(frame_two, 0.1)[0]\n        self._trim_otgib = trim_otgib.CapPlanarHoles(0.1)\n\n        return self._trim_otgib\n\n    @property\n    def surf_otgib(self):\n        if self.otgib is not None:\n            otg = self.transpose_otgib()\n\n            swp = rh.SweepOneRail()\n\n            extr, = swp.PerformSweep(self.edge, otg)\n\n            self._surf_otgib = extr.CapPlanarHoles(0.1)\n        else:\n            self._surf_otgib = None\n        return self._surf_otgib\n\n    def __init__(self, edge, base_surf, type, side):\n        BendSide.__init__(self, edge, base_surf, type)\n        self.side = side\n\n\nclass Panel:\n\n    @property\n    def surf_trimed(self):\n        s = rh.Brep.CreateEdgeSurface([self.niche.edge, self.side[0].edge, self.bottom.edge, self.side[1].edge])\n        self._surf_trimed = s\n        return self._surf_trimed\n\n    def __init__(self, surface, type):\n        self.surface = surface\n        self.type = type\n        self.edges = self.surface.Edges\n        self.gen_side_types()\n\n        self.niche_otgib = self.niche.trim_otgib\n        self.right_side_otgib = self.side[0].trim_otgib\n        self.left_side_otgib = self.side[1].trim_otgib\n\n    def gen_side_types(self):\n        if self.type == 0:\n            self.niche = Niche(self.edges[0], self.surface, self.type)\n            self.bottom = Bottom(self.edges[2], self.surface, self.type)\n            self.side = [Side(self.edges[3], self.surface, self.type, 'right'),\n                         Side(self.edges[1], self.surface, self.type, 'left')]\n        else:\n            self.niche = Niche(self.edges[0], self.surface, self.type)\n            self.bottom = Bottom(self.edges[2], self.surface, self.type)\n            self.side = [Side(self.edges[1], self.surface, self.type, 'right'),\n                         Side(self.edges[3], self.surface, self.type, 'left')]\n\n        self.side_types = [self.niche, self.bottom, self.side[0], self.side[1]]\n        self.intersect()\n\n    def intersect(self):\n        for i, v in enumerate(self.side_types):\n            param = []\n            for ind, val in enumerate(self.side_types):\n                if i != ind:\n                    inters = rs.CurveCurveIntersection(v.edge, val.edge)\n                    if inters is not None:\n                        param.append(inters[0][5])\n            param = sorted(param)\n\n            trimed = rh.Curve.Trim(v.edge, param[0], param[1])\n            v.edge = trimed\n\n\nclass Pnl(Panel):\n    def __init__(self, surface, type):\n        Panel.__init__(self, surface, type)\n\nimport ghpythonlib.treehelpers as th\nn_left = []\ns_left = []\nn_right = []\ns_right = []\nn_left_side = []\nn_right_side = []\nfor i in niche_left:\n    pan = Panel(i, 0)\n    s_left.append(pan.surf_trimed)\n    n_left.append(pan.niche_otgib)\n    n_left_side.append([pan.right_side_otgib, pan.left_side_otgib])\n\n\nfor i in niche_right:\n    pan = Panel(i, 1)\n    s_right.append(pan.surf_trimed)\n    n_right.append(pan.niche_otgib)\n    n_right_side.append([pan.right_side_otgib, pan.left_side_otgib])\n\nn_right_side = th.list_to_tree(n_right_side)\nn_left_side = th.list_to_tree(n_left_side)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}