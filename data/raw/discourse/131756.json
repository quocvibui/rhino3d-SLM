{
  "source_url": "https://discourse.mcneel.com/t/kinetic-foldable-panel-system/131756",
  "topic_id": 131756,
  "title": "Kinetic Foldable Panel System",
  "question": "Kinetic_Facade_1_Cover\n1920×1080 90.6 KB\n\n\nI’d like to share my method of making this non-stretching foldable facade using GH ! (No plugin needed, but a bit C# coding is needed)\n\nNotice: This is just a prototype, and may need some debugging afterwards.\n\nHere we go…\n\n\nStep 1.\n\nFirst we need to make some triangle meshes. I’d prefer equilateral triangle (or similar to it), otherwise it will look weird.\n\nSince it’s not today’s topic so I won’t cover how to make it here. We begin with these meshes.\n\n\nKinetic_Facade_1_1\n1920×1080 151 KB\n\n\nStep 2.\n\nThen get each mesh center, and move them along their normal, this will be the top point of the convex shell, so we call this parameter “convex height”\n\n\nKinetic_Facade_1_2\n1920×1080 141 KB\n\n\nStep 3.\n\nMake lines with “convex center” and triangle points in each group. We call these edges “bone edge”\n\n\nKinetic_Facade_1_3\n1920×1080 167 KB\n\n\nStep 4.\n\nHere I only keep few triangles for better understanding.\n\nProject elevated center point to each triangle edge, and we got points for folding panels (We call them “folding points”). So far nothing important, just basic manipulations.\n\n\nKinetic_Facade_1_4\n1920×1080 154 KB\n\n\nStep 5.\n\nHere comes an important part, we have to check whether the order of each point matches the order of each bone edge, and apparently they don’t in this case, so we have to unify them.\n\n\nKinetic_Facade_1_5_1\n1333×750 206 KB\n\n\nKinetic_Facade_1_5_2\n1333×750 208 KB\n\n\nKinetic_Facade_1_5_3\n1333×750 213 KB\n\n\nBy reversing list and shifting list, we can match each point to their corresponding edge.\n\n\nStep 6.\n\nOK, Here’s where the fun begins.\n\n\nBy now edges are grouped by meshes where they came from.\n\nWe add another level of group, group each with their next neighbor edge, as you can see in the list structure.\n\n\nKinetic_Facade_1_6\n1920×1080 181 KB\n\n\nStep 7.\n\nJoin each set of edges, then explode, to unify their direction.\n\n\nKinetic_Facade_1_7_1\n1333×750 176 KB\n\n\nKinetic_Facade_1_7_2\n1333×750 196 KB\n\n\nThis is the key step !\n...",
  "code_blocks": [
    {
      "code": "import Rhino.Geometry as rg\nimport Rhino.Geometry.Intersect as ri\n\n\ndist = max( 0.0017, min(idist, 0.95))\nfactor = 0.95\nmeshs, lst1, lst2, lst3, lst4, vertexs, points = [], [], [], [], [], [], []\nfor crv, cen in zip(crvs, cens):\n\n    # List of scale curves\n    #lst1.append(scrv)\n\n    # List of triangular vertex\n    pts = list(crv.ToArray())\n    \n    # Movement of center\n    boo, plane = crv.TryGetPlane()\n    zvec = plane.Normal\n    zvec.Unitize()  # Unitize the vector to 1 unit.\n    moveCen = cen + zvec * dist # Move the center to up with the heigh = dist\n    vertexs.append(moveCen)\n    # Movement of corners\n    ptLst = pts[:-1]  # Loop of points list\n    for i, pt in enumerate(ptLst):\n        points.append(pt)\n        line1 = rg.Line(pt, cen)\n        lst2.append(line1)\n        len1 = line1.Length  # Distance from vertex to centroid\n\n        # Create the Circle from moved center\n        planeC1 = rg.Plane.CreateFromPoints(cen, pt, moveCen)\n        circle01 = rg.Circle(planeC1, moveCen, len1)\n        sphere = rg.Sphere(moveCen, len1)\n        \n        # Find the intersection line1 x circle1\n        t1, t2, itp1, t4, itp2 = ri.Intersection.LineCircle(line1, circle01)\n        \n        lst1.append(itp1)  # IMPORTANT!!!!!! \n        \n\n        # Find the mid of curve\n        pt0 = ptLst[i]\n        pt1 = ptLst[(i+1) % len(ptLst)]\n        ptMid = (pt0+ pt1) /2\n        line3 = rg.Line(cen, ptMid)\n        len3 = line3.Length  # Length of small Sphere\n\n        # Create the circle for intersection\n        planeC2 = rg.Plane.CreateFromPoints(cen, ptMid, moveCen)\n        circle02 = rg.Circle(planeC2, moveCen, len3)\n\n\n\n        sphere3 = rg.Sphere(moveCen, len3)\n        lst3.append(line3)  # Line 3 is from mid to center\n        h1, h2, itp3, h3, itp4 = ri.Intersection.LineCircle(line3, circle02)\n       \n        lst4.append(itp4)\n        \n        \"\"\"   ============== CREATE THE MESH =============  \"\"\"\n\n        # Create Mesh\n        mesh = rg.Mesh()\n        i0 = mesh.Vertices.Add(moveCen)\n        i1 = mesh.Vertices.Add(itp1)\n        i2 = mesh.Vertices.Add(itp4)\n        \n        mesh.Faces.AddFace(i0, i1, i2)\n\n\n        # Scale the mesh\n        centroid = rg.Point3d((moveCen.X + itp1.X + itp4.X)/3,\n                              (moveCen.Y + itp1.Y + itp4.Y)/3,\n                              (moveCen.Z + itp1.Z + itp4.Z)/3)\n\n        xform3 = rg.Transform.Scale(centroid, factor2)\n        mesh.Transform(xform3)\n        \n        # Create mirror Plane\n        miNormal = pt0 - ptMid\n        plane = rg.Plane(ptMid, miNormal)\n        #planes.append(plane) \n        # miXform\n        miXform = rg.Transform.Mirror(plane)\n        dupMesh = mesh.Duplicate()\n        dupMesh.Transform(miXform)\n\n        meshs.extend([mesh, dupMesh])\n\na = lst1\nb = lst2\nc = lst3\nd = lst4\nf = meshs\ne = vertexs\ng = points\nh = circle01",
      "language": "python",
      "author": "ngochungwru",
      "post_number": 11,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "mesh",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 2,
  "posts_count": 11,
  "views": 4855
}