{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/ghuser_py/LBT2PH%20Create%20PHPP%20Spaces.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "ghuser_py/LBT2PH Create PHPP Spaces.py",
  "instruction": "Note: Be aware that if you plan on setting the Honeybee Ventilation or Occupancy \nLoads / Schedules using the Honyebee tools, be sure to that BEFORE you use this \ncomponent. This component will use...",
  "code": "#\n# LBT2PH: A Plugin for creating Passive House Planning Package (PHPP) models from LadybugTools. Created by blgdtyp, llc\n# \n# This component is part of the PH-Tools toolkit <https://github.com/PH-Tools>.\n# \n# Copyright (c) 2020, bldgtyp, llc <phtools@bldgtyp.com> \n# LBT2PH is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# LBT2PH is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# For a copy of the GNU General Public License\n# see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n#\n\"\"\"\nNote: Be aware that if you plan on setting the Honeybee Ventilation or Occupancy \nLoads / Schedules using the Honyebee tools, be sure to that BEFORE you use this \ncomponent. This component will use those loads/schedules to generate the PHPP values. \nIf you apply those Honeybee loads / schedules AFTER this component, those edits \nwill not be taken into account and your PHPP will not match the Honyebee/E+ model.\n-\nEM March 1, 2021\n    Args:\n        _HB_rooms: The Honeybee Rooms you would like to build the PHPP Spaces for.\n        set_honeybee_loads_: <bool> Default=False. Set 'True' to have this component \n            set the Honeybee room loads and schedules such that they match the PHPP values \n            entered here and/or found on the TFA surfaces in the Rhino model.\n        _TFA_surfaces: <list :Surface> The individual space floor surfaces represting \n            each individual 'space' inside the Honeybee Room (zone).\n        _spaces_geometry: <list :PolySurface> Geometry representing the 'space shape' \n            of an individial 'space' or area inside of the Honeybee Room. NOTE: Make \n            sure that your space-shapes are 'open' on the bottom so that they can be \n            joined to the TFA Surfaces to form a closed Brep in the end.\n        vent_flowrate_source_: <str> Enter either 'UD' or 'EP' indicating which source \n            should be used to determine the fresh-air flow rates. 'UD' (user-determined) \n            will try and read flow-rates from your Rhino geometry. So make sure that\n            you assigned flow rates to the geometry. 'EP' (EnergyPlus) will try and \n            use the E+/Honeybee Program assigned to the Honyebee Room in order to \n            determine the fresh-air flow rates.\n        phpp_vent_schedule_: An optional input for a PHPP-Style ternary ventilation \n            schedule to use for determining flow-rates.\n   Returns:\n        space_breps_: <Rhino Brep> A list of the space Breps for preview / checking\n        phpp_spaces_: A list of the PHPP-Space objects for preview / checking\n        HB_rooms_: A list of the Honeybee Rooms with the new PHPP Spaces added.\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghc\nimport Grasshopper.Kernel as ghK\nfrom copy import deepcopy\n\nimport LBT2PH\nimport LBT2PH.__versions__\nimport LBT2PH.helpers\nimport LBT2PH.spaces\nimport LBT2PH.ventilation\nimport LBT2PH.schedules\n\nreload(LBT2PH)\nreload(LBT2PH.__versions__)\nreload(LBT2PH.helpers)\nreload(LBT2PH.spaces)\nreload(LBT2PH.ventilation)\nreload(LBT2PH.schedules)\n\ntry:\n    from honeybee_energy.load.ventilation import Ventilation\n    from honeybee_energy.lib.schedules import schedule_by_identifier\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee_energy:\\n\\t{}'.format(e))\n\nghenv.Component.Name = \"LBT2PH Create PHPP Spaces\"\nLBT2PH.__versions__.set_component_params(ghenv, dev=False)\n\n# This is all from Honeybee 'ApplyLoadVals' Component\n#-------------------------------------------------------------------------------\n# get the always on schedule\nalways_on = schedule_by_identifier('Always On')\n\ndef dup_load(hb_obj, object_name, object_class):\n    \"\"\"Duplicate a load object assigned to a Room or ProgramType.\"\"\"\n    # try to get the load object assgined to the Room or ProgramType\n    try:  # assume it's a Room\n        load_obj = hb_obj.properties\n        for attribute in ('energy', object_name):\n            load_obj = getattr(load_obj, attribute)\n    except AttributeError:  # it's a ProgramType\n        load_obj = getattr(hb_obj, object_name)\n\n    load_id = '{}_{}'.format(hb_obj.identifier, object_name)\n    try:  # duplicate the load object\n        dup_load = load_obj.duplicate()\n        dup_load.identifier = load_id\n        return dup_load\n    except AttributeError:  # create a new object\n        try:  # assume it's People, Lighting, Equipment or Infiltration\n            return object_class(load_id, 0, always_on)\n        except:  # it's a Ventilation object\n            return object_class(load_id)\n\ndef assign_load(hb_obj, load_obj, object_name):\n    \"\"\"Assign a load object to a Room or a ProgramType.\"\"\"\n    try:  # assume it's a Room\n        setattr(hb_obj.properties.energy, object_name, load_obj)\n    except AttributeError:  # it's a ProgramType\n        setattr(hb_obj, object_name, load_obj)\n\ndef schedule_object(schedule):\n    \"\"\"Get a schedule object by its identifier or return it it it's already a schedule.\"\"\"\n    if isinstance(schedule, str):\n        return schedule_by_identifier(schedule)\n    return schedule\n\n# Sort out the UD TFA and Space Geometry to use\n# ------------------------------------------------------------------------------\nwith LBT2PH.helpers.context_rh_doc(ghdoc):\n    space_geom = [ rs.coercebrep(guid) for guid in _spaces_geometry ]\n\nrhino_tfa_objects = LBT2PH.spaces.find_all_tfa_surfaces(_TFA_surfaces, ghenv, ghdoc)\n\n\n# Sort the input TFA surfaces depending on which Honeybee Room they are 'in'\n# ------------------------------------------------------------------------------\nHB_rooms_ = []\ntfa_objs = {}\nif _HB_rooms:\n    for tfa_srfc_geom, tfa_srfc_params in rhino_tfa_objects:\n        # ----------------------------------------------------------------------\n        # Find the TFA's host Room/Zone\n        centroid, host_room = LBT2PH.spaces.find_tfa_host_room(tfa_srfc_geom, _HB_rooms)\n        tfa_obj = LBT2PH.spaces.TFA_Surface(tfa_srfc_geom, host_room, tfa_srfc_params)\n        if host_room is None: LBT2PH.spaces.display_host_error(tfa_obj, ghenv)\n        \n        # Add the new TFA Object to the master dict\n        # ----------------------------------------------------------------------\n        d = { tfa_obj.id : tfa_obj }\n        \n        if tfa_obj.dict_key in tfa_objs:\n            tfa_objs[tfa_obj.dict_key].update(d)\n        else:\n            tfa_objs[tfa_obj.dict_key] = d\n\n\n\n# Build default / auto PHPP-Space for each HB-Room\n# ------------------------------------------------------------------------------\nfor hb_room in _HB_rooms:\n    if not _TFA_surfaces:\n        \n        tfa_objs_from_hb = LBT2PH.spaces.TFA_Surface.from_hb_room( hb_room, ghenv )\n        \n        # Add the new TFA Object to the master dict\n        # ----------------------------------------------------------------------\n        for tfa_obj in tfa_objs_from_hb:\n            d = { tfa_obj.id : tfa_obj }\n            \n            if tfa_obj.dict_key in tfa_objs:\n                tfa_objs[tfa_obj.dict_key].update(d)\n            else:\n                tfa_objs[tfa_obj.dict_key] = d\n\n\n# Find all the 'touching' TFA surfaces, organize by 'neighbor' into groups\n# ------------------------------------------------------------------------------\nif tfa_objs:\n    for tfa_obj_list in tfa_objs.values():\n        LBT2PH.spaces.find_neighbors( tfa_obj_list )\n\ntfa_srfcs_grouped_by_neighbor = LBT2PH.spaces.bin_tfa_srfcs_by_neighbor(tfa_objs)\ntfa_srfcs_cleaned = LBT2PH.spaces.join_touching_tfa_groups(tfa_srfcs_grouped_by_neighbor, ghenv)\n\n\n# Build the Spaces for each tfa surface\n# ------------------------------------------------------------------------------\nphpp_spaces_dict = {}\nfor tfa_srfc in tfa_srfcs_cleaned:\n    # See if you can make a closed space Brep\n    # If you can, create a new Room Volume from the closed Brep set\n    # Then remove that Room's Geom from the set to test (to speed future search?)\n    # If no closables match found, create a default space volume\n    # If no space geom input, just build a default size space for each\n    \n    # --------------------------------------------------------------------------\n    if _spaces_geometry:\n        for i, space_geometry in enumerate(space_geom):\n            joined_vol = ghc.BrepJoin([space_geometry, tfa_srfc.surface])\n            if joined_vol.closed is True:\n                new_space_vol = LBT2PH.spaces.Volume( tfa_srfc, joined_vol )\n                #_spaces_geometry.pop(i) # Causes error sometimes... used to speed things up. Might be another way\n                break\n        else:\n            msg = 'Could not join {} with any space geometry.'.format(tfa_srfc.dict_key)\n            ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, msg)\n            new_space_vol = LBT2PH.spaces.Volume( tfa_srfc )\n    else:\n        new_space_vol = LBT2PH.spaces.Volume( tfa_srfc )\n    \n    \n    # --------------------------------------------------------------------------\n    # Sort the new Space Volume into the master Dict based on name\n    if new_space_vol.dict_key in phpp_spaces_dict.keys():\n        phpp_spaces_dict[new_space_vol.dict_key].append( new_space_vol )\n    else:\n        phpp_spaces_dict[new_space_vol.dict_key] = [ new_space_vol ]\n\n\n# Build the final PHPP-Spaces from all the the Space Volume Objects\n#-------------------------------------------------------------------------------\nphpp_spaces_ = []\n\nfor space_volumes in phpp_spaces_dict.values():\n    # Create a single new Room from the list of Room Volumes\n    new_space_obj = LBT2PH.spaces.Space( space_volumes )\n    phpp_spaces_.append( new_space_obj )\n\n\n\n# Set each Space's fresh-air ventilation flow rates\n#-------------------------------------------------------------------------------\nif 'UD' in str(vent_flowrate_source_).upper(): flow_type = 'UD'\nelse: flow_type = 'EP'\n\nvent_flows_by_phpp_spaces = {}\nfor hb_room in _HB_rooms:\n    # 1) Figure out the Zone's Nominal (peak) Ventilation Flow Rate\n    #    (People + Area + Zone + ACHs) based on HB Program Loads\n    #\n    # 2) Set the individual PHPP-Space Flow Rates based on the HB Program, or from Rhino Scene\n    #\n    # 3) If no UD schedule, Calculate the HB/EP Room Flow rates based on the PHPP-Rooms\n    #\n    # 4) Set the Honeybee Room load / schedule to match the PHPP rates\n    #\n    \n    room_airflow_sup = 0\n    room_airflow_eta = 0\n    room_airflow_trans = 0\n    \n    rm_hb_flow_rates = LBT2PH.ventilation.calc_room_vent_rates_from_HB(hb_room, ghenv)\n    hb_room_tfa = sum(space.space_tfa for space in phpp_spaces_ if space.host_room_name == hb_room.display_name)\n    \n    # Calc the PHPP-Space flowrates from the Honeybee-Room / EP Program Values\n    #---------------------------------------------------------------------------\n    # First, set the UD Schedule if provided, regradless of if its 'EP' or 'UD' flow-type\n    for space in phpp_spaces_:\n        if space.host_room_name != hb_room.display_name:\n            continue\n        \n        if phpp_vent_schedule_:\n            space.vent_sched = phpp_vent_schedule_\n        else:\n            if flow_type != 'UD':\n                space.vent_sched = LBT2PH.ventilation.calc_space_vent_schedule(space, hb_room, hb_room_tfa)\n    \n    # Next, Determine the Flow Rates from EP Program\n    if flow_type != 'UD':\n        for space in phpp_spaces_:\n            if space.host_room_name != hb_room.display_name:\n                continue\n            \n            # Figure out the Flow-Rates from EP-Program\n            space_vent_flow_rates = LBT2PH.ventilation.calc_space_vent_rates(space, hb_room, hb_room_tfa, rm_hb_flow_rates.nominal, ghenv)\n            if space_vent_flow_rates:\n                space.set_phpp_vent_rates( space_vent_flow_rates )\n                room_airflow_sup += space_vent_flow_rates.get('V_sup')\n                room_airflow_eta += space_vent_flow_rates.get('V_eta')\n                room_airflow_trans += space_vent_flow_rates.get('V_trans')\n    \n    # Calc the new Honeybee-Room Vent Load and Schedule to match the PHPP-Space\n    #---------------------------------------------------------------------------\n    if set_honeybee_loads_:\n        room_max_airflow = max(room_airflow_sup, room_airflow_eta, room_airflow_trans)\n        new_flowrate = ( room_max_airflow / hb_room.floor_area)/3600\n        \n        vent_flows_by_phpp_spaces[hb_room.identifier] = { 'per_area':new_flowrate, 'per_person':0 }\n\n\n\n# Pack the output\n#-------------------------------------------------------------------------------\nHB_rooms_ = []\nspace_breps_ = []\nconst_vent_sched = LBT2PH.schedules.create_hb_constant_schedule( 'PHPP_Const_Vent_Sched' )\nfor hb_room in _HB_rooms:\n    new_hb_room = hb_room.duplicate()\n    \n   # Set the PHPP Dict values\n    #---------------------------------------------------------------------------\n    spaces = {}\n    for phpp_space in phpp_spaces_:\n        if new_hb_room.display_name == phpp_space.host_room_name:\n            spaces.update( {phpp_space.dict_key : phpp_space.to_dict()}  )\n            \n            # Grab the brep for preview as well\n            space_breps_.extend(phpp_space.space_breps)\n    \n    new_hb_room = LBT2PH.helpers.add_to_HB_model(new_hb_room, 'spaces', spaces, ghenv)\n    \n    \n    # Set the Honeybee Ventilation load / schedule\n    #---------------------------------------------------------------------------\n    if vent_flows_by_phpp_spaces:\n        vent_per_floor = vent_flows_by_phpp_spaces.get(hb_room.identifier,{}).get('per_area', None)\n        vent_per_person = vent_flows_by_phpp_spaces.get(hb_room.identifier,{}).get('per_person', None)\n        \n        # vent_per_floor_ Load\n        vent = dup_load(new_hb_room, 'ventilation', Ventilation)\n        vent.flow_per_area = vent_per_floor\n        assign_load(new_hb_room, vent, 'ventilation')\n        \n        # vent_per_person_ Load (note: gets zero'd out)\n        vent = dup_load(new_hb_room, 'ventilation', Ventilation)\n        vent.flow_per_person = vent_per_person\n        assign_load(new_hb_room, vent, 'ventilation')\n        \n        ventilation = dup_load(new_hb_room, 'ventilation', 'ventilation_sch_')\n        ventilation.schedule = schedule_object(const_vent_sched)\n        assign_load(new_hb_room, ventilation, 'ventilation')\n    \n    \n    HB_rooms_.append(new_hb_room)",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}