{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/hatch.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/hatch.py",
  "instruction": null,
  "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport System.Guid\n\ndef AddHatch(curve_id, hatch_pattern=None, scale=1.0, rotation=0.0):\n    \"\"\"Creates a new hatch object from a closed planar curve object\n    Parameters:\n      curve_id = identifier of the closed planar curve that defines the\n          boundary of the hatch object\n      hatch_pattern[opt] = name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale[opt] = hatch pattern scale factor\n      rotation[opt] = hatch pattern rotation angle in degrees.\n    Returns:\n      identifier of the newly created hatch on success\n      None on error\n    \"\"\"\n    rc = AddHatches(curve_id, hatch_pattern, scale, rotation)\n    if rc: return rc[0]\n    return scriptcontext.errorhandler()\n\n\ndef AddHatches(curve_ids, hatch_pattern=None, scale=1.0, rotation=0.0):\n    \"\"\"Creates one or more new hatch objects a list of closed planar curves\n    Parameters:\n      curve_ids = identifiers of the closed planar curves that defines the\n          boundary of the hatch objects\n      hatch_pattern[opt] = name of the hatch pattern to be used by the hatch\n          object. If omitted, the current hatch pattern will be used\n      scale[opt] = hatch pattern scale factor\n      rotation[opt] = hatch pattern rotation angle in degrees.\n    Returns:\n      identifiers of the newly created hatch on success\n      None on error\n    \"\"\"\n    id = rhutil.coerceguid(curve_ids, False)\n    if id: curve_ids = [id]\n    index = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern and hatch_pattern!=index:\n        if isinstance(hatch_pattern, int):\n            index = hatch_pattern\n        else:\n            index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if index<0: return scriptcontext.errorhandler()\n    curves = [rhutil.coercecurve(id, -1, True) for id in curve_ids]\n    rotation = Rhino.RhinoMath.ToRadians(rotation)\n    hatches = Rhino.Geometry.Hatch.Create(curves, index, rotation, scale)\n    if not hatches: return scriptcontext.errorhandler()\n    ids = []\n    for hatch in hatches:\n        id = scriptcontext.doc.Objects.AddHatch(hatch)\n        if id==System.Guid.Empty: continue\n        ids.append(id)\n    if not ids: return scriptcontext.errorhandler()\n    scriptcontext.doc.Views.Redraw()\n    return ids\n\n\ndef AddHatchPatterns(filename, replace=False):\n    \"\"\"Adds hatch patterns to the document by importing hatch pattern definitions\n    from a pattern file.\n    Parameters:\n      filename = name of the hatch pattern file\n      replace[opt] = If hatch pattern names already in the document match hatch\n          pattern names in the pattern definition file, then the existing hatch\n          patterns will be redefined\n    Returns:\n      Names of the newly added hatch patterns if successful\n      None on error\n    \"\"\"\n    patterns = Rhino.DocObjects.HatchPattern.ReadFromFile(filename, True)\n    if not patterns: return scriptcontext.errorhandler()\n    rc = []\n    for pattern in patterns:\n         index = scriptcontext.doc.HatchPatterns.Add(pattern)\n         if index>=0:\n             pattern = scriptcontext.doc.HatchPatterns[index]\n             rc.append(pattern.Name)\n    if not rc: return scriptcontext.errorhandler()\n    return rc\n\n\ndef CurrentHatchPattern(hatch_pattern=None):\n    \"\"\"Returns or sets the current hatch pattern file\n    Parameters:\n      hatch_pattern[opt] = name of an existing hatch pattern to make current\n    Returns:\n      if hatch_pattern is not specified, the current hatch pattern\n      if hatch_pattern is specified, the previous hatch pattern\n      None on error\n    \"\"\"\n    rc = scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n    if hatch_pattern:\n        index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if index<0: return scriptcontext.errorhandler()\n        scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex = index\n    return rc\n\n\ndef ExplodeHatch(hatch_id, delete=False):\n    \"\"\"Explodes a hatch object into its component objects. The exploded objects\n    will be added to the document. If the hatch object uses a solid pattern,\n    then planar face Brep objects will be created. Otherwise, line curve objects\n    will be created\n    Parameters:\n      hatch_id = identifier of a hatch object\n      delete[opt] = delete the hatch object\n    Returns:\n      list of identifiers for the newly created objects\n      None on error\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(rhobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    pieces = rhobj.HatchGeometry.Explode()\n    if not pieces: return scriptcontext.errorhandler()\n    attr = rhobj.Attributes\n    rc = []\n    for piece in pieces:\n        id = None\n        if isinstance(piece, Rhino.Geometry.Curve):\n            id = scriptcontext.doc.Objects.AddCurve(piece, attr)\n        elif isinstance(piece, Rhino.Geometry.Brep):\n            id = scriptcontext.doc.Objects.AddBrep(piece, attr)\n        if id: rc.append(id)\n    return rc\n\n\ndef HatchPattern(hatch_id, hatch_pattern=None):\n    \"\"\"Returns or changes a hatch object's hatch pattern\n    Paramters:\n      hatch_id = identifier of a hatch object\n      hatch_pattern[opt] = name of an existing hatch pattern to replace the\n          current hatch pattern\n    Returns:\n      if hatch_pattern is not specified, the current hatch pattern\n      if hatch_pattern is specified, the previous hatch pattern\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    old_index = hatchobj.HatchGeometry.PatternIndex\n    if hatch_pattern:\n        new_index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n        if new_index<0: return scriptcontext.errorhandler()\n        hatchobj.HatchGeometry.PatternIndex = new_index\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return scriptcontext.doc.HatchPatterns[old_index].Name\n\n\ndef HatchPatternCount():\n    \"Returns the number of hatch patterns in the document\"\n    return scriptcontext.doc.HatchPatterns.Count\n\n\ndef HatchPatternDescription(hatch_pattern):\n    \"\"\"Returns the description of a hatch pattern. Note, not all hatch patterns\n    have descriptions\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.HatchPatterns[index].Description\n\n\ndef HatchPatternFillType(hatch_pattern):\n    \"\"\"Returns the fill type of a hatch pattern.\n        0 = solid, uses object color\n        1 = lines, uses pattern file definition\n        2 = gradient, uses fill color definition\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.HatchPatterns[index].FillType\n    return int(rc)\n\n\ndef HatchPatternNames():\n    \"Returns the names of all of the hatch patterns in the document\"\n    rc = []\n    for i in range(scriptcontext.doc.HatchPatterns.Count):\n        hatchpattern = scriptcontext.doc.HatchPatterns[i]\n        if hatchpattern.IsDeleted: continue\n        rc.append(hatchpattern.Name)\n    return rc\n\ndef HatchRotation(hatch_id, rotation=None):\n    \"\"\"Returns or modifies the rotation applied to the hatch pattern when\n    it is mapped to the hatch's plane\n    Parameters:\n      hatch_id = identifier of a hatch object\n      rotation[opt] = rotation angle in degrees\n    Returns:\n      if rotation is not defined, the current rotation angle\n      if rotation is specified, the previous rotation angle\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id, True, True)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternRotation\n    rc = Rhino.RhinoMath.ToDegrees(rc)\n    if rotation is not None and rotation!=rc:\n        rotation = Rhino.RhinoMath.ToRadians(rotation)\n        hatchobj.HatchGeometry.PatternRotation = rotation\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef HatchScale(hatch_id, scale=None):\n    \"\"\"Returns or modifies the scale applied to the hatch pattern when it is\n    mapped to the hatch's plane\n    Parameters:\n      hatch_id = identifier of a hatch object\n      scale[opt] = scale factor\n    Returns:\n      if scale is not defined, the current scale factor\n      if scale is defined, the previous scale factor\n      None on error\n    \"\"\"\n    hatchobj = rhutil.coercerhinoobject(hatch_id)\n    if not isinstance(hatchobj, Rhino.DocObjects.HatchObject):\n        return scriptcontext.errorhandler()\n    rc = hatchobj.HatchGeometry.PatternScale\n    if scale and scale!=rc:\n        hatchobj.HatchGeometry.PatternScale = scale\n        hatchobj.CommitChanges()\n        scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsHatch(object_id):\n    \"\"\"Verifies the existence of a hatch object in the document\n    Paramters:\n      object_id = identifier of an object\n    Returns:\n      True or False\n    \"\"\"\n    rhobj = rhutil.coercerhinoobject(object_id, True, False)\n    return isinstance(rhobj, Rhino.DocObjects.HatchObject)\n\n\ndef IsHatchPattern(name):\n    \"\"\"Verifies the existence of a hatch pattern in the document\n    Parameters:\n      name = the name of a hatch pattern\n    Returns:\n      True or False\n    \"\"\"\n    return scriptcontext.doc.HatchPatterns.Find(name, True)>=0\n\n\ndef IsHatchPatternCurrent(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is the current hatch pattern\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    Returns:\n      True or False\n      None on error\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return index==scriptcontext.doc.HatchPatterns.CurrentHatchPatternIndex\n\n\ndef IsHatchPatternReference(hatch_pattern):\n    \"\"\"Verifies that a hatch pattern is from a reference file\n    Parameters:\n      hatch_pattern = name of an existing hatch pattern\n    Returns:\n      True or False\n      None on error\n    \"\"\"\n    index = scriptcontext.doc.HatchPatterns.Find(hatch_pattern, True)\n    if index<0: return scriptcontext.errorhandler()\n    return scriptcontext.doc.HatchPatterns[index].IsReference\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}