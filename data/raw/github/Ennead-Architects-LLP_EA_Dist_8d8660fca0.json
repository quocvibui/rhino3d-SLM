{
  "source_url": "https://github.com/Ennead-Architects-LLP/EA_Dist/blob/635520d89b8308b78eabf5b60bb80121d0fa3838/Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import%20Export.panel/Rhino.pulldown/room2diagram.pushbutton/base_processor.py",
  "repo": "Ennead-Architects-LLP/EA_Dist",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Apps/_revit/EnneaDuck.extension/EnneadTab.tab/Import Export.panel/Rhino.pulldown/room2diagram.pushbutton/base_processor.py",
  "instruction": "Shared functionality between Rhino and Revit processing. Provides color scheme extraction and curve processor discovery.",
  "code": "#!/usr/bin/python\r\n# -*- coding: utf-8 -*-\r\n\r\n\"\"\"\r\nShared functionality between Rhino and Revit processing. Provides color scheme extraction and curve processor discovery.\r\n\"\"\"\r\n\r\n# ============================================================================\r\n# RHINOINSIDE IMPORT CHECK - MUST BE FIRST\r\n# ============================================================================\r\ntry:\r\n    import clr  # pyright: ignore\r\n    clr.AddReference('RhinoCommon')\r\n    import Rhino  # pyright: ignore\r\n    clr.AddReference('RhinoInside.Revit')\r\n    from RhinoInside.Revit.Convert.Geometry import GeometryDecoder as RIR_DECODER  # pyright: ignore\r\n    from RhinoInside.Revit.Convert.Geometry import GeometryEncoder as RIR_ENCODER  # pyright: ignore\r\n    RHINO_IMPORT_OK = True\r\nexcept:\r\n    RHINO_IMPORT_OK = False\r\n\r\n# ============================================================================\r\n# STANDARD IMPORTS\r\n# ============================================================================\r\n# from EnneadTab import NOTIFICATION  # Commented out to avoid rate limiting\r\nfrom EnneadTab.REVIT import REVIT_UNIT\r\nfrom Autodesk.Revit import DB # pyright: ignore\r\nfrom abc import abstractmethod\r\n\r\n\r\nclass BaseProcessor:\r\n    \"\"\"\r\n    Base class for shared processing functionality between Rhino and Revit.\r\n    \r\n    This class provides common functionality for:\r\n    - Color scheme extraction from Revit views\r\n    - Curve processing (fillet and offset operations)\r\n    - Space/room data extraction and processing\r\n    - View validation and element collection\r\n    - Common processing workflow orchestration\r\n    \"\"\"\r\n    \r\n    # ============================================================================\r\n    # INITIALIZATION\r\n    # ============================================================================\r\n    \r\n    def __init__(self, revit_doc, fillet_radius, offset_distance):\r\n        \"\"\"Initialize base processor.\r\n        \r\n        Args:\r\n            revit_doc: Active Revit document\r\n            fillet_radius: Corner fillet radius in feet (can be string or float)\r\n            offset_distance: Inner offset distance in feet (can be string or float)\r\n        \"\"\"\r\n        self.revit_doc = revit_doc\r\n        \r\n        # Convert to float if string values are passed\r\n        try:\r\n            self.fillet_radius = float(fillet_radius) if fillet_radius is not None else 0.0\r\n        except (ValueError, TypeError) as e:\r\n            print(\"WARNING: Invalid fillet_radius value '{}', using 0.0. Error: {}\".format(fillet_radius, str(e)))\r\n            self.fillet_radius = 0.0\r\n            \r\n        try:\r\n            self.offset_distance = float(offset_distance) if offset_distance is not None else 0.0\r\n        except (ValueError, TypeError) as e:\r\n            print(\"WARNING: Invalid offset_distance value '{}', using 0.0. Error: {}\".format(offset_distance, str(e)))\r\n            self.offset_distance = 0.0\r\n            \r\n        self.color_dict = {}\r\n        self.para_name = \"Area_$Department\"\r\n    \r\n    # ============================================================================\r\n    # PUBLIC INTERFACE METHODS\r\n    # ============================================================================\r\n    \r\n    def process_single_view(self, config, view, level_name=None):\r\n        \"\"\"Process a single view with comprehensive error handling.\r\n        \r\n        This is the main public interface for processing a single view.\r\n        It orchestrates the entire processing workflow from validation to completion.\r\n        \r\n        Args:\r\n            config: Processing configuration object\r\n            view: Revit view object to process\r\n            level_name: Optional level name override\r\n            \r\n        Returns:\r\n            bool: True if successful, False otherwise\r\n        \"\"\"\r\n        try:\r\n            # Validate view\r\n            if not view:\r\n                print(\"Cannot process: View is null\")\r\n                return False\r\n            \r\n            # SAFEGUARD: Check if view is still valid\r\n            if not view.IsValidObject:\r\n                print(\"Cannot process: View is no longer valid\")\r\n                return False\r\n            \r\n            if not self.is_view_suitable_for_processing(view):\r\n                print(\"Cannot process view '{}': View type '{}' is not suitable for room/area processing\".format(view.Name, view.ViewType))\r\n                return False\r\n            \r\n            # Process the view using the integrated approach\r\n            try:\r\n                # Determine if we need to convert to Rhino format based on processor type\r\n                # Use class name to avoid circular import issues\r\n                convert_to_rhino = self.__class__.__name__ == \"RhinoProcess\"\r\n                \r\n                # Use the integrated view processing method\r\n                results = self.process_view_with_elements(config.element_type, view, level_name, convert_to_rhino)\r\n                if results:\r\n                    # Delegate to appropriate processor with processed results\r\n                    success = self.process_spaces_from_results(results, source_view=view)\r\n                    if success:\r\n                        print(\"Successfully processed view: {}\".format(view.Name))\r\n                        return True\r\n                    else:\r\n                        print(\"Failed to process spaces for view: {}\".format(view.Name))\r\n                        return False\r\n                else:\r\n                    print(\"No results from view processing - skipping view: {}\".format(view.Name))\r\n                    return False\r\n                    \r\n            except Exception as e:\r\n                print(\"Error in view processing for view {}: {}. Skipping view.\".format(view.Name, str(e)))\r\n                return False\r\n                \r\n        except Exception as e:\r\n            print(\"CRITICAL ERROR in process_single_view for view {}: {}. Skipping view.\".format(\r\n                view.Name if view else \"Unknown\", str(e)))\r\n            return False\r\n    \r\n    def process_curves(self, input_curves, curve_type=\"rhino\"):\r\n        \"\"\"Process curves with fillet and offset operations.\r\n        \r\n        This is the main public interface for curve processing.\r\n        It handles the complete workflow from input curves to processed output.\r\n        \r\n        Args:\r\n            input_curves: List of curves (Rhino or Revit)\r\n            curve_type: \"rhino\" or \"revit\" to specify input type\r\n            \r\n        Returns:\r\n            List of processed curves (same type as input)\r\n        \"\"\"\r\n        # DEBUG logs removed for production; keep warnings/errors elsewhere\r\n        \r\n        if not input_curves or len(input_curves) == 0:\r\n            #\r\n            return input_curves\r\n        \r\n        if not RHINO_IMPORT_OK:\r\n            print(\"RhinoInside not available - using original curves\")\r\n            return input_curves\r\n        \r\n        try:\r\n            # Convert to Rhino curves for processing\r\n            #\r\n            rhino_curves = self._convert_to_rhino_curves(input_curves, curve_type)\r\n            #\r\n            \r\n            if not rhino_curves:\r\n                # print(\"  DEBUG: No Rhino curves converted, returning original\")\r\n                return input_curves\r\n            \r\n            # Join curves into a single curve\r\n            #\r\n            try:\r\n                joined_curves = Rhino.Geometry.Curve.JoinCurves(rhino_curves)\r\n                #\r\n                \r\n                if not joined_curves or len(joined_curves) == 0:\r\n                    #\r\n                    # If joining fails, try processing each curve individually\r\n                    processed_curves = []\r\n                    for curve in rhino_curves:\r\n                        processed_curve = curve\r\n                        \r\n                        # Apply fillet if specified\r\n                        if self.fillet_radius > 0:\r\n                            processed_curve = self._apply_fillet_to_rhino_curve(processed_curve)\r\n                            if not processed_curve:\r\n                                processed_curve = curve  # Use original if fillet fails\r\n                        \r\n                        # Apply offset if specified\r\n                        if self.offset_distance > 0:\r\n                            processed_curve = self._apply_offset_to_rhino_curve(processed_curve)\r\n                            if not processed_curve:\r\n                                processed_curve = curve  # Use original if offset fails\r\n                        \r\n                        processed_curves.append(processed_curve)\r\n                    \r\n                    #\r\n                    return processed_curves\r\n                \r\n                # Apply fillet if specified\r\n                if self.fillet_radius > 0:\r\n                    #\r\n                    joined_curves[0] = self._apply_fillet_to_rhino_curve(joined_curves[0])\r\n                    if not joined_curves[0]:\r\n                        #\r\n                        return input_curves\r\n                \r\n                # Apply offset if specified\r\n                if self.offset_distance > 0:\r\n                    #\r\n                    joined_curves[0] = self._apply_offset_to_rhino_curve(joined_curves[0])\r\n                    if not joined_curves[0]:\r\n                        #\r\n                        return input_curves\r\n                \r\n  \r\n                return [joined_curves[0]]\r\n                \r\n            except Exception as e:\r\n                #\r\n                # If joining fails, try processing each curve individually\r\n                processed_curves = []\r\n                for curve in rhino_curves:\r\n                    processed_curve = curve\r\n                    \r\n                    # Apply fillet if specified\r\n                    if self.fillet_radius > 0:\r\n                        processed_curve = self._apply_fillet_to_rhino_curve(processed_curve)\r\n                        if not processed_curve:\r\n                            processed_curve = curve  # Use original if fillet fails\r\n                    \r\n                    # Apply offset if specified\r\n                    if self.offset_distance > 0:\r\n                        processed_curve = self._apply_offset_to_rhino_curve(processed_curve)\r\n                        if not processed_curve:\r\n                            processed_curve = curve  # Use original if offset fails\r\n                    \r\n                    processed_curves.append(processed_curve)\r\n                \r\n                #\r\n                return processed_curves\r\n        \r\n        except Exception as e:\r\n            print(\"Error in curve processing: {}. Using original curves.\".format(str(e)))\r\n            return input_curves\r\n    \r\n    def process_spaces_from_results(self, results, processor_type=\"auto\", source_view=None):\r\n        \"\"\"Process spaces from pre-processed results.\r\n        \r\n        This method delegates to the appropriate subclass method based on processor type.\r\n        \r\n        Args:\r\n            results: Dictionary containing processed_spaces, level_name, etc.\r\n            processor_type: \"rhino\", \"revit\", or \"auto\" (detects based on class type)\r\n            source_view: Original source view (for getting scale and other properties)\r\n            \r\n        Returns:\r\n            bool: True if successful, False otherwise\r\n        \"\"\"\r\n        # Auto-detect processor type if not specified\r\n        if processor_type == \"auto\":\r\n            if hasattr(self, 'rhino_doc'):\r\n                processor_type = \"rhino\"\r\n            else:\r\n                processor_type = \"revit\"\r\n        \r\n        # Delegate to the appropriate subclass method\r\n        if processor_type == \"rhino\":\r\n            if hasattr(self, '_process_spaces_for_rhino'):\r\n                return self._process_spaces_for_rhino(results)\r\n            else:\r\n                print(\"ERROR: RhinoProcessor not available - _process_spaces_for_rhino method not found\")\r\n                return False\r\n        elif processor_type == \"revit\":\r\n            if hasattr(self, '_process_spaces_for_revit'):\r\n                return self._process_spaces_for_revit(results, source_view)\r\n            else:\r\n                print(\"ERROR: RevitProcessor not available - _process_spaces_for_revit method not found\")\r\n                return False\r\n        else:\r\n            print(\"ERROR: Unknown processor type: {}. Using default.\".format(processor_type))\r\n            # Try to auto-detect and use the available method\r\n            if hasattr(self, '_process_spaces_for_rhino'):\r\n                print(\"Falling back to Rhino processor\")\r\n                return self._process_spaces_for_rhino(results)\r\n            elif hasattr(self, '_process_spaces_for_revit'):\r\n                print(\"Falling back to Revit processor\")\r\n                return self._process_spaces_for_revit(results, source_view)\r\n            else:\r\n                print(\"ERROR: No processor methods available\")\r\n                return False\r\n    \r\n\r\n    \r\n\r\n    @abstractmethod\r\n    def _process_spaces_for_revit(self, results, source_view=None):\r\n        raise NotImplementedError(\"Subclasses must implement this method\")\r\n    \r\n    @abstractmethod\r\n    def _process_spaces_for_rhino(self, results):\r\n        raise NotImplementedError(\"Subclasses must implement this method\")\r\n    \r\n    \r\n    \r\n    \r\n \r\n    \r\n    # ============================================================================\r\n    # STATUS AND UTILITY METHODS\r\n    # ============================================================================\r\n    \r\n    def get_curve_processor_status(self):\r\n        \"\"\"Get the status of the curve processor.\r\n        \r\n        Returns:\r\n            bool: True if curve processor is available and working\r\n        \"\"\"\r\n        return RHINO_IMPORT_OK\r\n    \r\n    def get_color_dict_status(self):\r\n        \"\"\"Get the status of the color dictionary.\r\n        \r\n        Returns:\r\n            bool: True if color dictionary has entries\r\n        \"\"\"\r\n        return len(self.color_dict) > 0\r\n    \r\n    # ============================================================================\r\n    # VIEW PROCESSING METHODS\r\n    # ============================================================================\r\n    \r\n    def process_view_with_elements(self, element_type, source_view, level_name, convert_to_rhino=False):\r\n        \"\"\"Main processing function for a single view with comprehensive error handling.\r\n        \r\n        This method orchestrates the view processing workflow including validation,\r\n        element collection, and space processing.\r\n        \r\n        Args:\r\n            element_type: Type of element (\"Rooms\" or \"Areas\")\r\n            source_view: Source view to process\r\n            level_name: Optional level name override\r\n            convert_to_rhino: Boolean indicating if curves should be converted to Rhino format\r\n            \r\n        Returns:\r\n            dict: Processing results or None if failed\r\n        \"\"\"\r\n        try:\r\n            # Validate document and view\r\n            if not self.validate_document_and_view(source_view):\r\n                return None\r\n            \r\n            # Check if view is suitable for processing\r\n            if not self.is_view_suitable_for_processing(source_view):\r\n                print(\"Cannot process view '{}': View type '{}' is not suitable for room/area processing\".format(source_view.Name, source_view.ViewType))\r\n                return None\r\n            \r\n            # Collect elements from view\r\n            spaces = self.collect_elements_from_view(element_type, source_view)\r\n            if not spaces:\r\n                print(\"No elements found in view: {}\".format(source_view.Name))\r\n                return None\r\n            \r\n            # Process spaces using common logic\r\n            results = self.process_spaces_common(spaces, element_type, level_name, source_view)\r\n            \r\n            print(\"Successfully processed view: {} ({} elements)\".format(source_view.Name, len(spaces)))\r\n            return results\r\n            \r\n        except Exception as e:\r\n            print(\"Error processing view {}: {}. Skipping view.\".format(source_view.Name, str(e)))\r\n            return None\r\n    \r\n    def validate_document_and_view(self, source_view):\r\n        \"\"\"Validate that document and view are still valid.\r\n        \r\n        Args:\r\n            source_view: View to validate\r\n            \r\n        Returns:\r\n            bool: True if valid, False otherwise\r\n        \"\"\"\r\n        # SAFEGUARD: Check if document is still valid\r\n        if not self.revit_doc or not self.revit_doc.IsValidObject:\r\n            print(\"ERROR: Revit document is no longer valid\")\r\n            return False\r\n        \r\n        # SAFEGUARD: Check if view is valid\r\n        if not source_view or not source_view.IsValidObject:\r\n            print(\"ERROR: Source view is no longer valid\")\r\n            return False\r\n        \r\n        return True\r\n    \r\n    def is_view_suitable_for_processing(self, view):\r\n        \"\"\"Check if a view is suitable for room/area diagram processing.\r\n        \r\n        Args:\r\n            view: Revit view object\r\n            \r\n        Returns:\r\n            bool: True if suitable, False otherwise\r\n        \"\"\"\r\n        if not view:\r\n            return False\r\n        \r\n        # Check view type - we want views that can show rooms/areas\r\n        suitable_view_types = [\r\n            DB.ViewType.FloorPlan,\r\n            DB.ViewType.AreaPlan,\r\n            DB.ViewType.CeilingPlan,\r\n            DB.ViewType.EngineeringPlan\r\n        ]\r\n        \r\n        return view.ViewType in suitable_view_types\r\n    \r\n    def collect_elements_from_view(self, element_type, source_view):\r\n        \"\"\"Collect elements from a specific view based on element type.\r\n        \r\n        Args:\r\n            element_type: Type of element (\"Rooms\" or \"Areas\")\r\n            source_view: Source view to collect elements from\r\n            \r\n        Returns:\r\n            list: List of Revit elements\r\n        \"\"\"\r\n        try:\r\n            # Get the appropriate built-in category using the Enum\r\n            from shared_constants import ElementType\r\n            \r\n            # Handle both enum objects and string values\r\n            if hasattr(element_type, 'value'):\r\n                # It's an enum with .value property\r\n                element_type_str = element_type.value\r\n            elif hasattr(element_type, 'name'):\r\n                # It's an enum with .name property\r\n                element_type_str = element_type.name\r\n            elif hasattr(element_type, '__class__') and element_type.__class__.__name__ == 'ElementType':\r\n                # It's the ElementType class itself, use the string value\r\n                element_type_str = str(element_type)\r\n            else:\r\n                # It's already a string or other type\r\n                element_type_str = str(element_type)\r\n            \r\n            built_in_category = ElementType.get_built_in_category(element_type_str)\r\n            \r\n            # Collect elements from the source view\r\n            spaces = DB.FilteredElementCollector(self.revit_doc, source_view.Id)\\\r\n               .OfCategory(built_in_category).ToElements()\r\n            \r\n            # SAFEGUARD: Check if we got too many elements\r\n            if len(spaces) > 1000:\r\n                print(\"WARNING: Too many elements found ({}). Limiting to first 1000 to prevent memory issues.\".format(len(spaces)))\r\n                spaces = spaces[:1000]\r\n            \r\n            return spaces\r\n            \r\n        except Exception as e:\r\n            print(\"ERROR: Failed to collect elements: {}. Stopping export.\".format(str(e)))\r\n            return []\r\n    \r\n    def get_level_and_scheme_info(self, view):\r\n        \"\"\"Get level name and area scheme information from a view.\r\n        \r\n        Args:\r\n            view: Revit view object\r\n            \r\n        Returns:\r\n            dict: Dictionary with level_name and area_scheme_name\r\n        \"\"\"\r\n        level_name = \"Unknown_Level\"\r\n        area_scheme_name = \"Default\"\r\n        \r\n        if view and view.GenLevel:\r\n            level_name = view.GenLevel.Name\r\n        \r\n        # For area plans, also check the area scheme to avoid conflicts\r\n        if view.ViewType == DB.ViewType.AreaPlan:\r\n            try:\r\n                # Use the proper AreaScheme property from ViewPlan\r\n                if hasattr(view, 'AreaScheme') and view.AreaScheme:\r\n                    area_scheme_name = view.AreaScheme.Name\r\n                else:\r\n                    area_scheme_name = \"Default\"\r\n            except:\r\n                area_scheme_name = \"Default\"\r\n        \r\n        return {\r\n            'level_name': level_name,\r\n            'area_scheme_name': area_scheme_name\r\n        }\r\n    \r\n    def create_unique_identifier(self, view):\r\n        \"\"\"Create a unique identifier for a view based on level and area scheme.\r\n        \r\n        Args:\r\n            view: Revit view object\r\n            \r\n        Returns:\r\n            str: Unique identifier string\r\n        \"\"\"\r\n        info = self.get_level_and_scheme_info(view)\r\n        level_name = info['level_name']\r\n        area_scheme_name = info['area_scheme_name']\r\n        \r\n        # Create a unique identifier combining level and area scheme (only for area plans)\r\n        if view.ViewType == DB.ViewType.AreaPlan:\r\n            unique_identifier = \"{}_AreaScheme_{}\".format(level_name, area_scheme_name)\r\n        else:\r\n            # For floor plans and other view types, just use level name\r\n            unique_identifier = level_name\r\n        \r\n        return unique_identifier\r\n    \r\n    # ============================================================================\r\n    # SPACE PROCESSING METHODS\r\n    # ============================================================================\r\n    \r\n    def process_spaces_common(self, spaces, element_type, level_name, source_view):\r\n        \"\"\"Common space processing logic shared between Rhino and Revit.\r\n        \r\n        This method processes a list of spaces and extracts all necessary data\r\n        including identifiers, areas, boundary curves, and color information.\r\n        \r\n        Args:\r\n            spaces: List of Revit space objects\r\n            element_type: Type of element (\"Rooms\" or \"Areas\")\r\n            level_name: Optional level name override\r\n            source_view: Optional source view for level info and color scheme\r\n            \r\n        Returns:\r\n            dict: Processing results with color_dict, level_name, etc.\r\n        \"\"\"\r\n        # Get color scheme from source view (each view maintains its own color scheme)\r\n        self.get_color_dict(element_type, source_view)\r\n        \r\n        # Determine level name\r\n        if level_name is None:\r\n            level_name = \"Unknown_Level\"\r\n            if source_view and source_view.GenLevel:\r\n                level_name = source_view.GenLevel.Name\r\n        \r\n        # Create boundary options\r\n        option = DB.SpatialElementBoundaryOptions()\r\n        \r\n        # Process each space\r\n        processed_spaces = []\r\n        for space in spaces:\r\n            space_identifier = self.get_space_identifier(space)\r\n            if not space_identifier:\r\n                continue\r\n                \r\n            space_area = self.get_space_area(space)\r\n            boundary_curves = self.get_boundary_curves(space, option)\r\n            \r\n            processed_spaces.append({\r\n                'space': space,\r\n                'identifier': space_identifier,\r\n                'area': space_area,\r\n                'curves': boundary_curves,\r\n                'color': self.color_dict.get(space_identifier)\r\n            })\r\n        \r\n        return {\r\n            'color_dict': self.color_dict,\r\n            'level_name': level_name,\r\n            'processed_spaces': processed_spaces,\r\n            'option': option\r\n        }\r\n    \r\n    def get_color_dict(self, element_type, source_view):\r\n        \"\"\"Extract color mapping from source view's color fill scheme.\r\n        \r\n        Args:\r\n            element_type: Type of element (\"Rooms\" or \"Areas\")\r\n            source_view: Optional source view to get color scheme from (defaults to active view)\r\n            \r\n        Returns:\r\n            dict: Color mapping dictionary {identifier: color}\r\n        \"\"\"\r\n        self.color_dict = {}\r\n        \r\n        # Use source view if provided, otherwise use active view\r\n        view_to_use = source_view if source_view else self.revit_doc.ActiveView\r\n        \r\n        # Get the appropriate built-in category using the Enum\r\n        try:\r\n            from shared_constants import ElementType\r\n            \r\n            # Handle both enum objects and string values\r\n            if hasattr(element_type, 'value'):\r\n                # It's an enum with .value property\r\n                element_type_str = element_type.value\r\n            elif hasattr(element_type, 'name'):\r\n                # It's an enum with .name property\r\n                element_type_str = element_type.name\r\n            elif hasattr(element_type, '__class__') and element_type.__class__.__name__ == 'ElementType':\r\n                # It's the ElementType class itself, use the string value\r\n                element_type_str = str(element_type)\r\n            else:\r\n                # It's already a string or other type\r\n                element_type_str = str(element_type)\r\n            \r\n            built_in_category = ElementType.get_built_in_category(element_type_str)\r\n        except ValueError as e:\r\n            print(str(e))\r\n            return self.color_dict\r\n        \r\n        # Get the color scheme ID for the specified category from the source view\r\n        try:\r\n            color_scheme_id = view_to_use.GetColorFillSchemeId(DB.ElementId(built_in_category))\r\n            if color_scheme_id == DB.ElementId.InvalidElementId:\r\n                view_name = view_to_use.Name if view_to_use else \"active view\"\r\n                print(\"No color scheme found for {} in {}\".format(element_type, view_name))\r\n                return self.color_dict\r\n            \r\n            # Get the color scheme element\r\n            color_scheme = self.revit_doc.GetElement(color_scheme_id)\r\n            if not color_scheme:\r\n                print(\"Could not retrieve color scheme for {}\".format(element_type))\r\n                return self.color_dict\r\n            \r\n            # Extract color mappings from the scheme\r\n            for entry in color_scheme.GetEntries():\r\n                entry_value = entry.GetStringValue()\r\n                if entry_value:  # Only add non-empty entries\r\n                    self.color_dict[entry_value] = entry.Color\r\n                    \r\n            view_name = view_to_use.Name if view_to_use else \"active view\"\r\n            print(\"Extracted {} color mappings from {}\".format(len(self.color_dict), view_name))\r\n                    \r\n        except Exception as e:\r\n            print(\"Error retrieving color scheme for {}: {}\".format(element_type, str(e)))\r\n        \r\n        return self.color_dict\r\n    \r\n    def get_space_identifier(self, space):\r\n        \"\"\"Get space identifier from parameter.\r\n        \r\n        Args:\r\n            space: Revit space object\r\n            \r\n        Returns:\r\n            str: Space identifier or None\r\n        \"\"\"\r\n        try:\r\n            return space.LookupParameter(self.para_name).AsString()\r\n        except:\r\n            return None\r\n    \r\n    def get_space_area(self, space):\r\n        \"\"\"Get space area in square feet.\r\n        \r\n        Args:\r\n            space: Revit space object\r\n            \r\n        Returns:\r\n            float: Space area in square feet, rounded to nearest integer\r\n        \"\"\"\r\n        try:\r\n            area_sf = space.Area\r\n            return int(round(area_sf)) if area_sf > 0 else 0\r\n        except:\r\n            return 0\r\n    \r\n    def get_boundary_curves(self, space, option):\r\n        \"\"\"Get boundary curves from space.\r\n        \r\n        Args:\r\n            space: Revit space object\r\n            option: SpatialElementBoundaryOptions\r\n            \r\n        Returns:\r\n            list: List of Revit curve segments (not converted)\r\n        \"\"\"\r\n        try:\r\n            boundary_segments = space.GetBoundarySegments(option)\r\n            curve_segments = []\r\n            \r\n            if not boundary_segments:\r\n                # print(\"DEBUG: No boundary segments found\")\r\n                return curve_segments\r\n                \r\n            # print(\"DEBUG: Found {} boundary segment arrays\".format(len(boundary_segments)))\r\n            \r\n            for i, segment_array in enumerate(boundary_segments):\r\n                if not segment_array:\r\n                    # print(\"DEBUG: Segment array {} is empty\".format(i))\r\n                    continue\r\n                    \r\n                # print(\"DEBUG: Processing segment array {} with {} segments\".format(i, len(segment_array)))\r\n                \r\n                for j, segment in enumerate(segment_array):\r\n                    try:\r\n                        curve = segment.GetCurve()\r\n                        if curve:\r\n                            # According to Revit API docs, GetCurve() should return a valid Revit curve\r\n                            # Check if it's a Revit curve (has IsValidObject property)\r\n                            is_revit_curve = hasattr(curve, 'IsValidObject')\r\n                            \r\n                            if is_revit_curve:\r\n                                # It's a Revit curve - check validity and clone immediately\r\n                                if curve.IsValidObject:\r\n                                    try:\r\n                                        # Clone the curve immediately to preserve its validity\r\n                                        cloned_curve = curve.Clone()\r\n                                        if cloned_curve and cloned_curve.IsValidObject:\r\n                                            curve_segments.append(cloned_curve)\r\n                                            # print(\"DEBUG: Added cloned Revit curve from segment {}-{}\".format(i, j))\r\n                                        else:\r\n                                            # print(\"DEBUG: Cloned Revit curve is invalid from segment {}-{}\".format(i, j))\r\n                                            pass # Removed DEBUG print\r\n                                    except Exception as clone_error:\r\n                                        # print(\"DEBUG: Failed to clone Revit curve from segment {}-{}: {}\".format(i, j, str(clone_error)))\r\n                                        # Try to use original curve as fallback if it's still valid\r\n                                        if curve.IsValidObject:\r\n                                            curve_segments.append(curve)\r\n                                            # print(\"DEBUG: Added original Revit curve as fallback from segment {}-{}\".format(i, j))\r\n                                        else:\r\n                                            # print(\"DEBUG: Original Revit curve also invalid from segment {}-{}\".format(i, j))\r\n                                            pass # Removed DEBUG print\r\n                                else:\r\n                                    # print(\"DEBUG: Revit curve is invalid from segment {}-{}\".format(i, j))\r\n                                    pass # Removed DEBUG print\r\n                            else:\r\n                                # It's not a Revit curve - this shouldn't happen with GetCurve() from boundary segments\r\n                                # But if it does, try to treat it as a curve-like object\r\n                                # print(\"DEBUG: Adding non-Revit curve (type: {}) from segment {}-{}\".format(type(curve), i, j))\r\n                                curve_segments.append(curve)\r\n                        else:\r\n                            # print(\"DEBUG: No curve from segment {}-{}\".format(i, j))\r\n                            pass # Removed DEBUG print\r\n                    except Exception as segment_error:\r\n                        # print(\"DEBUG: Error processing segment {}-{}: {}\".format(i, j, str(segment_error)))\r\n                        pass # Removed DEBUG print\r\n                        \r\n            # print(\"DEBUG: Total curves extracted: {}\".format(len(curve_segments)))\r\n            return curve_segments\r\n            \r\n        except Exception as e:\r\n            print(\"Error getting boundary curves: {}\".format(str(e)))\r\n            return []\r\n    \r\n    # ============================================================================\r\n    # CURVE PROCESSING METHODS (Internal)\r\n    # ============================================================================\r\n    \r\n    def _convert_to_rhino_curves(self, input_curves, curve_type):\r\n        \"\"\"Convert input curves to Rhino curves.\r\n        \r\n        Args:\r\n            input_curves: List of input curves\r\n            curve_type: \"rhino\" or \"revit\" to specify input type\r\n            \r\n        Returns:\r\n            list: List of Rhino curves or None if conversion fails\r\n        \"\"\"\r\n        if not RHINO_IMPORT_OK:\r\n            print(\"Rhino libraries not available - cannot convert curves\")\r\n            return None\r\n        \r\n        rhino_curves = []\r\n        \r\n        if curve_type.lower() == \"rhino\":\r\n            # Input is already Rhino curves\r\n            for curve in input_curves:\r\n                if curve and hasattr(curve, 'IsValid') and curve.IsValid:\r\n                    rhino_curves.append(curve)\r\n        \r\n        elif curve_type.lower() == \"revit\":\r\n            # Convert Revit curves to Rhino curves\r\n            for curve in input_curves:\r\n                if curve:\r\n                    # Check if it's a Revit curve (has IsValidObject property)\r\n                    is_revit_curve = hasattr(curve, 'IsValidObject')\r\n                    \r\n                    if is_revit_curve:\r\n                        # It's a Revit curve (Line, Arc, etc.) - convert using RIR_ENCODER\r\n                        if curve.IsValidObject:\r\n                            try:\r\n                                rhino_curve = RIR_DECODER.ToCurve(curve)\r\n                                if rhino_curve and hasattr(rhino_curve, 'IsValid') and rhino_curve.IsValid:\r\n                                    rhino_curves.append(rhino_curve)\r\n                                    # print(\"DEBUG: Converted Revit curve to Rhino curve\")\r\n                                else:\r\n                                    print(\"Warning: Invalid Rhino curve converted from Revit curve\")\r\n                                    # Try fallback conversion\r\n                                    rhino_curve = self._fallback_curve_conversion(curve)\r\n                                    if rhino_curve:\r\n                                        rhino_curves.append(rhino_curve)\r\n                            except Exception as e:\r\n                                print(\"Warning: Failed to convert Revit curve to Rhino curve: {}\".format(str(e)))\r\n                                # Try fallback conversion\r\n                                rhino_curve = self._fallback_curve_conversion(curve)\r\n                                if rhino_curve:\r\n                                    rhino_curves.append(rhino_curve)\r\n                        else:\r\n                            # print(\"Warning: Revit curve is invalid\")\r\n                            pass # Removed DEBUG print\r\n                    else:\r\n                        # It's not a Revit curve - might already be a Rhino curve or other type\r\n                        # print(\"DEBUG: Non-Revit curve detected (type: {}), checking if it's already a valid curve\".format(type(curve)))\r\n                        \r\n                        # For non-Revit curves, try to create Rhino curves from their properties\r\n                        try:\r\n                            # Check if it's a Line type (which we saw in the debug output)\r\n                            if hasattr(curve, 'From') and hasattr(curve, 'To'):\r\n                                # It's a Line with From/To properties\r\n                                start_point = curve.From\r\n                                end_point = curve.To\r\n                                rhino_line = Rhino.Geometry.Line(\r\n                                    Rhino.Geometry.Point3d(start_point.X, start_point.Y, start_point.Z),\r\n                                    Rhino.Geometry.Point3d(end_point.X, end_point.Y, end_point.Z)\r\n                                )\r\n                                if rhino_line.IsValid:\r\n                                    # Convert Line to Curve for compatibility with Rhino methods\r\n                                    rhino_curve = rhino_line.ToNurbsCurve()\r\n                                    if rhino_curve and rhino_curve.IsValid:\r\n                                        rhino_curves.append(rhino_curve)\r\n                                        # print(\"DEBUG: Created Rhino curve from Line.From/To properties\")\r\n                                    else:\r\n                                        # print(\"Warning: Converted Rhino curve is invalid\")\r\n                                        pass # Removed DEBUG print\r\n                                else:\r\n                                    # print(\"Warning: Created Rhino line is invalid\")\r\n                                    pass # Removed DEBUG print\r\n                            elif hasattr(curve, 'GetEndPoint'):\r\n                                # Try using GetEndPoint method (like Revit curves)\r\n                                try:\r\n                                    start_point = curve.GetEndPoint(0)\r\n                                    end_point = curve.GetEndPoint(1)\r\n                                    if start_point and end_point:\r\n                                        # Create a Line first, then convert to Curve for compatibility\r\n                                        rhino_line = Rhino.Geometry.Line(\r\n                                            Rhino.Geometry.Point3d(start_point.X, start_point.Y, start_point.Z),\r\n                                            Rhino.Geometry.Point3d(end_point.X, end_point.Y, end_point.Z)\r\n                                        )\r\n                                        if rhino_line.IsValid:\r\n                                            # Convert Line to Curve for compatibility with Rhino methods\r\n                                            rhino_curve = rhino_line.ToNurbsCurve()\r\n                                            if rhino_curve and rhino_curve.IsValid:\r\n                                                rhino_curves.append(rhino_curve)\r\n                                                # print(\"DEBUG: Created Rhino curve from GetEndPoint method\")\r\n                                            else:\r\n                                                # print(\"Warning: Converted Rhino curve from GetEndPoint is invalid\")\r\n                                                pass # Removed DEBUG print\r\n                                        else:\r\n                                            # print(\"Warning: Created Rhino line from GetEndPoint is invalid\")\r\n                                            pass # Removed DEBUG print\r\n                                    else:\r\n                                        # print(\"Warning: GetEndPoint returned None\")\r\n                                        pass # Removed DEBUG print\r\n                                except Exception as get_endpoint_error:\r\n                                    # print(\"Warning: GetEndPoint failed: {}\".format(str(get_endpoint_error)))\r\n                                    pass # Removed DEBUG print\r\n                            elif hasattr(curve, 'IsValid') and curve.IsValid:\r\n                                # It already has IsValid property (might be Rhino curve)\r\n                                rhino_curves.append(curve)\r\n                                # print(\"DEBUG: Added existing valid curve (likely already Rhino)\")\r\n                            else:\r\n                                # Try to get curve properties through reflection\r\n                                # print(\"DEBUG: Attempting to inspect Line object properties\")\r\n                                try:\r\n                                    # Try to get start and end points through different methods\r\n                                    start_point = None\r\n                                    end_point = None\r\n                                    \r\n                                    # Try common property names\r\n                                    for start_prop in ['StartPoint', 'Start', 'From', 'Point1']:\r\n                                        if hasattr(curve, start_prop):\r\n                                            start_point = getattr(curve, start_prop)\r\n                                            # print(\"DEBUG: Found start point property: {}\".format(start_prop))\r\n                                            break\r\n                                    \r\n                                    for end_prop in ['EndPoint', 'End', 'To', 'Point2']:\r\n                                        if hasattr(curve, end_prop):\r\n                                            end_point = getattr(curve, end_prop)\r\n                                            # print(\"DEBUG: Found end point property: {}\".format(end_prop))\r\n                                            break\r\n                                    \r\n                                    if start_point and end_point:\r\n                                        rhino_line = Rhino.Geometry.Line(\r\n                                            Rhino.Geometry.Point3d(start_point.X, start_point.Y, start_point.Z),\r\n                                            Rhino.Geometry.Point3d(end_point.X, end_point.Y, end_point.Z)\r\n                                        )\r\n                                        if rhino_line.IsValid:\r\n                                            # Convert Line to Curve for compatibility\r\n                                            rhino_curve = rhino_line.ToNurbsCurve()\r\n                                            if rhino_curve and rhino_curve.IsValid:\r\n                                                rhino_curves.append(rhino_curve)\r\n                                                # print(\"DEBUG: Created Rhino curve from discovered properties\")\r\n                                            else:\r\n                                                # print(\"Warning: Converted Rhino curve from discovered properties is invalid\")\r\n                                                pass # Removed DEBUG print\r\n                                        else:\r\n                                            # print(\"Warning: Created Rhino line from discovered properties is invalid\")\r\n                                            pass # Removed DEBUG print\r\n                                    else:\r\n                                        # print(\"Warning: Could not find start/end point properties on Line object\")\r\n                                        # print(\"DEBUG: Available attributes: {}\".format([attr for attr in dir(curve) if not attr.startswith('_')]))\r\n                                        pass # Removed DEBUG print\r\n                                except Exception as reflect_error:\r\n                                    # print(\"Warning: Property reflection failed: {}\".format(str(reflect_error)))\r\n                                    pass # Removed DEBUG print\r\n                        except Exception as e:\r\n                             # print(\"Warning: Failed to convert non-Revit curve to Rhino: {}\".format(str(e)))\r\n                             pass # Removed DEBUG print\r\n                else:\r\n                    # print(\"Warning: Null curve in input\")\r\n                    pass # Removed DEBUG print\r\n        \r\n        # print(\"Converted {} valid Rhino curves from {} input curves\".format(len(rhino_curves), len(input_curves) if input_curves else 0))\r\n        return rhino_curves\r\n    \r\n\r\n    \r\n    def _apply_fillet_to_rhino_curve(self, rhino_curve):\r\n        \"\"\"Apply fillet to a single Rhino curve.\r\n        \r\n        Args:\r\n            rhino_curve: Rhino curve to apply fillet to\r\n            \r\n        Returns:\r\n            Rhino.Geometry.Curve: Filleted curve or original if failed\r\n        \"\"\"\r\n        if not rhino_curve or not RHINO_IMPORT_OK:\r\n            return rhino_curve\r\n        \r\n        try:\r\n            # Apply fillet using Rhino method\r\n            filleted_curve = Rhino.Geometry.Curve.CreateFilletCornersCurve(\r\n                rhino_curve,\r\n                self.fillet_radius,\r\n                0.001,  # tolerance\r\n                0.1     # angle tolerance in degrees\r\n            )\r\n            \r\n            if filleted_curve:\r\n                # print(\"Applied fillet with radius {} feet\".format(self.fillet_radius))\r\n                return filleted_curve\r\n            \r\n            print(\"Fillet failed - using original curve\")\r\n            return rhino_curve\r\n            \r\n        except Exception as e:\r\n            print(\"Error applying fillet: {}. Using original curve.\".format(str(e)))\r\n            return rhino_curve\r\n    \r\n    def _apply_offset_to_rhino_curve(self, rhino_curve):\r\n        \"\"\"Apply offset to a single Rhino curve using pure RhinoCommon with recursive retry.\r\n        \r\n        Args:\r\n            rhino_curve: Rhino curve to apply offset to\r\n            \r\n        Returns:\r\n            Rhino.Geometry.Curve: Offset curve or original if failed\r\n        \"\"\"\r\n        if not rhino_curve or not RHINO_IMPORT_OK:\r\n            return rhino_curve\r\n        \r\n        # Use recursive retry mechanism starting with full offset distance\r\n        result = self._try_offset_with_retry(rhino_curve, self.offset_distance)\r\n        return result if result else rhino_curve\r\n    \r\n    def _try_offset_with_retry(self, rhino_curve, offset_distance, min_distance=0.05):\r\n        \"\"\"Recursively try offset with progressively smaller distances.\r\n        \r\n        Args:\r\n            rhino_curve: Rhino curve to apply offset to\r\n            offset_distance: Current offset distance to try (in feet)\r\n            min_distance: Minimum offset distance threshold (in feet)\r\n            \r\n        Returns:\r\n            Rhino.Geometry.Curve: Offset curve or None if all attempts failed\r\n        \"\"\"\r\n        if not rhino_curve or not RHINO_IMPORT_OK:\r\n            return None\r\n        \r\n        # Check if we've reached minimum threshold\r\n        if offset_distance < min_distance:\r\n            print(\"Offset distance {} feet is below minimum threshold {} feet - giving up\".format(offset_distance, min_distance))\r\n            return None\r\n        \r\n        try:\r\n            # Convert offset distance to Revit units\r\n            offset_distance_revit = REVIT_UNIT.unit_to_internal(offset_distance, \"feet\")\r\n            \r\n            # Get a point inside the curve for direction (like slab offseter)\r\n            direction_point = self._get_point_inside_curve(rhino_curve)\r\n            \r\n            if not direction_point:\r\n                print(\"Could not determine offset direction for distance {} feet\".format(offset_distance))\r\n                return None\r\n            \r\n            # Get the normal vector for the curve plane (Z-axis for 2D curves)\r\n            normal_vector = Rhino.Geometry.Vector3d.ZAxis\r\n            \r\n            # Use pure RhinoCommon Curve.Offset method with proper IronPython overload\r\n            # Signature: Offset(point_on_curve, normal, distance, tolerance, corner_style)\r\n            tolerance = 0.001  # Model tolerance\r\n            corner_style = Rhino.Geometry.CurveOffsetCornerStyle.Sharp\r\n            \r\n            offset_curves = rhino_curve.Offset.Overloads[Rhino.Geometry.Point3d, Rhino.Geometry.Vector3d, float, float, Rhino.Geometry.CurveOffsetCornerStyle](direction_point, normal_vector, offset_distance_revit, tolerance, corner_style)\r\n            \r\n            if offset_curves and len(offset_curves) > 0:\r\n                # Find the closed curve (like slab offseter does)\r\n                for offset_curve in offset_curves:\r\n                    if offset_curve.IsClosed:\r\n                        print(\"Applied offset with distance {} feet (successfully)\".format(offset_distance))\r\n                        return offset_curve\r\n                \r\n                # If no closed curve found, use the first one\r\n                print(\"Applied offset with distance {} feet (using first result)\".format(offset_distance))\r\n                return offset_curves[0]\r\n            else:\r\n                # Offset failed - try with half the distance\r\n                half_distance = offset_distance / 2.0\r\n                print(\"Offset failed with distance {} feet - retrying with {} feet\".format(offset_distance, half_distance))\r\n                return self._try_offset_with_retry(rhino_curve, half_distance, min_distance)\r\n            \r\n        except Exception as e:\r\n            # Error occurred - try with half the distance\r\n            half_distance = offset_distance / 2.0\r\n            print(\"Error applying offset with distance {} feet: {}. Retrying with {} feet\".format(offset_distance, str(e), half_distance))\r\n            return self._try_offset_with_retry(rhino_curve, half_distance, min_distance)\r\n    \r\n    def _fallback_curve_conversion(self, curve):\r\n        \"\"\"Fallback method to convert Revit curve to Rhino curve when RIR_DECODER fails.\r\n        \r\n        Args:\r\n            curve: Revit curve object\r\n            \r\n        Returns:\r\n            Rhino.Geometry.Curve: Converted Rhino curve or None if failed\r\n        \"\"\"\r\n        try:\r\n            if hasattr(curve, 'GetEndPoint'):\r\n                start_point = curve.GetEndPoint(0)\r\n                end_point = curve.GetEndPoint(1)\r\n                if start_point and end_point:\r\n                    # Create a Rhino line from Revit curve endpoints\r\n                    rhino_line = Rhino.Geometry.Line(\r\n                        Rhino.Geometry.Point3d(start_point.X, start_point.Y, start_point.Z),\r\n                        Rhino.Geometry.Point3d(end_point.X, end_point.Y, end_point.Z)\r\n                    )\r\n                    if rhino_line.IsValid:\r\n                        # Convert Line to Curve for compatibility with Rhino methods\r\n                        rhino_curve = rhino_line.ToNurbsCurve()\r\n                        if rhino_curve and rhino_curve.IsValid:\r\n                            return rhino_curve\r\n        except Exception as e:\r\n            print(\"Warning: Fallback curve conversion failed: {}\".format(str(e)))\r\n        \r\n        return None\r\n    \r\n    # ============================================================================\r\n    # INTERNAL UTILITY METHODS\r\n    # ============================================================================\r\n    \r\n    def _get_point_inside_curve(self, rhino_curve):\r\n        \"\"\"Get a point inside the curve for offset direction.\r\n        \r\n        Args:\r\n            rhino_curve: Rhino curve to find point inside\r\n            \r\n        Returns:\r\n            Rhino.Geometry.Point3d: Point inside curve or None if failed\r\n        \"\"\"\r\n        try:\r\n            # Get the curve's bounding box\r\n            bbox = rhino_curve.GetBoundingBox(True)\r\n            \r\n            # Get the center of the bounding box\r\n            center = bbox.Center\r\n            \r\n            # Check if center is inside the curve\r\n            if rhino_curve.IsClosed and self._is_point_inside_curve(rhino_curve, center):\r\n                return center\r\n            \r\n            # If center is not inside, try to find a point inside\r\n            # Use the slab offseter's approach: try random points within the bounding box\r\n            import random\r\n            max_attempts = 50\r\n            \r\n            for _ in range(max_attempts):\r\n                # Generate a random point within the bounding box\r\n                x = random.uniform(bbox.Min.X, bbox.Max.X)\r\n                y = random.uniform(bbox.Min.Y, bbox.Max.Y)\r\n                z = center.Z  # Keep the same Z as the curve\r\n                \r\n                test_point = Rhino.Geometry.Point3d(x, y, z)\r\n                \r\n                if self._is_point_inside_curve(rhino_curve, test_point):\r\n                    return test_point\r\n            \r\n            # If we can't find a point inside, use the center anyway\r\n            return center\r\n            \r\n        except Exception as e:\r\n            print(\"Error finding point inside curve: {}\".format(str(e)))\r\n            return None\r\n    \r\n    def _is_point_inside_curve(self, rhino_curve, point):\r\n        \"\"\"Check if a point is inside a closed curve.\r\n        \r\n        Args:\r\n            rhino_curve: Rhino curve to check against\r\n            point: Point to check\r\n            \r\n        Returns:\r\n            bool: True if point is inside curve, False otherwise\r\n        \"\"\"\r\n        try:\r\n            if not rhino_curve.IsClosed:\r\n                return False\r\n            \r\n            # Use Rhino's point containment test\r\n            containment = rhino_curve.PointAt(point)\r\n            return containment == Rhino.Geometry.PointContainment.Inside\r\n            \r\n        except:\r\n            # Fallback: use a simple ray casting method\r\n            try:\r\n                # Cast a ray from the point and count intersections\r\n                ray = Rhino.Geometry.Ray3d(point, Rhino.Geometry.Vector3d.XAxis)\r\n                intersections = Rhino.Geometry.Intersect.Intersection.CurveRay(rhino_curve, ray)\r\n                \r\n                if intersections:\r\n                    # Odd number of intersections means point is inside\r\n                    return len(intersections) % 2 == 1\r\n                \r\n                return False\r\n            except:\r\n                return False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pass\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}