{
  "source_url": "https://github.com/antonsavov/rhino_api_for_llm/blob/43e6a31ec418d5f82df6908326818fd31e700d98/extract_api_signatures.py",
  "repo": "antonsavov/rhino_api_for_llm",
  "repo_stars": 0,
  "repo_description": "This repo contains guidelines how to feed large language models (LLMs) with accurate context and call signatures so they can generate GhPython code with fewer hallucinations.",
  "license": "MIT",
  "filepath": "extract_api_signatures.py",
  "instruction": "Extract Python-style method signatures from RhinoCommon HTML. Notes: - Processes files starting with \"M_\" and ending with \".htm\" or \".html\". - Derives fully-qualified method target (namespace.class.method) and *parameter types* from the <meta name=\"Microsoft.Help.Id\" ...> tag, because it contains fully-qualified types. - Derives *parameter names*, return type, and static/instance info from the C# \"Syntax\" code block. - Produces one line per method, e.g.: Rhino.ApplicationSettings.AppearanceSettings.SetPaintColor(whichColor: Rhino.ApplicationSettings.PaintColor, c: System.Drawing.Color, forceUiUpdate: bool) -> None No external dependencies: uses only Python stdlib. Best-effort type mapping for common .NET types to Python typing names (float, int, bool, str). Unknown types are kept as-is (often fully-qualified Rhino/System types). © Anton Savov 2025 - MIT License",
  "code": "\n#!/usr/bin/env python3\n# Extract Python-style method signatures from RhinoCommon HTML.\n#\n# Notes:\n# - Processes files starting with \"M_\" and ending with \".htm\" or \".html\".\n# - Derives fully-qualified method target (namespace.class.method) and *parameter types* from the\n#   <meta name=\"Microsoft.Help.Id\" ...> tag, because it contains fully-qualified types.\n# - Derives *parameter names*, return type, and static/instance info from the C# \"Syntax\" code block.\n# - Produces one line per method, e.g.:\n#   Rhino.ApplicationSettings.AppearanceSettings.SetPaintColor(whichColor: Rhino.ApplicationSettings.PaintColor, c: System.Drawing.Color, forceUiUpdate: bool) -> None\n#\n# No external dependencies: uses only Python stdlib.\n# Best-effort type mapping for common .NET types to Python typing names (float, int, bool, str).\n# Unknown types are kept as-is (often fully-qualified Rhino/System types).\n#\n# © Anton Savov 2025 - MIT License\n\nimport os\nimport re\nimport html\nimport sys\n\n# ---------- Configuration (overridden by CLI args if provided) ----------\nINPUT_DIRS = [r\"grasshopper-api-docs/api/grasshopper/html\",r\"rhinocommon-api-docs/api/RhinoCommon/html\"]\nOUTPUT_PATHS = [r\"ref_api_grasshopper_all.txt\", r\"ref_api_rhinocommon_all.txt\"]\n\n# ---------- Helpers ----------\n\ndef read_text(path):\n    with open(path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n        return f.read()\n\ndef extract_help_id(html_text):\n    \"\"\"\n    Return the Microsoft.Help.Id content string, e.g.:\n    'M:Rhino.Display.ColorHSL.CreateFromLCH(Rhino.Display.ColorLCH)'\n    or for ctors:\n    'M:Rhino.Display.ColorHSL.#ctor(System.Double,System.Double,System.Double)'\n    \"\"\"\n    m = re.search(r'<meta[^>]+name=[\"\\']Microsoft\\.Help\\.Id[\"\\'][^>]+content=[\"\\']([^\"\\']+)[\"\\']', html_text, re.IGNORECASE)\n    if not m:\n        return None\n    return html.unescape(m.group(1))\n\ndef extract_csharp_pre(html_text):\n    \"\"\"\n    Extract the C# Syntax code block inside the ..._code_Div1 container.\n    Returns plain text (HTML tags stripped), or None if not found.\n    \"\"\"\n    # Find the C# tab content block (conventionally *_code_Div1)\n    m = re.search(r'<div[^>]+id=[\"\\'][^\"\\']*_code_Div1[\"\\'][\\s\\S]*?<pre[^>]*>([\\s\\S]*?)</pre>', html_text, re.IGNORECASE)\n    if not m:\n        # Fallback: first <pre> on page\n        m = re.search(r'<pre[^>]*>([\\s\\S]*?)</pre>', html_text, re.IGNORECASE)\n        if not m:\n            return None\n    pre_html = m.group(1)\n    # Strip tags\n    pre_text = re.sub(r'<[^>]+>', '', pre_html)\n    # Unescape entities\n    pre_text = html.unescape(pre_text)\n    # Normalize whitespace\n    pre_text = pre_text.replace('\\r', '')\n    return pre_text.strip()\n\ndef split_types_list(s):\n    \"\"\"\n    Split a comma-separated type list that may contain nested generics like Dict{K,V}\n    Uses angle-bracket style <...> and/or curly braces {..} (docs sometimes vary).\n    Also ignores commas inside angle brackets or curly braces.\n    \"\"\"\n    parts = []\n    buf = []\n    depth_angle = 0\n    depth_curly = 0\n    depth_paren = 0  # just in case\n    for ch in s:\n        if ch == '<':\n            depth_angle += 1\n            buf.append(ch)\n        elif ch == '>':\n            depth_angle = max(0, depth_angle - 1)\n            buf.append(ch)\n        elif ch == '{':\n            depth_curly += 1\n            buf.append(ch)\n        elif ch == '}':\n            depth_curly = max(0, depth_curly - 1)\n            buf.append(ch)\n        elif ch == '(':\n            depth_paren += 1\n            buf.append(ch)\n        elif ch == ')':\n            depth_paren = max(0, depth_paren - 1)\n            buf.append(ch)\n        elif ch == ',' and (depth_angle == 0 and depth_curly == 0 and depth_paren == 0):\n            parts.append(''.join(buf).strip())\n            buf = []\n        else:\n            buf.append(ch)\n    if buf:\n        parts.append(''.join(buf).strip())\n    # Remove empty strings\n    parts = [p for p in parts if p]\n    return parts\n\ndef parse_help_id(help_id):\n    \"\"\"\n    Parse the Microsoft.Help.Id string for methods.\n    Returns:\n        container_fqn (e.g., 'Rhino.Display.ColorHSL')\n        method_raw (e.g., 'CreateFromLCH' or '#ctor')\n        param_types (list of fully-qualified types as in the meta)\n    \"\"\"\n    if not help_id or not help_id.startswith('M:'):\n        return None, None, []\n    body = help_id[2:]  # strip 'M:'\n    # Split on first '(' to isolate method target vs params\n    if '(' in body:\n        left, right = body.split('(', 1)\n        params_part = right.rsplit(')', 1)[0] if ')' in right else right\n    else:\n        left = body\n        params_part = ''\n    # Method name is the segment after last '.'\n    # But there is a special '#ctor'\n    if '.#ctor' in left:\n        container_fqn = left.split('.#ctor')[0]\n        method_raw = '#ctor'\n    else:\n        container_fqn, method_raw = left.rsplit('.', 1)\n\n    param_types = split_types_list(params_part) if params_part else []\n    return container_fqn, method_raw, param_types\n\nCS_ACCESS_KWS = {'public','private','protected','internal'}\nCS_MODIFIER_KWS = {'static','virtual','override','sealed','extern','unsafe','abstract','new','readonly','partial','async'}\n\ndef parse_csharp_signature(cs_text, container_simple):\n    \"\"\"\n    From the C# code snippet, derive:\n      - return_type (string), or None for constructors\n      - method_name (string), e.g., 'SetPaintColor' or container name for constructor\n      - param_names (list)\n      - is_static (bool)\n    container_simple is the simple class/struct name (e.g., 'ColorHSL')\n    \"\"\"\n    if not cs_text:\n        return None, None, [], False\n\n    # Reduce to the first signature block: from start to first closing paren ')'\n    # This should cover most cases including multi-line parameter lists.\n    # Remove trailing method body or semicolons.\n    text = cs_text.strip()\n    # Keep only up to the first closing parenthesis followed by optional tokens\n    # to avoid parsing property accessors or multiple overloads in the same block.\n    if ')' in text:\n        text = text[:text.index(')')+1]\n\n    # Collapse whitespace for easier parsing\n    oneline = ' '.join(text.replace('\\n', ' ').split())\n    # Example:\n    # 'public static void SetPaintColor( PaintColor whichColor, Color c, bool forceUiUpdate )'\n    # 'public ColorHSL( Color rgb )'\n\n    is_static = ' static ' in f' {oneline} '\n\n    # Extract parameter list (between outermost parentheses)\n    params_part = ''\n    if '(' in oneline and ')' in oneline:\n        head, params = oneline.split('(', 1)\n        params_part = params.rsplit(')', 1)[0].strip()\n    else:\n        head = oneline\n\n    # Clean head: remove access & modifiers\n    head_tokens = [t for t in head.strip().split() if t not in CS_ACCESS_KWS and t not in CS_MODIFIER_KWS]\n    # Now, head_tokens is like ['void','SetPaintColor'] or ['ColorHSL'] (constructor)\n    method_name = None\n    return_type = None\n    if len(head_tokens) == 1:\n        # Constructor: e.g., ['ColorHSL']\n        method_name = head_tokens[0]\n        return_type = None  # constructors return None in Python\n    elif len(head_tokens) >= 2:\n        return_type = head_tokens[-2]\n        method_name = head_tokens[-1]\n\n    # Parameter names: split on commas not in generic angles/curly\n    param_names = []\n    if params_part:\n        parts = split_types_list(params_part)\n        for p in parts:\n            # Remove default values and ref/out/params/in keywords\n            p = p.strip()\n            p = re.sub(r'\\s*=\\s*[^,]+$', '', p)  # remove default = value\n            p = re.sub(r'^(this|ref|out|params|in)\\s+', '', p)\n            # Name is the last token\n            tokens = p.split()\n            if tokens:\n                name = tokens[-1]\n                # Strip trailing commas if any\n                name = name.rstrip(',')\n                # Handle array indicator on name (should be on type, but be safe)\n                name = name.replace('[]','')\n                # Clean @ prefixes (verbatim identifiers)\n                name = name.lstrip('@')\n                # Fallback for weird cases\n                if not re.match(r'^[A-Za-z_]\\w*$', name):\n                    name = f'arg{len(param_names)+1}'\n                param_names.append(name)\n            else:\n                param_names.append(f'arg{len(param_names)+1}')\n    return return_type, method_name, param_names, is_static\n\n# Basic .NET -> Python type mapping\ndef map_dotnet_to_python(t, container_fqn=None, container_simple=None):\n    t = t.strip()\n    # Common aliases\n    aliases = {\n        'System.Void': 'None',\n        'void': 'None',\n        'System.Boolean': 'bool',\n        'bool': 'bool',\n        'System.Double': 'float',\n        'double': 'float',\n        'System.Single': 'float',\n        'float': 'float',\n        'System.Int32': 'int',\n        'int': 'int',\n        'System.Int64': 'int',\n        'long': 'int',\n        'System.String': 'str',\n        'string': 'str',\n        'System.Object': 'Any',\n        'object': 'Any',\n    }\n    # Arrays: Type[]\n    if t.endswith('[]'):\n        inner = t[:-2].strip()\n        return f'List[{map_dotnet_to_python(inner, container_fqn, container_simple)}]'\n    # Nullable: Nullable{T} or T?\n    m = re.match(r'(?:System\\.)?Nullable\\{(.+)\\}$', t)\n    if m:\n        inner = m.group(1).strip()\n        return f'Optional[{map_dotnet_to_python(inner, container_fqn, container_simple)}]'\n    if t.endswith('?') and not t.endswith('??'):\n        inner = t[:-1]\n        return f'Optional[{map_dotnet_to_python(inner, container_fqn, container_simple)}]'\n    # Generics like List{T}, Dictionary{K,V}, IEnumerable{T}\n    m = re.match(r'(?P<base>[\\w\\.]+)\\{(?P<inner>.+)\\}$', t)\n    if m:\n        base = m.group('base')\n        inner = m.group('inner')\n        inner_parts = split_types_list(inner)\n        mapped_inners = [map_dotnet_to_python(p, container_fqn, container_simple) for p in inner_parts]\n        base_map = {\n            'System.Collections.Generic.List': 'List',\n            'System.Collections.Generic.IList': 'List',\n            'System.Collections.Generic.IReadOnlyList': 'Sequence',\n            'System.Collections.Generic.IEnumerable': 'Iterable',\n            'System.Collections.Generic.ICollection': 'Sequence',\n            'System.Collections.Generic.Dictionary': 'Dict',\n            'System.Collections.Generic.IDictionary': 'Dict',\n            'System.Tuple': 'Tuple',\n        }\n        py_base = base_map.get(base, base.split('.')[-1])  # fallback: last segment\n        inner_str = ', '.join(mapped_inners)\n        return f'{py_base}[{inner_str}]'\n    # If simple alias exists\n    if t in aliases:\n        return aliases[t]\n    # If return type equals the container simple name, qualify it\n    if container_simple and t == container_simple:\n        return container_fqn or t\n    return t  # keep as-is (e.g., Rhino.Display.ColorLCH, System.Drawing.Color, etc.)\n\ndef build_signature_line(container_fqn, method_raw, param_types, cs_return_type, cs_method_name, param_names, is_static):\n    # Determine final method name\n    container_simple = container_fqn.split('.')[-1] if container_fqn else None\n    if method_raw == '#ctor' or (cs_method_name and container_simple and cs_method_name == container_simple):\n        py_method_name = '__init__'\n        py_return = 'None'\n    else:\n        py_method_name = cs_method_name or method_raw\n        # Return type mapping (best effort)\n        py_return = map_dotnet_to_python(cs_return_type or 'None', container_fqn, container_simple)\n\n    # Parameter annotations\n    ann_types = []\n    for t in param_types:\n        ann_types.append(map_dotnet_to_python(t, container_fqn, container_simple))\n\n    # Align parameter names count with types\n    if len(param_names) != len(ann_types):\n        # Fallback: generate arg1, arg2, ...\n        param_names = [f'arg{i+1}' for i in range(len(ann_types))]\n\n    params = []\n    if py_method_name == '__init__' or (not is_static and cs_method_name):\n        params.append('self')\n    for name, ann in zip(param_names, ann_types):\n        params.append(f'{name}: {ann}')\n\n    qualified = f'{container_fqn}.{py_method_name}'\n    return f'{qualified}({\", \".join(params)}) -> {py_return}'\n\ndef process_file(path):\n    html_text = read_text(path)\n    help_id = extract_help_id(html_text)\n    container_fqn, method_raw, param_types = parse_help_id(help_id or '')\n    cs_text = extract_csharp_pre(html_text)\n    cs_return_type, cs_method_name, param_names, is_static = parse_csharp_signature(cs_text or '', container_fqn.split('.')[-1] if container_fqn else None)\n\n    if not container_fqn or not (method_raw or cs_method_name):\n        return None  # not a method page\n    try:\n        line = build_signature_line(container_fqn, method_raw, param_types, cs_return_type, cs_method_name, param_names, is_static)\n        return line\n    except Exception as e:\n        return None\n\ndef filter_namespace(input_file, output_file, namespace=\"Rhino.Geometry\"):\n    with open(input_file, \"r\", encoding=\"utf-8\") as infile, \\\n         open(output_file, \"w\", encoding=\"utf-8\") as outfile:\n        \n        for line in infile:\n            if line.startswith(namespace):\n                outfile.write(line)\n\ndef main():\n\n    for input_dir, output_txt in zip(INPUT_DIRS, OUTPUT_PATHS):       \n        if not input_dir:\n            print(\"ERROR: Please provide an input directory.\")\n            sys.exit(2)\n\n        input_dir = os.path.abspath(os.path.expanduser(input_dir))\n        out_path = os.path.abspath(os.path.expanduser(output_txt))\n\n        total = 0\n        found = 0\n        lines = []\n\n        for root, dirs, files in os.walk(input_dir):\n            for fn in files:\n                if not (fn.startswith('M_') and fn.lower().endswith(('.htm', '.html'))):\n                    continue\n                total += 1\n                fp = os.path.join(root, fn)\n                line = process_file(fp)\n                if line:\n                    lines.append(line)\n                    found += 1\n\n        # Sort for stability\n        lines.sort()\n        os.makedirs(os.path.dirname(out_path), exist_ok=True)\n        with open(out_path, 'w', encoding='utf-8') as f:\n            for ln in lines:\n                f.write(ln + '\\n')\n\n        print(f\"Processed {total} method files; extracted {found} signatures.\")\n        print(f\"Output written to: {out_path}\")\n    \n    # save only Rhino.Geometry methods to a separate file\n    # Change these filenames as needed\n    input_filename = OUTPUT_PATHS[1]  # assuming Rhinocommon output\n    output_filename = \"ref_api_rhinocommon_geometry.txt\"\n    filter_namespace(input_filename, output_filename, namespace=\"Rhino.Geometry\")\n    print(f\"Filtered lines saved to {output_filename}\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}