{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Curve_addTanTanLines.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Curve_addTanTanLines.py",
  "instruction": "Creates tangent-tangent lines along curve with itself.",
  "code": "\"\"\"\r\nCreates tangent-tangent lines along curve with itself.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n211101: Created.\r\n220201: Added more options.\r\n        Now, equal but opposing lines are treated as duplicates.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nlengths_skipped = [] # Global log.\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fMinLineLength'; keys.append(key)\r\n    values[key] = 1000.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], True, 1e-6)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bKnots_NotGrevs'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'SeedPts'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Greville', 'Knot')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fEpsilon'; keys.append(key)\r\n    values[key] = 1e-5\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], True, Rhino.RhinoMath.ZeroTolerance)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMinLineLength':\r\n            if cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve and parameter with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve # Includes selection of BrepsEdges.\r\n\r\n\r\n    def customGeometryFilter(rdObj, rgObj, compIdx):\r\n        if not rgObj.IsPlanar(tolerance=Opts.values['fEpsilon']):\r\n            return False\r\n\r\n        return True\r\n\r\n    go.SetCustomGeometryFilter(customGeometryFilter)\r\n\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fMinLineLength')\r\n        addOption('bKnots_NotGrevs')\r\n        addOption('fEpsilon')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMinLineLength'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef uniqueKnots(nc):\r\n    \r\n    iK = 0\r\n    ts_Unique = []\r\n    \r\n    while iK < nc.Knots.Count:\r\n        k = nc.Knots[iK]\r\n        m = nc.Knots.KnotMultiplicity(index=iK)\r\n\r\n        if k < nc.Domain.T0:\r\n            # Overlapping knot from periodic curve.\r\n            iK += m\r\n            continue\r\n\r\n        if k > nc.Domain.T1:\r\n            # Overlapping knot from periodic curve.\r\n            break\r\n\r\n        if m < nc.Degree:\r\n            ts_Unique.append(k)\r\n\r\n        iK += m\r\n\r\n    return ts_Unique\r\n\r\n\r\ndef createLines(crv, fMinLineLength, bKnots_NotGrevs, fEpsilon, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    nc = crv.ToNurbsCurve()\r\n    \r\n    if bKnots_NotGrevs:\r\n        ts = uniqueKnots(nc)\r\n    else:\r\n        ts = list(nc.GrevilleParameters())\r\n        if not nc.IsPeriodic:\r\n            ts = ts[1:-1]\r\n    \r\n    lines = [] # for duplicate testing.\r\n    \r\n    for a, tA in enumerate(ts):\r\n        for tB in ts[a+1:]:\r\n            rc = rg.Line.TryCreateBetweenCurves(\r\n                nc, nc, tA, tB, perpendicular0=False, perpendicular1=False)\r\n            \r\n            if not rc[0]: continue\r\n            \r\n            tA_Out, tB_Out, line = rc[1:]\r\n            \r\n            line_reversed = rg.Line(line.To, line.From)\r\n            \r\n            for lineInLines in lines:\r\n                if line.EpsilonEquals(lineInLines, epsilon=fEpsilon):\r\n                    break\r\n                if line_reversed.EpsilonEquals(lineInLines, epsilon=fEpsilon):\r\n                    break\r\n\r\n            else:\r\n                # No match found.\r\n                if line.Length < fMinLineLength:\r\n                    lengths_skipped.append(line.Length)\r\n                    continue\r\n\r\n                lines.append(line)\r\n\r\n    return lines\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fMinLineLength = Opts.values['fMinLineLength']\r\n    bKnots_NotGrevs = Opts.values['bKnots_NotGrevs']\r\n    fEpsilon = Opts.values['fEpsilon']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    gLines_Out = []\r\n\r\n    for objref in objrefs:\r\n        crv = objref.Curve()\r\n        \r\n        lines = createLines(crv, fMinLineLength, bKnots_NotGrevs, fEpsilon, bEcho, bDebug)\r\n        if not lines: continue\r\n\r\n        gLines_Out.extend(sc.doc.Objects.AddLine(line) for line in lines)\r\n    \r\n    sPrint = [\"{} lines added.\".format(len(gLines_Out) if gLines_Out else \"No\")]\r\n    \r\n    if len(lengths_skipped) > 0:\r\n        sPrint.append(\"Skipped {0:} lines of lengths {1:.{3:}f} through {2:.{3:}f}.\".format(\r\n            len(lengths_skipped),\r\n            min(lengths_skipped),\r\n            max(lengths_skipped),\r\n            sc.doc.ModelDistanceDisplayPrecision))\r\n    \r\n    print('  '.join(sPrint))\r\n    \r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}