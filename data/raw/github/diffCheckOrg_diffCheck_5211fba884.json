{
  "source_url": "https://github.com/diffCheckOrg/diffCheck/blob/8f668b1f273e8d81a282c6115ba3eae07eef9235/src/gh/diffCheck/diffCheck/df_transformations.py",
  "repo": "diffCheckOrg/diffCheck",
  "repo_stars": 15,
  "repo_description": "diffCheck is a CAD-integrated tool for evaluating digital timber fabrication processes.",
  "license": "GPL-3.0",
  "filepath": "src/gh/diffCheck/diffCheck/df_transformations.py",
  "instruction": "Df transformations",
  "code": "import Rhino\nimport Rhino.Geometry as rg\n\nimport numpy as np\nimport math\n\n\ndef get_inverse_transformation(\n    x_form: Rhino.Geometry.Transform,\n) -> Rhino.Geometry.Transform:\n    \"\"\"\n        Get the inverse of a transformation\n\n        :param x_form: the transformation to get the inverse from\n        :return: the inverse transformation\n    \"\"\"\n    transformation_matrix = np.array(\n        [\n            [x_form.M00, x_form.M01, x_form.M02, x_form.M03],\n            [x_form.M10, x_form.M11, x_form.M12, x_form.M13],\n            [x_form.M20, x_form.M21, x_form.M22, x_form.M23],\n            [x_form.M30, x_form.M31, x_form.M32, x_form.M33],\n        ]\n    )\n    inverse_transformation_matrix = np.linalg.inv(transformation_matrix)\n\n    x_form_back = Rhino.Geometry.Transform()\n    for i in range(4):\n        for j in range(4):\n            x_form_back[i, j] = inverse_transformation_matrix[i, j]\n\n    return x_form_back\n\n\ndef pln_2_pln_world_transform(brep: Rhino.Geometry.Brep) -> Rhino.Geometry.Transform:\n    \"\"\"\n        Transform a brep (beam) to the world plane\n\n        :param brep: the brep to transform\n        :return: the transformation\n    \"\"\"\n\n    def _get_lowest_brep_vertex(brep) -> Rhino.Geometry.Point3d:\n        \"\"\"\n            Get the the vertex with the lowest y,x and z values\n\n            :param brep: the brep to get the lowest vertex from\n            :return: the lowest vertex\n        \"\"\"\n        biggest_vertices = brep.Vertices\n        lowest_x = 0\n        lowest_y = 0\n        lowest_z = 0\n        for vertex in biggest_vertices:\n            if vertex.Location.X < lowest_x:\n                lowest_x = vertex.Location.X\n            if vertex.Location.Y < lowest_y:\n                lowest_y = vertex.Location.Y\n            if vertex.Location.Z < lowest_z:\n                lowest_z = vertex.Location.Z\n        return Rhino.Geometry.Point3d(lowest_x, lowest_y, lowest_z)\n\n    # find the longest edge of the brep\n    edges = brep.Edges\n    longest_edge: Rhino.Geometry.Curve = None\n    longest_edge_length = 0\n    for edge in edges:\n        if edge.GetLength() > longest_edge_length:\n            longest_edge_length = edge.GetLength()\n            longest_edge = edge\n\n    # find biggest face\n    face_indices = longest_edge.AdjacentFaces()\n    faces = [brep.Faces[face_index] for face_index in face_indices]\n    biggest_face: Rhino.Geometry.BrepFace = None\n    biggest_face_area = 0\n    for face in faces:\n        if rg.AreaMassProperties.Compute(face).Area > biggest_face_area:\n            biggest_face_area = rg.AreaMassProperties.Compute(face).Area\n            biggest_face = face\n\n    # get the plane of the biggest face\n    if biggest_face.TryGetPlane()[0] is False:\n        raise ValueError(\"The face is not planar\")\n        return None\n    plane_src = biggest_face.TryGetPlane()[1]\n    plane_tgt = Rhino.Geometry.Plane.WorldXY\n\n    # plane to plane transformation\n    x_form_pln2pln = Rhino.Geometry.Transform.PlaneToPlane(plane_src, plane_tgt)\n    brep.Transform(x_form_pln2pln)\n\n    # adjust to x,y,z positive\n    lowest_vertex = _get_lowest_brep_vertex(brep)\n    x_form_transl_A = Rhino.Geometry.Transform.Translation(rg.Vector3d(-lowest_vertex))\n    brep.Transform(x_form_transl_A)\n\n    # aabb\n    bbox = brep.GetBoundingBox(True)\n    bbox_corners = bbox.GetCorners()\n    y_val_sum = 0\n    x_val_sum = 0\n    for corner in bbox_corners:\n        y_val_sum += corner.Y\n        x_val_sum += corner.X\n\n    # check if a 90 deg rotation is needed (for the joint detector)\n    x_form_transl_B = None\n    x_form_rot90z = None\n    if x_val_sum > y_val_sum:\n        # AABB is alligned to x axis. No rotation needed\n        pass\n    else:\n        # AABB is not alligned to y axis. A 90 deg rotation is needed.\n        x_form_rot90z = Rhino.Geometry.Transform.Rotation(\n            math.radians(90), rg.Vector3d.ZAxis, rg.Point3d.Origin\n        )\n        brep.Transform(x_form_rot90z)\n        lowest_vertex = _get_lowest_brep_vertex(brep)\n\n        x_form_transl_B = Rhino.Geometry.Transform.Translation(\n            rg.Vector3d(-lowest_vertex)\n        )\n        brep.Transform(x_form_transl_B)\n\n    # resume the transformations in one\n    x_form = Rhino.Geometry.Transform.Identity\n    if x_form_transl_B:\n        Rhino.Geometry.Transform.TryGetInverse(x_form_transl_B)\n        Rhino.Geometry.Transform.TryGetInverse(x_form_rot90z)\n        x_form = x_form_transl_B * x_form_rot90z\n    x_form = x_form * x_form_transl_A * x_form_pln2pln\n\n    return x_form\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}