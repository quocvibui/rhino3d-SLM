{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_selGripsPerGrevillesClosestToObjs.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_selGripsPerGrevillesClosestToObjs.py",
  "instruction": "This script will select grips (control points) of a single surface who's corresponding\r\nGreville points are closest to input reference points and curves.\r\n\r\nA case use of this is:\r\n1. Intersection...",
  "code": "\"\"\"\r\nThis script will select grips (control points) of a single surface who's corresponding\r\nGreville points are closest to input reference points and curves.\r\n\r\nA case use of this is:\r\n1. Intersection curves of the NURBS surface with another object is created.\r\n2. The intersection curves, possibly one at a time, can be the reference input of this script.\r\n3. Once selected, the grips can be transformed with visual clues to eliminate each intersection.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250127-30: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom clr import StrongBox\r\nfrom System import Array\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAutoPickSrf'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iClosestGripCtPerAnalysisPt'; keys.append(key)\r\n    values[key] = 1\r\n    riOpts[key] = ri.Custom.OptionInteger(1, setLowerLimit=True, limit=1)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddInterior'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AddInteriorGripsForCrvInput'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTolForSharedGrips'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'DistTolForEquallySharedGrips'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'iClosestGripCtPerAnalysisPt':\r\n            if cls.riOpts[key].CurrentValue == 0:\r\n                print(\"Value must be 1 or more. Now set to 1.\")\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = 1\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fTolForSharedGrips':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = Rhino.RhinoMath.ZeroTolerance\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Ref():\r\n    \"\"\"\r\n    Get grips with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves and/or points to find grips\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Point | rd.ObjectType.Curve\r\n\r\n    #go.EnablePreSelect(True, ignoreUnacceptablePreselectedObjects=False)\r\n\r\n    go.AcceptNumber(True, acceptZero=False)\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opt.clear()\r\n\r\n        #key = 'AllSrfGripsOn'; idxs_Opt[key] = go.AddOption(key)\r\n        #addOption('bAutoPickSrf')\r\n        addOption('iClosestGripCtPerAnalysisPt')\r\n        addOption('bAddInterior')\r\n        addOption('fTolForSharedGrips')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iClosestGripCtPerAnalysisPt'\r\n            Opts.riOpts[key].CurrentValue = abs(int(go.Number()))\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTolForSharedGrips'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _find_indices_of_minimums(lst, levels, tol_per_level):\r\n    zipped_lists = zip(lst, range(len(lst)))\r\n    zipped_lists.sort()\r\n    level = 1 # Base 1.\r\n    idxs_Out = [zipped_lists[0][1]]\r\n    dist_Start_of_level = zipped_lists[0][0]\r\n    for dist, idx in zipped_lists[1:]:\r\n        if (dist - dist_Start_of_level) <= tol_per_level:\r\n            idxs_Out.append(idx)\r\n        else:\r\n            level += 1\r\n            if level > levels:\r\n                return idxs_Out\r\n            dist_Start_of_level = dist\r\n            idxs_Out.append(idx)\r\n\r\n    return idxs_Out\r\n\r\n\r\ndef _getGripsIndices_GripsClosestToPoint(rgPoint, idxs_UVs, pt3ds_Grevs, levels, tol_per_level):\r\n    pt = rgPoint.Location\r\n\r\n    dists = []\r\n\r\n    for i, (iU, iV) in enumerate(idxs_UVs):\r\n        dist = pt3ds_Grevs[i].DistanceTo(pt)\r\n        dists.append(dist)\r\n\r\n    return _find_indices_of_minimums(\r\n        dists,\r\n        levels=levels,\r\n        tol_per_level=tol_per_level)\r\n\r\n\r\ndef _GrevillePt3ds_NestedList(ns):\r\n    pt3ds_Grevs = []\r\n    for iU in range(ns.Points.CountU):\r\n        pt3ds_Grevs.append([])\r\n        for iV in range(ns.Points.CountV):\r\n            pt2d = ns.Points.GetGrevillePoint(iU, iV)\r\n            pt3d = ns.PointAt(pt2d.X, pt2d.Y)\r\n            pt3ds_Grevs[-1].append(pt3d)\r\n    return pt3ds_Grevs\r\n\r\n\r\ndef _findMinGrevSpan(ns):\r\n    pt3ds_Grevs = _GrevillePt3ds_NestedList(ns)\r\n    fMinDist = float('Inf')\r\n\r\n    for iU in range(ns.Points.CountU):\r\n        for iV in range(ns.Points.CountV):\r\n            if iU < (ns.Points.CountU - 1):\r\n                dist = pt3ds_Grevs[iU][iV].DistanceTo(pt3ds_Grevs[iU+1][iV])\r\n                if dist < fMinDist:\r\n                    fMinDist = dist\r\n            if iV < (ns.Points.CountV - 1):\r\n                dist = pt3ds_Grevs[iU][iV].DistanceTo(pt3ds_Grevs[iU][iV+1])\r\n                if dist < fMinDist:\r\n                    fMinDist = dist\r\n\r\n    return fMinDist\r\n\r\n\r\ndef _curve_DivideByLength(rgCurve, segmentLength, includeEnds):\r\n    strongBox_points = StrongBox[Array[rg.Point3d]]()\r\n\r\n    ts = rgCurve.DivideByLength(\r\n        segmentLength=segmentLength,\r\n        includeEnds=True,\r\n        points=strongBox_points)\r\n\r\n    pts = list(strongBox_points.Value)\r\n\r\n    return pts\r\n\r\n\r\ndef _U_V_indices_from_flat_list_index(idx_In, v_count):\r\n    return (idx_In // v_count), (idx_In % v_count)\r\n\r\n\r\ndef _nestedList_of_NurbsSrf_CPs_from_flatList(lst):\r\n    pass\r\n\r\n\r\ndef _get_CP_indices_between_input_indices(idxs_In, countV):\r\n    \"\"\"\r\n    Parameters:\r\n        idxs_In: Flat list of int.\r\n\r\n    Returns: Flat list of int.\r\n    \"\"\"\r\n\r\n    iVs_perU = {}\r\n    iUs_perV = {}\r\n    for idx in idxs_In:\r\n        iU = idx // countV\r\n        iV = idx % countV\r\n        if iU not in iVs_perU:\r\n            iVs_perU[iU] = [iV]\r\n        else:\r\n            iVs_perU[iU].append(iV)\r\n        if iV not in iUs_perV:\r\n            iUs_perV[iV] = [iU]\r\n        else:\r\n            iUs_perV[iV].append(iU)\r\n\r\n    if not iVs_perU and not iUs_perV:\r\n        return []\r\n\r\n    idxs_Added = []\r\n\r\n    for iU in iVs_perU:\r\n        if len(iVs_perU[iU]) == 1:\r\n            continue\r\n        for iV in range(min(iVs_perU[iU])+1, max(iVs_perU[iU])):\r\n            idx_Btwn = iU*countV + iV\r\n            if idx_Btwn not in idxs_Added:\r\n                idxs_Added.append(idx_Btwn)\r\n\r\n    for iV in iUs_perV:\r\n        if len(iUs_perV[iV]) == 1:\r\n            continue\r\n        for iU in range(min(iUs_perV[iV])+1, max(iUs_perV[iV])):\r\n            idx_Btwn = iU*countV + iV\r\n            if idx_Btwn not in idxs_Added:\r\n                idxs_Added.append(idx_Btwn)\r\n\r\n    return idxs_Added\r\n\r\n\r\ndef _getGripsIndices_GripsClosestToCurve(rgCurve, segmentLength, pt3ds_Grevs, levels=1, tol_per_level=None):\r\n    pts = _curve_DivideByLength(rgCurve, segmentLength=segmentLength, includeEnds=True)\r\n\r\n    idxs_Mins_All = []\r\n\r\n    for pt in pts:\r\n        dists = []\r\n        for i in range(len(pt3ds_Grevs)):\r\n            dist = pt3ds_Grevs[i].DistanceTo(pt)\r\n            dists.append(dist)\r\n\r\n        idxs_Mins_This_pt = _find_indices_of_minimums(\r\n            dists,\r\n            levels=levels,\r\n            tol_per_level=tol_per_level)\r\n\r\n        idxs_Mins_All.extend(idxs_Mins_This_pt)\r\n\r\n    return sorted(set(idxs_Mins_All))\r\n\r\n\r\ndef selectGrips(objrefs_Ref, rdBrep_1F, iClosestGripCtPerAnalysisPt=1, bAddInterior=True, fTolForSharedGrips=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rgB = rdBrep_1F.BrepGeometry\r\n    rgS = rgB.Faces[0].UnderlyingSurface()\r\n    if not isinstance(rgS, rg.NurbsSurface):\r\n        if bEcho:\r\n            print(\"Non-NurbsSurface passed to selectGrips. Nothing will be done.\")\r\n        return\r\n\r\n    ns = rgS\r\n\r\n    if fTolForSharedGrips is None:\r\n        fTolForSharedGrips = sc.doc.ModelAbsoluteTolerance\r\n\r\n    # Creating flat lists.\r\n\r\n    #pt2ds_Grevs = []\r\n    pt3ds_Grevs = []\r\n    idxs_UVs = [] # CPs & Grevilles.\r\n\r\n    for iU in range(ns.Points.CountU):\r\n        for iV in range(ns.Points.CountV):\r\n            idxs_UVs.append((iU,iV))\r\n            pt2d = ns.Points.GetGrevillePoint(iU, iV)\r\n            #pt2ds_Grevs.append(pt2d)\r\n            pt3d = ns.PointAt(pt2d.X, pt2d.Y)\r\n            pt3ds_Grevs.append(pt3d)\r\n\r\n    fMinGrevSpan = None\r\n\r\n    idx_Grips_to_sel = []\r\n\r\n    for objref in objrefs_Ref:\r\n        rgO = objref.Object().Geometry\r\n        if isinstance(rgO, rg.Point):\r\n            idxs_Grips = _getGripsIndices_GripsClosestToPoint(\r\n                rgO,\r\n                idxs_UVs=idxs_UVs,\r\n                pt3ds_Grevs=pt3ds_Grevs,\r\n                levels=iClosestGripCtPerAnalysisPt,\r\n                tol_per_level=fTolForSharedGrips)\r\n            idx_Grips_to_sel.extend(idxs_Grips)\r\n        elif isinstance(rgO, rg.Curve):\r\n            if fMinGrevSpan is None:\r\n                fMinGrevSpan = _findMinGrevSpan(ns)\r\n                #sEval = \"fMinGrevSpan\"; print(sEval,'=',eval(sEval))\r\n            idxs_Grips = _getGripsIndices_GripsClosestToCurve(\r\n                rgO,\r\n                segmentLength=0.25*fMinGrevSpan,\r\n                pt3ds_Grevs=pt3ds_Grevs,\r\n                levels=iClosestGripCtPerAnalysisPt,\r\n                tol_per_level=fTolForSharedGrips)\r\n            idx_Grips_to_sel.extend(idxs_Grips)\r\n\r\n            if bAddInterior:\r\n                idxs_Grips = _get_CP_indices_between_input_indices(idxs_Grips, ns.Points.CountV)\r\n            idx_Grips_to_sel.extend(idxs_Grips)\r\n\r\n        else:\r\n            if bEcho:\r\n                print(\"{} is no supported as reference geometry.\".format(rgO))\r\n\r\n    if not idx_Grips_to_sel:\r\n        return\r\n\r\n    rdGrips = None\r\n    rdGrips_AlreadySelected = []\r\n    bGrips_AlreadyOn = rdBrep_1F.GripsOn\r\n\r\n    if not bGrips_AlreadyOn:\r\n        rdBrep_1F.GripsOn = True\r\n\r\n    rdGrips = rdBrep_1F.GetGrips()\r\n\r\n    if bGrips_AlreadyOn:\r\n        if rdBrep_1F.GripsSelected:\r\n            for i, rdG in enumerate(rdGrips):\r\n                if rdG.IsSelected(checkSubObjects=False):\r\n                    print(i, rdG.Index)\r\n                    rdGrips_AlreadySelected.append(rdG.Index)\r\n\r\n    iCt_Selected = 0\r\n\r\n    for iG in idx_Grips_to_sel:\r\n        rv = rdGrips[iG].Select(\r\n            on=True,\r\n            syncHighlight=True,\r\n            persistentSelect=True,\r\n            ignoreGripsState=True,\r\n            ignoreLayerLocking=False,\r\n            ignoreLayerVisibility=False)\r\n        if rv:\r\n            iCt_Selected += 1\r\n\r\n    if bEcho:\r\n        if not iCt_Selected:\r\n            print(\"No grips were selected.\")\r\n        else:\r\n            print(\"{} surface grips are selected.\".format(iCt_Selected))\r\n\r\n\r\ndef _findClosestSrf(objrefs):\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    rdBs_Pass = [] # Normal, 1-face, & NurbsSurface.\r\n    for rdB in sc.doc.Objects.GetObjectList(oes):\r\n        if rdB.BrepGeometry.Faces.Count != 1:\r\n            continue\r\n        rgS = rdB.BrepGeometry.Faces[0].UnderlyingSurface()\r\n        if not isinstance(rgS, rg.NurbsSurface):\r\n            continue\r\n        rdBs_Pass.append(rdB)\r\n\r\n    pts = []\r\n    for objref in objrefs:\r\n        rdO = objref.Object()\r\n        rgO = rdO.Geometry\r\n        if isinstance(rgO, rg.Point):\r\n            pt = rgO.Location\r\n            pts.append(pt)\r\n        elif isinstance(rgO, rg.Curve):\r\n            pt = rgO.PointAtMid\r\n            pts.append(pt)\r\n\r\n    if not pts:\r\n        return\r\n\r\n    dist_per_B = []\r\n\r\n    for rdB in rdBs_Pass:\r\n        dists_thisB = []\r\n        for pt in pts:\r\n            pt_OnB = rdB.BrepGeometry.ClosestPoint(pt)\r\n            dist = pt_OnB.DistanceTo(pt)\r\n            dists_thisB.append(dist)\r\n        dist_per_B.append(min(dists_thisB))\r\n\r\n    return rdBs_Pass[dist_per_B.index(min(dist_per_B))]\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_Ref = getInput_Ref()\r\n    if objrefs_Ref is None: return\r\n\r\n    bAutoPickSrf = Opts.values['bAutoPickSrf']\r\n    iClosestGripCtPerAnalysisPt = Opts.values['iClosestGripCtPerAnalysisPt']\r\n    bAddInterior = Opts.values['bAddInterior']\r\n    fTolForSharedGrips = Opts.values['fTolForSharedGrips']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if bAutoPickSrf:\r\n        rdB = _findClosestSrf(objrefs_Ref)\r\n        #rdB.Select(\r\n        #    on=True,\r\n        #    syncHighlight=True,\r\n        #    persistentSelect=True,\r\n        #    ignoreGripsState=True,\r\n        #    ignoreLayerLocking=False,\r\n        #    ignoreLayerVisibility=False)\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    selectGrips(\r\n        objrefs_Ref=objrefs_Ref,\r\n        rdBrep_1F=rdB,\r\n        iClosestGripCtPerAnalysisPt=iClosestGripCtPerAnalysisPt,\r\n        bAddInterior=bAddInterior,\r\n        fTolForSharedGrips=fTolForSharedGrips,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n    )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}