{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_ExtractKnitConstraintsFromOpenMeshPatch.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_ExtractKnitConstraintsFromOpenMeshPatch.py",
  "instruction": "Extracts the necessary constraint to create KnitContours for an open mesh with\none closed boundary based  on specified parameters. The constraints consist of\na start, end as well as a  left and right...",
  "code": "\"\"\"\nExtracts the necessary constraint to create KnitContours for an open mesh with\none closed boundary based  on specified parameters. The constraints consist of\na start, end as well as a  left and right boundary. Preview shows the start\ncourse in red, the end course in green and the left/right boundaries in blue.\nTo extract the constraints, the boundary of the mesh is broken apart at kinks\nwhich exceed the specified break angle. The 'Start' and 'End' parameters define\nindices for the resulting list of polylines.\n    Inputs:\n        Mesh: The mesh that should be knit for constraint extraction.\n              {item, mesh}\n        BreakAngle: Angle at which to break apart mesh boundary.\n                    {item, float}\n        StartIndex: Index for the start course.\n                    {item, integer}\n        EndIndex: Index for the end course.\n                  {item, integer}\n    Output:\n        KnitConstraints: The KnitConstraint for this mesh for contour\n                         generation.\n                         {item, KnitConstraint}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 210929\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"ExtractKnitConstraintsFromOpenMeshPatch\"\nghenv.Component.NickName =\"EKCFOMP\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"04 Constraints\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    from cockatoo import KnitConstraint\n    from cockatoo.utilities import break_polyline\nexcept ImportError as e:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass ExtractKnitConstraintsFromOpenMeshPatch(component):\n    \n    def __init__(self):\n        super(ExtractKnitConstraintsFromOpenMeshPatch, self).__init__()\n        self.SC = None\n        self.EC = None\n        self.LB = []\n        self.RB = []\n    \n    def get_ClippingBox(self):\n        return Rhino.Geometry.BoundingBox()\n    \n    def DrawViewportWires(self, args):\n        try:\n            # get display from args\n            display = args.Display\n            \n            if self.SC and self.EC:\n                # diplay colors for start and end in custom display\n                scol = System.Drawing.Color.Red\n                ecol = System.Drawing.Color.Green\n                bcol = System.Drawing.Color.SkyBlue\n                # add start and end to customdisplay\n                display.DrawCurve(self.SC, scol, 3)\n                display.DrawCurve(self.EC, ecol, 3)\n                [display.DrawCurve(c, bcol, 2) for c in self.LB]\n                [display.DrawCurve(c, bcol, 2) for c in self.RB]\n            \n        except Exception, e:\n            System.Windows.Forms.MessageBox.Show(str(e),\n                                                 \"Error while drawing preview!\")\n    \n    def RunScript(self, Mesh, BreakAngle, Start, End, FlipDir):\n        # define default break angle for mesh boundary\n        if BreakAngle == None:\n            BreakAngle = 1.0\n        \n        NullTree = Grasshopper.DataTree[object]()\n        \n        if not Mesh or Start == None or End == None:\n            if not Mesh:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No Mesh input!\")\n            if not Start:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No Start input!\")\n            if not End:\n                rml = self.RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rml, \"No End input!\")\n            return NullTree\n        \n        # get naked edges of the mesh boundary\n        meshBoundary = list(Mesh.GetNakedEdges())\n        if len(meshBoundary) > 1:\n            raise NotImplementedError(\"Meshes with multiple closed boundaries\"+\n                                      \" are not supported yet!\")\n            return Grasshopper.DataTree[object]()\n        \n        # break the boundary polyline based on angles\n        boundarysegments = break_polyline(meshBoundary[0], BreakAngle, as_crv=True)\n        \n        # sanitize start and end inputs\n        if Start > len(boundarysegments)-1:\n            Start = len(boundarysegments)-1\n        if End > len(boundarysegments)-1:\n            End = len(boundarysegments)-1\n        \n        # extract left and right boundaries by indices\n        if Start == End:\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, \"Start index cannot be the same as \" +\n                                       \"end index! Aborting...\")\n            return NullTree\n        elif Start > End:\n            Right = boundarysegments[End+1:Start]\n            Left = boundarysegments[0:End] + boundarysegments[Start+1:]\n        elif End > Start:\n            Right = boundarysegments[Start+1:End]\n            Left = boundarysegments[0:Start] + boundarysegments[End+1:]\n        \n        # extract start and end course polyline by index\n        if FlipDir:\n            StartCourse = boundarysegments[End]\n            EndCourse = boundarysegments[Start]\n        else:\n            StartCourse = boundarysegments[Start]\n            EndCourse = boundarysegments[End]\n        \n        # join the boundary curves\n        if len(Left) > 0:\n            LeftBoundary = list(Rhino.Geometry.Curve.JoinCurves(Left))[0]\n        else:\n            print StartCourse.PointAtEnd == EndCourse.PointAtStart\n            raise NotImplementedError(\"Touching start and end courses are \" +\n                                      \"not supported yet!\")\n        if len(Right) > 0:\n            RightBoundary = list(Rhino.Geometry.Curve.JoinCurves(Right))[0]\n        else:\n            print StartCourse.PointAtStart == EndCourse.PointAtEnd\n            raise NotImplementedError(\"Touching start and end courses are \" +\n                                      \"not supported yet!\")\n        \n        # StartBoundary startpoint\n        ssp = StartCourse.PointAtStart\n        # EndBoundary startpoint\n        esp = EndCourse.PointAtStart\n        # LeftBoundary startpoint\n        lsp = LeftBoundary.PointAtStart\n        # RightBoundary startpoint\n        rsp = RightBoundary.PointAtStart\n        \n        # define maximum distance for boundary direction flipping as 10 * abstol\n        md = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n        md = md * 10\n        \n        # check for flipping of left and right boundaries\n        lbsccp = StartCourse.ClosestPoint(lsp, md)\n        rbsccp = StartCourse.ClosestPoint(rsp, md)\n        if not lbsccp[0]:\n            LeftBoundary.Reverse()\n        if not rbsccp[0]:\n            RightBoundary.Reverse()\n        \n        # check for flipping of start and end courses\n        scrbcp = LeftBoundary.ClosestPoint(ssp, md)\n        ecrbcp = LeftBoundary.ClosestPoint(esp, md)\n        if not scrbcp[0]:\n            StartCourse.Reverse()\n        if not ecrbcp[0]:\n            EndCourse.Reverse()\n        \n        # Break apart left and right boundaries again so we don't have to do\n        # it yet again in the next step\n        LeftBoundary = break_polyline(LeftBoundary.ToPolyline(),\n                                      BreakAngle,\n                                      as_crv=True)\n        RightBoundary = break_polyline(RightBoundary.ToPolyline(),\n                                       BreakAngle,\n                                       as_crv=True)\n        \n        # set left and right for preview drawing\n        self.SC = StartCourse\n        self.EC = EndCourse\n        self.LB = LeftBoundary\n        self.RB = RightBoundary\n        \n        KC = KnitConstraint(StartCourse, EndCourse, LeftBoundary, RightBoundary)\n        \n        # DEPRECATED!\n        # KnitConstraints = Grasshopper.DataTree[object]()\n        # KnitConstraints.Add(StartCourse, Grasshopper.Kernel.Data.GH_Path(0))\n        # KnitConstraints.Add(EndCourse, Grasshopper.Kernel.Data.GH_Path(1))\n        # KnitConstraints.AddRange(LeftBoundary, Grasshopper.Kernel.Data.GH_Path(2))\n        # KnitConstraints.AddRange(RightBoundary, Grasshopper.Kernel.Data.GH_Path(3))\n        \n        # return outputs if you have them; here I try it for you:\n        return KC\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}