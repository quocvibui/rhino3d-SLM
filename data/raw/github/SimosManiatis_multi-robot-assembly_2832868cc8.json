{
  "source_url": "https://github.com/SimosManiatis/multi-robot-assembly/blob/e0f9038e33e420b5b5cfafb368d99047f645e6d7/src/robotic_assembly/RobotSetup.py",
  "repo": "SimosManiatis/multi-robot-assembly",
  "repo_stars": 0,
  "repo_description": "The project is  focused on designing a system of multi-robot assembly of rigidity-preserving structures, all while eliminating the use of scaffolding. ",
  "license": "MIT",
  "filepath": "src/robotic_assembly/RobotSetup.py",
  "instruction": "Import necessary modules for RoboDK communication and robot programming",
  "code": "# Import necessary modules for RoboDK communication and robot programming\nimport robolink as rl        # RoboLink module to interact with RoboDK software\nimport robodk as rdk         # RoboDK module for robot simulations and manipulations\nfrom math import radians     # Function to convert degrees to radians\n\n# Set this to True to enable debug outputs for troubleshooting\ndebug = True\n\n# Check if the script is running inside Rhino/Grasshopper environment\ntry:\n    # Try to import Rhino.Geometry module\n    import Rhino.Geometry as rg\n    inside_rhino = True\n    if debug:\n        print(\"Running inside Rhino/Grasshopper environment.\")\nexcept ImportError:\n    # If import fails, assume script is running outside Rhino and use rhino3dm\n    import rhino3dm as rg\n    inside_rhino = False\n    if debug:\n        print(\"Running outside Rhino; using rhino3dm.\")\n\n# Initialize the RoboDK API (RoboLink) to communicate with RoboDK software\nRDK = rl.Robolink()\n\n# Define a custom exception class for robot-related errors\nclass RobotError(Exception):\n    pass\n\ndef connect_to_robot(robot_name):\n    \"\"\"\n    Connects to a robot in the RoboDK station by its name.\n\n    Parameters:\n    robot_name (str): The name of the robot to connect to.\n\n    Returns:\n    robot (Robolink.Item): The robot item in RoboDK.\n\n    Raises:\n    RobotError: If the robot is not found in the RoboDK station.\n    \"\"\"\n    if debug:\n        print(f\"Attempting to connect to robot '{robot_name}'.\")\n    # Search for the robot in the RoboDK station\n    robot = RDK.Item(robot_name, rl.ITEM_TYPE_ROBOT)\n    if not robot.Valid():\n        # If robot is not found, raise an error\n        raise RobotError(f\"Could not find robot '{robot_name}' in RoboDK.\")\n    if debug:\n        print(f\"Successfully connected to robot '{robot_name}'.\")\n    return robot\n\ndef set_robot_base(robot, rotation_angles, robot_name):\n    \"\"\"\n    Sets the robot's base frame orientation to the specified rotation angles while keeping the current position.\n\n    Parameters:\n    robot (Robolink.Item): The robot item in RoboDK.\n    rotation_angles (tuple): A tuple containing rotation angles (rx_deg, ry_deg, rz_deg) in degrees.\n    robot_name (str): The name of the robot.\n\n    Returns:\n    str: A success message indicating the new base orientation.\n\n    Raises:\n    RobotError: If the robot base cannot be found or accessed.\n    \"\"\"\n    if debug:\n        print(f\"Setting base orientation for robot '{robot_name}'.\")\n        print(f\"Rotation angles (degrees): RX={rotation_angles[0]}, RY={rotation_angles[1]}, RZ={rotation_angles[2]}\")\n\n    # Get the robot's parent item, which should be its base frame\n    robot_base = robot.Parent()\n    if robot_base.Valid():\n        # Retrieve the current pose (position and orientation) of the robot base\n        current_base_pose = robot_base.Pose()\n        # Extract the position component of the pose\n        current_position = current_base_pose.Pos()\n\n        # Unpack rotation angles\n        rx_deg, ry_deg, rz_deg = rotation_angles\n        # Create a rotation matrix from the specified rotation angles\n        rotation_matrix = (\n            rdk.rotx(radians(rx_deg)) *\n            rdk.roty(radians(ry_deg)) *\n            rdk.rotz(radians(rz_deg))\n        )\n\n        # Combine the current position with the new rotation to create the new base pose\n        new_base_pose = rdk.transl(*current_position) * rotation_matrix\n\n        # Update the robot's base frame with the new pose\n        robot_base.setPose(new_base_pose)\n\n        if debug:\n            print(\"Robot base orientation has been set successfully.\")\n    else:\n        # If the robot base is not valid, raise an error\n        raise RobotError(\"Could not find or access the robot base.\")\n\n    return f\"Robot '{robot_name}' base orientation set to RX={rx_deg}, RY={ry_deg}, RZ={rz_deg} degrees.\"\n\ndef get_current_base_position(robot):\n    \"\"\"\n    Retrieves the current base position and the first joint rotation of the robot.\n\n    Parameters:\n    robot (Robolink.Item): The robot item in RoboDK.\n\n    Returns:\n    str: A message containing the current base position and the first joint rotation.\n\n    Raises:\n    RobotError: If the robot base cannot be retrieved.\n    \"\"\"\n    if debug:\n        print(\"Retrieving current base position of the robot.\")\n    # Get the robot's parent item, which should be its base frame\n    robot_base = robot.Parent()\n    if robot_base.Valid():\n        # Retrieve the current pose (position and orientation) of the robot base\n        current_base_pose = robot_base.Pose()\n        # Extract the position component of the pose\n        current_position = current_base_pose.Pos()\n        # Get the robot's current joint angles\n        joints = robot.Joints().list()\n        # Get the rotation angle of the first joint (in degrees)\n        first_joint_deg = joints[0]\n        if debug:\n            print(f\"Current base position: X={current_position[0]}, Y={current_position[1]}, Z={current_position[2]}, First joint rotation: {first_joint_deg} degrees.\")\n        return f\"Current base position: X={current_position[0]}, Y={current_position[1]}, Z={current_position[2]}, First joint rotation: {first_joint_deg} degrees\"\n    else:\n        # If the robot base is not valid, raise an error\n        raise RobotError(\"Could not retrieve base position.\")\n\ndef validate_point_index(point_index, points_list):\n    \"\"\"\n    Validates that the given point index is within the bounds of the points list.\n\n    Parameters:\n    point_index (int): The index of the point to validate.\n    points_list (list): The list of points.\n\n    Returns:\n    bool: True if the index is valid, False otherwise.\n    \"\"\"\n    if debug:\n        print(f\"Validating point index {point_index} (Total points: {len(points_list)}).\")\n    # Check if point_index is within the range of points_list\n    return 0 <= point_index < len(points_list)\n\ndef rhino_to_robodk_coordinates(point):\n    \"\"\"\n    Converts a point from Rhino coordinate system to RoboDK coordinate system.\n\n    Parameters:\n    point (rg.Point3d): The point to convert.\n\n    Returns:\n    tuple: A tuple containing the X, Y, Z coordinates.\n    \"\"\"\n    if debug:\n        print(f\"Converting point ({point.X}, {point.Y}, {point.Z}) to RoboDK coordinates.\")\n    # Return the point's coordinates as a tuple\n    return point.X, point.Y, point.Z\n\n# Main script logic starts here\ntry:\n    # If the script is running outside Rhino, set default input parameters\n    if not inside_rhino:\n        # Define the robot's name as it appears in RoboDK\n        RobotName = 'YourRobotName'\n        # Define a list of table points (positions) using Rhino geometry points\n        TablePoints = [\n            rg.Point3d(100, 200, 300),\n            rg.Point3d(400, 500, 600),\n        ]\n        # Select the index of the point to use from TablePoints\n        PointIndex = 0\n        # Boolean flag to determine if the robot's base should be set\n        SetBase = True\n        # Define the rotation angles for setting the robot base orientation\n        RotationAngles = (0, 0, 180)  # Rotation angles as a tuple (RX, RY, RZ) in degrees\n\n    # Debug output of input parameters\n    if debug:\n        print(\"All input parameters have been validated.\")\n        print(f\"RobotName: {RobotName}\")\n        print(f\"PointIndex: {PointIndex}\")\n        print(f\"SetBase: {SetBase}\")\n        if SetBase:\n            print(f\"RotationAngles: RX={RotationAngles[0]}, RY={RotationAngles[1]}, RZ={RotationAngles[2]}\")\n\n    # Connect to the robot specified by RobotName\n    robot = connect_to_robot(RobotName)\n\n    # Validate that the selected point index is within the range of TablePoints\n    if not validate_point_index(PointIndex, TablePoints):\n        raise IndexError(f\"Point index {PointIndex} is out of bounds.\")\n\n    # Retrieve the selected point from TablePoints\n    point = TablePoints[PointIndex]\n    # Convert the Rhino point to RoboDK coordinates\n    x, y, z = rhino_to_robodk_coordinates(point)\n\n    # Debug output of the point coordinates\n    if debug:\n        print(f\"Using point coordinates: X={x}, Y={y}, Z={z}\")\n\n    if SetBase:\n        # Set the robot's base frame orientation to the specified rotation angles\n        SuccessMessage = set_robot_base(robot, RotationAngles, RobotName)\n        # Prepare a message with the new base orientation\n        BasePosition = f\"Base orientation set to: RX={RotationAngles[0]}, RY={RotationAngles[1]}, RZ={RotationAngles[2]} degrees\"\n\n        if debug:\n            # Debug output of success messages\n            print(SuccessMessage)\n            print(BasePosition)\n    else:\n        # Retrieve the current base position and first joint rotation\n        BasePosition = get_current_base_position(robot)\n        SuccessMessage = f\"Connected to robot '{RobotName}' and retrieved current base position and first joint rotation.\"\n\n        if debug:\n            # Debug output of success messages\n            print(SuccessMessage)\n            print(BasePosition)\n\nexcept (RobotError, IndexError, NameError) as e:\n    # Catch any custom RobotError, IndexError, or NameError exceptions\n    SuccessMessage = f\"Error: {e}\"\n    BasePosition = \"\"\n\n    if debug:\n        # Debug output of the error message\n        print(SuccessMessage)\n\n# If the script is running inside Rhino, assign outputs to variables\nif inside_rhino:\n    # Assign output variables for Rhino/Grasshopper components\n    A = SuccessMessage\n    B = BasePosition\nelse:\n    # If running outside Rhino, print the outputs to the console\n    print(SuccessMessage)\n    print(BasePosition)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhino3dm"
  ],
  "has_docstring": true
}