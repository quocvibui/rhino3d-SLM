{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_faces_with_small_area_over_perimeterLength.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_faces_with_small_area_over_perimeterLength.py",
  "instruction": "Spb brep faces with small area over perimeter length",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n250514: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fMaxTol'; keys.append(key)\r\n    #values[key] = max((sc.doc.ModelAbsoluteTolerance)**2.0, 1e-6)\r\n    #values[key] = (1.5 * sc.doc.ModelAbsoluteTolerance)**2.0\r\n    #values[key] = 0.5 * sc.doc.ModelAbsoluteTolerance**2.0 # Triangle.\r\n    values[key] = 0.5 * sc.doc.ModelAbsoluteTolerance\r\n    #names[key] = 'MaxTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMaxTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            if cls.riOpts[key].CurrentValue <= 1e-12:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = 1e-12\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getAllNormalBreps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.NormalObjects = True\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.IncludeLights = False\r\n    oes.IncludeGrips = False\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    go.SubObjectSelect = False\r\n    \r\n    go.AcceptNothing(True)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fMaxTol')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return getAllNormalBreps()\r\n\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMaxTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getFaces(rgBrep0, fMaxTol=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if fMaxTol is None: fMaxTol = Opts.values['fMaxTol']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    idx_rgFaces_Found = []\r\n    fArea_Min_Brep = fArea_Max_Brep = None\r\n\r\n    sCP_Base = Rhino.RhinoApp.CommandPrompt\r\n\r\n    # Search all faces of brep for slivers.\r\n    for iF, rgFace in enumerate(rgBrep0.Faces):\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Search canceled by user.\")\r\n\r\n        Rhino.RhinoApp.CommandPrompt = \"{}  Face {} of {}\".format(\r\n            sCP_Base,\r\n            iF + 1,\r\n            rgBrep0.Faces.Count)\r\n\r\n        rgBrepX_1Face = rgFace.DuplicateFace(duplicateMeshes=True)\r\n        \r\n        area = rgBrepX_1Face.GetArea()\r\n        \r\n        if area is None:\r\n            raise Exception(\"Area is None.\")\r\n        \r\n        # GetArea returns 0 when the area cannot be calculated.\r\n        if area == 0:\r\n            rgBrepX_1Face.Dispose()\r\n            continue\r\n        \r\n        fTotalEdgeLength = sum([edge.GetLength() for edge in rgBrepX_1Face.Edges])\r\n        \r\n        if bDebug:\r\n            sEval = \"fMaxTol\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"area\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"fTotalEdgeLength\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"area/fTotalEdgeLength\"; print(sEval, '=', eval(sEval))\r\n        \r\n        if (area/fTotalEdgeLength) > fMaxTol:\r\n            continue\r\n        \r\n        idx_rgFaces_Found.append(rgFace.FaceIndex)\r\n        \r\n        if (\r\n                fArea_Min_Brep is None or\r\n                area < fArea_Min_Brep\r\n        ):\r\n            fArea_Min_Brep = area\r\n        if (\r\n                fArea_Max_Brep is None or\r\n                area > fArea_Max_Brep\r\n        ):\r\n            fArea_Max_Brep = area\r\n        \r\n        rgBrepX_1Face.Dispose()\r\n\r\n    Rhino.RhinoApp.CommandPrompt = sCP_Base\r\n\r\n    return sorted(idx_rgFaces_Found), fArea_Min_Brep, fArea_Max_Brep\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef processBrepObjects(rhBreps_In, fMaxTol=None, bEcho=None, bDebug=None):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    if fMaxTol is None: fMaxTol = Opts.values['fMaxTol']\r\n    if bEcho is None: bEcho = Opts.values['bEcho']\r\n    if bDebug is None: bDebug = Opts.values['bDebug']\r\n    \r\n    fArea_Min_All = fArea_Max_All = None\r\n    iCt_Found = 0\r\n    gBreps1_Found_All = [] # Accumulation of duplicated faces (breps)\r\n    \r\n    nBreps_In = len(rhBreps_In)\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*nBreps_In,0)) for i in range(10)]\r\n\r\n    for iB, rhBrep0 in enumerate(rhBreps_In):\r\n        if sc.escape_test(False):\r\n            print(\"Search canceled by user.\")\r\n            return\r\n\r\n        if nBreps_In == 1:\r\n            Rhino.RhinoApp.CommandPrompt = \"Analyzing 1 brep\"\r\n        elif iB in idxs_AtTenths:\r\n            Rhino.RhinoApp.CommandPrompt = \"Analysis at {:d}% of {} breps\".format(\r\n                int(100.0 * (iB+1) / nBreps_In), nBreps_In)\r\n        \r\n        # Obtain GUID, RhinoObject, and geometry.\r\n        if isinstance(rhBrep0, Guid):\r\n            gBrep0 = rhBrep0\r\n            rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep0)\r\n            if rdBrep0 is None: continue\r\n        elif isinstance(rhBrep0, rd.ObjRef):\r\n            gBrep0 = rhBrep0.ObjectId\r\n            rdBrep0 = rhBrep0.Object()\r\n        elif isinstance(rhBrep0, rd.RhinoObject):\r\n            rdBrep0 = rhBrep0\r\n            gBrep0 = rhBrep0.Id\r\n        else:\r\n            print(\"GUID could not be obtained.\")\r\n            continue\r\n        rgBrep0 = rdBrep0.Geometry\r\n        if rgBrep0 is None:\r\n            print(\"Brep geometry could not be obtained for {}.\".format(gBrep0))\r\n            continue\r\n        if not rgBrep0.IsValid and bEcho:\r\n            print(\"Brep {} is invalid and will be skipped because rg.Curve.GetDistancesBetweenCurves may hang.\".format(\r\n                gBrep0))\r\n            continue\r\n\r\n        rc = getFaces(rgBrep0, fMaxTol=fMaxTol)\r\n\r\n        if rc is None: continue\r\n        (\r\n            idx_rgFaces_Found,\r\n            fArea_Min_Brep,\r\n            fArea_Max_Brep,\r\n            ) = rc\r\n    \r\n        if not idx_rgFaces_Found: continue\r\n        \r\n        iCt_Found += len(idx_rgFaces_Found)\r\n    \r\n        # Extract faces from polyface brep.\r\n        rc = xBrepObject.extractFaces(\r\n                gBrep0,\r\n                idx_rgFaces_Found,\r\n                bEcho=bEcho)\r\n        if rc is None: continue\r\n\r\n        gBreps1_Found_All.extend(rc[0]) # To be selected later.\r\n        \r\n        if fArea_Min_All is None or fArea_Min_Brep < fArea_Min_All:\r\n            fArea_Min_All = fArea_Min_Brep\r\n        if fArea_Max_All is None or fArea_Max_Brep > fArea_Max_All:\r\n            fArea_Max_All = fArea_Max_Brep\r\n    \r\n    if not iCt_Found:\r\n        print(\"No faces with area less than {} square {} found.\".format(\r\n                formatDistance(fMaxTol),\r\n                sc.doc.GetUnitSystemName(\r\n                        modelUnits=True,\r\n                        capitalize=False,\r\n                        singular=False,\r\n                        abbreviate=False\r\n                    )\r\n                ))\r\n        return\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n    ct_Selected = rs.SelectObjects(object_ids=gBreps1_Found_All)\r\n    if len(gBreps1_Found_All) == ct_Selected:\r\n        s = \"{} monoface brep(s) selected.\".format(ct_Selected)\r\n    else:\r\n        s  = \"{} faces found,\".format(\r\n                len(gBreps1_Found_All))\r\n        s += \" but only {} selected.\".format(ct_Selected)\r\n\r\n    if iCt_Found == 1:\r\n        s += \"\\nArea: {} square {}\".format(\r\n            formatDistance(fArea_Min_All),\r\n            sc.doc.GetUnitSystemName(\r\n                modelUnits=True,\r\n                capitalize=False,\r\n                singular=False,\r\n                abbreviate=False\r\n                )\r\n            )\r\n    else:\r\n        s += \"\\nRange of areas found:\"\r\n        s += \" [{}, {}] square {}\".format(\r\n            formatDistance(fArea_Min_All),\r\n            formatDistance(fArea_Max_All),\r\n            sc.doc.GetUnitSystemName(\r\n                modelUnits=True,\r\n                capitalize=False,\r\n                singular=False,\r\n                abbreviate=False\r\n                )\r\n            )\r\n    print(s)\r\n\r\n\r\ndef main():\r\n\r\n    rhObjs = getInput()\r\n    if rhObjs is None: return\r\n\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    processBrepObjects(rhBreps_In=rhObjs)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}