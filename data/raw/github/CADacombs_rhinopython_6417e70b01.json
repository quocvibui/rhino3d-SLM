{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_EdgeContinuity_BatchSelect.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_EdgeContinuity_BatchSelect.py",
  "instruction": "210320-21: Created.\r\n210326: Added support for naked edge, including auto-matching.",
  "code": "\"\"\"\r\n210320-21: Created.\r\n210326: Added support for naked edge, including auto-matching.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAllMatedEdgesInSelBrep'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'SelectionMode'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Edges', 'Polysrfs')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMatchNakedPairs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fMatchTol'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print \"Add option for {} failed.\".format(key)\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMatchTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-9:\r\n                cls.riOpts[key].CurrentValue = 1e-9\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps or edges with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    #go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n\r\n        if Opts.values['bAllMatedEdgesInSelBrep']:\r\n            go.GeometryFilter = rd.ObjectType.Brep # Curve is used here for brep edges.\r\n            go.SetCommandPrompt(\"Select polysurfaces\")\r\n        else:\r\n            go.DisablePreSelect()\r\n            go.GeometryFilter = rd.ObjectType.Curve # Curve is used here for brep edges.\r\n            if Opts.values['bMatchNakedPairs']:\r\n                go.GeometryAttributeFilter = (\r\n                        ri.Custom.GeometryAttributeFilter.EdgeCurve)\r\n                go.SetCommandPrompt(\"Select edges\")\r\n            else:\r\n                go.GeometryAttributeFilter = (\r\n                        ri.Custom.GeometryAttributeFilter.MatedEdge)\r\n                go.SetCommandPrompt(\"Select interior edges\")\r\n\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bAllMatedEdgesInSelBrep')\r\n        if not Opts.values['bAllMatedEdgesInSelBrep']:\r\n            addOption('bMatchNakedPairs')\r\n            if Opts.values['bMatchNakedPairs']:\r\n                addOption('fMatchTol')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return (\r\n                objrefs,\r\n                Opts.values['bAllMatedEdgesInSelBrep'],\r\n                Opts.values['bMatchNakedPairs'],\r\n                Opts.values['fMatchTol'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMatchTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef processBreps_MatedEdges(rhBreps, idxEdges=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBreps: list(GUIDs of Breps or rd.BrepObjects)\r\n        idxEdges:\r\n            None to process all edges or\r\n            list(list of int(EdgeIndices) per brep in rhBreps)\r\n    \"\"\"\r\n\r\n    sc.doc.Objects.UnselectAll() # For first call to _EdgeContinuity.\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"\")\r\n    \r\n    for iB in xrange(len(rhBreps)):\r\n        rhB = rhBreps[iB]\r\n        \r\n        if isinstance(rhB, Guid):\r\n            gB = rhB\r\n            rdB = sc.doc.Objects.FindId(gB)\r\n        elif isinstance(rhB, rd.BrepObject):\r\n            rdB = rhB\r\n        else:\r\n            print \"Item in rhBreps is {}, not BrepObject nor GUID of one.\".format(\r\n                rhB.GetType().Name)\r\n            continue\r\n\r\n        rgB = rdB.Geometry\r\n        \r\n        compIdxs = [None, None]\r\n\r\n        if idxEdges is None:\r\n            idxEs = xrange(rgB.Edges.Count)\r\n        else:\r\n            idxEs = idxEdges[iB]\r\n        \r\n        for idxE in idxEs:\r\n            edge = rgB.Edges[idxE]\r\n            \r\n            sPrompt = \"Processing edge {} of {}\".format(\r\n                    idxE+1, rgB.Edges.Count)\r\n            if len(rhBreps) > 1:\r\n                sPrompt += \" in polysurface {} of {}\".format(\r\n                    iB+1, len(rhBreps))\r\n            \r\n            sPrompt += \" ...\"\r\n            \r\n            Rhino.RhinoApp.CommandPrompt = sPrompt\r\n            if bDebug: print sPrompt\r\n            \r\n            if sc.escape_test(throw_exception=False):\r\n                print \"Script interrupted by user.\"\r\n                return\r\n            \r\n            if edge.TrimCount == 2:\r\n                iTs = edge.TrimIndices()\r\n                for i in 0,1:\r\n                    compIdxs[i] = rg.ComponentIndex(\r\n                        type=rg.ComponentIndexType.BrepTrim,\r\n                        index=iTs[i])\r\n                for compIdx in compIdxs:\r\n                    rdB.SelectSubObject(\r\n                        componentIndex=compIdx,\r\n                        select=True,\r\n                        syncHighlight=True,\r\n                        persistentSelect=True)\r\n                \r\n                rc = Rhino.RhinoApp.RunScript(\"_EdgeContinuity _Enter\", echo=bDebug)\r\n                \r\n                Rhino.RhinoApp.CommandPrompt = sPrompt\r\n                \r\n                for compIdx in compIdxs:\r\n                    rdB.SelectSubObject(\r\n                        componentIndex=compIdx,\r\n                        select=False,\r\n                        syncHighlight=True,\r\n                        persistentSelect=True)\r\n\r\n\r\ndef processBreps_NakedEdges(rhBreps, idxEdges=None, fMatchTol=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBreps: list(GUIDs of Breps or rd.BrepObjects)\r\n        idxEdges:\r\n            None to process all edges or\r\n            list(int(EdgeIndices) per rhBreps order)\r\n    \"\"\"\r\n\r\n    if fMatchTol is None: fMatchTol = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    sc.doc.Objects.UnselectAll() # For first call to _EdgeContinuity.\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"\")\r\n\r\n\r\n    def fill_rdBs_rgEs():\r\n        for i, (rhB, idxE) in enumerate(zip(rhBreps, idxEdges)):\r\n            if isinstance(rhB, Guid):\r\n                rdB = sc.doc.Objects.FindId(rhB)\r\n            elif isinstance(rhB, rd.BrepObject):\r\n                rdB = rhB\r\n            else:\r\n                print \"Item in rhBreps is {}, not BrepObject nor GUID of one.\".format(\r\n                    rhB.GetType().Name)\r\n                continue\r\n            rgB = rdB.BrepGeometry\r\n            rdBs.append(rdB)\r\n            rgEs.append(rgB.Edges[idxE])\r\n\r\n    rdBs = []\r\n    rgEs = []\r\n    fill_rdBs_rgEs()\r\n\r\n    if not rgEs or len(rgEs) < 2: return\r\n\r\n\r\n    idxs_Matches_Pairs = [] # Pairs of edges by rgEs list indices (not EdgeIndex).\r\n    idxs_Matches_Flat = [] # Indices matched.\r\n\r\n    for iA, rgE_A in enumerate(rgEs):\r\n        if iA in idxs_Matches_Flat: continue\r\n        for iB in range(iA+1, len(rgEs)):\r\n            if iB in idxs_Matches_Flat: continue\r\n            rgE_B = rgEs[iB]\r\n            ptA_Mid = None\r\n            if (\r\n                (\r\n                    rgE_A.PointAtStart.DistanceTo(rgE_B.PointAtStart) <= fMatchTol\r\n                    and\r\n                    rgE_A.PointAtEnd.DistanceTo(rgE_B.PointAtEnd) <= fMatchTol\r\n                )\r\n                or\r\n                (\r\n                    rgE_A.PointAtStart.DistanceTo(rgE_B.PointAtEnd) <= fMatchTol\r\n                    and\r\n                    rgE_A.PointAtEnd.DistanceTo(rgE_B.PointAtStart) <= fMatchTol\r\n                )\r\n            ):\r\n                if ptA_Mid is None:\r\n                    ptA_Mid = rgE_A.PointAt(rgE_A.Domain.Mid)\r\n                rc = rgE_B.ClosestPoint(ptA_Mid)\r\n                if rc[0]:\r\n                    if rgE_B.PointAt(rc[1]).DistanceTo(ptA_Mid) <= fMatchTol:\r\n                        idxs_Matches_Pairs.append((iA, iB))\r\n                        idxs_Matches_Flat.extend((iA, iB))\r\n\r\n    if bDebug:\r\n        print idxs_Matches_Pairs\r\n        print idxs_Matches_Flat\r\n\r\n\r\n    for i, (iA, iB) in enumerate(idxs_Matches_Pairs):\r\n\r\n        sPrompt = \"Processing edge pair {} of {}\".format(\r\n                i+1, len(idxs_Matches_Pairs))\r\n        sPrompt += \" ...\"\r\n\r\n        Rhino.RhinoApp.CommandPrompt = sPrompt\r\n        if bDebug: print sPrompt\r\n            \r\n        if sc.escape_test(throw_exception=False):\r\n            print \"Script interrupted by user.\"\r\n            return\r\n        \r\n        rdB_A = rdBs[iA]\r\n        rdB_B = rdBs[iB]\r\n        rgE_A = rgEs[iA]\r\n        rgE_B = rgEs[iB]\r\n\r\n        compIdx_A = rg.ComponentIndex(\r\n            type=rg.ComponentIndexType.BrepTrim,\r\n            index=rgE_A.TrimIndices()[0])\r\n        compIdx_B = rg.ComponentIndex(\r\n            type=rg.ComponentIndexType.BrepTrim,\r\n            index=rgE_B.TrimIndices()[0])\r\n\r\n        rdB_A.SelectSubObject(\r\n            componentIndex=compIdx_A,\r\n            select=True,\r\n            syncHighlight=True,\r\n            persistentSelect=True)\r\n\r\n        rdB_B.SelectSubObject(\r\n            componentIndex=compIdx_B,\r\n            select=True,\r\n            syncHighlight=True,\r\n            persistentSelect=True)\r\n\r\n        rc = Rhino.RhinoApp.RunScript(\"_EdgeContinuity _Enter\", echo=bDebug)\r\n\r\n        Rhino.RhinoApp.CommandPrompt = sPrompt\r\n\r\n        rdB_A.SelectSubObject(\r\n            componentIndex=compIdx_A,\r\n            select=False,\r\n            syncHighlight=True,\r\n            persistentSelect=True)\r\n\r\n        rdB_B.SelectSubObject(\r\n            componentIndex=compIdx_B,\r\n            select=False,\r\n            syncHighlight=True,\r\n            persistentSelect=True)\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 7:\r\n        print \"This script calls _EdgeContinuity,\" \\\r\n            \" a command that was introduced in Rhino 7.\"\r\n        return\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        objrefs,\r\n        bAllMatedEdgesInSelBrep,\r\n        bMatchNakedPairs,\r\n        fMatchTol,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n\r\n    if bAllMatedEdgesInSelBrep:\r\n        processBreps_MatedEdges(\r\n            rhBreps=[o.ObjectId for o in objrefs],\r\n            idxEdges=None,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n    else:\r\n        gBs_ForMatedEs = []\r\n        iEs_Mated = []\r\n\r\n        gBs_NakedEs = []\r\n        iEs_Naked = []\r\n\r\n        for objref in objrefs:\r\n            rgE = objref.Edge()\r\n            if rgE.Valence == rg.EdgeAdjacency.Interior:\r\n                gB = objref.ObjectId\r\n                if gB in gBs_ForMatedEs:\r\n                    iB = gBs_ForMatedEs.index(gB)\r\n                    iEs_Mated[iB].append(rgE.EdgeIndex)\r\n                else:\r\n                    gBs_ForMatedEs.append(gB)\r\n                    iEs_Mated.append([rgE.EdgeIndex])\r\n            elif bMatchNakedPairs and rgE.Valence == rg.EdgeAdjacency.Naked:\r\n                gBs_NakedEs.append(objref.ObjectId)\r\n                iEs_Naked.append(rgE.EdgeIndex)\r\n            else:\r\n                print \"Skipping edge of {} valence.\".format(rgE.Valence)\r\n\r\n        if gBs_ForMatedEs:\r\n            processBreps_MatedEdges(\r\n                rhBreps=gBs_ForMatedEs,\r\n                idxEdges=iEs_Mated,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n\r\n        if gBs_NakedEs:\r\n            processBreps_NakedEdges(\r\n                rhBreps=gBs_NakedEs,\r\n                idxEdges=iEs_Naked,\r\n                fMatchTol=fMatchTol,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}