{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_SunriseSunset.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_SunriseSunset.py",
  "instruction": "Use this component to get information about the sun\n-\nThis component is based on NOAA's research (National Oceanic and Atmospheric Administration) and it uses equations from Astronomical Algorithms,...",
  "code": "# Sunrise Sunset\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Antonello Di Nunzio <antonellodinunzio@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to get information about the sun\n-\nThis component is based on NOAA's research (National Oceanic and Atmospheric Administration) and it uses equations from Astronomical Algorithms, by Jean Meeus.\n\"The sunrise and sunset results are theoretically accurate to within a minute for locations between +/- 72 latitude, and within 10 minutes outside of those latitudes.\"\nSpecial thanks goes to the authors of the spreadsheets Solar Calculation and the web page\nhttp://www.esrl.noaa.gov/gmd/grad/solcalc/index.html\n-\nThis component calculates sunrise and sunset per hourly data. The approximation error of OfficialSunriseSunset could be about one-two minutes.\n-\nDespite this component does not consider the leap day (FEB 29th), results are accurate enough.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _location: The output from the importEPW or constructLocation component.  This is essentially a list of text summarizing a location on the earth.\n        _HOYorAnalysisPeriod: Connect: \n        a) a list of HOYs from outputs of the Ladybug_DOY_HOY for specific date;\n        b) OR a list of values from 1 to 8760 for the whole year;\n        c) OR Ladybug Analysis Period for the whole year.\n        isSunUpshift_: Set the number of hour after the sunrise and before the sunset you intend to exclude from the calculation of isSunUp. If no value is connected, the default value is 0.\n        _year: A number between -1000 to 3000. The approximations used in these script are very good for years between 1800 and 2100. Results should still be sufficiently accurate for the range from -1000 to 3000.\n        isSunUpAltitude_: write a conditional statement about solar altitude. Use 'v' as variable.\n        -\n        Here's an example:          v > 25.5 and v < 67.3\n        -\n        It is possible to use the following symbols:\n            and, or, ==, !=, >, <, >=, <=, ), (\n            \n    Returns:\n        readMe!: ...\n        officialSunriseSunset: It is the time between day and night when there is light outside and the Sun is on the horizon (9050').\n        solarNoon: Solar noon is when the sun is at its highest point in the sky each day.\n        solarElevationCorrected: Number(s) indicating the sun altitude(s) in degrees for each sun position on the sun path. It consider the atmospheric refraction.\n        solarAzimut: Number(s) indicating the sun azimuths in degrees for each sun position on the sun path.\n        sunVector: Vector(s) indicating the direction of sunlight for each sun position.\n        isSunUp: A list of number. 1 if the sun is up and 0 if the sun is down.\n        -\n        Use Ladybug Analysis Period or a list of values from 1 to 8760 to generate data for the whole year.\n        -\n        Try to connect this output to Ladybug 3D Chart to get a daylight chart of your location.\n        date: Detailied information for each sun position including date and time.\n        sunLightDuration: Duration of sunlight per day expressed in minutes.\n        -\n        This output is available just for _HOYorAnalysisPeriod type a) and b)\n        -\n        Try to connect this output to Ladybug_Average Data to create charts of your location using Ladybug_Monthly Bar Chart.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_SunriseSunset\"\nghenv.Component.NickName = 'Sunrise Sunset'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"1 | AnalyzeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport math\nimport re\n\ndef checkTheData(location, HOY):\n    if not location\\\n    or not HOY:\n        checkData = False\n    elif location and HOY:\n        checkData = True\n    else: checkData = True\n    return checkData\n\ndef sunVectorCalc(azimut, zenit):\n    # from polar to cartesian\n    x = 100 * math.sin(math.radians(90 - zenit)) * math.cos(math.radians(90 - azimut))\n    y = 100 * math.sin(math.radians(90 - zenit)) * math.sin(math.radians(90 - azimut))\n    z = 100 * math.cos(math.radians(90 - zenit))\n    \n    #refPoint = rs.AddPoint(x,y,z)\n    vector = rs.VectorCreate([0,0,0] , [x,y,z])\n    vector = rs.VectorUnitize(vector)\n    return vector\n\ndef readLocation(location):\n    locationStr = location.split('\\n')\n    newLocStr = \"\"\n    #clean the idf file\n    for line in locationStr:\n        if '!' in line:\n            line = line.split('!')[0]\n            newLocStr  = newLocStr + line.replace(\" \", \"\")\n        else:\n            newLocStr  = newLocStr + line\n    \n    newLocStr = newLocStr.replace(';', \"\")\n    site, locationName, latitude, longitude, timeZone, elevation = newLocStr.split(',')\n    \n    latitude = float(latitude)\n    longitude = float(longitude)\n    timeZone = float(timeZone)\n    \n    return latitude, longitude, timeZone\n\ndef JDtoTime(hour):\n    hourDec = hour * 24\n    hours = int(hourDec)\n    minute = int(round((hourDec - hours) * 60,0))\n    if minute == 60:\n        hours += 1\n        minute = \"00\"\n    if hours < 10:\n        hours = \"0\" + str(hours)\n    if minute == 0:\n        minutes = \"00\"\n    elif minute < 10:\n        minutes = \"0\" + str(minute)\n    else: minutes = minute\n    time = str(hours) + \":\" + str(minutes)\n    return time\n\ndef dateToDOY(month, day):\n    doy = math.floor((275 * month)/9) - math.floor((month + 9)/12) + day -30\n    \n    return doy\n\ndef sunCalcPreparation(hour, day, month, year, timeZone):\n    # year input\n    if year == None:\n        year = 2016\n    else: year = year_\n    \n    # Julian day from calendar day\n    if (month <= 2):\n        year -= 1\n        month += 12\n    A = math.floor(year/100)\n    B = 2 - A + math.floor(A/4)\n    \n    JulianDay = (math.floor(365.25*(year + 4716)) + math.floor(30.6001*(month+1))\\\n    + day + B - 1524.5) - timeZone / 24 + hour\n    \n    # calcTimeJulianCent\t\n    julianCent = (JulianDay - 2451545.0)/36525.0\n    \n    # calculate the Geometric Mean Longitude of the Sun\n    L0 = 280.46646 + julianCent * (36000.76983 + 0.0003032 * julianCent)\n    while (L0 > 360.0):\n        L0 -= 360.0\n    while (L0 < 0.0):\n        L0 += 360.0\n    \n    # calculate the Geometric Mean Anomaly of the Sun\n    M = 357.52911 + julianCent * (35999.05029 - 0.0001537 * julianCent)\n    \n    # calculate the eccentricity of earth's orbit\n    e = 0.016708634 - julianCent * (0.000042037 + 0.0000001267 * julianCent)\n    \n    # calculate the equation of center for the sun\n    CentreSun = math.sin(math.radians(M)) * (1.914602 - julianCent\\\n    * (0.004817 + 0.000014 * julianCent)) + math.sin(math.radians(2 * M))\\\n    * (0.019993 - 0.000101 * julianCent) + math.sin(math.radians(3 * julianCent)) * 0.000289\n    \n    #Sun True Long (deg)\n    sunTrueLog = L0 + CentreSun\n    \n    #Sun True Anom (deg)\n    sunTrueAnom = M + CentreSun\n    \n    #Sun Rad Vector (AUs)\n    sunRadVector = (1.000001018 * (1 - e * e))/(1 + e * math.cos(math.radians(sunTrueAnom)))\n    \n    #Sun App Long (deg)\n    sunAppLog = sunTrueLog - 0.00569 - 0.00478 * math.sin(math.radians(125.04 - 1934.136 * julianCent))\n    \n    #Mean Obliq Ecliptic (deg)\n    meanObliqEcliptic = 23 + (26 + ((21.448 - julianCent\\\n    * (46.815 + julianCent * (0.00059 - julianCent * 0.001813)))) / 60) / 60\n    \n    #Obliq Corr (deg)\n    obliqCorr = meanObliqEcliptic + 0.00256 * math.cos(math.radians(125.04 - 1934.136 * julianCent))\n    \n    #Sun Rt Ascen (deg)\n    data1 = math.cos(math.radians(sunAppLog))\n    data2 = math.cos(math.radians(obliqCorr))* math.sin(math.radians(sunAppLog))\n    \n    sunRtAscend = 90 - math.degrees(math.atan2(data1 , data2))\n    \n    #Sun Declin (deg)\n    sunDeclin = math.degrees(math.asin(math.sin(math.radians(obliqCorr)) * math.sin(math.radians(sunAppLog))))\n    \n    #var y\n    varY = math.tan(math.radians(obliqCorr / 2)) * math.tan(math.radians(obliqCorr / 2))\n    \n    #equation of time\n    eqOfTime = 4 * math.degrees(varY * math.sin(2 * math.radians(L0))\\\n    - 2 * e * math.sin(math.radians(M)) + 4 * e * varY * math.sin(math.radians(M))\\\n    * math.cos(2 * math.radians(L0)) - 0.5 * varY * varY * math.sin(4 * math.radians(L0))\\\n    - 1.25 * e * e * math.sin(2 * math.radians(M)))\n    \n    #returns\n    return eqOfTime, sunDeclin\n\ndef sunCalcTimeData(day, month, latitude, longitude, timeZone, eqOfTime, sunDeclin):\n    try:\n        #Solar Noon\n        solarNoon = (720 - 4 * longitude - eqOfTime + timeZone * 60) / 1440\n        solarNoonTime = JDtoTime(solarNoon)\n        \n        #HA Sunrise (deg)\n        haSunrise = math.degrees(math.acos(math.cos(math.radians(90.833))\\\n        / (math.cos(math.radians(latitude)) * math.cos(math.radians(sunDeclin)))\\\n        - math.tan(math.radians(latitude)) * math.tan(math.radians(sunDeclin))))\n        \n        #Solar Noon\n        solarNoon = (720 - 4 * longitude - eqOfTime + timeZone * 60) / 1440\n        solarNoonTime = JDtoTime(solarNoon)\n        \n        #Sunrise Time (LST)\n        sunriseTime = solarNoon - haSunrise * 4 / 1440\n        time1 = JDtoTime(sunriseTime)\n        if (sunriseTime*24 <= 0):\n            time1 = \"up\"\n        else:\n            time1 = time1\n        \n        #Sunset Time (LST)\n        sunsetTime = solarNoon + haSunrise * 4 / 1440\n        time2 = JDtoTime(sunsetTime)\n        if sunsetTime*24 >= 24:\n            time2 = \"up\"\n        else:\n            time2 = time2\n            \n        #Sunlight Duration (minutes)\n        sunLightDuration = int(round(haSunrise * 8,1))\n        \n        #solve the issue of extreme location\n    except:\n        solarNoonTime = solarNoonTime\n        if ((latitude > 66.4) and (dateToDOY(month, day) < 79 or dateToDOY(month, day) > 267)):\n            time1 = \"down\"\n            time2 = \"down\"\n            sunLightDuration = \"0\"\n            sunriseTime = 9999\n            sunsetTime = 9999\n        elif ((latitude > 66.4) and (dateToDOY(month, day) > 79 or dateToDOY(month, day) < 267)):\n            time1 = \"up\"\n            time2 = \"up\"\n            sunLightDuration = \"1440\"\n            sunriseTime = 99\n            sunsetTime = 99\n        elif ((latitude < -66.4) and (dateToDOY(month, day) < 83 or dateToDOY(month, day) > 263)):\n            time1 = \"up\"\n            time2 = \"up\"\n            sunLightDuration = \"1440\"\n            sunriseTime = 99\n            sunsetTime = 99\n        elif ((latitude < -66.4) and (dateToDOY(month, day) > 83 or dateToDOY(month, day) < 263)):\n            time1 = \"down\"\n            time2 = \"down\"\n            sunLightDuration = \"0\"\n            sunriseTime = 9999\n            sunsetTime = 9999\n    \n    #returns\n    return time1, time2, solarNoonTime, sunriseTime, sunsetTime, sunLightDuration\n\ndef sunCalcSunData(hour, latitude, longitude, timeZone, eqOfTime, sunDeclin):\n    #True Solar Time (min)\n    trueSolarTime = (hour * 1440 + eqOfTime + 4 * longitude - 60 * timeZone) % 1440\n    \n    #Hour Angle (deg)\n    if trueSolarTime / 4 <0:\n        hourAngle = trueSolarTime / 4 + 180\n    else: hourAngle = trueSolarTime / 4 - 180\n    \n    #Solar Zenith Angle (deg)\n    solarZenit = math.degrees(math.acos(math.sin(math.radians(latitude))\\\n    * math.sin(math.radians(sunDeclin)) + math.cos(math.radians(latitude))\\\n    * math.cos(math.radians(sunDeclin)) * math.cos(math.radians(hourAngle))))\n    \n    #Solar Elevation Angle (deg)\n    solarElevationAngle = 90 - solarZenit\n    \n    #Approx Atmospheric Refraction (deg)\n    if solarElevationAngle > 85:\n        apprAtmospRef = 0\n    elif solarElevationAngle > 5:\n        apprAtmospRef = (58.1 / math.tan(math.radians(solarElevationAngle)) - 0.07\\\n        / (math.tan(math.radians(solarElevationAngle))**3) + 0.000086 / (math.tan(math.radians(solarElevationAngle))**5)) / 3600\n    elif solarElevationAngle > -0.575:\n        apprAtmospRef = (1735 + solarElevationAngle * (-518.2 + solarElevationAngle\\\n        * (103.4 + solarElevationAngle * (-12.79 + solarElevationAngle * 0.711)))) / 3600\n    else: apprAtmospRef = (-20.772 / math.tan(math.radians(solarElevationAngle))) / 3600\n    \n    #Solar Elevation corrected for atm refraction (deg)\n    solarElevationCorrected = solarElevationAngle + apprAtmospRef\n    \n    #Solar Azimut\n    if hourAngle > 0:\n        solarAzimut = (math.degrees(math.acos(((math.sin(math.radians(latitude))\\\n        * math.cos(math.radians(solarZenit))) - math.sin(math.radians(sunDeclin)))\\\n        / (math.cos(math.radians(latitude)) * math.sin(math.radians(solarZenit))))) + 180) % 360\n    else: solarAzimut = (540 - math.degrees(math.acos(((math.sin(math.radians(latitude))\\\n    * math.cos(math.radians(solarZenit))) - math.sin(math.radians(sunDeclin)))\\\n    / (math.cos(math.radians(latitude)) * math.sin(math.radians(solarZenit)))))) % 360\n    \n    #vector Rhino geometry\n    vector = sunVectorCalc(solarAzimut, solarElevationCorrected)\n    \n    #returns\n    return solarElevationCorrected, solarAzimut, vector\n\ndef main():\n    if readLocation(_location)[0] == 90 or readLocation(_location)[0] == -90:\n        warning = \"Latitude should be in range (-89.99 , 89.99)\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n        \n    # output lists\n    officialSunriseSunset = []\n    solarElevationCorrected = []\n    isSunUp = []\n    sunVector = []\n    solarNoon = []\n    solarAzimut = []\n    date = []\n    sunLightDuration = []\n    # function lists\n    sunRiseTime = []\n    sunSetTime = []\n    hourJd = []\n    sunset = []\n    sunrise = []\n    \n    try:\n        # run sunCalc function\n        day = []\n        month = []\n        hour = []\n        \n        for hoy in _HOYorAnalysisPeriod:\n            d, m, t = lb_preparation.hour2Date(hoy, True)\n            day.append(d)\n            month.append(m + 1)\n            hour.append(t)\n            date.append(lb_preparation.hour2Date(hoy))\n        # hourJd function\n        for item in hour:\n            hourJd.append(item / 24)\n            \n        for i in range(0, len(_HOYorAnalysisPeriod)):\n            eqOfTime = sunCalcPreparation(hourJd[i], day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclin = sunCalcPreparation(hourJd[i], day[i], month[i], year_, readLocation(_location)[2])[1]\n            #function for sun data\n            dataSun = sunCalcSunData(hourJd[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTime, sunDeclin)\n            # output Sun\n            solarElevationCorrected.append(dataSun[0])\n            solarAzimut.append(dataSun[1])\n            sunVector.append(dataSun[2])\n            \n            ##Sunlight Duration per day (minutes)\n            eqOfTimeDuration = sunCalcPreparation(1, day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclinDuration = sunCalcPreparation(1, day[i], month[i], year_, readLocation(_location)[2])[1]\n            #function for sun data\n            dataSunDuration = sunCalcTimeData(day[i], month[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTimeDuration, sunDeclinDuration)\n            sunLightDuration.append(dataSunDuration[5])\n            \n            # logical conditions for hoursJd\n            if ((readLocation(_location)[0] > 66.4) and (dateToDOY(month[i], day[i]) < 79 or dateToDOY(month[i], day[i]) > 267)):\n                sunRisehourJd = 0.5\n                sunSethourJd = 0.5\n            elif ((readLocation(_location)[0] > 66.4) and (dateToDOY(month[i], day[i]) > 79 or dateToDOY(month[i], day[i]) < 267)):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n                \n            elif ((readLocation(_location)[0] < -66.4) and (dateToDOY(month[i], day[i]) < 83 or dateToDOY(month[i], day[i]) > 263)):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n            elif ((readLocation(_location)[0] <- 66.4) and (dateToDOY(month[i], day[i]) > 83 or dateToDOY(month[i], day[i]) < 263)):\n                sunRisehourJd = 0.5\n                sunSethourJd = 0.5\n                \n            elif (readLocation(_location)[0] <= 66.4) or (readLocation(_location)[0] >= -66.4):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n                \n            # Sunrise\n            eqOfTimeRise = sunCalcPreparation(sunRisehourJd, day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclinRise = sunCalcPreparation(sunRisehourJd, day[i], month[i], year_, readLocation(_location)[2])[1]\n            \n            dataSunRise = sunCalcTimeData(day[i], month[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTimeRise, sunDeclinRise)\n            sunRiseTime.append(dataSunRise[0])\n            sunrise.append(dataSunRise[3])\n            \n            \n            # Sunset\n            eqOfTimeSet = sunCalcPreparation(sunSethourJd, day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclinSet = sunCalcPreparation(sunSethourJd, day[i], month[i], year_, readLocation(_location)[2])[1]\n            \n            dataSunSet = sunCalcTimeData(day[i], month[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTimeSet, sunDeclinSet)\n            sunSetTime.append(dataSunSet[1])\n            sunset.append(dataSunSet[4])\n            \n            if sunRiseTime[i] == \"down\":\n                officialSunriseSunset.append(sunRiseTime[i] + \" , \" + \"down\")\n            else:\n                officialSunriseSunset.append(sunRiseTime[i] + \" , \" + sunSetTime[i])\n            \n            # solarNoon\n            solarNoon.append(dataSunSet[2])\n        \n        \n        \n        #generate isSunUp list\n        # isSunUpshift_, thanks to Cheney for this input.\n        # http://www.grasshopper3d.com/forum/topics/ladybug-sunrise-sunset?groupUrl=ladybug&commentId=2985220%3AComment%3A1519545&xg_source=msg_com_gr_forum\n        if isSunUpshift_ == None:\n            hourShift = 0\n        else: hourShift = abs(isSunUpshift_)\n        \n        for i in range (0, len(hour)):\n            if sunrise[i] == 9999 or sunset[i] == 9999:\n                sunUp = 0\n                isSunUp.append(sunUp)\n            elif sunrise[i] == 99 or sunset[i] == 99:\n                if (24 - hourShift) >= hour[i] > hourShift:\n                    sunUp = 1\n                    isSunUp.append(sunUp)\n                else: isSunUp.append(0)\n            elif hour[i]-hourShift <= (24*sunrise[i]) or hour[i]+hourShift >= (24*sunset[i]):\n                sunUp = 0\n                isSunUp.append(sunUp)\n            else:\n                sunUp = 1\n                isSunUp.append(sunUp)\n         \n        if isSunUpAltitude_:\n            for i in range (0, len(isSunUp)):\n                v = solarElevationCorrected[i]\n                if isSunUpAltitude_.find('v') != (-1) and isSunUp[i] != 0:\n                    variable = re.compile('(v)')\n                    conditional_statement = variable.sub( str(v), isSunUpAltitude_)\n                    if (eval(conditional_statement)):\n                        isSunUp[i] = 1\n                    else: isSunUp[i] = 0\n         \n                \n    except:\n        HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(_HOYorAnalysisPeriod, 1)\n        day = []\n        month = []\n        hour = []\n        for hoy in HOYS:\n            d, m, t = lb_preparation.hour2Date(hoy, True)\n            day.append(d)\n            month.append(m+1)\n            hour.append(t)\n            date.append(lb_preparation.hour2Date(hoy))\n            \n        # hourJd function\n        for item in hour:\n            hourJd.append(item / 24)\n        \n        for i in range(0, len(HOYS)):\n            eqOfTime = sunCalcPreparation(hourJd[i], day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclin = sunCalcPreparation(hourJd[i], day[i], month[i], year_, readLocation(_location)[2])[1]\n            #function for sun data\n            dataSun = sunCalcSunData(hourJd[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTime, sunDeclin)\n            # output Sun\n            solarElevationCorrected.append(dataSun[0])\n            solarAzimut.append(dataSun[1])\n            sunVector.append(dataSun[2])\n            \n            # logical conditions for hoursJd\n            if ((readLocation(_location)[0] > 66.4) and (dateToDOY(month[i], day[i]) < 79 or dateToDOY(month[i], day[i]) > 267)):\n                sunRisehourJd = 0.5\n                sunSethourJd = 0.5\n            elif ((readLocation(_location)[0] > 66.4) and (dateToDOY(month[i], day[i]) > 79 or dateToDOY(month[i], day[i]) < 267)):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n                \n            elif ((readLocation(_location)[0] < -66.4) and (dateToDOY(month[i], day[i]) < 83 or dateToDOY(month[i], day[i]) > 263)):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n            elif ((readLocation(_location)[0] <- 66.4) and (dateToDOY(month[i], day[i]) > 83 or dateToDOY(month[i], day[i]) < 263)):\n                sunRisehourJd = 0.5\n                sunSethourJd = 0.5\n                \n            elif (readLocation(_location)[0] <= 66.4) or (readLocation(_location)[0] >= -66.4):\n                sunRisehourJd = 0\n                sunSethourJd = 1\n                \n            # Sunrise\n            eqOfTimeRise = sunCalcPreparation(sunRisehourJd, day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclinRise = sunCalcPreparation(sunRisehourJd, day[i], month[i], year_, readLocation(_location)[2])[1]\n            \n            dataSunRise = sunCalcTimeData(day[i], month[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTimeRise, sunDeclinRise)\n            sunRiseTime.append(dataSunRise[0])\n            sunrise.append(dataSunRise[3])\n            \n            # Sunset\n            eqOfTimeSet = sunCalcPreparation(sunSethourJd, day[i], month[i], year_, readLocation(_location)[2])[0]\n            sunDeclinSet = sunCalcPreparation(sunSethourJd, day[i], month[i], year_, readLocation(_location)[2])[1]\n            \n            dataSunSet = sunCalcTimeData(day[i], month[i], readLocation(_location)[0], readLocation(_location)[1],\\\n            readLocation(_location)[2], eqOfTimeSet, sunDeclinSet)\n            sunSetTime.append(dataSunSet[1])\n            sunset.append(dataSunSet[4])\n            \n            if sunRiseTime[i] == \"down\":\n                officialSunriseSunset.append(sunRiseTime[i] + \" , \" + \"down\")\n            else:\n                officialSunriseSunset.append(sunRiseTime[i] + \" , \" + sunSetTime[i])\n            \n            # solarNoon\n            solarNoon.append(dataSunSet[2])\n            \n        #generate isSunUp list\n        if isSunUpshift_ == None:\n            hourShift = 0\n        else: hourShift = abs(isSunUpshift_)\n        \n        for i in range (0, len(hour)):\n            if sunrise[i] == 9999 or sunset[i] == 9999:\n                sunUp = 0\n                isSunUp.append(sunUp)\n            elif sunrise[i] == 99 or sunset[i] == 99:\n                if (24 - hourShift) >= hour[i] > hourShift:\n                    sunUp = 1\n                    isSunUp.append(sunUp)\n                else: isSunUp.append(0)\n            elif hour[i]-hourShift <= (24*sunrise[i]) or hour[i]+hourShift >= (24*sunset[i]):\n                sunUp = 0\n                isSunUp.append(sunUp)\n            else:\n                sunUp = 1\n                isSunUp.append(sunUp)\n                \n        if isSunUpAltitude_:\n            for i in range (0, len(isSunUp)):\n                v = solarElevationCorrected[i]\n                if isSunUpAltitude_.find('v') != (-1) and isSunUp[i] != 0:\n                    variable = re.compile('(v)')\n                    conditional_statement = variable.sub( str(v), isSunUpAltitude_)\n                    if (eval(conditional_statement)):\n                        isSunUp[i] = 1\n                    else: isSunUp[i] = 0\n                    \n    return officialSunriseSunset, solarElevationCorrected, solarAzimut, solarNoon, isSunUp, sunVector, date, sunLightDuration\n#import the classes\ninitCheck = False\nif sc.sticky.has_key('ladybug_release'):\n    initCheck = True\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = True\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\nelse:\n    initCheck = False\n    print \"You should first let the Ladybug fly...\"\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n\n#Check the data to make sure it is the correct type\ncheckData = False\nif initCheck == True:\n    checkData = checkTheData(_location, _HOYorAnalysisPeriod)\n    \n    if checkData == True:\n        result = main()\n        if result != -1:\n            officialSunriseSunset, solarElevationCorrected, solarAzimut, solarNoon ,isSunUp, sunVector, date, sunLightDuration = result\n            print 'calculation completed!'\n    else:\n        print 'Please provide all _inputs'",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}