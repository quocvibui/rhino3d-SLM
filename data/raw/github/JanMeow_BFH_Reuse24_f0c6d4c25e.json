{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/otherThing/mergeCalculate2.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/otherThing/mergeCalculate2.py",
  "instruction": "Merge calculate2",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import BrepClosestPoint\nimport scriptcontext as rs\nimport time\nimport math\nfrom ghpythonlib.components import Shatter, BoundarySurfaces, BrepXBrep\nfrom copy import copy\nimport threading\n\nbrickLength, brickHeight = tempPattern\n\nstart = time.time()\nwallData = iWallData.data\nwindowData = iWindowData.data\n\n\nif init:\n    initial_point_data = {}\n    initial_curve_data = {}\n    initial_value_data = {}\n    wallCalculateData = {}\n\n# check if object is moved\ntry:\n    for wallKey in wallData:\n        wallData[wallKey].update_movement(initial_curve_data)\n\n    for windowKey in windowData:\n        windowData[windowKey].update_movement(initial_point_data)\n\n    for wallKey in wallData:\n        wallData[wallKey].check_isMoved(initial_curve_data)\n\n    for windowKey in windowData:\n        windowData[windowKey].check_isMoved(initial_point_data)\n\nexcept:\n    initial_point_data = {}\n    initial_curve_data = {}\n\n    # check if object is moved\n    for wallKey in wallData:\n        wallData[wallKey].update_movement(initial_curve_data)\n\n    for windowKey in windowData:\n        windowData[windowKey].update_movement(initial_point_data)\n\n    for wallKey in wallData:\n        wallData[wallKey].check_isMoved(initial_curve_data)\n\n    for windowKey in windowData:\n        windowData[windowKey].check_isMoved(initial_point_data)\n\n\n# Calculate the closest wall of windows\nfor key in windowData:\n    windowData[key].wall = []\nfor key in wallData:\n    wallData[key].windowList = []\n\nwallList = [(wallData[key].nickname, wallData[key].surface) for key in wallData]\nwindow_List = [(windowData[key].nickname, windowData[key].pt) for key in windowData]\n\nfor winNickname, winPt in window_List:\n    allDist = []\n    allPt = []\n    allWallNickname = []\n    for wallNickname, wallSrf in wallList:\n        wallSrf = wallSrf.ToBrep()\n        closestPt = wallSrf.ClosestPoint(winPt)\n        dist = winPt.DistanceTo(closestPt)\n        allDist.append(dist)\n        allPt.append(closestPt)\n        allWallNickname.append(wallNickname)\n\n    minDist = min(allDist)\n    closestId = allDist.index(minDist)\n    ptOnWall = allPt[closestId]\n\n    xAxis = ptOnWall - winPt\n    yAxis = rg.Vector3d(0,0,1)\n    worldZAxis = rg.Vector3d(0,0,1)\n    winPlane = rg.Plane(ptOnWall, xAxis, yAxis)\n    winPlane.Rotate(math.pi/2, worldZAxis, ptOnWall)\n    winPlane.Translate(worldZAxis*windowData[winNickname].locHeight)\n    windowData[winNickname].winPlane = winPlane\n    \n    closestWallNickname = allWallNickname[closestId]\n    wallData[closestWallNickname].windowList.append(winNickname)\n    windowData[winNickname].wall = closestWallNickname\n\n\n# check if value is change\ntry:\n    for wallKey in wallData:\n        wallData[wallKey].update_value(initial_value_data)\n\n    for wallKey in wallData:\n        wallData[wallKey].check_value(initial_value_data)\n\nexcept:\n    initial_value_data = {}\n\n    for wallKey in wallData:\n        #print(initial_value_data)\n        wallData[wallKey].update_value(initial_value_data)\n    \n    for wallKey in wallData:\n        wallData[wallKey].check_value(initial_value_data)\n\n\n\n\n\nclass WallCalculate:\n    def __init__(self, wallObj, brickLength, brickHeight):\n        self.wallObj = wallObj\n        self.brickLength = brickLength\n        self.brickHeight = brickHeight\n        self.windowList = [windowData.get(key) for key in self.wallObj.windowList]\n        self.surface = wallObj.surface\n        self.curve = wallObj.curve\n        self.wallHeight = wallObj.height\n\n        self.demoForTile()\n        \n    \n\n\n    def demoForTile(self):\n        self.extrusionStore = self.generatePattern()\n        self.windowRectangle = self.buildWindow()\n        self.facade = self.wallWithOpen()\n\n    def generatePattern(self):\n        evenSegment = Shatter(self.curve, self.curve.DivideByLength(self.brickLength, True))\n        oddCrv = self.curve.Trim(rg.CurveEnd.Start, self.brickLength / 2)\n        remainOddCrv = self.curve.Trim(rg.CurveEnd.End, self.curve.GetLength()-self.brickLength/2)\n        arr = oddCrv.DivideByLength(self.brickLength, True)\n        oddSegment = Shatter(oddCrv, arr)\n        oddSegment.insert(0, remainOddCrv)\n\n        evenExtrusion = [rg.Extrusion.Create(crv, self.brickHeight, False) for crv in evenSegment if crv]\n        oddExtrusion = [rg.Extrusion.Create(crv, self.brickHeight, False) for crv in oddSegment if crv]\n\n        layerNum = int(math.ceil(self.wallHeight / self.brickHeight))\n        extrusionStore = []\n        for layer in range(layerNum):\n            isEvenLayer = layer % 2 == 0\n            extrusions = evenExtrusion if isEvenLayer else oddExtrusion\n            translation = rg.Vector3d(0, 0, self.brickHeight * layer)\n            matrix = rg.Transform.Translation(translation)\n            for brick in extrusions:\n                brickCopy = copy(brick)\n                brickCopy.Transform(matrix)\n                extrusionStore.append(brickCopy)\n        \n        return extrusionStore or []\n\n    def buildWindow(self):\n        windowRectangle = []\n        for windowObj in self.windowList:\n            rect = rg.Rectangle3d(windowObj.winPlane, windowObj.width, windowObj.height)\n            negXAxis = rg.Transform.Translation(-windowObj.winPlane.XAxis * (windowObj.width / 2))\n            rect.Transform(negXAxis)\n            windowRectangle.append(rect)\n        return windowRectangle\n\n    def wallWithOpen(self):\n        if not self.windowList:\n            return self.extrusionStore\n\n        combinedGeometries = self.windowRectangle + [self.surface]\n        windowRect = BoundarySurfaces(combinedGeometries)\n        return self.processFacade(windowRect)\n\n    def processFacade(self, windowRect):\n        if not self.extrusionStore:\n            return []\n\n        facade = []\n        threads = []\n        facade_lock = threading.Lock()\n\n        for block in self.extrusionStore:\n            thread = threading.Thread(target=self._process_block, args=(block, windowRect, facade, facade_lock))\n            threads.append(thread)\n            thread.start()\n\n        for thread in threads:\n            thread.join()\n\n        return facade\n\n    def _process_block(self, block, windowRect, facade, facade_lock):\n        result = BrepXBrep(windowRect, block)\n        if result:\n            with facade_lock:\n                facade.append(result[0])\n\n\n\n\n# Detect which wall need to be rebuild.\nfor wallKey in wallData:\n    boolList = [windowData.get(windowNickname).isMoved for windowNickname in wallData[wallKey].windowList]\n    boolList.append(wallData[wallKey].isMoved)\n    boolList.append(wallData[wallKey].isValueChanged)\n    isTrueInside = any(boolList)\n    wallData[wallKey].rebuild = isTrueInside\n\n\ntry:\n    for wallKey in wallData:\n        if wallData[wallKey].rebuild or wallCalculateData.get(wallData[wallKey].nickname) == None:\n            wallFacadeObj = WallCalculate(wallData[wallKey], brickLength, brickHeight)\n            wallCalculateData[wallData[wallKey].nickname] = wallFacadeObj\nexcept:\n    wallCalculateData = {}\n    for wallKey in wallData:\n        if wallData[wallKey].rebuild or wallCalculateData.get(wallData[wallKey].nickname) == None:\n            wallFacadeObj = WallCalculate(wallData[wallKey], brickLength, brickHeight)\n            wallCalculateData[wallData[wallKey].nickname] = wallFacadeObj\n\n\n\nclass classForOutput:\n    def __init__(self):\n        pass\n\nallData = classForOutput()\nallData.wallData= wallData\nallData.windowData = windowData\nallData.facadeData = wallCalculateData\noAllData = allData\n\n#for key in wallData:\n#    print(wallData[key].windowList)\n\nend = time.time()\nprint(end - start)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}