{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_filletEdges_in_FreeCAD.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_filletEdges_in_FreeCAD.py",
  "instruction": "Complement to _FilletEdge.  \r\n\r\nThis script uses headless FreeCAD ( https://wiki.freecadweb.org/Headless_FreeCAD )\r\n\r\nThe most significant differences from Rhino's _FilletEdge are at...",
  "code": "\"\"\"\r\nComplement to _FilletEdge.  \r\n\r\nThis script uses headless FreeCAD ( https://wiki.freecadweb.org/Headless_FreeCAD )\r\n\r\nThe most significant differences from Rhino's _FilletEdge are at the\r\nintersections of non-tangent edges.\r\n\r\nCaution: Check the resultant polysurfaces (B-reps) for missing faces.\r\n\r\nSee script file for setup instructions.\r\n\r\nSend any questions, comments, or script development service needs to @spb on\r\nthe McNeel Forums ( https://discourse.mcneel.com/ )\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\nThis script was last tested on\r\n- Rhino 8.11.24254.15001, 2024-09-10\r\nUsing\r\n- FreeCAD 0.21.2.33771 (Git)\r\nOn Windows.\r\n\r\nRequirements to run:\r\n1. Rhino 7 or 8.  Other versions have not been tested.  If you try other versions,\r\n    please inform me (see below) of the results.\r\n\r\n2. FreeCAD, preferrably the same version as stated above,\r\n    https://www.freecadweb.org/downloads.php\r\n    installed where Rhino running the script can access it.\r\n\r\n3. Modification of the code in the \"Variables to modify per OS\"... section\r\n    below as needed.  Notice that as provided, .stp and .py communication files\r\n    are created on the current user's Desktop.\r\n\r\n\r\n211222-220103: Created.\r\n220106: subprocess.Popen now runs in a threading.Timer.\r\n220110: Removed code for PartDesign Fillet since it has less options than Part Fillet.\r\n        Added multiple fillet radius input capability similar to _FilletEdge.\r\n220111: Added preview of text dots on edges containing their assigned radius.\r\n        Added option to use previous input.\r\n240101: When running on Windows, now searches and automatically sets FreeCAD\r\n        version to the latest installed.  Also, added command option to change versions\r\n        if more than one are available.\r\n240918: To avoid Python process conflicts, the PYTHONHOME environment variable is\r\n        now deleted when the script is run in Rhino 8.\r\n\r\nTODO:\r\nFor previous input option, should the input be merged with any current input?\r\nMaybe?: Allow variable radius fillet input.\r\n    FreeCAD only creates variable fillets that have 2 radii and are G1 blended\r\n    between the edges so that the target fillet radii can G1 match to\r\n    an adjacent fillet at a tangent edge.  They are not linearly blended.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\nimport os\r\nfrom subprocess import Popen, PIPE\r\nfrom threading import Timer\r\n\r\n\r\nif not Rhino.Runtime.HostUtils.RunningOnWindows:\r\n    raise Exception(\r\n        \"Non-Windows OS. Modify the code in class FC_paths, then delete this 'if' code block.\")\r\n\r\n\r\nclass FC_paths:\r\n    \"\"\"\r\n    Variables to modify per OS, installation paths, and desired placement of\r\n    .stp and .py files for communication between Rhino and FreeCAD.\r\n    \"\"\"\r\n\r\n    sFC_Path_Parent = os.environ[\"ProgramFiles\"]\r\n\r\n    sFC_Vers = [s[8:] for s in os.listdir(sFC_Path_Parent) if \"FreeCAD\" in s]\r\n    if not sFC_Vers:\r\n        raise Exception(\"FreeCAD not found in Program Files.\",\r\n        \"If it is installed, this script needs to be modified to accommodate FreeCAD's path.\")\r\n\r\n    sFreeCADcmd_path = '\"{}\"'.format(\r\n            os.path.join(\r\n            sFC_Path_Parent,\r\n            \"FreeCAD {}\".format(sFC_Vers[0]),\r\n            \"bin\\FreeCADcmd.exe\"))\r\n\r\n    _desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')\r\n\r\n    sPath_Script_for_FC = _desktop + r\"\\to_FC.py\"\r\n\r\n    sPath_STEP_to_FC = _desktop + r\"\\to_FC.stp\"\r\n\r\n    sPath_STEP_from_FC = _desktop + r\"\\from_FC.stp\"\r\n\r\n\r\n    @classmethod\r\n    def setFC_Cmd_path(cls, sFC_Ver):\r\n        cls.sFreeCADcmd_path = '\"{}\"'.format(\r\n            os.path.join(\r\n            cls.sFC_Path_Parent,\r\n            \"FreeCAD {}\".format(sFC_Ver),\r\n            \"bin\\FreeCADcmd.exe\"))\r\n\r\n\r\ndef checkAndDelPYTHONHOME(bDebug=False):\r\n    \"\"\"\r\n    Doing this due to behavior of Rhino 8.\r\n    \"\"\"\r\n\r\n    import os\r\n\r\n    for sVar in ('PYTHONHOME', ):\r\n        sEval = \"os.environ['{}']\".format(sVar)\r\n        if sVar in os.environ:\r\n            print(sEval,\"=\",eval(sEval))\r\n            del os.environ[sVar]\r\n            if sVar in os.environ:\r\n                print(sEval,\"=\",eval(sEval))\r\n                del os.environ[sVar]\r\n            else:\r\n                if bDebug: print(\"{} doesn't exist.\".format(sEval))\r\n        else:\r\n            if bDebug: print(\"{} doesn't exist.\".format(sEval))\r\n\r\n\r\ns_FC = []\r\n\r\ndef fc(s=''): s_FC.append(s)\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadius'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fFreeCADTimeoutSecs'; keys.append(key)\r\n    values[key] = 10.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iFC_ver'; keys.append(key)\r\n    listValues[key] = [s.replace('.', 'p') for s  in FC_paths.sFC_Vers]\r\n    values[key] = len(listValues[key]) - 1\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadius':\r\n            if cls.riOpts[key].CurrentValue < 2.0*sc.doc.ModelAbsoluteTolerance:\r\n                cls.riOpts[key].CurrentValue = 0.0\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            print(\"Why is key, {}, here?  Value was not set or sticky-saved.\".format(key))\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput(bPrevBrepsArePresent):\r\n    \"\"\"\r\n    Get BrepEdges with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edges to fillet\")\r\n    go.SetCommandPromptDefault(\"Confirm edges & radius\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve # Curve is also used for brep edges.\r\n    go.GeometryAttributeFilter = (\r\n            ri.Custom.GeometryAttributeFilter.MatedEdge |\r\n            ri.Custom.GeometryAttributeFilter.EdgeCurve)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go_Main on repeats of While loop.\r\n    go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fRadius')\r\n        if bPrevBrepsArePresent:\r\n            idxs_Opt['UsePrevInput'] = go.AddOption('UsePrevInput')\r\n        addOption('fFreeCADTimeoutSecs')\r\n        if len(FC_paths.sFC_Vers) > 1: addOption('iFC_ver')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return []\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        if go.Option().Index == idxs_Opt['UsePrevInput']:\r\n            go.Dispose()\r\n            return 'UsePrevInput'\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\nclass DrawRadiusDotsConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.prs = None\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n\r\n    def PostDrawObjects(self, drawEventArgs):\r\n        if not self.prs: return\r\n\r\n        for pt, rad in self.prs:\r\n\r\n            if rad == 0.0:\r\n                continue\r\n\r\n            rc = drawEventArgs.Display.DrawDot(\r\n                worldPosition=pt,\r\n                text=\"{:.{}f}\".format(rad, sc.doc.ModelDistanceDisplayPrecision),\r\n                dotColor=sc.doc.Layers.CurrentLayer.Color,\r\n                textColor=Color.Black if sc.doc.Layers.CurrentLayer.Color != Color.Black else Color.White)\r\n\r\n\r\ndef create_subBs_per_Es_to_fillet(rgB, idxs_Es):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    # Don't bother creating subsets when the face count is low.\r\n    if rgB.Faces.Count < 13:\r\n        return [rgB.DuplicateBrep()], range(rgB.Faces.Count)\r\n\r\n\r\n    iFs = []\r\n\r\n    for iE in idxs_Es:\r\n        for iF in rgB.Edges[iE].AdjacentFaces():\r\n            if iF in iFs: continue\r\n            iFs.append(iF)\r\n\r\n\r\n    # Add faces adjacent to all faces in iFs so that the faces at the ends\r\n    # of the fillets are processed correctly.\r\n    iEs_NoFillet = []\r\n    for iF in iFs:\r\n        for iE in rgB.Faces[iF].AdjacentEdges():\r\n            if iE in idxs_Es: continue\r\n            if iE in iEs_NoFillet: continue\r\n            iEs_NoFillet.append(iE)\r\n\r\n    for iE in iEs_NoFillet:\r\n        for iF_A in rgB.Edges[iE].AdjacentFaces():\r\n            if iF_A not in iFs:\r\n                iFs.append(iF_A)\r\n\r\n\r\n    # In case there are any faces missing from the sub-Brep.\r\n    iEs_SharedVs = []\r\n    for iE_Fillet in idxs_Es:\r\n        v = rgB.Edges[iE_Fillet].StartVertex\r\n        for iE in v.EdgeIndices():\r\n            if iE in idxs_Es: continue\r\n            if iE in iEs_NoFillet: continue\r\n            iEs_SharedVs.append(iE)\r\n        v = rgB.Edges[iE_Fillet].EndVertex\r\n        for iE in v.EdgeIndices():\r\n            if iE in idxs_Es: continue\r\n            if iE in iEs_NoFillet: continue\r\n            iEs_SharedVs.append(iE)\r\n\r\n    for iE in iEs_SharedVs:\r\n        for iF_V in rgB.Edges[iE].AdjacentFaces():\r\n            if iF_V not in iFs:\r\n                print(\"Face[{}] added via Vertex routine\".format(iF_V))\r\n                iFs.append(iF_V)\r\n\r\n\r\n    print(\"Face count of Brep: {}\".format(rgB.Faces.Count))\r\n    print(\"Face count of sub-Brep: {}\".format(len(iFs)))\r\n\r\n\r\n    # Don't bother creating subsets in some cases.\r\n    if len(iFs) == rgB.Faces.Count:\r\n        return [rgB.DuplicateBrep()], range(rgB.Faces.Count)\r\n\r\n    if rgB.Faces.Count - len(iFs) < 13:\r\n        return [rgB.DuplicateBrep()], range(rgB.Faces.Count)\r\n\r\n\r\n    print(\"Creating sub-Brep for export.\")\r\n\r\n    rgBs_ToJoin = [rgB.Faces[iF].DuplicateFace(False) for iF in iFs]\r\n\r\n    join_tol = max(\r\n        sc.doc.ModelAbsoluteTolerance,\r\n        max([rgB.Edges[iE].Tolerance for iE in idxs_Es]))\r\n\r\n    return rg.Brep.JoinBreps(rgBs_ToJoin, tolerance=join_tol), iFs\r\n\r\n\r\ndef create_FC_code_Point3Ds_to_Vectors(pts_Mids):\r\n    fc('from FreeCAD import Base')\r\n    fc('V=Base.Vector')\r\n    fc('midVs = []')\r\n    for pt in pts_Mids:\r\n        fc('midVs.append(V({}, {}, {}))'.format(pt.X, pt.Y, pt.Z))\r\n    fc('')\r\n    return True\r\n\r\n\r\ndef export_to_STEP(rgBrep, bDebug=False):\r\n    rdObj_MostRecent = sc.doc.Objects.MostRecentObject()\r\n    uInt32_MostRecent = rdObj_MostRecent.RuntimeSerialNumber\r\n\r\n    gBrep_for_STEP = sc.doc.Objects.AddBrep(rgBrep)\r\n    if gBrep_for_STEP == gBrep_for_STEP.Empty: return\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    rdB_to_FC = sc.doc.Objects.AllObjectsSince(uInt32_MostRecent)[0]\r\n\r\n    sc.doc.Objects.Select(objectId=rdB_to_FC.Id)\r\n\r\n    scriptToExportStp = \" \".join([\r\n        \"_-Export\",\r\n        '\"{}\"'.format(FC_paths.sPath_STEP_to_FC),\r\n        \"_Schema=AP214AutomotiveDesign\",\r\n        \"_ExportParameterSpaceCurves=No\",\r\n        \"_SplitClosedSurfaces=No\",\r\n        \"_Enter\"])\r\n\r\n    if not Rhino.RhinoApp.RunScript(scriptToExportStp, echo=bDebug): return\r\n\r\n    if not sc.doc.Objects.Delete(rdB_to_FC): return\r\n\r\n    return True\r\n\r\n\r\ndef import_STEP_into_Rhino(bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    rdObj_MostRecent = sc.doc.Objects.MostRecentObject()\r\n    uInt32_MostRecent = rdObj_MostRecent.RuntimeSerialNumber\r\n\r\n    scriptToImportStp = \" \".join([\r\n        \"_-Import\",\r\n        '\"{}\"'.format(FC_paths.sPath_STEP_from_FC),\r\n        \"_JoinSurfaces=Yes\",\r\n        \"_LimitFaces=No\",\r\n        \"_SkipInvisibles=Yes\",\r\n        \"_ShowBadObjectWarning=Yes\",\r\n        \"_ShowNestedBlockWarning=No\",\r\n        \"_EnterEnd\"])\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Importing STEP ...\")\r\n\r\n    Rhino.RhinoApp.RunScript(scriptToImportStp, echo=bDebug)\r\n\r\n    return sc.doc.Objects.AllObjectsSince(uInt32_MostRecent)\r\n\r\n\r\ndef create_FC_code_Determine_edges_to_fillet():\r\n\r\n    fc('def idx_input_mid_match(edge):')\r\n    fc('    try:')\r\n    fc('        midE=edge.valueAt(edge.Curve.parameterAtDistance(edge.Length/2.0, edge.FirstParameter))')\r\n    fc('    except:')\r\n    fc('        print(edge.Curve)')\r\n    fc('        Part.show(edge)')\r\n    fc('        Part.Vertex(edge.Curve.parameterAtDistance(0.0))')\r\n    fc('        1/0')\r\n    fc('    for i, v in enumerate(midVs):')\r\n    fc('        if midE.distanceToPoint(v) < 0.01:')\r\n    fc('            return i')\r\n    fc()\r\n    fc('edges_to_fillet = []')\r\n    fc('idx_edges_to_fillet = []')\r\n    fc('rads_per_idxE = []')\r\n    fc()\r\n    fc('for iE, edge in enumerate(doc.Fillet.Base.Shape.Edges):')\r\n    #fc('    print(edge.Length)')\r\n    fc('    if edge.Degenerated:')\r\n    fc('        print(\"Degenerated Edge skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    if edge.Length < 1e-6:')\r\n    fc('        print(\"Edge with length {} skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    if edge.Length < 0.01:')\r\n    fc('        print(\"Edge with length {} skipped.\".format(edge.Length))')\r\n    fc('        continue')\r\n    fc('    idxMid = idx_input_mid_match(edge)')\r\n    fc('    if idxMid is None:')\r\n    fc('        continue')\r\n    fc('    edges_to_fillet.append(edge)')\r\n    fc('    idx_edges_to_fillet.append(iE+1)') # Part Edge indices are base 1 in FreeCAD.\r\n    fc('    rads_per_idxE.append(rads_per_pts_Mids[idxMid])')\r\n    fc('    if len(edges_to_fillet) == len(midVs):')\r\n    fc('        break')\r\n    fc('else:')\r\n    fc('    raise Exception(\"Not all the input edges were matched to the edges in FreeCAD.\")')\r\n    fc()\r\n    fc()\r\n\r\n\r\ndef subprocess_FC(sArgs, fFreeCADTimeoutSecs=5.0, bEcho=True):\r\n    \"\"\"\r\n    Parameters:\r\n        sArgs: str(Although Popen also accepts a list, trying this when calling FreeCADcmd.exe has so far been unnsuccesful.)\r\n    Returns on success: True\r\n    Returns on fail: False\r\n\r\n    References:\r\n    https://web.archive.org/web/20160709205942/http://www.ironpython.info/index.php?title=Launching_Sub-Processes\r\n    https://www.blog.pythonlibrary.org/2016/05/17/python-101-how-to-timeout-a-subprocess/\r\n    \"\"\"\r\n\r\n    kill = lambda process: process.kill()\r\n\r\n    p = Popen(sArgs, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True) # shell=True hides console window.\r\n\r\n    my_timer = Timer(fFreeCADTimeoutSecs, kill, [p])\r\n\r\n\r\n    bSuccess = False\r\n\r\n    try:\r\n        my_timer.start()\r\n        stdout, stderr = p.communicate()\r\n    except:\r\n        pass\r\n    else:\r\n        if stderr or p.returncode:\r\n            if bEcho:\r\n                print(\"Failed to get FreeCAD to complete the filleting.\")\r\n                print(\"stderr from FreeCAD: {}\".format(stderr if stderr else \"None\"))\r\n                if p.returncode:\r\n                    print(\"returncode: {}\".format(p.returncode))\r\n        else:\r\n            bSuccess = True\r\n    finally:\r\n        my_timer.cancel()\r\n\r\n    return bSuccess\r\n\r\n\r\ndef processBrep(rgBrep_In, idxs_Edges, fRadii, fFreeCADTimeoutSecs=10.0, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep_In: ObjRef or tuple(rd.BrepObject or GUID, float(edge index))\r\n        idxs_Edges: list(int(EdgeIndex))\r\n        fRadii: list(floats in idxs_Edges order)\r\n        fFreeCADTimeoutSecs: float\r\n        bEcho: bool\r\n        bDebug: bool\r\n    \"\"\"\r\n\r\n    sCmdPrompt_In = Rhino.RhinoApp.CommandPrompt\r\n\r\n    if not rgBrep_In.IsValid:\r\n        if bEcho:\r\n            print(\"{}-face brep is invalid.  Fix first.  Brep is skipped.\".format(\r\n                rgBrep_In.Faces.Count))\r\n        return False, None\r\n\r\n\r\n    rgBs_ToFillet, idx_Fs_to_FC = create_subBs_per_Es_to_fillet(rgBrep_In, idxs_Edges)\r\n\r\n    if not rgBs_ToFillet:\r\n        if bEcho:\r\n            print(\"No shells to fillet in a brep.\")\r\n        return False, None\r\n\r\n\r\n    pts_Mids = []\r\n    for iE in idxs_Edges:\r\n        ts = list(rgBrep_In.Edges[iE].DivideByCount(2, includeEnds=False))\r\n        if not ts:\r\n            print(\"Midpoint of edge[{}] not found.\".format(iE))\r\n            return False, None\r\n        pt = rgBrep_In.Edges[iE].PointAt(ts[0])\r\n        pts_Mids.append(pt)\r\n\r\n\r\n    # Internal distance unit of FreeCAD is millimeter.\r\n    if sc.doc.ModelUnitSystem != Rhino.UnitSystem.Millimeters:\r\n        fScaleUnit = Rhino.RhinoMath.UnitScale(\r\n            sc.doc.ModelUnitSystem,\r\n            Rhino.UnitSystem.Millimeters) # from, to\r\n\r\n        # Breps sent to FC via STEP do not need to be scaled.\r\n\r\n        for iP, pt in enumerate(pts_Mids):\r\n            pts_Mids[iP].X = pt.X * fScaleUnit\r\n            pts_Mids[iP].Y = pt.Y * fScaleUnit\r\n            pts_Mids[iP].Z = pt.Z * fScaleUnit\r\n\r\n\r\n        #fRadius *= fScaleUnit\r\n        fRadii = [r*fScaleUnit for r in fRadii]\r\n\r\n\r\n    fc('import FreeCAD as App')\r\n    fc('import Part')\r\n    fc()\r\n    fc()\r\n\r\n\r\n    if not create_FC_code_Point3Ds_to_Vectors(pts_Mids):\r\n        raise Exception(\"Could not create_FC_code_Point3Ds_to_Vectors.\") \r\n\r\n    fc('rads_per_pts_Mids = []')\r\n    for r in fRadii:\r\n        fc('rads_per_pts_Mids.append({})'.format(r))\r\n\r\n\r\n    for rgB_ToFillet in rgBs_ToFillet:\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\"Exporting STEP ...\")\r\n\r\n        if not export_to_STEP(rgB_ToFillet, bDebug): return\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt_In)\r\n\r\n        fc('shape = Part.Shape()')\r\n        fc('shape.read(r\"{}\")'.format(FC_paths.sPath_STEP_to_FC))\r\n\r\n        fc('Part.show(shape)')\r\n\r\n        fc('doc = FreeCAD.ActiveDocument')\r\n        #fc('doc.recompute()') # Worked in 0.19.\r\n\r\n\r\n\r\n        # For debugging.\r\n        #fc()\r\n        #script_FC = \"\\n\".join(s_FC)\r\n        #with open(FC_paths.sPath_Script_for_FC, \"w\") as f: \r\n        #    f.write(script_FC) \r\n        #return True, None\r\n        #\r\n\r\n\r\n        fc('doc.addObject(\"Part::Fillet\",\"Fillet\")')\r\n        fc('doc.Fillet.Base = doc.Shape')\r\n        #fc('doc.recompute()') # Worked in 0.19, but raised 'Recompute failed!' in more recent versions.  Also, disabled previous recompute since it seems to work without, even in 0.19.\r\n\r\n\r\n        create_FC_code_Determine_edges_to_fillet()\r\n\r\n\r\n        # Fillet.\r\n        fc('data_for_featFillet = []')\r\n        fc('for i, iE in enumerate(idx_edges_to_fillet):')\r\n        fc('    data_for_featFillet.append((iE, rads_per_idxE[i], rads_per_idxE[i]))')\r\n        fc()\r\n        fc('doc.Fillet.Edges = data_for_featFillet')\r\n        fc('doc.recompute()')\r\n        fc('doc.Shape.Visibility = False')\r\n        fc()\r\n        fc()\r\n\r\n\r\n    # Create STEP file for Rhino.\r\n    fc('import Import')\r\n    fc('Import.export([FreeCAD.ActiveDocument.Fillet], r\"{}\")'.format(\r\n        FC_paths.sPath_STEP_from_FC))\r\n\r\n\r\n    # Create script file.\r\n    fc()\r\n    script_FC = \"\\n\".join(s_FC)\r\n\r\n    with open(FC_paths.sPath_Script_for_FC, \"w\") as f: \r\n        f.write(script_FC) \r\n\r\n\r\n    # Send script to headless FreeCAD (FreeCADcmd.exe) via subprocess.\r\n    sForConsole = FC_paths.sFreeCADcmd_path + \" RunMode=Script \" + '\"{}\"'.format(\r\n        FC_paths.sPath_Script_for_FC)\r\n    if bDebug: print(sForConsole)\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Running FreeCAD ...\")\r\n\r\n    rc = subprocess_FC(\r\n        sForConsole, fFreeCADTimeoutSecs=fFreeCADTimeoutSecs, bEcho=bEcho)\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt_In)\r\n    if bDebug: print(rc)\r\n\r\n    if not rc: return False, None\r\n\r\n\r\n    def create_subBs_per_Fs_to_remove(rgB, iFs_to_Remove):\r\n        \"\"\"\r\n        \"\"\"\r\n\r\n        rgB_Out = rgB.DuplicateBrep()\r\n\r\n        for iF in sorted(iFs_to_Remove, reverse=True):\r\n            rgB_Out.Faces.RemoveAt(iF)\r\n\r\n        return rgB_Out\r\n\r\n\r\n    if len(idx_Fs_to_FC) == rgBrep_In.Faces.Count:\r\n        rgB_Fs_not_sent_to_FC = None\r\n    else:\r\n        rgB_Fs_not_sent_to_FC = create_subBs_per_Fs_to_remove(rgBrep_In, idx_Fs_to_FC)\r\n\r\n\r\n    return True, rgB_Fs_not_sent_to_FC\r\n\r\n\r\ndef processBrepObject(rhBrep_In, idxs_Es, fRadii, fFreeCADTimeoutSecs=10.0, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBrep_In: ObjRef or tuple(rd.BrepObject or GUID, float(edge index))\r\n        idxs_Es: list(int(EdgeIndex))\r\n        fRadii: list(floats in idxs_Es order)\r\n        fFreeCADTimeoutSecs: float\r\n        bEcho: bool\r\n        bDebug: bool\r\n    \"\"\"\r\n\r\n    sCmdPrompt_In = Rhino.RhinoApp.CommandPrompt\r\n\r\n    rdB_In = None\r\n    if isinstance(rhBrep_In, Guid):\r\n        gB_In = rhBrep_In\r\n        rdB_In = sc.doc.Objects.FindId(gB_In)\r\n    elif isinstance(rhBrep_In, rd.BrepObject):\r\n        rdB_In = rhBrep_In\r\n        gB_In = rdB_In.Id\r\n\r\n    if not rdB_In: return\r\n\r\n    rgB_In = rdB_In.BrepGeometry\r\n\r\n    if not rgB_In.IsValid:\r\n        print(\"Brep {} is invalid.  Fix first.  Brep is skipped.\".format(gB_In))\r\n        return\r\n\r\n    bSuccess, rgB_Fs_not_sent_to_FC = processBrep(\r\n        rgB_In,\r\n        idxs_Es,\r\n        fRadii=fRadii,\r\n        fFreeCADTimeoutSecs=fFreeCADTimeoutSecs,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n    if not bSuccess: return\r\n\r\n    rdBs_from_FC = import_STEP_into_Rhino(bDebug)\r\n    if not rdBs_from_FC:\r\n        if bEcho:\r\n            print(\"Filleted breps were not imported.\")\r\n        return\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt_In)\r\n\r\n\r\n    if rgB_Fs_not_sent_to_FC is None:\r\n        rgBs_forOut = [rdB.BrepGeometry for rdB in rdBs_from_FC]\r\n    else:\r\n        join_tol = max(\r\n            sc.doc.ModelAbsoluteTolerance,\r\n            max([rgB_In.Edges[iE].Tolerance for iE in idxs_Es]))\r\n\r\n        rgBs_forOut = rg.Brep.JoinBreps(\r\n            [rgB_Fs_not_sent_to_FC] + [rdB.BrepGeometry for rdB in rdBs_from_FC],\r\n            tolerance=join_tol)\r\n\r\n        if len(rgBs_forOut) > 1:\r\n            if bEcho:\r\n                print(\"More than 1 brep resulted from join.\")\r\n\r\n    if len(rgBs_forOut) == 1:\r\n        sc.doc.Objects.Replace(gB_In, rgBs_forOut[0])\r\n\r\n    if len(rgBs_forOut) > 1:\r\n        for rgB_Out in rgBs_forOut:\r\n            sc.doc.Objects.AddBrep(rgB_Out, rdB_In.Attributes)\r\n        sc.doc.Objects.Delete(rdB_In)\r\n\r\n    for rdB in rdBs_from_FC:\r\n        sc.doc.Objects.Delete(rdB)\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion >= 8:\r\n        checkAndDelPYTHONHOME(Opts.values['bDebug'])\r\n\r\n    gBs_In = [] # This is used as the index for the brep in the following routine.\r\n    idx_rgEdges_PerBrep = []\r\n    rads_for_idxEs_PerBrep = []\r\n\r\n\r\n    prevSels_Present = []\r\n    skey_prevSels = 'prevSels({})'.format(__file__)\r\n    if skey_prevSels in sc.sticky:\r\n        prevSels_Saved = sc.sticky[skey_prevSels]\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n        iter.ObjectTypeFilter = rd.ObjectType.Brep\r\n        gBs_Saved = [d.Id for d in sc.doc.Objects.GetObjectList(iter)]\r\n        for gB, pts, rads in prevSels_Saved:\r\n            if gB in  gBs_Saved:\r\n                prevSels_Present.append((gB, pts, rads))\r\n\r\n\r\n    skey_conduit = 'conduit({})'.format(__file__)\r\n    if (skey_conduit in sc.sticky) and sc.sticky[skey_conduit]:\r\n        conduit = sc.sticky[skey_conduit]\r\n    else:\r\n        conduit = DrawRadiusDotsConduit()\r\n        sc.sticky[skey_conduit] = conduit\r\n\r\n    conduit.Enabled = False # Turns off the conduit if left on from a previous execution of this script.\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n    def get_BE_FromInput(rhObj):\r\n        if not hasattr(rhObj, '__iter__'):\r\n            if not isinstance(rhObj, rd.ObjRef): return\r\n\r\n            objref = rhObj\r\n\r\n            gB = objref.ObjectId\r\n            idxE = objref.Edge().EdgeIndex\r\n\r\n            return gB, idxE\r\n\r\n        if len(rhObj) != 2: return\r\n        rhB, idxE = rhObj\r\n        if not isinstance(idxE, int): return\r\n\r\n        if isinstance(rhB, rd.BrepObject):\r\n            rdB = rhB\r\n            gB = rdB.Id\r\n        elif isinstance(rhB, Guid):\r\n            gB = rhB\r\n\r\n        return gB, idxE\r\n\r\n\r\n    def sortInputPerBrep(rhObjs_In):\r\n\r\n        for rhObj in rhObjs_In:\r\n\r\n            rc = get_BE_FromInput(rhObj)\r\n            if not rc: return\r\n\r\n            gB, idxE = rc\r\n\r\n            if gB in gBs_In:\r\n                if idxE in idx_rgEdges_PerBrep[gBs_In.index(gB)]:\r\n                    # Modify radius value.\r\n                    idxEperB = idx_rgEdges_PerBrep[gBs_In.index(gB)].index(idxE)\r\n                    rads_for_idxEs_PerBrep[gBs_In.index(gB)][idxEperB] = fRadius\r\n                    continue\r\n\r\n                idx_rgEdges_PerBrep[gBs_In.index(gB)].append(idxE)\r\n                rads_for_idxEs_PerBrep[gBs_In.index(gB)].append(fRadius)\r\n                continue\r\n\r\n            gBs_In.append(gB)\r\n            idx_rgEdges_PerBrep.append([idxE])\r\n            rads_for_idxEs_PerBrep.append([fRadius])\r\n\r\n\r\n    def getEdgeIndex_MatchingMidPoint(rgBrep, midpt):\r\n        for edge in rgBrep.Edges:\r\n            ts = list(edge.DivideByCount(2, includeEnds=False))\r\n            if not ts:\r\n                print(\"Midpoint of edge[{}] not found.\".format(edge.EdgeIndex))\r\n                return\r\n            if edge.PointAt(ts[0]).DistanceTo(midpt) < 0.1 * sc.doc.ModelAbsoluteTolerance:\r\n                return edge.EdgeIndex\r\n\r\n\r\n    def prepareDataForPreviewAndSticky():\r\n        zipped = zip(gBs_In, idx_rgEdges_PerBrep, rads_for_idxEs_PerBrep)\r\n\r\n\r\n        rgBs = []\r\n        pts_Mids_All = [] # Won't include matching radius of 0.0.\r\n        rads_All = [] # Won't include radius of 0.0.\r\n        \r\n        bprs = [] # list of tuples of (GUID, pts, radii) for saving input for future use of script.\r\n\r\n        for gB_In, idxs_Es, rads_for_idxEs in zipped:\r\n            rdB = sc.doc.Objects.FindId(gB_In)\r\n            rgB = rdB.Geometry\r\n            rgBs.append(rgB)\r\n            pts_Mids_ThisB = [] # Won't include matching radius of 0.0.\r\n            rads_ThisB = [] # Won't include radius of 0.0.\r\n\r\n            for i, rad in enumerate(rads_for_idxEs):\r\n                if rad == 0.0:\r\n                    continue\r\n                iE = idxs_Es[i]\r\n                ts = list(rgB.Edges[iE].DivideByCount(2, includeEnds=False))\r\n                if not ts:\r\n                    print(\"Midpoint of edge[{}] not found.\".format(iE))\r\n                    return\r\n                pt = rgB.Edges[iE].PointAt(ts[0])\r\n                pts_Mids_ThisB.append(pt)\r\n                rads_ThisB.append(rad)\r\n\r\n            if not pts_Mids_ThisB: continue\r\n            bprs.append((rdB.Id, pts_Mids_ThisB, rads_ThisB))\r\n            pts_Mids_All.extend(pts_Mids_ThisB)\r\n            rads_All.extend(rads_ThisB)\r\n\r\n        sc.sticky[skey_prevSels] = bprs\r\n\r\n        if not rgBs: return\r\n\r\n        return pts_Mids_All, rads_All\r\n\r\n\r\n    while True:\r\n        rc = getInput(bool(prevSels_Present))\r\n\r\n        if rc is None:\r\n            conduit.Enabled = False\r\n            del conduit\r\n            del sc.sticky[skey_conduit]\r\n            sc.sticky[skey_conduit] = None\r\n            return\r\n\r\n        if rc == 'UsePrevInput':\r\n            sc.doc.Objects.UnselectAll()\r\n            gBs_In = []\r\n            idx_rgEdges_PerBrep = []\r\n            rads_for_idxEs_PerBrep = []\r\n            for gB, pts, rads in prevSels_Present:\r\n                rgB = sc.doc.Objects.FindId(gB).BrepGeometry\r\n                idx_rgEdges_ThisB = []\r\n                rads_for_idxEs_ThisB = []\r\n                for i, pt in enumerate(pts):\r\n                    idxE = getEdgeIndex_MatchingMidPoint(rgB, pt)\r\n                    if idxE is None: continue\r\n                    idx_rgEdges_ThisB.append(idxE)\r\n                    rads_for_idxEs_ThisB.append(rads[i])\r\n                if idx_rgEdges_ThisB:\r\n                    gBs_In.append(gB)\r\n                    idx_rgEdges_PerBrep.append(idx_rgEdges_ThisB)\r\n                    rads_for_idxEs_PerBrep.append(rads_for_idxEs_ThisB)\r\n\r\n            rc = prepareDataForPreviewAndSticky()\r\n            if not rc: continue\r\n            pts_Mids_All, rads_All = rc\r\n\r\n            conduit.prs = zip(pts_Mids_All, rads_All)\r\n\r\n            conduit.Enabled = True\r\n            sc.doc.Views.Redraw()\r\n\r\n            continue\r\n\r\n\r\n        fRadius = Opts.values['fRadius']\r\n        fFreeCADTimeoutSecs = Opts.values['fFreeCADTimeoutSecs']\r\n        iFC_ver = Opts.values['iFC_ver']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n        if not rc:\r\n            conduit.Enabled = False\r\n            del conduit\r\n            break\r\n\r\n        objrefs = rc\r\n\r\n        sortInputPerBrep(objrefs)\r\n\r\n        rc = prepareDataForPreviewAndSticky()\r\n        if not rc: continue\r\n        pts_Mids_All, rads_All = rc\r\n\r\n        conduit.prs = zip(pts_Mids_All, rads_All)\r\n\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    if not gBs_In: return\r\n\r\n    print(\"Proceeding to create fillets.\")\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    FC_paths.setFC_Cmd_path(FC_paths.sFC_Vers[iFC_ver])\r\n\r\n    gBreps_Res_All = []\r\n\r\n    zipped = zip(gBs_In, idx_rgEdges_PerBrep, rads_for_idxEs_PerBrep)\r\n\r\n    for iB, (gB_In, idxs_Es, rads_for_idxEs) in enumerate(zipped):\r\n\r\n        sCmdPrompt = \"Processing brep {} of {}\".format(iB+1, len(gBs_In))\r\n        Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt)\r\n\r\n        s_FC[:] = [] # So that a new FreeCAD script is made for each brep.\r\n\r\n        rc = processBrepObject(\r\n            gB_In,\r\n            idxs_Es,\r\n            fRadii=rads_for_idxEs,\r\n            fFreeCADTimeoutSecs=fFreeCADTimeoutSecs,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n\r\n        if rc:\r\n            gBreps_Res_All.extend(rc)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}