{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_revit_baker.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_revit_baker.py",
  "instruction": "GHPython Component: Revit Baker",
  "code": "# File: scripts/gh_revit_baker.py\n\"\"\"\nGHPython Component: Revit Baker\n\nTransforms framing elements into outputs suitable for Rhino.Inside.Revit's\nAdd Structural Column and Add Structural Beam components.\n\nThis component classifies elements as vertical (columns) vs horizontal (beams),\nmaps profile names to Revit family types, computes Cross-Section Rotation (CSR)\nfor CFS beams, and creates placement planes for vertical columns.\n\nCRITICAL: Vertical columns use PLANE-BASED placement to avoid centerline offset.\nSee docs/ai/ai-rir-revit-patterns.md for details on why curves cause offset issues.\n\nInputs:\n    elements_json: JSON string from Framing Generator component\n    wall_json: JSON string from Wall Analyzer (for level information)\n    revit_column_types: List of available Revit Structural Column family types\n    revit_beam_types: List of available Revit Structural Framing family types\n    type_mapping: Optional dict mapping profile names to Revit type names\n    mirror_opening_studs: Boolean - if True, king studs/trimmers on opposite\n                          sides of openings face each other (default: False)\n    run: Boolean to trigger execution\n\nOutputs:\n    baking_data_json: JSON string with all member data organized by wall.\n                      For columns: includes plane_origin and plane_x_axis for\n                      orientation control. For beams: includes csr_angle.\n    column_curves: DataTree of centerlines for vertical columns.\n                   Connect to RiR \"Add Structural Column\" Curve input.\n    beam_curves: DataTree of centerlines for horizontal elements (plates, etc.)\n                 These use CSR parameter for orientation.\n    debug_info: Processing summary\n\nNote on Column Orientation:\n    Column orientation data (plane_origin, plane_x_axis) is in baking_data_json.\n    Use the Baking Data Parser to extract and create Rhino Planes for updating\n    column Location after creation. This follows the JSON-based pattern.\n\nJSON Output Structure:\n    {\n      \"walls\": {\n        \"<wall_id>\": {\n          \"base_level_id\": <int>,\n          \"top_level_id\": <int>,\n          \"members\": [\n            {\n              \"id\": \"<element_id>\",\n              \"element_type\": \"<type>\",\n              \"classification\": \"column\"|\"beam\",\n              \"profile_name\": \"<profile>\",\n              \"revit_type_name\": \"<matched_type>\",\n              \"csr_angle\": <float>,  // For beams only; columns use plane orientation\n              \"centerline_start\": {\"x\": <float>, \"y\": <float>, \"z\": <float>},\n              \"centerline_end\": {\"x\": <float>, \"y\": <float>, \"z\": <float>},\n              \"plane_origin\": {\"x\": <float>, \"y\": <float>, \"z\": <float>},  // Columns only\n              \"plane_x_axis\": {\"x\": <float>, \"y\": <float>, \"z\": <float>},  // Columns only\n              \"geometry_index\": <int>\n            },\n            ...\n          ]\n        },\n        ...\n      },\n      \"summary\": {\n        \"total_walls\": <int>,\n        \"total_columns\": <int>,\n        \"total_beams\": <int>,\n        \"material_system\": \"<system>\"\n      }\n    }\n\nUsage:\n    1. Connect 'elements_json' from Framing Generator\n    2. Connect 'wall_json' from Wall Analyzer\n    3. Connect Revit family types (use RiR type pickers)\n    4. Optionally provide 'type_mapping' for custom profile-to-type mapping\n    5. Set 'mirror_opening_studs' to True for mirrored king stud orientation\n    6. Set 'run' to True\n    7. Connect column_planes to RiR \"Add Structural Column\" (Plane input)\n    8. Connect beam_curves + CSR to RiR \"Add Structural Framing\"\n\"\"\"\n\nimport sys\nimport json\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n# Clear cached modules to ensure fresh imports when script changes\n_modules_to_clear = [k for k in sys.modules.keys() if 'timber_framing_generator' in k]\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\nprint(f\"[RELOAD] Cleared {len(_modules_to_clear)} cached timber_framing_generator modules\")\n\n# =============================================================================\n# RhinoCommon Setup\n# =============================================================================\n\nimport clr\n\nclr.AddReference('RhinoCommon')\nclr.AddReference('Grasshopper')\nclr.AddReference('RhinoInside.Revit')\n\nimport Rhino.Geometry as rg\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom RhinoInside.Revit import Revit\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\nfrom src.timber_framing_generator.core.json_schemas import (\n    deserialize_framing_results, FramingElementData, Point3D\n)\nfrom src.timber_framing_generator.core.material_system import ElementType\n\n# =============================================================================\n# Element Classification\n# =============================================================================\n\n# Vertical members -> Structural Columns\nCOLUMN_ELEMENT_TYPES = {\n    ElementType.STUD.value,\n    ElementType.KING_STUD.value,\n    ElementType.TRIMMER.value,\n    ElementType.HEADER_CRIPPLE.value,\n    ElementType.SILL_CRIPPLE.value,\n}\n\n# Horizontal members -> Structural Beams/Framing\nBEAM_ELEMENT_TYPES = {\n    # Timber\n    ElementType.BOTTOM_PLATE.value,\n    ElementType.TOP_PLATE.value,\n    ElementType.ROW_BLOCKING.value,\n    # CFS\n    ElementType.BOTTOM_TRACK.value,\n    ElementType.TOP_TRACK.value,\n    ElementType.BRIDGING.value,\n    # Shared\n    ElementType.HEADER.value,\n    ElementType.SILL.value,\n}\n\n# Default type mapping for common profiles\n# Maps framing generator profile names to Revit family type names\nDEFAULT_TYPE_MAPPING = {\n    # Timber profiles\n    \"2x4\": \"2x4\",\n    \"2x6\": \"2x6\",\n    \"2x8\": \"2x8\",\n    \"2x10\": \"2x10\",\n    \"2x12\": \"2x12\",\n    # CFS profiles - map to Clark Dietrich naming with (50) yield strength suffix\n    # 350-series (3.5\" web)\n    \"350S125-33\": \"350S125-33(50)\",\n    \"350S125-43\": \"350S125-43(50)\",\n    \"350S125-54\": \"350S125-54(50)\",\n    \"350S125-68\": \"350S125-68(50)\",\n    \"350S162-33\": \"350S162-33(50)\",\n    \"350S162-43\": \"350S162-43(50)\",\n    \"350S162-54\": \"350S162-54(50)\",\n    \"350T125-33\": \"350T125-33(50)\",\n    \"350T125-43\": \"350T125-43(50)\",\n    \"350T125-54\": \"350T125-54(50)\",\n    \"350T250-54\": \"350T250-54(50)\",\n    # 362-series (3.625\" web) - Clark Dietrich standard\n    \"362S125-33\": \"362S125-33(50)\",\n    \"362S125-43\": \"362S125-43(50)\",\n    \"362S125-54\": \"362S125-54(50)\",\n    \"362S125-68\": \"362S125-68(50)\",\n    \"362S162-33\": \"362S162-33(50)\",\n    \"362S162-43\": \"362S162-43(50)\",\n    \"362S162-54\": \"362S162-54(50)\",\n    \"362S162-68\": \"362S162-68(50)\",\n    \"362T125-33\": \"362T125-33(50)\",\n    \"362T125-43\": \"362T125-43(50)\",\n    \"362T125-54\": \"362T125-54(50)\",\n    \"362T125-68\": \"362T125-68(50)\",\n    \"362T250-54\": \"362T250-54(50)\",\n    \"362T250-68\": \"362T250-68(50)\",\n    # 400-series (4\" web)\n    \"400S125-33\": \"400S125-33(50)\",\n    \"400S125-43\": \"400S125-43(50)\",\n    \"400S125-54\": \"400S125-54(50)\",\n    \"400S125-68\": \"400S125-68(50)\",\n    \"400T125-54\": \"400T125-54(50)\",\n    \"400T250-54\": \"400T250-54(50)\",\n    # 550-series (5.5\" web)\n    \"550S125-33\": \"550S125-33(50)\",\n    \"550S125-43\": \"550S125-43(50)\",\n    \"550S125-54\": \"550S125-54(50)\",\n    \"550S125-68\": \"550S125-68(50)\",\n    \"550S250-97\": \"550S250-97(50)\",\n    \"550T125-54\": \"550T125-54(50)\",\n    \"550T200-54\": \"550T200-54(50)\",\n    \"550T250-54\": \"550T250-54(50)\",\n    # 600-series (6\" web)\n    \"600S162-33\": \"600S162-33(50)\",\n    \"600S162-43\": \"600S162-43(50)\",\n    \"600S162-54\": \"600S162-54(50)\",\n    \"600S162-68\": \"600S162-68(50)\",\n    \"600T125-33\": \"600T125-33(50)\",\n    \"600T125-43\": \"600T125-43(50)\",\n    \"600T125-54\": \"600T125-54(50)\",\n    # 800-series (8\" web)\n    \"800S162-54\": \"800S162-54(50)\",\n    \"800S162-68\": \"800S162-68(50)\",\n    \"800T125-54\": \"800T125-54(50)\",\n    \"800T125-68\": \"800T125-68(50)\",\n}\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef classify_element(element_type: str) -> str:\n    \"\"\"\n    Classify an element as 'column' or 'beam' based on its type.\n\n    Args:\n        element_type: Element type string from elements_json\n\n    Returns:\n        'column' for vertical members, 'beam' for horizontal members,\n        'unknown' for unrecognized types\n    \"\"\"\n    elem_type_lower = element_type.lower()\n\n    if elem_type_lower in COLUMN_ELEMENT_TYPES:\n        return \"column\"\n    elif elem_type_lower in BEAM_ELEMENT_TYPES:\n        return \"beam\"\n    else:\n        # Check by naming convention for unknown types\n        if any(x in elem_type_lower for x in ['stud', 'cripple', 'trimmer']):\n            return \"column\"\n        elif any(x in elem_type_lower for x in ['plate', 'track', 'header', 'sill', 'blocking', 'bridging']):\n            return \"beam\"\n        return \"unknown\"\n\n\ndef parse_cfs_profile_name(profile_name: str) -> dict:\n    \"\"\"\n    Parse a CFS profile name into its components.\n\n    Examples:\n        \"362S125-54\" -> {\"series\": \"362\", \"type\": \"S\", \"flange\": \"125\", \"gauge\": \"54\"}\n        \"600T125-54(50)\" -> {\"series\": \"600\", \"type\": \"T\", \"flange\": \"125\", \"gauge\": \"54\"}\n\n    Returns:\n        Dict with profile components or None if not a CFS profile\n    \"\"\"\n    import re\n    # Match patterns like 362S125-54 or 600T125-54(50)\n    pattern = r'^(\\d{3})([ST])(\\d{3})-(\\d{2,3})(?:\\(\\d+\\))?$'\n    match = re.match(pattern, profile_name.upper())\n    if match:\n        return {\n            \"series\": match.group(1),\n            \"type\": match.group(2),\n            \"flange\": match.group(3),\n            \"gauge\": match.group(4),\n        }\n    return None\n\n\ndef find_similar_cfs_profile(profile_name: str, type_name_map: dict,\n                              debug: bool = False) -> tuple:\n    \"\"\"\n    Find a similar CFS profile when exact match isn't available.\n\n    Matching priority:\n    1. Same profile type (S/T), same flange (125/162/250), same gauge - different series\n    2. Same profile type, different flange, same gauge\n    3. Any CFS profile of same type (S/T)\n\n    Args:\n        profile_name: Source profile (e.g., \"362S125-54\")\n        type_name_map: Dict of lowercase type names to Revit types\n        debug: Print debug info\n\n    Returns:\n        Tuple of (matched_type, match_quality) or (None, None)\n    \"\"\"\n    if debug:\n        print(f\"  [CFS MATCH] Starting CFS match for '{profile_name}'\")\n\n    source = parse_cfs_profile_name(profile_name)\n    if not source:\n        if debug:\n            print(f\"  [CFS MATCH] Source profile '{profile_name}' did not parse as CFS\")\n        return None, None\n\n    if debug:\n        print(f\"  [CFS MATCH] Source parsed: {source}\")\n\n    # Parse all available CFS types\n    cfs_types = []\n    sample_type_names = []\n    for type_name, rt in type_name_map.items():\n        if len(sample_type_names) < 10:\n            sample_type_names.append(type_name)\n        parsed = parse_cfs_profile_name(type_name)\n        if parsed:\n            cfs_types.append((type_name, rt, parsed))\n\n    if debug:\n        print(f\"  [CFS MATCH] Sample type names from map: {sample_type_names}\")\n        print(f\"  [CFS MATCH] Found {len(cfs_types)} CFS types out of {len(type_name_map)} total\")\n        if cfs_types:\n            print(f\"  [CFS MATCH] CFS types found: {[t[0] for t in cfs_types[:5]]}\")\n\n    if not cfs_types:\n        if debug:\n            print(f\"  [CFS MATCH] No CFS types found in available Revit types\")\n        return None, None\n\n    if debug:\n        print(f\"  Source profile parsed: {source}\")\n        print(f\"  Available CFS types: {len(cfs_types)}\")\n\n    # Priority 1: Same type (S/T), same gauge, prefer similar series\n    candidates = []\n    for type_name, rt, parsed in cfs_types:\n        if parsed[\"type\"] == source[\"type\"] and parsed[\"gauge\"] == source[\"gauge\"]:\n            # Calculate series difference (closer = better)\n            series_diff = abs(int(parsed[\"series\"]) - int(source[\"series\"]))\n            flange_match = 1 if parsed[\"flange\"] == source[\"flange\"] else 0\n            # Score: prefer same flange, then closer series\n            score = (flange_match * 1000) + (1000 - series_diff)\n            candidates.append((score, type_name, rt))\n\n    if candidates:\n        candidates.sort(reverse=True)  # Highest score first\n        best = candidates[0]\n        if debug:\n            print(f\"  CFS similar match: '{profile_name}' -> '{best[1]}' (score={best[0]})\")\n        return best[2], 'cfs_similar'\n\n    # Priority 2: Same type (S/T), any gauge - for when gauge differs\n    for type_name, rt, parsed in cfs_types:\n        if parsed[\"type\"] == source[\"type\"]:\n            if debug:\n                print(f\"  CFS type match: '{profile_name}' -> '{type_name}'\")\n            return rt, 'cfs_type_match'\n\n    # Priority 3: Any CFS type at all (last resort within CFS family)\n    if cfs_types:\n        type_name, rt, _ = cfs_types[0]\n        if debug:\n            print(f\"  CFS fallback: '{profile_name}' -> '{type_name}'\")\n        return rt, 'cfs_fallback'\n\n    return None, None\n\n\ndef find_matching_revit_type(profile_name: str, revit_types: list,\n                              user_mapping: dict = None,\n                              debug_first_n: int = 0) -> tuple:\n    \"\"\"\n    Find a matching Revit type for a profile name.\n\n    Matching strategy (in order):\n    1. User-provided mapping (exact match)\n    2. Exact match with Revit type name\n    3. Profile name contained in Revit type name\n    4. Default mapping\n    5. Similar CFS profile (same type/gauge, different series)\n    6. Fallback to first available type\n\n    Args:\n        profile_name: Profile name from framing element (e.g., \"2x4\")\n        revit_types: List of available Revit family types\n        user_mapping: Optional dict of profile_name -> revit_type_name\n        debug_first_n: If > 0, print debug info for first N calls\n\n    Returns:\n        Tuple of (matched_type, match_quality) where match_quality is:\n        'exact', 'contains', 'default', 'cfs_similar', 'fallback', or None\n    \"\"\"\n    if not revit_types:\n        return None, None\n\n    profile_lower = profile_name.lower().strip()\n\n    # Build mapping of revit type names to types\n    type_name_map = {}\n    type_name_list = []  # For debug output\n    for rt in revit_types:\n        try:\n            # Get type name - handle both Revit API objects and strings\n            if hasattr(rt, 'Name'):\n                name = rt.Name\n            elif hasattr(rt, 'get_Name'):\n                name = rt.get_Name()\n            else:\n                name = str(rt)\n            type_name_map[name.lower()] = rt\n            type_name_list.append(name)\n        except Exception as e:\n            type_name_list.append(f\"ERROR: {e}\")\n            continue\n\n    # Debug output for first few calls\n    if debug_first_n > 0:\n        print(f\"\\n[TYPE MATCH DEBUG] Profile: '{profile_name}' -> '{profile_lower}'\")\n        print(f\"  Available types ({len(type_name_list)}): {type_name_list[:5]}...\")\n\n    # 1. User-provided mapping\n    if user_mapping and profile_name in user_mapping:\n        target_name = user_mapping[profile_name].lower()\n        if target_name in type_name_map:\n            return type_name_map[target_name], 'user_mapping'\n        if debug_first_n > 0:\n            print(f\"  User mapping '{profile_name}' -> '{user_mapping[profile_name]}' NOT FOUND in types\")\n\n    # 2. Exact match\n    if profile_lower in type_name_map:\n        return type_name_map[profile_lower], 'exact'\n\n    # 3. Profile name contained in type name (e.g., \"2x4\" in \"Stud - 2x4\")\n    for type_name, rt in type_name_map.items():\n        if profile_lower in type_name:\n            if debug_first_n > 0:\n                print(f\"  Contains match: '{profile_lower}' in '{type_name}'\")\n            return rt, 'contains'\n\n    if debug_first_n > 0:\n        print(f\"  No contains match found for '{profile_lower}'\")\n\n    # 4. Default mapping\n    if profile_name in DEFAULT_TYPE_MAPPING:\n        default_target = DEFAULT_TYPE_MAPPING[profile_name].lower()\n        if default_target in type_name_map:\n            return type_name_map[default_target], 'default'\n        # Also try pattern matching with default\n        for type_name, rt in type_name_map.items():\n            if default_target in type_name:\n                return rt, 'default_contains'\n\n    # 5. NEW: Find similar CFS profile when exact match fails\n    # This handles cases where generator uses 362-series but Revit has 350/600-series\n    cfs_match, cfs_quality = find_similar_cfs_profile(\n        profile_name, type_name_map, debug=(debug_first_n > 0)\n    )\n    if cfs_match:\n        return cfs_match, cfs_quality\n\n    # 6. Fallback to first available type\n    if revit_types:\n        return revit_types[0], 'fallback'\n\n    return None, None\n\n\ndef create_centerline_curve(element: FramingElementData, factory):\n    \"\"\"\n    Create a LineCurve centerline from a framing element.\n\n    Args:\n        element: FramingElementData with centerline info\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        LineCurve geometry or None if creation fails\n    \"\"\"\n    start = element.centerline_start\n    end = element.centerline_end\n\n    return factory.create_line_curve(\n        (start.x, start.y, start.z),\n        (end.x, end.y, end.z)\n    )\n\n\ndef create_column_plane(element: FramingElementData, wall_x_axis: tuple,\n                        should_flip: bool = False) -> tuple:\n    \"\"\"\n    Create a placement plane for a vertical column.\n\n    CRITICAL: Vertical columns use plane-based placement to avoid the\n    centerline offset issue that occurs with curve-based \"Slanted\" columns.\n    The plane's X-axis controls the column's orientation (where C-section\n    lips face).\n\n    Args:\n        element: FramingElementData with centerline info\n        wall_x_axis: Tuple (x, y, z) of wall's X-axis direction\n        should_flip: If True, flip X-axis 180° (for end studs, mirrored elements)\n\n    Returns:\n        Tuple of (rg.Plane, x_axis_tuple) or (None, None) if creation fails\n    \"\"\"\n    try:\n        # Origin at column base (centerline start)\n        origin = rg.Point3d(\n            element.centerline_start.x,\n            element.centerline_start.y,\n            element.centerline_start.z\n        )\n\n        # X-axis controls where C-section lips face\n        # Standard: face toward wall's X-axis direction\n        wall_ax = wall_x_axis[0] if wall_x_axis else 1.0\n        wall_ay = wall_x_axis[1] if wall_x_axis else 0.0\n\n        x_axis = rg.Vector3d(wall_ax, wall_ay, 0)\n        x_axis.Unitize()\n\n        # Flip for end studs, mirrored opening elements, etc.\n        if should_flip:\n            x_axis = -x_axis\n\n        # Z-axis is always World Z (column goes vertical)\n        z_axis = rg.Vector3d(0, 0, 1)\n\n        # Y-axis = Z × X (right-hand rule)\n        y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n        y_axis.Unitize()\n\n        plane = rg.Plane(origin, x_axis, y_axis)\n\n        # Return plane and the x_axis as tuple for JSON serialization\n        x_axis_tuple = (float(x_axis.X), float(x_axis.Y), float(x_axis.Z))\n        return plane, x_axis_tuple\n\n    except Exception as e:\n        print(f\"Error creating column plane: {e}\")\n        return None, None\n\n\ndef compute_csr_angle(element_type: str, material_system: str,\n                      centerline_vector: tuple = None,\n                      wall_normal: tuple = None,\n                      wall_x_axis: tuple = None,\n                      element_id: str = None,\n                      mirror_opening_studs: bool = False,\n                      is_end_stud: bool = False) -> float:\n    \"\"\"\n    Compute Cross-Section Rotation angle for CFS elements.\n\n    CFS (Cold-Formed Steel) profiles are C-shaped and require specific\n    orientation when baked to Revit. This function returns the CSR angle\n    based on element type, wall normal, and wall x_axis.\n\n    CRITICAL INSIGHT:\n    CSR rotates around the beam's centerline axis. The \"local Y\" direction\n    (perpendicular to centerline in horizontal plane) determines where CSR 90°\n    points. For blocking to face INWARD:\n    - local Y = world_Z × centerline_direction\n    - If local Y points opposite to wall_normal → CSR 90° = INWARD\n    - If local Y points same as wall_normal → CSR 270° = INWARD\n\n    Args:\n        element_type: Element type string (e.g., \"stud\", \"bottom_plate\")\n        material_system: \"timber\" or \"cfs\"\n        centerline_vector: Tuple (x, y, z) of the centerline direction vector.\n        wall_normal: Tuple (x, y, z) of the wall's Z-axis (outward normal).\n        wall_x_axis: Tuple (x, y, z) of the wall's X-axis (run direction).\n        element_id: Element ID string. Used to detect opening side for mirroring.\n        mirror_opening_studs: If True, flip trimmer_0 and king_stud_1 by 180°.\n        is_end_stud: If True, this is the last stud at the wall end (flip 180°).\n\n    Returns:\n        CSR angle in degrees (0, 90, 180, or 270)\n    \"\"\"\n    # Timber elements don't need rotation\n    if material_system.lower() != \"cfs\":\n        return 0.0\n\n    elem_lower = element_type.lower()\n\n    # Get vector components with defaults\n    vec_x, vec_y, vec_z = centerline_vector if centerline_vector else (1, 0, 0)\n    norm_x, norm_y, norm_z = wall_normal if wall_normal else (0, 0, 0)\n    wall_ax, wall_ay, wall_az = wall_x_axis if wall_x_axis else (1, 0, 0)\n\n    # For vertical members, the vector is primarily Z\n    is_vertical = abs(vec_z) > max(abs(vec_x), abs(vec_y))\n\n    if is_vertical:\n        # Vertical members (studs, cripples, etc.)\n        VERTICAL_TYPES = {\"stud\", \"king_stud\", \"trimmer\",\n                          \"header_cripple\", \"sill_cripple\"}\n\n        if elem_lower in VERTICAL_TYPES:\n            # =========================================================\n            # Column CSR: All columns face toward wall's U vector (wall_x_axis)\n            # =========================================================\n            # For vertical columns, CSR rotates around the Z-axis.\n            # Empirically determined from Revit testing:\n            #   CSR 0°   = C-opening faces +X\n            #   CSR 90°  = C-opening faces -Y (not +Y!)\n            #   CSR 180° = C-opening faces -X\n            #   CSR 270° = C-opening faces +Y (not -Y!)\n            #\n            # To face wall_x_axis direction:\n            if abs(wall_ax) >= abs(wall_ay):\n                # Wall runs along X\n                base_csr = 0.0 if wall_ax >= 0 else 180.0\n            else:\n                # Wall runs along Y (note: 90°=-Y, 270°=+Y)\n                base_csr = 270.0 if wall_ay >= 0 else 90.0\n\n            # =========================================================\n            # Flip logic for special studs\n            # =========================================================\n            should_flip = False\n\n            # 1. End stud (last stud at wall end) - always flip\n            if is_end_stud and elem_lower == \"stud\":\n                should_flip = True\n\n            # 2. mirror_opening_studs logic:\n            #    - Flip trimmer BEFORE opening (side 0 / left): trimmer_X_0\n            #    - Flip king stud AFTER opening (side 1 / right): king_stud_X_1\n            if mirror_opening_studs and element_id:\n                if elem_lower == \"trimmer\" and element_id.endswith(\"_0\"):\n                    # Trimmer before opening (left side) - flip\n                    should_flip = True\n                elif elem_lower == \"king_stud\" and element_id.endswith(\"_1\"):\n                    # King stud after opening (right side) - flip\n                    should_flip = True\n\n            if should_flip:\n                return (base_csr + 180.0) % 360.0\n\n            return base_csr\n\n    # Horizontal members\n    HORIZONTAL_TYPES = {\n        \"bottom_plate\", \"bottom_track\",\n        \"top_plate\", \"top_track\",\n        \"sill\", \"header\",\n        \"row_blocking\", \"bridging\"\n    }\n\n    if elem_lower not in HORIZONTAL_TYPES:\n        return 0.0\n\n    # =========================================================================\n    # Determine if centerline matches wall x_axis direction\n    # =========================================================================\n    # Compute dot product to see if they point same direction\n    # dot > 0 means same direction, dot < 0 means opposite\n    dot_product = vec_x * wall_ax + vec_y * wall_ay + vec_z * wall_az\n    centerline_matches_wall_axis = dot_product >= 0\n\n    # =========================================================================\n    # Compute local Y direction (perpendicular to centerline in horizontal plane)\n    # local_Y = world_Z × centerline = (0,0,1) × (vec_x, vec_y, 0)\n    #         = (-vec_y, vec_x, 0) [normalized direction]\n    # =========================================================================\n    # For CSR 90°, the C-opening faces local Y direction\n    # We want C-opening to face INWARD (opposite of wall_normal)\n    #\n    # Check if local_Y points opposite to wall_normal (inward):\n    # local_Y · wall_normal < 0 means local_Y points inward\n    local_y_x = -vec_y  # Cross product of (0,0,1) × (vec_x, vec_y, 0)\n    local_y_y = vec_x\n    dot_local_y_normal = local_y_x * norm_x + local_y_y * norm_y\n    local_y_points_inward = dot_local_y_normal < 0\n\n    # =========================================================================\n    # Determine CSR based on element type\n    # =========================================================================\n    # CSR reference (empirically determined from Revit testing):\n    #   CSR 0°   = C-opening faces -local_Y (opposite of horizontal perpendicular)\n    #   CSR 90°  = C-opening faces UP (+Z)\n    #   CSR 180° = C-opening faces +local_Y (horizontal perpendicular)\n    #   CSR 270° = C-opening faces DOWN (-Z)\n    #\n    # CFS Framing Orientation Rules:\n    #   - Bottom plates/tracks: face UP (CSR 90°)\n    #   - Top plates/tracks: face DOWN (CSR 270°)\n    #   - Sills: face DOWN (CSR 270°)\n    #   - Headers: face UP (CSR 90°)\n    #   - Blocking/Bridging: face DOWN (CSR 270°)\n\n    if elem_lower in {\"bottom_plate\", \"bottom_track\"}:\n        return 90.0  # Face UP\n\n    elif elem_lower in {\"top_plate\", \"top_track\"}:\n        return 270.0  # Face DOWN\n\n    elif elem_lower == \"sill\":\n        return 270.0  # Face DOWN\n\n    elif elem_lower == \"header\":\n        return 90.0  # Face UP\n\n    elif elem_lower in {\"row_blocking\", \"bridging\"}:\n        return 270.0  # Face DOWN\n\n    return 0.0\n\n\ndef parse_wall_json(wall_json_input):\n    \"\"\"\n    Parse wall JSON and extract level and geometry information.\n\n    Args:\n        wall_json_input: JSON string or list from Wall Analyzer\n\n    Returns:\n        Dict mapping wall_id to {base_level_id, top_level_id, wall_length}\n    \"\"\"\n    # Handle Grasshopper wrapping in list\n    json_str = wall_json_input\n    if isinstance(wall_json_input, (list, tuple)):\n        json_str = wall_json_input[0] if wall_json_input else \"[]\"\n\n    try:\n        walls = json.loads(json_str)\n        if not isinstance(walls, list):\n            walls = [walls]\n\n        wall_data = {}\n        for wall in walls:\n            wall_id = wall.get('wall_id', 'unknown')\n            wall_data[wall_id] = {\n                'base_level_id': wall.get('base_level_id'),\n                'top_level_id': wall.get('top_level_id'),\n                'wall_length': wall.get('wall_length', 0),\n            }\n        return wall_data\n    except Exception as e:\n        print(f\"Error parsing wall_json: {e}\")\n        return {}\n\n\ndef get_revit_level_by_id(doc, level_id: int):\n    \"\"\"\n    Get a Revit Level element by its integer ID.\n\n    Args:\n        doc: Revit Document\n        level_id: Integer element ID\n\n    Returns:\n        Revit Level element or None\n    \"\"\"\n    if level_id is None:\n        return None\n\n    try:\n        from Autodesk.Revit import DB\n        element_id = DB.ElementId(level_id)\n        level = doc.GetElement(element_id)\n        return level\n    except Exception as e:\n        print(f\"Error getting level {level_id}: {e}\")\n        return None\n\n\ndef extract_wall_id_from_element(element: FramingElementData) -> str:\n    \"\"\"\n    Extract wall ID from element metadata or cell_id.\n\n    Args:\n        element: FramingElementData instance\n\n    Returns:\n        Wall ID string or 'unknown'\n    \"\"\"\n    # Try metadata first\n    if element.metadata and element.metadata.get('wall_id'):\n        return element.metadata['wall_id']\n\n    # Try cell_id (format: \"1361779_SC_0\")\n    if element.cell_id:\n        parts = element.cell_id.split('_')\n        if len(parts) >= 1:\n            return parts[0]\n\n    # Try element id\n    if '_' in element.id:\n        parts = element.id.split('_')\n        if len(parts) >= 1 and parts[0].isdigit():\n            return parts[0]\n\n    return 'unknown'\n\n\n# =============================================================================\n# Main Execution\n# =============================================================================\n\n# Initialize outputs\nbaking_data_json = \"\"\ncolumn_curves = DataTree[object]()   # Curves for column creation\nbeam_curves = DataTree[object]()     # Curves for beam placement (with CSR)\ndebug_info = \"\"\n\nif run and elements_json:\n    try:\n        # Handle Grasshopper wrapping\n        json_input = elements_json\n        if isinstance(elements_json, (list, tuple)):\n            json_input = elements_json[0] if elements_json else \"\"\n\n        # Get geometry factory\n        factory = get_factory()\n\n        # Get Revit document for level lookup\n        doc = Revit.ActiveDBDocument\n\n        # Parse elements JSON\n        results = deserialize_framing_results(json_input)\n\n        # Parse wall JSON for level information\n        wall_levels = {}\n        if wall_json:\n            wall_levels = parse_wall_json(wall_json)\n\n        # Parse mirror_opening_studs input (default False)\n        do_mirror = False\n        if mirror_opening_studs:\n            if isinstance(mirror_opening_studs, (list, tuple)):\n                do_mirror = bool(mirror_opening_studs[0]) if mirror_opening_studs else False\n            else:\n                do_mirror = bool(mirror_opening_studs)\n\n        # Parse user type mapping if provided\n        user_type_mapping = None\n        if type_mapping:\n            if isinstance(type_mapping, str):\n                try:\n                    user_type_mapping = json.loads(type_mapping)\n                except:\n                    pass\n            elif isinstance(type_mapping, dict):\n                user_type_mapping = type_mapping\n\n        debug_lines = [\n            \"Revit Baker v3.0 (with CSR support)\",\n            \"=\" * 40,\n            f\"Material System: {results.material_system}\",\n            f\"Total Elements: {len(results.elements)}\",\n            f\"Walls with Level Info: {len(wall_levels)}\",\n            f\"Mirror Opening Studs: {do_mirror}\",\n            f\"Revit Document: {'Available' if doc else 'NOT AVAILABLE'}\",\n            \"\",\n        ]\n\n        # DEBUG: Show wall level info\n        if wall_levels:\n            debug_lines.append(\"Wall Level Data (first 5):\")\n            for i, (wid, levels) in enumerate(list(wall_levels.items())[:5]):\n                debug_lines.append(f\"  Wall {wid}: base_level_id={levels.get('base_level_id')}, top_level_id={levels.get('top_level_id')}\")\n            if len(wall_levels) > 5:\n                debug_lines.append(f\"  ... and {len(wall_levels) - 5} more walls\")\n            debug_lines.append(\"\")\n        else:\n            debug_lines.append(\"WARNING: No wall level data parsed!\")\n            debug_lines.append(\"  - Is wall_json connected?\")\n            debug_lines.append(\"  - Does wall_json contain base_level_id/top_level_id fields?\")\n            debug_lines.append(\"\")\n\n        # Convert revit type inputs to lists\n        column_type_list = []\n        beam_type_list = []\n\n        if revit_column_types:\n            if isinstance(revit_column_types, (list, tuple)):\n                column_type_list = list(revit_column_types)\n            else:\n                column_type_list = [revit_column_types]\n\n        if revit_beam_types:\n            if isinstance(revit_beam_types, (list, tuple)):\n                beam_type_list = list(revit_beam_types)\n            else:\n                beam_type_list = [revit_beam_types]\n\n        # DEBUG: Extract and show Revit type names\n        def get_type_name(rt):\n            try:\n                if hasattr(rt, 'Name'):\n                    return rt.Name\n                elif hasattr(rt, 'get_Name'):\n                    return rt.get_Name()\n                else:\n                    return str(rt)\n            except:\n                return \"ERROR\"\n\n        column_type_names = [get_type_name(rt) for rt in column_type_list[:5]]\n        beam_type_names = [get_type_name(rt) for rt in beam_type_list[:5]]\n\n        debug_lines.append(f\"Available Column Types: {len(column_type_list)}\")\n        debug_lines.append(f\"  First 5 names: {column_type_names}\")\n        debug_lines.append(f\"Available Beam Types: {len(beam_type_list)}\")\n        debug_lines.append(f\"  First 5 names: {beam_type_names}\")\n        debug_lines.append(\"\")\n\n        # DEBUG: Show first few element profile names\n        profile_names_seen = set()\n        for elem in results.elements[:20]:\n            profile_names_seen.add(elem.profile.name)\n        debug_lines.append(f\"Profile names in elements (sample): {sorted(profile_names_seen)}\")\n        debug_lines.append(\"\")\n\n        # =================================================================\n        # Group elements by wall for structured JSON output\n        # =================================================================\n        wall_elements = {}  # wall_id -> list of elements\n        for element in results.elements:\n            wall_id = extract_wall_id_from_element(element)\n            if wall_id not in wall_elements:\n                wall_elements[wall_id] = []\n            wall_elements[wall_id].append(element)\n\n        # Initialize baking data structure\n        baking_data = {\n            \"walls\": {},\n            \"summary\": {\n                \"total_walls\": 0,\n                \"total_columns\": 0,\n                \"total_beams\": 0,\n                \"material_system\": results.material_system\n            }\n        }\n\n        # Track counts and statistics\n        column_count = 0\n        beam_count = 0\n        skipped_count = 0\n        unmapped = []\n        type_match_stats = {'exact': 0, 'contains': 0, 'default': 0, 'fallback': 0, 'user_mapping': 0, 'default_contains': 0, 'cfs_similar': 0, 'cfs_type_match': 0, 'cfs_fallback': 0}\n\n        # CSR statistics for debug output\n        csr_stats = {}  # element_type -> {csr_angle -> count}\n\n        # Centerline vector debug tracking\n        vector_debug = {}  # element_type -> list of (vector, csr) for first few\n\n        # DEBUG: Track first few elements for detailed output\n        debug_element_count = 0\n        max_debug_elements = 3\n\n        # =================================================================\n        # Process each wall's elements\n        # =================================================================\n        for wall_id, elements in wall_elements.items():\n            # Get level info from wall data\n            wall_level_info = wall_levels.get(wall_id, {})\n            base_level_id = wall_level_info.get('base_level_id')\n            top_level_id = wall_level_info.get('top_level_id')\n\n            # Initialize wall data in baking structure\n            wall_data = {\n                \"base_level_id\": base_level_id,\n                \"top_level_id\": top_level_id,\n                \"members\": []\n            }\n\n            for element in elements:\n                elem_type = element.element_type.lower()\n                classification = classify_element(elem_type)\n\n                # DEBUG: Track level resolution for first few elements\n                if debug_element_count < max_debug_elements:\n                    print(f\"\\n[LEVEL DEBUG] Element: {element.id}\")\n                    print(f\"  Wall ID from element: '{wall_id}'\")\n                    print(f\"  Wall ID in wall_levels: {wall_id in wall_levels}\")\n                    print(f\"  base_level_id: {base_level_id}, top_level_id: {top_level_id}\")\n                    # DEBUG: Show centerline coordinates for alignment verification\n                    print(f\"  [CENTERLINE] start=({element.centerline_start.x:.4f}, {element.centerline_start.y:.4f}, {element.centerline_start.z:.4f})\")\n                    print(f\"  [CENTERLINE] end=({element.centerline_end.x:.4f}, {element.centerline_end.y:.4f}, {element.centerline_end.z:.4f})\")\n                    debug_element_count += 1\n\n                # Profile name for type matching\n                profile_name = element.profile.name\n\n                # Enable debug for first few type matches\n                debug_type_match = (column_count + beam_count) < 3\n\n                # Determine which type list to use based on classification\n                if classification == \"column\":\n                    type_list = column_type_list\n                elif classification == \"beam\":\n                    type_list = beam_type_list\n                else:\n                    unmapped.append(f\"Unknown: {element.id} ({elem_type})\")\n                    skipped_count += 1\n                    continue\n\n                # Match to Revit type\n                matched_type, match_quality = find_matching_revit_type(\n                    profile_name, type_list, user_type_mapping,\n                    debug_first_n=1 if debug_type_match else 0\n                )\n\n                if matched_type is None:\n                    unmapped.append(f\"{classification.title()}: {element.id} ({profile_name})\")\n                    skipped_count += 1\n                    continue\n\n                if match_quality:\n                    type_match_stats[match_quality] = type_match_stats.get(match_quality, 0) + 1\n\n                # =========================================================\n                # Compute CSR angle for CFS elements\n                # =========================================================\n                # Use the ACTUAL centerline vector (end - start) as rotation axis\n                # This is what Revit uses to determine CSR rotation direction\n                centerline_vector = (\n                    element.centerline_end.x - element.centerline_start.x,\n                    element.centerline_end.y - element.centerline_start.y,\n                    element.centerline_end.z - element.centerline_start.z\n                )\n\n                # Extract wall normal (wall_z_axis) and wall x_axis from element metadata\n                wall_normal = None\n                wall_x_axis = None\n                if element.metadata:\n                    if 'wall_z_axis' in element.metadata:\n                        axis = element.metadata['wall_z_axis']\n                        if isinstance(axis, dict):\n                            wall_normal = (axis.get('x', 0), axis.get('y', 0), axis.get('z', 0))\n                        elif isinstance(axis, (list, tuple)):\n                            wall_normal = tuple(axis)\n\n                    if 'wall_x_axis' in element.metadata:\n                        axis = element.metadata['wall_x_axis']\n                        if isinstance(axis, dict):\n                            wall_x_axis = (axis.get('x', 0), axis.get('y', 0), axis.get('z', 0))\n                        elif isinstance(axis, (list, tuple)):\n                            wall_x_axis = tuple(axis)\n\n                # Detect if this is the end stud (last stud at panel/wall end)\n                # For panelized walls, each panel has its own first/last studs\n                # First stud = normal orientation, Last stud = flipped (facing inward)\n                is_end_stud = False\n                is_panel_end_stud = False\n                if elem_type == \"stud\":\n                    wall_length = wall_level_info.get('wall_length', 0)\n                    u_coord = getattr(element, 'u_coord', None)\n                    stud_width = 0.125  # 1.5\" in feet (approximate)\n                    tolerance = stud_width * 1.5\n\n                    # Check for panel boundaries in element metadata\n                    panel_u_start = None\n                    panel_u_end = None\n                    if element.metadata:\n                        panel_u_start = element.metadata.get('panel_u_start')\n                        panel_u_end = element.metadata.get('panel_u_end')\n\n                    if u_coord is not None:\n                        # Check if at panel end (for panelized walls)\n                        if panel_u_end is not None:\n                            if abs(u_coord - (panel_u_end - stud_width / 2)) < tolerance:\n                                is_panel_end_stud = True\n                                is_end_stud = True\n                        # Check if at wall end (for non-panelized or last panel)\n                        elif wall_length > 0:\n                            if u_coord > wall_length - tolerance:\n                                is_end_stud = True\n\n                    # DEBUG: Track end stud detection for first wall\n                    if wall_id == list(wall_elements.keys())[0] and elem_type == \"stud\":\n                        if 'end_stud_debug' not in vector_debug:\n                            vector_debug['end_stud_debug'] = []\n                        vector_debug['end_stud_debug'].append({\n                            'id': element.id,\n                            'u_coord': u_coord,\n                            'wall_length': wall_length,\n                            'panel_u_start': panel_u_start,\n                            'panel_u_end': panel_u_end,\n                            'is_end_stud': is_end_stud,\n                            'is_panel_end_stud': is_panel_end_stud\n                        })\n\n                csr_angle = compute_csr_angle(\n                    elem_type,\n                    results.material_system,\n                    centerline_vector,\n                    wall_normal,\n                    wall_x_axis,\n                    element.id,\n                    do_mirror,\n                    is_end_stud\n                )\n\n                # =========================================================\n                # Create geometry based on classification\n                # =========================================================\n                # COLUMNS: Curve for creation, plane data in JSON for orientation\n                # BEAMS: Curves with CSR for orientation\n\n                column_curve = None\n                column_x_axis_tuple = None\n                beam_curve = None\n\n                if classification == \"column\":\n                    # Create centerline curve for column creation\n                    column_curve = create_centerline_curve(element, factory)\n                    if not column_curve:\n                        skipped_count += 1\n                        continue\n\n                    # Determine if column orientation should be flipped\n                    should_flip = False\n\n                    # End stud (last stud at panel/wall end) - always flip\n                    # For panelized walls, each panel's last stud faces inward\n                    if is_end_stud and elem_type == \"stud\":\n                        should_flip = True\n\n                    # mirror_opening_studs: flip trimmer_0 and king_stud_1\n                    if do_mirror and element.id:\n                        if elem_type == \"trimmer\" and element.id.endswith(\"_0\"):\n                            should_flip = True\n                        elif elem_type == \"king_stud\" and element.id.endswith(\"_1\"):\n                            should_flip = True\n\n                    # Compute orientation X-axis for JSON output\n                    # (Baking Data Parser will create actual Plane from this)\n                    wall_ax = wall_x_axis[0] if wall_x_axis else 1.0\n                    wall_ay = wall_x_axis[1] if wall_x_axis else 0.0\n                    if should_flip:\n                        column_x_axis_tuple = (-wall_ax, -wall_ay, 0.0)\n                    else:\n                        column_x_axis_tuple = (wall_ax, wall_ay, 0.0)\n                else:\n                    # Beams use centerline curves with CSR for orientation\n                    beam_curve = create_centerline_curve(element, factory)\n                    if not beam_curve:\n                        skipped_count += 1\n                        continue\n\n                # DEBUG: Track opening element CSR details\n                if elem_type in ('king_stud', 'trimmer'):\n                    if 'opening_elements_debug' not in vector_debug:\n                        vector_debug['opening_elements_debug'] = []\n                    # Compute base CSR (without flip) for comparison\n                    wall_ax = wall_x_axis[0] if wall_x_axis else 1\n                    wall_ay = wall_x_axis[1] if wall_x_axis else 0\n                    if abs(wall_ax) >= abs(wall_ay):\n                        base_csr = 0.0 if wall_ax >= 0 else 180.0\n                    else:\n                        base_csr = 90.0 if wall_ay >= 0 else 270.0\n                    is_flipped = abs(csr_angle - base_csr) > 1.0  # Check if different from base\n                    vector_debug['opening_elements_debug'].append({\n                        'wall_id': wall_id,\n                        'id': element.id,\n                        'csr': csr_angle,\n                        'base_csr': base_csr,\n                        'flipped': is_flipped\n                    })\n\n                # Track CSR statistics for debug\n                if elem_type not in csr_stats:\n                    csr_stats[elem_type] = {}\n                csr_stats[elem_type][csr_angle] = csr_stats[elem_type].get(csr_angle, 0) + 1\n\n                # Get Revit type name for JSON output\n                revit_type_name = get_type_name(matched_type)\n\n                # Determine geometry index based on classification (compute BEFORE debug tracking)\n                if classification == \"column\":\n                    geometry_index = column_count\n                else:\n                    geometry_index = beam_count\n\n                # Track ALL blocking elements for comprehensive debug\n                if elem_type == \"row_blocking\":\n                    if elem_type not in vector_debug:\n                        vector_debug[elem_type] = []\n                    vec_x, vec_y, vec_z = centerline_vector\n                    local_y = (-vec_y, vec_x)  # Cross product with Z\n                    norm_x, norm_y = (wall_normal[0], wall_normal[1]) if wall_normal else (0, 0)\n                    dot_local_y_normal = local_y[0] * norm_x + local_y[1] * norm_y\n                    local_y_inward = dot_local_y_normal < 0\n                    vector_debug[elem_type].append({\n                        'id': element.id,\n                        'start': (element.centerline_start.x, element.centerline_start.y, element.centerline_start.z),\n                        'end': (element.centerline_end.x, element.centerline_end.y, element.centerline_end.z),\n                        'vector': centerline_vector,\n                        'normal': wall_normal,\n                        'csr': csr_angle,\n                        'local_y': local_y,\n                        'local_y_inward': local_y_inward,\n                        'wall_id': wall_id,\n                        'geometry_index': geometry_index\n                    })\n\n                # Build member data for JSON\n                member_data = {\n                    \"id\": element.id,\n                    \"element_type\": element.element_type,\n                    \"classification\": classification,\n                    \"profile_name\": profile_name,\n                    \"revit_type_name\": revit_type_name,\n                    \"centerline_start\": {\n                        \"x\": element.centerline_start.x,\n                        \"y\": element.centerline_start.y,\n                        \"z\": element.centerline_start.z\n                    },\n                    \"centerline_end\": {\n                        \"x\": element.centerline_end.x,\n                        \"y\": element.centerline_end.y,\n                        \"z\": element.centerline_end.z\n                    },\n                    \"geometry_index\": geometry_index\n                }\n\n                # Add classification-specific data\n                if classification == \"column\":\n                    # Columns use plane-based placement (no CSR)\n                    member_data[\"plane_origin\"] = {\n                        \"x\": element.centerline_start.x,\n                        \"y\": element.centerline_start.y,\n                        \"z\": element.centerline_start.z\n                    }\n                    if column_x_axis_tuple:\n                        member_data[\"plane_x_axis\"] = {\n                            \"x\": column_x_axis_tuple[0],\n                            \"y\": column_x_axis_tuple[1],\n                            \"z\": column_x_axis_tuple[2]\n                        }\n                else:\n                    # Beams use CSR for orientation\n                    member_data[\"csr_angle\"] = csr_angle\n\n                wall_data[\"members\"].append(member_data)\n\n                # Add geometry to appropriate DataTree\n                # Note: Column plane data (for orientation) is in baking_data_json\n                if classification == \"column\":\n                    path = GH_Path(column_count)\n                    column_curves.Add(column_curve, path)\n                    column_count += 1\n                elif classification == \"beam\":\n                    path = GH_Path(beam_count)\n                    beam_curves.Add(beam_curve, path)\n                    beam_count += 1\n\n            # Add wall data to baking structure\n            baking_data[\"walls\"][wall_id] = wall_data\n\n        # Update summary\n        baking_data[\"summary\"][\"total_walls\"] = len(wall_elements)\n        baking_data[\"summary\"][\"total_columns\"] = column_count\n        baking_data[\"summary\"][\"total_beams\"] = beam_count\n\n        # Serialize to JSON output\n        baking_data_json = json.dumps(baking_data, indent=2)\n\n        # =================================================================\n        # Build debug summary\n        # =================================================================\n        debug_lines.append(\"Classification Summary:\")\n        debug_lines.append(f\"  Walls: {len(wall_elements)}\")\n        debug_lines.append(f\"  Columns: {column_count}\")\n        debug_lines.append(f\"  Beams: {beam_count}\")\n        debug_lines.append(f\"  Skipped/Unmapped: {skipped_count}\")\n        debug_lines.append(\"\")\n\n        # Wall ID matching summary\n        wall_ids_in_json = set(wall_levels.keys())\n        wall_ids_from_elements = set(wall_elements.keys())\n        matched_wall_ids = wall_ids_from_elements & wall_ids_in_json\n        unmatched_element_wall_ids = wall_ids_from_elements - wall_ids_in_json\n        debug_lines.append(\"Wall ID Matching:\")\n        debug_lines.append(f\"  Wall IDs from elements: {len(wall_ids_from_elements)}\")\n        debug_lines.append(f\"  Wall IDs in wall_json: {len(wall_ids_in_json)}\")\n        debug_lines.append(f\"  Matched: {len(matched_wall_ids)}\")\n        if unmatched_element_wall_ids:\n            debug_lines.append(f\"  UNMATCHED element wall IDs: {sorted(unmatched_element_wall_ids)[:5]}\")\n        debug_lines.append(\"\")\n\n        # Orientation summary (CFS only)\n        debug_lines.append(\"Orientation Control (CFS):\")\n        debug_lines.append(f\"  Material System: {results.material_system}\")\n        debug_lines.append(f\"  Mirror Opening Studs: {do_mirror}\")\n        debug_lines.append(f\"  Columns: Plane-based (X-axis controls orientation)\")\n        debug_lines.append(f\"  Beams: CSR parameter (Cross-Section Rotation)\")\n        if results.material_system.lower() == \"cfs\":\n            debug_lines.append(\"  Beam CSR Values by Element Type:\")\n            for elem_type in sorted(csr_stats.keys()):\n                # Skip column types in CSR stats (they use plane orientation)\n                if elem_type in {\"stud\", \"king_stud\", \"trimmer\", \"header_cripple\", \"sill_cripple\"}:\n                    continue\n                angles = csr_stats[elem_type]\n                angle_summary = \", \".join([f\"{angle}°: {count}\" for angle, count in sorted(angles.items())])\n                debug_lines.append(f\"    {elem_type}: {angle_summary}\")\n\n            # Show ALL blocking elements grouped by wall\n            debug_lines.append(\"\")\n            debug_lines.append(\"  ALL Blocking Elements (grouped by wall):\")\n            if \"row_blocking\" in vector_debug:\n                # Group by wall\n                by_wall = {}\n                for sample in vector_debug[\"row_blocking\"]:\n                    wid = sample.get('wall_id', '?')\n                    if wid not in by_wall:\n                        by_wall[wid] = []\n                    by_wall[wid].append(sample)\n\n                for wid in sorted(by_wall.keys()):\n                    samples = by_wall[wid]\n                    # Get wall normal from first sample\n                    norm = samples[0]['normal'] if samples else None\n                    norm_str = f\"({norm[0]:.2f}, {norm[1]:.2f})\" if norm else \"None\"\n                    debug_lines.append(f\"    Wall {wid} (norm={norm_str}): {len(samples)} blocking\")\n                    for i, sample in enumerate(samples):\n                        start = sample.get('start', (0, 0, 0))\n                        end = sample.get('end', (0, 0, 0))\n                        vec = sample['vector']\n                        csr = sample['csr']\n                        gidx = sample.get('geometry_index', '?')\n                        # Determine direction\n                        if abs(vec[0]) >= abs(vec[1]):\n                            direction = \"+X\" if vec[0] >= 0 else \"-X\"\n                        else:\n                            direction = \"+Y\" if vec[1] >= 0 else \"-Y\"\n                        # Show Z coordinate to identify upper vs lower row\n                        z_height = start[2] if len(start) > 2 else 0\n                        debug_lines.append(f\"      [{i}] {sample['id']}: X({start[0]:.1f}->{end[0]:.1f}) Y({start[1]:.1f}) Z={z_height:.1f} dir={direction} CSR={csr}° idx={gidx}\")\n            # Show end stud detection debug (with panel info)\n            if 'end_stud_debug' in vector_debug:\n                debug_lines.append(\"\")\n                debug_lines.append(\"  End Stud Detection (first wall, with panel info):\")\n                for stud in vector_debug['end_stud_debug']:\n                    panel_info = \"\"\n                    if stud.get('panel_u_start') is not None or stud.get('panel_u_end') is not None:\n                        panel_info = f\" panel=[{stud.get('panel_u_start', '?'):.2f}-{stud.get('panel_u_end', '?'):.2f}]\"\n                    is_panel_end = stud.get('is_panel_end_stud', False)\n                    end_type = \"PANEL_END\" if is_panel_end else (\"WALL_END\" if stud['is_end_stud'] else \"\")\n                    debug_lines.append(f\"    {stud['id']}: u={stud['u_coord']:.2f}{panel_info} {end_type}\")\n\n            # Show detailed king stud and trimmer CSR values for mirror debug\n            debug_lines.append(\"\")\n            debug_lines.append(\"  Opening Elements CSR (mirror_opening_studs debug):\")\n            debug_lines.append(f\"    mirror_opening_studs = {do_mirror}\")\n            # Collect CSR values we computed for opening elements\n            if 'opening_elements_debug' in vector_debug:\n                for item in vector_debug['opening_elements_debug']:\n                    debug_lines.append(f\"    {item['wall_id']}: {item['id']} -> CSR={item['csr']}° (base={item['base_csr']}°, flipped={item['flipped']})\")\n        else:\n            debug_lines.append(\"  (Timber - all CSR angles are 0°)\")\n        debug_lines.append(\"\")\n\n        debug_lines.append(\"Type Matching Stats:\")\n        for quality, count in type_match_stats.items():\n            if count > 0:\n                debug_lines.append(f\"  {quality}: {count}\")\n        debug_lines.append(\"\")\n\n        if unmapped:\n            debug_lines.append(f\"Unmapped Elements ({len(unmapped)}):\")\n            for item in unmapped[:10]:  # Show first 10\n                debug_lines.append(f\"  - {item}\")\n            if len(unmapped) > 10:\n                debug_lines.append(f\"  ... and {len(unmapped) - 10} more\")\n\n        debug_info = \"\\n\".join(debug_lines)\n\n    except json.JSONDecodeError as e:\n        debug_info = f\"JSON Parse Error: {str(e)}\"\n        baking_data_json = json.dumps({\"error\": str(e)})\n    except Exception as e:\n        import traceback\n        debug_info = f\"ERROR: {str(e)}\\n{traceback.format_exc()}\"\n        baking_data_json = json.dumps({\"error\": str(e)})\n\nelif not run:\n    debug_info = \"Set 'run' to True to execute\"\n    baking_data_json = json.dumps({\"error\": \"Not running\"})\nelif not elements_json:\n    debug_info = \"No elements_json input provided\"\n    baking_data_json = json.dumps({\"error\": \"No input\"})\n\n# Print debug_info so it appears in the 'out' output\nprint(debug_info)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}