{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_CrvDeviation.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_CrvDeviation.py",
  "instruction": "This script is an alternative to _CrvDeviation and\r\nRhinoCommon's Curve.GetDistancesBetweenCurves; it is used by other scripts.\r\n\r\nExample of erroneous results from...",
  "code": "\"\"\"\r\nThis script is an alternative to _CrvDeviation and\r\nRhinoCommon's Curve.GetDistancesBetweenCurves; it is used by other scripts.\r\n\r\nExample of erroneous results from Curve.GetDistancesBetweenCurves:\r\nhttps://discourse.mcneel.com/t/function-of-curve-getdistancesbetweencurves-tolerance-parameter/190553\r\n\r\nSetting LwrLimit, UprLimit, or MaxDistToRegard to 0 will disable that option.\r\n\r\nMaxDistToRegard is the lowest value, over which the distances will be ignored.\r\n\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n170927: Created.\r\n...\r\n171204: Now polycurves and polylines are \"exploded\" into segments.  If they are not,\r\n        Curve.GetDistancesBetweenCurves sometimes fails or produces erroneous results.\r\n        Curves from curve set A are not selectable for set B even though they previously were removed anyway.\r\n...\r\n240903-10:  Added optional 2 curve input routine. Removed some functions. Refactored.\r\n            Add display conduit similar to _CrvDeviation for when Mode=Abs.\r\n            Trialing a UX different than _CrvDeviation for when Mode=Abs,\r\n            that gives the user the option to skip leaving marks.\r\n241212: Updated notes, comments, and some option default values.\r\n\r\nTODO:\r\n    Clean code in spb_GDBCs_1Way that eliminates false positives at curve ends.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bInputSets'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Input2'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Crvs', 'Sets')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExplodeCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fLocAlongCrvTol'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    # Using ModelUnitSystem in case sc.doc.Name is None.\r\n    stickyKeys[key] = '{}({})({})({})'.format(key, __file__, sc.doc.Name, sc.doc.ModelUnitSystem)\r\n\r\n    key = 'bOnlyPerp'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'ClosestPtType'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Any', 'OnlyPerp')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDist_max_to_regard'; keys.append(key)\r\n    names[key] = 'MaxDistToRegard'\r\n    values[key] = 200.0 * sc.doc.ModelAbsoluteTolerance\r\n    #if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n    #    values[key] = 0.125\r\n    #elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n    #    values[key] = 3.0\r\n    #else:\r\n    #    values[key] = 1000.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bLimitMode'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Mode'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Abs', 'Limit')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fUprLimit'; keys.append(key)\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n        values[key] = 0.026\r\n    elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n        values[key] = 3.6\r\n    else:\r\n        values[key] = 1000.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fLwrLimit'; keys.append(key)\r\n    values[key] = (\r\n        0.014 if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches\r\n        else (\r\n            2.4 if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters\r\n            else 10.0*sc.doc.ModelAbsoluteTolerance)\r\n        )\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bMarkMax'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMarkMin'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bVerifyAddMarks'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddLine'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotDecPlaces'; keys.append(key)\r\n    values[key] = sc.doc.ModelDistanceDisplayPrecision - 1\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iDotFontHt'; keys.append(key)\r\n    values[key] = 11\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fLocAlongCrvTol':\r\n            if cls.riOpts[key].CurrentValue <= 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n            if cls.riOpts[key].CurrentValue <= max((1e-6, 0.001*sc.doc.ModelAbsoluteTolerance)):\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n        if key == 'fUprLimit':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n            if (cls.values[key] > 0.0) and (cls.values[key] > cls.values['fDist_max_to_regard']):\r\n                cls.values['fDist_max_to_regard'] = cls.riOpts['fDist_max_to_regard'].CurrentValue = cls.values[key]\r\n                sc.sticky[cls.stickyKeys['fDist_max_to_regard']] = cls.values['fDist_max_to_regard']\r\n            return\r\n\r\n        if key == 'fLwrLimit':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getPreselectedCurves():\r\n    gObjs_Preselected = []\r\n    for rdObj in sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False):\r\n        gObjs_Preselected.append(rdObj.Id)\r\n    if gObjs_Preselected:\r\n        gCrvs_Preselected = []\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n        for rdRhinoObject in sc.doc.Objects.GetObjectList(iter):\r\n            if rdRhinoObject.Id in gObjs_Preselected:\r\n                if rdRhinoObject.ObjectType == rd.ObjectType.Curve:\r\n                    gCrvs_Preselected.append(rdRhinoObject.Id)\r\n        if len(gCrvs_Preselected) == 2:\r\n            if Opts.values['bEcho']:\r\n                s  = \"({} curves\".format(len(gCrvs_Preselected))\r\n                s += \" were preselected and will thus be the selection set.)\"\r\n                print(s)\r\n            return tuple(gCrvs_Preselected)\r\n\r\n\r\ndef _addCommonOptions(go):\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    addOption('bInputSets')\r\n    addOption('bExplodeCrvs')\r\n    addOption('fLocAlongCrvTol')\r\n    addOption('bOnlyPerp')\r\n    addOption('fDist_max_to_regard')\r\n    addOption('bLimitMode')\r\n    if Opts.values['bLimitMode']:\r\n        addOption('fUprLimit')\r\n        addOption('fLwrLimit')\r\n    else:\r\n        addOption('bMarkMax')\r\n        addOption('bMarkMin')\r\n        if Opts.values['bMarkMax'] or Opts.values['bMarkMin']:\r\n            addOption('bVerifyAddMarks')\r\n    if (Opts.values['bLimitMode'] or Opts.values['bMarkMax'] or Opts.values['bMarkMin']):\r\n        if not Opts.values['bAddLine'] and not Opts.values['bAddDot']:\r\n            Opts.riOpts['bAddLine'].CurrentValue = True\r\n            Opts.setValue('bAddLine')\r\n            Opts.riOpts['bAddDot'].CurrentValue = True\r\n            Opts.setValue('bAddDot')\r\n        addOption('bAddLine')\r\n        addOption('bAddDot')\r\n        if Opts.values['bAddDot']:\r\n            addOption('iDotDecPlaces')\r\n            addOption('iDotFontHt')\r\n    addOption('bEcho')\r\n    addOption('bDebug')\r\n\r\n    return idxs_Opts\r\n\r\n\r\ndef getInput_2Crvs():\r\n    \"\"\"\r\n    Get 2 curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select 2 curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.GroupSelect = True\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opts = {}\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n\r\n    while True:\r\n        if Opts.values['bInputSets']:\r\n            go.Dispose()\r\n            sc.doc.Objects.UnselectAll()\r\n            sc.doc.Views.Redraw()\r\n            return getInput_2Sets()\r\n\r\n\r\n        go.ClearCommandOptions()\r\n        idxs_Opts.clear()\r\n        idxs_Opts.update(_addCommonOptions(go))\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=2)\r\n\r\n        # Use bPreselectedObjsChecked so that only selected objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return [objrefs[0].Curve()], [objrefs[1].Curve()]\r\n\r\n        # An option was selected or a number was entered.\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fLocAlongCrvTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getInput_2Sets():\r\n    \"\"\"\r\n    Get 2 sets of curves with optional input.\r\n    \"\"\"\r\n\r\n    rgCrvs_lists = [[],[]]\r\n\r\n    go = ri.Custom.GetObject()\r\n    sCommandPromptAdd = 'A', 'B'\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.GroupSelect = True\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    bPreselectedObjsChecked = False\r\n    \r\n    idxs_Opts = {}\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    # Get input for each curve set using a loop.\r\n    for iCrvSet in 0,1:\r\n\r\n        go.SetCommandPrompt(\"Select curve set {}\".format(sCommandPromptAdd[iCrvSet]))\r\n\r\n        while True:\r\n            if not Opts.values['bInputSets']:\r\n                go.Dispose()\r\n                sc.doc.Objects.UnselectAll()\r\n                sc.doc.Views.Redraw()\r\n                return getInput_2Crvs()\r\n\r\n\r\n            go.ClearCommandOptions()\r\n            idxs_Opts.clear()\r\n            idxs_Opts.update(_addCommonOptions(go))\r\n\r\n            res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n            \r\n            # Use bPreselectedObjsChecked so that only selected objects before the\r\n            # first call to go.GetMultiple is considered.\r\n            if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n                bPreselectedObjsChecked = True\r\n                go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n                continue\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                go.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Object:\r\n                break\r\n\r\n            # An option was selected or a number was entered.\r\n\r\n            if res == ri.GetResult.Number:\r\n                key = 'fLocAlongCrvTol'\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n                Opts.setValue(key)\r\n                continue\r\n\r\n            for key in idxs_Opts:\r\n                if go.Option().Index == idxs_Opts[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n        if go.ObjectCount == 0: return\r\n        \r\n        rgCrvs_lists[iCrvSet] = [o.Geometry() for o in go.Objects()]\r\n        \r\n        if iCrvSet == 0:\r\n            gCrvsA = [o.ObjectId for o in go.Objects()]\r\n        \r\n        # Custom geometry filter to only allow selection of curves not in first set.\r\n        def curvesNotIn1stSetGeomFilter(rdObj, geom, compIdx):\r\n            # TODO: Fix this.\r\n            \r\n            # Wires.\r\n            if (\r\n                compIdx.Index == -1 and\r\n                not isinstance(geom, rg.BrepEdge) and\r\n                rdObj.Id not in gCrvsA\r\n            ):\r\n                return True\r\n            if isinstance(geom, rg.BrepEdge):\r\n                return True\r\n            return not rdObj.Id in gCrvsA\r\n        go.SetCustomGeometryFilter(curvesNotIn1stSetGeomFilter)    \r\n    \r\n    go.Dispose()\r\n    \r\n    # Remove first set of curves from second.\r\n    rgCrvs_lists[1] = rgCrvs_lists[1][len(rgCrvs_lists[0]):]\r\n    \r\n    if len(rgCrvs_lists[1]) == 0: return # Second set of objects were not selected.\r\n    \r\n    return tuple(\r\n        ([rgCrvs_lists[0]]) +\r\n        ([rgCrvs_lists[1]]) +\r\n        [Opts.values[key] for key in Opts.keys])\r\n\r\n\r\ndef isMaxClosestDistBtwn2CrvsWithinTol(rgCrv_A, rgCrv_B, tolerance):\r\n    \"\"\"\r\n    Alternative to Curve.GetDistancesBetweenCurves for better results when\r\n    curves contain loops, etc.\r\n\r\n    Returns:\r\n        False (If not within tolerance parameter)\r\n        float(Largest deviation found)\r\n    \"\"\"\r\n\r\n\r\n    def isOutsideOfTolerance(rgC_Cat, rgC_Dog, ts_Cat):\r\n\r\n        for iT_Cat in xrange(len(ts_Cat)):\r\n\r\n            t_Cat = ts_Cat[iT_Cat]\r\n\r\n            pt_Cat = rgC_Cat.PointAt(t_Cat)\r\n\r\n            bSuccess, t_Dog = rgC_Dog.ClosestPoint(pt_Cat)\r\n\r\n            if not bSuccess:\r\n                raise ValueError(\"Closest point could not be calculated.\")\r\n\r\n            pt_Dog = rgC_Dog.PointAt(t_Dog)\r\n\r\n            dist = pt_Cat.DistanceTo(pt_Dog)\r\n\r\n            if dist > tolerance:\r\n                return True\r\n\r\n            fDevs.append(dist)\r\n\r\n        return False\r\n\r\n    fDivLength = 10.0*sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    fDevs = []\r\n\r\n    # First, check span ends.\r\n    ts_A = []\r\n    for iSpan in range(rgCrv_A.SpanCount):\r\n        spanDomain = rgCrv_A.SpanDomain(iSpan)\r\n        ts_A.append(spanDomain.T0)\r\n    if spanDomain.T1 not in ts_A:\r\n        ts_A.append(spanDomain.T1)\r\n\r\n    if isOutsideOfTolerance(rgCrv_A, rgCrv_B, ts_A):\r\n        return False\r\n\r\n    ts_B = []\r\n    for iSpan in range(rgCrv_B.SpanCount):\r\n        spanDomain = rgCrv_B.SpanDomain(iSpan)\r\n        ts_B.append(spanDomain.T0)\r\n    if spanDomain.T1 not in ts_B:\r\n        ts_B.append(spanDomain.T1)\r\n\r\n    if isOutsideOfTolerance(rgCrv_B, rgCrv_A, ts_B):\r\n        return False\r\n\r\n\r\n    for M in 1000.0, 10.0:\r\n        fDivLength = M * sc.doc.ModelAbsoluteTolerance\r\n\r\n        ts_A = []\r\n\r\n        rc = rgCrv_A.DivideByLength(\r\n            segmentLength=fDivLength,\r\n            includeEnds=True)\r\n        if rc:\r\n            ts_A = rc\r\n            if isOutsideOfTolerance(rgCrv_A, rgCrv_B, ts_A):\r\n                return False\r\n\r\n        ts_B = []\r\n\r\n        rc = rgCrv_B.DivideByLength(\r\n            segmentLength=fDivLength,\r\n            includeEnds=True)\r\n        if rc:\r\n            ts_B = rc\r\n            if isOutsideOfTolerance(rgCrv_B, rgCrv_A, ts_B):\r\n                return False\r\n\r\n    return max(fDevs)\r\n\r\n\r\ndef spb_GDBC_1Way(curve_TestPts, curve_ClosestPt, fLocAlongCrvTol, bOnlyPerp=True, bDebug=False):\r\n    \"\"\"\r\n    Alternative to Curve.GetDistancesBetweenCurves for more accuracy.\r\n\r\n    Parameters:\r\n        curve_TestPts: rg.Curve that will be divided to obtain the testPoints for ClosestPoint.\r\n        curve_ClosestPt: rg.Curve that is the object of the ClosestPoint call.\r\n        segmentLength: float : Division length of curve_TestPts to obtain some testPoints for ClosestPoint.\r\n        bDebug: bool\r\n\r\n    Returns:\r\n        The same as Curve.GetDistancesBetweenCurves:\r\n            bool: success\r\n            float: maxDistance\r\n            float: maxDistanceParameterA\r\n            float: maxDistanceParameterB\r\n            float: minDistance\r\n            float: minDistanceParameterA\r\n            float: minDistanceParameterB\r\n    \"\"\"\r\n\r\n    # Segment lengths for the first iteration of distances to check.\r\n    segmentLength = 1000.0 * min((fLocAlongCrvTol, sc.doc.ModelAbsoluteTolerance))\r\n\r\n    if bDebug:\r\n        sEval = \"curve_TestPts.Domain.T0\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"curve_ClosestPt.Domain.T1\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"segmentLength\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    def generate_list_of_curve_parameters_for_ClosestPoint(curve, segmentLength):\r\n        if bDebug: print(\"generate_list_of_curve_parameters_for_ClosestPoint\")\r\n\r\n        ts_Out = []\r\n\r\n        rc = curve.DivideByLength(\r\n            segmentLength=segmentLength,\r\n            includeEnds=True)\r\n        if rc:\r\n            ts_Out.extend(rc)\r\n\r\n        # For open curve, add the ends of the curve.\r\n        if not curve.IsClosed:\r\n            # DivideByLength doesn't add the T1 segment\r\n            # even when includeEnds == True.\r\n            # https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_DivideByLength.htm\r\n            # shows the parameter labeled as 'includeStart'.\r\n            if curve.Domain.T1 not in ts_Out:\r\n                ts_Out.append(curve.Domain.T1)\r\n\r\n        # Add parameters of all knots at full multiplicity.\r\n        nc_Temp = curve.ToNurbsCurve()\r\n        iK = 0\r\n        while iK < nc_Temp.Knots.Count:\r\n            sc.escape_test()\r\n            m = nc_Temp.Knots.KnotMultiplicity(iK)\r\n            if m == nc_Temp.Degree:\r\n                k = nc_Temp.Knots[iK]\r\n                if k not in ts_Out:\r\n                    ts_Out.append(k)\r\n            iK += m\r\n        nc_Temp.Dispose()\r\n\r\n        if len(ts_Out) != len(set(ts_Out)):\r\n            sEval = \"len(ts_Out)\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"len(set(ts_Out))\"; print(sEval, '=', eval(sEval))\r\n            raise ValueError(\"Duplicate parameters?  Check getClosestDistsBtwn2Crvs.\")\r\n\r\n        ts_Out.sort()\r\n\r\n        if bDebug:\r\n            sEval = \"ts_Out[:10]\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"ts_Out[-10:]\"; print(sEval, '=', eval(sEval))\r\n\r\n        return ts_Out\r\n\r\n\r\n    ts_A_FullCrv = generate_list_of_curve_parameters_for_ClosestPoint(curve_TestPts, segmentLength)\r\n\r\n    if bDebug:\r\n        sEval = \"len(ts_A_FullCrv)\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    def calc_parameters_and_distances(ts_A_In, curveA, curveB, bOnlyPerp):\r\n        if bDebug: print(\"calc_parameters_and_distances\")\r\n\r\n        ts_B = []\r\n        dists_per_ts_A_Out = []\r\n\r\n        rads_90degs = Rhino.RhinoMath.ToRadians(90.0)\r\n\r\n        for i_t_A, t_A in enumerate(ts_A_In):\r\n\r\n            pt_A = curveA.PointAt(t_A)\r\n\r\n            bSuccess, t_B = curveB.ClosestPoint(pt_A)\r\n\r\n            if not bSuccess:\r\n                raise ValueError(\"Closest point could not be calculated.\")\r\n\r\n            pt_B = curveB.PointAt(t_B)\r\n\r\n            v_tan_B = curveB.TangentAt(t_B)\r\n            v_dist = pt_A - pt_B\r\n\r\n            if not bOnlyPerp:\r\n                dists_per_ts_A_Out.append(pt_A.DistanceTo(pt_B))\r\n                ts_B.append(t_B)\r\n                continue\r\n\r\n            # bOnlyPerp == True\r\n\r\n            if v_dist.IsTiny():\r\n                dists_per_ts_A_Out.append(pt_A.DistanceTo(pt_B))\r\n                ts_B.append(t_B)\r\n                continue\r\n\r\n            angle_between = rg.Vector3d.VectorAngle(v_tan_B, v_dist)\r\n            angle_from90 = abs(rads_90degs - angle_between)\r\n\r\n            #if bDebug:\r\n            #    sEval = \"pt_A\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"pt_B\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"v_tan_B\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"v_dist\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"Rhino.RhinoMath.ToDegrees(angle_between)\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"Rhino.RhinoMath.ToDegrees(angle_from90)\"; print(sEval, '=', eval(sEval))\r\n            #    sEval = \"v_dist.IsTiny()\"; print(sEval, '=', eval(sEval))\r\n                #if not v_dist.IsTiny():\r\n                #sc.doc.Objects.AddPoint(pt_A)\r\n                #sc.doc.Objects.AddPoint(pt_B)\r\n\r\n            if angle_from90 > sc.doc.ModelAngleToleranceRadians:\r\n                dists_per_ts_A_Out.append(None)\r\n            else:\r\n                dists_per_ts_A_Out.append(pt_A.DistanceTo(pt_B))\r\n\r\n            ts_B.append(t_B)\r\n\r\n        if bDebug:\r\n            sEval = \"len(ts_B)\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"len(dists_per_ts_A_Out)\"; print(sEval, '=', eval(sEval))\r\n\r\n        return ts_B, dists_per_ts_A_Out\r\n\r\n\r\n    ts_B, dists_per_ts_A = calc_parameters_and_distances(\r\n        ts_A_FullCrv,\r\n        curve_TestPts,\r\n        curve_ClosestPt,\r\n        bOnlyPerp=bOnlyPerp)\r\n    if bDebug:\r\n        sEval = \"len(dists_per_ts_A)\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"dists_per_ts_A[:10]\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"dists_per_ts_A[-10:]\"; print(sEval, '=', eval(sEval))\r\n\r\n    if all(d is None for d in dists_per_ts_A):\r\n        return False, [], [], [], [], [], []\r\n\r\n    # Get max distance.\r\n    dist_Max = max(dists_per_ts_A)\r\n    idx_MaxDist = dists_per_ts_A.index(dist_Max)\r\n    t_A_MaxDist = ts_A_FullCrv[idx_MaxDist]\r\n    t_B_MaxDist = ts_B[idx_MaxDist]\r\n\r\n    if bDebug:\r\n        sEval = \"dist_Max\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"idx_MaxDist\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"t_A_MaxDist\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"t_B_MaxDist\"; print(sEval, '=', eval(sEval))\r\n\r\n    # Get min distance.\r\n    dist_Min = min(d for d in dists_per_ts_A if d is not None)\r\n    idx_MinDist = dists_per_ts_A.index(dist_Min)\r\n    t_A_MinDist = ts_A_FullCrv[idx_MinDist]\r\n    t_B_MinDist = ts_B[idx_MinDist]\r\n\r\n    if bDebug:\r\n        sEval = \"dist_Min\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"idx_MinDist\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"t_A_MinDist\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"t_B_MinDist\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    if bDebug:\r\n        print(\"Iterate in smaller group of division points about the current winner\",\r\n              \"to find a more accurate winner.\")\r\n\r\n\r\n    def findMoreAccurateWinner(ts_A_In, curveA, idx_Winner_In, segmentLength_In, fLocAlongCrvTol, bFindMax_NotMin):\r\n        if bDebug: print(\"findMoreAccurateWinner\")\r\n\r\n        ts_A_WIP = ts_A_In[:]\r\n        cA_WIP = curveA.Duplicate()\r\n        idx_Winner_WIP = idx_Winner_In\r\n        segmentLength = segmentLength_In\r\n\r\n        t_A_Winner = ts_A_WIP[idx_Winner_In]\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            segmentLength *= 0.1\r\n\r\n            if segmentLength < (fLocAlongCrvTol - 1e-7):\r\n                break\r\n\r\n            if bDebug: sEval = \"segmentLength\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n            if idx_Winner_WIP > 0:\r\n                t0 = ts_A_WIP[idx_Winner_WIP - 1]\r\n            else:\r\n                t0 = ts_A_WIP[0]\r\n\r\n            if idx_Winner_WIP < (len(ts_A_WIP) - 1):\r\n                t1 = ts_A_WIP[idx_Winner_WIP + 1]\r\n            else:\r\n                t1 = ts_A_WIP[len(ts_A_WIP) - 1]\r\n\r\n            if bDebug:\r\n                sEval = \"t0\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"t1\"; print(sEval, '=', eval(sEval))\r\n\r\n            cA_WIP = cA_WIP.Trim(rg.Interval(t0, t1))\r\n            #sc.doc.Objects.AddCurve(cA_WIP); sc.doc.Views.Redraw(); 1/0\r\n            if bDebug: sEval = \"cA_WIP.GetLength()\"; print(sEval, '=', eval(sEval))\r\n\r\n            ts_A_WIP = generate_list_of_curve_parameters_for_ClosestPoint(cA_WIP, segmentLength)\r\n            if bDebug:\r\n                sEval = \"len(ts_A_WIP)\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"ts_A_WIP[:10]\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"ts_A_WIP[-10:]\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n\r\n\r\n            ts_B_WIP, dists_per_ts_A_WIP = calc_parameters_and_distances(\r\n                ts_A_WIP,\r\n                cA_WIP,\r\n                curve_ClosestPt,\r\n                bOnlyPerp=bOnlyPerp)\r\n\r\n            # Get winning distance.\r\n            if bFindMax_NotMin:\r\n                dist_Winner = max(dists_per_ts_A_WIP)\r\n            else:\r\n                dist_Winner = min(d for d in dists_per_ts_A_WIP if d is not None)\r\n            idx_Winner_WIP = dists_per_ts_A_WIP.index(dist_Winner)\r\n            t_A_Winner = ts_A_WIP[idx_Winner_WIP]\r\n            t_B_Winner = ts_B_WIP[idx_Winner_WIP]\r\n\r\n            if bDebug:\r\n                sEval = \"dist_Winner\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"idx_Winner_WIP\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"t_A_Winner\"; print(sEval, '=', eval(sEval))\r\n                sEval = \"t_B_Winner\"; print(sEval, '=', eval(sEval))\r\n\r\n        return dist_Winner, t_A_Winner, t_B_Winner\r\n\r\n\r\n    rc = findMoreAccurateWinner(\r\n        ts_A_In=ts_A_FullCrv,\r\n        curveA=curve_TestPts,\r\n        idx_Winner_In=idx_MaxDist,\r\n        segmentLength_In=segmentLength,\r\n        fLocAlongCrvTol=fLocAlongCrvTol,\r\n        bFindMax_NotMin=True)\r\n\r\n    dist_Max, t_A_MaxDist, t_B_MaxDist = rc\r\n\r\n\r\n    if dist_Min > 0.0:\r\n        rc = findMoreAccurateWinner(\r\n            ts_A_In=ts_A_FullCrv,\r\n            curveA=curve_TestPts,\r\n            idx_Winner_In=idx_MinDist,\r\n            segmentLength_In=segmentLength,\r\n            fLocAlongCrvTol=fLocAlongCrvTol,\r\n            bFindMax_NotMin=False)\r\n\r\n        dist_Min, t_A_MinDist, t_B_MinDist = rc\r\n\r\n\r\n    if (\r\n        dist_Max is not None and\r\n        dist_Max > 1e-6 and\r\n        ((t_A_MaxDist - curve_TestPts.Domain.T0) <= 1e-6)\r\n        or\r\n        ((t_A_MaxDist - curve_TestPts.Domain.T1) <= 1e-6)\r\n        ):\r\n        v_dist = curve_TestPts.PointAt(t_A_MaxDist) - curve_ClosestPt.PointAt(t_B_MaxDist)\r\n\r\n        if v_dist.IsTiny():\r\n            pass\r\n        else:\r\n            rads_90degs = Rhino.RhinoMath.ToRadians(90.0)\r\n\r\n            v_tan_A = curve_TestPts.TangentAt(t_A_MaxDist)\r\n\r\n            angle_between = rg.Vector3d.VectorAngle(v_tan_A, v_dist)\r\n            angle_from90 = abs(rads_90degs - angle_between)\r\n\r\n            if angle_from90 > Rhino.RhinoMath.ToRadians(22.5):\r\n                dist_Max = None\r\n                t_A_MaxDist = None\r\n                t_B_MaxDist = None\r\n\r\n\r\n    if (\r\n        dist_Min is not None and\r\n        dist_Min > 1e-6 and\r\n        ((t_A_MinDist - curve_TestPts.Domain.T0) <= 1e-6) or\r\n        ((t_A_MinDist - curve_TestPts.Domain.T1) <= 1e-6)\r\n        ):\r\n        v_dist = curve_TestPts.PointAt(t_A_MinDist) - curve_ClosestPt.PointAt(t_B_MinDist)\r\n\r\n        if v_dist.IsTiny():\r\n            pass\r\n        else:\r\n            rads_90degs = Rhino.RhinoMath.ToRadians(90.0)\r\n\r\n            v_tan_A = curve_TestPts.TangentAt(t_A_MinDist)\r\n\r\n            angle_between = rg.Vector3d.VectorAngle(v_tan_A, v_dist)\r\n            angle_from90 = abs(rads_90degs - angle_between)\r\n\r\n            if angle_from90 > Rhino.RhinoMath.ToRadians(22.5):\r\n                dist_Min = None\r\n                t_A_MinDist = None\r\n                t_B_MinDist = None\r\n\r\n\r\n\r\n    return (\r\n        True,\r\n        dist_Max, \r\n        t_A_MaxDist,\r\n        t_B_MaxDist,\r\n        dist_Min,\r\n        t_A_MinDist,\r\n        t_B_MinDist,\r\n        )\r\n\r\n\r\ndef spb_GDBC_BothWays(curveA, curveB, fLocAlongCrvTol=None, bOnlyPerp=True, bDebug=False):\r\n    \"\"\"\r\n    Alternative to Curve.GetDistancesBetweenCurves for more accurate results when\r\n    curves contain loops, etc.\r\n    'BothWays\" refers to checking test points on one curve against the other curve and vice versa.\r\n    Returns:\r\n        The same as Curve.GetDistancesBetweenCurves:\r\n            bool: success\r\n            float: maxDistance\r\n            float: maxDistanceParameterA\r\n            float: maxDistanceParameterB\r\n            float: minDistance\r\n            float: minDistanceParameterA\r\n            float: minDistanceParameterB\r\n    \"\"\"\r\n\r\n\r\n    if fLocAlongCrvTol is None:\r\n        fLocAlongCrvTol = 100.0*sc.doc.ModelAbsoluteTolerance\r\n    if bDebug: sEval = \"fLocAlongCrvTol\"; print(sEval, '=', eval(sEval))\r\n\r\n    Rhino.RhinoApp.Wait()\r\n    rc = spb_GDBC_1Way(\r\n        curve_TestPts=curveA,\r\n        curve_ClosestPt=curveB,\r\n        fLocAlongCrvTol=fLocAlongCrvTol,\r\n        bOnlyPerp=bOnlyPerp,\r\n        bDebug=bDebug)\r\n    (\r\n        bSuccess_onB,\r\n        dist_Max_ClosestPt_on_B,\r\n        tA_MaxDist_ClosestPt_on_B,\r\n        tB_MaxDist_ClosestPt_on_B,\r\n        dist_Min_ClosestPt_on_B,\r\n        tA_MinDist_ClosestPt_on_B,\r\n        tB_MinDist_ClosestPt_on_B,\r\n       ) = rc\r\n    if bDebug: sEval = \"rc\"; print(sEval, '=', eval(sEval))\r\n\r\n    Rhino.RhinoApp.Wait()\r\n\r\n    # Notice that curveA and curveB are reversed.\r\n    rc = spb_GDBC_1Way(\r\n        curve_TestPts=curveB,\r\n        curve_ClosestPt=curveA,\r\n        fLocAlongCrvTol=fLocAlongCrvTol,\r\n        bOnlyPerp=bOnlyPerp,\r\n        bDebug=bDebug)\r\n    (\r\n        bSuccess_onA,\r\n        dist_Max_ClosestPt_on_A,\r\n        tB_MaxDist_ClosestPt_on_A,\r\n        tA_MaxDist_ClosestPt_on_A,\r\n        dist_Min_ClosestPt_on_A,\r\n        tB_MinDist_ClosestPt_on_A,\r\n        tA_MinDist_ClosestPt_on_A,\r\n       ) = rc\r\n    if bDebug: sEval = \"rc\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    if not bSuccess_onA and not bSuccess_onB:\r\n        return\r\n\r\n    if not bSuccess_onA and bSuccess_onB:\r\n        dist_Max = dist_Max_ClosestPt_on_B\r\n        tA_Max_Out = tA_MaxDist_ClosestPt_on_B\r\n        tB_Max_Out = tB_MaxDist_ClosestPt_on_B\r\n        dist_Min = dist_Min_ClosestPt_on_B\r\n        tA_Min_Out = tA_MinDist_ClosestPt_on_B\r\n        tB_Min_Out = tB_MinDist_ClosestPt_on_B\r\n        #sc.doc.Objects.AddCurve(curveA)\r\n        #sc.doc.Objects.AddCurve(curveB)\r\n        #sc.doc.Views.Redraw()\r\n        #raise Exception(\"not bSuccess_onA and bSuccess_onB\")\r\n\r\n    elif bSuccess_onA and not bSuccess_onB:\r\n        dist_Max = dist_Max_ClosestPt_on_A\r\n        tA_Max_Out = tA_MaxDist_ClosestPt_on_A\r\n        tB_Max_Out = tB_MaxDist_ClosestPt_on_A\r\n        dist_Min = dist_Min_ClosestPt_on_A\r\n        tA_Min_Out = tA_MinDist_ClosestPt_on_A\r\n        tB_Min_Out = tB_MinDist_ClosestPt_on_A\r\n        #sc.doc.Objects.AddCurve(curveA)\r\n        #sc.doc.Objects.AddCurve(curveB)\r\n        #sc.doc.Views.Redraw()\r\n        #raise Exception(\"bSuccess_onA and not bSuccess_onB\")\r\n\r\n    else:\r\n        if dist_Max_ClosestPt_on_B > dist_Max_ClosestPt_on_A:\r\n            dist_Max = dist_Max_ClosestPt_on_B\r\n            tA_Max_Out = tA_MaxDist_ClosestPt_on_B\r\n            tB_Max_Out = tB_MaxDist_ClosestPt_on_B\r\n            #ptA_Max = curveA.PointAt(tA_MaxDist_onB_from_pt_on_A)\r\n            #ptB_Max = curveB.PointAt(tB_MaxDist_onB_from_pt_on_A)\r\n        else:\r\n            dist_Max = dist_Max_ClosestPt_on_A\r\n            tA_Max_Out = tA_MaxDist_ClosestPt_on_A\r\n            tB_Max_Out = tB_MaxDist_ClosestPt_on_A\r\n            #ptA_Max = curveA.PointAt(tA_MaxDist_onA_from_pt_on_B)\r\n            #ptB_Max = curveB.PointAt(tB_MaxDist_onA_from_pt_on_B)\r\n\r\n        if dist_Min_ClosestPt_on_B < dist_Min_ClosestPt_on_A:\r\n            dist_Min = dist_Min_ClosestPt_on_B\r\n            tA_Min_Out = tA_MinDist_ClosestPt_on_B\r\n            tB_Min_Out = tB_MinDist_ClosestPt_on_B\r\n            #ptA_Min = curveA.PointAt(tA_MinDist_onB_from_pt_on_A)\r\n            #ptB_Min = curveB.PointAt(tB_MinDist_onB_from_pt_on_A)\r\n        else:\r\n            dist_Min = dist_Min_ClosestPt_on_A\r\n            tA_Min_Out = tA_MinDist_ClosestPt_on_A\r\n            tB_Min_Out = tB_MinDist_ClosestPt_on_A\r\n            #ptA_Min = curveA.PointAt(tA_MinDist_onA_from_pt_on_B)\r\n            #ptB_Min = curveB.PointAt(tB_MinDist_onA_from_pt_on_B)\r\n\r\n\r\n    # Check for intersection to replace any minimum distance values.\r\n    if dist_Min > 1e-6:\r\n        intersections = rg.Intersect.Intersection.CurveCurve(\r\n            curveA,\r\n            curveB,\r\n            tolerance=0.1*sc.doc.ModelAbsoluteTolerance,\r\n            overlapTolerance=0.0)\r\n        if intersections:\r\n            dist_Min = 0.0\r\n            tA_Min_Out = intersections[0].ParameterA\r\n            tB_Min_Out = intersections[0].ParameterB\r\n            #ptA_Min = intersections[0].PointA\r\n            #ptB_Min = intersections[0].PointB\r\n\r\n\r\n    return (\r\n        dist_Max,\r\n        tA_Max_Out,\r\n        tB_Max_Out,\r\n        dist_Min,\r\n        tA_Min_Out,\r\n        tB_Min_Out\r\n        )\r\n\r\n\r\ndef getDevsBtwn2Sets(rgCrvs_SetA, rgCrvs_SetB, **kwargs):\r\n    \"\"\"\r\n    Returns:\r\n        fDists_Max,\r\n        ptsA_Max,\r\n        ptsB_Max,\r\n        fDists_Min,\r\n        ptsA_Min,\r\n        ptsB_Min\r\n        Unlike Curve.GetDistancesBetweenCurves, doesn't return a boolean value for success.\r\n        In the case of fail, empty lists are the values of each variable.\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bExplodeCrvs = getOpt('bExplodeCrvs')\r\n    fLocAlongCrvTol = getOpt('fLocAlongCrvTol')\r\n    bOnlyPerp = getOpt('bOnlyPerp')\r\n    fDist_max_to_regard = getOpt('fDist_max_to_regard')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    try: rgCrvs_SetA = list(rgCrvs_SetA)\r\n    except: rgCrvs_SetA = [rgCrvs_SetA]\r\n\r\n    try: rgCrvs_SetB = list(rgCrvs_SetB)\r\n    except: rgCrvs_SetB = [rgCrvs_SetB]\r\n\r\n    fDists_Max = []\r\n    ptsA_Max = []\r\n    ptsB_Max = []\r\n\r\n    fDists_Min = []\r\n    ptsA_Min = []\r\n    ptsB_Min = []\r\n\r\n\r\n    # Explode parent curves into segments.\r\n\r\n\r\n    if not bExplodeCrvs:\r\n        rgCs_A = rgCrvs_SetA\r\n        rgCs_B = rgCrvs_SetB\r\n    else:\r\n        rgCs_A = []\r\n        for c in rgCrvs_SetA:\r\n            rgCs = c.DuplicateSegments()\r\n            if rgCs:\r\n                rgCs_A.extend(rgCs)\r\n            else:\r\n                 # DuplicateSegments returns an empty array when\r\n                 # curve is not composed of multiple segments.\r\n                rgCs_A.append(c)\r\n\r\n        rgCs_B = []\r\n        for c in rgCrvs_SetB:\r\n            rgCs = c.DuplicateSegments()\r\n            if rgCs:\r\n                rgCs_B.extend(rgCs)\r\n                 # DuplicateSegments returns an empty array when\r\n                 # curve is not composed of multiple segments.\r\n            else:\r\n                rgCs_B.append(c)\r\n\r\n\r\n    # Due to a bug in V5 (SR12) bug\r\n    # (fixed in V6 per https://mcneel.myjetbrains.com/youtrack/issue/RH-41877),\r\n    # bad parameter values are returned from GetDistancesBetweenCurves for ArcCurves,\r\n    # so convert any found to a NurbsCurve.\r\n    if Rhino.RhinoApp.ExeVersion == 5:\r\n        for i, cA in enumerate(rgCs_A):\r\n            if isinstance(cA, rg.ArcCurve):\r\n                rgCs_A[i] = cA.ToNurbsCurve()\r\n        for i, cB in enumerate(rgCs_B):\r\n            if isinstance(cB, rg.ArcCurve):\r\n                rgCs_B[i] = cB.ToNurbsCurve()\r\n\r\n\r\n    for i_cA, cA in enumerate(rgCs_A):\r\n        Rhino.RhinoApp.Wait()\r\n        Rhino.RhinoApp.SetCommandPrompt(\r\n            \"Working ... Curve A {} of {} on each of {} Curve Bs\".format(\r\n                i_cA, len(rgCs_A), len(rgCs_B)))\r\n\r\n        for i_cB, cB in enumerate(rgCs_B):\r\n            sc.escape_test()\r\n\r\n            rc = spb_GDBC_BothWays(\r\n                cA,\r\n                cB,\r\n                fLocAlongCrvTol=fLocAlongCrvTol,\r\n                bOnlyPerp=bOnlyPerp,\r\n                bDebug=bDebug)\r\n\r\n            if rc is None:\r\n                if bDebug: print(\"No valid deviation found.\")\r\n                continue\r\n\r\n            (\r\n                fDist_Max,\r\n                tA_Max,\r\n                tB_Max,\r\n                fDist_Min,\r\n                tA_Min,\r\n                tB_Min\r\n               ) = rc\r\n\r\n            if fDist_Min is not None:\r\n                if (\r\n                    fDist_max_to_regard and\r\n                    fDist_Min > fDist_max_to_regard\r\n                    ):\r\n                        if bDebug: print(\"Skipped distance {}.\".format(fDist_Min))\r\n                else:\r\n                    ptA_Min = None if tA_Min is None else cA.PointAt(tA_Min)\r\n                    ptB_Min = None if tB_Min is None else cB.PointAt(tB_Min)\r\n    \r\n                    fDists_Min.append(fDist_Min)\r\n                    ptsA_Min.append(ptA_Min)\r\n                    ptsB_Min.append(ptB_Min)\r\n\r\n            if fDist_Max is not None:\r\n                if (\r\n                    fDist_max_to_regard and\r\n                    fDist_Max > fDist_max_to_regard\r\n                    ):\r\n                        if bDebug: print(\"Skipped distance {}.\".format(fDist_Max))\r\n                else:\r\n                    ptA_Max = None if tA_Max is None else cA.PointAt(tA_Max)\r\n                    ptB_Max = None if tB_Max is None else cB.PointAt(tB_Max)\r\n    \r\n                    fDists_Max.append(fDist_Max)\r\n                    ptsA_Max.append(ptA_Max)\r\n                    ptsB_Max.append(ptB_Max)\r\n\r\n\r\n    return (\r\n        fDists_Max,\r\n        ptsA_Max,\r\n        ptsB_Max,\r\n        fDists_Min,\r\n        ptsA_Min,\r\n        ptsB_Min\r\n        )\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.lines = []\r\n        self.line_colors = []\r\n        self.dots = []\r\n        self.dot_colors = []\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        for line in self.lines:\r\n            bbox = line.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n        for dot in self.dots:\r\n            bbox = dot.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        for i, line in enumerate(self.lines):\r\n            drawEventArgs.Display.DrawLine(\r\n                line=line,\r\n                color=self.line_colors[i],\r\n                thickness=self.crv_thk)\r\n\r\n        for i, dot in enumerate(self.dots):\r\n            drawEventArgs.Display.DrawDot(\r\n                worldPosition=dot.Point,\r\n                text=dot.Text,\r\n                dotColor=self.dot_colors[i],\r\n                textColor=Color.White if self.dot_colors[i] == Color.Red else Color.Black)\r\n\r\n            # TODO: Why doesn't this work?\r\n            #drawEventArgs.Display.DrawDot(\r\n            #    dot=dot,\r\n            #    fillColor=self.dot_colors[i],\r\n            #    dotColor=self.dot_colors[i],\r\n            #    textColor=Color.White,\r\n            #    borderColor=self.dot_colors[i])\r\n\r\n\r\ndef _addTextDot(text, pt, iDotFontHt, attrib):\r\n    rgDot = rg.TextDot(text, pt)\r\n    rgDot.FontHeight = iDotFontHt\r\n    sc.doc.Objects.AddTextDot(rgDot, attrib)\r\n\r\n\r\ndef _addPreview(conduit, fDists_Max, ptsA_Max, ptsB_Max, fDists_Min, ptsA_Min, ptsB_Min, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAddLine = getOpt('bAddLine')\r\n    bAddDot = getOpt('bAddDot')\r\n    iDotDecPlaces = getOpt('iDotDecPlaces')\r\n    iDotFontHt = getOpt('iDotFontHt')\r\n\r\n\r\n    if not (bAddLine or bAddDot):\r\n        return\r\n\r\n    # Maximum deviation(s).\r\n    for i, fDist_Max in enumerate(fDists_Max):\r\n        ptA_Max = ptsA_Max[i]\r\n        ptB_Max = ptsB_Max[i]\r\n        if None in (fDist_Max, ptA_Max, ptB_Max):\r\n            raise Exception(\"None in {}, {} ,{}\".format(fDist_Max, ptA_Max, ptB_Max))\r\n        if bAddLine:\r\n            conduit.lines.append(rg.Line(ptA_Max, ptB_Max))\r\n            conduit.line_colors.append(Color.Red)\r\n        if bAddDot:\r\n            conduit.dots.append(\r\n                rg.TextDot(\r\n                    text=\"{0:.{1}f}\".format(fDist_Max, iDotDecPlaces),\r\n                    location=(ptA_Max + ptB_Max) / 2.0))\r\n            conduit.dot_colors.append(Color.Red)\r\n\r\n    # Minimum deviation(s).\r\n    for i, fDist_Min in enumerate(fDists_Min):\r\n        ptA_Min = ptsA_Min[i]\r\n        ptB_Min = ptsB_Min[i]\r\n        if None in (fDist_Min, ptA_Min, ptB_Min):\r\n            raise Exception(\"None in {}, {} ,{}\".format(fDist_Max, ptA_Min, ptB_Min))\r\n        if bAddLine and fDist_Min:\r\n            conduit.lines.append(rg.Line(ptA_Min, ptB_Min))\r\n            conduit.line_colors.append(Color.Lime)\r\n        if bAddDot:\r\n            conduit.dots.append(\r\n                rg.TextDot(\r\n                    text=\"{0:.{1}f}\".format(fDist_Min, iDotDecPlaces),\r\n                    location=(ptA_Min + ptB_Min) / 2.0))\r\n            conduit.dot_colors.append(Color.Lime)\r\n\r\n\r\ndef _addAnnotation(fDists_Max, ptsA_Max, ptsB_Max, fDists_Min, ptsA_Min, ptsB_Min, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAddLine = getOpt('bAddLine')\r\n    bAddDot = getOpt('bAddDot')\r\n    iDotDecPlaces = getOpt('iDotDecPlaces')\r\n    iDotFontHt = getOpt('iDotFontHt')\r\n\r\n\r\n    if not (bAddLine or bAddDot):\r\n        return\r\n\r\n    attr_Red = rd.ObjectAttributes()\r\n    attr_Red.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n    #attr.ObjectDecoration = rd.ObjectDecoration.BothArrowhead\r\n    attr_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attr_Red.ObjectColor = attr_Red.ObjectColor.Red\r\n\r\n    attr_Green = attr_Red.Duplicate()\r\n    attr_Green.ObjectColor = attr_Green.ObjectColor.Lime\r\n\r\n    # Maximum deviation(s).\r\n    if fDists_Max:\r\n        for i, fDist_Max in enumerate(fDists_Max):\r\n            ptA_Max = ptsA_Max[i]\r\n            ptB_Max = ptsB_Max[i]\r\n            if None in (fDist_Max, ptA_Max, ptB_Max):\r\n                raise Exception(\"None in {}, {} ,{}\".format(fDist_Max, ptA_Max, ptB_Max))\r\n            #if (fDist_max is not None\r\n            #        and ptA_max is not None and ptB_max is not None\r\n            #):\r\n            if bAddLine:\r\n                sc.doc.Objects.AddLine(ptA_Max, ptB_Max, attr_Red)\r\n            if bAddDot:\r\n                _addTextDot(\r\n                    \"{0:.{1}f}\".format(fDist_Max, iDotDecPlaces),\r\n                    (ptA_Max + ptB_Max) / 2.0,\r\n                    iDotFontHt,\r\n                    attr_Red)\r\n\r\n    # Minimum deviation(s).\r\n    if fDists_Min:\r\n        for i, fDist_Min in enumerate(fDists_Min):\r\n            ptA_Min = ptsA_Min[i]\r\n            ptB_Min = ptsB_Min[i]\r\n            if None in (fDist_Min, ptA_Min, ptB_Min):\r\n                raise Exception(\"None in {}, {} ,{}\".format(fDist_Min, ptA_Min, ptB_Min))\r\n            #if (fDist_min is not None\r\n            #        and ptA_min is not None and ptB_min is not None):\r\n            if bAddLine and fDist_Min:\r\n                sc.doc.Objects.AddLine(ptA_Min, ptB_Min, attr_Green)\r\n            if bAddDot:\r\n                _addTextDot(\r\n                    \"{0:.{1}f}\".format(fDist_Min, iDotDecPlaces),\r\n                    (ptA_Min + ptB_Min) / 2.0,\r\n                    iDotFontHt,\r\n                    attr_Green)\r\n\r\n\r\ndef main():\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__) # StickyKey\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    rgCrvsA = []\r\n    rgCrvsB = []\r\n\r\n    rc = getPreselectedCurves()\r\n    if rc:\r\n        rgCrvsA = [sc.doc.Objects.FindId(rc[0]).Geometry]\r\n        rgCrvsB = [sc.doc.Objects.FindId(rc[1]).Geometry]\r\n    else:\r\n        bInputSets = Opts.values['bInputSets']\r\n        if bInputSets:\r\n            rc = getInput_2Sets()\r\n        else:\r\n            rc = getInput_2Crvs()\r\n        if rc is None: return\r\n        #print(rc)\r\n        rgCrvsA = rc[0]\r\n        rgCrvsB = rc[1]\r\n\r\n    bInputSets = Opts.values['bInputSets']\r\n    bExplodeCrvs = Opts.values['bExplodeCrvs']\r\n    fLocAlongCrvTol = Opts.values['fLocAlongCrvTol']\r\n    bOnlyPerp = Opts.values['bOnlyPerp']\r\n    fDist_max_to_regard = Opts.values['fDist_max_to_regard']\r\n    bLimitMode = Opts.values['bLimitMode']\r\n    fUprLimit = Opts.values['fUprLimit']\r\n    fLwrLimit = Opts.values['fLwrLimit']\r\n    bMarkMax = Opts.values['bMarkMax']\r\n    bMarkMin = Opts.values['bMarkMin']\r\n    bVerifyAddMarks = Opts.values['bVerifyAddMarks']\r\n    bAddLine = Opts.values['bAddLine']\r\n    bAddDot = Opts.values['bAddDot']\r\n    iDotDecPlaces = Opts.values['iDotDecPlaces']\r\n    iDotFontHt = Opts.values['iDotFontHt']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if bDebug:\r\n        sEval = \"rgCrvsA\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"len(rgCrvsA)\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"rgCrvsB\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"len(rgCrvsB)\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    rc = getDevsBtwn2Sets(\r\n        rgCrvsA,\r\n        rgCrvsB,\r\n        bExplodeCrvs=bExplodeCrvs,\r\n        fLocAlongCrvTol=fLocAlongCrvTol,\r\n        bOnlyPerp=bOnlyPerp,\r\n        fDist_max_to_regard=fDist_max_to_regard,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    (\r\n        fDists_Max,\r\n        ptsA_Max,\r\n        ptsB_Max,\r\n        fDists_Min,\r\n        ptsA_Min,\r\n        ptsB_Min\r\n        ) = rc\r\n\r\n\r\n\r\n    if (\r\n        all([d is None for d in fDists_Max])\r\n        and\r\n        all([d is None for d in fDists_Min])\r\n        ):\r\n        print(\"No results.\")\r\n        return\r\n\r\n\r\n    fDist_Max_All = max(fDists_Max) if fDists_Max else None\r\n    fDist_Min_All = min(fDists_Min) if fDists_Min else None\r\n\r\n    if bDebug:\r\n        sEval = \"fDist_Max_All\"; print(sEval, '=', eval(sEval))\r\n        sEval = \"fDist_Min_All\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    if bEcho:\r\n        s = \"\"\r\n        if fDist_Min_All is not None:\r\n            s += \"Minimum deviation = {0:.{1}g}\".format(\r\n                    fDist_Min_All, 6)\r\n        if bLimitMode and fDist_Min_All >= fLwrLimit:\r\n            s += \"  None are below {}.\".format(fLwrLimit)\r\n        print(s)\r\n\r\n        s = \"\"\r\n        if fDist_Max_All is not None:\r\n            s += \"Maximum deviation = {0:.{1}g}\".format(\r\n                    fDist_Max_All, 6)\r\n        if bLimitMode and fDist_Max_All <= fUprLimit:\r\n            s += \"  None are above {}.\".format(fUprLimit)\r\n\r\n        print(s)\r\n\r\n\r\n\r\n    if not bLimitMode and bVerifyAddMarks and (bMarkMax or bMarkMin):\r\n        if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n            conduit = None\r\n            #    conduit = DrawConduit()\r\n            #    sc.sticky[sk_conduit] = conduit\r\n            #if not ((sk_conduit in sc.sticky) and sc.sticky[sk_conduit]):\r\n            #    conduit = DrawConduit()\r\n            #    sc.sticky[sk_conduit] = conduit\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n        if bMarkMax and bMarkMin:\r\n            _addPreview(\r\n                conduit,\r\n                fDists_Max, ptsA_Max, ptsB_Max,\r\n                fDists_Min, ptsA_Min, ptsB_Min,\r\n                bAddLine=bAddLine,\r\n                bAddDot=bAddDot,\r\n                iDotDecPlaces=iDotDecPlaces,\r\n                iDotFontHt=iDotFontHt,\r\n                )\r\n        elif bMarkMax:\r\n            _addPreview(\r\n                conduit,\r\n                fDists_Max, ptsA_Max, ptsB_Max,\r\n                [], [], [],\r\n                bAddLine=bAddLine,\r\n                bAddDot=bAddDot,\r\n                iDotDecPlaces=iDotDecPlaces,\r\n                iDotFontHt=iDotFontHt,\r\n                )\r\n        elif bMarkMin:\r\n            _addPreview(\r\n                conduit,\r\n                [], [], [],\r\n                fDists_Min, ptsA_Min, ptsB_Min,\r\n                bAddLine=bAddLine,\r\n                bAddDot=bAddDot,\r\n                iDotDecPlaces=iDotDecPlaces,\r\n                iDotFontHt=iDotFontHt,\r\n                )\r\n        else:\r\n            raise Exception(\"What happened?\")\r\n\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n        go = ri.Custom.GetOption()\r\n        go.SetCommandPrompt(\"Press Enter to skip marks or\")\r\n        idx_Opt = go.AddOption(\"KeepMarks\")\r\n\r\n        res = go.Get()\r\n\r\n        conduit.Enabled = False\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if not go.Option():\r\n            return\r\n\r\n\r\n\r\n    if bLimitMode:\r\n        if (fDist_Min_All >= fLwrLimit) and (fDist_Max_All <= fUprLimit):\r\n            return\r\n\r\n\r\n        def filter_results_per_limits(\r\n            fDists_Max_In,\r\n            ptsA_Max_In,\r\n            ptsB_Max_In,\r\n            fDists_Min_In,\r\n            ptsA_Min_In,\r\n            ptsB_Min_In\r\n            ):\r\n\r\n            fDists_Max_Out = []\r\n            ptsA_Max_Out = []\r\n            ptsB_Max_Out = []\r\n            fDists_Min_Out = []\r\n            ptsA_Min_Out = []\r\n            ptsB_Min_Out = []\r\n\r\n            for i, fDist_Min in enumerate(fDists_Min_In):\r\n                fDist_Max = fDists_Max_In[i]\r\n                ptA_Max = ptsA_Max_In[i]\r\n                ptB_Max = ptsB_Max_In[i]\r\n                ptA_Min = ptsA_Min_In[i]\r\n                ptB_Min = ptsB_Min_In[i]\r\n\r\n                if fUprLimit and (fDist_Max > fUprLimit):\r\n                    fDists_Max_Out.append(fDist_Max)\r\n                    ptsA_Max_Out.append(ptA_Max)\r\n                    ptsB_Max_Out.append(ptB_Max)\r\n\r\n                if fLwrLimit and (fDist_Min < fLwrLimit):\r\n                    fDists_Min_Out.append(fDist_Min)\r\n                    ptsA_Min_Out.append(ptA_Min)\r\n                    ptsB_Min_Out.append(ptB_Min)\r\n\r\n            return (\r\n                fDists_Max_Out,\r\n                ptsA_Max_Out,\r\n                ptsB_Max_Out,\r\n                fDists_Min_Out,\r\n                ptsA_Min_Out,\r\n                ptsB_Min_Out\r\n                )\r\n\r\n\r\n        rc = filter_results_per_limits(*rc)\r\n\r\n        (\r\n            fDists_Max,\r\n            ptsA_Max,\r\n            ptsB_Max,\r\n            fDists_Min,\r\n            ptsA_Min,\r\n            ptsB_Min\r\n            ) = rc\r\n\r\n\r\n        if not fDists_Max and not fDists_Min:\r\n            if bEcho:\r\n                print(\"None of the curves deviate outside of limits.\")\r\n            return\r\n\r\n\r\n\r\n    if bLimitMode or (bMarkMax and bMarkMin):\r\n        _addAnnotation(\r\n            fDists_Max, ptsA_Max, ptsB_Max,\r\n            fDists_Min, ptsA_Min, ptsB_Min,\r\n            bAddLine=bAddLine,\r\n            bAddDot=bAddDot,\r\n            iDotDecPlaces=iDotDecPlaces,\r\n            iDotFontHt=iDotFontHt,\r\n            )\r\n    elif bMarkMax:\r\n        _addAnnotation(\r\n            fDists_Max, ptsA_Max, ptsB_Max,\r\n            [], [], [],\r\n            bAddLine=bAddLine,\r\n            bAddDot=bAddDot,\r\n            iDotDecPlaces=iDotDecPlaces,\r\n            iDotFontHt=iDotFontHt,\r\n            )\r\n    elif bMarkMin:\r\n        _addAnnotation(\r\n            [], [], [],\r\n            fDists_Min, ptsA_Min, ptsB_Min,\r\n            bAddLine=bAddLine,\r\n            bAddDot=bAddDot,\r\n            iDotDecPlaces=iDotDecPlaces,\r\n            iDotFontHt=iDotFontHt,\r\n            )\r\n    else:\r\n        return\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}