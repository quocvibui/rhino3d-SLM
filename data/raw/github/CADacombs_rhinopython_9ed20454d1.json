{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_Join.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_Join.py",
  "instruction": "This script is an alternative to _Join for curves.\r\n\r\nUnlike _Join,\r\n1. It can optionally join curves that share a layer and/or color.\r\n2. It optionally does not simplify/convert curves.\r\n3. It has a...",
  "code": "\"\"\"\r\nThis script is an alternative to _Join for curves.\r\n\r\nUnlike _Join,\r\n1. It can optionally join curves that share a layer and/or color.\r\n2. It optionally does not simplify/convert curves.\r\n3. It has a tolerance setting.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n180207: Created, starting with joinBreps.\r\n...\r\n180316: Added support for brep edge curves.\r\n...\r\n190513: Fixed bug where breps of selected edges were being joined.\r\n250109-10,15: Reenabled the RhinoCommon method.\r\n        Disabled support for BrepEdges until script is working properly for just wires.\r\n        Refactored.\r\n250204: Bug fix.\r\n250326: Reimplemented the _Join routine for Rhino < 8.12.\r\n251012: Due to the reference to the model units, a global variable was replaced with another variable that is calculated at run time.\r\n\r\nTODO:\r\n    Reenable support for BrepEdges.\r\n    Possibly reenable RC routine for < 8.12.\r\n        The indices of the joined input are not returned by V5's JoinCurves method and overloads.\r\n\r\n_Join (at least in V8.14) appears to use 1.8 * ModelAbsoluteTolerance as the\r\nendpoint distance (gap or overlap) threshold to perform the join.\r\n\r\nsimpleJoin in Curve.JoinCurves will preserve curve types. That also means contiguous\r\nLineCurves will connect as LineCurve segments in PolyCurves instead of converting to PolylineCurve segment.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fJoinTol'; keys.append(key)\r\n    values[key] = max((0.1 * sc.doc.ModelAbsoluteTolerance, 1e-6)) # Default in _Join is 1.8 * sc.doc.ModelAbsoluteTolerance.\r\n    names[key] = 'Tolerance'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bByLayer'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'JoinByLayer'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bByColor'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'JoinByColor'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUseUiJoinCmd'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Use'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'RhinoCommon', 'JoinCommand')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSimpleJoin'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fJoinTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n            if cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _formatDistance(fDistance, fPrecision=None):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    if fDistance == Rhino.RhinoMath.UnsetValue:\r\n        return \"(Infinite)\"\r\n    if fPrecision is None:\r\n        fPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    if fDistance < 10.0**(-(fPrecision-1)):\r\n        # For example, if fDistance is 1e-5 and fPrecision == 5,\r\n        # the end of this script would display only one digit.\r\n        # Instead, this return displays 2 digits.\r\n        return \"{:.2e}\".format(fDistance)\r\n\r\n    return \"{:.{}f}\".format(fDistance, fPrecision)\r\n\r\n\r\ndef _isCurveJoinable(rdCrv):\r\n    \"\"\"Joinable is valid and open.\"\"\"\r\n    rgC = rdCrv.CurveGeometry\r\n    if not rgC.IsValid: return False\r\n    return not rgC.IsClosed\r\n\r\n\r\ndef _getAllNormalJoinableWires():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Curve\r\n    return [rdC for rdC in sc.doc.Objects.GetObjectList(oes) if _isCurveJoinable(rdC)]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    go.GeometryAttributeFilter = (\r\n        ri.Custom.GeometryAttributeFilter.OpenCurve\r\n        |\r\n        ri.Custom.GeometryAttributeFilter.WireCurve\r\n        )\r\n\r\n    go.SubObjectSelect = False\r\n\r\n    #go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n\r\n    go.AcceptNothing(True)\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n\r\n    #go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    #bSequentialSel = False\r\n    #print(\"Seq1Sel = Sequential single selection\")\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    bPre812 = (\r\n        Rhino.RhinoApp.ExeVersion < 8 or\r\n        (Rhino.RhinoApp.ExeVersion == 8 and Rhino.RhinoApp.ExeServiceRelease < 12)\r\n        )\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opt.clear()\r\n\r\n        addOption('fJoinTol')\r\n        idxs_Opt['Toggle'] = go.AddOption(\"ToggleFilters\")\r\n        addOption('bByLayer')\r\n        addOption('bByColor')\r\n        if not bPre812:\r\n            addOption('bUseUiJoinCmd')\r\n            if not Opts.values['bUseUiJoinCmd']:\r\n                addOption('bSimpleJoin')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        # minimumNumber isn't set to 2 because when only 1 curve is selected, \r\n        # ri.GetResult.Nothing is triggered.\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked:\r\n            if (\r\n                    go.ObjectsWerePreselected and\r\n                    go.ObjectCount == 1\r\n            ):\r\n                if go.ObjectCount == 1:\r\n                    if bDebug: print(\"Only 1 object was preselected.\")\r\n                    bPreselectedObjsChecked = True\r\n                    go.EnablePreSelect(enable=False, ignoreUnacceptablePreselectedObjects=True)\r\n                    go.AlreadySelectedObjectSelect = True\r\n                    continue\r\n                elif bDebug:\r\n                    print(\"{} objects were preselected.\".format(go.ObjectCount))\r\n            else:\r\n                # This is another good place to print join option settings.\r\n                pass\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return _getAllNormalJoinableWires()\r\n\r\n        if res == ri.GetResult.Object:\r\n            if go.ObjectCount < 2:\r\n                print(\"At least 2 breps must be selected.\")\r\n                go.Dispose()\r\n                return\r\n\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return objrefs\r\n\r\n        #if res == ri.GetResult.Option and go.OptionIndex() == 1:\r\n        #    bSequentialSel = True\r\n        #    break\r\n        \r\n        if res == ri.GetResult.Number:\r\n            key = 'fJoinTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if 'Toggle' in idxs_Opt and go.Option().Index == idxs_Opt['Toggle']:\r\n            for key in 'bByLayer', 'bByColor':\r\n                Opts.riOpts[key].CurrentValue = not Opts.riOpts[key].CurrentValue\r\n                Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n    1/0\r\n    # Unnecessary due to go.GetMultiple' minimumNumber=2 ?\r\n    #    # At least 2 curves must be selected.\r\n    #    if go.ObjectCount < 2: return\r\n    \r\n    gCrvs_FromWire = []; gCrvs_FromEdge = []\r\n    \r\n    for objref in go.Objects():\r\n        if objref.GeometryComponentIndex.Index == -1:\r\n            gCrvs_FromWire.append(objref.ObjectId)\r\n        else:\r\n            rdObj = objref.Object()\r\n            if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n                print(\"Objects in block instances are not supported.\")\r\n                continue\r\n            \r\n            # Add curves of edges.\r\n            gCrv = sc.doc.Objects.AddCurve(objref.Geometry())\r\n            if gCrv != Guid.Empty:\r\n                gCrvs_FromEdge.append(gCrv)\r\n    \r\n    go.Dispose()\r\n\r\n\r\ndef _getCurveObjects(rhCrvs):\r\n    if all((isinstance(rhC, rd.CurveObject) for rhC in rhCrvs)): return rhCrvs\r\n\r\n    rdCs_In = []\r\n    for rhC in rhCrvs:\r\n        if isinstance(rhC, rd.CurveObject):\r\n            rdCs_In.append(rhC)\r\n        else:\r\n            rdC = rs.coercerhinoobject(rhC)\r\n            if rdC.ObjectType != rd.ObjectType.Curve:\r\n                raise Exception(\"{} passed to separateInputIntoJoiningSets.\".format(\r\n                    rdC.GetType().Name))\r\n            rdCs_In.append(rdC)\r\n    return rdCs_In\r\n\r\n\r\ndef _separateInputIntoJoiningSets(rhCrvs, bByLayer=True, bByColor=True, bDebug=False):\r\n\r\n    rdCs_In = _getCurveObjects(rhCrvs)\r\n\r\n    if not (bByLayer or bByColor):\r\n        return [rdCs_In] # Nested 1-level for actual separation (see below).\r\n\r\n\r\n    if bByLayer and bByColor:\r\n        rdCs_Per_to_join = [] # Nested 1-level.\r\n        sLayers = [] # Full layer paths (with '::').\r\n        colors = [] # May be System.Drawing.Color or int for rs.ObjectColorSource.\r\n        for rdC in rdCs_In:\r\n            sLayer = rs.ObjectLayer(rdC) # Full layer path (with '::').\r\n            ocs = rs.ObjectColorSource(rdC)\r\n            color = rs.ObjectColor(rdC) if ocs == 1 else rs.ObjectColorSource(rdC)\r\n\r\n            if (sLayer not in sLayers) or (color not in colors):\r\n                rdCs_Per_to_join.append([rdC])\r\n                sLayers.append(sLayer)\r\n                colors.append(color)\r\n                continue\r\n\r\n            idxs_Layer_match = [idx for idx, _ in enumerate(sLayers) if _ == sLayer]\r\n            idxs_color_match = [idx for idx, _ in enumerate(colors) if _ == color]\r\n            matches = list(set(idxs_Layer_match) & set(idxs_color_match))\r\n            if len(matches) == 0:\r\n                rdCs_Per_to_join.append([rdC])\r\n                sLayers.append(sLayer)\r\n                colors.append(color)\r\n            elif len(matches) == 1:\r\n                idx_Match = matches[0]\r\n                rdCs_Per_to_join[idx_Match].append(rdC)\r\n            else:\r\n                raise Exception(\"Multiple layer and color matches.\")\r\n\r\n        if bDebug:\r\n            sEval = \"sLayers\"; print(sEval, '=', eval(sEval))\r\n            sEval = \"colors\"; print(sEval, '=', eval(sEval))\r\n\r\n        return rdCs_Per_to_join\r\n\r\n\r\n    if bByLayer:\r\n        rdCs_Per_to_join = [] # Nested 1-level.\r\n        sLayers = [] # Full layer paths (with '::').\r\n        for rdC in rdCs_In:\r\n            sLayer = rs.ObjectLayer(rdC) # Full layer path (with '::').\r\n            if sLayer in sLayers:\r\n                idx = sLayers.index(sLayer)\r\n                rdCs_Per_to_join[idx].append(rdC)\r\n            else:\r\n                rdCs_Per_to_join.append([rdC])\r\n                sLayers.append(sLayer)\r\n\r\n        if bDebug: sEval = \"sLayers\"; print(sEval, '=', eval(sEval))\r\n\r\n        return rdCs_Per_to_join\r\n\r\n\r\n    if bByColor:\r\n        rdCs_Per_to_join = [] # Nested 1-level.\r\n        colors = [] # May be System.Drawing.Color or int for rs.ObjectColorSource.\r\n        for rdC in rdCs_In:\r\n            ocs = rs.ObjectColorSource(rdC)\r\n            color = rs.ObjectColor(rdC) if ocs == 1 else rs.ObjectColorSource(rdC)\r\n\r\n            if color in colors:\r\n                idx = colors.index(color)\r\n                rdCs_Per_to_join[idx].append(rdC)\r\n            else:\r\n                rdCs_Per_to_join.append([rdC])\r\n                colors.append(color)\r\n\r\n        if bDebug: sEval = \"colors\"; print(sEval, '=', eval(sEval))\r\n\r\n        return rdCs_Per_to_join\r\n\r\n    raise Exception(\"What happened?\")\r\n\r\n\r\ndef joinCurves_using_RC_method(rgCrvs_In, fJoinTol=None, bSimpleJoin=False, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        list(rg.Curves from Join)\r\n        list(int of indices of rgCrvs_In)\r\n        str: Error\r\n    \"\"\"\r\n\r\n    if len(rgCrvs_In) == 0:\r\n        return None, None, \"No curves in set to join.\"\r\n\r\n    if len(rgCrvs_In) < 2:\r\n        return None, None, \"Only 1 curves in set to join.\"\r\n\r\n    if fJoinTol is None:\r\n        fJoinTol = 1.8 * sc.doc.ModelAbsoluteTolerance # The same as _Join for curves (per Rhino 8.14).\r\n\r\n\r\n    rgCs_Joined, idxs_Out_per_In = rg.Curve.JoinCurves(\r\n        rgCrvs_In,\r\n        joinTolerance=fJoinTol,\r\n        preserveDirection=False,\r\n        simpleJoin=bSimpleJoin)\r\n\r\n\r\n    #sEval = \"len(rgCs_Joined)\"; print(sEval, '=', eval(sEval))\r\n    #sEval = \"max(idxs_Out_per_In) + 1\"; print(sEval, '=', eval(sEval))\r\n    #sEval = \"idxs_Out_per_In\"; print(sEval, '=', eval(sEval))\r\n    #print(idxs_Out_per_In)\r\n\r\n    #for rgC_Joined in rgCs_Joined:\r\n    #    sc.doc.Objects.AddCurve(rgC_Joined)\r\n    #sc.doc.Views.Redraw()\r\n    #return\r\n\r\n    idxs_Out_per_In = list(idxs_Out_per_In)\r\n\r\n    rgCs_Out = [] # Actual joins, not all output from JoinCurves.\r\n    idxs_In_perOut = []\r\n    for idx_Joined in range(len(rgCs_Joined)):\r\n        if idxs_Out_per_In.count(idx_Joined) > 1:\r\n            rgCs_Out.append(rgCs_Joined[idx_Joined])\r\n            idxs_In_perOut.append([])\r\n\r\n    #sEval = \"len(rgCs_Out)\"; print(sEval, '=', eval(sEval))\r\n\r\n\r\n    for idx_In, idx_Out_per_In in enumerate(idxs_Out_per_In):\r\n        iCt = idxs_Out_per_In.count(idx_Out_per_In)\r\n        if iCt > 1:\r\n            idxs_In_perOut[idx_Out_per_In].append(idx_In)\r\n\r\n    return rgCs_Out, idxs_In_perOut, None\r\n\r\n    \"\"\"\r\n    For simpleJoin=True,\r\n    Set True to use the simple joining method. In general, set this parameter to false.\r\n    (https://developer.rhino3d.com/api/rhinocommon/rhino.geometry.curve/joincurves)\r\n    \r\n    RhinoMergeCurves()\r\n    Description: Join a bunch of ON_Curves into one or more ON_Curves Parameters:\r\n    input_curves [in] Array of pointers to ON_Curves to be joined output [out] Array\r\n    of pointers to joined results join_tol [in] max distance between endpoints to be joined.\r\n    If join_tol < ON_EPSILON, use CRhinoDoc::AbsoluteTolerance() bPreserveDir [in] if TRUE,\r\n    don't reverse input curves to get them to join key [out] if non-null, curves[i] is part of output[key[i]] WARNING - key[i] may be -1 for some i, in particular if curves[i] is extremely short, key[i] will be -1 and curves[i] will not contribute to the joined results. Returns: @untitled table TRUE Success False Failure Remarks: Join as many of the input curves as have matching endpoints. If the input curve is a NURBS curve or a line, the endpoints within the specified tolerance are trued up to meet exactly. All of the input curves are copied and the caller must free the results. When curves are joined they are made into polycurves. Memory for the curves is allocated and becomes the responsibility of the caller.\r\n    (https://developer.rhino3d.com/api/cpp/group___rhino.html#ga422fa1a9386624b9cbdb77faaeb1bc5b)\r\n    \"\"\"\r\n\r\n\r\ndef join_Cmd(rdCrvs_In, fJoinTol=None, bEcho=False, bDebug=False):\r\n    \"\"\"\r\n    rdCrvs_In: rd.BrepObjects or their GUIDs\r\n    \"\"\"\r\n\r\n    if rs.SelectObjects(rdCrvs_In) == 0:\r\n        print(s + \"Error!  Crvs should be selected.  Command stopped.\")\r\n        return\r\n\r\n    if not Rhino.RhinoMath.EpsilonEquals(\r\n        fJoinTol,\r\n        1.8*sc.doc.ModelAbsoluteTolerance,\r\n        epsilon=1e-6 * Rhino.RhinoMath.UnitScale(Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    ):\r\n        fModelTol_Saved = sc.doc.ModelAbsoluteTolerance\r\n        fModelTol_ForJoin = sc.doc.ModelAbsoluteTolerance = fJoinTol / 1.8\r\n        if bDebug:\r\n            print(\"ModelAbsTol was changed from {} to {}\"\r\n                  \" because _Join's tolerance is 1.8 * ModelAbsTol.\".format(\r\n                      _formatDistance(fModelTol_Saved),\r\n                      _formatDistance(sc.doc.ModelAbsoluteTolerance)))\r\n        bChangedMAT = True\r\n    else:\r\n        bChangedMAT = False\r\n\r\n    rdObj_MostRecent = sc.doc.Objects.MostRecentObject()\r\n    uInt32_MostRecent = rdObj_MostRecent.RuntimeSerialNumber\r\n\r\n    rs.Command(\"_NoEcho _Join\", bEcho)\r\n\r\n\r\n    if bChangedMAT:\r\n        sc.doc.ModelAbsoluteTolerance = fModelTol_Saved\r\n        if bDebug:\r\n            print(\"ModelAbsTol was returned to {}.\".format(\r\n                _formatDistance(sc.doc.ModelAbsoluteTolerance)))\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    return list(sc.doc.Objects.AllObjectsSince(uInt32_MostRecent))\r\n\r\n\r\ndef join_CurveObjects(rhCrvs_In, bByLayer=True, bByColor=True, bUseUiJoinCmd=False, bSimpleJoin=False, fJoinTol=None, bEcho=False, bDebug=False):\r\n\r\n    rdCrvs_Separated = _separateInputIntoJoiningSets(rhCrvs_In, bByLayer, bByColor)\r\n\r\n    gCs_Out = []\r\n    iCt_gCs_Closed = 0\r\n    gCs_DeleteFails = []\r\n    rdCs_replaced_with_joins = []\r\n\r\n    for rdCrvs_PerSet in rdCrvs_Separated:\r\n        if (bUseUiJoinCmd or\r\n            Rhino.RhinoApp.ExeVersion < 8 or\r\n            (Rhino.RhinoApp.ExeVersion == 8 and Rhino.RhinoApp.ExeServiceRelease < 12)\r\n        ):\r\n            fModelTol_Saved = sc.doc.ModelAbsoluteTolerance\r\n            try:\r\n                rdCs_Joins_this_set = join_Cmd(rdCrvs_PerSet, fJoinTol, bEcho, bDebug)\r\n            except Exception as e:\r\n                pass\r\n            else:\r\n                e = None\r\n            finally:\r\n                if sc.doc.ModelAbsoluteTolerance != fModelTol_Saved:\r\n                    sc.doc.ModelAbsoluteTolerance = fModelTol_Saved\r\n\r\n            if e:\r\n                raise\r\n\r\n            #sEval = \"\"; print(sEval,'=',eval(sEval))\r\n\r\n            if not rdCs_Joins_this_set:\r\n                continue\r\n\r\n            gCs_Out.extend([rdC.Id for rdC in rdCs_Joins_this_set])\r\n\r\n            iCt_gCs_Closed += sum([rdC.CurveGeometry.IsClosed for rdC in rdCs_Joins_this_set])\r\n\r\n            for rdC in rdCrvs_PerSet:\r\n                if rdC.IsDeleted:\r\n                    rdCs_replaced_with_joins.append(rdC)\r\n        else:\r\n            rgCrvs_perSet = [rdC.CurveGeometry for rdC in rdCrvs_PerSet]\r\n            rvs = joinCurves_using_RC_method(\r\n                rgCrvs_perSet,\r\n                fJoinTol=fJoinTol,\r\n                bSimpleJoin=bSimpleJoin,\r\n                bDebug=bDebug)\r\n            if rvs is None:\r\n                continue\r\n\r\n            (\r\n                rgCs_Joins_this_set,\r\n                idxs_rgCs_Joined_input_per_join_this_set,\r\n                sLog,\r\n                ) = rvs\r\n\r\n            if not rgCs_Joins_this_set:\r\n                if bDebug and sLog:\r\n                    print(sLog)\r\n                continue\r\n\r\n            #print(rvs)\r\n\r\n            for idx_Joined, rgC_Joined in enumerate(rgCs_Joins_this_set):\r\n                attr = rdCrvs_PerSet[idxs_rgCs_Joined_input_per_join_this_set[idx_Joined][0]].Attributes\r\n\r\n                gC_Out = sc.doc.Objects.AddCurve(rgC_Joined, attr)\r\n\r\n                if gC_Out != Guid.Empty:\r\n                    gCs_Out.append(gC_Out)\r\n                    for idx_rdC_In in idxs_rgCs_Joined_input_per_join_this_set[idx_Joined]:\r\n                        bDeleted = sc.doc.Objects.Delete(rdCrvs_PerSet[idx_rdC_In], quiet=False)\r\n                        if bDeleted:\r\n                            rdCs_replaced_with_joins.append(rdCrvs_PerSet[idx_rdC_In])\r\n                        else:\r\n                            gCs_DeleteFails.append(rdCrvs_PerSet[idx_rdC_In].Id)\r\n\r\n                    if rgC_Joined.IsClosed:\r\n                        iCt_gCs_Closed += 1\r\n\r\n\r\n    #print(rdCs_replaced_with_joins)\r\n\r\n    if gCs_Out:\r\n        if not gCs_DeleteFails:\r\n            if iCt_gCs_Closed == len(gCs_Out):\r\n                print(\"Replaced {} curves with {} joined, closed curves.\".format(\r\n                    len(rdCs_replaced_with_joins),\r\n                    len(gCs_Out),\r\n                    )\r\n                      )\r\n            else:\r\n                print(\"Replaced {} curves with {} joined curves. {} of which are closed.\".format(\r\n                    len(rdCs_replaced_with_joins),\r\n                    len(gCs_Out),\r\n                    iCt_gCs_Closed),\r\n                      )\r\n        else:\r\n            print(\"Added {} joined curves.\".format(len(gCs_Out)))\r\n            print(\"Failed to delete {} curves.\".format(len(gCs_DeleteFails)))\r\n    else:\r\n        print(\"None of the {} curves were joined.\".format(len(rhCrvs_In)))\r\n\r\n    return gCs_Out\r\n\r\n\r\ndef main():\r\n\r\n    #if Rhino.RhinoApp.ExeVersion < 8:\r\n    #    print(\"This script uses a method added to RhinoCommon 8.12. Rhino 7 is not current supported in this branch of the script.\")\r\n    #    return\r\n    #if Rhino.RhinoApp.ExeVersion == 8 and Rhino.RhinoApp.ExeServiceRelease < 12:\r\n    #    print(\"This script uses a method added to RhinoCommon 8.12. Upgrade your Rhino 8 to use this script.\")\r\n    #    return\r\n\r\n\r\n    gObjs_Preselected = [rdObj.Id for rdObj in sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False)]\r\n\r\n    rhCrvs = getInput() # ObjRefs, rd.CurveObjects, or None.\r\n    if rhCrvs is None: return\r\n\r\n    fJoinTol = Opts.values['fJoinTol']\r\n    bByLayer = Opts.values['bByLayer']\r\n    bByColor = Opts.values['bByColor']\r\n    bUseUiJoinCmd = Opts.values['bUseUiJoinCmd']\r\n    bSimpleJoin = Opts.values['bSimpleJoin']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    #if gCrvs0_FromEdge:\r\n    #    # If any edge curves were selected, curves will be joined ignoring layer and color.\r\n    #    if bByLayer:\r\n    #        print(\"Edge curve in selection, so all curves' layers will be ignored.\")\r\n    #    bByLayer = False\r\n        \r\n    #    if bByColor:\r\n    #        print(\"Edge curve in selection, so all curves' layers will be ignored.\")\r\n    #    bByColor = False\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    gCs_Res = join_CurveObjects(\r\n        rhCrvs,\r\n        bByLayer=bByLayer,\r\n        bByColor=bByColor,\r\n        bUseUiJoinCmd=bUseUiJoinCmd,\r\n        bSimpleJoin=bSimpleJoin,\r\n        fJoinTol=fJoinTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    if gObjs_Preselected:\r\n        for gObj in gObjs_Preselected: sc.doc.Objects.Select(gObj)\r\n        for gC in gCs_Res: sc.doc.Objects.Select(gC)\r\n\r\n    # Note that one case when gCs_Res is None is when _Join is used.\r\n    if gCs_Res:\r\n        sc.doc.Views.Redraw()\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n    return\r\n\r\n\r\n\r\n\r\n    if len(gCrvs0_FromWire + gCrvs0_FromEdge) == len(rgCrvs1):\r\n        print(\"Unable to join any curves.\")\r\n        if len(gCrvs0_FromEdge): sc.doc.Views.Redraw()\r\n        return\r\n    \r\n    isClosedCt = 0\r\n    \r\n    gCrvs1 = []\r\n    \r\n    for rgCrv1 in rgCrvs1:\r\n        \r\n\r\n        \r\n        # Don't modify monoface curves.\r\n        if rgCrv1.Faces.Count == 1:\r\n            continue\r\n        \r\n        if not rgCrv1.IsValid:\r\n            print(\"The geometry of at least one of the new curves is invalid.\"\r\n                  \"Crv will not be modified.\")\r\n            continue\r\n        \r\n        if gCrv0:\r\n            gCrv0 = gCrvs0_FromMarker[0] # Get 1st to take its attribute instead of the last's.\r\n            \r\n            rdCrv0 = rs.coercerhinoobject(gCrv0) # Using last gCrv0 in gCrvs0_FromMarker.\r\n            if rdCrv0 is None and Rhino.RhinoApp.ExeVersion >= 6:\r\n                # If using Rhino V6 or newer, try using sc.doc.Objects.Find.\r\n                print(\"sc.doc.Objects.FindId failed! Using sc.doc.Objects.Find instead ...\")\r\n                rdCrv0 = sc.doc.Objects.Find(gCrv0)\r\n            if rdCrv0 is None:\r\n                print(\"DocObject for {} not found!\".format(gCrv0))\r\n                continue\r\n            \r\n            attr = rdCrv0.Attributes.Duplicate()\r\n        else:\r\n            attr = None\r\n        \r\n        gCrv1 = sc.doc.Objects.AddCrv(rgCrv1, attr)\r\n        if gCrv1 == Guid.Empty:\r\n            print(\"GUID is empty!  Check results.\")\r\n            continue\r\n        \r\n        if rgCrv1.IsClosed:\r\n            isClosedCt += 1\r\n        \r\n        # Remove user string marker.\r\n        removeMarkers(gCrv1)\r\n        \r\n        # Delete old curves.\r\n        for gCrv0 in gCrvs0_FromMarker:\r\n            sc.doc.Objects.Delete(gCrv0, quiet=False)\r\n        \r\n        gCrvs1.append(gCrv1)\r\n    \r\n    #rs.MatchObjectAttributes(gCrvs1, gCrvs0[0])\r\n    \r\n    s = \"{} wire curves and {} curves from edges joined into\".format(\r\n            len(gCrvs0_FromWire), len(gCrvs0_FromEdge))\r\n    sPolyInfos = []\r\n    if isClosedCt > 0:\r\n        sPolyInfos.append(\" {} closed polycurves(s)\".format(isClosedCt))\r\n    if isClosedCt < len(gCrvs1):\r\n        sPolyInfos.append(\" {} open polycurves(s).\".format(\r\n                len(gCrvs1) - isClosedCt))\r\n    print(s + \",\".join(sPolyInfos))\r\n    \r\n    if gObjs_Preselected:\r\n        rs.SelectObjects(gObjs_Preselected)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}