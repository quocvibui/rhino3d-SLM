{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_CreatePHPPwindow.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_CreatePHPPwindow.py",
  "instruction": "Use this component BEFORE an HB 'addHBGlz' component to add PHPP-Style parameters to the window. \r\r\nComponent will:\r\r\n    - Create PHPP-Style Constructions from EP input or Default ('Exterior...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nUse this component BEFORE an HB 'addHBGlz' component to add PHPP-Style parameters to the window. \r\r\nComponent will:\r\r\n    - Create PHPP-Style Constructions from EP input or Default ('Exterior Window') with a U-W-Installed cacl'd for each window\r\r\n    - Read window params from the Rhino Scene (object User-Text) and get data from the Rhino Window Library (Document User-Text)\r\r\n    - Accept direct user-input of frame, glass and install objects\r\r\n---------\r\r\nWill work in that order, and later inputs will overwrite previous ones (direct user input overwrites Rhino scene params, which overwrites EP-Constructions)\r\r\nOnce it has gotten all the window params, builds a new PHPP-Style Window Object and writes to the master dictionary attached to the zone (creates this dict if it doesn't already exist)\r\r\nWill lastly, write the NEW EP-Construction and EP-Material with the U-W-Installed value to the HB Library for use in the EP Simulation. \r\r\n-\r\r\nEM July 25, 2020\r\r\n    Args:\r\r\n        _HBZones: (list) The HB Zone object(s) from HB Consttructors\r\r\n        names_: (list) <Optional> An optional entry for user-defined Window Names to use. Input either a single name or a list matching the length of the geometry. \r\r\n        frames_: (list) <Optional> An optional entry for user-defined Frame Objects. Use the 'PHPP | Win. Frame' Component to create a Frame Object and pass in. Either pass in a single Frame object, or a list of Frames that matches the Geometry. If the length of the Frames list doesn't match the Geometry, the first Frame Object input will be used for all Windows.\r\r\n        glazings_: (list) <Optional> An optional entry for user-defined Glass Objects. Use the 'PHPP | Win. Glass' Component to create a Glass Object and pass in. Either pass in a single Glass object, or a list of Frames that matches the Geometry. If the length of the Glass list doesn't match the Geometry, the first Glass Object input will be used for all Windows.\r\r\n        psi_installs_: (list) <Optional> An optional entry for user-defined Psi-Install Values (W/m-k). Either pass in a single number which will be used for all edges, or a list of 4 numbers (left, right, bottom, top) - one for each edge.\r\r\n        installs_:(list) <Optional> An optional entry for user-defined Install Conditions (1|0) for each window edge (1=Apply Psi-Install, 0=Don't apply Psi-Install). Either pass in a single number which will be used for all edges, or a list of 4 numbers (left, right, bottom, top) - one for each edge.\r\r\n        EPConsts: (list) <Optional> A list of EP Construction Names to use for the windows. Accepts a single name which is then applied to all windows, or a list of names corresponding (length / order) to the windows. Be sure that the EP Constructions and EP Materials are already added to the HB Library.\r\r\n        _windowGeom: (list) The Window Geometry to use. Accepts Surfaces or Curves from the Rhino scene. Pass all Rhino Geometry through an 'ID' component in order to have the component read the parameters from the Rhino Scene. Set the type hint to 'srfc' if you are trying to pass in geometry that you created in Grasshopper rather than Rhino geometry.\r\r\n    Returns:\r\r\n        HBZones_: The HBZone(s) with the new 'phppWindowDict' entries added.\r\r\n        windowSurfaces_: A List of the Window Surfaces\r\r\n        windowNames_: A List of the Window Names\r\r\n        EPConstructions_: A List of the NEW EPConstructions to be applied to the Windows.\r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_CreatePHPPwindow\"\r\r\nghenv.Component.NickName = \"New PHPP Window\"\r\r\nghenv.Component.Message = 'JUL_25_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"01 | Model\"\r\r\n\r\r\nimport scriptcontext as sc\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport Rhino\r\r\nimport Grasshopper.Kernel as ghK\r\r\nimport json\r\r\nimport ghpythonlib.components as ghc\r\r\nimport random\r\r\nimport re\r\r\nfrom System import Object\r\r\nfrom Grasshopper import DataTree\r\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\r\n\r\r\n# Defs and Classes\r\r\nidf2ph_rhDoc = sc.sticky['idf2ph_rhDoc']\r\r\nPHPP_Glazing = sc.sticky['PHPP_Glazing']\r\r\nPHPP_Frame = sc.sticky['PHPP_Frame']\r\r\nPHPP_Window_Install = sc.sticky['PHPP_Window_Install']\r\r\nPHPP_WindowObject = sc.sticky['PHPP_WindowObject']\r\r\nphpp_makeHBMaterial = sc.sticky['phpp_makeHBMaterial']\r\r\nphpp_makeHBConstruction = sc.sticky['phpp_makeHBConstruction']\r\r\nphpp_getWindowLibraryFromRhino = sc.sticky['phpp_getWindowLibraryFromRhino']\r\r\n\r\r\nhb_hive = sc.sticky[\"honeybee_Hive\"]()\r\r\nhb_EPMaterialAUX = sc.sticky[\"honeybee_EPMaterialAUX\"]()\r\r\nHBZoneObjects = hb_hive.callFromHoneybeeHive(_HBZones)\r\r\n\r\r\n#################################################################\r\r\n# Def from HB 'addToEPLibrary'\r\r\ndef HB_addToEPLibrary(EPObject, overwrite):\r\r\n    # import the classes\r\r\n    \r\r\n    hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\r\r\n    added, name = hb_EPObjectsAux.addEPObjectToLib(EPObject, overwrite)\r\r\n    \r\r\n    if not added:\r\r\n        msg = name + \" is not added to the project library!\"\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, msg)\r\r\n        print msg\r\r\n    else:\r\r\n        print name + \" is added to this project library!\"\r\r\n\r\r\ndef createHBMats(_winName, _uwInst, _gVal):\r\r\n    # Add the EP Construction name to the output list\r\r\n    # Create a new 'U-w-installed' Material for the window\r\r\n    matName = \"PHPP_MAT_{}\".format(_winName).upper()\r\r\n    newHBMat = phpp_makeHBMaterial(\r\r\n            matName, # Material Name\r\r\n            _uwInst, # The new U-w-Installed\r\r\n            _gVal,\r\r\n            0.75) # Default VT\r\r\n    \r\r\n    # Create a new 'U-w-installed' Construction for the window\r\r\n    constructionName = \"PHPP_CONST_{}\".format(_winName)\r\r\n    new_EPConstruction = phpp_makeHBConstruction(constructionName, matName)\r\r\n    \r\r\n    return newHBMat, constructionName, new_EPConstruction\r\r\n\r\r\ndef cleanUpName(_baseName):\r\r\n    nameNoSpaces = re.sub(r'\\s+', '_', _baseName)\r\r\n    nameNoPeriods = nameNoSpaces.replace(\".\", \"-\")\r\r\n    nameAddPrefix = '__Win_' + nameNoPeriods\r\r\n    \r\r\n    return nameAddPrefix\r\r\n\r\r\ndef getWindowBasics(_in):\r\r\n    with idf2ph_rhDoc():\r\r\n        # Get the Window Geometry\r\r\n        geom = rs.coercegeometry(_in)\r\r\n        windowSurface  = ghc.BoundarySurfaces( geom )\r\r\n        \r\r\n        # Inset the window just slightly. If any windows touch one another or the zone edges\r\r\n        # will failt to create a proper closed Brep. So shink them ever so slightly. Hopefully\r\r\n        # not enough to affect the results. \r\r\n        windowPerim = ghc.JoinCurves( ghc.DeconstructBrep(windowSurface).edges, preserve=False )\r\r\n        try:\r\r\n            windowPerim = ghc.OffsetonSrf(windowPerim, 0.004, windowSurface) # 0.4mm so hopefully rounds down\r\r\n        except:\r\r\n            windowPerim = ghc.OffsetonSrf(windowPerim, -0.004, windowSurface)\r\r\n        windowSurface = ghc.BoundarySurfaces( windowPerim )\r\r\n        \r\r\n        # Pull in the Object Name from Rhino Scene\r\r\n        try:\r\r\n            windowName = rs.ObjectName(_in)\r\r\n        except:\r\r\n            print('No!')\r\r\n            warning = \"Can't get the Name for some reason?\\nDouble check:\\n\"\\\r\r\n            \"If you are passing in Rhino Geometry,\\nbe sure to pass it through\\n\"\\\r\r\n            \"an 'ID' component before inputing into the '_windowGeom' input?\"\r\r\n            ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n            \r\r\n        windowName = windowName if windowName!=None else 'Unnamed_Window'\r\r\n        windowName = cleanUpName(windowName)\r\r\n        \r\r\n        \r\r\n        # Double check that the surface Normal didn't get flipped\r\r\n        c1 = ghc.Area(geom).centroid\r\r\n        n1 = rs.SurfaceNormal(geom, c1)\r\r\n        \r\r\n        c2 = ghc.Area(windowSurface).centroid\r\r\n        n2 = rs.SurfaceNormal(windowSurface, c2)\r\r\n        \r\r\n        normAngleDifference = ghc.Degrees( ghc.Angle(n1, n2).angle )\r\r\n        if round(normAngleDifference, 0) != 0:\r\r\n            # Flip the surface if it doesn't match the source\r\r\n            windowSurface = ghc.Flip(windowSurface).surface\r\r\n        \r\r\n        return windowName, windowSurface\r\r\n\r\r\ndef getWindowUserText(_in):\r\r\n    with idf2ph_rhDoc():\r\r\n        windowDataFromRhino = {}\r\r\n        \r\r\n        if rs.IsUserText(_in):\r\r\n            print 'Pulling data from Rhino model for Window: {}'.format(rs.ObjectName(_in))\r\r\n            # Get the User-Text data from the Rhino Scene\r\r\n            for eachKey in rs.GetUserText(_in):\r\r\n                windowDataFromRhino[eachKey] = rs.GetUserText(_in, eachKey) \r\r\n            return windowDataFromRhino\r\r\n        else:\r\r\n            return None\r\r\n\r\r\ndef getWindowParamsFromLib(_in, _lib):\r\r\n    instDepth = _in.get('InstallDepth', 0.1)\r\r\n    varType = _in.get('VariantType', 'a')\r\r\n    psiInstallType = _in.get('PsiInstallType', None)\r\r\n    \r\r\n    frameTypeName = _in['FrameType']\r\r\n    frameTypeObj = _lib['lib_FrameTypes'][frameTypeName] # the dict is inside a list....\r\r\n    \r\r\n    glassTypeName = _in['GlazingType']\r\r\n    glassTypeObj = _lib['lib_GlazingTypes'][glassTypeName]\r\r\n    \r\r\n    installs = [\r\r\n    0 if _in['InstallLeft']=='False' else 1,\r\r\n    0 if _in['InstallRight']=='False' else 1,\r\r\n    0 if _in['InstallBottom']=='False' else 1,\r\r\n    0 if _in['InstallTop']=='False' else 1\r\r\n    ]\r\r\n    \r\r\n    # Update the Psi-Installs with UD Values if found in the Library\r\r\n    if psiInstallType:\r\r\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n        psiInstalls_UD =  json.loads(rs.GetDocumentUserText('PHPP_lib_PsiInstall_'+psiInstallType) )\r\r\n        sc.doc = ghdoc\r\r\n        \r\r\n        if psiInstalls_UD['Left'] != None:\r\r\n            installs[0] = psiInstalls_UD['Left'] * installs[0]\r\r\n        if psiInstalls_UD['Right'] != None: \r\r\n            installs[1] = psiInstalls_UD['Right'] * installs[1]\r\r\n        if psiInstalls_UD['Bottom'] != None:\r\r\n            installs[2] = psiInstalls_UD['Bottom'] * installs[2]\r\r\n        if psiInstalls_UD['Top'] != None:\r\r\n            installs[3] = psiInstalls_UD['Top'] * installs[3]\r\r\n    \r\r\n    return frameTypeObj, glassTypeObj, installs, varType, instDepth\r\r\n\r\r\ndef isZoneHost(_winSrfc, _HBzones):\r\r\n    # Performs a BrepXBrep collision to see if the Windw\r\r\n    # is 'on' any of the HB Zone Surfaces or not?\r\r\n    \r\r\n    for zone in _HBzones:\r\r\n        if 'surfaces' not in dir(zone):\r\r\n            warning = \"Double check the input into _HBZones? It looks like perhaps you are\\n\"\\\r\r\n            \"passing in just the HB Surfaces? Be sure to pass those surfaces to an HB 'createHBZones'\\n\"\\\r\r\n            \"before this in order to create a 'Zone' before passing in here.\"\r\r\n            ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning) \r\r\n            return None\r\r\n        for srfc in zone.surfaces:\r\r\n            if ghc.BrepXBrep(srfc.geometry, _winSrfc).curves != None:\r\r\n                hostZone = zone.name\r\r\n                return hostZone\r\r\n    \r\r\n    return None\r\r\n\r\r\ndef uniqueNames(_windowName, _HBzones, _hostZoneName):\r\r\n    # Looks at the HB Zones to see if there are duplicate window names\r\r\n    # Creates a unique name if so. Returns the name and sets the attr on the HB Zone\r\r\n    \r\r\n    for zone in _HBzones:\r\r\n        if zone.name == _hostZoneName:\r\r\n            try:\r\r\n                # Get the master list of window names for the zone\r\r\n                windowNameList = getattr(zone, 'windowNameList')\r\r\n            except:\r\r\n                # If there isn't one, start it now\r\r\n                windowNameList = []\r\r\n                setattr(zone, 'windowNameList', windowNameList)\r\r\n            \r\r\n            # See if the name already in the Master List. If not, add it\r\r\n            if _windowName not in windowNameList:\r\r\n                windowNameList.append(_windowName)\r\r\n            else:\r\r\n                # if it is a duplicate name, add a new unique ID number and then add it\r\r\n                _windowName = \"{}_{:03d}\".format(_windowName, len(windowNameList) )\r\r\n                windowNameList.append(_windowName)\r\r\n            \r\r\n            setattr(zone, 'windowNameList', windowNameList)\r\r\n    \r\r\n    return _windowName\r\r\n\r\r\ndef getParamsFromMultiLayerConsr(_materialsList):\r\r\n    rValues = []\r\r\n    \r\r\n    for material in _materialsList:\r\r\n        values, comments, UValue_SI, UValue_IP = hb_EPMaterialAUX.decomposeMaterial(material.upper(), ghenv.Component)\r\r\n        rValues.append( 1/UValue_SI )\r\r\n    \r\r\n    gValue = 0.4 #DEFAULT\r\r\n    \r\r\n    return 1/sum(rValues), gValue\r\r\n\r\r\ndef getWindowParamsFromHBLib(_constName):\r\r\n    # Calls the EP Construction from the HB Library\r\r\n    frameUf_ = []\r\r\n    frameW_ = []\r\r\n    framePsiG_ = []\r\r\n    framePsiInst_ = []\r\r\n    glassU_ = None\r\r\n    glassG_ = None\r\r\n    glassVT_= None\r\r\n    \r\r\n    # First, Get the Construction Object from the HB Library\r\r\n    construction = hb_EPMaterialAUX.decomposeEPCnstr(_constName.upper())\r\r\n    if construction != -1:\r\r\n        materials, comments, UValue_SI, UValue_IP = construction\r\r\n        \r\r\n        # Get all the Material Params as well\r\r\n        if len(materials) == 1:\r\r\n            # Simple Material Window (Single Layer), pull the parms\r\r\n            values, comments, UValue_SI, UValue_IP = hb_EPMaterialAUX.decomposeMaterial(materials[0].upper(), ghenv.Component)\r\r\n            EP_uValue = values[1]\r\r\n            EP_gValue = values[2]\r\r\n        elif len(materials) > 1:\r\r\n            # MultiLayer Assembly. Calc the effective U-w\r\r\n            EP_uValue, EP_gValue = getParamsFromMultiLayerConsr( materials )\r\r\n    \r\r\n    # Set up the outputs \r\r\n    for i in range(4):\r\r\n        frameUf_.append(float( EP_uValue) )\r\r\n        frameW_.append(0.12)\r\r\n        framePsiG_.append(0)\r\r\n        framePsiInst_.append(0)\r\r\n        \r\r\n    glassU_ = float( EP_uValue )\r\r\n    glassG_ = float( EP_gValue )\r\r\n    \r\r\n    return glassU_, glassG_, frameUf_, frameW_, framePsiG_, framePsiInst_\r\r\n\r\r\ndef getWindowIDinfo(_count, _windowGeom):\r\r\n    # Get the Window Name, Host Zone and Geometry from Rhino Scene\r\r\n    windowName, windowSurface = getWindowBasics(_windowGeom)\r\r\n    hostZoneName = isZoneHost(windowSurface, HBZoneObjects)\r\r\n    \r\r\n    try: windowName = inputs.getInputNames()[_count]\r\r\n    except:pass\r\r\n    \r\r\n    # Fix Duplicate window names if there are any\r\r\n    if hostZoneName:\r\r\n        windowName = uniqueNames(windowName, HBZoneObjects, hostZoneName)\r\r\n    else:\r\r\n        warning = 'Cound not find the host zone for \"{}\"? Check the window geometry is Co-Planar with a Zone surface?'.format( windowName )\r\r\n        ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning) \r\r\n    \r\r\n    outputs.getWinNames().append( windowName )\r\r\n    outputs.getWinSrfcs().append( windowSurface )\r\r\n    \r\r\n    return windowName, windowSurface, hostZoneName\r\r\n\r\r\ndef getWindowParams(_count, _windowGeom, _phppLibrary):\r\r\n    \r\r\n    #####################################\r\r\n    # Sort out the Window's Params to use\r\r\n    \r\r\n    # 1)\r\r\n    # Get the EP Construction params from the HB Library\r\r\n    EPConstName = inputs.getEPConst()[_count] \r\r\n    glassU, glassG, frameUf, frameW, framePsiG, framePsiInst = getWindowParamsFromHBLib(EPConstName)\r\r\n    \r\r\n    glassTypeObj = PHPP_Glazing(EPConstName+'_Glass', _gValue=float(glassG), _uValue=float(glassU) )\r\r\n    frameTypeObj = PHPP_Frame(EPConstName+'_Frame', _uValues=frameUf , _frameWidths=frameW , _psiGlazings=framePsiG , _psiInstalls=framePsiInst )\r\r\n    installsObj = PHPP_Window_Install( [1,1,1,1] ) # Default\r\r\n    variantType = 'a'\r\r\n    instDepth = 0.1\r\r\n    \r\r\n    # 2)\r\r\n    # Next, Try and pull Params from the Rhino scene if there are any\r\r\n    windowDataFromRhino = getWindowUserText(_windowGeom)\r\r\n    if windowDataFromRhino and _phppLibrary:\r\r\n        windowParams = getWindowParamsFromLib(windowDataFromRhino, _phppLibrary)\r\r\n        frameTypeObj, glassTypeObj, installValues, variantType, instDepth = windowParams\r\r\n        installsObj = PHPP_Window_Install( installValues )\r\r\n    \r\r\n    # 3)\r\r\n    # Last, get any user input Param Objects for frame, glass, installs, etc....\r\r\n    try: glassTypeObj = inputs.getInputGlazing()[_count]\r\r\n    except:pass\r\r\n    \r\r\n    try: frameTypeObj = inputs.getInputFrames()[_count]\r\r\n    except:pass\r\r\n    \r\r\n    try:\r\r\n        if len( inputs.getInputInstalls() ) == 1:\r\r\n            # Could be a single value passed in, if so - use it for all four\r\r\n            installsUI = []\r\r\n            for i in range(4):\r\r\n                installsUI.append( inputs.getInputInstalls()[0] )\r\r\n            installsObj = PHPP_Window_Install(installsUI)\r\r\n        elif len( inputs.getInputInstalls()[0] ) == 4:\r\r\n            # Could be a list of 4 values, if so, create a new InstallObj with all four\r\r\n            installsObj = PHPP_Window_Install( inputs.getInputInstalls()[0] )\r\r\n    except:\r\r\n        pass\r\r\n    \r\r\n    try:\r\r\n        if len( inputs.getInputPsiInst() ) == 1:\r\r\n            # Single value input, use this for all four\r\r\n            setattr( frameTypeObj, 'psiInstLeft', float(inputs.getInputPsiInst()[0]) )\r\r\n            setattr( frameTypeObj, 'psiInstRight', float(inputs.getInputPsiInst()[0]) )\r\r\n            setattr( frameTypeObj, 'psiInstBottom', float(inputs.getInputPsiInst()[0]) )\r\r\n            setattr( frameTypeObj, 'psiInstTop', float(inputs.getInputPsiInst()[0]) )\r\r\n            \r\r\n        elif len( inputs.getInputPsiInst() ) == 4:\r\r\n            # List of 4 values, use this \r\r\n            setattr( frameTypeObj, 'psiInstLeft', float(inputs.getInputPsiInst()[0]) )\r\r\n            setattr( frameTypeObj, 'psiInstRight', float(inputs.getInputPsiInst()[1]) )\r\r\n            setattr( frameTypeObj, 'psiInstBottom', float(inputs.getInputPsiInst()[2]) )\r\r\n            setattr( frameTypeObj, 'psiInstTop', float(inputs.getInputPsiInst()[3]) )\r\r\n    except:\r\r\n        pass\r\r\n    \r\r\n    return glassTypeObj, frameTypeObj, installsObj, variantType, instDepth\r\r\n\r\r\ndef cleanInput(_inputList, targetListLength, outputLocation, _defaultVal=None, ):\r\r\n    # Used to make sure the input lists are all the same length\r\r\n    # if the input param list isn't the same, use only the first item for all\r\r\n    \r\r\n    if len(_inputList) == targetListLength:\r\r\n        for each in _inputList:\r\r\n            outputLocation.append(each)\r\r\n    elif len(_inputList) >= 1:\r\r\n        for i in range(targetListLength):\r\r\n            outputLocation.append(_inputList[0])\r\r\n    elif len(_inputList) == 0 and _defaultVal != None:\r\r\n        for i in range(targetListLength):\r\r\n            outputLocation.append(_defaultVal)\r\r\n\r\r\nclass Outputs:\r\r\n    \"\"\" Temporary object to store and manage the output values of the component\r\r\n    \r\r\n    Note to self: playing around with this method.... seems like I made\r\r\n    it more complicated than it needs to be though. Maybe just go back to normal?\r\r\n    \"\"\"\r\r\n    \r\r\n    __windowSurfaces = None\r\r\n    __windowNames = None\r\r\n    __EPConstructions = None\r\r\n    __windowObjs = None\r\r\n    __HBConstructions = None\r\r\n    __HBMaterials = None\r\r\n    \r\r\n    @staticmethod\r\r\n    def getWinSrfcs():\r\r\n        if Outputs.__windowSurfaces == None:\r\r\n            Outputs.__windowSurfaces = []\r\r\n        return Outputs.__windowSurfaces\r\r\n    \r\r\n    @staticmethod\r\r\n    def getWinNames():\r\r\n        if Outputs.__windowNames == None:\r\r\n            Outputs.__windowNames = []\r\r\n        return Outputs.__windowNames\r\r\n    \r\r\n    @staticmethod\r\r\n    def getEPConsts():\r\r\n        if Outputs.__EPConstructions == None:\r\r\n            Outputs.__EPConstructions = []\r\r\n        return Outputs.__EPConstructions\r\r\n        \r\r\n    @staticmethod\r\r\n    def getWinObjs():\r\r\n        if Outputs.__windowObjs == None:\r\r\n            Outputs.__windowObjs = DataTree[Object]()\r\r\n        return Outputs.__windowObjs\r\r\n        \r\r\n    @staticmethod\r\r\n    def getHBConsts():\r\r\n        if Outputs.__HBConstructions == None:\r\r\n            Outputs.__HBConstructions = []\r\r\n        return Outputs.__HBConstructions\r\r\n    \r\r\n    @staticmethod\r\r\n    def getHBMats():\r\r\n        if Outputs.__HBMaterials == None:\r\r\n            Outputs.__HBMaterials = []\r\r\n        return Outputs.__HBMaterials\r\r\n\r\r\nclass Inputs:\r\r\n    \r\r\n    __InputNames = None\r\r\n    __InputFrames = None\r\r\n    __InputGlazing = None\r\r\n    __InputPsiInst = None\r\r\n    __InputEPConst = None\r\r\n    __Installs = None\r\r\n    \r\r\n    @staticmethod\r\r\n    def getInputNames():\r\r\n        if Inputs.__InputNames == None:\r\r\n            Inputs.__InputNames = []\r\r\n        return Inputs.__InputNames\r\r\n    \r\r\n    @staticmethod\r\r\n    def getInputFrames():\r\r\n        if Inputs.__InputFrames == None:\r\r\n            Inputs.__InputFrames = []\r\r\n        return Inputs.__InputFrames\r\r\n    \r\r\n    @staticmethod\r\r\n    def getInputGlazing():\r\r\n        if Inputs.__InputGlazing == None:\r\r\n            Inputs.__InputGlazing = []\r\r\n        return Inputs.__InputGlazing\r\r\n    \r\r\n    @staticmethod\r\r\n    def getInputPsiInst():\r\r\n        if Inputs.__InputPsiInst == None:\r\r\n            Inputs.__InputPsiInst = []\r\r\n        return Inputs.__InputPsiInst\r\r\n    \r\r\n    @staticmethod\r\r\n    def getEPConst():\r\r\n        if Inputs.__InputEPConst == None:\r\r\n            Inputs.__InputEPConst = []\r\r\n        return Inputs.__InputEPConst\r\r\n    \r\r\n    @staticmethod\r\r\n    def getInputInstalls():\r\r\n        if Inputs.__Installs == None:\r\r\n            Inputs.__Installs = []\r\r\n        return Inputs.__Installs\r\r\n\r\r\n# Master Output class obj\r\r\noutputs = Outputs()\r\r\ninputs = Inputs()\r\r\n\r\r\ncleanInput(names_, len(_windowGeom), inputs.getInputNames() )\r\r\ncleanInput(frames_, len(_windowGeom), inputs.getInputFrames() )\r\r\ncleanInput(glazings_, len(_windowGeom), inputs.getInputGlazing() )\r\r\ncleanInput(psi_installs_, 4, inputs.getInputPsiInst() )\r\r\ncleanInput(installs_, 4, inputs.getInputInstalls() )\r\r\ncleanInput(EPConsts, len(_windowGeom), inputs.getEPConst(), 'Exterior Window')\r\r\n\r\r\n# Get the Rhino Scene Document User-Text (Window Library)\r\r\nif len(_windowGeom)>0 and len(_HBZones)>0:\r\r\n    _phppLibrary = phpp_getWindowLibraryFromRhino()\r\r\nelse:\r\r\n    _phppLibrary = None\r\r\n\r\r\n# Get the Window Name, Host Zone and Geometry from Rhino Scene\r\r\nif len(_windowGeom)>0 and len(_HBZones)>0:\r\r\n    for i, winGeom in enumerate(_windowGeom):\r\r\n        # Get the Basic Window Information, Data Parameters\r\r\n        windowName, windowSurface, hostZoneName = getWindowIDinfo(i, winGeom)\r\r\n        glassTypeObj, frameTypeObj, installsObj, variantType, instDepth = getWindowParams(i, winGeom, _phppLibrary)\r\r\n        \r\r\n        #####################################\r\r\n        # Create the 'WINDOW' object from frame, glass, installs passed in\r\r\n        newWindowObj = PHPP_WindowObject(\r\r\n                                    windowName,\r\r\n                                    glassTypeObj,\r\r\n                                    frameTypeObj,\r\r\n                                    installsObj,\r\r\n                                    windowSurface,\r\r\n                                    variantType,\r\r\n                                    instDepth\r\r\n                                    )\r\r\n        \r\r\n        # Calc the Uw Installed for the new Window Object (based on size, params...)\r\r\n        uW_Inst = newWindowObj.getUwInstalled()\r\r\n        \r\r\n        # Create a NEW HB Materials and Constructions for the window\r\r\n        # based on the U-W-installed, add to the output lists\r\r\n        newHBMat, constructionName, new_EPConstruction = createHBMats(windowName, uW_Inst, newWindowObj.Type_Glass.gValue)\r\r\n        outputs.getEPConsts().append(constructionName)\r\r\n        \r\r\n        # The full IDF text to write\r\r\n        outputs.getHBMats().append(newHBMat) # The full txt to write to IDF\r\r\n        outputs.getHBConsts().append(new_EPConstruction) # The full txt to write to IDF\r\r\n        \r\r\n        # Add the PHPP Style Window + UNIQUE name to a HB Zone master list, so can pull out later\r\r\n        # Find the right zone to write to \r\r\n        for i, zone in enumerate(HBZoneObjects):\r\r\n            if zone.name == hostZoneName:\r\r\n                # If the Window Dict doesn't yet exist\r\r\n                if 'phppWindowDict' in zone.__dict__.keys():\r\r\n                    phppWindowDict = zone.phppWindowDict\r\r\n                else:\r\r\n                    setattr(zone, 'phppWindowDict', {})\r\r\n                    phppWindowDict = zone.phppWindowDict\r\r\n                \r\r\n                # Add the new window Object to the Zone's Dict\r\r\n                phppWindowDict[newWindowObj.Name] = newWindowObj\r\r\n                \r\r\n                # Add to a preview output\r\r\n                outputs.getWinObjs().Add(newWindowObj, GH_Path(i))\r\r\n\r\r\n# Pass along the Component Outputs\r\r\nwindowSurfaces_ = outputs.getWinSrfcs()\r\r\nwindowNames_ = outputs.getWinNames()\r\r\nEPConstructions_ = outputs.getEPConsts()\r\r\nwindowObjs_ = outputs.getWinObjs()\r\r\n\r\r\n#################################################################\r\r\n# Add the HB Materials and Constructions to the HB Library\r\r\naddToHBLib_ = True\r\r\n\r\r\nif addToHBLib_ and len(outputs.getHBConsts())>0 and len(outputs.getHBMats())>0:\r\r\n    print('----')\r\r\n    for eachMat in outputs.getHBMats():\r\r\n        HB_addToEPLibrary(eachMat, overwrite=True)\r\r\n    print('----')\r\r\n    for eachConst in outputs.getHBConsts():\r\r\n        HB_addToEPLibrary(eachConst, overwrite=True)\r\r\n\r\r\n# Add modified Surfaces / Zones back to the HB dictionary\r\r\nif len(_HBZones)>0:\r\r\n    HBZones_  = hb_hive.addToHoneybeeHive(HBZoneObjects, ghenv.Component)\r\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}