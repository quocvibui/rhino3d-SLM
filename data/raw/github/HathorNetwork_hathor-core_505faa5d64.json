{
  "source_url": "https://github.com/HathorNetwork/hathor-core/blob/23f26cadf706a0bd36d0f26e43d95d7ce6a8e26b/hathor/transaction/scripts/execute.py",
  "repo": "HathorNetwork/hathor-core",
  "repo_stars": 91,
  "repo_description": "Hathor coreÂ is the official and reference client for operating a full node in Hathor Network.",
  "license": "Apache-2.0",
  "filepath": "hathor/transaction/scripts/execute.py",
  "instruction": "Copyright 2023 Hathor Labs Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "code": "#  Copyright 2023 Hathor Labs\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#  http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nfrom __future__ import annotations\n\nimport struct\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, NamedTuple, Optional, Union\n\nfrom hathor.transaction import BaseTransaction, Transaction, TxInput\nfrom hathor.transaction.exceptions import DataIndexError, FinalStackInvalid, InvalidScriptError, OutOfData\n\nif TYPE_CHECKING:\n    from hathor.transaction.scripts.opcode import OpcodesVersion\n\n\n@dataclass(slots=True, frozen=True, kw_only=True)\nclass ScriptExtras:\n    tx: Transaction\n    version: OpcodesVersion\n\n\n@dataclass(slots=True, frozen=True, kw_only=True)\nclass UtxoScriptExtras(ScriptExtras):\n    txin: TxInput\n    spent_tx: BaseTransaction\n\n\n# XXX: Because the Stack is a heterogeneous list of bytes and int, and some OPs only work for when the stack has some\n#      or the other type, there are many places that require an assert to prevent the wrong type from being used,\n#      alternatives include: 1. only using `list[bytes]` and operations that work on `int` to build them from `bytes`,\n#      2. using `bytearray` instead of `list[...]` and using type codes on the stack or at least value sizes on the\n#      stack and OPs should use the extra info accordingly 3. using some \"in stack error\" at least custom exceptions\n#      for signaling that an OP was applied on a wrongly typed stack.\nStack = list[Union[bytes, int, str]]\n\n\nclass OpcodePosition(NamedTuple):\n    opcode: int\n    position: int\n\n\ndef execute_eval(data: bytes, log: list[str], extras: ScriptExtras) -> None:\n    \"\"\" Execute eval from data executing opcode methods\n\n        :param data: data to be evaluated that contains data and opcodes\n        :type data: bytes\n\n        :param log: list of log messages\n        :type log: list[str]\n\n        :param extras: namedtuple with extra fields\n        :type extras: :py:class:`hathor.transaction.scripts.ScriptExtras`\n\n        :raises ScriptError: case opcode is not found\n        :raises FinalStackInvalid: case the evaluation fails\n    \"\"\"\n    from hathor.transaction.scripts.opcode import Opcode, execute_op_code\n    from hathor.transaction.scripts.script_context import ScriptContext\n    stack: Stack = []\n    context = ScriptContext(stack=stack, logs=log, extras=extras)\n    data_len = len(data)\n    pos = 0\n    while pos < data_len:\n        opcode, pos = get_script_op(pos, data, stack)\n        if Opcode.is_pushdata(opcode):\n            continue\n\n        # this is an opcode manipulating the stack\n        execute_op_code(Opcode(opcode), context, extras.version)\n\n    evaluate_final_stack(stack, log)\n\n\ndef evaluate_final_stack(stack: Stack, log: list[str]) -> None:\n    \"\"\" Checks the final state of the stack.\n        It's valid if only has 1 value on stack and that value is 1 (true)\n    \"\"\"\n    if len(stack) == 0:\n        log.append('Empty Stack left')\n        raise FinalStackInvalid('\\n'.join(log))\n    if len(stack) > 1:\n        log.append('Stack left with more than one value')\n        raise FinalStackInvalid('\\n'.join(log))\n    # check if value left on stack is 1 (true)\n    if stack.pop() != 1:\n        # stack left with non-True value\n        log.append('Stack left with False value')\n        raise FinalStackInvalid('\\n'.join(log))\n\n\ndef script_eval(tx: Transaction, txin: TxInput, spent_tx: BaseTransaction, version: OpcodesVersion) -> None:\n    \"\"\"Evaluates the output script and input data according to\n    a very limited subset of Bitcoin's scripting language.\n\n    :param tx: the transaction being validated, the 'owner' of the input data\n    :type tx: :py:class:`hathor.transaction.Transaction`\n\n    :param txin: transaction input being evaluated\n    :type txin: :py:class:`hathor.transaction.TxInput`\n\n    :param spent_tx: the transaction referenced by the input\n    :type spent_tx: :py:class:`hathor.transaction.BaseTransaction`\n\n    :raises ScriptError: if script verification fails\n    \"\"\"\n    raw_script_eval(\n        input_data=txin.data,\n        output_script=spent_tx.outputs[txin.index].script,\n        extras=UtxoScriptExtras(tx=tx, txin=txin, spent_tx=spent_tx, version=version),\n    )\n\n\ndef raw_script_eval(*, input_data: bytes, output_script: bytes, extras: ScriptExtras) -> None:\n    log: list[str] = []\n\n    from hathor.transaction.scripts import MultiSig\n    if MultiSig.re_match.search(output_script):\n        # For MultiSig there are 2 executions:\n        # First we need to evaluate that redeem_script matches redeem_script_hash\n        # we can't use input_data + output_script because it will end with an invalid stack\n        # i.e. the signatures will still be on the stack after ouput_script is executed\n        redeem_script_pos = MultiSig.get_multisig_redeem_script_pos(input_data)\n        full_data = input_data[redeem_script_pos:] + output_script\n        execute_eval(full_data, log, extras)\n\n        # Second, we need to validate that the signatures on the input_data solves the redeem_script\n        # we pop and append the redeem_script to the input_data and execute it\n        multisig_data = MultiSig.get_multisig_data(input_data)\n        execute_eval(multisig_data, log, extras)\n    else:\n        # merge input_data and output_script\n        full_data = input_data + output_script\n        execute_eval(full_data, log, extras)\n\n\ndef decode_opn(opcode: int) -> int:\n    \"\"\" Decode integer opcode (OP_N) to its integer value\n\n        :param opcode: the opcode to convert\n        :type opcode: bytes\n\n        :raises InvalidScriptError: case opcode is not a valid OP_N\n\n        :return: int value for opcode param\n        :rtype: int\n    \"\"\"\n    from hathor.transaction.scripts import Opcode\n    int_val = opcode - Opcode.OP_0\n    if not (0 <= int_val <= 16):\n        raise InvalidScriptError('unknown opcode {}'.format(opcode))\n    return int_val\n\n\ndef get_script_op(pos: int, data: bytes, stack: Optional[Stack] = None) -> OpcodePosition:\n    \"\"\" Interpret opcode at `pos` and return the opcode and the position of the next opcode\n        if opcode is a pushdata, push extracted data to stack if there is a stack\n\n        :param pos: position of opcode to read\n        :type pos: int\n\n        :param data: script to be evaluated that contains data and opcodes\n        :type data: bytes\n\n        :param stack: stack to put any extracted data or None if not interested on the extracted data\n        :type stack: Union[Stack, None]\n\n        :raises OutOfData: when trying to read out of script\n        :raises InvalidScriptError: when opcode in `pos` is invalid\n\n        :return: extracted opcode at `pos` and position of next opcode on `data`\n        :rtype: OpcodePosition\n    \"\"\"\n    opcode = get_data_single_byte(pos, data)\n\n    # validate opcode\n    from hathor.transaction.scripts import Opcode\n    if not Opcode.is_valid_opcode(opcode):\n        raise InvalidScriptError('Invalid Opcode ({}) at position {} in {!r}'.format(opcode, pos, data))\n\n    to_append: Union[bytes, int, str]\n    if 1 <= opcode <= 75:\n        # pushdata: push up to 75 bytes on stack\n        pos += 1\n        to_append = get_data_bytes(pos, opcode, data)\n        pos += opcode\n        if stack is not None:\n            stack.append(to_append)\n    elif opcode == Opcode.OP_PUSHDATA1:\n        # pushdata1: push up to 255 bytes on stack\n        pos += 1\n        length = get_data_single_byte(pos, data)\n        pos += 1\n        to_append = get_data_bytes(pos, length, data)\n        pos += length\n        if stack is not None:\n            stack.append(to_append)\n    elif Opcode.OP_0 <= opcode <= Opcode.OP_16:\n        # OP_N: push and  integer (0 to 16) to stack\n        # OP_N in [OP_0, OP_16]\n        to_append = decode_opn(opcode)\n        pos += 1\n        if stack is not None:\n            stack.append(to_append)\n    else:\n        # if opcode is a function and not a pushdata, move pos to next byte (next opcode)\n        pos += 1\n\n    return OpcodePosition(opcode=opcode, position=pos)\n\n\ndef get_data_value(k: int, data: bytes) -> bytes:\n    \"\"\"Extracts the kth value from data.\n\n    data should be in the format value0:value1:value2:...:valueN. This last representation\n    is merely for understanding the logic. In practice, data will be a sequence of bytes,\n    with each value preceded by the length of such value.\n\n    # TODO allow values larger than 255 bytes (some logic similar to OP_PUSHDATA1?)\n\n    :param k: index of item to retrieve\n    :type k: int\n\n    :param data: data to get value from\n    :type data: bytes\n\n    :raises OutOfData: if data length to read is larger than what's available\n    :raises DataIndexError: index requested from data is not available\n    \"\"\"\n    data_len = len(data)\n    position = 0\n    iteration = 0\n    while position < data_len:\n        length = data[position]\n        if length == 0:\n            # TODO throw error\n            pass\n        position += 1\n        if (position + length) > len(data):\n            raise OutOfData('trying to read {} bytes starting at {}, available {}'.format(length, position, len(data)))\n        value = data[position:position + length]\n        if iteration == k:\n            return value\n        iteration += 1\n        position += length\n    raise DataIndexError\n\n\ndef binary_to_int(binary: bytes) -> int:\n    \"\"\"Receives a binary and transforms it to an integer\n\n    :param binary: value to convert\n    :type binary: bytes\n    \"\"\"\n    if len(binary) == 1:\n        _format = '!B'\n    elif len(binary) == 2:\n        _format = '!H'\n    elif len(binary) == 4:\n        _format = '!I'\n    elif len(binary) == 8:\n        _format = '!Q'\n    else:\n        raise struct.error\n\n    (value,) = struct.unpack(_format, binary)\n    return value\n\n\ndef get_data_bytes(position: int, length: int, data: bytes) -> bytes:\n    \"\"\" Extract `length` bytes from `data` starting at `position`\n\n        :param position: start position of bytes string to extract\n        :type position: int\n\n        :param length: len of bytes str to extract\n        :type length: int\n\n        :param data: script containing data to extract\n        :type data: bytes\n\n        :raises OutOfData: when trying to read out of script\n\n        :return: bytes string of extracted data\n        :rtype: bytes\n    \"\"\"\n    if not (0 < length <= len(data)):\n        raise OutOfData(\"length ({}) should be from 0 up to data length\".format(length))\n    if not (0 < position < len(data)):\n        raise OutOfData(\"position should be inside data\")\n    if (position+length) > len(data):\n        raise OutOfData('trying to read {} bytes starting at {}, available {}'.format(length, position, len(data)))\n    return data[position:position+length]\n\n\ndef get_data_single_byte(position: int, data: bytes) -> int:\n    \"\"\" Extract 1 byte from `data` at `position`\n\n        :param position: position of byte to extract\n        :type position: int\n\n        :param data: script containing data to extract\n        :type data: bytes\n\n        :raises OutOfData: when trying to read out of script\n\n        :return: extracted byte\n        :rtype: int\n    \"\"\"\n    if not (0 <= position < len(data)):\n        raise OutOfData(\"trying to read a byte at {} outside of data, available {}\".format(position, len(data)))\n    return data[position]\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}