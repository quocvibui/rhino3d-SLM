{
  "source_url": "https://github.com/felipeharker/alexandria-lab-scripting/blob/1771434a741c840da1d8ab008876e4866d6fecf3/alexandria-scripts/ghpython/cell_creator.py",
  "repo": "felipeharker/alexandria-lab-scripting",
  "repo_stars": 0,
  "repo_description": "python, c#, etc. script library for Alexandria Labs",
  "license": "unknown",
  "filepath": "alexandria-scripts/ghpython/cell_creator.py",
  "instruction": "ALEXANDRIA IO SPEC (standardized) Inputs: - PatternName (GH: Pattern) | str | Pattern keyword (square/tri/hex/weave/cairo) - PatternIndex (GH: Index) | int | Pattern fallback index - CountX (GH: X) | int | Cell count in X - CountY (GH: Y) | int | Cell count in Y - CellSize (GH: Size) | float | Base module size - OriginPt (GH: Origin) | Rhino.Geometry.Point3d | Grid origin point Outputs: - Cells (GH: Cells) | list[Rhino.Geometry.Polyline] | Closed cell boundaries - Edges (GH: Edges) | list[Rhino.Geometry.Line] | Unique undirected edges - Centers (GH: Centers) | list[Rhino.Geometry.Point3d] | Cell centroids - Info (GH: Info) | str | Status summary",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - PatternName (GH: Pattern) | str | Pattern keyword (square/tri/hex/weave/cairo)\n# - PatternIndex (GH: Index) | int | Pattern fallback index\n# - CountX (GH: X) | int | Cell count in X\n# - CountY (GH: Y) | int | Cell count in Y\n# - CellSize (GH: Size) | float | Base module size\n# - OriginPt (GH: Origin) | Rhino.Geometry.Point3d | Grid origin point\n# Outputs:\n# - Cells (GH: Cells) | list[Rhino.Geometry.Polyline] | Closed cell boundaries\n# - Edges (GH: Edges) | list[Rhino.Geometry.Line] | Unique undirected edges\n# - Centers (GH: Centers) | list[Rhino.Geometry.Point3d] | Cell centroids\n# - Info (GH: Info) | str | Status summary\n\n__author__ = \"FHarker\"\n__version__ = \"2025.10.01\"\n\n\"\"\"Pattern Library Browser (Slider-driven)\nInputs:\n    Pattern: optional text name: \"square\", \"tri\", \"hex\", \"weave\", \"cairo\"\n    Index: integer index (0-based) to select pattern\n    X: int, cells in X\n    Y: int, cells in Y\n    Size: float, base module size\n    Origin: Point3d, base origin\nOutputs:\n    Cells: list[Polyline], closed cell boundaries\n    Edges: list[Line], unique edges (undirected)\n    Centers: list[Point3d], cell centroids\n    Info: string summary\n\"\"\"\n\nimport Rhino\nfrom Rhino.Geometry import Point3d, Polyline, Line\nimport math\n\n# -------------------------\n# Utilities\n# -------------------------\n\ndef polyline_from_points(pts, close=True):\n    pl = Polyline(pts)\n    if close and pts and pts[0].DistanceTo(pts[-1]) > 1e-9:\n        pl.Add(pts[0])\n    return pl\n\ndef poly_center(pl):\n    \"\"\"Area centroid for closed polygon; falls back to average if degenerate.\"\"\"\n    pts = list(pl)\n    if len(pts) < 4:\n        return pts[0]\n    if pts[0].DistanceTo(pts[-1]) < 1e-9:\n        pts = pts[:-1]\n    A = 0.0\n    Cx = 0.0\n    Cy = 0.0\n    for i in range(len(pts)):\n        x0, y0 = pts[i].X, pts[i].Y\n        x1, y1 = pts[(i+1)%len(pts)].X, pts[(i+1)%len(pts)].Y\n        cross = x0*y1 - x1*y0\n        A  += cross\n        Cx += (x0 + x1)*cross\n        Cy += (y0 + y1)*cross\n    if abs(A) < 1e-12:\n        sx = sum(p.X for p in pts)/len(pts)\n        sy = sum(p.Y for p in pts)/len(pts)\n        return Point3d(sx, sy, pts[0].Z)\n    A *= 0.5\n    return Point3d(Cx/(6.0*A), Cy/(6.0*A), pts[0].Z)\n\ndef add_edge_unique(edge_set, a, b):\n    \"\"\"Store undirected edges uniquely using rounded coordinate keys.\"\"\"\n    key = lambda p: (round(p.X,6), round(p.Y,6), round(p.Z,6))\n    ka, kb = key(a), key(b)\n    k = (ka, kb) if ka <= kb else (kb, ka)\n    if k not in edge_set:\n        edge_set[k] = Line(a, b)\n\n# -------------------------\n# Pattern generators\n# -------------------------\n\ndef gen_square(X, Y, Size, Origin):\n    cells = []\n    ox, oy, oz = Origin.X, Origin.Y, Origin.Z\n    for j in range(Y):\n        for i in range(X):\n            x0 = ox + i*Size\n            y0 = oy + j*Size\n            pts = [\n                Point3d(x0,       y0,       oz),\n                Point3d(x0+Size,  y0,       oz),\n                Point3d(x0+Size,  y0+Size,  oz),\n                Point3d(x0,       y0+Size,  oz)\n            ]\n            cells.append(polyline_from_points(pts, True))\n    return cells\n\ndef gen_tri(X, Y, Size, Origin):\n    # Equilateral triangles from staggered rows\n    w = Size\n    h = Size * math.sqrt(3)/2.0\n    cells = []\n    ox, oy, oz = Origin.X, Origin.Y, Origin.Z\n    for r in range(Y):\n        xoff = (w/2.0) if (r % 2) else 0.0\n        for c in range(X):\n            x0 = ox + c*w + xoff\n            y0 = oy + r*h\n            pA = Point3d(x0,     y0,    oz)\n            pB = Point3d(x0+w/2, y0+h,  oz)\n            pC = Point3d(x0+w,   y0,    oz)\n            if (c + r) % 2 == 0:\n                cells.append(polyline_from_points([pA, pB, pC], True))\n            else:\n                cells.append(polyline_from_points([pA, Point3d(x0+w/2, y0-h, oz), pC], True))\n    return cells\n\ndef gen_hex(X, Y, Size, Origin):\n    # Pointy-top hex grid (side length = Size)\n    s = Size\n    w = math.sqrt(3)*s\n    h = 1.5*s\n    cells = []\n    ox, oy, oz = Origin.X, Origin.Y, Origin.Z\n\n    def hex_verts(cx, cy):\n        pts = []\n        for k in range(6):\n            ang = math.radians(60*k - 30)\n            pts.append(Point3d(cx + s*math.cos(ang), cy + s*math.sin(ang), oz))\n        return pts\n\n    for r in range(Y):\n        xoff = 0.0 if (r % 2 == 0) else w/2.0\n        for c in range(X):\n            cx = ox + c*w + xoff\n            cy = oy + r*h\n            cells.append(polyline_from_points(hex_verts(cx, cy), True))\n    return cells\n\ndef gen_weave(X, Y, Size, Origin, band_ratio=0.6):\n    # Basket weave strips (horizontal/vertical alternating by row)\n    t = max(0.05, min(0.95, band_ratio)) * Size\n    cells = []\n    ox, oy, oz = Origin.X, Origin.Y, Origin.Z\n    for j in range(Y):\n        for i in range(X):\n            x0 = ox + i*Size\n            y0 = oy + j*Size\n            if (j % 2) == 0:\n                ymid = y0 + 0.5*Size\n                pts = [\n                    Point3d(x0,        ymid - t/2, oz),\n                    Point3d(x0+Size,   ymid - t/2, oz),\n                    Point3d(x0+Size,   ymid + t/2, oz),\n                    Point3d(x0,        ymid + t/2, oz)\n                ]\n            else:\n                xmid = x0 + 0.5*Size\n                pts = [\n                    Point3d(xmid - t/2, y0,        oz),\n                    Point3d(xmid + t/2, y0,        oz),\n                    Point3d(xmid + t/2, y0+Size,   oz),\n                    Point3d(xmid - t/2, y0+Size,   oz)\n                ]\n            cells.append(polyline_from_points(pts, True))\n    return cells\n\ndef gen_cairo(X, Y, Size, Origin):\n    ox, oy, oz = Origin.X, Origin.Y, Origin.Z\n    s = Size\n    w = math.sqrt(3)*s     # horizontal pitch\n    h = 1.5*s              # vertical pitch\n    a = 0.5*s\n    b = 1.0*s\n\n    def cell(cx, cy, z):\n        p1 = Point3d(cx - a, cy - b, z)\n        p2 = Point3d(cx + a, cy - b, z)\n        p3 = Point3d(cx + b, cy,     z)\n        p4 = Point3d(cx,     cy + b, z)\n        p5 = Point3d(cx - b, cy,     z)\n        return Polyline([p1,p2,p3,p4,p5,p1])\n\n    cells = []\n    for r in range(Y):\n        xoff = 0.0 if (r % 2 == 0) else w/2.0\n        for c in range(X):\n            cx = ox + c*w + xoff\n            cy = oy + r*h\n            cells.append(cell(cx, cy, oz))\n    return cells\n\n# -------------------------\n# Registry\n# -------------------------\n\ndef registry_ordered():\n    \"\"\"Ordered pattern list: (key, factory) tuples in stable UI order.\"\"\"\n    return [\n        (\"square\", lambda X,Y,S,O: gen_square(X,Y,S,O)),\n        (\"tri\",    lambda X,Y,S,O: gen_tri(X,Y,S,O)),\n        (\"hex\",    lambda X,Y,S,O: gen_hex(X,Y,S,O)),\n        (\"weave\",  lambda X,Y,S,O: gen_weave(X,Y,S,O,band_ratio=0.6)),\n        (\"cairo\",  lambda X,Y,S,O: gen_cairo(X,Y,S,O)),\n    ]\n\ndef registry_dict():\n    return {k:f for k,f in registry_ordered()}\n\n# -------------------------\n# Main\n# -------------------------\n\n# Defaults\nif X is None or X < 1: X = 10\nif Y is None or Y < 1: Y = 10\nif Size is None or Size <= 0: Size = 1.0\nif Origin is None: Origin = Point3d(0,0,0)\n\nordered = registry_ordered()\nreg = registry_dict()\n\n# Choose by Index if available, else by Pattern text\nidx_in = locals().get('Index', None)\nif idx_in is not None:\n    try:\n        i = int(idx_in)\n    except:\n        i = 0\n    if len(ordered) == 0:\n        raise Exception(\"Registry is empty.\")\n    # Clamp to valid range (change to modulo if wrap-around preferred)\n    if i < 0: i = 0\n    if i >= len(ordered): i = len(ordered)-1\n    name = ordered[i][0]\nelse:\n    token = Pattern or \"square\"\n    try:\n        name = str(token).strip().lower()\n    except:\n        name = \"square\"\n\nif name not in reg:\n    name = \"square\"\n\n# Generate cells\nCells = reg[name](X, Y, Size, Origin)\n\n# Centers & unique edges\nCenters = [poly_center(pl) for pl in Cells]\nedge_dict = {}\nfor pl in Cells:\n    pts = list(pl)\n    if len(pts) < 2: continue\n    if pts[0].DistanceTo(pts[-1]) > 1e-9:\n        pts.append(pts[0])\n    for j in range(len(pts)-1):\n        add_edge_unique(edge_dict, pts[j], pts[j+1])\nEdges = list(edge_dict.values())\n\n# Report\nidx_lookup = {k:i for i,(k,_) in enumerate(ordered)}\nidx = idx_lookup.get(name, -1)\nInfo = \"Index: {} | Pattern: {} | Cells: {} | Edges: {} | Size: {} | Grid: {}x{}\".format(\n    idx, name, len(Cells), len(Edges), round(Size,3), X, Y\n)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}