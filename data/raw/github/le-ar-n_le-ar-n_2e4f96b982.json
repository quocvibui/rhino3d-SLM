{
  "source_url": "https://github.com/le-ar-n/le-ar-n/blob/64600ee3bbe7e42f87f28442923b216cc565cf24/code/02_geometry/libraries/algorithms/random_walk/random_walk_from_image_mult.py",
  "repo": "le-ar-n/le-ar-n",
  "repo_stars": 9,
  "repo_description": null,
  "license": "unknown",
  "filepath": "code/02_geometry/libraries/algorithms/random_walk/random_walk_from_image_mult.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 03.10.2016\n\n@author: kathrind\n\n'''\n\nimport math\nimport random as rnd\nimport ghpythonlib.components as ghcomp\nimport Rhino.Geometry as rg\nfrom libraries.useful import clamp, map_range\nfrom libraries.geometry.vector import get_vector_sum\nfrom libraries.useful.color import convert_rgb_to_grey\n\n\n#===============================================================================\nclass RandomWalkImg:\n\n    #===========================================================================\n    def __init__(self, image_file, step, black_value, max_dist_to_next_pt, num_init_walks = 10, scale_factor = 1, sources = []):\n        \n        if not len(sources):\n            self.load_image(image_file)\n            self.scale(scale_factor)\n            \n            # generate random points with varying density based on the image file\n            self.sources = self.generate_random_points_from_image(step, black_value)\n        else:\n            self.sources = sources\n        \n        self.walks = self.init_walks(num_init_walks)\n        self.dead_walks = []\n        \n        self.max_dist_to_next_pt = max_dist_to_next_pt\n        \n    def init_walks(self, num_init_walks):\n        \n        walks = []\n        for i in range(num_init_walks):\n            init_pt = self.sources.pop(rnd.randrange(0, len(self.sources)))\n            walk = [init_pt] #array of pts along walk\n            walks.append(walk)\n        return walks\n            \n    #===========================================================================\n    def load_image(self, image_file):\n        self.cmesh = ghcomp.ImportImage(image_file)\n        bb = self.cmesh.GetBoundingBox(rg.Plane.WorldXY)\n        self.width = bb.Max.X\n        self.height = bb.Max.Y\n        self.point_cloud = rg.PointCloud(self.cmesh.Vertices.ToPoint3dArray())\n\n    #===========================================================================\n    def scale(self, factor):\n        S = rg.Transform.Scale(rg.Plane.WorldXY, factor, factor, factor)\n        self.cmesh.Transform(S)\n        self.point_cloud.Transform(S)\n        self.width *= factor\n        self.height *= factor\n    \n    #===========================================================================   \n    def get_grey_value(self, x, y):     \n        point = rg.Point3d(x, y, 0)\n        color_rgb = self.cmesh.VertexColors[self.point_cloud.ClosestPoint(point)]\n        grey = convert_rgb_to_grey(color_rgb.R, color_rgb.G, color_rgb.B)   \n        grey = clamp(grey, 0, 255)\n        return grey\n    \n    #===========================================================================\n    def generate_random_points_from_image(self, step, black_value):\n        '''Read pixel values from an image and according to the grey value in every pixel, create random \n        points. The size is adjustable with 'step' and the amount of points in black with 'black_value'.'''\n\n        random_points = []\n\n        for x in range(int(self.width / float(step))):\n            for y in range(int(self.height / float(step))): \n                grey = self.get_grey_value(x*step, y*step)\n                amount = int(map_range(grey, 0, 255, black_value, 0))\n                for i in range(amount):\n                    rndx = x*step + rnd.uniform(-1, 1)*step\n                    rndy = y*step + rnd.uniform(-1, 1)*step\n                    random_points.append(rg.Point3d(rndx, rndy, 0))\n        \n        return random_points\n     \n    #===========================================================================\n    def min_distance(self, s, others):\n        distances = [s.DistanceTo(o) for o in others]\n        min_distance = min(distances)\n        other = others[distances.index(min_distance)]\n        return min_distance, other\n        \n    #===========================================================================\n    def step(self):\n        \n        if len(self.sources):\n            new_walks = []\n            walk_indices_to_delete = []\n            for i, walk in enumerate(self.walks):\n    \n                current_pt = walk[-1]\n                \n                # now find the closest point form the sources, append it to the walk, and pop it from the sources\n                min_dist, nex_pt = self.min_distance(current_pt, self.sources)\n    \n                \n                if min_dist > self.max_dist_to_next_pt:\n                    nex_pt = self.sources.pop(rnd.randrange(0, len(self.sources)))\n                    new_walks.append([nex_pt])\n                    walk_indices_to_delete.append(i)\n                else:\n                    self.sources.remove(nex_pt)\n                    walk.append(nex_pt)\n            \n            if len(new_walks):\n                for i, idx in enumerate(walk_indices_to_delete):\n                    dead_walk = self.walks.pop(idx)\n                    if len(dead_walk) > 1:\n                        self.dead_walks.append(dead_walk)\n                    self.walks.append(new_walks[i])\n                        \n        else:\n            pass\n            ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}