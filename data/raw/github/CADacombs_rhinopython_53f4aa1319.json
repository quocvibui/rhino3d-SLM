{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_Faces_Sliver.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_Faces_Sliver.py",
  "instruction": "This script finds faces whose edge-edge curve deviation is <= an input value.\r\n\r\nFor faces with short edges, their breps often require more repair, e.g., merging edges in adjacent faces.",
  "code": "\"\"\"\r\nThis script finds faces whose edge-edge curve deviation is <= an input value.\r\n\r\nFor faces with short edges, their breps often require more repair, e.g., merging edges in adjacent faces.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160704: Created starting with FindShortEdges.py.\r\n...\r\n210519: Now will find faces that have all short non-seam edges.\r\n210526: Trialing another quick select value.\r\n210630: Added progress status of faces processed.\r\n220420: Repaired for Rhino 7+ due to a RhinoCommon 7.17 script-breaking change.\r\n220817: Modified an option default value.\r\n220818: Modified options and main routine.\r\n220915: Replaced edge count option with another option.\r\n221214: Bug fix in options.\r\n230405: Modified an option default value.\r\n230826, 0915: Modified an option default value.\r\n240402: Added an option to skip short edges in deviation checks.\r\n240526, 250324: Modified an option default value.\r\n250325: Added the option where the MaxSliverWidth value is also used for the MaxShortEdgeLength.\r\n250514: Disabled check of single-edge face since the GetDistanceBetweenCurves doesn't always report correctly.\r\n        Modified available command options per settings of other options.\r\n250916,24: Modified some option default values.\r\n251008-09: Added an option to define the minimum length of an edge to include for faces to skip. Modified some option default values.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrepObject\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fMaxSliverWidth'; keys.append(key)\r\n    values[key] = 2.0 * sc.doc.ModelAbsoluteTolerance # 1.8 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bSkipFacesWithShortEdges'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'FacesWithShortEdges'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Include', 'Skip')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSkipSliverCheckOfShortEdges'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'CheckDevsOfShortEdges'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Include', 'Skip')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUseSliverTolForMaxShortEdgeLengthTol'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'UseSliverTolForMaxShortLength'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fMaxEdgeLengthConsideredShort'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fIgnoreEdgesBelowThisLength'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEntireFaceMustBeASliver'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fMaxSliverWidth':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fMaxEdgeLengthConsideredShort':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fIgnoreEdgesBelowThisLength':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getAllNormalBreps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.NormalObjects = True\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.IncludeLights = False\r\n    oes.IncludeGrips = False\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('fMaxSliverWidth')\r\n        key = 'Tenth'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'Half'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'MT'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'Double'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'TenX'; idxs_Opt[key] = go.AddOption(key)\r\n        addOption('bSkipFacesWithShortEdges')\r\n        if not Opts.values['bSkipFacesWithShortEdges']:\r\n            addOption('bSkipSliverCheckOfShortEdges')\r\n        if Opts.values['bSkipFacesWithShortEdges'] or Opts.values['bSkipSliverCheckOfShortEdges']:\r\n            addOption('bUseSliverTolForMaxShortEdgeLengthTol')\r\n            if not Opts.values['bUseSliverTolForMaxShortEdgeLengthTol']:\r\n                addOption('fMaxEdgeLengthConsideredShort')\r\n            addOption('fIgnoreEdgesBelowThisLength')\r\n        addOption('bEntireFaceMustBeASliver')\r\n        addOption('bExtract')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return getAllNormalBreps()\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['Tenth']:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = 0.1 * Opts.riOpts['fMaxSliverWidth'].CurrentValue\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['Half']:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = 0.5 * Opts.riOpts['fMaxSliverWidth'].CurrentValue\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['MT']:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['Double']:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = 2.0 * Opts.riOpts['fMaxSliverWidth'].CurrentValue\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['TenX']:\r\n            key = 'fMaxSliverWidth'\r\n            Opts.riOpts[key].CurrentValue = 10.0 * Opts.riOpts['fMaxSliverWidth'].CurrentValue\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _indexPairsOfOverlappingCurves(rgCrvs, fMaxSliverWidth, bEntireFaceMustBeASliver):\r\n\r\n    idx_rgCrvs_OverlapPairs = []\r\n    #fOverlap_Face_Min = None\r\n    fOverlap_Face_MaxBelowTol = None\r\n\r\n    if not rgCrvs:\r\n        raise ValueError(\"Curve set has no curves!\")\r\n\r\n    # 180702: Added.\r\n    for rgC in rgCrvs:\r\n        if not rgC.IsValid:\r\n            print(\"Warning: Curve is invalid, so this group of curves will be skipped because rg.Curve.GetDistancesBetweenCurves may hang.\")\r\n            return\r\n\r\n    if len(rgCrvs) == 1:\r\n        # TODO: Determine a better routine for single edge faces. GetDistancesBetweenCurves doesn't always work well.\r\n        return\r\n        \r\n        rgC_In = rgCrvs[0]\r\n        \r\n        tMidLength = rgC_In.DivideByCount(\r\n            segmentCount=2,\r\n            includeEnds=False)[0]\r\n        \r\n        rgC_A = rgC_In.Trim(t0=rgC_In.Domain.T0, t1=tMidLength)\r\n        rgC_B = rgC_In.Trim(t0=tMidLength, t1=rgC_In.Domain.T1)\r\n        # tMidLength was rgC_In.Domain.Mid\r\n        rvs = rg.Curve.GetDistancesBetweenCurves(\r\n            rgC_A,\r\n            rgC_B,\r\n            tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n        if not rvs[0]:\r\n            return\r\n        \r\n        fOverlap_Max = rvs[1]\r\n        sc.doc.Objects.AddCurve(rgC_A)\r\n        sc.doc.Objects.AddCurve(rgC_B)\r\n        return\r\n        sc.doc.Objects.AddPoint(rgC_In.PointAt(tMidLength))\r\n        sc.doc.Objects.AddLine(rgC_A.PointAt(rvs[2]), rgC_B.PointAt(rvs[3])); sc.doc.Views.Redraw()\r\n        fOverlap_Min = rvs[4]\r\n        rgC_A.Dispose()\r\n        rgC_B.Dispose()\r\n        if fOverlap_Max > fMaxSliverWidth:\r\n            return\r\n        \r\n        return (0, 0), fOverlap_Max\r\n\r\n    iCt_Cs = len(rgCrvs)\r\n\r\n    fOverlap_Maxs = []\r\n    fOverlap_Maxs_Sliver = []\r\n\r\n    for iE_A in xrange(iCt_Cs):\r\n        rgC_A = rgCrvs[iE_A]\r\n        for iE_B in xrange(iE_A+1, iCt_Cs):\r\n            rgC_B = rgCrvs[iE_B]\r\n            rc = rg.Curve.GetDistancesBetweenCurves(\r\n                rgC_A,\r\n                rgC_B,\r\n                tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n            if not rc[0]:\r\n                return\r\n\r\n            fOverlap_Max = rc[1]\r\n            fOverlap_Maxs.append(fOverlap_Max)\r\n            fOverlap_Min = rc[4]\r\n            if fOverlap_Max <= fMaxSliverWidth:\r\n                idx_rgCrvs_OverlapPairs.append((iE_A, iE_B))\r\n#                    if fOverlap_Face_Min is None or fOverlap_Min < fOverlap_Face_Min:\r\n#                        fOverlap_Face_Min = fOverlap_Min\r\n                fOverlap_Maxs_Sliver.append(fOverlap_Max)\r\n                #if fOverlap_Face_MaxBelowTol is None or fOverlap_Max > fOverlap_Face_MaxBelowTol:\r\n                #    fOverlap_Face_MaxBelowTol = fOverlap_Max\r\n            elif bEntireFaceMustBeASliver:\r\n                # Skip any face with an overlap larger than fMaxSliverWidth.\r\n                return\r\n\r\n    return idx_rgCrvs_OverlapPairs, max(fOverlap_Maxs_Sliver)\r\n\r\n\r\ndef getFaces(rgBrep, fMaxSliverWidth, bSkipFacesWithShortEdges, bSkipSliverCheckOfShortEdges, fMaxEdgeLengthConsideredShort, fIgnoreEdgesBelowThisLength, bEntireFaceMustBeASliver, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Search all faces of brep for slivers.\r\n\r\n    Parameters:\r\n        rgBrep\r\n        fMaxSliverWidth\r\n        bSkipFacesWithShortEdges\r\n        bSkipSliverCheckOfShortEdges\r\n        fMaxEdgeLengthConsideredShort\r\n        fIgnoreEdgesBelowThisLength\r\n        bEntireFaceMustBeASliver\r\n        bEcho\r\n        bDebug\r\n\r\n    Returns:\r\n        sorted(idxs_rgFaces_Pass), nOverlapPairCt, fOverlap_Brep_MaxBelowTol\r\n        Or None on error.\r\n    \"\"\"\r\n\r\n\r\n    rgB = rgBrep\r\n\r\n    if fMaxSliverWidth == None:\r\n        fMaxSliverWidth = sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    # Previous sliver-finding routine.\r\n    #    def isFaceSliver(rgFace, fSliverMaximumTolerance=2.0*sc.doc.ModelAbsoluteTolerance, bEcho=True):\r\n    #        \r\n    #        rgBrep_1F = rgFace.DuplicateFace(False)\r\n    #        # Use DuplicateNakedEdgeCurves instead of AdjacentEdges to skip seams.\r\n    #        rgCrvs = rgBrep_1F.DuplicateNakedEdgeCurves(True, True)\r\n    #        rgBrep_1F.Dispose()\r\n    #        \r\n    #        # Reject faces with number of edges exceeding 2.\r\n    #        if len(rgCrvs) != 2:\r\n    #            map(lambda x: x.Dispose(), rgCrvs)\r\n    #            return False\r\n    #        \r\n    #        rc = _indexPairsOfOverlappingCurves(rgCrvs, fSliverMaximumTolerance, bEntireFaceMustBeASliver=True)\r\n    #        map(lambda x: x.Dispose(), rgCrvs)\r\n    #        \r\n    #        if rc is None or len(rc[0]) == 0: return False\r\n    #        \r\n    #        return True\r\n\r\n\r\n    idxs_rgFaces_Pass = []\r\n    #fOverlap_Min_Brep = None\r\n    fOverlaps_Brep_MaxBelowTol = []\r\n    nOverlapPairCt = 0\r\n\r\n\r\n    iCt_Fs = rgBrep.Faces.Count\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*iCt_Fs,0)) for i in range(10)]\r\n\r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n\r\n\r\n    def getCrvsToCheck(rgF, bSkipFacesWithShortEdges, bSkipSliverCheckOfShortEdges, fMaxEdgeLengthConsideredShort, fIgnoreEdgesBelowThisLength):\r\n\r\n        #if not bSkipFacesWithShortEdges and not bSkipSliverCheckOfShortEdges:\r\n        #    return [rgF.Brep.Edges[i] for i in rgF.AdjacentEdges()]\r\n\r\n        rgEs_Out = []\r\n\r\n        for iE in rgF.AdjacentEdges():\r\n            rgE = rgF.Brep.Edges[iE]\r\n\r\n            # Skip seams.\r\n            if rgE.Valence == rg.EdgeAdjacency.Interior:\r\n                rgFaces_Adj = rgE.AdjacentFaces()\r\n                if rgFaces_Adj[0] == rgFaces_Adj[1]:\r\n                    continue\r\n\r\n            fLength = rgE.GetLength()\r\n\r\n            if fIgnoreEdgesBelowThisLength and (fLength < fIgnoreEdgesBelowThisLength):\r\n                continue\r\n            elif fMaxEdgeLengthConsideredShort and (fLength <= fMaxEdgeLengthConsideredShort):\r\n                if bSkipFacesWithShortEdges:\r\n                    return\r\n                if bSkipSliverCheckOfShortEdges:\r\n                    continue\r\n\r\n            rgEs_Out.append(rgE)\r\n\r\n        return rgEs_Out\r\n\r\n\r\n    for idxF in xrange(rgB.Faces.Count):\r\n        if iCt_Fs == 1:\r\n            pass\r\n        elif iCt_Fs < 100:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                sCmdPrompt0 +\r\n                \"  Analyzing {} of {} faces\".format(\r\n                    idxF+1, iCt_Fs))\r\n        elif idxF in idxs_AtTenths:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                sCmdPrompt0 +\r\n                \"  Analysis at {:d}% of {} faces ...\".format(\r\n                    int(100.0 * (idxF+1) / iCt_Fs), iCt_Fs))\r\n\r\n\r\n        rgF = rgB.Faces[idxF]\r\n\r\n        # Allowing single edge faces because they will be split and checked.\r\n\r\n\r\n        rgCrvs = getCrvsToCheck(rgF, bSkipFacesWithShortEdges, bSkipSliverCheckOfShortEdges, fMaxEdgeLengthConsideredShort, fIgnoreEdgesBelowThisLength)\r\n\r\n        if not rgCrvs:\r\n            continue\r\n\r\n        if len(rgCrvs) == 0:\r\n            # All short non-seam edges?\r\n            idxs_rgFaces_Pass.append(rgF.FaceIndex)\r\n            continue\r\n\r\n        rc = _indexPairsOfOverlappingCurves(rgCrvs, fMaxSliverWidth, bEntireFaceMustBeASliver)\r\n        if rc is None or len(rc[0]) == 0:\r\n            continue\r\n\r\n        idx_rgCrvs_OverlapPairs, fOverlap_Face_MaxBelowTol = rc\r\n        \r\n        idxs_rgFaces_Pass.append(rgF.FaceIndex)\r\n        \r\n        nOverlapPairCt += len(idx_rgCrvs_OverlapPairs)\r\n        \r\n        fOverlaps_Brep_MaxBelowTol.append(fOverlap_Face_MaxBelowTol)\r\n        \r\n        #        if fOverlap_Min_Brep is None or fOverlap_Face_Min < fOverlap_Min_Brep:\r\n        #            fOverlap_Min_Brep = fOverlap_Face_Min\r\n        #        if fOverlap_Brep_MaxBelowTol is None or fOverlap_Face_MaxBelowTol > fOverlap_Brep_MaxBelowTol:\r\n        #            fOverlap_Brep_MaxBelowTol = fOverlap_Face_MaxBelowTol\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n    return sorted(idxs_rgFaces_Pass), nOverlapPairCt, fOverlaps_Brep_MaxBelowTol\r\n\r\n\r\ndef processBrepObjects(rhBreps0, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBreps0\r\n        fMaxSliverWidth,\r\n        bSkipFacesWithShortEdges,\r\n        bSkipSliverCheckOfShortEdges,\r\n        fMaxEdgeLengthConsideredShort,\r\n        fIgnoreEdgesBelowThisLength,\r\n        bEntireFaceMustBeASliver,\r\n        bExtract,\r\n        bEcho,\r\n        bDebug,\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fMaxSliverWidth = getOpt('fMaxSliverWidth')\r\n    bSkipFacesWithShortEdges = getOpt('bSkipFacesWithShortEdges')\r\n    bSkipSliverCheckOfShortEdges = getOpt('bSkipSliverCheckOfShortEdges')\r\n    bUseSliverTolForMaxShortEdgeLengthTol = getOpt('bUseSliverTolForMaxShortEdgeLengthTol')\r\n    fMaxEdgeLengthConsideredShort = getOpt('fMaxEdgeLengthConsideredShort')\r\n    fIgnoreEdgesBelowThisLength = getOpt('fIgnoreEdgesBelowThisLength')\r\n    bEntireFaceMustBeASliver = getOpt('bEntireFaceMustBeASliver')\r\n    bExtract = getOpt('bExtract')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n    if bUseSliverTolForMaxShortEdgeLengthTol:\r\n        fMaxEdgeLengthConsideredShort = fMaxSliverWidth\r\n\r\n    fOverlap_Min_All = fOverlap_Max_All = None\r\n    fOverlaps_BelowTol_AllBreps = []\r\n    gBreps_Extracted_All = [] # Accumulation of duplicated faces (breps)\r\n    iOverlap_ct_total = 0\r\n    \r\n    len_rhBs0 = len(rhBreps0)\r\n    idxs_AtTenths = [int(round(0.1*i*len(rhBreps0),0)) for i in range(10)]\r\n\r\n\r\n    # escape_test is sometimes called when this script is called by a (Rhino Python Editor: New -) Command.\r\n    if sc.escape_test(throw_exception=False, reset=True):\r\n        print(\"sc.escape_test was triggered.\")\r\n\r\n\r\n    iCt_FacesSel_All = 0\r\n\r\n    for iB, rhBrep0 in enumerate(rhBreps0):\r\n        if sc.escape_test(False):\r\n            print(\"Searching interrupted by user.\")\r\n            return\r\n        \r\n        if len_rhBs0 == 1:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analyzing brep ...\")\r\n        elif len_rhBs0 <= 12:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analyzing {} of {} breps\".format(\r\n                iB+1, len_rhBs0))\r\n        elif iB in idxs_AtTenths:\r\n            # May be many monoface breps.\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analysis at {:d}% of {} breps ...\".format(\r\n                int(100.0 * (iB+1) / len_rhBs0), len_rhBs0))\r\n\r\n        # Obtain GUID, RhinoObject, and geometry.\r\n        if isinstance(rhBrep0, Guid):\r\n            gBrep0 = rhBrep0\r\n            rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep0)\r\n            if rdBrep0 is None: continue\r\n        elif isinstance(rhBrep0, rd.ObjRef):\r\n            gBrep0 = rhBrep0.ObjectId\r\n            rdBrep0 = rhBrep0.Object()\r\n        elif isinstance(rhBrep0, rd.RhinoObject):\r\n            rdBrep0 = rhBrep0\r\n            gBrep0 = rhBrep0.Id\r\n        else:\r\n            print(\"GUID could not be obtained.\")\r\n            continue\r\n        \r\n        rgBrep0 = rdBrep0.Geometry\r\n        if rgBrep0 is None or (rgBrep0.IsSolid and rgBrep0.IsSurface): continue\r\n        if not rgBrep0.IsValid and bEcho:\r\n            print(\"Brep {} is invalid and will be skipped because Curve.GetDistancesBetweenCurves may hang.\".format(gBrep0))\r\n            continue\r\n        \r\n        rc = getFaces(\r\n            rgBrep=rgBrep0,\r\n            fMaxSliverWidth=fMaxSliverWidth,\r\n            bSkipFacesWithShortEdges=bSkipFacesWithShortEdges,\r\n            bSkipSliverCheckOfShortEdges=bSkipSliverCheckOfShortEdges,\r\n            fMaxEdgeLengthConsideredShort=fMaxEdgeLengthConsideredShort,\r\n            fIgnoreEdgesBelowThisLength=fIgnoreEdgesBelowThisLength,\r\n            bEntireFaceMustBeASliver=bEntireFaceMustBeASliver,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n        rgBrep0.Dispose()\r\n        if rc is None: continue\r\n\r\n        (\r\n            idxs_rgFaces_Pass,\r\n            iCt_Overlaps_1Brep,\r\n            fOverlaps_MaxBelowTol_1Brep,\r\n            ) = rc\r\n    \r\n        if not idxs_rgFaces_Pass: continue\r\n\r\n        if bExtract:\r\n            rc = xBrepObject.extractFaces(\r\n                    gBrep0,\r\n                    idxs_rgFaces_Pass,\r\n                    bCurrentLayer=False,\r\n                    bByLayerColor=False,\r\n                    bAddOnlyMonofaces=True,\r\n                    bEcho=False,\r\n                    bDebug=bDebug)\r\n            if rc is None: continue\r\n            gBreps_Extracted_All.extend(rc[0])\r\n        else:\r\n            iCt_FacesSel = xBrepObject.selectFaces(\r\n                    gBrep0,\r\n                    idxs_rgFaces_Pass,\r\n                    bEcho=bEcho)\r\n            iCt_FacesSel_All += iCt_FacesSel\r\n        \r\n        iOverlap_ct_total += iCt_Overlaps_1Brep\r\n        \r\n        fOverlaps_BelowTol_AllBreps.extend(fOverlaps_MaxBelowTol_1Brep)\r\n        \r\n        #        if fOverlap_Min_All is None or fOverlap_Min_ThisBrep < fOverlap_Min_All:\r\n        #            fOverlap_Min_All = fOverlap_Min_ThisBrep\r\n        #        if fOverlap_Max_All is None or fOverlaps_MaxBelowTol_1Brep > fOverlap_Max_All:\r\n        #            fOverlap_Max_All = fOverlaps_MaxBelowTol_1Brep\r\n\r\n\r\n    if iOverlap_ct_total == 0:\r\n        print(\"No completely overlapping edges found.\")\r\n        return\r\n\r\n\r\n    print(\"{} completely overlapping edge(s) found.\".format(iOverlap_ct_total))\r\n\r\n    if bExtract:\r\n        if len(gBreps_Extracted_All) > 1:\r\n            sc.doc.Objects.Select(List[Guid](gBreps_Extracted_All))\r\n        else:\r\n            sc.doc.Objects.Select(gBreps_Extracted_All[0])\r\n        rdBreps1_Selected = [rdObj for rdObj in\r\n                sc.doc.Objects.GetSelectedObjects(False, False)]\r\n        print(\"{} monoface brep(s) selected.\".format(len(rdBreps1_Selected)))\r\n    elif iCt_FacesSel_All:\r\n        print(\"{} face(s) selected.\".format(iCt_FacesSel_All))\r\n\r\n    if len(fOverlaps_BelowTol_AllBreps) == 1:\r\n        print(\"Width of sliver: {0:.{1}f}\".format(\r\n            min(fOverlaps_BelowTol_AllBreps),\r\n            sc.doc.ModelDistanceDisplayPrecision+1))\r\n    else:\r\n        print(\"Range of widths of slivers:\")\r\n        print(\" [{0:.{2}f}, {1:.{2}f}]\".format(\r\n            min(fOverlaps_BelowTol_AllBreps),\r\n            max(fOverlaps_BelowTol_AllBreps),\r\n            sc.doc.ModelDistanceDisplayPrecision+1))\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fMaxSliverWidth = Opts.values['fMaxSliverWidth']\r\n    bSkipFacesWithShortEdges = Opts.values['bSkipFacesWithShortEdges']\r\n    bSkipSliverCheckOfShortEdges = Opts.values['bSkipSliverCheckOfShortEdges']\r\n    bUseSliverTolForMaxShortEdgeLengthTol = Opts.values['bUseSliverTolForMaxShortEdgeLengthTol']\r\n    fMaxEdgeLengthConsideredShort = Opts.values['fMaxEdgeLengthConsideredShort'] if Opts.values['bSkipFacesWithShortEdges'] else 0.0\r\n    fIgnoreEdgesBelowThisLength = Opts.values['fIgnoreEdgesBelowThisLength']\r\n    bEntireFaceMustBeASliver = Opts.values['bEntireFaceMustBeASliver']\r\n    bExtract = Opts.values['bExtract']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    processBrepObjects(\r\n        objrefs,\r\n        fMaxSliverWidth=fMaxSliverWidth,\r\n        bSkipFacesWithShortEdges=bSkipFacesWithShortEdges,\r\n        bSkipSliverCheckOfShortEdges=bSkipSliverCheckOfShortEdges,\r\n        fMaxEdgeLengthConsideredShort=fMaxSliverWidth if bUseSliverTolForMaxShortEdgeLengthTol else fMaxEdgeLengthConsideredShort,\r\n        fIgnoreEdgesBelowThisLength=fIgnoreEdgesBelowThisLength,\r\n        bEntireFaceMustBeASliver=bEntireFaceMustBeASliver,\r\n        bExtract=bExtract,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}