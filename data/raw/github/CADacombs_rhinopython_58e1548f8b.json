{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_removeMultipleKnots.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_removeMultipleKnots.py",
  "instruction": "NurbsSurfaceKnotList.RemoveMultipleKnots appears to not remove multiplicities\r\nfrom full (== degree) multiplicities.\r\n_RemoveMultiKnot does the same (at least up through version 7.25).",
  "code": "\"\"\"\r\nNurbsSurfaceKnotList.RemoveMultipleKnots appears to not remove multiplicities\r\nfrom full (== degree) multiplicities.\r\n_RemoveMultiKnot does the same (at least up through version 7.25).\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n221224,26: WIP: Created, starting with another script.\r\n\r\nTODO: Filter out conical cross-section directions.\r\n      Add support for periodic surfaces.\r\n\"\"\"\r\n\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrep_getDistancesBetween2\r\nimport xBrepFace\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAllowBrepSelection'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'SelectionMode'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'FacesOnly', 'FacesAndBreps')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLimitDev'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSrfOnFail'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'AddSrfOnFail'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _sortBrepsAndFaces(objrefs):\r\n    \"\"\"\r\n    Parameters:\r\n        list(objrefs)\r\n    Returns:\r\n        list(Brep GUIDs)\r\n        list(lists(integers of Face indices) per brep)\r\n    \"\"\"\r\n        \r\n    gBs = []\r\n    rdBs = []\r\n    idxFs_perB = []\r\n    \r\n    for o in objrefs:\r\n        gB = o.ObjectId\r\n        rdB = o.Object()\r\n        rgB = o.Brep()\r\n\r\n        if not rgB.IsValid:\r\n            print(\"Brep {} is invalid.  Fix first.\".format(gB))\r\n            continue\r\n\r\n        idx_CompIdx = o.GeometryComponentIndex.Index\r\n        if idx_CompIdx == -1:\r\n            if gB in gBs:\r\n                idxFs_perB[gBs.index(gB)] = range(rgB.Faces.Count)\r\n            else:\r\n                gBs.append(gB)\r\n                rdBs.append(rdB)\r\n                idxFs_perB.append(range(rgB.Faces.Count))\r\n        else:\r\n            rgFace_Brep0 = o.Face()\r\n            if gB in gBs:\r\n                if rgFace_Brep0 in idxFs_perB[gBs.index(gB)]:\r\n                    continue\r\n                else:\r\n                    idxFs_perB[gBs.index(gB)].append(rgFace_Brep0.FaceIndex)\r\n            else:\r\n                gBs.append(gB)\r\n                rdBs.append(rdB)\r\n                idxFs_perB.append([rgFace_Brep0.FaceIndex])\r\n\r\n    return rdBs, idxFs_perB\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get BrepFaces with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select faces\")\r\n\r\n    go.SetCommandPromptDefault(\"All normal breps when none are selected\")\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    #go.SubObjectSelect = False\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        if Opts.values['bAllowBrepSelection']:\r\n            go.SetCommandPrompt(\"Select breps and/or faces\")\r\n            go.GeometryFilter = rd.ObjectType.Brep | rd.ObjectType.Curve\r\n        else:\r\n            go.SetCommandPrompt(\"Select faces\")\r\n            go.GeometryFilter = rd.ObjectType.Surface\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        go.AcceptNumber(Opts.values['bLimitDev'], acceptZero=Opts.values['bLimitDev'])\r\n\r\n        addOption('bAllowBrepSelection')\r\n        addOption('bLimitDev')\r\n        if Opts.values['bLimitDev']:\r\n            addOption('fDevTol')\r\n        addOption('bReplace')\r\n        if Opts.values['bReplace']:\r\n            addOption('bExtract')\r\n        addOption('bSrfOnFail')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return _sortBrepsAndFaces(objrefs)\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            oes = rd.ObjectEnumeratorSettings()\r\n            oes.NormalObjects = True\r\n            oes.LockedObjects = False\r\n            oes.IncludeLights = False\r\n            oes.IncludeGrips = False\r\n            oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n\r\n            rdBs = list(sc.doc.Objects.GetObjectList(oes))\r\n            go.Dispose()\r\n            if len(rdBs) == 0: return\r\n\r\n            return (\r\n                rdBs,\r\n                [[iF for iF in range(rdBs[iB].BrepGeometry.Faces.Count)]\r\n                for iB in range(len(rdBs))]\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            if Opts.values['bLimitDev']:\r\n                key = 'fDevTol'\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n            else:\r\n                continue\r\n\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef knotMultiplicityList(knots):\r\n    \"\"\"Returns a list.\"\"\"\r\n    i = 0\r\n    iMulties = []\r\n    fKnotTs_Unique = []\r\n    while i < knots.Count:\r\n        sc.escape_test()\r\n        knot = knots[i]\r\n        fKnotTs_Unique.append(knot)\r\n        iMulti = knots.KnotMultiplicity(index=i)\r\n        iMulties.append(iMulti)\r\n        #print(\"{} at {:.4f}\".format(iMulti, knot),\r\n        i += iMulti\r\n    return iMulties\r\n\r\n\r\ndef multiplicityRangeOfInteriorKnots(ns, iDir):\r\n    degree = ns.Degree(iDir)\r\n    knots = ns.KnotsV if iDir else ns.KnotsU\r\n    ms = []\r\n    iK = degree\r\n    while iK < knots.Count-degree:\r\n        sc.escape_test()\r\n        m = knots.KnotMultiplicity(iK)\r\n        ms.append(m)\r\n        iK += m\r\n    return ms\r\n\r\n\r\ndef removeMultipleKnots(ns_In, bDebug=False):\r\n    \"\"\"\r\n    This is a replacement for NurbsSurfaceKnotList.RemoveMultipleKnots,\r\n    also reducing full (== degree) multiplicities to 1.\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script only works in Rhino V6 and above.\")\r\n        return\r\n\r\n    if not isinstance(ns_In, rg.NurbsSurface):\r\n        if bDebug: print(\"{} skipped.\".format(ns_In.GetType().Name))\r\n        return\r\n\r\n    if ns_In.SpanCount(0) == 1 and ns_In.SpanCount(1) == 1:\r\n        if bDebug: print(\"No interior knots.\")\r\n        return\r\n\r\n    knots_In = ns_In.KnotsU, ns_In.KnotsV\r\n\r\n    ms_U = knotMultiplicityList(ns_In.KnotsU)\r\n    ms_V = knotMultiplicityList(ns_In.KnotsV)\r\n\r\n    if (\r\n        (len(ms_U[1:-1]) == 0 or max(ms_U[1:-1]) == 1) and\r\n        (len(ms_V[1:-1]) == 0 or max(ms_V[1:-1]) == 1)\r\n        ):\r\n        if bDebug: print(\"No interior knots with multiplicity above 1.\")\r\n        return\r\n\r\n    ns_Out = ns_In.Duplicate()\r\n\r\n    knots_Out = ns_Out.KnotsU, ns_Out.KnotsV\r\n\r\n    # https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Collections_NurbsSurfaceKnotList_RemoveKnots.htm\r\n    # Remove knots from the knot vector and adjusts the remaining control points to maintain surface position as closely as possible.\r\n    # The knots from Knots[index0] through Knots[index1 - 1] will be removed.\r\n\r\n    for iDir in (0,1):\r\n        knots = knots_Out[iDir]\r\n        degree = ns_Out.Degree(iDir)\r\n        iK = knots.Count - degree - 1\r\n        if bDebug: sEval = 'iK'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        while iK > degree:\r\n            sc.escape_test()\r\n            m = knots.KnotMultiplicity(iK)\r\n            if bDebug: sEval = 'm'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            index0 = iK - m + 1\r\n            index1 = iK\r\n            if bDebug: sEval = 'index0'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            if bDebug: sEval = 'index1'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            knots_Out[iDir].RemoveKnots(index0, index1)\r\n\r\n            if bDebug: sEval = 'ns_Out.KnotsU.Count'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            if bDebug: sEval = 'ns_Out.KnotsV.Count'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            iK -= m\r\n            if bDebug: sEval = 'iK'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    return ns_Out\r\n\r\n\r\ndef createSurface(ns_In, fDevTol, bDebug=False):\r\n    \"\"\"\r\n    Returns on success:\r\n        rg.NurbsSurface\r\n        float(surface deviation)\r\n        None\r\n    Returns on deviation fail:\r\n        None\r\n        float(surface deviation needed)\r\n        None\r\n    Returns on other fails:\r\n        None\r\n        None\r\n        str(Reason of failure)\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        raise Exception(\"This script only works in Rhino V6 and above.\")\r\n\r\n\r\n    if not isinstance(ns_In, rg.NurbsSurface):\r\n        return None, None, \"{} skipped.\".format(ns_In.GetType().Name)\r\n\r\n    if ns_In.SpanCount(0) == 1 and ns_In.SpanCount(1) == 1:\r\n        return None, None, \"NurbsSurface has no interior knots.\"\r\n\r\n    if bDebug:\r\n        sEval = 'ns_In.KnotsU.Count'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = 'ns_In.KnotsV.Count'; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    ms_U = knotMultiplicityList(ns_In.KnotsU)\r\n    ms_V = knotMultiplicityList(ns_In.KnotsV)\r\n\r\n    if (\r\n        (len(ms_U[1:-1]) == 0 or max(ms_U[1:-1]) == 1) and\r\n        (len(ms_V[1:-1]) == 0 or max(ms_V[1:-1]) == 1)\r\n        ):\r\n        return None, None, \"No interior knots with multiplicity above 1.\"\r\n\r\n\r\n    ns_Out = removeMultipleKnots(ns_In, bDebug)\r\n\r\n\r\n    rgMeshParams = rg.MeshingParameters.QualityRenderMesh\r\n\r\n    rc = xBrep_getDistancesBetween2.getDistancesBetweenBreps(\r\n        ns_In,\r\n        ns_Out,\r\n        rgMeshParams,\r\n        bCalcBrepIntersection=False)\r\n\r\n    if rc[0]:\r\n        rgSrf1_LastGood = ns_Out.Duplicate()\r\n        fDev = rc[1]\r\n\r\n\r\n    def getNurbsSurfaceChangeDescription(rgNurbsSrf1, rgNurbsSrf2):\r\n        s  = \"  Prop:I->O\"\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"Deg\",\r\n                rgNurbsSrf1.OrderU-1,\r\n                rgNurbsSrf2.OrderU-1,\r\n                rgNurbsSrf1.OrderV-1,\r\n                rgNurbsSrf2.OrderV-1,\r\n        )\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"PtCt\",\r\n                rgNurbsSrf1.Points.CountU,\r\n                rgNurbsSrf2.Points.CountU,\r\n                rgNurbsSrf1.Points.CountV,\r\n                rgNurbsSrf2.Points.CountV,\r\n        )\r\n        if Rhino.RhinoApp.ExeVersion >= 7:\r\n            s += \"  {}:({}->{})x({}->{})\".format(\r\n                    \"IsUniform\",\r\n                    str(isKnotVectorUniform(rgNurbsSrf1.KnotsU))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf2.KnotsU))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf1.KnotsV))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf2.KnotsV))[0],\r\n            )\r\n        s += \"  {}:{}->{}\".format(\r\n                \"IsRational\",\r\n                str(rgNurbsSrf1.IsRational)[0],\r\n                str(rgNurbsSrf2.IsRational)[0],\r\n        )\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"IsClosed\",\r\n                str(rgNurbsSrf1.IsClosed(0))[0],\r\n                str(rgNurbsSrf2.IsClosed(0))[0],\r\n                str(rgNurbsSrf1.IsClosed(1))[0],\r\n                str(rgNurbsSrf2.IsClosed(1))[0],\r\n        )\r\n        if (    rgNurbsSrf1.IsClosed(0) or rgNurbsSrf1.IsClosed(1) or\r\n                rgNurbsSrf2.IsClosed(0) or rgNurbsSrf2.IsClosed(1)\r\n        ):\r\n            s += \"  {}:{}->{}\".format(\r\n                    \"IsPeriodic\",\r\n                    str(rgNurbsSrf1.IsPeriodic)[0],\r\n                    str(rgNurbsSrf2.IsPeriodic)[0],\r\n            )\r\n        return s\r\n\r\n\r\n    if fDevTol is None or (fDev <= fDevTol):\r\n\r\n        if bDebug:\r\n            rgBrep_1F_Mod = rgBs_1F_Res[0]\r\n            s  = getNurbsSurfaceChangeDescription(ns_In, ns_Out)\r\n            s += \"  Deviation: {0:.2e}\".format(fDev)\r\n            print(s)\r\n\r\n        return ns_Out, fDev, None\r\n\r\n    ns_Out.Dispose()\r\n\r\n    return None, fDev, None\r\n\r\n\r\ndef addBrepOfSrf(rgSrf, bDebug=False):\r\n    gB_Out = sc.doc.Objects.AddSurface(rgSrf)\r\n    if bDebug:\r\n        if gB_Out.Guid != gB_Out.Empty:\r\n            print(\"Converted underlying surface was added.\")\r\n        else:\r\n            print(\"Converted underlying surface could not be added.\")\r\n\r\n\r\ndef create1FaceBrepWithNewSurface(rgFace_In, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgFace_In\r\n        fDevTol\r\n        bSrfOnFail\r\n        bDebug\r\n    Returns on success:\r\n        rg.Brep\r\n        float(surface deviation)\r\n        None\r\n    Returns on deviation fail:\r\n        None\r\n        float(surface deviation needed)\r\n        None\r\n    Returns on other fails:\r\n        None\r\n        None\r\n        str(Reason of failure)\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        raise Exception(\"This script only works in Rhino V6 and above.\")\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    bExtract = getOpt('bExtract')\r\n    bSrfOnFail = getOpt('bSrfOnFail')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rgSrf_In = rgFace_In.UnderlyingSurface()\r\n\r\n    if not isinstance(rgSrf_In, rg.NurbsSurface):\r\n        return None, None, \"Skipped {}.\".format(rgSrf_In.GetType().Name)\r\n\r\n\r\n    rc = createSurface(\r\n        rgSrf_In,\r\n        fDevTol,\r\n        bDebug=bDebug,\r\n        )\r\n    if rc[0] is None: return rc\r\n\r\n    ns_Res, fDev, sLog = rc\r\n\r\n    # Success in creating NurbsSurface.  Now, create correctly trimmed brep.\r\n    \r\n    rgB_1F_In = rgFace_In.DuplicateFace(duplicateMeshes=False)\r\n\r\n    rgB_1F_In.Faces[0].RebuildEdges(\r\n        tolerance=max((1e-6, 0.1*sc.doc.ModelAbsoluteTolerance)),\r\n        rebuildSharedEdges=True,\r\n        rebuildVertices=True)\r\n    #rgBrep0_1Face.Faces.ShrinkFaces()\r\n\r\n    if rgB_1F_In.IsSurface:\r\n        rgB_1F_In.Dispose()\r\n        rgB_1F_Out = ns_Res.ToBrep()\r\n        ns_Res.Dispose()\r\n        if not rgB_1F_Out.IsValid:\r\n            rgB_1F_Out.Dispose()\r\n            if bSrfOnFail: addBrepOfSrf(ns_Res, bDebug)\r\n            return None, None, \"Invalid brep geometry after ToBrep.\"\r\n        return rgB_1F_Out, fDev, None\r\n    \r\n    # Test areas before trimming.\r\n    fArea_Trimmed = rgB_1F_In.GetArea()\r\n    if fArea_Trimmed:\r\n        rgBrep_Untrimmed = rgB_1F_In.Faces[0].UnderlyingSurface().ToBrep()\r\n        fArea_Untrimmed = rgBrep_Untrimmed.GetArea()\r\n        rgBrep_Untrimmed.Dispose()\r\n        if fArea_Untrimmed:\r\n            if abs(fArea_Trimmed - fArea_Untrimmed) <= sc.doc.ModelAbsoluteTolerance**2:\r\n                rgB_1F_Out = ns_Res.ToBrep()\r\n                ns_Res.Dispose()\r\n                if not rgB_1F_Out.IsValid:\r\n                    rgB_1F_Out.Dispose()\r\n                    if bSrfOnFail: addBrepOfSrf(ns_Res, bDebug)\r\n                    return None, None, \"Invalid brep geometry after ToBrep.\"\r\n                return rgB_1F_Out, fDev, None\r\n\r\n    rgB_1F_Out = xBrepFace.retrimFace(\r\n            rgB_1F_In.Faces[0],\r\n            rgSrf_Replacement=ns_Res,\r\n            fSplitTol=1.0*sc.doc.ModelAbsoluteTolerance if fDevTol is None else fDevTol,\r\n            bDebug=bDebug\r\n    )\r\n    rgB_1F_In.Dispose()\r\n    ns_Res.Dispose()\r\n\r\n    if rgB_1F_Out is None:\r\n        if bSrfOnFail: addBrepOfSrf(ns_Res, bDebug)\r\n        return None, None, \"xBrepFace.createMonofaceBrep returned None.\"\r\n\r\n    if not rgB_1F_Out.IsValid:\r\n        rgB_1F_Out.Dispose()\r\n        if bSrfOnFail: addBrepOfSrf(ns_Res, bDebug)\r\n        return None, None, \"An invalid brep was skipped.\"\r\n\r\n    return rgB_1F_Out, fDev, None\r\n\r\n\r\ndef processBrepObject(rhBrep, idxFaces=None, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBrep: rd.BrepObject or GUID of brep.\r\n        idxFaces\r\n        fDevTol\r\n        bReplace\r\n        bExtract\r\n        bSrfOnFail\r\n        bEcho\r\n        bDebug\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        raise Exception(\"This script only works in Rhino V6 and above.\")\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fDevTol = getOpt('fDevTol')\r\n    bReplace = getOpt('bReplace')\r\n    bExtract = getOpt('bExtract')\r\n    bSrfOnFail = getOpt('bSrfOnFail')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def isKnotVectorUniform(knots):\r\n        return (\r\n            (knots.KnotStyle == rg.KnotStyle.Uniform) or\r\n            (knots.KnotStyle == rg.KnotStyle.QuasiUniform) or\r\n            (\r\n                (knots.KnotStyle == rg.KnotStyle.PiecewiseBezier) and\r\n                knots.Count == knots.KnotMultiplicity(0) * 2)\r\n            )\r\n\r\n\r\n    rgBs_1F_Res = []\r\n    idxsFs_Success = []\r\n    fDevs = []\r\n    fDevs_Needed = []\r\n    sLogs = []\r\n\r\n\r\n    if isinstance(rhBrep, rd.BrepObject):\r\n        rdB_In = rhBrep\r\n    else:\r\n        rdB_In = rs.coercerhinoobject(rhBrep)\r\n    rgB_In = rdB_In.BrepGeometry\r\n\r\n    sCmdPrompt_In = Rhino.RhinoApp.CommandPrompt\r\n    \r\n    idxs_AtTenths = [int(round(0.1*i*len(idxFaces),0)) for i in range(10)]\r\n    \r\n    for iF, idx_rgFace in enumerate(idxFaces):\r\n        if sc.escape_test(False):\r\n            raise Exception(\"Searching interrupted by user.\")\r\n\r\n        if iF in idxs_AtTenths:\r\n            s = sCmdPrompt_In + \", {:d}% of {} faces in current brep ...\".format(\r\n                int(100.0 * (iF+1) / len(idxFaces)), len(idxFaces))\r\n            \r\n            if bDebug:\r\n                print(s)\r\n            else:\r\n                Rhino.RhinoApp.SetCommandPrompt(s)\r\n\r\n        rgFace_In = rgB_In.Faces[idx_rgFace]\r\n\r\n\r\n        rc = create1FaceBrepWithNewSurface(\r\n            rgFace_In,\r\n            fDevTol=fDevTol,\r\n            bSrfOnFail=bSrfOnFail,\r\n            bDebug=bDebug\r\n            )\r\n\r\n        rgB_1F_Res, fDev, sLog = rc\r\n\r\n        if rgB_1F_Res is None:\r\n            if fDev is not None:\r\n                fDevs_Needed.append(fDev)\r\n            if sLog is not None:\r\n                sLogs.append(sLog)\r\n            continue\r\n\r\n        rgBs_1F_Res.append(rgB_1F_Res)\r\n        idxsFs_Success.append(idx_rgFace)\r\n        fDevs.append(fDev)\r\n\r\n\r\n    if not rgBs_1F_Res:\r\n        return [], [], fDevs_Needed, sLogs\r\n\r\n\r\n    gBs_NewFs = []\r\n    gBs_Res = []\r\n\r\n\r\n    if not bReplace:\r\n        # Adding the new face over each old one.\r\n        gBrep1_thisBrep = []\r\n        for rgBrep_1F_New, idxF in zip(rgBs_1F_Res, idxsFs_Success):\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBrep_1F_New)\r\n            if gBrep1 != gBrep1.Empty:\r\n                gBrep1_thisBrep.append(gBrep1)\r\n        gBs_Res.append(gBrep1_thisBrep)\r\n        \r\n        if bEcho: print(\"{} monofaces added.\".format(len(gBs_Res)))\r\n        \r\n        if bExtract:\r\n            rc = xBrepObject.extractFaces(rdB_In, idxsFs_Success)\r\n            gBs_1Fs_Extracted, gBs_RemainingGeom = rc\r\n            if bEcho:\r\n                print(\"{} monofaces extracted.\".format(len(gBs_1Fs_Extracted)))\r\n                print(\"{} breps of unmodified faces remain.\".format(len(gBs_RemainingGeom)))\r\n    else:\r\n        # bReplace==True.\r\n        if bExtract:\r\n            rc = xBrepObject.replaceFaces(\r\n                rdB_In,\r\n                idxsFs_Success,\r\n                rgBs_1F_Res,\r\n                bExtract=True,\r\n                fTolerance_Join=max(fDevs))\r\n            if rc:\r\n                gBs_NewFaces, gBs_RemainingGeom = rc\r\n                if bEcho:\r\n                    print(\"{} monofaces extracted.\".format(len(gBs_NewFaces)))\r\n                    print(\"{} breps of unmodified faces remain.\".format(len(gBs_RemainingGeom)))\r\n                gBs_Res = gBs_NewFaces + gBs_RemainingGeom\r\n        else:\r\n            fTols_Edges = [edge.Tolerance for edge in rgB_In.Edges]\r\n            fTolerance_Join = max((\r\n                    2.0*fDevTol if fDevTol is not None else 0.0,\r\n                    1.1*max(fTols_Edges),\r\n                    sc.doc.ModelAbsoluteTolerance))\r\n            rc = xBrepObject.replaceFaces(\r\n                    rdB_In,\r\n                    idxsFs_Success,\r\n                    rgBs_1F_Res,\r\n                    bExtract=False,\r\n                    fTolerance_Join=fTolerance_Join)\r\n            if rc:\r\n                gBs_Res = rc\r\n                if bEcho:\r\n                    print(\"Brep was replaced with {} revised faces.\".format(\r\n                        len(idxsFs_Success)))\r\n            else:\r\n                if bEcho:\r\n                    print(\"Brep could not be replaced with {} revised faces.\".format(\r\n                        len(idxsFs_Success)))\r\n\r\n    for brep in rgBs_1F_Res: brep.Dispose()\r\n    rgB_In.Dispose()\r\n\r\n    return gBs_Res, fDevs, fDevs_Needed, sLogs\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    \"\"\"Returns: str\"\"\"\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    elif fDistance == 0.0:\r\n        return \"exactly 0\".format(fDistance)\r\n    elif fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-2)):\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef main():\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script works only in Rhino V6 and above.\")\r\n        return\r\n\r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    rdBs_In, idxFs_PerB = rc\r\n    if not rdBs_In: return\r\n\r\n    fDevTol = Opts.values['fDevTol'] if Opts.values['bLimitDev'] else None\r\n    bExtract = Opts.values['bExtract']\r\n    bReplace = Opts.values['bReplace']\r\n    bSrfOnFail = Opts.values['bSrfOnFail']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    bDocModified = False\r\n\r\n    gBs_Res_perBs_In = []\r\n    fDevs_All = []\r\n    fDevs_Needed_All = []\r\n    sLogs_All = []\r\n\r\n\r\n    if len(rdBs_In) == 1:\r\n        s = \"Processing brep\"\r\n    else:\r\n        idxs_AtTenths = [int(round(0.1*i*len(rdBs_In),0)) for i in range(10)]\r\n\r\n\r\n    for iB, (rdB_In, idxFs) in enumerate(zip(rdBs_In, idxFs_PerB)):\r\n        if len(rdBs_In) > 1:\r\n            if iB in idxs_AtTenths:\r\n                s = \"Processing at {:d}% of {} breps\".format(\r\n                    int(100.0 * (iB+1) / len(rdBs_In)), len(rdBs_In))\r\n        \r\n            if bDebug:\r\n                print(s)\r\n            else:\r\n                Rhino.RhinoApp.SetCommandPrompt(s)\r\n\r\n\r\n        rc = processBrepObject(\r\n            rdB_In,\r\n            idxFs,\r\n            fDevTol=fDevTol,\r\n            bExtract=bExtract,\r\n            bSrfOnFail=bSrfOnFail,\r\n            bDebug=bDebug)\r\n        if rc[0] is None: return\r\n\r\n        gBs_Res, fDevs, fDevs_Needed, sLogs = rc\r\n\r\n        gBs_Res_perBs_In.extend(gBs_Res)\r\n        fDevs_All.extend(fDevs)\r\n        fDevs_Needed_All.extend(fDevs_Needed)\r\n        sLogs_All.extend(sLogs)\r\n\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\n    if fDevs_All:\r\n        if len(fDevs_All) == 1:\r\n            print(\"Converted surfaces with deviation {}.\".format(\r\n                formatDistance(fDevs_All[0])))\r\n        else:\r\n            print(\"Converted surfaces with deviations {} through {}.\".format(\r\n                formatDistance(min(fDevs_All)),\r\n                formatDistance(max(fDevs_All))))\r\n\r\n    if fDevs_Needed_All:\r\n        if len(fDevs_Needed_All) == 1:\r\n            s += \"Need tolerance of {}.\".format(\r\n                formatDistance(fDevs_Needed_All[0]))\r\n            s += \" to convert surface.\"\r\n        else:\r\n            s = \"Need tolerances of {} through {}\".format(\r\n                formatDistance(min(fDevs_Needed_All)),\r\n                formatDistance(max(fDevs_Needed_All)))\r\n            s += \" to convert remaining convertible surfaces.\"\r\n        print(s)\r\n\r\n\r\n    for sLog in set(sLogs_All):\r\n        print(\"{} of {}\".format(sLogs_All.count(sLog), sLog))\r\n\r\n\r\n    ## Select new faces.\r\n    #gBs_1F_Added_NETList = List[Guid](gBs_1F_Added)\r\n    #nSelected = sc.doc.Objects.Select(gBs_1F_Added_NETList)\r\n        \r\n    #if nSelected > 0:\r\n    #    print(\"{} monoface breps of simplified surfaces are\"\r\n    #            \" selected.\".format(nSelected))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}