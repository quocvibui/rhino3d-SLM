{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Fin.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Fin.py",
  "instruction": "This script is an alternative to _Fin.\r\nUnlike _Fin, it can:\r\n  * Modify the input curve, including simplifying it based on an input tolerance.\r\n  * Apply any angle from the base surface, not just to...",
  "code": "\"\"\"\r\nThis script is an alternative to _Fin.\r\nUnlike _Fin, it can:\r\n  * Modify the input curve, including simplifying it based on an input tolerance.\r\n  * Apply any angle from the base surface, not just to be normal (0 deg.) or tangent (90 deg.).\r\n  * Align the ends of the surfaces so that transitions to consecutives surfaces are G1.\r\n  * Optionally output section curves and optionally the curve based on the input curve.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190625-27: Created, starting with another script.\r\n...\r\n230419-20: Added use of OffsetNormalToSurface.  Refactored.\r\n230423-25: Various major changes.  Added AlignEndDirs option.  Now uses DrawConduit for preview.\r\n230925: Changed the click behavior when angle is not variable and not 0, 90, 180, 270.\r\n240816,18: Modified simplification of input curve routine.\r\n        Removed use of OffsetNormalToSurface since it provides the same solution as SPB's routine.\r\n        Added BothDirs option.\r\n\r\nTODO:\r\n    Review and modify or delete bSplitAtPolyKnots.\r\n    Add support for bAlignEndDirs when the Output is SectionCrvs.\r\n    ?: Replace curveWithSpansCompletelyOnFace with a routine that instead trims curve to the face.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Enum\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bUseFaceOfSelNakedEdge'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bLoose'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Output'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'SectionCrvs', 'LooseSrfs')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAlignEndDirs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExplodePolyCrv'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSplitAtPolyKnots'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSimplifyCrv'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSimplifyCrvTol'; keys.append(key)\r\n    values[key] = 0.1*sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fAngle_Start_Deg'; keys.append(key)\r\n    values[key] = 0.0\r\n    names[key] = 'AngleFromNormal'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bVariableAngle'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fAngle_End_Deg'; keys.append(key)\r\n    values[key] = 45.0\r\n    names[key] = 'EndAngle'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAngleChangePerCrvParam_NotLength'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'AngleChangePerCrv'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Length', 'Param')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDistance'; keys.append(key)\r\n    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n        values[key] = 1.0\r\n    else:\r\n        values[key] = 10.0 * Rhino.RhinoMath.UnitScale(\r\n            Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bDeg3InLoftDir_Not1'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'DegInLoftDir'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], '1', '3')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bBothDirs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtGrevilles'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtKnots'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtEqualDivisions'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddCrv'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDivisionCt'; keys.append(key)\r\n    values[key] = 10\r\n    riOpts[key] = ri.Custom.OptionInteger(\r\n            initialValue=values[key], setLowerLimit=True, limit=1)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fSimplifyCrvTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _addCommonOptions(go):\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    addOption('bLoose')\r\n    if Opts.values['bLoose']:\r\n        addOption('bAlignEndDirs')\r\n    addOption('bExplodePolyCrv')\r\n    #addOption('bSplitAtPolyKnots')\r\n    addOption('bSimplifyCrv')\r\n    if Opts.values['bSimplifyCrv']:\r\n        addOption('fSimplifyCrvTol')\r\n    Opts.names['fAngle_Start_Deg'] = 'AngleFromNormal'\r\n    addOption('bVariableAngle')\r\n    if Opts.values['bVariableAngle']:\r\n        Opts.names['fAngle_Start_Deg'] = 'StartAngle'\r\n    addOption('fAngle_Start_Deg')\r\n    if Opts.values['bVariableAngle']:\r\n        addOption('fAngle_End_Deg')\r\n    if Opts.values['bLoose']:\r\n        addOption('bAngleChangePerCrvParam_NotLength')\r\n    addOption('fDistance')\r\n    if Opts.values['bLoose']:\r\n        addOption('bDeg3InLoftDir_Not1')\r\n        addOption('bBothDirs')\r\n    if not Opts.values['bLoose']:\r\n        addOption('bAddCrv')\r\n        addOption('bAtGrevilles')\r\n        addOption('bAtKnots')\r\n        addOption('bAtEqualDivisions')\r\n        if Opts.values['bAtEqualDivisions']:\r\n            addOption('iDivisionCt')\r\n    addOption('bEcho')\r\n    addOption('bDebug')\r\n\r\n    return idxs_Opt\r\n\r\n\r\ndef _getInput_Curve():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curve on face\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    #bPreselectedObjsChecked = False\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        addOption('bUseFaceOfSelNakedEdge')\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_CrvOnFace = go.Object(0)\r\n            go.Dispose()\r\n\r\n            return objref_CrvOnFace\r\n\r\n        bNumberIsForDistDir = (\r\n            not Opts.values['bLoose']\r\n            or\r\n            (not Opts.values['bVariableAngle'] and\r\n                Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0))\r\n            or\r\n            (Opts.values['bVariableAngle'] and\r\n                Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0) and\r\n                Opts.values['fAngle_End_Deg'] == Opts.values['fAngle_Start_Deg'])\r\n            )\r\n\r\n        if res == ri.GetResult.Number:\r\n            if bNumberIsForDistDir:\r\n                key = 'fDistance'\r\n            else:\r\n                key = 'fAngle_Start_Deg'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Face():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select base face\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_Face = go.Object(0)\r\n\r\n            go.Dispose()\r\n    \r\n            return objref_Face\r\n\r\n\r\n        bNumberIsForDistDir = (\r\n            not Opts.values['bLoose']\r\n            or\r\n            (not Opts.values['bVariableAngle'] and\r\n                Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0))\r\n            or\r\n            (Opts.values['bVariableAngle'] and\r\n                Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0) and\r\n                Opts.values['fAngle_End_Deg'] == Opts.values['fAngle_Start_Deg'])\r\n            )\r\n\r\n\r\n        if res == ri.GetResult.Number:\r\n            if bNumberIsForDistDir:\r\n                key = 'fDistance'\r\n            else:\r\n                key = 'fAngle_Start_Deg'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Click():\r\n    \"\"\"\r\n    Click to toggle angle and/or direction with optional input.\r\n\r\n    Returns:\r\n        True: To recalculate and reloop\r\n        False: To not recalculate and break out of loop with current output.\r\n        None: To not recalculate and return without output.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetPoint()\r\n\r\n    bDefaultsForClickDirFlipOnly = (\r\n        not Opts.values['bLoose']\r\n        or\r\n        (not Opts.values['bVariableAngle'] and\r\n            Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0))\r\n        or\r\n        (Opts.values['bVariableAngle'] and\r\n            Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0) and\r\n            Opts.values['fAngle_End_Deg'] == Opts.values['fAngle_Start_Deg'])\r\n        )\r\n\r\n    if bDefaultsForClickDirFlipOnly:\r\n        go.SetCommandPrompt(\"Left click to flip direction\")\r\n    else:\r\n        go.SetCommandPrompt(\"Left click to cycle the 4 angle and direction flips\")\r\n\r\n    go.SetCommandPromptDefault(\"Accept result\")\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    key = 'FlipDir'; idxs_Opt[key] = go.AddOption(key)\r\n    if not bDefaultsForClickDirFlipOnly:\r\n        key = 'FlipAngle'; idxs_Opt[key] = go.AddOption(key)\r\n        if Opts.values['bVariableAngle']:\r\n            key = 'SwapAngles'; idxs_Opt[key] = go.AddOption(key)\r\n\r\n    idxs_Opt.update(_addCommonOptions(go))\r\n\r\n    res = go.Get()\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        go.Dispose()\r\n        return\r\n\r\n    if res == ri.GetResult.Nothing:\r\n        go.Dispose()\r\n        return False\r\n\r\n    if res == ri.GetResult.Point:\r\n        if Opts.values['bDebug']:\r\n            sEval = \"bDefaultsForClickDirFlipOnly\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        if bDefaultsForClickDirFlipOnly:\r\n            Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n            Opts.setValue('fDistance')\r\n            go.Dispose()\r\n            return True\r\n\r\n        if Opts.values['bDebug']:\r\n            sEval = \"Opts.values['fDistance']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval = \"Opts.values['fAngle_Start_Deg']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval = \"Opts.values['fAngle_End_Deg']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        if (\r\n            Opts.riOpts['fDistance'].CurrentValue > 0.0 and\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue > 0.0\r\n        ):\r\n            #print(\"+D +A\")\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n            Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n            Opts.setValue('fAngle_Start_Deg')\r\n            Opts.setValue('fAngle_End_Deg')\r\n        elif (\r\n            Opts.riOpts['fDistance'].CurrentValue < 0.0 and\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue > 0.0\r\n        ):\r\n            #print(\"-D +A Good\")\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n            Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n            Opts.setValue('fAngle_Start_Deg')\r\n            Opts.setValue('fAngle_End_Deg')\r\n        elif (\r\n            Opts.riOpts['fDistance'].CurrentValue < 0.0 and\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue <= 0.0\r\n        ):\r\n            #print(\"-D -A Good\")\r\n            Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n            Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n            Opts.setValue('fDistance')\r\n            Opts.setValue('fAngle_Start_Deg')\r\n            Opts.setValue('fAngle_End_Deg')\r\n        elif (\r\n            Opts.riOpts['fDistance'].CurrentValue > 0.0 and\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue <= 0.0\r\n        ):\r\n            #print(\"+D -A\")\r\n            Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n            Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n            Opts.setValue('fDistance')\r\n            Opts.setValue('fAngle_Start_Deg')\r\n            Opts.setValue('fAngle_End_Deg')\r\n        else:\r\n            raise Exception(\"What happened?\")\r\n        go.Dispose()\r\n        return True\r\n\r\n    if res == ri.GetResult.Number:\r\n        if bDefaultsForClickDirFlipOnly:\r\n            key = 'fDistance'\r\n        else:\r\n            key = 'fAngle_Start_Deg'\r\n        Opts.riOpts[key].CurrentValue = go.Number()\r\n        Opts.setValue(key)\r\n        go.Dispose()\r\n        return True\r\n\r\n    # An option was selected.\r\n\r\n    if Opts.values['bVariableAngle'] and 'SwapAngles' in idxs_Opt and go.OptionIndex() == idxs_Opt['SwapAngles']:\r\n        Opts.riOpts['fAngle_Start_Deg'].CurrentValue, Opts.riOpts['fAngle_End_Deg'].CurrentValue = (\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue, Opts.riOpts['fAngle_Start_Deg'].CurrentValue)\r\n        Opts.setValue('fAngle_Start_Deg')\r\n        Opts.setValue('fAngle_End_Deg')\r\n        go.Dispose()\r\n        return True\r\n\r\n    if not bDefaultsForClickDirFlipOnly and 'FlipAngle' in idxs_Opt and go.OptionIndex() == idxs_Opt['FlipAngle']:\r\n        #Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n        #Opts.setValue('fDistance')\r\n        Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n        Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n        Opts.setValue('fAngle_Start_Deg')\r\n        Opts.setValue('fAngle_End_Deg')\r\n        go.Dispose()\r\n        return True\r\n\r\n    if go.OptionIndex() == idxs_Opt['FlipDir']:\r\n        Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n        Opts.setValue('fDistance')\r\n    #    if Opts.riOpts['fAngle_Start_Deg'].CurrentValue == 0.0:\r\n    #        Opts.riOpts['fAngle_Start_Deg'].CurrentValue = 180.0\r\n    #    elif Opts.riOpts['fAngle_Start_Deg'].CurrentValue < 0.0:\r\n    #        Opts.riOpts['fAngle_Start_Deg'].CurrentValue = (\r\n    #                -180.0 + Opts.riOpts['fAngle_Start_Deg'].CurrentValue) % 180.0\r\n    #    else:\r\n    #        Opts.riOpts['fAngle_Start_Deg'].CurrentValue = (\r\n    #                180.0 - Opts.riOpts['fAngle_Start_Deg'].CurrentValue) % 180.0\r\n            \r\n    #    if Opts.riOpts['fAngle_End_Deg'].CurrentValue == 0.0:\r\n    #        Opts.riOpts['fAngle_End_Deg'].CurrentValue = 180.0\r\n    #    elif Opts.riOpts['fAngle_End_Deg'].CurrentValue < 0.0:\r\n    #        Opts.riOpts['fAngle_End_Deg'].CurrentValue = (\r\n    #                -180.0 + Opts.riOpts['fAngle_End_Deg'].CurrentValue) % 180.0\r\n    #    else:\r\n    #        Opts.riOpts['fAngle_End_Deg'].CurrentValue = (\r\n    #                180.0 - Opts.riOpts['fAngle_End_Deg'].CurrentValue) % 180.0\r\n\r\n    #    Opts.setValue('fAngle_Start_Deg')\r\n    #    Opts.setValue('fAngle_End_Deg')\r\n        go.Dispose()\r\n        return True\r\n\r\n    for key in idxs_Opt:\r\n        if go.Option().Index == idxs_Opt[key]:\r\n            Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n            break\r\n\r\n    go.Dispose()\r\n    return True\r\n\r\n\r\ndef _createArrayedLines(rgCrv, rgSrf, fDistance, fAngle_Start_Deg, fAngle_End_Deg, rgCrv_Full, bAngleChangePerCrvParam_NotLength, bAtGrevilles, bAtKnots, bAtEqualDivisions, iDivisionCt):\r\n    \"\"\"\r\n    rgSurface0: rg.Surface, including rg.BrepFace\r\n    rgCrv_Full: For variable angle calculation\r\n    \"\"\"\r\n\r\n    rgCrv_In = rgCrv\r\n    rgSrf_In = rgSrf\r\n\r\n    rgNurbsCrv_rgCrv0 = rgCrv_In.ToNurbsCurve()\r\n\r\n    rgLines_Arrayed = []\r\n\r\n    ts = []\r\n    if bAtGrevilles:\r\n        ts.extend(rgNurbsCrv_rgCrv0.GrevilleParameters())\r\n    if bAtKnots:\r\n        ts.append(rgNurbsCrv_rgCrv0.Domain.T0)\r\n        for iSpan in xrange(rgNurbsCrv_rgCrv0.SpanCount):\r\n            ts.append(rgNurbsCrv_rgCrv0.SpanDomain(iSpan).T1)\r\n        ts.append(rgNurbsCrv_rgCrv0.Domain.T1)\r\n    if bAtEqualDivisions:\r\n        if rgNurbsCrv_rgCrv0.IsClosed: iDivisionCt -= 1\r\n        rc = rgNurbsCrv_rgCrv0.DivideByCount(\r\n                segmentCount=iDivisionCt,\r\n                includeEnds=True)\r\n        if rc:\r\n            ts.extend(rc)\r\n\r\n    ts = sorted(set(ts))\r\n    # TODO: Remove near duplicate parameters.\r\n\r\n\r\n    #angle_Const_Rad = angle_Var_Rad = None\r\n    if fAngle_End_Deg is None or fAngle_End_Deg == fAngle_Start_Deg:\r\n        angles_per_param = [Rhino.RhinoMath.ToRadians(fAngle_Start_Deg)] * len(ts)\r\n        #angle_Const_Rad = Rhino.RhinoMath.ToRadians(fAngle_Start_Deg)\r\n    else:\r\n        if not bAngleChangePerCrvParam_NotLength:\r\n            length_Full = rgCrv_Full.GetLength()\r\n        angles_per_param = []\r\n        for t in ts:\r\n            if bAngleChangePerCrvParam_NotLength:\r\n                t_Normalized = rgCrv_Full.Domain.NormalizedParameterAt(t)\r\n                angle_Var_Rad = Rhino.RhinoMath.ToRadians(\r\n                    fAngle_Start_Deg * (1.0 - t_Normalized) +\r\n                    fAngle_End_Deg * t_Normalized)\r\n            else:\r\n                length_to_t = rgCrv_Full.GetLength(\r\n                    subdomain=rg.Interval(rgCrv_Full.Domain.T0, t))\r\n                angle_Var_Rad = Rhino.RhinoMath.ToRadians(\r\n                    fAngle_Start_Deg * (1.0 - length_to_t/length_Full) +\r\n                    fAngle_End_Deg * length_to_t/length_Full)\r\n            angles_per_param.append(angle_Var_Rad)\r\n\r\n    #sEval='angles_per_param[:2]'; print(sEval+':',eval(sEval))\r\n    #sEval='angles_per_param[-2:]'; print(sEval+':',eval(sEval))\r\n    #sEval='angles_per_param'; print(sEval+':',eval(sEval))\r\n\r\n    for iT, t in enumerate(ts):\r\n        pt_Start = rgNurbsCrv_rgCrv0.PointAt(t)\r\n        bSuccess, u, v = rgSrf_In.ClosestPoint(pt_Start)\r\n        if not bSuccess: continue\r\n        vect_Normal = rgSrf_In.NormalAt(u, v)\r\n        bSuccess, frame = rgNurbsCrv_rgCrv0.PerpendicularFrameAt(t)\r\n        if not bSuccess: continue\r\n        \r\n        pt_NoAngle = pt_Start + vect_Normal * fDistance\r\n\r\n        pt_End = rg.Point3d(pt_NoAngle)\r\n\r\n        #if angle_Const_Rad is None:\r\n        #    if bAngleChangePerCrvParam_NotLength:\r\n        #        t_Normalized = rgCrv_Full.Domain.NormalizedParameterAt(t)\r\n        #        angle_Var_Rad = Rhino.RhinoMath.ToRadians(\r\n        #            fAngle_Start_Deg * (1.0 - t_Normalized) +\r\n        #            fAngle_End_Deg * t_Normalized)\r\n        #    else:\r\n        #        length_to_t = rgCrv_Full.GetLength(\r\n        #            subdomain=rg.Interval(rgCrv_Full.Domain.T0, t))\r\n        #        angle_Var_Rad = Rhino.RhinoMath.ToRadians(\r\n        #            fAngle_Start_Deg * (1.0 - length_to_t/length_Full) +\r\n        #            fAngle_End_Deg * length_to_t/length_Full)\r\n\r\n        #sEval='angle_Const_Rad'; print(sEval+':',eval(sEval))\r\n        #sEval='angle_Var_Rad'; print(sEval+':',eval(sEval))\r\n\r\n\r\n        #xform_Rotation = rg.Transform.Rotation(\r\n        #        angleRadians=angle_Const_Rad if angle_Var_Rad is None else angle_Var_Rad,\r\n        #        rotationAxis=frame.ZAxis,\r\n        #        rotationCenter=frame.Origin)\r\n\r\n        xform_Rotation = rg.Transform.Rotation(\r\n                angleRadians=angles_per_param[iT],\r\n                rotationAxis=frame.ZAxis,\r\n                rotationCenter=frame.Origin)\r\n\r\n\r\n\r\n        pt_End.Transform(xform_Rotation)\r\n\r\n        rgLines_Arrayed.append(rg.Line(pt_Start, pt_End))\r\n\r\n    if rgLines_Arrayed[0].EpsilonEquals(rgLines_Arrayed[-1], epsilon=1.0 / (2**32)):\r\n        rgLines_Arrayed.pop()\r\n\r\n    return rgLines_Arrayed\r\n\r\n\r\ndef _curveWithSpansCompletelyOnFace(rgCrv, rgFace, t_Crv_Pick, fTol, bDebug=False):\r\n    \"\"\"\r\n    Only process spans of the curve whose spans start and ends are on the Face.\r\n    \"\"\"\r\n    iSpans_OnFace = []\r\n    for iSpan in xrange(rgCrv.SpanCount):\r\n        t = rgCrv.SpanDomain(iSpan).T0\r\n        pt_OnCrv = rgCrv.PointAt(t)\r\n        bSuccess, u, v = rgFace.ClosestPoint(pt_OnCrv)\r\n        if not bSuccess: continue\r\n        pt_OnFace = rgFace.PointAt(u,v)\r\n        dist = pt_OnFace.DistanceTo(pt_OnCrv)\r\n        if dist > fTol:\r\n            if bDebug:\r\n                sEval='dist'; print(sEval+': ',eval(sEval))\r\n                print(\"PointAtStart not on underlying surface.\")\r\n            continue\r\n        \r\n        t = rgCrv.SpanDomain(iSpan).T1\r\n        pt_OnCrv = rgCrv.PointAt(t)\r\n        bSuccess, u, v = rgFace.ClosestPoint(pt_OnCrv)\r\n        if not bSuccess: continue\r\n        pt_OnFace = rgFace.PointAt(u,v)\r\n        dist = pt_OnFace.DistanceTo(pt_OnCrv)\r\n        if dist > fTol:\r\n            if bDebug:\r\n                #sc.doc.Objects.AddPoint(pt_OnFace)\r\n                sEval='dist'; print(sEval+': ',eval(sEval))\r\n                print(\"PointAtEnd not on underlying surface.\")\r\n            continue\r\n        \r\n        iSpans_OnFace.append(iSpan)\r\n    \r\n    if not iSpans_OnFace:\r\n        print(\"None of the spans of the curve are completely on the face.\")\r\n        rgFace.Brep.Dispose()\r\n        return\r\n\r\n    if len(iSpans_OnFace) == rgCrv.SpanCount:\r\n        return rgCrv.Duplicate()\r\n\r\n    if len(iSpans_OnFace) == 1:\r\n        return rgCrv.Trim(\r\n            rgCrv.SpanDomain(iSpans_OnFace[0]).T0,\r\n            rgCrv.SpanDomain(iSpans_OnFace[0]).T1)\r\n\r\n    # Create nested lists of contiguous spans so that curves that go off and\r\n    # on the face can be correctly processed.\r\n    iSpans_Contiguous_nests = [[iSpans_OnFace[0]]]\r\n    for iSpan in iSpans_OnFace[1:]:\r\n        if iSpan == iSpans_Contiguous_nests[-1][-1] + 1:\r\n            iSpans_Contiguous_nests[-1].append(iSpan)\r\n        else:\r\n            iSpans_Contiguous_nests.append([iSpan])\r\n        \r\n    if rgCrv.IsClosed and len(iSpans_Contiguous_nests) > 1:\r\n        if (\r\n                iSpans_Contiguous_nests[0][0] == 0 and\r\n                iSpans_Contiguous_nests[-1][-1] == rgCrv.SpanCount-1\r\n        ):\r\n            iSpans_Contiguous_nests[0] = iSpans_Contiguous_nests[-1] + iSpans_Contiguous_nests[0]\r\n            iSpans_Contiguous_nests.pop()\r\n    \r\n    if len(iSpans_Contiguous_nests) == 1:\r\n        rgC_Out = rgCrv.Trim(\r\n                rgCrv.SpanDomain(iSpans_Contiguous_nests[0][0]).T0,\r\n                rgCrv.SpanDomain(iSpans_Contiguous_nests[0][-1]).T1)\r\n    elif len(iSpans_Contiguous_nests) > 1:\r\n        for iSpan_NestIndex, iSpans_Contiguous in enumerate(iSpans_Contiguous_nests):\r\n            for iSpan in iSpans_Contiguous:\r\n                if rgCrv.SpanDomain(iSpan).T0 <= t_Crv_Pick <= rgCrv.SpanDomain(iSpan).T1:\r\n                    rgC_Out = rgCrv.Trim(\r\n                            rgCrv.SpanDomain(iSpans_Contiguous_nests[iSpan_NestIndex][0]).T0,\r\n                            rgCrv.SpanDomain(iSpans_Contiguous_nests[iSpan_NestIndex][-1]).T1)\r\n                else:\r\n                    print(\"Curve was not picked within the face.\")\r\n                    rgCrv.Dispose()\r\n                    return\r\n        \r\n    if bDebug:\r\n        sc.doc.Objects.AddCurve(rgC_Out)\r\n\r\n    return rgC_Out\r\n\r\n\r\ndef _getDistancesBetweenCurves(crvA, crvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    if not rc[0]:\r\n        raise Exception(\"GetDistancesBetweenCurves returned None.\")\r\n        return None\r\n\r\n    return rc[1]\r\n\r\n\r\ndef _matchCrvEndDirs(nc_ToMod, nc_Ref):\r\n    \"\"\"\r\n    nc_ToMod is modified.\r\n    \"\"\"\r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=False,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtStart,\r\n        tangent=nc_Ref.TangentAtStart)\r\n    if not bSuccess:\r\n        print(\"SetEndCondition failed.\")\r\n        return False\r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=True,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtEnd,\r\n        tangent=nc_Ref.TangentAtEnd)\r\n    if not bSuccess:\r\n        print(\"SetEndCondition failed.\")\r\n        return False\r\n\r\n    return True\r\n\r\n\r\ndef _tangentAngleDifference(cA, cB, bDebug=False):\r\n    tanDiffAtStart = rg.Vector3d.VectorAngle(cA.TangentAtStart, cB.TangentAtStart)\r\n    tanDiffAtEnd = rg.Vector3d.VectorAngle(cA.TangentAtEnd, cB.TangentAtEnd)\r\n    if bDebug:\r\n        sEval='Rhino.RhinoMath.ToDegrees(tanDiffAtStart)'; print(sEval+':',eval(sEval))\r\n        sEval='Rhino.RhinoMath.ToDegrees(tanDiffAtEnd)'; print(sEval+':',eval(sEval))\r\n\r\n\r\ndef _rebuild_to_Bezier(nc_In, iDegs, fTol, bDebug=False):\r\n    \"\"\"\r\n    More strict fTol used on degree 2 since that Bezier doesn't allow\r\n    tangency matching of both ends when they are not already aligned.\r\n\r\n    Returns on success: rg.NurbsCurve, float(deviation)\r\n    Returns on fail: None\r\n    \"\"\"\r\n    if bDebug: print(\"rebuild_Bezier with fTol={}:\".format(fTol))\r\n\r\n    for iDeg in iDegs:\r\n        pointCount = iDeg + 1\r\n\r\n        rebuilt = nc_In.Rebuild(\r\n            pointCount=pointCount,\r\n            degree=iDeg,\r\n            preserveTangents=True)\r\n\r\n        bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n            nc_In, rebuilt, tolerance=0.1*fTol)[:2]\r\n\r\n        if bSuccess:\r\n            if iDeg==2:\r\n                if fDistMax < 1e-6:\r\n                    if bDebug:\r\n                        print(\"Rebuilt within {}  Deg:{}  PtCt:{}\".format(\r\n                            fDistMax, iDeg, pointCount))\r\n                        _tangentAngleDifference(nc_In, rebuilt, bDebug)\r\n                    rebuilt.Domain = nc_In.Domain # Needed for variable angles.\r\n                    return rebuilt, fDistMax\r\n            elif fDistMax <= fTol:\r\n                if bDebug:\r\n                    print(\"Rebuilt within {}  Deg:{}  PtCt:{}\".format(\r\n                        fDistMax, iDeg, pointCount))\r\n                    _tangentAngleDifference(nc_In, rebuilt, bDebug)\r\n                    rebuilt.Domain = nc_In.Domain # Needed for variable angles.\r\n                return rebuilt, fDistMax\r\n\r\n        if bDebug:\r\n            print(\"Rebuild requires {}  Deg:{}  PtCt:{}\".format(\r\n                fDistMax, iDeg, pointCount))\r\n        rebuilt.Dispose()\r\n\r\n\r\ndef _rebuild_to_MultiSpan(nc_In, iDegs, fTol, bDebug=False):\r\n    \"\"\"\r\n    Will not bother rebuilding to degree-2 since multiple spans are divided by\r\n    G1-likely knots.\r\n    \"\"\"\r\n    if bDebug: print(\"rebuild_MultiSpan with fTol={}:\".format(fTol))\r\n\r\n    iCt_MaxSpans = nc_In.SpanCount\r\n\r\n    #iCt_MaxCp = int(round(nc.GetLength() / (100.0 * sc.doc.ModelAbsoluteTolerance)))\r\n    #if bDebug: sEval='iCt_MaxCp'; print(sEval+':',eval(sEval))\r\n\r\n\r\n    # Rebuild at maximum control point count.\r\n    #pointCount = iCt_MaxCp\r\n\r\n    iDegs_ForRebuildSearch = []\r\n    rebuilts_LastSuccess = [] # per iDeg.\r\n    fDevs = [] # per iDeg.\r\n\r\n    for iDeg in iDegs:\r\n\r\n        if iDeg < 3: continue\r\n\r\n        pointCount = iDeg + iCt_MaxSpans\r\n\r\n        rebuilt = nc_In.Rebuild(\r\n            pointCount=pointCount,\r\n            degree=iDeg,\r\n            preserveTangents=True)\r\n\r\n        bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n            nc_In, rebuilt, tolerance=0.1*fTol)[:2]\r\n\r\n        if bSuccess and fDistMax <= fTol:\r\n            iDegs_ForRebuildSearch.append(iDeg)\r\n            rebuilts_LastSuccess.append(rebuilt)\r\n            fDevs.append(fDistMax)\r\n            if bDebug:\r\n                print(\"Rebuilt within {}  Deg:{}  PtCt:{}\".format(\r\n                    fTol, iDeg, pointCount))\r\n        else:\r\n            rebuilt.Dispose()\r\n\r\n\r\n    if not iDegs_ForRebuildSearch:\r\n        if bDebug:\r\n            print(\"Not rebuilt within {} at max. span ct. of {}, so quitting rebuilding.\".format(\r\n                fTol, iCt_MaxSpans))\r\n        return\r\n\r\n\r\n    if bDebug: print(\"Binary search.\")\r\n\r\n    for i, iDeg in enumerate(iDegs_ForRebuildSearch):\r\n\r\n        iCt_MaxCp = iDeg + iCt_MaxSpans\r\n\r\n        iCts_Cps_Tried = [iDeg + 1, iCt_MaxCp]\r\n\r\n        iCt_Cp_Try = (iCt_MaxCp + iDeg + 1) // 2\r\n\r\n        while iCt_Cp_Try not in iCts_Cps_Tried:\r\n            sc.escape_test()\r\n\r\n            rebuilt = nc_In.Rebuild(\r\n                pointCount=iCt_Cp_Try,\r\n                degree=iDeg,\r\n                preserveTangents=True)\r\n\r\n            bSuccess, fDistMax = rg.Curve.GetDistancesBetweenCurves(\r\n                nc_In, rebuilt, tolerance=0.1*fTol)[:2]\r\n\r\n            if bDebug:\r\n                print(\"Degree:{}  CPtCt:{}  fDistMax:{}  WithinTol:{}\".format(\r\n                    iDeg,\r\n                    iCt_Cp_Try,\r\n                    fDistMax if bSuccess else bSuccess,\r\n                    fDistMax <= fTol if bSuccess else bSuccess\r\n                    ))\r\n\r\n\r\n            iCts_Cps_Tried.append(iCt_Cp_Try)\r\n            iCts_Cps_Tried.sort()\r\n\r\n            if bSuccess and fDistMax <= fTol:\r\n                rebuilts_LastSuccess[i].Dispose()\r\n                rebuilts_LastSuccess[i] = rebuilt\r\n                fDevs[i] = fDistMax\r\n                # Bisect left.\r\n                iCt_Cp_Try = (\r\n                    (iCt_Cp_Try +\r\n                        iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)-1]) // 2)\r\n            else:\r\n                rebuilt.Dispose()\r\n                # Bisect right.\r\n                iCt_Cp_Try = (\r\n                    (iCt_Cp_Try +\r\n                        iCts_Cps_Tried[iCts_Cps_Tried.index(iCt_Cp_Try)+1]) // 2)\r\n\r\n    if len(rebuilts_LastSuccess) == 1:\r\n        rebuilt_Winner = rebuilts_LastSuccess[0]\r\n        fDev_Winner = fDevs[0]\r\n    else:\r\n        # TODO: Change the winner to that with minimum deviation instead of least CPs?\r\n        iCts_Pts = [nc_In.Points.Count for nc_In in rebuilts_LastSuccess]\r\n        idx_Winner = iCts_Pts.index(min(iCts_Pts))\r\n        rebuilt_Winner = rebuilts_LastSuccess[idx_Winner]\r\n        fDev_Winner = fDevs[idx_Winner]\r\n    rebuilt_Winner.Domain = nc_In.Domain # Needed for variable angles.\r\n    _tangentAngleDifference(nc_In, rebuilt_Winner, bDebug)\r\n    return rebuilt_Winner, fDev_Winner\r\n\r\n\r\ndef _simplifyCrv(rgCrv_In, fTol, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Output a degree-3 curve with only simple internal knots.\r\n    Only output degree-3 for similar limation of _Loft and RC's Loft.\r\n    \"\"\"\r\n\r\n    #if isinstance(rgCrv_In, rg.PolylineCurve):\r\n    #    raise Exception(\"PolylineCurve is not supported.\")\r\n    if isinstance(rgCrv_In, (rg.LineCurve, rg.ArcCurve)):\r\n        return rgCrv_In.DuplicateCurve()\r\n\r\n    nc_WIP = rgCrv_In.ToNurbsCurve()\r\n\r\n    if nc_WIP.SpanCount == 1:\r\n        if bDebug: print(\"Curve has only 1 span.\")\r\n        return nc_WIP\r\n\r\n\r\n    rc = _rebuild_to_Bezier(\r\n        rgCrv_In,\r\n        iDegs=(2,3,5),\r\n        fTol=fTol,\r\n        bDebug=bDebug)\r\n    if rc:\r\n        return rc[0]\r\n\r\n    rc = _rebuild_to_MultiSpan(\r\n        rgCrv_In,\r\n        iDegs=(3,5),\r\n        fTol=fTol,\r\n        bDebug=bDebug)\r\n    if rc:\r\n        return rc[0]\r\n\r\n    #def knotMultiplicityList(knots):\r\n    #    \"\"\"Returns a list.\"\"\"\r\n    #    i = 0\r\n    #    iMulties = []\r\n    #    fKnotTs_Unique = []\r\n    #    while True:\r\n    #        knot = knots[i]\r\n    #        fKnotTs_Unique.append(knot)\r\n    #        iMulti = knots.KnotMultiplicity(index=i)\r\n    #        iMulties.append(iMulti)\r\n    #        #print(\"{} at {:.4f}\".format(iMulti, knot),\r\n    #        i += iMulti\r\n    #        if i >= knots.Count:\r\n    #            break\r\n    #    return iMulties\r\n\r\n\r\n    if (nc_WIP.Knots.KnotStyle in (\r\n        rg.KnotStyle.QuasiUniform,\r\n        rg.KnotStyle.Uniform)\r\n    ):\r\n        return nc_WIP\r\n\r\n    # Non-uniform but only simple internal knots is disabled for now.\r\n    #ms = knotMultiplicityList(nc_WIP.Knots)\r\n    #if not(nc_WIP.IsClosed and nc_WIP.IsPeriodic):\r\n    #    ms = ms[1:-1]\r\n    #if all([m == 1 for m in ms]):\r\n    #    return nc_WIP\r\n\r\n    if nc_WIP.IsPeriodic:\r\n        nc_WIP.Knots.CreatePeriodicKnots(knotSpacing=1.0) # Modifies existing Knots.\r\n    else:\r\n        nc_WIP.Knots.CreateUniformKnots(knotSpacing=1.0) # Modifies existing Knots.\r\n\r\n    nc_WIP.Domain = rgCrv_In.Domain\r\n\r\n    dev = _getDistancesBetweenCurves(rgCrv_In, nc_WIP)\r\n    if dev <= fTol:\r\n        return nc_WIP\r\n    if bDebug: print(\"'MakeUniform' routine result is {} (not within {}).\".format(\r\n        dev, fTol))\r\n\r\n    nc_WIP.Dispose()\r\n\r\n    if bEcho:\r\n        print(\"Curve could not be simplified within {} deviation.\".format(fTol))\r\n\r\n\r\ndef _splitNurbsCrvsAtPolyKnots(ncs):\r\n    ncs_Out = []\r\n    for nc in ncs:\r\n        if not isinstance(nc, rg.NurbsCurve):\r\n            ncs_Out.append(nc.DuplicateCurve())\r\n            continue\r\n\r\n        ts_polyknots = []\r\n\r\n        if nc.IsPeriodic:\r\n            iKs = range(nc.Knots.Count)\r\n        elif nc.IsClosed:\r\n            iKs = range(nc.Knots.Count - nc.Degree)\r\n        else:\r\n            iKs = range(nc.Degree, nc.Knots.Count - nc.Degree)\r\n\r\n        for iK in iKs:\r\n            if nc.Knots.KnotMultiplicity(iK) > 1:\r\n                ts_polyknots.append(nc.Knots[iK])\r\n\r\n        if not ts_polyknots:\r\n            ncs_Out.append(nc.DuplicateCurve())\r\n            continue\r\n        rc = nc.Split(ts_polyknots)\r\n        if not rc:\r\n            print(\"Check input.\")\r\n        else:\r\n            ncs_Out.extend(rc)\r\n    return ncs_Out\r\n\r\n\r\ndef updateList(list_, func, **kwargs):\r\n    \"\"\"\r\n    Only replace items in list when the result from function is not None.\r\n    Otherwise, copy old item into new list.\r\n    When replaced, the old item is Disposed.\r\n\r\n    Returns: bool indicating whether the list has been updated.\r\n    \"\"\"\r\n\r\n    bUpdated = False\r\n\r\n    for i, item in enumerate(list_):\r\n\r\n        rc = func(item, **kwargs)\r\n        if rc is not None:\r\n            list_[i].Dispose()\r\n            list_[i] = rc\r\n            bUpdated = True\r\n\r\n    return bUpdated\r\n\r\n\r\ndef _prepareCrvToFin(rgCrv_In, bSimplifyCrv, bExplodePolyCrv, bSplitAtPolyKnots, bMakeDeformable, fTol, bEcho=True, bDebug=False):\r\n\r\n    if bExplodePolyCrv and isinstance(rgCrv_In, rg.PolyCurve):\r\n        ncs_WIP = [_.ToNurbsCurve() for _ in rgCrv_In.Explode()]\r\n    else:\r\n        ncs_WIP = [rgCrv_In.ToNurbsCurve()]\r\n\r\n    if bSimplifyCrv:\r\n        bSimplified = updateList(ncs_WIP, _simplifyCrv, fTol=fTol, bEcho=bEcho, bDebug=bDebug)\r\n    #elif bSplitAtPolyKnots:\r\n    #    for i in range(len(ncs_WIP)):\r\n    #        rc = _splitNurbsCrvAtPolyKnots(ncs_WIP[i], fTol, bDebug)\r\n    #        if rc:\r\n    #            ncs_WIP[i].Dispose()\r\n    #            ncs_WIP[i] = rc\r\n    #    rc = _splitNurbsCrvAtPolyKnots(ncs_WIP)\r\n    #    for _ in ncs_WIP: _.Dispose()\r\n    #    ncs_WIP = rc\r\n\r\n    if bMakeDeformable:\r\n        for i in range(len(ncs_WIP)):\r\n            if ncs_WIP[i].Degree < 3 and ncs_WIP[i].Points.Count < 4:\r\n                ncs_WIP[i].IncreaseDegree(3)\r\n\r\n    return ncs_WIP\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.breps = []\r\n        self.crvs = []\r\n        self.lines = []\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        for brep in self.breps:\r\n            bbox = brep.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n        for crv in self.crvs:\r\n            bbox = crv.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n        for line in self.lines:\r\n            bbox = line.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        color = sc.doc.Layers.CurrentLayer.Color\r\n\r\n        for brep in self.breps:\r\n\r\n            displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n            da = displayMode.DisplayAttributes\r\n            if da.ShadingEnabled:\r\n                drawEventArgs.Display.DrawBrepShaded(\r\n                    brep=brep,\r\n                    material=Rhino.Display.DisplayMaterial(diffuse=color))\r\n            drawEventArgs.Display.DrawBrepWires(\r\n                brep=brep,\r\n                color=color,\r\n                wireDensity=1)\r\n\r\n        for crv in self.crvs:\r\n            drawEventArgs.Display.DrawCurve(\r\n                curve=crv,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n        if self.lines:\r\n            drawEventArgs.Display.DrawLines(\r\n                lines=self.lines,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n\r\ndef _createGeometryInteractively():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__) # StickyKey\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    objref_CrvToFin = _getInput_Curve()\r\n    if objref_CrvToFin is None: return\r\n\r\n\r\n    bUseFaceOfSelNakedEdge = Opts.values['bUseFaceOfSelNakedEdge']\r\n\r\n\r\n    rgEdge = objref_CrvToFin.Edge()\r\n\r\n    if rgEdge and bUseFaceOfSelNakedEdge and rgEdge.Valence == rg.EdgeAdjacency.Naked:\r\n        idxF = objref_CrvToFin.Edge().AdjacentFaces()[0]\r\n        rgF_In = rgEdge.Brep.Faces[idxF]\r\n    else:\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n        objref_Face = _getInput_Face()\r\n        if objref_Face is None: return\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n\r\n        rgF_In = objref_Face.Face()\r\n\r\n\r\n    bLoose = Opts.values['bLoose']\r\n    bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n    bExplodePolyCrv = Opts.values['bExplodePolyCrv']\r\n    bSplitAtPolyKnots = Opts.values['bSplitAtPolyKnots']\r\n    bSimplifyCrv = Opts.values['bSimplifyCrv']\r\n    fAngle_Start_Deg = Opts.values['fAngle_Start_Deg']\r\n    fAngle_End_Deg = Opts.values['fAngle_End_Deg'] if Opts.values['bVariableAngle'] else None\r\n    bAngleChangePerCrvParam_NotLength = Opts.values['bAngleChangePerCrvParam_NotLength']\r\n    fDistance = Opts.values['fDistance']\r\n    fSimplifyCrvTol = Opts.values['fSimplifyCrvTol']\r\n    bDeg3InLoftDir_Not1 = Opts.values['bDeg3InLoftDir_Not1']\r\n    bBothDirs = Opts.values['bBothDirs']\r\n    bAddCrv = Opts.values['bAddCrv']\r\n    bAtGrevilles = Opts.values['bAtGrevilles']\r\n    bAtKnots = Opts.values['bAtKnots']\r\n    bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n    iDivisionCt = Opts.values['iDivisionCt']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    #sEval='fDistance'; print(sEval+':',eval(sEval))\r\n    #sEval='fAngle_Start_Deg'; print(sEval+':',eval(sEval))\r\n    #sEval='fAngle_End_Deg'; print(sEval+':',eval(sEval))\r\n\r\n    rgC_In, t_Crv0_Pick = objref_CrvToFin.CurveParameter()\r\n\r\n\r\n    if isinstance(rgC_In, rg.PolyCurve):\r\n        rgC_In.RemoveNesting()\r\n\r\n\r\n    rgC_In_TrimmedToFace = _curveWithSpansCompletelyOnFace(\r\n        rgC_In, rgF_In, t_Crv0_Pick, sc.doc.ModelAbsoluteTolerance, bDebug)\r\n    if rgC_In_TrimmedToFace is None: return\r\n\r\n\r\n    if rgC_In_TrimmedToFace.IsClosed and fAngle_End_Deg:\r\n        fAngle_End_Deg = Opts.values['fAngle_End_Deg'] = sc.sticky[Opts.stickyKeys['fAngle_End_Deg']] = None\r\n        bVariableAngle = Opts.values['bVariableAngle'] = sc.sticky[Opts.stickyKeys['bVariableAngle']] = False\r\n\r\n\r\n    if not ((sk_conduit in sc.sticky) and sc.sticky[sk_conduit]):\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        rgBs_FromLoft = []\r\n        rgBs_JoinedLofts = []\r\n        ncs_FinEnd = []\r\n        rgLs_ForOut = []\r\n\r\n        if not bLoose and not (bAddCrv or bAtGrevilles or bAtKnots or bAtEqualDivisions):\r\n            print(\"No output has been enabled. Pick some.\")\r\n        else:\r\n            bMakeDeformable = (\r\n                (bLoose and bAlignEndDirs)\r\n                or\r\n                (fAngle_End_Deg\r\n                 and\r\n                 (fAngle_End_Deg != fAngle_Start_Deg))\r\n                )\r\n\r\n            ncs_FinStart = _prepareCrvToFin(\r\n                rgC_In_TrimmedToFace,\r\n                bSimplifyCrv,\r\n                bExplodePolyCrv,\r\n                bSplitAtPolyKnots,\r\n                bMakeDeformable,\r\n                fTol=fSimplifyCrvTol,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n\r\n            #for nc in ncs_FinStart:\r\n            #    sc.doc.Objects.AddCurve(nc)\r\n\r\n\r\n            if bLoose:\r\n                for nc_FinStart in ncs_FinStart:\r\n                    rc = _createArrayedLines(\r\n                        rgCrv=nc_FinStart,\r\n                        rgSrf=rgF_In,\r\n                        fDistance=fDistance,\r\n                        fAngle_Start_Deg=fAngle_Start_Deg,\r\n                        fAngle_End_Deg=fAngle_End_Deg,\r\n                        rgCrv_Full=rgC_In_TrimmedToFace,\r\n                        bAngleChangePerCrvParam_NotLength=bAngleChangePerCrvParam_NotLength,\r\n                        bAtGrevilles=True,\r\n                        bAtKnots=False,\r\n                        bAtEqualDivisions=False,\r\n                        iDivisionCt=iDivisionCt)\r\n                    if not rc: continue\r\n                    rgLs_GrevillesOnly = rc\r\n\r\n                    pts_Arrayed = [line.To for line in rgLs_GrevillesOnly]\r\n                    #for pt in pts_Arrayed: sc.doc.Objects.AddPoint(pt)\r\n                    #sc.doc.Views.Redraw()\r\n\r\n                    # Create curve at other end of fin.\r\n                    #print(len(nc_FinStart.GrevillePoints(False)))\r\n                    #1/0\r\n                    nc_FinEnd = nc_FinStart.Duplicate()\r\n                    nc_FinEnd.SetGrevillePoints(pts_Arrayed)\r\n\r\n                    if (\r\n                        not nc_FinEnd.IsPeriodic and\r\n                        bAlignEndDirs and\r\n                        not _matchCrvEndDirs(nc_FinEnd, nc_FinStart)\r\n                    ):\r\n                        if bEcho: print(\"Alignment of end tangent failed.\")\r\n                        nc_WIP.Dispose()\r\n                        continue\r\n\r\n                    ncs_FinEnd.append(nc_FinEnd)\r\n\r\n                    breps_Loft = rg.Brep.CreateFromLoft(\r\n                        curves=[nc_FinStart, nc_FinEnd],\r\n                        start=rg.Point3d.Unset,\r\n                        end=rg.Point3d.Unset,\r\n                        loftType=rg.LoftType.Normal if bDeg3InLoftDir_Not1 else rg.LoftType.Straight,\r\n                        closed=False)\r\n                    def extendOtherDir(breps):\r\n                        for i, brep in enumerate(breps):\r\n                            # Changing U is loft direction.\r\n                            ns = brep.Surfaces[0]\r\n                            interval = ns.Domain(0)\r\n                            interval.Reverse()\r\n                            if not ns.Extend(direction=0, interval=interval):\r\n                                continue\r\n                            ns = brep.Surfaces[0]\r\n                            breps[i] = ns.ToBrep()\r\n                    if breps_Loft and bBothDirs:\r\n                        breps_Loft = list(breps_Loft)\r\n                        extendOtherDir(breps_Loft)\r\n                    rgBs_FromLoft.extend(breps_Loft)\r\n\r\n\r\n                    nc_FinStart.Dispose()\r\n\r\n                if rgBs_JoinedLofts:\r\n                    for rgB in rgBs_JoinedLofts: rgB.Dispose()\r\n                    rgBs_JoinedLofts = None\r\n                gBs_Out = []\r\n                if rgBs_FromLoft:\r\n                    rgBs_JoinedLofts = rg.Brep.JoinBreps(\r\n                        rgBs_FromLoft,\r\n                        tolerance=2.0*sc.doc.ModelAbsoluteTolerance)\r\n                    for _ in rgBs_FromLoft: _.Dispose()\r\n\r\n\r\n                conduit.breps = rgBs_JoinedLofts\r\n                conduit.crvs = []\r\n                conduit.lines = []\r\n\r\n            else:\r\n                # Not Loose.\r\n                if bAtGrevilles or bAtKnots or bAtEqualDivisions:\r\n                    for nc_FinStart in ncs_FinStart:\r\n                        rc = _createArrayedLines(\r\n                            rgCrv=nc_FinStart,\r\n                            rgSrf=rgF_In,\r\n                            fDistance=fDistance,\r\n                            fAngle_Start_Deg=fAngle_Start_Deg,\r\n                            fAngle_End_Deg=fAngle_End_Deg,\r\n                            rgCrv_Full=rgC_In_TrimmedToFace,\r\n                            bAngleChangePerCrvParam_NotLength=bAngleChangePerCrvParam_NotLength,\r\n                            bAtGrevilles=bAtGrevilles,\r\n                            bAtKnots=bAtKnots,\r\n                            bAtEqualDivisions=bAtEqualDivisions,\r\n                            iDivisionCt=iDivisionCt)\r\n                        if rc:\r\n                            rgLs_ForOut.extend(rc)\r\n\r\n                conduit.breps = []\r\n                conduit.crvs = ncs_FinStart if bAddCrv else []\r\n                conduit.lines = rgLs_ForOut\r\n\r\n            conduit.Enabled = True\r\n\r\n            sc.doc.Views.Redraw()\r\n\r\n            if bEcho:\r\n                sOut = []\r\n                if len(rgBs_JoinedLofts) > 1: sOut.append((\"{} brep(s)\".format(len(rgBs_JoinedLofts))))\r\n                if len(ncs_FinStart) > 1: sOut.append(\"{} fin start curves\".format(len(ncs_FinEnd)))\r\n                if rgLs_ForOut: sOut.append(\"{} lines\".format(len(rgLs_ForOut)))\r\n                if sOut:\r\n                    print(\"Calculated {}.\".format(\", \".join(sOut)))\r\n\r\n\r\n        rc = _getInput_Click()\r\n\r\n        conduit.Enabled = False\r\n\r\n        if rc is None:\r\n            for _ in rgBs_JoinedLofts: _.Dispose()\r\n            for _ in ncs_FinEnd: _.Dispose()\r\n            return\r\n\r\n        if not rc:\r\n            return (\r\n                rgBs_JoinedLofts,\r\n                ncs_FinStart if bAddCrv else [],\r\n                rgLs_ForOut,\r\n                bEcho)\r\n\r\n\r\n        for _ in rgBs_JoinedLofts: _.Dispose()\r\n        for _ in ncs_FinEnd: _.Dispose()\r\n\r\n\r\n\r\n        bLoose = Opts.values['bLoose']\r\n        bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n        bExplodePolyCrv = Opts.values['bExplodePolyCrv']\r\n        bSplitAtPolyKnots = Opts.values['bSplitAtPolyKnots']\r\n        bSimplifyCrv = Opts.values['bSimplifyCrv']\r\n        fAngle_Start_Deg = Opts.values['fAngle_Start_Deg']\r\n        fAngle_End_Deg = Opts.values['fAngle_End_Deg'] if Opts.values['bVariableAngle'] else None\r\n        bAngleChangePerCrvParam_NotLength = Opts.values['bAngleChangePerCrvParam_NotLength']\r\n        fDistance = Opts.values['fDistance']\r\n        fSimplifyCrvTol = Opts.values['fSimplifyCrvTol']\r\n        bDeg3InLoftDir_Not1 = Opts.values['bDeg3InLoftDir_Not1']\r\n        bBothDirs = Opts.values['bBothDirs']\r\n        bAddCrv = Opts.values['bAddCrv']\r\n        bAtGrevilles = Opts.values['bAtGrevilles']\r\n        bAtKnots = Opts.values['bAtKnots']\r\n        bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n        iDivisionCt = Opts.values['iDivisionCt']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n        #sEval='fDistance'; print(sEval+':',eval(sEval))\r\n        #sEval='fAngle_Start_Deg'; print(sEval+':',eval(sEval))\r\n        #sEval='fAngle_End_Deg'; print(sEval+':',eval(sEval))\r\n\r\n\r\ndef main():\r\n\r\n    rc = _createGeometryInteractively()\r\n    if rc is None: return\r\n\r\n    rgBs, rgCs, rgLs, bEcho = rc\r\n\r\n    gBs = []\r\n    for rgB in rgBs:\r\n        gB = sc.doc.Objects.AddBrep(rgB)\r\n        rgB.Dispose()\r\n        if gB != gB.Empty:\r\n            gBs.append(gB)\r\n\r\n    gCs = []\r\n    for rgC in rgCs:\r\n        gC = sc.doc.Objects.AddCurve(rgC)\r\n        if gC != gC.Empty:\r\n            gCs.append(gC)\r\n\r\n    gLs = [] # LineCurves\r\n    for line in rgLs:\r\n        gL = sc.doc.Objects.AddLine(line)\r\n        if gL != gL.Empty:\r\n            gLs.append(gL)\r\n\r\n    if bEcho:\r\n        sOut = []\r\n        if gBs:\r\n            iCt_Fs = sum(sc.doc.Objects.FindId(g).BrepGeometry.Faces.Count for g in gBs)\r\n            sOut.append((\"{} brep(s) with {} faces\".format(\r\n                len(gBs), iCt_Fs)))\r\n        if gCs: sOut.append(\"{} fin end curves\".format(len(gCs)))\r\n        if gLs: sOut.append(\"{} lines\".format(len(gLs)))\r\n        print(\"Added {}\".format(\", \".join(sOut)))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}