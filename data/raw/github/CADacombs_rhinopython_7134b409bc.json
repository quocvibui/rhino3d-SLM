{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_ExtrudeCrvTapered_Not_using_CFTE.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_ExtrudeCrvTapered_Not_using_CFTE.py",
  "instruction": "This script is an alternative to _ExrudeCrvTapered.\r\n\r\nAlthough it doesn't have all _ExrudeCrvTapered's options, e.g., Corners,\r\nit has a few additional features:\r\n    It can create simple/loose...",
  "code": "\"\"\"\r\nThis script is an alternative to _ExrudeCrvTapered.\r\n\r\nAlthough it doesn't have all _ExrudeCrvTapered's options, e.g., Corners,\r\nit has a few additional features:\r\n    It can create simple/loose extrudes.\r\n    It can create variable tapers, where the start and end angles are\r\n        at the ends of each connected path profile.\r\n    It can align the ends of the tapered-to curves with the curves to taper-from curves\r\n        to aid in constructing contiguous breps with G1 continuity.\r\n    Besides b-reps, it optionally outputs curves used in the construction of the b-reps.\r\n\r\nLimitations:\r\n    There is no equivalent option to _ExtrudeCrvTapered's Corners.\r\n    Variable taper is disabled for closed, including periodic, curves.\r\n    Closed, non-periodic, single-segment curves are split in 2 instead of creating 3-vertex breps.\r\n\r\nOptions:\r\n    NumberEntry\r\n        Dist: Direct numeric entry will set value of Distance setting.\r\n        DraftAngle: Direct numeric entry will set value of DraftAngle setting.\r\n    Distance: Length of taper\r\n    DistType\r\n        Projected: The extrusion direction length matches the Distance value (a la _ExtrudeCrvTapered).\r\n        True: Each section length matches the Distance value.\r\n    VariableTaper: Indicate whether the ends of the path profiles can have different DraftAngles with angles interpolated between them the profiles.\r\n    TaperChangePerCrv: \r\n    DraftAngle/StartDraftAngle: Angle of draft/taper.\r\n    EndDraftAngle\r\n    SwapAngles: Swap the values of StartDraftAngle and EndDraftAngle.\r\n    TaperChangePerCrv\r\n        Length: Arc lengths determine the amount to interpolate the draft angles between assigned ends.\r\n        Param: Curve parameters determine the amount to interpolate the draft angles between assigned ends.\r\n    FlipDir: Negates value of Distance.\r\n    FlipAngle: Negates value of VariableTaper.\r\n    DirPerZAxisOf\r\n        CPlane: Working view's CPlane's ZAxis is the pull/draw direction.\r\n        World: World's ZAxis is the pull/draw direction regardless of current CPlane of the working view.\r\n    OnlyBezierOut: Multi-span NurbsCurves are split at all interior knots.\r\n    AlignEndDirs: Each end of taper segment is aligned to its relative end of its path segment.\r\n        This creates G1 continuity when the adjacent path segments are G1-continuous at their ends.\r\n    AtGrevilles: Calculate taper line at all Grevilles for optional output of the lines.  This is calculated regardless for some other option settings.\r\n    AtKnots: Calculate taper line at all knots for optional output of the lines.\r\n    AtEqualDivisions: Calculate taper line at all Grevilles for optional output of the lines.\r\n    DivisionCt: Only available when AtEqualDivisions=Yes, sets how many divisions each profile/segment is divided.\r\n    AddCrvs\r\n    AddBrep\r\n    BrepMethod\r\n        GrevilleOnly\r\n        LoftSectionLines\r\n        Sweep2BrepMethod\r\n        Sweep2Class\r\n        Network\r\n    BrepTol\r\n    Echo\r\n    Debug\r\n\r\nSend any questions, comments, or script development service needs to @spb on the McNeel Forums: https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190604: Created from a split from another script.  Added bAddTaperEndCrvs.\r\n190624: Now, command waits for Enter or options when curves are preselected.\r\n...\r\n220828: Added an option.  Refactored.\r\n231117-21: Added bAlignEndDirs.  Removed bRebuildPath.  Prepared path curves are now added with other curves.\r\n        Replaced an import with some of its code, then simplified it.\r\n        Input of curves can no longer be modified during script execution after their first selection.\r\n        Instead, left clicks will cycle through distance and angle signs.\r\n        Replaced adding DocObjects for pending geometry with DrawConduit until results are accepted.\r\n        Now supports periodic curves.\r\n231126: Bug fixes: One for handling DuplicateCurve simplified output.  One for\r\n        tapered line output versus brep method.\r\n240711: Bug fix to correctly extract Greville points of input with mixed curve\r\n        types and/or NurbsCurve degrees.\r\n\r\nTODO: (Maybe) For AlignEndDirs, adjust tapered line curves.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport math\r\n\r\nfrom System import Enum\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bNumResForDist_NotAngle'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'NumberEntry'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'DraftAngle', 'Dist')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDistance'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bProjDist'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DistType'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'True', 'Projected')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bVariableTaper'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fAngle_Start_Deg'; keys.append(key)\r\n    values[key] = 45.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fAngle_End_Deg'; keys.append(key)\r\n    values[key] = 45.0\r\n    names[key] = 'EndDraftAngle'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bTaperChangePerCrvParam_NotArcLength'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'TaperChangePerCrv'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Length', 'Param')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bCPlane'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DirPerZAxisOf'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'World', 'CPlane')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSplitPathsAtG2PlusKnots'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'OnlyBezierOut'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAlignEndDirs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtGrevilles'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtKnots'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAtEqualDivisions'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDivisionCt'; keys.append(key)\r\n    values[key] = 2\r\n    riOpts[key] = ri.Custom.OptionInteger(\r\n            initialValue=values[key],\r\n            setLowerLimit=True,\r\n            limit=2)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddBrep'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iBrepMethod'; keys.append(key)\r\n    listValues[key] = 'GrevilleOnly', 'LoftSectionLines', 'Sweep2BrepMethod', 'Sweep2Class', 'Network' # All items must be strings.\r\n    values[key] = 0\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iLoftType'; keys.append(key)\r\n    listValues[key] = Enum.GetNames(rg.LoftType)\r\n    values[key] = 0\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fBrepTol'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=1e-6)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDistance':\r\n            if -1e-6 < cls.riOpts[key].CurrentValue < 1e-6:\r\n                print(\"fDistance input is too small.\")\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                return\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fBrepTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            print(\"Why is key, {}, here?  Value was not set or sticky-saved.\".format(key))\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _addCommonOptions(go):\r\n    idxs_Opt = {}\r\n\r\n    Opts.names['fAngle_Start_Deg'] = 'StartDraftAngle' if Opts.values['bVariableTaper'] else 'DraftAngle'\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    addOption('bNumResForDist_NotAngle')\r\n    addOption('fDistance')\r\n    if not Opts.values['bVariableTaper']:\r\n        addOption('bProjDist')\r\n    addOption('bVariableTaper')\r\n    addOption('fAngle_Start_Deg')\r\n    if Opts.values['bVariableTaper']:\r\n        addOption('fAngle_End_Deg')\r\n        idxs_Opt['SwapAngles'] = go.AddOption('SwapAngles')\r\n        addOption('bTaperChangePerCrvParam_NotArcLength')\r\n    idxs_Opt['FlipDir'] = go.AddOption('FlipDir')\r\n    idxs_Opt['FlipAngle'] = go.AddOption('FlipAngle')\r\n    addOption('bCPlane')\r\n    addOption('bSplitPathsAtG2PlusKnots')\r\n    addOption('bAlignEndDirs')\r\n    addOption('bAtGrevilles')\r\n    addOption('bAtKnots')\r\n    addOption('bAtEqualDivisions')\r\n    if Opts.values['bAtEqualDivisions']:\r\n        addOption('iDivisionCt')\r\n    addOption('bAddCrvs')\r\n    addOption('bAddBrep')\r\n    if Opts.values['bAddBrep']:\r\n        addOption('iBrepMethod')\r\n        if Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'LoftSectionLines':\r\n            addOption('iLoftType')\r\n        addOption('fBrepTol')\r\n    addOption('bEcho')\r\n    addOption('bDebug')\r\n\r\n    return idxs_Opt\r\n\r\n\r\ndef _getInput_Crvs():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \r\n    Returns\r\n        None to cancel.\r\n        ObjRefs[]\r\n    \"\"\"\r\n\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select curves to extrude\")\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=False)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n        idxs_Opt.clear()\r\n        idxs_Opt = _addCommonOptions(go)\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return \r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDistance' if Opts.values['bNumResForDist_NotAngle'] else 'fAngle_Start_Deg'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n        elif Opts.values['bVariableTaper'] and go.OptionIndex() == idxs_Opt['SwapAngles']:\r\n            Opts.riOpts['fAngle_Start_Deg'].CurrentValue, Opts.riOpts['fAngle_End_Deg'].CurrentValue = (\r\n                    Opts.riOpts['fAngle_End_Deg'].CurrentValue, Opts.riOpts['fAngle_Start_Deg'].CurrentValue)\r\n            Opts.setValue('fAngle_Start_Deg')\r\n            Opts.setValue('fAngle_End_Deg')\r\n        elif go.OptionIndex() == idxs_Opt['FlipAngle']:\r\n            for key in 'fAngle_Start_Deg', 'fAngle_End_Deg':\r\n                Opts.riOpts[key].CurrentValue = -Opts.riOpts[key].CurrentValue\r\n                Opts.setValue(key)\r\n        elif go.OptionIndex() == idxs_Opt['FlipDir']:\r\n            for key in 'fDistance', 'fAngle_Start_Deg', 'fAngle_End_Deg':\r\n                Opts.riOpts[key].CurrentValue = -Opts.riOpts[key].CurrentValue\r\n                Opts.setValue(key)\r\n        elif Opts.values['bAddBrep'] and go.OptionIndex() == idxs_Opt['iBrepMethod']:\r\n            Opts.setValue('iBrepMethod', go.Option().CurrentListOptionIndex)\r\n            #Opts.values['iBrepMethod'] = go.Option().CurrentListOptionIndex\r\n        elif Opts.values['bAddBrep'] and Opts.values['iBrepMethod'] == 1 and go.OptionIndex() == idxs_Opt['iLoftType']:\r\n            #Opts.values['iLoftType'] = go.Option().CurrentListOptionIndex\r\n            Opts.setValue('iLoftType', go.Option().CurrentListOptionIndex)\r\n        else:\r\n            for key in idxs_Opt:\r\n                if go.Option().Index == idxs_Opt[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n\r\ndef _getInput_Opts():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \r\n    Returns\r\n        None to cancel.\r\n        bool(Generate new geometry), bool(Accept results):\r\n    \"\"\"\r\n\r\n\r\n    gp = ri.Custom.GetPoint()\r\n\r\n    bDefaultsForClickDirFlipOnly = (\r\n        (not Opts.values['bVariableTaper'] and\r\n            Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0))\r\n        or\r\n        (Opts.values['bVariableTaper'] and\r\n            Opts.values['fAngle_Start_Deg'] in (0.0, 90.0, 180.0, 270.0) and\r\n            Opts.values['fAngle_End_Deg'] == Opts.values['fAngle_Start_Deg'])\r\n        )\r\n\r\n    if bDefaultsForClickDirFlipOnly:\r\n        gp.SetCommandPrompt(\"Left click to flip direction\")\r\n    else:\r\n        gp.SetCommandPrompt(\"Left click to cycle 4 angle and direction combos\")\r\n\r\n\r\n    gp.SetCommandPromptDefault(\"Accept results\")\r\n    gp.AcceptNothing(True)\r\n    gp.AcceptNumber(True, acceptZero=False)\r\n\r\n    idxs_Opt = _addCommonOptions(gp)\r\n\r\n\r\n    res = gp.Get()\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        gp.Dispose()\r\n        return \r\n\r\n    if res == ri.GetResult.Nothing:\r\n        gp.Dispose()\r\n        return False, True\r\n\r\n    #sEval = \"bDefaultsForClickDirFlipOnly\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sEval = \"Opts.values['bVariableTaper']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sEval = \"Opts.values['fDistance']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sEval = \"Opts.values['fAngle_Start_Deg']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    #sEval = \"Opts.values['fAngle_End_Deg']\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    if res == ri.GetResult.Point:\r\n        if bDefaultsForClickDirFlipOnly:\r\n            Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n            Opts.setValue('fDistance')\r\n        else:\r\n            if (\r\n                Opts.riOpts['fDistance'].CurrentValue > 0.0 and\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue >= 0.0\r\n            ):\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n                Opts.setValue('fAngle_Start_Deg')\r\n                Opts.setValue('fAngle_End_Deg')\r\n            elif (\r\n                Opts.riOpts['fDistance'].CurrentValue < 0.0 and\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue >= 0.0\r\n            ):\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n                Opts.setValue('fAngle_Start_Deg')\r\n                Opts.setValue('fAngle_End_Deg')\r\n            elif (\r\n                Opts.riOpts['fDistance'].CurrentValue < 0.0 and\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue <= 0.0\r\n            ):\r\n                Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n                Opts.setValue('fDistance')\r\n                Opts.setValue('fAngle_Start_Deg')\r\n                Opts.setValue('fAngle_End_Deg')\r\n            elif (\r\n                Opts.riOpts['fDistance'].CurrentValue > 0.0 and\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue <= 0.0\r\n            ):\r\n                Opts.riOpts['fDistance'].CurrentValue = -Opts.riOpts['fDistance'].CurrentValue\r\n                Opts.riOpts['fAngle_Start_Deg'].CurrentValue = -Opts.riOpts['fAngle_Start_Deg'].CurrentValue\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue = -Opts.riOpts['fAngle_End_Deg'].CurrentValue\r\n                Opts.setValue('fDistance')\r\n                Opts.setValue('fAngle_Start_Deg')\r\n                Opts.setValue('fAngle_End_Deg')\r\n            else:\r\n                raise Exception(\"What happened?\")\r\n        gp.Dispose()\r\n        return True, False\r\n\r\n    if res == ri.GetResult.Number:\r\n        key = 'fDistance' if Opts.values['bNumResForDist_NotAngle'] else 'fAngle_Start_Deg'\r\n        Opts.riOpts[key].CurrentValue = gp.Number()\r\n        Opts.setValue(key)\r\n    elif Opts.values['bVariableTaper'] and gp.OptionIndex() == idxs_Opt['SwapAngles']:\r\n        Opts.riOpts['fAngle_Start_Deg'].CurrentValue, Opts.riOpts['fAngle_End_Deg'].CurrentValue = (\r\n                Opts.riOpts['fAngle_End_Deg'].CurrentValue, Opts.riOpts['fAngle_Start_Deg'].CurrentValue)\r\n        Opts.setValue('fAngle_Start_Deg')\r\n        Opts.setValue('fAngle_End_Deg')\r\n    elif gp.OptionIndex() == idxs_Opt['FlipAngle']:\r\n        for key in 'fAngle_Start_Deg', 'fAngle_End_Deg':\r\n            Opts.riOpts[key].CurrentValue = -Opts.riOpts[key].CurrentValue\r\n            Opts.setValue(key)\r\n    elif gp.OptionIndex() == idxs_Opt['FlipDir']:\r\n        for key in 'fDistance', 'fAngle_Start_Deg', 'fAngle_End_Deg':\r\n            Opts.riOpts[key].CurrentValue = -Opts.riOpts[key].CurrentValue\r\n            Opts.setValue(key)\r\n    elif Opts.values['bAddBrep'] and gp.OptionIndex() == idxs_Opt['iBrepMethod']:\r\n        Opts.setValue('iBrepMethod', gp.Option().CurrentListOptionIndex)\r\n        #Opts.values['iBrepMethod'] = go.Option().CurrentListOptionIndex\r\n    elif Opts.values['bAddBrep'] and Opts.values['iBrepMethod'] == 1 and gp.OptionIndex() == idxs_Opt['iLoftType']:\r\n        #Opts.values['iLoftType'] = go.Option().CurrentListOptionIndex\r\n        Opts.setValue('iLoftType', gp.Option().CurrentListOptionIndex)\r\n    else:\r\n        for key in idxs_Opt:\r\n            if gp.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, gp.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n    return True, False\r\n\r\n\r\ndef continuityVectorsAt(nc, t, side=rg.CurveEvaluationSide.Default):\r\n    \"\"\"\r\n    Returns: Tuple of these 4 items:\r\n        3D point as a vector,\r\n        Unit tangent vector,\r\n        Curvature vector,\r\n        Vector for comparing G3 continuity, not the G3 vector itself\r\n        \r\n        None for any of aforementioned vectors on fail.\r\n    \"\"\"\r\n    \r\n    if not isinstance(nc, rg.NurbsCurve): return\r\n    \r\n    vs = nc.DerivativeAt(\r\n            t,\r\n            derivativeCount=3,\r\n            side=side)\r\n    \r\n    # Not using rg.Curve.TangentAt since it doesn't take into account CurveEvaluationSide.\r\n    vTangency = vs[1]/vs[1].Length\r\n\r\n    cross = rg.Vector3d.CrossProduct\r\n\r\n    # For R3\r\n    vCurvature = cross(cross(vs[1], vs[2]), vs[1]) / vs[1].Length**4\r\n\r\n    return vs[0], vTangency, vCurvature\r\n\r\n\r\ndef _getG2Discontinuities(rgCrv_In):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    fAngleTol_Rad = sc.doc.ModelAngleToleranceRadians\r\n    fRadiusTol = sc.doc.ModelAbsoluteTolerance\r\n\r\n    nc = rgCrv_In.ToNurbsCurve()\r\n\r\n    t0 = nc.Domain.T0\r\n    t1 = nc.Domain.T1\r\n\r\n    ts_discontinuities = []\r\n\r\n    bG3_discontinuousFound = False\r\n\r\n    # This will also skip simple knot overlaps of Periodic curves.\r\n    if nc.IsClosed and not nc.IsPeriodic:\r\n        iK = 0\r\n    else:\r\n        iK = nc.Degree\r\n    iK_Stop = nc.Knots.Count - nc.Degree\r\n\r\n    while iK < iK_Stop:\r\n        sc.escape_test()\r\n\r\n        m = nc.Knots.KnotMultiplicity(iK)\r\n\r\n        if m <= nc.Degree - 3:\r\n            # Continuity at this knot is at least G3.\r\n            iK += m\r\n            continue\r\n\r\n        if iK == 0:\r\n            (\r\n                vG0_Below,\r\n                vG1_Below,\r\n                vG2_Below,\r\n                ) = continuityVectorsAt(\r\n                    nc,\r\n                    nc.Knots[nc.Knots.Count - 1],\r\n                    rg.CurveEvaluationSide.Below)\r\n        else:\r\n            (\r\n                vG0_Below,\r\n                vG1_Below,\r\n                vG2_Below,\r\n                ) = continuityVectorsAt(\r\n                    nc,\r\n                    nc.Knots[iK],\r\n                    rg.CurveEvaluationSide.Below)\r\n\r\n\r\n        (\r\n            vG0_Above,\r\n            vG1_Above,\r\n            vG2_Above,\r\n            ) = continuityVectorsAt(\r\n                nc,\r\n                nc.Knots[iK],\r\n                rg.CurveEvaluationSide.Above)\r\n\r\n\r\n        # G1.\r\n\r\n        if m > nc.Degree - 1:\r\n\r\n            iParallel = vG1_Below.IsParallelTo(\r\n                other=vG1_Above, angleTolerance=fAngleTol_Rad)\r\n\r\n            if not iParallel == 1:\r\n                ts_discontinuities.append(nc.Knots[iK])\r\n                iK += m\r\n                continue\r\n\r\n\r\n        # G2.\r\n\r\n        if m > nc.Degree - 2:\r\n\r\n            if vG2_Below.IsTiny() and vG2_Above.IsTiny():\r\n                # Linear.\r\n                pass\r\n            else:\r\n\r\n                iParallel = vG2_Below.IsParallelTo(\r\n                    other=vG2_Above, angleTolerance=fAngleTol_Rad)\r\n\r\n                fCrvDelta_Degrees = Rhino.RhinoMath.ToDegrees(\r\n                    rg.Vector3d.VectorAngle(vG2_Below, vG2_Above))\r\n\r\n                if iParallel != 1:\r\n                    ts_discontinuities.append(nc.Knots[iK])\r\n                    iK += m\r\n                    continue\r\n                else:\r\n                    kappa_Below = vG2_Below.Length\r\n                    kappa_Above = vG2_Above.Length\r\n                    ratio_of_curvature = (abs(kappa_Below-kappa_Above) /\r\n                                        max(kappa_Below, kappa_Above))\r\n                    delta_radius = abs(1.0/kappa_Below-1.0/kappa_Above)\r\n                    if delta_radius > fRadiusTol:\r\n                        ts_discontinuities.append(nc.Knots[iK])\r\n                        iK += m\r\n                        continue\r\n\r\n        iK += m\r\n\r\n    nc.Dispose()\r\n\r\n    return ts_discontinuities\r\n\r\n\r\ndef _tallyCurveTypes(crvs):\r\n    sCrvTypes = []\r\n    for crv in crvs:\r\n        sCrvTypes.append(crv.GetType().Name)\r\n    sOuts = []\r\n    for sCrvType in sorted(set(sCrvTypes)):\r\n        sOuts.append(\"{} of {}\".format(sCrvTypes.count(sCrvType), sCrvType))\r\n    return sOuts\r\n\r\n\r\ndef _prepareCurves(rgCrvs_In, bSplitPathsAtG2PlusKnots=False, bMakeDeg_1_Deformable=True, bMakeDeg_2_Deformable=True):\r\n    \"\"\"\r\n    Prepare curves, including splitting per options.\r\n\r\n    Returns: list of (profile) lists of new curves\r\n    \"\"\"\r\n\r\n    # JoinCurves groups curves for further processing\r\n    # and also aligns direction within each PolyCurve.\r\n    if len(rgCrvs_In) == 1:\r\n        rgCrvs_Joined = [rgCrvs_In[0].DuplicateCurve()]\r\n    else:\r\n        rgCrvs_Joined = rg.Curve.JoinCurves(\r\n            rgCrvs_In,\r\n            joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n        if not rgCrvs_Joined: return\r\n\r\n    rgCs_Out = [] # Connected paths.\r\n\r\n    for rgCrv_Joined in rgCrvs_Joined:\r\n        segs = rgCrv_Joined.DuplicateSegments()\r\n\r\n        rgCrvs_ExplodedPoly = []\r\n\r\n        for seg in segs:\r\n            nc = seg.ToNurbsCurve()\r\n            seg.Dispose()\r\n\r\n            if nc.Degree != 2:\r\n                rgCrvs_ExplodedPoly.append(nc)\r\n                continue\r\n\r\n            # Multi-span, degree-2 curves are split to avoid creating kinks.\r\n            if nc.SpanCount == 1:\r\n                rgCrvs_ExplodedPoly.append(nc)\r\n                continue\r\n\r\n            bcs = rg.BezierCurve.CreateBeziers(nc)\r\n            nc.Dispose()\r\n            for bc in bcs:\r\n                nc2 = bc.ToNurbsCurve() # BezierCurve is not a subclass of rg.Curve.\r\n                rgCrvs_ExplodedPoly.append(nc2)\r\n                bc.Dispose()\r\n\r\n        rgCrv_Joined.Dispose()\r\n\r\n        # Split each curve at each G2 discontinuity.\r\n        rgCs_SplitAtNonG2_AllPolycrvs = []\r\n        for rgCrv_SplitPoly in rgCrvs_ExplodedPoly:\r\n            ts = _getG2Discontinuities(rgCrv_SplitPoly)\r\n            rgCs_SplitAtNonG2_ThisPolycrv = rgCrv_SplitPoly.Split(\r\n                [rgCrv_SplitPoly.Domain.T0] + ts + [rgCrv_SplitPoly.Domain.T1])\r\n            rgCs_SplitAtNonG2_AllPolycrvs.extend(rgCs_SplitAtNonG2_ThisPolycrv)\r\n\r\n        if not bSplitPathsAtG2PlusKnots:\r\n            rgCs_AfterG2PlusSplits = rgCs_SplitAtNonG2_AllPolycrvs[:] # Referencing same Geometry, so do not Dispose yet.\r\n        else:\r\n            rgCs_AfterG2PlusSplits = []\r\n            for c in rgCs_SplitAtNonG2_AllPolycrvs:\r\n                ts_SpanBoundaries = [c.Domain.T0]\r\n                for iSpan in xrange(c.SpanCount):\r\n                    ts_SpanBoundaries.append(c.SpanDomain(iSpan).T1)\r\n                rgCrvs_SplitAtKnots = c.Split(ts_SpanBoundaries)\r\n                rgCs_AfterG2PlusSplits.extend(rgCrvs_SplitAtKnots)\r\n                c.Dispose()\r\n\r\n        rgCs_Out_1Profile = [] # Will contain PolyCurves and/or NurbsCurves.\r\n\r\n        if not (bMakeDeg_1_Deformable or bMakeDeg_2_Deformable):\r\n            rgCs_Out_1Profile.extend(rgCs_AfterG2PlusSplits)\r\n        else:\r\n            for c in rgCs_AfterG2PlusSplits:\r\n                if bMakeDeg_1_Deformable and c.Points.Count == 2:\r\n                    if not c.IncreaseDegree(3):\r\n                        raise Exception(\"Could not raise degree of {}.\".format(c.GetType().Name))\r\n                elif bMakeDeg_2_Deformable and c.Points.Count == 3:\r\n                    if not c.IncreaseDegree(3):\r\n                        raise Exception(\"Could not raise degree of {}.\".format(c.GetType().Name))\r\n                rgCs_Out_1Profile.append(c)\r\n\r\n        if len(rgCs_Out_1Profile) == 1:\r\n            # Besides unnecessarily using JoinCurves,\r\n            # JoinCurves will also convert a degree-1 NurbsCurve into a PolylineCurve.\r\n            nc_Out = rgCs_Out_1Profile[0]\r\n\r\n            # TODO?: Splitting a non-periodic closed curve in 2 may be a temporary solution\r\n            # for handling the 2 angles at the kink.\r\n            if nc_Out.IsClosed and not nc_Out.IsPeriodic:\r\n                ncs_Out_Split = nc_Out.Split(nc_Out.Domain.Mid)\r\n                rgCs_Joined_Out = rg.Curve.JoinCurves(\r\n                    ncs_Out_Split,\r\n                    joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n                if len(rgCs_Joined_Out) != 1:\r\n                    raise Exception(\"JoinCurves should have returned 1 curves, but returned {} instead.\".format(len(rgCs_Joined_Out)))\r\n\r\n                rgCs_Out.append(rgCs_Joined_Out[0])\r\n                continue\r\n\r\n            rgCs_Out.append(nc_Out)\r\n            continue\r\n\r\n        rgCs_Joined_Out = rg.Curve.JoinCurves(\r\n            rgCs_Out_1Profile,\r\n            joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n        if len(rgCs_Joined_Out) != 1:\r\n            raise Exception(\"JoinCurves should have returned 1 curves, but returned {} instead.\".format(len(rgCs_Joined_Out)))\r\n\r\n        rgCs_Out.append(rgCs_Joined_Out[0])\r\n\r\n    return rgCs_Out\r\n\r\n\r\ndef _getGrevilleParametersWithinDomain(rgCrv_In, bDebug=False):\r\n    nc = rgCrv_In.ToNurbsCurve()\r\n    ts = list(nc.GrevilleParameters())\r\n    if bDebug:\r\n        print(\"_getGrevilleParametersWithinDomain ---v\")\r\n        print(\"All Greville parameters: {}\".format(nc.GrevilleParameters()))\r\n    if nc.IsPeriodic: # or _getG2Discontinuities(nc):\r\n        while ts[0] < nc.Domain.T0:\r\n            sc.escape_test()\r\n            del ts[0]\r\n        while ts[-1] >= nc.Domain.T1:\r\n            sc.escape_test()\r\n            del ts[-1]\r\n    if bDebug:\r\n        sEval = \"ts\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        print(\"_getGrevilleParametersWithinDomain ---^\")\r\n    nc.Dispose()\r\n    return ts\r\n\r\n\r\ndef _getParametersForLines(rgCrv_Path_Full, bAtGrevilles, bAtKnots, iEqualDivisionCt=None):\r\n\r\n    ts = []\r\n\r\n    if bAtGrevilles:\r\n        # Do not use NurbsCurve of full path in case the input is a\r\n        # PolyCurve containing mixed curve types and/or NurbsCurve degrees.\r\n        rgCs_Path_Segs = rgCrv_Path_Full.DuplicateSegments() # Various rg.Curve types.\r\n        ncs_Path_Segs = [c.ToNurbsCurve() for c in rgCs_Path_Segs]\r\n        for c in ncs_Path_Segs:\r\n            ts.extend(_getGrevilleParametersWithinDomain(c))\r\n            c.Dispose()\r\n\r\n    if iEqualDivisionCt or bAtKnots:\r\n        nc_Path_Full = rgCrv_Path_Full.ToNurbsCurve()\r\n\r\n        if iEqualDivisionCt:\r\n            rc = nc_Path_Full.DivideByCount(\r\n                    segmentCount=iEqualDivisionCt,\r\n                    includeEnds=True)\r\n            if rc: ts.extend(rc)\r\n            if nc_Path_Full.IsClosed:\r\n                ts.append(nc_Path_Full.Domain.T1)\r\n\r\n        if bAtKnots:\r\n            rc = set(nc_Path_Full.Knots)\r\n            if rc: ts.extend(rc)\r\n\r\n        nc_Path_Full.Dispose()\r\n\r\n    if ts is None:\r\n        print(\"No parameters were obtained.\")\r\n        return\r\n\r\n    ts = sorted(set(ts)) # Remove duplicates and sort.\r\n\r\n    return ts\r\n\r\n\r\ndef _calculateAnglesAtParameters(rgCrv_Path, ts, fAngle_Start_Deg, fAngle_End_Deg, bTaperChangePerCrvParam_NotArcLength, bDebug=False):\r\n    \"\"\"\r\n    All angles are in degrees.\r\n    \"\"\"\r\n\r\n\r\n    if fAngle_Start_Deg == fAngle_End_Deg:\r\n       return [fAngle_Start_Deg]*len(ts)\r\n\r\n\r\n    if not bTaperChangePerCrvParam_NotArcLength:\r\n        length_Full = rgCrv_Path.GetLength()\r\n\r\n    angles_ts = [fAngle_Start_Deg]\r\n\r\n    for i in range(1, len(ts) - 1):\r\n\r\n        t = ts[i]\r\n\r\n        #elif len(ts) >= 4 and iT == 1:\r\n        #    # Same angle so that the brep starts at a tangent.\r\n        #    angle_Rad = Rhino.RhinoMath.ToRadians(fAngle_Start_Deg)\r\n        #elif len(ts) >= 4 and iT == len(ts) - 2:\r\n        #    # Same angle so that the brep end at a tangent.\r\n        #    angle_Rad = Rhino.RhinoMath.ToRadians(fAngle_End_Deg)\r\n\r\n        if bTaperChangePerCrvParam_NotArcLength:\r\n            t_Normalized = rgCrv_Path.Domain.NormalizedParameterAt(t)\r\n            angle_t = (fAngle_Start_Deg * (1.0 - t_Normalized) +\r\n                       fAngle_End_Deg * t_Normalized)\r\n        else:\r\n            length_to_t = rgCrv_Path.GetLength(\r\n                    subdomain=rg.Interval(rgCrv_Path.Domain.T0, t))\r\n            angle_t = (fAngle_Start_Deg * (1.0 - length_to_t/length_Full) +\r\n                    fAngle_End_Deg * length_to_t/length_Full)\r\n\r\n        angles_ts.append(angle_t)\r\n\r\n        if bDebug: print(angle_t)\r\n\r\n    angles_ts.append(fAngle_End_Deg)\r\n\r\n    return angles_ts\r\n\r\n\r\ndef _createArrayedLines(rgCrv_Path_seg, Lc_ToArray, plane_Proj, ts_Profile, fAngles_ts_FullPath_Rads, bDebug=False):\r\n    \"\"\"\r\n    bAlignEndDirs: Used to determine whether to include last segment of closed curves.\r\n    \"\"\"\r\n\r\n    xform_Proj = rg.Transform.PlanarProjection(plane_Proj)\r\n\r\n    rgLcs_Arrayed = []\r\n\r\n    nc_Path = rgCrv_Path_seg.ToNurbsCurve()\r\n\r\n    nc_Path_Flattened = nc_Path.Duplicate()\r\n    nc_Path_Flattened.Transform(xform_Proj)\r\n\r\n    #sc.doc.Objects.AddCurve(rgCrv_Path_Flattened); return\r\n    rgLcs_Arrayed = []\r\n    ts_Out = []\r\n    for iT, t in enumerate(ts_Profile):\r\n        if t < nc_Path.Domain.T0:\r\n            continue\r\n        if t > nc_Path.Domain.T1:\r\n            continue\r\n\r\n        ts_Out.append(t)\r\n\r\n        angle_Taper_Rad = fAngles_ts_FullPath_Rads[iT]\r\n\r\n        bSuccess, frame = nc_Path_Flattened.PerpendicularFrameAt(t=t)\r\n        if not bSuccess:\r\n            raise Exception(\"Perpendicular frame could not be calculated.\")\r\n\r\n        angle_StraightenFrame_Rad = rg.Vector3d.VectorAngle(frame.YAxis, plane_Proj.ZAxis, frame)\r\n\r\n        frame.Rotate(\r\n            angle=angle_StraightenFrame_Rad + angle_Taper_Rad,\r\n            axis=frame.ZAxis)\r\n\r\n        # Debug frame orientation.\r\n        #sc.doc.Objects.AddPoint(frame.PointAt(0.0,0.0,0.0))\r\n        #attr_Red = rd.ObjectAttributes()\r\n        #attr_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        #attr_Red.ObjectColor = Color.Red\r\n        #sc.doc.Objects.AddPoint(frame.PointAt(1.0,0.0,0.0), attr_Red)\r\n        #attr_Green = rd.ObjectAttributes()\r\n        #attr_Green.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        #attr_Green.ObjectColor = Color.Lime\r\n        #sc.doc.Objects.AddPoint(frame.PointAt(0.0,1.0,0.0), attr_Green)\r\n\r\n        xform1 = rg.Transform.PlaneToPlane(plane_Proj, frame)\r\n        xform2 = rg.Transform.Translation(\r\n                nc_Path.PointAt(t)-nc_Path_Flattened.PointAt(t))\r\n        xform3 = xform2 * xform1\r\n\r\n        rgLc_Arrayed_WIP = Lc_ToArray.Duplicate()\r\n        rgLc_Arrayed_WIP.Transform(xform3)\r\n        rgLcs_Arrayed.append(rgLc_Arrayed_WIP)\r\n\r\n    nc_Path.Dispose()\r\n    nc_Path_Flattened.Dispose()\r\n\r\n    if rgCrv_Path_seg.IsClosed:\r\n        # Removing last if duplicate of first for certain closed curve cases.\r\n        dist_1st_and_last = rgLcs_Arrayed[0].Line.From.DistanceTo(rgLcs_Arrayed[-1].Line.From)\r\n        if bDebug:\r\n            sEval = \"dist_1st_and_last\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        if dist_1st_and_last <= 1e-6:\r\n            dist_1st_and_last = rgLcs_Arrayed[0].Line.To.DistanceTo(rgLcs_Arrayed[-1].Line.To)\r\n            if bDebug:\r\n                sEval = \"dist_1st_and_last\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            if dist_1st_and_last <= 1e-6:\r\n                rgLcs_Arrayed.pop()\r\n                ts_Out.pop()\r\n\r\n    return rgLcs_Arrayed, ts_Out\r\n\r\n\r\ndef _matchCrvEndDirs(nc_ToMod, nc_Ref):\r\n    \"\"\"\r\n    nc_ToMod is modified.\r\n    \"\"\"\r\n    \r\n    if nc_ToMod.Points.Count < 4:\r\n        return False\r\n    \r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=False,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtStart,\r\n        tangent=nc_Ref.TangentAtStart)\r\n    if not bSuccess:\r\n        raise Exception(\"SetEndCondition failed.\")\r\n        return False\r\n    bSuccess = nc_ToMod.SetEndCondition(\r\n        bSetEnd=True,\r\n        continuity=rg.NurbsCurve.NurbsCurveEndConditionType.Tangency,\r\n        point=nc_ToMod.PointAtEnd,\r\n        tangent=nc_Ref.TangentAtEnd)\r\n    if not bSuccess:\r\n        raise Exception(\"SetEndCondition failed.\")\r\n        return False\r\n\r\n    return True\r\n\r\n\r\ndef createBrep(iBrepMethod, iLoftType, fBrepTol, rgCrv_Path, rgNurbsCrv_TaperEnd_1Seg, rgLineCrvs_Arrayed):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if not isinstance(rgCrv_Path, rg.NurbsCurve):\r\n        raise Exception(\"{} passed to createBrep for path.\".format(rgCrv_Path.GetType().Name))\r\n\r\n    rgNurbsCrv1_PathSeg = rgCrv_Path.ToNurbsCurve()\r\n\r\n    rgBs_Out = []\r\n\r\n    if Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'GrevilleOnly':\r\n        rgBs_Out = rg.Brep.CreateFromLoft(\r\n                curves=[rgNurbsCrv1_PathSeg, rgNurbsCrv_TaperEnd_1Seg],\r\n                start=rg.Point3d.Unset,\r\n                end=rg.Point3d.Unset,\r\n                loftType=rg.LoftType.Straight,\r\n                closed=False)\r\n    elif Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'LoftSectionLines':\r\n        rgBs_Out = rg.Brep.CreateFromLoft(\r\n                curves=rgLineCrvs_Arrayed,\r\n                start=rg.Point3d.Unset,\r\n                end=rg.Point3d.Unset,\r\n                loftType=Enum.ToObject(rg.LoftType, iLoftType),\r\n                closed=rgNurbsCrv1_PathSeg.IsClosed)\r\n    elif Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'Sweep2BrepMethod':\r\n        rgBs_Out = rg.Brep.CreateFromSweep(\r\n                rail1=rgNurbsCrv1_PathSeg,\r\n                rail2=rgNurbsCrv_TaperEnd_1Seg,\r\n                shapes=rgLineCrvs_Arrayed,\r\n                closed=rgNurbsCrv1_PathSeg.IsClosed,\r\n                tolerance=fBrepTol)\r\n    elif Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'Sweep2Class':\r\n        rgSweep2 = rg.SweepTwoRail()\r\n        #rgSweep2.AngleToleranceRadians\r\n        rgSweep2.ClosedSweep = rgNurbsCrv1_PathSeg.IsClosed\r\n        rgSweep2.MaintainHeight = False\r\n        rgSweep2.SweepTolerance = fBrepTol\r\n        rgBs_Out = rgSweep2.PerformSweep(\r\n                rail1=rgNurbsCrv1_PathSeg,\r\n                rail2=rgNurbsCrv_TaperEnd_1Seg,\r\n                crossSections=rgLineCrvs_Arrayed)\r\n    elif Opts.listValues['iBrepMethod'][Opts.values['iBrepMethod']] == 'Network':\r\n        # continuity of 1 = position\r\n        rgNurbsSrf, iError = rg.NurbsSurface.CreateNetworkSurface(\r\n                curves=[rgNurbsCrv1_PathSeg, rgNurbsCrv_TaperEnd_1Seg]+rgLineCrvs_Arrayed,\r\n                continuity=1,\r\n                edgeTolerance=fBrepTol,\r\n                interiorTolerance=fBrepTol,\r\n                angleTolerance=sc.doc.ModelAngleToleranceDegrees)\r\n        if iError:\r\n            print(\"CreateNetworkSurface error code: {}\".format(iError))\r\n        else:\r\n            rgBs_Out = [rgNurbsSrf.ToBrep()]\r\n            rgNurbsSrf.Dispose()\r\n\r\n    rgNurbsCrv1_PathSeg.Dispose()\r\n\r\n    return rgBs_Out\r\n\r\n\r\ndef _createGeometryForProfile(rgC_Profile_Prepared, Lc_ToArray, plane_Proj, fAngle_Start_Deg, fAngle_End_Deg, bTaperChangePerCrvParam_NotArcLength, bAlignEndDirs, bAtGrevilles, bAtKnots, iDivisionCt, bAddBrep, iBrepMethod, iLoftType, fBrepTol, bDebug=False):\r\n\r\n    Lcs_Arrayed_Profile = []\r\n    rgCs_TaperEnd_Profile = []\r\n    rgBs_1Profile = []\r\n\r\n    if fAngle_Start_Deg != fAngle_End_Deg:\r\n        if rgC_Profile_Prepared.IsClosed and fAngle_End_Deg != fAngle_Start_Deg:\r\n            print(\"Variable taper was disabled for closed path profile.\")\r\n            if fAngle_Start_Deg != 0.0:\r\n                fAngle_End_Deg = fAngle_Start_Deg\r\n            else:\r\n                fAngle_Start_Deg = fAngle_End_Deg\r\n\r\n    ts_Lines_PerOpts_FullPath = _getParametersForLines(rgC_Profile_Prepared, bAtGrevilles, bAtKnots, iDivisionCt)\r\n    ts_Lines_GrevsOnly_FullPath = _getParametersForLines(rgC_Profile_Prepared, bAtGrevilles=True, bAtKnots=False, iEqualDivisionCt=None)\r\n\r\n    fAngles_ts_PerOpts_FullPath_Degs = _calculateAnglesAtParameters(\r\n        rgC_Profile_Prepared,\r\n        ts_Lines_PerOpts_FullPath,\r\n        fAngle_Start_Deg,\r\n        fAngle_End_Deg,\r\n        bTaperChangePerCrvParam_NotArcLength,\r\n        bDebug)\r\n    fAngles_ts_PerOpts_FullPath_Rads = [Rhino.RhinoMath.ToRadians(deg) for deg in fAngles_ts_PerOpts_FullPath_Degs]\r\n\r\n    fAngles_ts_GrevsOnly_FullPath_Degs = _calculateAnglesAtParameters(\r\n        rgC_Profile_Prepared,\r\n        ts_Lines_GrevsOnly_FullPath,\r\n        fAngle_Start_Deg,\r\n        fAngle_End_Deg,\r\n        bTaperChangePerCrvParam_NotArcLength,\r\n        bDebug)\r\n    fAngles_ts_GrevsOnly_FullPath_Rads = [Rhino.RhinoMath.ToRadians(deg) for deg in fAngles_ts_GrevsOnly_FullPath_Degs]\r\n\r\n\r\n    rgCs_TaperStart_Profile = rgC_Profile_Prepared.DuplicateSegments() # Various rg.Curve types.\r\n\r\n\r\n    def getArrayedLineCrvsAtGrevillesOnly(nc_Path_seg, rgLcs_In, ts_Lcs_In):\r\n        rgLcs_Out = []\r\n        ts = _getGrevilleParametersWithinDomain(nc_Path_seg)\r\n        if bDebug:\r\n            sEval = \"ts\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        for i, t in enumerate(ts):\r\n            if t in ts_Lcs_In:\r\n                rgLcs_Out.append(rgLcs_In[ts_Lcs_In.index(t)])\r\n            elif i == len(ts)-1:\r\n                rgLcs_Out.append(rgLcs_Out[0])\r\n            else:\r\n                print(\"All Greville parameters: {}\".format(nc_Path_seg.GrevilleParameters()))\r\n                print(\"Parameter, {:.15f}, is not in list: {}\".format(t, ts_Lcs_In))\r\n                raise Exception(\"Parameter is not in list. See Command History for more info.\")\r\n        return rgLcs_Out\r\n\r\n\r\n    for i_Path_1Seg, rgC_Path_Seg in enumerate(rgCs_TaperStart_Profile):\r\n\r\n        nc_Path_seg = rgC_Path_Seg.ToNurbsCurve()\r\n\r\n        # These arrayed lines are per options.\r\n        rc = _createArrayedLines(\r\n            rgCrv_Path_seg=nc_Path_seg,\r\n            Lc_ToArray=Lc_ToArray,\r\n            plane_Proj=plane_Proj,\r\n            ts_Profile=ts_Lines_PerOpts_FullPath,\r\n            fAngles_ts_FullPath_Rads=fAngles_ts_PerOpts_FullPath_Rads,\r\n            bDebug=bDebug)\r\n        if rc is None:\r\n            raise Exception(\"Nothing returned from createArrayedGeometry.\")\r\n        Lcs_Arrayed_PerOpts_PathSeg, ts_Lcs_Arrayed_ThisSeg = rc\r\n\r\n        Lcs_Arrayed_Profile.extend(Lcs_Arrayed_PerOpts_PathSeg)\r\n\r\n        # Taper end segments require both taper start segments and tapered lines.\r\n        # Breps require taper start segments, tapered lines, and/or taper end segments,\r\n        # depending on the surface-creation method used.\r\n\r\n\r\n        # These arrayed lines are at Grevilles only.\r\n        rc = _createArrayedLines(\r\n            rgCrv_Path_seg=nc_Path_seg,\r\n            Lc_ToArray=Lc_ToArray,\r\n            plane_Proj=plane_Proj,\r\n            ts_Profile=ts_Lines_GrevsOnly_FullPath,\r\n            fAngles_ts_FullPath_Rads=fAngles_ts_GrevsOnly_FullPath_Rads,\r\n            bDebug=bDebug)\r\n        if rc is None:\r\n            raise Exception(\"Nothing returned from createArrayedGeometry.\")\r\n        Lcs_Arrayed__GrevsOnly_PathSeg, ts_Lcs_Arrayed_ThisSeg = rc\r\n\r\n\r\n        ## These arrayed lines are only at Greville points.\r\n        #rgLineCrvs_Arrayed_1PathSeg_GrevsOnly = getArrayedLineCrvsAtGrevillesOnly(\r\n        #    nc_Path_seg, \r\n        #    Lcs_Arrayed_ThisSeg,\r\n        #    ts_Lcs_Arrayed_ThisSeg)\r\n\r\n\r\n        # Create taper end curve.\r\n        def createTaperEndCrv(rgCrv1_Path_1Seg, rgLineCrvs_Arrayed_PathSeg_GrevsOnly):\r\n            pts_AtEndsOf_Lcs_Arrayed = []\r\n            for rgLc in rgLineCrvs_Arrayed_PathSeg_GrevsOnly:\r\n                pts_AtEndsOf_Lcs_Arrayed.append(rgLc.PointAtEnd)\r\n            nc_OppOfPath = rgCrv1_Path_1Seg.DuplicateCurve()\r\n            if not nc_OppOfPath.SetGrevillePoints(pts_AtEndsOf_Lcs_Arrayed):\r\n                pass\r\n#                sEval = \"len(nc_OppOfPath.GrevillePoints())\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n#                sEval = \"len(nc_OppOfPath.GrevillePoints(all=True))\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n#                sEval = \"len(nc_OppOfPath.GrevillePoints(all=False))\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n#                sEval = \"len(rgLineCrvs_Arrayed_PathSeg_GrevsOnly)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n#                for Lc in rgLineCrvs_Arrayed_PathSeg_GrevsOnly:\r\n#                    sc.doc.Objects.AddCurve(Lc)\r\n            return nc_OppOfPath\r\n        nc_OppOfPath = createTaperEndCrv(nc_Path_seg, Lcs_Arrayed__GrevsOnly_PathSeg)\r\n\r\n        if bAlignEndDirs and not nc_OppOfPath.IsPeriodic:\r\n            _matchCrvEndDirs(nc_OppOfPath, nc_Path_seg)\r\n\r\n\r\n        rgCs_TaperEnd_Profile.append(nc_OppOfPath)\r\n\r\n        if bAddBrep:\r\n            rc = createBrep(\r\n                iBrepMethod=iBrepMethod,\r\n                iLoftType=iLoftType,\r\n                fBrepTol=fBrepTol,\r\n                rgCrv_Path=nc_Path_seg,\r\n                rgNurbsCrv_TaperEnd_1Seg=nc_OppOfPath,\r\n                rgLineCrvs_Arrayed=Lcs_Arrayed_PerOpts_PathSeg)\r\n            if rc is None:\r\n                print(\"Cannot create brep(s).  Check input.\")\r\n            else:\r\n                # Save to later join, adding only the joined breps to the conduit.\r\n                rgBs_1Profile.extend(rc)\r\n\r\n    if bAddBrep and rgBs_1Profile:\r\n        rgBs_Joined = rg.Brep.JoinBreps(\r\n            rgBs_1Profile,\r\n            tolerance=2.0*fBrepTol)\r\n        for b in rgBs_1Profile: b.Dispose()\r\n    else:\r\n        rgBs_Joined = None\r\n\r\n    return (\r\n        rgCs_TaperStart_Profile,\r\n        Lcs_Arrayed_Profile,\r\n        rgCs_TaperEnd_Profile,\r\n        rgBs_Joined,\r\n        )\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.breps = []\r\n        self.crvs = []\r\n        self.lines = []\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        for brep in self.breps:\r\n            bbox = brep.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n        for crv in self.crvs:\r\n            bbox = crv.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n        for line in self.lines:\r\n            bbox = line.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        breps = self.breps\r\n        color = sc.doc.Layers.CurrentLayer.Color\r\n\r\n        for brep in breps:\r\n            displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n            da = displayMode.DisplayAttributes\r\n            if da.ShadingEnabled:\r\n                drawEventArgs.Display.DrawBrepShaded(\r\n                    brep=brep,\r\n                    material=Rhino.Display.DisplayMaterial(diffuse=color))\r\n            drawEventArgs.Display.DrawBrepWires(\r\n                brep=brep,\r\n                color=color,\r\n                wireDensity=1)\r\n\r\n        for crv in self.crvs:\r\n            drawEventArgs.Display.DrawCurve(\r\n                curve=crv,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n        if self.lines:\r\n            drawEventArgs.Display.DrawLines(\r\n                lines=self.lines,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n    def clearGeometry(self):\r\n        try:\r\n            for _ in self.breps:\r\n                if _: _.Dispose()\r\n            self.breps.Clear() # .NET method.\r\n            for _ in self.crvs:\r\n                if _: _.Dispose()\r\n            self.crvs.Clear() # .NET method.\r\n            self.lines.Clear() # .NET method.\r\n        except:\r\n            print(\"Failed in disposing and clearing conduit's geometry.\")\r\n\r\n\r\ndef main():\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__)\r\n\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n        if conduit:\r\n            conduit.clearGeometry()\r\n            conduit.Enabled = False\r\n            sc.doc.Views.Redraw()\r\n        if Opts.values['bDebug']:\r\n            conduit = None\r\n            conduit = DrawConduit()\r\n            sc.sticky[sk_conduit] = conduit\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n    else:\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n    objrefs_Paths = _getInput_Crvs()\r\n    if objrefs_Paths is None: return\r\n\r\n\r\n    rgCs_Paths_In = []\r\n    for objref_Path in objrefs_Paths:\r\n        c = objref_Path.Curve()\r\n        rgCs_Paths_In.append(c)\r\n\r\n    bGenerateNew = True\r\n    bAcceptResults = False\r\n\r\n    fDistance = Opts.values['fDistance']\r\n    bProjDist = Opts.values['bProjDist']\r\n    fAngle_Start_Deg = Opts.values['fAngle_Start_Deg']\r\n    bVariableTaper = Opts.values['bVariableTaper']\r\n    fAngle_End_Deg = Opts.values['fAngle_End_Deg'] if bVariableTaper else fAngle_Start_Deg\r\n    bTaperChangePerCrvParam_NotArcLength = Opts.values['bTaperChangePerCrvParam_NotArcLength']\r\n    bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n    bCPlane = Opts.values['bCPlane']\r\n    bAtGrevilles = Opts.values['bAtGrevilles']\r\n    bAtKnots = Opts.values['bAtKnots']\r\n    bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n    iDivisionCt = Opts.values['iDivisionCt']\r\n    bSplitPathsAtG2PlusKnots = Opts.values['bSplitPathsAtG2PlusKnots']\r\n    bAddCrvs = Opts.values['bAddCrvs']\r\n    bAddBrep = Opts.values['bAddBrep']\r\n    iBrepMethod = Opts.values['iBrepMethod']\r\n    iLoftType = Opts.values['iLoftType']\r\n    fBrepTol = Opts.values['fBrepTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    # Only setting these variables for code that checks them.\r\n    rgLine_ToArray = None\r\n    rgCs_Profiles_Prepared = []\r\n\r\n\r\n    while True:\r\n\r\n        while not (bAtGrevilles or bAtKnots or bAtEqualDivisions):\r\n            print(\"No path point sampling is enabled.\")\r\n            sc.doc.Views.Redraw()\r\n\r\n            rc = _getInput_Opts()\r\n            if rc is None:\r\n                if rgLine_ToArray: rgLine_ToArray.Dispose()\r\n                for c in rgCs_Profiles_Prepared: c.Dispose()\r\n                return\r\n\r\n            bGenerateNew, bAcceptResults = rc\r\n\r\n            if bAcceptResults:\r\n                if rgLine_ToArray: rgLine_ToArray.Dispose()\r\n                for c in rgCs_Profiles_Prepared: c.Dispose()\r\n                return\r\n\r\n            fDistance = Opts.values['fDistance']\r\n            bProjDist = Opts.values['bProjDist']\r\n            fAngle_Start_Deg = Opts.values['fAngle_Start_Deg']\r\n            bVariableTaper = Opts.values['bVariableTaper']\r\n            fAngle_End_Deg = Opts.values['fAngle_End_Deg'] if bVariableTaper else fAngle_Start_Deg\r\n            bTaperChangePerCrvParam_NotArcLength = Opts.values['bTaperChangePerCrvParam_NotArcLength']\r\n            bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n            bCPlane = Opts.values['bCPlane']\r\n            bAtGrevilles = Opts.values['bAtGrevilles']\r\n            bAtKnots = Opts.values['bAtKnots']\r\n            bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n            iDivisionCt = Opts.values['iDivisionCt']\r\n            bSplitPathsAtG2PlusKnots = Opts.values['bSplitPathsAtG2PlusKnots']\r\n            bAddCrvs = Opts.values['bAddCrvs']\r\n            bAddBrep = Opts.values['bAddBrep']\r\n            iBrepMethod = Opts.values['iBrepMethod']\r\n            iLoftType = Opts.values['iLoftType']\r\n            fBrepTol = Opts.values['fBrepTol']\r\n            bEcho = Opts.values['bEcho']\r\n            bDebug = Opts.values['bDebug']\r\n\r\n\r\n        if bAlignEndDirs:\r\n            bMakeDeg_1_Deformable = fAngle_End_Deg and (fAngle_End_Deg != fAngle_Start_Deg)\r\n            bMakeDeg_2_Deformable = True\r\n        else:\r\n            bMakeDeg_1_Deformable = False\r\n            bMakeDeg_2_Deformable = False\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\"Preparing path curves ...\")\r\n\r\n        rgCs_Profiles_Prepared = _prepareCurves(\r\n            rgCrvs_In=rgCs_Paths_In,\r\n            bSplitPathsAtG2PlusKnots=bSplitPathsAtG2PlusKnots,\r\n            bMakeDeg_1_Deformable=bMakeDeg_1_Deformable,\r\n            bMakeDeg_2_Deformable=bMakeDeg_2_Deformable)\r\n        if not rgCs_Profiles_Prepared:\r\n            print(\"No valid path curves were provided.\")\r\n            conduit = None\r\n            return\r\n\r\n\r\n        if bProjDist and not bVariableTaper:\r\n            rgLine_ToArray = rg.Line(\r\n                rg.Point3d(0.0, 0.0, 0.0),\r\n                rg.Point3d(\r\n                    0.0,\r\n                    fDistance/math.cos(math.radians(fAngle_Start_Deg)),\r\n                    0.0))\r\n        else:\r\n            rgLine_ToArray = rg.Line(\r\n                rg.Point3d(0.0, 0.0, 0.0),\r\n                rg.Point3d(0.0, fDistance, 0.0))\r\n\r\n        if bCPlane:\r\n            view_Active = sc.doc.Views.ActiveView\r\n            plane_Proj = view_Active.ActiveViewport.ConstructionPlane()\r\n        \r\n            xform1 = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, plane_Proj)\r\n            rgLine_ToArray.Transform(xform1)\r\n        else:\r\n            plane_Proj = rg.Plane.WorldXY\r\n\r\n        Lc_ToArray = rg.LineCurve(rgLine_ToArray)\r\n\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\"Creating geometry ...\")\r\n\r\n        for i_Path_Profile, rgC_Profile_Prepared in enumerate(rgCs_Profiles_Prepared):\r\n\r\n            rc = _createGeometryForProfile(\r\n                rgC_Profile_Prepared,\r\n                Lc_ToArray,\r\n                plane_Proj,\r\n                fAngle_Start_Deg,\r\n                fAngle_End_Deg,\r\n                bTaperChangePerCrvParam_NotArcLength,\r\n                bAlignEndDirs=bAlignEndDirs,\r\n                bAtGrevilles=bAtGrevilles,\r\n                bAtKnots=bAtKnots,\r\n                iDivisionCt = iDivisionCt if bAtEqualDivisions else None,\r\n                bAddBrep=bAddBrep,\r\n                iBrepMethod=iBrepMethod,\r\n                iLoftType=iLoftType,\r\n                fBrepTol=fBrepTol,\r\n                bDebug=bDebug,\r\n                )\r\n            (\r\n                rgCs_TaperStart_Profile,\r\n                rgLcs_Arrayed_Profile,\r\n                rgCs_TaperEnd_Profile,\r\n                rgBs_Res_Profile,\r\n                ) = rc\r\n\r\n\r\n            if bAddCrvs:\r\n                if rgCs_TaperStart_Profile: conduit.crvs.extend(rgCs_TaperStart_Profile)\r\n                if rgLcs_Arrayed_Profile: conduit.crvs.extend(rgLcs_Arrayed_Profile)\r\n                if rgCs_TaperEnd_Profile: conduit.crvs.extend(rgCs_TaperEnd_Profile)\r\n\r\n            if bAddBrep and rgBs_Res_Profile:\r\n                conduit.breps.extend(rgBs_Res_Profile)\r\n\r\n        conduit.Enabled = True\r\n\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n        rc = _getInput_Opts()\r\n        if rc is None:\r\n            conduit.clearGeometry()\r\n            conduit.Enabled = False\r\n            sc.doc.Views.Redraw()\r\n            return\r\n\r\n        bGenerateNew, bAcceptResults = rc\r\n\r\n        if bAcceptResults:\r\n            break\r\n\r\n        if not bGenerateNew:\r\n            continue\r\n\r\n        conduit.clearGeometry()\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n        fDistance = Opts.values['fDistance']\r\n        bProjDist = Opts.values['bProjDist']\r\n        fAngle_Start_Deg = Opts.values['fAngle_Start_Deg']\r\n        bVariableTaper = Opts.values['bVariableTaper']\r\n        fAngle_End_Deg = Opts.values['fAngle_End_Deg'] if bVariableTaper else fAngle_Start_Deg\r\n        bTaperChangePerCrvParam_NotArcLength = Opts.values['bTaperChangePerCrvParam_NotArcLength']\r\n        bAlignEndDirs = Opts.values['bAlignEndDirs']\r\n        bCPlane = Opts.values['bCPlane']\r\n        bAtGrevilles = Opts.values['bAtGrevilles']\r\n        bAtKnots = Opts.values['bAtKnots']\r\n        bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n        iDivisionCt = Opts.values['iDivisionCt']\r\n        bSplitPathsAtG2PlusKnots = Opts.values['bSplitPathsAtG2PlusKnots']\r\n        bAddCrvs = Opts.values['bAddCrvs']\r\n        bAddBrep = Opts.values['bAddBrep']\r\n        iBrepMethod = Opts.values['iBrepMethod']\r\n        iLoftType = Opts.values['iLoftType']\r\n        fBrepTol = Opts.values['fBrepTol']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n\r\n    gBs_Out = []\r\n    iCt_Faces_Added = 0\r\n    for rgB in conduit.breps:\r\n        gB_Out = sc.doc.Objects.AddBrep(rgB)\r\n        if gB_Out != gB_Out.Empty:\r\n            gBs_Out.append(gB_Out)\r\n            if bEcho:\r\n                rdB_Out = sc.doc.Objects.FindId(gB_Out)\r\n                iCt_Faces_Added += rdB_Out.BrepGeometry.Faces.Count\r\n    gCs_Out = []\r\n    for crv in conduit.crvs:\r\n        gCrv_Out = sc.doc.Objects.AddCurve(crv)\r\n        if gCrv_Out != gCrv_Out.Empty:\r\n            gCs_Out.append(gCrv_Out)\r\n\r\n    if bEcho:\r\n        if not (gBs_Out or gCs_Out):\r\n            print(\"Nothing added.\")\r\n        else:\r\n            sAdded = []\r\n            sAdded.append(\"{} curves\".format(len(gCs_Out)))\r\n            sAdded.append(\"{} breps with {} faces\".format(\r\n                len(gBs_Out), iCt_Faces_Added))\r\n            print(\"Added {}\".format(\", \".join(sAdded)))\r\n\r\n\r\n    conduit.clearGeometry()\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}