{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Layer_delete.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Layer_delete.py",
  "instruction": "180521-25: Created, starting with deleteCrvsInAllNonRefBlocks.py.\r\n190924-25: Bug fixes for better handling of blocks that may contain instances\r\n        to delete but are not on layers to delete.\r\n ...",
  "code": "\"\"\"\r\n180521-25: Created, starting with deleteCrvsInAllNonRefBlocks.py.\r\n190924-25: Bug fixes for better handling of blocks that may contain instances\r\n        to delete but are not on layers to delete.\r\n        Improved feedback.\r\n        Refactored.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\ndef getLayersToDelete(bEcho=True):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    layers_ToDel_Picked = rs.GetLayers(\r\n            \"Select layers to delete (Reference layers will be ignored.)\")\r\n    if not layers_ToDel_Picked: return\r\n    \r\n    layers_ToDel_Picked_NoRefs = []\r\n    for layer in layers_ToDel_Picked:\r\n        if not rs.IsLayerReference(layer):\r\n            layers_ToDel_Picked_NoRefs.append(layer)\r\n    \r\n    def getLayerDescendants(layer_Parent):\r\n        for layer_Child in rs.LayerChildren(layer_Parent):\r\n            layers_Descendant.append(layer_Child)\r\n            getLayerDescendants(layer_Child)\r\n    \r\n    layers_ToDel_WIP = layers_ToDel_Picked_NoRefs[:]\r\n    \r\n    # Add decendant layers if any layers have children.\r\n    for layer in layers_ToDel_Picked_NoRefs:\r\n        if rs.LayerChildCount(layer):\r\n            layers_Descendant = []\r\n            getLayerDescendants(layer)\r\n            \r\n            for layer_Desc in layers_Descendant:\r\n                \r\n                # Remove any layer already in list so that\r\n                # descendants succeed their ancestors.\r\n                if layer_Desc in layers_ToDel_WIP:\r\n                    layers_ToDel_WIP.remove(layer_Desc)\r\n                \r\n                layers_ToDel_WIP.append(layer_Desc)\r\n    \r\n    if bEcho and layers_ToDel_WIP:\r\n        print \"Layers to delete:\"\r\n        for layer in layers_ToDel_WIP:\r\n            print \"  \" + layer\r\n    \r\n    # Return the layers names to a new list in reverse order;\r\n    # Descendants precede their ancestors.\r\n    return layers_ToDel_WIP[::-1]\r\n\r\n\r\ndef getModifiableBlocks():\r\n    blocks_ToEval = []\r\n    for block in rs.BlockNames(sort=True):\r\n        if rs.IsBlockReference(block) or not rs.IsBlockEmbedded(block): continue\r\n        blocks_ToEval.append(block)\r\n    return blocks_ToEval\r\n\r\n\r\ndef getBlocksToDelete(layers_ToDel, bEcho=True):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    #\r\n    # Phase 1: Acquire names of all block definitions that contain\r\n    # no objects on layers to keep.\r\n    \r\n    blocks_ToDel_P1 = []\r\n    \r\n    for block in getModifiableBlocks():\r\n        bHasLayerToKeep = False\r\n        \r\n        for gBlockObj in rs.BlockObjects(block):\r\n            if rs.ObjectLayer(gBlockObj) not in layers_ToDel:\r\n                bHasLayerToKeep = True\r\n        \r\n        if not bHasLayerToKeep:\r\n            blocks_ToDel_P1.append(block)\r\n    #\r\n    \r\n    #\r\n    # Phase 2: Acquire names of all block definitions that contain\r\n    # no instances of blocks to keep and\r\n    # no non-instance objects on layers to keep.\r\n    \r\n    blocks_ToDel_P2 = []\r\n    \r\n    for block in getModifiableBlocks():\r\n        if block in blocks_ToDel_P1: continue\r\n        \r\n        bHasLayerToKeep = False\r\n        bHasInstToKeep = False\r\n        \r\n        for gBlockObj in rs.BlockObjects(block):\r\n            if rs.ObjectType(gBlockObj) == rs.filter.instance:\r\n                block_Inst = rs.BlockInstanceName(gBlockObj)\r\n                if block_Inst not in blocks_ToDel_P1:\r\n                    bHasInstToKeep = True\r\n            elif rs.ObjectLayer(gBlockObj) not in layers_ToDel:\r\n                bHasLayerToKeep = True\r\n            \r\n        \r\n        if not bHasLayerToKeep and not bHasInstToKeep:\r\n            blocks_ToDel_P2.append(block)\r\n    \r\n    blocks_ToDel_All = sorted(blocks_ToDel_P1 + blocks_ToDel_P2)\r\n    \r\n    if bEcho and blocks_ToDel_All:\r\n        print \"Blocks to delete:\"\r\n        for block in blocks_ToDel_All:\r\n            print \"  \" + block\r\n    \r\n    return blocks_ToDel_All\r\n\r\n\r\ndef getBlocksToModify(layers_ToDel, blocks_ToDel, bEcho=True):\r\n    \"\"\"\r\n    Acquire names of all block definitions to modify. This includes those that\r\n    are not set to be deleted and contain\r\n    (objects on layers to delete) or\r\n    (instances of block definitions to delete).\r\n    \"\"\"\r\n    \r\n    blocks_ToMod = []\r\n    \r\n    for block in getModifiableBlocks():\r\n        if block in blocks_ToDel: continue\r\n        \r\n        bHasLayerToDel = False\r\n        bHasInstToDel = False\r\n        \r\n        for gBlockObj in rs.BlockObjects(block):\r\n            if rs.ObjectType(gBlockObj) == rs.filter.instance:\r\n                if rs.BlockInstanceName(gBlockObj) in blocks_ToDel:\r\n                    bHasInstToDel = True\r\n            \r\n            if rs.ObjectLayer(gBlockObj) in layers_ToDel:\r\n                bHasLayerToDel = True\r\n        \r\n        if bHasLayerToDel or bHasInstToDel:\r\n            blocks_ToMod.append(block)\r\n    \r\n    if bEcho and blocks_ToMod:\r\n        print \"Blocks to modify (contain combination of instances and/or\" \\\r\n              \" other objects to delete and not to delete):\"\r\n        for block in blocks_ToMod:\r\n            print \"  \" + block\r\n    \r\n    return blocks_ToMod\r\n\r\n\r\ndef deleteObjectsEx(object_ids, ignore_modes=False):\r\n    # From https://discourse.mcneel.com/t/rs-deleteobject-with-object-in-locked-layer/39988/10\r\n    rc = 0\r\n    object_ids = rs.coerceguidlist(object_ids)\r\n    if object_ids:\r\n        for id in object_ids:\r\n            rhobj = rs.coercerhinoobject(id)\r\n            if rhobj and sc.doc.Objects.Delete(rhobj, True, ignore_modes): rc+=1\r\n        if rc: sc.doc.Views.Redraw()\r\n    return rc\r\n\r\n\r\ndef addBlock(object_ids, base_point, name=None, delete_input=False):\r\n    \"\"\"\r\n    rhinoscriptsyntax.AddBlock but allows other block definition instances to\r\n    be included in the block.\r\n    \r\n    Adds a new block definition to the document\r\n    Parameters:\r\n      object_ids ([guid, ....]) objects that will be included in the block\r\n      base_point (point): 3D base point for the block definition\r\n      name (str, optional): name of the block definition. If omitted a name will be\r\n        automatically generated\r\n      delete_input (bool): if True, the object_ids will be deleted\r\n    Returns:\r\n      str: name of new block definition on success\r\n    Example:\r\n      import rhinoscriptsyntax as rs\r\n      objs = rs.GetObjects(\"Select objects to define block\")\r\n      if objs:\r\n          point = rs.GetPoint(\"Block base point\")\r\n          if point:\r\n              block = rs.AddBlock(objs, point, None, True)\r\n              rs.InsertBlock(block, point)\r\n    See Also:\r\n      InsertBlock\r\n    \"\"\"\r\n    base_point = rs.coerce3dpoint(base_point, True)\r\n    if not name:\r\n        name = sc.doc.InstanceDefinitions.GetUnusedInstanceDefinitionName()\r\n    found = sc.doc.InstanceDefinitions.Find(name)\r\n    objects = []\r\n    for id in object_ids:\r\n        obj = rs.coercerhinoobject(id, True)\r\n        if obj.IsReference: return\r\n        ot = obj.ObjectType\r\n        if ot==Rhino.DocObjects.ObjectType.Light: return\r\n        if ot==Rhino.DocObjects.ObjectType.Grip: return\r\n        if ot==Rhino.DocObjects.ObjectType.Phantom: return\r\n        if ot==Rhino.DocObjects.ObjectType.InstanceReference and found:\r\n            uses, nesting = obj.UsesDefinition(found.Index)\r\n        #            if uses: return    # This is preventing blocks containing instances from being redefined.\r\n        objects.append(obj)\r\n    if objects:\r\n        geometry = [obj.Geometry for obj in objects]\r\n        attrs = [obj.Attributes for obj in objects]\r\n        rc = 0\r\n        if found:\r\n          rc = sc.doc.InstanceDefinitions.ModifyGeometry(found.Index, geometry, attrs)\r\n        else:\r\n          rc = sc.doc.InstanceDefinitions.Add(name, \"\", base_point, geometry, attrs)\r\n        if rc>=0:\r\n            if delete_input:\r\n                for obj in objects: sc.doc.Objects.Delete(obj, True)\r\n            sc.doc.Views.Redraw()\r\n    return name\r\n\r\n\r\ndef modifyBlocks(blocks_ToMod, layers_ToDel, blocks_ToDel, bEcho=True):\r\n    \"\"\"\r\n    \"\"\"\r\n    if bEcho: print \"Modifying blocks ...\"\r\n    \r\n    ctBlocksModified = 0\r\n    \r\n    # Lock all objects not in blocks before modifying blocks.\r\n    # Same list will be used later in rs.UnlockObjects.\r\n    gObjsToLock = rs.NormalObjects()\r\n    if gObjsToLock: rs.LockObjects(gObjsToLock)\r\n    \r\n    for iB, block in enumerate(blocks_ToMod):\r\n        # Delete objects on each layer to delete.\r\n        for gBlockObj in rs.ExplodeBlockInstance(\r\n                rs.InsertBlock(block, (0.0, 0.0, 0.0))):\r\n            if rs.ObjectLayer(gBlockObj) in layers_ToDel:\r\n                rs.DeleteObject(gBlockObj)\r\n            elif rs.ObjectType(gBlockObj) == rs.filter.instance:\r\n                if rs.BlockInstanceName(gBlockObj) in blocks_ToDel:\r\n                    rs.DeleteObject(gBlockObj)\r\n        \r\n        # Redefine block.\r\n        block_redefined = addBlock(\r\n                object_ids=rs.NormalObjects(),\r\n                base_point=(0.0, 0.0, 0.0),\r\n                name=block,\r\n                delete_input=True)\r\n        if block_redefined is None:\r\n            if bEcho: print \"  {} was NOT modified.\".format(block)\r\n        else:\r\n            ctBlocksModified += 1\r\n    \r\n    # Unlock only objects that were previously unlocked.\r\n    if gObjsToLock: rs.UnlockObjects(gObjsToLock)\r\n    \r\n    if bEcho:\r\n        if ctBlocksModified == len(blocks_ToMod):\r\n            print \"  All {} blocks were modified.\".format(ctBlocksModified)\r\n        else:\r\n            print \"  {} out of {} blocks were modified.\".format(\r\n                    ctBlocksModified, len(blocks_ToMod))\r\n    \r\n    return ctBlocksModified\r\n\r\n\r\ndef deleteBlocks(blocks_ToDel, bEcho=True):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    blocks_ToDel_Removing = blocks_ToDel[:]\r\n    if bEcho: print \"Deleting blocks ...\"\r\n    ctBlocksDeleted = 0\r\n    while blocks_ToDel_Removing:\r\n        ctBlocksDeleted_ThisRound = 0\r\n        for block in blocks_ToDel_Removing[:]:\r\n            if rs.DeleteBlock(block):\r\n                blocks_ToDel_Removing.remove(block)\r\n                ctBlocksDeleted += 1\r\n                ctBlocksDeleted_ThisRound += 1\r\n            else:\r\n                # If a block was not deleted,\r\n                # it may be nested inside another block.\r\n                pass\r\n        if not ctBlocksDeleted_ThisRound:\r\n            break\r\n    \r\n    if bEcho:\r\n        if ctBlocksDeleted == len(blocks_ToDel):\r\n            print \"  All {} blocks were deleted.\".format(ctBlocksDeleted)\r\n        else:\r\n            print \"  {} out of {} blocks were deleted.\".format(\r\n                    ctBlocksDeleted, len(blocks_ToDel))\r\n    \r\n    return ctBlocksDeleted\r\n\r\n\r\ndef deleteLayers(layers_ToDel, bEcho=True):\r\n    \r\n    # Change the current layer if it is slated to be deleted.\r\n    if rs.CurrentLayer() in layers_ToDel:\r\n        for layer in rs.LayerNames(sort=True):\r\n            if layer not in layers_ToDel and not rs.IsLayerReference(layer):\r\n                rs.CurrentLayer(layer)\r\n                break\r\n        else:\r\n            if bEcho:\r\n                print \"No eligible layers are available to be made current.\"\r\n    \r\n    if bEcho: print \"Deleting layers ...\"\r\n    ctLayersDeleted = 0\r\n    for layer in layers_ToDel:\r\n        if rs.DeleteLayer(layer):\r\n            ctLayersDeleted += 1\r\n        else:\r\n            if bEcho: print \"  {} was NOT deleted.\".format(layer)\r\n    if bEcho:\r\n        if ctLayersDeleted == len(layers_ToDel):\r\n            print \"  All {} layers were deleted.\".format(ctLayersDeleted)\r\n        else:\r\n            print \"  {} out of {} layers were deleted.\".format(\r\n                    ctLayersDeleted, len(layers_ToDel))\r\n    \r\n    return ctLayersDeleted\r\n\r\n\r\ndef main():\r\n    \r\n    bEcho = True\r\n    \r\n    layers_ToDel = getLayersToDelete(bEcho)\r\n    if not layers_ToDel: return\r\n    \r\n    if not getModifiableBlocks():\r\n        if bEcho:\r\n            print \"There are no non-reference, non-linked block definitions\" \\\r\n                  \" in this document.\"\r\n        blocks_ToDel = blocks_ToMod = None\r\n    else:\r\n        blocks_ToDel = getBlocksToDelete(layers_ToDel, bEcho)\r\n        blocks_ToMod = getBlocksToModify(layers_ToDel, blocks_ToDel, bEcho)\r\n    \r\n    plugin = rs.GetPlugInObject(\"Rhino Bonus Tools\")\r\n    layerState = \"Used by deleteLayers\"\r\n    plugin.SaveLayerState(layerState)\r\n    \r\n    rs.EnableRedraw(False)\r\n    \r\n    for layer in rs.LayerNames():\r\n        rs.LayerVisible(layer, True)\r\n        rs.LayerLocked(layer, False)\r\n    \r\n    for layer in layers_ToDel:\r\n        rc = deleteObjectsEx(rs.ObjectsByLayer(layer), ignore_modes=True)\r\n    \r\n    if blocks_ToMod:\r\n        rc = modifyBlocks(blocks_ToMod, layers_ToDel, blocks_ToDel, bEcho)\r\n    \r\n    plugin.RestoreLayerState(layerState)\r\n    plugin.DeleteLayerState(layerState)\r\n    \r\n    if blocks_ToDel:\r\n        rc = deleteBlocks(blocks_ToDel, bEcho)\r\n    \r\n    rc = deleteLayers(layers_ToDel, bEcho)\r\n    \r\n    rs.EnableRedraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}