{
  "source_url": "https://discourse.mcneel.com/t/pattern-maker-with-dynamic-preview/31396",
  "topic_id": 31396,
  "title": "Pattern maker with dynamic preview",
  "question": "I picked up this script that I once made in rhino script and enhanced it with new options and dynamic preview.\n\nI think the usage is quite self explanatory.\n\n\nThere are a few more things I want to implement as you can see in the comments, but I’m also open for others’ suggestions.\n\n\n\"\"\"\nThis script allows you draw make patterns from multiple curves at once.\nIt assumes all curves are more or less the same size, and have a reasonable\nwidth and height to begin with.\nIt will then randomly use the curves to make a pattern.\nThe pattern is then applied to a boundary curve that must be closed.\nIt uses getpoint in order to enable dynamic redraw when changing the pattern \nsettings.\n\n***********************************\n* script written by Gijs de Zwart *\n* www.studiogijs.nl               *\n* April, 2016                     *\n***********************************\n\n\nimplemented:\n\n* user selects 1 or more curves to use as pattern\n* user selects boundary to fill (closed curve)\n* boundary gets filled with a preview of the endresult\n* curves outside the boundary are removed\n* curves that intersect with the boundary are removed\n* pattern looks at the size of the curve(s) (boundingbox) to get correct spacing\n* possibility to enter a margin from the border of the boundary\n* possibility to give curve(s) a random scale/ rotation\n* possibility to offset each row\n\nto do:\npossibility to scale the curve(s) that are used in the boundary\npossibility to flip curve(s)\nerror checking\n\"\"\"\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry.Curve as Curve\nimport random as rand\nimport Rhino\nimport System.Drawing.Color as Color\nimport scriptcontext as sc\n\ndef RunCommand():\n\n    class fillcrv():\n        def __init__(self,crv):\n            bbox=crv.GetBoundingBox(True)\n            self.crv=crv\n            self.width=bbox.Max.X-bbox.Min.X\n            self.height=bbox.Max.Y-bbox.Min.Y\n            self.h_space=self.width\n            self.v_space=self.height\n            self.lower=bbox.Min\n\n\n    def getSpac...",
  "code_blocks": [
    {
      "code": "import rhinoscriptsyntax as rs\nimport Rhino.Geometry.Curve as Curve\nimport random as rand\nimport Rhino\nimport System.Drawing.Color as Color\nimport scriptcontext as sc\n\ndef RunCommand():\n\n    class fillcrv():\n        def __init__(self,crv):\n            bbox=crv.GetBoundingBox(True)\n            self.crv=crv\n            self.width=bbox.Max.X-bbox.Min.X\n            self.height=bbox.Max.Y-bbox.Min.Y\n            self.h_space=self.width\n            self.v_space=self.height\n            self.lower=bbox.Min\n\n\n    def getSpace(offset, x_space, y_space):\n        #returns horizontal and vertical space and row offset (skew)\n        h_space=0\n        v_space=0\n        for crv in curves:\n            if h_space<crv.h_space:\n                h_space=crv.h_space\n\n            if v_space<crv.v_space:\n                v_space=crv.v_space\n        h_space+= h_space*x_space/100\n        v_space+= v_space*y_space/100\n        \n        if h_space==0:\n            h_space=10\n        if v_space==0:\n            v_space=10\n        h_skew=h_space*offset/100\n        return [h_space,v_space,h_skew]\n\n    def CalcStartCondition(boundary):\n        #returns width, height and startpoint transformation\n        #and changes boundary to offset margin if requested\n\n        bbox=boundary.GetBoundingBox(True)\n        cen_boundary=bbox.Center\n        plane=Rhino.Geometry.Plane.WorldXY\n        plane.Origin = bbox.Min\n\n        b_width=bbox.Max.X-bbox.Min.X\n\n        b_height=bbox.Max.Y-bbox.Min.Y\n\n        #calculate translation vector from curve to boundary\n\n        start=bbox.Min-curves[0].lower\n\n        return [b_width, b_height, start, boundary]\n\n    def CreatePatternCurves(v_amount, h_amount, v_space, h_space, h_skew, start, boundary):\n        #creates patterned curves in rectangular grid\n        trans=start\n        reset=start[0]\n        odd=0\n        i=0\n        scfactor=0.1\n        patterncurves=[]\n        for y in range(0,v_amount):\n\n            #reset transformation in x-direction\n            trans[0]=reset\n\n            if odd%2==1:\n                trans[0]+=h_skew\n            odd+=1\n            i=0\n            CurveCount=len(curves)-1\n            random = optRandom.CurrentValue\n            for x in range(0,h_amount):\n                if random:\n                    v=rand.randint(0,CurveCount)\n                    copy=curves[v].crv.Duplicate()\n                else:\n                    \n                    if i>CurveCount:\n                        i=0\n                    copy=curves[i].crv.Duplicate()\n                copy.Translate(trans)\n                cen=copy.GetBoundingBox(True).Center\n                \n                if optScaleCurves.CurrentValue==True:\n                    \n                    scfactor=0.2+0.8/v_amount*y\n                    scale=Rhino.Geometry.Transform.Scale(cen,scfactor)\n                    copy.Transform(scale)\n                \n                \n\n                #check if point to copy is inside boundary and margin\n                margin=optMargin.CurrentValue\n\n                if boundary.Contains(cen) == Rhino.Geometry.PointContainment.Inside:\n\n                    #check if it intersects with the boundarycurve:\n                    #uses intersection tolerance to leave a margin\n                    intersection_tolerance = margin+0.01\n                    overlap_tolerance = 0\n                    intersections = Rhino.Geometry.Intersect.Intersection.CurveCurve(\n                                        boundary,\n                                        copy,\n                                        intersection_tolerance,\n                                        overlap_tolerance\n                                        )\n                    if intersections.Count==0:\n                        patterncurves.append(copy)\n\n                #increment horizontal transform\n                trans[0]+=h_space\n                i+=1\n\n            #increment vertical transform\n            trans[1]+=v_space\n\n        return patterncurves\n\n    def fillBoundary(crv,boundary, offset, x_space, y_space, random):\n        #returns pattern curves within boundary\n        b_width, b_height, start, boundary = CalcStartCondition(boundary)\n        #determine horizontal and vertical spacing and skew\n        h_space,v_space,h_skew = getSpace(offset, x_space, y_space)\n\n        # calculate amount of curves needed\n        h_amount=int(b_width/h_space)+1\n\n        v_amount=int(b_height/v_space)+1\n        #create the pattern\n        patterncurves=CreatePatternCurves(v_amount, h_amount, v_space, h_space, h_skew, start, boundary)\n        return patterncurves\n\n\n    def OnDynamicDraw(sender, e):\n\n            random=optRandom.CurrentValue\n            offset=optOffset.CurrentValue\n            x_space=optSpaceX.CurrentValue\n            y_space=optSpaceY.CurrentValue\n            h_space,v_space,h_skew = getSpace(offset, x_space, y_space)\n            patterncurves = fillBoundary(curves, boundary, offset, x_space, y_space, random)\n    \n            for curve in patterncurves:\n                e.Display.DrawCurve(curve, Color.LightCyan, 1)\n            \n    def addPatternToRhino():\n        patterncurves = fillBoundary(curves, boundary, offset, x_space, y_space, random)\n        for i in range(0, len(patterncurves)):\n            sc.doc.Objects.AddCurve(patterncurves[i])\n        sc.doc.Views.Redraw()\n\n    boundary = rs.GetObject(\"select boundarycurve to fill\", rs.filter.curve)\n    if not boundary:\n        return\n    boundary = rs.coercecurve(boundary)\n    crvs=rs.GetObjects(\"select curves to use as pattern\", rs.filter.curve)\n    if not crvs:\n        return\n    if not boundary.IsClosed:\n        return\n\n    curves=[]\n    origin=Rhino.Geometry.Point3d(0,0,0)\n    for crv in crvs:\n        crv=rs.coercecurve(crv)\n        bb=crv.GetBoundingBox(True)\n        center=bb.Center\n        trans=origin-center\n        crv.Translate(trans)\n        #sc.doc.Objects.AddCurve(crv)\n\n        c=crv.Duplicate()\n        c=fillcrv(c)\n        curves.append(c)\n\n    gp=Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt(\"pattern properties\")\n\n    optMargin=Rhino.Input.Custom.OptionDouble(0,0,100)\n    gp.AddOptionDouble(\"margin\",optMargin)\n\n    \n    optRandom = Rhino.Input.Custom.OptionToggle(False, \"Off\", \"On\")\n    gp.AddOptionToggle(\"add_randomness\", optRandom)\n    \n    optScaleCurves = Rhino.Input.Custom.OptionToggle(False, \"Off\", \"On\")\n    gp.AddOptionToggle(\"scale_curves\", optScaleCurves)\n\n    optOffset = Rhino.Input.Custom.OptionInteger(0,-200,200)\n    gp.AddOptionInteger(\"offset_percentage\",optOffset)\n\n    optSpaceX = Rhino.Input.Custom.OptionInteger(0,-50,500)\n    gp.AddOptionInteger(\"x_space_percentage\",optSpaceX)\n    \n    optSpaceY = Rhino.Input.Custom.OptionInteger(0,-50,500)\n    gp.AddOptionInteger(\"y_space_percentage\",optSpaceY)\n    gp.DynamicDraw+=OnDynamicDraw\n    patterncurves=[]\n    #start collecting user options\n    while True:\n        gp.Get()\n        if gp.Result()==Rhino.Input.GetResult.Option:\n            continue\n        break\n    \n    random=optRandom.CurrentValue\n    offset=optOffset.CurrentValue\n    margin=optMargin.CurrentValue\n    x_space=optSpaceX.CurrentValue\n    y_space=optSpaceY.CurrentValue\n    boolCanOffset=True\n\n    addPatternToRhino()\nif( __name__ == \"__main__\" ):\n    RunCommand()",
      "language": "python",
      "author": "Gijs",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "\"\"\"\nThis script allows you draw make patterns from multiple curves at once.\nIt assumes all curves are more or less the same size, and have a reasonable\nwidth and height to begin with.\nIt will then randomly use the curves to make a pattern.\nThe pattern is then applied to a boundary curve that must be closed.\nIt uses getpoint in order to enable dynamic redraw when changing the pattern \nsettings.\n\n***********************************\n* script written by Gijs de Zwart *\n* www.studiogijs.nl               *\n* April, 2016                     *\n***********************************\n\n\nimplemented:\n\n* user selects 1 or more curves to use as pattern\n* user selects boundary to fill (closed curve)\n* boundary gets filled with a preview of the endresult\n* curves outside the boundary are removed\n* curves that intersect with the boundary are removed\n* pattern looks at the size of the curve(s) (boundingbox) to get correct spacing\n* possibility to enter a margin from the border of the boundary\n* possibility to give curve(s) a random scale/ rotation\n* possibility to offset each row\n\nto do:\npossibility to scale the curve(s) that are used in the boundary\npossibility to flip curve(s)\nerror checking\n\"\"\"\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry.Curve as Curve\nimport random as rand\nimport Rhino\nimport System.Drawing.Color as Color\nimport scriptcontext as sc\n\ndef RunCommand():\n\n    class fillcrv():\n        def __init__(self,crv):\n            bbox=crv.GetBoundingBox(True)\n            self.crv=crv\n            self.width=bbox.Max.X-bbox.Min.X\n            self.height=bbox.Max.Y-bbox.Min.Y\n            self.h_space=self.width\n            self.v_space=self.height\n            self.lower=bbox.Min\n\n\n    def getSpace(offset, space):\n        #returns horizontal and vertical space and row offset (skew)\n        h_space=0\n        v_space=0\n        for crv in curves:\n            if h_space<crv.h_space:\n                h_space=crv.h_space\n\n            if v_space<crv.v_space:\n                v_space=crv.v_space\n        h_space+= h_space*space/100\n        v_space+= v_space*space/100\n        h_skew=h_space*offset/100\n        return [h_space,v_space,h_skew]\n\n    def CalcStartCondition(boundary):\n        #returns width, height and startpoint transformation\n        #and changes boundary to offset margin if requested\n\n        bbox=boundary.GetBoundingBox(True)\n        cen_boundary=bbox.Center\n        plane=Rhino.Geometry.Plane.WorldXY\n        plane.Origin = bbox.Min\n\n        b_width=bbox.Max.X-bbox.Min.X\n\n        b_height=bbox.Max.Y-bbox.Min.Y\n\n        #calculate translation vector from curve to boundary\n        start=bbox.Min-curves[0].lower\n\n        return [b_width, b_height, start, boundary]\n\n    def CreatePatternCurves(v_amount, h_amount, v_space, h_space, h_skew, start, boundary):\n        #creates patterned curves in rectangular grid\n        trans=start\n        reset=start[0]\n        odd=0\n        i=0\n\n        patterncurves=[]\n        for y in range(0,v_amount):\n\n            #reset transformation in x-direction\n            trans[0]=reset\n\n            if odd%2==1:\n                trans[0]+=h_skew\n            odd+=1\n            for x in range(0,h_amount):\n\n                i=rand.randint(0,len(curves)-1)\n                copy=curves[i].crv.Duplicate()\n                copy.Translate(trans)\n                cen=copy.GetBoundingBox(True).Center\n\n                random = optRandom.CurrentValue\n\n                if random and copy!=None:\n                    rnd=rand.randint(90,110)/100\n                    rot_rnd=rand.uniform(-.1,.1)\n                    scale=Rhino.Geometry.Transform.Scale(cen,rnd)\n                    rotation=Rhino.Geometry.Transform.Rotation(rot_rnd, cen)\n                    copy.Transform(scale)\n                    copy.Transform(rotation)\n\n                #check if point to copy is inside boundary and margin\n                margin=optMargin.CurrentValue\n\n                if boundary.Contains(cen) == Rhino.Geometry.PointContainment.Inside:\n\n                    #check if it intersects with the boundarycurve:\n                    #uses intersection tolerance to leave a margin\n                    intersection_tolerance = margin+0.01\n                    overlap_tolerance = 0.0\n                    intersections = Rhino.Geometry.Intersect.Intersection.CurveCurve(\n                                        boundary,\n                                        copy,\n                                        intersection_tolerance,\n                                        overlap_tolerance\n                                        )\n                    if not intersections:\n                        patterncurves.append(copy)\n\n                #increment horizontal transform\n                trans[0]+=h_space\n\n            #increment vertical transform\n            trans[1]+=v_space\n\n        return patterncurves\n\n    def fillBoundary(crv,boundary, offset, space, random):\n        #returns pattern curves within boundary\n        b_width, b_height, start, boundary = CalcStartCondition(boundary)\n        #determine horizontal and vertical spacing and skew\n        h_space,v_space,h_skew = getSpace(offset, space)\n\n        # calculate amount of curves needed\n        h_amount=int(b_width/h_space)+1\n\n        v_amount=int(b_height/v_space)+1\n        #create the pattern\n        patterncurves=CreatePatternCurves(v_amount, h_amount, v_space, h_space, h_skew, start, boundary)\n        return patterncurves\n\n\n    def OnDynamicDraw(sender, e):\n        #try:\n        random=optRandom.CurrentValue\n        offset=optOffset.CurrentValue\n        space=optSpace.CurrentValue\n        h_space,v_space,h_skew = getSpace(offset, space)\n        patterncurves = fillBoundary(curves, boundary, offset, space, random)\n\n        for curve in patterncurves:\n            e.Display.DrawCurve(curve, Color.LightCyan, 1)\n        \"\"\"\n        except Exception as ex:\n            template = \"An exception of type {0} occured. Arguments:\\n{1!r}\"\n            message = template.format(type(ex).__name__, ex.args)\n            print message\n            return\n        \"\"\"\n\n    def addPatternToRhino():\n        if boolCanOffset==False:\n            print \"couldn't offset curve, used boundary instead\"\n        patterncurves = fillBoundary(curves, boundary, offset, space, random)\n        for i in range(0, len(patterncurves)):\n            sc.doc.Objects.AddCurve(patterncurves[i])\n        sc.doc.Views.Redraw()\n\n    boundary = rs.GetObject(\"select boundarycurve to fill\", rs.filter.curve)\n    if not boundary:\n        return\n    boundary = rs.coercecurve(boundary)\n    crvs=rs.GetObjects(\"select curves to use as pattern\", rs.filter.curve)\n    if not crvs:\n        return\n    if not boundary.IsClosed:\n        return\n\n    curves=[]\n    for crv in crvs:\n        crv=rs.coercecurve(crv)\n        crv=fillcrv(crv)\n        curves.append(crv)\n\n    gp=Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt(\"pattern properties\")\n\n    optMargin=Rhino.Input.Custom.OptionDouble(0,0,100)\n    gp.AddOptionDouble(\"margin\",optMargin)\n\n    optRandom = Rhino.Input.Custom.OptionToggle(True, \"Off\", \"On\")\n    gp.AddOptionToggle(\"add_randomness\", optRandom)\n\n    optOffset = Rhino.Input.Custom.OptionInteger(50,0,100)\n    gp.AddOptionInteger(\"offset_percentage\",optOffset)\n\n    optSpace = Rhino.Input.Custom.OptionInteger(50,0,500)\n    gp.AddOptionInteger(\"space_percentage\",optSpace)\n    gp.DynamicDraw+=OnDynamicDraw\n\n    #start collecting user options\n    while True:\n        gp.Get()\n        if gp.Result()==Rhino.Input.GetResult.Option:\n            continue\n        break\n\n    random=optRandom.CurrentValue\n    offset=optOffset.CurrentValue\n    margin=optMargin.CurrentValue\n    space=optSpace.CurrentValue\n    boolCanOffset=True\n\n    addPatternToRhino()\nif( __name__ == \"__main__\" ):\n    RunCommand()",
      "language": "python",
      "author": "Gijs",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 5,
  "views": 2643
}