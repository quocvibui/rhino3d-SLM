{
  "source_url": "https://discourse.mcneel.com/t/how-to-speed-up-ghpython-codes/77630",
  "topic_id": 77630,
  "title": "How to speed up ghpython codes?",
  "question": "I wrote more than 200 lines of Ghpython codes,including one main program and 7 functions constructed by dictionary data  structure.I have imported several necessary ghpython function pakages ,such as scriptcontext,rhinoscriptsyntax,ghpythonlib.components,Rhino.Geometry and so on.But it spent about ten seconds every time in finishing all.I want it done less than one second.GH_CPython has been unsuccessfully used to solve the problem because it can not import ghpython pakages metioned above.And I have tried to import numba to sort it out via installing Anacond3 which also confused me,failling at end.I use rhino6 and the grasshopper version is 1.0.0007.So how can I do to speed up my codes?\n\nPlease help me. Thank you all.",
  "code_blocks": [
    {
      "code": "Dict_PlanStandby,Dict_PlanExistence,Dict_RB,Dict_Plan,Dict_PlanData,Dict_UnionTraCursSta,Dict_PlanDataArea,Dict_PtCenOri = {},{},{},{},{},{},{},{}#Dict_Plan = {0;[HighArea1,HighArea2],1:[Midarea1,MidArea2],2:[LowArea1,LowArea2]}\nfor iHigh in xrange(len(Curve_RBHigh)):\n    Dict_RB.setdefault(0,{})[iHigh]=Curve_RBHigh[iHigh]\nfor iMid in xrange(len(Curve_RBMid)):\n    Dict_RB.setdefault(1,{})[iMid]=Curve_RBMid[iMid]\nfor iLow in xrange(len(Curve_RBLow)):\n    Dict_RB.setdefault(2,{})[iLow]=Curve_RBLow[iLow]\nDict_SunDis = {0:[45,45,45],1:[35,25,25],2:[20,15,10]}#0-High,1-Mid,2-Low,\"0:[30,30,30]\"means\"High:[High,Mid,Low]\"\nDict_HorDis= {0:[13,13,13],1:[13,8,8],2:[13,6,6]}#Num_column:[Raw_0,Raw_1,Raw_2]\nfor m in xrange(len(List_Standby)):\n    Dict_PlanStandby[m] = List_Standby[m]\nfor n in xrange(len(List_PlanExistence)):\n    Dict_PlanExistence[n] = List_PlanExistence[n]\nfor jHigh in xrange(len(Plan_High)):\n    Area_PlanHigh = int(rs.CurveArea(Plan_High[jHigh])[0])\n    Dict_Plan.setdefault(0,{})[jHigh] = Area_PlanHigh\n    Dict_PlanDataArea[jHigh] = Area_PlanHigh#Dict_PlanDataArea is used to judge which the Plan_Input is\n    Dict_PlanData[jHigh] = Plan_High[jHigh]#Dict_PlanData is used to prepare for the Dict_UnionTraCursSta\nfor jMid in xrange(len(Plan_Mid)):\n    Area_PlanMid = int(rs.CurveArea(Plan_Mid[jMid])[0])\n    Dict_Plan.setdefault(1,{})[jMid] = Area_PlanMid\n    Dict_PlanDataArea[len(Plan_High)+jMid] = Area_PlanMid\n    Dict_PlanData[len(Plan_High)+jMid] = Plan_Mid[jMid]\nfor jLow in xrange(len(Plan_Low)):\n    Area_PlanLow = int(rs.CurveArea(Plan_Low[jLow])[0])\n    Dict_Plan.setdefault(2,{})[jLow] = Area_PlanLow#Dict_Plan is used to judge the High/Mid/Low of RB and so on\n    Dict_PlanDataArea[len(Plan_High)+len(Plan_Mid)+jLow] = Area_PlanLow#Dict_PlanDataArea is used to find the key via area\n    Dict_PlanData[len(Plan_High)+len(Plan_Mid)+jLow] = Plan_Low[jLow]#Dict_PlanData is used to construct n*n trajectories\n#8.2.Construct the n*n trajectories named as Dict_UnionTraCursSta\nfor iValue in xrange(len(Dict_PlanData)):#As the Plan_Base\n    Dict_PtCenOri[iValue] = rs.CurveAreaCentroid(Dict_PlanData.values()[iValue])[0]\n    for jValue in xrange(len(Dict_PlanData)):#As the Plan_Input\n        Length_ijSta = Func_JudgeLength(Dict_RB,Dict_SunDis,Dict_HorDis,Dict_Plan,Dict_PlanData.values()[iValue],Dict_PlanData.values()[jValue])#Length_ijSta[3] is the RedBoundary\n        Tra_CurSingleSta = Func_TraCur(Dict_PlanData.values()[iValue],Dict_PlanData.values()[jValue],0,Length_ijSta[0],Length_ijSta[1],Length_ijSta[2],Length_ijSta[3])\n        Dict_UnionTraCursSta.setdefault(iValue,{})[jValue]=Tra_CurSingleSta\n#10.Main program:Fistly,find the correct trajectory via Key_Input and Key_Base;Secondly,move the Tra to the Plan_Base one by one;Thirdly,union all of the Tras\n#Fourthly,judge whether the Plan_input is overflow based on the pts on UnionTraCurs\nDict_KeyExi,Dict_KeySta,Dict_UpdateTemp = {},{},{}\nfor i in xrange(len(Dict_PlanStandby)):\n    Dict_UnionTraCurs = {}#Store the trajectory\n    Area_PlanSta = int(rs.CurveArea(Dict_PlanStandby.values()[i])[0])\n    Key_Input = {vSta:kSta for kSta,vSta in copy.deepcopy(Dict_PlanDataArea).iteritems()}[Area_PlanSta]\n    Pt_CenterSta = rs.CurveAreaCentroid(Dict_PlanStandby.values()[i])[0]#Pt_CenterSta help move Plan_Standby to move to Pts[Pt_inputidex]\n    for j in xrange(len(Dict_PlanExistence)):\n        Area_PlanExi = int(rs.CurveArea(Dict_PlanExistence.values()[j])[0])\n        Pt_jCenterBase = rs.CurveAreaCentroid(Dict_PlanExistence.values()[j])[0]\n        Key_Base =  {vExi:kExi for kExi,vExi in copy.deepcopy(Dict_PlanDataArea).iteritems()}[Area_PlanExi]\n        Cur_TraOri = Dict_UnionTraCursSta[Key_Base][Key_Input]#Fistly,find the Trajectory between NO.i and NO.j\n        Line_rot0 = SouthLineSelf(Dict_PlanExistence.values()[j])#Calculate the angle of the Plan_base to rotate the Dict_Trajectory\n        rs.ReverseCurve(Line_rot0)\n        Line_rotbase0 = SouthLineWorld(Dict_PlanExistence.values()[j]) \n        Angle_rot0 = rs.Angle2(Line_rot0,Line_rotbase0)[0]\n        if ghcomp.CurveClosestPoint(rs.CurveEndPoint(Line_rot0),Line_rotbase0)[2] < ghcomp.CurveClosestPoint(rs.CurveStartPoint(Line_rot0),Line_rotbase0)[2]:\n            Angle_rot0 = Angle_rot0*(-1)\n        Cur_TraTemp = rs.CopyObject(Cur_TraOri,rs.VectorCreate(Pt_jCenterBase,Dict_PtCenOri.values()[Key_Base]))\n        Tra_SingleFin = rs.RotateObject(Cur_TraTemp,Dict_PtCenOri.values()[Key_Base],Angle_rot0)#Secondly,copy Cur_TraOri and move it to the Pt(named as Dict_PtCenOri.itervalues()[Key_Base])\n        Dict_UnionTraCurs[j] = Tra_SingleFin\n    if len(Dict_PlanExistence) == 1:\n        UnionTraCurs = Dict_UnionTraCurs.values()\n    if len(Dict_PlanExistence) > 1:\n        UnionTraCurs = rs.CurveBooleanUnion(Dict_UnionTraCurs.values())#Thirdly,union all of the Tras\n    for key,value in Dict_Plan.iteritems():\n        if int(rs.CurveArea(Dict_PlanStandby.values()[i])[0]) in value.itervalues():\n            Curve_RedBoundaryFin = Dict_RB[key].values()\n    Dict_PtsFinal = Func_TraUniBooPts(UnionTraCurs,Num_DivUniTra,Dict_PlanStandby.values()[i],Curve_RedBoundaryFin)#Func_TraUniBooPts return a dictionary\n    if Dict_PtsFinal:#Fourthly,judge whether the Plan_input is overflow\n        Plan_FinalInput = Func_ConfirmPlan(Dict_PlanStandby.values()[i],Angle_input[i],Dict_PtsFinal.values(),Pt_inputidex[i])\n        Dict_UpdateTemp[1000+i] = Plan_FinalInput#Just be different\n        Dict_PlanExistence.update(Dict_UpdateTemp)\n    else:\n        break\nif len(List_PlanExistence)+len(List_Standby) == len(Dict_PlanExistence):\n    a = True\nelse:a = False\nb = Dict_PlanExistence.values()",
      "language": "python",
      "author": "niyuxiangken",
      "post_number": 13,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 17,
  "views": 1837
}