{
  "source_url": "https://github.com/leclusen/necs-sandbox/blob/8d8006ae3c845c9f3e38154803caac6b03d298a9/structure-batiment/structure_aligner/validation/reference_comparator.py",
  "repo": "leclusen/necs-sandbox",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "structure-batiment/structure_aligner/validation/reference_comparator.py",
  "instruction": "Reference comparator for V2 pipeline output validation.",
  "code": "\"\"\"Reference comparator for V2 pipeline output validation.\n\nPhase 7.1 - Compares output .3dm against a reference .3dm to validate\nthat the V2 pipeline produces results within acceptable tolerances.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport math\nfrom collections import defaultdict\nfrom dataclasses import asdict, dataclass, field\nfrom pathlib import Path\n\nimport rhino3dm\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ObjectComparison:\n    \"\"\"Comparison result for a single named object.\"\"\"\n    name: str\n    element_type: str = \"\"\n    output_vertex_count: int = 0\n    reference_vertex_count: int = 0\n    matched_vertices: int = 0\n    total_compared: int = 0\n    match_rate: float = 0.0\n    displacements: list[float] = field(default_factory=list)\n    max_displacement: float = 0.0\n    mean_displacement: float = 0.0\n\n\n@dataclass\nclass ComparisonResult:\n    \"\"\"Comprehensive comparison between output and reference 3dm files.\"\"\"\n    output_3dm: str = \"\"\n    reference_3dm: str = \"\"\n    tolerance: float = 0.005\n\n    # Object-level counts\n    output_object_count: int = 0\n    reference_object_count: int = 0\n    common_objects: int = 0\n    output_only_objects: int = 0\n    reference_only_objects: int = 0\n\n    # Vertex matching\n    total_vertices_compared: int = 0\n    vertices_matched: int = 0\n    overall_match_rate: float = 0.0\n\n    # Displacement distribution\n    mean_displacement: float = 0.0\n    median_displacement: float = 0.0\n    p95_displacement: float = 0.0\n    max_displacement: float = 0.0\n\n    # Per-type breakdown\n    type_breakdown: dict[str, dict] = field(default_factory=dict)\n\n    # Lists\n    output_only_names: list[str] = field(default_factory=list)\n    reference_only_names: list[str] = field(default_factory=list)\n\n    # Per-object details (optional, can be large)\n    object_comparisons: list[dict] = field(default_factory=list)\n\n    errors: list[str] = field(default_factory=list)\n\n\ndef compare_with_reference(\n    output_3dm: Path,\n    reference_3dm: Path,\n    tolerance: float = 0.005,\n    include_object_details: bool = False,\n) -> ComparisonResult:\n    \"\"\"Compare output 3dm against a reference 3dm file.\n\n    Args:\n        output_3dm: Path to the pipeline output .3dm file.\n        reference_3dm: Path to the reference .3dm file.\n        tolerance: Position matching tolerance in meters (default: 5mm).\n        include_object_details: If True, include per-object comparison details.\n\n    Returns:\n        ComparisonResult with all metrics.\n    \"\"\"\n    result = ComparisonResult(\n        output_3dm=str(output_3dm),\n        reference_3dm=str(reference_3dm),\n        tolerance=tolerance,\n    )\n\n    # Load models\n    out_model = rhino3dm.File3dm.Read(str(output_3dm))\n    if out_model is None:\n        result.errors.append(f\"Failed to read output 3dm: {output_3dm}\")\n        return result\n\n    ref_model = rhino3dm.File3dm.Read(str(reference_3dm))\n    if ref_model is None:\n        result.errors.append(f\"Failed to read reference 3dm: {reference_3dm}\")\n        return result\n\n    # Index objects by name\n    out_objects = _index_objects_by_name(out_model)\n    ref_objects = _index_objects_by_name(ref_model)\n\n    result.output_object_count = len(out_objects)\n    result.reference_object_count = len(ref_objects)\n\n    out_names = set(out_objects.keys())\n    ref_names = set(ref_objects.keys())\n\n    common_names = out_names & ref_names\n    result.common_objects = len(common_names)\n    result.output_only_objects = len(out_names - ref_names)\n    result.reference_only_objects = len(ref_names - out_names)\n    result.output_only_names = sorted(out_names - ref_names)\n    result.reference_only_names = sorted(ref_names - out_names)\n\n    # Compare common objects\n    all_displacements: list[float] = []\n    type_stats: dict[str, dict] = defaultdict(\n        lambda: {\"compared\": 0, \"matched\": 0, \"objects\": 0}\n    )\n\n    for name in sorted(common_names):\n        out_obj = out_objects[name]\n        ref_obj = ref_objects[name]\n\n        out_verts = _extract_vertices(out_obj.Geometry)\n        ref_verts = _extract_vertices(ref_obj.Geometry)\n\n        elem_type = _infer_element_type(name)\n        type_stats[elem_type][\"objects\"] += 1\n\n        obj_comp = ObjectComparison(\n            name=name,\n            element_type=elem_type,\n            output_vertex_count=len(out_verts),\n            reference_vertex_count=len(ref_verts),\n        )\n\n        # Compare vertex by vertex (index-based matching)\n        n = min(len(out_verts), len(ref_verts))\n        obj_comp.total_compared = n\n        matched = 0\n\n        for i in range(n):\n            d = _distance_3d(out_verts[i], ref_verts[i])\n            obj_comp.displacements.append(round(d, 6))\n            all_displacements.append(d)\n\n            type_stats[elem_type][\"compared\"] += 1\n            if d <= tolerance:\n                matched += 1\n                type_stats[elem_type][\"matched\"] += 1\n\n        obj_comp.matched_vertices = matched\n        obj_comp.match_rate = (\n            round(matched / n * 100, 1) if n > 0 else 100.0\n        )\n        if obj_comp.displacements:\n            obj_comp.max_displacement = round(max(obj_comp.displacements), 6)\n            obj_comp.mean_displacement = round(\n                sum(obj_comp.displacements) / len(obj_comp.displacements), 6\n            )\n\n        if include_object_details:\n            result.object_comparisons.append(asdict(obj_comp))\n\n    # Overall stats\n    result.total_vertices_compared = len(all_displacements)\n    result.vertices_matched = sum(1 for d in all_displacements if d <= tolerance)\n    result.overall_match_rate = (\n        round(result.vertices_matched / len(all_displacements) * 100, 1)\n        if all_displacements\n        else 0.0\n    )\n\n    # Displacement distribution\n    if all_displacements:\n        sorted_d = sorted(all_displacements)\n        result.mean_displacement = round(\n            sum(sorted_d) / len(sorted_d), 6\n        )\n        n = len(sorted_d)\n        result.median_displacement = round(\n            sorted_d[n // 2] if n % 2 == 1\n            else (sorted_d[n // 2 - 1] + sorted_d[n // 2]) / 2,\n            6,\n        )\n        p95_idx = min(int(n * 0.95), n - 1)\n        result.p95_displacement = round(sorted_d[p95_idx], 6)\n        result.max_displacement = round(sorted_d[-1], 6)\n\n    # Type breakdown\n    result.type_breakdown = {\n        t: {\n            \"objects\": s[\"objects\"],\n            \"vertices_compared\": s[\"compared\"],\n            \"vertices_matched\": s[\"matched\"],\n            \"match_rate\": round(s[\"matched\"] / s[\"compared\"] * 100, 1)\n            if s[\"compared\"] > 0\n            else 0.0,\n        }\n        for t, s in sorted(type_stats.items())\n    }\n\n    logger.info(\n        \"Comparison: %d common objects, %d/%d vertices matched (%.1f%%) within %.3fm\",\n        result.common_objects,\n        result.vertices_matched,\n        result.total_vertices_compared,\n        result.overall_match_rate,\n        tolerance,\n    )\n\n    return result\n\n\ndef _index_objects_by_name(\n    model: rhino3dm.File3dm,\n) -> dict[str, rhino3dm.File3dmObject]:\n    \"\"\"Index model objects by their Name attribute, skipping unnamed.\"\"\"\n    objects: dict[str, rhino3dm.File3dmObject] = {}\n    for obj in model.Objects:\n        name = obj.Attributes.Name\n        if name:\n            if name in objects:\n                logger.warning(\"Duplicate object name '%s' â€” last instance used\", name)\n            objects[name] = obj\n    return objects\n\n\ndef _extract_vertices(\n    geom: rhino3dm.GeometryBase,\n) -> list[tuple[float, float, float]]:\n    \"\"\"Extract vertex positions from a geometry object.\"\"\"\n    verts: list[tuple[float, float, float]] = []\n\n    if isinstance(geom, rhino3dm.Brep):\n        for i in range(len(geom.Vertices)):\n            v = geom.Vertices[i]\n            loc = v.Location\n            verts.append((loc.X, loc.Y, loc.Z))\n    elif isinstance(geom, rhino3dm.PolylineCurve):\n        for i in range(geom.PointCount):\n            p = geom.Point(i)\n            verts.append((p.X, p.Y, p.Z))\n    elif isinstance(geom, rhino3dm.LineCurve):\n        p1 = geom.PointAtStart\n        p2 = geom.PointAtEnd\n        verts.append((p1.X, p1.Y, p1.Z))\n        verts.append((p2.X, p2.Y, p2.Z))\n    elif isinstance(geom, rhino3dm.NurbsCurve):\n        for i in range(len(geom.Points)):\n            cp = geom.Points[i]\n            w = cp.W if cp.W != 0 else 1.0\n            verts.append((cp.X / w, cp.Y / w, cp.Z / w))\n    elif isinstance(geom, rhino3dm.Point):\n        loc = geom.Location\n        verts.append((loc.X, loc.Y, loc.Z))\n\n    return verts\n\n\ndef _distance_3d(\n    a: tuple[float, float, float],\n    b: tuple[float, float, float],\n) -> float:\n    \"\"\"Euclidean distance between two 3D points.\"\"\"\n    return math.sqrt(\n        (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2\n    )\n\n\ndef _infer_element_type(name: str) -> str:\n    \"\"\"Infer element type from object name.\"\"\"\n    lower = name.lower()\n    if lower.startswith(\"dalle\"):\n        return \"dalle\"\n    if lower.startswith(\"voile\"):\n        return \"voile\"\n    if lower.startswith(\"appuis\") or lower.startswith(\"appui\"):\n        return \"appui\"\n    if lower.startswith(\"poteau\"):\n        return \"poteau\"\n    if lower.startswith(\"poutre\"):\n        return \"poutre\"\n    if lower.startswith(\"filaire\"):\n        return \"filaire\"\n    return \"other\"\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}