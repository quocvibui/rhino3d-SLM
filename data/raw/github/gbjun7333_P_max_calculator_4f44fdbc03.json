{
  "source_url": "https://github.com/gbjun7333/P_max_calculator/blob/8844e2d7a8f3bd7c387827d6a834114aa901129d/grasshopper/parking_integrated.py",
  "repo": "gbjun7333/P_max_calculator",
  "repo_stars": 0,
  "repo_description": "parking capacity calculation system",
  "license": "MIT",
  "filepath": "grasshopper/parking_integrated.py",
  "instruction": "P_max 주차대수 산출 시스템 - 통합 버전",
  "code": "# -*- coding: utf-8 -*-\n# r: pyshp\n\"\"\"\nP_max 주차대수 산출 시스템 - 통합 버전\n\nparcel_layout_evaluation_analysis 구조 기반\n- pyshp로 Shapefile 읽기 (geopandas 없음!)\n- Rhino.Geometry + ghpythonlib 기반 기하 연산\n- 단일 스크립트 실행\n\n=== Grasshopper 입력 ===\n- shapefile_path: 병합된 Shapefile 경로 (AL_D194_with_building.shp)\n- save_path: 결과 저장 경로 (CSV)\n\n=== 사용법 ===\nGrasshopper Python Script 컴포넌트에서:\n    globals()['shapefile_path'] = shapefile_path\n    globals()['save_path'] = save_path\n    exec(open(r'D:\\...\\parking_integrated.py', encoding='utf-8').read())\n\"\"\"\n\nfrom __future__ import annotations\nimport os\nimport importlib\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom pathlib import Path, PureWindowsPath\nfrom datetime import datetime\nimport time\n\n# Rhino imports (ghpythonlib 불필요)\nimport Rhino\nimport Rhino.Geometry as geo\n\n# pyshp import\nimport shapefile\n\n\n# ==============================================================================\n# 상수 정의\n# ==============================================================================\nTOL = 0.0001\nDIST_TOL = 0.01\nRAW_TOL = 0.5\nCLIPPER_TOL = 0.0000000001\nBIGNUM = 10000000\nROUNDING_PRECISION = 6\n\n# 건축선/인접대지경계선 (m)\nSMALL_SETBACK = 1.0\nLARGE_SETBACK = 2.0\nSMALL_ADJ_OFFSET = 0.5\nLARGE_ADJ_OFFSET = 1.5\n\n# 건축물 제약\nMIN_BUILDING_WIDTH = 4.0\nLARGE_LOT_AREA = 660.0\n\n# 주차 관련\nPARKING_WIDTH_OLD = 2.3\nPARKING_WIDTH_NEW = 2.5\nPARKING_DATE_THRESHOLD = \"2019-03-01\"\nMAX_CLUSTER_SIZE = 5\nMAX_TANDEM_ALLOWED = 8\nELEVATOR_CORE_SIZE = 5.0\nMIN_ROAD_WIDTH_FOR_PARKING = 6.0\n\n# 필터링 키워드\nDROP_KEYWORDS = [\n    '아파트', '공장', '창고시설', '노유자시설', '자동차관련시설',\n    '경로당', '관리사무소', '주민회의실', '무인택배', '경비실',\n    '위험물', '분뇨', '쓰레기', '동물', '식물', '발전시설',\n    '교정', '군사', '방송통신'\n]\n\n\n# ==============================================================================\n# 데이터 클래스\n# ==============================================================================\nclass Parcel:\n    \"\"\"필지 기본 클래스\"\"\"\n    def __init__(self, region: geo.Curve, pnu: str, jimok: str, record: Dict):\n        self.region = region\n        self.pnu = pnu\n        self.jimok = jimok\n        self.record = record\n\n\nclass Lot(Parcel):\n    \"\"\"대지 클래스\"\"\"\n    def __init__(self, region: geo.Curve, pnu: str, jimok: str, record: Dict,\n                 road_adj: str = None, max_height: float = None, min_height: float = None):\n        super().__init__(region, pnu, jimok, record)\n        self.road_adj = road_adj\n        self.max_height = max_height\n        self.min_height = min_height\n\n\nclass Road(Parcel):\n    \"\"\"도로 클래스\"\"\"\n    pass\n\n\nclass Building:\n    \"\"\"건축물 클래스\"\"\"\n    def __init__(self, pnu: str, a32: str, a33: str, a39: int, a50: str, a77: int):\n        self.pnu = pnu\n        self.a32 = a32  # 주용도\n        self.a33 = a33  # 상세용도\n        self.a39 = a39  # 기존 주차대수\n        self.a50 = a50  # 사용승인일\n        self.a77 = a77  # 승강기 수\n        self.tandem_mode = self._determine_tandem_mode()\n        self.should_drop = self._should_drop()\n\n    def _should_drop(self) -> bool:\n        \"\"\"제외 대상 여부\"\"\"\n        a32_str = str(self.a32).lower() if self.a32 else \"\"\n        a33_str = str(self.a33).lower() if self.a33 else \"\"\n\n        for keyword in DROP_KEYWORDS:\n            if keyword in a33_str:\n                return True\n\n        if '업무시설' in a32_str and '오피스텔' not in a33_str:\n            return True\n\n        return False\n\n    def _determine_tandem_mode(self) -> str:\n        \"\"\"연접주차 허용 여부\"\"\"\n        a33_str = str(self.a33) if self.a33 else \"\"\n\n        if '다가구' in a33_str:\n            return 'ALLOW_TANDEM'\n        if any(kw in a33_str for kw in ['다세대', '연립', '도시형']):\n            return 'DISALLOW_TANDEM'\n        return 'DISALLOW_TANDEM'\n\n\n# ==============================================================================\n# Shapefile 읽기 (pyshp 기반)\n# ==============================================================================\nclass ShapefileReader:\n    \"\"\"Shapefile 읽기 클래스 (pyshp 기반)\"\"\"\n\n    def __init__(self):\n        # Grasshopper에서 __file__이 rhinocode:// URI일 수 있음\n        try:\n            file_path = __file__\n            if file_path and not file_path.startswith('rhinocode:'):\n                self._module_root = Path(file_path).resolve().parent\n                self._project_root = self._module_root.parent\n            else:\n                self._module_root = Path.cwd()\n                self._project_root = Path.cwd()\n        except:\n            self._module_root = Path.cwd()\n            self._project_root = Path.cwd()\n\n    def _resolve_path(self, file_path: Any) -> Path:\n        \"\"\"경로 정규화\"\"\"\n        if file_path is None:\n            raise ValueError(\"File path is empty\")\n\n        if isinstance(file_path, (list, tuple)):\n            file_path = file_path[0] if file_path else None\n\n        raw_str = str(file_path).strip()\n        if not raw_str:\n            raise ValueError(\"File path is empty string\")\n\n        # Windows 경로 처리\n        if \"\\\\\" in raw_str and \"/\" not in raw_str:\n            candidate = Path(PureWindowsPath(raw_str).as_posix())\n        else:\n            candidate = Path(raw_str.replace(\"\\\\\", \"/\"))\n\n        candidate = candidate.expanduser()\n\n        if candidate.is_absolute() and candidate.exists():\n            return candidate\n\n        # 상대 경로 탐색\n        for root in [Path.cwd(), self._module_root, self._project_root]:\n            resolved = (root / candidate).resolve()\n            if resolved.exists():\n                return resolved\n\n        raise FileNotFoundError(f\"Cannot find file: {file_path}\")\n\n    def _get_field_value(self, record: List, fields: List[str], field_name: str, default: Any = None) -> Any:\n        \"\"\"필드 값 추출\"\"\"\n        try:\n            idx = fields.index(field_name)\n            return record[idx]\n        except (ValueError, IndexError):\n            return default\n\n    def _curve_from_points(self, points: List[Tuple[float, float]]) -> Optional[geo.PolylineCurve]:\n        \"\"\"점 리스트로 커브 생성\"\"\"\n        if len(points) < 3:\n            return None\n\n        pts3d = [geo.Point3d(p[0], p[1], 0) for p in points]\n\n        # 닫힌 커브 확인\n        if pts3d[0].DistanceTo(pts3d[-1]) > TOL:\n            pts3d.append(pts3d[0])\n\n        curve = geo.PolylineCurve(pts3d)\n        return curve if curve and curve.IsValid else None\n\n    def read_merged_data(self, file_path: str) -> Tuple[List[Tuple[Lot, Building]], List[Road]]:\n        \"\"\"병합된 Shapefile 읽기 (AL_D194_with_building.shp)\n\n        필드:\n        - A1: PNU, A11: 지목, A24: 도로접면\n        - B_A32: 주용도, B_A33: 상세용도, B_A39: 주차대수, B_A50: 사용승인일, B_A77: 승강기\n        \"\"\"\n        shp_path = self._resolve_path(file_path)\n\n        sf = None\n        for enc in ['utf-8', 'cp949', 'euc-kr', None]:\n            try:\n                sf = shapefile.Reader(str(shp_path), encoding=enc, encodingErrors='ignore') if enc else shapefile.Reader(str(shp_path))\n                sf.records()\n                print(f\"[ShapefileReader] Opened with encoding={enc}\")\n                break\n            except:\n                continue\n\n        if sf is None:\n            raise RuntimeError(f\"Failed to open shapefile: {shp_path}\")\n\n        shapes = sf.shapes()\n        records = sf.records()\n        fields = [f[0] for f in sf.fields[1:]]\n        fields_lower = [f.lower() for f in fields]\n\n        def get_idx(name):\n            name_l = name.lower()\n            return fields_lower.index(name_l) if name_l in fields_lower else -1\n\n        # 필드 인덱스\n        pnu_idx = get_idx('A1')\n        jimok_idx = get_idx('A11')\n        road_adj_idx = get_idx('A24')\n        min_h_idx = get_idx('min_height')\n        max_h_idx = get_idx('max_height')\n        b_a32_idx = get_idx('B_A32')\n        b_a33_idx = get_idx('B_A33')\n        b_a39_idx = get_idx('B_A39')\n        b_a50_idx = get_idx('B_A50')\n        b_a77_idx = get_idx('B_A77')\n\n        lot_building_pairs = []\n        roads = []\n        drop_count = 0\n\n        for shape, record in zip(shapes, records):\n            # 커브 생성\n            if len(shape.parts) <= 1:\n                curve = self._curve_from_points(shape.points)\n            else:\n                start = shape.parts[0]\n                end = shape.parts[1] if len(shape.parts) > 1 else len(shape.points)\n                curve = self._curve_from_points(shape.points[start:end])\n\n            if not curve:\n                continue\n\n            # 필드 값 읽기\n            pnu = str(record[pnu_idx]) if pnu_idx >= 0 else ''\n            jimok = str(record[jimok_idx]) if jimok_idx >= 0 else ''\n            road_adj = str(record[road_adj_idx]) if road_adj_idx >= 0 else ''\n            min_height = record[min_h_idx] if min_h_idx >= 0 else None\n            max_height = record[max_h_idx] if max_h_idx >= 0 else None\n\n            record_dict = {fields[i]: record[i] for i in range(len(fields)) if i < len(record)}\n\n            # 지목 기준 분류\n            if jimok in ['도로', '구거', ''] or not jimok.strip():\n                roads.append(Road(curve, pnu, jimok, record_dict))\n                continue\n\n            # 건물 정보 읽기\n            b_a32 = str(record[b_a32_idx]) if b_a32_idx >= 0 else ''\n            b_a33 = str(record[b_a33_idx]) if b_a33_idx >= 0 else ''\n            b_a39 = record[b_a39_idx] if b_a39_idx >= 0 else 0\n            b_a50 = str(record[b_a50_idx]) if b_a50_idx >= 0 else ''\n            b_a77 = record[b_a77_idx] if b_a77_idx >= 0 else 0\n\n            try:\n                b_a39 = int(b_a39) if b_a39 else 0\n                b_a77 = int(b_a77) if b_a77 else 0\n            except:\n                b_a39, b_a77 = 0, 0\n\n            # 건물 정보 없으면 스킵\n            if not b_a32 and not b_a33:\n                continue\n\n            building = Building(pnu, b_a32, b_a33, b_a39, b_a50, b_a77)\n\n            if building.should_drop:\n                drop_count += 1\n                continue\n\n            lot = Lot(curve, pnu, jimok, record_dict, road_adj, max_height, min_height)\n            lot_building_pairs.append((lot, building))\n\n        print(f\"[ShapefileReader] Loaded {len(lot_building_pairs)} lot-building pairs, {len(roads)} roads, dropped {drop_count}\")\n        return lot_building_pairs, roads\n\n\n# ==============================================================================\n# 기하학 유틸리티 (ghpythonlib 기반)\n# ==============================================================================\ndef get_area(curve: geo.Curve) -> float:\n    \"\"\"면적 계산\"\"\"\n    if not curve or not curve.IsValid:\n        return 0.0\n    try:\n        amp = geo.AreaMassProperties.Compute(curve)\n        return round(amp.Area, ROUNDING_PRECISION) if amp else 0.0\n    except:\n        return 0.0\n\n\ndef offset_inward(curve: geo.Curve, dist: float) -> Optional[geo.Curve]:\n    \"\"\"안쪽으로 offset (Rhino 기본 메서드)\"\"\"\n    if not curve or dist <= 0:\n        return None\n\n    try:\n        plane = geo.Plane.WorldXY\n        original_area = get_area(curve)\n\n        # 양방향 시도해서 면적이 줄어드는 쪽 선택\n        for sign in [-1, 1]:\n            offsets = curve.Offset(plane, sign * dist, TOL, geo.CurveOffsetCornerStyle.Sharp)\n\n            if not offsets or len(offsets) == 0:\n                continue\n\n            valid = [c for c in offsets if c and c.IsValid and c.IsClosed]\n            if not valid:\n                continue\n\n            # 가장 큰 면적 선택 (안쪽 offset 결과)\n            best = max(valid, key=lambda c: get_area(c))\n            best_area = get_area(best)\n\n            # 원본보다 작아야 안쪽 offset\n            if best_area < original_area and best_area > 0:\n                return best\n\n        return None\n    except Exception as e:\n        print(f\"[offset_inward] Error: {e}\")\n        return None\n\n\ndef simplify_with_offset(curve: geo.Curve, width: float) -> Optional[geo.Curve]:\n    \"\"\"offset in-out으로 단순화 (좁은 부분 제거)\"\"\"\n    if not curve or width <= 0:\n        return curve\n\n    try:\n        # 안쪽으로 offset\n        inner = offset_inward(curve, width / 2)\n        if not inner:\n            return None\n\n        # 다시 바깥으로 offset (Rhino 기본)\n        plane = geo.Plane.WorldXY\n        offsets = inner.Offset(plane, width / 2, TOL, geo.CurveOffsetCornerStyle.Sharp)\n\n        if not offsets or len(offsets) == 0:\n            return None\n\n        valid = [c for c in offsets if c and c.IsValid and c.IsClosed]\n        if valid:\n            return max(valid, key=lambda c: get_area(c))\n        return None\n    except:\n        return None\n\n\ndef curves_adjacent(curve_a: geo.Curve, curve_b: geo.Curve, threshold: float = 0.5) -> bool:\n    \"\"\"두 커브가 인접한지 확인\"\"\"\n    if not curve_a or not curve_b:\n        return False\n    try:\n        result = curve_a.ClosestPoints(curve_b)\n        if result[0]:\n            return result[1].DistanceTo(result[2]) <= threshold\n        return False\n    except:\n        return False\n\n\ndef estimate_road_width(road: Road) -> float:\n    \"\"\"도로 폭 추정\"\"\"\n    if not road or not road.region:\n        return 6.0\n    try:\n        area = get_area(road.region)\n        perimeter = road.region.GetLength()\n        if perimeter <= 0:\n            return 6.0\n        width = (2.0 * area) / perimeter\n        return max(2.0, min(width, 50.0))\n    except:\n        return 6.0\n\n\n# ==============================================================================\n# P_max 계산\n# ==============================================================================\ndef get_buildable_region(lot: Lot, debug: bool = False) -> Optional[geo.Curve]:\n    \"\"\"건축가능영역 계산 (필지 경계에서 1m offset)\"\"\"\n    if not lot or not lot.region:\n        if debug: print(f\"  [DEBUG] lot or region is None\")\n        return None\n\n    try:\n        lot_area = get_area(lot.region)\n        if debug: print(f\"  [DEBUG] lot_area={lot_area:.1f}\")\n\n        # 단순화: 1m offset만 적용\n        region = offset_inward(lot.region, 1.0)\n        if not region:\n            if debug: print(f\"  [DEBUG] 1m offset failed\")\n            return None\n\n        if debug: print(f\"  [DEBUG] after 1m offset area={get_area(region):.1f}\")\n\n        return region\n    except Exception as e:\n        if debug: print(f\"  [DEBUG] Exception: {e}\")\n        return None\n\n\nPARKING_DEPTH = 5.0  # 주차 깊이 (m)\nCLUSTER_GAP = 2.5  # 클러스터 간 간격 (m)\n\n\ndef get_longest_edge(curve: geo.Curve) -> Tuple[geo.Point3d, geo.Point3d, float]:\n    \"\"\"커브에서 가장 긴 변 찾기 (도로접면 추정용)\n\n    Returns:\n        (시작점, 끝점, 각도 in radians)\n    \"\"\"\n    import math\n\n    longest_length = 0\n    longest_start = None\n    longest_end = None\n    angle = 0\n\n    try:\n        segments = curve.DuplicateSegments()\n        if segments:\n            for seg in segments:\n                length = seg.GetLength()\n                if length > longest_length:\n                    longest_length = length\n                    longest_start = seg.PointAtStart\n                    longest_end = seg.PointAtEnd\n\n            if longest_start and longest_end:\n                dx = longest_end.X - longest_start.X\n                dy = longest_end.Y - longest_start.Y\n                angle = math.atan2(dy, dx)\n    except:\n        pass\n\n    return longest_start, longest_end, angle\n\n\ndef create_rotated_cell(cx: float, cy: float, width: float, depth: float, angle: float) -> List[Tuple[float, float]]:\n    \"\"\"회전된 주차 셀 생성\n\n    Args:\n        cx, cy: 셀 중심점\n        width: 주차폭 (차량 옆면 방향)\n        depth: 주차깊이 (차량 앞뒤 방향)\n        angle: 회전 각도 (radians)\n    \"\"\"\n    import math\n\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n\n    # 셀의 4개 코너 (중심 기준)\n    hw = width / 2\n    hd = depth / 2\n\n    corners = [\n        (-hd, -hw),  # 좌하\n        (hd, -hw),   # 우하\n        (hd, hw),    # 우상\n        (-hd, hw),   # 좌상\n    ]\n\n    rotated = []\n    for lx, ly in corners:\n        rx = cx + lx * cos_a - ly * sin_a\n        ry = cy + lx * sin_a + ly * cos_a\n        rotated.append((rx, ry))\n\n    rotated.append(rotated[0])  # 닫힌 폴리곤\n    return rotated\n\n\ndef curve_to_points(curve: geo.Curve) -> List[Tuple[float, float]]:\n    \"\"\"Rhino Curve를 좌표 리스트로 변환\"\"\"\n    pts = []\n    if not curve:\n        return pts\n\n    try:\n        # PolylineCurve인 경우\n        if hasattr(curve, 'ToPolyline'):\n            polyline = curve.ToPolyline()\n            if polyline:\n                for i in range(polyline.Count):\n                    pt = polyline[i]\n                    pts.append((pt.X, pt.Y))\n\n        # 점이 없으면 분할해서 추출\n        if not pts:\n            # 커브를 세그먼트로 분할\n            segments = curve.DuplicateSegments()\n            if segments:\n                for seg in segments:\n                    pt = seg.PointAtStart\n                    pts.append((pt.X, pt.Y))\n                # 마지막 점 추가\n                pt = segments[-1].PointAtEnd\n                pts.append((pt.X, pt.Y))\n\n        # 닫힌 폴리곤 확인\n        if pts and pts[0] != pts[-1]:\n            pts.append(pts[0])\n\n    except Exception as e:\n        print(f\"[curve_to_points] Error: {e}\")\n\n    return pts\n\n\ndef cell_inside_region(cell_pts: List[Tuple[float, float]], region_curve: geo.Curve) -> bool:\n    \"\"\"주차 셀이 주차가능영역 안에 완전히 포함되는지 확인\"\"\"\n    if not region_curve:\n        return False\n\n    for pt in cell_pts[:-1]:  # 마지막 점은 첫 점과 동일\n        pt3d = geo.Point3d(pt[0], pt[1], 0)\n        containment = region_curve.Contains(pt3d, geo.Plane.WorldXY, TOL)\n        if containment != geo.PointContainment.Inside:\n            return False\n    return True\n\n\ndef compute_pmax(lot: Lot, building: Building, road_width: float, debug: bool = False) -> Dict:\n    \"\"\"P_max 계산 + 주차 셀 생성 (도로접면 각도 기준 회전 배치)\"\"\"\n    import math\n\n    pnu = lot.pnu\n\n    # 주차가능영역 = 필지에서 1m offset (단순화)\n    parking_region = get_buildable_region(lot, debug=debug)\n    if not parking_region:\n        return {\n            'pnu': pnu, 'p_max': 0, 'p_existing': building.a39,\n            'p_diff': -building.a39, 'tandem_mode': building.tandem_mode,\n            'road_width': road_width,\n            'parking_cells': [],\n            'error': 'NO_BUILDABLE'\n        }\n\n    # 주차폭 결정\n    date_str = building.a50\n    if len(date_str) == 8:\n        date_str = f\"{date_str[:4]}-{date_str[4:6]}-{date_str[6:8]}\"\n    parking_width = PARKING_WIDTH_OLD if date_str < PARKING_DATE_THRESHOLD else PARKING_WIDTH_NEW\n\n    # 도로접면 각도 찾기 (가장 긴 변 = 도로접면 추정)\n    edge_start, edge_end, base_angle = get_longest_edge(lot.region)\n\n    if debug:\n        print(f\"  [DEBUG] base_angle={math.degrees(base_angle):.1f}°\")\n\n    # BoundingBox로 검색 범위 결정\n    try:\n        bbox = parking_region.GetBoundingBox(True)\n        min_x, min_y = bbox.Min.X, bbox.Min.Y\n        max_x, max_y = bbox.Max.X, bbox.Max.Y\n        bbox_width = max_x - min_x\n        bbox_height = max_y - min_y\n        center_x = (min_x + max_x) / 2\n        center_y = (min_y + max_y) / 2\n    except:\n        return {\n            'pnu': pnu, 'p_max': 0, 'p_existing': building.a39,\n            'p_diff': -building.a39, 'tandem_mode': building.tandem_mode,\n            'parking_cells': [],\n            'error': 'NO_BBOX'\n        }\n\n    # 연접 가능 여부에 따른 최대 열 수\n    max_rows = 2 if building.tandem_mode == 'ALLOW_TANDEM' else 1\n\n    # 검색 범위 (대각선 기준으로 충분히 넓게)\n    search_size = max(bbox_width, bbox_height) * 1.5\n    n_cols_max = int(search_size / parking_width) + 2\n    n_rows_max = min(max_rows, int(search_size / PARKING_DEPTH) + 2)\n\n    # 도로접면 기준 시작점 (가장 긴 변의 중점)\n    if edge_start and edge_end:\n        start_x = (edge_start.X + edge_end.X) / 2\n        start_y = (edge_start.Y + edge_end.Y) / 2\n    else:\n        start_x, start_y = center_x, center_y\n\n    # 셀 배치 (다양한 각도 시도 + 연속 배치 후 간격 적용)\n    best_cells = []\n\n    # 다양한 각도 시도 (0°, 30°, 45°, 60°, 90°)\n    for angle_offset in [0, math.pi/6, math.pi/4, math.pi/3, math.pi/2]:\n        angle = base_angle + angle_offset\n        cos_a = math.cos(angle)\n        sin_a = math.sin(angle)\n\n        angle_cells = []  # 이 각도에서의 모든 셀\n\n        for row in range(n_rows_max):\n            # 1단계: 연속으로 가능한 모든 셀 위치 찾기\n            candidate_cells = []\n\n            for col in range(-n_cols_max, n_cols_max + 1):\n                local_x = (row + 0.5) * PARKING_DEPTH\n                local_y = col * parking_width\n\n                cx = start_x + local_x * cos_a - local_y * sin_a\n                cy = start_y + local_x * sin_a + local_y * cos_a\n\n                cell = create_rotated_cell(cx, cy, parking_width, PARKING_DEPTH, angle)\n\n                if cell_inside_region(cell, parking_region):\n                    candidate_cells.append((col, cell))\n\n            # 2단계: 연속 구간 찾아서 5대마다 간격 적용\n            if candidate_cells:\n                candidate_cells.sort(key=lambda x: x[0])\n\n                # 연속 구간 분리\n                segments = []\n                current_segment = [candidate_cells[0]]\n\n                for i in range(1, len(candidate_cells)):\n                    if candidate_cells[i][0] == candidate_cells[i-1][0] + 1:\n                        current_segment.append(candidate_cells[i])\n                    else:\n                        segments.append(current_segment)\n                        current_segment = [candidate_cells[i]]\n                segments.append(current_segment)\n\n                # 각 연속 구간에서 5대마다 1대 제외 (간격 생성)\n                for segment in segments:\n                    for i, (col, cell) in enumerate(segment):\n                        # 6번째, 12번째, 18번째... 제외\n                        if (i + 1) % (MAX_CLUSTER_SIZE + 1) != 0:\n                            angle_cells.append(cell)\n\n        # 이 각도 결과가 더 좋으면 채택\n        if len(angle_cells) > len(best_cells):\n            best_cells = angle_cells\n\n    parking_cells = best_cells\n    p_max = len(parking_cells)\n\n    # 8대 이하 특례 (연접주차 허용인 경우)\n    if p_max > MAX_TANDEM_ALLOWED and building.tandem_mode == 'ALLOW_TANDEM':\n        # 1열만 사용하도록 재계산\n        single_row_cells = []\n\n        for angle_offset in [0, math.pi/6, math.pi/4, math.pi/3, math.pi/2]:\n            angle = base_angle + angle_offset\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n\n            candidate_cells = []\n            for col in range(-n_cols_max, n_cols_max + 1):\n                local_x = 0.5 * PARKING_DEPTH\n                local_y = col * parking_width\n\n                cx = start_x + local_x * cos_a - local_y * sin_a\n                cy = start_y + local_x * sin_a + local_y * cos_a\n\n                cell = create_rotated_cell(cx, cy, parking_width, PARKING_DEPTH, angle)\n\n                if cell_inside_region(cell, parking_region):\n                    candidate_cells.append((col, cell))\n\n            # 연속 구간 + 5대마다 간격 적용\n            if candidate_cells:\n                candidate_cells.sort(key=lambda x: x[0])\n                segments = []\n                current_segment = [candidate_cells[0]]\n\n                for i in range(1, len(candidate_cells)):\n                    if candidate_cells[i][0] == candidate_cells[i-1][0] + 1:\n                        current_segment.append(candidate_cells[i])\n                    else:\n                        segments.append(current_segment)\n                        current_segment = [candidate_cells[i]]\n                segments.append(current_segment)\n\n                valid_cells = []\n                for segment in segments:\n                    for i, (col, cell) in enumerate(segment):\n                        if (i + 1) % (MAX_CLUSTER_SIZE + 1) != 0:\n                            valid_cells.append(cell)\n\n                if len(valid_cells) > len(single_row_cells):\n                    single_row_cells = valid_cells\n\n        parking_cells = single_row_cells\n        p_max = len(parking_cells)\n\n    # 코어(승강기) 도형 생성 - 도로접면에서 가장 먼 곳에 배치\n    core_cells = []\n    if building.a77 > 0:\n        core_size = ELEVATOR_CORE_SIZE\n\n        # 도로접면(가장 긴 변) 중점에서 가장 먼 방향 찾기\n        # parking_region의 중심점 구하기\n        amp = geo.AreaMassProperties.Compute(parking_region)\n        if amp:\n            centroid = amp.Centroid\n            # 도로접면 중점에서 중심점 방향 = 안쪽 방향\n            dx = centroid.X - start_x\n            dy = centroid.Y - start_y\n            dist_to_center = math.sqrt(dx * dx + dy * dy)\n\n            if dist_to_center > 0:\n                # 안쪽 방향 단위 벡터\n                inward_x = dx / dist_to_center\n                inward_y = dy / dist_to_center\n\n                for core_idx in range(building.a77):\n                    placed = False\n                    # 안쪽으로 점점 들어가면서 배치 시도\n                    for depth_mult in [0.8, 0.6, 0.4, 0.2]:\n                        # 코어 중심 위치 (안쪽 깊숙이)\n                        core_depth = dist_to_center * depth_mult * 2  # 중심 넘어서 안쪽으로\n                        lateral_offset = (core_idx - (building.a77 - 1) / 2) * (core_size + 1.0)\n\n                        # 안쪽 방향으로 이동\n                        cx = start_x + inward_x * core_depth - inward_y * lateral_offset\n                        cy = start_y + inward_y * core_depth + inward_x * lateral_offset\n\n                        # 코어 사각형 생성 (도로접면 각도에 맞춤)\n                        core = create_rotated_cell(cx, cy, core_size, core_size, base_angle)\n\n                        if cell_inside_region(core, parking_region):\n                            core_cells.append(core)\n                            placed = True\n                            break\n\n                    if not placed:\n                        # 다른 각도로 시도\n                        core = create_rotated_cell(cx, cy, core_size, core_size, base_angle + math.pi / 2)\n                        if cell_inside_region(core, parking_region):\n                            core_cells.append(core)\n\n    # 코어와 겹치는 주차 셀 제거\n    if core_cells:\n        def cells_overlap(cell1: List[Tuple[float, float]], cell2: List[Tuple[float, float]]) -> bool:\n            \"\"\"두 셀(폴리곤)이 겹치는지 확인\"\"\"\n            # cell1의 중심점이 cell2 내부에 있는지 확인\n            c1_cx = sum(p[0] for p in cell1[:-1]) / 4\n            c1_cy = sum(p[1] for p in cell1[:-1]) / 4\n            c2_cx = sum(p[0] for p in cell2[:-1]) / 4\n            c2_cy = sum(p[1] for p in cell2[:-1]) / 4\n\n            # 중심점 간 거리로 겹침 판단 (간단한 방법)\n            # 코어 크기(5m)와 주차 셀 크기(~2.5m x 5m) 고려\n            dist = math.sqrt((c1_cx - c2_cx) ** 2 + (c1_cy - c2_cy) ** 2)\n            min_dist = (core_size + max(parking_width, PARKING_DEPTH)) / 2\n            return dist < min_dist\n\n        # 코어와 겹치지 않는 주차 셀만 유지\n        filtered_parking = []\n        for p_cell in parking_cells:\n            overlaps = False\n            for c_cell in core_cells:\n                if cells_overlap(p_cell, c_cell):\n                    overlaps = True\n                    break\n            if not overlaps:\n                filtered_parking.append(p_cell)\n\n        parking_cells = filtered_parking\n        p_max = len(parking_cells)\n\n    return {\n        'pnu': pnu,\n        'p_max': p_max,\n        'p_existing': building.a39,\n        'p_diff': p_max - building.a39,\n        'tandem_mode': building.tandem_mode,\n        'parking_width': parking_width,\n        'road_width': round(road_width, 2),\n        'parking_cells': parking_cells,  # 도로접면 기준 회전된 셀들\n        'core_cells': core_cells  # 코어(승강기) 도형\n    }\n\n\n# ==============================================================================\n# 좌표 매칭 함수\n# ==============================================================================\ndef point_in_curve(pt: geo.Point3d, curve: geo.Curve) -> bool:\n    \"\"\"점이 닫힌 커브 내부에 있는지 확인\"\"\"\n    if not curve or not curve.IsClosed:\n        return False\n    result = curve.Contains(pt, geo.Plane.WorldXY, TOL)\n    return result == geo.PointContainment.Inside\n\n\ndef curves_overlap(curve_a: geo.Curve, curve_b: geo.Curve) -> bool:\n    \"\"\"두 커브가 겹치는지 확인 (내부 포함 또는 교차)\"\"\"\n    if not curve_a or not curve_b:\n        return False\n\n    try:\n        # curve_b의 중심점이 curve_a 내부에 있는지\n        amp = geo.AreaMassProperties.Compute(curve_b)\n        if amp and point_in_curve(amp.Centroid, curve_a):\n            return True\n\n        # 교차점 확인\n        intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, TOL, TOL)\n        if intersections and intersections.Count > 0:\n            return True\n\n        return False\n    except:\n        return False\n\n\n# ==============================================================================\n# 메인 실행\n# ==============================================================================\ndef run_parking_calculation(shapefile_path: str, save_path: str):\n    \"\"\"메인 실행 함수 (병합된 데이터 사용)\"\"\"\n    print(\"=\" * 60)\n    print(\"P_max 주차대수 산출 시스템\")\n    print(\"=\" * 60)\n\n    reader = ShapefileReader()\n    # 1. 데이터 로드 (이미 매칭됨)\n    print(\"\\n[STEP 1] 데이터 로드\")\n    lot_building_pairs, roads = reader.read_merged_data(shapefile_path)\n\n    print(f\"  Lot-Building pairs: {len(lot_building_pairs)}, Roads: {len(roads)}\")\n\n\n    # 2. P_max 계산\n    print(\"\\n[STEP 2] P_max 계산\")\n    results = []\n    success_count = 0\n\n    st_time = time.time()\n    for i, (lot, building) in enumerate(lot_building_pairs):\n        if (i + 1) % 500 == 0:\n            print(f\"  계산 진행: {i+1}/{len(lot_building_pairs)}\")\n\n        # A24 (도로접면 코드)로 도로폭 판단\n        # 10, 11, 12 = 6m 미만 / 나머지 = 6m 이상\n        road_adj_code = str(lot.road_adj).strip() if lot.road_adj else ''\n        if road_adj_code in ['10', '11', '12']:\n            road_width = 4.0  # 6m 미만\n        else:\n            road_width = 6.0  # 6m 이상\n\n        # 처음 3개 디버그 출력\n        debug = (i < 3)\n        if debug:\n            print(f\"\\n[DEBUG #{i}] PNU={lot.pnu}, road_adj={road_adj_code}, road_width={road_width}\")\n\n        result = compute_pmax(lot, building, road_width, debug=debug)\n        results.append(result)\n\n        if debug:\n            print(f\"  -> p_max={result['p_max']}, error={result.get('error', 'None')}\")\n\n        if result['p_max'] > 0:\n            success_count += 1\n\n    # 3. 저장 (SHP)\n    print(f\"\\n[STEP 3] 결과 저장\")\n    print(f\"  계산 완료: {len(results)}개\")\n    print(f\"  P_max > 0: {success_count}개\")\n    print(f\"  소요 시간: {time.time() - st_time:.2f}초\")\n\n    if results and save_path:\n        save_file = str(save_path)\n        if save_file.endswith('.csv'):\n            save_file = save_file.replace('.csv', '.shp')\n        elif not save_file.endswith('.shp'):\n            save_file = save_file + '_parking.shp'\n\n        # Shapefile 작성 (주차 셀 + 코어 폴리곤)\n        w = shapefile.Writer(save_file)\n        w.field('PNU', 'C', 20)\n        w.field('TYPE', 'C', 10)  # PARKING / CORE\n        w.field('CELL_ID', 'N', 10, 0)\n        w.field('P_MAX', 'N', 10, 0)\n        w.field('P_EXIST', 'N', 10, 0)\n        w.field('TANDEM', 'C', 20)\n        w.field('PARK_W', 'N', 10, 2)\n\n        cell_count = 0\n        core_count = 0\n        for r in results:\n            pnu = r['pnu'][:20] if r['pnu'] else ''\n\n            # 주차 셀 출력\n            parking_cells = r.get('parking_cells', [])\n            for cell_id, cell_pts in enumerate(parking_cells):\n                w.poly([cell_pts])\n                w.record(\n                    pnu,\n                    'PARKING',\n                    cell_id + 1,\n                    r['p_max'],\n                    r['p_existing'],\n                    r['tandem_mode'][:20] if r['tandem_mode'] else '',\n                    r.get('parking_width', 0)\n                )\n                cell_count += 1\n\n            # 코어 출력\n            core_cells = r.get('core_cells', [])\n            for core_id, core_pts in enumerate(core_cells):\n                w.poly([core_pts])\n                w.record(\n                    pnu,\n                    'CORE',\n                    core_id + 1,\n                    r['p_max'],\n                    r['p_existing'],\n                    r['tandem_mode'][:20] if r['tandem_mode'] else '',\n                    0  # 코어는 주차폭 없음\n                )\n                core_count += 1\n\n        w.close()\n\n        # PRJ 파일 (Korean 1985 Modified - 입력 데이터와 동일)\n        prj_content = '''PROJCS[\"Korean_1985_Modified_Korea_Central_Belt\",GEOGCS[\"GCS_Korean_Datum_1985\",DATUM[\"D_Korean_Datum_1985\",SPHEROID[\"Bessel_1841\",6377397.155,299.1528128]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",200000.0],PARAMETER[\"False_Northing\",500000.0],PARAMETER[\"Central_Meridian\",127.002890277778],PARAMETER[\"Scale_Factor\",1.0],PARAMETER[\"Latitude_Of_Origin\",38.0],UNIT[\"Meter\",1.0]]'''\n        prj_path = save_file.replace('.shp', '.prj')\n        with open(prj_path, 'w') as f:\n            f.write(prj_content)\n\n        print(f\"  저장: {save_file}\")\n        print(f\"  총 주차 셀: {cell_count}개\")\n        print(f\"  총 코어: {core_count}개\")\n\n        # CSV 파일 작성 (필지별 요약)\n        csv_file = save_file.replace('.shp', '.csv')\n        with open(csv_file, 'w', encoding='utf-8-sig') as f:\n            # 헤더\n            f.write('PNU,P_MAX,P_EXIST,P_DIFF,TANDEM_MODE,PARKING_WIDTH,ROAD_WIDTH,CORE_CNT,ERROR\\n')\n\n            for r in results:\n                pnu = r.get('pnu', '')\n                p_max = r.get('p_max', 0)\n                p_exist = r.get('p_existing', 0)\n                p_diff = r.get('p_diff', 0)\n                tandem = r.get('tandem_mode', '')\n                park_w = r.get('parking_width', 0)\n                road_w = r.get('road_width', 0)\n                core_cnt = len(r.get('core_cells', []))\n                error = r.get('error', '')\n\n                f.write(f'{pnu},{p_max},{p_exist},{p_diff},{tandem},{park_w},{road_w},{core_cnt},{error}\\n')\n\n        print(f\"  CSV 저장: {csv_file}\")\n\n    # 통계\n    if results:\n        p_max_values = [r['p_max'] for r in results]\n        p_existing_values = [r['p_existing'] for r in results]\n        print(f\"\\n[통계]\")\n        print(f\"  평균 P_max: {sum(p_max_values)/len(p_max_values):.2f}\")\n        print(f\"  평균 기존: {sum(p_existing_values)/len(p_existing_values):.2f}\")\n        print(f\"  연접 허용: {sum(1 for r in results if r['tandem_mode'] == 'ALLOW_TANDEM')}개\")\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"완료!\")\n    print(\"=\" * 60)\n\n    return results\n\n\n# ==============================================================================\n# Grasshopper 진입점\n# ==============================================================================\nif __name__ == \"__main__\":\n    shapefile_path = globals().get('shapefile_path', None)\n    save_path = globals().get('save_path', None)\n\n    if shapefile_path:\n        results = run_parking_calculation(shapefile_path, save_path)\n    else:\n        print(\"[ERROR] 입력 경로를 설정해주세요:\")\n        print(\"  - shapefile_path: 병합된 Shapefile (AL_D194_with_building.shp)\")\n        print(\"  - save_path: 결과 저장 경로 (CSV)\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}