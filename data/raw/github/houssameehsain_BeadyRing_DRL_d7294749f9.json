{
  "source_url": "https://github.com/houssameehsain/BeadyRing_DRL/blob/f8f228c52a733176cbb32d666e012d1ceb12e29e/BeadyRing_env.py",
  "repo": "houssameehsain/BeadyRing_DRL",
  "repo_stars": 4,
  "repo_description": "Modeling of urban form based on the 'Beady Ring' model (Hillier & Hanson, 1984) using deep reinforcement learning.",
  "license": "MIT",
  "filepath": "BeadyRing_env.py",
  "instruction": "Beady ring env",
  "code": "import random\r\nfrom math import floor\r\nimport scriptcontext as sc\r\nimport ghpythonlib.components as ghcomp\r\nimport ghpythonlib.treehelpers as th\r\n\r\n\r\nclass BeadyRing_env:\r\n    def __init__(self):\r\n        self._carrier_color = 127.5\r\n        self._house_color = 0\r\n        self._street_color = 255\r\n        self._cell_size = 3\r\n        self._max_row_len = 21\r\n        self._obs_size = 9\r\n        self._3d = False\r\n        self.pad = int(floor(self._obs_size/2))\r\n        self.max_world_row_len = int(self._max_row_len + 2*self.pad)\r\n        self.iter = 0\r\n        \r\n        # grid world\r\n        xy_plane = ghcomp.XYPlane(ghcomp.ConstructPoint(0, 0, 0))\r\n        cell, _ = ghcomp.Rectangle(xy_plane, self._cell_size, self._cell_size, 0)\r\n        \r\n        r_max = self._cell_size * self.max_world_row_len\r\n        move_range = [i for i in range(0, r_max, self._cell_size)]\r\n        \r\n        y_vec = ghcomp.UnitY(move_range)\r\n        cell_col, _ = ghcomp.Move(cell, y_vec)\r\n        \r\n        x_vec = ghcomp.UnitX(move_range)\r\n        grid_world = []\r\n        for c in cell_col:\r\n            cell_row, _ = ghcomp.Move(c, x_vec)\r\n            grid_world.append(cell_row)\r\n        \r\n        self.grid_world = ghcomp.ReverseList(grid_world)\r\n        \r\n        # initial location\r\n        self.R = int(floor(self.max_world_row_len/2))\r\n        self.C = int(floor(self.max_world_row_len/2))\r\n        \r\n        R_space = [r for r in range(int(self.pad), int(self._max_row_len + self.pad))]\r\n        C_space = [c for c in range(int(self.pad), int(self._max_row_len + self.pad))]\r\n        self.RC_space = [[[r, c] for c in C_space] for r in R_space]\r\n        \r\n        self.x = self.R - self.pad\r\n        self.y = self.C - self.pad\r\n        \r\n        self.cell = [[self.x, self.y], [self.R, self.C]]\r\n        self.adjacent_cells = [[[self.x, self.y], [self.R, self.C]]]\r\n        self.adj_cells = [[[self.x, self.y], [self.R, self.C]]]\r\n        \r\n        # initial state\r\n        self.state = [[self._carrier_color for _ in range(int(self.max_world_row_len))] \r\n                        for _ in range(int(self.max_world_row_len))]\r\n        \r\n        # initial observation\r\n        self.observation = self.get_obs()\r\n\r\n    def step(self, _cell_state):\r\n        self.iter += 1\r\n        # update state step\r\n        self.state[self.R][self.C] = 255*_cell_state\r\n        \r\n        for i, a in enumerate(self.adj_cells):\r\n            if a == self.cell:\r\n                del self.adj_cells[i]\r\n        \r\n        adjacent = self.get_adjacent()\r\n        \r\n        # reward\r\n        reward = 0\r\n        adj_street_count = 0\r\n        \r\n        for a in adjacent:\r\n            if int(self.state[a[1][0]][a[1][1]]) == 255:\r\n                adj_street_count += 1\r\n        \r\n        if _cell_state == 1:\r\n            if adj_street_count >= 3:\r\n                reward -= 1\r\n            elif adj_street_count == 0:\r\n                reward -= 1\r\n            elif 0 < adj_street_count < 3:\r\n                reward += 1\r\n        elif _cell_state == 0:\r\n            # density metric\r\n            reward += 1/(self._max_row_len**2)\r\n            if adj_street_count == 0:\r\n                reward -= 1\r\n            elif adj_street_count >= 3:\r\n                reward -= 1\r\n            elif 0 < adj_street_count < 3:\r\n                reward += 2\r\n        \r\n        for item in adjacent:\r\n            if item not in self.adjacent_cells:\r\n                self.adjacent_cells.append(item)\r\n                self.adj_cells.append(item)\r\n        \r\n        # done\r\n        done = False\r\n        if len(self.adj_cells) == 0:\r\n            done = True\r\n        elif len(self.adj_cells) > 0:\r\n            # next action location selection\r\n            self.cell = random.choice(self.adj_cells)\r\n            \r\n            self.x = self.cell[0][0]\r\n            self.y = self.cell[0][1]\r\n            \r\n            self.R = self.cell[1][0]\r\n            self.C = self.cell[1][1]\r\n        \r\n        # observation\r\n        self.observation = self.get_obs()\r\n        \r\n        return self.observation, reward, done, {}\r\n\r\n    def reset(self):\r\n        # initial state\r\n        self.state = [[self._carrier_color for _ in range(int(self.max_world_row_len))] \r\n                        for _ in range(int(self.max_world_row_len))]\r\n        \r\n        # reset step counter\r\n        self.iter = 0\r\n        \r\n        # initial location\r\n        self.R = int(floor(self.max_world_row_len/2))\r\n        self.C = int(floor(self.max_world_row_len/2))\r\n        \r\n        self.x = self.R - self.pad\r\n        self.y = self.C - self.pad\r\n        \r\n        self.cell = [[self.x, self.y], [self.R, self.C]]\r\n        self.adjacent_cells = [[[self.x, self.y], [self.R, self.C]]]\r\n        self.adj_cells = [[[self.x, self.y], [self.R, self.C]]]\r\n        \r\n        # initial observation\r\n        self.observation = self.get_obs()\r\n        \r\n        return self.observation\r\n\r\n    def render(self):\r\n        # state visualization\r\n        color_state = [ghcomp.ColourRGB(255, self.state[i], self.state[i], \r\n                        self.state[i]) for i in range(self.max_world_row_len)]\r\n        \r\n        # observation grid\r\n        left_up_R = int(self.R - self.pad)\r\n        left_up_C = int(self.C - self.pad)\r\n        right_bottom_R = int(self.R + self.pad)\r\n        right_bottom_C = int(self.C + self.pad)\r\n        obs_grid_ = []\r\n        for i in range(left_up_R, right_bottom_R + 1):\r\n            obs_grid_.append(self.grid_world[i][left_up_C : right_bottom_C + 1])\r\n        \r\n        return color_state, obs_grid_\r\n\r\n    def get_obs(self):\r\n        # observation\r\n        left_up_R = int(self.R - self.pad)\r\n        left_up_C = int(self.C - self.pad)\r\n        right_bottom_R = int(self.R + self.pad)\r\n        right_bottom_C = int(self.C + self.pad)\r\n        obs_ = []\r\n        for i in range(left_up_R, right_bottom_R + 1):\r\n            obs_row = []\r\n            for j in range(left_up_C, right_bottom_C + 1):\r\n                item = self.state[i][j]\r\n                obs_row.append(item)\r\n            obs_.append(obs_row)\r\n        return obs_\r\n\r\n    def get_adjacent(self):\r\n        # von Neumann neighbourhood\r\n        adjacent = []\r\n        if self.x < len(self.RC_space) - 1:\r\n            adjacent.append([[self.x+1, self.y], self.RC_space[self.x+1][self.y]])\r\n        if self.y > 0:\r\n            adjacent.append([[self.x, self.y-1], self.RC_space[self.x][self.y-1]])\r\n        if self.x > 0:\r\n            adjacent.append([[self.x-1, self.y], self.RC_space[self.x-1][self.y]])\r\n        if self.y < len(self.RC_space[self.x]) - 1:\r\n            adjacent.append([[self.x, self.y+1], self.RC_space[self.x][self.y+1]])\r\n        return adjacent\r\n\r\n    def get_house_cells(self):\r\n        ## house cells\r\n        house_cells_ = []\r\n        for i in range(self.max_world_row_len):\r\n            for j in range(self.max_world_row_len):\r\n                if self.state[i][j] == 0:\r\n                    house_cells_.append(self.grid_world[i][j])\r\n        return house_cells_\r\n\r\nif 'env' not in globals():\r\n    env = BeadyRing_env()\r\n    sc.sticky['env'] = env\r\n\r\nif reset:\r\n    observation = sc.sticky['env'].reset()\r\n    reward = None\r\n    done = False\r\n    info = {}\r\n    \r\nelif action is not None:\r\n    observation, reward, done, info = sc.sticky['env'].step(action)\r\n    \r\nelse:\r\n    raise RuntimeError(\"Either reset or action must be provided\")\r\n\r\nif render:\r\n    grid_world_ = th.list_to_tree(sc.sticky['env'].grid_world, source=[0,0])\r\n    color_state, obs_grid = sc.sticky['env'].render()\r\n    color_state_ = th.list_to_tree(color_state, source=[0,0])\r\n    obs_grid_ = th.list_to_tree(obs_grid, source=[0,0])\r\n    if sc.sticky['env']._3d:\r\n        house_cells = sc.sticky['env'].get_house_cells()\r\n        house_cells_ = th.list_to_tree(house_cells, source=[0,0])\r\n\r\nsc.sticky[\"observation\"] = observation\r\nsc.sticky[\"reward\"] = reward\r\nsc.sticky[\"done\"] = done\r\nsc.sticky[\"info\"] = info\r\n\r\n\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}