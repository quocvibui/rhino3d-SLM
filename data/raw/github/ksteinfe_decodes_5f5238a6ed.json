{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/mesh.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/mesh.py",
  "instruction": null,
  "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport System.Guid, System.Array, System.Drawing.Color\n\n\ndef AddMesh(vertices, face_vertices, vertex_normals=None, texture_coordinates=None, vertex_colors=None):\n    \"\"\"Adds a mesh object to the document\n    Parameters:\n      vertices = list of 3D points defining the vertices of the mesh\n      face_vertices = list containing lists of 3 or 4 numbers that define the\n        vertex indices for each face of the mesh. If the third a fourth vertex\n        indices of a face are identical, a triangular face will be created.\n      vertex_normals[opt] = list of 3D vectors defining the vertex normals of\n        the mesh. Note, for every vertex, there must be a corresponding vertex\n        normal\n      texture_coordinates[opt] = list of 2D texture coordinates. Note, for\n        every vertex, there must be a corresponding texture coordinate\n      vertex_colors[opt] = a list of color values. Note, for every vertex,\n        there must be a corresponding vertex color\n    Returns:\n      Identifier of the new object if successful\n      None on error\n    \"\"\"\n    mesh = Rhino.Geometry.Mesh()\n    for a, b, c in vertices: mesh.Vertices.Add(a, b, c)\n    for face in face_vertices:\n        if len(face)<4:\n            mesh.Faces.AddFace(face[0], face[1], face[2])\n        else:\n            mesh.Faces.AddFace(face[0], face[1], face[2], face[3])\n    if vertex_normals:\n        count = len(vertex_normals)\n        normals = System.Array.CreateInstance(Rhino.Geometry.Vector3f, count)\n        for i, normal in enumerate(vertex_normals):\n            normals[i] = Rhino.Geometry.Vector3f(normal[0], normal[1], normal[2])\n        mesh.Normals.SetNormals(normals)\n    if texture_coordinates:\n        count = len(texture_coordinates)\n        tcs = System.Array.CreateInstance(Rhino.Geometry.Point2f, count)\n        for i, tc in enumerate(texture_coordinates):\n            tcs[i] = Rhino.Geometry.Point2f(tc[0], tc[1], tc[2])\n        mesh.TextureCoordinates.SetTextureCoordinates(tcs)\n    if vertex_colors:\n        count = len(vertex_colors)\n        colors = System.Array.CreateInstance(System.Drawing.Color, count)\n        for i, color in enumerate(vertex_colors):\n            colors[i] = System.Drawing.Color.FromArgb(color[0], color[1], color[2])\n        mesh.VertexColors.SetColors(colors)\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef AddPlanarMesh(object_id, delete_input=False):\n    \"\"\"Creates a planar mesh from a closed, planar curve\n    Parameters:\n      object_id = identifier of a closed, planar curve\n      delete_input[opt] = if True, delete the input curve defined by object_id\n    Returns:\n      id of the new mesh on success\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(object_id, -1, True)\n    mesh = Rhino.Geometry.Mesh.CreateFromPlanarBoundary(curve, Rhino.Geometry.MeshingParameters.Default)\n    if not mesh: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(mesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef CurveMeshIntersection(curve_id, mesh_id, return_faces=False):\n    \"\"\"Calculates the intersection of a curve object and a mesh object\n    Parameters:\n      curve_id = identifier of a curve object\n      mesh_id = identifier or a mesh object\n      return_faces[opt] = return both intersection points and face indices.\n        If False, then just the intersection points are returned\n    Returns:\n      if return_false is omitted or False, then a list of intersection points\n      if return_false is True, the a one-dimensional list containing information\n        about each intersection. Each element contains the following two elements\n        (point of intersection, mesh face index where intersection lies)\n      None on error\n    \"\"\"\n    curve = rhutil.coercecurve(curve_id, -1, True)\n    mesh = rhutil.coercemesh(mesh_id, True)\n    tolerance = scriptcontext.doc.ModelAbsoluteTolerance\n    polylinecurve = curve.ToPolyline(0,0,0,0,0.0,tolerance,0.0,0.0,True)\n    pts, faceids = Rhino.Geometry.Intersect.Intersection.MeshPolyline(mesh, polylinecurve)\n    if not pts: return scriptcontext.errorhandler()\n    pts = list(pts)\n    if return_faces:\n        faceids = list(faceids)\n        return list(zip(pts, faceids))\n    return pts\n\n\ndef DisjointMeshCount(object_id):\n    \"\"\"Returns number of meshes that could be created by calling SplitDisjointMesh\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      The number of meshes that could be created\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.DisjointMeshCount\n\n\ndef DuplicateMeshBorder(mesh_id):\n    \"\"\"Creates curves that duplicates a mesh border\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of curve ids on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    polylines = mesh.GetNakedEdges()\n    rc = []\n    if polylines:\n        for polyline in polylines:\n            id = scriptcontext.doc.Objects.AddPolyline(polyline)\n            if id!=System.Guid.Empty: rc.append(id)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef ExplodeMeshes(mesh_ids, delete=False):\n    \"\"\"Explodes a mesh object, or mesh objects int submeshes. A submesh is a\n    collection of mesh faces that are contained within a closed loop of\n    unwelded mesh edges. Unwelded mesh edges are where the mesh faces that\n    share the edge have unique mesh vertices (not mesh topology vertices)\n    at both ends of the edge\n    Parameters:\n      mesh_ids = list of mesh identifiers\n      delete[opt] = delete the input meshes\n    Returns:\n      List of identifiers\n    \"\"\"\n    id = rhutil.coerceguid(mesh_ids)\n    if id: mesh_ids = [mesh_ids]\n    rc = []\n    for mesh_id in mesh_ids:\n        mesh = rhutil.coercemesh(mesh_id, True)\n        if mesh:\n            submeshes = mesh.ExplodeAtUnweldedEdges()\n            if submeshes:\n                for submesh in submeshes:\n                    id = scriptcontext.doc.Objects.AddMesh(submesh)\n                    if id!=System.Guid.Empty: rc.append(id)\n    if rc: scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef IsMesh(object_id):\n    \"Verifies if an object is a mesh\"\n    mesh = rhutil.coercemesh(object_id)\n    return mesh is not None\n\n\ndef IsMeshClosed(object_id):\n    \"\"\"Verifies a mesh object is closed\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.IsClosed\n\n\ndef IsMeshManifold(object_id):\n    \"\"\"Verifies a mesh object is manifold. A mesh for which every edge is shared\n    by at most two faces is called manifold. If a mesh has at least one edge\n    that is shared by more than two faces, then that mesh is called non-manifold\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.IsManifold(True)\n    return rc[0]\n\n\ndef IsPointOnMesh(object_id, point):\n    \"\"\"Verifies that a point is on a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n      point = test point\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    max_distance = Rhino.RhinoMath.SqrtEpsilon\n    face, pt = mesh.ClosestPoint(point, max_distance)\n    return face>=0\n\n\ndef MeshArea(object_ids):\n    \"\"\"Returns the approximate area of one or more mesh objects\n    Parameters:\n      object_ids = identifiers of one or more mesh objects\n    Returns:\n      a list containing 3 numbers if successful where\n        element[0] = number of meshes used in calculation\n        element[1] = total area of all meshes\n        element[2] = the error estimate\n      None if not successful\n    \"\"\"\n    id = rhutil.coerceguid(object_ids)\n    if id: object_ids = [object_ids]\n    meshes_used = 0\n    total_area = 0.0\n    error_estimate = 0.0\n    for id in object_ids:\n        mesh = rhutil.coercemesh(id, True)\n        if mesh:\n            mp = Rhino.Geometry.AreaMassProperties.Compute(mesh)\n            if mp:\n                meshes_used += 1\n                total_area += mp.Area\n                error_estimate += mp.AreaError\n    if meshes_used==0: return scriptcontext.errorhandler()\n    return meshes_used, total_area, error_estimate\n\n\ndef MeshAreaCentroid(object_id):\n    \"\"\"Calculates the area centroid of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      Point3d representing the area centroid if successful\n      None on error  \n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    mp = Rhino.Geometry.AreaMassProperties.Compute(mesh)\n    if mp is None: return scriptcontext.errorhandler()\n    return mp.Centroid\n\n\ndef MeshBooleanDifference(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean difference operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanDifference(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshBooleanIntersection(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean intersection operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes on success\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanIntersection(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\ndef MeshBooleanSplit(input0, input1, delete_input=True):\n    \"\"\"Performs a boolean split operation on two sets of input meshes\n    Parameters:\n      input0, input1 = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes on success\n      None on error\n    \"\"\"\n    id = rhutil.coerceguid(input0)\n    if id: input0 = [id]\n    id = rhutil.coerceguid(input1)\n    if id: input1 = [id]\n    meshes0 = [rhutil.coercemesh(id, True) for id in input0]\n    meshes1 = [rhutil.coercemesh(id, True) for id in input1]\n    if not meshes0 or not meshes1: raise ValueError(\"no meshes to work with\")\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanSplit(meshes0, meshes1)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        input = input0 + input1\n        for id in input:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshBooleanUnion(mesh_ids, delete_input=True):\n    \"\"\"Performs a boolean union operation on a set of input meshes\n    Parameters:\n      mesh_ids = identifiers of meshes\n      delete_input[opt] = delete the input meshes\n    Returns:\n      list of identifiers of new meshes\n    \"\"\"\n    if len(mesh_ids)<2: raise ValueError(\"mesh_ids must contain at least 2 meshes\")\n    meshes = [rhutil.coercemesh(id, True) for id in mesh_ids]\n    newmeshes = Rhino.Geometry.Mesh.CreateBooleanUnion(meshes)\n    rc = []\n    for mesh in newmeshes:\n        id = scriptcontext.doc.Objects.AddMesh(mesh)\n        if id!=System.Guid.Empty: rc.append(id)\n    if rc and delete_input:\n        for id in mesh_ids:\n            id = rhutil.coerceguid(id, True)\n            scriptcontext.doc.Objects.Delete(id, True)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshClosestPoint(object_id, point, maximum_distance=None):\n    \"\"\"Returns the point on a mesh that is closest to a test point\n    Parameters:\n      object_id = identifier of a mesh object\n      point = point to test\n      maximum_distance[opt] = upper bound used for closest point calculation.\n        If you are only interested in finding a point Q on the mesh when\n        point.DistanceTo(Q) < maximum_distance, then set maximum_distance to\n        that value\n    Returns:\n      Tuple containing the results of the calculation where\n        element[0] = the 3-D point on the mesh\n        element[1] = the index of the mesh face on which the 3-D point lies\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    point = rhutil.coerce3dpoint(point, True)\n    tolerance=maximum_distance if maximum_distance else 0.0\n    face, closest_point = mesh.ClosestPoint(point, tolerance)\n    if face<0: return scriptcontext.errorhandler()\n    return closest_point, face\n\n\n# [skipping for now] MeshContourPoints\n\ndef MeshFaceCenters(mesh_id):\n    \"\"\"Returns the center of each face of the mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of 3d points defining the center of each face\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    count = mesh.Faces.Count\n    rc = [mesh.Faces.GetFaceCenter(i) for i in range(count)]\n    return rc\n\n\ndef MeshFaceCount(object_id):\n    \"\"\"Returns the total face count of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.Count\n\n\ndef MeshFaceNormals(mesh_id):\n    \"\"\"Returns the face unit normal for each face of a mesh object\n    Paramters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      A list of 3D vectors that define the face unit normals of the mesh\n      None on error    \n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    if mesh.FaceNormals.Count != mesh.Faces.Count:\n        mesh.FaceNormals.ComputeFaceNormals()\n    rc = []\n    for i in range(mesh.FaceNormals.Count):\n        normal = mesh.FaceNormals[i]\n        rc.append(Rhino.Geometry.Vector3d(normal))\n    return rc\n\n\ndef MeshFaces(object_id, face_type=True):\n    \"\"\"Returns the face vertices of a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n      face_type[opt] = The face type to be returned. True = both triangles\n        and quads. False = only triangles\n    Returns:\n      a list of 3D points that define the face vertices of the mesh. If\n      face_type is True, then faces are returned as both quads and triangles\n      (4 3D points). For triangles, the third and fourth vertex will be\n      identical. If face_type is False, then faces are returned as only\n      triangles(3 3D points). Quads will be converted to triangles.\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = []\n    for i in range(mesh.Faces.Count):\n        getrc, p0, p1, p2, p3 = mesh.Faces.GetFaceVertices(i)\n        p0 = Rhino.Geometry.Point3d(p0)\n        p1 = Rhino.Geometry.Point3d(p1)\n        p2 = Rhino.Geometry.Point3d(p2)\n        p3 = Rhino.Geometry.Point3d(p3)\n        rc.append( p0 )\n        rc.append( p1 )\n        rc.append( p2 )\n        if face_type:\n            rc.append(p3)\n        else:\n            if p2!=p3:\n                rc.append( p2 )\n                rc.append( p3 )\n                rc.append( p0 )\n    return rc\n\n\ndef MeshFaceVertices(object_id):\n    \"\"\"Returns the vertex indices of all faces of a mesh object\n    Paramters:\n      object_id = identifier of a mesh object\n    Returns:\n      A list containing tuples of 4 numbers that define the vertex indices for\n      each face of the mesh. Both quad and triangle faces are returned. If the\n      third and fourth vertex indices are identical, the face is a triangle.\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = []\n    for i in range(mesh.Faces.Count):\n        face = mesh.Faces.GetFace(i)\n        rc.append( (face.A, face.B, face.C, face.D) )\n    return rc\n\n\ndef MeshHasFaceNormals(object_id):\n    \"\"\"Verifies a mesh object has face normals\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.FaceNormals.Count>0\n\n\ndef MeshHasTextureCoordinates(object_id):\n    \"\"\"Verifies a mesh object has texture coordinates\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.TextureCoordinates.Count>0\n\n\ndef MeshHasVertexColors(object_id):\n    \"\"\"Verifies a mesh object has vertex colors\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.VertexColors.Count>0\n\n\ndef MeshHasVertexNormals(object_id):\n    \"\"\"Verifies a mesh object has vertex normals\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Normals.Count>0\n\n\ndef MeshMeshIntersection(mesh1, mesh2, tolerance=None):\n    \"\"\"Calculates the intersections of a mesh object with another mesh object\n    Parameters:\n      mesh1, mesh2 = identifiers of meshes\n      tolerance[opt] = the intersection tolerance\n    Returns:\n      List of 3d point arrays that define the vertices of the intersection curves\n    \"\"\"\n    mesh1 = rhutil.coercemesh(mesh1, True)\n    mesh2 = rhutil.coercemesh(mesh2, True)\n    if tolerance is None: tolerance = Rhino.RhinoMath.ZeroTolerance\n    polylines = Rhino.Geometry.Intersect.Intersection.MeshMeshAccurate(mesh1, mesh2, tolerance)\n    if polylines: return list(polylines)\n    return []\n\n\ndef MeshNakedEdgePoints(object_id):\n    \"\"\"Identifies the naked edge points of a mesh object. This function shows\n    where mesh vertices are not completely surrounded by faces. Joined\n    meshes, such as are made by MeshBox, have naked mesh edge points where\n    the sub-meshes are joined\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      List of boolean values that represent whether or not a mesh vertex is\n      naked or not. The number of elements in the list will be equal to\n      the value returned by MeshVertexCount. In which case, the list will\n      identify the naked status for each vertex returned by MeshVertices\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.GetNakedEdgePointStatus()\n    return rc\n\n\ndef MeshOffset(mesh_id, distance):\n    \"\"\"Makes a new mesh with vertices offset at a distance in the opposite\n    direction of the existing vertex normals\n    Parameters:\n      mesh_id = identifier of a mesh object\n      distance = the distance to offset\n    Returns:\n      id of the new mesh object if successful\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    offsetmesh = mesh.Offset(distance)\n    if offsetmesh is None: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddMesh(offsetmesh)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add mesh to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshQuadCount(object_id):\n    \"\"\"Returns the number of quad faces of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.QuadCount\n\n\ndef MeshQuadsToTriangles(object_id):\n    \"\"\"Converts a mesh object's quad faces to triangles\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      True or False indicating success or failure\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = True\n    if mesh.Faces.QuadCount>0:\n        rc = mesh.Faces.ConvertQuadsToTriangles()\n        if rc:\n            id = rhutil.coerceguid(object_id, True)\n            scriptcontext.doc.Objects.Replace(id, mesh)\n            scriptcontext.doc.Views.Redraw()\n    return rc\n\n# [skipping for now] MeshTextureCoordinates\n\ndef MeshTriangleCount(object_id):\n    \"\"\"Returns the number of triangular faces of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Faces.TriangleCount\n\n\ndef MeshVertexColors(mesh_id, colors=0):\n    \"\"\"Returns of modifies the vertex colors of a mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n      colors[opt] = A list of color values. Note, for each vertex, there must\n        be a corresponding vertex color. If the value is None, then any\n        existing vertex colors will be removed from the mesh\n    Returns:\n      if colors is not specified, the current vertex colors\n      if colors is specified, the previous vertex colors\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    rc = [mesh.VertexColors[i] for i in range(mesh.VertexColors.Count)]\n    if colors==0: return rc\n    if colors is None:\n        mesh.VertexColors.Clear()\n    else:\n        color_count = len(colors)\n        if color_count!=mesh.Vertices.Count:\n            raise ValueError(\"length of colors must match vertex count\")\n        colors = [rhutil.coercecolor(c) for c in colors]\n        mesh.VertexColors.Clear()\n        for c in colors: mesh.VertexColors.Add(c)\n        id = rhutil.coerceguid(mesh_id, True)\n        scriptcontext.doc.Objects.Replace(id, mesh)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef MeshVertexCount(object_id):\n    \"\"\"Returns the vertex count of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    return mesh.Vertices.Count\n\n\ndef MeshVertexFaces(mesh_id, vertex_index):\n    \"\"\"Returns the mesh faces that share a specified mesh vertex\n    Parameters:\n      mesh_id = identifier of a mesh object\n      vertex_index = index of the mesh vertex to find faces for\n    Returns:\n      list of face indices on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    return mesh.Vertices.GetVertexFaces(vertex_index)\n\n\ndef MeshVertexNormals(mesh_id):\n    \"\"\"Returns the vertex unit normal for each vertex of a mesh object\n    Parameters:\n      mesh_id = identifier of a mesh object\n    Returns:\n      list of vertex normals, (empty list if no normals exist)\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    count = mesh.Normals.Count\n    if count<1: return []\n    return [Rhino.Geometry.Vector3d(mesh.Normals[i]) for i in range(count)]\n\n\ndef MeshVertices(object_id):\n    \"\"\"Returns the vertices of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      list of 3D points\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    count = mesh.Vertices.Count\n    rc = []\n    for i in range(count):\n        vertex = mesh.Vertices[i]\n        rc.append(Rhino.Geometry.Point3d(vertex))\n    return rc\n\n\ndef MeshVolume(object_ids, True):\n    \"\"\"\n    Returns the approximate volume of one or more closed mesh objects\n    Parameters:\n      object_ids = identifiers of one or more mesh objects\n    Returns:\n      a tuple containing 3 numbers if successful where\n        element[0] = number of meshes used in volume calculation\n        element[1] = total volume of all meshes\n        element[2] = the error estimate\n      None if not successful\n    \"\"\"\n    id = rhutil.coerceguid(object_ids)\n    if id: object_ids = [id]\n    meshes_used = 0\n    total_volume = 0.0\n    error_estimate = 0.0\n    for id in object_ids:\n        mesh = rhutil.coercemesh(id, True)\n        mp = Rhino.Geometry.VolumeMassProperties.Compute(mesh)\n        if mp:\n            meshes_used += 1\n            total_volume += mp.Volume\n            error_estimate += mp.VolumeError\n    if meshes_used==0: return scriptcontext.errorhandler()\n    return meshes_used, total_volume, error_estimate\n\n\ndef MeshVolumeCentroid(object_id):\n    \"\"\"Calculates the volume centroid of a mesh object\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      Point3d representing the volume centroid\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    mp = Rhino.Geometry.VolumeMassProperties.Compute(mesh)\n    if mp: return mp.Centroid\n    return scriptcontext.errorhandler()\n\n\ndef PullCurveToMesh(mesh_id, curve_id):\n    \"\"\"Pulls a curve object to a mesh object. The function makes a polyline\n    approximation of the input curve and get the closest point on the mesh\n    for each point on the polyline. Then it \"connects the points\" so that\n    you have a polyline on the mesh\n    Paramters:\n      mesh_id = identifier of mesh object that pulls\n      curve_id = identifier of curve object to pull\n    Returns:\n      Guid of new curve on success\n      None on error\n    \"\"\"\n    mesh = rhutil.coercemesh(mesh_id, True)\n    curve = rhutil.coercecurve(curve_id, True)\n    tol = scriptcontext.doc.ModelAbsoluteTolerance\n    polyline = curve.PullToMesh(mesh, tol)\n    if not polyline: return scriptcontext.errorhandler()\n    rc = scriptcontext.doc.Objects.AddCurve(polyline)\n    if rc==System.Guid.Empty: raise Exception(\"unable to add polyline to document\")\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef SplitDisjointMesh(object_id, delete_input=False):\n    \"\"\"Splits up a mesh object into its unconnected pieces\n    Parameters:\n      object_id = identifier of a mesh object\n      delete_input [opt] = delete the input object\n    Returns:\n      list of Guids for the new meshes\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    pieces = mesh.SplitDisjointPieces()\n    rc = [scriptcontext.doc.Objects.AddMesh(piece) for piece in pieces]\n    if rc and delete_input:\n        id = rhutil.coerceguid(object_id, True)\n        scriptcontext.doc.Objects.Delete(id)\n    scriptcontext.doc.Views.Redraw()\n    return rc\n\n\ndef UnifyMeshNormals(object_id):\n    \"\"\"Fixes inconsistencies in the directions of faces of a mesh\n    Parameters:\n      object_id = identifier of a mesh object\n    Returns:\n      number of faces that were modified\n    \"\"\"\n    mesh = rhutil.coercemesh(object_id, True)\n    rc = mesh.UnifyNormals()\n    if rc>0:\n        id = rhutil.coerceguid(object_id, True)\n        scriptcontext.doc.Objects.Replace(id, mesh)\n        scriptcontext.doc.Views.Redraw()\n    return rc\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}