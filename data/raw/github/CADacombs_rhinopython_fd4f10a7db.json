{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_Fair.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_Fair.py",
  "instruction": "This script is an alternative to _Fair.\r\n\r\n1. When LimitDev=Yes, the results are often closer to the distance tolerance than _Fair.\r\n2. The end preservation type is only limited by the number of...",
  "code": "\"\"\"\r\nThis script is an alternative to _Fair.\r\n\r\n1. When LimitDev=Yes, the results are often closer to the distance tolerance than _Fair.\r\n2. The end preservation type is only limited by the number of control points in the curves.\r\n    Rhino 7's _Fair changes all point locations except the ends.\r\n    Rhino 8's _Fair can presure up to 3 control points from each end.\r\n3. When LimitDev=No, NURBS curve structures for degrees other than 3 are preserved.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n170814-19: Created.\r\n...\r\n211113: Script now requires Rhino 7 or higher.  Replaced an import with a local function.\r\n221229-30: Modified main function routine.  Refactored.\r\n        Clamp order is no longer limited to 2.  (It was discovered today that\r\n        Curve.Fair clamp parameters doesn't have that limit.)\r\n230107: Relabeled some options.\r\n240103: Relabeled some options. Modified the notes above. Modified some printed text.\r\n\r\nTODO: Investigate results of non-3-degree input.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bLimitDev'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fAngleTol_Deg'; keys.append(key)\r\n    values[key] = 50.0 * sc.doc.ModelAngleToleranceDegrees\r\n    names[key] = 'AngleTolForKinks'\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=0.0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEqualEndPreservations'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'SetEndPreservations'\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='Separate', onValue='Same')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iEndsContinuityOrder'; keys.append(key)\r\n    values[key] = 1\r\n    riOpts[key] = ri.Custom.OptionInteger(initialValue=values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iStartContinuityOrder'; keys.append(key)\r\n    values[key] = 1\r\n    riOpts[key] = ri.Custom.OptionInteger(initialValue=values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iEndContinuityOrder'; keys.append(key)\r\n    values[key] = 1\r\n    names[key] = 'EndOrder'\r\n    riOpts[key] = ri.Custom.OptionInteger(initialValue=values[key], setLowerLimit=True, limit=0)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace_NotAdd'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'DocAction'\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='Add', onValue='Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'iEndsContinuityOrder':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = 0\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    #go.SubObjectSelect = False\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    bPreselectedObjsChecked = False\r\n    \r\n    print(\"The ContinuityOrder is the value found after 'G'.\",\"For example, 1 is for G1, or tangency continuity.\")\r\n    \r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bLimitDev')\r\n        if Opts.values['bLimitDev']:\r\n            addOption('fDevTol')\r\n            addOption('fAngleTol_Deg')\r\n        addOption('bEqualEndPreservations')\r\n        if Opts.values['bEqualEndPreservations']:\r\n            addOption('iEndsContinuityOrder')\r\n        else:\r\n            addOption('iStartContinuityOrder')\r\n            addOption('iEndContinuityOrder')\r\n        addOption('bReplace_NotAdd')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            if Opts.values['bLimitDev']:\r\n                key = 'fDevTol'\r\n            elif Opts.values['bEqualEndPreservations']:\r\n                key = 'iEndsContinuityOrder'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getPreselectedCurves():\r\n    gObjs_Preselected = [rdObj.Id for rdObj in sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False)]\r\n    if gObjs_Preselected:\r\n        gCrvs_Preselected = []\r\n        iter = rd.ObjectEnumeratorSettings()\r\n        iter.NormalObjects = True\r\n        iter.LockedObjects = False\r\n        iter.IncludeLights = False\r\n        iter.IncludeGrips = False\r\n        for rdRhinoObject in sc.doc.Objects.GetObjectList(iter):\r\n            if rdRhinoObject.Id in gObjs_Preselected:\r\n                if rdRhinoObject.ObjectType == rd.ObjectType.Curve:\r\n                    gCrvs_Preselected.append(rdRhinoObject.Id)\r\n        if gCrvs_Preselected:\r\n            if Opts.values['bEcho']:\r\n                s  = \"({} curves\".format(len(gCrvs_Preselected))\r\n                s += \" were preselected.)\"\r\n                print(s)\r\n            return tuple(gCrvs_Preselected)\r\n\r\n\r\ndef getDistancesBetweenCurves(crvA, crvB):\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n            crvA, crvB, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n\r\n    if not rc[0]:\r\n        raise Exception(\"GetDistancesBetweenCurves returned None.\")\r\n        return None\r\n\r\n    return rc[1]\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=None):\r\n    if iPrecision is None: iPrecision = sc.doc.ModelDistanceDisplayPrecision\r\n\r\n    try:\r\n        fDistance = float(fDistance)\r\n    except:\r\n        return \"(No deviation provided)\"\r\n\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef fairCurve_NoDevLimit(rgCrv_In, iStartContinuityOrder, iEndContinuityOrder, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    nc_Start = rgCrv_In.ToNurbsCurve()\r\n\r\n    if bDebug:\r\n        sEval = \"nc_Start.Points.Count\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"nc_Start.Degree\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"iStartContinuityOrder\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"iEndContinuityOrder\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    if nc_Start.Points.Count < (iStartContinuityOrder + iEndContinuityOrder + 2):\r\n        nc_Start.Dispose()\r\n        return None, \"Clamping continuity is too high for curve's point count.\"\r\n\r\n    #if nc_Start.Points.Count < (iStartContinuityOrder + iEndContinuityOrder) + 2*nc_Start.Degree:\r\n    #    nc_Start.Dispose()\r\n    #    return None, \"Clamping continuity is too high for curve's point count.\"\r\n\r\n\r\n\r\n    bb = rgCrv_In.GetBoundingBox(accurate=True)\r\n    distanceTolerance = bb.Diagonal.Length\r\n    angleTolerance = Rhino.RhinoMath.ToRadians(90.0)\r\n\r\n    if nc_Start.Degree == 3:\r\n        nc_Prev = nc_Start.DuplicateCurve()\r\n    else:\r\n        nc_Prev = rg.NurbsCurve.Create(\r\n            periodic=False,\r\n            degree=3,\r\n            points=[cp.Location for cp in nc_Start.Points])\r\n        #sc.doc.Objects.AddCurve(nc_Prev); sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n    iWhile = 0\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        nc_Res = nc_Prev.Fair(\r\n            distanceTolerance=1000*distanceTolerance,\r\n            angleTolerance=angleTolerance,\r\n            clampStart=iStartContinuityOrder,\r\n            clampEnd=iEndContinuityOrder,\r\n            iterations=1000)\r\n\r\n        if nc_Res is None:\r\n            if iWhile == 0:\r\n                return None, \"Clamping continuity may be too high for curve's point count.\"\r\n            nc_Res = nc_Prev\r\n            break\r\n\r\n        if nc_Res.EpsilonEquals(nc_Prev, epsilon=Rhino.RhinoMath.ZeroTolerance):\r\n            if bDebug:\r\n                sEval = \"iWhile\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"dev\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            nc_Prev.Dispose()\r\n            break\r\n\r\n        nc_Prev.Dispose()\r\n        nc_Prev = nc_Res\r\n\r\n        iWhile += 1\r\n\r\n    if nc_Start.Degree == 3:\r\n        nc_Start.Dispose()\r\n        return nc_Res, None\r\n    else:\r\n        nc_Out = nc_Start\r\n        for iCp in range(nc_Out.Points.Count):\r\n            nc_Out.Points.SetPoint(\r\n                iCp,\r\n                point=nc_Res.Points[iCp].Location,\r\n                weight=nc_Res.Points[iCp].Weight)\r\n        return nc_Out, None\r\n\r\n\r\ndef fairCurve_DevLimit(rgCrv_In, fDevTol, fAngleTol_Deg, iStartContinuityOrder, iEndContinuityOrder, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    nc_Start = rgCrv_In.ToNurbsCurve()\r\n\r\n    if nc_Start.Points.Count < (iStartContinuityOrder + iEndContinuityOrder + 2):\r\n        nc_Start.Dispose()\r\n        return None, \"Clamping continuity is too high for curve's point count.\"\r\n\r\n    #if nc_Start.Points.Count < (iStartContinuityOrder + iEndContinuityOrder) + 2*nc_Start.Degree:\r\n    #    nc_Start.Dispose()\r\n    #    return None, \"Clamping continuity is too high for curve's point count.\"\r\n\r\n    nc_Prev = rgCrv_In.ToNurbsCurve()\r\n\r\n    distanceTolerance = fDevTol\r\n    angleTolerance = Rhino.RhinoMath.ToRadians(fAngleTol_Deg)\r\n\r\n\r\n\r\n    nc_Res = nc_Start.Fair(\r\n        distanceTolerance=2.0*fDevTol,\r\n        angleTolerance=angleTolerance,\r\n        clampStart=iStartContinuityOrder,\r\n        clampEnd=iEndContinuityOrder,\r\n        iterations=1)\r\n\r\n    if nc_Res is None:\r\n        return None, \"Clamping continuity may be too high for curve's point count.\"\r\n\r\n    dev = getDistancesBetweenCurves(nc_Start, nc_Res)\r\n\r\n    if dev == fDevTol:\r\n        return nc_Res, None\r\n\r\n    if dev > fDevTol:\r\n        iterations = 1\r\n\r\n    else:\r\n        # Try higher iterations to get dev closer to fDevTol.\r\n\r\n        iWhile = 0\r\n\r\n        iter_L = 1\r\n        iter_M = None\r\n        iter_H = 2**16\r\n\r\n\r\n        dev = None\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            if bDebug: sEval = \"iWhile\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            iter_M = (iter_L + iter_H) // 2\r\n\r\n            if iter_M in (iter_L, iter_H):\r\n                if bDebug:\r\n                    sEval = \"iter_L\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"iter_M\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                    sEval = \"iter_H\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                iterations = iter_L\r\n                break\r\n\r\n            dev_Last = dev\r\n\r\n            nc_Res = nc_Start.Fair(\r\n                distanceTolerance=distanceTolerance,\r\n                angleTolerance=angleTolerance,\r\n                clampStart=iStartContinuityOrder,\r\n                clampEnd=iEndContinuityOrder,\r\n                iterations=iter_M)\r\n\r\n            if nc_Res is None:\r\n                raise Exception(\"Fair returned None.\")\r\n\r\n            dev = getDistancesBetweenCurves(nc_Start, nc_Res)\r\n            if bDebug: sEval = \"dev\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            if dev_Last and abs(dev - dev_Last) < 1e-6:\r\n                # No improvement.\r\n                iterations = iter_H\r\n                break\r\n\r\n\r\n            if dev <= fDevTol:\r\n                iter_L = iter_M\r\n            else:\r\n                iter_H = iter_M\r\n\r\n            nc_Res.Dispose()\r\n\r\n            iWhile += 1\r\n        else:\r\n            iterations = iter_H\r\n\r\n        if bDebug: sEval = \"iterations\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    dist_L = fDevTol\r\n    dist_M = None\r\n    dist_H = 2.0*fDevTol\r\n\r\n\r\n\r\n    nc_Res = nc_Start.Fair(\r\n        distanceTolerance=dist_H,\r\n        angleTolerance=angleTolerance,\r\n        clampStart=iStartContinuityOrder,\r\n        clampEnd=iEndContinuityOrder,\r\n        iterations=1)\r\n\r\n\r\n    if nc_Res is None:\r\n        raise Exception(\"Fair returned None.\")\r\n\r\n    dev = getDistancesBetweenCurves(nc_Start, nc_Res)\r\n\r\n    if dev <= fDevTol:\r\n        return nc_Res, None\r\n\r\n\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        dist_M = (dist_L + dist_H) / 2.0\r\n\r\n        if dist_M in (dist_L, dist_H):\r\n            if bDebug:\r\n                sEval = \"dist_L\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"dist_M\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"dist_H\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            break\r\n\r\n\r\n        #sEval = \"dist_M\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        nc_Res = nc_Start.Fair(\r\n            distanceTolerance=dist_M,\r\n            angleTolerance=angleTolerance,\r\n            clampStart=iStartContinuityOrder,\r\n            clampEnd=iEndContinuityOrder,\r\n            iterations=1)\r\n\r\n        if nc_Res is None:\r\n            raise Exception(\"Fair returned None.\")\r\n\r\n        dev = getDistancesBetweenCurves(nc_Start, nc_Res)\r\n\r\n        if dev > fDevTol:\r\n            dist_H = dist_M\r\n        else:\r\n            dist_L = dist_M\r\n\r\n        nc_Res.Dispose()\r\n\r\n\r\n\r\n    distanceTolerance = dist_L\r\n\r\n\r\n    nc_Res = nc_Start.Fair(\r\n        distanceTolerance=distanceTolerance,\r\n        angleTolerance=angleTolerance,\r\n        clampStart=iStartContinuityOrder,\r\n        clampEnd=iEndContinuityOrder,\r\n        iterations=iterations)\r\n\r\n    return nc_Res, None\r\n\r\n\r\n\r\ndef isKnotVectorUniform(knots):\r\n    return (\r\n        (knots.KnotStyle == rg.KnotStyle.Uniform) or\r\n        (knots.KnotStyle == rg.KnotStyle.QuasiUniform) or\r\n        (\r\n            (knots.KnotStyle == rg.KnotStyle.PiecewiseBezier) and\r\n            knots.Count == knots.KnotMultiplicity(0) * 2)\r\n        )\r\n\r\n\r\ndef printOutput(rgCrv, nc_End):\r\n\r\n    print(\"Original curve is a {}.\".format(rgCrv.GetType().Name))\r\n\r\n    nc_Start = rgCrv.ToNurbsCurve()\r\n\r\n    if nc_End:\r\n        s = \"Prop:I-O\"\r\n        s += \"  {}:{}-{}\".format(\"Deg\", nc_Start.Degree, nc_End.Degree)\r\n        s += \"  {}:{}-{}\".format(\"PtCt\", nc_Start.Points.Count, nc_End.Points.Count)\r\n        s += \"  {}:{}-{}\".format(\"IsUniform\",\r\n                str(isKnotVectorUniform(nc_Start.Knots))[0],\r\n                str(isKnotVectorUniform(nc_End.Knots))[0])\r\n        s += \"  {}:{}-{}\".format(\"IsRational\",\r\n                str(nc_Start.IsRational)[0],\r\n                str(nc_End.IsRational)[0])\r\n        s += \"  {}:{}-{}\".format(\"IsClosed\",\r\n                str(nc_Start.IsClosed)[0],\r\n                str(nc_End.IsClosed)[0])\r\n        if nc_Start.IsClosed or nc_End.IsClosed:\r\n            s += \"  {}:{}-{}\".format(\"IsPeriodic\",\r\n                    str(nc_Start.IsPeriodic)[0],\r\n                    str(nc_End.IsPeriodic)[0])\r\n\r\n        crv_dev = getDistancesBetweenCurves(rgCrv, nc_End)\r\n\r\n        if crv_dev:\r\n            s += \"  Deviation: {0:.{1}f}\".format(\r\n                    crv_dev, sc.doc.ModelDistanceDisplayPrecision)\r\n        else:\r\n            s += \"  Curve deviation cannot be calculated!\"\r\n        \r\n        print(s)\r\n    \r\n    else:\r\n        sEval = \"rgNurbsCrv1\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if nc_End is None:\r\n            print(\"Invalid input for fairCurve?\")\r\n        else: # False\r\n            print(\"Curve could not be found for entered parameters.\")\r\n            print(\"Input curve CpCt:{},  IsUniform:{},  IsPeriodic:{}\".format(\r\n                    nc_Start.Points.Count,\r\n                    str(isKnotVectorUniform(nc_Start.Knots))[0],\r\n                    nc_Start.IsPeriodic))\r\n\r\n    nc_Start.Dispose()\r\n\r\n\r\ndef main(bEcho=False, bDebug=False):\r\n\r\n    gCs_Preselected = getPreselectedCurves()\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    fDevTol = Opts.values['fDevTol'] if Opts.values['bLimitDev'] else None\r\n    fAngleTol_Deg = Opts.values['fAngleTol_Deg']\r\n    if Opts.values['bEqualEndPreservations']:\r\n        iStartContinuityOrder = Opts.values['iEndsContinuityOrder']\r\n        iEndContinuityOrder = Opts.values['iEndsContinuityOrder']\r\n    else:\r\n        iStartContinuityOrder = Opts.values['iStartContinuityOrder']\r\n        iEndContinuityOrder = Opts.values['iEndContinuityOrder']\r\n    bReplace_NotAdd = Opts.values['bReplace_NotAdd']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    gCs_Replaced = []\r\n    gCs_Added = []\r\n    sLogs = []\r\n    \r\n    for objref in objrefs:\r\n        rdC_In = objref.Object()\r\n\r\n        rgC_In = rdC_In.Geometry\r\n\r\n        if isinstance(rgC_In, rg.LineCurve):\r\n            print(\"LineCurve skipped.\")\r\n            continue\r\n        if rgC_In.IsLinear():\r\n            print(\"Linear curve skipped.\")\r\n            continue\r\n\r\n        nc_Start = rgC_In.ToNurbsCurve()\r\n\r\n\r\n        crv_dev = None\r\n        \r\n        if fDevTol is None:\r\n            nc_Res, sLog = fairCurve_NoDevLimit(\r\n                rgCrv_In=nc_Start,\r\n                iStartContinuityOrder=iStartContinuityOrder,\r\n                iEndContinuityOrder=iEndContinuityOrder,\r\n                bDebug=bDebug)\r\n        else:\r\n            nc_Res, sLog = fairCurve_DevLimit(\r\n                rgCrv_In=nc_Start,\r\n                fDevTol=fDevTol,\r\n                fAngleTol_Deg=fAngleTol_Deg,\r\n                iStartContinuityOrder=iStartContinuityOrder,\r\n                iEndContinuityOrder=iEndContinuityOrder,\r\n                bDebug=bDebug)\r\n\r\n        if sLog is not None:\r\n            sLogs.append(sLog)\r\n\r\n        if nc_Res is None:\r\n            pass\r\n        elif rg.NurbsCurve.EpsilonEquals(nc_Res, nc_Start, epsilon=Rhino.RhinoMath.ZeroTolerance):\r\n            print(\"No change in curve geometry within {}.\".format(\r\n                formatDistance(Rhino.RhinoMath.ZeroTolerance)))\r\n            continue\r\n        else:\r\n            if bReplace_NotAdd:\r\n                if sc.doc.Objects.Replace(rdC_In.Id, nc_Res):\r\n                    gCs_Replaced.append(rdC_In.Id)\r\n            else:\r\n                gC_Added = sc.doc.Objects.AddCurve(nc_Res)\r\n                if gC_Added == gC_Added.Empty:\r\n                    print(\"Could not add new curve.\")\r\n                else:\r\n                    gCs_Added.append(gC_Added)\r\n\r\n            crv_dev = getDistancesBetweenCurves(nc_Start, nc_Res)\r\n\r\n            printOutput(rgC_In, nc_Res)\r\n\r\n\r\n    for sLog in set(sLogs):\r\n        print(\"[{}]: {}\".format(sLogs.count(sLog), sLog))\r\n\r\n    if gCs_Preselected:\r\n        [sc.doc.Objects.Select(objectId=_) for _ in gCs_Preselected]\r\n    else:\r\n        if gCs_Replaced:\r\n            [sc.doc.Objects.Select(objectId=_) for _ in gCs_Replaced]\r\n        if gCs_Added:\r\n            [sc.doc.Objects.Select(objectId=_) for _ in gCs_Added]\r\n    \r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main(bEcho=0, bDebug=0)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}