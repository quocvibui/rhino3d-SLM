{
  "source_url": "https://github.com/jongarrison/splint_geo_processor/blob/b4a410b94aa8ddd9dad7ee8d35d452964254ef41/generators/src/FingerModel.py",
  "repo": "jongarrison/splint_geo_processor",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "generators/src/FingerModel.py",
  "instruction": "FingerModel.py\nGenerate anatomically-based finger geometry for splint modeling.",
  "code": "\"\"\"\nFingerModel.py\nGenerate anatomically-based finger geometry for splint modeling.\n\"\"\"\n\nfrom importlib import reload\nimport Rhino.Geometry as rg\nfrom Rhino.Geometry import Point3d, Vector3d, Line, Plane, Polyline\nimport scriptcontext as sc\nimport math\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Tuple\nfrom splintcommon import log\n\nclass FingerModelError(Exception):\n    \"\"\"Raised when finger model creation fails.\"\"\"\n    pass\n\n\nclass GeometryCreationError(Exception):\n    \"\"\"Raised when a geometry primitive (sphere, cylinder, etc.) fails to create.\"\"\"\n    pass\n\n\nclass TrimError(Exception):\n    \"\"\"Raised when trimming operation fails.\"\"\"\n    pass\nimport BrepGeneration\nreload(BrepGeneration)\nfrom BrepGeneration import create_tapered_cylinder, create_bulged_cylinder, create_sphere, create_cylinder\n\nimport BrepUnion\nreload(BrepUnion)\nfrom BrepUnion import robust_brep_union, BrepUnionError, InvalidBrepError\n\n\n# Segment names in order from base to tip (joints and phalanges as separate segments)\nSEGMENT_ORDER = [\"metacarpal\", \"mcp\", \"proximal\", \"pip\", \"middle\", \"dip\", \"distal\", \"tip\"]\n\n\n@dataclass\nclass FingerParams:\n    \"\"\"Parameters for generating a finger model.\"\"\"\n    \n    # Endpoint circumferences (mm) - at joints and fingertip\n    # Only required for segments being rendered (validated by validate_for_segment_range)\n    mcp_circ: float = 0.0\n    pip_circ: float = 0.0\n    dip_circ: float = 0.0\n    tip_circ: float = 0.0\n    \n    # Phalanx mid-circumferences (mm) - optional bulge/waist at bone midpoints\n    # When None, creates simple tapered cylinders instead of bulged\n    proximal_mid_circ: Optional[float] = None\n    middle_mid_circ: Optional[float] = None\n    distal_mid_circ: Optional[float] = None\n    \n    # Phalanx lengths (mm) - from base to tip\n    proximal_len: float = 0.0\n    middle_len: float = 0.0\n    distal_len: float = 0.0\n    \n    # Joint flexion angles (degrees) - positive = flexion toward palm\n    mcp_flex: float = 0.0\n    pip_flex: float = 0.0\n    dip_flex: float = 0.0\n    \n    # Joint lateral angles (degrees) - positive = toward +Y (ulnar for right hand)\n    mcp_lateral: float = 0.0\n    pip_lateral: float = 0.0\n    dip_lateral: float = 0.0\n    \n    # Metacarpal stub length (mm)\n    metacarpal_len: float = 0.0\n    \n    # Segment range (which parts to generate)\n    # Valid: \"metacarpal\", \"mcp\", \"proximal\", \"pip\", \"middle\", \"dip\", \"distal\", \"tip\"\n    start_at: str = \"metacarpal\"\n    end_at: str = \"tip\"\n    \n    # Shell mode: adds thickness to all radii (0 = off)\n    shell_thickness: float = 0.0\n    \n    # Augment joint sphere radii to improve boolean union reliability (mm)\n    augment_joint_spheres: float = 0.2\n    \n    # Trim region specification: (joint_name, offset_mm)\n    # offset is negative for before joint, positive for after\n    # Example: (\"mcp\", -20.0) means 20mm before MCP joint\n    # When None, no trimming is performed on that end\n    trim_start: Optional[Tuple[str, float]] = None\n    trim_end: Optional[Tuple[str, float]] = None\n    \n    def get_segment_range(self) -> Tuple[int, int]:\n        \"\"\"Returns (start_index, end_index) for segment generation.\"\"\"\n        start_idx = SEGMENT_ORDER.index(self.start_at.lower())\n        end_idx = SEGMENT_ORDER.index(self.end_at.lower())\n        if start_idx > end_idx:\n            raise ValueError(f\"start_at '{self.start_at}' must come before end_at '{self.end_at}'\")\n        return start_idx, end_idx\n    \n    def includes_segment(self, segment: str) -> bool:\n        \"\"\"Check if a segment is within the generation range.\"\"\"\n        start_idx, end_idx = self.get_segment_range()\n        seg_idx = SEGMENT_ORDER.index(segment.lower())\n        return start_idx <= seg_idx <= end_idx\n    \n    def validate_for_segment_range(self) -> List[str]:\n        \"\"\"\n        Validate that required parameters are set for the specified segment range.\n        \n        Returns list of error messages (empty if valid).\n        \"\"\"\n        errors = []\n        \n        # Circumference requirements based on which segments are rendered\n        # Each circ is needed if we're rendering geometry that uses it\n        \n        # mcp_circ: needed for metacarpal, mcp joint, or proximal phalanx\n        if self.includes_segment(\"metacarpal\") or self.includes_segment(\"mcp\") or self.includes_segment(\"proximal\"):\n            if self.mcp_circ <= 0:\n                errors.append(f\"mcp_circ must be > 0 when rendering metacarpal/mcp/proximal (got {self.mcp_circ})\")\n        \n        # pip_circ: needed for proximal phalanx, pip joint, or middle phalanx\n        if self.includes_segment(\"proximal\") or self.includes_segment(\"pip\") or self.includes_segment(\"middle\"):\n            if self.pip_circ <= 0:\n                errors.append(f\"pip_circ must be > 0 when rendering proximal/pip/middle (got {self.pip_circ})\")\n        \n        # dip_circ: needed for middle phalanx, dip joint, or distal phalanx\n        if self.includes_segment(\"middle\") or self.includes_segment(\"dip\") or self.includes_segment(\"distal\"):\n            if self.dip_circ <= 0:\n                errors.append(f\"dip_circ must be > 0 when rendering middle/dip/distal (got {self.dip_circ})\")\n        \n        # tip_circ: needed for distal phalanx or tip sphere\n        if self.includes_segment(\"distal\") or self.includes_segment(\"tip\"):\n            if self.tip_circ <= 0:\n                errors.append(f\"tip_circ must be > 0 when rendering distal/tip (got {self.tip_circ})\")\n        \n        # Length requirements - phalanx lengths needed if rendering that phalanx\n        if self.includes_segment(\"proximal\") and self.proximal_len <= 0:\n            errors.append(f\"proximal_len must be > 0 when rendering proximal (got {self.proximal_len})\")\n        \n        if self.includes_segment(\"middle\") and self.middle_len <= 0:\n            errors.append(f\"middle_len must be > 0 when rendering middle (got {self.middle_len})\")\n        \n        if self.includes_segment(\"distal\") and self.distal_len <= 0:\n            errors.append(f\"distal_len must be > 0 when rendering distal (got {self.distal_len})\")\n        \n        if self.includes_segment(\"metacarpal\") and self.metacarpal_len <= 0:\n            errors.append(f\"metacarpal_len must be > 0 when rendering metacarpal (got {self.metacarpal_len})\")\n        \n        return errors\n\n\ndef get_trim_point_and_plane(\n    trim_spec: Tuple[str, float],\n    joint_positions: dict,\n    params: 'FingerParams'\n) -> Tuple[Point3d, Plane]:\n    \"\"\"\n    Convert a trim specification (joint, offset) to a 3D point and perpendicular plane.\n    \n    Args:\n        trim_spec: (joint_name, offset_mm) where offset is negative for before, positive for after\n        joint_positions: dict from compute_joint_positions()\n        params: FingerParams for segment lengths\n        \n    Returns:\n        (point, plane) where plane is perpendicular to centerline at point\n    \"\"\"\n    joint_name, offset = trim_spec\n    joint_name = joint_name.lower()\n    \n    if joint_name not in joint_positions:\n        raise ValueError(f\"Unknown joint name: {joint_name}. Valid: {list(joint_positions.keys())}\")\n    \n    joint_pos, joint_dir, joint_dist = joint_positions[joint_name]\n    \n    # Target distance along centerline\n    target_dist = joint_dist + offset\n    \n    # Find which segment this falls in and compute the point\n    # Segments: origin->mcp (metacarpal), mcp->pip (proximal), pip->dip (middle), dip->tip (distal)\n    segments = [\n        (\"origin\", \"mcp\", params.metacarpal_len),\n        (\"mcp\", \"pip\", params.proximal_len),\n        (\"pip\", \"dip\", params.middle_len),\n        (\"dip\", \"tip\", params.distal_len),\n    ]\n    \n    cumulative = 0.0\n    for start_joint, end_joint, seg_len in segments:\n        seg_start_dist = cumulative\n        seg_end_dist = cumulative + seg_len\n        \n        if seg_start_dist <= target_dist <= seg_end_dist:\n            # Target is within this segment\n            start_pos, _, _ = joint_positions[start_joint]\n            end_pos, end_dir, _ = joint_positions[end_joint]\n            \n            # Compute direction for this segment\n            seg_dir = Vector3d(end_pos - start_pos)\n            seg_dir.Unitize()\n            \n            # Interpolate position within segment\n            t = (target_dist - seg_start_dist) / seg_len if seg_len > 0 else 0\n            trim_point = start_pos + seg_dir * (t * seg_len)\n            \n            # Create plane perpendicular to segment direction\n            trim_plane = Plane(trim_point, seg_dir)\n            \n            return trim_point, trim_plane\n        \n        cumulative = seg_end_dist\n    \n    # If we get here, target_dist is outside the finger bounds\n    # Clamp to the nearest end\n    if target_dist < 0:\n        origin_pos, origin_dir, _ = joint_positions[\"origin\"]\n        trim_point = origin_pos + origin_dir * target_dist  # extend backward\n        trim_plane = Plane(trim_point, origin_dir)\n    else:\n        tip_pos, tip_dir, _ = joint_positions[\"tip\"]\n        overshoot = target_dist - cumulative\n        trim_point = tip_pos + tip_dir * overshoot  # extend forward\n        trim_plane = Plane(trim_point, tip_dir)\n    \n    return trim_point, trim_plane\n\n\ndef trim_finger_model(\n    finger_brep: rg.Brep,\n    centerline: Polyline,\n    params: 'FingerParams',\n    joint_positions: dict,\n    tolerance: float\n) -> Tuple[rg.Brep, Polyline]:\n    \"\"\"\n    Trim the finger model to the region specified by params.trim_start and params.trim_end.\n    \n    Args:\n        finger_brep: The unioned finger brep to trim\n        centerline: The centerline polyline\n        params: FingerParams with trim_start and/or trim_end specified\n        joint_positions: Dict from create_finger_model mapping joint names to\n                        (position, direction, cumulative_distance)\n        tolerance: Geometric tolerance\n        \n    Returns:\n        (trimmed_brep, trimmed_centerline)\n    \"\"\"\n    if params.trim_start is None and params.trim_end is None:\n        return finger_brep, centerline\n    \n    log(\"\\n--- Trimming Finger Model ---\")\n    \n    # Get bounding box to size the cutting planes appropriately\n    bbox = finger_brep.GetBoundingBox(True)\n    plane_extent = bbox.Diagonal.Length * 2  # ensure plane is large enough\n    \n    trimmed_brep = finger_brep\n    \n    # Process trim_start (remove material before this plane)\n    if params.trim_start is not None:\n        start_point, start_plane = get_trim_point_and_plane(params.trim_start, joint_positions, params)\n        log(f\"Trim start: {params.trim_start} -> point={start_point}\")\n        \n        # Create a PlaneSurface large enough to cut through the brep\n        plane_srf = rg.PlaneSurface(start_plane, \n                                     rg.Interval(-plane_extent, plane_extent),\n                                     rg.Interval(-plane_extent, plane_extent))\n        \n        # Split brep with plane and keep the part on the positive side (toward tip)\n        split_result = trimmed_brep.Split([plane_srf.ToBrep()], tolerance)\n        if split_result and len(split_result) > 0:\n            # Find the piece(s) on the positive side of the plane (toward fingertip)\n            # The positive side is where plane.Normal points\n            kept_pieces = []\n            for piece in split_result:\n                centroid = rg.VolumeMassProperties.Compute(piece).Centroid\n                # Check which side of plane the centroid is on\n                dist = start_plane.DistanceTo(centroid)\n                if dist > 0:  # On positive side (toward tip)\n                    kept_pieces.append(piece)\n            \n            if kept_pieces:\n                if len(kept_pieces) == 1:\n                    trimmed_brep = kept_pieces[0]\n                else:\n                    # Union the kept pieces\n                    unioned = rg.Brep.CreateBooleanUnion(kept_pieces, tolerance)\n                    if unioned and len(unioned) > 0:\n                        trimmed_brep = unioned[0]\n                    else:\n                        raise TrimError(\n                            f\"Failed to union {len(kept_pieces)} pieces after trim_start split\"\n                        )\n                \n                # Cap the planar hole created by the split\n                capped = trimmed_brep.CapPlanarHoles(tolerance)\n                if capped:\n                    trimmed_brep = capped\n                    log(f\"Trim start applied and capped, kept {len(kept_pieces)} piece(s)\")\n                else:\n                    log(f\"Trim start applied (cap failed), kept {len(kept_pieces)} piece(s)\")\n            else:\n                raise TrimError(\n                    f\"No geometry pieces on positive side of trim_start plane at {params.trim_start}\"\n                )\n        else:\n            raise TrimError(\n                f\"Brep.Split() returned no result for trim_start at {params.trim_start}\"\n            )\n    \n    # Process trim_end (remove material after this plane)\n    if params.trim_end is not None:\n        end_point, end_plane = get_trim_point_and_plane(params.trim_end, joint_positions, params)\n        log(f\"Trim end: {params.trim_end} -> point={end_point}\")\n        \n        # Create a PlaneSurface large enough to cut through the brep\n        bbox = trimmed_brep.GetBoundingBox(True)\n        plane_extent = bbox.Diagonal.Length * 2\n        plane_srf = rg.PlaneSurface(end_plane,\n                                     rg.Interval(-plane_extent, plane_extent),\n                                     rg.Interval(-plane_extent, plane_extent))\n        \n        # Split brep with plane and keep the part on the negative side (toward origin)\n        split_result = trimmed_brep.Split([plane_srf.ToBrep()], tolerance)\n        if split_result and len(split_result) > 0:\n            kept_pieces = []\n            for piece in split_result:\n                centroid = rg.VolumeMassProperties.Compute(piece).Centroid\n                dist = end_plane.DistanceTo(centroid)\n                if dist < 0:  # On negative side (toward origin)\n                    kept_pieces.append(piece)\n            \n            if kept_pieces:\n                if len(kept_pieces) == 1:\n                    trimmed_brep = kept_pieces[0]\n                else:\n                    unioned = rg.Brep.CreateBooleanUnion(kept_pieces, tolerance)\n                    if unioned and len(unioned) > 0:\n                        trimmed_brep = unioned[0]\n                    else:\n                        raise TrimError(\n                            f\"Failed to union {len(kept_pieces)} pieces after trim_end split\"\n                        )\n                \n                # Cap the planar hole created by the split\n                capped = trimmed_brep.CapPlanarHoles(tolerance)\n                if capped:\n                    trimmed_brep = capped\n                    log(f\"Trim end applied and capped, kept {len(kept_pieces)} piece(s)\")\n                else:\n                    log(f\"Trim end applied (cap failed), kept {len(kept_pieces)} piece(s)\")\n            else:\n                raise TrimError(\n                    f\"No geometry pieces on negative side of trim_end plane at {params.trim_end}\"\n                )\n        else:\n            raise TrimError(\n                f\"Brep.Split() returned no result for trim_end at {params.trim_end}\"\n            )\n    \n    # Trim the centerline at the same points\n    trimmed_centerline = centerline\n    if centerline is not None and centerline.Count >= 2:\n        # Convert polyline to curve for trimming operations\n        centerline_curve = centerline.ToNurbsCurve()\n        \n        # Get trim parameters on the curve\n        start_param = centerline_curve.Domain.Min\n        end_param = centerline_curve.Domain.Max\n        \n        if params.trim_start is not None:\n            start_point, _ = get_trim_point_and_plane(params.trim_start, joint_positions, params)\n            success, t = centerline_curve.ClosestPoint(start_point)\n            if success:\n                start_param = t\n        \n        if params.trim_end is not None:\n            end_point, _ = get_trim_point_and_plane(params.trim_end, joint_positions, params)\n            success, t = centerline_curve.ClosestPoint(end_point)\n            if success:\n                end_param = t\n        \n        # Trim the curve and convert back to polyline\n        if start_param < end_param:\n            trimmed_curve = centerline_curve.Trim(start_param, end_param)\n            if trimmed_curve:\n                # Convert back to polyline by sampling points\n                trimmed_centerline = Polyline()\n                # Add start point\n                trimmed_centerline.Add(trimmed_curve.PointAtStart)\n                # Add intermediate points from original polyline that fall within range\n                for i in range(centerline.Count):\n                    pt = centerline[i]\n                    success, t = trimmed_curve.ClosestPoint(pt)\n                    if success:\n                        dist = pt.DistanceTo(trimmed_curve.PointAt(t))\n                        if dist < tolerance and t > trimmed_curve.Domain.Min and t < trimmed_curve.Domain.Max:\n                            trimmed_centerline.Add(pt)\n                # Add end point\n                trimmed_centerline.Add(trimmed_curve.PointAtEnd)\n                log(f\"Trimmed centerline: {trimmed_centerline.Count} points\")\n    \n    if trimmed_brep:\n        log(f\"Trimmed finger volume: {trimmed_brep.GetVolume():.2f} mm^3\")\n    \n    return trimmed_brep, trimmed_centerline\n\n\ndef advance_to_next_joint(\n    initial_plane: Plane,\n    phalanx_length: float,\n    lateral_degrees: float,\n    flexion_degrees: float\n) -> Tuple[Plane, Line]:\n    \"\"\"\n    Compute the coordinate frame transformation for advancing to the next joint.\n    \n    This function only performs the geometric math - no brep creation.\n    Use create_joint_and_phalanx() afterward if geometry is needed.\n    \n    The plane's axes define the local coordinate system:\n    - X-axis: direction the phalanx extends\n    - Y-axis: flexion rotation axis (curl toward palm)\n    - Z-axis: lateral rotation axis (side-to-side deviation)\n    \n    Rotations are applied around the initial plane's axes (before any rotation),\n    with the rotation center at the initial plane's origin.\n    \n    Args:\n        initial_plane: Plane at joint center (origin) with orientation axes\n        phalanx_length: Length of the phalanx in mm\n        lateral_degrees: Lateral deviation angle (rotation around Z-axis)\n        flexion_degrees: Flexion angle (rotation around Y-axis)\n        \n    Returns:\n        (new_plane, new_line)\n        - new_plane: Plane at end of phalanx with updated orientation\n        - new_line: Centerline of the phalanx (from joint to next joint)\n    \"\"\"\n    # Extract axes from initial plane (these remain fixed for rotation calculations)\n    origin = initial_plane.Origin\n    x_axis = initial_plane.XAxis\n    y_axis = initial_plane.YAxis\n    z_axis = initial_plane.ZAxis\n    \n    # Create the phalanx line starting at origin, extending along x-axis\n    phalanx_end = origin + x_axis * phalanx_length\n    new_line = Line(origin, phalanx_end)\n    \n    # Copy initial plane to new plane (will be rotated)\n    new_plane = Plane(initial_plane)\n    \n    # Apply flexion rotation (around initial Y-axis, centered at origin)\n    if flexion_degrees != 0:\n        flexion_xform = rg.Transform.Rotation(\n            math.radians(flexion_degrees), y_axis, origin\n        )\n        new_plane.Transform(flexion_xform)\n        # Transform the line's end point\n        end_pt = Point3d(new_line.To)\n        end_pt.Transform(flexion_xform)\n        new_line = Line(origin, end_pt)\n    \n    # Apply lateral rotation (around initial Z-axis, centered at origin)\n    if lateral_degrees != 0:\n        lateral_xform = rg.Transform.Rotation(\n            math.radians(lateral_degrees), z_axis, origin\n        )\n        new_plane.Transform(lateral_xform)\n        # Transform the line's end point\n        end_pt = Point3d(new_line.To)\n        end_pt.Transform(lateral_xform)\n        new_line = Line(origin, end_pt)\n    \n    # Move new_plane's origin to the end of the rotated line\n    new_plane.Origin = new_line.To\n    \n    return new_plane, new_line\n\n\ndef create_joint_and_phalanx(\n    phalanx_line: Line,\n    joint_begin_radius: float,\n    joint_end_radius: float,\n    tolerance: float,\n    mid_radius: Optional[float] = None,\n    sphere_augment: float = 0.0\n) -> Tuple[rg.Brep, rg.Brep]:\n    \"\"\"\n    Create the joint sphere and phalanx geometry for a previously computed line.\n    \n    Call this after advance_to_next_joint() when geometry is actually needed.\n    \n    Args:\n        phalanx_line: Centerline from advance_to_next_joint()\n        joint_begin_radius: Radius at joint (start of phalanx)\n        joint_end_radius: Radius at end of phalanx\n        tolerance: Geometric tolerance for brep operations\n        mid_radius: Optional radius at phalanx midpoint for bulge effect\n        sphere_augment: Additional radius to add to joint sphere for union reliability\n        \n    Returns:\n        (joint_brep, phalanx_brep)\n        - joint_brep: Sphere at joint center (line start)\n        - phalanx_brep: Tapered or bulged cylinder for phalanx\n    \"\"\"\n    # Create joint sphere at the line's start point (joint center)\n    # Augment radius slightly for better boolean union reliability\n    sphere_radius = joint_begin_radius + sphere_augment\n    joint_brep = create_sphere(phalanx_line.From, sphere_radius, tolerance)\n    \n    # Create phalanx - bulged if mid_radius provided, otherwise tapered\n    if mid_radius is not None:\n        phalanx_brep = create_bulged_cylinder(\n            phalanx_line, joint_begin_radius, mid_radius, joint_end_radius, tolerance\n        )\n    else:\n        phalanx_brep = create_tapered_cylinder(\n            phalanx_line, joint_begin_radius, joint_end_radius, tolerance\n        )\n    \n    return joint_brep, phalanx_brep\n\n\ndef create_finger_model(\n    params: FingerParams,\n    tolerance: Optional[float] = None,\n    return_parts: bool = True\n):\n    \"\"\"\n    Generate a finger model from anatomical measurements.\n    \n    Orientation: Finger along +X, palm faces -Z. Positive angles = flexion toward palm.\n    Construction order: Metacarpal -> MCP -> Proximal -> PIP -> Middle -> DIP -> Distal -> Tip\n    \n    The current_plane tracks position and orientation through the finger:\n    - Origin: current joint/segment position\n    - X-axis: direction finger extends\n    - Y-axis: flexion rotation axis\n    - Z-axis: lateral rotation axis (palm normal)\n    \n    Position is always computed from origin through all segments, but geometry is only\n    created for segments within start_at..end_at range. This ensures partial models\n    align with full models for boolean operations.\n    \n    Args:\n        params: FingerParams dataclass with all measurements and options\n        tolerance: Geometric tolerance for operations (defaults to document tolerance)\n        return_parts: Whether to include component breps in return\n        \n    Returns:\n        (centerline_polyline, finger_brep, component_breps, joint_positions)\n        joint_positions maps joint names to (position, direction, cumulative_distance)\n    \"\"\"\n    \n    if tolerance is None:\n        tolerance = sc.doc.ModelAbsoluteTolerance\n    \n    # Validate parameters for the specified segment range\n    validation_errors = params.validate_for_segment_range()\n    if validation_errors:\n        for err in validation_errors:\n            log(f\"VALIDATION ERROR: {err}\")\n        raise ValueError(f\"Invalid FingerParams: {'; '.join(validation_errors)}\")\n    \n    shell = params.shell_thickness\n    \n    log(\"=\" * 60)\n    log(\"CREATING FINGER MODEL\")\n    log(\"=\" * 60)\n    log(f\"Endpoints - MCP:{params.mcp_circ}mm, PIP:{params.pip_circ}mm, DIP:{params.dip_circ}mm, Tip:{params.tip_circ}mm\")\n    log(f\"Mid-phalanx - Prox:{params.proximal_mid_circ}mm, Mid:{params.middle_mid_circ}mm, Dist:{params.distal_mid_circ}mm\")\n    log(f\"Lengths - Prox:{params.proximal_len}mm, Mid:{params.middle_len}mm, Dist:{params.distal_len}mm\")\n    log(f\"Flexion - MCP:{params.mcp_flex}deg, PIP:{params.pip_flex}deg, DIP:{params.dip_flex}deg\")\n    log(f\"Lateral - MCP:{params.mcp_lateral}deg, PIP:{params.pip_lateral}deg, DIP:{params.dip_lateral}deg\")\n    log(f\"Metacarpal stub: {params.metacarpal_len}mm\")\n    log(f\"Segment range: {params.start_at} -> {params.end_at}\")\n    if shell != 0:\n        log(f\"Shell thickness: {shell}mm\")\n    \n    # Convert endpoint circumferences to radii, add shell thickness\n    mcp_radius = params.mcp_circ / (2 * math.pi) + shell\n    pip_radius = params.pip_circ / (2 * math.pi) + shell\n    dip_radius = params.dip_circ / (2 * math.pi) + shell\n    tip_radius = params.tip_circ / (2 * math.pi) + shell\n    \n    # Convert phalanx mid-circumferences to radii (None = use tapered cylinder)\n    proximal_mid_radius = (params.proximal_mid_circ / (2 * math.pi) + shell) if params.proximal_mid_circ else None\n    middle_mid_radius = (params.middle_mid_circ / (2 * math.pi) + shell) if params.middle_mid_circ else None\n    distal_mid_radius = (params.distal_mid_circ / (2 * math.pi) + shell) if params.distal_mid_circ else None\n    \n    log(f\"Radii - MCP:{mcp_radius:.2f}, PIP:{pip_radius:.2f}, DIP:{dip_radius:.2f}, Tip:{tip_radius:.2f}\")\n    \n    # Track components and centerline points\n    components = []\n    centerline_points = []\n    \n    # Track joint positions: maps joint name to (position, direction, cumulative_distance)\n    joint_positions = {}\n    cumulative_dist = 0.0\n    \n    # Helper to add start point on first rendered segment\n    def add_start_point_if_first(pt):\n        if not centerline_points:\n            centerline_points.append(Point3d(pt))\n    \n    # Initialize current_plane at origin\n    # X = finger direction, Y = flexion axis, Z = lateral axis (palm normal up)\n    current_plane = Plane(Point3d.Origin, Vector3d.XAxis, Vector3d.YAxis)\n    \n    # Record origin position\n    joint_positions[\"origin\"] = (Point3d(current_plane.Origin), Vector3d(current_plane.XAxis), cumulative_dist)\n    \n    # --- METACARPAL STUB (cylinder, no joint) ---\n    metacarpal_end = current_plane.Origin + current_plane.XAxis * params.metacarpal_len\n    if params.includes_segment(\"metacarpal\"):\n        log(\"\\n--- Metacarpal Stub ---\")\n        add_start_point_if_first(current_plane.Origin)\n        # Cylinder axis is the plane's normal, so create plane with XAxis as normal\n        metacarpal_axis_plane = Plane(current_plane.Origin, current_plane.XAxis)\n        metacarpal_brep = create_cylinder(metacarpal_axis_plane, mcp_radius, params.metacarpal_len, tolerance)\n        if metacarpal_brep:\n            components.append(metacarpal_brep)\n            log(f\"Metacarpal: length={params.metacarpal_len}mm, radius={mcp_radius:.2f}mm\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create metacarpal stub (len={params.metacarpal_len}, r={mcp_radius:.2f})\"\n            )\n        centerline_points.append(Point3d(metacarpal_end))\n    \n    # Move plane origin to end of metacarpal (MCP joint location)\n    current_plane.Origin = metacarpal_end\n    cumulative_dist += params.metacarpal_len\n    joint_positions[\"mcp\"] = (Point3d(current_plane.Origin), Vector3d(current_plane.XAxis), cumulative_dist)\n    \n    # --- MCP JOINT + PROXIMAL PHALANX ---\n    log(\"\\n--- MCP Joint + Proximal Phalanx ---\")\n    # Always advance the plane (coordinate math only)\n    new_plane, prox_line = advance_to_next_joint(\n        current_plane,\n        params.proximal_len,\n        params.mcp_lateral,\n        params.mcp_flex\n    )\n    \n    # Only create geometry if either segment is included\n    mcp_brep = None\n    prox_brep = None\n    if params.includes_segment(\"mcp\") or params.includes_segment(\"proximal\"):\n        mcp_brep, prox_brep = create_joint_and_phalanx(\n            prox_line,\n            mcp_radius,\n            pip_radius,\n            tolerance,\n            proximal_mid_radius,\n            params.augment_joint_spheres\n        )\n    \n    if params.includes_segment(\"mcp\"):\n        add_start_point_if_first(prox_line.From)\n        if mcp_brep:\n            components.append(mcp_brep)\n            log(f\"MCP Joint: center={prox_line.From}, radius={mcp_radius:.2f}mm\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create MCP joint sphere (center={prox_line.From}, r={mcp_radius:.2f})\"\n            )\n    \n    if params.includes_segment(\"proximal\"):\n        add_start_point_if_first(prox_line.From)\n        if prox_brep:\n            components.append(prox_brep)\n            log(f\"Proximal Phalanx: length={params.proximal_len}mm, r1={mcp_radius:.2f}, r2={pip_radius:.2f}\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create proximal phalanx (len={params.proximal_len}, r1={mcp_radius:.2f}, r2={pip_radius:.2f})\"\n            )\n        centerline_points.append(Point3d(prox_line.To))\n    \n    current_plane = new_plane\n    cumulative_dist += params.proximal_len\n    joint_positions[\"pip\"] = (Point3d(current_plane.Origin), Vector3d(prox_line.Direction), cumulative_dist)\n    \n    # --- PIP JOINT + MIDDLE PHALANX ---\n    log(\"\\n--- PIP Joint + Middle Phalanx ---\")\n    # Always advance the plane (coordinate math only)\n    new_plane, mid_line = advance_to_next_joint(\n        current_plane,\n        params.middle_len,\n        params.pip_lateral,\n        params.pip_flex\n    )\n    \n    # Only create geometry if either segment is included\n    pip_brep = None\n    mid_brep = None\n    if params.includes_segment(\"pip\") or params.includes_segment(\"middle\"):\n        pip_brep, mid_brep = create_joint_and_phalanx(\n            mid_line,\n            pip_radius,\n            dip_radius,\n            tolerance,\n            middle_mid_radius,\n            params.augment_joint_spheres\n        )\n    \n    if params.includes_segment(\"pip\"):\n        add_start_point_if_first(mid_line.From)\n        if pip_brep:\n            components.append(pip_brep)\n            log(f\"PIP Joint: center={mid_line.From}, radius={pip_radius:.2f}mm\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create PIP joint sphere (center={mid_line.From}, r={pip_radius:.2f})\"\n            )\n    \n    if params.includes_segment(\"middle\"):\n        add_start_point_if_first(mid_line.From)\n        if mid_brep:\n            components.append(mid_brep)\n            log(f\"Middle Phalanx: length={params.middle_len}mm, r1={pip_radius:.2f}, r2={dip_radius:.2f}\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create middle phalanx (len={params.middle_len}, r1={pip_radius:.2f}, r2={dip_radius:.2f})\"\n            )\n        centerline_points.append(Point3d(mid_line.To))\n    \n    current_plane = new_plane\n    cumulative_dist += params.middle_len\n    joint_positions[\"dip\"] = (Point3d(current_plane.Origin), Vector3d(mid_line.Direction), cumulative_dist)\n    \n    # --- DIP JOINT + DISTAL PHALANX ---\n    log(\"\\n--- DIP Joint + Distal Phalanx ---\")\n    # Always advance the plane (coordinate math only)\n    new_plane, dist_line = advance_to_next_joint(\n        current_plane,\n        params.distal_len,\n        params.dip_lateral,\n        params.dip_flex\n    )\n    \n    # Only create geometry if either segment is included\n    dip_brep = None\n    dist_brep = None\n    if params.includes_segment(\"dip\") or params.includes_segment(\"distal\"):\n        dip_brep, dist_brep = create_joint_and_phalanx(\n            dist_line,\n            dip_radius,\n            tip_radius,\n            tolerance,\n            distal_mid_radius,\n            params.augment_joint_spheres\n        )\n    \n    if params.includes_segment(\"dip\"):\n        add_start_point_if_first(dist_line.From)\n        if dip_brep:\n            components.append(dip_brep)\n            log(f\"DIP Joint: center={dist_line.From}, radius={dip_radius:.2f}mm\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create DIP joint sphere (center={dist_line.From}, r={dip_radius:.2f})\"\n            )\n    \n    if params.includes_segment(\"distal\"):\n        add_start_point_if_first(dist_line.From)\n        if dist_brep:\n            components.append(dist_brep)\n            log(f\"Distal Phalanx: length={params.distal_len}mm, r1={dip_radius:.2f}, r2={tip_radius:.2f}\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create distal phalanx (len={params.distal_len}, r1={dip_radius:.2f}, r2={tip_radius:.2f})\"\n            )\n        centerline_points.append(Point3d(dist_line.To))\n    \n    current_plane = new_plane\n    cumulative_dist += params.distal_len\n    joint_positions[\"tip\"] = (Point3d(current_plane.Origin), Vector3d(dist_line.Direction), cumulative_dist)\n    \n    # --- FINGERTIP (sphere at final position) ---\n    if params.includes_segment(\"tip\"):\n        log(\"\\n--- Fingertip ---\")\n        add_start_point_if_first(current_plane.Origin)\n        tip_brep = create_sphere(current_plane.Origin, tip_radius, tolerance)\n        if tip_brep:\n            components.append(tip_brep)\n            log(f\"Fingertip: center={current_plane.Origin}, radius={tip_radius:.2f}mm\")\n        else:\n            raise GeometryCreationError(\n                f\"Failed to create fingertip sphere (center={current_plane.Origin}, r={tip_radius:.2f})\"\n            )\n    \n    # Create centerline polyline\n    centerline = Polyline(centerline_points) if centerline_points else None\n    log(f\"\\nCenterline: {len(centerline_points)} points\")\n    \n    # Union all components\n    log(\"\\n--- Unioning Components ---\")\n    log(f\"Component count: {len(components)}\")\n    \n    if not components:\n        raise FingerModelError(\n            f\"No components generated for segment range {params.start_at} to {params.end_at}\"\n        )\n    \n    # robust_brep_union will raise BrepUnionError on failure\n    finger_brep, success, method = robust_brep_union(components, tolerance, check_volumes=True)\n    \n    log(f\"SUCCESS: Finger union complete via {method}\")\n    log(f\"Final finger volume: {finger_brep.GetVolume():.2f} mm^3\")\n    \n    # Apply trimming if specified (trim_finger_model raises TrimError on failure)\n    if params.trim_start is not None or params.trim_end is not None:\n        finger_brep, centerline = trim_finger_model(finger_brep, centerline, params, joint_positions, tolerance)\n    \n    log(\"=\" * 60)\n    \n    return centerline, finger_brep, components if return_parts else None, joint_positions\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}