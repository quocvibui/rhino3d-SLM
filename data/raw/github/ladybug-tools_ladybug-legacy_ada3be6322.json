{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_SolarFanBasic.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_SolarFanBasic.py",
  "instruction": "Use this component to generate a solar fan with minimumal input data. This component predefines monthly and hourly ranges in order to simplify the creation of useful fan geometry.    \nThe solar fan...",
  "code": "#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Saeran Vasanthakumar <saeranv@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate a solar fan with minimumal input data. This component predefines monthly and hourly ranges in order to simplify the creation of useful fan geometry.    \nThe solar fan is used to ensure that a given property within a boundary curve is guarenteed a specified minimum hours of direct solar access for each day in a specified month range of the year.\nThus, context geometries surrounding this boundary curve that do not penetrate the solar fan will not cast shadows onto the boundary area for the specified hour and month range.\n\nThe start and end dates that determine the month range for solar access can be chosen from the following options:\n0) Mar 21 - Jun 21\n1) Mar 21 - Sep 21\n2) Mar 21 - Dec 21\n3) Jun 21 - Sep 21\n4) Jun 21 - Dec 21\n5) Sep 21 - Dec 21\nThe default set to 3) June 21 to September 21.\n\nNote that extremely complicated concave shapes will take a long time to calculate a solar fan for.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _boundary:  closed boundary curve representing a piece of land (such as a park) or a window for which solar access is desired.\n        _location: The output from the importEPW or constructLocation component.  This is essentially a list of text summarizing a location on the earth.\n        _requiredHours: The number of hours of direct solar access that the property inside the boundary curve should receive during the _monthRange. For example an input of 4 will define the hour range roughly between 10AM and 2PM. The component will compute the hour range that will maximize the fan volume. \n        _height: The number of Rhino model units that the solar fan should be extended above the boundary curve.\n        north_: Input a vector to be used as a true North direction or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n        _monthRange: An optional interger value to change the month range for which solar access is being considered. The default month range is Jun 21 - Sep 21.\n            Integers input here must be between 0 - 5 and correspond to the following :\n            ---\n            0 = Mar 21 - Jun 21\n            1 = Mar 21 - Sep 21\n            2 = Mar 21 - Dec 21\n            3 = Jun 21 - Sep 21\n            4 = Jun 21 - Dec 21\n            5 = Sep 21 - Dec 21\n            ---\n            Where, in the North/South Hemispheres, these dates repsectively signify:  \n                Mar 21 = Vernal/Autumnal Equinox\n                Jun 21 = Summer/Winter Solstice\n                Sep 21 = Autumnal/Vernal Equinox\n                Dec 21 = Winter/Summer Solstice\n \n    Returns:\n        solarFan: Brep representing a solar fan.  This volume should be clear of shading in order to ensure solar access to the area inside the boundary curve for the given number of hours.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_SolarFanBasic\"\nghenv.Component.NickName = 'SolarFanBasic'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\n\nimport math\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport scriptcontext as sc\nimport datetime\nimport random\nfrom decimal import Decimal as D\nimport Grasshopper.Kernel as gh\n\n\"\"\" --------------------------3D CONVEX HULL CLASSES------------------------------\"\"\"\n\n\"\"\" The following code class for 3D convex hull is from \n    http://michelanders.blogspot.ca/2012/02/3d-convex-hull-in-python.html\n\"\"\"\ndebug = False\nclass Vector:\n\tdef __init__(self,x,y,z):\n\t\tself.x=x\n\t\tself.y=y\n\t\tself.z=z\n\t\n\tdef __str__(self):\n\t\treturn str(self.x)+\" \"+str(self.y)+\" \"+str(self.z)\n\n\tdef __sub__(self,other):\n\t\treturn Vector(other.x-self.x,other.y-self.y,other.z-self.z)\n\t\n\tdef __add__(self,other):\n\t\treturn Vector(other.x+self.x,other.y+self.y,other.z+self.z)\n\n\nclass Vertex:\n\tdef __init__(self,v,vnum=None,duplicate=None,onhull=False,mark=False):\n\t\tself.v = v\n\t\tself.vnum = vnum\n\t\tself.duplicate = duplicate # ref to incident cone edge (or None)\n\t\tself.onhull = onhull # T iff point on hull.\n\t\tself.mark = mark # T iff point already processed.\n\t\n\tdef __str__(self):\n\t\treturn str(self.v.x)+\" \"+str(self.v.y)+\" \"+str(self.v.z)\n\t\n\tdef debug(self):\n\t\treturn \"Vertex: %d %s dup:%s onhull:%s mark:%s\\n\"%(self.vnum,self.v,self.duplicate,self.onhull,self.mark)\n\t\t\n\t@staticmethod\n\tdef Collinear(a,b,c):\n\t\t\"\"\"\n\t\tCollinear checks to see if the three vertices given are collinear,\n\t\tby checking to see if each element of the cross product is zero.\n\t\t\"\"\"\n\t\treturn ( abs(( c.v.z - a.v.z ) * ( b.v.y - a.v.y ) -\n\t\t( b.v.z - a.v.z ) * ( c.v.y - a.v.y )) <1e-4\n\tand abs(( b.v.z - a.v.z ) * ( c.v.x - a.v.x ) -\n\t\t( b.v.x - a.v.x ) * ( c.v.z - a.v.z )) <1e-4\n\tand abs(( b.v.x - a.v.x ) * ( c.v.y - a.v.y ) -\n\t\t( b.v.y - a.v.y ) * ( c.v.x - a.v.x )) <1e-4 )\n\nclass Edge:\n\tenum = 0\n\t\n\tdef __init__(self,adjface=[None,None],endpts=[None,None],newface=None,delete=False):\n\t\tself.adjface = []\n\t\tself.adjface.extend(adjface)\n\t\tself.endpts = []\n\t\tself.endpts.extend(endpts)\n\t\tself.newface = newface # ref to incident cone face\n\t\tself.delete = delete # T iff edge should be deleted\n\t\tself.enum = Edge.enum\n\t\tEdge.enum+=1\n\t\t\n\tdef __str__(self):\n\t\taf=[str(f.fnum) if not (f is None) else '.' for f in self.adjface]\n\t\treturn \"edge(%d): %s %s del: %s newf: %d adjf:%s\"%(self.enum,self.endpts[0],self.endpts[1],self.delete,self.newface.fnum if not (self.newface is None) else -1,\" \".join(af))\n\t\t\nclass Face:\n\tfnum=0\n\tdef __init__(self,edge=[None,None,None],vertex=[None,None,None],visible=False):\n\t\tself.edge = []\n\t\tself.edge.extend(edge)\n\t\tself.vertex = []\n\t\tself.vertex.extend(vertex)\n\t\tself.visible = visible # T iff face visible from new point\n\t\tself.fnum = Face.fnum\n\t\tFace.fnum+=1\n\t\t\n\tdef __str__(self):\n\t\treturn \"\"\"facet normal 0 0 0\nouter loop\nvertex %s\nvertex %s\nvertex %s\nendloop\nendfacet\"\"\"%(self.vertex[0],self.vertex[1],self.vertex[2])\n\n\tdef debug(self):\n\t\treturn \"Face(%d) visble: %s\\n\\t%s\\t%s\\t%s\"%(self.fnum,self.visible,self.vertex[0].debug(),self.vertex[1].debug(),self.vertex[2].debug())\n\t\t\n\tdef InitEdges(self, fold=None):\n\t\tv0=self.vertex[0]\n\t\tv1=self.vertex[1]\n\t\tv2=self.vertex[2]\n\t\tnewedges=[]\n\t\t# Create edges of the initial triangle\n\t\tif fold is None:\n\t\t\te0 = Edge()\n\t\t\te1 = Edge()\n\t\t\te2 = Edge()\n\t\t\tnewedges=[e0,e1,e2]\n\t\telse: # Copy from fold, in reverse order\n\t\t\te0 = fold.edge[2]\n\t\t\te1 = fold.edge[1]\n\t\t\te2 = fold.edge[0]\n\t\te0.endpts[0] = v0\n\t\te0.endpts[1] = v1\n\t\te1.endpts[0] = v1\n\t\te1.endpts[1] = v2\n\t\te2.endpts[0] = v2\n\t\te2.endpts[1] = v0\n\t\n\t\tself.edge[0] = e0\n\t\tself.edge[1] = e1\n\t\tself.edge[2] = e2\n\t\n\t\t# Link edges to face\n\t\te0.adjface[0] = self\n\t\te1.adjface[0] = self\n\t\te2.adjface[0] = self\n\n\t\t\t\n\t\treturn newedges\n\t\t\n\tdef MakeCcw(f,e,p): # the customary self is called f here instead of self\n\t\t\"\"\"\n\t\tMakeCcw puts the vertices in the face structure in counterclock wise \n\t\torder.  We want to store the vertices in the same \n\t\torder as in the visible face.  The third vertex is always p.\n\n\t\tAlthough no specific ordering of the edges of a face are used\n\t\tby the code, the following condition is maintained for each face f:\n\t\tone of the two endpoints of f.edge[i] matches f.vertex[i]. \n\t\tBut note that this does not imply that f.edge[i] is between\n\t\tf.vertex[i] and f.vertex[(i+1)%3].  (Thanks to Bob Williamson.)\n\t\t\"\"\"\n\t\t\n\t\t# fv\tThe visible face adjacent to e\n\t\t# i     Index of e.endpoint[0] in fv\n\t\n\t\tif e.adjface[0].visible:      \n\t\t\tfv = e.adjface[0]\n\t\telse:\n\t\t\tfv = e.adjface[1]\n\t\n\t\t# Set vertex[0] & [1] of f to have the same orientation\n\t\t# as do the corresponding vertices of fv\n\t\ti=0\n\t\twhile(fv.vertex[i] != e.endpts[0]):\n\t\t\ti+=1\n\t\t# Orient f the same as fv\n\t\tswap=False\n\t\tif fv.vertex[ (i+1) % 3 ] != e.endpts[1] :\n\t\t\tf.vertex[0] = e.endpts[1]  \n\t\t\tf.vertex[1] = e.endpts[0]    \n\t\telse:\n\t\t\tf.vertex[0] = e.endpts[0]   \n\t\t\tf.vertex[1] = e.endpts[1]   \n\t\t\t(f.edge[1], f.edge[2] ) = (f.edge[2], f.edge[1] )\n\t\t\t#print('swapped') \n\t\t\t# This swap is tricky. e is edge[0]. edge[1] is based on endpt[0],\n\t\t\t# edge[2] on endpt[1].  So if e is oriented \"forwards,\" we\n\t\t\t# need to move edge[1] to follow [0], because it precedes. */\n\n\t\tf.vertex[2] = p\n\t\t\n# Define flags\nONHULL = True\nREMOVED = True\nVISIBLE  = True\nPROCESSED = True\n\nclass Hull:\n\tdef __init__(self,v):\n\t\tself.vertices = []\n\t\tself.edges = []\n\t\tself.faces = []\n\t\tself.ReadVertices(v)\n\t\tv=self.DoubleTriangle()\n\t\tself.ConstructHull(v)\n\t\tself.EdgeOrderOnFaces()\n\n\tdef ReadVertices(self,v):\n\t\tself.vertices = [ Vertex(vc,i) for i,vc in enumerate(v) ]\n\t\t\n\tdef EdgeOrderOnFaces(self):\n\t\t\"\"\"\n\t\tEdgeOrderOnFaces: puts e0 between v0 and v1, e1 between v1 and v2,\n\t\te2 between v2 and v0 on each face.  This should be unnecessary, alas.\n\t\t\"\"\"\n\t\tfor f in self.faces:\n\t\t\tfor i in (0,1,2):\n\t\t\t\tif ( not (((f.edge[i].endpts[0] == f.vertex[i]) and\n\t\t\t\t\t(f.edge[i].endpts[1] == f.vertex[(i+1)%3])) or\n\t\t\t\t\t((f.edge[i].endpts[1] == f.vertex[i]) and\n\t\t\t\t\t(f.edge[i].endpts[0] == f.vertex[(i+1)%3])))):\n\t\t\t\t\t# Change the order of the edges on the face\n\t\t\t\t\tfor j in (0,1,2):\n\t\t\t\t\t\t# find the edge that should be there\n\t\t\t\t\t\tif (((f.edge[j].endpts[0] == f.vertex[i]) and\n\t\t\t\t\t\t\t(f.edge[j].endpts[1] == f.vertex[(i+1)%3])) or\n\t\t\t\t\t\t\t((f.edge[j].endpts[1] == f.vertex[i]) and\n\t\t\t\t\t\t\t(f.edge[j].endpts[0] == f.vertex[(i+1)%3]))) :\n\t\t\t\t\t\t\t# Swap it with the one erroneously put into its place\n\t\t\t\t\t\t\t(f.edge[i],f.edge[j]) = (f.edge[j],f.edge[i])\n\tdef __str__(self):\n\t\ts=[\"solid points\"]\n\t\tfor f in self.faces:\n\t\t\ts.append(str(f))\n\t\ts.append(\"endsolid points\")\n\t\treturn \"\\n\".join(s)\n\t\t\n\tdef debug(self,msg=''):\n\t\ts=[msg+'\\n']\n\t\tfor f in self.faces:\n\t\t\ts.append(f.debug())\n\t\ts.append('-'*40)\n\t\treturn \"\".join(s)\n\t\t\n\t@staticmethod\n\tdef VolumeSign(f,p):\n\t\t\"\"\"\n\t\tVolumeSign returns the sign of the volume of the tetrahedron determined by f\n\t\tand p.  VolumeSign is +1 iff p is on the negative side of f,\n\t\twhere the positive side is determined by the rh-rule.  So the volume \n\t\tis positive if the ccw normal to f points outside the tetrahedron.\n\t\tThe final fewer-multiplications form is due to Bob Williamson.\n\t\t\n\t\tThis implementation differs from the one in the book in that it does not assume that\n\t\tcoordinates are integers.\n\t\t\"\"\"\n\t\ta=f.vertex[0].v - p.v\n\t\tb=f.vertex[1].v - p.v\n\t\tc=f.vertex[2].v - p.v\n\t\t\n\t\tvol = ( a.x * (b.y*c.z - b.z*c.y)\n\t\t+ a.y * (b.z*c.x - b.x*c.z)\n\t\t+ a.z * (b.x*c.y - b.y*c.x) )\n\t\tepsilon = 1e-7\n\t\tif abs(vol) >  epsilon:\n\t\t\tif vol>0 : return 1\n\t\t\telse : return -1\n\t\telse:\n\t\t\tax=D(a.x)\n\t\t\tay=D(a.y)\n\t\t\taz=D(a.z)\n\t\t\tbx=D(b.x)\n\t\t\tby=D(b.y)\n\t\t\tbz=D(b.z)\n\t\t\tcx=D(c.x)\n\t\t\tcy=D(c.y)\n\t\t\tcz=D(c.z)\n\t\t\tvol = ( ax * (by*cz - bz*cy)\n\t\t\t+ ay * (bz*cx - bx*cz)\n\t\t\t+ az * (bx*cy - by*cx) )\n\t\t\tif vol<D(0.0):\n\t\t\t\treturn -1\n\t\t\telif vol>D(0.0):\n\t\t\t\treturn 1\n\t\treturn 0\n\n\tdef ShowEdges(self,msg=\"\"):\n\t\tprint(msg)\n\t\tfor e in self.edges:\n\t\t\tif e.adjface[0] is None or e.adjface[1] is None :\n\t\t\t\tprint(str(e))\n\t\t\t\t\n\tdef ShowNewEdges(self,msg=\"\"):\n\t\tprint(msg,len(self.newedges))\n\t\tfor e in self.newedges:\n\t\t\tprint(str(e))\n\t\t\t\t\n\tdef DoubleTriangle(self):\n\t\t\"\"\"\n\t\tDoubleTriangle builds the initial double triangle.  It first finds 3 \n\t\tnoncollinear points and makes two faces out of them, in opposite order.\n\t\tIt then finds a fourth point that is not coplanar with that face.  The  \n\t\tvertices are stored in the face structure in counterclockwise order so \n\t\tthat the volume between the face and the point is negative. Lastly, the\n\t\t3 newfaces to the fourth point are constructed and the data structures\n\t\tare cleaned up. \n\t\t\"\"\"\n\n\t\t# Find 3 noncollinear points\n\t\tv0 = 0\n\t\tnv = len(self.vertices)\n\t\twhile(Vertex.Collinear(self.vertices[v0%nv],self.vertices[(v0+1)%nv],self.vertices[(v0+2)%nv])):\n\t\t\tv0 = (v0+1)%nv\n\t\t\tif v0 == 0:\n\t\t\t\traise Exception(\"DoubleTriangle:  All points are Collinear!\")\n\t\t\t\t\n\t\tv1 = (v0+1)%nv\n\t\tv2 = (v1+1)%nv\n\t\n\t\t# Mark the vertices as processed\n\t\tself.vertices[v0].mark = PROCESSED\n\t\tself.vertices[v1].mark = PROCESSED\n\t\tself.vertices[v2].mark = PROCESSED\n\n\t\t# Create the two \"twin\" faces\n\t\tself.faces.append(Face(vertex=[self.vertices[v0],self.vertices[v1],self.vertices[v2]]))\n\t\tf0=self.faces[-1]\n\t\tself.edges.extend(f0.InitEdges())\n\t\tself.faces.append(Face(vertex=[self.vertices[v2],self.vertices[v1],self.vertices[v0]]))\n\t\tf1=self.faces[-1]\n\t\tself.edges.extend(f1.InitEdges(f0))\n\n\t\t# Link adjacent face fields.\n\n\t\tf0.edge[0].adjface[1] = f1\n\t\tf0.edge[1].adjface[1] = f1\n\t\tf0.edge[2].adjface[1] = f1\n\t\tf1.edge[0].adjface[1] = f0\n\t\tf1.edge[1].adjface[1] = f0\n\t\tf1.edge[2].adjface[1] = f0\n\t\n\t\t#Find a fourth, noncoplanar point to form tetrahedron\n\t\tv3 = (v2+1)%nv\n\t\tvol = self.VolumeSign( f0, self.vertices[v3] )\n\t\twhile vol == 0:\n\t\t\tv3 = (v3+1)%nv\n\t\t\tif v3==0:\n\t\t\t\traise Exception(\"DoubleTriangle:  All points are coplanar!\")\n\t\t\tvol = self.VolumeSign( f0, self.vertices[v3] )\n\t\n\t\tif debug: print(self.debug('initial'))\n\t\t\t\n\t\treturn v3\n\t\t\n\tdef ConstructHull(self,v):\n\t\t\"\"\"\n\t\tConstructHull adds the vertices to the hull one at a time.  The hull\n\t\tvertices are those in the list marked as onhull.\n\t\t\"\"\"\n\n\t\t# vertices is supposed to be a circular list that we traverse once, starting at v\n\t\t# however, the call to CleanUp may delete vertices from this list\n\t\tev = v\n\t\twhile(True):\n\t\t\tif not self.vertices[v].mark:\n\t\t\t\tself.vertices[v].mark = PROCESSED;\n\t\t\tself.AddOne(self.vertices[v]);\n\t\t\tev,v=self.CleanUp(ev,v) # cleanup may delete vertices!\n\t\t\tif v == ev : break\n\t\t\t\n\tdef AddOne(self,p):\n\t\t\"\"\"\n\t\tAddOne is passed a vertex.  It first determines all faces visible from \n\t\tthat point.  If none are visible then the point is marked as not \n\t\tonhull.  Next is a loop over edges.  If both faces adjacent to an edge\n\t\tare visible, then the edge is marked for deletion.  If just one of the\n\t\tadjacent faces is visible then a new face is constructed.\n\t\t\"\"\"\n\t\t\n\t\tvis = False\n\n\t\t# Mark faces visible from p.\n\t\tfor f in self.faces:\n\t\t\tvol = self.VolumeSign( f, p )\n\t\t\tif vol < 0 : \n\t\t\t\tf.visible = VISIBLE\n\t\t\t\tvis = True;                      \n\n\t\t# If no faces are visible from p, then p is inside the hull\n\t\tif not vis:\n\t\t\tp.onhull = not ONHULL  \n\t\t\treturn False \n\n\t\t# Mark edges in interior of visible region for deletion.\n\t\t# Erect a newface based on each border edge\n\t\tself.newedges=[]\n\t\tcount=0\n\t\tfor e in self.edges:\n\t\t\tif e.adjface[0].visible and\te.adjface[1].visible:\n\t\t\t\t# e interior: mark for deletion\n\t\t\t\te.delete = REMOVED\n\t\t\telif e.adjface[0].visible or e.adjface[1].visible: \n\t\t\t\t# e border: make a new face\n\t\t\t\te.newface = self.MakeConeFace( e, p )\n\t\t\t\tcount+=1\n\t\tself.edges.extend(self.newedges)\n\t\tif debug : print(self.debug('addone'))\n\t\t\n\t\treturn True\n\n\tdef MakeConeFace(self,e,p):\n\t\t\"\"\"\n\t\tMakeConeFace makes a new face and two new edges between the \n\t\tedge and the point that are passed to it. It returns a pointer to\n\t\tthe new face.\n\t\t\"\"\"\n\t\t\n\t\tnew_edge=[None,None]\n\t\tdupc=0\n\t\t# Make two new edges (if it doesn't already exist)\n\t\tfor i in (0,1):\n\t\t\t# If the edge exists, copy it into new_edge\n\t\t\t# Otherwise (duplicate is NULL), MakeNullEdge\n\t\t\td = e.endpts[i].duplicate\n\t\t\tif d is None:\n\t\t\t\tnew_edge[i] = Edge(endpts=[e.endpts[i],p])\n\t\t\t\te.endpts[i].duplicate = new_edge[i]\n\t\t\t\tself.newedges.append(new_edge[i])\n\t\t\telse:\n\t\t\t\tnew_edge[i] = d\n\t\t\t\tdupc += 1\n\n\t\t# Make the new face\n\t\tnew_face = Face(edge=[e,new_edge[0],new_edge[1]])\n\t\tself.faces.append(new_face)\n\t\tnew_face.MakeCcw( e, p )\n\t\t\n\t\t# Set the adjacent face pointers\n\t\tcount=0\n\t\tfor i in (0,1):\n\t\t\tfor j in (0,1):\n\t\t\t\t# Only one None link should be set to new_face\n\t\t\t\tif new_edge[i].adjface[j] is None:\n\t\t\t\t\tnew_edge[i].adjface[j] = new_face\n\t\t\t\t\tcount+=1\n\t\t\t\t\tbreak\n\t\t#print(new_face.fnum,count,dupc)\n\t\treturn new_face\n\n\tdef CleanUp(self,ev,v):\n\t\t\"\"\"\n\t\tCleanUp goes through each data structure list and clears all\n\t\tflags and NULLs out some pointers.  The order of processing\n\t\t(edges, faces, vertices) is important.\n\t\t\"\"\"\n\t\tde=self.CleanEdges()\n\t\tif debug: print(self.debug('cleanedges '+\" \".join(de)))\n\t\tself.CleanFaces()\n\t\tif debug: print(self.debug('cleanfaces'))\n\t\tev,v=self.CleanVertices(ev,v)\n\t\tif debug: print(self.debug('cleanvertices'))\n\t\treturn ev,v\n\t\t\n\tdef CleanEdges(self):\n\t\t\"\"\"\n\t\tCleanEdges runs through the edge list and cleans up the structure.\n\t\tIf there is a newface then it will put that face in place of the \n\t\tvisible face and NULL out newface. It also deletes so marked edges.\n\t\t\"\"\"\n\t\t# Integrate the newface's into the data structure\n\t\tfor e in self.edges:\n\t\t\tif e.newface:\n\t\t\t\tif e.adjface[0].visible:\n\t\t\t\t\te.adjface[0] = e.newface\n\t\t\t\t\tif e.newface is None: print(\"0 XXXXXXXXXXXXXXXXXXXX\")\n\t\t\t\telse:\n\t\t\t\t\te.adjface[1] = e.newface\n\t\t\t\t\tif e.newface is None: print(\"1 XXXXXXXXXXXXXXXXXXXX\")\n\t\t\te.newface = None\n\n\t\t# Delete any edges marked for deletion. */\n\t\tdeleted_edges = [str(e.enum) for e in self.edges if e.delete ]\n\t\tself.edges = [e for e in self.edges if not e.delete ]\n\t\treturn deleted_edges\n\t\t\t\t\n\tdef CleanFaces(self):\n\t\t\"\"\"\n\t\tCleanFaces runs through the face list and deletes any face marked visible.\n\t\t\"\"\"\n\n\t\tself.faces = [f for f in self.faces if not f.visible ]\n\t\t\n\tdef CleanVertices(self,evi,vi):\n\t\t\"\"\"\n\t\tCleanVertices runs through the vertex list and deletes the \n\t\tvertices that are marked as processed but are not incident to any \n\t\tundeleted edges. \n\t\t\"\"\"\n\t\t#self.ShowNewEdges(\"cv in evi:\"+str(evi)+\" vi:\"+str(vi))\n\n\t\t# Mark all vertices incident to some undeleted edge as on the hull\n\t\tfor e in self.edges:\n\t\t\te.endpts[0].onhull = ONHULL\n\t\t\te.endpts[1].onhull = ONHULL\n\t\t\n\t\t# Delete all vertices that have been processed but are not on the hull\n\t\tfor i,v in enumerate(self.vertices):\n\t\t\tif v.mark and not v.onhull:\n\t\t\t\tdel self.vertices[i]\n\t\t\t\tif i<evi : evi -= 1\n\t\t\t\tif i<vi : vi -= 1\n\t\tvi = (vi+1)%len(self.vertices)\n\n\t\t# Reset flags\n\t\tfor v in self.vertices:\n\t\t\tv.duplicate = None\n\t\t\tv.onhull = not ONHULL\n\t\t\n\t\t#self.ShowNewEdges(\"cv out evi:\"+str(evi)+\" vi:\"+str(vi))\n\t\treturn evi,vi\n\n\tdef add_object(self):\n\t\tverts = [v.v for v in self.vertices]\n\t\tvertmap =  {v.vnum:i for i,v in enumerate(self.vertices)}\n\t\tedges = []\n\t\tfaces = [ [vertmap[v.vnum] for v in f.vertex] for f in self.faces]\n\t\tmesh = bpy.data.meshes.new(name='Convex Hull')\n\t\tmesh.from_pydata(verts, edges, faces)\n\t\tadd_object_data(bpy.context, mesh, operator=None)\n\t\t#f=open(\"file.stl\",\"w\")\n\t\t#f.write(str(self))\n\t\t#f.close()\n\n\"\"\" --------------------------3D CONVEX HULL CLASSES------------------------------\"\"\"\n\n\nclass SunCalculation:\n    \"\"\" \n    Modified from: http://michelanders.blogspot.ca/2010/12/calulating-sunrise-and-sunset-in-python.html\n    Calculate sunrise and sunset based on equations from NOAA\n    http://www.srrb.noaa.gov/highlights/sunrise/calcdetails.html\n    \"\"\"\n    def __init__(self,lat,long): # default Amsterdam\n        self.lat=lat\n        self.long=long\n  \n    def sunrise(self,when):\n        \"\"\"\n        return the time of sunrise as a datetime.time object\n        when is a datetime.datetime object. If none is given\n        a local time zone is assumed (including daylight saving\n        if present)\n        \"\"\"\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.sunrise_t)\n  \n    def sunset(self,when):\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.sunset_t)\n  \n    def solarnoon(self,when):\n        self.__preptime(when)\n        self.__calc()\n        return self.__timefromdecimalday(self.solarnoon_t)\n  \n    @staticmethod\n    def __timefromdecimalday(day):\n        \"\"\"\n        returns a datetime.time object.\n  \n        day is a decimal day between 0.0 and 1.0, e.g. noon = 0.5\n        \"\"\"\n        hours  = 24.0*day\n        h = int(hours)\n        minutes = (hours-h)*60\n        m = int(minutes)\n        seconds = (minutes-m)*60\n        s = int(seconds)\n        return datetime.time(hour=h,minute=m,second=s)\n\n    def __preptime(self,when):\n        \"\"\"\n        Extract information in a suitable format from when, \n        a datetime.datetime object.\n        \"\"\"\n        # datetime days are numbered in the Gregorian calendar\n        # while the calculations from NOAA are distibuted as\n        # OpenOffice spreadsheets with days numbered from\n        # 1/1/1900. The difference are those numbers taken for \n        # 18/12/2010\n        self.day = when.toordinal()-(734124-40529)\n        t=when.time()\n        self.time= (t.hour + t.minute/60.0 + t.second/3600.0)/24.0\n  \n        self.timezone=0\n        offset=when.utcoffset()\n        if not offset is None:\n            self.timezone=offset.seconds/3600.0 + (offset.days * 24)\n  \n    def __calc(self):\n        \"\"\"\n        Perform the actual calculations for sunrise, sunset and\n        a number of related quantities.\n  \n        The results are stored in the instance variables\n        sunrise_t, sunset_t and solarnoon_t\n        \"\"\"\n        timezone = self.timezone # in hours, east is positive\n        longitude= self.long     # in decimal degrees, east is positive\n        latitude = self.lat      # in decimal degrees, north is positive\n\n        time = self.time # percentage past midnight, i.e. noon  is 0.5\n        day = self.day     # daynumber 1=1/1/1900\n \n        Jday = day+2415018.5+time-timezone/24 # Julian day\n        Jcent =(Jday-2451545)/36525 # Julian century\n\n        Manom = 357.52911+Jcent*(35999.05029-0.0001537*Jcent)\n        Mlong = 280.46646+Jcent*(36000.76983+Jcent*0.0003032)%360\n        Eccent = 0.016708634-Jcent*(0.000042037+0.0001537*Jcent)\n        Mobliq = 23+(26+((21.448-Jcent*(46.815+Jcent*(0.00059-Jcent*0.001813))))/60)/60\n        obliq = Mobliq+0.00256*math.cos(math.radians(125.04-1934.136*Jcent))\n        vary = math.tan(math.radians(obliq/2))*math.tan(math.radians(obliq/2))\n        Seqcent = math.sin(math.radians(Manom))*(1.914602-Jcent*(0.004817+0.000014*Jcent))+math.sin(math.radians(2*Manom))*(0.019993-0.000101*Jcent)+math.sin(math.radians(3*Manom))*0.000289\n        Struelong = Mlong+Seqcent\n        Sapplong = Struelong-0.00569-0.00478*math.sin(math.radians(125.04-1934.136*Jcent))\n        declination = math.degrees(math.asin(math.sin(math.radians(obliq))*math.sin(math.radians(Sapplong))))\n  \n        eqtime = 4*math.degrees(vary*math.sin(2*math.radians(Mlong))-2*Eccent*math.sin(math.radians(Manom))+4*Eccent*vary*math.sin(math.radians(Manom))*math.cos(2*math.radians(Mlong))-0.5*vary*vary*math.sin(4*math.radians(Mlong))-1.25*Eccent*Eccent*math.sin(2*math.radians(Manom)))\n\n        #hourangle= math.degrees(math.acos(math.cos(math.radians(90.833))/(math.cos(math.radians(latitude))*math.cos(math.radians(declination)))-math.tan(math.radians(latitude))*math.tan(math.radians(declination))))\n\n        self.solarnoon_t=(720-4*longitude-eqtime+timezone*60)/1440\n        #self.sunrise_t  =self.solarnoon_t-hourangle*4/1440\n        #self.sunset_t   =self.solarnoon_t+hourangle*4/1440\n\nclass ConvexHull2d:\n    \"\"\"Modifed from: http://tomswitzer.net/2009/12/jarvis-march/\"\"\"\n    def __init__(self):\n        self.TURN_LEFT, self.TURN_RIGHT, self.TURN_NONE = (1, -1, 0)\n \n    def turn(self,p,q,r):\n        \"\"\"Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\"\"\"\n        return cmp((q[0] - p[0])*(r[1] - p[1]) - (r[0] - p[0])*(q[1] - p[1]), 0)\n \n    def _dist(self,p,q):\n        \"\"\"Returns the squared Euclidean distance between p and q.\"\"\"\n        dx, dy = q[0] - p[0], q[1] - p[1]\n        return dx * dx + dy * dy\n \n    def _next_hull_pt(self,points, p):\n        \"\"\"Returns the next point on the convex hull in CCW from p.\"\"\"\n        q = p\n        for r in points:\n            t = self.turn(p, q, r)\n            if t == self.TURN_RIGHT or \\\n            t == self.TURN_NONE and \\\n            self._dist(p, r) > self._dist(p, q):\n                q = r\n        return q\n \n    def convex_hull(self,points):\n        \"\"\"Returns the points on the convex hull of points in CCW order.\"\"\"\n        hull = [min(points)]\n        for p in hull:\n            q = self._next_hull_pt(points, p)\n            if q != hull[0]:\n                hull.append(q)\n        return hull\n\nclass Curve2ConvexHull3d:\n    def __init__(self):\n        pass\n        \n    def convert_pts(self,pt):\n        rc_pt = map(lambda p: rs.coerce3dpoint(p),pt)\n        return map(lambda y: Vector(y[0],y[1],y[2]),rc_pt)\n\n    def get_brep(self,pts):\n        h = Hull(pts)\n        #print i,h\n        F = []\n        for f in h.faces:\n            ptlst = map(lambda i:rs.AddPoint(i.v.x,i.v.y,i.v.z), f.vertex)\n            F.append(rs.AddPlanarSrf(rs.AddCurve(ptlst+[ptlst[0]],1)))\n        brepfacelst = map(lambda c: rs.coercebrep(c),F)\n        brep = rs.JoinSurfaces(brepfacelst)\n        return brep\n\n    def call_convexhull(self,p,count):\n        ##print 'count:', count ##for testing\n        if count > 20:\n            return None\n        else:\n            #randomize pts\n            random.shuffle(p)\n            brep = self.get_brep(p)\n            if brep != None:\n                return brep\n            else:\n                # dare, dare again, always dare, \n                # and France is saved!  G.Danton\n                return self.call_convexhull(p,count+1)\n\n    def get_convexhull(self,lot):\n        brep_lst = []\n        pt_lst = []\n        rs.EnableRedraw(False)\n        for T in lot:\n            bound = rs.CurvePoints(T[0])[:-1]\n            chull = rs.CurvePoints(T[1])[:-1]\n            Rhino.Geometry.Point3d.CullDuplicates(bound,TOL)\n            Rhino.Geometry.Point3d.CullDuplicates(chull,TOL)\n            pts = self.convert_pts(chull + bound)\n            brep = self.call_convexhull(pts,0)\n            if brep == None: 'brep=none -sv'\n            brep_lst.append(brep)\n            pt_lst.append(bound+chull)\n        rs.EnableRedraw()\n        return brep_lst,pt_lst\n\nclass CleanBrep:\n    def __init__(self,tol,L):\n        self.tol = tol\n        self.L = L\n    \n    def safeUnionMethod(self,solarFans):\n        \"\"\"From Ladybug\"\"\"\n        res = []\n        x = solarFans[0]\n        for fanCount in range(len(solarFans[1:])):\n            if gh.GH_Document.IsEscapeKeyDown():\n                    print \"terminated!\"\n                    break\n            try:\n                rs.EnableRedraw(False)\n                #x = solarFans[fanCount]\n                y = solarFans[fanCount]\n                x.Faces.SplitKinkyFaces(rc.RhinoMath.DefaultAngleTolerance, False)\n                y.Faces.SplitKinkyFaces(rc.RhinoMath.DefaultAngleTolerance, False)\n                a = rc.Geometry.Brep.CreateBooleanUnion([x, y], sc.doc.ModelAbsoluteTolerance)\n                if a == None:\n                    a = [x,solarFans[fanCount]]\n                rs.EnableRedraw()\n            except:\n                a = [x,solarFans[fanCount]]\n        \n            if a:\n                res.extend(a)\n                x = y\n        return res\n    \n    def slowUnionMethod(self,solarFans):\n        fanlst = [solarFans.pop(0)]\n        rs.EnableRedraw(False)\n        for next_fan in solarFans:\n            if gh.GH_Document.IsEscapeKeyDown():\n                print \"terminated!\"\n                break\n            breplst = [fanlst[0],next_fan]\n            boolean_result = Rhino.Geometry.Brep.CreateBooleanUnion(breplst,TOL)\n            if boolean_result:\n                fanlst = boolean_result\n            else:\n                return -1\n            Rhino.RhinoApp.Wait()\n        rs.EnableRedraw()\n        return fanlst\n\n    def unionFans(self): \n        if len(self.L) == 1: # convex\n            #print 'no union' ## for testing\n            return self.L\n        else:\n            #print 'safeiunionmethod' ## for testing\n            fanlst = self.safeUnionMethod(self.L)\n        \n        if len(fanlst) > 1 and len(fanlst) < 10: # safeUnionMethod has failed\n            #print 'slowunionmethod' ## for testing\n            slowfanlst = self.slowUnionMethod(self.L)\n            if slowfanlst != -1:\n                fanlst = slowfanlst\n        if len(fanlst) > 1: #final check\n            error_union = \\\n            \"Sorry your boundary geometry is too complicated for\\n\"\\\n            \"this component too handle cleanly. If you boolean union\\n\"\\\n            \"the multiple geometries that has been outputted, it will\\n\"\\\n            \"give you your Solar Fan.\"\n            print error_union\n            #ghenv.Component.AddRuntimeMessage(ERROR_W,error_union)\n        return fanlst\n\n    def mergeface(self,brplst):\n        map(lambda b: b.MergeCoplanarFaces(TOL),brplst)\n        return brplst\n    \n    def cleanBrep(self):\n        blst = self.unionFans()\n        return self.mergeface(blst)\n\ndef readLocation(location):\n    \"\"\"From Ladybug\"\"\"\n    locationStr = location.split('\\n')\n    newLocStr = \"\"\n    #clean the idf file\n    for line in locationStr:\n        if '!' in line:\n            line = line.split('!')[0]\n            newLocStr  = newLocStr + line.replace(\" \", \"\")\n        else:\n            newLocStr  = newLocStr + line\n    newLocStr = newLocStr.replace(';', \"\")\n    site, locationName, latitude, longitude, timeZone, elevation = newLocStr.split(',')\n    return float(latitude), float(longitude), float(timeZone), float(elevation)\n\ndef get_sunpt(lat,cpt,month,day,hourlst,north_=0,lon=0,tZ=0,scale_=100):\n    \"\"\"modifed from Ladybug\"\"\"\n    lb_sunpath = sc.sticky[\"ladybug_SunPath\"]()\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    sunpt_lst = []\n    for hour in hourlst:\n        centerPt = rs.coerce3dpoint(cpt)\n        northAngle_, northVector = lb_preparation.angle2north(north_)\n        lb_sunpath.initTheClass(lat,northAngle=northAngle_,cenPt=centerPt,\\\n        scale=scale_,longtitude=lon, timeZone=tZ )\n        lb_sunpath.solInitOutput(month,day,hour)\n        sunpt_lst.append(lb_sunpath.sunPosPt()[2]) # basePoint.Location\n        #return sunSphereMesh, sunVector, basePoint.Location\n    return sunpt_lst\n\ndef get_plane(b,ht):\n    endpt = rs.AddPoint(0,0,ht)\n    startpt = rs.AddPoint(0,0,0)\n    top_vec = rs.VectorCreate(endpt,startpt)\n    top_pts = rs.CurvePoints(rs.CopyObject(b,top_vec))\n    return rs.PlaneFitFromPoints(top_pts)\n\ndef project_curve(sunpts,cpt,topplane,b):\n    L = []\n    for spt in sunpts:\n        line = cpt,spt\n        proj_pt = rs.LinePlaneIntersection(line,topplane)\n        vec = rs.VectorCreate(proj_pt,cpt)\n        topcurve = rs.CopyObject(b,vec)\n        L.append(topcurve)\n    return L\n\ndef get_solarnoon(month,year,tz,d,lat,lon):\n    \"\"\"get_solarnoon: month -> solarnoon \"\"\" \n    date = datetime.datetime(year,month,d)\n    SC = SunCalculation(lat,lon)\n    snoon = SC.solarnoon(date)\n    return snoon.hour + tz + snoon.minute/60.0\n\ndef clean_curve(b):\n    \"\"\"Clean curve geometry\n        1. Checks if guid or object\n        2. Simplifiebs\n        3. Reverse curve dirn\n        4. Closes curve if not already closed\n    \"\"\"\n    if type(b) == type(rs.AddPoint(0,0,0)): # already guid\n        pass\n    else:\n        b = sc.doc.Objects.AddCurve(b)\n    rs.SimplifyCurve(b)\n    # reverse curve direction\n    boundarybrep = rs.coercecurve(b)\n    Rhino.Geometry.Curve.Reverse(boundarybrep)\n    sc.doc.Objects.Replace(b,boundarybrep)\n    if rs.IsCurveClosed(b):\n        return b\n    else:\n        return rs.CloseCurve(b)\n\n\ndef getSolarData(tp,s_snoon,e_snoon):\n    # solar noon\n    t = tp/2.0\n    shourlst = [s_snoon-t,s_snoon+t]\n    ehourlst = [e_snoon-t,e_snoon+t]\n    day = 21\n    return shourlst,ehourlst,day\n\ndef getSolarGeom(boundary,ht,lat,shourlst,ehourlst,day,north,long,timeZ,s_mth,e_mth):\n    CH = ConvexHull2d()\n    boundary_pts = rs.CurvePoints(boundary) # you'll need this later\n    boundary_pts.pop(-1)\n    bchullpts = CH.convex_hull(boundary_pts)\n    centerPt = rs.CurveAreaCentroid(rs.AddCurve(bchullpts + [bchullpts[0]],1))[0]\n    #centerPt = rs.CurveAreaCentroid(boundary)[0]\n    boundary_plane = rs.PlaneFitFromPoints(boundary_pts)\n    top_plane = get_plane(boundary,ht)\n\n    # project curve to user_defined height\n    sun_pts = get_sunpt(lat,centerPt,s_mth,day,shourlst,north_=north,lon=long,tZ=timeZ,scale_=100)\n    sun_pts.extend(get_sunpt(lat,centerPt,e_mth,day,ehourlst,north_=north,lon=long,tZ=timeZ,scale_=100))\n\n    top_lst = project_curve(sun_pts,centerPt,top_plane,boundary)\n    top_curves = map(lambda x: rs.coercecurve(x),top_lst) # temp for viz\n    top_lst = map(lambda x: rs.CurvePoints(x),top_lst)\n    top_pts = map(lambda x: rs.coerce3dpoint(x),\\\n        reduce(lambda i,j:i+j,top_lst))\n\n    # convex hull methods\n    chull_pts = CH.convex_hull(top_pts)\n    chull_crv = rs.AddCurve(chull_pts + [chull_pts[0]],1)\n    #chull_centerPt = rs.CurveAreaCentroid(chull_crv)[0]\n    # adjust curve directions\n    #if not rs.CurveDirectionsMatch(boundary,chull_crv):\n    #   rs.ReverseCurve(boundary)\n\n    #b = rs.CurvePoints(boundary) + rs.CurvePoints(chull_crv)\n    #c = rs.CurvePoints(chull_crv)\n    return (boundary,chull_crv),top_curves\n\n\n# DECOMPOSE BOUNDARY CURVE\ndef mesh2curve(lof,lov):\n    \"\"\"convert list of face vertices into closed planar curves\"\"\"\n    L = []\n    for i,fv in enumerate(lof):\n        if fv[2] == fv[3]:\n            # triangle face\n            fv = [fv[0],fv[1],fv[2],fv[0]]\n        else:\n            # quad face\n            fv = [fv[0],fv[1],fv[2],fv[3],fv[0]]\n        L.append(rs.AddCurve(map(lambda fi: lov[fi], fv),1))\n    return L\n\ndef checkConcaveConvex(curve):\n    CH = ConvexHull2d()\n    curve_pts = rs.CurvePoints(curve)\n    curve_pts.pop(-1)\n    chull_pts = CH.convex_hull(curve_pts)\n    \n    if len(chull_pts) == len(curve_pts): # no need to mesh\n        meshcurves = curve\n        ##print 'is convex' ## for testing\n    else:\n        meshParam = Rhino.Geometry.MeshingParameters.Coarse\n        mesh = Rhino.Geometry.Mesh.CreateFromPlanarBoundary(curve,meshParam)\n        mesh = sc.doc.Objects.AddMesh(mesh)\n        vertice_lst = rs.MeshVertices(mesh)\n        face_lst = rs.MeshFaceVertices(mesh)\n        meshcurves = mesh2curve(face_lst,vertice_lst)\n        ## print 'is concave' ## for testing\n    return meshcurves\n\n\ndef main(north,_boundary,timeperiod,monthRange,location,height):\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        latitude,longitude,timeZone,elevation = readLocation(location)\n        year = datetime.datetime.now().year\n        day = 21\n        s_mth,e_mth = MONTH_DICT[monthRange][0], MONTH_DICT[monthRange][1] \n        s_snoon = get_solarnoon(s_mth,year,timeZone,day,latitude,longitude)\n        e_snoon = get_solarnoon(e_mth,year,timeZone,day,latitude,longitude)\n        \n        \"\"\"solar variables\"\"\"\n        shourlst,ehourlst,day = getSolarData(timeperiod,s_snoon,e_snoon)\n    \n        \"\"\"work with curves\"\"\"\n        \n        curve_ = rs.coercecurve(_boundary, -1, True)\n        boundary_lst = checkConcaveConvex(curve_)\n    \n        chull_lst = []\n        top_lst = [] # for testing purposes\n        if type(boundary_lst) != type([]):\n            boundary_lst = [_boundary]\n    \n        for boundary_ in boundary_lst:\n            boundary = clean_curve(boundary_)\n            bcurve,tc = getSolarGeom(boundary,height,latitude,\\\n            shourlst,ehourlst,day,north,longitude,timeZone,s_mth,e_mth)\n            chull_lst.append(bcurve)\n            top_lst.extend(tc)\n    \n        b2ch = Curve2ConvexHull3d()\n        breplst,ptlst = b2ch.get_convexhull(chull_lst)\n    \n        L = map(lambda m: rs.coercebrep(m),breplst)\n        CB = CleanBrep(TOL,L)\n        map(lambda id: sc.doc.Objects.Delete(id,True), breplst) #delete breplst\n        return CB.cleanBrep()\n        ##bcurve = boundary_lst ## for testing purposes\n        ##top_curves = top_lst ## for testing purposes\n    else:\n        print \"You should first let the Ladybug fly...\"\n        ghenv.Component.AddRuntimeMessage(ERROR_W, \"You should first let the Ladybug fly...\")\n\nMONTH_DICT = {0:(3,6), 1:(3,9), 2:(3,12),\\\n              3:(6,9), 4:(6,12),\\\n              5:(9,12)}\nTOL = sc.doc.ModelAbsoluteTolerance\nERROR_W = gh.GH_RuntimeMessageLevel.Warning\n\n\"\"\"\nGet monthrange based on month references.\nDefault is Jun 21 - Sep 21.\n---\n0 = Mar 21 - Jun 21\n1 = Mar 21 - Sep 21\n2 = Mar 21 - Dec 21\n3 = Jun 21 - Sep 21\n4 = Jun 21 - Dec 21\n5 = Sep 21 - Dec 21\n\"\"\"\nif not _monthRange:\n    _monthRange = 3\nif not north_:\n    north_ = 0\nif _boundary and _requiredHours and _location and _height:\n    solarFan = main(north_,_boundary,_requiredHours,int(_monthRange),_location,_height)\nelse:\n    print \"At least one of the inputs is missing!\"\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}