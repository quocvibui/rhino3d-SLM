{
  "source_url": "https://github.com/ibois-epfl/Manis-timber-plate-joinery-solver/blob/9b0d22db181d4f55f01816440a5c0a31cda502bc/Gh%20compilation%20files/thicken.py",
  "repo": "ibois-epfl/Manis-timber-plate-joinery-solver",
  "repo_stars": 12,
  "repo_description": "A grasshopper plugin to create joints between timber panels and export CNC toolpath and robot trajectories for fully automated workflow from design to fabrication to assembly.",
  "license": "MIT",
  "filepath": "Gh compilation files/thicken.py",
  "instruction": "Scale the plates while keeping faces planar.",
  "code": "\"\"\"Scale the plates while keeping faces planar.\"\"\"\r\n\r\nfrom ghpythonlib.componentbase import dotnetcompiledcomponent as component\r\nimport Grasshopper, GhPython\r\nimport System\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as rg\r\nimport math\r\nimport scriptcontext\r\n\r\n__author__ = \"Nicolas Rogeau\"\r\n__laboratory__ = \"IBOIS, Laboratory for Timber Construction\" \r\n__university__ = \"EPFL, Ecole Polytechnique Federale de Lausanne\"\r\n__funding__ = \"NCCR Digital Fabrication, ETH Zurich\"\r\n__version__ = \"2021.09\"\r\n\r\n\r\nclass MyComponent(component):\r\n    def __new__(cls):\r\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\r\n            \"Thicken plates\", \"Thicken\", \"\"\"Scale the plates while keeping faces planar.\"\"\", \"Manis\", \"Utility\")\r\n        return instance\r\n    \r\n    def get_ComponentGuid(self):\r\n        return System.Guid(\"73376a07-b918-43c0-8a29-1fab470a5cd0\")\r\n    \r\n    def SetUpParam(self, p, name, nickname, description):\r\n        p.Name = name\r\n        p.NickName = nickname\r\n        p.Description = description\r\n        p.Optional = True\r\n    \r\n    def RegisterInputParams(self, pManager):\r\n        p = Grasshopper.Kernel.Parameters.Param_Brep()\r\n        self.SetUpParam(p, \"breps\", \"breps\", \"Plate breps to scale.\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_Number()\r\n        self.SetUpParam(p, \"new_thickness\", \"new_thickness\", \"New thickness for to the plates.\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n        p = Grasshopper.Kernel.Parameters.Param_Number()\r\n        self.SetUpParam(p, \"proportion\", \"proportion\", \"(Optional) Change the direction of the scaling (from 0 to 1, default = 0.5).\")\r\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\r\n        self.Params.Input.Add(p)\r\n        \r\n    \r\n    def RegisterOutputParams(self, pManager):\r\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\r\n        self.SetUpParam(p, \"breps\", \"breps\", \"Updated breps.\")\r\n        self.Params.Output.Add(p)\r\n        \r\n    \r\n    def SolveInstance(self, DA):\r\n        p0 = self.marshal.GetInput(DA, 0)\r\n        p1 = self.marshal.GetInput(DA, 1)\r\n        p2 = self.marshal.GetInput(DA, 2)\r\n        result = self.RunScript(p0, p1, p2)\r\n\r\n        if result is not None:\r\n            self.marshal.SetOutput(result, DA, 0, True)\r\n        \r\n    def get_Internal_Icon_24x24(self):\r\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAAC0SURBVEhL7ZJbCsMwDARzph4213UtURmxGT9qkp9SwQTtSmgx5CilPAqaPV7nWT7gnECTSMcdnfewsm/tm3HRejzQPdKt0YFqa9Lx5uueahczoiTAi/YzaCpRWwG2s0oE0GwAmshWQH3GckXAN/UPmNYPBFx+qwERQLMBaCJbAfaKVSJA/RFo9tgKiKckA7U1OSB83VPdGh1kHYcV3SPtYoYVHPei/QyaRD2aQ3CHQPM+yvEGLDPifQrgf5IAAAAASUVORK5CYII=\"\r\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\r\n\r\n    \r\n    def RunScript(self, breps, new_thickness, proportion):\r\n\r\n        def surface_centroid(surface):\r\n            surface = rs.coercesurface(surface)\r\n            return rg.AreaMassProperties.Compute(surface).Centroid\r\n\r\n        def sort_surfaces_by_altitude(planar_surfaces):\r\n            faces = planar_surfaces\r\n            faces_tuples = []\r\n            for i in range(len(faces)):\r\n                face_centroid = surface_centroid(faces[i])\r\n                faces_tuples.append([faces[i],face_centroid[2]])\r\n            sortedfaces = sorted(faces_tuples, key=lambda faces: faces[1])\r\n            return sortedfaces\r\n\r\n        def sort_surfaces_by_area(planar_surfaces):\r\n            faces = planar_surfaces\r\n            faces_tuples = []\r\n            for face in faces:\r\n                face = rg.BrepFace.DuplicateFace(face, False)\r\n                face_area = rg.Brep.GetArea(face)\r\n                faces_tuples.append([face,face_area])\r\n            sortedfaces = sorted(faces_tuples, key=lambda faces: faces[1])\r\n            return sortedfaces\r\n\r\n        def get_face_largest_contour(face):\r\n            if str(face.ObjectType) == 'Surface':\r\n                face = rg.Brep.CreateFromSurface(face)\r\n            curves = rg.Brep.DuplicateEdgeCurves(face)\r\n            borders = rg.Curve.JoinCurves(curves)\r\n            curves_tuples = []\r\n            for i in range(len(borders)):\r\n                surface = rg.Brep.CreatePlanarBreps(borders[i])\r\n                area = rg.AreaMassProperties.Compute(surface).Area\r\n                curves_tuples.append([borders[i], area])\r\n            sortedcurves = sorted(curves_tuples, key=lambda curves: curves[1])\r\n            sortedcurves.reverse()\r\n            perimeter = sortedcurves[0][0]\r\n            return perimeter\r\n\r\n        def resimplify_Curve(curve):\r\n            \"\"\"Simplify and change curve seam if it's not already a vertice\"\"\"\r\n\r\n            curve=scriptcontext.doc.Objects.Add(curve)\r\n            vertices = rs.PolylineVertices(curve)\r\n            best_candidate=curve\r\n            best_v_len = len(vertices)\r\n\r\n            for i in range(len(vertices)):\r\n                new_candidate = rs.CopyObject(curve)\r\n                rs.CurveSeam(new_candidate, rs.CurveClosestPoint(new_candidate,vertices[i]))\r\n                rs.SimplifyCurve(new_candidate)\r\n                v_len = len(rs.PolylineVertices(new_candidate))\r\n                if v_len < best_v_len:\r\n                    best_candidate = rs.CopyObject(new_candidate)\r\n                    best_v_len = v_len\r\n            return rs.coercecurve(best_candidate)\r\n        \r\n        def align_curve_direction(guide, curve):\r\n            if rs.CurveDirectionsMatch(curve, guide) == False: \r\n                try: rg.Curve.Reverse(curve)\r\n                except: rs.ReverseCurve(curve)\r\n            return curve\r\n\r\n        def line_to_vec(line, unitize=False):\r\n            \"\"\"get a vector from a line\"\"\"\r\n            vec = rs.VectorCreate(rs.CurveEndPoint(line),rs.CurveStartPoint(line))\r\n            if unitize is True:\r\n                vec = rs.VectorUnitize(vec)\r\n            return vec\r\n\r\n        def curve_seam(curve, point):\r\n            return rs.CurveSeam(curve, rs.CurveClosestPoint(curve, point))\r\n\r\n        def match_seams(curve1, curve2, simplify=True):\r\n                            \"\"\"match the seam of two curves that have parallel segments\"\"\"\r\n\r\n                            if simplify is True:\r\n                                curve1=resimplify_Curve(curve1)\r\n                                curve2=resimplify_Curve(curve2)\r\n                            curve2 = align_curve_direction(rs.coercecurve(curve1),rs.coercecurve(curve2))\r\n                            curve1=scriptcontext.doc.Objects.Add(curve1)\r\n                            curve2=scriptcontext.doc.Objects.Add(curve2)\r\n                            seg1 = rs.ExplodeCurves(curve1)\r\n                            seg2 = rs.ExplodeCurves(curve2)\r\n                            shift = None\r\n\r\n                            if len(seg1) == len(seg2):\r\n                                for i in range(len(seg2)):\r\n                                    flag = True\r\n                                    for j in range(len(seg1)):\r\n                                        vec1 = line_to_vec(seg2[(i+j)%len(seg2)])\r\n                                        vec2 = line_to_vec(seg1[j])\r\n                                        if rs.IsVectorParallelTo(vec1,vec2) != 1:\r\n                                            flag = False\r\n                                    if flag == True:\r\n                                        shift = i\r\n                                        break\r\n                            else: raise Exception(\"polylines have a different number of segments\")\r\n                            if shift == None: raise Exception(\"polyline segments are not parallel\")\r\n                            else:\r\n                                points = rs.PolylineVertices(curve2)\r\n\r\n                                curve_seam(curve2, points[shift])\r\n                                rs.coercecurve(curve2)\r\n                            curve1 = rs.coercecurve(curve1)\r\n                            curve2 = rs.coercecurve(curve2)\r\n                            return [curve1,curve2]\r\n                \r\n        def brep_from_2_poly(poly1, poly2):\r\n                            poly2 = align_curve_direction(rs.coercegeometry(poly1), rs.coercegeometry(poly2))\r\n                            poly2 = rs.AddPolyline(rs.PolylineVertices(poly2)+[rs.PolylineVertices(poly2)[0]])\r\n                            poly1, poly2 = match_seams(rs.coercecurve(poly1),rs.coercecurve(poly2))\r\n                            points_a = rs.PolylineVertices(poly1)\r\n                            points_b = rs.PolylineVertices(poly2)\r\n                            faces = []\r\n                            if len(points_a) == len(points_b):\r\n                                for i in range(len(points_a)-1):\r\n                                    poly = rs.AddPolyline([(points_a[i]), (points_a[i+1]), (points_b[i+1]), (points_b[i]), (points_a[i])])\r\n                                    faces.append(rs.AddPlanarSrf(poly)[0])\r\n                            brep = rs.JoinSurfaces(faces)\r\n                            rs.CapPlanarHoles(brep)\r\n                            return rs.coercebrep(brep)\r\n\r\n        if proportion is None: proportion = 0.5\r\n        new_breps = []\r\n        for brep in breps:\r\n            #faces\r\n            faces= brep.Faces\r\n            sortedfaces = sort_surfaces_by_area(faces)\r\n            sortedfaces.reverse()\r\n            top_and_bottom = [sortedfaces[0][0],sortedfaces[1][0]]\r\n            bottom_face = sort_surfaces_by_altitude(top_and_bottom)[0][0]\r\n            top_face = sort_surfaces_by_altitude(top_and_bottom)[1][0]\r\n        \r\n            #contour\r\n            top_contour = get_face_largest_contour(top_face)\r\n            if type(top_contour) != rg.PolylineCurve: top_contour=top_contour.ToPolyline(0.01,0.01,0.01,10000)\r\n            top_contour = resimplify_Curve(top_contour)\r\n            bottom_contour = get_face_largest_contour(bottom_face)\r\n            bottom_contour = align_curve_direction(top_contour,bottom_contour)\r\n            top_contour, bottom_contour = match_seams(top_contour, bottom_contour)\r\n            top_center = rs.CurveAreaCentroid(top_contour)[0]\r\n            thickness = rg.Point3d.DistanceTo(top_center, rg.Brep.ClosestPoint(bottom_face, top_center))\r\n            if new_thickness != thickness and new_thickness != None : \r\n                normal = rs.CurveNormal(top_contour)\r\n                top_vertices = rs.PolylineVertices(top_contour)\r\n                bottom_vertices = rs.PolylineVertices(bottom_contour)\r\n                for i in range(len(bottom_vertices)):\r\n                    vec = rs.VectorCreate(top_vertices[i],bottom_vertices[i])\r\n                    vec = rs.VectorUnitize(vec)\r\n                    angle = rs.VectorAngle(normal, vec)\r\n                    factor = (new_thickness - thickness)/math.cos(math.radians(angle))\r\n                    top_vertices[i] = rs.MoveObject(top_vertices[i], factor*proportion*vec)\r\n                    bottom_vertices[i] = rs.MoveObject(bottom_vertices[i], -factor*(1-proportion)*vec)\r\n                top_contour=rs.coercecurve(rs.AddPolyline(top_vertices))\r\n                bottom_contour=rs.coercecurve(rs.AddPolyline(bottom_vertices))\r\n                new_breps.append(brep_from_2_poly(top_contour, bottom_contour))\r\n        \r\n        return new_breps\r\n\r\nclass AssemblyInfo(GhPython.Assemblies.PythonAssemblyInfo):\r\n    def get_AssemblyName(self):\r\n        return \"Thicken plates\"\r\n    \r\n    def get_AssemblyDescription(self):\r\n        return \"\"\"\"\"\"\r\n\r\n    def get_AssemblyVersion(self):\r\n        return \"0.1\"\r\n\r\n    def get_AuthorName(self):\r\n        return \"\"\r\n    \r\n    def get_Id(self):\r\n        return System.Guid(\"76b95803-ad1b-46dc-bf51-173cd45e5198\")",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}