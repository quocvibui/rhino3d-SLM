{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Basic%20Part.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Basic Part.py",
  "instruction": "Create a basic Wasp Part to be used for aggregation\n-\nProvided by Wasp 0.6\n    Args:\n        NAME: Part name\n        GEO: Part geometry. It will be converted to mesh - to improve performance, perform...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nCreate a basic Wasp Part to be used for aggregation\n-\nProvided by Wasp 0.6\n    Args:\n        NAME: Part name\n        GEO: Part geometry. It will be converted to mesh - to improve performance, perform the conversion before adding to the part and user a low-poly count\n        CONN: Connections list\n        COLL: OPTIONAL // Collider geometry (for collision detection). A collider will be automatically generated. For complex parts, automatic generation might not work, and you can add a custom collider geometry here.\n        ATTR: OPTIONAL // Part attributes\n    Returns:\n        PART: Part instance\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Basic Part\"\nghenv.Component.NickName = 'Part'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"2 | Parts\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\n\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    from wasp.core import Part\n    from wasp.core import Collider\n    from wasp import global_tolerance\n    from wasp.utilities import reserved_chars\n\n\ndef main(part_name, part_geo, connections, collider, attributes):\n    \n    check_data = True\n    \n    ## check inputs\n    if part_name is None:\n        check_data = False\n        msg = \"No part name provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    elif any(char in part_name for char in reserved_chars):\n        check_data = False\n        msg = \"Part name \" + part_name + \" contains a space or one of the reserved characters: \" + reserved_chars\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n    \n    if part_geo is None:\n        check_data = False\n        msg = \"No part geometry provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n        check_data = False\n    \n    if collider is None:\n        if part_geo is not None:\n            collider_geo = part_geo.Duplicate().Offset(global_tolerance)\n            collider_intersection = rg.Intersect.Intersection.MeshMeshFast(collider_geo, part_geo)\n            if len(collider_intersection) > 0:\n                collider_geo = None\n                collider_geo = part_geo.Duplicate()\n                center = part_geo.GetBoundingBox(True).Center\n                scale_plane = rg.Plane(center, rg.Vector3d(1,0,0), rg.Vector3d(0,1,0))\n                scale_transform = rg.Transform.Scale(scale_plane, 1-global_tolerance, 1-global_tolerance, 1-global_tolerance)\n                collider_geo.Transform(scale_transform)\n                collider_intersection = rg.Intersect.Intersection.MeshMeshFast(collider_geo, part_geo)\n                if len(collider_intersection) > 0:\n                    collider_geo = None\n                    msg = \"Could not compute a valid collider geometry. Please provide a valid collider in the COLL input.\"\n                    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n                    check_data = False\n            \n            if collider_geo is not None:\n                collider = Collider([collider_geo])\n            \n    else:\n        if type(collider) != Collider:\n            if type(collider) == rg.Mesh:\n                collider = Collider([collider])\n            else:\n                msg = \"Collider geometry must be of type Mesh or WaspCollider.\"\n                ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n                check_data = False\n        \n    if collider is not None and collider.faces_count > 1000:\n        msg = \"The collider has a high faces count. Consider providing a low poly collider to improve performance\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    \n    if check_data:\n        new_part = Part(part_name, part_geo, connections, collider, attributes)\n        \n        if new_part.dim < global_tolerance*10:\n            msg = \"The parts you created are very small. You might consider scaling them or decreasing the tolerance of your Rhino file.\"\n            ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n        \n        return new_part\n    else:\n        return -1\n\n\nresult = main(NAME, GEO, CONN, COLL, ATTR)\n\nif result != -1:\n    PART = result",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}