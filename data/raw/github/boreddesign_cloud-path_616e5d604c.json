{
  "source_url": "https://github.com/boreddesign/cloud-path/blob/170d1772505d0e9873582791b3c366bb9216af0f/rhino_to_json.py",
  "repo": "boreddesign/cloud-path",
  "repo_stars": 0,
  "repo_description": "CAD 2D to 3D Loft Visualizer - Cloud-based web application for visualizing 2D profiles extruded along paths",
  "license": "unknown",
  "filepath": "rhino_to_json.py",
  "instruction": "Rhino to JSON Converter for CAD Loft Visualizer",
  "code": "\"\"\"\nRhino to JSON Converter for CAD Loft Visualizer\n\nThis script exports Rhino geometry (curves, polylines, arcs, circles) to JSON format\nwith start/end points, geometry type, and arc/circle properties for accurate geometry sampling.\n\nExported Properties:\n- type: line, arc, circle, polyline, curve\n- start, end: endpoint coordinates [x, y] or [x, y, z]\n- center (arcs/circles): center point coordinates\n- radius (arcs/circles): radius value\n- clockwise (arcs/circles): direction of arc/circle\n- closed: whether the curve is closed\n\nUsage in Rhino:\n1. Open this script in Rhino's Python editor\n2. Select your geometry (profile or path)\n3. Run the script\n4. Choose whether it's a profile (2D) or path (2D/3D)\n5. The JSON file will be saved\n\nRequirements:\n- Rhino 6 or later with Python support\n- rhinoscriptsyntax module\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport json\nimport math\n\ndef point_to_array(point, is_profile=False):\n    \"\"\"\n    Convert a Rhino point to array format\n    \n    Args:\n        point: Rhino point (list or tuple)\n        is_profile: If True, returns 2D [x, y]. If False, returns 3D [x, y, z]\n    \n    Returns:\n        Point as [x, y] or [x, y, z]\n    \"\"\"\n    if is_profile:\n        return [float(point[0]), float(point[1])]\n    else:\n        z = float(point[2]) if len(point) > 2 else 0.0\n        return [float(point[0]), float(point[1]), z]\n\n\ndef get_curve_endpoints(curve_id):\n    \"\"\"\n    Get start and end points of a curve\n    \n    Args:\n        curve_id: Rhino object ID of the curve\n    \n    Returns:\n        Tuple of (start_point, end_point) or None if failed\n    \"\"\"\n    try:\n        domain = rs.CurveDomain(curve_id)\n        if domain is None:\n            return None\n        \n        start_point = rs.EvaluateCurve(curve_id, domain[0])\n        end_point = rs.EvaluateCurve(curve_id, domain[1])\n        \n        if start_point and end_point:\n            return (start_point, end_point)\n    except:\n        pass\n    \n    return None\n\n\ndef geometry_to_segment(obj_id, is_profile=False):\n    \"\"\"\n    Convert a Rhino geometry object to a segment with type and endpoints\n    \n    Args:\n        obj_id: Rhino object ID\n        is_profile: If True, uses 2D points. If False, uses 3D points\n    \n    Returns:\n        Dictionary with 'type', 'start', 'end', and optionally 'center', 'radius', 'clockwise', 'closed'\n    \"\"\"\n    obj_type = rs.ObjectType(obj_id)\n    \n    if obj_type != rs.filter.curve:\n        return None\n    \n    segment = {}\n    \n    # Determine geometry type\n    if rs.IsLine(obj_id):\n        segment['type'] = 'line'\n    elif rs.IsArc(obj_id):\n        segment['type'] = 'arc'\n        # Extract arc properties for accurate arc sampling\n        try:\n            arc_center = rs.ArcCenterPoint(obj_id)\n            arc_radius = rs.ArcRadius(obj_id)\n            \n            if arc_center and arc_radius:\n                segment['center'] = point_to_array(arc_center, is_profile)\n                segment['radius'] = float(arc_radius)\n                \n                # Determine arc direction (clockwise or counterclockwise)\n                # Get arc plane to determine direction\n                arc_plane = rs.ArcPlane(obj_id)\n                if arc_plane:\n                    # Check if arc normal points up (counterclockwise) or down (clockwise)\n                    # For 2D profiles, check Z component of normal\n                    normal = arc_plane[3]  # Normal vector is the 4th element of plane\n                    if is_profile:\n                        # For profiles in XY plane, Z > 0 means counterclockwise\n                        segment['clockwise'] = (normal[2] < 0)\n                    else:\n                        # For 3D paths, use the same logic\n                        segment['clockwise'] = (normal[2] < 0)\n        except:\n            # If arc properties fail, continue without them\n            # Fallback will handle it\n            pass\n    elif rs.IsCircle(obj_id):\n        segment['type'] = 'circle'\n        segment['closed'] = True\n        # Extract circle properties\n        try:\n            circle_center = rs.CircleCenterPoint(obj_id)\n            circle_radius = rs.CircleRadius(obj_id)\n            \n            if circle_center and circle_radius:\n                segment['center'] = point_to_array(circle_center, is_profile)\n                segment['radius'] = float(circle_radius)\n                \n                # Determine circle direction\n                circle_plane = rs.CirclePlane(obj_id)\n                if circle_plane:\n                    normal = circle_plane[3]\n                    if is_profile:\n                        segment['clockwise'] = (normal[2] < 0)\n                    else:\n                        segment['clockwise'] = (normal[2] < 0)\n        except:\n            # If circle properties fail, continue without them\n            pass\n    elif rs.IsPolyline(obj_id):\n        segment['type'] = 'polyline'\n        # For polylines, get first and last vertices\n        vertices = rs.PolylineVertices(obj_id)\n        if vertices and len(vertices) >= 2:\n            segment['start'] = point_to_array(vertices[0], is_profile)\n            segment['end'] = point_to_array(vertices[-1], is_profile)\n            if rs.IsCurveClosed(obj_id):\n                segment['closed'] = True\n            return segment\n    else:\n        # Generic curve\n        segment['type'] = 'curve'\n    \n    # Get start and end points\n    endpoints = get_curve_endpoints(obj_id)\n    if endpoints:\n        segment['start'] = point_to_array(endpoints[0], is_profile)\n        segment['end'] = point_to_array(endpoints[1], is_profile)\n        \n        # Check if closed\n        if rs.IsCurveClosed(obj_id):\n            segment['closed'] = True\n        \n        return segment\n    \n    return None\n\n\ndef export_to_json():\n    \"\"\"\n    Main function to export selected Rhino geometry to JSON\n    \"\"\"\n    # Get selected objects\n    obj_ids = rs.GetObjects(\"Select geometry to export (curves, polylines, arcs, circles)\", \n                           rs.filter.curve, preselect=True)\n    \n    if not obj_ids:\n        rs.MessageBox(\"No objects selected.\", 0, \"Error\")\n        return\n    \n    # Ask user if this is a profile or path\n    result = rs.GetString(\"Is this a PROFILE (2D) or PATH (2D/3D)?\", \n                         \"PROFILE\", [\"PROFILE\", \"PATH\"])\n    \n    if not result:\n        return\n    \n    is_profile = (result == \"PROFILE\")\n    \n    # Collect segments from all selected objects\n    segments = []\n    \n    for obj_id in obj_ids:\n        segment = geometry_to_segment(obj_id, is_profile)\n        if segment:\n            segments.append(segment)\n        else:\n            rs.MessageBox(\"Failed to extract geometry from object {}\".format(obj_id), 0, \"Warning\")\n    \n    if not segments:\n        rs.MessageBox(\"No geometry extracted from selected objects.\", 0, \"Error\")\n        return\n    \n    # Get file path to save\n    default_name = \"profile.json\" if is_profile else \"path.json\"\n    file_path = rs.SaveFileName(\"Save JSON file\", \"JSON Files (*.json)|*.json||\", \"\", default_name)\n    \n    if not file_path:\n        return\n    \n    # Write JSON file\n    try:\n        with open(file_path, 'w') as f:\n            json.dump(segments, f, indent=2)\n        \n        rs.MessageBox(\"Successfully exported {} segments to:\\n{}\".format(len(segments), file_path), \n                     0, \"Export Complete\")\n        \n        print(\"Exported {} segments to {}\".format(len(segments), file_path))\n        print(\"Type: {}\".format(\"Profile (2D)\" if is_profile else \"Path (2D/3D)\"))\n        \n    except Exception as e:\n        rs.MessageBox(\"Error saving file: {}\".format(str(e)), 0, \"Error\")\n\n\n# Run the export function\nif __name__ == \"__main__\":\n    export_to_json()\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}