{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/surfaces.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/surfaces.py",
  "instruction": "Surfaces",
  "code": "import System\nimport rhinoscriptsyntax as rs\nimport helpers\nimport Grasshopper.Kernel as ghK\nimport Rhino\nimport math\nimport random\nfrom collections import namedtuple\n\ntry:  # import the core honeybee dependencies\n    from honeybee.boundarycondition import Surface, Outdoors, Ground, Adiabatic\n    from honeybee.facetype import Wall, RoofCeiling, Floor\n    import ladybug_geometry\n    from ladybug_rhino.togeometry import to_face3d\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\n\nclass Temp_Surface:\n    \"\"\" A temporary holder for some surface stuff. Used to be just a nametuple.. \"\"\"\n\n    def __init__(self, _geom=None, _params=None):\n        self.geom = _geom\n        self.params = _params\n\n    def __iter__(self):\n        return (i for i in (self.geom, self.params))\n\n    def __unicode__(self):\n        return u'A Temporary Surface with Geom and Params'\n\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n\n    def __repr__(self):\n        return \"_geom={!r}, _params={!r}\".format(self.geom, self.params)\n\n\nclass hb_surface:\n    \"\"\" Simple class to organize data for a 'surface'. Used to set up data for a HB-Face Component\n\n    Args:\n        _srfc: <Surface> A single 'Surface' object with .geom and .param properties\n        _constructions: <Dict> A dict of all the EP Constructions\n        _ghenv: The Grasshopper 'ghenv' object from the active scene\n    Properties:\n        * geometry\n        * name\n        * type\n        * type_legacy\n        * bc\n        * const \n        * rad_mod   \n    \"\"\"\n\n    srfc_type_schema = {\n        'Wall': {'legacy': 0, 'lbt1': 'Wall'},\n        'WALL': {'legacy': 0, 'lbt1': 'Wall'},\n        'UndergroundWall': {'legacy': 0.5, 'lbt1': 'Wall'},\n        'ROOF': {'legacy': 1, 'lbt1': 'RoofCeiling'},\n        'Roof': {'legacy': 1, 'lbt1': 'RoofCeiling'},\n        'UndergroundCeiling': {'legacy': 1.5, 'lbt1': 'Wall'},\n        'FLOOR': {'legacy': 2, 'lbt1': 'Floor'},\n        'Floor': {'legacy': 2, 'lbt1': 'Floor'},\n        'UndergroundSlab': {'legacy': 2.25, 'lbt1': 'Floor'},\n        'SlabOnGrade': {'legacy': 2.5, 'lbt1': 'Floor'},\n        'ExposedFloor': {'legacy': 2.75, 'lbt1': 'Floor'},\n        'RoofCeiling': {'legacy': 3, 'lbt1': 'RoofCeiling'},\n        'CEILING': {'legacy': 3, 'lbt1': 'RoofCeiling'},\n        'AIRWALL': {'legacy': 4, 'lbt1': 'AirBoundary'},\n        'WINDOW':  {'legacy': 5, 'lbt1': 'Wall'},\n        'SHADING': {'legacy': 6, 'lbt1': 'Wall'}\n    }\n\n    def __init__(self, _srfc, _constructions):\n        self.id = random.randint(1000, 9999)\n        self.geometry = _srfc.geom\n        self.params = _srfc.params\n        self.constructions = _constructions\n        self.rad_mod = None\n\n    def check_surface_names(self):\n        \"\"\" Used to provide the user warnings if surfaces without names are found. \"\"\"\n\n        nm = self.params.get('Object Name', None)\n        warning = None\n\n        if nm is None or nm == 'None':\n            warning = \"Warning: Some Surfaces look like they are missing names? It is possible that\\n\"\\\n                \"the Honeybee 'solveAdjc' component will not work correctly without names.\\n\"\\\n                \"This is especially true for 'interior' surfaces up against other thermal zones.\\n\"\\\n                \"If you run into trouble later, maybe try applying a unique name to all surfaces.\\n\"\\\n                \"For now, I will apply a random/default name to each surface.\"\n\n        return warning\n\n    def _add_ext_flag_to_name(self, _ud_value):\n        \"\"\" So that the EP Results can be properly sorted at the very end, add an EXT or INT flag to the srfc\"\"\"\n\n        if self.bc is None:\n            return 'EXT_' + str(_ud_value)\n        elif 'Adiabatic' in self.bc:\n            return 'INT_' + str(_ud_value)\n        else:\n            return 'EXT_' + str(_ud_value)\n\n    def _get_srfc_type(self, _ud_value, _version):\n        try:\n            assert type(_ud_value) == str, '_ud_value input should be str'\n            return self.srfc_type_schema.get(_ud_value, {_version: 'Wall'}).get(_version, 'Wall')\n        except:\n            return 'Wall'\n\n    @property\n    def name(self):\n        default_name = 'No_Name_{}'.format(self.id)\n\n        try:\n            ud_value = self.params.get('Object Name', default_name)\n            if str(ud_value) == 'None':\n                ud_value = default_name\n\n            ud_value = self._add_ext_flag_to_name(ud_value)\n            return ud_value\n        except:\n            return default_name\n\n    @property\n    def type(self):\n        ud_value = self.params.get('srfType', 'Wall')\n        return self._get_srfc_type(ud_value, 'lbt1')\n\n    @property\n    def type_legacy(self):\n        \"\"\"Exposure type used by old 'Legacy' Honeybee \"\"\"\n\n        ud_value = self.params.get('srfType', 'Wall')\n        return self._get_srfc_type(ud_value, 'legacy')\n\n    @property\n    def bc(self):\n        return self.params.get('EPBC', 'Outdoors')\n\n    @property\n    def const(self):\n        ud_value = self.params.get('EPConstruction', None)\n        if not ud_value:\n            return None\n\n        ud_value = 'PHPP_CONST_' + str(ud_value).upper()\n        ud_value = ud_value.replace(' ', '_')\n\n        return self.constructions.get(ud_value, ud_value)\n\n\nclass PHPP_Surface:\n    def __init__(self, _lbt_face, _rm_name, _rm_id, _scene_north_vec, _ghenv):\n        self.lbt_srfc = _lbt_face\n        self.HostZoneName = _rm_name\n        self.HostZoneID = _rm_id\n        self.scene_north_vector = self.calc_scene_north_vector(_scene_north_vec)\n        self.ghenv = _ghenv\n        self.Factor_Shading = 0.5\n        self.Factor_Absorptivity = 0.6\n        self.Factor_Emissivity = 0.9\n\n    def calc_scene_north_vector(self, _input_vector):\n        ''' \n        Arguments:\n            _input_vector: Vector2d or an anlge representing the scene's North direction \n        Returns:\n            north_vector:\n        '''\n\n        default_north_vector = Rhino.Geometry.Vector2d(0, 1)\n\n        if _input_vector is None:\n            return default_north_vector\n\n        if isinstance(_input_vector, ladybug_geometry.geometry2d.pointvector.Vector2D):\n            return _input_vector\n\n        if isinstance(_input_vector, Rhino.Geometry.Vector2d):\n            return _input_vector\n\n        # If its an angle input, create the vector from the angle\n        try:\n            angle = float(_input_vector)\n            return angle\n        except:\n            return default_north_vector\n\n    @property\n    def Name(self):\n        try:\n            lbt_srfc_name = self.lbt_srfc.display_name\n            clean_name = lbt_srfc_name.replace('EXT_', '').replace('INT_', '')\n            return clean_name\n        except Exception as e:\n            print('Error getting name from the LBT Face?', e)\n            return 'NameError'\n\n    @property\n    def identifier(self):\n        try:\n            lbt_srfc_identifier = self.lbt_srfc.identifier\n            clean_identifier = lbt_srfc_identifier.replace(\n                'EXT_', '').replace('INT_', '')\n            return clean_identifier\n        except Exception as e:\n            print('Error getting idetifier from the LBT Face?', e)\n            return 'NameError'\n\n    @property\n    def AssemblyName(self):\n        try:\n            lbt_val = self.lbt_srfc.properties.energy.construction.display_name\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Face Construction?', e)\n            return None\n\n    @property\n    def Assembly_ID(self):\n        try:\n            lbt_val = self.lbt_srfc.properties.energy.construction.identifier\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Face Construction Identifier?', e)\n            return None\n\n    @property\n    def exposure(self):\n        try:\n            lbt_exposure = self.lbt_srfc.boundary_condition\n            return lbt_exposure\n        except Exception as e:\n            print('Error getting the LBT BC?', e)\n            return None\n\n    @property\n    def type(self):\n        try:\n            lbt_type = self.lbt_srfc.type\n            return lbt_type\n        except Exception as e:\n            print('Error getting the LBT Surface Type?', e)\n            return None\n\n    @property\n    def GroupNum(self):\n        ''' Figure out the 'Group Number' for PHPP based on the Srfc exposure & type '''\n\n        bc = self.exposure\n        face_type = self.type\n\n        if isinstance(bc, (Surface)):\n            return None\n        elif isinstance(face_type, Wall) and isinstance(bc, (Outdoors)):\n            return 8\n        elif isinstance(face_type, Wall) and isinstance(bc, (Ground)):\n            return 9\n        elif isinstance(face_type, RoofCeiling) and isinstance(bc, (Outdoors)):\n            return 10\n        elif isinstance(face_type, Floor) and isinstance(bc, (Ground)):\n            return 11\n        elif isinstance(face_type, Floor) and isinstance(bc, (Outdoors)):\n            return 12\n        elif isinstance(bc, (Adiabatic)):\n            return 18\n        else:\n            groupWarning = \"Couldn't figure out the Group Number for surface '{self.Name}'?\\n\"\\\n                \"It appears to have an exposure of: '{self.exposure}' and a type of: '{self.type}'?\\n\"\\\n                \"I will give this surface a group type of 13. You may want to overwrite that in PHPP.\".format(\n                    self=self)\n            self.ghenv.Component.AddRuntimeMessage(\n                ghK.GH_RuntimeMessageLevel.Warning, groupWarning)\n            return 13\n\n    @property\n    def SurfaceArea(self):\n        try:\n            lbt_val = self.lbt_srfc.area\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Surface Area?', e)\n            return None\n\n    @property\n    def NormalVector(self):\n        try:\n            lbt_val = self.lbt_srfc.normal\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Surface Normal?', e)\n            return None\n\n    @property\n    def Srfc(self):\n        try:\n            lbt_val = self.lbt_srfc.geometry\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Surface Geometry?', e)\n            return None\n\n    @property\n    def AngleFromHoriz(self):\n        up_vec = Rhino.Geometry.Vector3d(0, 0, 1)\n        face_normal_vec = self.NormalVector\n\n        angle = rs.VectorAngle(up_vec, face_normal_vec)\n        return angle\n\n    @property\n    def AngleFromNorth(self):\n        ''' Uses the Surface's Normal Vector and the project's north angle\n        vector and computes the clockwise orientation angle 0--360 between them\n\n        http://frasergreenroyd.com/obtaining-the-angle-between-two-vectors-for-360-degrees/\n        Results 0=north, 90=east, 180=south, 270=west\n        Arguments:\n            None\n        Returns: \n            angle: the angle off North for the surface (Degrees) clockwise from 0\n        '''\n\n        # Get the input Vector's X and Y parts\n        x1 = self.NormalVector.x\n        y1 = self.NormalVector.y\n\n        # Note: ladybug_geometry vectors use lowercase 'x', Rhino uses uppercase 'X'\n        try:\n            x2 = self.scene_north_vector.X\n            y2 = self.scene_north_vector.Y\n        except AttributeError as e:\n            x2 = self.scene_north_vector.x\n            y2 = self.scene_north_vector.y\n\n        # Calc the angle between the vectors\n        angle = math.atan2(y2, x2) - math.atan2(y1, x1)\n        angle = angle * 360 / (2 * math.pi)\n\n        if angle < 0:\n            angle = angle + 360\n\n        # Return Angle in Degrees\n        return angle\n\n    @property\n    def Centroid(self):\n        try:\n            lbt_val = self.lbt_srfc.geometry.centroid\n            return lbt_val\n        except Exception as e:\n            print('Error getting the LBT Surface Centroid?', e)\n            return None\n\n    def __unicode__(self):\n        return u'A PHPP-Style Surface Object: < {} >'.format(self.Name)\n\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n\n    def __repr__(self):\n        return \"{}(_lbt_face={!r})\".format(\n            self.__class__.__name__, self.lbt_srfc)\n\n\ndef get_input_geom(_input_list, _ghenv):\n    \"\"\"Gets geom and guid from whatever objects are input as the '_srfcs' \"\"\"\n\n    _input_num = 0\n    output = []\n    Geom = namedtuple('Geom', ['geom', 'guid'])\n\n    for i, input_obj in enumerate(_input_list):\n        if not input_obj:\n            continue\n\n        # Get the GUID of the item being input into the component's 0-pos input\n        input_guid = _ghenv.Component.Params.Input[_input_num].VolatileData[0][i].ReferenceID\n        rh_obj = Rhino.RhinoDoc.ActiveDoc.Objects.Find(input_guid)\n\n        if rh_obj:\n            # Must be some Rhino Geometry being input\n            # Try and explode any multi-surface Breps\n            # If that fails, must be a Mesh, just pass along without exploding.\n            geom = rs.coercegeometry(rh_obj)\n\n            # Try and convert whatever it is into a Brep (for Extrusions, etc.)\n            try:\n                geom = geom.ToBrep()\n            except AttributeError as e:\n                pass\n\n            try:\n                for srfc in geom.Faces:\n                    output.append(Geom(srfc, input_guid))\n            except AttributeError as e:\n                output.append(Geom(geom, input_guid))\n        else:\n\n            # Must be some Grasshopper Geometry being input\n            try:\n                for srfc in input_obj.Faces:\n                    output.append(Geom(srfc, None))\n            except AttributeError as e:\n                output.append(Geom(input_obj, None))\n\n    return output\n\n\ndef get_rh_srfc_params(_input_geom, _ghenv, _ghdoc):\n    \"\"\" Pulls geom and UserText params from the Rhino scene.\n\n    Args:\n        _srfc_GUIDs: <list: Guid:> A list of the surface GUID numbers.\n        _ghenv: The <ghenv> object from the Grasshopper component calling this function\n        _ghdoc: The <ghDoc> object from the Grasshopper component calling this function\n    Returns:\n        surfaces: A List of surface objects. Each object has a .geom and a .param property\n    \"\"\"\n\n    surfaces = []\n\n    for item in _input_geom:\n        # --- Get UserText params\n        srfc_user_text = _get_surface_rh_userText(item.guid, _ghenv, _ghdoc)\n\n        new_srfc_obj = Temp_Surface(item.geom, srfc_user_text)\n        surfaces.append(new_srfc_obj)\n\n    return surfaces\n\n\ndef determine_surface_type_by_orientation(_surfaces):\n    \"\"\" Determines the 'type' of surface automatically, based on its surface normal.\n\n    Args:\n        _surfaces: <List: Surface:> A List of Surface objects with a .geom and a .params attribute.\n    Returns:\n        surface_type: A new list of Surface objs with their Surface Type modified as appropriate\n    \"\"\"\n\n    surfaces = []\n    warnings = {}\n    for srfc_geom, srfc_params in _surfaces:\n        # Code here adapted from Honeybee Legacy 'decomposeZone' method\n        # Checks the surface normal and depending on the direction,\n        # assigns it as a 'wall', 'floor' or 'roof'\n\n        def find_srfc_normal(_f):\n            centroid = Rhino.Geometry.AreaMassProperties.Compute(_f).Centroid\n            b, u, v = _f.ClosestPoint(centroid)\n            face_normal = _f.NormalAt(u, v)\n\n            return face_normal\n\n        maximumRoofAngle = 30\n        try:\n            # ---- Find the surface normal of the srfc\n            normal = find_srfc_normal(srfc_geom)\n\n            # ---- Find the surface type based on the normal\n            angle2Z = math.degrees(Rhino.Geometry.Vector3d.VectorAngle(\n                normal, Rhino.Geometry.Vector3d.ZAxis))\n\n            if angle2Z < maximumRoofAngle or angle2Z > 360 - maximumRoofAngle:\n                srfc_type = 'RoofCeiling'\n                bc = 'Outdoors'\n            elif 160 < angle2Z < 200:\n                srfc_type = 'Floor'\n                bc = 'Ground'\n\n                # ---- Warn the user if it should have been a floor,\n                # but wasn't tagged as one.\n                msg = \"I found a surface which looks like it should be a 'Floor' but is\\n\"\\\n                    \"not tagged as a floor? To correct this, either:\\n\"\\\n                    \"    1) Check your Rhino-scene surface assignnements and geometry\\n\"\\\n                    \"    2) Try setting this component's 'auto-orientation_' intput to 'True'?\"\\\n\n                ud_srfc_type = srfc_params.get('srfType')\n                floor_types = ['FLOOR', 'ExposedFloor', 'UndergroundSlab', 'SlabOnGrade']\n                if ud_srfc_type not in floor_types:\n                    warnings['Floor'] = {'level': 'Warning', 'msg': msg}\n\n            else:\n                srfc_type = 'Wall'\n                bc = 'Outdoors'\n        except:\n            print('Failed to find surface normal. Are you sure it is Brep geometry?')\n            srfc_type = 'Wall'\n            bc = 'Outdoors'\n\n        # --- Build the new surface with the modified params\n        nm = srfc_params.get('Object Name')\n        new_srfc_params = {\n            'Object Name': nm,\n            'srfType': srfc_type,\n            'EPBC': bc,\n            'EPConstruction': srfc_params.get('EPConstruction', None),\n        }\n        new_srfc_obj = Temp_Surface(srfc_geom, new_srfc_params)\n        surfaces.append(new_srfc_obj)\n\n    return surfaces, warnings\n\n\ndef _get_surface_rh_userText(_srfc_GUID, _ghdoc, _ghenv):\n    \"\"\" Takes in an objects GUID and returns the full dictionary of\n    Attribute UserText Key and Value pairs. Cleans up a bit as well.\n\n    Args:\n        _GUID: <Guid> the Rhino GUID of the surface object to try and read from\n        _ghdoc: The Grasshopper Component 'ghdoc' object\n        _ghenv: The Grasshopper Component 'ghenv' object\n    Returns:\n        output_dict: a dictionary object with all the keys / values found in the Object's UserText\n    \"\"\"\n    output_dict = {}\n\n    if not _srfc_GUID:\n        return output_dict\n\n    # Note: I know this is the wrong way to do this,\n    # but testing using \"_srfc_GUID.GetType() != System.Guid\" will cause\n    # Mac OS to crash. So test using a basic text comparison I guess....\n    # if _srfc_GUID.GetType() != System.Guid:\n    if str(type(_srfc_GUID)) != \"<type 'Guid'>\":\n        remark = \"Unable to get parameter data for the surface? If trying to pull data\\n\"\\\n            \"from Rhino, be sure the '_srfc' input Type Hint is set to 'Guid'\\n\"\\\n            \"For now, using default values for all surface parameter values.\"\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, remark)\n        return output_dict\n\n    with helpers.context_rh_doc(_ghdoc):\n        output_dict['Object Name'] = rs.ObjectName(_srfc_GUID)\n\n        for eachKey in rs.GetUserText(_srfc_GUID):\n            if 'Object Name' not in eachKey:\n                val = rs.GetUserText(_srfc_GUID, eachKey)\n                if val != 'None':\n                    output_dict[eachKey] = val\n                else:\n                    output_dict[eachKey] = None\n\n    return output_dict\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}