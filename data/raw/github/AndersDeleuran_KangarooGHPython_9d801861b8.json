{
  "source_url": "https://github.com/AndersDeleuran/KangarooGHPython/blob/234633051df016e9f9d67ef92dbb9eefd52712ce/src/RelaxCableNetworkIntoPlane.py",
  "repo": "AndersDeleuran/KangarooGHPython",
  "repo_stars": 37,
  "repo_description": "How to stuff a Kangaroo in your Python using a Grasshopper",
  "license": "unknown",
  "filepath": "src/RelaxCableNetworkIntoPlane.py",
  "instruction": "Relax cable network into plane",
  "code": "ï»¿\"\"\"\r\nRelax a cable network into the XY plane using K2.\r\n    Inputs:\r\n        AssemblyGeo: The assembly geo to get the cable network from {datatree,object}\r\n        MakePlanar: Forces the network fully planar {item,bool}\r\n        Iterations: How many times to solve {item,int}\r\n        SpringStrength: How much the cables should keep its original length {item,float}\r\n        AngleStrength: How much to keep the cable network internal node angles at their ideal {item,float}\r\n        PlaneStrength: How hard to oull the cable network nodes to the XY plane {item,float}\r\n        OpenDegreeTwo: Rotates cables that touch degree two nodes by this amount {item,float}\r\n        MakePlanar: Fully planarizes the network into the plane by zeroing the Z values {item,bool}\r\n    Outputs:\r\n        RelaxedNetwork: The flat cable network {list,line}\r\n    Remarks:\r\n        Author: Anders Holden Deleuran\r\n        License: Apache License 2.0\r\n        Version: 201104\r\n\"\"\"\r\n\r\nghenv.Component.Name = \"RelaxCableNetworkIntoPlane\"\r\nghenv.Component.NickName =\"RCNIP\"\r\nghenv.Component.Category = \"CM_FAHS\"\r\nghenv.Component.SubCategory = \"4 Topology\"\r\n\r\nimport Rhino as rc\r\nimport Grasshopper as gh\r\nimport networkx as nx\r\nimport math\r\nfrom collections import deque\r\nfrom collections import Counter\r\nimport clr\r\nclr.AddReferenceToFileAndPath(gh.Folders.PluginFolder+\"Components\\KangarooSolver.dll\")\r\nimport KangarooSolver as ks\r\nimport Grasshopper.Kernel.Types as gkt\r\nfrom System.Collections.Generic import List\r\n\r\ndef castEdges(edges):\r\n    \r\n    \"\"\" Cast edges to RhinoCommon line type \"\"\"\r\n    \r\n    cEdges = []\r\n    for e in edges:\r\n        if type(e) is rc.Geometry.Line:\r\n            cEdges.append(e)\r\n        elif type(e) is rc.Geometry.LineCurve:\r\n            cEdges.append(e.Line)\r\n        elif type(e) is rc.Geometry.PolylineCurve or type(e) is rc.Geometry.NurbsCurve:\r\n            l = rc.Geometry.Line(e.PointAtStart,e.PointAtEnd)\r\n            cEdges.append(l)\r\n    return cEdges\r\n\r\ndef openDegreeTwoNodes(cables,angle):\r\n    \r\n    \"\"\" Rotates cables that meet at a degree two nodes around their end point \"\"\"\r\n    \r\n    # Get all vertices\r\n    vts = []\r\n    for l in cables:\r\n        vts.append(l.From)\r\n        vts.append(l.To)\r\n        \r\n    # Get valence two vertices\r\n    valTwoVts = []\r\n    for pt,n in Counter(vts).iteritems():\r\n        if n == 2:\r\n            valTwoVts.append(pt)\r\n            \r\n    # Adjust cables if start point in valence two nodes\r\n    newCables = []\r\n    rotAxis = rc.Geometry.Vector3d.ZAxis\r\n    for l in cables:\r\n        if l.From in valTwoVts:\r\n            tr = rc.Geometry.Transform.Rotation(math.radians(angle),rotAxis,l.To)\r\n            l.Transform(tr)\r\n        newCables.append(l)\r\n        \r\n    return newCables\r\n\r\ndef rebuildLines(lines,roundDecimal):\r\n    \r\n    \"\"\" Rebuilds a list of lines to a tolerance decimal in place \"\"\"\r\n    \r\n    for l in lines:\r\n        l.FromX = round(l.FromX,roundDecimal)\r\n        l.FromY = round(l.FromY,roundDecimal)\r\n        l.FromZ = round(l.FromZ,roundDecimal)\r\n        l.ToX = round(l.ToX,roundDecimal)\r\n        l.ToY = round(l.ToY,roundDecimal)\r\n        l.ToZ = round(l.ToZ ,roundDecimal)\r\n        \r\n        \r\ndef sortPointsAroundCenter(pts,center):\r\n    \r\n    \"\"\" Sort a list of points radially around a center \"\"\"\r\n    \r\n    # Make plane through points and set its origin\r\n    test,plane = rc.Geometry.Plane.FitPlaneToPoints(pts)\r\n    plane.Origin = center\r\n    \r\n    # Calculate vectors from center to points\r\n    vecs = [pt - center for pt in pts]\r\n    \r\n    # Calculate angles between vectors and plane X-axis\r\n    angles = [rc.Geometry.Vector3d.VectorAngle(plane.XAxis,v,plane) for v in vecs]\r\n    \r\n    # Sort points by angles\r\n    sortedBoth = sorted(zip(angles,pts))\r\n    sortedPts = [l[1] for l in sortedBoth]\r\n    \r\n    return sortedPts,plane\r\n\r\ndef linesToGraph(lines,edgeMode):\r\n    \r\n    \"\"\" Creates a NetworkX graph from a list of lines \"\"\"\r\n    \r\n    # Create graph\r\n    graph = nx.Graph()\r\n    \r\n    # Get line endpoints\r\n    endPts = []\r\n    for l in lines:\r\n        endPts.append(l.From)\r\n        endPts.append(l.To)\r\n        \r\n    # Remove duplicate points and sort these\r\n    uniquePts = list(set(endPts))\r\n    uniquePts.sort()\r\n    \r\n    # Add nodes to graph\r\n    for i,pt in enumerate(uniquePts):\r\n        graph.add_node(i,point=pt)\r\n        \r\n    # Calculate the sum of all curve lengths\r\n    sumCurveLengths = sum([l.Length for l in lines])\r\n    avrCurveLengthPrc = (sumCurveLengths/len(lines))/sumCurveLengths\r\n    \r\n    # Add edges using edgeMode to determine the edge weight\r\n    for l in lines:\r\n        \r\n        # Match the curve endpoints with the graph nodes\r\n        startNode = uniquePts.index(l.From)\r\n        endNode = uniquePts.index(l.To)\r\n        \r\n         # Calculate curve lenght percentage by all lines length\r\n        lengthPrc = (l.Length/sumCurveLengths)\r\n        \r\n        # Add edge using metric distance i.e. curve length\r\n        if edgeMode == \"metric\":            \r\n            graph.add_edge(startNode,endNode,weight=lengthPrc,line=l) \r\n            \r\n        # Or add edge using topological distance i.e. depth\r\n        elif edgeMode == \"average\":            \r\n            graph.add_edge(startNode,endNode,weight=avrCurveLengthPrc,line=l)\r\n            \r\n    return graph\r\n\r\ndef makeShowGoals(lines):\r\n    \r\n    \"\"\" Pass the cable lines through the solver \"\"\"\r\n    \r\n    goals = []\r\n    for l in lines:\r\n        ghCrv = gkt.GH_Curve(l.ToNurbsCurve())\r\n        gow = gkt.GH_ObjectWrapper(ghCrv)\r\n        gl = ks.Goals.Locator(gow)\r\n        goals.append(gl)\r\n        \r\n    return goals\r\n\r\ndef makeSpringGoals(lines,strength):\r\n    \r\n    \"\"\" Keep each cable its original length \"\"\"\r\n    \r\n    goals = []\r\n    for l in lines:\r\n        g = ks.Goals.Spring(l.From,l.To,l.Length,strength)  \r\n        goals.append(g)\r\n    return goals\r\n\r\ndef makeOnPlaneGoals(graph,strength):\r\n    \r\n    \"\"\" Pull the cable network nodes to the XY plane \"\"\"\r\n    \r\n    # Get node points\r\n    nodePts = []\r\n    for n in graph.nodes(data=True):\r\n        nodePts.append(n[1][\"point\"])\r\n        \r\n    # Define plane\r\n    plane = rc.Geometry.Plane.WorldXY\r\n    \r\n    # Make goals\r\n    nodePts = List[rc.Geometry.Point3d](nodePts)\r\n    goals = [ks.Goals.OnPlane(nodePts,plane,strength),]\r\n    \r\n    return goals\r\n\r\ndef makeAngleGoals(lineGraph,angleStrength):\r\n    \r\n    \"\"\" Keep the cable network internal node angles at their ideal \"\"\"\r\n    \r\n    allAngleGoals = []\r\n    for n in lineGraph.nodes():\r\n        \r\n        # Get node and neighbour points\r\n        nodePt = lineGraph.node[n][\"point\"]\r\n        neighbourPts = [lineGraph.node[n][\"point\"] for n in lineGraph.neighbors(n)]\r\n        \r\n        # Case B: Node has more than one neighbour\r\n        if len(neighbourPts) > 1 :\r\n            \r\n            # Calculate ideal angle\r\n            idealAngle = math.radians(360/len(neighbourPts))\r\n            \r\n            # Sort neighbours around around node\r\n            neighbourPts,plane = sortPointsAroundCenter(neighbourPts,nodePt)\r\n            \r\n            # Make K2 angle goals to neighbours\r\n            nLines = deque([rc.Geometry.Line(nPt,nodePt) for nPt in neighbourPts])\r\n            nodeAngleGoals = []\r\n            for i in range(len(nLines)):\r\n                g = ks.Goals.Angle(nLines[0],nLines[1],idealAngle,angleStrength)\r\n                nodeAngleGoals.append(g)\r\n                nLines.rotate()\r\n                \r\n            # Add to output\r\n            allAngleGoals.extend(nodeAngleGoals)\r\n            \r\n    return allAngleGoals\r\n\r\ndef solveGoals(goals,iterations,tol):\r\n    \r\n    \"\"\" Relax a line network using Kangaroo2 \"\"\"\r\n    \r\n    if iterations == 0:\r\n        return None\r\n        \r\n    else:\r\n        \r\n        # Make solver system and goals dotnet list\r\n        ps = ks.PhysicalSystem()\r\n        goalsList = List[ks.IGoal]()\r\n        \r\n        # Assign indexes to the particles in each Goal\r\n        for g in goals:\r\n            ps.AssignPIndex(g,tol)\r\n            goalsList.Add(g)\r\n            \r\n        # Solve system\r\n        for i in range(int(iterations)):\r\n            ps.Step(goalsList,False,1000)\r\n            \r\n        # Get edges\r\n        relaxedEdges = []\r\n        for o in ps.GetOutput(goalsList):\r\n            if type(o) is rc.Geometry.Line:\r\n                relaxedEdges.append(o)\r\n                \r\n        return relaxedEdges\r\n\r\ndef makePlanar(lines):\r\n    \r\n    \"\"\" Forces the network fully planar \"\"\"\r\n    \r\n    for l in lines:\r\n        \r\n        l.FromZ = 0\r\n        l.ToZ = 0\r\n\r\nif Toggle and AssemblyGeo.DataCount and AssemblyGeo.Branches[0]:\r\n    \r\n    # Unpack datatree and cast cables to lines\r\n    cables,beams,anchors = [b for b in AssemblyGeo.Branches]\r\n    cableLines = castEdges(cables)\r\n    \r\n    # Open degree/valence 2 nodes\r\n    if OpenDegreeTwo:\r\n        cableLines = openDegreeTwoNodes(cableLines,OpenDegreeTwo)\r\n        \r\n    # Rebuild to tolerance\r\n    rebuildLines(cableLines,6)\r\n    \r\n    # Make graph representing cable network\r\n    cnGraph = linesToGraph(cableLines,\"metric\")\r\n    \r\n    # Make K2 goals\r\n    showGoals = makeShowGoals(cableLines)\r\n    springGoals = makeSpringGoals(cableLines,SpringStrength)\r\n    angleGoals = makeAngleGoals(cnGraph,AngleStrength)\r\n    planeGoals = makeOnPlaneGoals(cnGraph,PlaneStrength)\r\n    goals = showGoals + angleGoals + springGoals + planeGoals\r\n    \r\n    # Solve goals\r\n    if Iterations:\r\n        cableLines = solveGoals(goals,Iterations,0.0001)\r\n        \r\n    # Fully Planarize network\r\n    if MakePlanar:\r\n        makePlanar(cableLines)\r\n        \r\n    # Check the input/output edge lengths are okay\r\n    checkLengths = []\r\n    for crv,l in zip(cables,cableLines):\r\n        checkLengths.append(abs(crv.GetLength() - l.Length) < 0.001)\r\n    if False in checkLengths:\r\n        RelaxedOkay = False\r\n    else:\r\n        RelaxedOkay = True\r\n        \r\n    # Output to GH\r\n    RelaxedNetwork = cableLines\r\nelse:\r\n    RelaxedNetwork = []\r\n    RelaxedOkay = []",
  "language": "python",
  "imports": [
    "Rhino",
    "RhinoCommon"
  ],
  "has_docstring": false
}