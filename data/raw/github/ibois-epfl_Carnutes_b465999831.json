{
  "source_url": "https://github.com/ibois-epfl/Carnutes/blob/d3bf0a816670108b5da1aafbd95493ae2260f2cc/src/Carnutes/find_multiple_trees_with_optimisation.py",
  "repo": "ibois-epfl/Carnutes",
  "repo_stars": 3,
  "repo_description": "Workshop content for AW 2024 Ba3-Ma1 architecture studio",
  "license": "GPL-3.0",
  "filepath": "src/Carnutes/find_multiple_trees_with_optimisation.py",
  "instruction": "This function finds multiple trees in the database that best fit the given element, starting by the element that has the most connections to make. It also optimizes for the tree usage.",
  "code": "\"\"\"\nThis function finds multiple trees in the database that best fit the given element, starting by the element that has the most connections to make. It also optimizes for the tree usage.\n\"\"\"\n\n#! python3\n\n# r: numpy==2.0.2\n# r: open3d==0.19.0\n# r: ZODB==6.0\n# r: igraph==0.11.6\n\nimport os\nimport copy\nimport System\nimport time\n\nfrom utils import tree, geometry, interact_with_rhino, conversions\nfrom utils import element as elem\nfrom utils.tree import Tree\nfrom packing import packing_combinatorics\n\nimport numpy as np\nimport Rhino\nimport scriptcontext\n\n\ndef crop(tree: tree, bounding_volume: Rhino.Geometry.Brep):\n    \"\"\"\n    Crop the tree to a bounding volume\n    Used to be a method of the tree class but has been moved out to make the Tree class available for testing outside of rhino.\n\n\n    :param bounding_volume: closed Brep\n        The bounding Brep to crop the tree to\n    \"\"\"\n    indexes_to_remove = []\n    for i in range(len(tree.point_cloud.points)):\n        point = tree.point_cloud.points[i]\n        if not bounding_volume.IsPointInside(\n            Rhino.Geometry.Point3d(point[0], point[1], point[2]), 0.01, True\n        ):\n            indexes_to_remove.append(i)\n    tree.point_cloud.points = [\n        point\n        for i, point in enumerate(tree.point_cloud.points)\n        if i not in indexes_to_remove\n    ]\n    tree.point_cloud.colors = [\n        color\n        for i, color in enumerate(tree.point_cloud.colors)\n        if i not in indexes_to_remove\n    ]\n\n\ndef main():\n    # ask the user for the optimisation basis:\n    optimisation_basis = 3\n    optimisation_basis = Rhino.Input.RhinoGet.GetInteger(\n        \"please provide the basis for the optimisation. The higher the number, the longer the calculation, but potentially the tree consumption will be lower\\n default = 3\",\n        True,\n        optimisation_basis,\n        0,\n        30,\n    )\n\n    # Create the model\n    current_model, layer_ids = interact_with_rhino.create_model_from_rhino_selection()\n\n    # For each element in the model, replace it with a point cloud. Starting from the elements with the highest degree.\n    db_path = os.path.dirname(os.path.realpath(__file__)) + \"/database/tree_database.fs\"\n\n    all_rmse = []\n\n    for i, element in enumerate(current_model.elements):\n        if element.type == elem.ElementType.Point:\n            continue\n        reference_pc_as_list = [\n            [\n                element.geometry.PointAtStart.X,\n                element.geometry.PointAtStart.Y,\n                element.geometry.PointAtStart.Z,\n            ],\n            [\n                element.geometry.PointAtEnd.X,\n                element.geometry.PointAtEnd.Y,\n                element.geometry.PointAtEnd.Z,\n            ],\n        ]\n        element_guid = element.GUID\n        target_diameter = element.diameter\n        for location in element.locations:\n            reference_pc_as_list.append(location)\n\n        # at this point the reference_pc_as_list should contain the points, but they are not ordered. We need to order them.\n        reference_pc_as_list = geometry.sort_points(reference_pc_as_list)\n        reference_skeleton = geometry.Pointcloud(reference_pc_as_list)\n        (best_tree, best_target, best_rmse, best_init_rotation) = (\n            packing_combinatorics.find_best_tree_optimized(\n                reference_skeleton,\n                target_diameter,\n                db_path,\n                optimisation_basis=3,\n                return_rmse=True,\n            )\n        )\n        if best_tree is None:\n            print(\"No tree found. Skiping this element.\")\n            continue\n\n        all_rmse.append(best_rmse)\n        best_tree = copy.deepcopy(best_tree)\n\n        best_tree.align_to_skeleton(reference_skeleton)\n\n        # Create a bounding volume for the element\n        bounding_volume = element.create_bounding_cylinder(radius=1)\n        crop(best_tree, bounding_volume)\n        best_tree.create_mesh()\n\n        tree_mesh = conversions.convert_carnutes_mesh_to_rhino_mesh(best_tree.mesh)\n        attributes = Rhino.DocObjects.ObjectAttributes()\n        attributes.LayerIndex = layer_ids[i]\n        scriptcontext.doc.Objects.AddMesh(tree_mesh, attributes)\n\n    return all_rmse\n\n\nif __name__ == \"__main__\":\n    init_time = time.time()\n    all_rmse = main()\n    end_time = time.time()\n    print(f\"Execution time: {end_time - init_time}\")\n    print(f\"The mean rmse fitting {len(all_rmse)} elements is {np.mean(all_rmse)}\")\n    print(\"Done\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}