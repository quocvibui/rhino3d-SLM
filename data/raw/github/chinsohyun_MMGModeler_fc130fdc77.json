{
  "source_url": "https://github.com/chinsohyun/MMGModeler/blob/f9e8fb18e08fc9ac13d56a9abd5158315ef4facc/Archives/python_for%20cuboctahedron_240909.py",
  "repo": "chinsohyun/MMGModeler",
  "repo_stars": 0,
  "repo_description": "3D Interface for Minimal Making Grammar",
  "license": "unknown",
  "filepath": "Archives/python_for cuboctahedron_240909.py",
  "instruction": "Python for cuboctahedron 240909",
  "code": "import rhinoscriptsyntax as rs\n\nrs.DefaultRenderer(False)\n\ndef square(w, l, offset, pt_cord, next_cord): #3\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2] * 2 * w/l))\n        pt1a = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2]* (1-2 * w/l))) \n        pt2 = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* (1-2 * w/l)))\n        pt2a = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* 2 * w/l))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        ptb = rs.AddPoint((a, b, next_cord[2]))\n        nptb = rs.AddPoint((next_cord[0], next_cord[1], c))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.2))\n        pt1a = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.2))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.8))\n        pt2a = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.8))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n        ptb = rs.AddPoint((next_cord[0], b, c))\n        nptb = rs.AddPoint((a, next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * 2 * w/l, c))\n        pt1a = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * (1-2 * w/l), c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * (1-2 * w/l), c))\n        pt2a = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * 2 * w/l, c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n        ptb = rs.AddPoint((a, next_cord[1], c))\n        nptb = rs.AddPoint((next_cord[0], b, next_cord[2]))\n\n    rect = [pt1, pt1a, pt2, pt2a, pt1]\n    big_rect = [pt_cord, ptb, next_cord, nptb, pt_cord]\n#    poly_points = [pt0, pt1, pt1a, pt2, pt2a, npt]\n    rs.HideObjects(rect)\n    rs.HideObjects([ptb, nptb])\n#    polyline = rs.AddPolyline(rect)\n    polyline1 = rs.AddPolyline(big_rect)\n    \n    polyline2 = rs.AddPolyline([pt0, pt1, pt2, npt])\n#    rs.AddSweep2(big_rect, big_rect, False )\n    return [polyline1, polyline2]\n    \ndef diagonal(w, l, offset, pt_cord, next_cord): #0\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.1, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.9, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.1))\n        pt2 = rs.AddPoint((a + offset[0] *(1-2 * w/l), b, c + offset[2] * 0.9))\n        npt = rs.AddPoint((a + offset[0] *(1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.1, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.9, b + offset[1]  * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2*w/l), next_cord[2]))\n\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n    \n    \ndef triangle_shape(w, l, offset, pt_cord, next_cord): #2\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n        \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.95 , c + offset[2]* (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.95))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.95, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n    \ndef z_shape(w, l, offset, pt_cord, next_cord): #1\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.5))\n        npt = rs.AddPoint((a + offset[0] * (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n\ndef cuboctahedron(pt, rotation, mode, number, container):\n    rs.DefaultRenderer(False)\n    if rotation >= number:\n        return\n    len = 30\n    width = 1\n    \n    \n    pt_cord = rs.PointCoordinates(pt)\n    container.append(pt_cord)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    x = len/2\n    \n    offsets = [\n            (x, x, 0), (x, -x, 0), (-x, x, 0), (-x, -x, 0),  # p_xy plane\n            (0, x, x), (0, x, -x), (0, -x, x), (0, -x, -x),  # p_yz plane\n            (x, 0, x), (-x, 0, x), (x, 0, -x), (-x, 0, -x)   # p_zx plane\n    ]\n            \n    for offset in offsets:\n        next_pt = rs.AddPoint((a + offset[0], b + offset[1], c + offset[2]))\n        rs.HideObjects([pt, next_pt])\n        next_cord = rs.PointCoordinates(next_pt)\n#        rs.HideObjects(next_pt)\n        if next_cord not in container:\n            if mode != 3:\n                if mode == 0:\n                     polyline = diagonal(width, len, offset, pt_cord, next_cord)\n        \n                elif mode == 1:\n                     polyline = z_shape(width, len, offset, pt_cord, next_cord)\n                     \n        \n                elif mode == 2:\n                     polyline = triangle_shape(width, len, offset, pt_cord, next_cord)\n                rs.HideObjects(polyline)\n                #offset\n                if offset[0] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n                if offset[1] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n                if offset[2] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n                shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n                shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n#                rs.AddSweep1(shape1, [pl1, pl2], True)\n    \n            else:\n                 polylines = square(width, len, offset, pt_cord, next_cord)\n                 \n                 \n            cuboctahedron(next_pt, rotation + 1, mode, number, container)\n#        rs.AddTextDot(rotation, rs.PointCoordinates(next_pt))\n\n    \n\ncenter_pt = rs.AddPoint( (0, 0, 0) )\ncontainer = []\ncuboctahedron(center_pt, 0, 2, 1, container)\n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}