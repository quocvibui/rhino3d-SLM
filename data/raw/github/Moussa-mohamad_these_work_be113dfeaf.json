{
  "source_url": "https://github.com/Moussa-mohamad/these_work/blob/2594e0f1bf5839db92263f3a606f83a3f3ff92a7/mesh/3d_model_PyC.py",
  "repo": "Moussa-mohamad/these_work",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "mesh/3d_model_PyC.py",
  "instruction": "3d model py c",
  "code": "\nimport rhinoscriptsyntax as rs\nimport gmsh\nimport numpy as np\nimport importlib\nimport plotly.graph_objects as go\nimport meshio\nfrom cvxopt import matrix, solvers, spmatrix\nfrom scipy.sparse import coo_matrix\nimport sys\nimport time\n#import pandas as pd\nimport os\nfrom pyevtk.hl import unstructuredGridToVTK\nfrom pyevtk.vtk import VtkTriangle, VtkQuad, VtkVertex\nimport mesh\n\n\ndef calculate_moment(point_coords, force_coords, applied_point_coords):\n    \"\"\"\n    Calculate the moment of a force around a point.\n\n    Parameters:\n    - point_coords: Coordinates of the point where the moment is calculated (numpy array).\n    - force_coords: Coordinates of the force vector (numpy array).\n    - applied_point_coords: Coordinates of the point where the force is applied (numpy array).\n\n    Returns:\n    - moment: Moment of the force around the point (numpy array).\n    \"\"\"\n    r = - point_coords + applied_point_coords\n    F = force_coords\n\n    # Calculate the cross product to get the moment\n    moment = np.cross(r, F)\n\n    return moment\ndef rotate_x(theta):\n    return np.array([\n        [1, 0, 0],\n        [0, np.cos(theta), -np.sin(theta)],\n        [0, np.sin(theta), np.cos(theta)]\n    ])\n\ndef rotate_y(theta):\n    return np.array([\n        [np.cos(theta), 0, np.sin(theta)],\n        [0, 1, 0],\n        [-np.sin(theta), 0, np.cos(theta)]\n    ])\n\ndef rotate_z(theta):\n    return np.array([\n        [np.cos(theta), -np.sin(theta), 0],\n        [np.sin(theta), np.cos(theta), 0],\n        [0, 0, 1]\n    ])\ndef transform_point(point, displacement, rotations):\n    \n\n    # Apply rotations\n    for rotation in rotations:\n        axis, angle = rotation[0], rotation[1]\n        if axis == 'x':\n            rotation_matrix = rotate_x(angle)\n        elif axis == 'y':\n            rotation_matrix = rotate_y(angle)\n        elif axis == 'z':\n            rotation_matrix = rotate_z(angle)\n        else:\n            raise ValueError(\"Invalid rotation axis. Use 'x', 'y', or 'z'.\")\n\n        point = np.dot(rotation_matrix, point)\n        # Apply displacement\n    point = np.array(point) + np.array(displacement)\n    return point.tolist()\n\ndef check_outward_normal(block_centroid,face_centroid,face_normal,local_ref):\n\n    block_centroid = [ block_centroid[0], block_centroid[1], block_centroid[2]]\n   \n    if np.dot(face_normal, np.array(block_centroid )- np.array(face_centroid)) > 0:\n        face_normal = [-1*element for element in face_normal]\n        \n        \n    if face_normal[1] != 0 or face_normal[2] != 0:\n        x_local = [face_normal[1]**2 + face_normal[2]**2, -face_normal[0]*face_normal[1] , -face_normal[0]*face_normal[2] ]\n        y_local = [0, face_normal[2] , -face_normal[1] ]\n    else:\n        if face_normal[0] > 0:\n            x_local = [0,1,0]\n            y_local = [0,0,1]\n        else:\n            x_local = [0,-1,0]\n            y_local = [0,0,1]\n  \n        \n    x_local /= np.linalg.norm(x_local)\n    y_local /= np.linalg.norm(y_local)\n\n    x_local = [round(element,4) for element in x_local ]\n    y_local = [round(element,4) for element in y_local ]\n    \n\n    local_ref = np.append(local_ref, np.array([[ face_ind, face_normal[0], face_normal[1],face_normal[2], \\\n                                              x_local[0],x_local[1],x_local[2], y_local[0],y_local[1],y_local[2]  ]]), axis =0)\n        \n  \n    return local_ref\n\ndef find_element_in_matrix(matrix, element):\n    for i, row in enumerate(matrix):\n        if element in row:\n            return i  # Return the index of the row where the element is found\n    return -1  # Return -1 if the element is not found in any row\n\ndef stat_parav(all_unique_points,noc_triangles_coor,noc_triangles,triangles_num,all_triangles,Ntriangles_num,stat_sol):\n    FILE_PATH = \"C:\\\\Users\\\\mmoussa\\\\Desktop\\\\rhino_test\\\\stat_stress\"\n    print(\"Running unstructured...\")\n    \n    normal_load = [ round(stat_sol[ind+2],2)   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n    shear_loadx = [ round(stat_sol[ind],2)   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n    shear_loady = [ round(stat_sol[ind+1],2)   for ind in range(0,len(stat_sol[0:-1:]),3) ]\n    \n    \n    \n    all_unique_points = np.array(all_unique_points)\n\n    # Define vertices\n    x = [float(element) for element in all_unique_points[:, 0]]\n    y = [float(element) for element in all_unique_points[:, 1]]\n    z = [float(element) for element in all_unique_points[:, 2]]\n\n    print(\"xxxxxx\",len(x))\n\n    print(len(normal_load))\n    \n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n\n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n   \n    \n    tri_ind = 0\n    node_ind = 0\n \n    for face_triangles in all_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n                \n                ctype.append(VtkQuad.tid)\n          \n  \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    #cd = np.random.rand(2)\n    cellData = {\"pressure\": []}\n\n    \n    # Define displacement components\n    normal_stress = np.array(normal_load)\n    shear_stress1 = np.array(shear_loadx)\n    shear_stress2 = np.array(shear_loady)\n    \n\n    # Combine displacement components into separate arrays\n    pointData = {\"normal_stress\":normal_stress, \"shear_stress1\": shear_stress1, \"shear_stress2\": shear_stress2  }\n\n  \n    \n    # Add combined displacement to pointData\n    #pointData[\"displacement\"] = displacement\n    print(conn)\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n    \n    \n    FILE_PATH = \"C:\\\\Users\\\\mmoussa\\\\Desktop\\\\rhino_test\\\\stat_body\"\n    \n    \n  \n    # Define vertices\n    \n    \n    noc_triangles_coor = np.array(noc_triangles_coor)\n\n    # Define vertices\n    x = [float(element) for element in noc_triangles_coor[:, 0]]\n    y = [float(element) for element in noc_triangles_coor[:, 1]]\n    z = [float(element) for element in noc_triangles_coor[:, 2]]\n\n   \n    x = np.array(x, dtype = np.float64)\n    y = np.array(y,dtype = np.float64)\n    z = np.array(z,dtype = np.float64)\n    \n     # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n\n    tri_ind = 0\n    node_ind = 0\n \n    for face_triangles in noc_triangles:\n      \n        for triangle in face_triangles:\n            for node in triangle:\n                conn.append(int(node-1))\n                node_ind += 1\n\n\n            offset.append(node_ind )\n\n            if len(triangle) == 3:\n                ctype.append(VtkTriangle.tid)\n            else:\n               \n                ctype.append(VtkQuad.tid)\n          \n  \n\n    conn =  np.array(conn)\n    offset =  np.array(offset)\n    ctype =  np.array(ctype)\n\n    pointData = {'d': np.ones(x.shape[0])}\n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\ndef streamprinter(text):\n    sys.stdout.write(text)\n    sys.stdout.flush()\n\n\n\ndef block_disp_plot(manifold_data,blocks,faces,points,ub):\n    ub = [ 1*element for element in ub ]\n \n    \n    fig = go.Figure()\n    new_points = []\n    initial_points = np.empty((0,3))\n    points_disp = np.empty((0,3))\n\n\n    FILE_PATH = \"C:\\\\Users\\\\mmoussa\\\\Desktop\\\\rhino_test\\\\disp\"\n  \n    # Define connectivity or vertices that belong to each element\n    conn = []\n    # Define offset of the last vertex of each element\n    offset = []\n    # Define cell types\n    ctype = []\n  \n    for ind, block_centroid in enumerate(blocks_centroid):\n      \n        faces_ind = blocks[np.where( blocks[:,0] == ind+1)][:,1]\n        for face in faces_ind:\n            points_ind = faces[ np.where(faces[:,0] == face)][:,2]\n            points_ind = [ int(element) -1 for element in points_ind] \n            \n            points_coor = points[points_ind][:,-3:]\n            points_coor.astype(float)\n            points_coor = np.array([[float(element) for element in row] for row in points_coor])\n            \n\n            all_new = []\n            reference_point = block_centroid[-3:]\n       \n            \n            displacement_vector = [ ub[6*ind], ub[6*ind +1], ub[6*ind +2] ]\n      \n            \n            rotations = [('x', ub[6*ind +3]), ('y',ub[6*ind +4]),('z',  ub[6*ind +5])]\n            \n            for element in points_coor:\n                #conn.extend( initial_points.shape[0])\n                #initial_points.append(element)\n                initial_points = np.append(initial_points, np.array([element]), axis = 0)\n                \n\n                conn.extend( [initial_points.shape[0] - 1 ])\n                \n                point_new_ref = [element[element1] - reference_point[element1] for element1 in range(3) ]\n               \n                \n                new_point = transform_point(point_new_ref , displacement_vector, rotations)\n                \n               \n                new_point = [new_point[element] + reference_point[element] for element in range(3) ]\n                \n                all_new.append(new_point)\n\n                points_disp = np.append(points_disp, np.array( [new_point[:] - element[:] ] ), axis = 0)\n                #points_disp.append( new_point[:] - element[:] ) \n                \n            ctype.extend ([VtkQuad.tid])\n            offset.extend( [initial_points.shape[0] ])\n            \n            new_points.append(all_new[0]) \n            \n            all_new = np.array(all_new)   \n            \n            \n\n            fig.add_trace( go.Scatter3d(x= all_new[:,0] ,\n                y= all_new[:,1] ,\n                z= all_new[:,2] ,\n                mode='lines',\n               \n                line=dict(color='blue', width=2),\n              showlegend=False  ))\n\n            \n            # Add the second mesh3d surface to the existing figure\n            \n            fig.add_trace(go.Mesh3d(x=all_new[:,0],\n                    y=all_new[:,1],\n                    z=all_new[:,2],\n\n                    i = [element for element in range(points_coor.shape[0]-2)],\n                    j = [element for element in range(1,points_coor.shape[0]-1)],\n                    k = [points_coor.shape[0]-1 for element in range(1,points_coor.shape[0]-1) ],\n                    opacity=0.9,\n                    color='grey',\n                    flatshading=True,\n                    alphahull=-1   )  )\n            \n    \n    points = new_points\n   \n    point = np.array([[float(element) for element in row] for row in points])\n    max_coor = np.max( point,axis = 0 )\n    min_coor = np.min( point,axis = 0 )\n    max_dist = max([max_coor[0] -min_coor[0], max_coor[1] -min_coor[1], max_coor[2] -min_coor[2]  ])\n  \n    center = np.mean( np.array([max_coor,min_coor]) ,axis = 0)\n    fig.update_layout(scene=dict(xaxis=dict(range=[center[0] - max_dist/2, center[0] + max_dist/2]),\n                                 yaxis=dict(range=[center[1] - max_dist/2, center[1] + max_dist/2]),\n                                 zaxis=dict(range=[center[2] - max_dist/2, center[2] + max_dist/2])))\n    fig.show()\n      # Save the figure as an HTML file\n    fig.write_html(\"C:/Users/mmoussa/Desktop/rhino_test/figure_disp.html\")  \n\n  #paraview part\n    \n    # Define vertices\n    x = [float(element) for element in initial_points[:, 0]]\n    y = [float(element) for element in initial_points[:, 1]]\n    z = [float(element) for element in initial_points[:, 2]]\n\n    x = np.array(x)\n    y = np.array(y)\n    z = np.array(z)\n\n    # Define displacement components\n    dx = np.array(points_disp[:,0])\n    dy = np.array(points_disp[:,1])\n    dz = np.array(points_disp[:,2])\n\n    pointData = {'dx': dx, 'dy': dy, 'dz': dz } \n    conn = np.array(conn)\n    offset = np.array(offset)\n    ctype = np.array(ctype)\n    \n\n    unstructuredGridToVTK(FILE_PATH, x, y, z, connectivity=conn, offsets=offset, cell_types=ctype, pointData=pointData)\n\n\ndef blocks_plot(face_points,fig):\n    \n\n\n\n    fig.add_trace(go.Scatter3d(x=face_points[:,0],\n            y=face_points[:,1],\n            z=face_points[:,2],\n            mode='lines',\n           \n            line=dict(color='blue', width=2),\n          showlegend=False   ))\n\n    \n    fig.add_trace( go.Mesh3d( x=face_points[:,0],\n            y=face_points[:,1],\n            z=face_points[:,2],\n\n            i = [0],\n            j = [1],\n            k = [2 ],\n            opacity=0.9,\n            color='grey',\n            flatshading=True,\n            alphahull=-1  ) )\n    \n           \n                   \n    return fig\n\n# Reload the RhinoScriptSyntax module\nimportlib.reload(rs)\nobjs = rs.AllObjects()\n\nfaces_rep = []\npts_coor = np.empty((0,3))\n\nblock_ind = 1\nface_ind = 1\n\nblocks = np.empty((0, 7), dtype=np.int32)\nfaces = np.empty((0,3))\nblocks_centroid = np.empty((0,4))\nblocks_volume = np.empty((0,2))\nblocks_att = []\n\nunsorted_faces_rep = []\nplans_data = np.empty((0,4))\nplan_ind = 1\nf_points = [] #faces points\nkeys_of_interest = [\"fx\", \"fy\", \"fz\", \"mx\", \"my\", \"mz\"]\nlocal_ref = np.empty((0,10))\nblocks_brep = [] \nbars = []\nsupports_type = [] \n\ncontacts_ind = []\ncontacts_nodes = []\ncontacts_FE = [0]\n\nfaces_ind = []\nfaces_nodes = []\nfaces_FE = [0]\n\nphi_type = []\ncoh_type = []\nlc_type = []\nfor obj in objs:\n    obj_type = rs.ObjectType(obj)\n    if obj_type == 4:\n        bars.append(obj) \n\n    if obj_type == 8: # Check if the object is a surface\n      \n        \n        boundary_curve_id = rs.DuplicateSurfaceBorder(obj)\n        # Get points along the boundary curve\n        points = rs.CurvePoints(boundary_curve_id)\n        points = points[0:-1:]\n        print(points[1])\n        \n        #points = rs.SurfacePoints(obj)\n        #print(rs.SurfacePointCount(obj))\n #mohamaddddd\n        \n        for i, point in enumerate(points):\n            print(point)\n            plans_data = np.append(plans_data, np.array([[ plan_ind, np.round(point[0],5) , np.round( point[1],5), np.round(point[2],5) ]]), axis = 0)\n        \n        plan_ind += 1\n        att_lcase = [item.lower() for item in  rs.GetUserText(obj)]\n       \n\n        if 'type' in att_lcase:\n            index = att_lcase.index('type')\n            if rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '3':\n                supports_type.append(3)\n            elif rs.GetUserText(obj, rs.GetUserText(obj)[index]) == '2':\n                supports_type.append(2)\n        else:\n            supports_type.append(-1)\n\n        \n        if 'c' in att_lcase:\n            index = att_lcase.index('c')\n            coh_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n            \n        else:\n            coh_type.append(-1)\n        \n        if 'phi' in att_lcase:\n            index = att_lcase.index('phi')\n            phi_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n            \n        else:\n            phi_type.append(-1)\n        \n        if 'lc' in att_lcase:\n            index = att_lcase.index('lc')\n            lc_type.append(float(rs.GetUserText(obj, rs.GetUserText(obj)[index])))\n            \n        else:\n            lc_type.append(-1)\n            \n\n   \n    if obj_type == 16:  # Check if the object is a solid\n        block_name = rs.ObjectName(obj)\n        \n        blocks_brep.append(obj)\n        # Explode the solid into its faces\n        faces_data = rs.ExplodePolysurfaces(obj)\n        \n        if faces_data:\n            for face in faces_data:\n\n                boundary_curve_id = rs.DuplicateSurfaceBorder(face)\n                if not boundary_curve_id:\n                    print(\"Failed to extract surface boundary.\")\n                    \n    \n                # Get points along the boundary curve\n                points = rs.CurvePoints(boundary_curve_id)\n                points = points[0:-1:]\n                # Get the control points of each face\n                #points = rs.SurfacePoints(face)\n                \n                face_pts = np.empty((0,3))\n                # Loop through the control points\n                for i, point in enumerate(points):\n                  \n                    # Print the coordinates of each control point\n                    face_pts = np.append(face_pts, np.array([[ np.round(point[0],5), np.round(point[1],5), np.round(point[2],5) ]]), axis = 0)\n                 \n              \n                \n                b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n                \n                face_centroid = np.mean(face_pts, axis = 0)\n                \n                face_normal = np.cross(face_centroid - face_pts[0], face_pts[1] - face_pts[0])\n            \n                face_normal /= np.linalg.norm(face_normal)\n                \n                \n                \n                \n                \n                pts_coor = np.append(pts_coor, face_pts, axis=0)\n\n                # Get unique points and their indices\n                pts_coor , unique_indices = np.unique(pts_coor, axis=0, return_index=True)\n\n                # Reorder the unique points based on their original order\n                pts_coor = pts_coor[np.argsort(unique_indices)]\n\n                added_positions = []\n\n                for point in face_pts:\n                    pt_position = np.where(np.all(pts_coor == point, axis=1))[0][0]\n                    added_positions.append(pt_position +1 )\n                \n                \n\n                #added_positions_copy = [element +1 for element in added_positions_copy]\n\n                unsorted_face_rep = '#'.join(map(str, added_positions.copy() ))\n\n                added_positions_copy = added_positions.copy()\n\n                sorted_point_indices = sorted(set(added_positions_copy))\n                #sorted_point_indices = [element + 1 for element in sorted_point_indices]\n\n                face_rep = '#'.join(map(str, sorted_point_indices ))\n               \n                if (not face_rep in faces_rep) or block_ind == 1:\n                    faces_rep.append(face_rep)\n                    f_points.append(face_pts)\n                    unsorted_faces_rep.append(unsorted_face_rep)\n\n                    faces_ind += [faces_rep.index(face_rep) + 1 ]\n                    faces_nodes += added_positions\n                    faces_FE.append(faces_FE[-1:][0] + len(added_positions))\n\n\n                    local_ref = check_outward_normal(b_centroid,face_centroid,face_normal,local_ref)\n                    local_ref[-1:, 0] = len(faces_rep)\n                \n                    block_name = -99\n                    blocks = np.append(blocks, np.array([[block_ind, len(faces_rep), block_name, face_ind  , 0,-1, 11 ]]), axis = 0)\n                    for ind in added_positions:\n                        faces = np.append(faces, np.array([[len(faces_rep), face_ind, ind  ]]),axis = 0) #ind or ind+1\n                else:\n                    contacts_ind += [faces_rep.index(face_rep) + 1 ]\n                    contacts_nodes += added_positions\n                  \n                    contacts_FE.append(contacts_FE[-1:][0] + len(added_positions))\n\n                    block_name = -99\n                    blocks = np.append(blocks, np.array([[block_ind, faces_rep.index(face_rep) + 1, block_name, face_ind, 0 , -1, 22 ]]), axis = 0)\n  \n                # Do something with each face (e.g., print face area)\n                face_area = rs.SurfaceArea(face)[1]\n                \n                \n                \n                face_ind += 1\n\n                # Optionally, you can delete the exploded face\n                rs.DeleteObject(face)\n                rs.DeleteObject(boundary_curve_id)\n                \n        \n       \n        b_centroid = rs.SurfaceVolumeCentroid(obj)[0]\n        b_volume = rs.SurfaceVolume(obj)[0]\n\n        blocks_volume = np.append(blocks_volume, np.array([[block_ind, b_volume ]]), axis = 0)\n\n        blocks_centroid = np.append(blocks_centroid, np.array([[block_ind, b_centroid[0], b_centroid[1], b_centroid[2] ]]), axis = 0)\n        \n        atb_keys = rs.GetUserText(obj)\n        \n        if atb_keys:\n            \n            b_att = [block_ind]\n\n            for atb_key in atb_keys:\n                if atb_key in keys_of_interest:\n                    key_ind = keys_of_interest.index(atb_key)\n                    \n\n                    b_att.extend([key_ind +1, rs.GetUserText(obj, atb_key) ])\n            \n            blocks_att.append(b_att)\n\n                    \n\n   \n        \n        block_ind += 1\n       \n# Get the number of rows in the array\nnum_rows = pts_coor.shape[0]\n\n# Create an array of 1-based indices\nindices_column = (np.arange(num_rows) + 1).reshape(-1, 1)\n\n# Add the indices column to the original array\npoints = np.hstack((indices_column, pts_coor))\n\nplans_rep = []\nsupports_ind = []\n\nif plans_data.shape[0] != 0:\n    for ind in range(plan_ind-1):\n     \n        plan_elements = plans_data[ np.where(plans_data[:,0] == ind +1 )[0] ]\n  \n        plan_pts = []\n        for  element in plan_elements:\n            pt_coor = element[-3:]\n            pt_ind = np.where( np.all(points[:,-3:] == pt_coor, axis=1)  )[0]\n            \n            plan_pts.extend(pt_ind)\n        \n        sorted_plan_pts = sorted(set(plan_pts))\n        sorted_plan_pts = [element + 1 for element in sorted_plan_pts]\n\n        plan_rep = '#'.join(map(str, sorted_plan_pts ))\n        \n        plans_rep.append(plan_rep)\n        \n    \nfor ind in contacts_ind:    blocks[np.where(blocks[:,1] == ind)[0], 4] = 1\n\n\nsupports_rep = set(plans_rep) &  set(faces_rep)\n\nfor ind in supports_rep :\n    if supports_type[plans_rep.index(ind)] == 2:\n        \n        blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4] = 2\n        \n        contacts_ind += [faces_rep.index(ind) +1]\n        \n        \n        unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n      \n        nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n        \n        contacts_nodes += nodes_ind\n        \n        contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n    \n    if supports_type[plans_rep.index(ind)] == 3:\n\n        supports_ind += [faces_rep.index(ind) +1]\n        blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 4 ] = 3\n\n        contacts_ind += [faces_rep.index(ind) +1]\n       \n        unsorted_rep = unsorted_faces_rep[faces_rep.index(ind)] \n        \n        nodes_ind = [int(num) for num in unsorted_rep.split('#')]\n        \n        contacts_nodes += nodes_ind\n        \n        contacts_FE += [ contacts_FE[-1:][0] + len(nodes_ind)]\n    if coh_type[plans_rep.index(ind)] != -1:\n        blocks[np.where(blocks[:,1] == faces_rep.index(ind) +1)[0] , 5 ] = float(coh_type[plans_rep.index(ind)])\n\n\n# Select the curve(s) you want to split\n#curve_ids = rs.GetObjects(\"Select curve(s) to split\", rs.filter.curve)\n\ncontacts_ind_sorted = sorted(contacts_ind)\n\n\nsupports_pos = []\nfor ind in supports_ind:\n    supports_pos += [contacts_ind_sorted.index(ind)]\n\n\n\ncurve_ids = bars\n\nif not curve_ids:\n    print(\"No curve selected. Exiting...\")\n    #quit()\nrs.EnableRedraw(False)\n\n\nbpts_inter = np.empty((0,3))\nbars_data = np.empty((0,7))\n\nif True:\n    for block_ind, solid_id in enumerate(blocks_brep):\n        pts_pos = set()\n        # Split the curves with the solid\n        for curve_id in curve_ids:\n            added_positions = []\n            att_num = 0\n\n            atb_keys = rs.GetUserText(curve_id)   \n            if atb_keys:\n                \n                for atb_key in atb_keys:\n                    if atb_key == 'A':\n                        bar_area = rs.GetUserText(curve_id, 'A')\n                        att_num += 1\n                    if atb_key == 'fy':\n                        bar_fy = rs.GetUserText(curve_id, 'fy')\n                        att_num += 1\n                        \n            if att_num == 2:\n                exploded_curve = rs.ExplodeCurves(curve_id)\n            \n                for line in exploded_curve:\n                    start_pt = rs.CurvePoints(line)[0]\n                    end_pt = rs.CurvePoints(line)[1]\n                \n                    bar_dir = np.array([start_pt[0]- end_pt[0]  , start_pt[1]- end_pt[1], start_pt[2]- end_pt[2]  ] )\n                    \n                    bar_dir /= np.linalg.norm(bar_dir)  \n                    bar_dir = [np.round(element, 5)  for element in bar_dir]\n                    # Check if the curve intersects with the solid\n                    if rs.CurveBrepIntersect(line, solid_id):\n            \n                        \n                        inter1_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][0]))\n                        inter1_coor = [inter1_coor[0], inter1_coor[1], inter1_coor[2] ]\n                        part_to_add = np.array( [inter1_coor])\n\n                        if len(rs.CurveBrepIntersect(line, solid_id)[1]) == 2:\n                            inter2_coor = rs.PointCoordinates((rs.CurveBrepIntersect(line, solid_id)[1][1]))\n                            inter2_coor = [inter2_coor[0], inter2_coor[1], inter2_coor[2]]\n                            part_to_add = np.array( [inter1_coor, inter2_coor])\n                    \n                        part_to_add = np.round(part_to_add, decimals=5)\n\n                        bpts_inter = np.append(bpts_inter, part_to_add , axis = 0)\n                        # Get unique points and their indice\n                        bpts_inter , unique_indices = np.unique(bpts_inter, axis=0, return_index=True)\n                \n                        # Reorder the unique points based on their original order\n                        bpts_inter = bpts_inter[np.argsort(unique_indices)]\n                    \n                        # Use broadcasting to compare all points in points_array with each point in set_of_points\n                        matches = np.all(np.expand_dims( bpts_inter, axis=1) == part_to_add, axis=2)\n\n                        # Find row indices where any row in set_of_points matches points_array\n                        added_positions = np.where(matches.any(axis=1))[0]\n                    \n                \n                        \n                        if len(added_positions) != 0:\n                            \n                            for  pt_pos in added_positions:\n                                \n                                pt_coor = bpts_inter[pt_pos]\n                                if np.dot(bar_dir, np.array(blocks_centroid[block_ind, -3:] )- np.array(pt_coor)) > 0:\n                                    bar_dir = [-1*element for element in bar_dir]\n                                \n                                bars_data = np.append( bars_data, np.array([[int(block_ind +1) , int(pt_pos +1), float(bar_area), float(bar_fy), *bar_dir  ]] ),axis = 0   )  \n            \n                rs.DeleteObjects(exploded_curve)\n\n    rs.EnableRedraw(True)\n\n\n\n\n\n\nlc = 1\n\nlc_faces_val = lc*np.ones((len(contacts_ind)), dtype = np.float64)\n\nprint(faces_rep)\nprint(plans_rep)\nfor ind, lc_face  in enumerate(lc_type):\n    if lc_face != -1:\n       \n        face_ind = faces_rep.index( plans_rep[ind] )\n        contact_ind = contacts_ind.index(face_ind + 1)\n     \n        lc_faces_val[contact_ind] = float(lc_face)\n\n\n\ncontacts_ind = np.array(contacts_ind, dtype = np.int32)\ncontacts_nodes = np.array(contacts_nodes, dtype = np.int32)\ncontacts_FE = np.array(contacts_FE, dtype = np.int32)\n\n\ncontacts_ind = np.array(contacts_ind, dtype = np.int32)\nfaces_nodes = np.array(faces_nodes, dtype = np.int32)\nfaces_FE = np.array(faces_FE, dtype = np.int32)\n\n\n\n\n\noutput = mesh.print_hello_pyth( contacts_ind,  np.array(blocks, dtype = np.float64) , np.array(points[:, 1:4 ], dtype = np.float64),  faces_FE, faces_nodes, np.array(blocks_centroid, dtype = np.float64) , \\\n                       np.array(local_ref,dtype = np.float64), lc_faces_val )\n\n\n\n\nsupports_nodes = set()\n\n\nfor pos in supports_pos:\n    for tri in output[4][pos]:\n            supports_nodes.update({ tri[0], tri[1], tri[2] } )\n\nsupports_nodes = list(supports_nodes)\n\nall_coh_nodes = set()\nall_coh_val = []\n\n\nfor ind, coh in enumerate(coh_type):\n    if coh != -1:\n     \n        faces_pos = faces_rep.index( plans_rep[ind] )\n        contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n        contact_nodes = set()\n        for tri in output[4][contact_pos]:\n            contact_nodes.update( {tri[0], tri[1], tri[2] })\n        \n        all_coh_nodes.update(contact_nodes) \n        all_coh_val += [coh for i in range(len(contact_nodes))] \n\n\nall_coh_nodes = list(all_coh_nodes)\n\n\n\nall_phi_nodes = set()\nall_phi_val = []\n\n\nfor ind, phi in enumerate(phi_type):\n    if phi != -1:\n        \n        faces_pos = faces_rep.index( plans_rep[ind] )\n        contact_pos = contacts_ind_sorted.index( faces_pos + 1 )\n\n        contact_nodes = set()\n        for tri in output[4][contact_pos]:\n            contact_nodes.update( {tri[0], tri[1], tri[2] })\n        \n        all_phi_nodes.update(contact_nodes) \n        all_phi_val += [phi for i in range(len(contact_nodes))] \n\n\nall_phi_nodes = list(all_phi_nodes)\n\n\n\nbars_data = np.unique(bars_data,axis = 0)\n#old part \n\n\ndef problem_building_up(blocks_centroid,points,faces,blocks,local_ref,blocks_att):\n    kc = 0\n    all_mesh_points = np.empty((0,6))\n    all_unique_points = np.empty((0,6))\n    \n    all_triangles = np.empty((0,3))\n    all_triangles_coor = []\n\n    noc_triangles = np.empty((0,3))\n    noc_triangles_coor = []\n    \n    equilibrium_data = []\n    equilibrium_line = []\n    equilibrium_col = []\n    equilibrium_matrix_row = []\n    equilibrium_matrix_col = []\n\n    all_supports_ind = []\n   \n    faces_ind_read = []\n    equilibrium_matrix = []\n    fig = go.Figure()\n    \n    equilibrium_matrix_row = output[1]\n    equilibrium_matrix_col = output[2]\n    equilibrium_matrix = output[0]\n\n    from scipy.linalg import block_diag\n\n\n    \n    if False:\n        #PORTIOLLI PART\n        all_mesh_points = np.empty((0,6))\n        equilibrium_data = []\n        equilibrium_line = []\n        equilibrium_col = []\n        equilibrium_matrix_row = []\n        equilibrium_matrix_col = []\n    \n    \n        equilibrium_matrix = []\n        for block_ind, block_centroid in enumerate(blocks_centroid[:,-3:]):\n            \n            contact_pos = np.where( (blocks[:,0] == block_ind +1) & ( (blocks[:,4] == 1 ) | (blocks[:,4] == 2 )  ) )\n            \n            if len(contact_pos) != 0:\n                contact_ind = [ blocks[element][1] for element in contact_pos[0]]\n                contact_ind_old = [ blocks[element][3] for element in contact_pos[0]]\n                \n                \n                \n                m_fx =  []\n                m_fy =[]\n                m_fz = []\n                equilibrium_fx = []\n                equilibrium_fy = []\n                equilibrium_fz = []\n                \n                points_number = all_mesh_points.shape[0]\n                \n                for ind, face in  enumerate(contact_ind):\n                    \n                        \n                    face_data = np.where(faces[:,0] == int(face))\n                    \n                    face_points_ind = faces[face_data,2]\n                    \n                    face_points_ind = [int(element)-1 for element in face_points_ind[0]]\n                    face_points = points[face_points_ind]\n                    face_points_coor = face_points[:,-3:]\n                   \n                    face_points_coor = np.array([[float(element) for element in line]  for line in face_points_coor ]  )\n                    \n                    \n                    face_mesh(face_points_coor)\n                    mesh_points = face_mesh_read()[0]\n                  \n                    #mesh_points = np.array([[np.round(element,30) for element in row ] for row in mesh_points])\n                    mesh_points = face_points_coor # no mesh effect\n                    \n                    \n                    local_ref_face = local_ref[ np.where(local_ref[:,0] == contact_ind_old[ind])[0] ][0]\n                    \n                    #global_ref_face = [  float(local_ref_face[2]) +  float(local_ref_face[5]) + float(local_ref_face[8]), \\\n                     #                 float(local_ref_face[3]) +  float(local_ref_face[6]) + float(local_ref_face[9]), \\\n                      #                  float(local_ref_face[1]) +  float(local_ref_face[4]) + float(local_ref_face[7])]\n                    \n                    equilibrium_fx += [  float(local_ref_face[4]) , float(local_ref_face[7]),  float(local_ref_face[1])  ]* mesh_points.shape[0] \n                    equilibrium_fy += [   float(local_ref_face[5]) , float(local_ref_face[8]), float(local_ref_face[2]) ,]* mesh_points.shape[0]\n                    equilibrium_fz += [  float(local_ref_face[6]) , float(local_ref_face[9]), float(local_ref_face[3])]* mesh_points.shape[0]\n                    \n                    \n                    \n                    x_local = [ float(local_ref_face[4]) ,  float(local_ref_face[5]) , float(local_ref_face[6])]\n                    y_local = [ float(local_ref_face[7]) ,  float(local_ref_face[8]) , float(local_ref_face[9])]\n                    normal =   [ float(local_ref_face[1]) ,  float(local_ref_face[2]) , float(local_ref_face[3])]\n                    \n                    for point in mesh_points:\n                        x_local_moment = calculate_moment(block_centroid, x_local, point)\n                        y_local_moment = calculate_moment(block_centroid, y_local, point)\n                        normal_moment = calculate_moment(block_centroid, normal, point)\n                        \n                        \n                        \n                        \n                        \n                        \n                        #m_fx +=  [x_local_moment[0], y_local_moment[0], normal_moment[0] ] \n                        #m_fy +=  [x_local_moment[1]*0, 0*y_local_moment[1]*0, normal_moment[1]*0 ]\n                        #m_fz +=  [x_local_moment[2], y_local_moment[2], normal_moment[2] ]\n                        \n                        m_fx +=  [x_local_moment[0], y_local_moment[0], normal_moment[0] ] \n                        m_fy +=  [x_local_moment[1], y_local_moment[1],normal_moment[1] ]\n                        m_fz +=  [x_local_moment[2], y_local_moment[2], normal_moment[2] ]\n                        \n                    \n                    \n                \n                        \n                    #non_zero_elements = [x for x in A if x != 0]\n                    #indices_of_non_zero_elements = [i for i, x in enumerate(A) if x != 0]\n    \n                    part_to_add = np.array([[str(block_ind +1), str(contact_ind[ind]), str(contact_ind_old[ind])] for _ in range(mesh_points.shape[0])])\n                    mesh_points = np.append(mesh_points, part_to_add,axis = 1)\n                    \n                    all_mesh_points = np.append( all_mesh_points, mesh_points,axis = 0)\n                    \n        \n        \n        \n        \n            equilibrium_block = np.array([equilibrium_fx, equilibrium_fy,equilibrium_fz, m_fx, m_fy, m_fz])\n            from scipy.sparse import csr_matrix\n            # Convert the array to a sparse matrix\n            \n            sparse_matrix = csr_matrix(equilibrium_block)\n            \n            # Get the non-zero elements and their indices\n            nonzero_elements = sparse_matrix.data\n            row_indices, col_indices = sparse_matrix.nonzero()\n    \n            \n            equilibrium_matrix = equilibrium_matrix + list(nonzero_elements)\n            \n            \n            row_indices = [element + 6*block_ind for element in row_indices]\n            \n            col_indices = [element + 3*points_number for element in col_indices]\n            \n            \n            equilibrium_matrix_row += row_indices\n            equilibrium_matrix_col += col_indices\n\n\n    #END PORTIOLLI\n    \n    \n    \n    \n   \n    \n    nb = int((max(equilibrium_matrix_row) + 1)/6)\n    \n\n    \n    # Specify the number of repetitions\n    n = all_mesh_points.shape[0]\n    \n    equilibrium_matrix_row = output[1]\n    equilibrium_matrix_col = output[2]\n    equilibrium_matrix = output[0]\n    \n   \n    \n    equilibrium_matrix_row = [int(element) for element in equilibrium_matrix_row]\n    #equilibrium_matrix_row.insert(50,3)\n \n    equilibrium_matrix_col = [int(element) for element in equilibrium_matrix_col]\n    \n    #equilibrium_matrix_col.insert(50,3*n)\n    \n\n\n    # Print the result\n    live_load = [0]*6*nb\n\n    #B_attributes = blocks_attributes(file)\n    n = int((max(equilibrium_matrix_col)+1)/3)\n    \n\n    if True:\n        for block_attributes in blocks_att:\n            for ind in range(1,len(block_attributes),2):\n                key = block_attributes[ind]\n              \n                \n                val = block_attributes[ind+1]\n\n                \n\n                #first_ind = equilibrium_matrix_row.index( (block_attributes[0])*6 - 6 + key - 1 )\n                \n                live_load[(block_attributes[0])*6 - 6 + key - 1] =  float(val)\n                \n                equilibrium_matrix.append( float(val))\n                equilibrium_matrix_row.append(  (block_attributes[0])*6 - 6 + key - 1  )\n                equilibrium_matrix_col.append(3*n)\n    \n    \n    \n    \n    \n    #equilibrium_matrix.insert(0, 1)\n   \n       \n    \n    equilibrium_matrix_row = [int(element) for element in equilibrium_matrix_row]\n    #equilibrium_matrix_row.insert(0,0)\n \n    equilibrium_matrix_col = [int(element) for element in equilibrium_matrix_col]\n    \n\n\n    c = np.zeros((3*n +1,1))\n    #c =  spmatrix( [-1], [3*n], [0], (3*n +1, 1 ) )     \n    c[3*n] = -1\n    c = matrix(c) # dead load vector x (-1)\n    \n    b = np.zeros((6*nb,1 )) \n    \n    density = 1/7 # blocks density\n   \n    for block_ind, block_volume in enumerate(blocks_volume):\n        b[6*block_ind +2] = density*block_volume[1] \n        #b[6*block_ind +3] = 3*1.4\n\n\n\n    \n\n  \n\n\n    \n    all_supports_ind = np.array(all_supports_ind)\n    \n    import sys\n    import mosek\n    import math\n    # Since the actual value of Infinity is ignores, we define it solely\n    # for symbolic purposes:\n    inf = 0.0\n\n    aval = equilibrium_matrix\n    acol = equilibrium_matrix_col\n    arow = equilibrium_matrix_row\n\n    avalk = equilibrium_matrix\n    acolk = equilibrium_matrix_col\n    arowk = equilibrium_matrix_row\n    #static approach\n    bars_cap = []\n   \n    if True:\n\n        for ind, point_coor in enumerate(bpts_inter):\n            blocks_data = bars_data[ np.where(bars_data[:,1] == ind +1)[0] ]\n            var_col = max(acol) + 1\n         \n            bars_cap.append( float(blocks_data[0][2]) * float(blocks_data[0][3] ) )\n            \n            for block in blocks_data:\n                block_ind = int(block[0]) - 1\n                block_centroid = blocks_centroid[block_ind][-3:]\n                bar_dir = block[-3:]\n                bar_dir = [float(element) for element in bar_dir]\n               \n                bar_moment = calculate_moment( block_centroid, bar_dir, point_coor )\n              \n                bar_tor = list(bar_dir) + list(bar_moment)\n           \n                nzero_pos = [ind for ind in range(6) if np.round(bar_tor[ind],5) != 0]\n              \n                for pos in nzero_pos:\n                  \n                    arow.append( block_ind*6 + pos )\n                    acol.append( var_col )\n                    aval.append( float(bar_tor[pos]) )\n                \n                \n            \n            \n            \n            \n        \n    \n    \n    \n\n    n = int((max(equilibrium_matrix_col)+1)/3)\n    \n    if True:\n        with mosek.Task() as task:\n            task = mosek.Task() \n            # Attach a printer to the task\n            task.set_Stream(mosek.streamtype.log, streamprinter)\n    \n            nef = n \n          \n            bkx = []\n            cohs = []\n            #bkx = [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up]*nef   #variables lower bounded, if free just put .fr\n            for i in range(nef):\n                if i not in supports_nodes:\n                    bkx += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.up] #variables lower bounds\n                else:\n                    bkx += [mosek.boundkey.fr, mosek.boundkey.fr, mosek.boundkey.fr] #variables lower bounds\n\n            bkx +=  [mosek.boundkey.lo]*1 + [mosek.boundkey.ra]*len(bars_cap)\n\n            blx = []\n            bux = []\n            for i in range(nef):\n                blx += [-inf, -inf , -20 ] #variables lower bounds\n                \n            blx +=  [0]*1 +  [ -0*element for element in bars_cap] \n            \n            for i in range(nef):\n                if i not in supports_nodes:\n                    bux += [-inf, -inf , 0 ] #variables lower bounds\n                else:\n                    bux += [-inf, -inf , -inf ] #variables lower bounds\n                \n            bux += [inf]*1 + list(bars_cap) #variables upper bounds\n        \n           \n            #ne = nb*6 + max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1 #num of equalities\n            \n            bkc = [mosek.boundkey.fx]*nb*6 #type of constraints (equalities here)\n            blc = list(b)    #b for equalities\n            buc = list(b) #b for equalities\n          \n            \n            if False:\n                bkc = [mosek.boundkey.fx]*ne #type of constraints (equalities here)\n    \n                \n                blc = list(b) + [0]*(max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1)   #b for equalities\n                buc = list(b) + [0]*(max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1) #b for equalities\n            \n            c = np.zeros((3*nef +1,1))\n            #c =  spmatrix( [-1], [3*n], [0], (3*n +1, 1 ) )     \n            c[3*nef] = -1\n            \n            z = [element for element in list(c)] + [0]*len(bars_cap) #objective function \n\n            \n            eq_dense =[]\n            aval = list(aval)\n            arow = list(arow)\n            acol = list(acol)\n         \n            #aval[13] *= -1\n            #aval[17] *= -1\n            \n            \n            \n            if False:\n                aval = equilibrium_matrix.copy() + contact_eq_element_x.copy() + contact_eq_element_y.copy() + contact_eq_element_z.copy()\n                    \n                arow = equilibrium_matrix_row.copy()\n                init_ind = max(arow) +1\n                arow += [element + init_ind   for element in contact_eq_row_x]\n                init_ind = max(arow) +1\n                arow += [element +  init_ind for element in contact_eq_row_y]\n                init_ind = max(arow) +1\n                arow += [element + init_ind for element in contact_eq_row_z]\n                \n                \n                \n                acol = equilibrium_matrix_col + contact_eq_col_x + contact_eq_col_y + contact_eq_col_z\n    \n            # equalities for kinematic problem\n            arowk = acol.copy()\n            acolk = arow.copy()\n            avalk = aval.copy()\n\n            ####### a remettre\n            if False:\n                for i in range(3*nef):\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(index, 6*nb + i)\n                    avalk.insert(index, 1)\n                    if ((i+1) % 3 == 0):\n                        index = arowk.index(i)\n                        arowk.insert(index, i)\n                        acolk.insert(  index, 6*nb + 3*n + int((i+1)/3) - 1 )\n                        avalk.insert(index, 1)\n\n             ###### till here        \n      \n           \n            num_lists = 3*nef + 1 + len(bars_cap)  # Adjust the number of inner lists as needed\n    \n          \n            asub_mos = [[] for _ in range(num_lists)]\n            aval_mos  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acol):\n                asub_mos[int(j)].append(arow[i])\n                aval_mos[int(j)].append(aval[i])\n            \n            numvar = len(bkx)\n            numcon = len(bkc)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar)\n    \n            for j in range(numvar):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z[j])\n                # Set the bounds on variable j\n                # blx[j] <= x_j <= bux[j]\n                task.putvarbound(j, bkx[j], blx[j], bux[j])\n            \n            \n            for j in range(len(aval_mos)):\n                \n               \n                # Input column j of A\n                task.putacol(j,     asub_mos[j],aval_mos[j])            # Non-zero Values of column j.\n            \n         \n        # Input the affine conic constraints\n            # Create a matrix F such that F * x = [x(3),x(0),x(1),x(4),x(5),x(2)] \n            task.appendafes(3*nef)\n         \n            list_con = []\n            list_coef = []\n            friction_ang = 33\n            for ind in range(nef):\n                if (ind +1) not in supports_nodes:\n                    friction_ang = 33\n                    c = 0 # input value\n                    \n                    if (ind+1) in all_phi_nodes:\n                        friction_ang = float(all_phi_val[all_phi_nodes.index(ind + 1)])\n                     \n                        \n                    \n\n                    if (ind+1) in all_coh_nodes:\n                        c = all_coh_val[all_coh_nodes.index(ind+1)]\n                        \n                    cohs += [-c,0,0]\n                    list_con += [3*ind + 2 , 3*ind,3*ind + 1]\n                   \n                    list_coef += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n             \n            task.putafefentrylist(range(3*nef - len(supports_nodes) ),                      # Rows\n                                list_con ,            # Columns \n                                list_coef  )          #coefficients\n    \n            # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n            \n            \n            coh_vect = []\n            for ind in range(nef - len(supports_nodes) ):\n                \n                #if ind not in all_supports_ind:\n                if True:\n                   \n                    coh = cohs[3*ind: 3*ind +3]\n                   \n                    coh_vect += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,          [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n           \n            \n           \n            \n            for i in range(numcon):\n                task.putconbound(i, bkc[i], blc[i], buc[i])\n    \n    \n        # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n    \n            # Optimize the task\n            task.optimize()\n            #task.writedata(\"cqo1.ptf\")\n            # Print a summary containing information\n            # about the solution for debugging purposes\n            task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            xx = task.getxx(mosek.soltype.itr)\n            ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            #print(\"xxx\",xx)\n            print(task.getsuc(mosek.soltype.itr)[0:6*nb])\n            print(task.getslc(mosek.soltype.itr)[0:6*nb])\n            print(ub)\n            #print(\"conic\",task.getdoty(mosek.soltype.itr))\n            \n            #skc, y = task.getsolution(mosek.soltype.bas)\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % xx[-1:])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n                \n              \n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n           # Clear or reset the task\n            \n            #del task  # Delete the task object\n    \n    \n\n        \n    #non associative calc\n    tol =1\n    itr = 0\n    alpha=0.3 \n    beta=0.6\n    #tolerance=0.001\n    tolerance=0.0001\n    \n    non_ass = False\n    if non_ass:\n    \n        while tol >tolerance: \n    \n            # Check if the solver found an optimal solution\n            if solsta == mosek.solsta.optimal:\n          \n                if itr>1:\n                    normalvalues_old = normalvalues\n                else:\n                    normalvalues_old = np.zeros((int(nef) - len(all_supports_ind),1))\n    \n                statsolver_old = xx[-1:][0]    \n                \n                normalvalues = np.empty((0,1))\n               \n                \n                for element in range(0,len(xx)-2,3):\n                    if int(element /3) not in all_supports_ind:\n                        normalvalues = np.append(normalvalues,xx[element+2]) \n            \n            coh_vect_new = [0,0,0]*len(coh_vect)\n            friction_coef = [1,1,1]*len(list_coef)\n         \n            for element in range(int(nef - len(all_supports_ind))):\n               \n                if itr >1:\n                    coh_vect_new[3*element] = 0.00001*min(normalvalues) + coh_vect[3*element] + (1+alpha)*abs(list_coef[3*element])*(beta*normalvalues[element] + (1-beta)*normalvalues_old[element])\n                    friction_coef[3*element] = math.tan(math.radians(friction_ang)*alpha)\n                    \n                else:\n        \n                    coh_vect_new[3*element] = 0.00001*min(normalvalues) + coh_vect[3*element] + (1+alpha)*abs(list_coef[3*element])*(normalvalues[element] )\n                    friction_coef[3*element] = math.tan(math.radians(friction_ang)*alpha)\n                    \n            #-list_coef[3*element]*alpha\n            statsol_old = xx\n    \n    \n            #mosek\n            with mosek.Task() as task:\n                # Attach a printer to the task\n                task.set_Stream(mosek.streamtype.log, streamprinter)\n        \n                \n             # Append 'numcon' empty constraints.\n                # The constraints will initially have no bounds.\n                task.appendcons(numcon)\n        \n                #Append 'numvar' variables.\n                # The variables will initially be fixed at zero (x=0).\n                task.appendvars(numvar)\n        \n                for j in range(numvar):\n                    # Set the linear term c_j in the objective.\n                    task.putcj(j, z[j])\n                    # Set the bounds on variable j\n                    # blx[j] <= x_j <= bux[j]\n                    task.putvarbound(j, bkx[j], blx[j], bux[j])\n                \n                \n                for j in range(len(aval_mos)):\n                    \n                   \n                    # Input column j of A\n                    task.putacol(j,      asub_mos[j],aval_mos[j])            # Non-zero Values of column j.\n                \n                \n        \n            # Input the affine conic constraints\n                # Create a matrix F such that F * x = [x(3),x(0),x(1),x(4),x(5),x(2)] \n                task.appendafes(3*nef)\n                \n                list_con = []\n                \n\n                for ind in range(nef):\n                    if ind not in all_supports_ind:\n                    \n                        list_con += [3*ind + 2 , 3*ind,3*ind + 1]\n                        #list_coef += [-math.tan(math.radians(friction_ang)),1.0,1.0]\n                    \n                task.putafefentrylist(range(3*nef - len(all_supports_ind) ),                      # Rows\n                                    list_con ,            # Columns \n                                    friction_coef  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n                \n                #coh_vect = []\n                for ind in range(nef - len(all_supports_ind) ):\n                    \n                    #if ind not in all_supports_ind:\n                    if True:\n                        quadcone  = task.appendquadraticconedomain(3)\n                        task.appendacc(quadcone,                 [3*ind, 3*ind +1, 3*ind + 2],   [coh_vect_new[3*ind], coh_vect_new[3*ind +1] , coh_vect_new[3*ind +2] ] )                    # None if there is no b for conic \n           \n                \n                for i in range(numcon):\n                    task.putconbound(i, bkc[i], blc[i], buc[i])\n        \n        \n            # Input the objective sense (minimize/maximize)\n                task.putobjsense(mosek.objsense.minimize)\n        \n                # Optimize the task\n                task.optimize()\n                #task.writedata(\"cqo1.ptf\")\n                # Print a summary containing information\n                # about the solution for debugging purposes\n                task.solutionsummary(mosek.streamtype.msg)\n                prosta = task.getprosta(mosek.soltype.itr)\n                solsta = task.getsolsta(mosek.soltype.itr)\n        \n                # Output a solution\n                xx = task.getxx(mosek.soltype.itr)\n                \n                ub = [task.getsuc(mosek.soltype.itr)[ind] - task.getslc(mosek.soltype.itr)[ind]  for ind in range(6*nb) ] # get dual variables for equilibrium but why upper ? not slb\n            \n                \n                #skc, y = task.getsolution(mosek.soltype.bas)\n                if solsta == mosek.solsta.optimal:\n                    print(\"Objective: %s\" % xx[-1:])\n                    #print(\"Optimal solution: %s\" % dual(xx))\n                    # Get dual variables for the linear constraints\n                    \n                  \n                elif solsta == mosek.solsta.dual_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif solsta == mosek.solsta.prim_infeas_cer:\n                    print(\"Primal or dual infeasibility.\\n\")\n                elif mosek.solsta.unknown:\n                    print(\"Unknown solution status\")\n                else:\n                    print(\"Other solution status\")\n            #end mosek\n    \n            if solsta == mosek.solsta.optimal:\n    #define obj do not forget\n                if itr >1:\n                    tol = abs(xx[-1:][0] - statsolver_old)/abs(xx[-1:][0] )\n                    print(\"tolerance\", tol)\n            else:\n                statsol = statsol_old\n                \n            if alpha <= 0.0001:\n                alpha = 0.0001\n            else:\n                alpha = alpha*0.7\n    \n            itr = itr+1\n            # Clear or reset the task\n            \n            del task  # Delete the task object\n                \n\n\n    \n    #end non ass\n\n     #kinematic approach\n    if False:\n        with mosek.Task() as task:\n            task = mosek.Task() \n            # Attach a printer to the task\n            task.set_Stream(mosek.streamtype.log, streamprinter)\n    \n            if False:\n                bkx = [mosek.boundkey.fr]*6*nb + [mosek.boundkey.fr]*(max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1) + \\\n                             [mosek.boundkey.fr,mosek.boundkey.fr,mosek.boundkey.up]*n + [mosek.boundkey.lo]*n  #variables lower bounded, if free just put .fr\n                blx = [-inf ]*6*nb + [-inf]*(max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1) + \\\n                                        [-inf,-inf, -inf]*n + [0]*n #variables lower bounds\n                bux = [inf]*6*nb + [inf]*(max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1) + \\\n                                 [inf, inf, 0]*n + [inf]*n  #variables upper bounds\n        \n            bkx = [mosek.boundkey.fr]*6*nb + [mosek.boundkey.fr,mosek.boundkey.fr,mosek.boundkey.up]*nef + [mosek.boundkey.lo]*2*nef   #variables lower bounded, if free just put .fr\n            blx = [-inf ]*6*nb +  [-inf,-inf, -inf]*nef + [0]*2*nef #variables lower bounds\n            bux = [inf]*6*nb +  [inf, inf, 0]*nef + [inf]*2*nef   #variables upper bounds\n            \n            ne = 3*nef\n            bkc = [mosek.boundkey.fx]*(ne +1 ) #type of constraints (equalities here)\n            blc =  [0]*ne + [1]   #b for equalities\n            buc = [0]*ne + [1]   #b for equalities\n            \n            if False:\n                nvcontact = (max(contact_eq_row_x) +1 + max(contact_eq_row_y) +1 + max(contact_eq_row_z) +1)\n            z = [element[0] for element in list(b)] #objective function \n            \n            if False:\n                z += [0]*(  3*n + n + nvcontact )\n            \n            z += [0,0,-0*0.2/math.tan(math.radians(33))]*(  nef  )\n            z += [0]*nef\n            \n            z += [0.4]*nef\n            \n            # equalities for kinematic problem\n            arowk = acol.copy()\n\n            acolk = arow.copy()\n        \n            avalk = aval.copy()\n\n\n            \n            \n            #acolk += [4]\n        \n          \n            #arowk += [ max(arowk) +1 ]\n            \n            #avalk += [1]\n        \n            #avalk += [0]\n            if False:\n                \n                for i in range(3*n):\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(index, 6*nb + nvcontact + i)\n                    avalk.insert(index, -1)\n                    if ((i+1) % 3 == 0):\n                        index = arowk.index(i)\n                        arowk.insert(index, i)\n                        acolk.insert(  index, 6*nb + nvcontact + 3*n + int((i+1)/3) - 1 )\n                        avalk.insert(index, 1)\n         \n            for i in range(3*nef):\n                index = arowk.index(i)\n                arowk.insert(index, i)\n                acolk.insert(index, 6*nb + i)\n                avalk.insert(index, -1)\n                if ((i+1) % 3 == 0):\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(  index, 6*nb + 3*nef + int((i+1)/3) - 1 )\n                    avalk.insert(index, 1)\n\n                    index = arowk.index(i)\n                    arowk.insert(index, i)\n                    acolk.insert(  index, 6*nb + 3*nef + nef + int((i+1)/3) - 1 )\n                    avalk.insert(index, -1)\n    \n           \n            \n      \n            if False:\n                num_lists = 6*nb + nvcontact + 3*n + n  # Adjust the number of inner lists as needed\n                \n            num_lists = 6*nb  + 3*nef + nef + nef*1  # Adjust the number of inner lists as needed\n    \n          \n            asub_mos = [[] for _ in range(num_lists)]\n            aval_mos  = [[] for _ in range(num_lists)]\n            \n            for i,j in enumerate(acolk):\n                asub_mos[int(j)].append(arowk[i])\n                aval_mos[int(j)].append(avalk[i])\n            \n            numvar = len(bkx)\n            numcon = len(bkc)\n            NUMANZ = 4 \n    \n         # Append 'numcon' empty constraints.\n            # The constraints will initially have no bounds.\n            task.appendcons(numcon)\n    \n            #Append 'numvar' variables.\n            # The variables will initially be fixed at zero (x=0).\n            task.appendvars(numvar)\n    \n            for j in range(numvar):\n                # Set the linear term c_j in the objective.\n                task.putcj(j, z[j])\n                # Set the bounds on variable j\n                # blx[j] <= x_j <= bux[j]\n                task.putvarbound(j, bkx[j], blx[j], bux[j])\n            \n          \n            for j in range(len(aval_mos)):\n                \n               \n                # Input column j of A\n                task.putacol(j,  asub_mos[j],aval_mos[j])            # Non-zero Values of column j.\n            \n            \n           \n        # Input the affine conic constraints\n            # Create a matrix F such that F * x = [x(3),x(0),x(1),x(4),x(5),x(2)] \n            if False:\n                task.appendafes(3*n)\n            \n                list_con = []\n                list_coef = []\n                friction_ang = 33\n                for ind in range(n):\n                    list_con += [ 6*nb + nvcontact + 3*ind + 2 , 6*nb + nvcontact + 3*ind,6*nb + nvcontact + 3*ind + 1]\n                    list_coef += [-1/math.tan(math.radians(30)),1.0,1.0]\n                \n                task.putafefentrylist(range(3*n),                      # Rows\n                                      list_con ,            # Columns \n                                      list_coef  )          #coefficients\n        \n                # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n                \n                coh_vect = []\n                for ind in range(n):\n                    coh = [-0,0, 0]\n                    coh_vect += coh\n                    quadcone  = task.appendquadraticconedomain(3)\n                    task.appendacc(quadcone,            [3*ind, 3*ind +1, 3*ind + 2],  coh)                    # None if there is no b for conic \n            \n            task.appendafes(3*nef)\n           \n            list_con = []\n            list_coef = []\n            \n            friction_ang = 33\n            for ind in range(nef):\n                list_con += [ 6*nb +  3*ind + 2 , 6*nb + 3*ind,6*nb +  3*ind + 1]\n                list_coef += [-1/math.tan(math.radians(friction_ang)),1.0,1.0]\n            \n            task.putafefentrylist(range(3*nef),                      # Rows\n                                  list_con ,            # Columns \n                                  list_coef  )          #coefficients\n    \n            # Quadratic cone (x(3),x(0),x(1)) \\in QUAD_3 \n            \n            coh_vect = []\n            for ind in range(nef):\n                coh = [-0.5*0,0, 0]\n                coh_vect += coh\n                quadcone  = task.appendquadraticconedomain(3)\n                task.appendacc(quadcone,      [3*ind, 3*ind +1, 3*ind + 2],   coh)                    # None if there is no b for conic \n           \n            \n           \n            \n            for i in range(numcon):\n                task.putconbound(i, bkc[i], blc[i], buc[i])\n    \n    \n        # Input the objective sense (minimize/maximize)\n            task.putobjsense(mosek.objsense.minimize)\n    \n            # Optimize the task\n            task.optimize()\n            #task.writedata(\"cqo1.ptf\")\n            # Print a summary containing information\n            # about the solution for debugging purposes\n            task.solutionsummary(mosek.streamtype.msg)\n            prosta = task.getprosta(mosek.soltype.itr)\n            solsta = task.getsolsta(mosek.soltype.itr)\n    \n            # Output a solution\n            kin_sol = task.getxx(mosek.soltype.itr)\n            print(\"kinsol\",kin_sol)\n            #ub = task.getxx(mosek.soltype.itr)[0:6*nb]\n            #ub = task.getsuc(mosek.soltype.itr)[0:6*nb] # get dual variables for equilibrium but why upper ? not slb\n            #skc, y = task.getsolution(mosek.soltype.bas)\n            if solsta == mosek.solsta.optimal:\n                print(\"Objective: %s\" % kin_sol[-1:])\n                #print(\"Optimal solution: %s\" % dual(xx))\n                # Get dual variables for the linear constraints\n                \n              \n            elif solsta == mosek.solsta.dual_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif solsta == mosek.solsta.prim_infeas_cer:\n                print(\"Primal or dual infeasibility.\\n\")\n            elif mosek.solsta.unknown:\n                print(\"Unknown solution status\")\n            else:\n                print(\"Other solution status\")\n           # Clear or reset the task\n            \n            #del task  # Delete the task object\n\n    #end kin\n\n    \n    b = matrix(b)\n   \n    q = [4 for ind in range(n)]\n    h = spmatrix( [0], [0], [3*n], (1,4*n ) )\n    h = np.zeros((4*n,1))\n    h = matrix(h)\n    \n    dims = {'l': 0, 'q': q, 's': []}\n \n    #sol = solvers.conelp(c, MCoul_matrix_sparse , h , dims, equilibrium_matrix_sparse, b)\n  \n    if False:\n        # ipopt part\n        ind = [element + 1 for element in range(len(equilibrium_matrix))]\n        \n        \n        equilibrium_matrix_row = [element + 1 for element in equilibrium_matrix_row] \n        \n        A_ipopt = np.array([ind, equilibrium_matrix_row,equilibrium_matrix_col,equilibrium_matrix]).T\n        \n        ind = [element + 1 for element in range(len(b))]\n        \n        b_ipopt = [element for element in b]\n        \n        b_ipopt = np.array([ind, b_ipopt]).T\n        \n        c_ipopt = np.array([[1,3*n,1]])\n\n\n        A_df = pd.DataFrame(  A_ipopt,  columns=[\"Aline\",\"ALineInd\",\"AColInd\",\"AVal\"], ).set_index(\"Aline\")\n\n        # Create a pandas.DataFrame with data for n_min, n_max\n        b_df = pd.DataFrame( b_ipopt , columns=[\"bline\", \"BVal\"],).set_index(\"bline\")\n\n        c_df = pd.DataFrame(c_ipopt ,columns=[\"cline\", \"CInd\", \"CVal\"],).set_index(\"cline\")\n        \n        \n        \n        \n        \n\n\n        ind = [element + 1 for element in range(len(contact_eq_element_x))]\n        contact_eq_row_x = [element + 1 for element in contact_eq_row_x] \n        Cx_ipopt = np.array([ind, contact_eq_row_x,contact_eq_col_x,contact_eq_element_x]).T\n\n        \n        ind = [element + 1 for element in range(len(contact_eq_element_y))]\n        contact_eq_row_y = [element + 1 for element in contact_eq_row_y] \n        Cy_ipopt = np.array([ind, contact_eq_row_y,contact_eq_col_y,contact_eq_element_y]).T\n\n        ind = [element + 1 for element in range(len(contact_eq_element_z))]\n        contact_eq_row_z = [element + 1 for element in contact_eq_row_z] \n        Cz_ipopt = np.array([ind, contact_eq_row_z,contact_eq_col_z,contact_eq_element_z]).T\n        \n        Cx_df = pd.DataFrame(Cx_ipopt,columns=[\"Cxline\",\" CxLineInd\",\"CxColInd\",\"CxVal\"],).set_index(\"Cxline\")\n        \n        Cy_df = pd.DataFrame( Cy_ipopt,columns=[\"Cyline\",\" CyLineInd\",\"CyColInd\",\"CyVal\"],).set_index(\"Cyline\")\n        \n        Cz_df = pd.DataFrame(Cz_ipopt,columns=[\"Czline\",\" CzLineInd\",\"CzColInd\",\"CzVal\"],).set_index(\"Czline\")\n    \n    #ub = ipopt_data(A_df,b_df,c_df,Cx_df , Cy_df, Cz_df)\n    #ub =[]\n    x = []\n    \n    #stat_rep(all_unique_points,noc_triangles_coor,noc_triangles,all_triangles_coor,all_triangles,xx)\n    #stat_rep1(all_unique_points,noc_triangles_coor,noc_triangles,all_triangles_coor,all_triangles,xx)\n    all_unique_points = output[3]\n    all_triangles = output[4]\n    triangles_num = max(output[5]) \n\n    noc_triangles_coor = output[6]\n    noc_triangles = output[7]\n    Ntriangles_num = max(output[8]) \n\n    stat_parav(all_unique_points,noc_triangles_coor,noc_triangles,triangles_num ,all_triangles,Ntriangles_num,xx[0:3*n+1])\n\n    return ub\n\ndef face_mesh(nodes):\n\n    # Initialize gmsh:\n    gmsh.initialize()\n    \n    # Def&ine nodes in Gmsh using the NumPy array:\n    lc = 100\n    node_tags = [gmsh.model.geo.add_point(x, y, z, lc) for x, y, z in nodes]\n    \n    # Define lines forming a square connected in a loop using a for loop:\n    lines = []\n    for i in range(len(node_tags)):\n        line = gmsh.model.geo.add_line(node_tags[i], node_tags[(i + 1) % len(node_tags)])\n        lines.append(line)\n    \n    # Define a loop connecting the lines to form a face:\n    loop = gmsh.model.geo.add_curve_loop(lines)\n    \n    # Define a surface using the loop:\n    face = gmsh.model.geo.add_plane_surface([loop])\n    \n    # Create the relevant Gmsh data structures from the Gmsh model:\n    gmsh.model.geo.synchronize()\n    \n    # Generate mesh:\n    gmsh.model.mesh.generate()\n    \n    # Write mesh data:\n    #gmsh.write(\"C:\\\\Users\\\\mmoussa\\\\Desktop\\\\rhino_test\\\\square_face.msh\")\n    elements = gmsh.model.mesh.getElements(dim=2, tag=-1)[2][0]\n    elements = [ int(element -1) for element in elements]\n    points = gmsh.model.mesh.get_nodes()[1]  # Coordinates of the mesh nodes\n    \n    nodes = [  list(points[ind:ind +3])   for ind in range(0,len(points), 3)]\n\n    triangles = [  list(elements [ind:ind +3])   for ind in range(0,len(elements), 3)]\n    gmsh.finalize()\n    return nodes,triangles\n\n\ndef face_mesh_read():\n    \n    \n    # Read the mesh file\n    mesh = meshio.read(\"C:\\\\Users\\\\mmoussa\\\\Desktop\\\\rhino_test\\\\square_face.msh\")\n    \n    # Access mesh information\n    points = mesh.points  # Coordinates of the mesh nodes\n    cells = mesh.cells  # Connectivity information for mesh elements (e.g., triangles, tetrahedra)\n    point_data = mesh.point_data  # Data associated with each mesh node\n    cell_data = mesh.cell_data  # Data associated with each mesh element\n    \n    \n    # Example: Print connectivity of the first 5 triangles\n    triangle_cells = None\n    for cell_block in cells:\n        if \"triangle\" in cell_block.type.lower():\n            triangle_cells = cell_block.data\n            break\n    \n    if triangle_cells is not None:\n        #print(f\"Connectivity of the first 5 triangles:\")\n        #print(triangle_cells[:5])\n    \n        # Get coordinates of each point in the first 5 triangles\n        for triangle in triangle_cells:\n            triangle_coordinates = points[triangle]\n           \n    else:\n        print(\"No triangle cells found in the mesh.\")\n    return points, triangle_cells\n\n\nub  = problem_building_up(blocks_centroid,points,faces,blocks,local_ref,blocks_att)\nblock_disp_plot(blocks_centroid,blocks,faces,points,ub)\n\n\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}