{
  "source_url": "https://github.com/VinCheetah/PyCalendar/blob/ba459308bba67299d6f3c1dc24f5308f532e990b/scripts/sport_utils.py",
  "repo": "VinCheetah/PyCalendar",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "scripts/sport_utils.py",
  "instruction": "Utilitaires pour la gestion des sports - Interface simplifiÃ©e.",
  "code": "#!/usr/bin/env python3\n\"\"\"\nUtilitaires pour la gestion des sports - Interface simplifiÃ©e.\n\nCe module fournit une interface de compatibilitÃ© pour les anciens scripts\ntout en utilisant le nouveau module script_base.py en interne.\n\nPour les nouveaux scripts, utilisez directement script_base.py:\n    from scripts.script_base import ScriptContext, Sport, create_base_parser\n\nUsage legacy:\n    from scripts.sport_utils import load_sport_from_config, find_latest_solution\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# Setup path pour import\n_SCRIPTS_DIR = Path(__file__).resolve().parent\n_PROJECT_ROOT = _SCRIPTS_DIR.parent\nif str(_PROJECT_ROOT) not in sys.path:\n    sys.path.insert(0, str(_PROJECT_ROOT))\n\n# RÃ©exporter depuis script_base pour compatibilitÃ©\nfrom scripts.script_base import (\n    # Classes principales\n    Sport as SportInfo,\n    ScriptContext,\n    \n    # Constantes\n    PROJECT_ROOT,\n    SOLUTIONS_DIR,\n    CONFIGS_DIR,\n    DATA_DIR,\n    SPORT_MAPPINGS,\n    CODE_TO_TYPE,\n    TYPE_TO_CODE,\n    PATTERN_TO_CODE,\n    CODE_TO_PATTERN,\n    SPORT_ALIASES,\n    \n    # Fonctions utilitaires\n    extraire_sport_code,\n    extraire_genre_niveau,\n    create_base_parser,\n    print_header,\n    print_success,\n    print_error,\n    print_warning,\n    print_info,\n)\n\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\n\n# ============================================================================\n# FONCTIONS DE COMPATIBILITÃ‰ (LEGACY API)\n# ============================================================================\n\ndef load_sport_from_config(config_path: str) -> SportInfo:\n    \"\"\"\n    Charge les informations de sport depuis un fichier de configuration YAML.\n    \n    LEGACY: PrÃ©fÃ©rez ScriptContext(config_path=...) pour les nouveaux scripts.\n    \"\"\"\n    ctx = ScriptContext(config_path=Path(config_path))\n    return SportInfo(\n        code=ctx.sport.code,\n        type=ctx.sport.type,\n        pattern=ctx.sport.pattern,\n        name=ctx.sport.name,\n        name_short=ctx.sport.name_short,\n        emoji=ctx.sport.emoji,\n        duree_match=ctx.sport.duree_match,\n        score_format=ctx.sport.score_format,\n    )\n\n\ndef find_latest_solution(sport_pattern: str, solutions_dir: str = None) -> Optional[Path]:\n    \"\"\"\n    Trouve le dernier fichier solution pour un sport donnÃ©.\n    \n    LEGACY: PrÃ©fÃ©rez ScriptContext(sport_arg=...).solution_path pour les nouveaux scripts.\n    \"\"\"\n    solutions_path = Path(solutions_dir) if solutions_dir else SOLUTIONS_DIR\n    \n    if not solutions_path.exists():\n        return None\n    \n    # PrioritÃ© 1: latest_{sport}.json\n    latest_file = solutions_path / f\"latest_{sport_pattern}.json\"\n    if latest_file.exists():\n        return latest_file\n    \n    # PrioritÃ© 2: Dernier solution_{sport}_*.json\n    solution_files = sorted(\n        solutions_path.glob(f\"solution_{sport_pattern}_*.json\"),\n        key=lambda f: f.stat().st_mtime,\n        reverse=True\n    )\n    \n    return solution_files[0] if solution_files else None\n\n\ndef get_sport_code_from_solution(solution_data: Dict[str, Any]) -> str:\n    \"\"\"\n    Extrait le code sport depuis les donnÃ©es de solution.\n    \n    LEGACY: PrÃ©fÃ©rez Sport.detect_from_solution(data).code\n    \"\"\"\n    sport = SportInfo.detect_from_solution(solution_data)\n    return sport.code if sport else 'VB'\n\n\ndef get_sport_pattern_from_code(code: str) -> str:\n    \"\"\"\n    Convertit un code sport en pattern de fichier.\n    \n    LEGACY: PrÃ©fÃ©rez Sport.from_code(code).pattern\n    \"\"\"\n    return CODE_TO_PATTERN.get(code.upper(), 'volley')\n\n\ndef detect_sport_from_filename(filename: str) -> Optional[SportInfo]:\n    \"\"\"\n    DÃ©tecte le sport depuis un nom de fichier.\n    \n    LEGACY: PrÃ©fÃ©rez Sport.detect_from_filename(filename)\n    \"\"\"\n    return SportInfo.detect_from_filename(filename)\n\n\ndef get_sport_info_from_poule(code_poule: str) -> SportInfo:\n    \"\"\"\n    Obtient les informations du sport depuis un code de poule.\n    \n    LEGACY: PrÃ©fÃ©rez Sport.from_poule_code(code)\n    \"\"\"\n    return SportInfo.from_poule_code(code_poule)\n\n\ndef resolve_sport_and_solution(\n    config_path: Optional[str] = None,\n    sport_arg: Optional[str] = None,\n    solution_path: Optional[str] = None,\n    default_sport: str = 'volley'\n) -> tuple:\n    \"\"\"\n    RÃ©sout le sport et le fichier solution depuis les arguments.\n    \n    LEGACY: PrÃ©fÃ©rez ScriptContext.from_args(args)\n    \"\"\"\n    ctx = ScriptContext(\n        config_path=Path(config_path) if config_path else None,\n        solution_path=Path(solution_path) if solution_path else None,\n        sport_arg=sport_arg or default_sport,\n    )\n    \n    return ctx.sport, ctx.solution_path\n\n\n# Alias pour compatibilitÃ© avec le code existant\nSUPPORTED_SPORT_CODES = list(SPORT_MAPPINGS.keys())\nSPORT_TYPE_TO_PATTERN = {v[0]: v[1] for v in SPORT_MAPPINGS.values()}\nPATTERN_TO_SPORT_TYPE = {v[1]: v[0] for v in SPORT_MAPPINGS.values()}\nCODE_TO_SPORT_TYPE = CODE_TO_TYPE\nSPORT_TYPE_TO_CODE = TYPE_TO_CODE\n\n\n# ============================================================================\n# TEST\n# ============================================================================\n\nif __name__ == '__main__':\n    print(\"=\" * 70)\n    print(\"Test du module sport_utils.py (API de compatibilitÃ©)\")\n    print(\"=\" * 70)\n    \n    # Test load_sport_from_config\n    print(\"\\nðŸ“‹ Test: load_sport_from_config\")\n    try:\n        sport = load_sport_from_config(\"configs/config_volley.yaml\")\n        print(f\"   Sport: {sport.name} {sport.emoji}\")\n        print(f\"   Code: {sport.code}, Pattern: {sport.pattern}\")\n    except Exception as e:\n        print(f\"   Erreur: {e}\")\n    \n    # Test find_latest_solution\n    print(\"\\nðŸ“ Test: find_latest_solution\")\n    solution = find_latest_solution(\"volley\")\n    print(f\"   Solution: {solution.name if solution else 'Non trouvÃ©e'}\")\n    \n    # Test extraire_sport_code\n    print(\"\\nðŸ Test: extraire_sport_code\")\n    print(f\"   VBFA1PA -> {extraire_sport_code('VBFA1PA')}\")\n    print(f\"   HBMA3PB -> {extraire_sport_code('HBMA3PB')}\")\n    \n    # Test extraire_genre_niveau\n    print(\"\\nðŸ“Š Test: extraire_genre_niveau\")\n    print(f\"   VBFA1PA -> {extraire_genre_niveau('VBFA1PA')}\")\n    print(f\"   HBMA3PB -> {extraire_genre_niveau('HBMA3PB')}\")\n    \n    print(\"\\n\" + \"=\" * 70)\n    print(\"âœ… Tests terminÃ©s!\")\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}