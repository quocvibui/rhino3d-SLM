{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_selOnSrf.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_selOnSrf.py",
  "instruction": "This script selects curves (wires or all curves (including edges)) and optionally adds curves of naked edges that lie\r\non selected faced.",
  "code": "\"\"\"\r\nThis script selects curves (wires or all curves (including edges)) and optionally adds curves of naked edges that lie\r\non selected faced.\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n200520-23: Created, starting with another script.\r\n...\r\n220317: Moved main function to a main library module.\r\n230106: Bug fix.\r\n230108: Fixed selection routine.\r\n250917: Added option to filter edges.\r\n\r\nTODO:\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrepFace\r\nimport xCurve\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bUnderlyingSrf'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bPartiallyOnSrf'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSamplingResolution'; keys.append(key)\r\n    values[key] = 100.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bIncludeEdges'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddCrvsForEdges'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fTolerance':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Faces():\r\n    \"\"\"\r\n    Get Brepfaces with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select faces\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bUnderlyingSrf')\r\n        addOption('fTolerance')\r\n        addOption('bPartiallyOnSrf')\r\n        addOption('fSamplingResolution')\r\n        addOption('bIncludeEdges')\r\n        if Opts.values['bIncludeEdges']:\r\n            addOption('bAddCrvsForEdges')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTolerance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getInput_Curves(objrefs_Face):\r\n    \"\"\"\r\n    Get curves or edges with optional input.\r\n    \"\"\"\r\n\r\n\r\n    def getBrep(rhBrep):\r\n        if isinstance(rhBrep, rg.Brep):\r\n            return None, rhBrep\r\n        elif isinstance(rhBrep, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhBrep\r\n        elif isinstance(rhBrep, rd.ObjRef):\r\n            rdObj = rhBrep.Object()\r\n            rgObj = rhBrep.Geometry()\r\n        elif isinstance(rhBrep, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhBrep) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhBrep)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, (rg.Brep, rg.BrepFace)):\r\n            return rdObj, rgObj\r\n\r\n\r\n    idxs_EdgesOfFaceToSplit = []\r\n    for objref_Face in objrefs_Face:\r\n        rdBrep_withFaceToCheck, rgBrep_withFaceToCheck = getBrep(objref_Face)\r\n        gBrep_withFaceToCheck = rdBrep_withFaceToCheck.Id\r\n        idxs_EdgesOfFaceToSplit.extend(objref_Face.Face().AdjacentEdges())\r\n\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    def notEdgeOfFaceToCheck(rdObj, geom, compIdx):\r\n        #print rdObj, geom, compIdx\r\n        if isinstance(rdObj, rd.BrepObject) and rdObj.Id == gBrep_withFaceToCheck:\r\n            if geom.EdgeIndex in idxs_EdgesOfFaceToSplit:\r\n                print(\"An edge of a face to split was picked and will not be used.\")\r\n                return False\r\n        return True\r\n    go.SetCustomGeometryFilter(notEdgeOfFaceToCheck)\r\n\r\n\r\n    go.AcceptNothing(True)\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False)\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    #print(go.GeometryAttributeFilter)\r\n\r\n    while True:\r\n        bIncludeEdges = Opts.values['bIncludeEdges']\r\n        if bIncludeEdges:\r\n            go.SetCommandPrompt(\"Select wires or edges\")\r\n            go.SetCommandPromptDefault(\"Enter for all normal wires and brep naked edges\")\r\n            go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.AcceptAllAttributes\r\n        else:\r\n            go.SetCommandPrompt(\"Select wires\")\r\n            go.SetCommandPromptDefault(\"Enter for all normal wires\")\r\n            go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bUnderlyingSrf')\r\n        addOption('fTolerance')\r\n        addOption('bPartiallyOnSrf')\r\n        addOption('fSamplingResolution')\r\n        if Opts.values['bIncludeEdges']:\r\n            addOption('bAddCrvsForEdges')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return []\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTolerance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _sortFacesByBrep(objrefs):\r\n    \"\"\"\r\n    Parameters:\r\n        list(objrefs)\r\n    Returns:\r\n        list(Brep GUIDs)\r\n        list(lists(integers of Face indices) per brep)\r\n    \"\"\"\r\n\r\n    gBs = []\r\n    rdBs = []\r\n    idxs_Fs_perB = []\r\n\r\n    for o in objrefs:\r\n        gB = o.ObjectId\r\n        rdB = o.Object()\r\n        rgB = o.Brep()\r\n        \r\n        if not rgB.IsValid:\r\n            print(\"Brep {} is invalid.  Fix first.\".format(gB))\r\n            rgB.Dispose()\r\n            continue\r\n        \r\n        idx_CompIdx = o.GeometryComponentIndex.Index\r\n        if idx_CompIdx == -1:\r\n            if gB in gBs:\r\n                idxs_Fs_perB[gBs.index(gB)] = range(rgB.Faces.Count)\r\n                continue\r\n\r\n            gBs.append(gB)\r\n            rdBs.append(rdB)\r\n            idxs_Fs_perB.append(range(rgB.Faces.Count))\r\n        else:\r\n            rgF = o.Face()\r\n            if gB in gBs:\r\n                if rgF.FaceIndex in idxs_Fs_perB[gBs.index(gB)]:\r\n                    continue\r\n                idxs_Fs_perB[gBs.index(gB)].append(rgF.FaceIndex)\r\n                continue\r\n\r\n            gBs.append(gB)\r\n            rdBs.append(rdB)\r\n            idxs_Fs_perB.append([rgF.FaceIndex])\r\n\r\n    return rdBs, idxs_Fs_perB\r\n\r\n\r\ndef _getDataForAllNormalCrvs(bIncludeEdges=False):\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False\r\n\r\n    rdOs_Out = []\r\n    rgCs_Out = []\r\n\r\n    if bIncludeEdges:\r\n        oes.ObjectTypeFilter = rd.ObjectType.Brep | rd.ObjectType.Curve\r\n        for rdO in sc.doc.Objects.GetObjectList(oes):\r\n            if isinstance(rdO, rd.BrepObject):\r\n                rgB = rdO.BrepGeometry\r\n                for rgE in rgB.Edges:\r\n                    if rgE.Valence == rg.EdgeAdjacency.Naked:\r\n                        rdOs_Out.append(rdO)\r\n                        rgCs_Out.append(rgE)\r\n            else:\r\n                rdOs_Out.append(rdO)\r\n                rgCs_Out.append(rdO.CurveGeometry)\r\n    else:\r\n        oes.ObjectTypeFilter = rd.ObjectType.Curve\r\n\r\n        for rdO in sc.doc.Objects.GetObjectList(oes):\r\n            rdOs_Out.append(rdO)\r\n            rgCs_Out.append(rdO.CurveGeometry)\r\n\r\n    return rdOs_Out, rgCs_Out\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_Face = getInput_Faces()\r\n    if objrefs_Face is None: return\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    objrefs_CurvesOrEdges = getInput_Curves(objrefs_Face)\r\n    if objrefs_CurvesOrEdges is None: return\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    bUnderlyingSrf = Opts.values['bUnderlyingSrf']\r\n    fTolerance = Opts.values['fTolerance']\r\n    bPartiallyOnSrf = Opts.values['bPartiallyOnSrf']\r\n    fSamplingResolution = Opts.values['fSamplingResolution']\r\n    bIncludeEdges = Opts.values['bIncludeEdges']\r\n    bAddCrvsForEdges = Opts.values['bAddCrvsForEdges']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n\r\n    #rdBs, idxs_Fs_perB = _sortFacesByBrep(objrefs_Face)\r\n    #if not rdBs: return\r\n\r\n    rgSs = []\r\n    for objref_F in objrefs_Face:\r\n        rgF = objref_F.Face()\r\n        rgS = rgF.UnderlyingSurface() if bUnderlyingSrf else rgF\r\n        rgSs.append(rgS)\r\n\r\n\r\n    if len(objrefs_CurvesOrEdges) == 0:\r\n        rdCsOrBs, rgCs = _getDataForAllNormalCrvs(bIncludeEdges=bIncludeEdges)\r\n        if len(rdCsOrBs) == 0:\r\n            print(\"No objects with curves.\")\r\n            return\r\n    else:\r\n        rdCsOrBs = []\r\n        rgCs = []\r\n        for objref in objrefs_CurvesOrEdges:\r\n            rdC, rgC = objref.Object(), objref.Curve()\r\n            if rdC:\r\n                rdCsOrBs.append(rdC)\r\n                rgCs.append(rgC)\r\n\r\n\r\n    iCBs_Found = []\r\n\r\n    for iS, rgS in enumerate(rgSs):\r\n\r\n        for iCB, (rdC_or_EB, rgC) in enumerate(zip(rdCsOrBs, rgCs)):\r\n\r\n            if rdC_or_EB.Id in iCBs_Found:\r\n                continue\r\n\r\n            rc = xCurve.filterCurvesOnSurface(\r\n                rgC,\r\n                rgS,\r\n                fSamplingResolution=fSamplingResolution,\r\n                fTolerance=fTolerance,\r\n                bDebug=bDebug)\r\n\r\n            if not rc or (len(rc[0]) + len(rc[1]) == 0): continue\r\n\r\n            cs_AllOnSrf, cs_PartiallyOnSrf = rc\r\n\r\n            if cs_AllOnSrf:\r\n                iCBs_Found.append(iCB)\r\n                continue\r\n\r\n            if bPartiallyOnSrf and cs_PartiallyOnSrf:\r\n                iCBs_Found.append(iCB)\r\n                continue\r\n\r\n\r\n    if len(iCBs_Found) == 0:\r\n        print(\"No curves found.\")\r\n        return\r\n\r\n\r\n    sOuts = []\r\n\r\n    sOuts.append(\"{} curves found.\".format(len(iCBs_Found)))\r\n\r\n\r\n    gCs_Out = []\r\n\r\n    for iCBs in iCBs_Found:\r\n        rdC_or_B = rdCsOrBs[iCBs]\r\n        if isinstance(rdC_or_B, rd.CurveObject):\r\n            rdC_or_B.Select(rdC_or_B)\r\n        elif bAddCrvsForEdges:\r\n            gC_Out = sc.doc.Objects.AddCurve(rgCs[iCBs])\r\n            if gC_Out != gC_Out.Empty:\r\n                gCs_Out.append(gC_Out)\r\n                sc.doc.Objects.Select(objectId=gC_Out)\r\n        else:\r\n            rgE = rgCs[iCBs]\r\n            compIdx = rg.ComponentIndex(\r\n                type=rg.ComponentIndexType.BrepEdge,\r\n                index=rgE.EdgeIndex)\r\n            rdC_or_B.SelectSubObject(\r\n                componentIndex=compIdx,\r\n                select=True,\r\n                syncHighlight=True,\r\n                persistentSelect=True)\r\n\r\n    if gCs_Out:\r\n        sOuts.append(\"{} curves added.\".format(len(gCs_Out)))\r\n\r\n    print(\"  \".join(sOuts))\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}