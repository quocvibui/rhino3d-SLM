{
  "source_url": "https://discourse.mcneel.com/t/issues-translating-vb-script-to-python/90125",
  "topic_id": 90125,
  "title": "Issues translating VB script to Python!",
  "question": "Hi everybody,\n\n\nThis discussion is a continuation of \nthis\n one from yesterday.\n\nI’m currently trying to translate/port \n@dave_stasiuk\n’s script, recommended yesterday by \n@HS_Kim\n \nhere\n, from Visual Basic to Python, because I need it as part of a more elaborate script.\n\n\nHowever, I don’t know much about VB. I’ve done a rough translation, but something is askew. The Python component doesn’t throw an error \nper se\n, however the output isn’t correct. In other words, it doesn’t correspond to what the VB component outputs.\n\n\nThe script is basically about converting grid lines to cells, like so:\n\n\n\n\nMy Python script\n\n\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\nfrom Grasshopper.Kernel.Data import GH_Path\nimport math\n\ntol = 0.01 # model tolerance\n\n# Shatter all the input curves by intersecting them with each other\nCrvs = [] # new list of curves\n\nfor CStart in range(len(C)):\n    \n    T = [] # new list of floats\n    \n    for CCut in range(len(C)):\n        if CStart != CCut:\n            CI = rg.Intersect.Intersection.CurveCurve(C[CStart], C[CCut], tol, tol)\n            for IE in CI:\n                T.append(IE.ParameterA)\n    \n    CShattered = C[CStart].Split(T)\n    \n    Crvs.extend(CShattered)\n\n\n# Set your \"half-curce\" lists\n\nVtc = [] # new list of point3d; all unique vertices\n\nHC = [] # new list of curves; half-curves\nHCI = [] # new list of ints; half-curve indices\nHCO = [] # new list of ints; half-curve opposites\nHCN = [] # new list of ints; next index for each half-curve\nHCV = [] # new list of ints; half-curve vertex\nHCF = [] # new list of ints; half-curve face\nHCPln = [] # new list of planes; half-curve planes\nHCK = [] # new list of booleans; flag if half-curve needs to be killed (if either starts or ends hanging)\n\nF = gh.DataTree[object]() # datatree of curves; for faces\nVOut = gh.DataTree[object]() # datatree of ints; for outgoing half_curves from each vertex\n\nfor Crv in Crvs: # cycle through each curve\n    \n    for CRun in range(0, 3, 2): # create two half-...",
  "code_blocks": [
    {
      "code": "import Rhino.Geometry as rg\nimport Grasshopper as gh\nfrom Grasshopper.Kernel.Data import GH_Path\nimport math\n\ntol = 0.01 # model tolerance\n\n# Shatter all the input curves by intersecting them with each other\nCrvs = [] # new list of curves\n\nfor CStart in range(len(C)):\n    \n    T = [] # new list of floats\n    \n    for CCut in range(len(C)):\n        if CStart != CCut:\n            CI = rg.Intersect.Intersection.CurveCurve(C[CStart], C[CCut], tol, tol)\n            for IE in CI:\n                T.append(IE.ParameterA)\n    \n    CShattered = C[CStart].Split(T)\n    \n    Crvs.extend(CShattered)\n\n\n# Set your \"half-curce\" lists\n\nVtc = [] # new list of point3d; all unique vertices\n\nHC = [] # new list of curves; half-curves\nHCI = [] # new list of ints; half-curve indices\nHCO = [] # new list of ints; half-curve opposites\nHCN = [] # new list of ints; next index for each half-curve\nHCV = [] # new list of ints; half-curve vertex\nHCF = [] # new list of ints; half-curve face\nHCPln = [] # new list of planes; half-curve planes\nHCK = [] # new list of booleans; flag if half-curve needs to be killed (if either starts or ends hanging)\n\nF = gh.DataTree[object]() # datatree of curves; for faces\nVOut = gh.DataTree[object]() # datatree of ints; for outgoing half_curves from each vertex\n\nfor Crv in Crvs: # cycle through each curve\n    \n    for CRun in range(0, 3, 2): # create two half-curves: first in one direction, and then the other...\n        \n        HC.append(Crv)\n        HCI.append(len(HCI))\n        HCO.append(len(HCI)-CRun) # a little index trick\n        HCN.append(-1)\n        HCF.append(-1)\n        HCK.append(False)\n        \n        VtcSet = -1\n        for VtxCheck in range(len(Vtc)):\n            if Vtc[VtxCheck].DistanceTo(Crv.PointAtStart) < tol:\n                VtcSet = VtxCheck # get the vertex index, if it already exists\n                break\n        \n        if VtcSet > -1:\n            HCV.append(VtcSet) # if the vertex already exists, set the half-curve vertex\n            VOut.Add(HCI[-1], GH_Path(VtcSet)) # add the new half-curve index to the list of outgoing half-curves associates with the vertex\n        else:\n            HCV.append(len(Vtc)) # if the vertex doesn't already exists, add a new vertex index\n            VOut.Add(HCI[-1], GH_Path(len(Vtc))) # add the new half-curve index to the list of outgoing half-curves associates with the vertex\n            Vtc.append(Crv.PointAtStart) # add the new vertex to the vertex list\n        \n        # Create, align and add the plane to be used for sequencing half-curves\n        AddPlane = rg.Plane(Vtc[HCV[-1]], P.ZAxis)\n        AddPlane.Rotate(rg.Vector3d.VectorAngle(AddPlane.XAxis, Crv.TangentAtStart, AddPlane), AddPlane.ZAxis)\n        HCPln.append(AddPlane)\n        \n        Crv.Reverse # reverse the cure for creating the opposite half-curve in the second part of the loop\n\n\n# For each vertex that has only one outgoing half-curve, kill the half-curve and its opposite\nfor Pth in VOut.Paths:\n    if VOut.Branch(Pth).Count == 1:\n        HCK[VOut.Branch(Pth)(0)] = True\n        HCK[HCO[VOut.Branch(Pth)(0)]] = True\n\n# Find the \"next\" half-curve for each starting half-curve by identifiying the outgoing half-curve from the end vertex\n# that presents the smallest angle by calculating its plane's x-axis angle from the starting half_curves's opposite plane\nfor HCIdx in HCI:\n    PlaneUse = HCPln[HCO[HCIdx]]\n    MinIdx = -1\n    MinAngle = 2 * math.pi\n    for HCOut in VOut.Branch(HCV[HCO[HCIdx]]):\n        if HCOut != HCO[HCIdx] and HCK[HCIdx] == False and HCK[HCOut] == False:\n            AngleTest = rg.Vector3d.VectorAngle(PlaneUse.XAxis, HCPln[HCOut].XAxis, PlaneUse)\n            if AngleTest < MinAngle:\n                MinIdx = HCOut\n                MinAngle = AngleTest\n    HCN[HCIdx] = MinIdx\n\n# Sequencing half-curves into faces by running along \"next\" half-curves in order until the starting half-curve is returned to\nFaceEdges = [] # list of ints\nDeleteEdges = [] # list of ints\n\n# Cycle through each half-curve\nfor HCIdx in HCI:\n    EmExit = 0\n    if HCF[HCIdx] == -1: # if it hasn't yet been assigned to a\n        EdgeCounter = 1\n        FaceIdx = F.Paths.Count\n        CurrentIdx = HCIdx\n        F.Add(HC[CurrentIdx], GH_Path(FaceIdx))\n        HCF[CurrentIdx] = FaceIdx\n        \n        while True:\n            if HCN[CurrentIdx] == -1: # if sequence half-curve has no next curve assigned, then the face is invalid\n                DeleteEdges.append(FaceIdx) # and will be added to the delete list\n                break\n            CurrentIdx = HCN[CurrentIdx]\n            F.Add(HC[CurrentIdx], GH_Path(FaceIdx))\n            EdgeCounter += 1\n            HCF[CurrentIdx] = FaceIdx\n            if HCN[CurrentIdx] == HCIdx: # exit once the starting hflcruve is reached again\n                break\n            EmExit += 1\n            if EmExit == len(Crvs)-1: # energency exit prevents infinite loops\n                break\n        \n        FaceEdges.append(EdgeCounter)\n\n# Find the perimeter by counting edges... it's possible that an interior face might have the most edges\n# so this could easily be approved upon\nPerim = -1\nPerimCount = -1\nfor FE in range(len(FaceEdges)):\n    if FaceEdges[FE] > PerimCount:\n        Perim = FE\n        PerimCount = FaceEdges[FE]\nDeleteEdges.append(Perim)\n\nNewPath = 0\nOutputFaces = gh.DataTree[object]()\n\n# Only output the faces that haven't been identified as either the perimeter of open\nfor Pth in F.Paths:\n    if not Pth.Indices[0] in DeleteEdges:\n        OutputFaces.AddRange(F.Branch(Pth), GH_Path(NewPath))\n        NewPath += 1\n\na = OutputFaces",
      "language": "python",
      "author": "diff-arch",
      "post_number": 1,
      "is_solution": false
    },
    {
      "code": "'Start by Shattering all of your input curves by intersecting them with each other\n\nDim Crvs As New List(Of Curve)\n\nFor CStart As Int32 = 0 To C.Count - 1\n\n  Dim T As New List(Of Double)\n\n  For CCut As Int32 = 0 To C.Count - 1\n    If CStart <> CCut Then\n      Dim CI As Intersect.CurveIntersections = Intersect.Intersection.CurveCurve(C(CStart), C(CCut), RhinoDoc.ActiveDoc.ModelAbsoluteTolerance, RhinoDoc.ActiveDoc.ModelAbsoluteTolerance)\n      For Each IE As Intersect.IntersectionEvent In CI\n        T.Add(IE.ParameterA)\n      Next\n    End If\n  Next\n\n  Dim CShattered() As Curve = C(CStart).Split(T)\n\n  Crvs.AddRange(CShattered)\n\nNext\n\n'Set your \"half-curve\" lists\n\nDim Vtc As New List(Of Point3d) 'all unique vertices\n\nDim HC As New List(Of Curve) 'list of half-curves\nDim HCI As New List(Of Int32) 'half curve indices\nDim HCO As New List(Of Int32) 'half curve opposites\nDim HCN As New List(Of Int32) 'next index for each half-curve\nDim HCV As New List(Of Int32) 'half-curve vertex\nDim HCF As New List(Of Int32) 'half-curve face\nDim HCPln As New List(Of Plane) 'half-curve plane\nDim HCK As New List(Of Boolean) 'flag if a half-curve needs to be killed (if it either starts or ends hanging)\n\nDim F As New DataTree(Of Curve) 'data tree for faces\nDim VOut As New DataTree(Of Int32) 'data tree of outgoing half-curves from each vertex\n\n\nFor Each Crv As Curve In Crvs 'cycle through each curve\n\n  For CRun As Int32 = 0 To 2 Step 2 'create two half-curves: first in one direction, and then the other...\n\n    HC.Add(Crv)\n    HCI.Add(HCI.Count)\n    HCO.Add(HCI.Count - Crun) 'a little index trick\n    HCN.Add(-1)\n    HCF.Add(-1)\n    HCK.Add(False)\n\n    Dim VtcSet As Int32 = -1\n    For VtxCheck As Int32 = 0 To Vtc.Count - 1\n      If Vtc(VtxCheck).DistanceTo(Crv.PointAtStart) < RhinoDoc.ActiveDoc.ModelAbsoluteTolerance Then\n        VtcSet = VtxCheck 'get the vertex index, if it already exists\n        Exit For\n      End If\n    Next\n\n    If VtcSet > -1 Then\n      HCV.Add(VtcSet) 'If the vertex already exists, set the half-curve vertex\n      VOut.Add(HCI.Last, New GH_Path(VtcSet)) 'add the new half-curve index to the list of outgoing half-curves associated with the vertex\n    Else\n      HCV.Add(Vtc.Count) 'if the vertex doesn't already exist, add a new vertex index\n      VOut.Add(HCI.Last, New GH_Path(Vtc.Count)) 'add the new half-curve index to the list of outgoing half-curves associated with the vertex\n      Vtc.Add(Crv.PointAtStart) 'add the new vertex to the vertex list\n    End If\n\n    'create, align and add the plane to be used for sequencing half-curves\n    Dim AddPlane As New Plane(Vtc(HCV.Last), P.ZAxis)\n    AddPlane.Rotate(Vector3d.VectorAngle(AddPlane.XAxis, Crv.TangentAtStart, AddPlane), AddPlane.ZAxis)\n    HCPln.Add(AddPlane)\n\n    Crv.Reverse 'reverse the curve for creating the opposite half-curve in the second part of the loop\n\n  Next\n\nNext\n\n\n'For each Vertex that has only one outgoing half-curve, kill the half-curve and its opposite\nFor Each Pth As GH_Path In VOut.Paths\n  If VOut.Branch(Pth).Count = 1 Then\n    HCK(VOut.Branch(Pth)(0)) = True\n    HCK(HCO(VOut.Branch(Pth)(0))) = True\n  End If\nNext\n\n'Find the \"next\" half-curve for each starting half curve by identifying the outgoing half-curve from the end vertex\n'that presents the smallest angle by calculating its plane's x-axis angle from x-axis of the starting half-curve's opposite plane\nFor Each HCIdx As Int32 In HCI\n  Dim PlaneUse As Plane = HCPln(HCO(HCIdx))\n  Dim MinIdx As int32 = -1\n  Dim MinAngle As Double = 2 * Math.PI\n  For Each HCOut As Int32 In VOut.Branch(HCV(HCO(HCIdx)))\n    If HCOut <> HCO(HCIdx) And HCK(HCIdx) = False And HCK(HCOut) = False\n      Dim AngleTest As Double = Vector3d.VectorAngle(PlaneUse.XAxis, HCPln(HCOut).XAxis, PlaneUse)\n      If AngleTest < MinAngle Then\n        MinIdx = HCOut\n        MinAngle = AngleTest\n      End If\n    End If\n  Next\n  HCN(HCIdx) = MinIdx\nNext\n\n'Sequence half-curves into faces by running along \"next\" half-curves in order until the starting half-curve is returned to\nDim FaceEdges As New List(Of Int32)\nDim DeleteEdges As New List(Of Int32)\n\n'cycle through each half-curve\nFor Each HCIdx As Int32 In HCI\n  Dim EmExit As Int32 = 0\n  If HCF(HCIdx) = -1 Then 'if it hasn't yet been assigned to a\n    Dim EdgeCounter As Int32 = 1\n    Dim FaceIdx as Int32 = F.Paths.Count\n    Dim CurrentIdx As Int32 = HCIdx\n    F.Add(HC(CurrentIdx), New GH_Path(FaceIdx))\n    HCF(CurrentIdx) = FaceIdx\n    Do\n      If HCN(CurrentIdx) = -1 Then 'if sequence half-curve has no next curve assigned, then the face is invalid\n        DeleteEdges.Add(FaceIdx) 'and will be added to the delete list\n        Exit Do\n      End If\n      CurrentIdx = HCN(CurrentIdx)\n      F.Add(HC(CurrentIdx), New GH_Path(FaceIdx))\n      EdgeCounter += 1\n      HCF(CurrentIdx) = FaceIdx\n      If HCN(CurrentIdx) = HCIdx Then Exit Do 'exit once the starting half-curve is reached again\n      EmExit += 1\n      If EmExit = Crvs.Count - 1 Then Exit Do 'emergency exit prevents infinite loops\n    Loop\n    FaceEdges.Add(EdgeCounter)\n  End If\nNext\n\n'Find the perimeter by counting edges...it's possible that an interior face might have the most edges\n'so this could easily be improved upon\nDim Perim As Int32 = -1\nDim PerimCount As Int32 = -1\nFor FE As Int32 = 0 To FaceEdges.Count - 1\n  If FaceEdges(FE) > PerimCount Then\n    Perim = FE\n    PerimCount = FaceEdges(FE)\n  End If\nNext\nDeleteEdges.Add(Perim)\n\nDim NewPath As Int32 = 0\nDim OutputFaces As New DataTree(Of Curve)\n\n'only output those faces that haven't been identified as either the perimeter or open\nFor Each Pth As GH_Path In F.Paths\n\n  If DeleteEdges.Contains(Pth.Indices(0)) = False Then\n    OutputFaces.AddRange(F.Branch(Pth), New GH_Path(NewPath))\n    NewPath += 1\n  End If\n\nNext\n\nCN = OutputFaces",
      "language": "python",
      "author": "diff-arch",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 5,
  "views": 849
}