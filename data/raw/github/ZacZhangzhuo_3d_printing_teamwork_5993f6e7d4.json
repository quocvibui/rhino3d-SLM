{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/working_file_joe/utils.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "working_file_joe/utils.py",
  "instruction": "This module contains utility functions:\n    1) Transformation functions\n    2) Useful geometry functions e.g. Intersections",
  "code": "\"\"\"\nThis module contains utility functions:\n    1) Transformation functions\n    2) Useful geometry functions e.g. Intersections\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport math\n\n# ----- Coordinate System conversions -----\n\ndef rhino_to_robotbase(ref_plane, model_base):\n    \"\"\"\n    Function that transforms a reference plane from Rhino coordinate system to the robot's base coordinate system\n    TODO (Jason): maybe change this whole method? maybe not model but robot base\n    \n    Args:\n        ref_plane: Rhino.Geometry plane object. The reference plane to transform\n        model_base: Rhino.Geometry plane object. The base plane for building on. Given in robot's base coordinate system.\n    \n    Returns:\n        ref_plane: Reference plane transformed to robot space\n    \"\"\"\n    \n    # Transform the orientation plane based on model_base coordinate system\n    _matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,model_base)\n    #_matrix = rg.Transform.PlaneToPlane(model_base,rg.Plane.WorldXY,)\n    ref_plane.Transform(_matrix)\n    return ref_plane\n\ndef matrix_to_axis_angle(m):\n    \"\"\"\n    Function that transforms a 4x4 matrix to axis-angle format\n    referenced from Martin Baker's www.euclideanspace.com\n    \n    Args:\n        m: Rhino.Geometry Transform structure  - 4x4 matrix\n    \n    Returns:\n        axis: Rhino.Geometry Vector3d object - axis-angle notation\n    \"\"\"\n    \n    epsilon = 0.01\n    epsilon2 = 0.01\n    \n    if (math.fabs(m.M01 - m.M10) < epsilon) & (math.fabs(m.M02 - m.M20) < epsilon) & (math.fabs(m.M12 - m.M21) < epsilon):\n    #singularity found\n    #first check for identity matrix which must have +1 for all terms\n    #in leading diagonal and zero in other terms\n        if (math.fabs(m.M01 + m.M10) < epsilon2) & (math.fabs(m.M02 + m.M20) < epsilon2) & (math.fabs(m.M12 + m.M21) < epsilon2) & (math.fabs(m.M00 + m.M11 + m.M22 - 3) < epsilon2):\n            #this singularity is identity matrix so angle = 0   make zero angle, arbitrary axis\n            angle = 0\n            x = 1\n            y = z = 0\n        else:\n            # otherwise this singularity is angle = 180\n            angle = math.pi;\n            xx = (m.M00 + 1) / 2\n            yy = (m.M11 + 1) / 2\n            zz = (m.M22 + 1) / 2\n            xy = (m.M01 + m.M10) / 4\n            xz = (m.M02 + m.M20) / 4\n            yz = (m.M12 + m.M21) / 4\n            if ((xx > yy) & (xx > zz)):\n                # m.M00 is the largest diagonal term\n                if (xx < epsilon):\n                    x = 0\n                    y = z = 0.7071\n                else:\n                    x = math.sqrt(xx)\n                    y = xy / x\n                    z = xz / x\n            elif (yy > zz): \n                # m.M11 is the largest diagonal term\n                if (yy < epsilon):\n                    x = z = 0.7071\n                    y = 0\n                else: \n                    y = math.sqrt(yy)\n                    x = xy / y\n                    z = yz / y\n            else: \n                # m.M22 is the largest diagonal term so base result on this\n                if (zz < epsilon):\n                    x = y = 0.7071\n                    z = 0\n                else:\n                    z = math.sqrt(zz)\n                    x = xz / z\n                    y = yz / z\n    else:\n        s = math.sqrt((m.M21 - m.M12) * (m.M21 - m.M12)+ (m.M02 - m.M20) * (m.M02 - m.M20)+ (m.M10 - m.M01) * (m.M10 - m.M01)); # used to normalise\n        if (math.fabs(s) < 0.001):\n            #prevent divide by zero, should not happen if matrix is orthogonal and should be\n            s = 1\n        angle = math.acos((m.M00 + m.M11 + m.M22 - 1) / 2)\n        x = (m.M21 - m.M12) / s\n        y = (m.M02 - m.M20) / s\n        z = (m.M10 - m.M01) / s\n    angleRad = angle\n    axis = rg.Vector3d(x,y,z)\n    axis = axis*angleRad\n    \n    return axis\n\ndef matrix_to_euler(m):\n    \"\"\"\n    Gets the Euler rotation angles from a transformation matrix\n    from http://forums.codeguru.com/archive/index.php/t-329530.html\n    \n    Args:\n        m = Transform object\n    Returns:\n        tuple of euler angles in radians\n    \"\"\"\n    \n    rotz = math.atan2(m.M10, m.M00)\n    roty = -math.asin(m.M20)\n    rotx = math.atan2(m.M21, m.M22)\n    return (rotx, roty, rotz)\n\n# ----- Matrix related helper functions\n\ndef dh_matrix((d, theta, a, alpha)):\n    \"\"\"\n    This function creates the Denavit Hartenberg transformation matrix between adjacent frames\n    \n    Arguments:\n        d: Joint distance. in mm\n        theta: joint angle. in radians\n        a: link length. in mm\n        alpha: twist angle. in radians\n    \n    Returns:\n        m: Denavit Hartenberg transformation matrix\n    \"\"\"\n    \n    _matrix = [\n    (math.cos(theta), -math.sin(theta) * math.cos(alpha),math.sin(theta) * math.sin(alpha),a * math.cos(theta)),\n    (math.sin(theta), math.cos(theta) * math.cos(alpha), -math.cos(theta) * math.sin(alpha), a * math.sin(theta)),\n    (0, math.sin(alpha),math.cos(alpha),d),\n    (0,0,0,1)\n    ]\n    \n    m = rg.Transform()\n    for i in range(4):\n        for j in range(4):\n            m[i,j] = _matrix[i][j]\n            \n    return m\n\ndef concatenate_matrices(matrices):\n    \"\"\"\n    This function creates a concatenated matrix from a list of matrices\n    \n    Arguments:\n        matrices: A list of tranformation matrices\n    \n    Returns:\n        _transform: Concatenated matrix\n    \"\"\"\n    _transform = matrices[0]\n    for i in range(1,len(matrices)):\n        _transform *= matrices[i]\n    return _transform\n\n\n# ----- Miscellaneous geometry helper functions\ndef signed_angle(v1,v2,v_normal):\n    \"\"\"\n    This function gets the angle between 2 vectors -pi < theta< pi\n    \n    Arguments:\n        v1: Vector3d. First unitized vector\n        v2: Vector3d. Second unitized vector\n        v_normal: Vector3d. Normal to 2 vectors that determines what is positive/negative\n    \n    Returns:\n        theta: float. signed angle between -pi and pi\n    \"\"\"\n    # from 0 to pi\n    c = rg.Vector3d.Multiply(v1,v2)\n    n = rg.Vector3d.CrossProduct(v1,v2)\n    s= n.Length\n    \n    theta  = math.atan2(s,c)\n    \n    if (rg.Vector3d.Multiply(n, v_normal) < 0):\n        theta *= -1\n    return theta\n\ndef cir_cir_intersection(cir1,cir2):\n    \"\"\"\n    Funtion that returns the intersection points between two circles\n    \n    Arguments:\n        1) cir1: First circle\n        2) cir2: Second Circle\n    \n    Returns:\n        xpts: list of 2 Point3d objectts\n        \n    Note that there is no error checking\n    \"\"\"\n    r1 = cir1.Radius\n    r2 = cir2.Radius\n    d = cir1.Center.DistanceTo(cir2.Center)\n    \n    a = (r1 **2 - r2**2 + d**2)/(2*d)\n    h = math.sqrt(r1 **2 - a **2 )\n    \n    v_c1 = rg.Vector3d(cir1.Center)\n    v_c2 = rg.Vector3d(cir2.Center)\n    \n    v_c1c2 = v_c2 - v_c1\n    v_c1c2.Unitize()\n    v_c1c2 *= a\n    \n    v_pt0 = v_c1 + v_c1c2\n    \n    v_pt0ptX = rg.Vector3d.CrossProduct(cir1.Normal,v_c1c2)\n    v_pt0ptX.Unitize()\n    v_pt0ptX *= h\n    \n    xpt1 = rg.Point3d(v_pt0 + v_pt0ptX)\n    v_pt0ptX.Reverse()\n    xpt2 = rg.Point3d(v_pt0 + v_pt0ptX)\n\n    return [xpt1,xpt2]\n    \ndef check_arguments(function):\n    def decorated(*args):\n        if None in args:\n            raise TypeError(\"Invalid Argument\")\n        return function(*args)\n    return decorated\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}