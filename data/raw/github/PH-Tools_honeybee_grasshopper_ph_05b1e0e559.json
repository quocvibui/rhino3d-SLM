{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph/blob/c433bc8e66f3a51fd05ee4c485f4c54c03d2a569/honeybee_ph_rhino/gh_compo_io/shading/shade_solve_LBT_rad.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph",
  "repo_stars": 6,
  "repo_description": "Honeybe-PH plugin for Rhino / Grasshopper ",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_rhino/gh_compo_io/shading/shade_solve_LBT_rad.py",
  "instruction": "GHCompo Interface: HBPH - Add Shading Factors - LBT Rad.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"GHCompo Interface: HBPH - Add Shading Factors - LBT Rad.\"\"\"\n\nimport math\n\ntry:\n    from itertools import izip as zip  # type: ignore\nexcept:\n    pass  # Python3\n\ntry:\n    from typing import Any, Collection\nexcept ImportError:\n    pass  # IronPython\n\ntry:\n    from System import Object  # type: ignore\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import System:\\n\\t{}\".format(e))\n\ntry:\n    import Rhino.Geometry as rg  # type: ignore\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import Rhino.Geometry:\\n\\t{}\".format(e))\n\ntry:\n    from Grasshopper import DataTree  # type: ignore\n    from Grasshopper.Kernel.Data import GH_Path  # type: ignore\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import Grasshopper:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee import aperture, room\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from ladybug.graphic import GraphicContainer\n    from ladybug.viewsphere import view_sphere\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug:\\n\\t{}\".format(e))\n\ntry:\n    from ladybug_geometry.geometry3d import Mesh3D\n    from ladybug_rhino.fromgeometry import from_mesh3d, from_point3d, from_vector3d\n    from ladybug_rhino.fromobjects import legend_objects\n    from ladybug_rhino.grasshopper import de_objectify_output\n    from ladybug_rhino.intersect import intersect_mesh_rays\n    from ladybug_rhino.text import text_objects\n    from ladybug_rhino.togeometry import to_joined_gridded_mesh3d, to_mesh3d\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ladybug_rhino:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph_rhino.gh_compo_io.shading.shade_create_bldg_shd import create_inset_aperture_surface\n    from honeybee_ph_rhino.gh_compo_io.shading.shade_LBT_rad_settings import HBPH_LBTRadSettings\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\n\ntry:\n    from ph_units.converter import _standardize_unit_name, convert, unit_type_alias_dict\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ph_units:\\n\\t{}\".format(e))\n\n\ntry:\n    from ph_gh_component_io import gh_io\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\n\n# Radiation and Shading Factor Calcs\n# -----------------------------------------------------------------------------\n\n\ndef hbph_to_joined_gridded_mesh3d(geometry, grid_size, offset_distance=0, _mesh_params=None):\n    # type: (list[rg.Brep | rg.Mesh], float, float, rg.MeshingParameters | None) -> Mesh3D\n    \"\"\"\n    ------------------------------------------------------------------\n    ADAPTED FROM LADYBUG ladybug_rhino.togeometry.to_joined_gridded_mesh3d()\n    in order to allow for custom Mesh Param settings.\n    ------------------------------------------------------------------\n\n    Create a single gridded Ladybug Mesh3D from an array of Rhino geometry.\n\n    Args:\n        * breps: An array of Rhino Breps and/or Rhino meshes that will be converted\n            into a single, joined gridded Ladybug Mesh3D.\n        * grid_size: A number for the grid size dimension with which to make the mesh.\n        * offset_distance: A number for the distance at which to offset the mesh from\n            the underlying brep. The default is 0.\n        * _mesh_params: Optional Rhino Meshing Parameters. Default=None\n    Returns:\n        A single gridded Ladybug Mesh3D from the Rhino geometry.\n    \"\"\"\n    lb_meshes = []\n    for geo in geometry:\n        if isinstance(geo, rg.Brep):\n            lb_meshes.append(hbph_to_gridded_mesh3d(geo, grid_size, offset_distance, _mesh_params))\n        else:  # assume that it's a Mesh\n            lb_meshes.append(to_mesh3d(geo))\n    if len(lb_meshes) == 1:\n        return lb_meshes[0]\n    else:\n        return Mesh3D.join_meshes(lb_meshes)\n\n\ndef hbph_to_gridded_mesh3d(brep, grid_size, offset_distance=0, _mesh_params=None):\n    # type: (Any, float, float, rg.MeshingParameters | None) -> Mesh3D\n    \"\"\"\n    ------------------------------------------------------------------\n    ADAPTED FROM LADYBUG ladybug_rhino.togeometry.to_gridded_mesh3d()\n    in order to allow for custom Mesh Param settings.\n    ------------------------------------------------------------------\n\n    Create a gridded Ladybug Mesh3D from a Rhino Brep.\n\n    This is useful since Rhino's grid meshing is often more beautiful than what\n    ladybug_geometry can produce. However, the ladybug_geometry Face3D.get_mesh_grid\n    method provides a workable alternative to this if it is needed.\n\n    Args:\n        * brep: A Rhino Brep that will be converted into a gridded Ladybug Mesh3D.\n        * grid_size: A number for the grid size dimension with which to make the mesh.\n        * offset_distance: A number for the distance at which to offset the mesh from\n            the underlying brep. The default is 0.\n        * _mesh_params: Optional Rhino Meshing Parameters to use for the meshing.\n    Returns:\n        A gridded Ladybug Mesh3D from the Rhino Brep.\n    \"\"\"\n    # -------------------------------------------------------------------------\n    # Mesh the brep using the supplied Params\n    mesh_grids = rg.Mesh.CreateFromBrep(brep, _mesh_params)  # type: ignore\n\n    # -------------------------------------------------------------------------\n    # Join the meshes into one\n    if len(mesh_grids) == 1:  # only one mesh was generated\n        mesh_grid = mesh_grids[0]\n    else:  # join the meshes into one\n        mesh_grid = rg.Mesh()\n        for m_grid in mesh_grids:\n            mesh_grid.Append(m_grid)\n\n    # -------------------------------------------------------------------------\n    # Offset the mesh, if necessary\n    if offset_distance != 0:\n        temp_mesh = rg.Mesh()\n        mesh_grid.Normals.UnitizeNormals()\n        for pt, vec in zip(mesh_grid.Vertices, mesh_grid.Normals):\n            temp_mesh.Vertices.Add(pt + (rg.Vector3f.Multiply(vec, offset_distance)))\n        for face in mesh_grid.Faces:\n            temp_mesh.Faces.AddFace(face)\n        mesh_grid = temp_mesh\n\n    return to_mesh3d(mesh_grid)\n\n\ndef create_shading_mesh(_bldg_shading_breps, _mesh_params):\n    # type: (Collection[rg.Brep], rg.MeshingParameters) -> rg.Mesh\n    \"\"\"Return a single new Rhino.Geometry.Mesh built from all the input shading surface Breps.\"\"\"\n\n    shade_mesh = rg.Mesh()\n    for brep in _bldg_shading_breps:\n        new_mesh = rg.Mesh.CreateFromBrep(brep, _mesh_params)\n        if new_mesh:\n            shade_mesh.Append(new_mesh)\n        else:\n            surface_name = brep.GetUserStrings().Get(\"display_name\")\n            msg = (\n                \"Error: Something is wrong with surface: {}. \\n\"\n                \"Cannot create a mesh properly for some reason. \\n\"\n                \"Check that all your geometry is correct with no overlaps or voids \\n\"\n                \"and check that the Honeybee surfaces are all being created correctly? \\n\"\n                \"If that surface has windows hosted on it, be sure the windows are not \\n\"\n                \"overlapping and that they are being generated correctly?\".format(surface_name)\n            )\n            raise Exception(msg)\n\n    return shade_mesh\n\n\ndef deconstruct_sky_matrix(_sky_mtx):\n    # type: (Any) ->tuple[list[rg.Vector3d], list[float]]\n    \"\"\"Copied from Ladybug 'IncidentRadiation' Component\n\n    Ground reflected irradiance is crudely accounted for by means of an emissive\n    \"ground hemisphere,\" which is like the sky dome hemisphere and is derived from\n    the ground reflectance that is associated with the connected _sky_mtx. This\n    means that including geometry that represents the ground surface will effectively\n    block such crude ground reflection.\n\n    Args:\n        * _sky_mtx: A Ladybug Sky Matrix for the season\n    Returns: (tuple)\n        * [0] (list[rg.Vector3d])\n        * [1] (list[float]) kWh/m2\n    \"\"\"\n\n    def is_north_input(_sky_mtx):\n        # type: (Any) -> bool\n        \"\"\"There is a north input for sky.\"\"\"\n        return _sky_mtx[0][0] != 0\n\n    # deconstruct the matrix and get the sky dome vectors\n    mtx = de_objectify_output(_sky_mtx)\n    total_sky_rad_kwh_m2 = [dir_rad + dif_rad for dir_rad, dif_rad in zip(mtx[1], mtx[2])]\n    ground_rad = [(sum(total_sky_rad_kwh_m2) / len(total_sky_rad_kwh_m2)) * mtx[0][1]] * len(total_sky_rad_kwh_m2)\n    total_sky_and_ground_rad = total_sky_rad_kwh_m2 + ground_rad\n\n    lb_vecs = (\n        view_sphere.tregenza_dome_vectors if len(total_sky_rad_kwh_m2) == 145 else view_sphere.reinhart_dome_vectors\n    )\n    if is_north_input(mtx):\n        # Rotate vectors\n        north_angle = math.radians(mtx[0][0])\n        lb_vecs = tuple(vec.rotate_xy(north_angle) for vec in lb_vecs)\n\n    ground_vecs = tuple(vec.reverse() for vec in lb_vecs)\n    sky_vecs = [from_vector3d(vec) for vec in lb_vecs]\n    sky_and_ground_vecs = [from_vector3d(vec) for vec in lb_vecs + ground_vecs]\n\n    return (sky_vecs, total_sky_rad_kwh_m2)\n\n\ndef radiation_in_rh_doc_unit(_radiation_kwh_m2, _unit_name):\n    # type: (list[float], str) -> list[float]\n    \"\"\"Return the Sky-dome radiation values in kWh/rh-document-unit (in2, ft2, m2, etc...)\"\"\"\n    area_unit_name = _standardize_unit_name(_unit_name.strip(), unit_type_alias_dict)\n    if area_unit_name.strip() == \"M2\":\n        return _radiation_kwh_m2\n    else:\n        unit_name = \"KWH/{}\".format(area_unit_name)\n        return [convert(_, \"KWH/M2\", unit_name) or 0.0 for _ in _radiation_kwh_m2]\n\n\ndef build_window_meshes(_window_surface, _grid_size, _shading_mesh_params, _window_mesh_params=None):\n    # type: (rg.Brep, float, rg.MeshingParameters, rg.MeshingParameters | None) -> tuple[list[rg.Point3d], list[rg.Vector3d], Mesh3D, rg.Mesh | None, rg.Mesh]\n    \"\"\"Create the Ladybug Mesh3D grided mesh for the window being analyzed\n\n    Args:\n        * _window_surface: A single window Brep from the scene\n        * _grid_size:\n        * _shading_mesh_params:\n        * _window_mesh_params:\n    Returns: (tuple)\n        * [0] points: All the analysis points on the window\n        * [1] normals: All the surface normal vectors for the analysis points\n        * [2] window_mesh: The LB window Mesh\n        * [3] window_back_mesh: A copy of the window Mesh shifted 'back'\n            just a little bit (0.1 units). Used when solving the 'unshaded' situation.\n        * [4] window_rh_mesh: The window as a Rhino-Mesh\n    \"\"\"\n\n    # Create the gridded mesh for the window surface\n    # -----------------------------------------------------------------------------------\n    offset_dist = 0.001\n    if not _window_mesh_params:\n        # -- If no custom params are supplied, use the standard Ladybug method\n        window_lb_mesh = to_joined_gridded_mesh3d([_window_surface], _grid_size, offset_dist)  # type: ignore\n    else:\n        # -- otherwise, use the custom settings provided by the user\n        window_lb_mesh = hbph_to_joined_gridded_mesh3d([_window_surface], _grid_size, offset_dist, _window_mesh_params)\n\n    if not window_lb_mesh:\n        raise Exception(\"Failed to create a mesh for the window surface {}.\".format(_window_surface))\n    window_rh_mesh_front = from_mesh3d(window_lb_mesh)\n    points = [from_point3d(pt) for pt in window_lb_mesh.face_centroids]\n\n    if not window_lb_mesh.face_normals:\n        raise Exception(\"Failed to get the normals for the window surface {}.\".format(_window_surface))\n    normals = [from_vector3d(vec) for vec in window_lb_mesh.face_normals]\n\n    # Create a 'back' mesh for the window\n    # -----------------------------------------------------------------------------------\n    # Mostly this is done so it can be passed to the ladybug_rhino.intersect.intersect_mesh_rays()\n    # solver as a surface which is certain to *not* shade the window at all\n    window_rh_mesh_back = None  # type: rg.Mesh | None\n    for sr in _window_surface.Surfaces:\n        window_normal = sr.NormalAt(0.5, 0.5)\n        window_normal.Unitize()\n        window_normal = window_normal * -1 * 0.1\n\n        window_back = _window_surface.Duplicate()\n        window_back.Translate(window_normal)\n        window_rh_mesh_back = rg.Mesh.CreateFromBrep(window_back, _shading_mesh_params)[0]\n\n    return points, normals, window_lb_mesh, window_rh_mesh_back, window_rh_mesh_front\n\n\ndef generate_intersection_data(_shade_mesh, _win_mesh_back, _points, _sky_vecs, _normals, _cpu_count):\n    # type: (rg.Mesh, rg.Mesh, list[rg.Point3d], list[rg.Vector3d], list[rg.Vector3d], int | None) -> tuple[list[int], list[int], list[int], list[int]]\n    \"\"\"Creates all the Intersection Matrix data for both the Shaded and the UNShaded conditions\n\n    Note that for the 'Unshaded' case you still have to pass the solver *something*, so\n    the _win_mesh_back is used for this case. This surface should block out any radiation coming from\n    'behind' and also not interfere with the front-side radiation calculation.\n\n    Adapted from Ladybug 'IncidentRadiation' Component\n\n    Args:\n        * _shade_mesh: The context shading joined mesh\n        * _win_mesh_back: The window surface pushed 'back' a little.\n        * _points:\n        * _sky_vecs:\n        * _normals:\n        * _cpu_count:\n    Returns: (tuple)\n        * [0] int_matrix_init_shaded: Intersection Matrix for window WITH shading\n        * [1] int_matrix_init_unshaded: Intersection Matrix for window WITHOUT shading\n        * [2] angles_s: Shaded\n        * [3] angles_u: UN-Shaded\n    \"\"\"\n\n    # intersect the rays with the mesh\n    # ---------------------------------------------------------------------------\n    int_matrix_init_shaded, angles_s = intersect_mesh_rays(_shade_mesh, _points, _sky_vecs, _normals, _cpu_count)\n    if not angles_s:\n        raise Exception(\"Failed to get the intersection angles for the shading mesh.\")\n\n    int_matrix_init_unshaded, angles_u = intersect_mesh_rays(_win_mesh_back, _points, _sky_vecs, _normals, _cpu_count)\n    if not angles_u:\n        raise Exception(\"Failed to get the intersection angles for the unshaded window mesh.\")\n\n    return int_matrix_init_shaded, int_matrix_init_unshaded, angles_s, angles_u\n\n\ndef calc_win_radiation(_int_matrix_init, _angles, _total_sky_rad_kWh_m2, _window_mesh):\n    # type: (list[int], list[int], list[float], Mesh3D) -> tuple[list[float], list[float]]\n    \"\"\"Computes total kWh per window based on the int_matrix and sky vec angles.\n\n    Note: the LBT radiation values are in kWh/m2 (I think), so we need to account for\n    the fact that the Mesh areas might NOT be in m2.\n\n    Ars:\n        _int_matrix_init\n        _angles:\n        _total_sky_rad:\n        _window_mesh:\n    Returns: (tuple)\n        * [0] (list[float]) The total kWh per window mesh-face\n        * [1] (list[float]) The face areas of the window mesh\n    \"\"\"\n\n    results_kWh = []\n    window_face_areas = []\n    int_matrix = []\n\n    count = (k for k in range(len(_angles) * 10))  # just a super large counter\n\n    for c, int_vals, angs in zip(count, _int_matrix_init, _angles):\n        if not _window_mesh.face_areas:\n            raise Exception(\"Failed to get the face areas for the window mesh.\")\n\n        pt_rel = (ival * math.cos(ang) for ival, ang in zip(int_vals, angs))\n        rad_result = sum(r * w for r, w in zip(pt_rel, _total_sky_rad_kWh_m2))\n\n        int_matrix.append(pt_rel)\n        results_kWh.append(rad_result * _window_mesh.face_areas[c])\n        window_face_areas.append(_window_mesh.face_areas[c])\n\n    return results_kWh, window_face_areas\n\n\n# Legend and Graphics\n# -----------------------------------------------------------------------------\n\n\ndef create_graphic_container(_season, _data, _study_mesh, _legend_par):\n    # type: (str, list[float], Mesh3D, Any) -> tuple[GraphicContainer, rg.TextDot]\n    \"\"\"Creates the Ladybug 'Graphic' Object from the result data\n\n    Copied from Ladybug 'IncidentRadiation' Component\n\n    Args:\n        * _season: (str) 'Winter' or 'Summer'. Used in the title.\n        * _data: (list: float:) A list of the result data to use to color / style the output\n        * _study_mesh: (ladybug_geometry.geometry3d.Mesh3D) The joined Mesh used in the analysis\n        * _legend_par: Ladybug Legend Parameters\n    Returns: (tuple)\n        * [0] graphic: (ladybug.graphic.GraphicContainer) The Ladybug Graphic Object\n        * [1] title: The text title\n    \"\"\"\n\n    graphic = GraphicContainer(_data, _study_mesh.min, _study_mesh.max, _legend_par)\n    graphic.legend_parameters.title = \"kWh\"\n\n    title = text_objects(\n        \"{} Incident Radiation\".format(_season),\n        graphic.lower_title_location,\n        graphic.legend_parameters.text_height * 1.5,\n        graphic.legend_parameters.font,\n    )\n\n    return graphic, title\n\n\ndef create_window_mesh(_lb_meshes):\n    # type: (list[Mesh3D]) -> Mesh3D\n    return Mesh3D.join_meshes(_lb_meshes)\n\n\ndef create_rhino_mesh(_graphic, _lb_mesh):\n    # type: (GraphicContainer, Mesh3D) -> tuple[rg.Mesh, list[rg.TextDot]]\n    \"\"\"Copied from Ladybug 'IncidentRadiation' Component\n\n    Args:\n        * _graphic: The Ladybug Graphic object\n        * _lb_mesh: A single joined mesh of the entire scene\n    Returns: (tuple)\n        * [0] mesh:\n        * [1] legend:\n    \"\"\"\n\n    # Create all of the visual outputs\n    _lb_mesh.colors = _graphic.value_colors\n    mesh = from_mesh3d(_lb_mesh)\n    legend = legend_objects(_graphic.legend)\n\n    return mesh, legend\n\n\n# Component Interface\n# -----------------------------------------------------------------------------\n\n\nclass GHCompo_SolveLBTRad(object):\n    def __init__(\n        self,\n        _IGH,\n        _settings,\n        _shading_surfaces_winter,\n        _shading_surfaces_summer,\n        _hb_rooms,\n        _run,\n    ):\n        # type: (gh_io.IGH, HBPH_LBTRadSettings, list, list, list[room.Room], bool) -> None\n        self.IGH = _IGH\n        self.settings = _settings\n        self.shading_surfaces_winter = _shading_surfaces_winter\n        self.shading_surfaces_summer = _shading_surfaces_summer\n        self.hb_rooms = _hb_rooms\n        self.run_solver = _run\n\n        # ---------------------------------------------------------------------\n        if not self.settings:\n            msg = \"Please input _settings to calculate Radiation results.\"\n            self.IGH.warning(msg)\n\n        if not self.hb_rooms:\n            msg = \"Please input Honeybee Rooms to calculate Radiation results.\"\n            self.IGH.warning(msg)\n\n        if not self.run_solver:\n            msg = \"Please set _run to True in order to calculate Radiation results.\"\n            self.IGH.warning(msg)\n\n    def check_shading_factors(self, aperture, winter_factor, summer_factor, _tolerance=0.0001):\n        # type: (aperture.Aperture, float, float, float) -> None\n        \"\"\"Check the shading factors are not 1.0 or 0.0, display warning if they are.\"\"\"\n        TOL = _tolerance\n        if (1.0 - winter_factor < TOL) or (0.0 + winter_factor < TOL):\n            msg = (\n                \"The Winter shading factor for the aperture '{}' is {:.2f}? \"\n                \"This may be an error. Please double check the shade geometry.\".format(\n                    aperture.display_name, winter_factor\n                )\n            )\n            print(msg)\n            self.IGH.warning(msg)\n\n        if (1.0 - summer_factor < TOL) or (0.0 + summer_factor < TOL):\n            msg = (\n                \"The Summer shading factor for the aperture '{}' is {:.2f}? \"\n                \"This may be an error. Please double check the shade geometry.\".format(\n                    aperture.display_name, summer_factor\n                )\n            )\n            print(msg)\n            self.IGH.warning(msg)\n\n    def run(self):\n        # type: () -> tuple[Any, Any, list[float], Any, list[float],  list[room.Room], list[str]]\n\n        if not self.run_solver or not self.settings or not self.hb_rooms:\n            return (None, None, [], None, [], self.hb_rooms, [])\n\n        # -- Get the current Rhino doc's unit system\n        rh_units_name = self.IGH.get_rhino_unit_system_name()\n\n        # -- Create context Shade meshes\n        # ---------------------------------------------------------------------\n        shade_mesh_winter = create_shading_mesh(self.shading_surfaces_winter, self.settings.mesh_params)\n        shade_mesh_summer = create_shading_mesh(self.shading_surfaces_summer, self.settings.mesh_params)\n\n        # Deconstruct the sky-matrix and get the sky dome vectors. Winter (w) and Summer (s)\n        # Convert the radiation values from kWh/m2 to the Rhino Document units\n        # ---------------------------------------------------------------------\n        w_sky_vecs, w_total_sky_rad_kWh_m2 = deconstruct_sky_matrix(self.settings.winter_sky_matrix)\n        s_sky_vecs, s_total_sky_rad_kWh_m2 = deconstruct_sky_matrix(self.settings.summer_sky_matrix)\n        w_total_sky_rad = radiation_in_rh_doc_unit(w_total_sky_rad_kWh_m2, self.IGH.get_rhino_areas_unit_name())\n        s_total_sky_rad = radiation_in_rh_doc_unit(s_total_sky_rad_kWh_m2, self.IGH.get_rhino_areas_unit_name())\n\n        # Calc window surface shaded and unshaded radiation\n        # ---------------------------------------------------------------------\n        lb_window_meshes = []\n        winter_radiation_shaded_ = DataTree[Object]()\n        winter_radiation_shaded_detailed_ = DataTree[Object]()\n        winter_radiation_unshaded_ = DataTree[Object]()\n        summer_radiation_shaded_ = DataTree[Object]()\n        summer_radiation_shaded_detailed_ = DataTree[Object]()\n        summer_radiation_unshaded_ = DataTree[Object]()\n        mesh_by_window = DataTree[Object]()\n\n        win_count = 0\n        hb_rooms_ = []\n        for room in self.hb_rooms:\n            new_room = room.duplicate()  # type: room.Room # type: ignore\n\n            for face in new_room.faces:\n                for aperture in face.apertures:\n                    window_surface = create_inset_aperture_surface(aperture, rh_units_name)\n\n                    # Build the meshes\n                    # ----------------------------------------------------------------------\n                    pts, nrmls, win_msh, win_msh_bck, rh_msh = build_window_meshes(\n                        window_surface,\n                        self.settings.grid_size,\n                        self.settings.mesh_params,\n                        self.settings.window_mesh_params,\n                    )\n                    lb_window_meshes.append(win_msh)\n\n                    # Solve Winter\n                    # ----------------------------------------------------------------------\n                    args_winter = (\n                        shade_mesh_winter,\n                        win_msh_bck,\n                        pts,\n                        w_sky_vecs,\n                        nrmls,\n                        self.settings.cpus,\n                    )\n\n                    (\n                        int_matrix_s,\n                        int_matrix_u,\n                        angles_s,\n                        angles_u,\n                    ) = generate_intersection_data(*args_winter)\n                    w_rads_shaded, face_areas = calc_win_radiation(int_matrix_s, angles_s, w_total_sky_rad, win_msh)\n                    w_rads_unshaded, face_areas = calc_win_radiation(int_matrix_u, angles_u, w_total_sky_rad, win_msh)\n\n                    winter_rad_shaded = sum(w_rads_shaded) / sum(face_areas)\n                    winter_rad_unshaded = sum(w_rads_unshaded) / sum(face_areas)\n\n                    winter_radiation_shaded_detailed_.AddRange(w_rads_shaded, GH_Path(win_count))\n                    winter_radiation_shaded_.Add(winter_rad_shaded, GH_Path(win_count))\n                    winter_radiation_unshaded_.Add(winter_rad_unshaded, GH_Path(win_count))\n\n                    # Solve Summer\n                    # ----------------------------------------------------------------------\n                    args_summer = (\n                        shade_mesh_summer,\n                        win_msh_bck,\n                        pts,\n                        s_sky_vecs,\n                        nrmls,\n                        self.settings.cpus,\n                    )\n\n                    (\n                        int_matrix_s,\n                        int_matrix_u,\n                        angles_s,\n                        angles_u,\n                    ) = generate_intersection_data(*args_summer)\n                    s_rads_shaded, face_areas = calc_win_radiation(int_matrix_s, angles_s, s_total_sky_rad, win_msh)\n                    s_rads_unshaded, face_areas = calc_win_radiation(int_matrix_u, angles_u, s_total_sky_rad, win_msh)\n\n                    summer_rad_shaded = sum(s_rads_shaded) / sum(face_areas)\n                    summer_rad_unshaded = sum(s_rads_unshaded) / sum(face_areas)\n\n                    summer_radiation_shaded_detailed_.AddRange(s_rads_shaded, GH_Path(win_count))\n                    summer_radiation_shaded_.Add(summer_rad_shaded, GH_Path(win_count))\n                    summer_radiation_unshaded_.Add(summer_rad_unshaded, GH_Path(win_count))\n\n                    mesh_by_window.Add(rh_msh, GH_Path(win_count))\n\n                    # Set the aperture shading factors\n                    # ----------------------------------------------------------------------\n                    winter_factor = winter_rad_shaded / winter_rad_unshaded\n                    summer_factor = summer_rad_shaded / summer_rad_unshaded\n                    self.check_shading_factors(aperture, winter_factor, summer_factor)\n                    aperture.properties.ph.winter_shading_factor = winter_factor\n                    aperture.properties.ph.summer_shading_factor = summer_factor\n\n                    win_count += 1\n\n            # -- Add the new room to the output set\n            # ----------------------------------------------------------------------\n            hb_rooms_.append(new_room)\n\n        # Create the mesh and legend outputs\n        # --------------------------------------------------------------------------\n        # Flatten the radiation data trees\n        winter_rad_vals = [item for branch in winter_radiation_shaded_detailed_.Branches for item in branch]\n        summer_rad_vals = [item for branch in summer_radiation_shaded_detailed_.Branches for item in branch]\n\n        # Create the single window Mesh\n        joined_window_mesh = create_window_mesh(lb_window_meshes)\n\n        winter_graphic, title = create_graphic_container(\n            \"Winter\", winter_rad_vals, joined_window_mesh, self.settings.legend_par\n        )\n        winter_radiation_shaded_mesh_, legend_ = create_rhino_mesh(winter_graphic, joined_window_mesh)\n\n        summer_graphic, title = create_graphic_container(\n            \"Summer\", summer_rad_vals, joined_window_mesh, self.settings.legend_par\n        )\n        summer_radiation_shaded_mesh_, legend_ = create_rhino_mesh(summer_graphic, joined_window_mesh)\n\n        # -- Pull out the shading factors\n        winter_shading_factors_, summer_shading_factors_, aperture_names_ = [], [], []\n        for room in hb_rooms_:\n            for face in room.faces:\n                for aperture in face.apertures:\n                    aperture_names_.append(aperture.display_name)\n                    winter_shading_factors_.append(aperture.properties.ph.winter_shading_factor)\n                    summer_shading_factors_.append(aperture.properties.ph.summer_shading_factor)\n\n        return (\n            legend_,\n            winter_radiation_shaded_mesh_,\n            winter_shading_factors_,\n            summer_radiation_shaded_mesh_,\n            summer_shading_factors_,\n            hb_rooms_,\n            aperture_names_,\n        )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}