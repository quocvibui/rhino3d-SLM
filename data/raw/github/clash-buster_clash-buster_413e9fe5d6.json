{
  "source_url": "https://github.com/clash-buster/clash-buster/blob/d056fa265f25935d0b1f43e07d9db674b15e0230/revitExtension/lib/rhino_decider.py",
  "repo": "clash-buster/clash-buster",
  "repo_stars": 4,
  "repo_description": "Generative design solutions for clash detection. Winner of DBE Hackathon 2019.",
  "license": "MIT",
  "filepath": "revitExtension/lib/rhino_decider.py",
  "instruction": "Rhino decider",
  "code": "import clr, sys\nsys.path.append(r\"C:\\Program Files\\Rhino WIP\\System\")\nclr.AddReference (\"RhinoCommon.dll\")\n\nfrom pyrevit import revit\nfrom Autodesk.Revit import DB, UI, Creation\nimport Rhino.Geometry as rg\nimport math\n#in order to work with the data that's coming from revit with rhino, we need to convert the lines.  Here we will \ndef convert_rvtLine_to_RhinoLine(revitLine):\n    revitLine_start_pt, revitLine_end_pt = revitLine.GetEndPoint(0), revitLine.GetEndPoint(1)\n    rhino_start, rhino_end = rg.Point3d(revitLine_start_pt.X, revitLine_start_pt.Y, revitLine_start_pt.Z), \\\n                                        rg.Point3d(revitLine_end_pt.X, revitLine_end_pt.Y, revitLine_end_pt.Z)\n    \n    return rg.Curve.CreateInterpolatedCurve([rhino_start, rhino_end], 1)\n    \ndef preview_rhino_line(rhinoline):\n    if type(rhinoline) == rg.Curve:\n        beam_start_pt, beam_end_pt = rhinoline.PointAtStart, rhinoline.PointAtEnd\n    elif type(rhinoline) == rg.Line:\n        beam_start_pt, beam_end_pt = rhinoline.From, rhinoline.To\n\n    p0 = DB.XYZ(beam_start_pt.X, beam_start_pt.Y, beam_start_pt.Z)\n    p1 = DB.XYZ(beam_end_pt.X, beam_end_pt.Y, beam_end_pt.Z)\n    \n    p2 = p1 + DB.XYZ(0,1,0)\n    revit_line = DB.Line.CreateBound(p0,p2)\n    \n    bmplane = DB.Plane.CreateByThreePoints(p0,p1,p2)\n    with DB.Transaction(revit.doc) as t1:\n        #print revit.doc.Title\n        t1.Start(\"Create Model Line\")\n        skp = DB.SketchPlane.Create(revit.doc, bmplane) \n        #print revit_line\n        #print p0,p1\n        revit.doc.Create.NewModelCurve(revit_line, skp)\n        t1.Commit()\n\n\ndef convert_rhinopoint_to_xyz(rhinopoint):\n    if isinstance(rhinopoint, list):\n        res = []\n        rhinopoints = rhinopoint\n        for rhinopoint in rhinopoint:\n            res.append(DB.XYZ(rhinopoint.X, rhinopoint.Y, rhinopoint.Z))\n        return res\n    else:\n        return DB.XYZ(rhinopoint.X, rhinopoint.Y, rhinopoint.Z)\n\n\ndef get_intersection_data(beamdata,pipedata):    \n    \"\"\"DBEI Hackathon\"\"\"\n\n    __author__ = \"Pragya Gupta\"\n    __version__ = \"2019.07.15\"\n\n\n    #convert revit line to rhino curve for each element\n    beam_line = convert_rvtLine_to_RhinoLine(beamdata[\"Line\"])\n    depth = beamdata[\"d\"]\n    width = beamdata[\"bf\"]\n    pipe_line = convert_rvtLine_to_RhinoLine(pipedata[\"Line\"])\n    diameter = pipedata[\"dia\"]\n\n    \"\"\"\n    CREATING A SURFACE FROM LINE THAT REPRESENTS THE TOP OF A BEAM\n    :param beam_line: a line that represents the top of the beam (it is assumed that \n    the width will be extruded from this on one side only)\n    :type beam_line: geometry\n    :param depth: the depth of the beam \n    :type depth: int (if the depth is a floating number, for the purpose of this \n    algorithm it'll be rounded to the nearest integer value)\n    \"\"\"\n\n    beam_start_pt, beam_end_pt = beam_line.PointAtStart, beam_line.PointAtEnd\n    beam_other_start, beam_other_end = rg.Point3d(beam_start_pt.X, beam_start_pt.Y, \n                                        beam_start_pt.Z - depth), rg.Point3d(\n                                        beam_end_pt.X, beam_end_pt.Y, \n                                        beam_end_pt.Z - depth)\n\n    # Creating a surface for visualisation and intersection\n    rg.Extrusion.Create(rg.LineCurve(beam_line), -depth, False)\n    beam_surface = rg.Brep.CreateFromCornerPoints(beam_start_pt, beam_end_pt, \n                                                beam_other_end, beam_other_start,0.1)\n\n\n    \"\"\"\n    FINDING THE POINT OF INTERSECTION BETWEEN BEAM SURFACE AND LINE REPRESENTING PIPE\n    :param pipe_line: a line that represents the center line of the pipe\n    :type pipe_line: geometry\n    \"\"\"\n    # Finding the point at which the pipe intersects the beam\n    intersection = rg.Intersect.Intersection.CurveBrep(pipe_line, beam_surface, 0.1)\n    #               results in a 2D array of boolean value, curves and points.\n\n    if intersection[0] == False:\n        print (\"This pipe does not clash with the beam\")\n    else: \n        intersection_pt = intersection[2][0]\n\n\n    \"\"\"\n    FINDING THE POINTS AND PARAMETERS THAT ARE INTEGRAL TO CREATING SOLUTIONS FOR \n    CLASH RESOLUTION\n    This algorithm asssumes that the overall beam dimension is not being modified.\n    The solution set includes modifications to the pipe and at times creating \n    through the beam\n    :param diameter: the diameter of the pipe including insulation\n    :parap type: float\n    \"\"\"\n\n    # Finding the beam length\n    beam_length = rg.Point3d.DistanceTo(beam_start_pt, beam_end_pt)\n\n    # Finding the pipe's start and end points. (While the pipes start and end may be \n    # much further away and more complex, this algorithm will assume a relatively \n    # manageable pipe length which may represent a section of the pipe)\n    pipe_start_pt , pipe_end_pt = pipe_line.PointAtStart, pipe_line.PointAtEnd\n\n    # Finding the maximum offset from the beam surfaces for the pipe to fit\n    left_line = rg.Line(pipe_start_pt, intersection_pt)\n    left_line_len = left_line.Length\n    left_line_max_len = left_line_len - diameter / 2 - 1 \n                        # 1\" for space between pipe and beam\n    left_line_scale_factor = left_line_max_len / left_line_len\n    xform = rg.Transform.Scale(pipe_start_pt, left_line_scale_factor)\n    left_line.Transform(xform)\n\n    left_maximum_point = left_line.To\n\n\n    right_line = rg.Line(pipe_end_pt, intersection_pt)\n    right_line_len = right_line.Length\n    right_line_max_len = right_line_len - diameter / 2 - width - 1\n                        # 1\" for space between pipe and beam\n    right_line_scale_factor = right_line_max_len / right_line_len\n    xform = rg.Transform.Scale(pipe_end_pt, right_line_scale_factor)\n    right_line.Transform(xform)\n\n    right_maximum_point = right_line.To\n\n\n\n    \"\"\"\n    BUILDING SOLUTIONS SET\n    This algorithm asssumes that the overall beam dimension is not being modified.\n    The solution set includes modifications to the pipe and at times creating \n    through the beam\n    \"\"\"\n    complete_solutions_set = {}\n\n    \"\"\"\n    OPTION 1 and OPTION 2 PIPE GOES THROUGH THE BEAM\n    \"\"\"\n    option_through = [pipe_start_pt , pipe_end_pt]\n    complete_solutions_set[\"option_through\"] = option_through\n\n\n    \"\"\"\n    OPTION 3 PIPE CRAWLS AROUND THE BEAM WITH 90 DEGREE BENDS\n    \"\"\"\n    option_crawl90 = [pipe_start_pt]\n\n    option_crawl90.append(left_maximum_point)\n\n\n    left_line_90degree_point = rg.Point3d(left_maximum_point.X, left_maximum_point.Y, \n                                            beam_other_start.Z - diameter/2 - 1)\n    option_crawl90.append(left_line_90degree_point)\n\n    right_line_90degree_point = rg.Point3d(right_maximum_point.X, \n                                            right_maximum_point.Y, \n                                            beam_other_start.Z - diameter/2 - 1)\n    option_crawl90.append(right_line_90degree_point)\n\n    option_crawl90.append(right_line.To)\n\n    option_crawl90.append(pipe_end_pt)\n\n    complete_solutions_set[\"option_crawl90\"] = option_crawl90\n\n\n    \"\"\"\n    OPTION 3 PIPE CRAWLS AROUND THE BEAM WITH 45 DEGREE BENDS\n    \"\"\"\n    option_crawl45 = [pipe_start_pt]\n\n\n    left_line_move_distance = [left_line_90degree_point.X - pipe_start_pt.X, \n                                left_line_90degree_point.Y - pipe_start_pt.Y, \n                                left_line_90degree_point.Z - pipe_start_pt.Z]\n\n    left_line_parallel = rg.Line(left_line_90degree_point, \n                                rg.Point3d(pipe_end_pt.X + left_line_move_distance[0], \n                                pipe_end_pt.Y + left_line_move_distance[1], \n                                pipe_end_pt.Z + left_line_move_distance[2]))\n\n    left_line_parallel_copy = rg.Line(left_line_90degree_point, \n                                rg.Point3d(pipe_end_pt.X + left_line_move_distance[0], \n                                pipe_end_pt.Y + left_line_move_distance[1], \n                                pipe_end_pt.Z + left_line_move_distance[2]))\n\n    left_rotation_radians = 135.0/360.0 * 2.0 * math.pi\n    \n    left_line_rotation_factor = rg.Transform.Rotation(left_rotation_radians, \n                                rg.Vector3d.YAxis, left_line_90degree_point)\n    \n    left_line_parallel_copy.Transform(left_line_rotation_factor)\n\n\n    left_line_45degree_point = rg.Intersect.Intersection.CurveLine(pipe_line, \n                                left_line_parallel_copy,  0.1,0.1)\n    \n    left_line_45degree_point = left_line_45degree_point[0].PointA\n    \n    option_crawl45.append(left_line_45degree_point)\n\n    option_crawl45.append(left_line_90degree_point)\n\n    option_crawl45.append(right_line_90degree_point)\n\n    right_line_move_distance = [right_line_90degree_point.X - pipe_start_pt.X, \n                                right_line_90degree_point.Y - pipe_start_pt.Y, \n                                right_line_90degree_point.Z - pipe_start_pt.Z]\n\n    right_line_parallel = rg.Line(right_line_90degree_point, \n                                rg.Point3d(pipe_end_pt.X + right_line_move_distance[0], \n                                pipe_end_pt.Y + right_line_move_distance[1], \n                                pipe_end_pt.Z + right_line_move_distance[2]))\n\n    right_line_parallel_copy = rg.Line(right_line_90degree_point, \n                                rg.Point3d(pipe_end_pt.X + right_line_move_distance[0], \n                                pipe_end_pt.Y + right_line_move_distance[1], \n                                pipe_end_pt.Z + right_line_move_distance[2]))\n\n    right_rotation_radians = 45.0/360.0 * 2.0 * math.pi\n\n    right_line_rotation_factor = rg.Transform.Rotation(right_rotation_radians, \n                                rg.Vector3d.YAxis, right_line_90degree_point)\n    right_line_parallel_copy.Transform(right_line_rotation_factor)\n\n    #\n    right_line_45degree_point = rg.Intersect.Intersection.CurveLine(pipe_line, \n                                right_line_parallel_copy,  0.1,0.1)\n                                \n    right_line_45degree_point = right_line_45degree_point[0].PointA\n\n    option_crawl45.append(right_line_45degree_point)\n\n    option_crawl45.append(pipe_end_pt)\n\n    complete_solutions_set[\"option_crawl45\"] = option_crawl45\n\n\n    \"\"\"\n    OPTION 4 PIPE BENDS 90 DEGREE ONCE BEFORE THE BEAM AND CONTINUES ONWARDS\n    In this option, the slope after the drop is retained\n    \"\"\"\n    option_drop90 = [pipe_start_pt, left_maximum_point, left_line_90degree_point, \n                        left_line_parallel.To]\n\n    complete_solutions_set[\"option_drop90\"] = option_drop90\n\n\n\n    \"\"\"\n    OPTION 5 PIPE BENDS 45 DEGREE ONCE BEFORE THE BEAM AND CONTINUES ONWARDS\n    In this option, the slope after the drop is retained\n    \"\"\"\n    option_drop45 = [pipe_start_pt, left_line_45degree_point, \n                        left_line_90degree_point, right_line_parallel.To]\n\n    complete_solutions_set[\"option_drop45\"] = option_drop45\n\n\n\n    \"\"\"\n    OPTION 6 RELOCATE THE PIPE TO GO BELOW THE BEAM\n    In this option, the slope of the original pipe is retained\n    it is only moved below the beam\n    \"\"\"\n    option_below_beam = []\n    option_below_beam.append(rg.Point3d(pipe_start_pt.X, pipe_start_pt.Y, \n                                beam_other_start.Z - diameter / 2 - 1))\n    option_below_beam.append(rg.Point3d(pipe_end_pt.X, pipe_end_pt.Y, \n                                beam_other_start.Z - diameter / 2 - 1))\n\n    complete_solutions_set[\"option_below_beam\"] = option_below_beam\n\n\n\n\n\n\n    \"\"\"\n    SELECTION SOLUTION SETS AS PER PIPE INTERSECTION POINT ON BEAM\n    The beam is divided into nine quadrants (sized based on structural impact)\n    Depending on the quadrant where the intersection is located,\n    the solutions set will consist of all or a combination of the above mentioned \n    solutions\n    \"\"\"\n    # Relocating intersection points on beam edges\n    intersection_pt_hor = rg.Point3d(intersection_pt.X, intersection_pt.Y, \n                                    beam_other_start.Z)\n\n    intersection_pt_ver = rg.Point3d(beam_other_start.X, beam_other_start.Y, \n                                    intersection_pt.Z)\n\n\n    # Finding distance relative to beam edges\n    intersection_dist_hor = rg.Point3d.DistanceTo(intersection_pt_hor, \n                                                    beam_other_start)\n\n    intersection_dist_ver = rg.Point3d.DistanceTo(intersection_pt_ver, \n                                                    beam_other_start)\n\n\n    # Defining horizontal and vertical quadrants\n    end_hor_quadrant = 0.2 * beam_length, (1-0.2) * beam_length\n\n    end_ver_quadrant = 0.3 * depth, (1-0.3) * depth\n\n\n    # Finding horizontal quadrant\n    if intersection_dist_hor < end_hor_quadrant[0]:\n        hor_quadrant = 0\n    elif intersection_dist_hor > end_hor_quadrant[1]:\n        hor_quadrant = 2\n    else: hor_quadrant = 1\n\n    # Finding vertical quadrant\n    if intersection_dist_ver < end_ver_quadrant[0]:\n        ver_quadrant = 0\n    elif intersection_dist_ver > end_ver_quadrant[1]:\n        ver_quadrant = 2\n    else: ver_quadrant = 1\n\n\n\n\n    \"\"\"\n    CREATING SOLUTIONS SETS BASED ON QUADRANTS\n    \"\"\"\n    if ver_quadrant == 0:\n        solution_set = {key: complete_solutions_set[key] for key in \n                        complete_solutions_set.keys() and ['option_through', \n                        'option_below_beam']}\n    elif ver_quadrant == 1 and hor_quadrant == 1:\n        solution_set = {key: complete_solutions_set[key] for key in \n                        complete_solutions_set.keys() and ['option_through', \n                        'option_crawl45', 'option_crawl90', 'option_drop45', \n                        'option_drop90', 'option_below_beam']}\n    elif ver_quadrant == 1 and hor_quadrant != 1:\n        solution_set = {key: complete_solutions_set[key] for key in \n                        complete_solutions_set.keys() and [\n                        'option_crawl45', 'option_crawl90', 'option_drop45', \n                        'option_drop90', 'option_below_beam']}\n    elif ver_quadrant == 2:\n        solution_set = {key: complete_solutions_set[key] for key in \n                        complete_solutions_set.keys() and [\n                        'option_crawl45', 'option_crawl90', 'option_drop45', \n                        'option_drop90', 'option_below_beam']}\n\n    #print (solution_set)\n\n\n\n    \"\"\"\n    ELIMINATING SOLUTIONS BASED ON TYPE OF PIPE\n    \"\"\"\n    sewer_key_list = ['option_through', 'option_drop45', \n                        'option_drop90', 'option_below_beam']\n    if type == \"sewer\":\n        solution_set = {key:solution_set[key] for key in sewer_key_list}\n    else: solution_set = solution_set\n    \n    # print (solution_set.keys())\n    return solution_set",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}