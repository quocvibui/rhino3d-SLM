{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\nfor i in range(10):\n    for j in range(10):\n        rs.AddPoint(i*2, j*2, 0)\n```", "code": "This script creates a 10x10 grid of points in the XY plane. It uses two nested loops, each iterating from 0 to 9. Each point is spaced 2 units apart in both X and Y directions, with all points at Z=0. The result is 100 points arranged in a regular rectangular grid pattern.", "source": "synthetic", "category": "code_explanation", "difficulty": "easy", "api": "rhinoscriptsyntax", "tags": ["explain", "grid", "point", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\nimport math\npts = []\nfor i in range(100):\n    t = i * 0.1\n    x = t * math.cos(t)\n    y = t * math.sin(t)\n    pts.append((x, y, 0))\nrs.AddInterpCurve(pts)\n```", "code": "This script generates an Archimedean spiral curve. It samples 100 points where the radius increases linearly with angle (t). For each step, t acts as both the angle (in radians) and the radius multiplier, creating a spiral that expands outward. The points are then connected with a smooth interpolated curve in the XY plane.", "source": "synthetic", "category": "code_explanation", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["explain", "spiral", "curve", "math", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nsphere = rg.Sphere(rg.Point3d(0,0,0), 10)\nbrep = sphere.ToBrep()\nbox = rg.Box(rg.Plane.WorldXY, rg.Interval(-6,-6), rg.Interval(-6,6), rg.Interval(-6,6))\nbox_brep = box.ToBrep()\nresult = rg.Brep.CreateBooleanDifference(brep, box_brep, 0.001)\nif result:\n    for r in result:\n        sc.doc.Objects.AddBrep(r)\n    sc.doc.Views.Redraw()\n```", "code": "This script creates a sphere of radius 10 centered at the origin, then subtracts a box from it using a boolean difference operation. The box extends from -6 to 6 in Y and Z, but only from -6 to -6 in X (a degenerate box). The boolean difference carves out the box shape from the sphere. The tolerance is set to 0.001 for the boolean operation. The result is added to the document and the viewport is refreshed.", "source": "synthetic", "category": "code_explanation", "difficulty": "medium", "api": "RhinoCommon", "tags": ["explain", "boolean", "brep", "RhinoCommon"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\nobjs = rs.GetObjects(\"Select objects\")\nif objs:\n    centroid = [0,0,0]\n    for obj in objs:\n        bb = rs.BoundingBox(obj)\n        c = [(bb[0][i]+bb[6][i])/2 for i in range(3)]\n        centroid = [centroid[i]+c[i] for i in range(3)]\n    centroid = [centroid[i]/len(objs) for i in range(3)]\n    for obj in objs:\n        rs.ScaleObject(obj, centroid, (0.5, 0.5, 0.5))\n```", "code": "This script selects multiple objects, calculates their collective center (average of all bounding box centers), then scales all objects to 50% of their original size using that collective center as the scale origin. This means all objects shrink toward their shared center point, maintaining their relative positions while getting smaller.", "source": "synthetic", "category": "code_explanation", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["explain", "scale", "centroid", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\ncurve = rs.GetObject(\"Select curve\", 4)\nif curve:\n    pts = rs.DivideCurve(curve, 20)\n    for i in range(len(pts)-1):\n        rs.AddLine(pts[i], (pts[i][0], pts[i][1], 0))\n```", "code": "This script divides a selected curve into 20 equal segments, getting 21 points along the curve. For each point (except the last), it draws a vertical line from the point down to the XY plane (Z=0). This creates a 'curtain' or 'fence' effect \u2014 vertical drop lines from the curve to the ground plane, useful for visualization or fabrication layouts.", "source": "synthetic", "category": "code_explanation", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["explain", "divide", "curve", "projection", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport math\nmesh = rg.Mesh()\nfor i in range(50):\n    u = i * 2 * math.pi / 50\n    for j in range(25):\n        v = j * math.pi / 25\n        x = (4 + math.cos(v)) * math.cos(u)\n        y = (4 + math.cos(v)) * math.sin(u)\n        z = math.sin(v)\n        mesh.Vertices.Add(x, y, z)\nfor i in range(49):\n    for j in range(24):\n        a = i*25+j\n        mesh.Faces.AddFace(a, a+1, a+26, a+25)\nmesh.Normals.ComputeNormals()\nsc.doc.Objects.AddMesh(mesh)\nsc.doc.Views.Redraw()\n```", "code": "This script creates a torus (donut shape) as a mesh using parametric equations. The outer loop (u) goes around the main ring (50 divisions), while the inner loop (v) goes around the tube cross-section (25 divisions). The major radius is 4 (distance from center to tube center) and the minor radius is 1 (tube radius). Quad faces are then created by connecting adjacent vertices in both directions, normals are computed, and the mesh is added to the document.", "source": "synthetic", "category": "code_explanation", "difficulty": "hard", "api": "RhinoCommon", "tags": ["explain", "torus", "mesh", "parametric", "RhinoCommon"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\nlayers = rs.LayerNames()\nfor layer in layers:\n    objs = rs.ObjectsByLayer(layer)\n    if objs:\n        count = len(objs)\n        types = {}\n        for obj in objs:\n            t = rs.ObjectType(obj)\n            types[t] = types.get(t, 0) + 1\n        print(\"{}: {} objects ({})\".format(layer, count, types))\n```", "code": "This script creates a summary report of all layers in the document. For each layer, it counts the total number of objects and groups them by object type. The output shows each layer name, its total object count, and a breakdown by type (where type numbers correspond to Rhino object types: 1=point, 4=curve, 8=surface, 16=polysurface, 32=mesh, etc.).", "source": "synthetic", "category": "code_explanation", "difficulty": "easy", "api": "rhinoscriptsyntax", "tags": ["explain", "layer", "report", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\nimport math\ndef branch(pt, angle, length, depth):\n    if depth == 0: return\n    end = (pt[0]+length*math.cos(angle), pt[1]+length*math.sin(angle), 0)\n    rs.AddLine(pt, end)\n    branch(end, angle+0.5, length*0.7, depth-1)\n    branch(end, angle-0.5, length*0.7, depth-1)\nbranch((0,0,0), math.pi/2, 10, 7)\n```", "code": "This script generates a fractal binary tree. Starting from the origin pointing upward (pi/2 radians), each branch splits into two sub-branches that diverge by 0.5 radians (about 28.6 degrees) left and right. Each sub-branch is 70% the length of its parent. The recursion goes 7 levels deep, creating 2^7-1 = 127 line segments total. The result is a tree-like branching pattern.", "source": "synthetic", "category": "code_explanation", "difficulty": "hard", "api": "rhinoscriptsyntax", "tags": ["explain", "fractal", "tree", "recursive", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport rhinoscriptsyntax as rs\ncrvs = rs.GetObjects(\"Select curves\", 4)\nif crvs:\n    for crv in crvs:\n        if rs.IsCurveClosed(crv):\n            area = rs.CurveArea(crv)\n            if area and area[0] > 100:\n                rs.ObjectColor(crv, (255,0,0))\n            else:\n                rs.ObjectColor(crv, (0,255,0))\n```", "code": "This script color-codes selected closed curves by area. It iterates through each selected curve, checks if it's closed, and measures its enclosed area. Curves with area greater than 100 square units are colored red, while smaller curves are colored green. Open curves are left unchanged. This is useful for quickly identifying large vs. small regions in a floor plan or similar layout.", "source": "synthetic", "category": "code_explanation", "difficulty": "medium", "api": "rhinoscriptsyntax", "tags": ["explain", "area", "color", "filter", "rhinoscriptsyntax"]}
{"instruction": "Explain what this code does:\n```python\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\ncrv = rs.GetObject(\"Select curve\", 4)\nif crv:\n    curve = rs.coercecurve(crv)\n    frames = curve.GetPerpendicularFrames([t/20.0 * curve.Domain.Length + curve.Domain.Min for t in range(21)])\n    for frame in frames:\n        circle = rg.Circle(frame, 2)\n        sc.doc.Objects.AddCircle(circle)\n    sc.doc.Views.Redraw()\n```", "code": "This script creates a series of circles perpendicular to a selected curve, like beads on a string. It divides the curve into 20 equal segments (21 points), gets the perpendicular frame (local coordinate system) at each point, and creates a circle of radius 2 on each frame. The result visualizes the curve's local orientation and could be used as preparation for a sweep or pipe-like operation.", "source": "synthetic", "category": "code_explanation", "difficulty": "hard", "api": "RhinoCommon", "tags": ["explain", "frame", "circle", "curve", "RhinoCommon"]}
