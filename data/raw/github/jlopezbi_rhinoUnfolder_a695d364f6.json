{
  "source_url": "https://github.com/jlopezbi/rhinoUnfolder/blob/37abb2c4d2a464e62dbdbb0bde72491dcbfd7343/rhino_unwrapper/islandMaker.py",
  "repo": "jlopezbi/rhinoUnfolder",
  "repo_stars": 8,
  "repo_description": "unwrap meshes in rhino!",
  "license": "GPL-3.0",
  "filepath": "rhino_unwrapper/islandMaker.py",
  "instruction": "THIS_PROJECT STUFF",
  "code": "#THIS_PROJECT STUFF\nimport transformations as trans\nimport flatEdge as fe\nimport flatGeom\nimport Net as nt\nimport island\nimport traversal as tr\nimport Map\nimport rhino_inputs as ri\nimport weight_functions as wf\n\n#RHINO STUFF\nimport rhinoscriptsyntax as rs\nimport Rhino\n\n#PYTHON STUFF\nimport collections,inspect\n\nreload(flatGeom)\nreload(trans)\nreload(fe)\nreload(nt)\nreload(island)\nreload(tr)\n\nMeshLoc = collections.namedtuple('MeshLoc',['face','edge'])\nIslandLoc = collections.namedtuple('IslandLoc',['face','edge']) #note face for island loc is prevFace\n\nclass IslandMaker(object):\n\n    def __init__(self,dataMap,myMesh,island_index=0):\n        '''\n        creates and island, which is a special mesh for representing an unfolded section of a mesh\n        '''\n        self.dataMap = dataMap\n        self.myMesh = myMesh\n        #island_index may eventaully be useful for grouping the island for fast island identification\n        self.island_index = island_index #index of island in net\n        self.visualize_mode = False\n        self.visited_faces = []\n        self.visited_edges = []\n\n    def make_island(self,meshLoc=None,startFrame=trans.make_origin_frame()):\n        self.island = island.Island()\n        self.island.add_dummy_elements()\n        assert self.myMesh.get_cuts(), \"cuts not set!\"\n        if meshLoc==None:\n            meshLoc = MeshLoc(0,0)\n        startIslandLoc = IslandLoc(face=0,edge=0)\n        self.layout_first_two_points(meshLoc,startFrame)\n        self.breadth_first_layout(self.island,meshLoc,startIslandLoc)\n        self.island.reverse_order_dummy_face()\n        return self.island,self.visited_faces\n    \n    def spawn_island(self):\n        self.island = island.Island()\n        self.island.add_dummy_elements()\n\n    def make_island_no_cuts(self,meshLoc=None,startFrame=trans.make_origin_frame()):\n        '''\n        Does not use cut list; unfolds until all faces have been touched\n        '''\n        self.spawn_island() \n        if meshLoc==None:\n            meshLoc = MeshLoc(0,0)\n        startIslandLoc = IslandLoc(face=0,edge=0)\n        self.layout_first_two_points(meshLoc,startFrame)\n        self.breadth_first_layout_face_version(self.island,meshLoc,startIslandLoc)\n        return self.island\n\n    def layout_first_two_points(self,meshLoc,start_frame):\n        '''\n        The process must be started with an island that has one edge, its from face, and the two verts\n        for that face and edge. This function adds those verts\n        Note that the verts are added in reverse order; this is consistent with the assumption\n        of breadth_first_layout.\n        '''\n        meshPointA,meshPointB = self.myMesh.get_oriented_points_for_edge(meshLoc.edge,meshLoc.face)\n        self.visited_edges.append(meshLoc.edge)\n        from_frame = self.myMesh.get_frame_oriented_with_face_normal(meshLoc.edge,meshLoc.face)\n        pnt0 = trans.get_mapped_point(meshPointA,from_frame,start_frame)\n        pnt1 = trans.get_mapped_point(meshPointB,from_frame,start_frame)\n        self.island.add_vert_from_point(pnt1)\n        self.island.add_vert_from_point(pnt0)\n        meshEdge = meshLoc.edge\n        islandEdge = 0\n        #NOTE: only works for myMeshes that have cuts set! consider alternatives to deal with this\n        if self.myMesh.is_fold_edge(meshEdge):\n            self.island.change_to_fold_edge(islandEdge)\n        if self.myMesh.is_cut_edge(meshEdge):\n            self.island.change_to_cut_edge(islandEdge)\n        if self.myMesh.is_naked_edge(meshEdge):\n            self.island.change_to_naked_edge(islandEdge)\n            \n    def breadth_first_layout(self,island,startMeshLoc,startIslandLoc):\n        ''' for layout to not accidently infinite loop the startMeshLoc must be on cut or naked edge\n        '''\n        assert (self.myMesh.is_cut_edge(startMeshLoc.edge) or self.myMesh.is_naked_edge(startMeshLoc.edge)),  \"meshloc is not on a cut edge or a naked edge!\"\n        layoutPair = (startMeshLoc,startIslandLoc)\n        queue = collections.deque([layoutPair])\n        self.visited_faces.append(startMeshLoc.face)\n        while True:\n            try:\n                meshLoc,islandLoc = queue.popleft()\n            except IndexError:\n                break\n            orientedEdges = self.myMesh.get_edges_ccw_besides_base(meshLoc.edge,meshLoc.face) \n            newVerts = []\n            newEdges = []\n            islandFaceToBe = island.next_face_index()\n            for i,orientedEdge in enumerate(orientedEdges):\n                edge,alignedWithFace = orientedEdge\n                face = self.myMesh.getOtherFaceIdx(edge,meshLoc.face)\n                # the last edge's head has already been layed out\n                if orientedEdge != orientedEdges[-1]: \n                    tailPoint,headPoint = self.myMesh.get_aligned_points(orientedEdge) \n                    mapped_point = self.get_mapped_point(headPoint,meshLoc,islandLoc) \n                    island.layout_add_vert_point(mapped_point) \n                angle = self.myMesh.getEdgeAngle(edge)\n                newEdge = island.layout_add_edge(i+1,edge,angle)\n                if self.myMesh.is_fold_edge(edge):\n                    island.change_to_fold_edge(edge=newEdge)\n                    self.visited_faces.append(face)\n                    island.update_edge_to_face(edge=newEdge,toFace=islandFaceToBe+(i+1)) \n                    newMeshLoc = MeshLoc(face,edge)\n                    newIslandLoc = IslandLoc(islandFaceToBe,newEdge)\n                    queue.append((newMeshLoc,newIslandLoc))\n                elif self.myMesh.is_cut_edge(edge): \n                    is_first = True\n                    if edge in self.visited_edges:\n                        is_first = False\n                    island.change_to_cut_edge(edge=newEdge,isLeader=is_first)\n                elif self.myMesh.is_naked_edge(edge): \n                    island.change_to_naked_edge(edge=newEdge) \n                self.visited_edges.append(edge)\n            island.layout_add_face(baseEdge=islandLoc.edge)\n\n    def breadth_first_layout_face_version(self,island,startMeshLoc,startIslandLoc):\n        '''\n        traverse all faces of mesh breadth first and create an island\n        (does not check if edges are cut or fold) \n        need to figure out how to setup island so ready to do this function...\n        '''\n        layoutPair = (startMeshLoc,startIslandLoc)\n        queue = collections.deque([layoutPair])\n        visited = [startMeshLoc.face]\n        while True:\n            try:\n                meshLoc,islandLoc = queue.popleft()\n            except IndexError:\n                break\n            orientedEdges = self.myMesh.get_edges_ccw_besides_base(meshLoc.edge,meshLoc.face) \n            newVerts = []\n            newEdges = []\n            islandFaceToBe = island.next_face_index()\n            for i,orientedEdge in enumerate(orientedEdges):\n                edge,alignedWithFace = orientedEdge\n                face = self.myMesh.getOtherFaceIdx(edge,meshLoc.face)\n                if orientedEdge != orientedEdges[-1]: # the last edge's head has already been layed out\n                    tailPoint,headPoint = self.myMesh.get_aligned_points(orientedEdge) \n                    mapped_point = self.get_mapped_point(headPoint,meshLoc,islandLoc) \n                    island.layout_add_vert_point(mapped_point) \n                newEdge = island.layout_add_edge(i+1)\n                if face and face not in visited:\n                    visited.append(face)\n                    island.update_edge_to_face(edge=newEdge,toFace=islandFaceToBe+(i+1)) \n                    newMeshLoc = MeshLoc(face,edge)\n                    newIslandLoc = IslandLoc(islandFaceToBe,newEdge)\n                    queue.append((newMeshLoc,newIslandLoc))\n            island.layout_add_face(baseEdge=islandLoc.edge)\n\n    def get_mapped_point(self,point,meshLoc,islandLoc):\n        from_frame = self.myMesh.get_frame_oriented_with_face_normal(meshLoc.edge,meshLoc.face)\n        to_frame = self.island.get_frame_reverse_edge(islandLoc.edge,islandLoc.face)\n        if self.visualize_mode:\n            from_frame.show()\n            to_frame.show()\n        return  trans.get_mapped_point(point,from_frame,to_frame)\n    \ndef breadth_first_traverse(myMesh,face):\n    '''\n    practice function for traversing mesh breadth-first\n    '''\n    queue = collections.deque([face])\n    visited = [face]\n    while True:\n        try:\n            nextFace = queue.popleft()\n            #nextMeshLoc = queue.popleft()\n            #Add face to Island(face,meshloc,islandloc)\n        except IndexError:\n            break\n        for neighbor in myMesh.get_adjacent_faces(nextFace):\n            if neighbor not in visited:\n                visited.append(neighbor)\n                queue.append(neighbor)\n    return visited\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}