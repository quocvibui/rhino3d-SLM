{
  "source_url": "https://github.com/fstwn/malt/blob/6d08c128e597abd73ba2e39f187c08f0883eded5/componentserver.py",
  "repo": "fstwn/malt",
  "repo_stars": 0,
  "repo_description": "Initially a collection of Hops components for Rhino 7 to enable certain Python3 code to be run within Grasshopper (actually not within but you get the idea I guess...). The 'dev_ft20' branch contains development code from the research project \"Fertigteil 2.0\"",
  "license": "MIT",
  "filepath": "componentserver.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\n\nimport argparse\nimport clr\nimport glob\nimport logging\nimport os\nfrom itertools import product\n\n\n# COMMAND LINE ARGUMENT PARSING -----------------------------------------------\n\n# Create argument parser\narg_parser = argparse.ArgumentParser(description=\"Process arguments for MALT \"\n                                                 \"component server.\")\n# Create arguments\narg_parser.add_argument(\"-d\", \"--debug\",\n                        action=\"store_true\",\n                        required=False,\n                        help=\"Activates Flask debug mode. \"\n                             \"Defaults to False.\",\n                        dest=\"debug\")\narg_parser.add_argument(\"-n\", \"--networkaccess\",\n                        action=\"store_true\",\n                        required=False,\n                        help=\"Activates network access mode. \"\n                             \"Defaults to False.\",\n                        dest=\"networkaccess\")\narg_parser.add_argument(\"-f\", \"--noflask\",\n                        action=\"store_false\",\n                        required=False,\n                        help=\"Runs server using Hops standard HTTP server. \"\n                             \"Defaults to False (uses Flask as middleware).\",\n                        dest=\"flask\")\n# Parse all command line arguments\ncl_args = arg_parser.parse_args()\n\n\n# OPTIONS ---------------------------------------------------------------------\n\n# Make matplotlib logger less verbose to prevent imports in\n# referenced libraries from triggering a wall of debug messages.\nlogging.getLogger(\"matplotlib\").setLevel(logging.WARNING)\n\n# Set to True to run in debug mode.\n_DEBUG = cl_args.debug\n\n# Set to True to allow access via local network (only works with Flask app!)\n# WARNING: THIS MIGHT BE A SECURITY RISK BECAUSE IT POTENTIALLY ALLOWS PEOPLE\n# TO EXECUTE CODE ON YOUR MACHINE! ONLY USE THIS IN A TRUSTED NETWORK!\n_NETWORK_ACCESS = cl_args.networkaccess\n\n# Set to True to run using Flask as middleware\n_FLASK = cl_args.flask\n\n# True if you want to run using Rhino.Inside.CPython\n_RHINOINSIDE = True\n\n# Set to True to enable System import\n_USING_SYSTEM = True\n\n# Set to True to enable Grasshopper import\n_USING_GH = False\n\n# Set to True to enable Kangaroo2 import\n_USING_K2 = False\n\n# HOPS & RHINO SETUP ----------------------------------------------------------\n\nimport ghhops_server as hs # NOQA402\n\n\n# Define a custom Hops class to enable Rhino.Inside.CPython in\n# combination with a Flask app (otherwise not possible)\nclass ExtendedHops(hs.Hops):\n    \"\"\"\n    Custom extended Hops class allowing Flask app to also run Rhino.Inside.\n    \"\"\"\n\n    def __new__(cls,\n                app=None,\n                debug=False,\n                force_rhinoinside=False,\n                *args,\n                **kwargs) -> hs.base.HopsBase:\n        # set logger level\n        hs.hlogger.setLevel(hs.logging.DEBUG if debug else hs.logging.INFO)\n\n        # determine the correct middleware base on the source app being wrapped\n        # when running standalone with no source apps\n        if app is None:\n            hs.hlogger.debug(\"Using Hops default http server\")\n            hs.params._init_rhino3dm()\n            return hs.middlewares.HopsDefault()\n\n        # if wrapping another app\n        app_type = repr(app)\n        # if app is Flask\n        if app_type.startswith(\"<Flask\"):\n            if force_rhinoinside:\n                hs.hlogger.debug(\"Using Hops Flask middleware and rhinoinside\")\n                hs.params._init_rhinoinside()\n            else:\n                hs.hlogger.debug(\"Using Hops Flask middleware and rhino3dm\")\n                hs.params._init_rhino3dm()\n            return hs.middlewares.HopsFlask(app, *args, **kwargs)\n\n        # if wrapping rhinoinside\n        elif app_type.startswith(\"<module 'rhinoinside'\"):\n            # determine if running with rhino.inside.cpython\n            # and init the param module accordingly\n            if not ExtendedHops.is_inside():\n                raise Exception(\"rhinoinside is not loaded yet\")\n            hs.hlogger.debug(\"Using Hops default http server with rhinoinside\")\n            hs.params._init_rhinoinside()\n            return hs.middlewares.HopsDefault(*args, **kwargs)\n\n        raise Exception(\"Unsupported app!\")\n\n\nprint(\"-----------------------------------------------------\")\nprint(\"[INFO] Hops Server Configuration:\")\nprint(\"[INFO] SERVER:  {0}\".format(\n            \"Flask App\" if _FLASK else \"Hops Default HTTP Server\"))\nprint(\"[INFO] RHINO:   {0}\".format(\n            \"Rhino.Inside.CPython\" if _RHINOINSIDE else \"rhino3dm\"))\nif _NETWORK_ACCESS:\n    print(\"[INFO] NETWORK: Network Access Enabled!\")\n    print(\"[WARNING] Enabling network access is a security risk because \\n\"\n          \"it potentially allows people to execute python code on your \\n\"\n          \"machine! Only use this option in a trusted network/environment!\")\nelse:\n    print(\"[INFO] NETWORK: Localhost Only\")\nprint(\"-----------------------------------------------------\")\n\n# RHINO.INSIDE OR RHINO3DM\nif _RHINOINSIDE:\n    print(\"[INFO] Loading Rhino.Inside.CPython ...\")\n    import rhinoinside\n    rhinoinside.load()\n    import Rhino # NOQA402\nelse:\n    import rhino3dm # NOQA402\n\n# SYSTEM IF NECESSARY\nif _USING_SYSTEM:\n    print(\"[INFO] Loading System (.NET) ...\")\n    import System # NOQA402\n\n# GRASSHOPPER IF NECESSARY\nif _USING_GH:\n    print(\"[INFO] Loading Grasshopper ...\")\n    clr.AddReference(\"Grasshopper.dll\")\n    import Grasshopper as gh # NOQA402\n\n# KANGAROO 2 IF NECESSARY\nif _USING_K2:\n    print(\"[INFO] Loading Kangaroo2 ...\")\n    clr.AddReference(\"KangarooSolver.dll\")\n    import KangarooSolver as ks # NOQA402\n\n\n# THIRD PARTY MODULE IMPORTS --------------------------------------------------\n\nimport igl # NOQA402\nimport numpy as np # NOQA402\nimport open3d as o3d # NOQA402\nimport potpourri3d as pp3d # NOQA402\nimport scipy # NOQA402\nfrom sklearn.manifold import TSNE # NOQA402\nfrom sklearn.decomposition import PCA # NOQA402\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\n\nimport malt # NOQA402\nfrom malt import hopsutilities as hsutil # NOQA402\nfrom malt import icp # NOQA402\nfrom malt import imgprocessing # NOQA402\nfrom malt import intri # NOQA402\nfrom malt import miphopper # NOQA402\nfrom malt import shapesph # NOQA402\nfrom malt import sshd # NOQA402\nfrom malt import vsa # NOQA402\n\n\n# REGSISTER FLASK AND/OR RHINOINSIDE HOPS APP ---------------------------------\n\nif _FLASK:\n    from flask import Flask # NOQA402\n    flaskapp = Flask(__name__)\n    hops = ExtendedHops(app=flaskapp, force_rhinoinside=_RHINOINSIDE)\nelif not _FLASK and _RHINOINSIDE:\n    hops = ExtendedHops(app=rhinoinside)\nelse:\n    hops = ExtendedHops()\n\n\n# HOPS COMPONENTS -------------------------------------------------------------\n\n# GET ALL AVAILABLE COMPONENTS ////////////////////////////////////////////////\n\n@hops.component(\n    \"/hops.AvailableComponents\",\n    name=\"AvailableComponents\",\n    nickname=\"Components\",\n    description=\"List all routes (URI's) of the available components\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[],\n    outputs=[\n        hs.HopsString(\"Components\", \"C\", \"All available Hops Components on this server.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsString(\"Description\", \"D\", \"The descriptions of the components\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef hops_AvailableComponentsComponent():\n    comps = []\n    descr = []\n    for c in hops._components:\n        uri = str(c)\n        if not uri.startswith(\"/test.\"):\n            comps.append(uri)\n            descr.append(hops._components[c].description)\n    return comps, descr\n\n\n# GUROBI INTERFACE COMPONENTS /////////////////////////////////////////////////\n\n@hops.component(\n    \"/gurobi.SolveAssignment2DPoints\",\n    name=\"SolveAssignment2DPoints\",\n    nickname=\"SolveAssignment2DPoints\",\n    description=\"Solve a 2d assignment problem given the datapoints using Gurobi.\", # NOQA502\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"Design\", \"D\", \"The datapoints that define the design as DataTree of Numbers, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsNumber(\"Inventory\", \"I\", \"The datapoints that define the inventory from which to choose the assignment as DataTree of Numbers, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n    ],\n    outputs=[\n        hs.HopsInteger(\"Assignment\", \"A\", \"An optimal solution for the given assignment problem.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsNumber(\"Cost\", \"C\", \"The cost values for the optimal solution.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef gurobi_SolveAssignment2DPointsComponent(design,\n                                            inventory):\n\n    # loop over trees and extract data points as numpy arrays\n    design_p, np_design = hsutil.hops_tree_to_np_array(design)\n    inventory_p, np_inventory = hsutil.hops_tree_to_np_array(inventory)\n\n    # verify feasibility of input datapoints\n    if np_design.shape[0] > np_inventory.shape[0]:\n        raise ValueError(\"Number of Design datapoints needs to be smaller \" +\n                         \"than or equal to number of Inventory datapoints!\")\n\n    # compute cost matrix\n    cost = np.zeros((np_design.shape[0], np_inventory.shape[0]))\n    for i, pt1 in enumerate(np_design):\n        for j, pt2 in enumerate(np_inventory):\n            cost[i, j] = np.linalg.norm(pt2 - pt1, ord=2)\n\n    # solve the assignment problem using the gurobi interface\n    assignment, assignment_cost = miphopper.solve_assignment_2d(cost)\n\n    # return data as hops tree\n    return (hsutil.np_int_array_to_hops_tree(assignment, design_p, True),\n            hsutil.np_float_array_to_hops_tree(assignment_cost, design_p))\n\n\n@hops.component(\n    \"/gurobi.SolveAssignment3DPoints\",\n    name=\"SolveAssignment3DPoints\",\n    nickname=\"SolveAssignment3DPoints\",\n    description=\"Solve a 3d assignment problem given the datapoints using Gurobi.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"Design\", \"D\", \"The datapoints that define the design as DataTree of Numbers, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsNumber(\"Inventory\", \"I\", \"The datapoints that define the inventory from which to choose the assignment as DataTree of Numbers, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsBoolean(\"SimplifyCase\", \"S\", \"Simplify the 3d problem case (or at least try to) by pre-computing the minimum cost and solving the resulting 2d cost matrix.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsInteger(\"Assignment\", \"A\", \"An optimal solution for the given assignment problem.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsNumber(\"Cost\", \"C\", \"The cost values for the optimal solution.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef gurobi_SolveAssignment3DPointsComponent(design,\n                                            inventory,\n                                            simplify=False):\n\n    # verify tree integrity\n    if (not hsutil.hops_tree_verify(design) or\n            not hsutil.hops_tree_verify(inventory)):\n        raise ValueError(\"DataTree structure is inconsistent! All paths have \"\n                         \"to be of the same shape!\")\n\n    # loop over design tree and extract data points as numpy arrays\n    design_p, np_design = hsutil.hops_tree_to_np_array(design)\n\n    # build inventory numpy array\n    inventory_p, np_inventory = hsutil.hops_tree_to_np_array(inventory, True)\n    inventory_shape = (len(set(p[0] for p in inventory_p)),\n                       len(set(p[1] for p in inventory_p)),\n                       len(np_inventory[0]))\n    np_inventory_2d = np.zeros(inventory_shape)\n    for path, data in zip(inventory_p, np_inventory):\n        i = path[0]\n        j = path[1]\n        for k, d in enumerate(data):\n            np_inventory_2d[i, j, k] = d\n\n    # verify tree integrity\n    if np_design.shape[0] > np_inventory_2d.shape[0]:\n        raise ValueError(\"Number of Design datapoints needs to be smaller \"\n                         \"than or equal to number of Inventory datapoints!\")\n\n    # simplifies the problem to a 2d assignment problem by pre-computing the\n    # minimum cost and then solving a 2d assignment problem\n    if simplify:\n        # create empty 2d cost matrix\n        cost = np.zeros((np_design.shape[0], inventory_shape[0]))\n        mapping = np.zeros((np_design.shape[0], inventory_shape[0]),\n                           dtype=int)\n\n        # loop over all design objects\n        for i, d_obj in enumerate(np_design):\n            # loop over all objects in the inventory per design object\n            for j in range(np_inventory_2d.shape[0]):\n                # find minimum orientation and index of it\n                pt1 = d_obj\n                allcosts = [np.linalg.norm(np_inventory_2d[j, k] - pt1, ord=2)\n                            for k in range(np_inventory_2d.shape[1])]\n                mincost = min(allcosts)\n                minidx = allcosts.index(mincost)\n                # build cost matrix and store index in a mapping\n                cost[i, j] = mincost\n                mapping[i, j] = minidx\n\n        # solve the assignment problem using the gurobi interface\n        assignment, assignment_cost = miphopper.solve_assignment_2d(cost)\n\n        assignment_3d = []\n        for i, v in enumerate(assignment):\n            assignment_3d.append((v, mapping[i, v]))\n        assignment_3d = np.array(assignment_3d)\n\n        # return data as hops tree\n        return (hsutil.np_int_array_to_hops_tree(assignment_3d, design_p),\n                hsutil.np_float_array_to_hops_tree(assignment_cost, design_p))\n    else:\n        # create empty 3d cost martix as np array\n        cost = np.zeros((np_design.shape[0],\n                         inventory_shape[0],\n                         inventory_shape[1]))\n\n        # loop over all design objects\n        for i, d_obj in enumerate(np_design):\n            # loop over all objects in the inventory per design object\n            for j in range(np_inventory_2d.shape[0]):\n                # loop over orientations for every object in the inventory\n                for k in range(np_inventory_2d.shape[1]):\n                    pt1 = d_obj\n                    pt2 = np_inventory_2d[j, k]\n                    cost[i, j, k] = np.linalg.norm(pt2 - pt1, ord=2)\n\n        # solve the assignment problem using the gurobi interface\n        assignment, assignment_cost = miphopper.solve_assignment_3d(cost)\n\n    # return data as hops tree\n    return (hsutil.np_int_array_to_hops_tree(assignment, design_p, True),\n            hsutil.np_float_array_to_hops_tree(assignment_cost, design_p))\n\n\n@hops.component(\n    \"/gurobi.SolveCuttingStockProblem\",\n    name=\"SolveCuttingStockProblem\",\n    nickname=\"SolveCSP\",\n    description=\"Solve a cutting stock problem.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"StockLength\", \"SL\", \"Stock Length\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"StockCrossSectionLong\", \"SCL\", \"Stock Cross Section Long Side\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"StockCrossSectionShort\", \"SCS\", \"Stock Cross Section Short Side\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"DemandLength\", \"DL\", \"Demand Length\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"DemandCrossSectionLong\", \"DCL\", \"Demand Cross Section Long Side\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"DemandCrossSectionShort\", \"DCS\", \"Demand Cross Section Short Side\", hs.HopsParamAccess.LIST), # NOQA501\n    ],\n    outputs=[\n        hs.HopsInteger(\"Assignment\", \"A\", \"An optimal solution for the given assignment problem.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"NewComponents\", \"N\", \"Components produced new.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef gurobi_SolveCSPComponent(stock_len,\n                             stock_cs_x,\n                             stock_cs_y,\n                             demand_len,\n                             demand_cs_x,\n                             demand_cs_y):\n\n    # SANITIZE INPUT DATA -----------------------------------------------------\n\n    if not len(stock_len) == len(stock_cs_x) == len(stock_cs_y):\n        raise ValueError(\"Stock Length and Cross Section Size lists must \"\n                         \"correspond in length!\")\n    if not len(demand_len) == len(demand_cs_x) == len(demand_cs_y):\n        raise ValueError(\"Demand Length and Cross Section Size lists must \"\n                         \"correspond in length!\")\n\n    # BUILD NP ARRAYS ---------------------------------------------------------\n\n    m = np.column_stack((np.array([round(x, 6) for x in demand_len]),\n                         np.array([round(x, 6) for x in demand_cs_x]),\n                         np.array([round(x, 6) for x in demand_cs_y])))\n\n    R = np.column_stack((np.array([round(x, 6) for x in stock_len]),\n                         np.array([round(x, 6) for x in stock_cs_x]),\n                         np.array([round(x, 6) for x in stock_cs_y])))\n\n    # COMPOSE N ON BASIS OF M -------------------------------------------------\n\n    cs_set = sorted(list(set([(x[1], x[2]) for x in m])), reverse=True)\n    N = np.array([(float(\"inf\"), x[0], x[1]) for x in cs_set])\n\n    # RUN CUTTING STOCK OPTIMIZATION ------------------------------------------\n\n    optimisation_result = miphopper.solve_csp(m, R, N)\n\n    # RETURN THE OPTIMIZATION RESULTS -----------------------------------------\n\n    return ([int(x[1]) for x in optimisation_result],\n            hsutil.np_float_array_to_hops_tree(N))\n\n\n# ITERATIVE CLOSEST POINT /////////////////////////////////////////////////////\n\n@hops.component(\n    \"/icp.RegisterPointClouds\",\n    name=\"RegisterPointClouds\",\n    nickname=\"Register\",\n    description=\"Register a Scene PointCloud with a given Model PointCloud.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"ScenePoints\", \"S\", \"ScenePoints to evaluate\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsPoint(\"ModelPoints\", \"M\", \"ModelPoints for ICP\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Threshold\", \"T\", \"Threshold for convergence\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"MaxIterations\", \"I\", \"Maximum iterations\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"NNAlgorithm\", \"A\", \"Algorithm used for nearest neighbor computation, can be 0 (KNN) or 1 (Hungarian). Defaults to KNN.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsPoint(\"RegisteredPoints\", \"R\", \"Registered ScenePoints\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Transform\", \"X\", \"Transformation Matrix\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Error\", \"E\", \"Mean Error of ICP operation\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Iterations\", \"I\", \"Iterations before termination.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef icp_RegisterPointCloudsComponent(scene_pts,\n                                     model_pts,\n                                     threshold=1e-3,\n                                     max_iters=20,\n                                     alg=0):\n\n    # sanitize alg input\n    if alg == 0:\n        alg = \"knn\"\n    elif alg == 1:\n        alg = \"hungarian\"\n    else:\n        raise RuntimeError(\"NNAlgorithm has to be either 0 or 1!\")\n\n    # convert points to lists\n    scene_pt_list = [[pt.X, pt.Y, pt.Z] for pt in scene_pts]\n    model_pt_list = [[pt.X, pt.Y, pt.Z] for pt in model_pts]\n\n    # get iterative closest point result\n    res = icp.repeat_icp_until_good_fit(scene_pt_list,\n                                        model_pt_list,\n                                        threshold,\n                                        10,\n                                        max_iterations=max_iters,\n                                        tolerance=1e-3,\n                                        nn_alg=alg)\n\n    # convert the transformation array to an actual rhino transform\n    xform = hsutil.np_array_to_rhino_transform(res[0])\n\n    # copy scene points and transform the copy using the xform\n    transformed_pts = scene_pts[:]\n    [pt.Transform(xform) for pt in transformed_pts]\n\n    # convert rhino transformation to list of floats for output\n    xformlist = []\n    for i, j in product(range(4), range(4)):\n        xformlist.append(float(res[0][i][j]))\n    err = float(res[1])\n    iters = float(res[2])\n\n    # return the results\n    return (transformed_pts, xformlist, err, iters)\n\n\n# LIBIGL //////////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/igl.MeshIsocurves\",\n    name=\"MeshIsocurves\",\n    nickname=\"MeshIsoC\",\n    description=\"Compute isocurves based on a function using libigl\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to compute isocurves on.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Values\", \"V\", \"The function to compute as a list of values at each vertex position of the mesh.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsInteger(\"Count\", \"C\", \"Number of Isocurves\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsLine(\"Isolines\", \"I\", \"The resulting isolines.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef igl_MeshIsocurvesComponent(mesh, values, count):\n    # check if mesh is all triangles\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh has to be triangular!\")\n\n    if not len(values) == mesh.Vertices.Count:\n        raise ValueError(\"List of function values does not correspond with \"\n                         \"mesh vertices!\")\n\n    # get np arrays of vertices and faces\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    values = np.array(values)\n\n    isoV, isoE = igl.isolines(V, F, values, count)\n\n    isoV = hsutil.np_array_to_rhino_points(isoV)\n\n    isoLines = []\n    for edge in isoE:\n        isoLines.append(Rhino.Geometry.Line(isoV[int(edge[0])],\n                                            isoV[int(edge[1])]))\n\n    return isoLines\n\n\n# INTRINSIC TRIANGULATIONS ////////////////////////////////////////////////////\n\n@hops.component(\n    \"/intri.IntrinsicTriangulation\",\n    name=\"IntrinsicTriangulation\",\n    nickname=\"InTri\",\n    description=\"Compute intrinsic triangulation of a triangle mesh.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to create intrinsic triangulation for.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"IntrinsicTriangulation\", \"T\", \"The resulting Mesh with an intrinsic triangulation.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef intri_IntrinsicTriangulationComponent(mesh):\n\n    # get vertices and faces as numpy arrays\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # initialize the glue map and edge lengths arrays from the input data\n    G = intri.build_gluing_map(F)\n    eL = intri.build_edge_lengths(V, F)\n\n    # flip to delaunay\n    intri.flip_to_delaunay(F, G, eL)\n\n    # duplicate original mesh and clear the faces\n    intri_mesh = mesh.Duplicate()\n    intri_mesh.Faces.Clear()\n\n    # set the intrinsic traignulation as faces\n    [intri_mesh.Faces.AddFace(int(f[0]), int(f[1]), int(f[2])) for f in F]\n\n    # compute normals and compact\n    intri_mesh.UnifyNormals()\n    intri_mesh.Normals.ComputeNormals()\n    intri_mesh.Compact()\n\n    # return results\n    return intri_mesh\n\n\n@hops.component(\n    \"/intri.HeatMethodDistance\",\n    name=\"HeatMethodDistance\",\n    nickname=\"HeatDist\",\n    description=\"Compute geodesic distances using the heat method.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to compute geodesic distances on.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"SourceVertex\", \"S\", \"The index of the source vertex from which to compute geodesic distances using the heat method. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"TextureScale\", \"T\", \"The texturescale used for setting the normalized values to the texture coordinates.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The mesh with texture coordinates set to the normalized values.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Distances\", \"D\", \"The geodesic distances to all mesh vertices.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Values\", \"V\", \"The normalized values for every mesh vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef intri_HeatMethodDistanceComponent(mesh,\n                                      source_vertex=0,\n                                      texture_scale=1.0):\n\n    # ensure that the user picked a feasible index\n    assert source_vertex <= mesh.Vertices.Count - 1, (\"The index of the \"\n                                                      \"source vertex cannot \"\n                                                      \"exceed the vertex \"\n                                                      \"count!\")\n\n    # get vertex and face array\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # initialize the edge lengths array from the input data\n    eL = intri.build_edge_lengths(V, F)\n\n    # compute geodesic heat distances\n    geodists = [float(d) for d in\n                intri.heat_method_distance_from_vertex(F, eL, source_vertex)]\n\n    # normalize all values for setting texture coordinates\n    vmin = min(geodists)\n    vmax = max(geodists)\n    mult = 1.0 / (vmax - vmin)\n    values = [mult * (v - vmin) for v in geodists]\n\n    # set texture coordinates of output mesh\n    out_mesh = mesh.Duplicate()\n    for i in range(out_mesh.Vertices.Count):\n        out_mesh.TextureCoordinates.SetTextureCoordinate(\n                    i,\n                    Rhino.Geometry.Point2f(0.0, values[i] * texture_scale))\n\n    # return results\n    return out_mesh, geodists, values\n\n\n# OPEN3D //////////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/open3d.AlphaShape\",\n    name=\"AlphaShape\",\n    nickname=\"AlphaShape\",\n    description=\"Construct a Mesh from a PointCloud using Open3D alpha shape algorithm.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Alpha\", \"A\", \"The Alpha value for the algorithm. Defaults to 1.0.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting triangle Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_AlphaShapeComponent(points, alpha=1.0):\n\n    # convert point list to np array\n    np_points = np.array([[pt.X, pt.Y, pt.Z] for pt in points])\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # estimate the normals\n    pointcloud.estimate_normals()\n\n    # compute convex hull triangle mesh\n    a_shape = o3d.geometry.TriangleMesh.create_from_point_cloud_alpha_shape(\n                                                                    pointcloud,\n                                                                    alpha)\n\n    # create rhino mesh from o3d output and add vertices and faces\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                            np.asarray(a_shape.vertices),\n                                            np.asarray(a_shape.triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n@hops.component(\n    \"/open3d.ConvexHull\",\n    name=\"ConvexHull\",\n    nickname=\"ConvexHull\",\n    description=\"Construct a Mesh from a PointCloud using Open3D convex hull.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting triangle Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_ConvexHullComponent(points):\n\n    # convert point list to np array\n    np_points = np.array([[pt.X, pt.Y, pt.Z] for pt in points])\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # estimate the normals\n    pointcloud.estimate_normals()\n\n    # compute convex hull triangle mesh\n    convex_hull = pointcloud.compute_convex_hull()\n\n    # create rhino mesh from o3d output and add vertices and faces\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                        np.asarray(convex_hull[0].vertices),\n                                        np.asarray(convex_hull[0].triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n@hops.component(\n    \"/open3d.BallPivotingMesh\",\n    name=\"BallPivotingMesh\",\n    nickname=\"BallPivotingMesh\",\n    description=\"Construct a Mesh from a PointCloud and corresponding normals using Open3D ball pivoting reconstruction.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsInteger(\"Depth\", \"D\", \"Depth parameter for the poisson algorithm. Defaults to 8.\", hs.HopsParamAccess.ITEM), # NOQA501\n        ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_BallPivotingMeshComponent(points,\n                                     triangles=100000):\n\n    # convert point list to np array\n    np_points = hsutil.rhino_points_to_np_array(points)\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # estimate normals of the pcd\n    pointcloud.estimate_normals()\n\n    # compute radius for bpa algorithm\n    distances = pointcloud.compute_nearest_neighbor_distance()\n    avg_dist = np.mean(distances)\n    radius = 3 * avg_dist\n\n    # create poisson mesh reconstruction\n    bpa_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(\n                        pointcloud,\n                        o3d.utility.DoubleVector([radius,\n                                                  radius * 2,\n                                                  radius * 3]))\n\n    # downsample mesh to a lower number of triangles\n    if triangles > 0:\n        bpa_mesh = bpa_mesh.simplify_quadric_decimation(triangles)\n\n    # remove artifacts and ensure mesh consistency\n    bpa_mesh.remove_degenerate_triangles()\n    bpa_mesh.remove_duplicated_triangles()\n    bpa_mesh.remove_duplicated_vertices()\n    bpa_mesh.remove_non_manifold_edges()\n\n    # create rhino mesh from o3d output and vertices and faces\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                        np.asarray(bpa_mesh.vertices),\n                                        np.asarray(bpa_mesh.triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n@hops.component(\n    \"/open3d.BallPivotingMeshNormals\",\n    name=\"BallPivotingMeshNormals\",\n    nickname=\"BallPivotingMeshNormals\",\n    description=\"Construct a Mesh from a PointCloud and corresponding normals using Open3D ball pivoting reconstruction.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsVector(\"Normals\", \"N\", \"The Normals of the pointcloud to be used in reconstruction\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsInteger(\"Triangles\", \"T\", \"Number of triangles the resulting mesh gets downsampled to. No downsampling will happen if 0 is supplied.. Defaults to 100000.\", hs.HopsParamAccess.ITEM), # NOQA501\n        ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_BallPivotingMeshNormalsComponent(points,\n                                            normals,\n                                            triangles=100000):\n\n    # convert point list to np array\n    np_points = hsutil.rhino_points_to_np_array(points)\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # if normals are present, use them, otherwise estimate using subroutine\n    if normals:\n        np_normals = np.array([[n.X, n.Y, n.Z] for n in normals])\n        pointcloud.normals = o3d.utility.Vector3dVector(np_normals)\n    else:\n        pointcloud.estimate_normals()\n\n    # compute radius for bpa algorithm\n    distances = pointcloud.compute_nearest_neighbor_distance()\n    avg_dist = np.mean(distances)\n    radius = 3 * avg_dist\n\n    # create poisson mesh reconstruction\n    bpa_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(\n                        pointcloud,\n                        o3d.utility.DoubleVector([radius,\n                                                  radius * 2,\n                                                  radius * 3]))\n\n    # downsample mesh to a lower number of triangles\n    if triangles > 0:\n        bpa_mesh = bpa_mesh.simplify_quadric_decimation(triangles)\n\n    # remove artifacts and ensure mesh consistency\n    bpa_mesh.remove_degenerate_triangles()\n    bpa_mesh.remove_duplicated_triangles()\n    bpa_mesh.remove_duplicated_vertices()\n    bpa_mesh.remove_non_manifold_edges()\n\n    # create rhino mesh from results\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                            np.asarray(bpa_mesh.vertices),\n                                            np.asarray(bpa_mesh.triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n@hops.component(\n    \"/open3d.PoissonMesh\",\n    name=\"PoissonMesh\",\n    nickname=\"PoissonMesh\",\n    description=\"Construct a Mesh from a PointCloud using Open3D poisson mesh reconstruction.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsInteger(\"Depth\", \"D\", \"Depth parameter for the poisson algorithm. Defaults to 8.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"Width parameter for the poisson algorithm. Ignored if depth is specified. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Scale\", \"S\", \"Scale parameter for the poisson algorithm.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"LinearFit\", \"L\", \"If true, the reconstructor will use linear interpolation to estimate the positions of iso-vertices.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_PoissonMeshComponent(points,\n                                depth=8,\n                                width=0,\n                                scale=1.1,\n                                linear_fit=False):\n\n    # convert point list to np array\n    np_points = np.array([[pt.X, pt.Y, pt.Z] for pt in points])\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # estimate the normals\n    pointcloud.estimate_normals()\n\n    # create poisson mesh reconstruction\n    poisson_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(\n                        pointcloud,\n                        depth=depth,\n                        width=width,\n                        scale=scale,\n                        linear_fit=linear_fit)[0]\n\n    # get bbx and crop poisson mesh with bbx\n    bbox = pointcloud.get_axis_aligned_bounding_box()\n    p_mesh_crop = poisson_mesh.crop(bbox)\n\n    # create rhino mesh from o3d output and add vertices and faces\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                            np.asarray(p_mesh_crop.vertices),\n                                            np.asarray(p_mesh_crop.triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n@hops.component(\n    \"/open3d.PoissonMeshNormals\",\n    name=\"PoissonMeshNormals\",\n    nickname=\"PoissonMeshNormals\",\n    description=\"Construct a Mesh from a PointCloud and corresponding normals using Open3D poisson mesh reconstruction.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"Points\", \"P\", \"The PointClouds Points\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsVector(\"Normals\", \"N\", \"The Normals of the pointcloud to be used in reconstruction\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsInteger(\"Depth\", \"D\", \"Depth parameter for the poisson algorithm. Defaults to 8.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"Width parameter for the poisson algorithm. Ignored if depth is specified. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Scale\", \"S\", \"Scale parameter for the poisson algorithm.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"LinearFit\", \"L\", \"If true, the reconstructor will use linear interpolation to estimate the positions of iso-vertices.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The resulting Mesh.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef open3d_PoissonMeshNormalsComponent(points,\n                                       normals,\n                                       depth=8,\n                                       width=0,\n                                       scale=1.1,\n                                       linear_fit=False):\n\n    # convert point list to np array\n    np_points = hsutil.rhino_points_to_np_array(points)\n\n    # create pointcloud\n    pointcloud = o3d.geometry.PointCloud()\n    pointcloud.points = o3d.utility.Vector3dVector(np_points)\n\n    # if normals are present, use them, otherwise estimate using subroutine\n    if normals:\n        np_normals = np.array([[n.X, n.Y, n.Z] for n in normals])\n        pointcloud.normals = o3d.utility.Vector3dVector(np_normals)\n    else:\n        pointcloud.estimate_normals()\n\n    # create poisson mesh reconstruction\n    poisson_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(\n                        pointcloud,\n                        depth=depth,\n                        width=width,\n                        scale=scale,\n                        linear_fit=linear_fit)[0]\n\n    # get bbx and crop poisson mesh with bbx\n    bbox = pointcloud.get_axis_aligned_bounding_box()\n    p_mesh_crop = poisson_mesh.crop(bbox)\n\n    # create rhino mesh from o3d output and vertices and faces\n    rhino_mesh = hsutil.np_arrays_to_rhino_triangle_mesh(\n                                            np.asarray(p_mesh_crop.vertices),\n                                            np.asarray(p_mesh_crop.triangles))\n\n    # return the rhino mesh\n    return rhino_mesh\n\n\n# OPENCV //////////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/opencv.CalibrateCameraCapture\",\n    name=\"CalibrateCameraCapture\",\n    nickname=\"CalCamCap\",\n    description=\"Calibrate a connected Webcam for contour detection using OpenCV.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"R\", \"Run the capturing and contour detection routine.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Device\", \"D\", \"The identifier of the capture device to use. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"The width of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Height\", \"H\", \"The height of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"Transform\", \"T\", \"The transformation matrix.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef opencv_CalibrateCameraCaptureComponent(run,\n                                           device=0,\n                                           width=3780,\n                                           height=1890):\n\n    # initilize identity matrix\n    xform = np.eye(3)\n\n    # run camera calibration\n    if run:\n        image = imgprocessing.capture_image(device)\n        xform = imgprocessing.calibrate_camera_image(image, width, height)\n    # get hops-compatible tree structure\n    rhinoxform = hsutil.np_float_array_to_hops_tree(xform)\n\n    return rhinoxform\n\n\n@hops.component(\n    \"/opencv.CalibrateCameraFile\",\n    name=\"CalibrateCameraFile\",\n    nickname=\"CalCamFile\",\n    description=\"Calibrate a camera based on an image for contour detection using OpenCV.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"R\", \"Run the calibration routine.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsString(\"FilePath\", \"F\", \"The filepath of the image.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"The width of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Height\", \"H\", \"The height of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"Transform\", \"T\", \"The transformation matrix.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef opencv_CalibrateCameraFileComponent(run,\n                                        filepath=\"\",\n                                        width=1131,\n                                        height=1131):\n    # initilize identity matrix\n    xform = np.eye(3)\n\n    # run camera calibration\n    if run:\n        xform = imgprocessing.calibrate_camera_file(filepath, width, height)\n\n    # get hops-compatible tree structure\n    rhinoxform = hsutil.np_float_array_to_hops_tree(xform)\n\n    return rhinoxform\n\n\n@hops.component(\n    \"/opencv.LoadCameraXForm\",\n    name=\"LoadCameraXForm\",\n    nickname=\"LoadCamXF\",\n    description=\"Load a camera perspective transformation from a file.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsString(\"Filepath\", \"F\", \"The filepath of the transformation.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsString(\"Log\", \"L\", \"The logging output of this component.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Transform\", \"T\", \"The transformation matrix.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef opencv_LoadCameraXForm(filepath: str = \"\"):\n\n    log = []\n    rhinoxform = {}\n\n    if not filepath or not os.path.isfile(filepath):\n        filepath = hsutil.sanitize_path(os.path.join(malt.IMGDIR, \"xform.yml\"))\n        log.append(\"No filepath supplied, will load default file...\")\n\n    try:\n        log.append(\"Loading transformation matrix from file:\")\n        log.append(filepath)\n        xform = imgprocessing.load_perspective_xform(filepath)\n        rhinoxform = hsutil.np_float_array_to_hops_tree(xform)\n    except SystemError:\n        raise ValueError((\"Could not read perspective transformation \"\n                          \"from {0}. Make sure the file is obtained by \"\n                          \"calling compute_perspective_xform()!\"))\n\n    return log, rhinoxform\n\n\n@hops.component(\n    \"/opencv.DetectContoursCapture\",\n    name=\"DetectContoursCapture\",\n    nickname=\"DetConCap\",\n    description=\"Capture an image from a connected camera and detect contours using OpenCV.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"R\", \"Run the capturing and contour detection routine.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"BinaryThreshold\", \"B\", \"The threshold for binary (black & white) conversion of the image. Defaults to 127, set to -1 to detect automatically based on image input.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"AreaThreshold\", \"T\", \"The area threshold for filtering the returned contours in pixels. Deactivated if set to 0. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Device\", \"D\", \"The identifier of the capture device to use. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"The width of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Height\", \"H\", \"The height of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"ChainApproximation\", \"C\", \"The chain approximation to use during contour detection. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Epsilon\", \"E\", \"The epsilon value for contour approximation in post-processing. Defaults to 0 (disabled).\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"Invert\", \"I\", \"If True, threshold image will be inverted. Use the invert function to detect black objects on white background.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"ExtOnly\", \"E\", \"If True, only external contours will be returned.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Transform\", \"X\", \"The transformation parameters from camera calibration.\", hs.HopsParamAccess.TREE), # NOQA501\n    ],\n    outputs=[\n        hs.HopsCurve(\"Boundary\", \"B\", \"The detected image boundary.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsCurve(\"Contours\", \"C\", \"The detected contours as Polylines.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef opencv_DetectContoursCaptureComponent(run,\n                                          bthresh=127,\n                                          athresh=0.0,\n                                          device=0,\n                                          width=1131,\n                                          height=1131,\n                                          chain=0,\n                                          eps=0.0,\n                                          invert=False,\n                                          external=True,\n                                          xformtree=None):\n\n    if run:\n        # capture an image for contour detection\n        image = imgprocessing.capture_image(device)\n\n        # retrieve transformation matrix from calibrate camera tree input\n        xform = hsutil.hops_tree_to_np_array(xformtree)[1]\n\n        # create warped image\n        warped_img = imgprocessing.warp_image(image, xform, width, height)\n\n        # run contour detection using opencv\n        if bthresh == -1:\n            otsu = True\n        else:\n            otsu = False\n        warped_img, contours = imgprocessing.detect_contours_from_image(\n                                        warped_img,\n                                        bthresh,\n                                        athresh,\n                                        chain,\n                                        invert,\n                                        external,\n                                        otsu)\n\n        # compute scaling factor for results\n        h_dst, w_dst, c_dst = warped_img.shape\n        scalingfactor = width / w_dst\n\n        # construct polylines from contour output\n        plcs = []\n        for cnt in contours:\n            # create .NET list because Polyline constructor won't correctly\n            # handle python lists (it took a while to find that out....)\n            if len(cnt) >= 2:\n                if eps > 0.0:\n                    cntpts = imgprocessing.approximate_contour(cnt, eps)\n                else:\n                    cntpts = cnt\n                ptL = System.Collections.Generic.List[Rhino.Geometry.Point3d]()\n                # add contour points to .NET list\n                [ptL.Add(Rhino.Geometry.Point3d(float(pt[0][0]),\n                                                float(pt[0][1]),\n                                                0.0)) for pt in cntpts]\n                # add first point again to close polyline\n                ptL.Add(Rhino.Geometry.Point3d(float(cntpts[0][0][0]),\n                                               float(cntpts[0][0][1]),\n                                               0.0))\n                # create polylinecurve from .NET list and scale with factor\n                plc = Rhino.Geometry.PolylineCurve(ptL)\n                plc.Scale(scalingfactor)\n                # append to output list\n                plcs.append(plc)\n\n        # create boundary of image as polyline curve for reference\n        bPts = System.Collections.Generic.List[Rhino.Geometry.Point3d]()\n        # add boundary points to .NET list\n        bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(float(w_dst), 0.0, 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(float(w_dst), float(h_dst), 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(0.0, float(h_dst), 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n        # create polylinecurve from .NET list and scale with factor\n        boundary = Rhino.Geometry.PolylineCurve(bPts)\n        boundary.Scale(scalingfactor)\n\n        # return output\n        return ([boundary], plcs)\n\n    return ([], [])\n\n\n@hops.component(\n    \"/opencv.DetectContoursFile\",\n    name=\"DetectContoursFile\",\n    nickname=\"DetConFile\",\n    description=\"Use an image file and detect contours using OpenCV.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"R\", \"Run the capturing and contour detection routine.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsString(\"FilePath\", \"F\", \"The filepath of the image.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"BinaryThreshold\", \"B\", \"The threshold for binary (black & white) conversion of the image. Defaults to 127, set to -1 to detect automatically based on image input.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"AreaThreshold\", \"T\", \"The area threshold for filtering the returned contours in pixels. Deactivated if set to 0. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"The width of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Height\", \"H\", \"The height of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"ChainApproximation\", \"C\", \"The chain approximation to use during contour detection. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Epsilon\", \"E\", \"The epsilon value for contour approximation in post-processing. Defaults to 0 (disabled).\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"Invert\", \"I\", \"If True, threshold image will be inverted. Use the invert function to detect black objects on white background.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"ExtOnly\", \"E\", \"If True, only external contours will be returned.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Transform\", \"X\", \"The transformation parameters from camera calibration.\", hs.HopsParamAccess.TREE), # NOQA501\n    ],\n    outputs=[\n        hs.HopsCurve(\"Boundary\", \"B\", \"The detected image boundary.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsCurve(\"Contours\", \"C\", \"The detected contours as Polylines.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsString(\"QRData\", \"Q\", \"The decoded data of detected QR-Codes\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef opencv_DetectContoursFileComponent(run,\n                                       filepath=\"\",\n                                       bthresh=127,\n                                       athresh=0.0,\n                                       width=1131,\n                                       height=1131,\n                                       chain=0,\n                                       eps=0.0,\n                                       invert=False,\n                                       external=True,\n                                       xformtree=None):\n\n    if run:\n        # read image from filepath\n        image = imgprocessing.read_image(filepath)\n\n        # retrieve transformation matrix from calibrate camera tree input\n        xform = hsutil.hops_tree_to_np_array(xformtree)[1]\n\n        # create warped image\n        warped_img = imgprocessing.warp_image(image, xform, width, height)\n\n        # copy image and perform qr code detection\n        qr_img = warped_img.copy()\n        qrdata, qrbbx = imgprocessing.detect_qr_codes_from_image(qr_img)\n\n        # run contour detection using opencv\n        if bthresh == -1:\n            otsu = True\n        else:\n            otsu = False\n        warped_img, contours = imgprocessing.detect_contours_from_image(\n                                        warped_img,\n                                        bthresh,\n                                        athresh,\n                                        chain,\n                                        invert,\n                                        external,\n                                        otsu)\n\n        # compute scaling factor for results\n        h_dst, w_dst, c_dst = warped_img.shape\n        scalingfactor = width / w_dst\n\n        # construct polylines from contour output\n        plcs = []\n        for cnt in contours:\n            # create .NET list because Polyline constructor won't correctly\n            # handle python lists (it took a while to find that out....)\n            if len(cnt) >= 2:\n                if eps > 0.0:\n                    cntpts = imgprocessing.approximate_contour(cnt, eps)\n                else:\n                    cntpts = cnt\n                ptL = System.Collections.Generic.List[Rhino.Geometry.Point3d]()\n                # add contour points to .NET list\n                [ptL.Add(Rhino.Geometry.Point3d(float(pt[0][0]),\n                                                float(pt[0][1]),\n                                                0.0)) for pt in cntpts]\n                # add first point again to close polyline\n                ptL.Add(Rhino.Geometry.Point3d(float(cntpts[0][0][0]),\n                                               float(cntpts[0][0][1]),\n                                               0.0))\n                # create polylinecurve from .NET list and scale with factor\n                plc = Rhino.Geometry.PolylineCurve(ptL)\n                plc.Scale(scalingfactor)\n                # append to output list\n                plcs.append(plc)\n\n        # create boundary of image as polyline curve for reference\n        bPts = System.Collections.Generic.List[Rhino.Geometry.Point3d]()\n        # add boundary points to .NET list\n        bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(float(w_dst), 0.0, 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(float(w_dst), float(h_dst), 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(0.0, float(h_dst), 0.0))\n        bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n        # create polylinecurve from .NET list and scale with factor\n        boundary = Rhino.Geometry.PolylineCurve(bPts)\n        boundary.Scale(scalingfactor)\n\n        # return output\n        return ([boundary], plcs, qrdata)\n\n    return ([], [], [])\n\n\n@hops.component(\n    \"/opencv.DetectContoursFileMulti\",\n    name=\"DetectContoursFileMulti\",\n    nickname=\"DetConFileMulti\",\n    description=\"Use a directory full of images and detect contours in every image using OpenCV.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsBoolean(\"Run\", \"R\", \"Run the capturing and contour detection routine.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsString(\"Directory\", \"D\", \"The path to the directory where the images are stored.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"BinaryThreshold\", \"B\", \"The threshold for binary (black & white) conversion of the image. Defaults to 127, set to -1 to detect automatically based on image input.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"AreaThreshold\", \"T\", \"The area threshold for filtering the returned contours in pixels. Deactivated if set to 0. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Width\", \"W\", \"The width of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Height\", \"H\", \"The height of the working area.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"ChainApproximation\", \"C\", \"The chain approximation to use during contour detection. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Epsilon\", \"E\", \"The epsilon value for contour approximation in post-processing. Defaults to 0 (disabled).\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"Invert\", \"I\", \"If True, threshold image will be inverted. Use the invert function to detect black objects on white background.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsBoolean(\"ExtOnly\", \"E\", \"If True, only external contours will be returned.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Transform\", \"X\", \"The transformation parameters from camera calibration.\", hs.HopsParamAccess.TREE), # NOQA501\n    ],\n    outputs=[\n        hs.HopsCurve(\"Boundary\", \"B\", \"The detected image boundary.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsCurve(\"Contours\", \"C\", \"The detected contours as Polylines.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsString(\"QRData\", \"Q\", \"The decoded data of detected QR-Codes\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef opencv_DetectContoursFileMultiComponent(run,\n                                            filepath='',\n                                            bthresh=127,\n                                            athresh=0.0,\n                                            width=1000,\n                                            height=1000,\n                                            chain=0,\n                                            eps=0.0,\n                                            invert=False,\n                                            external=True,\n                                            xformtree=None):\n\n    if run:\n        # read all images from the directory filepath\n        img_types = ['*.jpg', '*.png', '*.jpeg']\n        img_fps = []\n        for it in img_types:\n            img_fps.extend(glob.glob(os.path.join(filepath, it)))\n        # retrieve transformation matrix from calibrate camera tree input\n        xform = hsutil.hops_tree_to_np_array(xformtree)[1]\n        # set otsu flag\n        if bthresh == -1:\n            otsu = True\n        else:\n            otsu = False\n        # loop over all image file paths in the directory\n        image_boundary = None\n        all_contours = []\n        all_qrdata = []\n        for i, fp in enumerate(img_fps):\n            print('[OPENCV] Running contour detection for '\n                  f'{fp} ({i}/{len(img_fps)})...')\n            # read image into array\n            image = imgprocessing.read_image(fp)\n            # create warped image\n            warped_img = imgprocessing.warp_image(image, xform, width, height)\n            # copy image and perform qr code detection\n            qr_img = warped_img.copy()\n            qrdata, qrbbx = imgprocessing.detect_qr_codes_from_image(qr_img)\n            all_qrdata.append(qrdata)\n            # run contour detection using opencv\n            warped_img, contours = imgprocessing.detect_contours_from_image(\n                                            warped_img,\n                                            bthresh,\n                                            athresh,\n                                            chain,\n                                            invert,\n                                            external,\n                                            otsu)\n            # compute scaling factor for results\n            h_dst, w_dst, c_dst = warped_img.shape\n            scalingfactor = width / w_dst\n            # construct polylines from contour output\n            plcs = []\n            for cnt in contours:\n                # create .NET list because Polyline constructor won't correctly\n                # handle python lists (it took a while to find that out....)\n                if len(cnt) >= 2:\n                    if eps > 0.0:\n                        cntpts = imgprocessing.approximate_contour(cnt, eps)\n                    else:\n                        cntpts = cnt\n                    ptL = System.Collections.Generic.List[\n                        Rhino.Geometry.Point3d]()\n                    # add contour points to .NET list\n                    [ptL.Add(Rhino.Geometry.Point3d(float(pt[0][0]),\n                                                    float(pt[0][1]),\n                                                    0.0)) for pt in cntpts]\n                    # add first point again to close polyline\n                    ptL.Add(Rhino.Geometry.Point3d(float(cntpts[0][0][0]),\n                                                   float(cntpts[0][0][1]),\n                                                   0.0))\n                    # create polylinecurve from .NET list and scale with factor\n                    plc = Rhino.Geometry.PolylineCurve(ptL)\n                    plc.Scale(scalingfactor)\n                    # append to output list\n                    plcs.append(plc)\n            # append list of polyline curves to list of all detected contours\n            all_contours.append(plcs)\n            # create image boundary as polyline curve for reference\n            if i == 0:\n                bPts = System.Collections.Generic.List[\n                    Rhino.Geometry.Point3d]()\n                # add boundary points to .NET list\n                bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n                bPts.Add(Rhino.Geometry.Point3d(float(w_dst), 0.0, 0.0))\n                bPts.Add(Rhino.Geometry.Point3d(float(w_dst),\n                                                float(h_dst),\n                                                0.0))\n                bPts.Add(Rhino.Geometry.Point3d(0.0, float(h_dst), 0.0))\n                bPts.Add(Rhino.Geometry.Point3d(0.0, 0.0, 0.0))\n                # create polylinecurve from .NET list and scale with factor\n                image_boundary = Rhino.Geometry.PolylineCurve(bPts)\n                image_boundary.Scale(scalingfactor)\n\n        # return output\n        return ([image_boundary],\n                hsutil.nested_sequence_to_hops_tree(all_contours),\n                hsutil.nested_sequence_to_hops_tree(all_qrdata))\n\n    # return empty output if run flag is False\n    return ([],\n            hsutil.nested_sequence_to_hops_tree([]),\n            hsutil.nested_sequence_to_hops_tree([]))\n\n\n# POTPOURRI3D /////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/pp3d.MeshHeatMethodDistance\",\n    name=\"MeshHeatMethodDistance\",\n    nickname=\"MeshHeatDist\",\n    description=\"Compute geodesic distances using the heat method.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to compute geodesic distances on.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Sources\", \"S\", \"The indices of the source vertices from which to compute geodesic distances using the heat method. Defaults to 0.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"TextureScale\", \"T\", \"The texturescale used for setting the normalized values to the texture coordinates.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The mesh with texture coordinates set to the normalized values.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"Distances\", \"D\", \"The geodesic distances to all mesh vertices.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Values\", \"V\", \"The normalized values for every mesh vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef pp3d_HeatMethodDistanceComponent(mesh,\n                                     sources,\n                                     texture_scale=1.0):\n\n    # ensure that the user picked a feasible source\n    for v in list(sources):\n        assert v <= mesh.Vertices.Count - 1, (\"The index of the \"\n                                              \"source vertex cannot \"\n                                              \"exceed the vertex \"\n                                              \"count!\")\n\n    # get vertex and face array\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # compute geodesic heat distances\n    if len(sources) == 1:\n        geodists = [float(x) for x in\n                    pp3d.compute_distance(V, F, sources[0])]\n    else:\n        geodists = [float(x) for x in\n                    pp3d.compute_distance_multisource(V, F, sources)]\n\n    # normalize all values for setting texture coordinates\n    vmin = min(geodists)\n    vmax = max(geodists)\n    mult = 1.0 / (vmax - vmin)\n    values = [mult * (v - vmin) for v in geodists]\n\n    # set texture coordinates of output mesh\n    out_mesh = mesh.Duplicate()\n    for i in range(out_mesh.Vertices.Count):\n        out_mesh.TextureCoordinates.SetTextureCoordinate(\n                    i,\n                    Rhino.Geometry.Point2f(0.0, values[i] * texture_scale))\n\n    # return results\n    return out_mesh, geodists, values\n\n\n@hops.component(\n    \"/pp3d.MeshVectorHeatExtendScalar\",\n    name=\"MeshVectorHeatExtendScalar\",\n    nickname=\"MeshVecHeatExtScal\",\n    description=\"Extend scalar values along a mesh using the vector heat method.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to extend scalar on.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Sources\", \"S\", \"The indices of the source vertices from which to extend the scalar values.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"Values\", \"V\", \"The scalar values to extend per source vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"TextureScale\", \"T\", \"The texturescale used for setting the normalized values to the texture coordinates.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The mesh with texture coordinates set to the normalized values.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"ExtendedScalars\", \"E\", \"The extended scalar values for every mesh vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsNumber(\"NormalizedValues\", \"N\", \"The normalized extended scalar values for every mesh vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef pp3d_MeshVectorHeatExtendScalarComponent(mesh,\n                                             sources,\n                                             values,\n                                             texture_scale=1.0):\n\n    # ensure that the user picked feasible sources\n    for v in list(sources):\n        assert v >= 0, \"Vertex index cannot be negative!\"\n        assert v <= mesh.Vertices.Count - 1, (\"The index of the \"\n                                              \"source vertex cannot \"\n                                              \"exceed the vertex \"\n                                              \"count!\")\n\n    # sanitize input list lengths\n    assert len(sources) == len(values), (\"Number of sources and tangent \"\n                                         \"vectors has to correspond!\")\n\n    # get vertex and face array\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # Init vector heat solver\n    vhmsolver = pp3d.MeshVectorHeatSolver(V, F)\n\n    # extend the scalar\n    extended_scalars = [float(v) for v in\n                        vhmsolver.extend_scalar(sources, values)]\n\n    # normalize all values for setting texture coordinates\n    vmin = min(extended_scalars)\n    vmax = max(extended_scalars)\n    mult = 1.0 / (vmax - vmin)\n    nrmvalues = [mult * (v - vmin) for v in extended_scalars]\n\n    # set texture coordinates of output mesh\n    out_mesh = mesh.Duplicate()\n    for i in range(out_mesh.Vertices.Count):\n        out_mesh.TextureCoordinates.SetTextureCoordinate(\n                    i,\n                    Rhino.Geometry.Point2f(0.0, nrmvalues[i] * texture_scale))\n\n    return out_mesh, extended_scalars, nrmvalues\n\n\n@hops.component(\n    \"/pp3d.MeshVectorHeatParallelTransport\",\n    name=\"MeshVectorHeatParallelTransport\",\n    nickname=\"MeshVecHeatTransp\",\n    description=\"Parallel transport a vector along the surface.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to use for parallel transport.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Sources\", \"S\", \"The indices of the source vertices from which to transport the tangent vectors.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsVector(\"Vectors\", \"V\", \"The 2d tangent vectors to parallel transport per source vertex.\", hs.HopsParamAccess.LIST), # NOQA501\n    ],\n    outputs=[\n        hs.HopsVector(\"TangentFrames\", \"F\", \"The tangent frames used by the solver.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsVector(\"TransportVectors\", \"T\", \"The tangent vectors after parallel transport.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsVector(\"MappedVectors\", \"M\", \"The tangent vectors after parallel transport mapped to 3D.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef pp3d_MeshVectorHeatParallelTransportComponent(mesh,\n                                                  sources,\n                                                  vectors):\n\n    # ensure that the user picked feasible sources\n    for v in list(sources):\n        assert v >= 0, \"Vertex index cannot be negative!\"\n        assert v <= mesh.Vertices.Count - 1, (\"The index of the \"\n                                              \"source vertex cannot \"\n                                              \"exceed the vertex \"\n                                              \"count!\")\n\n    # sanitize input list lengths\n    assert len(sources) == len(vectors), (\"Number of sources and tangent \"\n                                          \"vectors has to correspond!\")\n\n    # get vertex and face array\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # sanitize rhino vectors to 2d tangent space\n    tvectors = []\n    for v in vectors:\n        tvectors.append([v.X, v.Y])\n\n    # init vector heat solver\n    vhmsolver = pp3d.MeshVectorHeatSolver(V, F)\n\n    # get tangent frames and convert them to rhino planes\n    basisX, basisY, basisN = vhmsolver.get_tangent_frames()\n    frames = {}\n    for i, (bX, bY, bN) in enumerate(zip(basisX, basisY, basisN)):\n        origin = Rhino.Geometry.Vector3d(\n                        Rhino.Geometry.Point3d(mesh.Vertices[i]))\n        xaxis = Rhino.Geometry.Vector3d(bX[0], bX[1], bX[2])\n        yaxis = Rhino.Geometry.Vector3d(bY[0], bY[1], bY[2])\n        frames[\"{%s}\" % str(i)] = (origin, xaxis, yaxis)\n\n    # extend the vector via parallel transport\n    if len(sources) > 1:\n        ext_vectors = vhmsolver.transport_tangent_vectors(sources,\n                                                          tvectors)\n    else:\n        ext_vectors = vhmsolver.transport_tangent_vector(sources[0],\n                                                         tvectors[0])\n\n    # map extended vectors to 3d space\n    ext_vectors_3d = (ext_vectors[:, 0, np.newaxis] * basisX +\n                      ext_vectors[:, 1, np.newaxis] * basisY)\n\n    # convert vectors to rhino\n    rh_vectors = hsutil.np_array_to_rhino_vectors(ext_vectors)\n    rh_vectors_3d = hsutil.np_array_to_rhino_vectors(ext_vectors_3d)\n\n    # return the results of the parallel transport\n    return frames, rh_vectors, rh_vectors_3d\n\n\n# SKLEARN /////////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/sklearn.TSNE\",\n    name=\"TSNE\",\n    nickname=\"TSNE\",\n    description=\"T-distributed Stochastic Neighbor Embedding.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"Data\", \"D\", \"Point Data to be reduced using t-SNE as a DataTree, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsInteger(\"Components\", \"N\", \"Dimension of the embedded space.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Perplexity\", \"P\", \"The perplexity is related to the number of nearest neighbors that are used in other manifold learning algorithms. Consider selecting a value between 5 and 50. Defaults to 30.\", hs.HopsParamAccess.ITEM, ), # NOQA501\n        hs.HopsNumber(\"EarlyExaggeration\", \"E\", \"Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. Defaults to 12.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"LearningRate\", \"R\", \"The learning rate for t-SNE is usually in the range (10.0, 1000.0). Defaults to 200.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Iterations\", \"I\", \"Maximum number of iterations for the optimization. Should be at least 250. Defaults to 1000.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Method\", \"M\", \"Barnes-Hut approximation (0) runs in O(NlogN) time. Exact method (1) will run on the slower, but exact, algorithm in O(N^2) time. Defaults to 0.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Initialization\", \"I\", \"Initialization method. Random (0) or PCA (1).\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"RandomSeed\", \"S\", \"Determines the random number generator. Pass an int for reproducible results across multiple function calls. Note that different initializations might result in different local minima of the cost function. Defaults to None.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"Points\", \"T\", \"The transformed points\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef sklearn_TSNEComponent(data,\n                          n_components=2,\n                          perplexity=30,\n                          early_exaggeration=12.0,\n                          learning_rate=200.0,\n                          n_iter=1000,\n                          method=0,\n                          init=0,\n                          rnd_seed=0):\n    # loop over tree and extract data points\n    paths, np_data = hsutil.hops_tree_to_np_array(data)\n    # convert method string\n    if method <= 0:\n        method_str = \"barnes_hut\"\n    else:\n        method_str = \"exact\"\n    if init <= 0:\n        init_str = \"random\"\n    else:\n        init_str = \"pca\"\n    # initialize t-SNE solver class\n    tsne = TSNE(n_components=n_components,\n                perplexity=perplexity,\n                early_exaggeration=early_exaggeration,\n                learning_rate=learning_rate,\n                n_iter=n_iter,\n                random_state=rnd_seed,\n                method=method_str,\n                init=init_str)\n    # run t-SNE solver on incoming data\n    tsne_result = tsne.fit_transform(np_data)\n    # return data as hops tree (dict)\n    return hsutil.np_float_array_to_hops_tree(tsne_result, paths)\n\n\n@hops.component(\n    \"/sklearn.PCA\",\n    name=\"PCA\",\n    nickname=\"PCA\",\n    description=\"Principal component analysis.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"Data\", \"D\", \"Point Data to be reduced using PCA as a DataTree, where each Branch represents one Point.\", hs.HopsParamAccess.TREE), # NOQA501\n        hs.HopsInteger(\"Components\", \"N\", \"Number of components (dimensions) to keep.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"Points\", \"T\", \"The transformed points\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef sklearn_PCAComponent(data,\n                         n_components=2):\n    # loop over tree and extract data points\n    paths, np_data = hsutil.hops_tree_to_np_array(data)\n    # initialize PCA solver class\n    pca = PCA(n_components=n_components)\n    # run PCA solver on incoming data\n    pca_result = pca.fit_transform(np_data)\n    # return data as hops tree (dict)\n    return hsutil.np_float_array_to_hops_tree(pca_result, paths)\n\n\n# SPHERICAL HARMONICS SHAPE DESCRIPTOR ////////////////////////////////////////\n\n@hops.component(\n    \"/sshd.MeshSphericalHarmonicsDescriptor\",\n    name=\"MeshSphericaHarmonicsDescriptor\",\n    nickname=\"MeshSHD\",\n    description=\"Description of mesh using a complex function on the sphere.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to compute the shape descriptor for.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Dimensions\", \"D\", \"Number of dimensions/coefficients for the computation. Defaults to 13.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"FeatureVector\", \"F\", \"The feature vector for the shape descriptor.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef sshd_MeshSphericalHarmonicsDescriptorComponent(mesh, dims=13):\n    # check if mesh is all triangles\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh has to be triangular!\")\n\n    # get np arrays of vertices and faces\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # compute shape descriptor\n    sdescr = sshd.descriptorCS(V, F, coef_num_sqrt=dims)\n\n    # convert descriptor values to floats\n    sdescr = [float(x) for x in sdescr]\n\n    # return results\n    return sdescr\n\n\n@hops.component(\n    \"/shapesph.MeshSphericalHarmonicsDescriptorRI\",\n    name=\"MeshSphericaHarmonicsDescriptorRI\",\n    nickname=\"MeshSHD\",\n    description=\"Description of mesh using rotation invariant spherical harmonics descriptor\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to compute the shape descriptor for.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"FeatureVector\", \"F\", \"The feature vector for the shape descriptor.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef shapesph_MeshSphericalHarmonicsDescriptorRIComponent(mesh):\n    # check if mesh is all triangles\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh has to be triangular!\")\n\n    # get plyfile elements of vertices and faces\n    V, F = hsutil.rhino_mesh_to_ply_elements(mesh)\n\n    # compute shape descriptor\n    sdescr = shapesph.compute_descriptor(V, F)\n\n    # convert descriptor values to floats\n    sdescr = [float(x) for x in sdescr]\n\n    # return results\n    return sdescr\n\n\n# VARIATIONAL SURFACE APPROXIMATION ///////////////////////////////////////////\n\n@hops.component(\n    \"/vsa.VariationalSurfaceApproximation\",\n    name=\"VariationalSurfaceApproximation\",\n    nickname=\"VSA\",\n    description=\"Run VSA on a Mesh.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsMesh(\"Mesh\", \"M\", \"The triangle mesh to run VSA on.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"NumRegions\", \"N\", \"The number of regions for the VSA\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsInteger(\"Iterations\", \"I\", \"The number of iterations to run VSA.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsMesh(\"Regions\", \"R\", \"The regions as a result of the VSA solve.\", hs.HopsParamAccess.LIST), # NOQA501\n    ])\ndef vsa_VariationalSurfaceApproximationComponent(mesh, n, iters):\n    # check if mesh is all triangles\n    if mesh.Faces.QuadCount > 0:\n        raise ValueError(\"Mesh has to be triangular!\")\n\n    # get plyfile elements of vertices and faces\n    V, F = hsutil.rhino_mesh_to_np_arrays(mesh)\n\n    # create new vsa instance\n    VSA = vsa.VariationalSurfaceApproximation(V, F, n)\n\n    # solve for x iterations\n    region_meshes = VSA.Solve(iters)\n\n    # create rhino meshes\n    rhino_region_meshes = []\n    for m in region_meshes:\n        rhinomesh = hsutil.np_arrays_to_rhino_triangle_mesh(m[0], m[1])\n        rhino_region_meshes.append(rhinomesh)\n\n    # return the results\n    return rhino_region_meshes\n\n\n# UTILS ///////////////////////////////////////////////////////////////////////\n\n@hops.component(\n    \"/utils.HausdorffDistance\",\n    name=\"HausdorffDistance\",\n    nickname=\"HDist\",\n    description=\"Hausdorff distance between two polylines.\", # NOQA501\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPoint(\"CurvePointsA\", \"A\", \"The points of the first polyline.\", hs.HopsParamAccess.LIST), # NOQA501\n        hs.HopsPoint(\"CurvePointsB\", \"B\", \"The points of the second polyline.\", hs.HopsParamAccess.LIST), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"DirectedHausdorffDistance\", \"D\", \"The directed hausdorff distance between the two polylines from A to B.\", hs.HopsParamAccess.ITEM), # NOQA501\n        hs.HopsNumber(\"SymmetricHausdorffDistance\", \"S\", \"The symmetric (maximum) hausdorff distance between the two polylines A and B.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef utils_HausdorffDistanceComponent(curveA, curveB):\n\n    u = hsutil.rhino_points_to_np_array(curveA)\n    v = hsutil.rhino_points_to_np_array(curveB)\n\n    dA, iuA, ivA = scipy.spatial.distance.directed_hausdorff(u, v)\n    dB, iuB, ivB = scipy.spatial.distance.directed_hausdorff(v, u)\n\n    return dA, max(dA, dB)\n\n\n# TEST AND VERIFICATION COMPONENTS ////////////////////////////////////////////\n\n@hops.component(\n    \"/test.DataTree\",\n    name=\"tDataTree\",\n    nickname=\"tDataTree\",\n    description=\"Test DataTree input/output.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsNumber(\"InTree\", \"I\", \"Input Tree.\", hs.HopsParamAccess.TREE), # NOQA501\n    ],\n    outputs=[\n        hs.HopsNumber(\"OutTree\", \"O\", \"Output Tree.\", hs.HopsParamAccess.TREE), # NOQA501\n    ])\ndef test_DataTreeComponent(tree):\n\n    if not tree:\n        tree = {}\n        tree[\"0;0\"] = [0.0]\n        tree[\"0;1\"] = [0, 1]\n        tree[\"0;2\"] = [\"a\", \"b\", \"c\"]\n        tree[\"0;3\"] = [0.0, \"abc\", True]\n    return tree\n\n\n@hops.component(\n    \"/test.Circle\",\n    name=\"tCircle\",\n    nickname=\"tCircle\",\n    description=\"Test Circle Param.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsCircle(\"InCircle\", \"I\", \"Input Circle.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsCircle(\"OutCircle\", \"O\", \"Output Circle.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef test_CircleComponent(circle):\n\n    if not circle:\n        circle = Rhino.Geometry.Circle(Rhino.Geometry.Plane.WorldXY,\n                                       1.0)\n    return circle\n\n\n@hops.component(\n    \"/test.Plane\",\n    name=\"tPlane\",\n    nickname=\"tPlane\",\n    description=\"Test Plane Param.\",\n    category=None,\n    subcategory=None,\n    icon=\"resources/icons/220204_malt_icon.png\",\n    inputs=[\n        hs.HopsPlane(\"InPlane\", \"I\", \"Input Plane.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ],\n    outputs=[\n        hs.HopsPlane(\"OutPlane\", \"O\", \"Output Plane.\", hs.HopsParamAccess.ITEM), # NOQA501\n    ])\ndef test_PlaneComponent(plane):\n\n    if not plane:\n        plane = Rhino.Geometry.Plane.WorldXY\n    return plane\n\n\n@hops.component(\n    \"/test.IntegerOutput\",\n    name=\"tIntegerOutput\",\n    nickname=\"tIntegerOutput\",\n    description=\"Add numbers with CPython and Test Integer output.\", # NOQA501\n    inputs=[\n        hs.HopsInteger(\"A\", \"A\", \"First number\"), # NOQA501\n        hs.HopsInteger(\"B\", \"B\", \"Second number\"), # NOQA501\n    ],\n    outputs=[\n        hs.HopsInteger(\"Sum\", \"S\", \"A + B\"), # NOQA501\n    ])\ndef test_IntegerOutputComponent(a, b):\n    return a + b\n\n\n# RUN HOPS APP AS EITHER FLASK OR DEFAULT -------------------------------------\n\nif __name__ == \"__main__\":\n    print(\"-----------------------------------------------------\")\n    print(\"[INFO] Available Hops Components on this Server:\")\n    [print(\"{0} -> {1}\".format(c, hops._components[c].description))\n     for c in hops._components if not str(c).startswith(\"/test.\")]\n    print(\"-----------------------------------------------------\")\n    if type(hops) == hs.HopsFlask:\n        if _NETWORK_ACCESS:\n            flaskapp.run(debug=_DEBUG, host=\"0.0.0.0\")\n        else:\n            flaskapp.run(debug=_DEBUG)\n    else:\n        hops.start(debug=_DEBUG)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhino3dm"
  ],
  "has_docstring": true
}