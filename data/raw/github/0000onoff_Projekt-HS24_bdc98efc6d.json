{
  "source_url": "https://github.com/0000onoff/Projekt-HS24/blob/8a5cd818ae9ed6e0128f64dcd94d646e8e797503/ironpython-stubs-master/release/stubs.min/Rhino/Geometry/__init___parts/Quaternion.py",
  "repo": "0000onoff/Projekt-HS24",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "ironpython-stubs-master/release/stubs.min/Rhino/Geometry/__init___parts/Quaternion.py",
  "instruction": "Quaternion",
  "code": "class Quaternion(object,IEquatable[Quaternion],IEpsilonComparable[Quaternion]):\n \"\"\"\n Represents the four coefficient values in a quaternion.\n\n    The first value a is the real part,\n\n    while the rest multipies i,j and k,that are imaginary.quaternion=a + bi + cj + dk\n\n \n\n Quaternion(a: float,b: float,c: float,d: float)\n \"\"\"\n @staticmethod\n def CrossProduct(p,q):\n  \"\"\"\n  CrossProduct(p: Quaternion,q: Quaternion) -> Quaternion\n\n  \n\n   Computes the vector cross product of p and q=(0,x,y,z),\n\n     where (x,y,z)=\n\n    Rhino.Geometry.Vector3d.CrossProduct(Rhino.Geometry.Vector3d,Rhino.Geometry.Vector3d)CrossProduct\n\n    (p.Rhino.Geometry.Quaternion.VectorVector,q.Rhino.Geometry.Quaternion.VectorVector).This is not \n\n    the same as the quaternion product p*q.\n\n  \n\n  \n\n   p: A quaternion.\n\n   q: Another quaternion.\n\n   Returns: A new quaternion.\n  \"\"\"\n  pass\n @staticmethod\n def Distance(p,q):\n  \"\"\"\n  Distance(p: Quaternion,q: Quaternion) -> float\n\n  \n\n   Returns the distance or norm of the difference between two quaternions.\n\n  \n\n   p: A quaternion.\n\n   q: Another quaternion.\n\n   Returns: (p - q).Length()\n  \"\"\"\n  pass\n def DistanceTo(self,q):\n  \"\"\"\n  DistanceTo(self: Quaternion,q: Quaternion) -> float\n\n  \n\n   Computes the distance or norm of the difference between this and another quaternion.\n\n  \n\n   q: Another quaternion.\n\n   Returns: (this - q).Length.\n  \"\"\"\n  pass\n def EpsilonEquals(self,other,epsilon):\n  \"\"\"\n  EpsilonEquals(self: Quaternion,other: Quaternion,epsilon: float) -> bool\n\n  \n\n   Check that all values in other are within epsilon of the values in this\n  \"\"\"\n  pass\n def Equals(self,*__args):\n  \"\"\"\n  Equals(self: Quaternion,obj: object) -> bool\n\n  \n\n   Determines whether an object is a quaternion and has the same value of this quaternion.\n\n  \n\n   obj: Another object to compare.\n\n   Returns: true if obj is a quaternion and has exactly equal coefficients; otherwise false.\n\n  Equals(self: Quaternion,other: Quaternion) -> bool\n\n  \n\n   Determines whether this quaternion has the same value of another quaternion.\n\n  \n\n   other: Another quaternion to compare.\n\n   Returns: true if the quaternions have exactly equal coefficients; otherwise false.\n  \"\"\"\n  pass\n def GetHashCode(self):\n  \"\"\"\n  GetHashCode(self: Quaternion) -> int\n\n  \n\n   Gets a non-unique but repeatable hashing code for this quaternion.\n\n   Returns: A signed number.\n  \"\"\"\n  pass\n def GetRotation(self,*__args):\n  \"\"\"\n  GetRotation(self: Quaternion) -> (bool,Plane)\n\n  \n\n   Returns the frame created by applying the quaternion's rotation\n\n     to the canonical \n\n    world frame (1,0,0),(0,1,0),(0,0,1).\n\n  \n\n   Returns: true if the operation succeeded; otherwise,false.\n\n  GetRotation(self: Quaternion) -> (bool,float,Vector3d)\n\n  \n\n   Returns the rotation defined by the quaternion.\n\n   Returns: True if the operation succeeded; otherwise,false.\n  \"\"\"\n  pass\n def Invert(self):\n  \"\"\"\n  Invert(self: Quaternion) -> bool\n\n  \n\n   Modifies this quaternion to become\n\n     (a/L2,-b/L2,-c/L2,-d/L2),where L2=length \n\n    squared=(a*a + b*b + c*c + d*d).This is the multiplicative inverse,i.e.,\n\n     \n\n    (a,b,c,d)*(a/L2,-b/L2,-c/L2,-d/L2)=(1,0,0,0).\n\n  \n\n   Returns: true if successful. false if the quaternion is zero and cannot be inverted.\n  \"\"\"\n  pass\n def MatrixForm(self):\n  \"\"\"\n  MatrixForm(self: Quaternion) -> Transform\n\n  \n\n   Returns 4x4 real valued matrix form of the quaternion\n\n     a  b  c  d\n\n     -b  a \n\n    -d  c\n\n     -c  d  a -b\n\n     -d -c  b  a\n\n     which has the same \n\n    arithmetic properties as the quaternion.\n\n  \n\n   Returns: A transform value.\n  \"\"\"\n  pass\n @staticmethod\n def Product(p,q):\n  \"\"\"\n  Product(p: Quaternion,q: Quaternion) -> Quaternion\n\n  \n\n   The quaternion product of p and q.  This is the same value as p*q.\n\n  \n\n   p: The first trasform.\n\n   q: The second trasform.\n\n   Returns: A transform value.\n  \"\"\"\n  pass\n def Rotate(self,v):\n  \"\"\"\n  Rotate(self: Quaternion,v: Vector3d) -> Vector3d\n\n  \n\n   Rotates a 3d vector. This operation is also called conjugation,\n\n     because the result \n\n    is the same as\n\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.\n\n  \n\n  \n\n   v: The vector to be rotated.\n\n   Returns: R*v,where R is the rotation defined by the unit quaternion.\n\n     This is mathematically \n\n    the same as the values\n\n     (Inverse(q)*(0,x,y,z)*q).Vector\n\n     and\n\n       \n\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.\n  \"\"\"\n  pass\n @staticmethod\n def Rotation(*__args):\n  \"\"\"\n  Rotation(plane0: Plane,plane1: Plane) -> Quaternion\n\n  \n\n   Returns the unit quaternion that represents the the rotation that maps\n\n     plane0.xaxis \n\n    to plane1.xaxis,plane0.yaxis to plane1.yaxis,and \n\n     plane0.zaxis to plane1.zaxis.\n\n  \n\n  \n\n   plane0: The first plane.\n\n   plane1: The second plane.\n\n   Returns: A quaternion value.\n\n  Rotation(angle: float,axisOfRotation: Vector3d) -> Quaternion\n\n  \n\n   Returns the unit quaternion\n\n     cos(angle/2),sin(angle/2)*x,sin(angle/2)*y,\n\n    sin(angle/2)*z\n\n     where (x,y,z) is the unit vector parallel to axis.  This is the\n\n   \n\n      unit quaternion that represents the rotation of angle about axis.\n\n  \n\n  \n\n   angle: An angle in radians.\n\n   axisOfRotation: The axis of rotation.\n\n   Returns: A new quaternion.\n  \"\"\"\n  pass\n def Set(self,a,b,c,d):\n  \"\"\"\n  Set(self: Quaternion,a: float,b: float,c: float,d: float)\n\n   Sets all coefficients of the quaternion.\n  \"\"\"\n  pass\n def SetRotation(self,*__args):\n  \"\"\"\n  SetRotation(self: Quaternion,plane0: Plane,plane1: Plane)\n\n   Sets the quaternion to the unit quaternion which rotates\n\n     plane0.xaxis to \n\n    plane1.xaxis,plane0.yaxis to plane1.yaxis,\n\n     and plane0.zaxis to plane1.zaxis.\n\n  \n\n  \n\n   plane0: The \"from\" rotation plane. Origin point is ignored.\n\n   plane1: The \"to\" rotation plane. Origin point is ignored.\n\n  SetRotation(self: Quaternion,angle: float,axisOfRotation: Vector3d)\n\n   Sets the quaternion to cos(angle/2),sin(angle/2)*x,sin(angle/2)*y,sin(angle/2)*z\n\n     \n\n    where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion\n\n     \n\n    that represents the rotation of angle about axis.\n\n  \n\n  \n\n   angle: in radians.\n\n   axisOfRotation: The direction of the axis of rotation.\n  \"\"\"\n  pass\n def Unitize(self):\n  \"\"\"\n  Unitize(self: Quaternion) -> bool\n\n  \n\n   Scales the quaternion's coordinates so that a*a + b*b + c*c + d*d=1.\n\n   Returns: true if successful.  false if the quaternion is zero and cannot be unitized.\n  \"\"\"\n  pass\n def __add__(self,*args):\n  \"\"\" x.__add__(y) <==> x+y \"\"\"\n  pass\n def __div__(self,*args):\n  \"\"\" x.__div__(y) <==> x/y \"\"\"\n  pass\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==y \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __mul__(self,*args):\n  \"\"\" x.__mul__(y) <==> x*yx.__mul__(y) <==> x*yx.__mul__(y) <==> x*yx.__mul__(y) <==> x*y \"\"\"\n  pass\n @staticmethod\n def __new__(self,a,b,c,d):\n  \"\"\"\n  __new__[Quaternion]() -> Quaternion\n\n  \n\n  __new__(cls: type,a: float,b: float,c: float,d: float)\n  \"\"\"\n  pass\n def __ne__(self,*args):\n  pass\n def __radd__(self,*args):\n  \"\"\"\n  __radd__(a: Quaternion,b: Quaternion) -> Quaternion\n\n  \n\n   Adds two quaternions.\n\n     This sums each quaternion coefficient with its correspondant \n\n    and returns\n\n     a new result quaternion.\n\n  \n\n  \n\n   a: A quaternion.\n\n   b: Another quaternion.\n\n   Returns: A new quaternion.\n  \"\"\"\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n def __rmul__(self,*args):\n  \"\"\"\n  __rmul__(a: Quaternion,b: Quaternion) -> Quaternion\n\n  \n\n   Multiplies a quaternion with another one.\n\n     Quaternion multiplication (Hamilton \n\n    product) is not commutative.\n\n  \n\n  \n\n   a: The first term.\n\n   b: The second term.\n\n   Returns: A new quaternion.\n  \"\"\"\n  pass\n def __rsub__(self,*args):\n  \"\"\"\n  __rsub__(a: Quaternion,b: Quaternion) -> Quaternion\n\n  \n\n   Subtracts a quaternion from another one.\n\n     This computes the difference of each \n\n    quaternion coefficient with its\n\n     correspondant and returns a new result quaternion.\n\n  \n\n  \n\n   a: A quaternion.\n\n   b: Another quaternion.\n\n   Returns: A new quaternion.\n  \"\"\"\n  pass\n def __str__(self,*args):\n  pass\n def __sub__(self,*args):\n  \"\"\" x.__sub__(y) <==> x-y \"\"\"\n  pass\n A=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the real part of the quaternion.\n\n\n\nGet: A(self: Quaternion) -> float\n\n\n\nSet: A(self: Quaternion)=value\n\n\"\"\"\n\n B=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the first imaginary coefficient of the quaternion.\n\n\n\nGet: B(self: Quaternion) -> float\n\n\n\nSet: B(self: Quaternion)=value\n\n\"\"\"\n\n C=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the second imaginary coefficient of the quaternion.\n\n\n\nGet: C(self: Quaternion) -> float\n\n\n\nSet: C(self: Quaternion)=value\n\n\"\"\"\n\n Conjugate=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets a new quaternion that is the conjugate of this quaternion.\n\n   This is (a,-b,-c,-d)\n\n\n\nGet: Conjugate(self: Quaternion) -> Quaternion\n\n\n\n\"\"\"\n\n D=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets the third imaginary coefficient of the quaternion.\n\n\n\nGet: D(self: Quaternion) -> float\n\n\n\nSet: D(self: Quaternion)=value\n\n\"\"\"\n\n Inverse=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Computes a new inverted quaternion,\n\n   (a/L2,-b/L2,-c/L2,-d/L2),where L2=length squared=(a*a + b*b + c*c + d*d).\n\n   This is the multiplicative inverse,i.e.,\n\n   (a,b,c,d)*(a/L2,-b/L2,-c/L2,-d/L2)=(1,0,0,0).\n\n   If this is the zero quaternion,then the zero quaternion is returned.\n\n\n\nGet: Inverse(self: Quaternion) -> Quaternion\n\n\n\n\"\"\"\n\n IsScalar=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"true if b,c,and d are all zero.\n\n\n\nGet: IsScalar(self: Quaternion) -> bool\n\n\n\n\"\"\"\n\n IsValid=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Determines if the four coefficients are valid numbers within RhinoCommon.\n\n   See Rhino.RhinoMath.IsValidDouble(System.Double).\n\n\n\nGet: IsValid(self: Quaternion) -> bool\n\n\n\n\"\"\"\n\n IsVector=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"true if a=0 and at least one of b,c,or d is not zero.\n\n\n\nGet: IsVector(self: Quaternion) -> bool\n\n\n\n\"\"\"\n\n IsZero=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"true if a,b,c,and d are all zero.\n\n\n\nGet: IsZero(self: Quaternion) -> bool\n\n\n\n\"\"\"\n\n Length=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Returns the length or norm of the quaternion.\n\n\n\nGet: Length(self: Quaternion) -> float\n\n\n\n\"\"\"\n\n LengthSquared=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the result of (a^2 + b^2 + c^2 + d^2).\n\n\n\nGet: LengthSquared(self: Quaternion) -> float\n\n\n\n\"\"\"\n\n Scalar=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"The real (scalar) part of the quaternion\n\n   This is Rhino.Geometry.Quaternion.A.\n\n\n\nGet: Scalar(self: Quaternion) -> float\n\n\n\n\"\"\"\n\n Vector=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"The imaginary part of the quaternion\n\n   (B,C,D)\n\n\n\nGet: Vector(self: Quaternion) -> Vector3d\n\n\n\n\"\"\"\n\n\n I=None\n Identity=None\n J=None\n K=None\n Zero=None\n\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": false
}