{
  "source_url": "https://github.com/felipeharker/alexandria-lab/blob/1d3696f4b28ecc45579b5fbe5809a7e00699fa08/alexandria-application-files/alexandria-scripts/ghpython/geo_nest.py",
  "repo": "felipeharker/alexandria-lab",
  "repo_stars": 1,
  "repo_description": "a repo of documents, links, visual assets, drawings, videos, articles, etc. I find interesting. Brain dump, catch-all repo with limited structure. ",
  "license": "unknown",
  "filepath": "alexandria-application-files/alexandria-scripts/ghpython/geo_nest.py",
  "instruction": "GhPython Component: Heuristic 2D nesting (Skyline packer + meta-heuristics)",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - Parts (GH: Crvs) | list[Rhino.Geometry.Curve] | Closed planar parts\n# - SheetGeo (GH: Sheet) | Rhino.Geometry.GeometryBase | Rectangular sheet source\n# - Spacing (GH: Spacing) | float | Part spacing\n# - Rotations (GH: Rotations) | int | Rotation samples per part\n# - Iterations (GH: Iterations) | int | Packing iterations\n# - SortMode (GH: SortMode) | int | Part sorting strategy\n# - HeuristicMode (GH: HeuristicMode) | int | Placement heuristic\n# - ObjectiveMode (GH: ObjectiveMode) | int | Optimization objective\n# - Run (GH: Run) | bool | Execution gate\n# Outputs:\n# - Nested (GH: Nested) | list[Rhino.Geometry.Curve] | Placed transformed parts\n# - Sheets (GH: Sheets) | list[Rhino.Geometry.Rectangle3d] | Used sheet rectangles\n# - NotNested (GH: NotNested) | list[Rhino.Geometry.Curve] | Unplaced parts\n\n\"\"\"GhPython Component: Heuristic 2D nesting (Skyline packer + meta-heuristics)\n\nWhat this does (practical + fast):\n- Treats each closed curve as a planar 2D part.\n- Nests using a Skyline (profile) rectangle packer.\n- Meta-heuristics over multiple iterations:\n  - varies ordering and placement heuristic (if enabled via -1 modes)\n  - tests ALL rotation angles every iteration\n\nIMPORTANT LIMITATIONS (explicit):\n- This is NOT true polygon nesting (no No-Fit-Polygon / Minkowski). It nests *bounding boxes*.\n- For production-grade polygon nesting, prefer OpenNest / NFP solvers.\n\nInputs (Grasshopper):\n    Crvs            (list[Rhino.Geometry.Curve])  closed planar curves (2D parts)\n    Sheet           (Curve or Surface or Brep or Rectangle3d) sheet boundary; must be rectangular\n    Spacing         (float) clearance between parts (same units as model)\n    Rotations       (int) number of rotation angles to test per part (>=1). ALL angles tested each iteration.\n    Iterations      (int) number of randomized packing attempts (>=1)\n\n    SortMode        (int)  -1=Explore, 0=AreaDesc, 1=MaxSideDesc, 2=PerimeterDesc, 3=RandomBiased\n    HeuristicMode   (int)  -1=Explore, 0=BottomLeft, 1=MinYThenWaste, 2=MinWasteThenY\n    ObjectiveMode   (int)  0=SheetsFirst, 1=UtilizationFirst, 2=CompactLastSheet\n    \n    Run             (bool) gate execution (False by default)\n\nOutputs:\n    Nested      (list[Rhino.Geometry.Curve]) transformed curves (nested on sheets)\n    Sheets      (list[Rhino.Geometry.Rectangle3d]) sheet rectangles used\n    NotNested   (list[Rhino.Geometry.Curve]) parts that could not be placed\n\"\"\"\n\nimport Rhino\nimport scriptcontext as sc\nimport random\nimport math\nimport time\n\nfrom Rhino.Geometry import (\n    Curve, Brep, Surface, Rectangle3d, Plane, Transform, BoundingBox, Point3d, Vector3d, Interval\n)\n\n# -----------------------------\n# Progress utilities (ALWAYS ON)\n# -----------------------------\n\ndef rhino_log(msg):\n    try:\n        Rhino.RhinoApp.WriteLine(str(msg))\n    except:\n        pass\n\ndef gh_message(msg):\n    try:\n        ghenv.Component.Message = str(msg)\n    except:\n        pass\n\ndef ms_since(t0):\n    return int(round((time.perf_counter() - t0) * 1000.0))\n\n# -----------------------------\n# Persistent storage across solutions\n# -----------------------------\n\nif \"nest_last_run\" not in sc.sticky:\n    sc.sticky[\"nest_last_run\"] = False\n\nif \"nest_last_results\" not in sc.sticky:\n    sc.sticky[\"nest_last_results\"] = ([], [], [])  # (Nested, Sheets, NotNested)\n\nrun_now = False\nif Run and not sc.sticky[\"nest_last_run\"]:\n    run_now = True\nsc.sticky[\"nest_last_run\"] = Run\n\n# -----------------------------\n# Helpers\n# -----------------------------\n\ndef _tol(default=0.01):\n    try:\n        if sc.doc and hasattr(sc.doc, \"ModelAbsoluteTolerance\"):\n            return sc.doc.ModelAbsoluteTolerance\n        if Rhino.RhinoDoc.ActiveDoc:\n            return Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n    except:\n        pass\n    return default\n\ndef _is_curve_planar_closed(c, tol):\n    if c is None or not isinstance(c, Curve):\n        return False\n    if not c.IsClosed:\n        return False\n    ok, _pl = c.TryGetPlane(tol)\n    return ok\n\ndef _curve_area(c):\n    amp = Rhino.Geometry.AreaMassProperties.Compute(c)\n    return amp.Area if amp else 0.0\n\ndef _sheet_to_rect(sheet, tol):\n    \"\"\"\n    Accept Rectangle3d, planar Curve, or Brep/Surface.\n    Returns (rect_local_in_WXY, sheet_plane_world) or (None, None).\n    Packing is done in local WXY, then mapped back to sheet_plane.\n    \"\"\"\n    if sheet is None:\n        return None, None\n\n    if isinstance(sheet, Rectangle3d):\n        w = sheet.Width\n        h = sheet.Height\n        if w <= tol or h <= tol:\n            return None, None\n        rect_local = Rectangle3d(Plane.WorldXY, Interval(0, w), Interval(0, h))\n        return rect_local, sheet.Plane\n\n    if isinstance(sheet, Curve):\n        ok, pl = sheet.TryGetPlane(tol)\n        if not ok:\n            return None, None\n        xform = Transform.PlaneToPlane(pl, Plane.WorldXY)\n        bb = sheet.GetBoundingBox(xform)\n        w = bb.Max.X - bb.Min.X\n        h = bb.Max.Y - bb.Min.Y\n        if w > tol and h > tol:\n            rect_local = Rectangle3d(Plane.WorldXY, Interval(0, w), Interval(0, h))\n            return rect_local, pl\n        return None, None\n\n    if isinstance(sheet, Surface):\n        b = sheet.ToBrep()\n        if b is None:\n            return None, None\n        sheet = b\n\n    if isinstance(sheet, Brep):\n        pl = Plane.WorldXY\n        try:\n            if sheet.Faces and sheet.Faces.Count > 0:\n                ok, pl2 = sheet.Faces[0].TryGetPlane(tol)\n                if ok:\n                    pl = pl2\n        except:\n            pass\n\n        xform = Transform.PlaneToPlane(pl, Plane.WorldXY)\n        bb = sheet.GetBoundingBox(xform)\n        w = bb.Max.X - bb.Min.X\n        h = bb.Max.Y - bb.Min.Y\n        if w > tol and h > tol:\n            rect_local = Rectangle3d(Plane.WorldXY, Interval(0, w), Interval(0, h))\n            return rect_local, pl\n\n    return None, None\n\ndef _angles(rotations):\n    r = max(1, int(rotations))\n    if r == 1:\n        return [0.0]\n    if r == 2:\n        return [0.0, 0.5 * math.pi]\n    step = 2.0 * math.pi / float(r)\n    return [i * step for i in range(r)]\n\ndef _bbox_data_local(crv_world, world_to_local, rot_angle, spacing):\n    \"\"\"\n    Precompute local bbox and rotation transform for a curve.\n    Returns dict:\n        w, h include spacing inflation.\n    \"\"\"\n    c = crv_world.DuplicateCurve()\n    c.Transform(world_to_local)  # world -> local WXY\n\n    bb0 = c.GetBoundingBox(True)\n    center = bb0.Center\n\n    rot = Transform.Rotation(rot_angle, Vector3d.ZAxis, center)\n    c.Transform(rot)\n\n    bb = c.GetBoundingBox(True)\n    w0 = (bb.Max.X - bb.Min.X)\n    h0 = (bb.Max.Y - bb.Min.Y)\n\n    w = w0 + spacing\n    h = h0 + spacing\n    perim = 2.0 * (w0 + h0)\n\n    return {\n        \"w\": w,\n        \"h\": h,\n        \"bbmin\": bb.Min,\n        \"rot\": rot,\n        \"bbox_area\": w * h,\n        \"bbox_perim\": perim,\n        \"max_side\": max(w, h)\n    }\n\n# -----------------------------\n# Skyline packer\n# -----------------------------\n# Segments are tuples (x, y, w) covering [0, sheet_w] without gaps.\n\ndef _skyline_init(sheet_w):\n    return [(0.0, 0.0, float(sheet_w))]\n\ndef _skyline_merge(segments, tol=1e-9):\n    if not segments:\n        return []\n    segments.sort(key=lambda s: s[0])\n    merged = [segments[0]]\n    for x, y, w in segments[1:]:\n        px, py, pw = merged[-1]\n        if abs((px + pw) - x) <= tol and abs(py - y) <= tol:\n            merged[-1] = (px, py, pw + w)\n        else:\n            merged.append((x, y, w))\n    return merged\n\ndef _skyline_y_and_waste(segments, start_i, rect_w):\n    x = segments[start_i][0]\n    x_end = x + rect_w\n\n    y = 0.0\n    i = start_i\n    cur_x = x\n    remaining = rect_w\n\n    while remaining > 1e-12:\n        if i >= len(segments):\n            return None, None\n        sx, sy, sw = segments[i]\n        seg_end = sx + sw\n        overlap = min(seg_end, x_end) - cur_x\n        if overlap <= 0.0:\n            i += 1\n            continue\n        if sy > y:\n            y = sy\n        remaining -= overlap\n        cur_x += overlap\n        if cur_x >= x_end - 1e-12:\n            break\n        i += 1\n\n    waste = 0.0\n    i = start_i\n    cur_x = x\n    while cur_x < x_end - 1e-12:\n        sx, sy, sw = segments[i]\n        seg_end = sx + sw\n        overlap = min(seg_end, x_end) - cur_x\n        if overlap > 0.0 and y > sy:\n            waste += (y - sy) * overlap\n        cur_x += overlap\n        if cur_x >= x_end - 1e-12:\n            break\n        i += 1\n        if i >= len(segments):\n            return None, None\n\n    return y, waste\n\ndef _skyline_find_position(segments, sheet_w, sheet_h, rect_w, rect_h, heuristic_mode):\n    \"\"\"\n    heuristic_mode:\n      0 = BottomLeft            (min y, then min x)\n      1 = MinYThenWaste         (min y, then min waste, then min x)\n      2 = MinWasteThenY         (min waste, then min y, then min x)\n    \"\"\"\n    if rect_w > sheet_w or rect_h > sheet_h:\n        return None, None, None\n\n    best = None  # (score, x, y)\n    for i, (x, _y, _w) in enumerate(segments):\n        if x + rect_w > sheet_w + 1e-9:\n            continue\n\n        y, waste = _skyline_y_and_waste(segments, i, rect_w)\n        if y is None:\n            continue\n        if y + rect_h > sheet_h + 1e-9:\n            continue\n\n        if heuristic_mode == 0:\n            score = (y, x)\n        elif heuristic_mode == 2:\n            score = (waste, y, x)\n        else:\n            score = (y, waste, x)\n\n        if best is None or score < best[0]:\n            best = (score, x, y)\n\n    if best is None:\n        return None, None, None\n\n    return best[1], best[2], best[0]\n\ndef _skyline_add_rect(segments, x, rect_w, new_top_y):\n    x_end = x + rect_w\n    new_segments = []\n\n    for sx, sy, sw in segments:\n        seg_end = sx + sw\n\n        if seg_end <= x or sx >= x_end:\n            new_segments.append((sx, sy, sw))\n            continue\n\n        if sx < x:\n            new_segments.append((sx, sy, x - sx))\n\n        if seg_end > x_end:\n            new_segments.append((x_end, sy, seg_end - x_end))\n\n    new_segments.append((x, new_top_y, rect_w))\n    return _skyline_merge(new_segments)\n\ndef _skyline_height_used(segments):\n    return max((s[1] for s in segments), default=0.0)\n\n# -----------------------------\n# Meta-heuristic packing\n# -----------------------------\n\ndef _sort_items(items, stats, sort_mode, rnd):\n    if sort_mode == 3:\n        # Random-biased: start from area-desc then shuffle a bit\n        items2 = sorted(items, key=lambda it: stats[it[\"id\"]][\"area\"], reverse=True)\n        return _random_biased_shuffle(items2, rnd)\n\n    if sort_mode == 1:\n        keyf = lambda it: stats[it[\"id\"]][\"max_side\"]\n    elif sort_mode == 2:\n        keyf = lambda it: stats[it[\"id\"]][\"bbox_perim\"]\n    else:\n        keyf = lambda it: stats[it[\"id\"]][\"area\"]\n\n    items2 = sorted(items, key=keyf, reverse=True)\n    return _random_biased_shuffle(items2, rnd)\n\ndef _random_biased_shuffle(items, rnd):\n    out = list(items)\n    n = len(out)\n    if n < 2:\n        return out\n    swaps = max(1, n // 5)\n    for _ in range(swaps):\n        a = rnd.randint(0, n - 1)\n        b = rnd.randint(0, n - 1)\n        out[a], out[b] = out[b], out[a]\n    return out\n\ndef _pack_skyline_once(items, precomp, sheet_w, sheet_h, angles, heuristic_mode):\n    placements = {}  # id -> (sheet_idx, angle, x, y)\n    skylines = [ _skyline_init(sheet_w) ]\n    bbox_area_used = 0.0\n\n    for it in items:\n        pid = it[\"id\"]\n\n        best = None  # (sheet_idx, angle, x, y, score, bbox_area)\n        for si, skyline in enumerate(skylines):\n            for ang in angles:\n                bd = precomp[pid].get(ang, None)\n                if bd is None:\n                    continue\n\n                w = bd[\"w\"]\n                h = bd[\"h\"]\n\n                x, y, score = _skyline_find_position(skyline, sheet_w, sheet_h, w, h, heuristic_mode)\n                if x is None:\n                    continue\n\n                # Prefer earlier sheets as a tie-break\n                cand_score = tuple(score) + (si,)\n                if best is None or cand_score < best[4]:\n                    best = (si, ang, x, y, cand_score, bd[\"bbox_area\"])\n\n        if best is None:\n            # add a new sheet (no cap)\n            skylines.append(_skyline_init(sheet_w))\n            si = len(skylines) - 1\n            skyline = skylines[si]\n\n            for ang in angles:\n                bd = precomp[pid].get(ang, None)\n                if bd is None:\n                    continue\n                w = bd[\"w\"]\n                h = bd[\"h\"]\n                x, y, score = _skyline_find_position(skyline, sheet_w, sheet_h, w, h, heuristic_mode)\n                if x is None:\n                    continue\n                best = (si, ang, x, y, tuple(score) + (si,), bd[\"bbox_area\"])\n                break\n\n        if best is None:\n            continue\n\n        si, ang, x, y, _score, a_bbox = best\n        bd = precomp[pid][ang]\n        w = bd[\"w\"]\n        h = bd[\"h\"]\n\n        skylines[si] = _skyline_add_rect(skylines[si], x, w, y + h)\n        placements[pid] = (si, ang, x, y)\n        bbox_area_used += a_bbox\n\n    unplaced_ids = [it[\"id\"] for it in items if it[\"id\"] not in placements]\n    last_h = _skyline_height_used(skylines[-1]) if skylines else 0.0\n    return placements, skylines, unplaced_ids, bbox_area_used, last_h\n\ndef _apply_placement_world(crv_world, sheet_plane_world, world_to_local, bbox_data, placement_xy, spacing):\n    x, y = placement_xy\n    bbmin = bbox_data[\"bbmin\"]\n    rot = bbox_data[\"rot\"]\n\n    c2 = crv_world.DuplicateCurve()\n    c2.Transform(world_to_local)\n    c2.Transform(rot)\n\n    target = Point3d(x + 0.5 * spacing, y + 0.5 * spacing, 0.0)\n    delta = target - Point3d(bbmin.X, bbmin.Y, 0.0)\n    c2.Transform(Transform.Translation(delta))\n\n    to_world = Transform.PlaneToPlane(Plane.WorldXY, sheet_plane_world)\n    c2.Transform(to_world)\n    return c2\n\n# -----------------------------\n# Main\n# -----------------------------\n\nNested = []\nSheets = []\nNotNested = []\n\nif not run_now:\n    Nested, Sheets, NotNested = sc.sticky[\"nest_last_results\"]\nelse:\n    try:\n        tol = _tol()\n\n        # Required-by-default inputs (safe defaults if None)\n        sort_mode = -1 if SortMode is None else int(SortMode)\n        heuristic_mode = -1 if HeuristicMode is None else int(HeuristicMode)\n        objective_mode = 0 if ObjectiveMode is None else int(ObjectiveMode)\n\n        spacing = 0.0 if Spacing is None else float(Spacing)\n        spacing = max(0.0, spacing)\n\n        rect_local, sheet_plane = _sheet_to_rect(Sheet, tol)\n        if rect_local is None or sheet_plane is None:\n            Nested, Sheets, NotNested = [], [], (Crvs if Crvs else [])\n            sc.sticky[\"nest_last_results\"] = (Nested, Sheets, NotNested)\n        else:\n            sheet_w = rect_local.Width\n            sheet_h = rect_local.Height\n            sheet_area = sheet_w * sheet_h\n\n            Crvs = [] if Crvs is None else Crvs\n\n            valid = []\n            invalid = []\n            for c in Crvs:\n                if c is None or not isinstance(c, Curve):\n                    continue\n                if not _is_curve_planar_closed(c, tol):\n                    invalid.append(c)\n                    continue\n                valid.append(c)\n\n            world_to_local = Transform.PlaneToPlane(sheet_plane, Plane.WorldXY)\n\n            rots = max(1, int(Rotations) if Rotations is not None else 2)\n            angles = _angles(rots)  # ALL angles tested each iteration\n\n            iters = max(1, int(Iterations) if Iterations is not None else 50)\n\n            rhino_log(\"Nesting Utility activated (Skyline). Iterations: {} | Rotations tested: {}\".format(iters, len(angles)))\n            gh_message(\"Nesting: running...\")\n\n            # Precompute bbox data for all (part, angle)\n            precomp = {}\n            stats = {}\n            items_base = []\n\n            for pid, crv in enumerate(valid):\n                precomp[pid] = {}\n                area = _curve_area(crv)\n\n                bbox_perim = 0.0\n                max_side = 0.0\n                for ang in angles:\n                    bd = _bbox_data_local(crv, world_to_local, ang, spacing)\n                    precomp[pid][ang] = bd\n                    if bd[\"bbox_perim\"] > bbox_perim:\n                        bbox_perim = bd[\"bbox_perim\"]\n                    if bd[\"max_side\"] > max_side:\n                        max_side = bd[\"max_side\"]\n\n                stats[pid] = {\n                    \"area\": area,\n                    \"bbox_perim\": bbox_perim,\n                    \"max_side\": max_side\n                }\n                items_base.append({\"id\": pid, \"crv\": crv})\n\n            def bbox_util_pct(bbox_area_used, sheets_used):\n                if sheets_used <= 0 or sheet_area <= 1e-12:\n                    return 0.0\n                return 100.0 * bbox_area_used / (sheet_area * float(sheets_used))\n\n            def true_util_pct(placed_ids, sheets_used):\n                if sheets_used <= 0 or sheet_area <= 1e-12:\n                    return 0.0\n                a = 0.0\n                for pid in placed_ids:\n                    a += stats[pid][\"area\"]\n                return 100.0 * a / (sheet_area * float(sheets_used))\n\n            def objective_tuple(objective_mode, unplaced_count, sheets_used, bbox_util, last_sheet_height):\n                # Lower is better.\n                if objective_mode == 1:\n                    # UtilizationFirst\n                    return (unplaced_count, sheets_used, -bbox_util, last_sheet_height)\n                if objective_mode == 2:\n                    # CompactLastSheet\n                    return (unplaced_count, sheets_used, last_sheet_height, -bbox_util)\n                # SheetsFirst\n                return (unplaced_count, sheets_used, -bbox_util, last_sheet_height)\n\n            heuristic_pool = [0, 1, 2]\n            sort_pool = [0, 1, 2, 3]\n\n            best = None\n\n            for k in range(iters):\n                iter_t0 = time.perf_counter()\n                rnd = random.Random(12345 + k)\n\n                hm = heuristic_mode\n                sm = sort_mode\n\n                # Explore modes if set to -1\n                if hm == -1:\n                    hm = rnd.choice(heuristic_pool)\n                if sm == -1:\n                    sm = rnd.choice(sort_pool)\n\n                items_iter = _sort_items(items_base, stats, sm, rnd)\n\n                placements, skylines, unplaced_ids, bbox_area_used, last_h = _pack_skyline_once(\n                    items_iter, precomp, sheet_w, sheet_h, angles, hm\n                )\n\n                sheets_used = len(skylines)\n                placed_ids = set(placements.keys())\n                bbox_util = bbox_util_pct(bbox_area_used, sheets_used)\n                true_util = true_util_pct(placed_ids, sheets_used)\n                unplaced_count = len(unplaced_ids)\n\n                score = objective_tuple(objective_mode, unplaced_count, sheets_used, bbox_util, last_h)\n\n                elapsed = ms_since(iter_t0)\n\n                # ALWAYS LOG EACH ITERATION\n                rhino_log(\n                    \"iter {:>3}/{:<3} | hm {} sm {} | {:>4} ms | sheets {:>2} | unplaced {:>3} | bbox {:>5.1f}% | true {:>5.1f}% | lastH {:>6.1f}\".format(\n                        k + 1, iters, hm, sm, elapsed, sheets_used, unplaced_count, bbox_util, true_util, last_h\n                    )\n                )\n                gh_message(\"Iter {}/{} | sheets {} | bbox {:.0f}% | {} ms\".format(k + 1, iters, sheets_used, bbox_util, elapsed))\n\n                if best is None or score < best[\"score\"]:\n                    best = {\n                        \"score\": score,\n                        \"placements\": placements,\n                        \"skylines\": skylines,\n                        \"unplaced_ids\": unplaced_ids,\n                        \"bbox_util\": bbox_util,\n                        \"true_util\": true_util,\n                        \"sheets_used\": sheets_used,\n                        \"hm\": hm,\n                        \"sm\": sm\n                    }\n\n                if unplaced_count == 0 and sheets_used == 1:\n                    break\n\n            if best is None:\n                Nested, Sheets, NotNested = [], [], (valid + invalid)\n                sc.sticky[\"nest_last_results\"] = (Nested, Sheets, NotNested)\n            else:\n                placements = best[\"placements\"]\n                sheets_used = best[\"sheets_used\"]\n\n                # Build sheet rectangles in world (stacked in +X for visualization)\n                offset_dx = sheet_w * 1.10\n                for si in range(sheets_used):\n                    pl = Plane(sheet_plane)\n                    pl.Origin = sheet_plane.Origin + (sheet_plane.XAxis * (offset_dx * si))\n                    rect_world = Rectangle3d(pl, rect_local.X, rect_local.Y)\n                    Sheets.append(rect_world)\n\n                # Build nested curves\n                for it in items_base:\n                    pid = it[\"id\"]\n                    if pid not in placements:\n                        continue\n                    si, ang, x, y = placements[pid]\n\n                    pl = Plane(sheet_plane)\n                    pl.Origin = sheet_plane.Origin + (sheet_plane.XAxis * (offset_dx * si))\n\n                    bbox_data = precomp[pid][ang]\n                    c_out = _apply_placement_world(it[\"crv\"], pl, world_to_local, bbox_data, (x, y), spacing)\n                    Nested.append(c_out)\n\n                NotNested = [valid[pid] for pid in best[\"unplaced_ids\"]] + list(invalid)\n\n                rhino_log(\n                    \"Nesting complete (Skyline). Sheets: {} | BBox util: {:.1f}% | True util: {:.1f}% | hm {} sm {}\".format(\n                        sheets_used, best[\"bbox_util\"], best[\"true_util\"], best[\"hm\"], best[\"sm\"]\n                    )\n                )\n                gh_message(\"Done | Sheets {} | bbox {:.0f}%\".format(sheets_used, best[\"bbox_util\"]))\n\n                sc.sticky[\"nest_last_results\"] = (Nested, Sheets, NotNested)\n\n    except Exception as e:\n        rhino_log(\"Nesting failed: {}\".format(e))\n        gh_message(\"Nesting: failed\")\n        Nested, Sheets, NotNested = sc.sticky[\"nest_last_results\"]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}