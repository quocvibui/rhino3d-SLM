{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Radiation%20Calla%20Dome.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Radiation Calla Dome.py",
  "instruction": "Use this component to draw Radiation Calla Dome, which shows you how radiation would fall on an object from all directions for a given sky.\n_\nIt is useful for finding the best direction with which to...",
  "code": "#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools>, Chris Mackey <Chris@MackeyArchitecture.com>, and Byron Mardas <byronmardas@gmail.com>\n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to draw Radiation Calla Dome, which shows you how radiation would fall on an object from all directions for a given sky.\n_\nIt is useful for finding the best direction with which to orient solar panels and gives a sense of the consequences of deviating from such an orientation.\n_\nThe Calla Dome can be understood in three different ways:\n_\n1) The Calla Dome a 3D representation of all possible radiation roses for a given sky since it includes all vertical angles from 0 to 90.\n2) The Calla Dome is the reciprocal of the Tergenza Sky Dome since the Cala Dome essentially shows you how the radiation from the sky will fall onto a hemispherical object.\n3) The Calla Dome is a smart radiation analysis of a hemisphere.  Your results would effectively be the same if you made a hemisphere in Rhino and ran it through the \"Radiation Analysis\" component but, with this component, you will get a smoother color gradient and the component will automatically output the point (or vector) with the most radiation.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _selectedSkyMtx: The output from the selectSkyMtx component.\n        _horAngleStep_: An angle in degrees between 0 and 360 that represents the step for horizontal rotation. Smaller numbers will yeild a finer and smoother mesh with smoother colors.  The number input here should be smaller than 360 and divisible by 360.  The default is set to 10 degrees.\n        _verAngleStep_: Angle in degrees step between 0 and 90 that represents the step for vertical rotation. Smaller numbers will yeild a finer and smoother mesh with smoother colors.  The number input here should be smaller than 90 and divisible by 90.  The default is set to 10 degrees.\n        _centerPoint: Input a point here to chage the center point of the Calla Dome and move it around the Rhino scene.  The default is set to the Rhino origin (0,0,0).\n        _scale_: Input a number here to change horizontal (XY) scale of the graph. The default value is set to 1.  Note that, for the dome representation, this input will change the scale of the entire dome (both horizontal and vertical).\n        _verScale_: Input a number here to change vertical (Z) scale of the graph. The default value is set to 1. Note that, for the dome representation, this input will have no effect.\n        _projection_: A number to set the projection of the sky hemisphere.  The default is set to draw a 3D hemisphere.  Choose from the following options:\n            0 = 3D hemisphere\n            1 = Orthographic (straight projection to the XY Plane)\n            2 = Stereographic (equi-angular projection to the XY Plane)\n        domeOrLily: Set to \"True\" to have the component create a radiation dome and set to \"False\" to have it generate a Lily.  The default is set to \"True\" for a Dome.\n            _\n            The difference between the Dome and the Lily is that, for the Lily, the Z scale is essentially the same as the color scale, which is redundant but also beautiful and potentially useful if you have to present data with a Black/White printer or to someone who is color blind.\n            _\n            For the Dome, the vertical angles of rotation serve to define the Z scale.  In this sense, the normal to the dome at any given point is the angle at which the radiation study is being run.  This gives a geometric intuitive sense of how you should orient panels to capture or avoid the most sun.\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        _runIt: Set to \"True\" to run the component and generate a radiation Calla Dome.\n    Returns:\n        readMe!: ...\n        radiationMesh: A colored mesh representing radiation of the Calla Dome.\n        baseCrvs: A set of guide curves for the Calla Dome.\n        legend: A legend of the radiation on the Calla Dome. Connect this output to a grasshopper \"Geo\" component in order to preview the legend in the Rhino scene.  \n        testPts: The vertices of the Calla Dome mesh.  These are hidden by default.\n        testPtsInfo: Information for each test point of the Calla Dome mesh.  \"HRA\" stands for \"Horizontal Rotation Angle\" while \"VRA\" stand for \"Vertical Rotation Angle.\"  HRA varies from 0 to 360 while VRA varies from 0 to 90.\n        values: The radiation values for each test points (or mesh faces) of the Calla Doem in kWh/m2.\n        maxRadPt: The point on the Cala Lilly with the greatest amount of solar radiation.  This is useful for understanding the best direction to orient solar panels.\n        maxRadVector: The vector that should be used to orient solar panels such that they recieve the greatest possible solar radiation.\n        maxRadInfo: Information about the test point with the greates amount of radiation in the Calla Dome.  \"HRA\" stands for \"Horizontal Rotation Angle\" while \"VRA\" stand for \"Vertical Rotation Angle.\"  HRA varies from 0 to 360 while VRA varies from 0 to 90.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Radiation Calla Dome\"\nghenv.Component.NickName = 'radiationCallaDome'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nJAN_29_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\nimport System\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport Rhino as rc\nimport math\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\n\n\n\ndef createSkyDomeMesh(basePoint, resolution, scale):\n    #Create a list of altitudes and azimuths based on the resolution.\n    altitudes = []\n    azimuths = []\n    \n    altitudes.append(0)\n    for num in range(resolution):\n        altitudes.append((90/resolution) + num*(90/resolution))\n    \n    azimuths.append(0)\n    for num in range(4*resolution-1):\n        azimuths.append((360/(4*resolution)) + num*(360/(4*resolution)))\n    \n    #Create the vertices of the mesh.\n    meshPts = []\n    startPt = rc.Geometry.Point3d(0, scale*10, 0)\n    for alt in altitudes:\n        for az in azimuths:\n            newPt = rc.Geometry.Point3d(startPt)\n            altRotate = rc.Geometry.Transform.Rotation(math.radians(alt), rc.Geometry.Vector3d.XAxis, rc.Geometry.Point3d.Origin)\n            azRotate = rc.Geometry.Transform.Rotation(-math.radians(az), rc.Geometry.Vector3d.ZAxis, rc.Geometry.Point3d.Origin)\n            newPt.Transform(altRotate)\n            newPt.Transform(azRotate)\n            meshPts.append(newPt)\n    \n    #Create the mesh.\n    uncoloredMesh = rc.Geometry.Mesh()\n    \n    for point in meshPts:\n        uncoloredMesh.Vertices.Add(point)\n    \n    numbersToWatch = range(0, len(meshPts), (resolution*4))\n    for count, point in enumerate(numbersToWatch):\n        numbersToWatch[count] = point -1\n    \n    for pointCount in range(len(meshPts) - (resolution*4)):\n        if pointCount not in numbersToWatch:\n            uncoloredMesh.Faces.AddFace(pointCount, pointCount+1, pointCount+(resolution*4)+1, pointCount+(resolution*4))\n        else:\n            uncoloredMesh.Faces.AddFace(pointCount, pointCount-(resolution*4)+1, pointCount+1, pointCount+(resolution*4))\n    \n    #Move the mesh from the origin to the base point location\n    startPtTransform = rc.Geometry.Transform.Translation(basePoint.X, basePoint.Y, basePoint.Z)\n    uncoloredMesh.Transform(startPtTransform)\n    \n    #Color the mesh with monotone colors.\n    uncoloredMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n    \n    uncoloredMesh.Flip(True, True, True)\n    \n    return uncoloredMesh\n\n\n\n\ndef main(genCumSkyResult, horAngleStep, verAngleStep, horScale,\n         projection, north, centerPoint, legendPar, bakeIt, domeOrLily=True):\n    \n    # import the classes\n    if sc.sticky.has_key('ladybug_release'):\n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        TregenzaPatchesNormalVectors = lb_preparation.TregenzaPatchesNormalVectors\n        conversionFac = lb_preparation.checkUnits()\n        \n        # check the input data\n        warn = \"Please provide a valid selctedSkyMtx!\"\n        try:\n            if genCumSkyResult[2][:11] == 'Sky Patches':\n                checkData = True\n            else:\n                checkData = False\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warn)\n                print warn\n                return -1\n        except Exception, e:\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warn)\n            checkData = False\n            print warn\n            return -1\n            \n        \n        if checkData:\n            # separate the data\n            indexList, listInfo = lb_preparation.separateList(genCumSkyResult, lb_preparation.strToBeFound)\n            selList = []\n            [selList.append(float(x)) for x in genCumSkyResult[indexList[0]+7:indexList[1]]]\n            genCumSkyResult = selList\n            \n            if indexList[-1] == 456:\n                patchesNormalVectors = lb_preparation.TregenzaPatchesNormalVectors\n            elif indexList[-1] == 1752:\n                patchesNormalVectors = lb_preparation.getReinhartPatchesNormalVectors()\n            \n            \n            # check the scale\n            try:\n                if float(horScale)!=0:\n                    try: horScale = float(horScale)/conversionFac\n                    except: horScale = 1/conversionFac\n                else:\n                    horScale = 1/conversionFac\n            except:\n                horScale = 1/conversionFac\n\n            horScale = horScale * .2\n            \n            verScale = horScale / 2\n\n            cenPt = lb_preparation.getCenPt(centerPoint)\n            \n            horAngleStep = horAngleStep or 1\n            \n            if horAngleStep > 90:\n                horAngleStep = 90\n            elif horAngleStep < 1:\n                horAngleStep = 1\n\n            if verAngleStep > 90:\n                verAngleStep = 90\n            elif verAngleStep < 1:\n                verAngleStep = 1\n\n            # find the range of angles \n            roseHAngles = rs.frange(0, 360, horAngleStep)\n            roseVAngles = rs.frange(0, 90, verAngleStep)\n            \n            if round(roseHAngles[-1]) == 360:\n                roseHAngles.remove(roseHAngles[-1])\n            if round(roseVAngles[-1]) > 90:\n                roseVAngles.remove(roseVAngles[-1])\n            elif round(roseVAngles[-1]) < 90:\n                roseVAngles.append(90)\n            \n            hRotationVectors = [];\n            northAngle, northVector = lb_preparation.angle2north(north)\n            eastVector = rc.Geometry.Vector3d(northVector)\n            eastVector.Rotate(math.radians(-90), rc.Geometry.Vector3d.ZAxis)\n            # print eastVector\n            \n            def radiationForVector(vec, genCumSkyResult, TregenzaPatchesNormalVectors = lb_preparation.TregenzaPatchesNormalVectors):\n                radiation = 0; patchNum = 0;\n                for patchNum, patchVec in enumerate(TregenzaPatchesNormalVectors):\n                    vecAngle = rs.VectorAngle(patchVec, vec)\n                    if  vecAngle < 90:\n                        radiation = radiation + genCumSkyResult[patchNum] * math.cos(math.radians(vecAngle))\n                return radiation\n            \n            pts = []\n            ptsClean = [] # clean points doesn't have the first point of the loop at the end\n            testPtsInfos = []\n            testPtsVectors = []\n            resultsFlatten = []\n            radResult = []\n            [pts.append([]) for a in range(len(roseVAngles))]\n            [radResult.append([]) for a in range(len(roseVAngles))]\n            \n            totAngleCount = len(roseVAngles)\n            radius = 100 * totAngleCount * horScale\n         \n            for angleCount, angle in enumerate(roseVAngles):\n                vectorVRotated = rc.Geometry.Vector3d(northVector)\n                \n                # rotate vertically\n                vectorVRotated.Rotate(math.radians(angle), eastVector)\n                \n                for hAngle in roseHAngles:\n                    hVector = rc.Geometry.Vector3d(vectorVRotated)\n                    hVector.Rotate(-math.radians(hAngle), rc.Geometry.Vector3d.ZAxis)\n                    \n                    # calculate radiation for each vector\n                    radiation = radiationForVector(hVector, genCumSkyResult, patchesNormalVectors)\n                    radResult[angleCount].append(radiation)\n                    resultsFlatten.append(radiation)\n                    \n                    # create the horizontal moving vector\n                    movingVector = rc.Geometry.Vector3d(northVector)\n                    movingVector.Rotate(-math.radians(hAngle), rc.Geometry.Vector3d.ZAxis)\n                    movingVector = 100 * (angleCount + 1) * horScale * movingVector\n                    \n                    #Check the dome or the mesh and see what should be done with the z-scale\n                    if domeOrLily == True or domeOrLily == None:\n                        #User has requested a dome.\n                        vertVector = rc.Geometry.Vector3d(vectorVRotated.X, vectorVRotated.Y, vectorVRotated.Z)\n                        vertVector = rc.Geometry.Vector3d.Multiply(vertVector, 100 * totAngleCount * horScale)\n                        pt = rc.Geometry.Point3d.Add(cenPt, vertVector)\n                        pointRotation = rc.Geometry.Transform.Rotation(northVector, movingVector, cenPt)\n                        pt.Transform(pointRotation)\n                        if projection == 1 or projection == 2:\n                            pt = lb_visualization.projectGeo([pt], projection, cenPt, radius)[0]\n                        pts[angleCount].append(pt)\n                        ptsClean.append(pt)\n                    else:\n                        #User has requested a lilly\n                        pt = rc.Geometry.Point3d.Add(cenPt, movingVector)\n                        verticalMove = radiation * verScale * rc.Geometry.Vector3d.ZAxis\n                        pt = rc.Geometry.Point3d.Add(pt, verticalMove)\n                        pts[angleCount].append(pt)\n                        ptsClean.append(pt)\n                    \n                    testPtsInfo = \"%.2f\"%radiation + ' ' + listInfo[0][3] + '\\nHRA='+ `hAngle` + '; VRA=' + `angle`\n                    testPtsInfos.append(testPtsInfo)\n                    testPtsVectors.append(hVector)\n                    \n                radResult[angleCount].append(radResult[angleCount][0])\n                # resultsFlatten.append(radResult[angleCount][0])\n                pts[angleCount].append(pts[angleCount][0])\n            \n            overwriteScale = False\n            if legendPar == []: overwriteScale = True\n            elif legendPar[-1] == None: overwriteScale = True\n            \n            # generate the colors\n            lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n            \n            if overwriteScale: legendScale = 0.85\n            \n            \n            values = []\n            # generate the mesh\n            vaseMesh = rc.Geometry.Mesh()\n            for vStep in range(len(roseVAngles)):\n                \n                if vStep!=0:\n                    for ptCount, pt in enumerate(pts[vStep]):\n                        try:\n                            singleMesh = rc.Geometry.Mesh()\n                            pt1 = pts[vStep-1][ptCount]\n                            value1 = radResult[vStep-1][ptCount-1]\n                            pt2 = pts[vStep][ptCount]\n                            value2 = radResult[vStep][ptCount-1]\n                            pt3 = pts[vStep-1][ptCount + 1]\n                            value3 = radResult[vStep][ptCount]\n                            pt4 = pts[vStep][ptCount + 1]\n                            value4 = radResult[vStep-1][ptCount]\n                            singleMesh.Vertices.Add(pt1)\n                            singleMesh.Vertices.Add(pt2)\n                            singleMesh.Vertices.Add(pt3)\n                            singleMesh.Vertices.Add(pt4)\n                            singleMesh.Faces.AddFace(0, 1, 3, 2)\n                            values.append([value1, value2, value4, value3])\n                            vaseMesh.Append(singleMesh)\n                        except:\n                            pass\n            \n            values = lb_preparation.flattenList(values)\n            # color the mesh\n            meshColors = lb_visualization.gradientColor(values, lowB, highB, customColors)\n            \n            # make a monotonemesh\n            vaseMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.White)\n            \n            #color the mesh based on the results\n            for vertices in range (vaseMesh.Vertices.Count):\n                vaseMesh.VertexColors[vertices] = meshColors[vertices]\n            \n            #Flip the mesh so that it always appears correctly in Rhino Display.\n            if domeOrLily == False:\n                vaseMesh.Flip(True, True, True)\n            \n            maxHorRadius = 100 * (angleCount + 1) * horScale\n            tempCompassCrv = rc.Geometry.Circle(cenPt, 1.1*maxHorRadius).ToNurbsCurve()\n            lb_visualization.calculateBB([vaseMesh, tempCompassCrv], True)\n            \n            # get the legend done\n            legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(resultsFlatten\n                    , lowB, highB, numSeg, listInfo[0][3], lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n            \n            # generate legend colors\n            legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n            \n            # color legend surfaces\n            legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n            \n            # title\n            customHeading = '\\n\\nRadiation Calla Dome (' + listInfo[0][3] + ')'\n            titleTextCurve, titleStr, titlebasePt = lb_visualization.createTitle(listInfo, lb_visualization.BoundingBoxPar, legendScale, customHeading, False, legendFont, legendFontSize, legendBold)\n            \n            if domeOrLily == False:\n                cenPtMoved = rc.Geometry.Point3d.Add(cenPt, 0.9*lb_visualization.BoundingBoxPar[3]*rc.Geometry.Vector3d.ZAxis)\n            else:\n                cenPtMoved = cenPt\n            compassCrvs, compassTextPts, compassText = \\\n                lb_visualization. compassCircle(\n                    cenPtMoved, northVector, maxHorRadius,\n                    roseHAngles, 1.2*textSize)\n\n            numberCrvs = lb_visualization.text2srf(compassText, compassTextPts, 'Times New Romans', textSize/1.2)\n            compassCrvs = compassCrvs + lb_preparation.flattenList(numberCrvs)\n            angleCrvs = []\n            if (projection == 1 or projection == 2) and domeOrLily != False:\n                angleCrvs, angleTextPt, angleText = lb_visualization.angleCircle(cenPt, northVector, radius, projection, sc.doc.ModelAbsoluteTolerance*3)\n                altitutdeMeshText = lb_visualization.text2srf(angleText, angleTextPt, 'Verdana', textSize/2, legendBold)\n                altitutdeMeshText = lb_preparation.flattenList(altitutdeMeshText)\n                angleCrvs.extend(altitutdeMeshText)\n            \n            # bake\n            if bakeIt > 0:\n                #Put all of the curves together.\n                finalCrvs = []\n                for crv in compassCrvs:\n                    try:\n                        testPt = crv.PointAtEnd\n                        finalCrvs.append(crv)\n                    except: pass\n                for crv in angleCrvs:\n                    try:\n                        testPt = crv.PointAtEnd\n                        finalCrvs.append(crv)\n                    except: pass\n                \n                #Put all of the text together.\n                legendText.append(titleStr)\n                textPt.append(titlebasePt)\n                legendText.extend(compassText)\n                textPt.extend(compassTextPts)\n                if (projection == 1 or projection == 2) and domeOrLily != False:\n                    legendText.extend(angleText)\n                    textPt.extend(angleTextPt)\n                # check the study type\n                placeName = listInfo[0][1]\n                studyLayerName = 'RADIATION_DOME'\n                stMonth, stDay, stHour, endMonth, endDay, endHour = lb_visualization.readRunPeriod((listInfo[0][5], listInfo[0][6]), False)\n                period = `stDay`+ ' ' + lb_visualization.monthList[stMonth-1] + ' ' + `stHour` + \\\n                 \" - \" + `endDay`+ ' ' + lb_visualization.monthList[endMonth-1] + ' ' + `endHour` \n                newLayerIndex, l = lb_visualization.setupLayers(period, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n                \n                if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, vaseMesh, legendSrfs, legendText, textPt, textSize, legendFont, finalCrvs, decimalPlaces, True)\n                else: lb_visualization.bakeObjects(newLayerIndex, vaseMesh, legendSrfs, legendText, textPt, textSize, legendFont, finalCrvs, decimalPlaces, False)\n            \n            #Find the max value and vector.\n            maxValue = max(resultsFlatten)\n            i = resultsFlatten.IndexOf(maxValue)\n            maxRadPt = ptsClean[i]\n            maxRadInfo = testPtsInfos[i]\n            maxPtVec = testPtsVectors[i]\n            \n        return ptsClean, vaseMesh, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], resultsFlatten, testPtsInfos, compassCrvs, angleCrvs, maxRadPt, maxRadInfo, maxPtVec\n        \n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return -1\n\nif _runIt:\n    north_ = 0\n    result = main(_selectedSkyMtx, _horAngleStep_, _verAngleStep_, _scale_,\n                  _projection_, north_, _centerPoint_, legendPar_, bakeIt_)\n    maxPtAndValue = []\n    if result!= -1:\n       radiationMesh = result[1]       \n       testPts = result [0]\n       legend = [result [2][0]] + result[2][1]\n       values = result[3]\n       testPtsInfo = result[4]\n       baseCrvs = result[5]\n       altitudeCrvs = result[6]\n       \n       maxRadPt = result[7]\n       maxRadInfo = result[8]\n       maxRadVector = result[9]\n    ghenv.Component.Params.Output[5].Hidden = True\nelse:\n    print \"Set runIt to True!\"\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}