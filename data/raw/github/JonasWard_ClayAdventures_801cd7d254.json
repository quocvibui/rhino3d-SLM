{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/archive/clay_bricks/PatternBrickLibrary/polyline.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/archive/clay_bricks/PatternBrickLibrary/polyline.py",
  "instruction": "Polyline",
  "code": "import Rhino.Geometry as rg\n\nclass Vertex:\n    \n    def __init__(self, pt, normal = None):\n        \n        self.loc = pt\n        self.o = pt\n        \n        if normal == None:\n            \n            self.n = rg.Point3d(1,0,0)\n\n        else:\n\n            self.n = normal\n            \n        self.special = False\n            \n    def offset(self, val):\n        \n        self.loc += self.n * val\n    \n    @property\n    def X(self):\n        \n        return self.loc.X\n        \n    @property\n    def Y(self):\n        \n        return self.loc.Y\n        \n    @property\n    def Z(self):\n        \n        return self.loc.Z\n        \n    def addVertex(self, other):\n        \n        self.loc += other.loc\n        self.n = (self.n + other.n) * .5\n        \n    def addPoint(self, other):\n        \n        self.loc += other\n\n    def add(self, other):\n        if isinstance(other, Vertex):\n            # print(\"adding Vertex\")\n            new_loc = self.loc + other.loc\n\n        elif isinstance(other, rg.Point3d):\n            # print(\"adding Point3d\")\n            new_loc = other + self.loc\n        \n        elif isinstance(other, int) or isinstance(other, float):\n            # print(\"adding Number\")\n            new_loc = self.loc + self.n * other\n        \n        return Vertex(new_loc, self.n)\n\n    def __add__(self, other):\n        return self.add(other)\n\nclass StructuredPolyline:\n    \n    def __init__(self, pts, closed = True):\n\n        if not(any(pts) ):\n            print(\"you have given me an empty point list\")\n        elif isinstance(pts[0], rg.Point3d):\n            # print(\"have been given points\")\n            self.ini_pt_set = pts\n            self._makeVertexSet()\n        elif isinstance(pts[0], Vertex):\n            # print(\"have been given vetexes\")\n            self.v_set = pts\n        \n        self.c = closed\n        \n    def _makeVertexSet(self):\n\n        self.v_set = None\n        tmp_v_set = []\n        \n        for i in range(self.count):\n\n            tmp_v_set.append(Vertex(\n                pt = self.pts(i),\n                normal = self.getNormal(i)\n            ))\n\n        self.v_set = tmp_v_set\n\n    def add_copy(self, mv_vs=None, z_shift=0.0):\n        mv_pt = rg.Point3d(0,0,z_shift)\n        loc_vs = [v.add(mv_pt) for v in self.v_set]\n        if not(mv_vs == None):\n            loc_vs = [v.add(mv_vs[i%len(mv_vs)]) for i, v in enumerate(loc_vs)]\n\n        return StructuredPolyline(loc_vs)\n            \n    def indexNorm(self, index):\n        \n        return index % self.count\n\n    def pts(self, index):\n        \n        i = self.indexNorm(index)\n        \n        if self.v_set == None:\n            \n            return self.ini_pt_set[i]\n        \n        else:\n            \n            return self.v_set[i].loc\n\n    def pointSet(self):\n\n        return [v.loc for v in self.v_set]\n\n    def interpolatedPoint(self, index):\n\n        i = int(index)\n        t_val = index - i\n\n        j = i + 1\n\n        pt_0 = self.pts(i)\n        pt_1 = self.pts(j)\n\n        new_vertex = Vertex(\n            pt_0 + (pt_1 - pt_0) * t_val,\n            self.getNormal(index)\n        )\n\n        return new_vertex\n\n    def addPoint(self, index):\n\n        v_set_a = self.v_set[:]\n\n    @property\n    def count(self):\n        \n        if self.v_set == None:\n            \n            return len(self.ini_pt_set)\n        \n        else:\n            \n            return len(self.v_set)\n            \n    def getDir(self, index):\n        \n        i = self.indexNorm(index)\n        \n        if i == self.count - 1:\n            \n            dir_vec = self.pts(-1) - self.pts(-2)\n\n        else:\n\n            dir_vec = self.pts(i + 1) - self.pts(i)\n            \n        size = (dir_vec.X ** 2 + dir_vec.Y ** 2) ** .5\n            \n        return dir_vec / size\n    \n    def getNormal(self, index):\n        \n        i = self.indexNorm(index)\n\n        if (int(i) == i):\n            # case you get a corner point\n        \n            if i == 0 or i == self.count - 1:\n                \n                dir_vec = self.getDir(i)\n                \n            else:\n\n                dir_vec_a = self.getDir(i - 1)\n                dir_vec_b = self.getDir(i)\n                \n                dir_vec = (dir_vec_a + dir_vec_b) * .5\n\n        else:\n            # case you get point on a line segment\n\n            dir_vec = self.getDir(int(i))\n\n        normal = rg.Point3d(\n            dir_vec.Y,\n            -dir_vec.X,\n            0\n        )\n\n        return normal\n\n    def offset(self, distance):\n\n        if self.v_set == None:\n\n            self._makeVertexSet()\n\n        for v in self.v_set:\n\n            v.offset(distance)\n\n    def toPolyline(self):\n\n        pt_set = []\n\n        for i in range(self.count):\n\n            pt_set.append(self.pts(i))\n\n        if self.c:\n\n            pt_set += [pt_set[0]]\n\n        return rg.Polyline(pt_set).ToPolylineCurve()\n\n\n            \n    \n    ",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}