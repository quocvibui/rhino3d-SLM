{
  "source_url": "https://github.com/StudioClue/Random_Paving_Generator/blob/215a114566e8a0c4449f222f6b84f19c2659f07c/Random_Paving_Patterns.py",
  "repo": "StudioClue/Random_Paving_Generator",
  "repo_stars": 0,
  "repo_description": "Generates Random Paving Patterns in Rhino by Python Script",
  "license": "MIT",
  "filepath": "Random_Paving_Patterns.py",
  "instruction": "Smart Panel(Paving Pattern) Generator for Rhino + Python\r\n---------------------------------------------------------\r\nThis script creates vertically stacked panels (tiles) in columns,\r\nusing fixed...",
  "code": "# =============================================================================\r\n# Author       : Studio Clue\r\n# Created Date : 2025-05-20\r\n# Description  : \r\n\"\"\"\r\nSmart Panel(Paving Pattern) Generator for Rhino + Python\r\n---------------------------------------------------------\r\nThis script creates vertically stacked panels (tiles) in columns,\r\nusing fixed height groups and random placement logic. Each panel\r\nis assigned to a layer based on its height, with randomized colors\r\nfor visual organization.\r\n\r\nThe top of all columns is aligned by intelligently filling the gaps\r\nwith existing panel sizes when possible, and generating custom panels\r\nonly when needed.\r\n\r\nGreat for learning procedural geometry, layer management, and RhinoScriptSyntax.\r\n\"\"\"\r\n# =============================================================================\r\n\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as geo\r\nimport random\r\n\r\ndef pavPattern(xNum, yNum):\r\n    srfs = []\r\n    y_bases = [0.0 for _ in range(xNum)]\r\n    existing_layers = []\r\n\r\n    bucket_size = 0.5\r\n    max_r = 3.0\r\n    num_buckets = int((max_r - 0.5) / bucket_size) + 1\r\n\r\n    # Predefine exact heights for each bucket index\r\n    bucket_heights = {i + 1: 0.5 + i * bucket_size for i in range(num_buckets)}\r\n    height_values = sorted(bucket_heights.values(), reverse=True)  # For largest-to-smallest matching\r\n\r\n    # Step 1: Generate regular tiles\r\n    for n in range(yNum):\r\n        for i in range(xNum):\r\n            bucket_index = random.randint(1, num_buckets)\r\n            r = bucket_heights[bucket_index]\r\n\r\n            layer_name = \"Height_Group_\" + str(bucket_index)\r\n\r\n            if not rs.IsLayer(layer_name):\r\n                rs.AddLayer(layer_name)\r\n                r_color = random.randint(0, 255)\r\n                g_color = random.randint(0, 255)\r\n                b_color = random.randint(0, 255)\r\n                rs.LayerColor(layer_name, (r_color, g_color, b_color))\r\n                existing_layers.append(layer_name)\r\n            elif layer_name not in existing_layers:\r\n                existing_layers.append(layer_name)\r\n\r\n            y0 = y_bases[i]\r\n            y1 = y0 + r\r\n\r\n            x_vals = [i - 0.5, i - 0.5, i + 0.5, i + 0.5]\r\n            y_vals = [y1, y0, y0, y1]\r\n            pts = [geo.Point3d(x_vals[j], y_vals[j], 0) for j in range(4)]\r\n\r\n            srf = rs.AddSrfPt([rs.coerce3dpoint(p) for p in pts])\r\n            if srf:\r\n                rs.ObjectLayer(srf, layer_name)\r\n\r\n            y_bases[i] = y1\r\n            srfs.append(srf)\r\n\r\n    # Step 2: Fill top gap per column with smart + randomized logic\r\n    max_height = max(y_bases)\r\n\r\n    for i in range(xNum):\r\n        current_y = y_bases[i]\r\n        gap = max_height - current_y\r\n\r\n        while gap > 0.001:\r\n            # Find all valid panel sizes that can fit the current gap\r\n            valid_fits = [(index, h) for index, h in bucket_heights.items() if h <= gap + 1e-6]\r\n\r\n            if valid_fits:\r\n                bucket_index, h = random.choice(valid_fits)\r\n\r\n                # Check if this is the last tile that completes the column\r\n                is_last_tile = abs(gap - h) < 1e-6\r\n\r\n                y0 = current_y\r\n                y1 = y0 + h\r\n                x_vals = [i - 0.5, i - 0.5, i + 0.5, i + 0.5]\r\n                y_vals = [y1, y0, y0, y1]\r\n                pts = [geo.Point3d(x_vals[j], y_vals[j], 0) for j in range(4)]\r\n\r\n                srf = rs.AddSrfPt([rs.coerce3dpoint(p) for p in pts])\r\n                if srf:\r\n                    if is_last_tile:\r\n                        # Override the layer with a random one for variation\r\n                        layer_name = random.choice(existing_layers)\r\n                    else:\r\n                        layer_name = \"Height_Group_\" + str(bucket_index)\r\n\r\n                    rs.ObjectLayer(srf, layer_name)\r\n                    srfs.append(srf)\r\n\r\n                current_y = y1\r\n                gap = max_height - current_y\r\n            else:\r\n                # Fallback case for tiny unmatched remainder\r\n                h = gap\r\n                y0 = current_y\r\n                y1 = y0 + h\r\n                layer_name = random.choice(existing_layers)\r\n                x_vals = [i - 0.5, i - 0.5, i + 0.5, i + 0.5]\r\n                y_vals = [y1, y0, y0, y1]\r\n                pts = [geo.Point3d(x_vals[j], y_vals[j], 0) for j in range(4)]\r\n                srf = rs.AddSrfPt([rs.coerce3dpoint(p) for p in pts])\r\n                if srf:\r\n                    rs.ObjectLayer(srf, layer_name)\r\n                    srfs.append(srf)\r\n                break\r\n\r\n        # If a tiny remainder is left, fill it with a random custom panel\r\n        if gap >= 0.001:\r\n            y0 = current_y\r\n            y1 = y0 + gap\r\n            filler_layer = random.choice(existing_layers)\r\n            x_vals = [i - 0.5, i - 0.5, i + 0.5, i + 0.5]\r\n            y_vals = [y1, y0, y0, y1]\r\n            pts = [geo.Point3d(x_vals[j], y_vals[j], 0) for j in range(4)]\r\n            srf = rs.AddSrfPt([rs.coerce3dpoint(p) for p in pts])\r\n            if srf:\r\n                rs.ObjectLayer(srf, filler_layer)\r\n                srfs.append(srf)\r\n\r\n    return srfs\r\n\r\n# Run the tile generator\r\npavPattern(10, 30)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}