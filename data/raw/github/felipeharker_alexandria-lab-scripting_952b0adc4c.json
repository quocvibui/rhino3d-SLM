{
  "source_url": "https://github.com/felipeharker/alexandria-lab-scripting/blob/1771434a741c840da1d8ab008876e4866d6fecf3/alexandria-scripts/ghpython/obstacle_shatter_length.py",
  "repo": "felipeharker/alexandria-lab-scripting",
  "repo_stars": 0,
  "repo_description": "python, c#, etc. script library for Alexandria Labs",
  "license": "unknown",
  "filepath": "alexandria-scripts/ghpython/obstacle_shatter_length.py",
  "instruction": "Adaptive shatter for multiple curves, avoiding obstacle regions.",
  "code": "# ALEXANDRIA IO SPEC (standardized)\n# Inputs:\n# - CenterCurves (GH: C) | list[Rhino.Geometry.Curve] | Center curves to shatter\n# - ObstacleCurves (GH: Obs) | list[Rhino.Geometry.Curve] | Obstacle boundaries\n# - MinSpacing (GH: dMin) | float | Minimum shatter spacing\n# - MaxSpacing (GH: dMax) | float | Maximum shatter spacing\n# - ObstacleTolerance (GH: ObsTol) | float | Centroid exclusion tolerance\n# - Step (GH: Step) | float | Arc-length shift step\n# - EdgeFactor (GH: EdgeFactor) | float | Cleanup merge factor\n# Outputs:\n# - SafeSegments (GH: CrvSeg) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Safe shattered segments\n# - CollidingSegments (GH: CrvColl) | Grasshopper.DataTree[Rhino.Geometry.Curve] | Colliding segments\n\n\"\"\"Adaptive shatter for multiple curves, avoiding obstacle regions.\n\nInputs:\n    C          : list of center curves to shatter (Rhino.Geometry.Curve)\n    Obs        : list of obstacle curves (rectangles/slots, closed & coplanar)\n    dMin       : minimum distance between shatter points (arc length)\n    dMax       : maximum distance between shatter points (arc length)\n    ObsTol     : minimum tolerance between the center (area centroid) of the Obs and a shatter point\n    Step       : arc-length step for testing +/- away from a forbidden point\n    EdgeFactor : cleanup factor in [0, 1]; segments shorter than\n                 EdgeFactor * dMin will try to merge with a neighbor.\n                 CLEANUP IGNORES dMax, so some segments may end up > dMax.\n\nOutputs:\n    CrvSeg  : DataTree of safe shattered segments (one branch per curve)\n    CrvColl : DataTree of colliding segments (one branch per curve)\n\"\"\"\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# --------------------------------------------------------\n# Per-curve logic (single-curve shatter)\n# --------------------------------------------------------\n\ndef process_curve(curve, Obs, dMin, dMax, ObsTol, Step, EdgeFactor, tol):\n    \"\"\"Return (safe_segments, colliding_segments) for a single curve.\"\"\"\n    CrvSeg  = []\n    CrvColl = []\n\n    if curve is None or not curve.IsValid:\n        return CrvSeg, CrvColl\n\n    length = curve.GetLength()\n    if length <= 0:\n        return CrvSeg, CrvColl\n\n    # Reference plane for Contains\n    success, plane = curve.TryGetPlane()\n    if not success:\n        plane = rg.Plane.WorldXY\n\n    # Obstacle centroids (for ObsTol keep-out radius)\n    centroids = []\n    if ObsTol > 0 and Obs:\n        for ob in Obs:\n            if ob is None:\n                continue\n            amp = rg.AreaMassProperties.Compute(ob)\n            if amp:\n                centroids.append(amp.Centroid)\n\n    # Normalize dMin / dMax\n    if dMin < 0: dMin = 0.0\n    if dMax < 0: dMax = 0.0\n    if dMax > 0 and dMin > dMax:\n        dMin, dMax = dMax, dMin\n\n    # Clamp EdgeFactor to [0, 1]\n    if EdgeFactor is None:\n        EdgeFactor = 0.5\n    try:\n        ef = float(EdgeFactor)\n    except:\n        ef = 0.5\n    if ef < 0.0: ef = 0.0\n    if ef > 1.0: ef = 1.0\n\n    # Target spacing\n    if dMin > 0 and dMax > 0:\n        target = 0.5 * (dMin + dMax)   # avg of dMin/dMax\n    elif dMin > 0:\n        target = dMin\n    elif dMax > 0:\n        target = dMax\n    else:\n        target = length / 20.0         # fallback\n\n    # Step in arc-length units\n    step = abs(Step)\n    if step <= 0:\n        step = target * 0.1\n\n    dom = curve.Domain\n    t_start = dom.T0\n    t_end   = dom.T1\n\n    ts = [t_start]\n    s_last = 0.0\n    max_iter = 10000\n    iter_count = 0\n\n    # ----- inline helpers, bound to this curve/plane/centroids -----\n\n    def point_forbidden(pt):\n        \"\"\"True if pt is inside any obstacle OR within ObsTol of any centroid.\"\"\"\n        if Obs:\n            for ob in Obs:\n                if ob is None:\n                    continue\n                pc = ob.Contains(pt, plane, tol)\n                if pc == rg.PointContainment.Inside or pc == rg.PointContainment.Coincident:\n                    return True\n        if ObsTol > 0 and centroids:\n            for c in centroids:\n                if pt.DistanceTo(c) <= ObsTol:\n                    return True\n        return False\n\n    def endpoint_collides(pt):\n        \"\"\"True if endpoint lies inside any obstacle region.\"\"\"\n        if not Obs:\n            return False\n        for ob in Obs:\n            if ob is None:\n                continue\n            pc = ob.Contains(pt, plane, tol)\n            if pc == rg.PointContainment.Inside or pc == rg.PointContainment.Coincident:\n                return True\n        return False\n\n    # ----- place shatter points along this curve (dMax-priority stepping) -----\n\n    while True:\n        iter_count += 1\n        if iter_count > max_iter:\n            break\n\n        remaining = length - s_last\n\n        # dMax priority for stepping:\n        if dMax > 0 and remaining <= dMax + tol:\n            break\n\n        # If no dMax given, fall back to dMin-based stopping\n        if dMax <= 0 and dMin > 0 and remaining <= dMin + tol:\n            break\n\n        # Window [s_min, s_max] for next shatter (arc length)\n        if dMin > 0:\n            s_min = s_last + dMin\n        else:\n            s_min = s_last + tol\n\n        if dMax > 0:\n            s_max = s_last + dMax\n        else:\n            s_max = s_last + remaining\n\n        if s_min >= length - tol:\n            break\n        if s_max > length:\n            s_max = length\n\n        # Initial target position\n        s_target = s_last + target\n        if s_target < s_min:\n            s_target = s_min\n        if s_target > s_max:\n            s_target = s_max\n\n        window = s_max - s_min\n        if window <= tol:\n            # Degenerate window: force a cut at s_max (still honors dMax in stepping)\n            rc, t_force = curve.LengthParameter(s_max)\n            if rc:\n                ts.append(t_force)\n                s_last = s_max\n            break\n\n        found = False\n        max_steps = int(window / step) + 2\n\n        for k in range(max_steps):\n            # Test s_target first, then ± k*step\n            if k == 0:\n                candidates = [s_target]\n            else:\n                candidates = [s_target + k*step, s_target - k*step]\n\n            for s_candidate in candidates:\n                if s_candidate < s_min - tol or s_candidate > s_max + tol:\n                    continue\n\n                rc, t_candidate = curve.LengthParameter(s_candidate)\n                if not rc:\n                    continue\n\n                pt = curve.PointAt(t_candidate)\n                if not point_forbidden(pt):\n                    ts.append(t_candidate)\n                    s_last = s_candidate\n                    found = True\n                    break\n\n            if found:\n                break\n\n        if not found:\n            # No safe point found in [dMin, dMax] → force a cut at s_max.\n            rc, t_force = curve.LengthParameter(s_max)\n            if not rc:\n                break\n            ts.append(t_force)\n            s_last = s_max\n            # continue to next segment\n\n    # Always include curve end\n    if abs(ts[-1] - t_end) > tol:\n        ts.append(t_end)\n\n    # Clean near-duplicate parameters\n    ts = sorted(ts)\n    clean_ts = [ts[0]]\n    for t in ts[1:]:\n        if abs(t - clean_ts[-1]) > tol:\n            clean_ts.append(t)\n    ts = clean_ts\n\n    # ----------------------------------------------------------\n    # GLOBAL small-segment cleanup (Soft-dMax):\n    # Try to remove ANY segment shorter than EdgeFactor * dMin\n    # by merging with a neighbor. This cleanup IGNORES dMax, so\n    # merged segments may end up longer than dMax.\n    # ----------------------------------------------------------\n    if dMin > 0 and ef > 0.0 and len(ts) > 2:\n        min_len = ef * dMin\n\n        while True:\n            n_segments = len(ts) - 1\n            if n_segments <= 1:\n                break\n\n            # Find smallest segment below min_len\n            idx_small = -1\n            smallest = None\n            for i in range(n_segments):\n                L_i = curve.GetLength(rg.Interval(ts[i], ts[i + 1]))\n                if L_i < min_len:\n                    if smallest is None or L_i < smallest:\n                        smallest = L_i\n                        idx_small = i\n\n            # No more segments below threshold → done\n            if idx_small == -1:\n                break\n\n            # Decide which neighbor to merge with\n            if idx_small == 0:\n                # Only merge with next (delete ts[1])\n                del ts[1]\n            elif idx_small == n_segments - 1:\n                # Only merge with previous (delete ts[-2])\n                del ts[-2]\n            else:\n                # Can merge left or right. Choose the merge that gives\n                # the shorter combined segment length (purely heuristic).\n                L_prev = curve.GetLength(rg.Interval(ts[idx_small - 1], ts[idx_small + 1]))\n                L_next = curve.GetLength(rg.Interval(ts[idx_small], ts[idx_small + 2]))\n                if L_prev <= L_next:\n                    # Merge with previous: drop ts[idx_small]\n                    del ts[idx_small]\n                else:\n                    # Merge with next: drop ts[idx_small + 1]\n                    del ts[idx_small + 1]\n            # Loop again and re-evaluate smallest\n\n    # ----- shatter & classify segments for this curve -----\n\n    for i in range(len(ts) - 1):\n        t0 = ts[i]\n        t1 = ts[i + 1]\n        if t1 - t0 <= tol:\n            continue\n\n        sub = curve.Trim(rg.Interval(t0, t1))\n        if not sub or not sub.IsValid:\n            continue\n\n        p0 = curve.PointAt(t0)\n        p1 = curve.PointAt(t1)\n\n        if endpoint_collides(p0) or endpoint_collides(p1):\n            CrvColl.append(sub)\n        else:\n            CrvSeg.append(sub)\n\n    return CrvSeg, CrvColl\n\n# --------------------------------------------------------\n# Multi-curve wrapper -> DataTree outputs\n# --------------------------------------------------------\n\nCrvSeg  = DataTree[object]()\nCrvColl = DataTree[object]()\n\ntol = sc.doc.ModelAbsoluteTolerance\n\n# Ensure we always have an iterable for C\nif C is None:\n    curves = []\nelse:\n    try:\n        curves = list(C)\n    except TypeError:\n        curves = [C]\n\nfor i, crv in enumerate(curves):\n    path = GH_Path(i)\n    safe_segments, coll_segments = process_curve(\n        crv, Obs, dMin, dMax, ObsTol, Step, EdgeFactor, tol\n    )\n\n    for seg in safe_segments:\n        CrvSeg.Add(seg, path)\n\n    for col in coll_segments:\n        CrvColl.Add(col, path)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}