{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/brep/brep.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/brep/brep.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs  # type: ignore\n\nimport compas_rhino.objects\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Brep\nfrom compas.geometry import BrepError\nfrom compas.geometry import BrepFilletError\nfrom compas.geometry import BrepTrimmingError\nfrom compas.geometry import Frame\nfrom compas.geometry import Line\nfrom compas.geometry import Plane\nfrom compas.geometry import Point\nfrom compas.geometry import Polyline\nfrom compas.tolerance import TOL\nfrom compas_rhino.conversions import box_to_rhino\nfrom compas_rhino.conversions import cone_to_rhino\nfrom compas_rhino.conversions import curve_to_compas\nfrom compas_rhino.conversions import curve_to_rhino\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import line_to_rhino_curve\nfrom compas_rhino.conversions import mesh_to_compas\nfrom compas_rhino.conversions import mesh_to_rhino\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import polyline_to_rhino_curve\nfrom compas_rhino.conversions import sphere_to_rhino\nfrom compas_rhino.conversions import torus_to_rhino\nfrom compas_rhino.conversions import transformation_to_rhino\nfrom compas_rhino.conversions import vector_to_rhino\nfrom compas_rhino.geometry import RhinoNurbsCurve\nfrom compas_rhino.geometry import RhinoNurbsSurface\n\nfrom .builder import _RhinoBrepBuilder\nfrom .edge import RhinoBrepEdge\nfrom .face import RhinoBrepFace\nfrom .loop import RhinoBrepLoop\nfrom .vertex import RhinoBrepVertex\n\n\ndef _export_brep_to_file(brep, filepath):\n    objects = Rhino.RhinoDoc.ActiveDoc.Objects\n    obj_id = objects.Add(brep)\n    obj = objects.Find(obj_id)\n    obj.Select(True)\n    rs.Command('_-Export \"' + filepath + '\" _Enter', False)\n    objects.Delete(obj_id, True)\n\n\ndef _import_brep_from_file(filepath):\n    # TODO: this only seems to work in ScriptEditor (AKA rhino, not GH)\n    rs.Command('_-Import \"' + filepath + '\" _Enter', False)\n    guid = rs.LastCreatedObjects()[0]  # this fails, could be Rhino bug\n    obj = compas_rhino.objects.find_object(guid)\n    geometry = obj.Geometry.Duplicate()\n    compas_rhino.objects.delete_object(guid)\n    return RhinoBrep.from_native(geometry)\n\n\ndef _join_meshes(meshes):\n    result = Mesh()\n    for mesh in meshes:\n        result.join(mesh)\n    return result\n\n\nclass RhinoBrep(Brep):\n    \"\"\"Rhino Brep backend class.\n\n    Wraps around and allows serialization and de-serialization of a :class:`Rhino.Geometry.Brep`.\n\n    Attributes\n    ----------\n    native_brep : :class:`Rhino.Geometry.Brep`\n        The underlying Rhino Brep instance.\n    vertices : list[:class:`compas_rhino.geometry.RhinoBrepVertex`], read-only\n        The list of vertices which comprise this Brep.\n    points : list[:class:`compas.geometry.Point`], read-only\n        The list of vertex geometries as points in 3D space.\n    edges : list[:class:`compas_rhino.geometry.RhinoBrepEdge`], read-only\n        The list of edges which comprise this brep.\n    trims : list[:class:`compas_rhino.geometry.RhinoBrepTrim`], read-only\n        The list of trims which comprise this brep.\n    loops : list[:class:`compas_rhino.geometry.RhinoBrepLoop`], read-only\n        The list of loops which comprise this brep.\n    faces : list[:class:`compas_rhino.geometry.RhinoBrepFace`], read-only\n        The list of faces which comprise this brep.\n    frame : :class:`compas.geometry.Frame`, read-only\n        The brep's origin (Frame.worldXY()).\n    area : float, read-only\n        The calculated area of this brep.\n    volume : float, read-only\n        The calculated volume of this brep.\n    centroid : :class:`compas.geometry.Point`, read-only\n        The calculated centroid of this brep.\n    curves : list[:class:`compas_rhino.geometry.RhinoNurbsCurve`], read-only\n        The list of curves which comprise this brep.\n    is_closed : bool, read-only\n        True if this brep is closed, False otherwise.\n    is_compound : bool, read-only\n        True if this brep is compound, False otherwise.\n    is_compoundsolid : bool, read-only\n        True if this brep is compound solid, False otherwise.\n    is_convex : bool, read-only\n        True if this brep is convex, False otherwise.\n    is_infinite : bool, read-only\n        True if this brep is infinite, False otherwise.\n    is_orientable : bool, read-only\n        True if this brep is orientable, False otherwise.\n    is_shell : bool, read-only\n        True if this brep is a shell, False otherwise.\n    is_surface : bool, read-only\n        True if this brep is a surface, False otherwise.\n    is_valid : bool, read-only\n        True if this brep is valid, False otherwise.\n    orientation : literal(:class:`~compas.geometry.BrepOrientation`), read-only\n        The orientation of this brep. One of: FORWARD, REVERSED, INTERNAL, EXTERNAL.\n    shells : list[:class:`compas_rhino.geometry.RhinoBrep`], read-only\n        The list of shells which comprise this brep.\n    solids : list[:class:`compas_rhino.geometry.RhinoBrep`], read-only\n        The list of solids which comprise this brep.\n    surfaces : list[:class:`compas_rhino.geometry.RhinoNurbsSurface`], read-only\n        The list of surfaces which comprise this brep.\n\n    \"\"\"\n\n    def __init__(self):\n        super(RhinoBrep, self).__init__()\n        self._brep = Rhino.Geometry.Brep()\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self.copy()\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        return {\n            \"vertices\": [v.__data__ for v in self.vertices],  # type: ignore\n            \"edges\": [e.__data__ for e in self.edges],  # type: ignore\n            \"faces\": [f.__data__ for f in self.faces],  # type: ignore\n        }\n\n    @classmethod\n    def __from_data__(cls, data):\n        \"\"\"Construct a RhinoBrep from its data representation.\n\n        Parameters\n        ----------\n        data : :obj:`dict`\n            The data dictionary.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        instance = cls()\n        builder = _RhinoBrepBuilder()\n        for v_data in data[\"vertices\"]:\n            RhinoBrepVertex.__from_data__(v_data, builder)\n        for e_data in data[\"edges\"]:\n            RhinoBrepEdge.__from_data__(e_data, builder)\n        for f_data in data[\"faces\"]:\n            RhinoBrepFace.__from_data__(f_data, builder)\n        instance.native_brep = builder.result\n        return instance\n\n    def copy(self, cls=None):\n        \"\"\"Creates a deep-copy of this Brep using the native Rhino.Geometry.Brep copying mechanism.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        # Avoid reconstruction when just copying. for sake of efficiency and stability\n        return RhinoBrep.from_native(self._brep.DuplicateBrep())\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def is_manifold(self):\n        return self._brep.IsManifold\n\n    @property\n    def is_solid(self):\n        return self._brep.IsSolid\n\n    @property\n    def native_brep(self):\n        return self._brep\n\n    @native_brep.setter\n    def native_brep(self, rhino_brep):\n        self._brep = rhino_brep\n\n    @property\n    def vertices(self):\n        return self.points\n\n    @property\n    def points(self):\n        if self._brep:\n            return [RhinoBrepVertex(vertex) for vertex in self._brep.Vertices]\n\n    @property\n    def edges(self):\n        if self._brep:\n            return [RhinoBrepEdge(edge) for edge in self._brep.Edges]\n\n    @property\n    def trims(self):\n        if self._brep:\n            return [RhinoBrepEdge(trim) for trim in self._brep.Trims]\n\n    @property\n    def loops(self):\n        if self._brep:\n            return [RhinoBrepLoop(loop) for loop in self._brep.Loops]\n\n    @property\n    def faces(self):\n        if self._brep:\n            return [RhinoBrepFace(face) for face in self._brep.Faces]\n\n    @property\n    def frame(self):\n        return Frame.worldXY()\n\n    @property\n    def area(self):\n        if self._brep:\n            return self._brep.GetArea()\n\n    @property\n    def volume(self):\n        if self._brep:\n            return self._brep.GetVolume()\n\n    @property\n    def centroid(self):\n        assert self._brep\n        centroid = Rhino.Geometry.AreaMassProperties.Compute(self._brep).Centroid\n        return Point(*centroid)\n\n    @property\n    def curves(self):\n        assert self._brep\n        return [RhinoNurbsCurve.from_native(c.ToNurbsCurve()) for c in self._brep.Curves3D]\n\n    @property\n    def is_closed(self):\n        assert self._brep\n        return self._brep.IsSolid\n\n    @property\n    def is_convex(self):\n        raise NotImplementedError(\"Convexity check is not implemented for Rhino Breps.\")\n\n    @property\n    def is_infinite(self):\n        # TODO: what does this exactly mean? couldn't find in the Rhino API\n        raise NotImplementedError\n\n    @property\n    def is_orientable(self):\n        assert self._brep\n        return self._brep.SolidOrientation in (Rhino.Geometry.BrepSolidOrientation.Inward, Rhino.Geometry.BrepSolidOrientation.Outward)\n\n    @property\n    def is_shell(self):\n        # not sure how to get this one\n        raise NotImplementedError\n\n    @property\n    def is_surface(self):\n        assert self._brep\n        return self._brep.IsSurface\n\n    @property\n    def is_valid(self):\n        assert self._brep\n        return self.IsValid\n\n    @property\n    def orientation(self):\n        assert self._brep\n        # TODO: align this with compas.geometry.BrepOrientation\n        return self._brep.SolidOrientation\n\n    @property\n    def surfaces(self):\n        assert self._brep\n        return [[RhinoNurbsSurface.from_native(s.ToNurbsSurface()) for s in self._brep.Surfaces]]\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_boolean_difference(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean difference of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps from which to substract.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps to substract.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanDifference(\n            [b.native_brep for b in breps_a],\n            [b.native_brep for b in breps_b],\n            TOL.absolute,\n        )\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_boolean_union(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean union of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One of more breps to join.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            Another one of more breps to join.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanUnion([b.native_brep for b in breps_a + breps_b], TOL.absolute)\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_boolean_intersection(cls, breps_a, breps_b):\n        \"\"\"Construct a Brep from the boolean intersection of two groups of Breps.\n\n        Parameters\n        ----------\n        breps_a : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            One or more Breps to instrsect.\n        breps_b : :class:`compas_rhino.geometry.RhinoBrep` or list(:class:`compas_rhino.geometry.RhinoBrep`)\n            Another one or more Breps to intersect.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of one or more resulting Breps.\n\n        \"\"\"\n        if not isinstance(breps_a, list):\n            breps_a = [breps_a]\n        if not isinstance(breps_b, list):\n            breps_b = [breps_b]\n        resulting_breps = Rhino.Geometry.Brep.CreateBooleanIntersection(\n            [b.native_brep for b in breps_a],\n            [b.native_brep for b in breps_b],\n            TOL.absolute,\n        )\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_box(cls, box):\n        \"\"\"Create a RhinoBrep from a box.\n\n        Parameters\n        ----------\n        box : :class:`compas.geometry.Box`\n            The box geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_box = box_to_rhino(box)\n        return cls.from_native(rhino_box.ToBrep())\n\n    @classmethod\n    def from_brepfaces(cls, faces):\n        \"\"\"Create a Brep from a list of Brep faces forming an open or closed shell.\n\n        Parameters\n        ----------\n        faces : list[:class:`compas.geometry.BrepFace`]\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        brep = Rhino.Geometry.Brep()\n        for face in faces:\n            brep.Faces.Add(face.native_face.UnderlyingSurface())\n        return cls.from_native(brep)\n\n    @classmethod\n    def from_breps(cls, breps, tolerance=None):\n        \"\"\"Joins the breps at any overlapping edges to form as few as possible resulting breps. There may be more than one brep in the result array.\n\n        Parameters\n        ----------\n        breps : list of :class:`compas.geometry.Brep`\n\n        Returns\n        -------\n        list of :class:`compas.geometry.Brep`\n\n        \"\"\"\n        tolerance = tolerance or TOL\n        rhino_breps = [b.native_brep for b in breps]\n        resulting_breps = Rhino.Geometry.Brep.JoinBreps(rhino_breps, tolerance.absolute, tolerance.angular)\n        return [cls.from_native(brep) for brep in resulting_breps]\n\n    @classmethod\n    def from_cone(cls, cone, cap_bottom=True):\n        \"\"\"Create a RhinoBrep from a cone.\n\n        Parameters\n        ----------\n        cone : :class:`compas.geometry.Cone`\n            The cone geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_cone = cone_to_rhino(cone)\n        return cls.from_native(rhino_cone.ToBrep(cap_bottom))\n\n    @classmethod\n    def from_cylinder(cls, cylinder):\n        \"\"\"Create a RhinoBrep from a box.\n\n        Parameters\n        ----------\n        box : :class:`compas.geometry.Box`\n            The box geometry of the brep.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_cylinder = cylinder_to_rhino(cylinder)\n        return cls.from_native(rhino_cylinder.ToBrep(True, True))\n\n    @classmethod\n    def from_curves(cls, curves, tolerance=None):\n        \"\"\"Create a RhinoBreps from a list of planar face boundary curves.\n\n        Parameters\n        ----------\n        curves : list of :class:`~compas.geometry.Curve` or :class:`~compas.geometry.Polyline`\n            The planar curves that make up the face borders of brep faces.\n\n        Returns\n        -------\n        list of :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if not isinstance(curves, list):\n            curves = [curves]\n        faces = []\n        for curve in curves:\n            if isinstance(curve, Polyline):\n                rhino_curve = polyline_to_rhino_curve(curve)\n            else:\n                rhino_curve = curve_to_rhino(curve)\n            face = Rhino.Geometry.Brep.CreatePlanarBreps(rhino_curve, tolerance)\n            if face is None:\n                raise BrepError(\"Failed to create face from curve: {} \".format(curve))\n            if len(face) > 1:\n                raise BrepError(\"Failed to create single face from curve: {} \".format(curve))\n            faces.append(face[0])\n        rhino_brep = Rhino.Geometry.Brep.JoinBreps(faces, tolerance)\n        if rhino_brep is None:\n            raise BrepError(\"Failed to create Brep from faces: {} \".format(faces))\n        return [cls.from_native(brep) for brep in rhino_brep]\n\n    @classmethod\n    def from_extrusion(cls, curve, vector, cap_ends=True):\n        \"\"\"Create a RhinoBrep from an extrusion.\n\n        Parameters\n        ----------\n        curve : :class:`~compas.geometry.Curve` or :class:`~compas.geometry.Polyline`\n            The curve to extrude.\n        vector : :class:`~compas.geometry.Vector`\n            The vector to extrude the curve along.\n        cap_ends : bool, optional\n            If True, the plannar ends of the extrusion will be capped, if possible.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if isinstance(curve, Polyline):\n            rhino_curve = polyline_to_rhino_curve(curve)\n        else:\n            rhino_curve = curve_to_rhino(curve)\n        extrusion = Rhino.Geometry.Surface.CreateExtrusion(rhino_curve, vector_to_rhino(vector))\n        if extrusion is None:\n            raise BrepError(\"Failed to create extrusion from curve: {} and vector: {}\".format(curve, vector))\n        rhino_brep = extrusion.ToBrep()\n        if cap_ends:\n            capped = rhino_brep.CapPlanarHoles(TOL.absolute)\n            if capped:\n                rhino_brep = capped\n        return cls.from_native(rhino_brep)\n\n    @classmethod\n    def from_iges(cls, filepath):\n        \"\"\"Construct a RhinoBrep from a IGES file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the step file.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if not filepath.endswith(\".igs\"):\n            raise ValueError(\"Expected file with .igs extension\")\n        return _import_brep_from_file(filepath)\n\n    @classmethod\n    def from_loft(cls, curves):\n        \"\"\"Construct a Brep by lofting a set of curves.\n\n        Parameters\n        ----------\n        curves : list[:class:`compas.geometry.Curve`]\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        rhino_curves = [curve_to_rhino(curve) for curve in curves]\n        start = Rhino.Geometry.Point3d.Unset\n        end = Rhino.Geometry.Point3d.Unset\n        loft_type = Rhino.Geometry.LoftType.Normal\n\n        results = Rhino.Geometry.Brep.CreateFromLoft(rhino_curves, start, end, loft_type, closed=False)\n        if not results:\n            raise BrepTrimmingError(\"Loft operation ended with no result\")\n        result = results[0]\n\n        return cls.from_native(result)\n\n    @classmethod\n    def from_mesh(cls, mesh):\n        \"\"\"Create a RhinoBrep from a mesh.\n\n        Parameters\n        ----------\n        mesh : :class:`compas.datastructures.Mesh`\n            The source mesh.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_mesh = mesh_to_rhino(mesh)\n        return cls.from_native(Rhino.Geometry.Brep.CreateFromMesh(rhino_mesh, True))\n\n    @classmethod\n    def from_native(cls, rhino_brep):\n        \"\"\"Constructs a RhinoBrep from an instance of a Rhino.Geometry.Brep.\n\n        Parameters\n        ----------\n        rhino_brep : :class:`Rhino.Geometry.Brep`\n            The instance of Rhino brep to wrap.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        brep = cls()\n        brep._brep = rhino_brep\n        return brep\n\n    @classmethod\n    def from_pipe(cls, path, radius, cap_mode=\"none\", tolerance=None, *args, **kwargs):\n        \"\"\"Construct a Brep by extruding a circle curve along the path curve.\n\n        Parameters\n        ----------\n        curve : :class:`compas.geometry.Curve`\n            The curve to extrude\n        radius : float\n            The radius of the pipe.\n        cap_mode : literal('none', 'flat', 'round'), optional\n            The type of end caps to create. Defaults to 'none'.\n        tolerance : :class:`~compas.tolerance.Tolerance`, optional\n            A Tolerance instance to use for the operation. Defaults to `TOL`.\n\n        Returns\n        -------\n        :class:`compas.geometry.Brep`\n\n        \"\"\"\n        tolerance = tolerance or TOL\n\n        if cap_mode == \"none\":\n            cap_mode = Rhino.Geometry.PipeCapMode.NONE\n        elif cap_mode == \"flat\":\n            cap_mode = Rhino.Geometry.PipeCapMode.Flat\n        elif cap_mode == \"round\":\n            cap_mode = Rhino.Geometry.PipeCapMode.Round\n        else:\n            raise ValueError(\"Invalid cap_ends value. Must be 'none', 'flat' or 'round'.\")\n\n        if hasattr(path, \"native_curve\"):\n            path = curve_to_rhino(path)\n        elif isinstance(path, Polyline):\n            path = polyline_to_rhino_curve(path)\n        elif isinstance(path, Line):\n            path = line_to_rhino_curve(path)\n        else:\n            raise TypeError(\"Unsupported path curve type: {}\".format(type(path)))\n\n        result = Rhino.Geometry.Brep.CreatePipe(path, radius, False, cap_mode, True, tolerance.absolute, tolerance.angular)\n        if result is None:\n            raise BrepError(\"Failed to create pipe from curve: {} and radius: {}\".format(path, radius))\n\n        return [cls.from_native(brep) for brep in result]\n\n    @classmethod\n    def from_plane(cls, plane, domain_u=(-1, +1), domain_v=(-1, +1)):\n        \"\"\"Create a RhinoBrep from a plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Plane` or :class:`compas.geometry.Frame`\n            The source plane.\n        domain_u : tuple of float, optional\n            The U domain of the plane. Defaults to (-1, +1).\n        domain_v : tuple of float, optional\n            The V domain of the plane. Defaults to (-1, +1).\n\n        Notes\n        -----\n        When using a Rhino Plane, to maintain the original orientation data\n        use :meth:`~compas_rhino.conversions.plane_to_compas_frame` and :meth:`~compas_rhino.conversions.frame_to_rhino_plane`.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if isinstance(plane, Frame):\n            rhino_plane = frame_to_rhino_plane(plane)\n        else:\n            rhino_plane = plane_to_rhino(plane)\n        u = Rhino.Geometry.Interval(domain_u[0], domain_u[1])\n        v = Rhino.Geometry.Interval(domain_v[0], domain_v[1])\n        surface = Rhino.Geometry.PlaneSurface(rhino_plane, u, v)\n        return cls.from_native(surface.ToBrep())\n\n    @classmethod\n    def from_polygons(cls, polygons, tolerance=None, *args, **kwargs):\n        \"\"\"Create a RhinoBrep from a list of polygons.\n\n        Parameters\n        ----------\n        polygons : list of :class:`compas.geometry.Polygon`\n            The source polygons.\n\n        Returns\n        -------\n        list of :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        polylines = []\n        for polygon in polygons:\n            points = polygon.points + [polygon.points[0]]  # make a closed polyline from the polygon\n            polylines.append(Polyline(points=[*points]))\n        return cls.from_curves(polylines, tolerance)\n\n    @classmethod\n    def from_sphere(cls, sphere):\n        \"\"\"Create a RhinoBrep from a sphere.\n\n        Parameters\n        ----------\n        sphere : :class:`compas.geometry.Sphere`\n            The source sphere.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        rhino_sphere = sphere_to_rhino(sphere)\n        return cls.from_native(rhino_sphere.ToBrep())\n\n    @classmethod\n    def from_step(cls, filepath):\n        \"\"\"Construct a RhinoBrep from a STEP file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the step file.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        if not (filepath.endswith(\".step\") or filepath.endswith(\".stp\")):\n            raise ValueError(\"Expected file with .step or .stp extension\")\n        return _import_brep_from_file(filepath)\n\n    @classmethod\n    def from_sweep(cls, profile, path, is_closed=False, tolerance=None):\n        \"\"\"Construct one or more RhinoBrep(s) from a sweep operation.\n\n        Parameters\n        ----------\n        profile : :class:`compas.geometry.Curve`\n            Curve describing the cross-section of the surface created by the sweep operation.\n        path : :class:`compas.geometry.Curve`\n            Curve describing the edge of the sweep surface. The profile curve is sweeped along this curve.\n        is_closed : bool, optional\n            If True, the resulting surface will be closed, if possible. Defaults to False.\n        tolerance : float, optional\n            The precision to use for the operation. Defaults to `TOL.absolute`.\n\n        Returns\n        -------\n        list of :class:`compas_rhino.geometry.RhinoBrep`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if hasattr(profile, \"native_curve\"):\n            profile = curve_to_rhino(profile)\n        elif isinstance(profile, Polyline):\n            profile = polyline_to_rhino_curve(profile)\n        elif isinstance(profile, Line):\n            profile = line_to_rhino_curve(profile)\n        else:\n            raise TypeError(\"Unsupported profile type: {}\".format(type(profile)))\n\n        if hasattr(path, \"native_curve\"):\n            path = curve_to_rhino(path)\n        elif isinstance(path, Polyline):\n            path = polyline_to_rhino_curve(path)\n        elif isinstance(path, Line):\n            path = line_to_rhino_curve(path)\n        else:\n            raise TypeError(\"Unsupported path type: {}\".format(type(path)))\n\n        results = Rhino.Geometry.Brep.CreateFromSweep(path, profile, is_closed, tolerance)\n        if not results:\n            raise BrepError(\"Sweep operation ended with no result\")\n\n        return [cls.from_native(result) for result in results]\n\n    @classmethod\n    def from_torus(cls, torus):\n        \"\"\"Construct a RhinoBrep from a COMPAS torus.\n\n        Parameters\n        ----------\n        torus : :class:`compas.geometry.Torus`\n\n        Returns\n        -------\n        :class:`compas.geometry.BRep`\n\n        \"\"\"\n        rhino_torus = torus_to_rhino(torus)\n        return cls.from_native(rhino_torus.ToBrep())\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n\n    def contains(self, object):\n        \"\"\"Check if the Brep contains a given geometric primitive.\n\n        Only closed and manifold breps can be checked for containment.\n\n        Parameters\n        ----------\n        object : :class:`~compas.geometry.Point`, :class:`~compas.geometry.Curve`, :class:`~compas.geometry.Surface`\n            The object to check for containment.\n\n        Raises\n        ------\n        BrepError\n            If the Brep is not solid.\n\n        Returns\n        -------\n        bool\n            True if the object is contained in the Brep, False otherwise.\n\n        \"\"\"\n        if not self.is_solid:\n            raise BrepError(\"Cannot check for containment if brep is not manifold or is not closed\")\n\n        if isinstance(object, Point):\n            return self._brep.IsPointInside(point_to_rhino(object), TOL.absolute, False)\n        else:\n            raise NotImplementedError\n\n    def to_meshes(self, u=16, v=16):\n        \"\"\"Convert the faces of this Brep shape to meshes.\n\n        Parameters\n        ----------\n        u : int, optional\n            The number of mesh faces in the U direction of the underlying surface geometry of every face of the Brep.\n        v : int, optional\n            The number of mesh faces in the V direction of the underlying surface geometry of every face of the Brep.\n\n        Returns\n        -------\n        list[:class:`~compas.datastructures.Mesh`]\n\n        \"\"\"\n        rg_meshes = Rhino.Geometry.Mesh.CreateFromBrep(self._brep, Rhino.Geometry.MeshingParameters.Default)\n        meshes = [mesh_to_compas(m) for m in rg_meshes]\n        return meshes\n\n    def to_viewmesh(self, linear_deflection: float = 0.001):\n        \"\"\"\n        Convert the Brep to a single view mesh.\n\n        Note\n        ----\n        Edges as polylines is not currently implemented for RhinoBrep. Therefore, an empty list will be returned.\n\n        Parameters\n        ----------\n        linear_deflection : float, optional\n            The maximum linear deflection between the geometry and its discrete representation.\n\n        Returns\n        -------\n        tuple[:class:`compas.datastructures.Mesh`, list[:class:`compas.geometry.Polyline`]]\n\n        \"\"\"\n        return _join_meshes(self.to_meshes()), []\n\n    def to_step(self, filepath):\n        if not (filepath.endswith(\".step\") or filepath.endswith(\".stp\")):\n            raise ValueError(\"Attempted to export STEP but file ends with {} extension\".format(filepath.split(\".\")[-1]))\n        _export_brep_to_file(self._brep, filepath)\n\n    def transform(self, matrix):\n        \"\"\"Transform this Brep by given transformation matrix\n\n        Parameters\n        ----------\n        matrix: :class:`compas.geometry.Transformation`\n            The transformation matrix by which to transform this Brep.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self._brep.Transform(transformation_to_rhino(matrix))\n\n    def trim(self, plane, tolerance=None):\n        \"\"\"Trim this brep by the given trimming plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Frame` or :class:`compas.geometry.Plane`\n            The frame or plane to use when trimming. The discarded bit is in the direction of the frame's normal.\n        tolerance : float, optional\n            The precision to use for the trimming operation. Defaults to `TOL.absolute`.\n\n        Notes\n        -----\n        Trimming operation may result in multiple results (breps). When trimming, only one is used.\n        The used bit is the one on the opposite side of the cutting plane's normal.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        BrepTrimmingError\n            If the trimming operation ended with no result.\n\n        See Also\n        --------\n        :meth:`compas_rhino.geometry.RhinoBrep.trimmed`\n\n        \"\"\"\n        result = self.trimmed(plane, tolerance)\n        self._brep = result.native_brep\n\n    def trimmed(self, plane, tolerance=None):\n        \"\"\"Returns a trimmed copy of this brep by the given trimming plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Frame` or :class:`compas.geometry.Plane`\n            The frame or plane to use when trimming. The discarded bit is in the direction of the plane's normal.\n        tolerance : float, optional\n            The precision to use for the trimming operation. Defaults to `TOL.absolute`.\n\n        Notes\n        -----\n        Trimming operation may result in multiple results (breps). When trimming, only one is used.\n        The used bit is the one on the opposite side of the cutting plane's normal.\n\n        Returns\n        -------\n        :class:`~compas_rhino.geometry.RhinoBrep`\n\n        Raises\n        ------\n        BrepTrimmingError\n            If the trimming operation ended with no result.\n\n        See Also\n        --------\n        :meth:`compas_rhino.geometry.RhinoBrep.trim`\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        if isinstance(plane, Frame):\n            plane = Plane.from_frame(plane)\n        results = self._brep.Trim(plane_to_rhino(plane), tolerance)\n        if not results:\n            raise BrepTrimmingError(\"Trim operation ended with no result\")\n        result = results[0]\n        capped = result.CapPlanarHoles(tolerance)\n        if capped:\n            result = capped\n        return RhinoBrep.from_native(result)\n\n    def slice(self, plane):\n        \"\"\"Slice through the Brep with a plane.\n\n        Parameters\n        ----------\n        plane : :class:`~compas.geometry.Plane` or :class:`~compas.geometry.Frame`\n            The plane to slice through the brep.\n\n        Returns\n        -------\n        list(:class:`~compas.geometry.Curve`)\n            Zero or more curves which represent the intersection(s) between the brep and the plane.\n\n        \"\"\"\n        if isinstance(plane, Frame):\n            plane = Plane.from_frame(plane)\n        curves = Rhino.Geometry.Brep.CreateContourCurves(self._brep, plane_to_rhino(plane))\n        return [curve_to_compas(curve) for curve in curves]\n\n    def split(self, cutter):\n        \"\"\"Splits a Brep into pieces using a Brep as a cutter.\n\n        Parameters\n        ----------\n        cutter : :class:`compas_rhino.geometry.RhinoBrep`\n            Another Brep to use as a cutter.\n\n        Returns\n        -------\n        list(:class:`compas_rhino.geometry.RhinoBrep`)\n            list of zero or more resulting Breps.\n\n        \"\"\"\n        resulting_breps = self._brep.Split(cutter.native_brep, TOL.absolute)\n        return [RhinoBrep.from_native(brep) for brep in resulting_breps]\n\n    def fillet(self, radius, edges=None):\n        \"\"\"Fillet edges of the Brep.\n\n        Parameters\n        ----------\n        radius : float\n            The radius of the fillet.\n        edges : list(:class:`compas_rhino.geometry.RhinoBrepEdge`)\n            The edges to fillet.\n\n        Raises\n        -------\n        BrepFilletingError\n            If the fillet operation fails.\n\n        \"\"\"\n        resulting_breps = self.filleted(radius, edges)\n        self._brep = resulting_breps.native_brep\n\n    def filleted(self, radius, edges=None):\n        \"\"\"Returns a filleted copy of the Brep.\n\n        Parameters\n        ----------\n        radius : float\n            The radius of the fillet.\n        edges : list(:class:`compas_rhino.geometry.RhinoBrepEdge`)\n            List of edges to exclude from the operation. When None all edges are included.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoBrep`\n            The resulting Brep.\n\n        Raises\n        -------\n        BrepFilletingError\n            If the fillet operation fails.\n\n        \"\"\"\n        all_edge_indices = set(edge.native_edge.EdgeIndex for edge in self.edges)  # type: ignore\n        excluded_indices = set(edge.native_edge.EdgeIndex for edge in edges or [])\n\n        edge_indices = all_edge_indices - excluded_indices\n        radii = [radius] * len(edge_indices)\n        blend = Rhino.Geometry.BlendType.Fillet\n        rail = Rhino.Geometry.RailType.DistanceFromEdge\n\n        resulting_breps = Rhino.Geometry.Brep.CreateFilletEdges(self._brep, edge_indices, radii, radii, blend, rail, TOL.absolute)\n        if not resulting_breps:\n            raise BrepFilletError(\"Fillet operation ended with no result\")\n        return RhinoBrep.from_native(resulting_breps[0])\n\n    def flip(self):\n        \"\"\"Flip the orientation of all faces of the Brep.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self._brep.Flip()\n\n    def cap_planar_holes(self, tolerance=None):\n        \"\"\"Cap all planar holes in the Brep.\n\n        Parameters\n        ----------\n        tolerance : float, optional\n            The precision to use for the operation. Defaults to `TOL.absolute`.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        BrepError\n            If the operation fails.\n\n        \"\"\"\n        tolerance = tolerance or TOL.absolute\n        result = self._brep.CapPlanarHoles(tolerance)\n        if result:\n            self._brep = result\n        else:\n            raise BrepError(\"Failed to cap planar holes\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}