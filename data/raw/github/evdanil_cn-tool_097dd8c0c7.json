{
  "source_url": "https://github.com/evdanil/cn-tool/blob/d83b0c68efb5aaf10f09f1b77ddd5c992157f4af/utils/user_input.py",
  "repo": "evdanil/cn-tool",
  "repo_stars": 1,
  "repo_description": "Utility allowing to receive information from Infoblox API",
  "license": "unknown",
  "filepath": "utils/user_input.py",
  "instruction": "User input",
  "code": "import termios\r\nimport sys\r\nimport tty\r\nfrom typing import Optional, Callable\r\nimport threading\r\nfrom core.base import ScriptContext\r\nfrom utils.app_lifecycle import exit_now\r\nfrom utils.display import get_global_color_scheme\r\nfrom rich.live import Live\r\nfrom rich.text import Text\r\nfrom rich.console import Group, Console\r\nimport time\r\nimport select\r\nimport os\r\ntry:\r\n    import msvcrt  # type: ignore\r\nexcept Exception:  # non-Windows\r\n    msvcrt = None\r\n\r\n\r\ndef read_user_input(ctx: ScriptContext, prompt: Optional[str] = \" \", read_pass: bool = False) -> str:\r\n    \"\"\"\r\n    Read user input and gracefully handle CTRL-C (KeyboardInterrupt) and\r\n    CTRL-D (EOFError) to ensure a clean application shutdown.\r\n\r\n    If read_pass is True, function will request a password string.\r\n    \"\"\"\r\n    raw_input = \"\"\r\n    try:\r\n        raw_input = ctx.console.input(f\"{prompt}\", password=read_pass, markup=True)\r\n\r\n    except EOFError:\r\n        # User pressed CTRL-D. This should also trigger a clean exit.\r\n        # We have access to everything we need via the context.\r\n        ctx.logger.info(\"CTRL-D (EOF) detected, returning...\")\r\n        return raw_input\r\n\r\n    except KeyboardInterrupt:\r\n        # User pressed CTRL-C. This is the main fix.\r\n        # We call the new exit_now function, passing the context and the list of\r\n        # plugins that is stored within the context.\r\n        ctx.logger.info(\"CTRL-C (SIGINT) detected, initiating clean shutdown.\")\r\n        exit_now(ctx, 1, \"Interrupted by user... Exiting...\")\r\n\r\n    return raw_input\r\n\r\n\r\ndef read_single_keypress(ctx: ScriptContext) -> str:\r\n    # Save the current terminal settings\r\n    fd = sys.stdin.fileno()\r\n    old_settings = termios.tcgetattr(fd)\r\n\r\n    ch = ''\r\n\r\n    try:\r\n        # Switch terminal to raw mode to capture single key press without enter\r\n        tty.setraw(sys.stdin.fileno())\r\n\r\n        # Read a single character\r\n        ch = sys.stdin.read(1)\r\n\r\n        # Check for Ctrl+C (End of Text character)\r\n        if ch == '\\x03':\r\n            # We must restore terminal settings BEFORE exiting, otherwise\r\n            # the user's terminal will be left in a broken state.\r\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n            ctx.logger.info(\"CTRL-C (SIGINT) detected in single-keypress mode, initiating clean shutdown.\")\r\n            exit_now(ctx, 1, \"Interrupted by user... Exiting...\")\r\n\r\n        # Check for Ctrl+D (End of Transmission character)\r\n        if ch == '\\x04':\r\n            # Restore terminal settings before exiting\r\n            # termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n            ctx.logger.info(\"CTRL-D (EOF) detected in single-keypress mode, returning normally\")\r\n\r\n    finally:\r\n        # Restore the terminal settings\r\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n\r\n    return ch\r\n\r\n\r\ndef press_any_key(ctx: ScriptContext) -> None:\r\n    \"\"\"  Prints press any key message and read single press of any key\r\n    \"\"\"\r\n    colors = get_global_color_scheme(ctx.cfg)\r\n    ctx.console.print(f\"[{colors['description']}]Press [{colors['error']}]any[/] key to continue[/]\")\r\n    read_single_keypress(ctx)\r\n\r\n\r\ndef read_user_input_live(\r\n    ctx: ScriptContext,\r\n    render: Callable[[], str],\r\n    indexing_active: bool = False,\r\n    refresh_signal: Optional[threading.Event] = None,\r\n) -> str:\r\n    \"\"\"\r\n    Live-updating menu with a keystroke-buffered prompt inside the Live area.\r\n    - Shows typed characters as you enter them.\r\n    - Supports Backspace, Enter, and Esc to clear.\r\n    - Keeps the status/menu refreshing until you press Enter.\r\n\r\n    Optimized to minimize CPU usage:\r\n    - Caches parsed Rich objects (avoids markup reparsing)\r\n    - Tracks state to detect real changes\r\n    - Uses minute-boundary detection for timestamp updates\r\n    - Adaptive refresh intervals (2.5s during indexing, 60s when idle)\r\n\r\n    refresh_signal allows external events to trigger an immediate refresh\r\n    without waiting for the next scheduled interval.\r\n    \"\"\"\r\n    from datetime import datetime\r\n\r\n    colors = get_global_color_scheme(ctx.cfg)\r\n    buffer: str = \"\"\r\n    is_windows = os.name == 'nt' or (sys.platform.startswith('win'))\r\n\r\n    # POSIX: set raw mode; Windows: use msvcrt\r\n    fd = None\r\n    old_settings = None\r\n    restored = False\r\n    if not is_windows:\r\n        fd = sys.stdin.fileno()\r\n        old_settings = termios.tcgetattr(fd)\r\n        # Enter a cbreak-like mode: disable canonical input and echo, keep output processing intact\r\n        new_settings = termios.tcgetattr(fd)\r\n        new_settings[3] = new_settings[3] & ~(termios.ICANON | termios.ECHO)\r\n        # Disable software flow control so we can handle CTRL-S/CTRL-Q ourselves\r\n        new_settings[0] = new_settings[0] & ~(termios.IXON | termios.IXOFF)\r\n        new_settings[6][termios.VMIN] = 1\r\n        new_settings[6][termios.VTIME] = 0\r\n        termios.tcsetattr(fd, termios.TCSANOW, new_settings)\r\n\r\n    # Use a dedicated Rich Console with force_terminal=True so Live updates in-place\r\n    live_console = Console(theme=getattr(ctx.console, 'theme', None), force_terminal=True)\r\n    got_kbint = False\r\n    try:\r\n        # Initialize state tracking\r\n        status_header = render().rstrip()\r\n        current_minute = datetime.now().minute\r\n\r\n        # State dict to track what changed\r\n        state = {\r\n            'status_header': status_header,\r\n            'buffer': buffer,\r\n            'minute': current_minute,\r\n            'was_indexing': indexing_active,  # Track indexing state changes\r\n        }\r\n\r\n        # Parse components once (cached Rich objects)\r\n        status_text = Text.from_markup(status_header)\r\n        prompt_text = Text.from_markup(f\"\\n\\n[{colors['description']}]Enter your choice:[/] \")\r\n\r\n        # Compose initial frame from cached objects\r\n        initial_group = Group(status_text, prompt_text)\r\n\r\n        # Initial interval based on current indexing state\r\n        status_refresh_interval = 2.5 if indexing_active else 60.0\r\n        next_status_at = time.monotonic() + max(0.5, status_refresh_interval)\r\n\r\n        # Base polling windows (used mainly on Windows path)\r\n        poll_active = 0.10  # when user is actively typing (last 2s)\r\n        poll_idle = 0.30    # relaxed polling when idle\r\n        last_key_time: float = 0.0  # 0 => no recent typing\r\n\r\n        with Live(initial_group, console=live_console, screen=True, refresh_per_second=1) as live:\r\n            updates_paused = False\r\n            while True:\r\n                # Check current indexing state dynamically (it can change mid-loop!)\r\n                try:\r\n                    current_indexing = bool(ctx.cache and ctx.cache.dc and ctx.cache.dc.get(\"indexing\", False))\r\n                except Exception:\r\n                    current_indexing = False\r\n\r\n                # Recalculate interval based on CURRENT state\r\n                status_refresh_interval = 2.5 if current_indexing else 60.0\r\n\r\n                # Detect indexing state transition\r\n                if current_indexing != state.get('was_indexing', False):\r\n                    # State changed! Adjust next wakeup immediately\r\n                    state['was_indexing'] = current_indexing\r\n                    if current_indexing:\r\n                        # Just started indexing - wake up sooner\r\n                        next_status_at = time.monotonic() + 0.1  # Wake almost immediately\r\n                    else:\r\n                        # Indexing stopped - can relax\r\n                        next_status_at = time.monotonic() + status_refresh_interval\r\n\r\n                now = time.monotonic()\r\n                now_dt = datetime.now()\r\n                current_minute = now_dt.minute\r\n\r\n                forced_refresh = False\r\n                if refresh_signal is not None and refresh_signal.is_set():\r\n                    forced_refresh = True\r\n                    refresh_signal.clear()\r\n\r\n                # Check if we need to refresh status (interval elapsed OR minute changed)\r\n                status_needs_refresh = (not updates_paused) and (\r\n                    forced_refresh or (now >= next_status_at) or (current_minute != state['minute'])\r\n                )\r\n\r\n                if status_needs_refresh:\r\n                    new_header = render().rstrip()\r\n                    if new_header != state['status_header']:\r\n                        state['status_header'] = new_header\r\n                        status_text = Text.from_markup(new_header)\r\n                    state['minute'] = current_minute\r\n                    # Use current dynamic interval\r\n                    next_status_at = now + max(0.5, status_refresh_interval)\r\n\r\n                # Check if buffer changed\r\n                buffer_changed = buffer != state['buffer']\r\n                if buffer_changed:\r\n                    state['buffer'] = buffer\r\n                    prompt_text = Text.from_markup(f\"\\n\\n[{colors['description']}]Enter your choice:[/] {buffer}\")\r\n\r\n                # Only update Live display if something actually changed\r\n                if (status_needs_refresh or buffer_changed) and not updates_paused:\r\n                    live.update(Group(status_text, prompt_text), refresh=True)\r\n\r\n                try:\r\n                    if is_windows and msvcrt:\r\n                        # Poll keyboard\r\n                        if msvcrt.kbhit():\r\n                            ch = msvcrt.getwch()\r\n                            # Handle special keys (arrows etc.) which come as \\xe0 or \\x00 prefix\r\n                            if ch in ('\\x00', '\\xe0'):\r\n                                _ = msvcrt.getwch()  # consume the next char\r\n                                continue\r\n                            if ch == '\\x13':  # CTRL-S pauses refresh\r\n                                if not updates_paused:\r\n                                    updates_paused = True\r\n                                    live.stop()\r\n                                    ctx.console.print(Group(status_text, prompt_text))\r\n                                    ctx.console.print(f\"\\n[{colors['description']}]Menu updates paused. Press CTRL-Q to resume.[/]\")\r\n                                continue\r\n                            if ch == '\\x11':  # CTRL-Q resumes refresh\r\n                                if updates_paused:\r\n                                    updates_paused = False\r\n                                    ctx.console.clear()\r\n                                    # Refresh menu when coming back\r\n                                    refreshed_header = render().rstrip()\r\n                                    status_text = Text.from_markup(refreshed_header)\r\n                                    state['status_header'] = refreshed_header\r\n                                    state['minute'] = datetime.now().minute\r\n                                    prompt_text = Text.from_markup(f\"\\n\\n[{colors['description']}]Enter your choice:[/] {buffer}\")\r\n                                    live.start()\r\n                                    live.update(Group(status_text, prompt_text), refresh=True)\r\n                                    next_status_at = time.monotonic() + max(0.5, status_refresh_interval)\r\n                                continue\r\n                            if ch in ('\\r', '\\n'):\r\n                                return buffer.strip()\r\n                            if ch == '\\x08':  # Backspace\r\n                                buffer = buffer[:-1]\r\n                                last_key_time = time.monotonic()\r\n                                continue\r\n                            if ch == '\\x1b':  # ESC clears buffer\r\n                                buffer = \"\"\r\n                                last_key_time = time.monotonic()\r\n                                continue\r\n                            # Printable char\r\n                            buffer += ch\r\n                            last_key_time = time.monotonic()\r\n                        else:\r\n                            # Calculate optimal sleep: either next status update or next minute boundary\r\n                            now2 = time.monotonic()\r\n                            sleep_for = max(0.0, next_status_at - now2)\r\n\r\n                            # Also consider minute boundary for timestamp updates\r\n                            now_dt = datetime.now()\r\n                            seconds_until_next_minute = 60 - now_dt.second\r\n                            sleep_for = min(sleep_for, seconds_until_next_minute)\r\n\r\n                            # Cap at 2.5s max to detect indexing state changes within reasonable time\r\n                            sleep_for = min(sleep_for, 2.5)\r\n\r\n                            # Adaptive polling based on recent typing activity (2s window)\r\n                            typing_active = (last_key_time > 0.0) and ((now2 - last_key_time) < 2.0)\r\n                            current_poll = poll_active if typing_active else poll_idle\r\n                            time.sleep(min(current_poll, sleep_for))\r\n                    else:\r\n                        # POSIX: select on stdin\r\n                        # Block until either input arrives, next status update, or next minute boundary\r\n                        now_mono = time.monotonic()\r\n                        timeout_status = max(0.0, next_status_at - now_mono)\r\n\r\n                        # Calculate seconds until next minute boundary for timestamp updates\r\n                        now_dt = datetime.now()\r\n                        seconds_until_next_minute = 60 - now_dt.second\r\n                        timeout = min(timeout_status, seconds_until_next_minute)\r\n\r\n                        # Cap at 2.5s max to detect indexing state changes within reasonable time\r\n                        # This ensures we loop back and check current_indexing at least every 2.5s\r\n                        timeout = min(timeout, 2.5)\r\n\r\n                        r, _, _ = select.select([sys.stdin], [], [], timeout)\r\n                        if r:\r\n                            ch = sys.stdin.read(1)\r\n                            if ch == '\\x13':  # CTRL-S pauses refresh\r\n                                if not updates_paused:\r\n                                    updates_paused = True\r\n                                    live.stop()\r\n                                    ctx.console.print(Group(status_text, prompt_text))\r\n                                    ctx.console.print(f\"\\n[{colors['description']}]Menu updates paused. Press CTRL-Q to resume.[/]\")\r\n                                continue\r\n                            if ch == '\\x11':  # CTRL-Q resumes refresh\r\n                                if updates_paused:\r\n                                    updates_paused = False\r\n                                    ctx.console.clear()\r\n                                    refreshed_header = render().rstrip()\r\n                                    status_text = Text.from_markup(refreshed_header)\r\n                                    state['status_header'] = refreshed_header\r\n                                    state['minute'] = datetime.now().minute\r\n                                    prompt_text = Text.from_markup(f\"\\n\\n[{colors['description']}]Enter your choice:[/] {buffer}\")\r\n                                    live.start()\r\n                                    live.update(Group(status_text, prompt_text), refresh=True)\r\n                                    next_status_at = time.monotonic() + max(0.5, status_refresh_interval)\r\n                                continue\r\n                            if ch in ('\\r', '\\n'):\r\n                                return buffer.strip()\r\n                            if ch in ('\\x7f', '\\b', '\\x08'):  # Backspace variants\r\n                                buffer = buffer[:-1]\r\n                                last_key_time = time.monotonic()\r\n                                continue\r\n                            if ch == '\\x1b':\r\n                                # Try to consume the rest of an escape sequence non-blocking\r\n                                # or treat ESC as clear buffer\r\n                                time.sleep(0.01)\r\n                                if select.select([sys.stdin], [], [], 0)[0]:\r\n                                    _ = sys.stdin.read(2)  # likely '[' + code\r\n                                else:\r\n                                    buffer = \"\"  # lone ESC clears\r\n                                last_key_time = time.monotonic()\r\n                                continue\r\n                            # Otherwise append printable characters\r\n                            if ch.isprintable():\r\n                                buffer += ch\r\n                                last_key_time = time.monotonic()\r\n                        # else: timeout reached; loop will refresh status on next iteration\r\n                except EOFError:\r\n                    # CTRL-D or similar: treat as empty submit\r\n                    return buffer.strip()\r\n                except KeyboardInterrupt:\r\n                    # Defer printing until after Live has exited and terminal restored\r\n                    ctx.cfg[\"exiting\"] = True\r\n                    got_kbint = True\r\n                    break\r\n    finally:\r\n        if not is_windows and fd is not None and old_settings is not None and not restored:\r\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n            restored = True\r\n    if got_kbint:\r\n        # After closing Live, ensure terminal restored, clear and print a clean final view\r\n        try:\r\n            if not is_windows and fd is not None and old_settings is not None and not restored:\r\n                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n                restored = True\r\n        except Exception:\r\n            pass\r\n        try:\r\n            ctx.console.clear()\r\n            # Re-render one final static view (now that exiting flag is set)\r\n            final_view = render()\r\n            ctx.console.print(final_view)\r\n            colors = get_global_color_scheme(ctx.cfg)\r\n            ctx.console.print(f\"\\n[{colors['error']}]Interrupted by user... Exiting gracefully...[/]\")\r\n        except Exception:\r\n            pass\r\n        ctx.logger.info(\"CTRL-C (SIGINT) detected, initiating clean shutdown.\")\r\n        exit_now(ctx, 1, \"Interrupted by user... Exiting...\")\r\n        return \"\"\r\n    return buffer.strip()\r\n\r\n\r\n",
  "language": "python",
  "imports": [],
  "has_docstring": false
}