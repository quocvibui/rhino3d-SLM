{
  "source_url": "https://github.com/969flash/parcel_layout_evaluation_analysis/blob/af8592ec3f658bf5bb8b63064ff33fdbf46240d0/grasshopper/scorers/shape.py",
  "repo": "969flash/parcel_layout_evaluation_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "grasshopper/scorers/shape.py",
  "instruction": null,
  "code": "from __future__ import annotations\n\nimport math\nfrom typing import List\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp  # type: ignore\nfrom units import Block\nimport utils\nimport os\n\nfrom constants import (\n    SHAPE_BLOCK_INFLUENCE,\n    SHAPE_CONVEXITY_WEIGHT,\n    SHAPE_CIRCULARITY_WEIGHT,\n    SHAPE_SQUARENESS_WEIGHT,\n)\n\n\ndef compute(block: Block) -> float:\n    \"\"\"Return the shape score for a block.\n\n    1) 각 필지의 RSI 평균을 계산하고\n    2) 블록 외곽선의 RSI를 기반으로 'ugly multiplier'를 만들어\n    3) 두 값을 곱해 최종 점수를 산출합니다.\n    \"\"\"\n    if not block.lots:\n        return 0.0\n\n    lot_scores = [get_rsi(lot.region) for lot in block.lots]\n    if not lot_scores:\n        return 0.0\n\n    lot_avg_rsi = sum(lot_scores) / len(lot_scores)\n\n    block_rsi = get_rsi(block.region)\n    block_multiplier = _compute_block_multiplier(block_rsi)\n\n    final_score = lot_avg_rsi * block_multiplier\n\n    return final_score\n\n\ndef get_rsi(region: geo.Curve | None) -> float:\n    \"\"\"Return the RSI value (0~1) for a single region.\"\"\"\n    convexity = get_convexity_index(region)\n    circularity = get_circularity_index(region)\n    squareness = get_squareness_index(region)\n\n    rsi = (\n        (convexity * SHAPE_CONVEXITY_WEIGHT)\n        + (circularity * SHAPE_CIRCULARITY_WEIGHT)\n        + (squareness * SHAPE_SQUARENESS_WEIGHT)\n    )\n\n    return rsi\n\n\ndef get_convexity_index(region: geo.Curve) -> float:\n    \"\"\"\n    볼록성 지수(CI) 계산: A / A_ch\n\n    - A: 원래 영역 면적\n    - A_ch: 최소 볼록 다각형(Convex Hull) 면적\n    - 결과값은 (0, 1] 범위. 1에 가까울수록 더 볼록함.\n    - 자루형, ㄷ자형, 별 모양 등 움푹 파인 필지에 페널티 부여\n    \"\"\"\n    if region is None:\n        raise ValueError(\"Region curve is required to compute convexity.\")\n    if not getattr(region, \"IsClosed\", False):\n        raise ValueError(\"Region curve must be closed to compute convexity.\")\n\n    try:\n        area = float(utils.get_area(region))\n    except Exception:\n        return 0.0\n    if area <= 0.0:\n        return 0.0\n\n    vertices = utils.get_vertices(region)\n    hull_crv = ghcomp.ConvexHull(vertices).hull\n\n    if not hull_crv:\n        return 0.0\n    try:\n        hull_area = float(utils.get_area(hull_crv))\n    except Exception:\n        return 0.0\n    if hull_area <= 0.0:\n        return 0.0\n    return area / hull_area\n\n\ndef get_circularity_index(region: geo.Curve) -> float:\n    \"\"\"\n    원형성 지수(Isoperimetric Quotient) 계산: (4 × π × A) / P²\n\n    - A: 필지 면적\n    - P: 필지 둘레\n    - 완벽한 원: 1.0\n    - 정사각형: ~0.785\n    - 길고 얇은 직사각형: 0에 가까운 값\n    - 극단적으로 길쭉한 필지에 페널티 부여\n    \"\"\"\n    if region is None:\n        raise ValueError(\"Region curve is required to compute circularity.\")\n    if not getattr(region, \"IsClosed\", False):\n        raise ValueError(\"Region curve must be closed to compute circularity.\")\n\n    try:\n        area = utils.get_area(region)\n        perim = utils.get_length(region)\n    except Exception:\n        return 0.0\n\n    # Isoperimetric Quotient 공식\n    circularity = (4.0 * math.pi * area) / (perim * perim)\n\n    # 이론적으로 1.0을 초과할 수 없지만, 부동소수점 오차로 인해 약간 초과할 수 있음\n    return circularity\n\n\ndef get_squareness_index(region: geo.Curve) -> float:\n    \"\"\"정사각형 기반 정방향성 지표를 반환.\"\"\"\n    bbox = utils.get_min_bbox(region)\n\n    corners = list(bbox.GetCorners())[:4]\n    dist_1 = corners[0].DistanceTo(corners[1])\n    dist_2 = corners[1].DistanceTo(corners[2])\n\n    aspect_ratio = min(dist_1, dist_2) / max(dist_1, dist_2)\n\n    vertex_count = len(utils.get_vertices(region))\n    vertex_penalty = 1.0\n    if vertex_count == 3:\n        vertex_penalty = 0.5\n    elif vertex_count == 4:\n        vertex_penalty = 1.0\n    elif vertex_count == 5:\n        vertex_penalty = 0.9\n    elif vertex_count == 6:\n        vertex_penalty = 0.8\n    elif vertex_count > 6:\n        vertex_penalty = 0.7\n\n    return aspect_ratio * vertex_penalty\n\n\ndef _compute_block_multiplier(block_rsi: float) -> float:\n    \"\"\"Return the block-level adjustment multiplier.\"\"\"\n    if block_rsi <= 0.0:\n        return 1.0 - SHAPE_BLOCK_INFLUENCE\n    return (block_rsi * SHAPE_BLOCK_INFLUENCE) + (1.0 - SHAPE_BLOCK_INFLUENCE)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}