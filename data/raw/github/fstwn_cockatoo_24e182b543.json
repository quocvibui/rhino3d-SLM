{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/modules/cockatoo/_knitnetwork.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "modules/cockatoo/_knitnetwork.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import deque\nfrom collections import OrderedDict\nfrom math import radians\nfrom math import pi\nfrom operator import itemgetter\n\n# DUNDER ----------------------------------------------------------------------\n__all__ = [\n    \"KnitNetwork\"\n]\n\n# THIRD PARTY MODULE IMPORTS --------------------------------------------------\nimport networkx as nx\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\nfrom cockatoo._knitnetworkbase import KnitNetworkBase\nfrom cockatoo._knitmappingnetwork import KnitMappingNetwork\nfrom cockatoo._knitdinetwork import KnitDiNetwork\nfrom cockatoo.environment import RHINOINSIDE\nfrom cockatoo.exception import KnitNetworkError\nfrom cockatoo.exception import KnitNetworkGeometryError\nfrom cockatoo.exception import NoEndNodesError\nfrom cockatoo.exception import NoWeftEdgesError\nfrom cockatoo.exception import MappingNetworkError\nfrom cockatoo.utilities import pairwise\n\n# RHINO IMPORTS ---------------------------------------------------------------\nif RHINOINSIDE:\n    import rhinoinside\n    rhinoinside.load()\n    from Rhino.Geometry import Brep as RhinoBrep\n    from Rhino.Geometry import Curve as RhinoCurve\n    from Rhino.Geometry import Line as RhinoLine\n    from Rhino.Geometry import Interval as RhinoInterval\n    from Rhino.Geometry import Mesh as RhinoMesh\n    from Rhino.Geometry import NurbsSurface as RhinoNurbsSurface\n    from Rhino.Geometry import Point3d as RhinoPoint3d\n    from Rhino.Geometry import Polyline as RhinoPolyline\n    from Rhino.Geometry import Surface as RhinoSurface\n    from Rhino.Geometry import Vector3d as RhinoVector3d\nelse:\n    from Rhino.Geometry import Brep as RhinoBrep\n    from Rhino.Geometry import Curve as RhinoCurve\n    from Rhino.Geometry import Line as RhinoLine\n    from Rhino.Geometry import Interval as RhinoInterval\n    from Rhino.Geometry import Mesh as RhinoMesh\n    from Rhino.Geometry import NurbsSurface as RhinoNurbsSurface\n    from Rhino.Geometry import Point3d as RhinoPoint3d\n    from Rhino.Geometry import Polyline as RhinoPolyline\n    from Rhino.Geometry import Surface as RhinoSurface\n    from Rhino.Geometry import Vector3d as RhinoVector3d\n\n# CLASS DECLARATION -----------------------------------------------------------\n\n\nclass KnitNetwork(KnitNetworkBase):\n    \"\"\"\n    Datastructure for representing a network (graph) consisting of nodes with\n    special attributes aswell as 'warp' edges, 'weft' edges and contour edges\n    which are neither 'warp' nor 'weft'.\n\n    Used for the automatic generation of knitting patterns based on mesh or\n    NURBS surface geometry.\n\n    Inherits from :class:`KnitNetworkBase`.\n\n    Notes\n    -----\n    The implemented algorithms are strongly based on the paper\n    *Automated Generation of Knit Patterns for Non-developable Surfaces* [1]_.\n    Also see *KnitCrete - Stay-in-place knitted formworks for complex concrete\n    structures* [2]_.\n\n    The implementation was further influenced by concepts and ideas presented\n    in the papers *Automatic Machine Knitting of 3D Meshes* [3]_,\n    *Visual Knitting Machine Programming* [4]_ and\n    *A Compiler for 3D Machine Knitting* [5]_.\n\n    References\n    ----------\n    .. [1] Popescu, Mariana et al. *Automated Generation of Knit Patterns\n           for Non-developable Surfaces*\n\n           See: `Automated Generation of Knit Patterns for Non-developable\n           Surfaces <https://block.arch.ethz.ch/brg/files/\n           POPESCU_DMSP-2017_automated-generation-knit-patterns_1505737906.\n           pdf>`_\n\n    .. [2] Popescu, Mariana *KnitCrete - Stay-in-place knitted formworks for\n           complex concrete structures*\n\n           See: `KnitCrete - Stay-in-place knitted formworks for complex\n           concrete structures <https://block.arch.ethz.ch/brg/files/\n           POPESCU_2019_ETHZ_PhD_KnitCrete-Stay-in-place-knitted-fabric-\n           formwork-for-complex-concrete-structures_small_1586266206.pdf>`_\n\n    .. [3] Narayanan, Vidya; Albaugh, Lea; Hodgins, Jessica; Coros, Stelian;\n           McCann, James *Automatic Machine Knitting of 3D Meshes*\n\n           See: `Automatic Machine Knitting of 3D Meshes\n           <https://textiles-lab.github.io/publications/2018-autoknit/>`_\n\n    .. [4] Narayanan, Vidya; Wu, Kui et al. *Visual Knitting Machine\n           Programming*\n\n           See: `Visual Knitting Machine Programming\n           <https://textiles-lab.github.io/publications/2019-visualknit/>`_\n\n    .. [5] McCann, James; Albaugh, Lea; Narayanan, Vidya; Grow, April;\n           Matusik, Wojciech; Mankoff, Jen; Hodgins, Jessica\n           *A Compiler for 3D Machine Knitting*\n\n           See: `A Compiler for 3D Machine Knitting\n           <https://la.disneyresearch.com/publication/machine-knitting-\n           compiler/>`_\n    \"\"\"\n\n    # INITIALIZATION ----------------------------------------------------------\n\n    def __init__(self, data=None, **attr):\n        \"\"\"\n        Initialize a KnitNetwork (inherits NetworkX graph) with edges, name,\n        graph attributes.\n\n        Parameters\n        ----------\n        data : input graph\n            Data to initialize graph.  If data=None (default) an empty\n            network is created.  The data can be an edge list, any\n            KnitNetworkBase or NetworkX graph object.\n\n        name : string, optional (default='')\n            An optional name for the graph.\n\n        attr : keyword arguments, optional (default= no attributes)\n            Attributes to add to graph as key=value pairs.\n        \"\"\"\n\n        # initialize using original init method\n        super(KnitNetwork, self).__init__(data=data, **attr)\n\n        # also copy the mapping_network attribute if it is already available\n        if data and isinstance(data, KnitNetwork) and data.mapping_network:\n            self.mapping_network = data.mapping_network\n        else:\n            self.mapping_network = None\n\n    @classmethod\n    def create_from_contours(cls, contours, course_height,\n                             reference_geometry=None):\n        \"\"\"\n        Create and initialize a KnitNetwork based on a set of contours, a\n        given course height and an optional reference geometry.\n        The reference geometry is a mesh or surface which should be described\n        by the network. While it is optional, it is **HIGHLY** recommended to\n        provide it!\n\n        Parameters\n        ----------\n        contours : :obj:`list` of :class:`Rhino.Geometry.Polyline`\n                   or :class:`Rhino.Geometry.Curve`\n            Ordered contours (i.e. isocurves, isolines) to initialize the\n            KnitNetwork with.\n\n        course_height : float\n            The course height for sampling the contours.\n\n        reference_geometry : :class:`Rhino.Geometry.Mesh`\n                             or :class:`Rhino.Geometry.Surface`\n            Optional underlying geometry that this network is based on.\n\n        Returns\n        -------\n        KnitNetwork : KnitNetwork\n            A new, initialized KnitNetwork instance.\n\n        Notes\n        -----\n        This method will automatically call initialize_position_contour_edges()\n        on the newly created network!\n\n        Raises\n        ------\n        KnitNetworkGeometryError\n            If a supplied contour is not a valid instance of\n            :obj:`Rhino.Geometry.Polyline` or :obj:`Rhino.Geometry.Curve`.\n        \"\"\"\n\n        # create network\n        network = cls(reference_geometry=reference_geometry)\n\n        # assign reference_geometry if present and valid\n        if reference_geometry:\n            if isinstance(reference_geometry, RhinoMesh):\n                network.graph[\"reference_geometry\"] = reference_geometry\n            elif isinstance(reference_geometry, RhinoBrep):\n                if reference_geometry.IsSurface:\n                    network.graph[\"reference_geometry\"] = RhinoNurbsSurface(\n                                            reference_geometry.Surfaces[0])\n            elif isinstance(reference_geometry, RhinoSurface):\n                network.graph[\"reference_geometry\"] = reference_geometry\n        else:\n            network.graph[\"reference_geometry\"] = None\n\n        # divide the contours and fill network with nodes\n        nodenum = 0\n        for i, crv in enumerate(contours):\n            # check input\n            if not isinstance(crv, RhinoCurve):\n                if isinstance(crv, RhinoPolyline):\n                    crv = crv.ToPolylineCurve()\n                else:\n                    errMsg = (\"Contour at index {} is not \".format(i) +\n                              \"a valid Curve or Polyline!\")\n                    raise KnitNetworkGeometryError(errMsg)\n\n            # compute divisioncount and divide contour\n            dc = round(crv.GetLength() / course_height)\n            tcrv = crv.DivideByCount(dc, True)\n            if not tcrv:\n                dpts = [crv.PointAtStart, crv.PointAtEnd]\n            else:\n                dpts = [crv.PointAt(t) for t in tcrv]\n\n            # loop over all nodes on the current contour\n            for j, point in enumerate(dpts):\n                # declare node attributes\n                vpos = i\n                vnum = j\n                if j == 0 or j == len(dpts) - 1:\n                    vleaf = True\n                else:\n                    vleaf = False\n                # create network node from rhino point\n                network.node_from_point3d(nodenum,\n                                          point,\n                                          position=vpos,\n                                          num=vnum,\n                                          leaf=vleaf,\n                                          start=False,\n                                          end=False,\n                                          segment=None,\n                                          increase=False,\n                                          decrease=False,\n                                          color=None)\n\n                # increment counter\n                nodenum += 1\n\n        # call position contour initialization\n        network.initialize_position_contour_edges()\n\n        return network\n\n    # TEXTUAL REPRESENTATION OF NETWORK ---------------------------------------\n\n    def __repr__(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n        \"\"\"\n\n        if self.name != \"\":\n            name = self.name\n        else:\n            name = \"KnitNetwork\"\n\n        nn = len(self.nodes())\n        ce = len(self.contour_edges)\n        wee = len(self.weft_edges)\n        wae = len(self.warp_edges)\n        data = (\"({} Nodes, {} Position Contours, {} Weft, {} Warp)\")\n        data = data.format(nn, ce, wee, wae)\n\n        return name + data\n\n    def ToString(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n\n        Notes\n        -----\n        Used for overloading the Grasshopper display in data parameters.\n        \"\"\"\n\n        return repr(self)\n\n    # INITIALIZATION OF POSITION CONTOUR EDGES --------------------------------\n\n    def initialize_position_contour_edges(self):\n        \"\"\"\n        Creates all initial position contour edges as neither 'warp' nor 'weft'\n        by iterating over all nodes in the network and grouping them based on\n        their 'position' attribute.\n\n        Notes\n        -----\n        This method is automatically called when creating a KnitNetwork using\n        the create_from_contours method!\n\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # get all nodes by position\n        posList = self.all_nodes_by_position(data=True)\n\n        for i, pos in enumerate(posList):\n            for j, node in enumerate(pos):\n                k = j + 1\n                if k < len(pos):\n                    self.create_contour_edge(node, pos[k])\n\n    # INITIALIZATION OF 'WEFT' EDGES BETWEEN 'LEAF' NODES ---------------------\n\n    def initialize_leaf_connections(self):\n        \"\"\"\n        Create all initial connections of the 'leaf' nodes by iterating over\n        all position contours and creating 'weft' edges between the 'leaf'\n        nodes of the position contours.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # get all leaves\n        leafNodes = self.all_leaves_by_position(True)\n\n        # loop through all the positions leaves\n        for i, lpos in enumerate(leafNodes):\n            j = i + 1\n            # loop through pairs of leaves\n            if j < len(leafNodes):\n                startLeaf = lpos[0]\n                endLeaf = lpos[1]\n                nextStart = leafNodes[j][0]\n                nextEnd = leafNodes[j][1]\n\n                # add edges to the network\n                self.create_weft_edge(startLeaf, nextStart)\n                self.create_weft_edge(endLeaf, nextEnd)\n\n    # INITIALIZATION OF PRELIMINARY 'WEFT' EDGES ------------------------------\n\n    def attempt_weft_connection(self, node, candidate, source_nodes,\n                                max_connections=4, verbose=False):\n        \"\"\"\n        Method for attempting a 'weft' connection to a candidate\n        node based on certain parameters.\n\n        Parameters\n        ----------\n        node : :obj:`tuple`\n            2-tuple representing the source node for the possible 'weft' edge.\n\n        candidate ::obj:`tuple`\n            -tuple representing the target node for the possible 'weft' edge.\n\n        source_nodes : :obj:`list`\n            List of nodes on the position contour of node. Used to check if\n            the candidate node already has a connection.\n\n        max_connections : int, optional\n            The new 'weft' connection will only be made if the candidate nodes\n            number of connected neighbors is below this.\n\n            Defaults to ``4``.\n\n        verbose : bool, optional\n            If ``True``, this routine and all its subroutines will print\n            messages about what is happening to the console.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        bool\n            ``True`` if the connection has been made,\n            ``False`` otherwise.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        # get connected neighbors\n        connecting_neighbors = self[candidate[0]]\n        # only do something if the maximum is not reached\n        if len(connecting_neighbors) < max_connections:\n            # determine if the node is already connected to a node from\n            # the input source nodes\n            isConnected = False\n            for cn in connecting_neighbors:\n                if cn in [v[0] for v in source_nodes]:\n                    isConnected = True\n                    # print info on verbose setting\n                    v_print(\"Candidate node {} is \".format(candidate[0]) +\n                            \"already connected! \" +\n                            \"Skipping to next \" +\n                            \"node...\")\n                    break\n            # check the flag and act accordingly\n            if not isConnected:\n                # print info on verbose setting\n                v_print(\"Connecting node {} to best \".format(node[0]) +\n                        \"candidate {}.\".format(candidate[0]))\n                # if all conditions are met, make the 'weft' connection\n                if node[1][\"position\"] < candidate[1][\"position\"]:\n                    self.create_weft_edge(node, candidate)\n                else:\n                    self.create_weft_edge(candidate, node)\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def _create_initial_weft_connections(self,\n                                         contour_set,\n                                         force_continuous_start=False,\n                                         force_continuous_end=False,\n                                         max_connections=4,\n                                         precise=False,\n                                         verbose=False):\n        \"\"\"\n        Private method for creating initial 'weft' connections for the supplied\n        set of contours, starting from the first contour in the set and\n        propagating to the last contour in the set.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        if len(contour_set) < 2:\n            v_print(\"Not enough contours in contour set!\")\n            return\n\n        # print info on verbose output\n        v_print(\"Creating initial 'weft' connections for contour set...\")\n\n        # loop over all nodes of positions (list of lists of tuples)\n        for i, pos in enumerate(contour_set):\n            # pos is a list of tuples (nodes)\n            if i < len(contour_set):\n                j = i + 1\n                if j == len(contour_set):\n                    break\n\n                # get initial and target nodes without 'leaf' nodes\n                initial_nodes = contour_set[i][1:-1]\n                target_nodes = contour_set[j][1:-1]\n\n                # options for continuous start and end\n                if force_continuous_start:\n                    initial_nodes = initial_nodes[1:]\n                    target_nodes = target_nodes[1:]\n                if force_continuous_end:\n                    initial_nodes = initial_nodes[:-1]\n                    target_nodes = target_nodes[:-1]\n\n                # skip if one of the contours has no nodes\n                if len(initial_nodes) == 0 or len(target_nodes) == 0:\n                    continue\n\n                # define forbidden node index\n                forbidden_node = -1\n\n                # loop through all nodes on the current position\n                for k, node in enumerate(initial_nodes):\n                    # print info on verbose setting\n                    v_print(\"Processing node {} on position {}:\".format(\n                                                node[0], node[1][\"position\"]))\n\n                    # get the geometry for the current node\n                    thisPt = node[1][\"geo\"]\n\n                    # filtering according to forbidden nodes\n                    target_nodes = [tn for tn in target_nodes\n                                    if tn[0] >= forbidden_node]\n\n                    if len(target_nodes) == 0:\n                        continue\n\n                    # get four closest nodes on adjacent contour\n                    if precise:\n                        allDists = [thisPt.DistanceTo(tv[1][\"geo\"])\n                                    for tv in target_nodes]\n                    else:\n                        allDists = [thisPt.DistanceToSquared(tv[1][\"geo\"])\n                                    for tv in target_nodes]\n\n                    # sort the target nodes by distance to current node\n                    allDists, sorted_target_nodes = zip(\n                                *sorted(zip(allDists,\n                                            target_nodes),\n                                        key=itemgetter(0)))\n\n                    # the four closest nodes are the possible connections\n                    possible_connections = sorted_target_nodes[:4]\n                    # print info on verbose setting\n                    v_print(\"Possible connections: {}\".format(\n                                    [pc[0] for pc in possible_connections]))\n\n                    # handle edge case where there is no possible\n                    # connection or just one\n                    if len(possible_connections) == 0:\n                        # skip if there are no possible connections\n                        continue\n                    elif len(possible_connections) == 1:\n                        # attempt to connect to only possible candidate\n                        fCand = possible_connections[0]\n                        res = self.attempt_weft_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                        # set forbidden node\n                        if res:\n                            forbidden_node = fCand[0]\n                        continue\n\n                    # get the contours current direction\n                    if k < len(initial_nodes)-1:\n                        contourDir = RhinoLine(\n                                    thisPt,\n                                    initial_nodes[k+1][1][\"geo\"]).Direction\n                    elif k == len(initial_nodes)-1:\n                        contourDir = RhinoLine(\n                                initial_nodes[k-1][1][\"geo\"], thisPt).Direction\n                    contourDir.Unitize()\n\n                    # get the directions of the possible connections\n                    candidatePoints = [pc[1][\"geo\"]\n                                       for pc in possible_connections]\n                    candidateDirections = [RhinoLine(\n                            thisPt, cp).Direction for cp in candidatePoints]\n                    [cd.Unitize() for cd in candidateDirections]\n\n                    # get the angles between contour dir and possible conn dir\n                    normals = [RhinoVector3d.CrossProduct(\n                                contourDir, cd) for cd in candidateDirections]\n                    angles = [RhinoVector3d.VectorAngle(\n                              contourDir, cd, n) for cd, n in zip(\n                              candidateDirections, normals)]\n\n                    # compute deltas as a mesaure of perpendicularity\n                    deltas = [abs(a - (0.5 * pi)) for a in angles]\n\n                    # sort possible connections by distance, then by delta\n                    allDists, deltas, angles, most_perpendicular = zip(\n                            *sorted(zip(\n                                    allDists,\n                                    deltas,\n                                    angles,\n                                    possible_connections[:]),\n                                    key=itemgetter(0, 1)))\n\n                    # get node neighbors\n                    nNeighbors = self[node[0]]\n\n                    # compute angle difference\n                    aDelta = angles[0] - angles[1]\n\n                    # CONNECTION FOR LEAST ANGLE CHANGE -----------------------\n                    if len(nNeighbors) > 2 and aDelta < radians(6.0):\n                        # print info on verbose setting\n                        v_print(\"Using procedure for least angle \" +\n                                \"change connection...\")\n\n                        # get previous connected edge and its direction\n                        prevEdges = self.node_weft_edges(node[0], data=True)\n                        if len(prevEdges) > 1:\n                            raise KnitNetworkError(\n                                \"More than one previous 'weft' connection! \" +\n                                \"This was unexpeced...\")\n                            prevDir = prevEdges[0][2][\"geo\"].Direction\n                        else:\n                            prevDir = prevEdges[0][2][\"geo\"].Direction\n                        prevDir.Unitize()\n\n                        # get directions for the best two candidates\n                        mpA = most_perpendicular[0]\n                        mpB = most_perpendicular[1]\n                        dirA = RhinoLine(thisPt, mpA[1][\"geo\"]).Direction\n                        dirB = RhinoLine(thisPt, mpB[1][\"geo\"]).Direction\n                        dirA.Unitize()\n                        dirB.Unitize()\n\n                        # get normals for angle measurement\n                        normalA = RhinoVector3d.CrossProduct(prevDir, dirA)\n                        normalB = RhinoVector3d.CrossProduct(prevDir, dirB)\n\n                        # measure the angles\n                        angleA = RhinoVector3d.VectorAngle(\n                                                        prevDir,\n                                                        dirA,\n                                                        normalA)\n                        angleB = RhinoVector3d.VectorAngle(\n                                                        prevDir,\n                                                        dirB,\n                                                        normalB)\n\n                        # select final candidate for connection by angle\n                        if angleA < angleB:\n                            fCand = mpA\n                        else:\n                            fCand = mpB\n\n                        # attempt to connect to final candidate\n                        res = self.attempt_weft_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                        # set forbidden node for next pass\n                        if res:\n                            forbidden_node = fCand[0]\n\n                    # CONNECTION FOR MOST PERPENDICULAR --------------------\n                    else:\n                        # print info on verbose setting\n                        v_print(\"Using procedure for most \" +\n                                \"perpendicular connection...\")\n                        # define final candidate\n                        fCand = most_perpendicular[0]\n\n                        # attempt to connect to final candidate node\n                        res = self.attempt_weft_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                        # set forbidden node if connection has been made\n                        if res:\n                            forbidden_node = fCand[0]\n\n    def _create_second_pass_weft_connections(self,\n                                             contour_set,\n                                             include_leaves=False,\n                                             least_connected=False,\n                                             precise=False,\n                                             verbose=False):\n        \"\"\"\n        Private method for creating second pass 'weft' connections for the\n        given set of contours.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        v_print = print if verbose else lambda *a, **k: None\n\n        # get attributes only once\n        position_attributes = nx.get_node_attributes(self, \"position\")\n        num_attributes = nx.get_node_attributes(self, \"num\")\n\n        if len(contour_set) < 2:\n            v_print(\"Not enough contours in contour set!\")\n            return\n\n        # print info on verbose output\n        v_print(\"Creating second pass 'weft' connections for contour set...\")\n\n        # loop over all nodes of positions (list of lists of tuples)\n        for i, pos in enumerate(contour_set):\n\n            # get initial nodes\n            initial_nodes = contour_set[i]\n\n            # get target position candidates\n            if (i > 0 and i < len(contour_set)-1 and\n                    i != 0 and i != len(contour_set)-1):\n                target_positionA = contour_set[i-1][0][1][\"position\"]\n                target_positionB = contour_set[i+1][0][1][\"position\"]\n            elif i == 0:\n                target_positionA = None\n                target_positionB = contour_set[i+1][0][1][\"position\"]\n            elif i == len(contour_set)-1:\n                target_positionA = contour_set[i-1][0][1][\"position\"]\n                target_positionB = None\n\n            # loop through all nodes on current position\n            for k, node in enumerate(initial_nodes):\n                # print info on verbose setting\n                v_print(\n                    \"Processing node {} on position {}:\".format(\n                        node[0], node[1][\"position\"]))\n\n                # get connecting edges on target position\n                conWeftEdges = self.node_weft_edges(node[0], data=True)\n                conPos = []\n                if len(conWeftEdges) == 0 and verbose:\n                    # print info on verbose setting\n                    v_print(\"No previously connected weft edges...\")\n                for weftEdge in conWeftEdges:\n                    weftEdgeFrom = weftEdge[0]\n                    weftEdgeTo = weftEdge[1]\n                    if weftEdgeFrom != node[0]:\n                        posEdgeTarget = position_attributes[weftEdgeFrom]\n                    elif weftEdgeTo != node[0]:\n                        posEdgeTarget = position_attributes[weftEdgeTo]\n                    if posEdgeTarget not in conPos:\n                        conPos.append(posEdgeTarget)\n\n                # select target position and continue in edge case scenarios\n                target_positions = []\n                if target_positionA == None:\n                    if target_positionB in conPos:\n                        v_print(\"Node is connected. Skipping...\")\n                        continue\n                    target_positions.append(target_positionB)\n                elif target_positionB == None:\n                    if target_positionA in conPos:\n                        v_print(\"Node is connected. Skipping...\")\n                        continue\n                    target_positions.append(target_positionA)\n                elif ((target_positionA in conPos) and\n                      (target_positionB in conPos)):\n                    v_print(\"Node is connected. Skipping...\")\n                    continue\n                elif ((target_positionB in conPos) and\n                      (target_positionA not in conPos)):\n                    target_positions.append(target_positionA)\n                elif ((target_positionA in conPos) and\n                      (target_positionB not in conPos)):\n                    target_positions.append(target_positionB)\n                elif (target_positionA != None and\n                      target_positionB != None and len(conPos) == 0):\n                    target_positions = [target_positionA, target_positionB]\n\n                # print info on verbose setting\n                if verbose and len(target_positions) > 1:\n                    v_print(\"Two target positions: {}, {}\".format(\n                                                         *target_positions))\n                elif verbose and len(target_positions) == 1:\n                    v_print(\"Target position: {}\".format(target_positions[0]))\n\n                # skip if there are no target positions\n                if len(target_positions) == 0:\n                    v_print(\"No target position! Skipping...\")\n                    continue\n\n                # only proceed if there is a target position\n                for target_position in target_positions:\n                    # get target nodes\n                    target_nodes = self.nodes_on_position(\n                                                    target_position, True)\n\n                    # get the point geo of this node\n                    thisPt = node[1][\"geo\"]\n\n                    # get a window of possible connections on the target\n                    # position by looking for the previos node on this contour\n                    # connected to target position, then propagating along\n                    # the target position to the next node that is connected\n                    # to this position. these two nodes will define the window\n\n                    # NOTE: the current node should never have a connection\n                    # to target position (theoretically!), otherwise it should\n                    # have fallen through the checks by now\n\n                    # print info on verbose setting\n                    v_print(\"Target position is {}. \".format(target_position) +\n                            \"Computing window...\")\n\n                    # get the previous node on this contour\n                    prevNode = initial_nodes[k-1]\n\n                    # assume that the previous node has a connection\n                    prevCon = self.node_weft_edges(prevNode[0], data=True)\n\n                    # get possible connections from previous connection\n                    possible_connections = []\n                    for edge in prevCon:\n                        edgeFrom = edge[0]\n                        edgeTo = edge[1]\n                        if edgeFrom != prevNode[0]:\n                            prevNodeTargetPos = position_attributes[edgeFrom]\n                            prevNodeTargetIndex = num_attributes[edgeFrom]\n                        elif edgeTo != prevNode[0]:\n                            prevNodeTargetPos = position_attributes[edgeTo]\n                            prevNodeTargetIndex = num_attributes[edgeTo]\n                        if prevNodeTargetPos == target_position:\n                            possible_connections.append(\n                                           target_nodes[prevNodeTargetIndex])\n\n                    # the farthest connection of the previous node is the first\n                    # point for our window\n                    if len(possible_connections) > 1:\n                        possible_connections.sort(key=lambda x: x[1][\"num\"])\n                        possible_connections.reverse()\n                        start_of_window = possible_connections[0]\n                    elif len(possible_connections) == 1:\n                        start_of_window = possible_connections[0]\n                    elif len(possible_connections) == 0:\n                        # print info on verbose setting\n                        v_print(\"No possible connection, skipping...\")\n                        continue\n\n                    # get the next node on this pos that is\n                    # connected to target position\n                    if k < len(initial_nodes)-1:\n                        future_nodes = initial_nodes[k+1:]\n                        for futurenode in future_nodes:\n                            filteredWeftEdges = []\n                            futureWeftEdges = self.node_weft_edges(\n                                                futurenode[0], data=True)\n                            for futureweft in futureWeftEdges:\n                                fwn = (futureweft[1], self.node[futureweft[1]])\n                                fwn_pos = fwn[1][\"position\"]\n                                fwn_num = fwn[1][\"num\"]\n                                if (fwn_pos == target_position and\n                                        fwn_num == start_of_window[1][\"num\"]):\n                                    # if the start of the window is found,\n                                    # it is the only possible connection\n                                    filteredWeftEdges = [futureweft]\n                                    break\n                                if (fwn_pos == target_position and\n                                        fwn_num > start_of_window[1][\"num\"]):\n                                    filteredWeftEdges.append(futureweft)\n                                else:\n                                    continue\n                            if (not filteredWeftEdges or\n                                    len(filteredWeftEdges) == 0):\n                                end_of_window = None\n                                continue\n\n                            # sort the filtered weft edges based on the 'num'\n                            # attribute of their target node\n                            filteredWeftEdges.sort(\n                                        key=lambda x: self.node[x[1]][\"num\"])\n\n                            # get the end of the window from the first edge on\n                            # the target position\n                            end_of_window = (\n                                        filteredWeftEdges[0][1],\n                                        self.node[filteredWeftEdges[0][1]])\n\n                            break\n                    else:\n                        end_of_window = None\n\n                    # define the window\n                    if end_of_window == None:\n                        window = [start_of_window]\n                    elif end_of_window == start_of_window:\n                        window = [start_of_window]\n                    else:\n                        window = [(n, d) for n, d\n                                  in self.nodes_iter(data=True)\n                                  if n >= start_of_window[0]\n                                  and n <= end_of_window[0]]\n\n                    if len(window) == 0:\n                        # print info on verbose setting\n                        v_print(\"Length of window is 0, skipping...\")\n                    elif len(window) == 1:\n                        # print info on verbose setting\n                        v_print(\"Window has only one node.\")\n                        v_print(\"Connecting to node {}\".format(window[0][0]) +\n                                \" on position {}...\".format(\n                                                    window[0][1][\"position\"]))\n\n                        # connect weft edge\n                        if node[1][\"position\"] < window[0][1][\"position\"]:\n                            self.create_weft_edge(node, window[0])\n                        else:\n                            self.create_weft_edge(window[0], node)\n                    else:\n                        # print info on verbose setting\n                        v_print(\"Processing window nodes: {}\".format(\n                                                    [w[0] for w in window]))\n\n                        # sort nodes in window by distance\n                        if precise:\n                            allDists = [thisPt.DistanceTo(pc[1][\"geo\"])\n                                        for pc in window]\n                        else:\n                            allDists = [thisPt.DistanceToSquared(pc[1][\"geo\"])\n                                        for pc in window]\n                        allDists, window = zip(*sorted(zip(allDists, window),\n                                               key=itemgetter(0)))\n\n                        if least_connected:\n                            wn_count = [len(self[n[0]]) for n in window]\n                            wn_count, allDists, window = zip(\n                                    *sorted(zip(allDists, wn_count, window),\n                                            key=itemgetter(0, 1)))\n                            # set final candidate node\n                            fCand = window[0]\n                        else:\n                            # get the contours current direction\n                            if k < len(initial_nodes)-1:\n                                contourDir = RhinoLine(\n                                        thisPt,\n                                        initial_nodes[k+1][1][\"geo\"]).Direction\n                            elif k == len(initial_nodes)-1:\n                                contourDir = RhinoLine(\n                                        initial_nodes[k-1][1][\"geo\"],\n                                        thisPt).Direction\n                            contourDir.Unitize()\n\n                            # get the directions of the possible connections\n                            candidatePoints = [pc[1][\"geo\"]\n                                               for pc in window]\n                            candidateDirections = [\n                                RhinoLine(thisPt, cp).Direction\n                                for cp in candidatePoints]\n                            [cd.Unitize() for cd in candidateDirections]\n\n                            # get the angles between contour dir and window dir\n                            normals = [RhinoVector3d.CrossProduct(\n                                       contourDir, cd)\n                                       for cd in candidateDirections]\n                            angles = [RhinoVector3d.VectorAngle(\n                                      contourDir, cd, n) for cd, n in zip(\n                                                candidateDirections, normals)]\n\n                            # compute deltas as a mesaure of perpendicularity\n                            deltas = [abs(a - (0.5 * pi)) for a in angles]\n\n                            # sort window by distance, then by delta\n                            allDists, deltas, most_perpendicular = zip(*sorted(\n                                        zip(allDists,\n                                            deltas,\n                                            window),\n                                        key=itemgetter(0, 1)))\n                            # set final candidate node for connection\n                            fCand = most_perpendicular[0]\n\n                        # print info on verbose setting\n                        v_print(\"Connecting to node \" +\n                                \"{} on position {}...\".format(\n                                                        fCand[0],\n                                                        fCand[1][\"position\"]))\n\n                        # connect weft edge to best target\n                        if node[1][\"position\"] < fCand[1][\"position\"]:\n                            self.create_weft_edge(node, fCand)\n                        else:\n                            self.create_weft_edge(fCand, node)\n\n    def initialize_weft_edges(self,\n                              start_index=None,\n                              propagate_from_center=False,\n                              force_continuous_start=False,\n                              force_continuous_end=False,\n                              angle_threshold=radians(6.0),\n                              max_connections=4,\n                              least_connected=False,\n                              precise=False,\n                              verbose=False):\n        \"\"\"\n        Attempts to create all the preliminary 'weft' connections for the\n        network.\n\n        Parameters\n        ----------\n        start_index : int, optional\n            This value defines at which index the list of contours is split.\n            If no index is supplied, will split the list at the longest\n            contour.\n\n            Defaults to ``None``.\n\n        propagate_from_center : bool, optional\n            If ``True``, will propagate left and right set of contours from\n            the center contour defined by start_index or the longest contour\n            ( < | > ). Otherwise, the propagation of the contours left to the\n            center will start at the left boundary ( > | > ).\n\n            Defaults to ``False``\n\n        force_continuous_start : bool, optional\n            If ``True``, forces the first row of stitches to be continuous.\n\n            Defaults to ``False``.\n\n        force_continuous_end : bool, optional\n            If ``True``, forces the last row of stitches to be continuous.\n\n            Defaults to ``False``.\n\n        max_connections : int, optional\n            The maximum connections a node is allowed to have to be considered\n            for an additional 'weft' connection.\n\n            Defaults to ``4``.\n\n        least_connected : bool, optional\n            If ``True``, uses the least connected node from the found\n            candidates.\n\n            Defaults to ``False``\n\n        precise : bool, optional\n            If ``True``, the distance between nodes will be calculated using\n            the Rhino.Geometry.Point3d.DistanceTo method, otherwise the much\n            faster Rhino.Geometry.Point3d.DistanceToSquared method is used.\n\n            Defaults to ``False``.\n\n        verbose : bool, optional\n            If ``True``, this routine and all its subroutines will print\n            messages about what is happening to the console. Great for\n            debugging and analysis.\n\n            Defaults to ``False``.\n\n        Raises\n        ------\n        KnitNetworkError\n            If the supplied splitting index is too high.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # get all the positions / contours\n        AllPositions = self.all_nodes_by_position(data=True)\n\n        if start_index == None:\n            # get index of longest contour\n            start_index = self.longest_position_contour()[0]\n        elif start_index >= len(AllPositions):\n            raise KnitNetworkError(\"Supplied splitting index is too high!\")\n\n        # if continuous start is True, connect the whole first row\n        if force_continuous_start:\n            chain = [pos[1] for pos in AllPositions]\n            for pair in pairwise(chain):\n                self.create_weft_edge(pair[0], pair[1])\n        # if continuous end is True, connect the whole last row\n        if force_continuous_end:\n            chain = [pos[-2] for pos in AllPositions]\n            for pair in pairwise(chain):\n                self.create_weft_edge(pair[0], pair[1])\n\n        # split position list into two sets based on start index\n        leftContours = AllPositions[0:start_index+1]\n        # optional propagation from center\n        # NOTE: this has shown problems / weird stitch geometries\n        if propagate_from_center:\n            leftContours.reverse()\n\n        rightContours = AllPositions[start_index:]\n\n        # create the initial weft connections\n        self._create_initial_weft_connections(\n                            leftContours,\n                            force_continuous_start=force_continuous_start,\n                            force_continuous_end=force_continuous_end,\n                            max_connections=max_connections,\n                            precise=precise,\n                            verbose=verbose)\n\n        self._create_initial_weft_connections(\n                            rightContours,\n                            force_continuous_start=force_continuous_start,\n                            force_continuous_end=force_continuous_end,\n                            max_connections=max_connections,\n                            precise=precise,\n                            verbose=verbose)\n\n        # create second pass weft connections\n        self._create_second_pass_weft_connections(\n                                            leftContours,\n                                            least_connected,\n                                            precise=precise,\n                                            verbose=verbose)\n\n        self._create_second_pass_weft_connections(\n                                            rightContours,\n                                            least_connected,\n                                            precise=precise,\n                                            verbose=verbose)\n\n        return True\n\n    # INITIALIZATION OF PRELIMINARY 'WARP' EDGES ------------------------------\n\n    def initialize_warp_edges(self, contour_set=None, verbose=False):\n        \"\"\"\n        Method for initializing first 'warp' connections once all preliminary\n        'weft' connections are made.\n\n        Parameters\n        ----------\n        contour_set : :obj:`list`, optional\n            List of lists of nodes to initialize 'warp' edges. If none are\n            supplied, all nodes ordered by thei 'position' attributes are\n            used.\n\n            Defaults to ``None``.\n\n        verbose : bool, optional\n            If ``True``, will print verbose output to the console.\n\n            Defaults to ``False``.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # if no contour set is provided, use all contours of this network\n        if contour_set == None:\n            contour_set = self.all_nodes_by_position(data=True)\n\n        # loop through all positions in the set of contours\n        for i, pos in enumerate(contour_set):\n            # get all nodes on current contour\n            initial_nodes = contour_set[i]\n\n            # loop through all nodes on this contour\n            for k, node in enumerate(initial_nodes):\n                connected_edges = self.edges(node[0], data=True)\n                numweft = len(self.node_weft_edges(node[0]))\n                if (len(connected_edges) > 4 or numweft > 2\n                        or i == 0 or i == len(contour_set)-1):\n                    # set 'end' attribute for this node\n                    self.node[node[0]][\"end\"] = True\n\n                    # loop through all candidate edges\n                    for j, edge in enumerate(connected_edges):\n                        # if it's not a 'weft' edge, assign attributes\n                        if not edge[2][\"weft\"]:\n                            connected_node = edge[1]\n                            # set 'end' attribute to conneted node\n                            self.node[connected_node][\"end\"] = True\n                            # set 'warp' attribute to current edge\n                            self[edge[0]][edge[1]][\"warp\"] = True\n\n    # ASSIGNING OF 'SEGMENT' ATTRIBUTES FOR MAPPING NETWORK -------------------\n\n    def _traverse_weft_edge_until_end(self, start_end_node, start_node,\n                                      seen_segments, way_nodes=None,\n                                      way_edges=None, end_nodes=None):\n        \"\"\"\n        Private method for traversing a path of 'weft' edges until another\n        'end' node is discoverd.\n        \"\"\"\n\n        # initialize output lists\n        if way_nodes == None:\n            way_nodes = deque()\n            way_nodes.append(start_node[0])\n        if way_edges == None:\n            way_edges = deque()\n        if end_nodes == None:\n            end_nodes = deque()\n\n        # get the connected edges and filter them, sort out the ones that\n        # already have a 'segment' attribute assigned\n        connected_weft_edges = self.node_weft_edges(start_node[0], data=True)\n        filtered_weft_edges = []\n        for cwe in connected_weft_edges:\n            if cwe[2][\"segment\"] != None:\n                continue\n            if cwe in way_edges:\n                continue\n            elif (cwe[1], cwe[0], cwe[2]) in way_edges:\n                continue\n            filtered_weft_edges.append(cwe)\n\n        if len(filtered_weft_edges) > 1:\n            print(filtered_weft_edges)\n            print(\"More than one filtered candidate weft edge! \" +\n                  \"Segment complete...?\")\n        elif len(filtered_weft_edges) == 1:\n            fwec = filtered_weft_edges[0]\n            connected_node = (fwec[1], self.node[fwec[1]])\n\n            # if the connected node is an end node, the segment is finished\n            if connected_node[1][\"end\"]:\n                # find out which order to set segment attributes\n                if start_end_node > connected_node[0]:\n                    segStart = connected_node[0]\n                    segEnd = start_end_node\n                else:\n                    segStart = start_end_node\n                    segEnd = connected_node[0]\n                if (segStart, segEnd) in seen_segments:\n                    segIndex = len([s for s in seen_segments\n                                    if s == (segStart, segEnd)])\n                else:\n                    segIndex = 0\n                # append the relevant data to the lists\n                end_nodes.append(connected_node[0])\n                way_edges.append(fwec)\n                seen_segments.append((segStart, segEnd))\n                # set final 'segment' attributes to all the way nodes\n                for waynode in way_nodes:\n                    self.node[waynode][\"segment\"] = (segStart,\n                                                     segEnd,\n                                                     segIndex)\n                # set final 'segment' attributes to all the way edges\n                for wayedge in way_edges:\n                    self[wayedge[0]][wayedge[1]][\"segment\"] = (segStart,\n                                                               segEnd,\n                                                               segIndex)\n                # return the seen segments\n                return seen_segments\n            else:\n                # set the initial segment attribute to the node\n                self.node[connected_node[0]][\"segment\"] = (start_end_node,\n                                                           None,\n                                                           None)\n\n                # set the initial segment attribute to the edge\n                self[fwec[0]][fwec[1]][\"segment\"] = (start_end_node,\n                                                     None,\n                                                     None)\n                # append the relevant data to the lists\n                way_nodes.append(connected_node[0])\n                way_edges.append(fwec)\n\n                # call this method recursively until a 'end' node is found\n                return self._traverse_weft_edge_until_end(\n                                                    start_end_node,\n                                                    connected_node,\n                                                    seen_segments,\n                                                    way_nodes,\n                                                    way_edges,\n                                                    end_nodes)\n        else:\n            return seen_segments\n\n    def traverse_weft_edges_and_set_attributes(self, start_end_node):\n        \"\"\"\n        Traverse a path of 'weft' edges starting from an 'end' node until\n        another 'end' node is discovered. Set 'segment' attributes to nodes\n        and edges along the way.\n\n        start_end_node : :obj:`tuple`\n            2-tuple representing the node to start the traversal.\n        \"\"\"\n\n        # get connected weft edges and sort them by their connected node\n        weft_connections = self.node_weft_edges(start_end_node[0], data=True)\n        weft_connections.sort(key=lambda x: x[1])\n\n        # loop through all connected weft edges\n        seen_segments = []\n        for cwe in weft_connections:\n            # check if connected weft edge already has a segment attribute\n            if cwe[2][\"segment\"]:\n                continue\n\n            # get connected node\n            connected_node = (cwe[1], self.node[cwe[1]])\n\n            # check the connected node. if it is an end node, we are done\n            if connected_node[1][\"end\"]:\n                # get segment start and end\n                if start_end_node[0] > connected_node[0]:\n                    segStart = connected_node[0]\n                    segEnd = start_end_node[0]\n                else:\n                    segStart = start_end_node[0]\n                    segEnd = connected_node[0]\n\n                # get segment index\n                if (segStart, segEnd) in seen_segments:\n                    segIndex = len([s for s in seen_segments\n                                    if s == (segStart, segEnd)])\n                else:\n                    segIndex = 0\n\n                # set the final segment attribute to the edge\n                self[cwe[0]][cwe[1]][\"segment\"] = (segStart, segEnd, segIndex)\n                seen_segments.append((segStart, segEnd))\n\n            # if the connected node is not an end node, we need to travel\n            # until we find one\n            else:\n                seen_segments = self._traverse_weft_edge_until_end(\n                                                        start_end_node[0],\n                                                        connected_node,\n                                                        seen_segments,\n                                                        way_edges=[cwe])\n\n    def assign_segment_attributes(self):\n        \"\"\"\n        Get the segmentation for loop generation and assign 'segment'\n        attributes to 'weft' edges and nodes.\n        \"\"\"\n\n        if len(self.weft_edges) == 0:\n            errMsg = (\"No 'weft' edges in KnitNetwork! Segmentation \" +\n                      \"is impossible.\")\n            raise NoWeftEdgesError(errMsg)\n        if len(self.end_nodes) == 0:\n            errMsg = (\"No 'end' nodes in KnitNetwork! Segmentation \" +\n                      \"is impossible.\")\n            raise NoEndNodesError(errMsg)\n\n        # remove contour and 'warp' edges and store them\n        warp_storage = []\n        contour_storage = []\n        for edge in self.edges(data=True):\n            if not edge[2][\"weft\"]:\n                if edge[2][\"warp\"]:\n                    warp_storage.append(edge)\n                else:\n                    contour_storage.append(edge)\n                self.remove_edge(edge[0], edge[1])\n\n        # get all 'end' nodes ordered by their 'position' attribute\n        all_ends_by_position = self.all_ends_by_position(data=True)\n\n        # loop through all 'end' nodes\n        for position in all_ends_by_position:\n            for endnode in position:\n                self.traverse_weft_edges_and_set_attributes(endnode)\n\n        # add all previously removed edges back into the network\n        [self.add_edge(edge[0], edge[1], attr_dict=edge[2])\n         for edge in warp_storage + contour_storage]\n\n    # CREATION OF MAPPING NETWORK ---------------------------------------------\n\n    def create_mapping_network(self):\n        \"\"\"\n        Creates the corresponding mapping network for the final loop generation\n        from a KnitNetwork instance with fully assigned 'segment' attributes.\n\n        The created mapping network will be part of the KnitNetwork instance.\n        It can be accessed using the mapping_network property.\n\n        Notes\n        -----\n        All nodes without an 'end' attribute as well as all 'weft' edges are\n        removed by this step. Final nodes as well as final 'weft' and 'warp'\n        edges can only be created using the mapping network.\n\n        Returns\n        -------\n        success : bool\n            ``True`` if the mapping network has been successfully created,\n            ``False`` otherwise.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # create a new KnitMappingNetwork instance\n        MappingNetwork = KnitMappingNetwork()\n\n        # get all edges of the current network by segment\n        weft_edges = sorted(self.weft_edges, key=lambda x: x[2][\"segment\"])\n        warp_edges = self.warp_edges\n\n        # initialize deque container for segment ids\n        segment_ids = deque()\n\n        # loop through all 'weft' edges and fill container with unique ids\n        for edge in weft_edges:\n            segment_id = edge[2][\"segment\"]\n            if segment_id not in segment_ids:\n                segment_ids.append(segment_id)\n\n        # error checking\n        if len(segment_ids) == 0:\n            errMsg = (\n                    \"The network contains no 'weft' edges with a 'segment' \" +\n                    \"attribute assigned to them. A KnitMappingNetwork can \" +\n                    \"only be created from a KnitNetwork with initialized \" +\n                    \"'weft' edges for courses and corresponding 'warp' \" +\n                    \"edges connecting their 'end' nodes.\")\n            raise NoWeftEdgesError(errMsg)\n\n        # loop through all unique segment ids\n        for id in segment_ids:\n            # get the corresponding edges for this id and sort them\n            segment_edges = [e for e in weft_edges if e[2][\"segment\"] == id]\n            segment_edges.sort(key=lambda x: x[0])\n            # extract start and end nodes\n            start_node = (id[0], self.node[id[0]])\n            endNode = (id[1], self.node[id[1]])\n            # get all the geometry of the individual edges\n            segment_geo = [e[2][\"geo\"] for e in segment_edges]\n            # create a segment contour edge in the mapping network\n            res = MappingNetwork.create_segment_contour_edge(\n                                                        start_node,\n                                                        endNode,\n                                                        id,\n                                                        segment_geo)\n            if not res:\n                errMsg = (\"SegmentContourEdge at segment id {} could not be \" +\n                          \"created!\")\n                raise KnitNetworkError(errMsg)\n\n        # add all warp edges to the mapping network to avoid lookup hassle\n        for warp_edge in warp_edges:\n            if warp_edge[0] > warp_edge[1]:\n                warp_from = warp_edge[1]\n                warp_to = warp_edge[0]\n            else:\n                warp_from = warp_edge[0]\n                warp_to = warp_edge[1]\n            MappingNetwork.add_edge(warp_from, warp_to, attr_dict=warp_edge[2])\n\n        # set mapping network property for this instance\n        self.mapping_network = MappingNetwork\n\n        # ditch all edges that are not 'warp' and nodes without 'end' attribute\n        [self.remove_node(n) for n, d in self.nodes_iter(data=True)\n         if not d[\"end\"]]\n        [self.remove_edge(s, e) for s, e, d in self.edges_iter(data=True)\n         if not d[\"warp\"]]\n\n        return True\n\n    # MAPPING NETWORK PROPERTY ------------------------------------------------\n\n    def _get_mapping_network(self):\n        \"\"\"\n        Gets the associated mapping network for this KnitNetwork instance.\n        \"\"\"\n\n        return self._mapping_network\n\n    def _set_mapping_network(self, mapping_network):\n        \"\"\"\n        Setter for this instance's associated mapping network.\n        \"\"\"\n\n        # set mapping network to instance\n        if (isinstance(mapping_network, KnitMappingNetwork)\n                or mapping_network == None):\n            self._mapping_network = mapping_network\n        else:\n            raise ValueError(\"Input is not of type KnitMappingNetwork!\")\n\n    mapping_network = property(_get_mapping_network,\n                               _set_mapping_network,\n                               None,\n                               \"The associated mapping network of this \" +\n                               \"KnitNetwork instance.\")\n\n    # RETRIEVAL OF NODES AND EDGES FROM MAPPING NETWORK -----------------------\n\n    def all_nodes_by_segment(self, data=False, edges=False):\n        \"\"\"\n        Returns all nodes of the network ordered by 'segment' attribute.\n        Note: 'end' nodes are not included!\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, the nodes contained in the output will be represented\n            as 2-tuples in the form of (node_identifier, node_data).\n\n            Defaults to ``False``\n\n        edges : bool, optional\n            If ``True``, the returned output list will contain 3-tuples in the\n            form of (segment_value, segment_nodes, segment_edge).\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes_by_segment : :obj:`list` of :obj:`tuple`\n            List of 2-tuples in the form of (segment_value, segment_nodes) or\n            3-tuples in the form of (segment_value, segment_nodes,\n            segment_edge) depending on the ``edges`` argument.\n\n        Raises\n        ------\n        MappingNetworkError\n            If the mapping network is not available for this instance.\n        \"\"\"\n\n        # retrieve mappingnetwork\n        mapnet = self.mapping_network\n        if not mapnet:\n            errMsg = (\"Mapping network has not been built for this instance!\")\n            raise MappingNetworkError(errMsg)\n\n        allSegments = mapnet.segment_contour_edges\n        allSegmentNodes = [(n, d) for n, d\n                           in self.nodes_iter(data=True) if d[\"segment\"]]\n\n        segdict = {}\n        for n in allSegmentNodes:\n            if n[1][\"segment\"] not in segdict:\n                segdict[n[1][\"segment\"]] = [n]\n            else:\n                segdict[n[1][\"segment\"]].append(n)\n\n        anbs = []\n        if data and edges:\n            for segment in allSegments:\n                segval = segment[2][\"segment\"]\n                try:\n                    segnodes = sorted(segdict[segval])\n                except KeyError:\n                    segnodes = []\n                anbs.append((segval, segnodes, segment))\n        elif data and not edges:\n            for segment in allSegments:\n                segval = segment[2][\"segment\"]\n                try:\n                    segnodes = sorted(segdict[segval])\n                except KeyError:\n                    segnodes = []\n                anbs.append((segval, segnodes))\n        elif not data and edges:\n            for segment in allSegments:\n                segval = segment[2][\"segment\"]\n                try:\n                    segnodes = sorted(segdict[segval])\n                except KeyError:\n                    segnodes = []\n                anbs.append((segval, [sn[0] for sn in segnodes], segment))\n        elif not data and not edges:\n            for segment in allSegments:\n                segval = segment[2][\"segment\"]\n                try:\n                    segnodes = sorted(segdict[segval])\n                except KeyError:\n                    segnodes = []\n                anbs.append((segval, [sn[0] for sn in segnodes]))\n\n        return anbs\n\n    # STITCH WIDTH SAMPLING ---------------------------------------------------\n\n    def sample_segment_contours(self, stitch_width):\n        \"\"\"\n        Samples the segment contours of the mapping network with the given\n        stitch width. The resulting points are added to the network as nodes\n        and a 'segment' attribute is assigned to them based on their origin\n        segment contour edge.\n\n        Parameters\n        ----------\n\n        stitch_width : float\n            The width of a single stitch inside the knit.\n\n        Raises\n        ------\n        MappingNetworkError\n            If the mapping network is not available for this instance.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # retrieve mapping network\n        mapnet = self.mapping_network\n        if not mapnet:\n            errMsg = (\"Mapping network has not been built for this \" +\n                      \"instance, sampling segment contours is impossible!\")\n            raise MappingNetworkError(errMsg)\n\n        # get the highest index of all the nodes in the network\n        maxNode = max(self.nodes())\n\n        # get all the segment geometry ordered by segment number\n        segment_contours = mapnet.segment_contour_edges\n\n        # sample all segments with the stitch width\n        nodeindex = maxNode + 1\n        for i, seg in enumerate(segment_contours):\n            # get the geometry of the contour and reparametreize its domain\n            geo = seg[2][\"geo\"]\n            geo = geo.ToPolylineCurve()\n            geo.Domain = RhinoInterval(0.0, 1.0)\n\n            # compute the division points\n            crvlen = geo.GetLength()\n            density = int(round(crvlen / stitch_width))\n            if density == 0:\n                continue\n            divT = geo.DivideByCount(density, False)\n            divPts = [geo.PointAt(t) for t in divT]\n\n            # set leaf attribute\n            # TODO: better leaf strategy - this works but assigns false\n            # leaf nodes. usually not a problem but it should be fixed anyway\n            if self.node[seg[0]][\"leaf\"] and self.node[seg[1]][\"leaf\"]:\n                nodeLeaf = True\n            else:\n                nodeLeaf = False\n\n            # add all the nodes to the network\n            for j, pt in enumerate(divPts):\n                # add node to network\n                self.node_from_point3d(\n                                    nodeindex,\n                                    pt,\n                                    position=None,\n                                    num=j,\n                                    leaf=nodeLeaf,\n                                    start=False,\n                                    end=False,\n                                    segment=seg[2][\"segment\"],\n                                    increase=False,\n                                    decrease=False,\n                                    color=None)\n                # increment node index\n                nodeindex += 1\n\n    # CREATION OF FINAL 'WEFT' CONNECTIONS ------------------------------------\n\n    def create_final_weft_connections(self):\n        \"\"\"\n        Loop through all the segment contour edges and create all 'weft'\n        connections for this network.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # get all nodes by segment contour\n        SegmentValues, AllNodesBySegment = zip(*self.all_nodes_by_segment(\n                                                                    data=True))\n\n        # loop through all the segment contours\n        for i, segment in enumerate(AllNodesBySegment):\n            segval = SegmentValues[i]\n            firstNode = (segval[0], self.node[segval[0]])\n            lastNode = (segval[1], self.node[segval[1]])\n\n            if len(segment) == 0:\n                self.create_weft_edge(firstNode, lastNode, segval)\n            elif len(segment) == 1:\n                self.create_weft_edge(firstNode, segment[0], segval)\n                self.create_weft_edge(segment[0], lastNode, segval)\n            else:\n                # loop through all nodes on the current segment and create\n                # the final 'weft' edges\n                for j, node in enumerate(segment):\n                    if j == 0:\n                        self.create_weft_edge(firstNode, node, segval)\n                        self.create_weft_edge(node, segment[j+1], segval)\n                    elif j < len(segment)-1:\n                        self.create_weft_edge(node, segment[j+1], segval)\n                    elif j == len(segment)-1:\n                        self.create_weft_edge(node, lastNode, segval)\n\n    # CREATION OF FINAL 'WARP' CONNECTIONS ------------------------------------\n\n    def attempt_warp_connection(self, node, candidate, source_nodes,\n                                max_connections=4, verbose=False):\n        \"\"\"\n        Method for attempting a 'warp' connection to a candidate\n        node based on certain parameters.\n\n        Parameters\n        ----------\n        node : node\n            The starting node for the possible 'weft' edge.\n\n        candidate : node\n            The target node for the possible 'weft' edge.\n\n        source_nodes : :obj:`list`\n            List of nodes on the position contour of node. Used to check if\n            the candidate node already has a connection.\n\n        max_connections : int, optional\n            The new 'weft' connection will only be made if the candidate nodes\n            number of connected neighbors is below this.\n\n            Defaults to ``4``.\n\n        verbose : bool, optional\n            If ``True``, this routine and all its subroutines will print\n            messages about what is happening to the console.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        result : bool\n            True if the connection has been made, otherwise false.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        connecting_neighbors = self[candidate[0]]\n        if len(connecting_neighbors) < max_connections:\n            isConnected = False\n            for cn in connecting_neighbors:\n                if cn in [v[0] for v in source_nodes]:\n                    isConnected = True\n                    # print info on verbose setting\n                    v_print(\"Candidate node {} is \".format(candidate[0]) +\n                            \"already connected! Skipping to next node...\")\n                    break\n            if not isConnected:\n                # print info on verbose setting\n                v_print(\"Connecting node {} to best candidate {}.\".format(\n                                                                node[0],\n                                                                candidate[0]))\n                # finally create the warp edge for good\n                self.create_warp_edge(node, candidate)\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def _create_initial_warp_connections(self, segment_pair, max_connections=4,\n                                         precise=False, verbose=False):\n        \"\"\"\n        Private method for creating first pass 'warp' connections for the\n        supplied pair of segment chains.\n        The pair is only defined as a list of nodes, the nodes have to be\n        supplied with their attribute data!\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        if len(segment_pair) < 2:\n            v_print(\"Not enough contour segments in supplied set!\")\n            return\n\n        # print info on verbose output\n        v_print(\"Creating initial 'warp' connections for contour set...\")\n\n        # get initial and target nodes without 'end' nodes\n        initial_nodes = segment_pair[0]\n        target_nodes = segment_pair[1]\n\n        # define forbidden node index\n        forbidden_node = -1\n\n        # do nothing if one of the sets is empty\n        if len(initial_nodes) == 0 or len(target_nodes) == 0:\n            return\n\n        # loop through all nodes on the current segment\n        for k, node in enumerate(initial_nodes):\n            # get geometry from current node\n            thisPt = node[1][\"geo\"]\n\n            # print info on verbose setting\n            v_print(\"Processing node {} on segment {}:\".format(\n                                                        node[0],\n                                                        node[1][\"segment\"]))\n\n            # filtering according to forbidden nodes\n            if forbidden_node != -1:\n                target_nodes = [tnode for tx, tnode in enumerate(target_nodes)\n                                if tx >= target_nodes.index(forbidden_node)]\n            if len(target_nodes) == 0:\n                continue\n\n            # compute distances to target nodes\n            if precise:\n                allDists = [thisPt.DistanceTo(tn[1][\"geo\"])\n                            for tn in target_nodes]\n            else:\n                allDists = [thisPt.DistanceToSquared(tn[1][\"geo\"])\n                            for tn in target_nodes]\n\n            # sort nodes after distances\n            allDists, sorted_target_nodes = zip(*sorted(\n                                                zip(allDists, target_nodes),\n                                                key=itemgetter(0)))\n\n            # the four nearest nodes are the possible connections\n            possible_connections = sorted_target_nodes[:4]\n            # print info on verbose setting\n            v_print(\"Possible connections: {}\".format([pc[0] for pc in\n                                                       possible_connections]))\n\n            # handle edge case where there is no possible connection or just\n            # one\n            if len(possible_connections) == 0:\n                continue\n            elif len(possible_connections) == 1:\n                # attempt to connect to only possible candidate\n                fCand = possible_connections[0]\n                res = self.attempt_warp_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                # set forbidden node\n                if res:\n                    forbidden_node = fCand\n                continue\n\n            # get the segment contours current direction\n            if k < len(initial_nodes)-1:\n                contourDir = RhinoLine(thisPt,\n                                       initial_nodes[k+1][1][\"geo\"]).Direction\n            elif k == len(initial_nodes)-1:\n                contourDir = RhinoLine(\n                                initial_nodes[k-1][1][\"geo\"], thisPt).Direction\n            contourDir.Unitize()\n\n            # get the directions of the possible connections\n            candidatePoints = [pc[1][\"geo\"] for pc in possible_connections]\n            candidateDirections = [RhinoLine(\n                            thisPt, cp).Direction for cp in candidatePoints]\n            [cd.Unitize() for cd in candidateDirections]\n\n            # get the angles between segment contour dir and possible conn dir\n            normals = [RhinoVector3d.CrossProduct(\n                       contourDir, cd) for cd in candidateDirections]\n            angles = [RhinoVector3d.VectorAngle(\n                      contourDir, cd, n) for cd, n in zip(\n                      candidateDirections, normals)]\n\n            # compute deltas as a measure of perpendicularity\n            deltas = [abs(a - (0.5 * pi)) for a in angles]\n\n            # sort possible connections first by distance, then by delta\n            (allDists,\n             deltas,\n             angles,\n             most_perpendicular) = zip(*sorted(zip(allDists,\n                                                   deltas,\n                                                   angles,\n                                                   possible_connections[:]),\n                                               key=itemgetter(0, 1)))\n\n            # compute angle difference\n            aDelta = angles[0] - angles[1]\n\n            # get node neighbors\n            nNeighbors = self[node[0]]\n\n            # CONNECTION FOR LEAST ANGLE CHANGE -------------------------------\n            if len(nNeighbors) > 2 and aDelta < radians(6.0):\n                # print info on verbose setting\n                v_print(\"Using procedure for least angle \" +\n                        \"change connection...\")\n\n                # get previous connected edge and its direction\n                prevEdges = self.node_warp_edges(node[0], data=True)\n                if len(prevEdges) > 1:\n                    print(\"More than one previous \" +\n                          \"'warp' connection! This was unexpected...\" +\n                          \"Taking the first one..?\")\n                    prevDir = prevEdges[0][2][\"geo\"].Direction\n                else:\n                    prevDir = prevEdges[0][2][\"geo\"].Direction\n                prevDir.Unitize()\n\n                # get directions for the best two candidates\n                mpA = most_perpendicular[0]\n                mpB = most_perpendicular[1]\n                dirA = RhinoLine(thisPt, mpA[1][\"geo\"]).Direction\n                dirB = RhinoLine(thisPt, mpB[1][\"geo\"]).Direction\n                dirA.Unitize()\n                dirB.Unitize()\n\n                # get normals for angle measurement\n                normalA = RhinoVector3d.CrossProduct(prevDir, dirA)\n                normalB = RhinoVector3d.CrossProduct(prevDir, dirB)\n\n                # measure the angles\n                angleA = RhinoVector3d.VectorAngle(prevDir, dirA, normalA)\n                angleB = RhinoVector3d.VectorAngle(prevDir, dirB, normalB)\n\n                # select final candidate for connection\n                if angleA < angleB:\n                    fCand = mpA\n                else:\n                    fCand = mpB\n\n                # attempt connection to final candidate\n                res = self.attempt_warp_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                # set forbidden node\n                if res:\n                    forbidden_node = fCand\n                continue\n\n            # CONNECTION FOR MOST PERPENDICULAR -------------------------------\n            else:\n                # print info on verbose setting\n                v_print(\"Using procedure for most \" +\n                        \"perpendicular connection...\")\n                # define final candidate node\n                fCand = most_perpendicular[0]\n                # attempt connection to final candidate\n                res = self.attempt_warp_connection(\n                                            node,\n                                            fCand,\n                                            initial_nodes,\n                                            max_connections=max_connections,\n                                            verbose=verbose)\n                # set forbidden node\n                if res:\n                    forbidden_node = fCand\n\n    def _create_second_pass_warp_connection(self, source_nodes, source_index,\n                                            window, precise=False,\n                                            verbose=False, reverse=False):\n        \"\"\"\n        Private method for creating second pass 'warp' connections for the\n        given set of contours.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        if len(window) == 0:\n            # print info on verbose setting\n            v_print(\"Length of window is 0, skipping...\")\n        elif len(window) == 1:\n            # print info on verbose setting\n            v_print(\"Window has only one node.\")\n            v_print(\"Connecting to node {}.\".format(window[0][0]))\n\n            # connect 'warp' edge\n            if reverse:\n                self.create_warp_edge(window[0], source_nodes[source_index])\n            else:\n                self.create_warp_edge(source_nodes[source_index], window[0])\n        else:\n            # retrive the point of the current source node\n            thisPt = source_nodes[source_index][1][\"geo\"]\n\n            # print info on verbose setting\n            v_print(\"Processing window nodes: {}\".format(\n                                                    [w[0] for w in window]))\n\n            # sort nodes in window by distance\n            if precise:\n                allDists = [thisPt.DistanceTo(pc[1][\"geo\"])\n                            for pc in window]\n            else:\n                allDists = [thisPt.DistanceToSquared(pc[1][\"geo\"])\n                            for pc in window]\n            allDists, window = zip(*sorted(zip(allDists, window),\n                                   key=itemgetter(0)))\n\n            # get the contours current direction\n            if source_index < len(source_nodes)-1:\n                sourceDir = RhinoLine(\n                            thisPt,\n                            source_nodes[source_index+1][1][\"geo\"]).Direction\n            elif source_index == len(source_nodes)-1:\n                sourceDir = RhinoLine(source_nodes[source_index-1][1][\"geo\"],\n                                      thisPt).Direction\n            sourceDir.Unitize()\n\n            # get the directions of the possible connections\n            candidatePoints = [pc[1][\"geo\"] for pc in window]\n            candidateDirections = [RhinoLine(thisPt, cp).Direction for cp\n                                   in candidatePoints]\n            [cd.Unitize() for cd in candidateDirections]\n\n            # get the angles between contour dir and window dir\n            normals = [RhinoVector3d.CrossProduct(sourceDir, cd)\n                       for cd in candidateDirections]\n            angles = [RhinoVector3d.VectorAngle(sourceDir, cd, n) for cd, n\n                      in zip(candidateDirections, normals)]\n\n            # compute deltas as a mesaure of perpendicularity\n            deltas = [abs(a - (0.5 * pi)) for a in angles]\n\n            # sort window by distance, then by delta\n            allDists, deltas, most_perpendicular = zip(*sorted(\n                                                    zip(allDists,\n                                                        deltas,\n                                                        window),\n                                                    key=itemgetter(0, 1)))\n            # set final candidate node for connection\n            fCand = most_perpendicular[0]\n\n            # print info on verbose setting\n            v_print(\"Connecting to node \" +\n                    \"{} on segment {}...\".format(fCand[0],\n                                                 fCand[1][\"segment\"]))\n\n            # connect warp edge to best target\n            if reverse:\n                self.create_warp_edge(fCand, source_nodes[source_index])\n            else:\n                self.create_warp_edge(source_nodes[source_index], fCand)\n\n    def create_final_warp_connections(self, max_connections=4,\n                                      include_end_nodes=True, precise=False,\n                                      verbose=False):\n        \"\"\"\n        Create the final 'warp' connections by building chains of segment\n        contour edges and connecting them.\n\n        For each source chain, a target chain is found using an\n        'educated guessing' strategy. This means that the possible target\n        chains are guessed by leveraging known topology facts about the network\n        and its special 'end' nodes.\n\n        Parameters\n        ----------\n        max_connections : int, optional\n            The number of maximum previous connections a candidate node for a\n            'warp' connection is allowed to have.\n\n            Defaults to ``4``.\n\n        include_end_nodes : bool, optional\n            If ``True``, 'end' nodes between adjacent segment contours in a\n            source chain will be included in the first pass of connecting\n            'warp' edges.\n\n            Defaults to ``True``.\n\n        precise : bool\n            If ``True``, the distance between nodes will be calculated using\n            the Rhino.Geometry.Point3d.DistanceTo method, otherwise the much\n            faster Rhino.Geometry.Point3d.DistanceToSquared method is used.\n\n            Defaults to ``False``.\n\n        verbose : bool, optional\n            If ``True``, this routine and all its subroutines will print\n            messages about what is happening to the console. Great for\n            debugging and analysis.\n\n            Defaults to ``False``.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # define verbose print function\n        v_print = print if verbose else lambda *a, **k: None\n\n        # get all segment ids, nodes per segment and edges\n        SegmentValues, AllNodesBySegment, SegmentContourEdges = zip(\n                        *self.all_nodes_by_segment(data=True, edges=True))\n\n        # build a dictionary of the segments by their index\n        SegmentDict = dict(zip(SegmentValues,\n                               zip(SegmentContourEdges, AllNodesBySegment)))\n\n        # build source and target chains\n        source_chains, target_chain_dict = self.mapping_network.build_chains(\n                                                                    False,\n                                                                    True)\n\n        # initialize container dict for connected chains\n        connected_chains = dict()\n\n        # initialize segment mapping dictionaries\n        source_to_target = OrderedDict()\n        target_to_source = OrderedDict()\n\n        source_to_key = dict()\n        target_to_key = dict()\n\n        # ITERATE OVER SOURCE SEGMENT CHAINS ----------------------------------\n\n        # loop through all source chains and find targets in target chains\n        # using an 'educated guess strategy'\n        for i, source_chain in enumerate(source_chains):\n            # get the first and last node ('end' nodes)\n            firstNode = (source_chain[0][0][0],\n                         self.node[source_chain[0][0][0]])\n            lastNode = (source_chain[0][-1][1],\n                        self.node[source_chain[0][-1][1]])\n            # get the chain value of the current chain\n            chain_value = source_chain[1]\n            # extract the ids of the current chain\n            current_ids = tuple(source_chain[0])\n            # extract the current chains geometry\n            current_chain_geo_list = [SegmentDict[id][0][2][\"geo\"]\n                                      for id in current_ids]\n            current_chain_geo = RhinoCurve.JoinCurves(\n                [ccg.ToPolylineCurve() for ccg in current_chain_geo_list])[0]\n            current_chain_spt = current_chain_geo.PointAtNormalizedLength(0.5)\n            # retrieve the current segments from the segment dictionary by id\n            current_segment_nodes = [SegmentDict[id][1] for id in current_ids]\n            # retrieve the current nodes from the list of current segments\n            current_nodes = []\n            for j, csn in enumerate(current_segment_nodes):\n                if include_end_nodes and j > 0:\n                    current_nodes.append((current_ids[j][0],\n                                          self.node[current_ids[j][0]]))\n                [current_nodes.append(n) for n in csn]\n\n            # reset the target key\n            target_key = None\n\n            # print info on verbose setting\n            v_print(\"--------------------------------------------------------\")\n            v_print(\"Processing segment chain {} ...\".format(source_chain))\n\n            # CASE 1 - ENCLOSED SHORT ROW <====> ALL CASES --------------------\n\n            # look for possible targets using a guess about the chain value\n            possible_target_keys = [key for key in target_chain_dict\n                                    if key[0] == chain_value[0]\n                                    and key[1] == chain_value[1]\n                                    and key not in connected_chains]\n            if len(possible_target_keys) > 0:\n                # find the correct chain by using geometric distance\n                possible_target_chains = [target_chain_dict[tk] for tk\n                                          in possible_target_keys]\n                # for every chain in the possible target chains, get the\n                # geometry and compute a sample distance\n                filtered_target_keys = []\n                possible_target_chain_dists = []\n                for j, ptc in enumerate(possible_target_chains):\n                    # retrieve possible target geometry and join into one crv\n                    ptc_geo_list = [SegmentDict[id][0][2][\"geo\"] for id in ptc]\n                    if ptc_geo_list == current_chain_geo_list:\n                        continue\n                    ptc_geo = RhinoCurve.JoinCurves(\n                        [ptcg.ToPolylineCurve() for ptcg in ptc_geo_list])[0]\n                    # get a sample point and measure the distance to the\n                    # source chain sample point\n                    ptc_spt = ptc_geo.PointAtNormalizedLength(0.5)\n                    if precise:\n                        ptc_dist = current_chain_spt.DistanceTo(ptc_spt)\n                    else:\n                        ptc_dist = current_chain_spt.DistanceToSquared(ptc_spt)\n                    # append the filtered key to the key list\n                    filtered_target_keys.append(possible_target_keys[j])\n                    # append the measured distance to the distance list\n                    possible_target_chain_dists.append(ptc_dist)\n                if len(filtered_target_keys) > 0:\n                    # sort filtered target keys using the distances\n                    possible_target_chain_dists, filtered_target_keys = zip(\n                                    *sorted(zip(\n                                                possible_target_chain_dists,\n                                                filtered_target_keys),\n                                            key=itemgetter(0)))\n                    # set target key\n                    target_key = filtered_target_keys[0]\n                else:\n                    target_key = None\n            else:\n                target_key = None\n\n            # attempt warp connections if we have found a correct key\n            if target_key:\n                # get the guessed target chain from the chain dictionary\n                target_chain = target_chain_dict[target_key]\n                # extract the ids for node retrieval\n                target_ids = tuple([seg for seg in target_chain])\n                # retrieve the target nodes from the segment dictionary by id\n                target_segment_nodes = [SegmentDict[id][1]\n                                        for id in target_ids]\n                target_nodes = []\n                for j, tsn in enumerate(target_segment_nodes):\n                    if include_end_nodes and j > 0:\n                        target_nodes.append((\n                                target_ids[j][0], self.node[target_ids[j][0]]))\n                    [target_nodes.append(n) for n in tsn]\n\n                # print info on verbose setting\n                v_print(\"<=====> detected. Connecting to \" +\n                        \"segment chain {}.\".format(target_key))\n\n                # we have successfully verified our target segment and\n                # can create some warp edges!\n                segment_pair = [current_nodes, target_nodes]\n\n                # fill mapping dictionaries\n                if current_ids not in source_to_target:\n                    source_to_target[current_ids] = target_ids\n                if current_ids not in source_to_key:\n                    source_to_key[current_ids] = chain_value\n                if target_ids not in target_to_source:\n                    target_to_source[target_ids] = current_ids\n                if target_ids not in target_to_key:\n                    target_to_key[target_ids] = target_key\n\n                # create initial warp connections between the chains\n                connected_chains[target_key] = True\n                self._create_initial_warp_connections(\n                                            segment_pair,\n                                            max_connections=max_connections,\n                                            precise=precise,\n                                            verbose=verbose)\n                continue\n\n            # CASE 2 - SHORT ROW TO THE RIGHT <=====/ ALL CASES ---------------\n\n            # look for possible targets using a guess about the chain value\n            possible_target_keys = [key for key in target_chain_dict\n                                    if key[0] == chain_value[0]\n                                    and key[1] == chain_value[1]+1\n                                    and key not in connected_chains]\n            if len(possible_target_keys) == 1:\n                target_key = possible_target_keys[0]\n            elif len(possible_target_keys) > 1:\n                # find the correct chain by using geometric distance\n                possible_target_chains = [target_chain_dict[tk] for tk\n                                          in possible_target_keys]\n                # for every chain in the possible target chains, get the\n                # geometry and compute a sample distance\n                possible_target_chain_dists = []\n                for ptc in possible_target_chains:\n                    # retrieve possible target geometry and join into one crv\n                    ptc_geo = [SegmentDict[id][0][2][\"geo\"] for id in ptc]\n                    ptc_geo = RhinoCurve.JoinCurves([pg.ToPolylineCurve()\n                                                     for pg in ptc_geo])[0]\n                    # get a sample point and measure the distance to the\n                    # source chain sample point\n                    ptc_spt = ptc_geo.PointAtNormalizedLength(0.5)\n                    if precise:\n                        ptc_dist = current_chain_spt.DistanceTo(ptc_spt)\n                    else:\n                        ptc_dist = current_chain_spt.DistanceToSquared(ptc_spt)\n                    # append the measured distance to the list\n                    possible_target_chain_dists.append(ptc_dist)\n                # sort possible target keys using the distances\n                possible_target_chain_dists, possible_target_keys = zip(\n                                    *sorted(zip(possible_target_chain_dists,\n                                                possible_target_keys),\n                                            key=itemgetter(0)))\n                target_key = possible_target_keys[0]\n            else:\n                target_key = None\n\n            # attempt warp connections if we have found a correct key\n            if target_key:\n                # get the guessed target chain from the chain dictionary\n                target_chain = target_chain_dict[target_key]\n                # extract the ids for node retrieval\n                target_ids = tuple([seg for seg in target_chain])\n                # retrieve the target nodes from the segment dictionary by id\n                target_segment_nodes = [SegmentDict[id][1]\n                                        for id in target_ids]\n                target_nodes = []\n                for j, tsn in enumerate(target_segment_nodes):\n                    if include_end_nodes and j > 0:\n                        target_nodes.append((target_ids[j][0],\n                                             self.node[target_ids[j][0]]))\n                    [target_nodes.append(n) for n in tsn]\n\n                targetFirstNode = target_ids[0][0]\n                targetLastNode = target_ids[-1][1]\n\n                # check if firstNode and targetFirstNode are connected via a\n                # 'warp' edge to verify\n                if (targetFirstNode == firstNode[0]\n                        and targetLastNode in self[lastNode[0]]):\n                    # print info on verbose setting\n                    v_print(\"<=====/ detected. Connecting \" +\n                            \"to segment {}.\".format(target_key))\n                    # we have successfully verified our target segment and\n                    # can create some warp edges!\n                    segment_pair = [current_nodes, target_nodes]\n                    connected_chains[target_key] = True\n\n                    # fill mapping dictionaries\n                    if current_ids not in source_to_target:\n                        source_to_target[current_ids] = target_ids\n                    if current_ids not in source_to_key:\n                        source_to_key[current_ids] = chain_value\n                    if target_ids not in target_to_source:\n                        target_to_source[target_ids] = current_ids\n                    if target_ids not in target_to_key:\n                        target_to_key[target_ids] = target_key\n\n                    # create initial 'warp' connections between the chains\n                    self._create_initial_warp_connections(\n                                            segment_pair,\n                                            max_connections=max_connections,\n                                            precise=precise,\n                                            verbose=verbose)\n                    continue\n                else:\n                    v_print(\"No real connection for <=====/. Next case...\")\n\n            # CASE 3 - SHORT ROW TO THE LEFT /====> ALL CASES -----------------\n\n            # look for possible targets using a guess about the chain value\n            possible_target_keys = [key for key in target_chain_dict\n                                    if key[0] == chain_value[0]+1\n                                    and key[1] == chain_value[1]\n                                    and key not in connected_chains]\n            if len(possible_target_keys) == 1:\n                target_key = possible_target_keys[0]\n            elif len(possible_target_keys) > 1:\n                # find the correct chain by using geometric distance\n                possible_target_chains = [target_chain_dict[tk] for tk\n                                          in possible_target_keys]\n                # for every chain in the possible target chains, get the\n                # geometry and compute a sample distance\n                possible_target_chain_dists = []\n                for ptc in possible_target_chains:\n                    # retrieve possible target geometry and join into one crv\n                    ptc_geo = [SegmentDict[id][0][2][\"geo\"] for id in ptc]\n                    ptc_geo = RhinoCurve.JoinCurves(\n                        [pg.ToPolylineCurve() for pg in ptc_geo])[0]\n                    # get a sample point and measure the distance to the\n                    # source chain sample point\n                    ptc_spt = ptc_geo.PointAtNormalizedLength(0.5)\n                    if precise:\n                        ptc_dist = current_chain_spt.DistanceTo(ptc_spt)\n                    else:\n                        ptc_dist = current_chain_spt.DistanceToSquared(ptc_spt)\n                    # append the measured distance to the list\n                    possible_target_chain_dists.append(ptc_dist)\n                # sort possible target keys using the distances\n                possible_target_chain_dists, possible_target_keys = zip(\n                                    *sorted(zip(possible_target_chain_dists,\n                                                possible_target_keys),\n                                            key=itemgetter(0)))\n                target_key = possible_target_keys[0]\n            else:\n                target_key = None\n\n            # attempt warp connections if we have found a correct key\n            if target_key:\n                # get the guessed target chain from the chain dictionary\n                target_chain = target_chain_dict[target_key]\n                # extract the ids for node retrieval\n                target_ids = tuple([seg for seg in target_chain])\n                # retrieve the target nodes from the segment dictionary by id\n                target_segment_nodes = [SegmentDict[id][1]\n                                        for id in target_ids]\n                target_nodes = []\n                for j, tsn in enumerate(target_segment_nodes):\n                    if include_end_nodes and j > 0:\n                        target_nodes.append((target_ids[j][0],\n                                             self.node[target_ids[j][0]]))\n                    [target_nodes.append(n) for n in tsn]\n\n                targetFirstNode = target_ids[0][0]\n                targetLastNode = target_ids[-1][1]\n\n                # check if firstNode and targetFirstNode are connected via a\n                # 'warp' edge to verify\n                if (targetFirstNode in self[firstNode[0]]\n                        and targetLastNode == lastNode[0]):\n                    # print info on verbose setting\n                    v_print(\"/=====> detected. Connecting \" +\n                            \"to segment {}.\".format(target_key))\n                    # we have successfully verified our target segment and\n                    # can create some warp edges!\n                    segment_pair = [current_nodes, target_nodes]\n                    connected_chains[target_key] = True\n\n                    # fill mapping dictionaries\n                    if current_ids not in source_to_target:\n                        source_to_target[current_ids] = target_ids\n                    if current_ids not in source_to_key:\n                        source_to_key[current_ids] = chain_value\n                    if target_ids not in target_to_source:\n                        target_to_source[target_ids] = current_ids\n                    if target_ids not in target_to_key:\n                        target_to_key[target_ids] = target_key\n\n                    self._create_initial_warp_connections(\n                                            segment_pair,\n                                            max_connections=max_connections,\n                                            precise=precise,\n                                            verbose=verbose)\n                    continue\n                else:\n                    v_print(\"No real connection for /=====>. Next case...\")\n\n            # CASE 4 - REGULAR ROW /=====/ ALL CASES --------------------------\n\n            # look for possible targets using a guess about the chain value\n            possible_target_keys = [key for key in target_chain_dict\n                                    if key[0] == chain_value[0]+1\n                                    and key[1] == chain_value[1]+1\n                                    and key not in connected_chains]\n            if len(possible_target_keys) == 1:\n                target_key = possible_target_keys[0]\n            elif len(possible_target_keys) > 1:\n                # find the correct chain by using geometric distance\n                possible_target_chains = [target_chain_dict[tk] for tk\n                                          in possible_target_keys]\n                # for every chain in the possible target chains, get the\n                # geometry and compute a sample distance\n                possible_target_chain_dists = []\n                for ptc in possible_target_chains:\n                    # retrieve possible target geometry and join into one crv\n                    ptc_geo = [SegmentDict[id][0][2][\"geo\"] for id in ptc]\n                    ptc_geo = RhinoCurve.JoinCurves([pg.ToPolylineCurve()\n                                                     for pg in ptc_geo])[0]\n                    # get a sample point and measure the distance to the\n                    # source chain sample point\n                    ptc_spt = ptc_geo.PointAtNormalizedLength(0.5)\n                    if precise:\n                        ptc_dist = current_chain_spt.DistanceTo(ptc_spt)\n                    else:\n                        ptc_dist = current_chain_spt.DistanceToSquared(ptc_spt)\n                    # append the measured distance to the list\n                    possible_target_chain_dists.append(ptc_dist)\n                # sort possible target keys using the distances\n                possible_target_chain_dists, possible_target_keys = zip(\n                                    *sorted(zip(possible_target_chain_dists,\n                                                possible_target_keys),\n                                            key=itemgetter(0)))\n                target_key = possible_target_keys[0]\n            else:\n                target_key = None\n\n            # attempt warp connections if we have found a correct key\n            if target_key:\n                # get the guessed target chain from the chain dictionary\n                target_chain = target_chain_dict[target_key]\n                # extract the ids for node retrieval\n                target_ids = tuple([seg for seg in target_chain])\n                # retrieve the target nodes from the segment dictionary by id\n                target_segment_nodes = [SegmentDict[id][1]\n                                        for id in target_ids]\n                target_nodes = []\n                for j, tsn in enumerate(target_segment_nodes):\n                    if include_end_nodes and j > 0:\n                        target_nodes.append((target_ids[j][0],\n                                             self.node[target_ids[j][0]]))\n                    [target_nodes.append(n) for n in tsn]\n\n                # set target first and last node ('end' nodes)\n                targetFirstNode = target_ids[0][0]\n                targetLastNode = target_ids[-1][1]\n\n                # check if firstNode and targetFirstNode are connected via a\n                # 'warp' edge to verify\n                if (targetFirstNode in self[firstNode[0]]\n                        and targetLastNode in self[lastNode[0]]):\n                    # print info on verbose setting\n                    v_print(\"/=====/ detected. Connecting \" +\n                            \"to segment {}.\".format(target_key))\n                    # we have successfully verified our target segment and\n                    # can create some warp edges!\n                    segment_pair = [current_nodes, target_nodes]\n                    connected_chains[target_key] = True\n\n                    # fill mapping dictionaries\n                    if current_ids not in source_to_target:\n                        source_to_target[current_ids] = target_ids\n                    if current_ids not in source_to_key:\n                        source_to_key[current_ids] = chain_value\n                    if target_ids not in target_to_source:\n                        target_to_source[target_ids] = current_ids\n                    if target_ids not in target_to_key:\n                        target_to_key[target_ids] = target_key\n\n                    self._create_initial_warp_connections(\n                                            segment_pair,\n                                            max_connections=max_connections,\n                                            precise=precise,\n                                            verbose=verbose)\n                    continue\n                else:\n                    v_print(\"No real connection for /=====/. No cases match.\")\n\n        # INVOKE SECOND PASS FOR SOURCE ---> TARGET ---------------------------\n        for i, current_chain in enumerate(source_to_target):\n            v_print(\"--------------------------------------------------------\")\n            v_print(\"S>T Current Chain: {}\".format(current_chain))\n            # build a list of nodes containing all nodes in the current chain\n            # including all 'end' nodes\n            current_chain_nodes = []\n            for j, ccid in enumerate(current_chain):\n                current_chain_nodes.append((ccid[0], self.node[ccid[0]]))\n                [current_chain_nodes.append(n) for n in SegmentDict[ccid][1]]\n            current_chain_nodes.append((current_chain[-1][1],\n                                        self.node[current_chain[-1][1]]))\n\n            # retrieve target chain from the source to target mapping\n            target_chain = source_to_target[current_chain]\n\n            cckey = source_to_key[current_chain]\n            tckey = target_to_key[target_chain]\n\n            # build a list of nodes containing all nodes in the target chain\n            # including all 'end' nodes\n            target_chain_nodes = []\n            for j, tcid in enumerate(target_chain):\n                target_chain_nodes.append((tcid[0], self.node[tcid[0]]))\n                [target_chain_nodes.append(n) for n in SegmentDict[tcid][1]]\n            target_chain_nodes.append((target_chain[-1][1],\n                                       self.node[target_chain[-1][1]]))\n\n            # initialize start of window marker\n            start_of_window = -1\n\n            # loop through all nodes on the current chain\n            for k, node in enumerate(current_chain_nodes):\n                # find out if the current node is already principally connected\n                node_connected = False\n                # if the node is the first or the last node, it is defined as\n                # connected per-se\n                if k == 0 or k == len(current_chain_nodes)-1:\n                    node_connected = True\n\n                # find out if the current node is already connected to the\n                # target chain, get node warp edges and their target nodes\n                node_warp_edges = self.node_warp_edges(node[0], data=False)\n                warp_edge_targets = [we[1] for we in node_warp_edges]\n                # loop over warp edge targets to get the start of the window\n                for wet in warp_edge_targets:\n                    # loop over target chain nodes\n                    for n, tcn in enumerate(target_chain_nodes):\n                        # if a warp edge target is in the target chain,\n                        # the node is connected and star of window for next\n                        # node is defined\n                        if wet == tcn[0]:\n                            if n > start_of_window or start_of_window == -1:\n                                start_of_window = n\n                            node_connected = True\n\n                # if the node is not connected to the target chain, we\n                # need to find the end of the window\n                if not node_connected:\n                    v_print(\"Node: {}\".format(node[0]))\n                    v_print(\"Start of window: {}\".format(start_of_window))\n\n                    # re-check start of window for <.====/ case\n                    if len(target_chain_nodes) >= 2 and start_of_window == -1:\n                        if target_chain_nodes[0] == current_chain_nodes[0]:\n                            start_of_window = 1\n                        else:\n                            start_of_window = 0\n\n                    end_of_window = None\n                    # loop over target chain nodes\n                    for n, tcn in enumerate(target_chain_nodes):\n                        if n >= start_of_window:\n                            if tcn[0] == current_chain_nodes[-1][0]:\n                                end_of_window = n\n                            # get all warp edges of the current target node\n                            # and their targets\n                            tcn_warp_edges = self.node_warp_edges(tcn[0],\n                                                                  data=False)\n                            tcn_warp_edge_targets = [we[1] for we\n                                                     in tcn_warp_edges]\n                            # loop over warp edge targets\n                            for twet in tcn_warp_edge_targets:\n                                if (twet in [cn[0] for cn\n                                             in current_chain_nodes]):\n                                    end_of_window = n\n                                    break\n                        if end_of_window and end_of_window > start_of_window:\n                            break\n\n                    # re-check end of window for /====.> case\n                    if end_of_window:\n                        tcn_we = target_chain_nodes[end_of_window]\n                        ccn_end = current_chain_nodes[-1]\n                        ccn_len = len(current_chain_nodes)\n                        if tcn_we == ccn_end and k == ccn_len-2:\n                            end_of_window -= 1\n                    if end_of_window < start_of_window:\n                        start_of_window = -1\n                        end_of_window = None\n\n                    # if we have a valid window, set the target nodes\n                    if start_of_window != -1 and end_of_window != None:\n                        if end_of_window == len(target_chain_nodes)-1:\n                            window = target_chain_nodes[start_of_window:]\n                        else:\n                            window = target_chain_nodes[start_of_window:\n                                                        end_of_window+1]\n\n                        v_print(\"End of window: {}\".format(end_of_window))\n\n                        # execute connection to target\n                        if cckey <= tckey:\n                            rev = False\n                        else:\n                            rev = True\n\n                        v_print(\"Connecting chain {} to chain {}\".format(\n                                                                    cckey,\n                                                                    tckey))\n\n                        self._create_second_pass_warp_connection(\n                                                        current_chain_nodes,\n                                                        k,\n                                                        window,\n                                                        precise=precise,\n                                                        verbose=verbose,\n                                                        reverse=rev)\n                    else:\n                        # print info on verbose setting\n                        v_print(\"No valid window for current chain!\")\n\n        # INVOKE SECOND PASS FOR TARGET ---> SOURCE ---------------------------\n        for i, current_chain in enumerate(target_to_source):\n            v_print(\"--------------------------------------------------------\")\n            v_print(\"T>S Current Chain: {}\".format(current_chain))\n\n            # build a list of nodes containing all nodes in the current chain\n            # including all 'end' nodes\n            current_chain_nodes = []\n            for j, ccid in enumerate(current_chain):\n                current_chain_nodes.append((ccid[0], self.node[ccid[0]]))\n                [current_chain_nodes.append(n) for n in SegmentDict[ccid][1]]\n            current_chain_nodes.append((current_chain[-1][1],\n                                        self.node[current_chain[-1][1]]))\n\n            # retrieve target chain from the source to target mapping\n            target_chain = target_to_source[current_chain]\n\n            cckey = target_to_key[current_chain]\n            tckey = source_to_key[target_chain]\n\n            # build a list of nodes containing all nodes in the target chain\n            # including all 'end' nodes\n            target_chain_nodes = []\n            for j, tcid in enumerate(target_chain):\n                target_chain_nodes.append((tcid[0], self.node[tcid[0]]))\n                [target_chain_nodes.append(n) for n in SegmentDict[tcid][1]]\n            target_chain_nodes.append((target_chain[-1][1],\n                                       self.node[target_chain[-1][1]]))\n\n            # initialize start of window marker\n            start_of_window = -1\n\n            # loop through all nodes on the current chain\n            for k, node in enumerate(current_chain_nodes):\n                # find out if the current node is already principally connected\n                node_connected = False\n                if k == 0 or k == len(current_chain_nodes)-1:\n                    node_connected = True\n\n                # find out if the current node is already connected to the\n                # target chain\n                node_warp_edges = self.node_warp_edges(node[0], data=False)\n                warp_edge_targets = [we[1] for we in node_warp_edges]\n                # loop over weft edge targets\n                for wet in warp_edge_targets:\n                    # if warp edge target  is in target chain nodes, node\n                    # is connected and the start of our window for the next\n                    # node\n                    for n, tcn in enumerate(target_chain_nodes):\n                        if wet == tcn[0]:\n                            if n > start_of_window or start_of_window == -1:\n                                start_of_window = n\n                            node_connected = True\n\n                # if the node is not connected to the target chain, we\n                # need to find the end of the window\n                if not node_connected:\n                    # print info on verbose output\n                    v_print(\"Node: {}\".format(node[0]))\n                    v_print(\"Start of window: {}\".format(start_of_window))\n\n                    # re-check start of window for <.====/ case\n                    if len(target_chain_nodes) >= 2 and start_of_window == -1:\n                        if target_chain_nodes[0] == current_chain_nodes[0]:\n                            start_of_window = 1\n                        else:\n                            start_of_window = 0\n\n                    end_of_window = None\n                    # loop over target chain nodes\n                    for n, tcn in enumerate(target_chain_nodes):\n                        if n >= start_of_window:\n                            if tcn[0] == current_chain_nodes[-1][0]:\n                                end_of_window = n\n                            # get all warp edges of the current target node and\n                            # their targets\n                            tcn_warp_edges = self.node_warp_edges(tcn[0],\n                                                                  data=False)\n                            tcn_warp_edge_targets = [we[1] for we\n                                                     in tcn_warp_edges]\n                            # loop over warp edge targets of current target\n                            # node\n                            for twet in tcn_warp_edge_targets:\n                                # if warp edge target is in current chain,\n                                # it is the end of the window\n                                if (twet in [cn[0] for cn\n                                             in current_chain_nodes]):\n                                    end_of_window = n\n                                    break\n                        if end_of_window and end_of_window > start_of_window:\n                            break\n\n                    # re-check end of window for /====.> case\n                    if end_of_window:\n                        tcn_we = target_chain_nodes[end_of_window]\n                        ccn_end = current_chain_nodes[-1]\n                        ccn_len = len(current_chain_nodes)\n                        if tcn_we == ccn_end and k == ccn_len-2:\n                            end_of_window -= 1\n                    if end_of_window < start_of_window:\n                        start_of_window = -1\n                        end_of_window = None\n\n                    # if there is a valid window, set the target chain nodes\n                    if start_of_window != -1 and end_of_window != None:\n                        if end_of_window == len(target_chain_nodes)-1:\n                            window = target_chain_nodes[start_of_window:]\n                        else:\n                            window = target_chain_nodes[start_of_window:\n                                                        end_of_window+1]\n\n                        # print info on verbose output\n                        v_print(\"End of window: {}\".format(end_of_window))\n\n                        # execute connection\n                        if cckey < tckey:\n                            rev = False\n                        else:\n                            rev = True\n\n                        v_print(\"Connecting chain {} to chain {}.\".format(\n                                                                        cckey,\n                                                                        tckey))\n\n                        self._create_second_pass_warp_connection(\n                                                        current_chain_nodes,\n                                                        k,\n                                                        window,\n                                                        precise=precise,\n                                                        verbose=verbose,\n                                                        reverse=rev)\n                    else:\n                        v_print(\"No valid window for current chain!\")\n\n    # FIND FACES OF NETWORK ---------------------------------------------------\n\n    def to_KnitDiNetwork(self):\n        \"\"\"\n        Constructs and returns a directed KnitDiNetwork based on this network\n        by duplicating all edges so that [u -> v] and [v -> u] for every\n        edge [u - v] in this undirected network.\n\n        Returns\n        -------\n        directed_network : :class:`KnitDiNetwork`\n            The directed representation of this network.\n        \"\"\"\n\n        # create a directed network with duplicate edges in opposing directions\n        dirnet = KnitDiNetwork()\n\n        dirnet.name = self.name\n        dirnet.add_nodes_from(self)\n        dirnet.add_edges_from((u, v, data)\n                              for u, nbrs in self.adjacency_iter()\n                              for v, data in nbrs.items())\n        dirnet.graph = self.graph\n        dirnet.node = self.node\n        dirnet.mapping_network = self.mapping_network\n\n        return dirnet\n\n    def find_cycles(self, mode=-1):\n        \"\"\"\n        Finds the cycles (faces) of this network by utilizing a wall-follower\n        mechanism.\n\n        Parameters\n        ----------\n        mode : int, optional\n            Determines how the neighbors of each node are sorted when finding\n            cycles for the network.\n            ``-1`` equals to using the world XY plane.\n\n            ``0`` equals to using a plane normal to the origin nodes closest\n            point on the reference geometry.\n\n            ``1`` equals to using a plane normal to the average of the origin\n            and neighbor nodes' closest points on the reference geometry.\n\n            ``2`` equals to using an average plane between a plane fit to the\n            origin and its neighbor nodes and a plane normal to the origin\n            nodes closest point on the reference geometry.\n\n            Defaults to ``-1``.\n\n        Warning\n        -------\n        Modes other than ``-1`` are only possible if this network has an\n        underlying reference geometry in form of a Mesh or NurbsSurface. The\n        reference geometry should be assigned when initializing the network by\n        assigning the geometry to the \"reference_geometry\" attribute of the\n        network.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [16]_.\n        \"\"\"\n\n        return self.to_KnitDiNetwork().find_cycles(mode=mode)\n\n    def create_mesh(self, mode=-1, max_valence=4):\n        \"\"\"\n        Constructs a mesh from this network by finding cycles and using them as\n        mesh faces.\n\n        Parameters\n        ----------\n        mode : int, optional\n            Determines how the neighbors of each node are sorted when finding\n            cycles for the network.\n\n            ``-1`` equals to using the world XY plane.\n\n            ``0`` equals to using a plane normal to the origin nodes closest\n            point on the reference geometry.\n\n            ``1`` equals to using a plane normal to the average of the origin\n            and neighbor nodes' closest points on the reference geometry.\n\n            ``2`` equals to using an average plane between a plane fit to the\n            origin and its neighbor nodes and a plane normal to the origin\n            nodes closest point on the reference geometry.\n\n            Defaults to ``-1``.\n\n        max_valence : int, optional\n            Sets the maximum edge valence of the faces. If this is set to > 4,\n            n-gon faces (more than 4 edges) are allowed. Otherwise, their\n            cycles are treated as invalid and will be ignored.\n\n            Defaults to ``4``.\n\n        Warning\n        -------\n        Modes other than ``-1`` are only possible if this network has an\n        underlying reference geometry in form of a Mesh or NurbsSurface. The\n        reference geometry should be assigned when initializing the network by\n        assigning the geometry to the \"reference_geometry\" attribute of the\n        network.\n        \"\"\"\n\n        return self.to_KnitDiNetwork().create_mesh(mode=mode,\n                                                   max_valence=max_valence)\n\n    # DUALITY -----------------------------------------------------------------\n\n    def create_dual(self, mode=-1, merge_adj_creases=False,\n                    mend_trailing_rows=False):\n        \"\"\"\n        Creates the dual of this KnitNetwork while translating current edge\n        attributes to the edges of the dual network.\n\n        Parameters\n        ----------\n        mode : int, optional\n            Determines how the neighbors of each node are sorted when finding\n            cycles for the network.\n\n            ``-1`` equals to using the world XY plane.\n\n            ``0`` equals to using a plane normal to the origin nodes closest\n            point on the reference geometry.\n\n            ``1`` equals to using a plane normal to the average of the origin\n            and neighbor nodes' closest points on the reference geometry.\n\n            ``2`` equals to using an average plane between a plane fit to the\n            origin and its neighbor nodes and a plane normal to the origin\n            nodes closest point on the reference geometry.\n\n            Defaults to ``-1``.\n\n        merge_adj_creases : bool, optional\n            If ``True``, will merge adjacent 'increase' and 'decrease' nodes\n            connected by a 'weft' edge into a single node. This effectively\n            simplifies the pattern, as a decrease is unneccessary to perform\n            if an increase is right beside it - both nodes can be replaced by a\n            single regular node (stitch).\n\n            Defaults to ``False``.\n\n        mend_trailing_rows : bool, optional\n            If ``True``, will attempt to mend trailing rows by reconnecting\n            nodes.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        dual_network : :class:`KnitDiNetwork`\n            The dual network of this KnitNetwork.\n\n        Warning\n        -------\n        Modes other than -1 (default) are only possible if this network has an\n        underlying reference geometry in form of a Mesh or NurbsSurface. The\n        reference geometry  should be assigned when initializing the network by\n        assigning the geometry to the 'reference_geometry' attribute of the\n        network.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # first find the cycles of this network\n        cycles = self.find_cycles(mode=mode)\n\n        # get node data for all nodes once\n        node_data = {k: self.node[k] for k in self.nodes_iter()}\n\n        # create new directed KnitDiNetwork for dual network\n        DualNetwork = KnitDiNetwork(\n                        reference_geometry=self.graph[\"reference_geometry\"])\n\n        # create mapping dict for edges to adjacent cycles\n        edge_to_cycle = {(u, v): None for u, v in self.edges_iter()}\n        edge_to_cycle.update({(v, u): None for u, v in self.edges_iter()})\n\n        # CREATE NODES OF DUAL ------------------------------------------------\n\n        # for each cycle, find the centroid node\n        for ckey in sorted(cycles.keys()):\n            cycle = cycles[ckey]\n            clen = len(cycle)\n\n            # skip invalid cycles (ngons and self-loops)\n            if clen > 4 or clen < 3:\n                continue\n\n            # loop over cycle edges and fill mapping dicts\n            closed_cycle = cycle[:]\n            closed_cycle.append(cycle[0])\n            for u, v in pairwise(closed_cycle):\n                edge_to_cycle[(u, v)] = ckey\n\n            # get coords of cycle nodes\n            cycle_coords = [[node_data[k][\"x\"],\n                             node_data[k][\"y\"],\n                             node_data[k][\"z\"]] for k in cycle]\n\n            # compute centroid\n            cx, cy, cz = zip(*cycle_coords)\n            centroid = [sum(cx) / clen, sum(cy) / clen, sum(cz) / clen]\n            centroid_pt = RhinoPoint3d(*centroid)\n\n            # get node 'leaf' attributes\n            is_leaf = True in [node_data[k][\"leaf\"] for k in cycle]\n\n            # get node 'color' attributes. only if all colors of the cycle\n            # match, the color attribute will be set!\n            colors = [node_data[k][\"color\"] for k in cycle]\n            if all(x == colors[0] for x in colors):\n                cycle_color = colors[0]\n            else:\n                cycle_color = None\n\n            # add node to dual network\n            DualNetwork.node_from_point3d(ckey,\n                                          centroid_pt,\n                                          position=None,\n                                          num=None,\n                                          leaf=is_leaf,\n                                          start=False,\n                                          end=False,\n                                          segment=None,\n                                          increase=False,\n                                          decrease=False,\n                                          color=cycle_color)\n\n        # CREATE EDGES IN DUAL ------------------------------------------------\n\n        # loop over original edges and create corresponding edges in dual\n        for u, v, d in self.edges_iter(data=True):\n            u, v = self.edge_geometry_direction(u, v)\n            cycle_a = edge_to_cycle[(u, v)]\n            cycle_b = edge_to_cycle[(v, u)]\n            if cycle_a != None and cycle_b != None:\n                node_a = (cycle_a, DualNetwork.node[cycle_a])\n                node_b = (cycle_b, DualNetwork.node[cycle_b])\n                if d[\"warp\"]:\n                    DualNetwork.create_weft_edge(node_b, node_a)\n                elif d[\"weft\"]:\n                    DualNetwork.create_warp_edge(node_a, node_b)\n\n        # SET ATTRIBUTES OF DUAL NODES ----------------------------------------\n\n        # loop over all nodes of the network and set crease and end attributes\n        for node in DualNetwork.nodes_iter():\n            node_data = DualNetwork.node[node]\n\n            warp_in = DualNetwork.node_warp_edges_in(node)\n            warp_out = DualNetwork.node_warp_edges_out(node)\n            weft_in = DualNetwork.node_weft_edges_in(node)\n            weft_out = DualNetwork.node_weft_edges_out(node)\n\n            warplen = len(warp_in) + len(warp_out)\n            weftlen = len(weft_in) + len(weft_out)\n\n            # 2 warp edges and 1 weft edge  >> end\n            if warplen == 2 and weftlen == 1:\n                node_data[\"end\"] = True\n                if weft_out:\n                    node_data[\"start\"] = True\n\n            # 1 warp edge and 1 weft edge   >> end and increase / decrease\n            elif warplen == 1 and weftlen == 1:\n                node_data[\"end\"] = True\n                if weft_out:\n                    node_data[\"start\"] = True\n\n                if warp_out and not node_data[\"leaf\"]:\n                    node_data[\"increase\"] = True\n                elif warp_in and not node_data[\"leaf\"]:\n                    node_data[\"decrease\"] = True\n\n            # 2 warp edges and 0 weft edges >> end\n            elif warplen == 2 and weftlen == 0:\n                node_data[\"end\"] = True\n                node_data[\"start\"] = True\n\n            # 1 warp edge and 0 weft edges  >> end\n            elif warplen == 1 and weftlen == 0:\n                node_data[\"end\"] = True\n                node_data[\"start\"] = True\n\n            # 0 warp edges and 1 weft edge  >> end\n            elif warplen == 0 and weftlen == 1:\n                node_data[\"end\"] = True\n                if weft_out:\n                    node_data[\"start\"] = True\n\n            # 1 warp edge and 2 weft edges  >> increase or decrease\n            elif warplen == 1 and weftlen == 2:\n                if not node_data[\"leaf\"]:\n                    if warp_out:\n                        node_data[\"increase\"] = True\n                    elif warp_in:\n                        node_data[\"decrease\"] = True\n\n        # MERGE ADJACENT INCREASES/DECREASES ----------------------------------\n\n        if merge_adj_creases:\n            increase_nodes = [inc for inc in DualNetwork.nodes_iter(data=True)\n                              if inc[1][\"increase\"]]\n            for increase, data in increase_nodes:\n                pred = DualNetwork.predecessors(increase)\n                suc = DualNetwork.successors(increase)\n                pred = [p for p in pred if DualNetwork.node[p][\"decrease\"]]\n                suc = [s for s in suc if DualNetwork.node[s][\"decrease\"]]\n                # merge only with pred or with suc but not both\n                if (len(pred) == 1 and\n                        DualNetwork.edge[pred[0]][increase][\"weft\"]):\n                    # merge nodes, edge is pred, increase\n                    pred = pred[0]\n                    pd = DualNetwork.node[pred]\n                    # remove the connecting edge\n                    DualNetwork.remove_edge(pred, increase)\n                    # get the points of the nodes\n                    increase_pt = data[\"geo\"]\n                    pred_pt = pd[\"geo\"]\n                    # compute the new merged point\n                    new_vec = RhinoVector3d(increase_pt - pred_pt)\n                    new_pt = pred_pt + (new_vec * 0.5)\n                    # replace the increase with the new pt and invert the\n                    # increase attribute\n                    data[\"geo\"] = new_pt\n                    data[\"x\"] = new_pt.X\n                    data[\"y\"] = new_pt.Y\n                    data[\"z\"] = new_pt.Z\n                    data[\"increase\"] = False\n                    # edit the edges of the increase\n                    for edge in DualNetwork.edges_iter(increase, data=True):\n                        edge[2][\"geo\"] = RhinoLine(\n                                            data[\"geo\"],\n                                            DualNetwork.node[edge[1]][\"geo\"])\n                    # edit edges of decrease\n                    for edge in DualNetwork.in_edges_iter(pred, data=True):\n                        if edge[2][\"warp\"]:\n                            fromNode = (edge[0], DualNetwork.node[edge[0]])\n                            toNode = (increase, data)\n                            DualNetwork.create_warp_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                        elif edge[2][\"weft\"]:\n                            fromNode = (edge[0], DualNetwork.node[edge[0]])\n                            toNode = (increase, data)\n                            DualNetwork.create_weft_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                    DualNetwork.remove_node(pred)\n                elif (not pred and len(suc) == 1 and\n                        DualNetwork.edge[increase][suc[0]][\"weft\"]):\n                    # merge nodes, edge is increase, suc\n                    suc = suc[0]\n                    sd = DualNetwork.node[suc]\n                    # remove the connecting edge\n                    DualNetwork.remove_edge(increase, suc)\n                    # get the points of the nodes\n                    increase_pt = data[\"geo\"]\n                    suc_pt = sd[\"geo\"]\n                    # compute the new merged point\n                    new_vec = RhinoVector3d(suc_pt - increase_pt)\n                    new_pt = increase_pt + (new_vec * 0.5)\n                    # replace the increase with the new pt and invert the\n                    # increase attribute\n                    data[\"geo\"] = new_pt\n                    data[\"x\"] = new_pt.X\n                    data[\"y\"] = new_pt.Y\n                    data[\"z\"] = new_pt.Z\n                    data[\"increase\"] = False\n                    # edit the edges of the increase\n                    for edge in DualNetwork.edges_iter(increase, data=True):\n                        edge[2][\"geo\"] = RhinoLine(\n                                            data[\"geo\"],\n                                            DualNetwork.node[edge[1]][\"geo\"])\n                    for edge in DualNetwork.in_edges_iter(increase, data=True):\n                        edge[2][\"geo\"] = RhinoLine(\n                                            DualNetwork.node[edge[0]][\"geo\"],\n                                            data[\"geo\"])\n                    # edit incoming edges of decrease\n                    for edge in DualNetwork.in_edges_iter(suc, data=True):\n                        if edge[2][\"warp\"]:\n                            fromNode = (edge[0], DualNetwork.node[edge[0]])\n                            toNode = (increase, data)\n                            DualNetwork.create_warp_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                        elif edge[2][\"weft\"]:\n                            fromNode = (edge[0], DualNetwork.node[edge[0]])\n                            toNode = (increase, data)\n                            DualNetwork.create_weft_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                    # edit outgoing edges of decrease\n                    for edge in DualNetwork.edges_iter(suc, data=True):\n                        if edge[2][\"warp\"]:\n                            fromNode = (increase, data)\n                            toNode = (edge[1], DualNetwork.node[edge[1]])\n                            DualNetwork.create_warp_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                        elif edge[2][\"weft\"]:\n                            fromNode = (increase, data)\n                            toNode = (edge[1], DualNetwork.node[edge[1]])\n                            DualNetwork.create_weft_edge(fromNode, toNode)\n                            DualNetwork.remove_edge(edge[0], edge[1])\n                    DualNetwork.remove_node(suc)\n\n        # ATTEMPT TO MEND TRAILING ROWS ---------------------------------------\n\n        if mend_trailing_rows:\n\n            # TODO: find a safer / more robust implementation attempt!\n            errMsg = (\"This option is not satisfyingly implemented for this \" +\n                      \"method, yet. Therefore, it is deactivated for now.\")\n            raise NotImplementedError(errMsg)\n\n            # get all nodes which are 'leaf' and 'end' (right side)\n            # and all nodes which are 'leaf' and 'start' (left side)\n            trailing = sorted([(n, d) for n, d in\n                              DualNetwork.nodes_iter(data=True)\n                              if d[\"leaf\"]\n                              and d[\"end\"]], key=lambda x: x[0])\n            trailing_left = deque([t for t in trailing if t[1][\"start\"]])\n            trailing_right = deque([t for t in trailing if not t[1][\"start\"]])\n\n            # from the trailing left nodes...\n            # travel one outgoing 'weft'\n            # from there travel one incoming 'warp'\n            # if the resulting node is 'start', 'end' and has 3 edges in total\n            # >> take its outgoing 'warp' edge (we already traveled that so\n            #    we should already have it)\n            # >> connect it to the trailing left node\n            # >> remove the 'leaf' attribute from the trailing node as it is no\n            #    longer trailing\n            # >> add the 'increase' attribute to the previous target of the\n            #    'warp' edge\n\n            while len(trailing_left) > 0:\n                # pop an item from the deque\n                trail = trailing_left.popleft()\n                # travel one outgoing 'weft' edge\n                weft_out = DualNetwork.node_weft_edges_out(trail[0], data=True)\n                if not weft_out:\n                    continue\n                weft_out = weft_out[0]\n                # check the target of the 'weft' edge for incoming 'warp'\n                warp_in = DualNetwork.node_warp_edges_in(\n                                                        weft_out[1],\n                                                        data=True)\n                warp_out = DualNetwork.node_warp_edges_out(\n                                                        weft_out[1],\n                                                        data=True)\n                if not warp_in:\n                    continue\n                warp_in = warp_in[0]\n                candidate = (warp_in[0], DualNetwork.node[warp_in[0]])\n                nce = len(DualNetwork.in_edges(warp_in[0]))\n                nce += len(DualNetwork.edges(warp_in[0]))\n                # if this condition holds, we have a trailing increase\n                if (candidate[1][\"start\"]\n                        and candidate[1][\"end\"]\n                        and nce == 3):\n                    # remove found 'warp' edge\n                    DualNetwork.remove_edge(warp_in[0], warp_in[1])\n                    # assign 'increase' attribute to former 'warp' edge target\n                    DualNetwork.node[warp_in[1]][\"increase\"] = True\n                    # connect candidate to trail with new 'warp' edge\n                    DualNetwork.create_warp_edge(candidate, trail)\n                    # remove 'leaf' attribute of former trail\n                    trail[1][\"leaf\"] = False\n                else:\n                    if warp_out:\n                        warp_out = warp_out[0]\n                        candidate = (warp_out[1],\n                                     DualNetwork.node[warp_out[1]])\n                        nce = len(DualNetwork.in_edges(warp_out[1]))\n                        nce += len(DualNetwork.edges(warp_out[1]))\n                        # if this condition holds, we have a trailing decrease\n                        if (candidate[1][\"start\"]\n                                and candidate[1][\"end\"]\n                                and nce == 3):\n                            # remove found 'warp' edge\n                            DualNetwork.remove_edge(warp_out[0], warp_out[1])\n                            # assign 'decrease' attribute to former 'warp'\n                            # edge source\n                            DualNetwork.node[warp_out[0]][\"decrease\"] = True\n                            # connect former trail to candidate with new\n                            # 'warp' edge\n                            DualNetwork.create_warp_edge(trail, candidate)\n                            # remove 'leaf' attribute of former trail\n                            trail[1][\"leaf\"] = False\n\n            while len(trailing_right) > 0:\n                # pop an item from the deque\n                trail = trailing_right.popleft()\n                # travel one incoming 'weft' edge\n                weft_in = DualNetwork.node_weft_edges_in(trail[0], data=True)\n                if not weft_in:\n                    continue\n                weft_in = weft_in[0]\n                # check the target of the 'weft' edge for incoming 'warp'\n                warp_in = DualNetwork.node_warp_edges_in(weft_in[0],\n                                                         data=True)\n                warp_out = DualNetwork.node_warp_edges_out(weft_in[0],\n                                                           data=True)\n                if not warp_in:\n                    continue\n                warp_in = warp_in[0]\n                candidate = (warp_in[0], DualNetwork.node[warp_in[0]])\n                nce = len(DualNetwork.in_edges(warp_in[0]))\n                nce += len(DualNetwork.edges(warp_in[0]))\n                # if this condition holds, we have a trailing increase\n                if candidate[1][\"end\"] and nce == 3:\n                    # remove found 'warp' edge\n                    DualNetwork.remove_edge(warp_in[0], warp_in[1])\n                    # assign 'increase' attribute to former 'warp' edge target\n                    DualNetwork.node[warp_in[1]][\"increase\"] = True\n                    # connect candidate to trail with new 'warp' edge\n                    DualNetwork.create_warp_edge(candidate, trail)\n                    # remove 'leaf' attribute of former trail\n                    trail[1][\"leaf\"] = False\n                else:\n                    if warp_out:\n                        warp_out = warp_out[0]\n                        candidate = (warp_out[1],\n                                     DualNetwork.node[warp_out[1]])\n                        nce = len(DualNetwork.in_edges(warp_out[1]))\n                        nce += len(DualNetwork.edges(warp_out[1]))\n                        # if this condition holds, we have a trailing decrease\n                        if (candidate[1][\"start\"]\n                                and candidate[1][\"end\"]\n                                and nce == 3):\n                            # remove found 'warp' edge\n                            DualNetwork.remove_edge(warp_out[0], warp_out[1])\n                            # assign 'decrease' attribute to former 'warp'\n                            # edge source\n                            DualNetwork.node[warp_out[0]][\"decrease\"] = True\n                            # connect former trail to candidate with new\n                            # 'warp' edge\n                            DualNetwork.create_warp_edge(trail, candidate)\n                            # remove 'leaf' attribute of former trail\n                            trail[1][\"leaf\"] = False\n\n        return DualNetwork\n\n# MAIN ------------------------------------------------------------------------\n\n\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}