{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/wasp/field/field.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/wasp/field/field.py",
  "instruction": "(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>",
  "code": "\"\"\"\n(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>\n\nThis file is part of Wasp. https://github.com/ar0551/Wasp\n@license GPL-3.0 <https://www.gnu.org/licenses/gpl.html>\n\n@version 0.6.001\n\nClasses and utilities for voxel fields generation\n\"\"\"\n\n\nimport math\n\nfrom Rhino.Geometry import BoundingBox\nfrom Rhino.Geometry import Vector3d, Point3d\nfrom Rhino.Geometry import Plane, Box\nfrom Rhino.Geometry import Transform\nfrom Rhino.Geometry import Mesh\n\nfrom wasp import global_tolerance\nfrom wasp.utilities import mesh_from_data, mesh_to_data, plane_from_data, plane_to_data\n\n\n#################################################################### Field ####################################################################\nclass Field(object):\n\t\n\t## constructor\n\tdef __init__(self, name, pts, count, resolution, plane = Plane.WorldXY, values = [], boundaries = []):\n\t\t\n\t\tself.name = name\n\t\tself.pts = pts\n\t\tself.resolution = resolution\n\t\tself.plane = plane\n\t\t\n\t\tself.bbox = Box(self.plane, self.pts)\n\t\t\n\t\tself.x_count = count[0]\n\t\tself.y_count = count[1]\n\t\tself.z_count = count[2]\n\t\t\n\t\tself.vals = []\n\t\tself.boundaries = boundaries\n\t\t\n\t\tself.is_tensor_field = False\n\n\t\tif len(values) > 0:\n\t\t\tself.set_values(values, self.boundaries)\n\t\n\n\t## generate plane from a list of boundaries\n\t@classmethod\n\tdef from_boundaries(cls, _boundaries, _resolution, _plane = Plane.WorldXY):\n\t\tglobal_bbox = None\n\t\tfor geo in _boundaries:\n\t\t\tif global_bbox is None:\n\t\t\t\tglobal_bbox = Box(_plane, geo)\n\t\t\telse:\n\t\t\t\tnew_box = Box(_plane, geo)\n\t\t\t\tfor corner in new_box.GetCorners():\n\t\t\t\t\tglobal_bbox.Union(corner)\n\t\t\n\t\tx_size = global_bbox.X.Max - global_bbox.X.Min\n\t\tx_count = int(math.ceil(x_size / _resolution)) + 1\n\t\ty_size = global_bbox.Y.Max - global_bbox.Y.Min\n\t\ty_count = int(math.ceil(y_size / _resolution)) + 1\n\t\tz_size = global_bbox.Z.Max - global_bbox.Z.Min\n\t\tz_count = int(math.ceil(z_size / _resolution)) + 1\n\t\t\n\t\tcount = [x_count, y_count, z_count]\n\t\t\n\t\tpts = []\n\t\ts_pt = global_bbox.PointAt(0,0,0)\n\t\ts_plane = Plane(s_pt, _plane.XAxis, _plane.YAxis)\n\t\torient_transform = Transform.PlaneToPlane(Plane.WorldXY, s_plane)\n\t\t\n\t\tfor z in range(z_count):\n\t\t\tfor y in range(y_count):\n\t\t\t\tfor x in range(x_count):\n\t\t\t\t\tpt = Point3d(x*_resolution, y*_resolution, z*_resolution)\n\t\t\t\t\tpt.Transform(orient_transform)\n\t\t\t\t\tpts.append(pt)\n\t\t\n\t\tempty_field = cls(None, pts, count, _resolution, plane = s_plane, boundaries = _boundaries)\n\t\t\n\t\treturn empty_field\n\n\t\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspField [name: %s, res: %s, count: %s]\" % (self.name, self.resolution, len(self.pts))\n\t\n\t\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\t## recreate empty field\n\t\tpts_in = []\n\t\tfor pl in data[\"pts\"]:\n\t\t\tpts_in.append(Point3d(pl[0], pl[1], pl[2]))\n\n\t\tboundaries_in = []\n\t\tfor bl in data[\"boundaries\"]:\n\t\t\tboundaries_in.append(mesh_from_data(bl))\n\t\t\n\t\tfield = cls(data[\"name\"], pts_in, data[\"count\"], data[\"resolution\"], plane = plane_from_data(data['plane']), boundaries = boundaries_in)\n\n\t\t## set values\n\t\tfield.set_values(data[\"values\"])\n\n\t\treturn field\n\t\t\n\t## return the data dictionary representing the field\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['name'] = self.name\n\t\tdata['pts'] = self.return_pts_list()\n\t\tdata['count'] = self.return_count_vec()\n\t\tdata['resolution'] = self.resolution\n\t\tdata['plane'] = plane_to_data(self.plane)\n\t\tdata['values'] = self.return_values_list()\n\t\tdata['boundaries'] = []\n\t\tfor bou in self.boundaries:\n\t\t\tdata['boundaries'].append(mesh_to_data(bou))\n\t\treturn data\t\t\t\n\t\n\n\t## return a transformed copy of the field\n\tdef transform(self, trans):\n\t\tpts_trans = [Point3d(pt) for pt in self.pts]\n\t\tfor pt in pts_trans:\n\t\t\tpt.Transform(trans)\n\t\tplane_trans = Plane(self.plane)\n\t\tplane_trans.Transform(trans)\n\t\tboundaries_trans = [b.Duplicate() for b in self.boundaries]\n\t\tfor bt in boundaries_trans:\n\t\t\tbt.Transform(trans)\n\t\t\n\t\tfield_trans = Field(self.name, pts_trans, self.return_count_vec(), self.resolution, plane=plane_trans, values=self.return_values_list(), boundaries = boundaries_trans)\n\t\treturn field_trans\n\t\n\n\t## return values as flattened list\n\tdef return_values_list(self):\n\t\tvalues_list = []\n\t\tfor z in range(0, self.z_count):\n\t\t\tfor y in range(0, self.y_count):\n\t\t\t\tfor x in range(0, self.x_count):\n\t\t\t\t\tvalues_list.append(self.vals[z][y][x])\n\t\treturn values_list\n\t\n\n\t## return xyz counts vector\n\tdef return_count_vec(self):\n\t\treturn [self.x_count, self.y_count, self.z_count]\n\t\n\n\t## return points as python list of lists\n\tdef return_pts_list(self):\n\t\treturn [[pt.X, pt.Y, pt.Z] for pt in self.pts]\n\t\n\n\t## set values in an empty field\n\tdef set_values(self, values, use_boundaries = False):\n\t\ttry:\n\t\t\tv = values[0][2]\n\t\t\tself.is_tensor_field = True\n\t\texcept:\n\t\t\tself.is_tensor_field = False\n\t\t\n\t\tpts_count = 0\n\t\t\n\t\tif len(values) > 0:\n\t\t\tfor z in range(0, self.z_count):\n\t\t\t\tself.vals.append([])\n\t\t\t\tfor y in range(0, self.y_count):\n\t\t\t\t\tself.vals[z].append([])\n\t\t\t\t\tfor x in range(0, self.x_count):\n\t\t\t\t\t\tif use_boundaries and len(self.boundaries) > 0:\n\t\t\t\t\t\t\tinside = False\n\t\t\t\t\t\t\tfor bou in self.boundaries:\n\t\t\t\t\t\t\t\tif bou.IsPointInside(self.pts[pts_count], global_tolerance, True) == True:\n\t\t\t\t\t\t\t\t\tself.vals[z][y].append(values[pts_count])\n\t\t\t\t\t\t\t\t\tinside = True\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tif inside == False:\n\t\t\t\t\t\t\t\tif self.is_tensor_field:\n\t\t\t\t\t\t\t\t\tself.vals[z][y].append(Vector3d(0,0,0))\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tself.vals[z][y].append(0.0)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tself.vals[z][y].append(values[pts_count])\n\t\t\t\t\t\tpts_count += 1\n\n\n\t## return value associated to the closest point of the field to the given point\n\tdef return_pt_val(self, pt):\n\t\tpt_trans = self.plane.RemapToPlaneSpace(pt)[1]\n\t\t\n\t\tx = int(math.floor(pt_trans.X/self.resolution))\n\t\ty = int(math.floor(pt_trans.Y/self.resolution))\n\t\tz = int(math.floor(pt_trans.Z/self.resolution))\n\t\t\n\t\tvalue = self.vals[z][y][x]\n\t\treturn value\n\n\n\t## find and return highest value in the field ########################### TO FIX FOR ORIENTABLE FIELD!!!\n\tdef return_highest_pt(self, constraints = None):\n\t\tmax_val = -1\n\t\tmax_coords = None\n\t\tmax_count = -1\n\t\tcount = 0\n\t\thighest_pt = None\n\t\t\n\t\tfor z in range(0, self.z_count):\n\t\t\tfor y in range(0, self.y_count):\n\t\t\t\tfor x in range(0, self.x_count):\n\t\t\t\t\tvalue = self.vals[z][y][x]\n\t\t\t\t\t## tensor field aggregation (WIP)\n\t\t\t\t\tif self.is_tensor_field:\n\t\t\t\t\t\tif value.Length > max_val:\n\t\t\t\t\t\t\tif constraints is not None:\n\t\t\t\t\t\t\t\tconstraint_check = False\n\t\t\t\t\t\t\t\tpt = Point3d(x*self.resolution, y*self.resolution, z*self.resolution)\n\t\t\t\t\t\t\t\tpt += self.bbox.Min\n\t\t\t\t\t\t\t\tfor constraint in constraints:\n\t\t\t\t\t\t\t\t\tif constraint.check_soft(pt) == False:\n\t\t\t\t\t\t\t\t\t\tconstraint_check = True\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\tif constraint_check == False:\n\t\t\t\t\t\t\t\t\tmax_val = value.Length\n\t\t\t\t\t\t\t\t\tmax_coords = (x,y,z)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tmax_val = value.Length\n\t\t\t\t\t\t\t\tmax_coords = (x,y,z)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif value > max_val:\n\t\t\t\t\t\t\tif constraints is not None:\n\t\t\t\t\t\t\t\tconstraint_check = False\n\t\t\t\t\t\t\t\t#pt = Point3d(x*self.resolution, y*self.resolution, z*self.resolution)\n\t\t\t\t\t\t\t\t#pt += self.bbox.Min\n\t\t\t\t\t\t\t\tpt = self.pts[count]\n\t\t\t\t\t\t\t\tfor constraint in constraints:\n\t\t\t\t\t\t\t\t\tif constraint.check_soft(pt) == False:\n\t\t\t\t\t\t\t\t\t\tconstraint_check = True\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\tif constraint_check == False:\n\t\t\t\t\t\t\t\t\tmax_val = value\n\t\t\t\t\t\t\t\t\tmax_coords = (x,y,z)\n\t\t\t\t\t\t\t\t\tmax_count = count\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tmax_val = value\n\t\t\t\t\t\t\t\tmax_coords = (x,y,z)\n\t\t\t\t\t\t\t\tmax_count = count\n\t\t\t\t\tcount += 1\n\n\t\thighest_pt = Plane(self.pts[max_count], self.plane.XAxis, self.plane.YAxis)\n\t\treturn highest_pt\n\t\n\n\tdef compute_voxel_mesh(self, iso, cap = True):\n\t\tvoxel_mesh = Mesh()\n\t\tfor z in range(self.z_count):\n\t\t\tfor y in range(self.y_count):\n\t\t\t\tfor x in range(self.x_count):\n\t\t\t\t\tif self.vals[z][y][x] > iso:\n\t\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\telif self.vals[z][y][x-1] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif x == self.x_count-1:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\telif self.vals[z][y][x+1] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\telif self.vals[z][y-1][x] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif y == self.y_count - 1:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\telif self.vals[z][y+1][x] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif z == 0:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\telif self.vals[z-1][y][x] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 2, index + 1, index + 0)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 3, index + 2, index + 0)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif z == self.z_count - 1:\n\t\t\t\t\t\t\tif cap:\n\t\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\telif self.vals[z+1][y][x] < iso:\n\t\t\t\t\t\t\tindex = voxel_mesh.Vertices.Count\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x+1,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Vertices.Add(x,y+1,z+1)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 1, index + 2)\n\t\t\t\t\t\t\tvoxel_mesh.Faces.AddFace(index + 0, index + 2, index + 3)\n\t\t\t\t\t\t\t\n\t\tvoxel_mesh.Weld(math.pi)\n\n\t\tscale_transform = Transform.Scale(Point3d(0,0,0), self.resolution) \n\t\tvoxel_mesh.Transform(scale_transform)\n\n\t\ts_pt = self.bbox.PointAt(0,0,0)\n\t\ts_plane = Plane(s_pt, self.plane.XAxis, self.plane.YAxis)\n\t\torient_transform = Transform.PlaneToPlane(Plane.WorldXY, s_plane)\n\t\tvoxel_mesh.Transform(orient_transform)\n\t\tvoxel_mesh.Translate(-self.resolution/2, -self.resolution/2, -self.resolution/2)\n\n\t\tvoxel_mesh.RebuildNormals()\n\t\treturn voxel_mesh",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}