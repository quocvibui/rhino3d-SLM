{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Outdoor%20Solar%20Temperature%20Adjustor.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Outdoor Solar Temperature Adjustor.py",
  "instruction": "Use this component to adjust an existing Mean Radiant Temperature for shortwave solar radiation.  This adjusted mean radiant temperature can then be used in comfort studies.\n_\nIn the case that...",
  "code": "# Outdoor Solar Adjusted Temperature Calculator\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to adjust an existing Mean Radiant Temperature for shortwave solar radiation.  This adjusted mean radiant temperature can then be used in comfort studies.\n_\nIn the case that _baseDryBulbOrMRT_ is \"True\" or None, this component will also account for long wave radiant heat loss to the sky.\n_\nThis component uses either Radiance functions or the SolarCal method in order to determine the amount of direct and diffuse solar radiation falling on a comfort mannequin.\nThe portion reflected off of the ground to the comfort mannequin is derived from these values of direct and diffuse radiation.\n\nBoth the SolarCal method and the formulas to translate radiation into an effective radiant field and into a solar-adjusted mean radiant temperature come from this paper:\nArens, Edward; Huang, Li; Hoyt, Tyler; Zhou, Xin; Shiavon, Stefano. (2014). Modeling the comfort effects of short-wave solar radiation indoors.  Indoor Environmental Quality (IEQ).\nhttp://escholarship.org/uc/item/89m1h2dg#page-4\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _location: The location output from the \"Ladybug_Import epw\" component. This is used to determine the position of the sun.\n        _cumSkyMtxOrDirNormRad: Either the output from a GenCumulativeSkyMtx component (for high-resolution analysis) or the directNormalRadiation ouput from the \"Ladybug_Import epw\" component (for simple, low-resolution analsysis).\n        _diffuseHorizRad: If you are running a simple analysis with Direct Normal Radiation above, you must provide the diffuseHorizaontalRadiation ouput from the \"Ladybug_Import epw\" component here.  Otherwise, this input is not required.\n        _baseTemperature: A number or list of numbers representing the mean radiant temperature of the surrounding surfaces in degrees Celcius.  This number will be modified to account for solar radiation.  This input can be air temperature data from the 'Import_epw' component and will follow the assumption that the surrounding mean radiant temperature is the same as the air temperature.  This assumption is ok for a person in an outdoor open field.  However, the more obstacles that surround the person (and the more \"contextShading_\" that you add), the more important it is to derive a starting mean radiant temperature from a Honeybee Energy simulation.\n        _baseDryBulbOrMRT_: Set to 'True' to have the _baseTemperature above understood as the outdoor dry bulb air temperature, in which case this component will attempt to account for long wave radiation by computing sky temperature and assuming all other surfaces are at the specified _baseTemperature.  Set to 'False' to have the input above interpreted as a starting long wave MRT, which will only be increased to account for short wave radiation.  The latter is useful for indoor conditions where you can compute a starting long wave MRT from the indoor surface temperatures.  The default is set to 'True' to interpret the input above as outdoor air temperature.\n        _horizInfraredRad_: A number or list of numbers representing downwelling long wave infrared radiation from the sky.  This input can also be the horizontalInfraredRadiation output of the Import EPE component.  The values are necessary to calculate long wave sky temperature when the input above is set to 'True.'\n        -------------------------: ...\n        bodyPosture_: An interger between 0 and 5 to set the posture of the comfort mannequin, which can have a large effect on the radiation for a given sun position.  0 = Standing, 1 = Sitting, 2 = Lying Down, 3 = Low-Res Standing, 4 = Low-Res Sitting, and 5 = Low-Res Lying Down.  The default is set to 1 for sitting.\n        rotationAngle_: An optional rotation angle in degrees.  Use this number to adjust the angle of the comfort mannequin in space.  The angle of the mannequin in relation to the sun can have a large effect on the amount of radiation that falls on it and thus largely affect the resulting mean radiant temperature.\n        bodyLocation_: An optional point that sets the position of the comfort mannequin in space.  Use this to move the comfort mannequin around in relation to contextShading_ connected below. Note that this point should be at the lowest point of the mannequin (atthe feet for sitting and standing).  The default is set to the Rhino origin.\n        contextShading_: Optional breps or meshes that represent shading or opaque solar obstructions around the mannequin.  If you are using this component for indoor studies, windows or any transparent materials should not be included in this geometry.  You should factor the transmissivity of these materials in with the windowTransmissivity_ input.  Also, note that, if you have a lot of this context geometry, you should make sure that you input a starting _baseTemperature that accounts for the temperature of all the temperture of these shading surfaces.\n        north_: Input a vector to be used as a true North direction for the sun path or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\n        groundReflectivity_: An optional decimal value between 0 and 1 that represents the fraction of solar radiation reflected off of the ground.  By default, this is set to 0.25, which is characteristic of outdoor grass or dry bare soil.  You may want to increase this value for concrete or decrease it for water or dark soil.\n        clothingAbsorptivity_: An optional decimal value between 0 and 1 that represents the fraction of solar radiation absorbed by the human body. The default is set to 0.7 for (average/brown) skin and average clothing.  You may want to increase this value for darker skin or darker clothing.\n        windowTransmissivity_: An optional decimal value between 0 and 1 that represents the transmissivity of windows around the person.  This can also be a list of 8760 values between 0 and 1 that represents a list of hourly window transmissivties, in order to represent the effect of occupants pulling blinds over the windows, etc. Note that you should only set a value here if you are using this component for indoor analysis where the only means by which sunlight will hit an occupant is if it comes through a window.  The default is set to 1 for outdoor conditions.\n        analysisPeriodOrHOY_: An optional analysis period from the 'Analysis Period component' or an hour of the year between 1 and 8760 for which you want to conduct the analysis. If no value is connected here, the component will run for the whole year if using raw epw DirNormRad or will run for noon on the winter solstice if using cumSkyMtx.\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\n        tempOrRad_: Set to 'True' to have the mannequin labled with adjusted perceived radiant temperature and set to 'False' to have the mannequin labled with total radiation falling on the person. The default is set to 'False'.\n        parallel_: Set to \"True\" to run the component using multiple CPUs.  This can dramatically decrease calculation time but can interfere with other intense computational processes that might be running on your machine.  For this reason, the default is set to 'True.'\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        _runIt: Set to \"True\" to run the component and calculate solar-adjusted Mean Radiant Temperature.\n    Returns:\n        readMe!: ...\n        --------------------: ...\n        effectiveRadiantField: The estimated effective radiant field of the comfort mannequin induced by the sun for each hour of the analysis period.  This is in W/m2.\n        MRTDelta: The estimated change in mean radiant temperature for the comfort mannequin induced by the solar radiation.  This is in degreed Celcius.\n        solarAdjustedMRT: The estimated solar adjusted mean radiant temperature for each hour of the analysis period.  This is essentially the change in mean radiant temperature above added to the hourly _baseTemperature input.  This is in degreed Celcius and can be plugged into any comfort components for comfort studies.\n        --------------------: ...\n        mannequinMesh: A colored mesh of a comfort mannequin showing the amount of radiation falling over the mannequin's body.\n        legend: A legend that corresponds to the colors on the mannequinMesh and shows the relative W/m2.\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the chart with the grasshopper \"move\" component.\n        --------------------: ...\n        meshFaceResult: If 'tempOrRad' is set to True, this will be the estimated solar adjusted radiant temperature for each mesh face of the mannequin in degrees Celcius.  This radiant temperature is averaged over the the entire analysis period. if 'tempOrRad' is set to False, this will be the total radiation on each mesh face over the analysis period.\n        meshFaceArea: The areas of each mesh face of the mannequin in square Rhino model units.  This list corresponds to the meshFaceRadTemp list above and can be used to help inform statistical analysis of the radiant assymmetry over the mannequin.\n\n\"\"\"\nghenv.Component.Name = \"Ladybug_Outdoor Solar Temperature Adjustor\"\nghenv.Component.NickName = 'SolarAdjustTemperature'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_09_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\n#compatibleLBVersion = VER 0.0.59\\nJUN_07_2016\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\nimport Rhino as rc\nimport scriptcontext as sc\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\nimport System\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport math\nimport System.Threading.Tasks as tasks\n\nw = gh.GH_RuntimeMessageLevel.Warning\n\n\ninputsDict = {\n    \n0: [\"_location\", \"The location output from the 'Ladybug_Import epw' component. This is used to determine the position of the sun.\"],\n1: [\"_cumSkyMtxOrDirNormRad\", \"Either the output from a GenCumulativeSkyMtx component (for high-resolution analysis) or the directNormallRadiation ouput from the 'Ladybug_Import epw' component (for simple, low-resolution analsysis).\"],\n2: [\"_diffuseHorizRad\", \"If you are running a simple analysis with Direct Normal Radiation above, you must provide the diffuseHorizaontalRadiation ouput from the 'Ladybug_Import epw' component here.  Otherwise, this input is not required.\"],\n3: [\"_baseTemperature\", \"A number or list of numbers representing either the outdoor dry bulb air temperture (if the input below is set to 'True') or the long wave mean radiant temperature (MRT) of the surrounding surfaces in degrees Celcius (if the input below is set to 'False').  The former is useufl for computing outdoor MRT if you only have the air temperature while the latter is useful for indoor conditions when you can compute a starting long wave MRT from the indoor surface temperatures.\"],\n4: [\"_baseDryBulbOrMRT_\", \"Set to 'True' to have the _baseTemperature above understood as the outdoor dry bulb air temperature, in which case this component will attempt to account for long wave radiation by computing sky temperature and assuming all other surfaces are at the specified _baseTemperature.  Set to 'False' to have the input above interpreted as a starting long wave MRT, which will only be increased to account for short wave radiation.  The latter is useful for indoor conditions where you can compute a starting long wave MRT from the indoor surface temperatures.  The default is set to 'True' to interpret the input above as outdoor air temperature.\"],\n5: [\"_horizInfraredRad_\", \"A number or list of numbers representing downwelling long wave infrared radiation from the sky.  This input can also be the horizontalInfraredRadiation output of the Import EPE component.  The values are necessary to calculate long wave sky temperature when the input above is set to 'True.'\"],\n6: [\"-------------------------\", \"...\"],\n7: [\"bodyPosture_\", \"An interger between 0 and 5 to set the posture of the comfort mannequin, which can have a large effect on the radiation for a given sun position.  0 = Standing, 1 = Sitting, 2 = Lying Down, 3 = Low-Res Standing, 4 = Low-Res Sitting, and 5 = Low-Res Lying Down.  The default is set to 1 for sitting.\"],\n8: [\"rotationAngle_\", \"An optional rotation angle in degrees.  Use this number to adjust the angle of the comfort mannequin in space.  The angle of the mannequin in relation to the sun can have a large effect on the amount of radiation that falls on it and thus largely affect the resulting mean radiant temperature.\"],\n9: [\"bodyLocation_\", \"An optional point that sets the position of the comfort mannequin in space.  Use this to move the comfort mannequin around in relation to contextShading_ connected below. Note that this point should be the center of gravity of your person.  The default is set to a person just above the Rhino origin.\"],\n10: [\"contextShading_\", \"Optional breps or meshes that represent shading or opaque solar obstructions around the mannequin.  If you are using this component for indoor studies, windows or any transparent materials should not be included in this geometry.  You should factor the transmissivity of these materials in with the windowTransmissivity_ input.  Also, note that, if you have a lot of this context geometry, you should make sure that you input a starting _baseTemperature that accounts for the temperature of all the temperture of these shading surfaces.\"],\n11: [\"north_\", \"Input a vector to be used as a true North direction for the sun path or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\"],\n12: [\"groundReflectivity_\", \"An optional decimal value between 0 and 1 that represents the fraction of solar radiation reflected off of the ground.  By default, this is set to 0.25, which is characteristic of outdoor grass or dry bare soil.  You may want to increase this value for concrete or decrease it for water or dark soil.\"],\n13: [\"clothingAbsorptivity_\", \"An optional decimal value between 0 and 1 that represents the fraction of solar radiation absorbed by the human body. The default is set to 0.7 for (average/brown) skin and average clothing.  You may want to increase this value for darker skin or darker clothing.\"],\n14: [\"windowTransmissivity_\", \"An optional decimal value between 0 and 1 that represents the transmissivity of windows around the person.  This can also be a list of 8760 values between 0 and 1 that represents a list of hourly window transmissivties, in order to represent the effect of occupants pulling blinds over the windows, etc. Note that you should only set a value here if you are using this component for indoor analysis where the only means by which sunlight will hit an occupant is if it comes through a window.  The default is set to 1 for outdoor conditions.\"],\n15: [\"analysisPeriodOrHOY_\", \"An optional analysis period from the 'Analysis Period component' or an hour of the year between 1 and 8760 for which you want to conduct the analysis. If no value is connected here, the component will run for the whole year if using raw epw DirNormRad or will run for noon on the winter solstice if using cumSkyMtx.\"],\n16: [\"legendPar_\", \"Optional legend parameters from the Ladybug Legend Parameters component.\"],\n17: [\"tempOrRad_\", \"Set to 'True' to have the mannequin labled with adjusted perceived radiant temperature and set to 'False' to have the mannequin labled with total radiation falling on the person. The default is set to 'False'.\"],\n18: [\"parallel_\", \"Set to 'True' to run the component using multiple CPUs.  This can dramatically decrease calculation time but can interfere with other intense computational processes that might be running on your machine.  For this reason, the default is set to 'True.'\"],\n19: [\"bakeIt_\", \"An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options: \\n     0 (or False) - No geometry will be baked into the Rhino scene (this is the default). \\n     1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \\n     2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\"],\n20: [\"_runIt\", \"The legend base point, which can be used to move the legend in relation to the chart with the grasshopper 'move' component.\"]\n}\n\n\noutputsDict = {\n    \n0: [\"readMe!\", \"...\"],\n1: [\"--------------------\", \"...\"],\n2: [\"effectiveRadiantField\", \"The estimated effective radiant field of the comfort mannequin induced by the sun for each hour of the analysis period.  This is in W/m2.\"],\n3: [\"MRTDelta\", \"The estimated change in mean radiant temperature for the comfort mannequin induced by the solar radiation.  This is in degreed Celcius.\"],\n4: [\"solarAdjustedMRT\", \"The estimated solar adjusted mean radiant temperature for each hour of the analysis period.  This is essentially the change in mean radiant temperature above added to the hourly _baseTemperature input.  This is in degreed Celcius and can be plugged into any comfort components for comfort studies.\"],\n5: [\"--------------------\", \"...\"],\n6: [\"mannequinMesh\", \"A colored mesh of a comfort mannequin showing the amount of radiation falling over the mannequin's body.\"],\n7: [\"legend\", \"A legend that corresponds to the colors on the mannequinMesh and shows the relative W/m2.\"],\n8: [\"legendBasePt\", \"The input data normalized by the floor area of it corresponding zone.\"],\n9: [\"--------------------\", \"...\"],\n10: [\"meshFaceResult\", \"If 'tempOrRad' is set to True, this will be the estimated solar adjusted radiant temperature for each mesh face of the mannequin in degrees Celcius.  This radiant temperature is averaged over the the entire analysis period. if 'tempOrRad' is set to False, this will be the total radiation on each mesh face over the analysis period.\"],\n11: [\"meshFaceArea\", \"The areas of each mesh face of the mannequin in square Rhino model units.  This list corresponds to the meshFaceRadTemp list above and can be used to help inform statistical analysis of the radiant assymmetry over the mannequin.\"]\n}\n\n\ndef checkTheInputs():\n    # import the classes\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n    lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\n    lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\n    lb_comfortModels = sc.sticky[\"ladybug_ComfortModels\"]()\n    lb_sunpath = sc.sticky[\"ladybug_SunPath\"]()\n    \n    #Set a default value for epwStr.\n    epwStr = []\n    \n    #Check to see if the user has connected valid MRT data.\n    checkData1 = False\n    radTemp = []\n    if len(_baseTemperature) > 0:\n        try:\n            if \"Temperature\" in _baseTemperature[2]:\n                radTemp = _baseTemperature[7:]\n                checkData1 = True\n                epwData = True\n                epwStr = _baseTemperature[0:7]\n        except: pass\n        if checkData1 == False:\n            for item in _baseTemperature:\n                try:\n                    radTemp.append(float(item))\n                    checkData1 = True\n                except: checkData1 = False\n        if checkData1 == False:\n            warning = '_baseTemperature input does not contain valid temperature values in degrees Celcius.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n        \n        \n        #If there is only one value for MRT, duplicate it 8760 times.\n        if len(radTemp) < 8760 and len(radTemp) !=0:\n            if len(radTemp) == 1:\n                dupData = []\n                for count in range(8760):\n                    dupData.append(radTemp[0])\n                radTemp = dupData\n            else:\n                warning = 'Input for _baseTemperature must be either the output of an energy simulation, a list of 8760 values, or a single MRT to be applied for every hour of the year.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n    else:\n        warning = 'Input _baseTemperature failed to collect data.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        return -1\n    \n    #Check to be sure the there is a _cumSkyMtxOrDirNormRad and use it to set the method of the component.\n    cumSkyMtx = None\n    location = None\n    methodInit = 0\n    directSolarRad = []\n    if len(_cumSkyMtxOrDirNormRad) > 0:\n        if _cumSkyMtxOrDirNormRad != [None]:\n            if \"SkyResultsCollection object\" in str(_cumSkyMtxOrDirNormRad[0]):\n                cumSkyMtx = _cumSkyMtxOrDirNormRad[0]\n                location = cumSkyMtx.location\n            elif str(_cumSkyMtxOrDirNormRad[0]) == 'key:location/dataType/units/frequency/startsAt/endsAt':\n                try:\n                    if 'Direct Normal Radiation' in _cumSkyMtxOrDirNormRad[2] and len(_cumSkyMtxOrDirNormRad) == 8767:\n                        location = _cumSkyMtxOrDirNormRad[1]\n                        methodInit = 2\n                        directSolarRad = _cumSkyMtxOrDirNormRad[7:]\n                    else:\n                        warning = 'Weather data connected to _cumSkyMtxOrDirNormRad is not Direct Normal Radiation or is not hourly data for a full year.'\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                        return -1\n                except:\n                    warning = 'Invalid value for _cumSkyMtxOrDirNormRad.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                    return -1\n            else:\n                warning = 'Invalid value for _cumSkyMtxOrDirNormRad.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n        else:\n            warning = 'Null value connected for _cumSkyMtxOrDirNormRad.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n    \n    # Get the diffuse Horizontal radiation.\n    diffSolarRad = []\n    if methodInit == 2:\n        try:\n            if len(_diffuseHorizRad) > 0:\n                if _diffuseHorizRad != [None]:\n                    if str(_diffuseHorizRad[0]) == 'key:location/dataType/units/frequency/startsAt/endsAt':\n                        try:\n                            if 'Diffuse Horizontal Radiation' in _diffuseHorizRad[2] and len(_diffuseHorizRad) == 8767:\n                                diffSolarRad = _diffuseHorizRad[7:]\n                            else:\n                                warning = 'Weather data connected to _diffuseHorizRad is not Diffuse Horizontal Radiation or is not hourly data for a full year.'\n                                print warning\n                                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                                return -1\n                        except:\n                            warning = 'Invalid value for _diffuseHorizRad.'\n                            print warning\n                            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                            return -1\n                    else:\n                        warning = 'Invalid value for _diffuseHorizRad.'\n                        print warning\n                        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                        return -1\n                else:\n                    warning = 'Null value connected for _diffuseHorizRad.'\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                    return -1\n            else:\n                return -1\n        except:\n            return -1\n    \n    #Check the bodyPosture_ input to be sure that it is a valid interger.\n    if methodInit == 0:\n        if bodyPosture_ == 0 or bodyPosture_ == 1 or bodyPosture_ == 2:\n            bodyPosture = bodyPosture_\n        elif bodyPosture_ == 3 or bodyPosture_ == 4 or bodyPosture_ == 5:\n            bodyPosture = bodyPosture_\n            methodInit = 1\n        elif bodyPosture_ == None:\n            bodyPosture = 1\n        else:\n            warning = 'Input for bodyPosture_ is not an accepted input interger.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n    else:\n        bodyPosture = -1\n    \n    \n    #Convert the rotation angle to radians or set a default of 0 if there is none.\n    rotateAngle = 0.0\n    if methodInit != 2:\n        try:\n            if rotationAngle_ != None: rotateAngle = rotationAngle_*0.0174532925\n        except: pass\n    \n    #Create the comfort mannequin.\n    conversionFac = lb_preparation.checkUnits()\n    if methodInit != 2:\n        if bodyPosture == 1:\n            mannequinData = lb_comfortModels.getSeatedMannequinData()\n        elif bodyPosture == 0 or bodyPosture == 2:\n            mannequinData = lb_comfortModels.getStandingMannequinData()\n        elif bodyPosture == 4:\n            mannequinData = lb_comfortModels.getSeatedMannequinSimple()\n        elif bodyPosture == 3 or bodyPosture == 5:\n            mannequinData = lb_comfortModels.getStandingMannequinSimple()\n        #Construct the mannequin from the point data.\n        mannequinMeshBreps = []\n        for faceList in mannequinData:\n            surfacePts = []\n            for pointCoord in faceList:\n                point = rc.Geometry.Point3d(pointCoord[0], pointCoord[1], pointCoord[2])\n                surfacePts.append(point)\n            if len(surfacePts) == 4: \n                surface = rc.Geometry.Brep.CreateFromCornerPoints(surfacePts[0], surfacePts[1], surfacePts[2], surfacePts[3], sc.doc.ModelAbsoluteTolerance)\n            else:\n                surface = rc.Geometry.Brep.CreateFromCornerPoints(surfacePts[0], surfacePts[1], surfacePts[2], sc.doc.ModelAbsoluteTolerance)\n            mannequinMeshBreps.append(surface)\n        mannequinMesh = rc.Geometry.Brep.JoinBreps(mannequinMeshBreps, sc.doc.ModelAbsoluteTolerance)[0]\n        #Scale the mannequin based on the model units.\n        scale = rc.Geometry.Transform.Scale(rc.Geometry.Plane.WorldXY, 1/conversionFac, 1/conversionFac, 1/conversionFac)\n        mannequinMesh.Transform(scale)\n        #If the user has selected a mannequin laying down, rotate the standing mannequin.\n        if bodyPosture == 2 or bodyPosture == 5:\n            lieDownTransform = rc.Geometry.Transform.Rotation(rc.Geometry.Vector3d.ZAxis, rc.Geometry.Vector3d.YAxis, rc.Geometry.Point3d.Origin)\n            moveUpTransform = rc.Geometry.Transform.Translation(0,-.85,.15)\n            mannequinMesh.Transform(lieDownTransform)\n            mannequinMesh.Transform(moveUpTransform)\n        else: pass\n        #Rotate the mannequin as the user wants.\n        if rotateAngle != 0.0:\n            rotateTransform = rc.Geometry.Transform.Rotation(rotateAngle, rc.Geometry.Vector3d.ZAxis, rc.Geometry.Point3d.Origin)\n            mannequinMesh.Transform(rotateTransform)\n        else: pass\n        #Change the location of the mannequin as the user wants.\n        if len(bodyLocation_) != 0:\n            if len(bodyLocation_) == 1:\n                for item in bodyLocation_:\n                    moveTransform = rc.Geometry.Transform.Translation(item.X, item.Y, item.Z)\n                    mannequinMesh.Transform(moveTransform)\n            else:\n                warning = 'Input for bodyLocation_ can only be a single point if using a detailed mannequin radiation mesh and a cumSkyMtx. \\n Switch the analysis to dirNormRad to run this component for multiple points.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n        else: pass\n        #Turn the mannequin brep into a mesh.\n        mannequinMesh = rc.Geometry.Mesh.CreateFromBrep(mannequinMesh, rc.Geometry.MeshingParameters.Coarse)\n    elif methodInit == 2:\n        mannequinMeshInit = []\n        #Get a series of 3 - 9 points to represent the person, which will be used to calculate the fraction of the body visible to the sun through the context.\n        if bodyPosture_ == 0 or bodyPosture_ == 3:\n            offsetDist = 0.8/conversionFac\n            mannequinAvgHeight = 0.85/conversionFac\n            mannequinX = 0\n            mannequinY = 0\n            if bodyPosture_ == 0: offsetHeights = [mannequinAvgHeight - offsetDist, (mannequinAvgHeight - offsetDist)+((offsetDist*2)/8), (mannequinAvgHeight - offsetDist)+((offsetDist*4)/8), (mannequinAvgHeight - offsetDist)+((offsetDist*6)/8), mannequinAvgHeight, (mannequinAvgHeight + offsetDist)-((offsetDist*6)/8), (mannequinAvgHeight + offsetDist)-((offsetDist*4)/8), (mannequinAvgHeight + offsetDist)-(offsetDist*2)/8, (mannequinAvgHeight + offsetDist)]\n            else: offsetHeights = [mannequinAvgHeight - offsetDist, mannequinAvgHeight, mannequinAvgHeight + offsetDist]\n            for height in offsetHeights:\n                mannequinMeshInit.append(rc.Geometry.Point3d(mannequinX, mannequinY, height))\n        elif bodyPosture_ == 1 or bodyPosture_ == 4 or bodyPosture_ == None:\n            offsetDist = 0.58/conversionFac\n            mannequinAvgHeight = 0.65/conversionFac\n            mannequinX = 0\n            mannequinY = 0\n            if bodyPosture_ == 1 or bodyPosture_ == None: offsetHeights = [mannequinAvgHeight - offsetDist, (mannequinAvgHeight - offsetDist)+((offsetDist*2)/8), (mannequinAvgHeight - offsetDist)+((offsetDist*4)/8), (mannequinAvgHeight - offsetDist)+((offsetDist*6)/8), mannequinAvgHeight, (mannequinAvgHeight + offsetDist)-((offsetDist*6)/8), (mannequinAvgHeight + offsetDist)-((offsetDist*4)/8), (mannequinAvgHeight + offsetDist)-(offsetDist*2)/8, (mannequinAvgHeight + offsetDist)]\n            else: offsetHeights = [mannequinAvgHeight - offsetDist, mannequinAvgHeight, mannequinAvgHeight + offsetDist]\n            for height in offsetHeights:\n                mannequinMeshInit.append(rc.Geometry.Point3d(mannequinX, mannequinY, height))\n        else:\n            mannequinAvgHeight = 0.1/conversionFac\n            mannequinX = 0\n            mannequinY = 0\n            offsetDist = 0.8/conversionFac\n            if bodyPosture_ == 2: offsetY = [mannequinY - offsetDist, (mannequinY - offsetDist)+((offsetDist*2)/8), (mannequinY - offsetDist)+((offsetDist*4)/8), (mannequinY - offsetDist)+((offsetDist*6)/8), mannequinY, (mannequinY + offsetDist)-((offsetDist*6)/8), (mannequinY + offsetDist)-((offsetDist*4)/8), (mannequinY + offsetDist)-(offsetDist*2)/8, (mannequinY + offsetDist)]\n            else: offsetY = [mannequinY - offsetDist, mannequinY, mannequinY + offsetDist]\n            for yTrans in offsetY:\n                mannequinMeshInit.append(rc.Geometry.Point3d(mannequinX, yTrans, mannequinAvgHeight))\n        \n        #If a bodylocation is input, move the original body location.\n        mannequinMesh = []\n        if len(bodyLocation_) != 0 and bodyLocation_[0] != None:\n            for loc in bodyLocation_:\n                newMesh = []\n                for point in mannequinMeshInit:\n                    newMesh.append(rc.Geometry.Point3d(point.X+loc.X, point.Y+loc.Y, point.Z+loc.Z))\n                mannequinMesh.append(newMesh)\n        else:\n            mannequinMesh.append(mannequinMeshInit)\n    \n    #Create a ground mesh.\n    if methodInit != 2:\n        groundMesh = rc.Geometry.Mesh()\n        point1 = rc.Geometry.Point3d(-.5, -1, 0)\n        point2 = rc.Geometry.Point3d(-.5, -2, 0)\n        point3 = rc.Geometry.Point3d(.5, -2, 0)\n        point4 = rc.Geometry.Point3d(.5, -1, 0)\n        groundMesh.Vertices.Add(point1)\n        groundMesh.Vertices.Add(point2)\n        groundMesh.Vertices.Add(point3)\n        groundMesh.Vertices.Add(point4)\n        groundMesh.Faces.AddFace(0, 1, 2, 3)\n        if len(bodyLocation_) != 0:\n            groundMesh.Transform(moveTransform)\n        else: pass\n    else:\n        groundMesh = None\n    \n    # Mesh the context.\n    if len(contextShading_)!=0:\n        ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\n        contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(contextShading_)\n        \n        ## mesh Brep\n        contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\n        \n        ## Flatten the list of surfaces\n        contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\n        contextSrfs = contextMesh + contextMeshedBrep\n    else: contextSrfs = []\n    \n    #Check the ground reflectivity.\n    if groundReflectivity_ != None:\n        if groundReflectivity_ <= 1 and groundReflectivity_ >= 0:\n            groundR = groundReflectivity_\n        else:\n            groundR = None\n            warning = 'groundReflectivity_ must be a value between 0 and 1.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n    else:\n        groundR = 0.25\n        print 'No value found for groundReflectivity_.  The ground reflectivity will be set to 0.25 for grass or light bare soil.'\n    \n    #Check the clothing absorptivity.\n    checkData5 = True\n    if clothingAbsorptivity_ != None:\n        if clothingAbsorptivity_ < 1 and clothingAbsorptivity_ > 0:\n            cloA = clothingAbsorptivity_\n        else:\n            cloA = None\n            warning = 'clothingAbsorptivity_ must be a value between 0 and 1.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n    else:\n        cloA = 0.7\n        print 'No value found for clothingAbsorptivity_.  The clothing absorptivity will be set to 0.7 for (average/brown) skin and average clothing.'\n    \n    #Check the windowTransmissivity_.\n    winTrans = []\n    if windowTransmissivity_ != []:\n        if len(windowTransmissivity_) == 8760:\n            allGood = True\n            for transVal in windowTransmissivity_:\n                transFloat = float(transVal)\n                if transFloat <= 1.0 and transFloat >= 0.0: winTrans.append(transFloat)\n                else: allGood = False\n            if allGood == False:\n                warning = 'windowTransmissivity_ must be a value between 0 and 1.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n        elif len(windowTransmissivity_) == 1:\n            if windowTransmissivity_[0] <= 1.0 and windowTransmissivity_[0] >= 0.0:\n                for count in range(8760):\n                    winTrans.append(windowTransmissivity_[0])\n            else:\n                warning = 'windowTransmissivity_ must be a value between 0 and 1.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n        else:\n            warning = 'windowTransmissivity_ must be either a list of 8760 values that correspond to hourly changing transmissivity over the year or a single constant value for the whole year.'\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n            return -1\n    else:\n        for count in range(8760):\n            winTrans.append(1)\n        print 'No value found for windowTransmissivity_.  The window transmissivity will be set to 1.0 for a fully outdoor calculation.'\n    \n    #Set the default parallel to False.\n    if parallel_ == None: parallel = False\n    else: parallel = parallel_\n    \n    #Make the default analyisis period for the whole year if the user has not input one.\n    checkData9 = True\n    periodMethod = 0\n    if analysisPeriodOrHOY_ == []:\n        if methodInit == 2:\n            analysisPeriodOrHOY = [(1,1,1),(12,31,24)]\n        else:\n            analysisPeriodOrHOY = 8508\n            periodMethod = 1\n    else:\n        #Check if the analysis period is an hour of the year or an HOY\n        try:\n            analysisPeriodOrHOY = int(analysisPeriodOrHOY_[0])\n            periodMethod = 1\n            if analysisPeriodOrHOY < 1 or analysisPeriodOrHOY > 8760:\n                checkData9 = False\n                warning = 'Hour of the year input for analysisPeriodOrHOY_ must be either a value between 1 and 8760.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        except:\n            analysisPeriodOrHOY = analysisPeriodOrHOY_\n    \n    #Set a north vector if there is not oe already.\n    if north_ != None:\n        northAngle, northVector = lb_preparation.angle2north(north_)\n    else:\n        northVector = rc.Geometry.Vector3d.YAxis\n        northAngle = 0.0\n    \n    #Set a default tempOrRad to false.\n    try:\n        if tempOrRad_ != None: tempOrRad = tempOrRad_\n        else: tempOrRad = False\n    except: tempOrRad = False\n    \n    #Set a default rotationAngle to 0.0.\n    try:\n        if rotationAngle_ != None: rotationAngle = rotationAngle_\n        else: rotationAngle = 0.0\n    except: rotationAngle = 0.0\n    \n    #Set a default _baseDryBulbOrMRT_.\n    if _baseDryBulbOrMRT_ != None: baseTempType = _baseDryBulbOrMRT_\n    else: baseTempType = True\n    \n    #Check to see if the user has connected valid relative humidity data.\n    checkData2 = False\n    infraredRad = []\n    try:\n        if baseTempType == True:\n            try:\n                if \"Infrared Radiation\" in _horizInfraredRad_[2]:\n                    infraredRad = _horizInfraredRad_[7:]\n                    checkData2 = True\n                    epwData = True\n                    epwStr = _horizInfraredRad_[0:7]\n            except: pass\n            if checkData2 == False:\n                for item in _horizInfraredRad_:\n                    try:\n                        infraredRad.append(float(item))\n                        checkData2 = True\n                    except: checkData2 = False\n            if checkData2 == False:\n                warning = '_horizInfraredRad_ input does not contain valid long wave sky radiation values.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n        \n        \n        #If there is only one value for MRT, duplicate it 8760 times.\n        if len(infraredRad) < 8760 and len(infraredRad) !=0:\n            if len(infraredRad) == 1:\n                dupData = []\n                for count in range(8760):\n                    dupData.append(infraredRad[0])\n                infraredRad = dupData\n            else:\n                warning = 'Input for _horizInfraredRad_ must be either the output of the import EPW component, a list of 8760 values, or a single relative humidity to be applied for every hour of the year.'\n                print warning\n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n                return -1\n    except: pass\n    \n    #Pull the location data from the inputs.\n    latitude = None\n    longitude = None\n    timeZone = None\n    try:\n        locList = _location.split('\\n')\n        for line in locList:\n            if \"Latitude\" in line: latitude = float(line.split(',')[0])\n            elif \"Longitude\" in line: longitude = float(line.split(',')[0])\n            elif \"Time Zone\" in line: timeZone = float(line.split(',')[0])\n    except:\n        warning = 'The connected _location is not a valid location from the \"Ladybug_Import EWP\" component or the \"Ladybug_Construct Location\" component.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    \n    return methodInit, baseTempType, radTemp, infraredRad, mannequinMesh, groundMesh, contextSrfs, groundR, cloA, winTrans, parallel, analysisPeriodOrHOY, periodMethod, latitude, longitude, timeZone, rotationAngle, northAngle, northVector, epwStr, conversionFac, cumSkyMtx, directSolarRad, diffSolarRad, location, tempOrRad, lb_preparation, lb_visualization, lb_mesh, lb_runStudy_GH, lb_comfortModels, lb_sunpath\n\n\ndef manageInputOutput(method, baseTempType):\n    #If some of the component inputs and outputs are not right, blot them out or change them.\n    for input in range(21):\n        if input == 2:\n            if method == 0 or method == 1:\n                ghenv.Component.Params.Input[input].NickName = \".\"\n                ghenv.Component.Params.Input[input].Name = \".\"\n                ghenv.Component.Params.Input[input].Description = \" \"\n            else:\n                ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n                ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n                ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n        elif input == 5 and baseTempType == False:\n            ghenv.Component.Params.Input[input].NickName = \".\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        elif input == 16 and method == 2:\n            ghenv.Component.Params.Input[input].NickName = \".\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        elif input == 17 and method == 2:\n            ghenv.Component.Params.Input[input].NickName = \".\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n        else:\n            ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n    \n    for output in range(12):\n        if output == 7 or output == 8 or output == 10 or output == 11:\n            if method == 2:\n                ghenv.Component.Params.Output[output].NickName = \".\"\n                ghenv.Component.Params.Output[output].Name = \".\"\n                ghenv.Component.Params.Output[output].Description = \" \"\n            else:\n                ghenv.Component.Params.Output[output].NickName = outputsDict[output][0]\n                ghenv.Component.Params.Output[output].Name = outputsDict[output][0]\n                ghenv.Component.Params.Output[output].Description = outputsDict[output][1]\n        else:\n            ghenv.Component.Params.Output[output].NickName = outputsDict[output][0]\n            ghenv.Component.Params.Output[output].Name = outputsDict[output][0]\n            ghenv.Component.Params.Output[output].Description = outputsDict[output][1]\n    \n    if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return False\n    else: return True\n\ndef restoreInputOutput():\n    for input in range(21):\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n    \n    for output in range(12):\n        ghenv.Component.Params.Output[output].NickName = outputsDict[output][0]\n        ghenv.Component.Params.Output[output].Name = outputsDict[output][0]\n        ghenv.Component.Params.Output[output].Description = outputsDict[output][1]\n\n\n\ndef runAnalyses(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs, parallel, cumSky_radiationStudy, conversionFac, northVector, lb_preparation, lb_mesh, lb_runStudy_GH):\n    RADIANCE_radiationStudy = []\n    if len(RADIANCE_radiationStudy)!=0:\n        pass\n    elif cumSky_radiationStudy != None and (len(cumSky_radiationStudy) == 456 or len(cumSky_radiationStudy) == 1752) and analysisSrfs:\n        indexList, listInfo = lb_preparation.separateList(cumSky_radiationStudy, lb_preparation.strToBeFound)\n        selList = []\n        for i in range(1):\n            [selList.append(float(x)) for x in cumSky_radiationStudy[indexList[i]+7:indexList[i+1]]]\n            \n        cumSky_radiationStudy = selList\n        if parallel:\n            try:\n                for geo in analysisSrfs + contextSrfs: geo.EnsurePrivateCopy()\n            except:\n                pass\n        \n        # join the meshes\n        joinedAnalysisMesh = lb_mesh.joinMesh(analysisSrfs)\n        if contextSrfs: joinedContext = lb_mesh.joinMesh(contextSrfs)\n        else: joinedContext = None\n        if len(cumSky_radiationStudy) == 145:\n            radResults, totalRadResults, intersectionMtx = lb_runStudy_GH.parallel_radCalculator(testPoints, ptsNormals, meshSrfAreas, joinedAnalysisMesh, joinedContext,\n                                    parallel, cumSky_radiationStudy, lb_preparation.TregenzaPatchesNormalVectors, conversionFac, 2200000000000000, northVector)\n        elif len(cumSky_radiationStudy) == 577:\n            radResults, totalRadResults, intersectionMtx = lb_runStudy_GH.parallel_radCalculator(testPoints, ptsNormals, meshSrfAreas, joinedAnalysisMesh, joinedContext,\n                                    parallel, cumSky_radiationStudy, lb_preparation.getReinhartPatchesNormalVectors(), conversionFac, 2200000000000000, northVector)\n                                    \n    \n    return radResults, totalRadResults, listInfo, intersectionMtx\n\ndef getHourlySky(daylightMtxDict, HOY):\n    # for presentation\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    stDate = lb_preparation.hour2Date(HOY, 1)\n    analysisP = ((stDate[1]+1, stDate[0], stDate[2]-1),(stDate[1]+1, stDate[0], stDate[2]))\n    \n    hourlyMtx = []\n    for patchNumber in daylightMtxDict.keys():\n        # first patch is the ground\n        #if patchNumber!=0:\n        hourlyMtx.append(daylightMtxDict[patchNumber][HOY])\n    return hourlyMtx, analysisP\n\ndef getCumulativeSky(daylightMtxDict, runningPeriod):\n    \n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    \n    def selectHourlyData(dataList, analysisPeriodOrHOY):\n        # read analysis period\n        stMonth, stDay, stHour, endMonth, endDay, endHour = lb_preparation.readRunPeriod(analysisPeriodOrHOY, False)\n        \n        selHourlyData =[];\n        \n        # select data\n        stAnnualHour = lb_preparation.date2Hour(stMonth, stDay, stHour)\n        endAnnualHour = lb_preparation.date2Hour(endMonth, endDay, endHour)\n        \n        # check it goes from the end of the year to the start of the year\n        if stAnnualHour < endAnnualHour:\n            for i, item in enumerate(dataList[stAnnualHour-1:endAnnualHour+1]):\n                if stHour-1 <= (i + stHour - 1)%24 <= endHour-1: selHourlyData.append(item)\n            type = True\n        else:\n            for i, item in enumerate(dataList[stAnnualHour-1:]):\n                if stHour-1 <= (i + stHour - 1)%24 <= endHour-1: selHourlyData.append(item)\n            for i, item in enumerate(dataList[:endAnnualHour + 1]):\n                if stHour-1 <= i %24 <= endHour-1: selHourlyData.append(item)\n            type = False\n        \n        return selHourlyData\n    \n    HOYS = selectHourlyData(range(8760), runningPeriod)\n    \n    hourlyMtx = []\n    for patchNumber in daylightMtxDict.keys():\n        cumulativeDifValue = 0\n        cumulativeDirValue = 0\n        # adding upp the values\n        try:\n            for HOY in HOYS:\n                difValue, dirValue = daylightMtxDict[patchNumber][HOY + 1]\n                cumulativeDifValue += difValue\n                cumulativeDirValue += dirValue \n        except Exception, e:\n            print `e`\n            \n        hourlyMtx.append([cumulativeDifValue/1000, cumulativeDirValue/1000])\n\n    return hourlyMtx\n\ndef prepareLBList(skyMtxLists, analysisPeriodOrHOY, locName, unit, removeDiffuse, removeDirect):\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    \n    # prepare the final output\n    stMonth, stDay, stHour, endMonth, endDay, endHour = lb_preparation.readRunPeriod(analysisPeriodOrHOY, False)\n    totalRad = [lb_preparation.strToBeFound, locName, \"Sky Patches' Total Radiation\", unit, 'NA', (stMonth, stDay, stHour), (endMonth, endDay, endHour)]\n    diffuseRad = [lb_preparation.strToBeFound, locName, \"Sky Patches' Diffuse Radiation\", unit, 'NA', (stMonth, stDay, stHour), (endMonth, endDay, endHour)]\n    directRad = [lb_preparation.strToBeFound, locName, \"Sky Patches' Direct Radiation\", unit, 'NA', (stMonth, stDay, stHour), (endMonth, endDay, endHour)]\n    \n    for radValues in skyMtxLists:\n        if not removeDiffuse and not removeDirect:\n            totalRad.append(sum(radValues))\n            diffuseRad.append(radValues[0])\n            directRad.append(radValues[1])\n        elif removeDiffuse and removeDirect:\n            totalRad.append(0)\n            diffuseRad.append(0)\n            directRad.append(0)\n        elif removeDirect:\n            totalRad.append(radValues[0])\n            diffuseRad.append(radValues[0])\n            directRad.append(0)\n        elif removeDiffuse:\n            totalRad.append(radValues[1])\n            diffuseRad.append(0)\n            directRad.append(radValues[1])\n    \n    return totalRad + diffuseRad + directRad\n\ndef resultVisualization(analysisSrfs, results, totalResults, legendPar, legendTitle, studyLayerName, checkTheName, l, listInfo, lb_preparation, lb_visualization):\n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    \n    colors = lb_visualization.gradientColor(results, lowB, highB, customColors)\n    \n    # color mesh surfaces\n    analysisSrfs = lb_visualization.colorMesh(colors, analysisSrfs)\n    \n    ## generate legend\n    # calculate the boundingbox to find the legendPosition\n    personGeo = analysisSrfs.DuplicateMesh()\n    personGeo.Faces.DeleteFaces([len(results)-1])\n    if sc.doc.ModelAbsoluteTolerance < 0.001: lb_visualization.calculateBB([personGeo])\n    elif sc.doc.ModelAbsoluteTolerance < 0.05:\n        initBoundBox = rc.Geometry.Mesh.GetBoundingBox(personGeo, rc.Geometry.Plane.WorldXY)\n        scalePlane = rc.Geometry.Plane(initBoundBox.Min, rc.Geometry.Vector3d.ZAxis)\n        scaleTrans = rc.Geometry.Transform.Scale(scalePlane, 1.5, 1.5, 1.5)\n        initBoundBox.Transform(scaleTrans)\n        finBBox = initBoundBox.ToBrep()\n        lb_visualization.calculateBB([finBBox])\n    else:\n        warning = 'Your Rhino model tolerance is not small enough and this will cause the legend text to display weirdly or the text function to fail.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        initBoundBox = rc.Geometry.Mesh.GetBoundingBox(personGeo, rc.Geometry.Plane.WorldXY)\n        scalePlane = rc.Geometry.Plane(initBoundBox.Min, rc.Geometry.Vector3d.ZAxis)\n        scaleTrans = rc.Geometry.Transform.Scale(scalePlane, 2, 2, 2)\n        initBoundBox.Transform(scaleTrans)\n        finBBox = initBoundBox.ToBrep()\n        lb_visualization.calculateBB([finBBox])\n    \n    # legend geometry\n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(results, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    \n    # legend colors\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n    # color legend surfaces\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n\n    customHeading = '\\n\\nSolar Adjusted Radiant Temperature'\n    titleTextCurve, titleStr, titlebasePt = lb_visualization.createTitle([listInfo[0]], lb_visualization.BoundingBoxPar, legendScale, customHeading, False, legendFont, legendFontSize, legendBold)\n    \n    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\n    \n    \n    return analysisSrfs, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], l, legendBasePoint, legendSrfs, legendText+[titleStr], textPt+[titlebasePt], textSize, legendFont, decimalPlaces\n\n\ndef convertFluxToTemp(radiantFlux, cloA, fracEff, radTransCoeff, currentRT, avgWinTrans, energyConvertFac):\n    newFlux = avgWinTrans*radiantFlux*energyConvertFac\n    ERFsolar = (newFlux * cloA)/0.95\n    avgRTDelt = (ERFsolar/(fracEff*radTransCoeff))\n    avgRT = currentRT + avgRTDelt\n    \n    return avgRT\n\ndef computeSkyTemp(La):\n    # formula by Man-ENvironment heat EXchange model (MENEX_2005)\n    # incoming long-wave radiation emitted from the sky hemisphere, in W/m2\n    skyTemp = (((La) / (0.95*5.667*(10**(-8))))**(0.25)) - 273\n    \n    return skyTemp\n\ndef main(method, baseTempType, radTemp, infraredRad, mannequinMesh, groundMesh, contextSrfs, groundR, cloA, winTrans, parallel, analysisPeriodOrHOY, periodMethod, latitude, longitude, timeZone, northAngle, northVector, epwStr, conversionFac, cumSkyMtx, location, tempOrRad, lb_preparation, lb_visualization, lb_mesh, lb_runStudy_GH, lb_comfortModels, lb_sunpath):\n    #Define lists to be filled and put headers on them.\n    ERF = []\n    MRTDelta = []\n    solarAdjustedMRT = []\n    \n    #Define the fraction of the body visible to radiation.\n    if bodyPosture_ == 0 or bodyPosture_ == 3:\n        fracEff = 0.725\n    elif bodyPosture_ == 1 or bodyPosture_ == 4 or bodyPosture_ == None:\n        fracEff = 0.696\n    else:\n        fracEff = 0.68\n    \n    #Define a good guess of a radiative heat transfer coefficient.\n    radTransCoeff = 6.012\n    \n    #Get a list of HOYs for the analysis period\n    if periodMethod == 0: HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriodOrHOY, 1)\n    else: HOYS = [analysisPeriodOrHOY]\n    \n    #Compute the existing ERF for the analysis period.\n    skyTemp = []\n    newRadTemp = []\n    for hour in HOYS:\n        newRadTemp.append(radTemp[hour-1])\n        if baseTempType == True:\n            skyTemp.append(computeSkyTemp(infraredRad[hour-1]))\n    radTemp = newRadTemp\n    \n    #Calculate the sun-up hours of the year to help make things faster down the road.\n    lb_sunpath.initTheClass(float(latitude), northAngle, rc.Geometry.Point3d.Origin, 100, float(longitude), float(timeZone))\n    altitudes = []\n    finalWinTransmiss = []\n    for hour in HOYS:\n        d, m, t = lb_preparation.hour2Date(hour, True)\n        lb_sunpath.solInitOutput(m+1, d, t)\n        altitude = lb_sunpath.solAlt\n        altitudes.append(altitude)\n        finalWinTransmiss.append(winTrans[hour-1])\n    \n    #Process the cumulative sky into an initial selected sky.\n    skyMtxLists = []\n    if periodMethod == 0: skyMtxLists = getCumulativeSky(cumSkyMtx.d, analysisPeriodOrHOY)\n    else: skyMtxLists, analysisPeriodTxt = getHourlySky(cumSkyMtx.d, analysisPeriodOrHOY)\n    \n    #Set a unit for the analysis.\n    if len(HOYS) == 1: unit = 'Wh'\n    else: unit = 'kWh'\n    \n    if len(skyMtxLists)!=0:\n        if periodMethod == 0: selectedSkyMtx = prepareLBList(skyMtxLists, analysisPeriodOrHOY, location, unit, False, False)\n        else: selectedSkyMtx = prepareLBList(skyMtxLists, analysisPeriodTxt, location, unit, False, False)\n        cumSky_radiationStudy = selectedSkyMtx\n        \n        #Set defaults.\n        disFromBase = 0.01\n        analysisSrfs = []\n        for mesh in mannequinMesh:\n             analysisSrfs.append(mesh)\n        analysisSrfs.append(groundMesh)\n        \n        ## extract test points\n        testPoints, ptsNormals, meshSrfAreas = lb_mesh.parallel_testPointCalculator(analysisSrfs, float(disFromBase), parallel)\n        originalTestPoints = testPoints\n        testPoints = lb_preparation.flattenList(testPoints)\n        \n        ptsNormals = lb_preparation.flattenList(ptsNormals)\n        meshSrfAreas = lb_preparation.flattenList(meshSrfAreas)\n        \n        #Get an intersection matrix of the geometry and the sky and some results for the whole analysis period.\n        radResults, totalRadResults, listInfo, intersectionMtx = runAnalyses(testPoints, ptsNormals, meshSrfAreas, analysisSrfs, contextSrfs, parallel, cumSky_radiationStudy, conversionFac, northVector, lb_preparation, lb_mesh, lb_runStudy_GH)\n        \n        if radResults:\n            #Analyse the person mech.\n            personMeshAreas = []\n            for area in meshSrfAreas[:-1]:\n                personMeshAreas.append(area*conversionFac*conversionFac)\n            if method == 0:\n                totalPersonArea = sum(personMeshAreas)\n            elif method == 1:\n                totalPersonArea = 1.775\n            \n            #Compute the sky view of each mesh face and an average sky view over the body.\n            skyViews = []\n            if baseTempType == True:\n                avgSkyTemp = sum(skyTemp)/len(skyTemp)\n                for ptCount in intersectionMtx.keys():\n                    skyView = 0\n                    numPatches = len(intersectionMtx[ptCount].keys())\n                    for patchCount in intersectionMtx[ptCount].keys():\n                        if intersectionMtx[ptCount][patchCount]['isIntersect']:\n                            skyView = skyView + 1/numPatches\n                    skyViews.append(skyView)\n                skyViewFac = 0\n                for count, area in enumerate(personMeshAreas):\n                    skyViewFac = skyViewFac + ((area/totalPersonArea) * skyViews[count])\n            \n            #Convert Rad results to radiant temperature.\n            if tempOrRad == True:\n                unit = 'C'\n                avgWinTrans = sum(finalWinTransmiss)/len(finalWinTransmiss)\n                currentRT = sum(radTemp)/len(radTemp)\n                meshResults = []\n                for count, flux in enumerate(radResults):\n                    if periodMethod == 0: energyConvertFac = 500\n                    else: energyConvertFac = 1\n                    avgFlux = flux/len(radTemp)\n                    if baseTempType == True:\n                        currentRT = sum(radTemp)/len(radTemp)\n                        currentRT = (avgSkyTemp*skyViews[count]) + (currentRT*(1-(skyViews[count])))\n                    convertRadTemp = convertFluxToTemp(avgFlux, cloA, fracEff, radTransCoeff, currentRT, avgWinTrans, energyConvertFac)\n                    meshResults.append(convertRadTemp)\n            else: meshResults = radResults\n            \n            #Make a colored mesh of the mannequin for the whole analysis period.\n            resultColored = []\n            legendColored = []\n            studyLayerNames = \"RADIATION_STUDIES\"\n            \n            if radResults!= None:\n                resultColored, legendColored, l, legendBasePoint, legendSrfs, allTxt, allTxtPt, fontSize, legendFont, decimalPlaces = resultVisualization(analysisSrfs, meshResults, totalRadResults, legendPar_, unit, studyLayerNames, True, 0, listInfo, lb_preparation, lb_visualization)\n            \n            #Remove the ground mesh, which is the last one.\n            resultColored.Faces.DeleteFaces([len(radResults)-1])\n            \n            #Unpack the legend.\n            legend = []\n            legend.append(legendColored[0])\n            for item in legendColored[1]:\n                legend.append(item)\n            \n            intDict = intersectionMtx\n            \n            #Add the headers to the computed lists.\n            if periodMethod == 0:\n                analysisStart = analysisPeriodOrHOY[0]\n                analysisEnd = analysisPeriodOrHOY[1]\n            else:\n                stDate = lb_preparation.hour2Date(analysisPeriodOrHOY)\n                analysisStart = stDate\n                analysisEnd = stDate\n            ERF.append('key:location/dataType/units/frequency/startsAt/endsAt')\n            ERF.append(str(location))\n            ERF.append('Effective Radiant Field')\n            ERF.append('kWh/m2')\n            ERF.append('Hourly')\n            ERF.append(analysisStart)\n            ERF.append(analysisEnd)\n            \n            MRTDelta.append('key:location/dataType/units/frequency/startsAt/endsAt')\n            MRTDelta.append(str(location))\n            MRTDelta.append('Short Wave MRT Delta')\n            MRTDelta.append('C')\n            MRTDelta.append('Hourly')\n            MRTDelta.append(analysisStart)\n            MRTDelta.append(analysisEnd)\n            \n            solarAdjustedMRT.append('key:location/dataType/units/frequency/startsAt/endsAt')\n            solarAdjustedMRT.append(str(location))\n            solarAdjustedMRT.append('Solar-Adjusted Mean Radiant Temperature')\n            solarAdjustedMRT.append('C')\n            solarAdjustedMRT.append('Hourly')\n            solarAdjustedMRT.append(analysisStart)\n            solarAdjustedMRT.append(analysisEnd)\n            \n            #Define functions for computing the radiation for each hour, which is in parallal and not in parallel.\n            def nonParallelRadCalc():\n                try:\n                    for count, hour in enumerate(HOYS):\n                        if gh.GH_Document.IsEscapeKeyDown(): assert False\n                        \n                        if count != len(HOYS)-1: lastVal = 1\n                        else: lastVal = 0\n                        if altitudes[count] > 0 or altitudes[count-1] > 0 or altitudes[count+lastVal] > 0:\n                            skyMtxLists, _analysisPeriodOrHOY_ = getHourlySky(cumSkyMtx.d, hour)\n                            selSkyMatrix = prepareLBList(skyMtxLists, _analysisPeriodOrHOY_, location, unit, False, False)\n                            \n                            indexList, listInfo = lb_preparation.separateList(selSkyMatrix, lb_preparation.strToBeFound)\n                            #separate total, diffuse and direct radiations\n                            separatedLists = []\n                            for i in range(len(indexList)-1):\n                                selList = []\n                                [selList.append(float(x)) for x in selSkyMatrix[indexList[i] + 7:indexList[i+1]]]\n                                separatedLists.append(selList)\n                            \n                            skyMatrix = separatedLists[0]\n                            \n                            radiationResult = []\n                            for ptCount in  intDict.keys():\n                                radValue = 0\n                                for patchCount in intDict[ptCount].keys():\n                                    if intDict[ptCount][patchCount]['isIntersect']:\n                                        radValue = radValue + (skyMatrix[patchCount] * math.cos(intDict[ptCount][patchCount]['vecAngle']))\n                                radiationResult.append(radValue)\n                            \n                            personRad = radiationResult[:-1]\n                            groundRad = radiationResult[-1]\n                            totalPersonBeamDiffRad = sum([a*b for a,b in zip(personRad,personMeshAreas)])\n                            \n                            #Account for the transmissivity of glass.\n                            if finalWinTransmiss[count] != 1:\n                                groundRad = groundRad*(finalWinTransmiss[count])\n                                totalPersonBeamDiffRad = totalPersonBeamDiffRad*(finalWinTransmiss[count])\n                            \n                            #Calculate the additional radiation reflected to the person by the ground.\n                            groundRefRad = 0.5 * groundRad * fracEff * groundR\n                            \n                            #Calculate the total person radiation and the ERF.\n                            totalPersonRad = totalPersonBeamDiffRad + groundRefRad\n                            radiantFlux = totalPersonRad/totalPersonArea\n                            hourERF = (radiantFlux * cloA)/0.95\n                            ERF.append(hourERF/1000)\n                            \n                            #Calculate the MRT delta, the solar adjusted MRT, and the solar adjusted operative temperature.\n                            mrtDelt = (hourERF/(fracEff*radTransCoeff))\n                            MRTDelta.append(mrtDelt)\n                            if baseTempType == False:\n                                hourMRT = mrtDelt + (radTemp[count])\n                            else:\n                                hourMRT = mrtDelt + (skyTemp[count]*(skyViewFac) + radTemp[count]*(1-(skyViewFac)))\n                            solarAdjustedMRT.append(hourMRT)\n                        else:\n                            ERF.append(0)\n                            MRTDelta.append(0)\n                            if baseTempType == False:\n                                hourMRT = radTemp[count]\n                            else:\n                                hourMRT = (skyTemp[count]*(skyViewFac) + radTemp[count]*(1-(skyViewFac)))\n                            solarAdjustedMRT.append(hourMRT)\n                    return True\n                except:\n                    print \"The calculation has been terminated by the user!\"\n                    e = gh.GH_RuntimeMessageLevel.Warning\n                    ghenv.Component.AddRuntimeMessage(e, \"The calculation has been terminated by the user!\")\n                    return False\n            \n            def parallelRadCalc():\n                def radCalc(count):\n                    if count != len(HOYS)-1: lastVal = 1\n                    else: lastVal = 0\n                    if altitudes[count] > 0 or altitudes[count-1] > 0 or altitudes[count+lastVal] > 0:\n                        skyMtxLists, _analysisPeriodOrHOY_ = getHourlySky(cumSkyMtx.d, HOYS[count])\n                        selSkyMatrix = prepareLBList(skyMtxLists, _analysisPeriodOrHOY_, location, unit, False, False)\n                        \n                        indexList, listInfo = lb_preparation.separateList(selSkyMatrix, lb_preparation.strToBeFound)\n                        #separate total, diffuse and direct radiations\n                        separatedLists = []\n                        for i in range(len(indexList)-1):\n                            selList = []\n                            [selList.append(float(x)) for x in selSkyMatrix[indexList[i] + 7:indexList[i+1]]]\n                            separatedLists.append(selList)\n                        \n                        skyMatrix = separatedLists[0]\n                        \n                        radiationResult = []\n                        for ptCount in  intDict.keys():\n                            radValue = 0\n                            for patchCount in intDict[ptCount].keys():\n                                if intDict[ptCount][patchCount]['isIntersect']:\n                                    radValue = radValue + (skyMatrix[patchCount] * math.cos(intDict[ptCount][patchCount]['vecAngle']))\n                            radiationResult.append(radValue)\n                        \n                        personRad = radiationResult[:-1]\n                        groundRad = radiationResult[-1]\n                        totalPersonBeamDiffRad = sum([a*b for a,b in zip(personRad,personMeshAreas)])\n                        \n                        #Account for the transmissivity of glass.\n                        if (finalWinTransmiss[count]) != 1:\n                            groundRad = groundRad*(finalWinTransmiss[count])\n                            totalPersonBeamDiffRad = totalPersonBeamDiffRad*(finalWinTransmiss[count])\n                        \n                        #Calculate the additional radiation reflected to the person by the ground.\n                        groundRefRad = 0.5 * groundRad * fracEff * groundR\n                        \n                        #Calculate the total person radiation and the ERF.\n                        totalPersonRad = totalPersonBeamDiffRad + groundRefRad\n                        radiantFlux = totalPersonRad/totalPersonArea\n                        hourERF = (radiantFlux * cloA)/0.95\n                        ERF[count+7] = hourERF/1000\n                        \n                        #Calculate the MRT delta, the solar adjusted MRT, and the solar adjusted operative temperature.\n                        mrtDelt = (hourERF/(fracEff*radTransCoeff))\n                        MRTDelta[count+7] = mrtDelt\n                        if baseTempType == False:\n                            hourMRT = mrtDelt + (radTemp[count])\n                        else:\n                            hourMRT = mrtDelt + (skyTemp[count]*(skyViewFac) + radTemp[count]*(1-(skyViewFac)))\n                        solarAdjustedMRT[count+7] = hourMRT\n                    else:\n                        ERF[count+7] = 0\n                        MRTDelta[count+7] = 0\n                        if baseTempType == False:\n                            hourMRT = radTemp[count]\n                        else:\n                            hourMRT = (skyTemp[count]*(skyViewFac) + radTemp[count]*(1-(skyViewFac)))\n                        solarAdjustedMRT[count+7] = hourMRT\n                \n                \n                tasks.Parallel.ForEach(range(len(HOYS)), radCalc)\n                \n                return True\n            \n            # Compute the radiation for each hour of the year.\n            runSuccess = False\n            if parallel == False:\n                runSuccess = nonParallelRadCalc()\n            else:\n                for count, hour in enumerate(HOYS):\n                    ERF.append(0)\n                    MRTDelta.append(0)\n                    solarAdjustedMRT.append(0)\n                runSuccess = parallelRadCalc()\n            \n            if runSuccess == True:\n                #If the user has requested to bake the results, then bake them.\n                if bakeIt_ > 0:\n                    #Set up the new layer.\n                    studyLayerName = 'SOLAR_TEMPERATURE'\n                    placeName = _location.split('\\n')[1]\n                    try:\n                        if len(analysisPeriodOrHOY) != 1: 'AnalysisPeriod = ' + str(analysisPeriodOrHOY)\n                    except: analysisTime = 'HOY = ' + str(analysisPeriodOrHOY)\n                    newLayerIndex, l = lb_visualization.setupLayers(analysisTime, 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\n                    #Bake the objects.\n                    if bakeIt_ == 1: lb_visualization.bakeObjects(newLayerIndex, resultColored, legendSrfs, allTxt, allTxtPt, fontSize, legendFont, None, decimalPlaces, True)\n                    else: lb_visualization.bakeObjects(newLayerIndex, resultColored, legendSrfs, allTxt, allTxtPt, fontSize, legendFont, None, decimalPlaces, False)\n                \n                \n                return ERF, MRTDelta, solarAdjustedMRT, resultColored, legend, legendBasePoint, meshResults, meshSrfAreas\n            else:\n                print \"The calculation has been terminated by the user!\"\n                e = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(e, \"The calculation has been terminated by the user!\")\n                return -1\n        else:\n            return -1\n            warning = \"Rad Study was cancelled by user.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    else:\n        return -1\n        warning = \"cumulativeSkyMtx failed to collect data.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n\n\ndef mainSimple(baseTempType, radTemp, infraredRad, mannequinMesh, context, groundR, cloA, winTrans, analysisPeriodOrHOY, periodMethod, latitude, longitude, timeZone, rotationAngle, northAngle, northVector, epwStr, directSolarRad, diffSolarRad, location, parallel, lb_preparation, lb_comfortModels, lb_sunpath):\n    #Define lists to be filled and put headers on them.\n    ERF = []\n    MRTDelta = []\n    solarAdjustedMRT = []\n    \n    #Define the fraction of the body visible to radiation.\n    if bodyPosture_ == 0 or bodyPosture_ == 3:\n        fracEff = 0.725\n    elif bodyPosture_ == 1 or bodyPosture_ == 4 or bodyPosture_ == None:\n        fracEff = 0.696\n    else:\n        fracEff = 0.68\n    \n    #Define a good guess of a radiative heat transfer coefficient.\n    radTransCoeff = 6.012\n    \n    #Get a list of HOYs for the analysis period\n    if periodMethod == 0: HOYS, months, days = lb_preparation.getHOYsBasedOnPeriod(analysisPeriodOrHOY, 1)\n    else: HOYS = [analysisPeriodOrHOY]\n    \n    #Compute the existing ERF for the analysis period.\n    skyTemp = []\n    newRadTemp = []\n    for hour in HOYS:\n        newRadTemp.append(radTemp[hour-1])\n        if baseTempType == True:\n            skyTemp.append(computeSkyTemp(infraredRad[hour-1]))\n    radTemp = newRadTemp\n    \n    #Calculate the sun-up hours of the year in order to understand whether the context geometry will block the sun.\n    lb_sunpath.initTheClass(float(latitude), northAngle, rc.Geometry.Point3d.Origin, 100, float(longitude), float(timeZone))\n    altitudes = []\n    azimuths = []\n    sunVectors = []\n    for hour in HOYS:\n        d, m, t = lb_preparation.hour2Date(hour, True)\n        lb_sunpath.solInitOutput(m+1, d, t)\n        altitude = lb_sunpath.solAlt\n        altitudes.append(altitude)\n        azimuths.append(lb_sunpath.solAz)\n        if altitude > 0:\n            sunVec = lb_sunpath.sunReverseVectorCalc()\n            sunVectors.append(sunVec)\n        else: sunVectors.append(None)\n    \n    for ptCount, manMeshPt in enumerate(mannequinMesh):\n        # Make the lists to be filled.\n        ERF.append([])\n        MRTDelta.append([])\n        solarAdjustedMRT.append([])\n        #Add the headers to the computed lists.\n        if periodMethod == 0:\n            analysisStart = analysisPeriodOrHOY[0]\n            analysisEnd = analysisPeriodOrHOY[1]\n        else:\n            stDate = lb_preparation.hour2Date(analysisPeriodOrHOY)\n            analysisStart = stDate\n            analysisEnd = stDate\n        ERF[ptCount].append('key:location/dataType/units/frequency/startsAt/endsAt')\n        ERF[ptCount].append(str(location))\n        ERF[ptCount].append('Effective Radiant Field')\n        ERF[ptCount].append('kWh/m2')\n        ERF[ptCount].append('Hourly')\n        ERF[ptCount].append(analysisStart)\n        ERF[ptCount].append(analysisEnd)\n        \n        MRTDelta[ptCount].append('key:location/dataType/units/frequency/startsAt/endsAt')\n        MRTDelta[ptCount].append(str(location))\n        MRTDelta[ptCount].append('Short Wave MRT Delta')\n        MRTDelta[ptCount].append('C')\n        MRTDelta[ptCount].append('Hourly')\n        MRTDelta[ptCount].append(analysisStart)\n        MRTDelta[ptCount].append(analysisEnd)\n        \n        solarAdjustedMRT[ptCount].append('key:location/dataType/units/frequency/startsAt/endsAt')\n        solarAdjustedMRT[ptCount].append(str(location))\n        solarAdjustedMRT[ptCount].append('Solar-Adjusted Mean Radiant Temperature')\n        solarAdjustedMRT[ptCount].append('C')\n        solarAdjustedMRT[ptCount].append('Hourly')\n        solarAdjustedMRT[ptCount].append(analysisStart)\n        solarAdjustedMRT[ptCount].append(analysisEnd)\n        \n        \n        #Calculate the skyview factor of the occupant.\n        if bodyPosture_ == None or bodyPosture_ == 0 or bodyPosture_ == 1 or bodyPosture_ == 2: middlePt = manMeshPt[4]\n        else: middlePt = manMeshPt[1]\n        \n        if len(context) > 0:\n            viewVectors = []\n            viewTuples = lb_preparation.TregenzaPatchesNormalVectors\n            for tuple in viewTuples:\n                viewVectors.append(rc.Geometry.Vector3d(tuple[0], tuple[1], tuple[2]))\n            totalVecNum = len(viewVectors)\n            vecBlockedList = []\n            for viewVec in viewVectors:\n                viewRay = rc.Geometry.Ray3d(middlePt, viewVec)\n                viewBlocked = False\n                for mesh in context:\n                    rayIntersect = rc.Geometry.Intersect.Intersection.MeshRay(mesh, viewRay)\n                    if rayIntersect > 0: viewBlocked = True\n                if viewBlocked == True: vecBlockedList.append(1)\n            skyViewFac = 1 - sum(vecBlockedList)/totalVecNum\n        else: skyViewFac = 1\n        \n        \n        #Compute all of the outputs.\n        def nonParallelMRTCalc():\n            try:\n                for count, hour in enumerate(HOYS):\n                    if gh.GH_Document.IsEscapeKeyDown(): assert False\n                    \n                    if altitudes[count] > 0:\n                        #Calculate fBes, the fraction of the body that is visible to the sun and is not blocked by the context.\n                        if len(context) > 0:\n                            #First get the sunRays.\n                            sunRays = []\n                            for point in manMeshPt:\n                                sunRay = rc.Geometry.Ray3d(point, sunVectors[count])\n                                sunRays.append(sunRay)\n                            \n                            #Next check how many of the sunrays are blocked.\n                            fBesList = []\n                            for ray in sunRays:\n                                sunBlocked = False\n                                for mesh in context:\n                                    rayIntersect = rc.Geometry.Intersect.Intersection.MeshRay(mesh, ray)\n                                    if rayIntersect > 0: sunBlocked = True\n                                if sunBlocked == False:fBesList.append(1)\n                                else: fBesList.append(0)\n                            \n                            #Finally, calculate Fbes from that which was blocked.\n                            fBes = sum(fBesList)/len(fBesList)\n                        else:\n                            fBes = 1\n                        \n                        if fBes > 0.0:\n                            #Calculate the diffuse, direct, and global horizontal components of the solar radiation.\n                            diffRad = diffSolarRad[hour-1]\n                            dirNormRad = directSolarRad[hour-1]\n                            globHorizRad = float(dirNormRad)*(math.sin(altitudes[count])) + diffRad\n                            \n                            #Calculate solar horizontal angle relative to front of person (SHARP).\n                            solarAz = math.degrees(azimuths[count])\n                            bodyAz = rotationAngle\n                            if bodyAz > 360:\n                                while bodyAz > 360:\n                                    bodyAz = bodyAz-360\n                            elif bodyAz < -360:\n                                while bodyAz > 360:\n                                    bodyAz = bodyAz-360\n                            angle_diff = abs(solarAz - bodyAz)\n                            if angle_diff <= 180:\n                                azFinal = int(angle_diff)\n                            else:\n                                azFinal = int(360 - angle_diff)\n                            \n                            #Define the Altitude as the SolarCal function understands it.\n                            altInit = int(math.degrees(altitudes[count]))\n                            if altInit > 90: altFinal = altInit-90\n                            else: altFinal = altInit\n                            \n                            #Calculate the projected area factor from the altitude and azimuth.\n                            if bodyPosture_ == 0 or bodyPosture_ == 3:\n                                ProjAreaFac = lb_comfortModels.splineStand(azFinal, altFinal)\n                            elif bodyPosture_ == 1 or bodyPosture_ == 4 or bodyPosture_ == None:\n                                ProjAreaFac = lb_comfortModels.splineSit(azFinal, altFinal)\n                            else:\n                                ProjAreaFac = lb_comfortModels.splineStand(azFinal, 90-altFinal)\n                            \n                            # Calculate the ERF of the occupant\n                            hourERF = ((0.5*fracEff*skyViewFac*(diffRad + (globHorizRad*groundR))+ (fracEff*ProjAreaFac*fBes*float(dirNormRad)))*winTrans[hour-1])*(cloA/0.95)\n                            \n                            ERF[ptCount].append(hourERF)\n                            #Calculate the MRT delta, the solar adjusted MRT, and the solar adjusted operative temperature.\n                            mrtDelt = (hourERF/(fracEff*radTransCoeff))\n                            MRTDelta[ptCount].append(mrtDelt)\n                            if baseTempType == False:\n                                hourMRT = mrtDelt + (radTemp[count])\n                            else:\n                                hourMRT = mrtDelt + (skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2)))\n                            solarAdjustedMRT[ptCount].append(hourMRT)\n                        else:\n                            ERF[ptCount].append(0)\n                            MRTDelta[ptCount].append(0)\n                            if baseTempType == False:\n                                solarAdjustedMRT[ptCount].append(radTemp[count])\n                            else:\n                                solarAdjustedMRT[ptCount].append((skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2))))\n                    else:\n                        ERF[ptCount].append(0)\n                        MRTDelta[ptCount].append(0)\n                        if baseTempType == False:\n                            solarAdjustedMRT[ptCount].append(radTemp[count])\n                        else:\n                            solarAdjustedMRT[ptCount].append((skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2))))\n                return True\n            except:\n                print \"The calculation has been terminated by the user!\"\n                e = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(e, \"The calculation has been terminated by the user!\")\n                return False\n        \n        def parallelMRTCalc():\n            def MRTCalc(count):\n                if altitudes[count] > 0:\n                    #Calculate fBes, the fraction of the body that is visible to the sun and is not blocked by the context.\n                    if len(context) > 0:\n                        #First get the sunRays.\n                        sunRays = []\n                        for point in manMeshPt:\n                            sunRay = rc.Geometry.Ray3d(point, sunVectors[count])\n                            sunRays.append(sunRay)\n                        \n                        #Next check how many of the sunrays are blocked.\n                        fBesList = []\n                        for ray in sunRays:\n                            sunBlocked = False\n                            for mesh in context:\n                                rayIntersect = rc.Geometry.Intersect.Intersection.MeshRay(mesh, ray)\n                                if rayIntersect > 0: sunBlocked = True\n                            if sunBlocked == False:fBesList.append(1)\n                            else: fBesList.append(0)\n                        \n                        #Finally, calculate Fbes from that which was blocked.\n                        fBes = sum(fBesList)/len(fBesList)\n                    else:\n                        fBes = 1\n                    \n                    if fBes > 0.0:\n                        #Calculate the diffuse, direct, and global horizontal components of the solar radiation.\n                        diffRad = diffSolarRad[HOYS[count]-1]\n                        dirNormRad = directSolarRad[HOYS[count]-1]\n                        globHorizRad = dirNormRad*(math.sin(altitudes[count])) + diffRad\n                        \n                        #Calculate solar horizontal angle relative to front of person (SHARP).\n                        solarAz = math.degrees(azimuths[count])\n                        bodyAz = rotationAngle\n                        if bodyAz > 360:\n                            while bodyAz > 360:\n                                bodyAz = bodyAz-360\n                        elif bodyAz < -360:\n                            while bodyAz > 360:\n                                bodyAz = bodyAz-360\n                        angle_diff = abs(solarAz - bodyAz)\n                        if angle_diff <= 180:\n                            azFinal = int(angle_diff)\n                        else:\n                            azFinal = int(360 - angle_diff)\n                        \n                        #Define the Altitude as the SolarCal function understands it.\n                        altInit = int(math.degrees(altitudes[count]))\n                        if altInit > 90: altFinal = altInit-90\n                        else: altFinal = altInit\n                        \n                        #Calculate the projected area factor from the altitude and azimuth.\n                        if bodyPosture_ == 0 or bodyPosture_ == 3:\n                            ProjAreaFac = lb_comfortModels.splineStand(azFinal, altFinal)\n                        elif bodyPosture_ == 1 or bodyPosture_ == 4 or bodyPosture_ == None:\n                            ProjAreaFac = lb_comfortModels.splineSit(azFinal, altFinal)\n                        else:\n                            ProjAreaFac = lb_comfortModels.splineStand(azFinal, 90-altFinal)\n                        \n                        # Calculate the ERF of the occupant\n                        hourERF = ((0.5*fracEff*skyViewFac*(diffRad + (globHorizRad*groundR))+ (fracEff*ProjAreaFac*fBes*dirNormRad))*winTrans[HOYS[count]-1])*(cloA/0.95)\n                        \n                        ERF[ptCount][count+7] = hourERF\n                        #Calculate the MRT delta, the solar adjusted MRT, and the solar adjusted operative temperature.\n                        mrtDelt = (hourERF/(fracEff*radTransCoeff))\n                        MRTDelta[ptCount][count+7] = mrtDelt\n                        if baseTempType == False:\n                            hourMRT = mrtDelt + (radTemp[count])\n                        else:\n                            hourMRT = mrtDelt + (skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2)))\n                        solarAdjustedMRT[ptCount][count+7] = hourMRT\n                    else:\n                        ERF[ptCount][count+7] = 0\n                        MRTDelta[ptCount][count+7] = 0\n                        if baseTempType == False:\n                            solarAdjustedMRT[ptCount][count+7] = radTemp[count]\n                        else:\n                            solarAdjustedMRT[ptCount][count+7] = (skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2)))\n                else:\n                    ERF[ptCount][count+7] = 0\n                    MRTDelta[ptCount][count+7] = 0\n                    if baseTempType == False:\n                        solarAdjustedMRT[ptCount][count+7] = radTemp[count]\n                    else:\n                        solarAdjustedMRT[ptCount][count+7] = (skyTemp[count]*(skyViewFac/2) + radTemp[count]*(1-(skyViewFac/2)))\n            \n            tasks.Parallel.ForEach(range(len(HOYS)), MRTCalc)\n        \n        # Compute the radiation for each hour of the year.\n        if parallel == False:\n            nonParallelMRTCalc()\n        else:\n            for count, hour in enumerate(HOYS):\n                ERF[ptCount].append(0)\n                MRTDelta[ptCount].append(0)\n                solarAdjustedMRT[ptCount].append(0)\n            parallelMRTCalc()\n    \n    return ERF, MRTDelta, solarAdjustedMRT\n\n\n\n\n\n#If Ladybug is not flying or is an older version, give a warning.\ninitCheck = True\ncheckInputOutput = False\n\n#Ladybug check.\nif not sc.sticky.has_key('ladybug_release') == True:\n    initCheck = False\n    print \"You should first let Ladybug fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Ladybug fly...\")\nelse:\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        ghenv.Component.AddRuntimeMessage(w, warning)\n\n\n\nif initCheck == True:\n    #Check the inputs\n    results = checkTheInputs()\n    if results!= -1:\n        method, baseTempType, radTemp, infraredRad, mannequinMesh, groundMesh, context, groundR, \\\n        cloA, winTrans, parallel, analysisPeriodOrHOY, periodMethod, latitude, longitude, \\\n        timeZone, rotationAngle, northAngle, northVector, epwStr, conversionFac, cumSkyMtx, \\\n        directSolarRad, diffSolarRad, location, tempOrRad, \\\n        lb_preparation, lb_visualization, lb_mesh, lb_runStudy_GH, lb_comfortModels,\\\n        lb_sunpath = results\n    #Change the inputs or outputs based on what is connected.\n    \n    if results!= -1:\n        checkInputOutput = manageInputOutput(method, baseTempType)\n    else: restoreInputOutput()\n    if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): checkInputOutput = False\n\n\nif _runIt == True and checkInputOutput == True:\n    if method == 0 or method == 1:\n        result = main(method, baseTempType, radTemp, infraredRad, mannequinMesh, \\\n        groundMesh, context, groundR, cloA, winTrans, parallel, analysisPeriodOrHOY, periodMethod, latitude, longitude, timeZone, northAngle, \\\n        northVector, epwStr, conversionFac, cumSkyMtx, location, tempOrRad, lb_preparation, lb_visualization, lb_mesh, \\\n        lb_runStudy_GH, lb_comfortModels, lb_sunpath)\n        if result != -1:\n            effectiveRadiantField, MRTDelta, solarAdjustedMRT, mannequinMesh, legend, legendBasePt, meshFaceResult, meshFaceArea = result\n    else:\n        result = mainSimple(baseTempType, radTemp, infraredRad, mannequinMesh, context, groundR, cloA, winTrans, analysisPeriodOrHOY, periodMethod, latitude, longitude, timeZone, rotationAngle, northAngle, northVector, epwStr, directSolarRad, diffSolarRad, location, parallel, lb_preparation, lb_comfortModels, lb_sunpath)\n        if result != -1:\n            effectiveRadiantFieldInit, MRTDeltaInit, solarAdjustedMRTInit = result\n            #Unpack the Data Trees of values.\n            effectiveRadiantField = DataTree[Object]()\n            MRTDelta = DataTree[Object]()\n            solarAdjustedMRT = DataTree[Object]()\n            mannequinMeshInit = mannequinMesh[:]\n            mannequinMesh = DataTree[Object]()\n            \n            for pCount, point in enumerate(effectiveRadiantFieldInit):\n                for iCount, item in enumerate(point):\n                    effectiveRadiantField.Add(item, GH_Path(pCount))\n                    MRTDelta.Add(MRTDeltaInit[pCount][iCount], GH_Path(pCount))\n                    solarAdjustedMRT.Add(solarAdjustedMRTInit[pCount][iCount], GH_Path(pCount))\n                    try:\n                        mannequinMesh.Add(mannequinMeshInit[pCount][iCount], GH_Path(pCount))\n                    except: pass\n\n#Hide the legend base point.\nghenv.Component.Params.Output[8].Hidden = True",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}