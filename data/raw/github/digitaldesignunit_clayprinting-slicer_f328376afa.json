{
  "source_url": "https://github.com/digitaldesignunit/clayprinting-slicer/blob/53537d912559e468aa7eac0c1c7942f48033251c/grasshopper_userobjects_src/DDUClayPrintingSlicer_PipelineController.py",
  "repo": "digitaldesignunit/clayprinting-slicer",
  "repo_stars": 4,
  "repo_description": "Open-Source Grasshopper-based slicer, primarily for printing clay on the WASP40100.",
  "license": "MIT",
  "filepath": "grasshopper_userobjects_src/DDUClayPrintingSlicer_PipelineController.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS\nimport time\n\n# RHINO SDK IMPORTS\nimport Grasshopper\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# CUSTOM RHINO IMPORTS\nimport scriptcontext as sc\nfrom scriptcontext import sticky as st\n\n# ADDITIONAL IMPORTS\nfrom System.Drawing import Color\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"PipelineController\"\nghenv.Component.NickName = \"PipelineController\"\nghenv.Component.Category = \"DDUClayPrintingSlicer\"\nghenv.Component.SubCategory = \"9 Utilities\"\n\n\nclass PipelineController(Grasshopper.Kernel.GH_ScriptInstance):\n    \"\"\"\n    Author: Max Benjamin Eschenbach\n    License: MIT License\n    Version: 250314\n    \"\"\"\n\n    # UNIQUE STICKY KEY OR STORING LAYERNAMES\n    LNKEY = str(ghenv.Component.InstanceGuid) + \"___LAYERNAMES\"\n    EVKEY = str(ghenv.Component.InstanceGuid) + \"___EVENTS\"\n    FLAG = str(ghenv.Component.InstanceGuid) + \"___FLAG\"\n\n    # COMPONENT UPDATING -------------------------------------------------------\n\n    def updateComponent(self):\n        # define callback action\n        def callBack(e):\n            ghenv.Component.ExpireSolution(False)\n        # schedule new solution\n        ghdoc.ScheduleSolution(1, Grasshopper.Kernel.GH_Document.GH_ScheduleDelegate(callBack))\n\n    # EVENT HANDLING -----------------------------------------------------------\n\n    def subscribe_to(self, event, func, key):\n        if self.EVKEY not in st:\n            st[self.EVKEY] = {}\n        if key not in st[self.EVKEY]:\n            st[self.EVKEY][key] = event\n        ukey = str(ghenv.Component.InstanceGuid) + \"_\" + key\n        if ukey not in st:\n            st[ukey] = func\n            event += st[ukey]\n\n    def unsubscribe_all(self):\n        if self.EVKEY in st:\n            for key in st[self.EVKEY]:\n                ukey = str(ghenv.Component.InstanceGuid) + \"_\" + key\n                if ukey in st:\n                    st[self.EVKEY][key] -= st[ukey]\n                    st.pop(ukey)\n        st[self.EVKEY] = {}\n\n    def flagEvent(self, sender, e):\n        st[self.FLAG] = True\n\n    def updateEvent(self, sender, e):\n        if st[self.FLAG] == True:\n            st[self.FLAG] = False\n            self.updateComponent()\n\n    def unsubEvent(self, sender, e):\n        self.unsubscribe_all()\n\n    # LAYER SET HANDLING -------------------------------------------------------\n\n    def CreateReferenceLayers(self, parentPrefix, refLayers, norefLayers, colours):\n        # get timestamp\n        ts = time.strftime(\"%y%m%d_%H-%M\")\n        # create parent layer name\n        parentLayername = parentPrefix + ts\n        ghenv.Component.Message = \"Referenced: \" + str(parentLayername)\n        # check if parent layer exists\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        exists = rs.IsLayer(parentLayername)\n        if exists:\n            ghenv.Component.AddRuntimeMessage(ghenv.Component.RuntimeMessageLevel.Remark,\n                \"Parent Layer already exists! Returning valid existing layers.\")\n            # get all children layers\n            allchildren = rs.LayerChildren(parentLayername)\n            # check all children layers for validity\n            validchildren = [parentLayername + \"::\" + vc for vc in refLayers]\n            realchildren = []\n            for c in allchildren:\n                if c in validchildren:\n                    realchildren.append(c)\n            # set sticky to real found child layers\n            st[self.LNKEY] = realchildren\n\n            # switch back to ghdoc\n            sc.doc = ghdoc\n            # return layer names\n            return realchildren\n        else:\n            # switch to Rhino doc\n            sc.doc = Rhino.RhinoDoc.ActiveDoc\n            # create parent layer\n            parentLayer = rs.AddLayer(parentLayername, Color.Black)\n            print(parentLayername)\n            # create referenced layers\n            newLayers = []\n            for i, rl in enumerate(refLayers + norefLayers):\n                lay = rs.AddLayer(parentLayername + '::' + rl,\n                                  colours[i])\n                if rl in refLayers:\n                    newLayers.append(lay)\n            # add them to the sticky\n            st[self.LNKEY] = newLayers\n            # switch back to ghdoc\n            sc.doc = ghdoc\n            # return layer names/paths\n            return newLayers\n\n    def LoadCurrentLayers(self, refLayers):\n        # switch to RhinoDoc\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        # retrieve current layer\n        cl = rs.CurrentLayer()\n        # check childcount\n        childcount = rs.LayerChildCount(cl)\n        # if no children, layer has to be childlayer or unrelated\n        if childcount == 0:\n            # get parent layer\n            parent = rs.ParentLayer(cl)\n            # switch back to GhDoc\n            sc.doc = ghdoc\n            if parent:\n                allvalid = [parent + \"::\" + lay for lay in refLayers]\n                # set message and return all valid children\n                ghenv.Component.Message = \"Referenced: \" + str(parent)\n                st[self.LNKEY] = allvalid\n                return allvalid\n            else:\n                st[self.LNKEY] = None\n                ghenv.Component.Message = None\n                return None\n        # if no children, layer has to be parent layer\n        elif childcount > 0:\n            parent = cl\n            # switch back to GhDoc and return all valid layers\n            sc.doc = ghdoc\n            if parent:\n                allvalid = [parent + \"::\" + lay for lay in refLayers]\n                # set message and return all valid children\n                ghenv.Component.Message = \"Referenced: \" + str(parent)\n                st[self.LNKEY] = allvalid\n                return allvalid\n        else:\n            # switch back to GhDoc\n            sc.doc = ghdoc\n            st[self.LNKEY] = None\n            return None\n\n    def retrieveGeometry(self, layers):\n        geometry = []\n        # switch to rhinodoc\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\n        # loop over layers\n        for i, layer in enumerate(layers):\n            objs = [rs.coercegeometry(obj) for obj in rs.ObjectsByLayer(layer)]\n            if objs is None:\n                objs = []\n            for i, obj in enumerate(objs):\n                if type(obj) == Rhino.Geometry.Point:\n                    objs[i] = Rhino.Geometry.Point3d(obj.Location)\n            geometry.append(objs)\n        # switch back to ghdoc\n        sc.doc = ghdoc\n        return geometry\n\n    def RunScript(self,\n            DynamicUpdate: bool,\n            CreateAndRef: bool,\n            LoadAndRef: bool,\n            ParentLayerPrefix: str,\n            ReferenceLayers: list[str],\n            AssistanceLayers: list[str],\n            LayerColours: list[System.Drawing.Color]):\n        # check for unique key in sticky dictionary\n        if self.LNKEY not in st:\n            st[self.LNKEY] = None\n        # define output variables ----------------------------------------------\n        AssemblyGeo = Grasshopper.DataTree[object]()\n        CurrentLayers = []\n        # subscribe to events for automatic component updating -----------------\n        if DynamicUpdate:\n            self.subscribe_to(Rhino.RhinoDoc.BeforeTransformObjects, self.flagEvent, \"BeforeTransformObjects\")\n            self.subscribe_to(Rhino.RhinoDoc.DeleteRhinoObject, self.flagEvent, \"DeleteRhinoObject\")\n            self.subscribe_to(Rhino.RhinoDoc.AddRhinoObject, self.flagEvent, \"AddRhinoObject\")\n            # self.subscribe_to(Rhino.RhinoDoc.LayerTableEvent, self.flagEvent, \"LayerTableEvent\")\n            self.subscribe_to(Rhino.RhinoDoc.UndeleteRhinoObject, self.flagEvent, \"UndeleteRhinoObjects\")\n            self.subscribe_to(Rhino.RhinoApp.Idle, self.updateEvent, \"Idle\")\n            self.subscribe_to(Rhino.RhinoDoc.CloseDocument, self.unsubEvent, \"CloseDocument\")\n            self.subscribe_to(Rhino.RhinoDoc.NewDocument, self.unsubEvent, \"NewDocument\")\n        else:\n            self.unsubscribe_all()\n        # catch missing layer colours ------------------------------------------\n        laycount = len(ReferenceLayers + AssistanceLayers)\n        if not LayerColours or len(LayerColours) == 0:\n            LayerColours = [Color.Black] * laycount\n        elif len(LayerColours) < len(ReferenceLayers + AssistanceLayers):\n            addCols = [Color.Black] * (laycount - len(LayerColours))\n            LayerColours.extend(addCols)\n        # if create button is pressed, create new layers and reference them ----\n        if CreateAndRef is True:\n            CurrentLayers = self.CreateReferenceLayers(ParentLayerPrefix,\n                                                       ReferenceLayers,\n                                                       AssistanceLayers,\n                                                       LayerColours)\n        # if load button is pressed, load from the current rhino-layer ---------\n        elif LoadAndRef is True:\n            # retrieve the current layerset based on the active rhino layer\n            CurrentLayers = self.LoadCurrentLayers(ReferenceLayers)\n        # if no button is pressed, make some checks and run standard procedure -\n        elif self.LNKEY in st and st[self.LNKEY] is not None:\n            layer_names = st[self.LNKEY]\n            CurrentLayers = layer_names\n        # fall back and return if there are no layer names stored in sticky\n        elif st[self.LNKEY] is None:\n            try:\n                # retrieve the current layerset based on the active rhino layer\n                CurrentLayers = self.LoadCurrentLayers(ReferenceLayers)\n            except Exception:\n                return AssemblyGeo, CurrentLayers\n        # retrieve all geometry\n        if CurrentLayers:\n            try:\n                allgeometry = self.retrieveGeometry(CurrentLayers)\n            except ValueError as errMsg:\n                ghenv.Component.AddRuntimeMessage(ghenv.Component.RuntimeMessageLevel.Error,\n                                       str(errMsg))\n                allgeometry = None\n        else:\n            ghenv.Component.AddRuntimeMessage(ghenv.Component.RuntimeMessageLevel.Warning,\n                \"Could not load layerset. Check your current Rhino layer or \" +\n                \"the controllers input parameters\")\n            allgeometry = None\n        if allgeometry:\n            for i, geo in enumerate(allgeometry):\n                AssemblyGeo.AddRange(geo, Grasshopper.Kernel.Data.GH_Path(i))\n        # return outputs\n        return AssemblyGeo, CurrentLayers",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}