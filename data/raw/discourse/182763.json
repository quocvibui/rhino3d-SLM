{
  "source_url": "https://discourse.mcneel.com/t/coding-a-pot-full-of-flowers/182763",
  "topic_id": 182763,
  "title": "Coding a pot full of flowers",
  "question": "Hi,\n\n\nI am trying to code a bouquet of flowers. I took this up as an exercise because I am a beginner in python and wanted a project to have a steep learning curve.\n\n\nThe code is supposed to work like this:\n\n\n\n\nCreating a pot:\n\nUsing a couple of simple operations I want to model a pot. This has been working out fine.\n\n\nCreating the halms/straws of the flowers:\n\nthis was a little more challenging, but still manageble. Starting with a set of points as the seeds I generated positions for the blossoms and smooth curves connecting them.\n\n\nCreating the blossoms:\n\nI wanted to create a simple geometric representation of a blossom. Now, for me, this is challenging. I have decided to divide this process into 3 seperate steps:\n\n3.1: Pascals theorem:\n\nI am trying to model blossoms and as the fundamental geometry I want to use ellipses. Pascals theorem states, that from any ellipse I can get six tangents whos intersections have connecting lines that intersect in one point. This allows me to create concentric blossoms, that are not completely symmetric.\n\n3.2: creating petal rings:\n\nEach blossom is build up of rings of petals that are stacked into each other. I am trying to create these petal rings from the information that pascals theorem gave me.\n\n3.3: Creating a blossom:\n\nThis again should be relativly easy: by stacking the petal rings they should create a blossom.\n\n\nBringing everything together:\n\nFinally, the Blossoms should be attached to the straws.\n\n\n\n\nI have been working on this code for the last few days. Unfortunately it seems like I am meeting no end with my debugging efforts. This is why I assume that fundamentally my coding style (for example using both rhinoscript and rhinocommon methods) is flawed.\n\n\nI would like to ask you all for some advice, just when you observe this code. What could I fundamentally change for the better (to make my coding more fruitful)?\n\n\nThanks,\n\n\nMerlin\n\n\nThe Code:\n\n\n\"\"\"Grasshopper Script Instance\"\"\"\nimport sys as sys\nimport Rhino\nimport Gra...",
  "code_blocks": [
    {
      "code": "\"\"\"Grasshopper Script Instance\"\"\"\nimport sys as sys\nimport Rhino\nimport Grasshopper\n\nimport rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport random as r\n\n# I would like to make some flowers.\n        \n#############################################\n# 0. Making a pot\n#############################################\n        \nplane1 = rs.WorldXYPlane()\ncircle1 = rs.AddCircle(plane1, 0.2)\n        \nplane2 = rs.MovePlane(rs.WorldXYPlane(), [0,0,0.6])\ncircle2 = rs.AddCircle(plane2, 0.25)\n        \nplane3 = plane2\ncircle3 = rs.AddCircle(plane3, 0.2)\n        \nplane4 = rs.MovePlane(rs.WorldXYPlane(), [0,0,0.5])\ncircle4 = rs.AddCircle(plane4, 0.19)\n        \nloft_this = [circle1, circle2, circle3, circle4]\n        \npot = rs.AddLoftSrf(loft_this, start=[0,0,0], \n                                end=[0,0,0.5], loft_type=2)\n        \nearth = rs.AddPlanarSrf(circle4)\n        \n#############################################\n# 1. Creating the seeds\n#############################################\n        \n# We have to plant seeds inside the pot.\n# Unfortunately not all seeds will flourish, \n# if they are planted at too close a distance.\n        \nnumber_of_flowers = 10\n        \nseeds = []\n        \nfor i in range(number_of_flowers):\n        \n    # Generate random (u, v) parameters\n        \n    u = r.random()\n    v = r.random()\n        \n    # Evaluate the surface at (u, v) to get the 3D point\n        \n    point = rs.EvaluateSurface(earth, u, v)\n        \n    seeds.append(point)\n        \n#############################################\n# 2. Create the positions for the flowerheads\n#############################################\n        \n# Moving them in z-direction...\n# ...and pushing the flowerhead positions outwards.\n        \nflower_height = 0.5\n        \nflowerheads = seeds\n        \ncentroid = (rs.SurfaceAreaCentroid(earth)[0][0],\n                    rs.SurfaceAreaCentroid(earth)[0][1],\n                   flower_height)\n\nflowerheads = rs.MoveObjects(flowerheads, [0,0,flower_height])\nflowerheads = rs.ScaleObjects(flowerheads, centroid, [3,3,0], False)\n        \n#############################################\n# 3. Creating the growth_paths\n#############################################\n        \n# I do this by simply using interpolating curves,....\n# ... which are perfect for this purpose:\n# Define a starting point and vector and an end point and vector....\n# .... and you will get a smooth cuve between the points....\n# .... with the vectors as tangents.\n        \n# First creating the vetors...\n        \nflowerhead_vectors = []\n        \nfor i,seed in enumerate(seeds):\n    vector = rs.VectorCreate(seed, flowerheads[i])\n    flowerhead_vectors.append(vector)\n        \n# ...then the growth_paths.\n        \ngrowth_paths = []\n        \nfor i,seed in enumerate(seeds):\n    growth_path = rs.AddInterpCurve(\n                    [seed,flowerheads[i]], degree=3, knotstyle=0, \n                    start_tangent=(0,0,1), end_tangent = flowerhead_vectors[i])\n    growth_paths.append(growth_path)\n        \n# Now, for creating the flower straws.\n        \n        \n        \n#############################################\n# 4. Creating the flower_operation\n#############################################\n\n# 4.1 Pascals Operation\n        \n# Pascals Theorem states the following for every ellipse:\n# If you draw 6 different tangents on the elipse ....\n# ....and take their intersection points...\n# .... you can create connecting lines between these points.....\n# .... that will always intersect each other in one point.\n        \n# Using this theorem allows me to create flowerheads...\n# ....with petals that all converge to one point.\n        \n        \ndef Pascal_Operation(x,y):\n\n    ellipse_id = rs.AddEllipse(rs.WorldXYPlane(), x, y)\n        \n    # Calculate tangent lines .... only as point pairs because thats all we need for now\n    tangent_lines = []\n    for i in range(6):  # Divide curve into 6 equal parts to get tangent points\n        param = i * rs.CurveLength(ellipse_id) / 6\n        point = rs.EvaluateCurve(ellipse_id, param)\n        tangent = rs.CurveTangent(ellipse_id, param)\n        points_of_tangent_line = [\n             point + x * tangent,\n             point - x * tangent,\n                ]\n        tangent_lines.append(points_of_tangent_line)\n        \n    # Calculate intersections of neighboring tangents\n    intersections_of_tangents = []\n    for i in range(6):\n        tangent_1 = tangent_lines[i]\n        tangent_2 = tangent_lines[(i + 3) % 6]\n    \n\n        intersection = rs.LineLineIntersection(\n            (tangent_1[0], tangent_1[1]), (tangent_2[0], tangent_2[1])\n        )\n        if intersection:\n            intersections_of_tangents.append(intersection[0])\n        \n    # Calculate intersecting lines (again only as point pairs because thats all we need for now) and...\n    # ...determine the intersection of just two lines (the third is automatically concurrent with the others).\n        \n    line_0 = intersections_of_tangents[0], intersections_of_tangents[3]\n    line_1 = intersections_of_tangents[1], intersections_of_tangents[4]\n\n    central_intersection = rs.LineLineIntersection(\n        (line_0[0], line_0[1]), (line_1[0], line_1[1]))\n        \n    return tangent_lines, intersections_of_tangents, central_intersection\n            \n        \n# now using this definition of pascals sentence...\n# ... we make some nice flowers.\n# Its gonna be fun!\n        \n# 4.2 Creating a function for what i like to call \"petal_rings\" \n\ndef petal_ring(x,y, petal_division):\n\n    ellipse_id = rs.AddEllipse(rs.WorldXYPlane(), x, y)\n    \n    rs.CurveSeam(ellipse_id, petal_division)\n\n    intersections_of_tangents = Pascal_Operation(x,y)[1]\n    central_intersection = Pascal_Operation(x,y)[2]\n\n    convex_curves = rs.SplitCurve(ellipse_id, [i * 1/6 for i in range(6)])\n\n    concave_curves = []\n\n    # Creating the upper end of each petal...\n    # ...by mirroring the ellipse-segments along the ellipse-tangents\n\n    for i in range(6):\n\n        start_point = intersections_of_tangents[i]\n        end_point = intersections_of_tangents[(i+1) % 6 ]\n\n        concave = rs.MirrorObject(convex_curves[i % 5], start_point, end_point, True)\n        concave = rs.MoveObject(concave, [0,0, x * 1.5])\n        concave_curves.append(concave)\n\n    petals = []\n\n    for i in range(6):\n\n        petal = rs.AddLoftSrf([concave_curves[i % 5], convex_curves[i % 5]], \n                            loft_type=1)\n        petals.append(petal)\n\n    return ellipse_id, petals, central_intersection\n    \n\n# 4.3 Creating the flowerheads\n\ndef blossom(x,y):\n\n    step_size = 0.03\n\n    # generate the outer ring of petals\n\n    outer_ring = petal_ring(x,y, 0)[1]\n\n    # generate the inner, offset ring of petals\n\n    outer_ring_center = petal_ring(x,y, 0)[2]\n\n    x2 = x * 0.75\n    y2 = y * 0.75\n\n    inner_ring = petal_ring(x2,y2, 1/6)[1]\n\n    inner_ring_center = petal_ring(x2,y2, 1/6)[2]\n\n    # Aligning the inner and the outer ring\n    direction = rs.VectorAdd(outer_ring_center - inner_ring_center, [0, 0, step_size])\n    inner_ring = rs.MoveObjects(inner_ring, direction)\n\n    # putting both rings together and creating the entire blossom\n    double_ring = inner_ring | outer_ring\n\n    blossom = []\n\n    for i in range(6):\n        ring = rs.ScaleObjects(double_ring, outer_ring_center, 0.5, copy=True)\n        ring = rs.MoveObjects(ring, [0, 0, step_size])\n        for i in ring:\n            blossom.append(ring)\n\n    return blossom, outer_ring_center\n\n#############################################\n# 5. Bringing it all together\n#############################################\n\nblossom_positioned = []\n\nfor i in range(number_of_flowers):\n    \n    #Create radii for the ellipses, within a certain boundary...\n    # ...to create differently shaped flowerheads.\n\n    u = r.uniform(0.05, 0.09)\n    v = r.uniform(0.05, 0.09)\n\n    flowerhead = blossom(u,v)\n\n    # reorienting the flowerhead\n\n    reference = [flowerhead[1], [0,0,1], [0,1,0]]\n\n    for i in flowerhead:\n        target = [flowerheads[i], flowerhead_vectors[i] + flowerheads[i], \n        rs.VectorCrossProduct(flowerheads[i], flowerhead_vectors[i] + flowerheads[i])]\n        flowerhead = rs.OrientObject(flowerhead[0][i], reference, target, flags = 0)\n\n        blossom_positioned.append(flowerhead)\n\n#############################################\n# 6. Visualizing it\n#############################################\n\nblossoms = blossom_positioned\npot = pot\nearth = earth",
      "language": "python",
      "author": "user2686",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "csharp",
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 3,
  "views": 2476
}