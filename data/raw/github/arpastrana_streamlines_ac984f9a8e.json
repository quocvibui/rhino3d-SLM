{
  "source_url": "https://github.com/arpastrana/streamlines/blob/603813aef3dd22f20b7821304bd4cadf20cd6bf1/src/streamlines/custom_mesh.py",
  "repo": "arpastrana/streamlines",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "src/streamlines/custom_mesh.py",
  "instruction": "A mesh wrapper that contains rs and compas information.",
  "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n'''\nA mesh wrapper that contains rs and compas information.\n'''\n\n__name__ = \"Structural Mesh\"\n__author__ = \"Rafael Pastrana\"\n__version__ = \"0.0.4\"\n__creation__ = \"2018.11.12\"\n__date__ = \"2018.11.12\"\n\n\nimport compas\nimport compas_rhino\n\nfrom compas.datastructures import Mesh\nfrom compas import geometry as cg\n\n\nfrom math import degrees\nfrom math import acos\n\nfrom streamlines.utilities import Utilities\n\nfrom compas.geometry import KDTree\nfrom compas.geometry import closest_point_on_plane\nfrom compas.geometry import distance_point_point\n\nfrom compas.topology import dijkstra_distances\n\nfrom compas.utilities import geometric_key\n\nfrom functools import reduce\n\ntry:\n    import rhinoscriptsyntax as rs\nexcept:\n    if compas.IPY:\n        raise\n\n\nut = Utilities()\n\n\ndef barycentric_coordinates(point, triangle, clamp=False):\n    '''\n    '''\n    a, b, c = triangle\n    pt = point\n\n    def clamper(value):\n        if not clamp:\n            return value\n        if value < 0.0:\n            return 0.0\n        elif value > 1.0:\n            return 1.0\n        return value\n    \n    def barycentric_1():\n        numerator = (b[1] - c[1]) * (pt[0] - c[0]) + (c[0] - b[0]) * (pt[1] - c[1])\n        denominator = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1])\n        return clamper(numerator / denominator)\n\n    def barycentric_2():\n        numerator = (c[1] - a[1]) * (pt[0] - c[0]) + (a[0] - c[0]) * (pt[1] - c[1])\n        denominator = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1])\n        return clamper(numerator / denominator)\n\n    bar_1 = barycentric_1()\n    bar_2 = barycentric_2()\n    bar_3 = 1 - bar_1 - bar_2\n    return [bar_1, bar_2, bar_3]\n\n\ndef barycentric_to_cartesian(barycentric, triangle):\n    '''\n    '''\n    bar_1, bar_2, bar_3 = barycentric\n    a, b, c = triangle\n\n    x = a[0] * bar_1 + b[0] * bar_2 + c[0] * bar_3\n    y = a[1] * bar_1 + b[1] * bar_2 + c[1] * bar_3\n\n    return [x, y, 0.0]\n\n\nclass StructuralMesh():\n\n    def __init__(self, cmesh):\n        # self.c_mesh = helpers.mesh.mesh_from_guid(Mesh, gh_mesh)\n        # self.gh_mesh = gh_mesh\n        self.c_mesh = cmesh\n        self.cMesh = cmesh   # temp\n\n        self.adj = None\n        self.e_weights = None\n        self.avg_edge = None\n\n        self.face_centroids = [self.c_mesh.face_centroid(f) for f in self.c_mesh.faces()]\n        self.gkey_fkey = {geometric_key(self.c_mesh.face_centroid(f)): f for f in self.c_mesh.faces()} \n        \n        self.face_tree = cg.KDTree(self.face_centroids)\n\n        self.boundary_vertices = self.c_mesh.vertices_on_boundary()\n        self.boundary_polygon = [self.c_mesh.vertex_coordinates(v) for v in self.boundary_vertices]\n\n\n        self.set_face_planes()\n        self.set_edge_planes()\n        # self.set_adjacency()\n        # self.set_avg_edge_length()\n\n    def set_avg_edge_length(self):\n        lengths = [self.c_mesh.edge_length(u, v) for u, v in self.c_mesh.edges()]\n        self.avg_edge = sum(lengths) / len(lengths)\n\n    def set_adjacency(self):\n        adjacency = {key: self.c_mesh.vertex_neighbors(key) for key in self.c_mesh.vertices()}\n        weight = {(u, v): self.c_mesh.edge_length(u, v) for u, v in self.c_mesh.edges()}\n        weight.update({(v, u): weight[(u, v)] for u, v in self.c_mesh.edges()})\n\n        self.adj = adjacency\n        self.e_weights = weight\n\n    def set_dijkstra_distances(self):\n        for v in self.c_mesh.vertices():\n            dijkstra_d = dijkstra_distances(self.adj, self.e_weights, v)\n            self.c_mesh.vertex_attribute(v, 'dijkstra', dijkstra_d)\n\n    def set_face_vectors(self, vector_field, name, normalize=True):\n        for f_key in self.c_mesh.faces():\n\n            vector_a = vector_field[int(f_key)]\n            if normalize is True:\n                vector_a = cg.normalize_vector(vector_a)  # normalize or not?\n            vector_b = cg.scale_vector(vector_a, -1.)\n            self.c_mesh.face_attribute(f_key, str(name) + '_a', vector_a)\n            self.c_mesh.face_attribute(f_key, str(name) + '_b', vector_b)\n\n    def set_face_planes(self):\n        for f_key in self.c_mesh.faces():\n            ct = self.c_mesh.face_centroid(f_key)\n            normal = self.c_mesh.face_normal(f_key)\n            self.c_mesh.face_attribute(f_key, 'plane', [ct, normal])\n\n    def set_edge_planes(self):\n        for u, v in self.c_mesh.edges():\n\n            # f_keys = self.c_mesh.edge_faces(u, v)\n            # f_keys = [f_key for f_key in f_keys if f_key is not None]\n\n            # normals = [self.c_mesh.face_normal(f_key) for f_key in f_keys]\n            # normals = list(map(lambda x: ut.align_vector(x, normals[0]),\n            #                    normals\n            #                    )\n            #                )\n\n            # vec = reduce(lambda x, y: cg.add_vectors(x, y), normals)\n\n            vec = [0.0, 0.0, 1.0]\n            vec = cg.cross_vectors(self.c_mesh.edge_vector(u, v), vec)\n            plane = [self.c_mesh.edge_midpoint(u, v), vec]\n\n            self.c_mesh.edge_attribute(edge=(u, v), name='plane', value=plane)\n\n    def set_vertex_vectors(self, name):\n        for v in self.c_mesh.vertices():\n            # 1. find keys of vertex' neighbouring faces\n            face_idxs = self.c_mesh.vertex_faces(v, ordered=True)\n\n            # 2. get attributes of the found faces and calculate weights\n            vec_a = self.c_mesh.faces_attribute(name=str(name) + '_a', keys=face_idxs)\n            vec_b = self.c_mesh.faces_attribute(name=str(name) + '_b', keys=face_idxs)\n\n            # 3. calculate weights\n            pt_cloud = [self.c_mesh.face_centroid(k) for k in face_idxs]\n            weights = ut.get_dist_weights(self.c_mesh.vertex_coordinates(v), pt_cloud)\n\n            # 4. multiply vectors by weights\n            nd_vec_a = ut.vectors_weight_reduce(vec_a, weights)\n            nd_vec_b = ut.vectors_weight_reduce(vec_b, weights)\n\n            # 6. assign vector attributes to vertices\n            self.c_mesh.vertex_attribute(v, str(name) + '_a', nd_vec_a)\n            self.c_mesh.vertex_attribute(v, str(name) + '_b', nd_vec_b)\n\n    def set_vertex_vectors_angles(self, name):\n        for v in self.c_mesh.vertices():\n            # 1. find keys of vertex' neighbouring faces\n            face_idxs = self.c_mesh.vertex_faces(v, ordered=True)\n\n            # 2. get attributes of the found faces and calculate weights\n            vec_a = self.c_mesh.faces_attribute(name=str(name) + '_a', keys=face_idxs)\n            vec_b = self.c_mesh.faces_attribute(name=str(name) + '_b', keys=face_idxs)\n\n            # 3. get connected edges\n            angles = []\n            for face_idx in face_idxs:\n                edges = []\n                for edge in self.c_mesh.face_halfedges(face_idx):\n                    if v in edge:\n                        edges.append(edge)\n                # if len(edges) > 1:\n                e_1 = self.c_mesh.edge_vector(edges[0][0], edges[0][1])\n                e_2 = self.c_mesh.edge_vector(edges[1][0], edges[1][1])\n                angle = cg.angle_vectors(e_1, e_2, deg=True)\n                angles.append(angle)\n\n            mass_angle = reduce(lambda x, y: x+y, angles)\n            weights = list(map(lambda x: x/mass_angle, angles))\n\n            # 4. multiply vectors by weights\n            nd_vec_a = ut.vectors_weight_reduce(vec_a, weights)\n            nd_vec_b = ut.vectors_weight_reduce(vec_b, weights)\n\n            # 6. assign vector attributes to vertices\n            self.c_mesh.vertex_attribute(v, str(name) + '_a', nd_vec_a)\n            self.c_mesh.vertex_attribute(v, str(name) + '_b', nd_vec_b)\n\n    def get_vector_on_face_vertices(self, point, f_key, name, vec=[0, 0, 0]):\n        v_keys = self.c_mesh.face_vertices(f_key)\n        v_vectors_a = self.c_mesh.vertices_attribute(name=str(name) + '_a',\n                                                        keys=v_keys\n                                                        )\n        v_vectors_b = self.c_mesh.vertices_attribute(name=str(name) + '_b',\n                                                        keys=v_keys\n                                                        )\n\n        v_vectors = ut.filter_aligned_vectors(vec, v_vectors_a, v_vectors_b)\n        pt_cloud = self.c_mesh.face_coordinates(f_key)\n        weights = ut.get_dist_weights(point, pt_cloud)\n\n        new_vectors = []\n        for idx, vec in enumerate(v_vectors):\n            new_vector = cg.scale_vector(vec, weights[idx])\n            new_vectors.append(new_vector)\n        return reduce(lambda x, y: cg.add_vectors(x, y), new_vectors)\n\n    def get_vector_on_face_ext(self, point, f_key, name, vec=[0, 0, 0]):\n        f_keys = [f_key]\n        f_keys.extend(self.c_mesh.face_neighbours(f_key))\n        v_keys = []\n        pt_cloud = []\n\n        for f_key in f_keys:\n            v_keys.extend(self.c_mesh.face_vertices(f_key))\n\n        v_keys = list(set(v_keys))\n        v_vectors_a = self.c_mesh.vertices_attribute(name=str(name) + '_a',\n                                                        keys=v_keys\n                                                        )\n        v_vectors_b = self.c_mesh.vertices_attribute(name=str(name) + '_b',\n                                                        keys=v_keys\n                                                        )\n\n        v_vectors = ut.filter_aligned_vectors(vec, v_vectors_a, v_vectors_b)\n\n        for v_key in v_keys:\n            pt_cloud.append(self.c_mesh.vertex_coordinates(v_key))\n\n        weights = ut.get_dist_weights(point, pt_cloud)\n        new_vectors = []\n        for idx, vec in enumerate(v_vectors):\n            new_vector = cg.scale_vector(vec, weights[idx])\n            new_vectors.append(new_vector)\n\n        return reduce(lambda x, y: cg.add_vectors(x, y), new_vectors)\n\n    def get_vector_on_face_faces(self, point, f_key, name, vec=[0, 0, 0]):\n        pt_cloud = []\n\n        f_keys = [f_key]\n        f_keys.extend(self.c_mesh.face_neighbors(f_key))\n        f_keys = list(set(f_keys))\n\n        f_vectors_a = self.c_mesh.faces_attribute(f_keys,\n                                                      str(name) + '_a'\n                                                      )\n        f_vectors_b = self.c_mesh.faces_attribute(f_keys,\n                                                      str(name) + '_b',\n                                                      )\n        f_vectors = ut.filter_aligned_vectors(vec, f_vectors_a, f_vectors_b)\n\n        for f_key in f_keys:\n            pt_cloud.append(self.c_mesh.face_centroid(f_key))\n\n        weights = ut.get_dist_weights(point, pt_cloud)\n        new_vectors = []\n        for idx, vec in enumerate(f_vectors):\n            new_vector = cg.scale_vector(vec, weights[idx])\n            new_vectors.append(new_vector)\n\n        return reduce(lambda x, y: cg.add_vectors(x, y), new_vectors)\n\n    def get_data_on_nodes(self, data_tag, mode='max'):\n        n_data = []\n\n        for v in self.c_mesh.vertices():\n            faces = self.c_mesh.vertex_faces(v)\n            f_data = self.c_mesh.faces_attribute(name=data_tag, keys=faces)\n\n            if mode == 'max':\n                val = max(f_data)\n            elif mode == 'min':\n                val = min(f_data)\n            elif mode == 'avg':\n                val = sum(f_data) / len(f_data)\n            elif mode == 'angle_avg':\n                weights = ut.get_angle_weights(self.c_mesh, v, faces)\n                val = ut.values_weight_reduce(f_data, weights)\n\n            n_data.append(val)\n        return n_data\n\n    def get_edge_labels(self, name, tol):\n\n        for u, v in self.c_mesh.edges():\n            vec_u_a = self.c_mesh.vertex_attribute(u, str(name) + '_a')\n            vec_v_a = self.c_mesh.vertex_attribute(v, str(name) + '_a')\n\n            dot = cg.dot_vectors(vec_u_a, vec_v_a)\n\n            if dot < 0 - tol:\n                label = -1\n            elif dot > 0 + tol:\n                label = 1\n            else:\n                label = 0\n\n            self.c_mesh.edge_attribute(edge=(u, v), name='label', value=label)\n\n    def get_face_labels(self, name, tol=0.6):\n        self.get_edge_labels(name, tol)\n\n        for f_key in self.c_mesh.faces():\n            valency = 1\n            for edge in self.c_mesh.face_halfedges(f_key):\n                valency *= self.c_mesh.edge_attribute(edge=edge, name='label')\n            self.c_mesh.face_attribute(f_key, 'label', valency)\n\n    def find_vector_on_face(self, point, f_key, name):\n        v_keys = self.c_mesh.face_vertices(f_key)\n        vectors_a = self.c_mesh.vertices_attribute(name=str(name) + '_a', keys=v_keys)\n        vectors_b = self.c_mesh.vertices_attribute(name=str(name) + '_b',keys=v_keys)\n\n        weights = ut.get_dist_weights(point,\n                                      self.c_mesh.face_coordinates(f_key)\n                                      )\n\n        vec_a = ut.vectors_weight_reduce(vectors_a, weights)\n        vec_b = ut.vectors_weight_reduce(vectors_b, weights)\n        return vec_a, vec_b\n\n    def find_vector_face_centers(self, name):\n        vectors = []\n        for f_key in self.c_mesh.faces():\n            ct = self.c_mesh.face_centroid(f_key)\n            vec_a, vec_b = self.find_vector_on_face(ct, f_key, name)\n            vectors.append((vec_a, vec_b))\n        return vectors\n\n    def stream_face_labels(self):\n        l_neg = []\n        l_null = []\n        l_pos = []\n\n        for f_key in self.c_mesh.faces():\n            label = self.c_mesh.face_attribute(f_key, 'label')\n\n            if label == -1:\n                l_neg.append(self.c_mesh.face_centroid(f_key))\n            elif label == 0:\n                l_null.append(self.c_mesh.face_centroid(f_key))\n            elif label == 1:\n                l_pos.append(self.c_mesh.face_centroid(f_key))\n\n        l_neg = list(map(lambda x: rs.AddPoint(x), l_neg))\n        l_null = list(map(lambda x: rs.AddPoint(x), l_null))\n        l_pos = list(map(lambda x: rs.AddPoint(x), l_pos))\n\n        return l_neg, l_null, l_pos\n\n    # def closest_point(self, point, maxdist=None):\n    #     maxdist = maxdist\n    #     # point, face = rs.MeshClosestPoint(self.gh_mesh,\n    #     #                                   rs.AddPoint(*point),\n    #     #                                   maxdist\n    #     #                                   )\n    #     point, face, dist = self.trimesh_closest_point_xy(self.c_mesh, point)\n\n    #     # point = [point.X, point.Y, point.Z]\n    #     return point, face\n\n    @staticmethod\n    def trimesh_closest_point_xy(mesh, point):\n        '''\n        '''\n        closest_pts = []\n\n        for fkey in mesh.faces():\n            triangle = mesh.face_coordinates(fkey)\n            plane = (mesh.face_centroid(fkey), mesh.face_normal(fkey))\n            closest_pt = closest_point_on_plane(point, plane)\n            \n            bars = barycentric_coordinates(closest_pt, triangle, clamp=True)\n            closest_pt = barycentric_to_cartesian(bars, triangle)\n\n            closest_pts.append((closest_pt, fkey, distance_point_point(point, closest_pt)))\n\n        if not closest_pts:\n            return None, None, None\n\n        return sorted(closest_pts, key=lambda x: x[2])[0]\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}