{
  "source_url": "https://github.com/Hiteca/ghShp/blob/2ac0247af55139b7ed7b3e8d188ddedbf40b6590/source/ghshp_export.py",
  "repo": "Hiteca/ghShp",
  "repo_stars": 7,
  "repo_description": "Grasshopper component to read and write ESRI Shapefile :earth_asia:",
  "license": "unknown",
  "filepath": "source/ghshp_export.py",
  "instruction": "Export geometry and data to ESRI Shapefile.",
  "code": "# -*- coding: utf-8 -*-\n\n# Source code available at https://github.com/hiteca\n\n\"\"\"\nExport geometry and data to ESRI Shapefile.\n\n    Args:\n        path: Path to exported .shp file\n        shape_type: pyShp shape type (1 - point, 3 - polyline, 5 - polygon...). See full list at https://github.com/GeospatialPython/pyshp\n        geometry: Geometry to export\n        fields: List of fields (format - \"name|type|length\")\n        records: Data rows. Each row in own branch\n        enc: File encoding. \n                Default - utf-8 \n        write: [bool] Connect button or toggle to write file\n\"\"\"\nghenv.Component.Name = \"Shapefile Export\"\nghenv.Component.NickName = 'Shp Export'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.icon\nghenv.Component.Category = \"Extra\"\nghenv.Component.SubCategory = \"Hiteca\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\n\nimport sys\n\nimport System\nimport clr\nimport os\nclr.AddReference(\"Grasshopper\")\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\n\nimport Grasshopper.Kernel as gh\n\nwe = gh.GH_RuntimeMessageLevel.Error\nww = gh.GH_RuntimeMessageLevel.Warning\n\ntry:\n    import shapefile\nexcept:\n    message = \"Python module 'pyshp' not found. Please download it and install to Rhino IronPython folder using manual at https://github.com/hiteca/ghshp\"\n    ghenv.Component.AddRuntimeMessage(we, message)\n    message = \"https://github.com/hiteca/ghshp#install-pyshp\"\n    ghenv.Component.AddRuntimeMessage(we, message)\n\nimport rhinoscriptsyntax as rs\n\ndef list2branch(source_tree,data,item_index,data_path):\n    _p = GH_Path(data_path).AppendElement(item_index)\n    for i in range(len(data)):\n        _data = data[i]\n        if type(_data) == list:\n            soruce_tree = v2branch(source_tree,_data,i,_p)\n        else:\n            source_tree.AddRange([_data],GH_Path(_p))\n    return source_tree\n    \n\ndef py_tree(source_tree, reverse=False, default=None):\n    if not reverse:\n        result = {}\n        for i in range(len(source_tree.Branches)):\n            d = source_tree.Branches[i]\n            p = GH_Path(source_tree.Paths[i])\n            \n            result[p] = list(d)\n        if len(result.keys())==0:\n            result[GH_Path(0)] = [default]\n    else:\n        result = DataTree[System.Object]()\n        for p in source_tree.keys():\n            d = source_tree[p]\n            _d = []\n            for j in range(len(d)):\n                data = d[j]\n                if type(data) == list:\n                    result = list2branch(result,data,j,p)\n                else:\n                    _d.append(data)\n            if len(_d) > 0:\n                result.AddRange(_d,p)\n                \n    return result\n\n\ndef repeat_latest(data,length):\n    if len(data) > length:\n        return data[:length]\n    else:\n        return data + ([data[-1]] * (length - len(data)))\n\n\ndef graft_tree(t):\n    r = {}\n    for k,v in t.items():\n        for i in range(len(v)):\n            r[GH_Path(k).AppendElement(i)] = [v[i]]\n    return r\n    \n    \ndef longest_list(t_a,t_b):\n    r_b = {}\n    r_a = {}\n    prev_a = t_a.items()[0][1]\n    prev_b = t_b.items()[0][1]\n    \n    if len(t_a) >= len(t_b):\n        keys = t_a.keys()\n    else:\n        keys = t_b.keys()\n\n    keys = sorted(keys, key=lambda x: str(GH_Path(x)))\n\n    for k in keys:\n        try:\n            branch_a = t_a[k]\n            prev_a = t_a[k]\n        except:\n            branch_a = prev_a\n        try:\n            branch_b = t_b[k]\n            prev_b = t_b[k]\n        except:\n            branch_b = prev_b\n        max_len = max(len(branch_b),len(branch_a))\n        if len(branch_b) >= len(branch_a):\n            branch_a = repeat_latest(branch_a, len(branch_b))\n        else:\n            branch_b = repeat_latest(branch_b, len(branch_a))\n        r_a[k] = branch_a\n        r_b[k] = branch_b\n        \n    return(r_a,r_b)\n\n\nshape_types = {\n    \"point\" : [\n        1, #POINT\n        8, #MULTIPOINT\n        11, #POINTZ\n        18, #MULTIPOINTZ\n        21, #POINTM\n        28, #MULTIPOINTM\n    ],\n    \"polyline\": [\n        3, #POLYLINE\n        5, #POLYGON\n        13, #POLYLINEZ\n        15, #POLYGONZ\n        23, #POLYLINEM\n        25, #POLYGONM\n        31, #MULTIPATCH\n    ]\n}\n\ndef find_type(t):\n    for k in shape_types.keys():        \n        if t in shape_types[k]:\n            return k\n            \n\n\ndef list2point(pt):\n    if len(pt)==2:\n        pt.append(0)\n    return rc.Geometry.Point3d(pt[0],pt[1],pt[2])\n\n\ndef write_shapefile(file_path, st, geom, fields, data, enc):\n    w = shapefile.Writer(shapeType=st)\n    sf_type = find_type(st)\n\n    records_dict = {}\n    # create fields\n    for f in fields:\n        _f = f.split(\";\")\n        if len(_f) == 3:\n            f_name, f_type, f_len = _f\n            f_len2 = 0\n        else:\n            f_name, f_type, f_len, f_len2 = _f\n        w.field(f_name, f_type, int(f_len), int(f_len2))\n\n    # generate geometry\n    for geom_branch in geom:\n        parts = []\n        if sf_type == \"point\":\n            for point in geom_branch:\n                parts.append(list(point))\n            parts = [parts]\n        else:\n            for polyline in geom_branch:\n                parts_p = []\n                points = rs.CurvePoints(polyline)\n                for p in points:\n                    parts_p.append(list(p))\n                parts.append(parts_p)\n        w.poly(parts=parts,shapeType=st)\n    \n    for record in data:\n        # TEMP\n        # encode strings to ASCII with ignore\n        # to prevent the same exception in pyshp\n        r = [r.encode(\"ascii\", 'ignore') if type(r) in [str, unicode] else r for r in record]\n        w.record(*r)\n    \n    try:\n        w.save(file_path)\n        print(\"Write successful - %s\" % file_path)\n    except Exception as e:\n        print(isinstance(e,UnicodeEncodeError))\n        print(\"Error with writing %s\" % file_path,e)\n    \n\npath = py_tree(path)\ngeometry = py_tree(geometry)\nshape_type = py_tree(shape_type)\nfields = py_tree(fields)\nrecords = py_tree(records)\nenc = py_tree(enc, default=\"utf-8\")\n\ndef shift_path(d):\n    new_dict = {}\n    for k,v in d.items():\n        _k = k.CullElement()\n        if _k not in new_dict.keys():\n            new_dict[_k] = []\n        new_dict[_k].append(v)\n    return new_dict\n\n\ndef write_many(path, shape_type, geometry, fields, records, enc):\n    for k,v in path.items():\n        \n        _geometry = geometry[k]\n        write_shapefile(path[k][0], shape_type[k][0], geometry[k], fields[k], \n                        records[k], enc[k][0])\n\n\nif write == True:\n    _path, geometry = longest_list(path,geometry)\n    _path, shape_type = longest_list(path,shape_type)\n    _path, fields = longest_list(path,fields)\n    _path, records = longest_list(path,records)\n    _path, enc = longest_list(path,enc)\n\n    geometry = shift_path(geometry)\n    records = shift_path(records)\n\n    write_many(path, shape_type, geometry, fields, records, enc)",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}