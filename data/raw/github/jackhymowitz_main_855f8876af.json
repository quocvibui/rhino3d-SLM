{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_CreateWindowReveals.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_CreateWindowReveals.py",
  "instruction": "Will create geometry for the window 'reveals' (the sides, top and bottom for windows which are installed in a host surface). These are used to accurately calcualte the window shading factors. Will...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nWill create geometry for the window 'reveals' (the sides, top and bottom for windows which are installed in a host surface). These are used to accurately calcualte the window shading factors. Will also generate 'punched' envelope surface geometry to allow for accurate shading assessment.\r\r\n-\r\r\nEM August 3, 2020\r\r\n    Args:\r\r\n        _HBZones: (list) The Honeybee Zones for analysis\r\r\n        moveWindows_: (bool) True = will move the window surfaces based on their 'InstallDepth' parameter. Use this if you want to push the windows 'in' to the host surface for the shading calculations. False = will not move the window surfaces.\r\r\n    Returns:\r\r\n        HBZones_: The updated Honeybee Zone objects to pass along to the next step.\r\r\n        windowNames_: A list of the window names in the order calculated.\r\r\n        windowSurfaces_: The window surfaces in the same order as the \"windowNames_\" output. If \"moveWindows_\" is set to True, these surfaces will be pushed 'in' according to their 'InstallDepth' parameter and surface normal.\r\r\n        windowSurrounds_: (Tree) Each branch represents one window object. The surfaces in each branch correspond to the Bottom, Left, Top and Right 'reveal' surfaces. Use this to calculate the shading factors for the window surface.\r\r\n        envelopSrfcs: The Honeybee zone surfaces, except with all the windows 'punched' out. \r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_CreateWindowReveals\"\r\r\nghenv.Component.NickName = \"Create Window Reveals\"\r\r\nghenv.Component.Message = 'AUG_03_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"01 | Model\"\r\r\n\r\r\nimport scriptcontext as sc\r\r\nimport ghpythonlib.components as ghc\r\r\nimport math\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport Rhino \r\r\nfrom System import Object\r\r\nfrom Grasshopper import DataTree\r\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\r\n\r\r\nhb_hive = sc.sticky[\"honeybee_Hive\"]()\r\r\nHBZoneObjects = hb_hive.callFromHoneybeeHive(_HBZones)\r\r\n\r\r\nwindowSurrounds_ = DataTree[Object]()\r\r\nwindowNames_ = []\r\r\nwindowSurfaces_ = []\r\r\nsrfcEdges = DataTree[Object]()\r\r\ncount = 0\r\r\n\r\r\nfor zone in HBZoneObjects:\r\r\n    for srfc in zone.surfaces:\r\r\n        if srfc.hasChild == False:\r\r\n            continue\r\r\n        \r\r\n        for childSrfc in srfc.childSrfs:\r\r\n            # Get the Window Surface Honeybee Info\r\r\n            windowNames_.append(childSrfc.name)\r\r\n            \r\r\n            # Get the PHPP Window Object\r\r\n            phppWindowObj = zone.phppWindowDict.get(childSrfc.name, None)\r\r\n            \r\r\n            # Get the Shading Geometry, Add to the output list\r\r\n            winShadingGeom = phppWindowObj.getWindowRevealGeom()\r\r\n            windowSurrounds_.AddRange( winShadingGeom, GH_Path(count) )\r\r\n            \r\r\n            # Move (inset) the Window Surface\r\r\n            windowSurfaces_.append( phppWindowObj.getInsetWindowSurface(moveWindows_) )\r\r\n            \r\r\n            count += 1\r\r\n            \r\r\n            # Add the updated Window Obj back to the phppDict\r\r\n            zone.phppWindowDict[childSrfc.name] = phppWindowObj\r\r\n\r\r\n# Go through and get all the opaque surfaces and add them to the output set\r\r\nenvelopSrfcs = DataTree[Object]()\r\r\nenvelopSrfcs_punched = []\r\r\nfor i, zone in enumerate(HBZoneObjects):\r\r\n    for srfc in zone.surfaces:\r\r\n        childSrfcs = []\r\r\n        parentSrfc = srfc.geometry\r\r\n        \r\r\n        if 'INTERIOR' not in str(srfc.EPConstruction).upper():\r\r\n            envelopSrfcs.Add(srfc.geometry, GH_Path(i) )\r\r\n            \r\r\n            if srfc.hasChild == True:\r\r\n                for childSrfc in srfc.childSrfs:\r\r\n                    childSrfcs.append(childSrfc.geometry)\r\r\n                    \r\r\n                envelopSrfcs_punched.append( ghc.SolidDifference(parentSrfc, childSrfcs) )\r\r\n            else:\r\r\n                envelopSrfcs_punched.append( srfc.geometry )\r\r\n\r\r\n# Pass Along the Honeybee Zones\r\r\nHBZones_ = _HBZones\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}