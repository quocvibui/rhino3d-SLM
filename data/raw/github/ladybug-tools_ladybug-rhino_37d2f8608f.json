{
  "source_url": "https://github.com/ladybug-tools/ladybug-rhino/blob/f3efee1cc7d68fad592b2538ad7aedead49455fd/ladybug_rhino/intersect.py",
  "repo": "ladybug-tools/ladybug-rhino",
  "repo_stars": 12,
  "repo_description": "ðŸž ðŸ¦ A library for translating between Ladybug Tools core libraries and Rhino CAD",
  "license": "AGPL-3.0",
  "filepath": "ladybug_rhino/intersect.py",
  "instruction": "Functions to handle intersection of Rhino geometries.",
  "code": "\"\"\"Functions to handle intersection of Rhino geometries.\n\nThese represent geometry computation methods  that are either not supported by\nladybug_geometry or there are much more efficient versions of them in Rhino.\n\"\"\"\nimport math\nimport operator\nimport array as specializedarray\n\ntry:\n    import System.Threading.Tasks as tasks\n    from System import Array\n    import clr\nexcept ImportError as e:\n    print('Failed to import Windows/.NET libraries\\nParallel processing functionality '\n          'will not be available\\n{}'.format(e))\n\ntry:\n    import Rhino.Geometry as rg\nexcept ImportError as e:\n    raise ImportError(\"Failed to import Rhino.\\n{}\".format(e))\n\nfrom .config import current_tolerance, rhino_version\n\n\ndef join_geometry_to_mesh(geometry):\n    \"\"\"Convert an array of Rhino Breps and/or Meshes into a single Rhino Mesh.\n\n    This is a typical pre-step before using the intersect_mesh_rays functions.\n\n    Args:\n        geometry: An array of Rhino Breps or Rhino Meshes.\n    \"\"\"\n    if len(geometry) == 1 and isinstance(geometry[0], rg.Mesh):\n        return geometry[0]\n    joined_mesh = rg.Mesh()\n    for geo in geometry:\n        if isinstance(geo, rg.Mesh):\n            joined_mesh.Append(geo)\n        elif isinstance(geo, rg.Brep):\n            meshes = rg.Mesh.CreateFromBrep(geo, rg.MeshingParameters.Default)\n            for mesh in meshes:\n                joined_mesh.Append(mesh)\n        else:  # it's likely an extrusion object\n            try:\n                geo = geo.ToBrep()  # extrusion objects must be cast to Brep in Rhino 8\n                meshes = rg.Mesh.CreateFromBrep(geo, rg.MeshingParameters.Default)\n                for mesh in meshes:\n                    joined_mesh.Append(mesh)\n            except Exception:\n                raise TypeError('Geometry must be either a Brep or a Mesh. '\n                                'Not {}.'.format(type(geo)))\n    return joined_mesh\n\n\ndef join_geometry_to_gridded_mesh(geometry, grid_size, offset_distance=0):\n    \"\"\"Create a single gridded Ladybug Mesh3D from an array of Rhino geometry.\n\n    Args:\n        breps: An array of Rhino Breps and/or Rhino meshes that will be converted\n            into a single, joined gridded Ladybug Mesh3D.\n        grid_size: A number for the grid size dimension with which to make the mesh.\n        offset_distance: A number for the distance at which to offset the points\n            from the underlying geometry. The default is 0.\n    \n    Returns:\n         A tuple with three elements\n\n        -   joined_mesh -- A Rhino Mesh from the input geometry.\n\n        -   points -- A list of Rhino Point3ds for the mesh face centers.\n\n        -   normals -- A list of Rhino Point3ds for the mesh face normals.\n    \"\"\"\n    # set up the meshing parameters\n    meshing_param = rg.MeshingParameters.Default\n    meshing_param.MaximumEdgeLength = grid_size\n    meshing_param.MinimumEdgeLength = grid_size\n    meshing_param.GridAspectRatio = 1\n    # loop through the geometry and mesh it\n    joined_mesh = rg.Mesh()\n    for geo in geometry:\n        if isinstance(geo, rg.Mesh):\n            joined_mesh.Append(geo)\n        else:\n            if not isinstance(geo, rg.Brep):  # it's likely an extrusion object\n                geo = geo.ToBrep()  # extrusion objects must be cast to Brep in Rhino 8\n            mesh_grids = rg.Mesh.CreateFromBrep(geo, meshing_param)\n            for m_grid in mesh_grids:\n                joined_mesh.Append(m_grid)\n    # compute the points at each face center and offset them if necessary\n    joined_mesh.FaceNormals.ComputeFaceNormals()\n    joined_mesh.FaceNormals.UnitizeFaceNormals()\n    normals = [joined_mesh.FaceNormals[i] for i in range(joined_mesh.FaceNormals.Count)]\n    points = []\n    if offset_distance == 0:\n        for i, n in enumerate(normals):\n            points.append(joined_mesh.Faces.GetFaceCenter(i))\n    else:\n        od = offset_distance\n        for i, n in enumerate(normals):\n            pt = joined_mesh.Faces.GetFaceCenter(i)\n            pt = rg.Point3d(pt.X + (n.X * od), pt.Y + (n.Y * od), pt.Z + (n.Z * od))\n            points.append(pt)\n    return joined_mesh, points, normals\n\n\ndef join_geometry_to_brep(geometry):\n    \"\"\"Convert an array of Rhino Breps and/or Meshes into a single Rhino Brep.\n\n    This is a typical pre-step before using the ray tracing functions.\n\n    Args:\n        geometry: An array of Rhino Breps or Rhino Meshes.\n    \"\"\"\n    joined_mesh = join_geometry_to_mesh(geometry)\n    return rg.Brep.CreateFromMesh(joined_mesh, False)\n\n\ndef bounding_box(geometry, high_accuracy=False):\n    \"\"\"Get a Rhino bounding box around an input Rhino Mesh or Brep.\n\n    This is a typical pre-step before using intersection functions.\n\n    Args:\n        geometry: A Rhino Brep or Mesh.\n        high_accuracy: If True, a physically accurate bounding box will be computed.\n            If not, a bounding box estimate will be computed. For some geometry\n            types, there is no difference between the estimate and the accurate\n            bounding box. Estimated bounding boxes can be computed much (much)\n            faster than accurate (or \"tight\") bounding boxes. Estimated bounding\n            boxes are always similar to or larger than accurate bounding boxes.\n    \"\"\"\n    return geometry.GetBoundingBox(high_accuracy)\n\n\ndef bounding_box_extents(geometry, high_accuracy=False):\n    \"\"\"Get min and max points around an input Rhino Mesh or Brep\n\n    Args:\n        geometry: A Rhino Brep or Mesh.\n        high_accuracy: If True, a physically accurate bounding box will be computed.\n            If not, a bounding box estimate will be computed. For some geometry\n            types, there is no difference between the estimate and the accurate\n            bounding box. Estimated bounding boxes can be computed much (much)\n            faster than accurate (or \"tight\") bounding boxes. Estimated bounding\n            boxes are always similar to or larger than accurate bounding boxes.\n    \"\"\"\n    b_box = bounding_box(geometry, high_accuracy)\n    return b_box.Max, b_box.Min\n\n\ndef intersect_mesh_rays(\n        mesh, points, vectors, normals=None, cpu_count=None, parallel=True):\n    \"\"\"Intersect a group of rays (represented by points and vectors) with a mesh.\n\n    All combinations of rays that are possible between the input points and\n    vectors will be intersected. This method exists since most CAD plugins have\n    much more efficient mesh/ray intersection functions than ladybug_geometry.\n    However, the ladybug_geometry Face3D.intersect_line_ray() method provides\n    a workable (albeit very inefficient) alternative to this if it is needed.\n\n    Args:\n        mesh: A Rhino mesh that can block the rays.\n        points: An array of Rhino points that will be used to generate rays.\n        vectors: An array of Rhino vectors that will be used to generate rays.\n        normals: An optional array of Rhino vectors that align with the input\n            points and denote the direction each point is facing. These will\n            be used to eliminate any cases where the vector and the normal differ\n            by more than 90 degrees. If None, points are assumed to have no direction.\n        cpu_count: An integer for the number of CPUs to be used in the intersection\n            calculation. The ladybug_rhino.grasshopper.recommended_processor_count\n            function can be used to get a recommendation. If set to None, all\n            available processors will be used. (Default: None).\n        parallel: Optional boolean to override the cpu_count and use a single CPU\n            instead of multiple processors.\n\n    Returns:\n        A tuple with two elements\n\n        -   intersection_matrix -- A 2D matrix of 0's and 1's indicating the results\n            of the intersection. Each sub-list of the matrix represents one of the\n            points and has a length equal to the vectors. 0 indicates a blocked\n            ray and 1 indicates a ray that was not blocked.\n\n        -   angle_matrix -- A 2D matrix of angles in radians. Each sub-list of the\n            matrix represents one of the normals and has a length equal to the\n            supplied vectors. Will be None if no normals are provided.\n    \"\"\"\n    intersection_matrix = [0] * len(points)  # matrix to be filled with results\n    angle_matrix = [0] * len(normals) if normals is not None else None\n    cutoff_angle = math.pi / 2  # constant used in all normal checks\n    if not parallel:\n        cpu_count = 1\n\n    def intersect_point(i):\n        \"\"\"Intersect all of the vectors of a given point without any normal check.\"\"\"\n        pt = points[i]\n        int_list = []\n        for vec in vectors:\n            ray = rg.Ray3d(pt, vec)\n            if rg.Intersect.Intersection.MeshRay(mesh, ray) >= 0:\n                is_clear = 0\n            else:\n                is_clear = 1\n            int_list.append(is_clear)\n        intersection_matrix[i] = int_list\n\n    def intersect_point_normal_check(i):\n        \"\"\"Intersect all of the vectors of a given point with a normal check.\"\"\"\n        pt, normal_vec = points[i], normals[i]\n        int_list = []\n        angle_list = []\n        for vec in vectors:\n            vec_angle = rg.Vector3d.VectorAngle(normal_vec, vec)\n            angle_list.append(vec_angle)\n            if vec_angle <= cutoff_angle:\n                ray = rg.Ray3d(pt, vec)\n                if rg.Intersect.Intersection.MeshRay(mesh, ray) >= 0:\n                    is_clear = 0\n                else:\n                    is_clear = 1\n                int_list.append(is_clear)\n            else:  # the vector is pointing behind the surface\n                int_list.append(0)\n        intersection_matrix[i] = specializedarray.array('B', int_list)\n        angle_matrix[i] = specializedarray.array('d', angle_list)\n\n    def intersect_each_point_group(worker_i):\n        \"\"\"Intersect groups of points so that only the cpu_count is used.\"\"\"\n        start_i, stop_i = pt_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_point(count)\n\n    def intersect_each_point_group_normal_check(worker_i):\n        \"\"\"Intersect groups of points with distance check so only cpu_count is used.\"\"\"\n        start_i, stop_i = pt_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_point_normal_check(count)\n\n    if cpu_count is not None and cpu_count > 1:\n        # group the points in order to meet the cpu_count\n        pt_count = len(points)\n        worker_count = min((cpu_count, pt_count))\n        i_per_group = int(math.ceil(pt_count / worker_count))\n        pt_groups = [[x, x + i_per_group] for x in range(0, pt_count, i_per_group)]\n        pt_groups[-1][-1] = pt_count  # ensure the last group ends with point count\n\n    if normals is not None:\n        if cpu_count is None:  # use all available CPUs\n            tasks.Parallel.ForEach(range(len(points)), intersect_point_normal_check)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(points)):\n                intersect_point_normal_check(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(\n                range(len(pt_groups)), intersect_each_point_group_normal_check)\n    else:\n        if cpu_count is None:  # use all available CPUs\n            tasks.Parallel.ForEach(range(len(points)), intersect_point)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(points)):\n                intersect_point(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(range(len(pt_groups)), intersect_each_point_group)\n\n    return intersection_matrix, angle_matrix\n\n\ndef intersect_rays_with_mesh_faces(\n        mesh, rays, context=None, normals=None, cpu_count=None):\n    \"\"\"Intersect a matrix of rays with a mesh to get the intersected mesh faces.\n\n    This method is useful when trying to color each face of the mesh with values\n    that can be linked to each one of the rays. For example, this method is\n    used in all shade benefit calculations.\n\n    Args:\n        mesh: A Rhino mesh that will be intersected with the rays.\n        rays: A matrix (list of lists) where each sublist contains Rhino Rays to be\n            intersected with the mesh.\n        context: An optional Rhino mesh that will be used to evaluate if the\n            rays are blocked before performing the calculation with the input\n            mesh. Rays that intersect this context will be discounted from\n            the calculation.\n        normals: An optional array of Rhino vectors that align with the input\n            rays and denote the direction each ray group is facing. These will\n            be used to eliminate any cases where the vector and the normal differ\n            by more than 90 degrees. If None, points are assumed to have no direction.\n        cpu_count: An integer for the number of CPUs to be used in the intersection\n            calculation. The ladybug_rhino.grasshopper.recommended_processor_count\n            function can be used to get a recommendation. If set to None, all\n            available processors will be used. (Default: None).\n\n    Returns:\n        A 2D matrix of integers indicating the results of the intersection.\n        Each sub-list of the matrix represents one of the mesh faces and the\n        integers within it refer to the indices of the rays in the rays\n        list that intersected that face.\n    \"\"\"\n    # create a list to populate intersected indices for each face\n    face_int = []\n    for _ in range(mesh.Faces.Count):\n        face_int.append([])  # place holder for result\n\n    # process the input normals if supplied\n    if normals is None:\n        ang_mtx = [[True] * len(r) for r in rays]\n    else:\n        cutoff_angle = math.pi / 2  # constant used in all normal checks\n        ang_mtx = []\n        for ray_list, normal_vec in zip(rays, normals):\n            pt_ang = []\n            for ray in ray_list:\n                vec_angle = rg.Vector3d.VectorAngle(normal_vec, ray.Direction)\n                vec_seen = True if vec_angle <= cutoff_angle else False\n                pt_ang.append(vec_seen)\n            ang_mtx.append(pt_ang)\n\n    def intersect_rays(i):\n        for j, ray in enumerate(rays[i]):\n            if ang_mtx[i][j]:\n                face_ids = clr.StrongBox[Array[int]]()\n                ray_p = rg.Intersect.Intersection.MeshRay(mesh, ray, face_ids)\n                if ray_p >= 0:\n                    for indx in list(face_ids.Value):\n                        face_int[indx].append(j)\n\n    def intersect_rays_context(i):\n        for j, ray in enumerate(rays[i]):\n            if ang_mtx[i][j] and rg.Intersect.Intersection.MeshRay(context, ray) < 0:\n                face_ids = clr.StrongBox[Array[int]]()\n                ray_p = rg.Intersect.Intersection.MeshRay(mesh, ray, face_ids)\n                if ray_p >= 0:\n                    for indx in list(face_ids.Value):\n                        face_int[indx].append(j)\n\n    def intersect_each_ray_group(worker_i):\n        \"\"\"Intersect groups of rays so that only the cpu_count is used.\"\"\"\n        start_i, stop_i = ray_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_rays(count)\n\n    def intersect_each_ray_group_context(worker_i):\n        \"\"\"Intersect groups of points with distance check so only cpu_count is used.\"\"\"\n        start_i, stop_i = ray_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_rays_context(count)\n\n    if cpu_count is not None and cpu_count > 1:\n        # group the rays in order to meet the cpu_count\n        ray_count = len(rays)\n        worker_count = min((cpu_count, ray_count))\n        i_per_group = int(math.ceil(ray_count / worker_count))\n        ray_groups = [[x, x + i_per_group] for x in range(0, ray_count, i_per_group)]\n        ray_groups[-1][-1] = ray_count  # ensure the last group ends with ray count\n\n    if context is not None:\n        if cpu_count is None:\n            tasks.Parallel.ForEach(range(len(rays)), intersect_rays_context)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(rays)):\n                intersect_rays_context(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(\n                range(len(ray_groups)), intersect_each_ray_group_context)\n    else:\n        if cpu_count is None:\n            tasks.Parallel.ForEach(range(len(rays)), intersect_rays)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(rays)):\n                intersect_rays(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(\n                range(len(ray_groups)), intersect_each_ray_group)\n\n    return face_int\n\n\ndef intersect_mesh_rays_distance(mesh, point, vectors, max_dist=None):\n    \"\"\"Intersect a group of rays with a mesh to get the distance until intersection.\n\n    Args:\n        mesh: A Rhino mesh that can block the rays.\n        points: A Rhino point that will be used to generate rays.\n        vectors: An array of Rhino vectors that will be used to generate rays.\n        max_dist: An optional number to set the maximum distance beyond which context\n            blocking the view is no longer considered relevant. If None,\n            geometries at all distances will be evaluated for whether they\n            block the view and the results may contain negative numbers\n            indicating that the view from that ray is never blocked\n\n    Returns:\n        A list of values for the distance at which intersection occurs.\n    \"\"\"\n    distances = []\n    if max_dist is None:\n        for vec in vectors:\n            ray = rg.Ray3d(point, vec)\n            dist = rg.Intersect.Intersection.MeshRay(mesh, ray)\n            distances.append(dist)\n    else:\n        for vec in vectors:\n            ray = rg.Ray3d(point, vec)\n            dist = rg.Intersect.Intersection.MeshRay(mesh, ray)\n            dist = max_dist if dist < 0 or dist > max_dist else dist\n            distances.append(dist)\n    return distances\n\n\ndef generate_intersection_rays(points, vectors):\n    \"\"\"Generate a series of rays to be used for intersection calculations.\n\n    All combinations of rays between the input points and vectors will be generated.\n\n    Args:\n        points: A list of Rhino point objects for the starting point of each ray.\n        vectors: A list of Rhino vector objects for the direction of each ray,\n            which will be projected from each point.\n    \"\"\"\n    int_rays = []\n    for pt in points:\n        pt_rays = []\n        for vec in vectors:\n            pt_rays.append(rg.Ray3d(pt, vec))\n        int_rays.append(pt_rays)\n    return int_rays\n\n\ndef intersect_mesh_lines(\n        mesh, start_points, end_points, max_dist=None, cpu_count=None, parallel=True):\n    \"\"\"Intersect a group of lines (represented by start + end points) with a mesh.\n\n    All combinations of lines that are possible between the input start_points and\n    end_points will be intersected. This method exists since most CAD plugins have\n    much more efficient mesh/line intersection functions than ladybug_geometry.\n    However, the ladybug_geometry Face3D.intersect_line_ray() method provides\n    a workable (albeit very inefficient) alternative to this if it is needed.\n\n    Args:\n        mesh: A Rhino mesh that can block the lines.\n        start_points: An array of Rhino points that will be used to generate lines.\n        end_points: An array of Rhino points that will be used to generate lines.\n        max_dist: An optional number to set the maximum distance beyond which the\n            end_points are no longer considered visible by the start_points.\n            If None, points with an unobstructed view to one another will be\n            considered visible no matter how far they are from one another.\n        cpu_count: An integer for the number of CPUs to be used in the intersection\n            calculation. The ladybug_rhino.grasshopper.recommended_processor_count\n            function can be used to get a recommendation. If set to None, all\n            available processors will be used. (Default: None).\n        parallel: Optional boolean to override the cpu_count and use a single CPU\n            instead of multiple processors.\n\n    Returns:\n        A 2D matrix of 0's and 1's indicating the results of the intersection.\n        Each sub-list of the matrix represents one of the points and has a\n        length equal to the end_points. 0 indicates a blocked ray and 1 indicates\n        a ray that was not blocked.\n    \"\"\"\n    int_matrix = [0] * len(start_points)  # matrix to be filled with results\n    if not parallel:\n        cpu_count = 1\n\n    def intersect_line(i):\n        \"\"\"Intersect a line defined by a start and an end with the mesh.\"\"\"\n        pt = start_points[i]\n        int_list = []\n        for ept in end_points:\n            lin = rg.Line(pt, ept)\n            int_obj = rg.Intersect.Intersection.MeshLine(mesh, lin)\n            is_clear = 1 if None in int_obj or len(int_obj) == 0 else 0\n            int_list.append(is_clear)\n        int_matrix[i] = int_list\n\n    def intersect_line_dist_check(i):\n        \"\"\"Intersect a line with the mesh with a distance check.\"\"\"\n        pt = start_points[i]\n        int_list = []\n        for ept in end_points:\n            lin = rg.Line(pt, ept)\n            if lin.Length > max_dist:\n                int_list.append(0)\n            else:\n                int_obj = rg.Intersect.Intersection.MeshLine(mesh, lin)\n                is_clear = 1 if None in int_obj or len(int_obj) == 0 else 0\n                int_list.append(is_clear)\n        int_matrix[i] = int_list\n\n    def intersect_each_line_group(worker_i):\n        \"\"\"Intersect groups of lines so that only the cpu_count is used.\"\"\"\n        start_i, stop_i = l_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_line(count)\n\n    def intersect_each_line_group_dist_check(worker_i):\n        \"\"\"Intersect groups of lines with distance check so only cpu_count is used.\"\"\"\n        start_i, stop_i = l_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_line_dist_check(count)\n\n    if cpu_count is not None and cpu_count > 1:\n        # group the lines in order to meet the cpu_count\n        l_count = len(start_points)\n        worker_count = min((cpu_count, l_count))\n        i_per_group = int(math.ceil(l_count / worker_count))\n        l_groups = [[x, x + i_per_group] for x in range(0, l_count, i_per_group)]\n        l_groups[-1][-1] = l_count  # ensure the last group ends with line count\n\n    if max_dist is not None:\n        if cpu_count is None:  # use all available CPUs\n            tasks.Parallel.ForEach(range(len(start_points)), intersect_line_dist_check)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(start_points)):\n                intersect_line_dist_check(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(\n                range(len(l_groups)), intersect_each_line_group_dist_check)\n    else:\n        if cpu_count is None:  # use all available CPUs\n            tasks.Parallel.ForEach(range(len(start_points)), intersect_line)\n        elif cpu_count <= 1:  # run everything on a single processor\n            for i in range(len(start_points)):\n                intersect_line(i)\n        else:  # run the groups in a manner that meets the CPU count\n            tasks.Parallel.ForEach(\n                range(len(l_groups)), intersect_each_line_group)\n    return int_matrix\n\n\ndef intersect_view_factor(\n        meshes, points, vectors, vector_weights,\n        context=None, normals=None, cpu_count=None):\n    \"\"\"Intersect a list of points with meshes to determine the view factor to each mesh.\n\n    Args:\n        meshes: A list of Rhino meshes that will be intersected to determine\n            the view factor from each point.\n        points: An array of Rhino points that will be used to generate rays.\n        vectors: An array of Rhino vectors that will be used to generate rays.\n        vector_weights: A list of numbers with the same length as the vectors\n            corresponding to the solid angle weight of each vector. The sum of\n            this list should be equal to one. These are needed to ensure that\n            the resulting view factors are accurate.\n        context: An optional Rhino mesh that will be used to evaluate if the\n            rays are blocked before performing the calculation with the input\n            meshes. Rays that intersect this context will be discounted from\n            the result.\n        normals: An optional array of Rhino vectors that align with the input\n            points and denote the direction each point is facing. These will\n            be used to eliminate any cases where the vector and the normal differ\n            by more than 90 degrees and will also be used to compute view factors\n            within the plane defined by this normal vector. If None, points are\n            assumed to have no direction and view factors will be computed\n            spherically around the points.\n        cpu_count: An integer for the number of CPUs to be used in the intersection\n            calculation. The ladybug_rhino.grasshopper.recommended_processor_count\n            function can be used to get a recommendation. If set to None, all\n            available processors will be used. (Default: None).\n\n    Returns:\n        A tuple with two values.\n\n        -   view_factors -- A 2D matrix of fractional values indicating the view\n            factor from each point to each mesh. Each sub-list of the matrix\n            denotes one of the input points.\n\n        -   mesh_indices -- A 2D matrix of integers indicating the index of each\n            mesh struck by each view ray. Each sub-list of the matrix represents\n            one of the points and the value in each sub-list is the integer of\n            the mesh that was struck by a given ray shot from the point.\n    \"\"\"\n    # set up the matrices to be filled\n    view_factors = [[] for _ in points]\n    mesh_indices = [[] for _ in points]\n    vec_count = len(vectors)\n    cutoff_angle = math.pi / 2  # constant used in all normal checks\n\n    # combine the context with the meshes if it is specified\n    context_index = None\n    if context is not None:\n        meshes = list(meshes) + [context]\n        context_index = len(meshes) - 1\n\n    def intersect_point(i):\n        \"\"\"Intersect all of the vectors of a given point without any normal check.\"\"\"\n        # create the rays to be projected from each point\n        rel_pt = points[i]\n        point_rays = []\n        for vec in vectors:\n            point_rays.append(rg.Ray3d(rel_pt, vec))\n        \n        # perform the intersection of the rays with the mesh\n        pt_int_mtx = []\n        for ray in point_rays:\n            srf_list = []\n            for srf in meshes:\n                intersect = rg.Intersect.Intersection.MeshRay(srf, ray)\n                if intersect < 0:\n                    intersect = 'N'\n                srf_list.append(intersect)\n            pt_int_mtx.append(srf_list)\n        \n        # find the intersection that was the closest for each ray\n        srf_hits = [[] for _ in meshes]\n        for ray_count, int_list in enumerate(pt_int_mtx):\n            if not all(x == 'N' for x in int_list):\n                min_index, _ = min(enumerate(int_list), key=operator.itemgetter(1))\n                if min_index == context_index:\n                    mesh_indices[i].append(-1)\n                else:\n                    mesh_indices[i].append(min_index)\n                    if normals is None or normals[i] is None:\n                        srf_hits[min_index].append(vector_weights[ray_count])\n                    else:\n                        # get the angle between the surface and the vector\n                        vec_angle = rg.Vector3d.VectorAngle(\n                            vectors[ray_count], normals[i])\n                        if vec_angle > cutoff_angle:\n                            srf_hits[min_index].append(0)\n                        else:\n                            srf_hits[min_index].append(\n                                vector_weights[ray_count] * 4 * abs(math.cos(vec_angle)))\n            else:\n                mesh_indices[i].append(-1)\n        \n        # sum up the lists and divide by the total rays to get the view factor\n        for hit_list in srf_hits:\n            view_factors[i].append(sum(hit_list) / vec_count)\n\n    def intersect_each_point_group(worker_i):\n        \"\"\"Intersect groups of points so that only the cpu_count is used.\"\"\"\n        start_i, stop_i = pt_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_point(count)\n\n    if cpu_count is not None and cpu_count > 1:\n        # group the points in order to meet the cpu_count\n        pt_count = len(points)\n        worker_count = min((cpu_count, pt_count))\n        i_per_group = int(math.ceil(pt_count / worker_count))\n        pt_groups = [[x, x + i_per_group] for x in range(0, pt_count, i_per_group)]\n        pt_groups[-1][-1] = pt_count  # ensure the last group ends with point count\n\n    if cpu_count is None:  # use all available CPUs\n        tasks.Parallel.ForEach(range(len(points)), intersect_point)\n    elif cpu_count <= 1:  # run everything on a single processor\n        for i in range(len(points)):\n            intersect_point(i)\n    else:  # run the groups in a manner that meets the CPU count\n        tasks.Parallel.ForEach(range(len(pt_groups)), intersect_each_point_group)\n\n    return view_factors, mesh_indices\n\n\ndef trace_ray(ray, breps, bounce_count=1):\n    \"\"\"Get a list of Rhino points for the path a ray takes bouncing through breps.\n\n    Args:\n        ray: A Rhino Ray whose path will be traced through the geometry.\n        breps: An array of Rhino breps through with the ray will be traced.\n        bounce_count: An positive integer for the number of ray bounces to trace\n            the sun rays forward. (Default: 1).\n    \"\"\"\n    return rg.Intersect.Intersection.RayShoot(ray, breps, bounce_count)\n\n\ndef normal_at_point(brep, point):\n    \"\"\"Get a Rhino vector for the normal at a specific point that lies on a brep.\n\n    Args:\n        breps: A Rhino brep on which the normal direction will be evaluated.\n        point: A Rhino point on the input brep where the normal will be evaluated.\n    \"\"\"\n    return brep.ClosestPoint(point, current_tolerance())[5]\n\n\ndef intersect_solids_parallel(solids, bound_boxes, cpu_count=None):\n    \"\"\"Intersect the co-planar faces of an array of solids using parallel processing.\n\n    Args:\n        original_solids: An array of closed Rhino breps (polysurfaces) that do\n            not have perfectly matching surfaces between adjacent Faces.\n        bound_boxes: An array of Rhino bounding boxes that parallels the input\n            solids and will be used to check whether two Breps have any potential\n            for intersection before the actual intersection is performed.\n        cpu_count: An integer for the number of CPUs to be used in the intersection\n            calculation. The ladybug_rhino.grasshopper.recommended_processor_count\n            function can be used to get a recommendation. If None, all available\n            processors will be used. (Default: None).\n        parallel: Optional boolean to override the cpu_count and use a single CPU\n            instead of multiple processors.\n\n    Returns:\n        int_solids -- The input array of solids, which have all been intersected\n        with one another.\n    \"\"\"\n    int_solids = solids[:]  # copy the input list to avoid editing it\n\n    def intersect_each_solid(i):\n        \"\"\"Intersect a solid with all of the other solids of the list.\"\"\"\n        bb_1 = bound_boxes[i]\n        # intersect the solids that come after this one\n        for j, bb_2 in enumerate(bound_boxes[i + 1:]):\n            if not overlapping_bounding_boxes(bb_1, bb_2):\n                continue  # no overlap in bounding box; intersection impossible\n            split_brep1, int_exists = \\\n                intersect_solid(int_solids[i], int_solids[i + j + 1])\n            if int_exists:\n                int_solids[i] = split_brep1\n        # intersect the solids that come before this one\n        for j, bb_2 in enumerate(bound_boxes[:i]):\n            if not overlapping_bounding_boxes(bb_1, bb_2):\n                continue  # no overlap in bounding box; intersection impossible\n            split_brep2, int_exists = intersect_solid(int_solids[i], int_solids[j])\n            if int_exists:\n                int_solids[i] = split_brep2\n\n    def intersect_each_solid_group(worker_i):\n        \"\"\"Intersect groups of solids so that only the cpu_count is used.\"\"\"\n        start_i, stop_i = s_groups[worker_i]\n        for count in range(start_i, stop_i):\n            intersect_each_solid(count)\n\n    if cpu_count is None or cpu_count <= 1:  # use all available CPUs\n        tasks.Parallel.ForEach(range(len(solids)), intersect_each_solid)\n    else:  # group the solids in order to meet the cpu_count\n        solid_count = len(int_solids)\n        worker_count = min((cpu_count, solid_count))\n        i_per_group = int(math.ceil(solid_count / worker_count))\n        s_groups = [[x, x + i_per_group] for x in range(0, solid_count, i_per_group)]\n        s_groups[-1][-1] = solid_count  # ensure the last group ends with solid count\n        tasks.Parallel.ForEach(range(len(s_groups)), intersect_each_solid_group)\n\n    return int_solids\n\n\ndef intersect_solids(solids, bound_boxes):\n    \"\"\"Intersect the co-planar faces of an array of solids.\n\n    Args:\n        original_solids: An array of closed Rhino breps (polysurfaces) that do\n            not have perfectly matching surfaces between adjacent Faces.\n        bound_boxes: An array of Rhino bounding boxes that parallels the input\n            solids and will be used to check whether two Breps have any potential\n            for intersection before the actual intersection is performed.\n\n    Returns:\n        int_solids -- The input array of solids, which have all been intersected\n        with one another.\n    \"\"\"\n    int_solids = solids[:]  # copy the input list to avoid editing it\n\n    for i, bb_1 in enumerate(bound_boxes):\n        for j, bb_2 in enumerate(bound_boxes[i + 1:]):\n            if not overlapping_bounding_boxes(bb_1, bb_2):\n                continue  # no overlap in bounding box; intersection impossible\n\n            # split the first solid with the second one\n            split_brep1, int_exists = intersect_solid(\n                int_solids[i], int_solids[i + j + 1])\n            int_solids[i] = split_brep1\n\n            # split the second solid with the first one if an intersection was found\n            if int_exists:\n                split_brep2, int_exists = intersect_solid(\n                    int_solids[i + j + 1], int_solids[i])\n                int_solids[i + j + 1] = split_brep2\n\n    return int_solids\n\n\ndef intersect_solid(solid, other_solid):\n    \"\"\"Intersect the co-planar faces of one solid Brep using another.\n\n    Args:\n        solid: The solid Brep which will be split with intersections.\n        other_solid: The other Brep, which will be used to split.\n\n    Returns:\n        A tuple with two elements\n\n        -   solid -- The input solid, which has been split.\n\n        -   intersection_exists -- Boolean to note whether an intersection was found\n            between the solid and the other_solid. If False, there's no need to\n            split the other_solid with the input solid.\n    \"\"\"\n    # variables to track the splitting process\n    intersection_exists = False  # boolean to note whether an intersection exists\n    temp_brep = solid.Split(other_solid, current_tolerance())\n    if len(temp_brep) != 0:\n        solid = rg.Brep.JoinBreps(temp_brep, current_tolerance())[0]\n        solid.Faces.ShrinkFaces()\n        intersection_exists = True\n    return solid, intersection_exists\n\n\ndef overlapping_bounding_boxes(bound_box1, bound_box2):\n    \"\"\"Check if two Rhino bounding boxes overlap within the tolerance.\n\n    This is particularly useful as a check before performing computationally\n    intense intersection processes between two bounding boxes. Checking the\n    overlap of the bounding boxes is extremely quick given this method's use\n    of the Separating Axis Theorem. This method is built into the intersect_solids\n    functions in order to improve its calculation time.\n\n    Args:\n        bound_box1: The first bound_box to check.\n        bound_box2: The second bound_box to check.\n    \"\"\"\n    # Bounding box check using the Separating Axis Theorem\n    bb1_width = bound_box1.Max.X - bound_box1.Min.X\n    bb2_width = bound_box2.Max.X - bound_box2.Min.X\n    dist_btwn_x = abs(bound_box1.Center.X - bound_box2.Center.X)\n    x_gap_btwn_box = dist_btwn_x - (0.5 * bb1_width) - (0.5 * bb2_width)\n\n    bb1_depth = bound_box1.Max.Y - bound_box1.Min.Y\n    bb2_depth = bound_box2.Max.Y - bound_box2.Min.Y\n    dist_btwn_y = abs(bound_box1.Center.Y - bound_box2.Center.Y)\n    y_gap_btwn_box = dist_btwn_y - (0.5 * bb1_depth) - (0.5 * bb2_depth)\n\n    bb1_height = bound_box1.Max.Z - bound_box1.Min.Z\n    bb2_height = bound_box2.Max.Z - bound_box2.Min.Z\n    dist_btwn_z = abs(bound_box1.Center.Z - bound_box2.Center.Z)\n    z_gap_btwn_box = dist_btwn_z - (0.5 * bb1_height) - (0.5 * bb2_height)\n\n    tolerance = current_tolerance()\n    if x_gap_btwn_box > tolerance or y_gap_btwn_box > tolerance or \\\n            z_gap_btwn_box > tolerance:\n        return False  # no overlap\n    return True  # overlap exists\n\n\ndef split_solid_to_floors(building_solid, floor_heights):\n    \"\"\"Extract a series of planar floor surfaces from solid building massing.\n\n    Args:\n        building_solid: A closed brep representing a building massing.\n        floor_heights: An array of float values for the floor heights, which\n            will be used to generate planes that subdivide the building solid.\n\n    Returns:\n        floor_breps -- A list of planar, horizontal breps representing the floors\n        of the building.\n    \"\"\"\n    tolerance = current_tolerance()\n    # get the floor brep at each of the floor heights.\n    floor_breps = []\n    for hgt in floor_heights:\n        story_breps = []\n        floor_base_pt = rg.Point3d(0, 0, hgt)\n        section_plane = rg.Plane(floor_base_pt, rg.Vector3d.ZAxis)\n        floor_crvs = rg.Brep.CreateContourCurves(building_solid, section_plane)\n        try:  # Assume a single contour curve has been found\n            floor_brep = rg.Brep.CreatePlanarBreps(floor_crvs, tolerance)\n        except TypeError:  # An array of contour curves has been found\n            floor_brep = rg.Brep.CreatePlanarBreps(floor_crvs)\n        if floor_brep is not None:\n            story_breps.extend(floor_brep)\n        floor_breps.append(story_breps)\n\n    return floor_breps\n\n\ndef geo_min_max_height(geometry):\n    \"\"\"Get the min and max Z values of any input object.\n\n    This is useful as a pre-step before the split_solid_to_floors method.\n    \"\"\"\n    # intersection functions changed in Rhino 7.15 such that we now need 2 * tolerance\n    add_val = current_tolerance() * 2 if (7, 15) <= rhino_version < (7, 17) else 0\n    bound_box = geometry.GetBoundingBox(rg.Plane.WorldXY)\n    return bound_box.Min.Z + add_val, bound_box.Max.Z\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}