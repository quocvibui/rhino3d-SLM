{
  "source_url": "https://github.com/Nihawl/DC-TowerProject/blob/c7c313efa7c772023ea11650ad3fe5b7f14b282c/Tower-Project-Module01.py",
  "repo": "Nihawl/DC-TowerProject",
  "repo_stars": 0,
  "repo_description": "Tower Skin 3D Model in Python - Part of \"Design Computing\" Course in Coursera ",
  "license": "MIT",
  "filepath": "Tower-Project-Module01.py",
  "instruction": "TOWER ASSIGNMENT import modules",
  "code": "#TOWER ASSIGNMENT\r\n#import modules\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\n#Divide Surface to Cubes and add text dots\r\n#Define each modular unit geometry \r\n\r\ndef SurfacePoints(STRSRF, INTU, INTV):\r\n    #create empty dictionary\r\n    ptMTX = {}\r\n    srfNorm = {}\r\n    \r\n    #find domain of surface\r\n    Udomain = rs.SurfaceDomain(STRSRF, 0)\r\n    Vdomain = rs.SurfaceDomain(STRSRF, 1)   \r\n    \r\n    #calculate step value\r\n    UStep = (Udomain[1] - Udomain[0]) / INTU\r\n    VStep = (Vdomain[1] - Vdomain[0]) / INTV\r\n    \r\n    #Calculate exponential step\r\n    exp_Step = DivideExponentially((Udomain[1] - Udomain[0]), INTU)\r\n    \r\n    #Plot points on surface\r\n    for i in range(INTU + 1):\r\n        for j in range(INTV + 1):\r\n            #define u and v in terms of i and j\r\n            #u = Udomain[0] + UStep * i\r\n            u = exp_Step[i] \r\n            v = Vdomain[0] + VStep * j\r\n            \r\n            #evaluate surface\r\n            point = rs.EvaluateSurface(STRSRF, u, v)\r\n            ptMTX[(i,j)] = point\r\n            \r\n            #find surface normal at parameters\r\n            vecNorm = rs.SurfaceNormal(STRSRF, (u,v))\r\n            #scale vector\r\n            vecNorm = rs.VectorUnitize(vecNorm)\r\n            vecNorm = rs.VectorScale(vecNorm, 2)\r\n            vecNorm = rs.PointAdd(vecNorm, point)\r\n            srfNorm[(i,j)] = vecNorm\r\n            \r\n    #Add text dots\r\n    #for i in range(INTU+1):\r\n        #for j in range(INTV+1):\r\n            #rs.AddTextDot((i,j),ptMTX[(i,j)])\r\n            #rs.AddTextDot((i,j),srfNorm[(i,j)])\r\n    #call function to create geometry\r\n    GenerateGeometry_Pattern1(ptMTX, srfNorm, INTU, INTV)\r\n\r\n#CREATE PATTERN 01 FUNCTION\r\n#def GenerateGeometry_Pattern1(ptMTX, srfNorm, INTU, INTV):\r\n#    for i in range(INTU + 1):\r\n#        for j in range(INTV + 1):\r\n#            if i > 0 and j > 0:\r\n#            #create back curve\r\n#                midpt_Back = MidPt(srfNorm[(i-1,j-1)], srfNorm[(i-1,j)])\r\n#                crv_Back = rs.AddCurve((ptMTX[(i-1,j-1)],midpt_Back, ptMTX[(i-1,j)]),3)\r\n#            #create front curve\r\n#                midpt_Front = MidPt(srfNorm[(i,j-1)], srfNorm[(i,j)])\r\n#                crv_Front = rs.AddCurve((ptMTX[(i-1,j-1)],midpt_Front, ptMTX[(i,j-1)]),3)\r\n#                #Loft\r\n#                module = rs.AddLoftSrf((crv_Back,crv_Front),None, None, 2)\r\n#                module = rs.FlipSurface(module, True)\r\n\r\n#CREATE PATTERN 02 FUNCTION\r\ndef GenerateGeometry_Pattern1(ptMTX, srfNorm, INTU, INTV):\r\n    for i in range(INTU + 1):\r\n        for j in range(INTV + 1):\r\n            if i > 0 and j > 0:\r\n                #Create front point grid\r\n                #create point 01\r\n                crv_01 = rs.AddCurve((srfNorm[(i-1, j)],srfNorm[(i, j-1)]),1)\r\n                pt_01 = rs.EvaluateCurve(crv_01, 2)\r\n                pt_01 = rs.AddPoint(pt_01)\r\n                #create point 02\r\n                crv_02 = rs.AddCurve((srfNorm[(i-1, j-1)],srfNorm[(i, j)]),1)\r\n                pt_02 = rs.EvaluateCurve(crv_02, 2)\r\n                pt_02 = rs.AddPoint(pt_02)\r\n                #create point 03\r\n                mid_end = MidPt(srfNorm[(i-1,j-1)], srfNorm[(i-1,j)])\r\n                mid_start = MidPt(srfNorm[(i,j-1)], srfNorm[(i,j)])\r\n                crv_03 = rs.AddCurve((mid_start, mid_end),1)\r\n                pt_03 = rs.EvaluateCurve(crv_03, 2)\r\n                pt_03 = rs.AddPoint(pt_03)\r\n                \r\n                #Create Surfaces\r\n                srf_01 = rs.AddSrfPt((ptMTX[(i-1,j-1)],pt_02,pt_01,ptMTX[(i-1,j)]))\r\n                \r\n                #srf_02 = rs.AddSrfPt((ptMTX[(i-1,j-1)],pt_02,pt_03,ptMTX[(i,j-1)]))\r\n                srf_02 = rs.AddSrfPt((ptMTX[(i,j-1)],pt_03,pt_02,ptMTX[(i-1,j-1)]))\r\n                \r\n                #srf_03 = rs.AddSrfPt((ptMTX[(i,j-1)],pt_03,ptMTX[(i,j)]))\r\n                srf_03 = rs.AddSrfPt((ptMTX[(i,j)],pt_03,ptMTX[(i,j-1)]))\r\n                \r\n                #srf_04 = rs.AddSrfPt((ptMTX[(i,j)],pt_03,pt_01,ptMTX[(i-1,j)]))\r\n                srf_04 = rs.AddSrfPt((ptMTX[(i-1,j)],pt_01,pt_03,ptMTX[(i,j)]))\r\n                \r\n                #Delete curves\r\n                rs.DeleteObjects((crv_01,crv_02,crv_03))\r\n                rs.DeleteObjects((pt_01, pt_02,pt_03))\r\n\r\n\r\n#GET MIDPOINT FUNCTION\r\ndef MidPt(PT01, PT02):\r\n        point = None\r\n        #calculate midpoint position\r\n        point = [(PT01[0] + PT02[0]) / 2,(PT01[1] + PT02[1]) / 2,\r\n        (PT01[2] + PT02[2]) / 2]\r\n        return point\r\n\r\n#DIVIDE EXPONENTIALLY FUNCTION\r\ndef DivideExponentially(maxLength, Divisions):\r\n    ##input curve\r\n    #crv = rs.GetObject('Select Curve', rs.filter.curve)\r\n    ##get length\r\n    #maxLength = rs.CurveLength(crv)\r\n    #\r\n    ##input number of divisions\r\n    #Divisions = rs.GetInteger('Enter number of divisions',8)\r\n    \r\n    #set up lists\r\n    point = []\r\n    yVal = []\r\n    \r\n    #create point where x is .72 of Vdomain and y and z are 0 (point[0])\r\n    pt = ([(maxLength*.72),0,0])\r\n    rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where x and y are .12 of model curve length and z is 0 (point[1])\r\n    pt = ([(maxLength*.12),(maxLength*.12),0])\r\n    rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where y is model curve length and x and z are 0 (point[2])\r\n    pt = ([0,maxLength,0])\r\n    rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #draw a curve between the three points\r\n    GRAPHcrvGUID = rs.AddCurve(point)\r\n    #divide curve\r\n    crvPoints = rs.DivideCurve(GRAPHcrvGUID, Divisions, True, True)\r\n    \r\n    #collect y-values\r\n    for i in range(len(crvPoints)):\r\n        yVal.append(crvPoints[i][1])\r\n        \r\n    return yVal\r\n#\r\ndef main():\r\n    #input values\r\n    strSRF = rs.GetObject('Select Surface')\r\n    intU = rs.GetInteger('Input u-interval',8)\r\n    intV = rs.GetInteger('Input v-interval',8)\r\n    rs.HideObject(strSRF)\r\n    rs.EnableRedraw(False)\r\n    SurfacePoints(strSRF, intU, intV)\r\n    rs.EnableRedraw(True)\r\n\r\nmain()    \r\n\r\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}