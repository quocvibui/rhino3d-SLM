{
  "source_url": "https://github.com/fstwn/ghautoknit/blob/5ca6d07df601d34be5a67fe6c76a942daef50a85/modules/ghautoknit/FileIO.py",
  "repo": "fstwn/ghautoknit",
  "repo_stars": 3,
  "repo_description": "A prototypical bridge between Grasshopper and Autoknit.",
  "license": "MIT",
  "filepath": "modules/ghautoknit/FileIO.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import deque\nimport itertools\nfrom os import path\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\nfrom ghautoknit import Structs\nfrom ghautoknit.Constraint import Constraint\n\n# RHINO IMPORTS ---------------------------------------------------------------\nfrom Rhino.Geometry import Mesh as RhinoMesh\nfrom Rhino.Geometry import Point3f as RhinoPoint3f\n\n# ALL LIST --------------------------------------------------------------------\n__all__ = [\n    \"LoadConstraints\",\n    \"SaveConstraints\",\n    \"InterpretStoredConstraints\",\n    \"LoadObj\",\n    \"SaveObj\"\n]\n\n\n# READ AND WRITE FUNCTIONS (PRIVATE) ------------------------------------------\n\n# SCALARS ---------------------------------------------------------------------\n\ndef _read_scalar(instream, name):\n    \"\"\"Reads a scalar from the stream and returns it as an integer.\"\"\"\n    try:\n        s = instream.read(Structs.STRUCT_SCALAR.size)\n        scalar = Structs.STRUCT_SCALAR.unpack(s)[0]\n        return scalar\n    except Exception as e:\n        raise RuntimeError(\"Failed to read scalar \" +\n                           \"{} // {}\".format(name, str(e)))\n\n\ndef _write_scalar(outstream, scalar, name):\n    \"\"\"Writes a scalar to the output stream.\"\"\"\n    try:\n        s = Structs.STRUCT_SCALAR.pack(scalar)\n        outstream.write(s)\n        return True\n    except Exception as e:\n        raise RuntimeError(\"Failed to write scalar \" +\n                           \"{} // {}\".format(name, e))\n\n\n# VECTORS ---------------------------------------------------------------------\n\ndef _read_vector(instream, structure, name):\n    \"\"\"Reads a vector from the instream and returns it as a tuple.\"\"\"\n    try:\n        v = instream.read(structure.size)\n        vector = structure.unpack(v)\n        return vector\n    except Exception as e:\n        raise RuntimeError(\"Failed to read vector \" +\n                           \"{} // {}\".format(name, str(e)))\n\n\ndef _write_vector(outstream, vector, structure, name):\n    \"\"\"Writes a vector to the output stream.\"\"\"\n    try:\n        v = structure.pack(*vector)\n        outstream.write(v)\n        return True\n    except Exception as e:\n        raise RuntimeError(\"Failed to write vector \" +\n                           \"{} // {}\".format(name, e))\n\n\n# VECTOR SEQUENCES ------------------------------------------------------------\n\ndef _read_vector_sequence(instream, structure, name):\n    \"\"\"\n    Reads a sequence of vectors from the stream using the given structure.\n    \"\"\"\n    try:\n        count = _read_scalar(instream, name + \" count\")\n        vectors = [_read_vector(instream,\n                                structure,\n                                name + \" {}\".format(i)) for i in range(count)]\n        return vectors\n    except Exception as e:\n        raise RuntimeError(\"Failed to read vector sequence \" +\n                           \"{} // {}\".format(name, str(e)))\n\n\ndef _write_vector_sequence(outstream, sequence, structure, name):\n    \"\"\"Writes a sequence of vectors to the stream using the given structure.\"\"\"\n    try:\n        count = len(sequence)\n        _write_scalar(outstream, count, name + \" count\")\n        for i, v in enumerate(sequence):\n            _write_vector(outstream, v, structure, name + \" {}\".format(str(i)))\n        return True\n    except Exception as e:\n        raise RuntimeError(\"Failed to write vector sequence \" +\n                           \"{} // {}\".format(name, str(e)))\n\n\n# LOADING AND SAVING OF CONSTRAINTS (PUBLIC) ----------------------------------\n\ndef LoadConstraints(filepath):\n    \"\"\"Loads autoknit constraints from a binary *.cons file.\"\"\"\n    with open(filepath, \"rb\") as f:\n        try:\n            vertices = _read_vector_sequence(f,\n                                             Structs.STRUCT_VERTEX,\n                                             \"vertices\")\n            constraints = _read_vector_sequence(\n                                            f,\n                                            Structs.STRUCT_STOREDCONSTRAINT,\n                                            \"constraints\")\n            return True, vertices, constraints\n        except Exception as e:\n            print(e)\n            return False, e\n\n\ndef SaveConstraints(filepath, vertices, constraints):\n    \"\"\"Saves constraints to a binary *.cons file compatible with autoknit.\"\"\"\n    try:\n        with open(filepath, \"wb\") as f:\n            vertices = list(itertools.chain.from_iterable(vertices))\n            _write_vector_sequence(f,\n                                   vertices,\n                                   Structs.STRUCT_VERTEX,\n                                   \"vertices\")\n\n            constraints = [c.Storable for c in constraints]\n            _write_vector_sequence(f,\n                                   constraints,\n                                   Structs.STRUCT_STOREDCONSTRAINT,\n                                   \"constraints\")\n    except Exception as e:\n        print(e)\n        raise RuntimeError(\"Could not write constraints file!\")\n\n\n# INTERPRETATION OF SAVED CONSTRAINTS -----------------------------------------\n\ndef InterpretStoredConstraints(points, storedconstraints):\n    \"\"\"Interprets the results of loading a *.cons file and builds\n    Autoknit Constraints from them.\"\"\"\n    points = deque(points)\n    constraints = []\n    for i, c in enumerate(storedconstraints):\n        vertices = [points.popleft() for x in range(c.Count)]\n        constraints.append(Constraint(i, vertices, c.Value, c.Radius))\n    return constraints\n\n\n# LOADING AND SAVING OF MODELS (OBJ FILES) ------------------------------------\n\ndef LoadObj(filepath):\n    \"\"\"Reads from an *.obj file and returns a mesh\"\"\"\n    # create a new, empty Rhino mesh\n    model = RhinoMesh()\n    # read from the file in text mode\n    with open(filepath, \"rt\") as f:\n        while True:\n            #scriptcontext.escape_test()\n\n            # read a line and split it into parts\n            line = f.readline()\n            if not line:\n                break\n\n            # split the line into parts\n            parts = str.split(line, \" \")\n            token = parts[0]\n            data = parts[1:]\n\n            # catch empty line as delimiter\n            if not parts or parts == [\"\"]:\n                continue\n\n            # catch vertices\n            elif token == \"v\":\n                # add vertex\n                vx, vy, vz = [float(c) for c in data]\n                vertex = RhinoPoint3f(vx, vy, vz)\n                model.Vertices.Add(vertex)\n\n            # catch faces\n            elif token == \"f\":\n                # add face\n                if len(data) == 3:\n                    # implementation detail: Rhino vertex indices are 0-based\n                    va, vb, vc = [int(i)-1 for i in data]\n                    model.Faces.AddFace(va, vb, vc)\n                elif len(data) == 4:\n                    # implementation detail: Rhino vertex indices are 0-based\n                    va, vb, vc, vd = [int(i)-1 for i in data]\n                    model.Faces.AddFace(va, vb, vc, vd)\n    return model\n\n\ndef SaveObj(filepath, mesh):\n    \"\"\"Saves a Rhino mesh as an *.obj file.\"\"\"\n    # run some checks on the input\n    if not mesh or type(mesh) is not RhinoMesh:\n        raise ValueError(\"Supplied mesh is not a valid Rhino mesh!\")\n    if not filepath or type(filepath) is not str:\n        raise ValueError(\"Supplied filepath is not a valid filepath!\")\n\n    # remove trailing newlines from the filepath and check for file extension\n    filepath = path.normpath(filepath.rstrip(\"\\n\\r\"))\n    if not filepath.lower().endswith(\".obj\"):\n        filepath = filepath + \".obj\"\n\n    # extract vertex coordinates from the mesh and build strings\n    mv = list(mesh.Vertices.ToPoint3dArray())\n    vertices = [\"v {} {} {}\\n\".format(v.X, v.Y, v.Z) for v in mv]\n\n    # extract faces from the mesh and build obj strings\n    fids = deque(mesh.Faces.ToIntArray(False))\n    temp = deque()\n    faces = deque()\n    while len(fids) > 0:\n        # scriptcontext.escape_test()\n        # if face is complete, check if it is a triangle, append and reset temp\n        if temp and len(temp) == 4:\n            if temp[-2] == temp[-1]:\n                temp.pop()\n            faces.append((\"f\" + (\" {}\" * len(temp)) + \"\\n\").format(*temp))\n            temp.clear()\n        else:\n            # standard procedure - just add index to temp\n            temp.append(fids.popleft() + 1)\n    else:\n        # handle trailing face at the end\n        if len(temp) > 0:\n            if len(temp) == 4 and temp[-2] == temp[-1]:\n                temp.pop()\n            faces.append((\"f\" + (\" {}\" * len(temp)) + \"\\n\").format(*temp))\n            temp.clear()\n\n    # open the file and write all the collected data to it\n    with open(filepath, \"wt\") as f:\n        # write the header to the file\n        f.write(\"# Rhino Grasshopper OBJ exporter by Max Eschenbach\\n\")\n        f.write(\"\\n\")\n        f.write(\"# Mesh Vertices\\n\")\n        f.writelines(vertices)\n        f.write(\"\\n\")\n        f.write(\"# Mesh Faces\\n\")\n        f.writelines(faces)\n\n\n# MAIN ------------------------------------------------------------------------\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}