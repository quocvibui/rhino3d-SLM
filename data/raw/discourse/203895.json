{
  "source_url": "https://discourse.mcneel.com/t/supercomb-a-supercharged-curvature-rebuild/203895",
  "topic_id": 203895,
  "title": "SuperComb, a supercharged Curvature rebuild",
  "question": "SuperComb, a Rebuild of Curvature Analysis with Grasshopper: Finer Controls, Enhanced Visualization\n\n\n\n\n\n\n\n\n\n\n\n\nI’ve rewritten Rhino’s curvature analysis tool for my specific needs using Grasshopper and Python. I’ve taken advantage of Anthropic’s Claude for AI-assisted coding to expand what’s possible with this enhanced visualization method.  The AI written GH Python coding was a rewarding experience. This took about 20-30 iterations of adding on features and testing.\n\n\nStandard Curvature Rebuild, Fine Control Comb Line Length\n1910×1334 114 KB\n\n\nThe integer-only scaling limitation and fine line width of the Rhino native tool was my initial motivation in rebuilding this function. The standard tool forces values like 125 or 126 with no ability to input 125.5 - and the visual jump between consecutive integers is dramatic. This SuperComb implementation allows for much finer, smoother control over line length and display.\n\n\nBlack and White Gradient\n1910×1334 94.1 KB\n\n\nColor Gradient 2\n1910×1334 98.6 KB\n\n\nThicker Comb Line Display\n1910×1334 102 KB\n\nThe color-mapping functionality adds another dimension entirely. The comb lines can now be related to customizable color palettes through two methods:\n\n\n\n\nDynamic mapping: Adjusts the full color palette to the min/max values present in a curve.\n\n\nFixed or referenced mapping: Assigns colors to specific radius thresholds defined by inputs.\n\n\n\n\nAlternate Gradient\n1910×1334 109 KB\n\n\nViewCapture20250502_001548\n1910×1334 132 KB\n\n\nOne interesting discovery was the ability to flip the magnitude display. My first introduction, back in the 90s, I found it counterintuitive that tighter curvature (smaller radius) generates longer display lines. I adapted to this CAD convention quickly, but I’ve never viewed any one system as the gold standard - it’s about adapting tools to what works for my exploration process.\n\n\nRadius Labels Toggled On\n1910×1334 157 KB\n\n\nViewCapture20250502_001618\n1910×1334 175 KB\n\n\nViewCapture20250502_001807\n1910×1334 1...",
  "code_blocks": [
    {
      "code": "# Full Python script for Advanced Grasshopper Curvature Comb\n# VERSION WITH Min/Max Length + Cosine Exaggeration + Curvature Radius-Based Distribution + Refined Boundary\n# MODIFIED: Radius-based length easing + PascalCase consistency fix",
      "language": "python",
      "author": "nxakt",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "import Rhino.Geometry as rg\nfrom System.Drawing import Color\nimport math\nimport sys\nimport time\n\n### SECTION 2: EASING AND BLENDING FUNCTIONS\n\ndef apply_easing(value, exaggeration, easing_type=\"cosine\", strength=1.0):\n    \"\"\"\n    Apply different easing functions to a normalized value (0-1)\n    \n    Parameters:\n        value: Normalized value (0-1)\n        exaggeration: Controls the \"contrast\" (0-1)\n                      0 = linear blend, 1 = full easing\n        easing_type: Type of easing to apply (\"cosine\" or \"hermite\")\n        strength: For hermite, controls the curve shape (0.5-2.0 typical)\n    Returns:\n        Blended value (0-1)\n    \"\"\"\n    # Ensure inputs are in valid range\n    value = max(0.0, min(1.0, value))\n    exaggeration = max(0.0, min(1.0, exaggeration))\n    \n    # Calculate appropriate blend based on easing type\n    if easing_type == \"cosine\":\n        # Cosine easing\n        eased_component = (1.0 - math.cos(math.pi * value)) * 0.5\n    elif easing_type == \"hermite\":\n        # Hermite ease-out with adjustable strength\n        eased_component = hermite_ease_out(value, strength)\n    else:\n        # Default to linear\n        eased_component = value\n    \n    # Blend between linear and eased\n    if exaggeration <= 0.0:\n        return value  # Linear (no change)\n    elif exaggeration >= 1.0:\n        return eased_component  # Full easing\n    else:\n        # Blend linearly between the two\n        return value * (1.0 - exaggeration) + eased_component * exaggeration\n###\n### SECTION 3: HERMITE EASING FUNCTION (CORRECTED)\n###\ndef hermite_ease_out(value, strength=1.0):\n    \"\"\"\n    Apply an ease-out Hermite curve to a normalized value (0-1)\n    with adjustable strength parameter\n    \n    Parameters:\n        value: Normalized value (0-1)\n        strength: Controls the shape of the curve (0.5-5.0 range)\n                  Higher values make the curve steeper initially\n    Returns:\n        Eased value (0-1)\n    \"\"\"\n    # Ensure input is in valid range\n    value = max(0.0001, min(1.0, value))  # Avoid zero which could cause domain error\n    strength = max(0.51, min(5.0, strength))  # Prevent extreme values\n    \n    # Modified Hermite ease-out formula with strength parameter\n    if abs(strength - 1.0) < 0.01:\n        # Standard Hermite: t * (2 - t)\n        return value * (2.0 - value)\n    elif strength < 1.0:\n        # Gentler curve for values < 1.0\n        return value ** (1.0/strength)\n    else:\n        # Sharper curve for values > 1.0\n        return 1.0 - ((1.0 - value) ** strength)\n\n###\n### SECTION 4: UTILITY FUNCTIONS\n###\ndef normalize_value(value, min_val, max_val):\n    \"\"\"\n    Normalize a value to the range 0.0-1.0 based on min and max values\n    \"\"\"\n    range_val = max_val - min_val\n    epsilon = 1e-10\n    if range_val < epsilon: \n        return 0.0\n    clamped_value = max(min_val, min(max_val, value))\n    normalized = (clamped_value - min_val) / range_val\n    return normalized\n\ndef map_value(value, in_min, in_max, out_min, out_max):\n    \"\"\"\n    Map a value from one range to another\n    \"\"\"\n    # Normalize to 0-1 then scale to output range\n    normalized = normalize_value(value, in_min, in_max)\n    return out_min + normalized * (out_max - out_min)\n\n###\n###    SECTION 5: GEOMETRIC HELPER FUNCTIONS\n###\n\ndef angle_between_vectors(vec1, vec2):\n    \"\"\"\n    Calculate the angle in degrees between two vectors\n    \"\"\"\n    # Ensure vectors are unitized\n    if not vec1.IsUnitVector: vec1.Unitize()\n    if not vec2.IsUnitVector: vec2.Unitize()\n    \n    # Calculate dot product and clamp to valid range\n    dot = max(-1.0, min(1.0, vec1 * vec2))\n    \n    # Convert to degrees\n    angle_rad = math.acos(dot)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg\n\ndef get_tangent(curve, t):\n    \"\"\"\n    Helper function to get tangent with proper error handling\n    Returns a unitized tangent vector\n    \"\"\"\n    result = curve.TangentAt(t)\n    \n    # Handle both return types (tuple or vector)\n    if isinstance(result, tuple):\n        success, tangent = result\n        if not success or tangent is None:\n            tangent = rg.Vector3d.ZAxis\n    else:\n        tangent = result\n        if tangent is None or tangent.IsZero:\n            tangent = rg.Vector3d.ZAxis\n    \n    # Ensure the vector is unitized\n    if not tangent.IsUnitVector:\n        tangent.Unitize()\n        \n    return tangent\n\n###\n###    SECTION 6: CURVE PARAMETER GENERATION FUNCTIONS\n###\n\ndef generate_constant_spacing_parameters(curve, spacing):\n    \"\"\"\n    Generate parameters along the curve with constant spacing\n    Parameters:\n        curve: The curve to analyze\n        spacing: The desired spacing between comb lines\n    Returns:\n        A list of parameters along the curve\n    \"\"\"\n    parameters = []\n    \n    # Get curve domain and length\n    domain = curve.Domain\n    curve_length = curve.GetLength()\n    \n    # Safety checks\n    if curve_length < 0.001:\n        return [domain.Mid]\n    \n    # Ensure spacing is valid\n    spacing = max(0.0001, spacing)\n    \n    # Calculate number of divisions\n    num_divisions = max(2, int(curve_length / spacing) + 1)\n    \n    # Create evenly spaced parameters\n    for i in range(num_divisions):\n        t = float(i) / (num_divisions - 1)\n        # Use normalized length for uniform spacing\n        success, param = curve.NormalizedLengthParameter(t)\n        if not success:\n            # Fall back to linear interpolation\n            param = domain.Min + t * domain.Length\n        parameters.append(param)\n    \n    # Make sure we have the end point\n    if parameters[-1] < domain.Max * 0.999:\n        parameters.append(domain.Max)\n    \n    return parameters\n\n### --------------------------------------------------------------\n###   SECTION 7: CURVATURE-BASED PARAMETER GENERATION (MODIFIED)\n### --------------------------------------------------------------\n\ndef generate_curvature_based_parameters(curve, scan_resolution, min_spacing_factor, max_spacing_factor, \n                                        comb_bias=0.5, exaggeration_factor=0.0):\n    \"\"\"\n    Generate parameters along the curve based on curvature radius - MODIFIED\n    Parameters:\n        curve: The curve to analyze\n        scan_resolution: Resolution for initial curve scanning\n        min_spacing_factor: Factor for minimum spacing (percentage of curvature radius)\n        max_spacing_factor: Factor for maximum spacing (percentage of curvature radius)\n        comb_bias: Midpoint of the S-curve transition (0.1-0.9)\n        exaggeration_factor: Factor to enhance curvature contrast (0.0-1.0)\n    Returns:\n        A list of parameters along the curve\n    \"\"\"\n    parameters = []\n    \n    # Get curve domain and length\n    domain = curve.Domain\n    curve_length = curve.GetLength()\n    \n    # Safety checks\n    if curve_length < 0.001:\n        return [domain.Mid]\n    \n    # Ensure inputs are valid\n    scan_resolution = max(0.0001, min(0.1, scan_resolution))\n    min_spacing_factor = max(0.001, min_spacing_factor)  \n    max_spacing_factor = max(min_spacing_factor * 1.1, max_spacing_factor)\n    comb_bias = max(0.1, min(0.9, comb_bias))  # Ensure comb_bias is within valid range\n    exaggeration_factor = max(0.0, min(1.0, exaggeration_factor))\n    \n    # Step 1: Scan the curve at an adaptive resolution to find min/max curvature\n    # PERFORMANCE: Adjust the scan step based on curve length\n    num_samples = max(20, min(200, int(curve_length / scan_resolution)))\n    \n    # PERFORMANCE: Pre-allocate arrays\n    scan_params = [0.0] * num_samples\n    radii = [float('inf')] * num_samples\n    \n    # Generate evenly spaced normalized parameters (faster than loop)\n    for i in range(num_samples):\n        t = float(i) / max(1, num_samples - 1)\n        # Convert to curve parameter\n        success, param = curve.NormalizedLengthParameter(t)\n        if not success:\n            param = domain.Min + t * domain.Length\n        scan_params[i] = param\n    \n    # Evaluate curvature at each parameter\n    epsilon = 1e-10\n    \n    # PERFORMANCE: Find min/max radius in a single pass\n    min_radius = float('inf')\n    max_radius = 0.0\n    \n    for i, t in enumerate(scan_params):\n        # Get curvature (optimized)\n        result = curve.CurvatureAt(t)\n        cv = None\n        mag = 0.0\n        \n        if isinstance(result, tuple):\n            success, cv = result\n            if success and cv is not None and cv.IsValid:\n                mag = cv.Length\n        else:\n            cv = result\n            if cv is not None and cv.IsValid:\n                mag = cv.Length\n        \n        # Calculate radius\n        if mag > epsilon:\n            radius = 1.0 / mag\n            radii[i] = radius\n            # Update min/max in a single pass\n            if radius < min_radius:\n                min_radius = radius\n            if radius > max_radius and radius < 1e6:  # Ignore extreme values\n                max_radius = radius\n    \n    # Filter out infinite values and find actual min/max\n    finite_radii = [r for r in radii if r < 1e6 and r > epsilon]\n    if not finite_radii:\n        # Fallback if no finite radii found\n        print(\"WARNING: No finite curvature radii found, using constant spacing\")\n        return generate_constant_spacing_parameters(curve, min_spacing_factor)\n    \n    # PERFORMANCE: Use the pre-calculated min/max\n    if min_radius == float('inf') or max_radius == 0.0:\n        # Re-calculate in case the single-pass logic failed\n        finite_radii.sort()\n        min_radius = finite_radii[0]\n        max_radius = finite_radii[-1]\n    \n    print(\"DEBUG: Min radius found:\", min_radius)\n    print(\"DEBUG: Max radius found:\", max_radius)\n    \n    # Step 2: Begin at start of curve\n    current_param = domain.Min\n    parameters.append(current_param)\n    \n    # Get initial point\n    current_point = curve.PointAt(current_param)\n    last_placed_point = current_point\n    last_placed_param = current_param\n    \n    # Step 3: Walk along curve placing comb lines based on curvature radius\n    # Use a much finer step size for walking the curve to ensure proper spacing\n    # This is critical for proper spacing in high curvature regions\n    adaptive_steps = max(100, min(1000, int(curve_length / (min_spacing_factor * 0.25))))\n    \n    # PERFORMANCE: Pre-calculate log values for mapping\n    log_min = math.log(max(epsilon, min_radius))\n    log_max = math.log(max(log_min + epsilon, max_radius))\n    log_range = log_max - log_min\n    \n    # More fine-grained approach - use direct parameter stepping\n    # This approach ensures that we don't miss any significant curvature changes\n    step_size = domain.Length / adaptive_steps\n    \n    # For tracking which distances we've already placed\n    # Step through curve with small steps\n    param = domain.Min  # Start at beginning\n    \n    while param <= domain.Max:\n        # Get current point\n        current_point = curve.PointAt(param)\n        \n        # Calculate distance from last placed point\n        distance_moved = current_point.DistanceTo(last_placed_point)\n        \n        # Get current curvature\n        result = curve.CurvatureAt(param)\n        cv = None\n        mag = 0.0\n        \n        if isinstance(result, tuple):\n            success, cv = result\n            if success and cv is not None and cv.IsValid:\n                mag = cv.Length\n        else:\n            cv = result\n            if cv is not None and cv.IsValid:\n                mag = cv.Length\n        \n        # Calculate radius (with safety check)\n        current_radius = float('inf')\n        if mag > epsilon:\n            current_radius = 1.0 / mag\n        \n        # Calculate desired spacing at this point based on radius percentage\n        # MODIFIED: Calculate spacing as percentage of current radius\n        if current_radius < float('inf'):\n            min_spacing = min_spacing_factor * current_radius  # e.g., 0.005 * 60mm = 0.3mm\n            max_spacing = max_spacing_factor * current_radius  # e.g., 0.05 * 215mm = 10.75mm\n            \n            # Calculate normalized position for S-curve based on log-scaled radius\n            if log_range > epsilon:\n                log_current = math.log(max(epsilon, current_radius))\n                # Normalize between 0-1 with 0 = tight curve, 1 = flat curve\n                normalized_radius = (log_current - log_min) / log_range\n                \n                # Apply S-curve with comb_bias as midpoint (where output = 0.5)\n                # MODIFIED: Use comb_bias to center the S-curve\n                norm_from_bias = normalized_radius - comb_bias\n                sigmoid_value = 1.0 / (1.0 + math.exp(-norm_from_bias * 10))\n                \n                # Apply easing to enhance contrast\n                if exaggeration_factor > 0:\n                    sigmoid_value = apply_easing(sigmoid_value, exaggeration_factor, \"hermite\", HermiteStrength)\n                \n                # Map to spacing range\n                desired_spacing = min_spacing + sigmoid_value * (max_spacing - min_spacing)\n            else:\n                # If range is too small, use average spacing\n                desired_spacing = (min_spacing + max_spacing) * 0.5\n        else:\n            # For infinite radius (straight line), use max spacing\n            desired_spacing = max_spacing_factor * 1000  # Arbitrary large value for straight lines\n        \n        # Place a comb line if we've moved far enough\n        if distance_moved >= desired_spacing:\n            parameters.append(param)\n            # Update reference for next evaluation\n            last_placed_point = current_point\n            last_placed_param = param\n        \n        # Fixed-size parameter step (small enough to catch tight curves)\n        param += step_size\n        \n        # Safety exit for domain end\n        if param > domain.Max and last_placed_param < domain.Max * 0.999:\n            parameters.append(domain.Max)\n            break\n    \n    # Ensure we have the end point\n    if parameters[-1] < domain.Max * 0.999:\n        parameters.append(domain.Max)\n    \n    print(f\"DEBUG: Generated {len(parameters)} parameters based on curvature radius\")\n    \n    # Debug: Check min actual spacing\n    if len(parameters) >= 2:\n        min_actual_spacing = float('inf')\n        prev_pt = curve.PointAt(parameters[0])\n        \n        for i in range(1, len(parameters)):\n            curr_pt = curve.PointAt(parameters[i])\n            spacing = curr_pt.DistanceTo(prev_pt)\n            if spacing < min_actual_spacing:\n                min_actual_spacing = spacing\n            prev_pt = curr_pt\n            \n        print(f\"DEBUG: Minimum actual spacing achieved: {min_actual_spacing:.6f}\")\n    \n    return parameters\n\n###\n###   SECTION 8: COLOR GENERATION FUNCTIONS\n###\n\ndef generate_sampled_radii_colors(radii_list, min_radius, max_radius, palette, invert=False):\n    \"\"\"\n    Generate colors for the sampled radii points based on the palette\n    \n    Parameters:\n        radii_list: List of radii values\n        min_radius: Minimum radius value\n        max_radius: Maximum radius value\n        palette: Color palette to use\n        invert: Whether to invert the mapping (radius to color)\n    \n    Returns:\n        colors: List of colors for each radius value\n    \"\"\"\n    if not radii_list or not palette:\n        return []\n    \n    colors = []\n    epsilon = 1e-10\n    num_colors = len(palette)\n    \n    # Ensure valid min/max radii\n    if min_radius <= epsilon or max_radius <= epsilon or max_radius <= min_radius:\n        min_infinite = True\n        for r in radii_list:\n            if r < float('inf') and r > epsilon:\n                if min_infinite or r < min_radius:\n                    min_radius = r\n                    min_infinite = False\n                if r > max_radius:\n                    max_radius = r\n    \n    # Generate a color for each radius\n    for radius in radii_list:\n        if radius <= epsilon or radius >= float('inf'):\n            # Zero or infinite radius - use first or last color\n            color_index = 0 if invert else num_colors - 1\n        else:\n            # Normalize radius between min and max radius (logarithmic)\n            log_min = math.log(max(epsilon, min_radius))\n            log_max = math.log(max(log_min + epsilon, max_radius))\n            log_radius = math.log(max(epsilon, radius))\n            \n            norm_radius = (log_radius - log_min) / (log_max - log_min)\n            norm_radius = max(0.0, min(1.0, norm_radius))\n            \n            if invert:\n                norm_radius = 1.0 - norm_radius\n            \n            # Map to color index\n            color_idx_float = norm_radius * (num_colors - 1)\n            color_index = int(round(color_idx_float))\n            color_index = max(0, min(num_colors - 1, color_index))\n        \n        colors.append(palette[color_index])\n    \n    return colors\n\n### --------------------------------------------------------------\n###    SECTION 9: BOUNDARY LINE GENERATION (MODIFIED)\n### --------------------------------------------------------------\n\ndef generate_smooth_boundary_lines(curve, end_points, boundary_line_sample, palette=None, use_palette=False, \n                                  curvature_mag_list=None, min_mag=0.0, max_mag=1.0, \n                                  min_length=10.0, max_length=50.0, added_length=10.0, \n                                  invert_length=False, exaggeration=0.0):\n    \"\"\"\n    Generate smooth boundary lines by sampling the original curve at a constant increment\n    and applying the same length calculation as the comb lines.\n    \"\"\"\n    print(\"DEBUG: Values used for boundary line:\")\n    print(f\"       min_length = {min_length}\")\n    print(f\"       max_length = {max_length}\")\n    print(f\"       added_length = {added_length}\")\n    print(f\"       invert_length = {invert_length}\")\n    print(f\"       exaggeration = {exaggeration}\")\n    print(f\"       boundary_line_sample = {boundary_line_sample}\")\n    \n    if not curve or not curve.IsValid:\n        return [], []\n    \n    # Initialize output lists\n    boundary_lines = []\n    boundary_colors = []\n    \n    # Sample the curve at a finer resolution for smooth boundary, now using BoundaryLineSample\n    boundary_params = generate_constant_spacing_parameters(curve, boundary_line_sample)\n    \n    # Rest of the function remains the same...\n    # ... (existing code for boundary line generation)\n    \n    # Calculate boundary points\n    boundary_points = []\n    boundary_mags = []\n    epsilon = 1e-10\n    \n    for t in boundary_params:\n        # Get curve point and curvature\n        pt = curve.PointAt(t)\n        \n        # Get curvature - handle both return patterns\n        result = curve.CurvatureAt(t)\n        if isinstance(result, tuple):\n            success, cv = result\n            if not success or cv is None or not cv.IsValid:\n                cv = rg.Vector3d.Zero\n                mag = 0.0\n            else:\n                mag = cv.Length\n        else:\n            cv = result\n            if cv is None or not cv.IsValid:\n                cv = rg.Vector3d.Zero\n                mag = 0.0\n            else:\n                mag = cv.Length\n        \n        # Handle NaN or Inf values\n        if math.isnan(mag) or math.isinf(mag):\n            mag = 0.0\n            cv = rg.Vector3d.Zero\n            \n        # Save magnitude for coloring\n        boundary_mags.append(mag)\n        \n        # Calculate Line Length using same logic as comb lines\n        normalized_mag = normalize_value(mag, min_mag, max_mag)\n        \n        # Apply hermite easing with the HermiteStrength parameter\n        exaggerated_norm_mag = apply_easing(normalized_mag, exaggeration, \"hermite\", HermiteStrength)\n        \n        if invert_length:\n            # For inverted length, high curvature = shorter lines\n            exaggerated_norm_mag = 1.0 - exaggerated_norm_mag\n        \n        # Map the normalized exaggerated value to the min-max length range\n        calculated_length = map_value(exaggerated_norm_mag, 0.0, 1.0, min_length, max_length)\n        \n        # Apply the additional length\n        current_length = calculated_length + added_length\n        \n        # Calculate boundary point position\n        scaled_vector = rg.Vector3d.Zero\n        direction_vector = rg.Vector3d.Zero\n        \n        if mag > epsilon and cv is not None and not cv.IsZero and cv.IsValid:\n            temp_dir = rg.Vector3d(cv)\n            if temp_dir.Unitize():\n                direction_vector = temp_dir\n                scaled_vector = direction_vector * current_length  # Use final adjusted length\n        \n        # Offset point from curve along curvature vector\n        boundary_pt = pt - scaled_vector\n        boundary_points.append(boundary_pt)\n    \n    # Create line segments between boundary points\n    if len(boundary_points) >= 2:\n        for i in range(len(boundary_points) - 1):\n            pt1 = boundary_points[i]\n            pt2 = boundary_points[i+1]\n            \n            line = rg.Line(pt1, pt2)\n            boundary_lines.append(line)\n            \n            # Determine color if palette is provided\n            if use_palette and palette:\n                # For color, use the magnitude at this point\n                mag = boundary_mags[i]\n                \n                # Normalize and get color index\n                norm_mag = normalize_value(mag, min_mag, max_mag)\n                color_idx_float = norm_mag * (len(palette) - 1)\n                color_index = int(round(color_idx_float))\n                color_index = max(0, min(len(palette) - 1, color_index))\n                \n                boundary_colors.append(palette[color_index])\n    \n    print(f\"DEBUG: Generated {len(boundary_lines)} boundary line segments\")\n    return boundary_lines, boundary_colors\n\n### --------------------------------------------------------------\n###   SECTION 10: INPUT PARAMETER HANDLING\n### --------------------------------------------------------------\n\n# --- Main Script ---\n\n# --- Define Expected Inputs ---\n# Start performance timing\nstart_time = time.time()\n\n# Initialize error message list\nerror_messages = []\n\n# Add new input for CombBias\ntry:\n    CombBias = float(CombBias) if 'CombBias' in globals() else 0.5\n    CombBias = max(0.1, min(0.9, CombBias))  # Clamp to valid range\nexcept (ValueError, TypeError):\n    print(\"ERROR: CombBias could not be converted to float, using default 0.5\")\n    CombBias = 0.5\n\n# Debug printing\nprint(\"DEBUG: CombBias value =\", CombBias)\n\n# Validate CombBias parameter\nif CombBias is None or CombBias < 0.1 or CombBias > 0.9:\n    error_messages.append(\"'CombBias' must be between 0.1 and 0.9. Using clamped value.\")\n    if CombBias is not None:\n        CombBias = max(0.1, min(0.9, CombBias))\n    else:\n        CombBias = 0.5\n\n# Add new input for BoundaryLineSample\ntry:\n    BoundaryLineSample = float(BoundaryLineSample) if 'BoundaryLineSample' in globals() else 2.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: BoundaryLineSample could not be converted to float, using default 2.0\")\n    BoundaryLineSample = 2.0\n\n# Debug printing for new parameter\nprint(\"DEBUG: BoundaryLineSample value =\", BoundaryLineSample)\n\n# Validate BoundaryLineSample parameter in validation section\nif BoundaryLineSample is None or BoundaryLineSample <= 0:\n    error_messages.append(\"'BoundaryLineSample' must be > 0. Using default value of 2.0.\")\n    BoundaryLineSample = 2.0\n\n# Add new input for Hermite strength\ntry:\n    HermiteStrength = float(HermiteStrength) if 'HermiteStrength' in globals() else 1.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: HermiteStrength could not be converted to float, using default 1.0\")\n    HermiteStrength = 1.0\n\n# Validate HermiteStrength parameter\nif HermiteStrength is None or HermiteStrength <= 0.0:\n    error_messages.append(\"'HermiteStrength' must be > 0. Using default value of 1.0.\")\n    HermiteStrength = 1.0\n\n# Add new input for ScanResolution\ntry:\n    ScanResolution = float(ScanResolution) if 'ScanResolution' in globals() else 0.25\nexcept (ValueError, TypeError):\n    print(\"ERROR: ScanResolution could not be converted to float, using default 0.25\")\n    ScanResolution = 0.25\n\n# Add new input for minimum and maximum length\ntry:\n    MinLength = float(MinLength) if 'MinLength' in globals() else 10.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: MinLength could not be converted to float, using default 10.0\")\n    MinLength = 10.0\n\ntry:\n    MaxLength = float(MaxLength) if 'MaxLength' in globals() else 50.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: MaxLength could not be converted to float, using default 50.0\")\n    MaxLength = 50.0\n    \n# Add new input for exaggeration factor (0.0 = linear, 1.0 = exponential)\ntry:\n    Exaggeration = float(Exaggeration) if 'Exaggeration' in globals() else 0.0\n    Exaggeration = max(0.0, min(1.0, Exaggeration))\nexcept (ValueError, TypeError):\n    print(\"ERROR: Exaggeration could not be converted to float, using default 0.0 (linear)\")\n    Exaggeration = 0.0\n    \n# Add new input for proportional spacing toggle\ntry:\n    UseProportionalSpacing = bool(UseProportionalSpacing) if 'UseProportionalSpacing' in globals() else True\nexcept (ValueError, TypeError):\n    print(\"ERROR: UseProportionalSpacing could not be converted to boolean, using default True\")\n    UseProportionalSpacing = True\n    \n# The constant value added to line lengths\ntry:\n    AddedLength = float(AddedLength) if 'AddedLength' in globals() else 10.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: AddedLength could not be converted to float, using default 10.0\")\n    AddedLength = 10.0\n\n# Add new input for marker points matching toggle\ntry:\n    # Boolean to toggle whether marker points match comb line positions\n    MarkerPointsMatch = bool(MarkerPointsMatch) if 'MarkerPointsMatch' in globals() else False\nexcept (ValueError, TypeError):\n    print(\"ERROR: MarkerPointsMatch could not be converted to boolean, using default False\")\n    MarkerPointsMatch = False\n\ntry:\n    MaxSpacing = float(MaxSpacing) if 'MaxSpacing' in globals() else 20.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: MaxSpacing could not be converted to float, using default 20.0\")\n    MaxSpacing = 20.0\n\ntry:\n    MinSpacing = float(MinSpacing) if 'MinSpacing' in globals() else 2.0\nexcept (ValueError, TypeError):\n    print(\"ERROR: MinSpacing could not be converted to float, using default 2.0\")\n    MinSpacing = 2.0\n\n###\n### SECTION 11: DEBUG OUTPUT AND INITIALIZATION\n###\n\n# Debug printing\nprint(\"DEBUG: ScanResolution value =\", ScanResolution)\nprint(\"DEBUG: MinLength value =\", MinLength)\nprint(\"DEBUG: MaxLength value =\", MaxLength)\nprint(\"DEBUG: Exaggeration value =\", Exaggeration)\nprint(\"DEBUG: AddedLength value =\", AddedLength)\nprint(\"DEBUG: MinSpacing value =\", MinSpacing)\nprint(\"DEBUG: MaxSpacing value =\", MaxSpacing)\nprint(\"DEBUG: UseProportionalSpacing =\", UseProportionalSpacing)\nprint(\"DEBUG: MarkerPointsMatch =\", MarkerPointsMatch)\nprint(\"DEBUG: HermiteStrength value =\", HermiteStrength)\n\n# --- Initialize Output Variables ---\nLines = []; Colors = []; BoundaryLines = []; BoundaryColors = []\nMinRadiusOutput = None; MaxRadiusOutput = None; SampledRadii = []; SampledMarkerPoints = []\nCalculatedLengths = []; SampledRadiiColors = []  # Added SampledRadiiColors output",
      "language": "python",
      "author": "nxakt",
      "post_number": 6,
      "is_solution": false
    }
  ],
  "tags": [
    "boolean",
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 2,
  "posts_count": 7,
  "views": 308
}