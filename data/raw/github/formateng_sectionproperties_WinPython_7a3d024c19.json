{
  "source_url": "https://github.com/formateng/sectionproperties_WinPython/blob/b599caae6cd0e9a08fc3fb5e6b99242ef9eae2b6/app_local.py",
  "repo": "formateng/sectionproperties_WinPython",
  "repo_stars": 1,
  "repo_description": "Using WinPython to run the python module SectionProperties from Grasshopper",
  "license": "MIT",
  "filepath": "app_local.py",
  "instruction": "from __future__ import print_function",
  "code": "#from __future__ import print_function\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\nimport rhino3dm as rhino\nimport sectionproperties.pre.sections as sections\nfrom sectionproperties.analysis.cross_section import CrossSection\nimport sectionproperties.post.post as post\nimport uuid\nimport io\nimport base64\nimport sys\nimport json\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\ndef parse_polyline(polyline, start_idx):\n    points = []\n    for i in range(polyline.PointCount - 1):\n        points.append([polyline.Point(i).X, polyline.Point(i).Y])\n\n    facets = []\n    for i in range(polyline.PointCount - 2):\n        facets.append([i + start_idx, i + start_idx + 1])\n    facets.append([polyline.PointCount + start_idx - 2, start_idx])\n\n    return points, facets\n\ndef rhino_mesh_from_meshpy(mesh):\n    \n    rmesh = rhino.Mesh()\n    for p in mesh.points:\n        rmesh.Vertices.Add(p[0], p[1], 0.0)\n    for e in mesh.elements:\n        rmesh.Faces.AddFace(e[0], e[1], e[2])\n\n    return rmesh\n\ndef parse_input(data):\n    eprint(\"start parsing input data\")\n    perimeter_polyline = rhino.CommonObject.Decode(data['perimeter'])\n\n    points = []\n    facets = []\n\n    # perimeter\n    pts, fs = parse_polyline(perimeter_polyline, 0)\n    points.extend(pts)\n    facets.extend(fs)\n\n    perimeter = [i for i in range(len(fs))]\n\n    # holes\n    holes = []\n    if 'holes' in data and 'hole_points' in data:\n        hole_polylines = [rhino.CommonObject.Decode(d) for d in data['holes']]\n        for h in hole_polylines:\n            pts, fs = parse_polyline(h, len(points))\n            points.extend(pts)\n            facets.extend(fs)\n\n        for p in data['hole_points']:\n            holes.append([p['X'], p['Y']])\n\n    # control_points\n    control_points = []\n    for p in data['control_points']:\n        control_points.append([p['X'], p['Y']])\n\n    # loads to check\n    loadcases = []\n    if 'loadcases' in data:\n        for load in data['loadcases']:\n            loadcase = []\n            loadcase.append(load['LC'])\n            loadcase.append(load['N'])\n            loadcase.append(load['Vx'])\n            loadcase.append(load['Vy'])\n            loadcase.append(load['Mxx'])\n            loadcase.append(load['Myy'])\n            loadcase.append(load['Mzz'])\n            loadcases.append(loadcase)\n\n    # eprint(loadcases)\n\n    # imagesToSend - list of images we want back again\n\n    # resultsToSend - list of result sets we want back again\n    \n    # custom material - also check what is the default for clarity!\n    # note the following is in cm\n    \n    # meshsize\n    mesh_size = 2.0\n    if 'mesh_size' in data:\n        mesh_size = data['mesh_size']\n\n    return points, facets, holes, control_points, perimeter, mesh_size, loadcases\n\ndef process_geometry(geometry, mesh_sizes, loadcases):\n    # update this to receive the geometry, mesh info, material and loads\n    \n    # generate a finite element mesh\n    mesh = geometry.create_mesh(mesh_sizes=mesh_sizes)\n\n    # generate material - can be overwritten if needed --all in N and cm\n\n    # create a CrossSection object for analysis\n    section = CrossSection(geometry, mesh)\n\n    # calculate various cross-section properties\n    section.calculate_geometric_properties()\n    section.calculate_warping_properties()\n    section.calculate_plastic_properties()\n\n    # Area\n    area = section.get_area()\n    sheararea = section.get_As()\n    asx = sheararea[0]\n    asy = sheararea[1]\n    \n    # Second Moment of Area about centroid\n    (ixx,iyy,ixy) = section.get_ic()\n\n    # Centroid\n    (xg,yg) = section.get_c()\n\n    # Radii of Gyration\n    (rxx,ryy) = section.get_rc()\n\n    # Principal bending axis angle\n    phi = section.get_phi()\n    # St. Venant torsion constant\n    ipp = section.get_j()\n    # Warping Constant\n    cw = section.get_gamma()\n\n    # Elastic Section Moduli\n    (welx_top,welx_bottom,wely_top,wely_bottom) = section.get_z()\n\n    # Plastic Section Moduli\n    (wplx,wply) = section.get_s()\n\n    # plot centroid to image\n    section.plot_centroids(pause=False)\n    buf = io.BytesIO()\n    plt.savefig(buf, format='png',bbox_inches='tight')\n    buf.seek(0)\n    plot_centroid = base64.b64encode(buf.getvalue()).decode()\n    plt.close()\n\n    # calculate torsion resistance from stress and torque\n    #from the below can also return torsional stress if wanted\n    stress_post = section.calculate_stress(Mzz=10)\n    unit_mzz_zxy = []\n    maxstress = []\n    for group in stress_post.material_groups:\n        maxstress.append(max(group.stress_result.sig_zxy_mzz))\n        unit_mzz_zxy.append(group.stress_result.sig_zxy_mzz.tolist())\n    #there should be only one maxstress value therefore:\n    wt = 10/maxstress[0]\n\n    #plot this image\n    stress_post.plot_stress_mzz_zxy(pause=False)\n    buf = io.BytesIO()\n    plt.savefig(buf, format='png',bbox_inches='tight')\n    buf.seek(0)\n    plot_unittorsionstress = base64.b64encode(buf.getvalue()).decode()\n    plt.close()\n\n    #foreach load case submitted calculate vm stress state and create image\n\n    vmStressImages = {}\n    vmStressStates = {}\n    for loadcase in loadcases:\n        lc_name = loadcase[0]\n        s_n = loadcase[1]\n        s_vx = loadcase[2]\n        s_vy = loadcase[3]\n        s_mxx = loadcase[4]\n        s_myy = loadcase[5]\n        s_mzz = loadcase[6]\n        stress_post = section.calculate_stress(N=s_n,Vx=s_vx,Vy=s_vy,Mxx=s_mxx,Myy=s_myy,Mzz=s_mzz)\n        stress_state = []\n        for group in stress_post.material_groups:\n            stress_state.append(group.stress_result.sig_vm.tolist())\n        vmStressStates['lc_'+str(lc_name)+'_vm_stress'] = stress_state\n        #plot this image\n        stress_post.plot_stress_vm(pause=False)\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png',bbox_inches='tight')\n        buf.seek(0)\n        vmStressImages['lc_'+str(lc_name)+'_vm_stress'] = base64.b64encode(buf.getvalue()).decode()\n        plt.close()\n\n    # create rhino mesh\n    rmesh = rhino_mesh_from_meshpy(mesh)\n\n    # return send_file(path, as_attachment=True)\n\n    # get some of the calculated section properties\n    return_data = {}\n    return_data['properties'] = {\n        'area': area,\n        'Avx': asx,\n        'Avy':asy,\n        'xg': xg,\n        'yg': yg,\n        'rxx': rxx,\n        'ryy': ryy,\n        'phi': phi,\n        'ixx': ixx,\n        'iyy': iyy,\n        'ipp':ipp,\n        'cw':cw,\n        'welx+': welx_top,\n        'welx-': welx_bottom,\n        'wely+': wely_top,\n        'wely-': wely_bottom,\n        'wplx': wplx,\n        'wply': wply,\n        'wt':wt,\n    }\n    return_data['geometry'] = {\n        'mesh': rhino.CommonObject.Encode(rmesh),\n    }\n    return_data['images'] = {\n        'centroids': plot_centroid,\n        'unittorsion_vxy_stress': plot_unittorsionstress,\n    }\n    return_data['images'].update(vmStressImages)\n    return_data['stress_results'] = {\n        'unittorsion_vxy_stress': unit_mzz_zxy,\n    }\n    return_data['stress_results'].update(vmStressStates)\n\n    return return_data\n\n#main part of the file starts here:\nfilename = sys.argv[1]\neprint(\"start working on the file:\"+ filename) \n\nwith open(filename) as f:\n    lines = f.readlines()\n    data = eval(lines[0].strip())\n\npoints, facets, holes, control_points, perimeter, mesh_size, loadcases = parse_input(data)\nmesh_sizes = [mesh_size]\n\ngeometry = sections.CustomSection(points, facets, holes, control_points)\ngeometry.clean_geometry()\n\ndata = process_geometry(geometry,mesh_sizes,loadcases)\n\njson_result = json.dumps(data)\nprint(json_result)\neprint('done')",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}