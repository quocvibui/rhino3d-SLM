{
  "source_url": "https://discourse.mcneel.com/t/isovist-optimization/103024",
  "topic_id": 103024,
  "title": "Isovist optimization",
  "question": "Hello guys,\n\n\nSo I’m making this project where I needed to recreate \nisovist\n code. I managed to recreate a code where every rectangle determines if it’s seeing the outer rectangle or not (for architectural purposes hehe).\n\n\nmanual_screen_095721_as\n1264×790 144 KB\n\n\nMy issues is the that the code takes about 30ms and I am using it in an optimization. it would help a lot if anyone can tell me a \nfaster\n way to get the same results.\n\n\nhere is my code:\n\n\nprivate void RunScript(List<Polyline> spaces, Polyline boundary, int nOfRays, double rad, List<string> spaceStrings, string desiredView, string streetView, ref object IsoVist)\n  {\n    var crvTree = new DataTree<Polyline>();\n    //add boundary to test\n    var obstacleCrvs = new List<Polyline>();\n    obstacleCrvs.AddRange(spaces);\n    obstacleCrvs.Add(boundary);\n\n    //isovist params\n    var centers = spaces.Select(x => x.CenterPoint());\n    var angle = (Math.PI * 2) / nOfRays;\n    var isoVist = new DataTree<Point3d>();\n\n\n    //socring params\n    var resultantView = false;\n    var scores = new List<int>();\n    int totalScore = 0;\n\n\n    //duplicating tree while removing test point\n    for (int i = 0; i < obstacleCrvs.Count - 1 ; i++)\n    {\n      var newCrvs = new List<Polyline>();\n      newCrvs.AddRange(obstacleCrvs);\n\n      newCrvs.RemoveAt(i);\n      crvTree.AddRange(newCrvs, new GH_Path(i));\n    }\n    //-----------------\n    //creating isovist\n    //-----------------\n    var xVector = new Vector3d(1, 0, 0);\n    //    var origin = new Point3d(0, 0, 0);\n\n    var rotatedVectors = new List<Vector3d>();\n    var lines = new List<Line>();\n\n    int m = 0;\n    foreach(Point3d center in centers)\n    {\n      for(int i = 0;i < nOfRays;i++)\n      {\n        xVector.Rotate((Math.PI * 2) / nOfRays, new Vector3d(0, 0, 1));\n        rotatedVectors.Add(xVector);\n        lines.Add(new Line(center, xVector, rad));\n      }\n      //    }\n      //intersect rays with curves\n      Rhino.Geometry.Intersect.CurveIntersections curveLinIntersects = n...",
  "code_blocks": [
    {
      "code": "//duplicating tree while removing test point\nLine[][][] crvarr = new Line[obstacleCrvs.Count - 1][][];\n\nfor (int i = 0; i < obstacleCrvs.Count - 1 ; i++)\n{\n  var newCrvs = new List<Polyline>(obstacleCrvs.Count);\n  newCrvs.AddRange(obstacleCrvs);\n\n  newCrvs.RemoveAt(i);\n  var polylineArr = new Line[newCrvs.Count][];\n\n  for(int j = 0; j < newCrvs.Count ; j++)\n    polylineArr[j] = newCrvs[j].GetSegments();\n\n  crvarr[i] = polylineArr;\n}\n//-----------------\n//creating isovist\n//-----------------\nvar centers = spaces.Select(x => x.CenterPoint()).ToList();\nvar angle = (Math.PI * 2) / nOfRays;\nPoint3d[][] isoVistArr = new Point3d[centers.Count][];\nvar xVector = new Vector3d(1, 0, 0);\nvar rotatedVectors = new List<Vector3d>();\n//creating lines for each center\nvar lineTree = new DataTree<Line>();\nvar lineArr = new Line[centers.Count][];\nfor(int u = 0; u < centers.Count;u++)\n{\n  var lines = new Line[nOfRays];\n  for(int i = 0;i < nOfRays;i++)\n  {\n    xVector.Rotate((Math.PI * 2) / nOfRays, new Vector3d(0, 0, 1));\n    rotatedVectors.Add(xVector);\n    var line = new Line(centers[u], xVector, rad);\n    lineTree.Add(line, new GH_Path(u));\n    lines[i] = line;\n  }\n  lineArr[u] = lines;\n}\n//intersect rays with curves\nfor(int u = 0; u < centers.Count;u++)\n{\n  Point3d[] isoVistArrBranch = new Point3d[nOfRays];\n  for(int i = 0;i < nOfRays;i++)\n  {\n    var orderPoints = new List<Point3d>();\n    for(int j = 0; j < crvarr[u].Length ;j++)\n    {\n      for(int k = 0; k < crvarr[u][j].Length ;k++)\n      {\n        double a;\n        double b;\n        bool curveLinIntersects =\n          Rhino.Geometry.Intersect.Intersection.LineLine(crvarr[u][j][k], lineArr[u][i],\n          out a, out b, RhinoDocument.ModelAbsoluteTolerance, true);\n        if(curveLinIntersects)\n          orderPoints.Add(crvarr[u][j][k].PointAt(a));\n      }\n    }\n    Print(orderPoints.Count.ToString());\n    //        var ptToAdd = orderPoints.OrderBy(x => x.DistanceTo(centers[u])).FirstOrDefault();\n    var ptToAdd = Rhino.Collections.Point3dList.ClosestPointInList(orderPoints, centers[u]);\n    isoVistArrBranch[i] = ptToAdd;\n  }\n  isoVistArr[u] = isoVistArrBranch;\n}\n//display isovist\nvar isoVist = new DataTree<Point3d>();\nfor (int i = 0; i < isoVistArr.Length; i++)\n  isoVist.AddRange(isoVistArr[i], new GH_Path(i));\n//    //display crvTree\nvar crvTree = new DataTree<Line>();\nfor (int i = 0; i < crvarr.Length; i++)\n{\n  for (int j = 0; j < crvarr.Length; j++)\n  {\n    crvTree.AddRange(crvarr[i][j], new GH_Path(i, j));\n  }\n}\n//\nCrvTree = crvTree;\nIsoVist = isoVist;",
      "language": "unknown",
      "author": "y.aboualghar",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "private void RunScript(List<Polyline> spaces, Polyline boundary, int nOfRays, double rad, List<string> spaceStrings, string desiredView, string streetView, ref object IsoVist)\n  {\n    var crvTree = new DataTree<Polyline>();\n    //add boundary to test\n    var obstacleCrvs = new List<Polyline>();\n    obstacleCrvs.AddRange(spaces);\n    obstacleCrvs.Add(boundary);\n\n    //isovist params\n    var centers = spaces.Select(x => x.CenterPoint());\n    var angle = (Math.PI * 2) / nOfRays;\n    var isoVist = new DataTree<Point3d>();\n\n\n    //socring params\n    var resultantView = false;\n    var scores = new List<int>();\n    int totalScore = 0;\n\n\n    //duplicating tree while removing test point\n    for (int i = 0; i < obstacleCrvs.Count - 1 ; i++)\n    {\n      var newCrvs = new List<Polyline>();\n      newCrvs.AddRange(obstacleCrvs);\n\n      newCrvs.RemoveAt(i);\n      crvTree.AddRange(newCrvs, new GH_Path(i));\n    }\n    //-----------------\n    //creating isovist\n    //-----------------\n    var xVector = new Vector3d(1, 0, 0);\n    //    var origin = new Point3d(0, 0, 0);\n\n    var rotatedVectors = new List<Vector3d>();\n    var lines = new List<Line>();\n\n    int m = 0;\n    foreach(Point3d center in centers)\n    {\n      for(int i = 0;i < nOfRays;i++)\n      {\n        xVector.Rotate((Math.PI * 2) / nOfRays, new Vector3d(0, 0, 1));\n        rotatedVectors.Add(xVector);\n        lines.Add(new Line(center, xVector, rad));\n      }\n      //    }\n      //intersect rays with curves\n      Rhino.Geometry.Intersect.CurveIntersections curveLinIntersects = null;\n      for(int i = 0; i < lines.Count ;i++)\n      {\n        var orderPoints = new List<Point3d>();\n\n        for(int j = 0; j < crvTree.Branch(m).Count ;j++)\n        {\n          curveLinIntersects =\n            Rhino.Geometry.Intersect.Intersection.CurveCurve(crvTree.Branch(m)[j].ToNurbsCurve(),\n            lines[i].ToNurbsCurve(),\n            RhinoDocument.ModelAbsoluteTolerance, RhinoDocument.ModelAbsoluteTolerance);\n\n          for(int k = 0; k < curveLinIntersects.Count ;k++)\n          {\n            var curveLinIntersect = curveLinIntersects[k].PointB;\n            orderPoints.Add(curveLinIntersect);\n          }\n        }\n        var ptToAdd = orderPoints.OrderBy(x => x.DistanceTo(center)).FirstOrDefault();\n        isoVist.Add(ptToAdd, new GH_Path(m));\n      }\n      m++;\n    }\n\n    IsoVist = isoVist;\n  }",
      "language": "csharp",
      "author": "y.aboualghar",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "geometry",
    "nurbs",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 8,
  "posts_count": 5,
  "views": 1641
}