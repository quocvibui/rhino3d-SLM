{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Countour%20Mesh.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Countour Mesh.py",
  "instruction": "Use this component to create contoured visualizations of any analysis mesh and corresponding numerical dataset in Ladybug + Honeybee.\nNote that this component currently only works for planar...",
  "code": "# This component re-color the mesh based on new parameters\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <Sadeghipour@gmail.com> and Chris Mackey <Chris@MackeyArchitecture.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to create contoured visualizations of any analysis mesh and corresponding numerical dataset in Ladybug + Honeybee.\nNote that this component currently only works for planar meshes.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _analysisResult: A numerical data set whose length corresponds to the number of faces in the _inputMesh.  This data will be used to generate contours from the mesh.\n        _inputMesh: An already-colored mesh from one of the Ladybug components which you would like to re-color based on data in the _analysisResult.\n        _contourType_: An integer to set the type of contour visualization.  The default is set to 0 for colored regions.  Choose from the following options:\n            0 - Colored Regions + Labeled Lines\n            1 - Colored Regions\n            2 - Labeled Lines\n            3 - Colored Lines\n        heightDomain_: Optional height domain to create a 3D mesh result. Use Construct Domain component to create a domain\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.  Legend Parameters can be used to change the colors, numerical range, and/or number of divisions of any Ladybug legend along with the corresponding colored mesh.\n        analysisTitle_: Text representing a new title for the re-colored mesh.  If no title is input here, the default will read \"unnamed.\"\n        legendTitle_: Text representing a new legend title for re-colored mesh. Legends are usually titled with the units of the _analysisResult.  If no text is provided here, the default title will read \"unkown units.\"\n        _labelSize_: A number to set the size of the text labels for the contours when _contourType_ 0 or 2 is selected.  The default is auto-calculated based on the size of the mesh.\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        layerName_: If bakeIt_ is set to \"True\", input Text here corresponding to the Rhino layer onto which the resulting mesh and legend should be baked.\n    Returns:\n        readMe!: ...\n        contourMesh: A list of colored meshes that is organized with each contour region as its own color.\n        underlayMesh: A mesh that is colored face-by-face (like a typical Ladybug mesh), which is plaed under the contour mesh to make the visualization read when the Rhino intersection fails to produce a complete contourMesh.\n        contourLines: Curves that show values of constant value along the results.\n        contourColors: Connect these to a native Grasshopper Preview componen along with the contourLines to get a colored line visualization.\n        contourLabels: A list of text meshes that show the value along each contour line.\n        legend: A new legend that that corresponds to the colors of the newMesh. Connect this output to a grasshopper \"Geo\" component in order to preview this legend separately in the Rhino scene.\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the newMesh with the grasshopper \"move\" component.\n        legendColors: A list of colors that correspond to each step in the legend.\n        intPlanes: The planes that were used to intersect the mesh to genrate the contours. Set heightDomain_ to a non-zer number to visualize.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Countour Mesh\"\nghenv.Component.NickName = 'contourMesh'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"7 | WIP\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n#compatibleLBVersion = VER 0.0.59\\nJAN_05_2017\n\nimport scriptcontext as sc\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport System\nfrom math import pi as PI\nimport Grasshopper.Kernel as gh\nfrom System import Object\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport copy\n\ndef checkMeshPlanarity(mesh, basePlanePt):\n    #Check the planarity.\n    meshIsPlanar = True\n    mesh.Normals.ComputeNormals()\n    mesh.FaceNormals.UnitizeFaceNormals()\n    meshPlaneVec = mesh.Normals[0]\n    if meshPlaneVec.Z < 0:\n        meshPlaneVec.Reverse()\n    meshPlaneVecReverse = copy.copy(meshPlaneVec)\n    meshPlaneVecReverse.Reverse()\n    meshNormals = []\n    for norm in mesh.Normals:\n        if not norm.Equals(meshPlaneVec):\n            meshNormals.append(norm)\n            if norm.Equals(meshPlaneVecReverse):\n                norm.Reverse()\n                meshNormals.append(norm)\n            else:\n                meshIsPlanar = False\n    \n    # Change the Mesh to be in the XYPlane.\n    meshPlane = rc.Geometry.Plane(basePlanePt, meshPlaneVec)\n    if meshIsPlanar:\n        changeBasisTransform = rc.Geometry.Transform.ChangeBasis(rc.Geometry.Plane.WorldXY, meshPlane)\n        mesh.Transform(changeBasisTransform)\n    else:\n        meshNormals = [meshPlaneVec for i in range(mesh.Normals.Count)]\n        changeBasisTransform = rc.Geometry.Transform.ChangeBasis(rc.Geometry.Plane.WorldXY, meshPlane)\n        mesh.Transform(changeBasisTransform)\n    \n    return meshIsPlanar, mesh, meshPlane, meshNormals\n\n\ndef main(analysisResult, inputMesh, contourType, heightDomain, legendPar, analysisTitle, legendTitle, bakeIt, layerName, lb_preparation, lb_visualization):\n    # Get the Unit System.\n    conversionFac = lb_preparation.checkUnits()\n    \n    # Check the mesh's structure.\n    if inputMesh.Faces.Count == len(analysisResult):\n        meshStruct = 0\n    elif inputMesh.Vertices.Count == len(analysisResult):\n        meshStruct = 1\n    else:\n        warning = 'length of the results [=' + str(len(analysisResult)) + '] is not equal to the number of mesh faces [=' + str(inputMesh.Faces.Count) + '] or mesh vertices[=' + str(inputMesh.Vertices.Count) + '].'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n        return -1\n    singleValMesh = False\n    \n    # Read the legend and generate a list of blank colors.\n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    blankColors = []\n    if meshStruct == 0:\n        for count in inputMesh.Faces:\n            blankColors.append(System.Drawing.Color.Gray)\n    elif meshStruct == 1:\n        for count in inputMesh.Vertices:\n            blankColors.append(System.Drawing.Color.Gray)\n    \n    # Generate an underlay mesh to cover our ass when the intersection fails.\n    underlayMesh = None\n    if contourType == 0 or contourType == 1 or contourType == None:\n        colors = lb_visualization.gradientColor(analysisResult, lowB, highB, customColors)\n        underlayMesh = lb_visualization.colorMesh(colors, inputMesh, True, meshStruct)\n        if heightDomain!=None:\n            underlayMesh = lb_visualization.create3DColoredMesh(underlayMesh, analysisResult, heightDomain, colors, meshStruct)\n        moveTrans = rc.Geometry.Transform.Translation(0,0,-(1/conversionFac)*.03)\n        underlayMesh.Transform(moveTrans)\n    \n    # Check the mesh's planarity\n    minPt = inputMesh.GetBoundingBox(rc.Geometry.Plane.WorldXY).Min\n    meshIsPlanar, inputMesh, meshPlane, meshNormals = checkMeshPlanarity(inputMesh, minPt)\n    if meshIsPlanar == False:\n        warning = 'The connected inputMesh is not planar and this component only works for planar meshes.' + \\\n        '\\n Try breaking up your mesh into planar pieces and feeding them individually into this component.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    # Find the min and max of the dataset.\n    sortedData = analysisResult[:]\n    sortedData.sort()\n    dataMin = sortedData[0]\n    dataMax = sortedData[-1]\n    fullRange = dataMax - dataMin\n    if lowB != 'min' and highB != 'max':\n        legendRange = highB - lowB\n    elif lowB != 'min':\n        legendRange = dataMax - lowB\n    elif highB != 'max':\n        legendRange = highB - dataMin\n    else:\n        legendRange = fullRange\n    if fullRange == 0 or fullRange < (legendRange/numSeg):\n        singleValMesh = True\n        fullRange = 1\n        contIncr = legendRange/numSeg\n    else:\n        contIncr = legendRange/fullRange\n    \n    # Create a mesh with a height domain, which can then be contoured.\n    if heightDomain!=None:\n        coloredChart = lb_visualization.create3DColoredMesh(inputMesh, analysisResult, heightDomain, blankColors, meshStruct, meshNormals)\n        contInterval = contIncr*(heightDomain.Max - heightDomain.Min)/(numSeg-1)\n    else:\n        heightD = rc.Geometry.Interval(0,(numSeg-1)*(1/conversionFac))\n        contInterval = contIncr*(1/conversionFac)\n        coloredChart = lb_visualization.create3DColoredMesh(inputMesh, analysisResult, heightD, blankColors, meshStruct)\n    \n    # Figure out some basic things about the Legend.\n    lb_visualization.calculateBB([coloredChart], True)\n    if not legendTitle:  legendTitle = 'unknown units  '\n    if not analysisTitle: analysisTitle = '\\nno title'\n    if legendFont == None: legendFont = 'Verdana'\n    if legendFontSize == None: legendFontSize = legendScale * (lb_visualization.BoundingBoxPar[2]/20)\n    \n    if contourType == 3:\n        legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(analysisResult\n            , lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale\n            , legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    elif contourType == 2:\n        legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(analysisResult\n            , lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale\n            , legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n        legendSrfs, legendTextCrv, textPt = [], [], []\n    else:\n        legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(analysisResult\n            , lowB, highB, numSeg+1, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale\n            , legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan, True)\n    \n    # generate legend colors.\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n    \n    # Generate intersection planes.\n    intMeshes = []\n    if contourType == 0 or contourType == 1 or contourType == None:\n        BB = coloredChart.GetBoundingBox(rc.Geometry.Plane.WorldXY)\n        boundBox = BB.ToBrep()\n        baseSplitPlaneOrigin = boundBox.Faces[4].GetBoundingBox(rc.Geometry.Plane.WorldXY).Min\n        baseSplitPlane = boundBox.Faces[4].ToBrep()\n        intMeshes = [rc.Geometry.Mesh.CreateFromBrep(baseSplitPlane)[0]]\n    \n    lastPt = lb_visualization.BoundingBoxPar[0]\n    if lowB != 'min':\n        if heightDomain!=None:\n            startVal = ((lowB-dataMin)/fullRange)*(heightDomain.Max - heightDomain.Min)\n        else:\n            startVal = ((lowB-dataMin)/fullRange)*(numSeg-1)*(1/conversionFac)\n        lastPt = rc.Geometry.Point3d(lastPt.X, lastPt.Y, startVal)\n        movedPlane = copy.deepcopy(baseSplitPlane)\n        planeTransf = rc.Geometry.Transform.Translation(0,0,lastPt.Z-baseSplitPlaneOrigin.Z)\n        movedPlane.Transform(planeTransf)\n        movedPlaneMesh = rc.Geometry.Mesh.CreateFromBrep(movedPlane)[0]\n        intMeshes = [movedPlaneMesh]\n    intPlanes = [rc.Geometry.Plane(lastPt, rc.Geometry.Vector3d.ZAxis)]\n    for count in range(int(numSeg)):\n        lastPt = rc.Geometry.Point3d(lastPt.X, lastPt.Y, lastPt.Z+contInterval)\n        intPlanes.append(rc.Geometry.Plane(lastPt, rc.Geometry.Vector3d.ZAxis))\n        if contourType == 0 or contourType == 1 or contourType == None:\n            movedPlane = copy.deepcopy(baseSplitPlane)\n            planeTransf = rc.Geometry.Transform.Translation(0,0,lastPt.Z-baseSplitPlaneOrigin.Z)\n            movedPlane.Transform(planeTransf)\n            movedPlaneMesh = rc.Geometry.Mesh.CreateFromBrep(movedPlane)[0]\n            intMeshes.append(movedPlaneMesh)\n    \n    # Contour the mesh.\n    contourMeshArea = rc.Geometry.AreaMassProperties.Compute(inputMesh).Area\n    initMeshArea = contourMeshArea\n    failedIntersects = []\n    contourMesh = []\n    contourLines = []\n    contourLabels = []\n    contourColors = []\n    labelText = []\n    labelTextPts = []\n    startTrigger = False\n    failIntersecTrigger = False\n    \n    #Generate colored regions.\n    if contourType == 0 or contourType == 1 or contourType == None:\n        if singleValMesh == True:\n            val = analysisResult[0]\n            if lowB == 'min': lowB = val\n            if legendRange == 0:\n                legendRange = 1\n            colorIndex = int((val-lowB)/legendRange)\n            coloredChart.VertexColors.CreateMonotoneMesh(legendColors[colorIndex])\n            contourMesh.append(coloredChart)\n        else:\n            try:\n                finalSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[0])[-1]\n                finalSplitMesh.VertexColors.CreateMonotoneMesh(legendColors[0])\n                contourArea = rc.Geometry.AreaMassProperties.Compute(finalSplitMesh).Area\n                if contourArea < contourMeshArea-sc.doc.ModelAbsoluteTolerance and finalSplitMesh.IsValid:\n                    contourMesh.append(finalSplitMesh)\n                startTrigger = True\n            except:\n                pass\n            for count in range(len(intMeshes)-1):\n                try:\n                    if startTrigger == False:\n                        finalSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[count])[-1]\n                        finalSplitMesh.VertexColors.CreateMonotoneMesh(legendColors[count])\n                        contourArea = rc.Geometry.AreaMassProperties.Compute(finalSplitMesh).Area\n                        if contourArea < contourMeshArea-sc.doc.ModelAbsoluteTolerance and finalSplitMesh.IsValid:\n                            contourMesh.append(finalSplitMesh)\n                            contourColors.append([legendColors[count]])\n                        startTrigger = True\n                        initSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[count+1])[-1]\n                        finalSplitMesh = rc.Geometry.Mesh.Split(initSplitMesh, intMeshes[count])[0]\n                    elif count == len(intMeshes)-2:\n                        finalSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[count])[0]\n                    else:\n                        initSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[count])[-1]\n                        initMeshArea = rc.Geometry.AreaMassProperties.Compute(initSplitMesh).Area\n                        finalSplitMesh = rc.Geometry.Mesh.Split(initSplitMesh, intMeshes[count+1])[0]\n                    try:\n                        lColor = legendColors[count+1]\n                        finalSplitMesh.VertexColors.CreateMonotoneMesh(lColor)\n                    except:\n                        lColor = legendColors[count+1]\n                        finalSplitMesh.VertexColors.CreateMonotoneMesh(lColor)\n                    contourArea = rc.Geometry.AreaMassProperties.Compute(finalSplitMesh).Area\n                    if contourArea < contourMeshArea-sc.doc.ModelAbsoluteTolerance and contourArea < initMeshArea-sc.doc.ModelAbsoluteTolerance and finalSplitMesh.IsValid:\n                        contourMesh.append(finalSplitMesh)\n                        contourColors.append([lColor])\n                except:\n                    try:\n                        finalSplitMesh = rc.Geometry.Mesh.Split(coloredChart, intMeshes[count])[0]\n                        finalSplitMesh.VertexColors.CreateMonotoneMesh(legendColors[count])\n                        finalSplitMesh.Transform(moveTrans)\n                        contourArea = rc.Geometry.AreaMassProperties.Compute(finalSplitMesh).Area\n                        if contourArea < contourMeshArea-sc.doc.ModelAbsoluteTolerance:\n                            failedIntersects.append(finalSplitMesh)\n                    except: pass\n    \n    # Generate Labeled Contours\n    try:\n        if contourType == 0 or contourType == 2 or contourType == None:\n            if lowB != 'min' and highB != 'max':\n                numbers = rs.frange(lowB, highB, round((highB - lowB) / (numSeg -1), 6))\n            elif lowB != 'min':\n                numbers = rs.frange(lowB, dataMax, round((dataMax - lowB) / (numSeg -1), 6))\n            elif highB != 'max':\n                numbers = rs.frange(dataMin, highB, round((highB - dataMin) / (numSeg -1), 6))\n            else:\n                numbers = rs.frange(dataMin, dataMax, round((dataMax - dataMin) / (numSeg -1), 6))\n            if decimalPlaces == None: decimalPlaces = 2\n            formatString = \"%.\"+str(decimalPlaces)+\"f\"\n            numbersStr = [(formatString % x) for x in numbers]\n            if _labelSize_ == None:\n                labelSize = textSize/5\n            else:\n                labelSize = _labelSize_\n            for count, plane in enumerate(intPlanes):\n                contourLines.append([])\n                contourLabels.append([])\n                theLines = rc.Geometry.Mesh.CreateContourCurves(coloredChart, plane)\n                for line in theLines:\n                    contourLines[count].append(line)\n                    try:\n                        pts = line.DivideByLength(labelSize, True)\n                        ptIndex = int(len(pts)/2)\n                        ltextPt = line.PointAt(pts[ptIndex])\n                        labelText.append(numbersStr[count])\n                        labelTextPts.append(ltextPt)\n                        labelTextMesh = lb_visualization.text2srf([numbersStr[count]], [ltextPt], legendFont, labelSize, legendBold)[0]\n                        contourLabels[count].append(labelTextMesh)\n                    except:\n                        pass\n    except:\n        legendSrfs = None\n    \n    if contourType == 3:\n        for count, plane in enumerate(intPlanes):\n            try:\n                contourColors.append([legendColors[count]])\n            except:\n                pass\n            contourLines.append(rc.Geometry.Mesh.CreateContourCurves(coloredChart, plane))\n    \n    # Project the mesh back to the XYPlane.\n    if heightDomain == None:\n        planeTrans = rc.Geometry.Transform.PlanarProjection(rc.Geometry.Plane.WorldXY)\n        crvMove = rc.Geometry.Transform.Translation(0,0,sc.doc.ModelAbsoluteTolerance*5)\n        for geo in contourMesh: geo.Transform(planeTrans)\n        for geo in failedIntersects: geo.Transform(planeTrans)\n        for geo in intMeshes: geo.Transform(planeTrans)\n        for crvList in contourLines:\n            for geo in crvList:\n                geo.Transform(planeTrans)\n                geo.Transform(crvMove)\n        for crvList in contourLabels:\n            for geoList in crvList:\n                for geo in geoList:\n                    geo.Transform(planeTrans)\n                    geo.Transform(crvMove)\n    \n    # color legend surfaces\n    if contourType != 2:\n        legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    else:\n        legendSrfs = None\n    \n    titlebasePt = lb_visualization.BoundingBoxPar[-2]\n    titleTextCurve = lb_visualization.text2srf([\"\\n\\n\" + analysisTitle], [titlebasePt], legendFont, legendFontSize, legendBold)\n    flattenedLegend = lb_preparation.flattenList(legendTextCrv + titleTextCurve)\n    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\n    \n    # Change the geomtry back to its original plane.\n    transfBack = rc.Geometry.Transform.ChangeBasis(meshPlane, rc.Geometry.Plane.WorldXY)\n    for geo in contourMesh: geo.Transform(transfBack)\n    for geo in failedIntersects: geo.Transform(transfBack)\n    for geo in intMeshes: geo.Transform(transfBack)\n    for crvList in contourLines:\n        for geo in crvList: geo.Transform(transfBack)\n    for crvList in contourLabels:\n        for geoList in crvList:\n            for geo in geoList: geo.Transform(transfBack)\n    for geo in flattenedLegend: geo.Transform(transfBack)\n    legendBasePoint.Transform(transfBack)\n    if legendSrfs != None:\n        try:\n            legendSrfs.Transform(transfBack)\n        except:\n            pass\n    \n    # Move any failed intersections below the main surface.\n    moveTrans = rc.Geometry.Transform.Translation(0,0,-(1/conversionFac)*.03)\n    for geo in failedIntersects: geo.Transform(moveTrans)\n    \n    # If the user has requested to bake the geomtry, then bake it.\n    if bakeIt > 0:\n        # Greate a joined mesh.\n        joinedContMesh = rc.Geometry.Mesh()\n        for colMesh in contourMesh:\n            joinedContMesh.Append(colMesh)\n        \n        # Flatten the list of contour curves.\n        flatContourLines = lb_preparation.flattenList(contourLines)\n        \n        # Format the text to be baked as text.\n        formatString = \"%.\"+str(decimalPlaces)+\"f\"\n        for count, item in enumerate(legendText):\n            try:\n                legendText[count] = formatString % item\n            except:pass\n        if contourType == 2:\n            legendText = []\n        legendText.append(analysisTitle)\n        textPt.append(titlebasePt)\n        legendText.extend(labelText)\n        textPt.extend(labelTextPts)\n        if heightDomain == None:\n            for geo in textPt: geo.Transform(planeTrans)\n        for geo in textPt: geo.Transform(transfBack)\n        \n        #Set up the study layer\n        studyLayerName = 'CUSTOM_PRESENTATION'\n        if layerName == None: layerName = 'Custom'\n        # check the study type\n        newLayerIndex, l = lb_visualization.setupLayers('Modified Version', 'LADYBUG', layerName, studyLayerName)\n        if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, joinedContMesh, legendSrfs, legendText, textPt, textSize, legendFont, flatContourLines, decimalPlaces, True)\n        else: lb_visualization.bakeObjects(newLayerIndex, joinedContMesh, legendSrfs, legendText, textPt, textSize, legendFont, flatContourLines, decimalPlaces, False)\n    \n    return contourMesh, [underlayMesh]+failedIntersects, contourLines, contourColors, contourLabels, [legendSrfs, flattenedLegend], legendBasePoint, legendColors, intMeshes\n\n\n\n# import the classes\ninitCheck = True\nif sc.sticky.has_key('ladybug_release'):\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n    except:\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n                 \"Use updateLadybug component to update userObjects.\\n\" + \\\n                 \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n                 \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        initCheck = False\n    \n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nelse:\n    print \"You should let the Ladybug fly first...\"\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"You should let the Ladybug fly first...\")\n    initCheck = False\n\n\n\nif initCheck == True and _inputMesh and len(_analysisResult)!=0:\n    result = main(_analysisResult, _inputMesh, _contourType_, heightDomain_, legendPar_, analysisTitle_, legendTitle_, bakeIt_, layerName_, lb_preparation, lb_visualization)\n    if result!= -1:\n        legend= []\n        [legend.append(item) for item in lb_visualization.openLegend(result[5])]\n        contourMesh = result[0]\n        underlayMesh = result[1]\n        legendBasePt = result[6]\n        legendColors = result[7]\n        contourLabelsInit = result[4]\n        contourLinesInit = result[2]\n        contourColorsInit = result[3]\n        intPlanes = result[8]\n        contourLines = DataTree[Object]()\n        contourColors = DataTree[Object]()\n        contourLabels = DataTree[Object]()\n        for count, datalist in enumerate(contourLinesInit):\n            for item in datalist: contourLines.Add(item, GH_Path(count))\n        for count, datalist in enumerate(contourColorsInit):\n            for item in datalist: contourColors.Add(item, GH_Path(count))\n        for count, branchlist in enumerate(contourLabelsInit):\n            for count2, datalist in enumerate(branchlist):\n                for item in datalist: contourLabels.Add(item, GH_Path(count, count2))\n        \n        # Hide output\n        ghenv.Component.Params.Output[7].Hidden = True\n        ghenv.Component.Params.Output[9].Hidden = True\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}