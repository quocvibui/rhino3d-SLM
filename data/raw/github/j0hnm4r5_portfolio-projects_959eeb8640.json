{
  "source_url": "https://github.com/j0hnm4r5/portfolio-projects/blob/fe4f5b2fd5be055b59ae6bcf0387b0dd4b07691b/Computing%20Drawing/Boids-Code/*boidsWithBorder.py",
  "repo": "j0hnm4r5/portfolio-projects",
  "repo_stars": 1,
  "repo_description": "Code for projects on john-mars.com",
  "license": "NOASSERTION",
  "filepath": "Computing Drawing/Boids-Code/*boidsWithBorder.py",
  "instruction": "*boids with border",
  "code": "import rhinoscriptsyntax as rs\nimport random, math\n\n\"\"\"\nFor each agent, for each increment of time:\na) Avoid crowding local flockmates. Steer to keep a minimum distance between each agent and the ones around it. In flocking models, a boid (bird/droid) reacts only to flockmates within a certain neighborhood around itself; there is no global steering intelligence. The neighborhood is defined by a distance from the center of the boid and the angle around it, measured by its direction of travel.\nb) Align towards the average heading of local flockmates.\nc) Cohere to the flock: move toward the center of mass of local flockmates. The center of mass is the average position of all the agents.\n\"\"\"\n\nclass Boid(object):\n\n\tSZ_radius = 10\n\tNZ_radius = 25\n\tNZ_angle = 270\n\n\theading_factor = .5\n\tseparation_factor = 1.5\n\talignment_factor = 2\n\tcohesion_factor = .5\n\tavoidance_factor = 1.5\n\tnode_factor = .5\n\n\tdef __init__(self, guid, heading, obstacles, nodes):\n\t\t\"\"\" CREATE A BOID \"\"\"\n\n\t\tself.guid = guid\n\n\t\tself.position = rs.PointCoordinates(self.guid)\n\t\tself.heading = heading\n\n\t\tself.obstacles = obstacles\n\t\tself.nodes = nodes\n\n\t\tself.SZ_neighbors = []\n\t\tself.NZ_neighbors = []\n\n\t\tself.NZ_avg_heading = []\n\t\tself.NZ_center_of_mass = []\n\n\t\tself.separation_vector = (0,0,0)\n\t\tself.alignment_vector = (0,0,0)\n\t\tself.cohesion_vector = (0,0,0)\n\t\tself.avoidance_vector = (0,0,0)\n\t\tself.node_vector = (0,0,0)\n\n\t\tself.path_pts = []\n\t\tself.path_guid = \"\"\n\t\tself.path_pts.append(self.position)\n\n\tdef get_SZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN SZ, MAKE IT AN SZ NEIGHBOR \"\"\"\n\n\t\tself.SZ_neighbors = []\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif (distance != 0) and (distance < Boid.SZ_radius):\n\t\t\t\tself.SZ_neighbors.append(agent)\n\n\tdef get_NZ_neighbors(self, population):\n\t\t\"\"\" IF AGENT IS WITHIN NZ, MAKE IT AN NZ NEIGHBOR \"\"\"\n\n\t\tself.NZ_neighbors = []\n\t\tcenter_cone = rs.VectorReverse(self.heading)\n\n\t\tfor agent in population:\n\t\t\tdistance = rs.Distance(self.guid, agent.guid)\n\t\t\tif distance != 0:\n\t\t\t\tagent_angle = rs.VectorAngle(rs.VectorCreate(self.guid, agent.guid), center_cone)\n\t\t\t\tif (distance < Boid.NZ_radius) and (agent_angle < Boid.NZ_angle / 2):\n\t\t\t\t\tself.NZ_neighbors.append(agent)\n\n\tdef separate(self):\n\t\t\"\"\" MOVE AWAY FROM NEIGHBORS IN SZ \"\"\"\n\t\tself.separation_vector = (0,0,0)\n\t\tif len(self.SZ_neighbors) > 0:\n\n\t\t\tfor neighbor in self.SZ_neighbors:\n\t\t\t\tself.separation_vector = rs.VectorAdd(rs.VectorCreate(self.position, neighbor.position), self.separation_vector)\n\n\t\t\tself.separation_vector = rs.VectorDivide(self.separation_vector, len(self.SZ_neighbors))\n\t\t\tself.separation_vector = rs.VectorScale(self.separation_vector, Boid.separation_factor)\n\n\tdef align(self):\n\t\t\"\"\" ALIIGN TOWARDS AVERAGE HEADING OF NEIGHBORS \"\"\"\n\t\tself.NZ_avg_heading = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_avg_heading = rs.VectorAdd(self.NZ_avg_heading, neighbor.heading)\n\n\t\t\tself.NZ_avg_heading = rs.VectorDivide(self.NZ_avg_heading, len(self.NZ_neighbors))\n\n\t\t\tself.alignment_vector = rs.VectorScale(self.NZ_avg_heading, Boid.alignment_factor)\n\n\tdef cohere(self):\n\t\t\"\"\" MOVE TOWARD THE CENTER OF MASS OF NEIGHBORS \"\"\"\n\t\tself.NZ_center_of_mass = (0,0,0)\n\n\t\tif len(self.NZ_neighbors) > 0:\n\n\t\t\tfor neighbor in self.NZ_neighbors:\n\t\t\t\tself.NZ_center_of_mass = rs.VectorAdd(self.NZ_center_of_mass, neighbor.position)\n\n\t\t\tself.NZ_center_of_mass = rs.VectorDivide(self.NZ_center_of_mass, len(self.NZ_neighbors))\n\n\t\t\tself.cohesion_vector = rs.VectorCreate(self.NZ_center_of_mass, self.position)\n\t\t\tself.cohesion_vector = rs.VectorScale(self.cohesion_vector, Boid.cohesion_factor)\n\n\tdef avoid(self):\n\t\t\"\"\" AVOID OBSTACLES \"\"\"\n\n\t\tif len(self.obstacles) == 1:\n\n\t\t\tavoidance_line = rs.VectorUnitize(self.heading)\n\t\t\tavoidance_line = rs.VectorScale(avoidance_line, Boid.SZ_radius)\n\t\t\tavoidance_line = rs.AddLine(self.position, rs.PointAdd(self.position, avoidance_line))\n\n\t\t\tccx = rs.CurveCurveIntersection(avoidance_line, self.obstacles[0])\n\t\t\tif ccx != None:\n\t\t\t\tcentroid = rs.CurveAreaCentroid(self.obstacles[0])\n\t\t\t\tcentroid_distance = rs.Distance(self.position, centroid[0])\n\t\t\t\tself.avoidance_vector = rs.VectorCreate(centroid[0], self.position)\n\t\t\t\tif centroid_distance < 75:\n\t\t\t\t\tself.avoidance_vector = rs.VectorScale(self.avoidance_vector, Boid.avoidance_factor)\n\t\t\t\telse:\n\t\t\t\t\tself.avoidance_vector = rs.VectorScale(self.avoidance_vector, centroid_distance/10)\n\t\t\telse:\n\t\t\t\tself.avoidance_vector = (0,0,0)\n\n\t\t\trs.DeleteObject(avoidance_line)\n\n\tdef spin(self):\n\t\t\"\"\" CIRCLE AROUND NODES \"\"\"\n\n\t\tnode_vector_list = []\n\t\tself.node_vector = (0,0,0)\n\n\t\tdistance = 1000\n\t\ti = 0\n\t\tfor node in self.nodes:\n\t\t\ttemp_distance = rs.Distance(node, self.position)\n\t\t\tif temp_distance < distance:\n\t\t\t\tdistance = temp_distance\n\t\t\t\tj = i\n\t\t\ti += 1\n\n\t\tself.node_vector = rs.VectorCreate(self.position, self.nodes[j])\n\t\tself.node_vector = rs.VectorRotate(self.node_vector, 90, (0,0,1))\n\t\tself.node_vector = rs.VectorScale(self.node_vector, Boid.node_factor)\n\n\n\tdef update_heading(self):\n\t\t\"\"\" AVERAGE SEPARATION, ALIGNMENT, AND COHESION VECTORS \"\"\"\n\n\t\tself.separate()\n\t\tself.align()\n\t\tself.cohere()\n\t\tself.avoid()\n\t\tself.spin()\n\n\t\tself.heading = rs.VectorAdd(self.heading, self.separation_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.alignment_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.cohesion_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.avoidance_vector)\n\t\tself.heading = rs.VectorAdd(self.heading, self.node_vector)\n\t\tself.heading = rs.VectorDivide(self.heading, 5)\n\t\tself.heading = rs.VectorScale(self.heading, Boid.heading_factor)\n\n\tdef move(self):\n\t\t\"\"\" MOVE A BOID \"\"\"\n\n\t\tself.position = rs.PointAdd(self.position, self.heading)\n\t\tself.path_pts.append(self.position)\n\t\trs.DeleteObject(self.guid)\n\t\tself.guid = rs.AddPoint(self.position)\n\n\n\tdef update(self, population):\n\t\t\"\"\" CHANGE HEADING AND MOVE BOID \"\"\"\n\n\t\tself.get_SZ_neighbors(population)\n\t\tself.get_NZ_neighbors(population)\n\t\tself.update_heading()\n\t\tself.move()\n\n\tdef draw_path(self):\n\t\t\"\"\" DRAW BOID'S PATH \"\"\"\n\n\t\tif self.path_guid:\n\t\t\trs.DeleteObject(self.path_guid)\n\t\tself.path_guid = rs.AddCurve(self.path_pts)\n\ndef fill(surface):\n\tbox = rs.BoundingBox(surface)\n\n\t# number = rs.GetReal(\"Number of Points:\", 50)\n\tnumber = 50\n\n\tpointlist = []\n\n\ti=0\n\twhile i<number:\n\t\tx = random.uniform(box[0][0],box[6][0])\n\t\ty = random.uniform(box[0][1],box[6][1])\n\t\tz = random.uniform(box[0][2],box[6][2])\n\t\tpoint = rs.AddPoint(x,y,z)\n\t\tpointlist.append(point)\n\t\ti+=1\n\n\treturn pointlist\n\ndef make_nodes(obstacles, node_number):\n\tnodes = []\n\tbox = rs.BoundingBox(obstacles[0])\n\ti=0\n\twhile i<node_number:\n\t\tx = random.uniform(box[0][0],box[6][0])\n\t\ty = random.uniform(box[0][1],box[6][1])\n\t\tz = random.uniform(box[0][2],box[6][2])\n\t\tnode = rs.AddPoint(x,y,z)\n\t\trs.ObjectLayer(node, \"Nodes\")\n\t\tnodes.append(node)\n\t\ti+=1\n\treturn nodes\n\n\n\ndef Main():\n\tobstacles = rs.GetObjects(\"Pick Bounding Object\", 12, preselect=True)\n\tpopulation_pts = fill(obstacles[0])\n\n\tnode_number = random.randint(0,5)\n\t# node_number = 2\n\tnodes = make_nodes(obstacles, node_number)\n\n\tif node_number == 0:\n\t\tsteps = 250\n\telse:\n\t\tsteps = 100\n\n\tinitial_heading = rs.VectorCreate((random.uniform(0,10),random.uniform(0,10),0), (0,0,0))\n\n\tpopulation = []\n\ti = 0\n\twhile i < len(population_pts):\n\t\tpopulation.append(Boid(population_pts[i], initial_heading, obstacles, nodes))\n\t\ti += 1\n\n\n\tfor t in range(steps):\n\t\tfor boid in population:\n\t\t\tboid.update(population)\n\n\n\tfor boid in population:\n\t\tboid.draw_path()\n\n\n\nMain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}