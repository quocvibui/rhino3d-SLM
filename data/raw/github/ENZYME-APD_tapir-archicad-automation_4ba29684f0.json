{
  "source_url": "https://github.com/ENZYME-APD/tapir-archicad-automation/blob/3cc4d67228a62381d6cf7d9c0c3897171044ace2/sandbox/grasshopper-plugin/scripts/api2.py",
  "repo": "ENZYME-APD/tapir-archicad-automation",
  "repo_stars": 94,
  "repo_description": "The easiest way to use the JSON/Python API from Archicad without knowing how to code.",
  "license": "MIT",
  "filepath": "sandbox/grasshopper-plugin/scripts/api2.py",
  "instruction": null,
  "code": "import json\nimport csv\nimport os\nimport urllib2 as rq\nfrom collections import OrderedDict\nimport  xml.etree.ElementTree as e\n# import requests\ntry: \n\timport scriptcontext as sc\nexcept:\n\tpass\n\t# print ('No sticky')\n\n# \"\"\"\n# Archicad API 3.0 for grasshopper nodes and ARCHICAD 25 Python pallete\n\n# \"\"\"\ndef readFromFile(csvFile):\n\t'''\n\tReads list of elements from file previouslly saved\n\t'''\n\t#path validation\n\tisFile = os.path.isfile(csvFile)\n\tif isFile:\n\t\twith open(csvFile,'r') as file:\n\t\t\treader = csv.reader(file)\n\t\t\t_list =[row[0] for row in reader]\n\t\t\tprint _list\n\t\tfile.close()\n\t\treturn _list\n\treturn []\ndef bakeToFile(_list,csvFile):\n\t'''\n\tSaves list to a textfile in one column\n\tINPUT:\n\t\t_list:\t\tlist - list of elements \n\t\tcsv_file: \tstr  - path to a location where file will be saved\n\t'''\n\twith open(csvFile,'w') as f:\n\t\twrite = csv.writer(f)\n\t\tfor row in _list:\n\t\t\twrite.writerow([row])\n\treturn '{} elements saved to file: {}'.format(len(_list),csvFile)\n\tf.close()\ndef composeAddonCommand(commandName,commandParams={},namespace='AdditionalJSONCommands'):\n\n\t# '''\n\t# Composes json command for Custom Addon: AdditionalJsonCommands\n\t# if commands requires parameters provide it in form of dictionary\n\t# Parametername:value\n\t# '''\n\tjson_command = {}\n\tjson_command['command'] = 'API.ExecuteAddOnCommand'\n    \n\n\taddOnCommandId  ={}\n\taddOnCommandId['commandNamespace'] = namespace\n\taddOnCommandId['commandName'] = commandName\n\n\n\taddOnCommandParameters = {}    \n\tif len(commandParams) > 0:\n\t\t_parameters={}\n\t\tfor command,value in commandParams.items():\n\t\t\t_parameters[command] = value\n\t\taddOnCommandParameters = _parameters\n\t\tjson_command['parameters'] = {'addOnCommandId':addOnCommandId,'addOnCommandParameters':addOnCommandParameters}\n\telse:\n\t\tjson_command['parameters'] = {'addOnCommandId':addOnCommandId}\n\treturn json_command\n\ndef extract_xml_from_bimx(bimxFile):\n\twith open(bimxFile,'r') as file:\n\t# with open(bimxFile,'r',encoding='utf-8') as file:\n\t\tdata = file.readlines()\n\tfile.close()\n\n\n\tfor i,j in enumerate(data):\n\t\t# print (i,j)\n\t\tif \"<Metadata\" in j:\n\t\t\ta = i \n\t\tif \"</Metadata\" in j:\n\t\t\tb = i+1\n\n\tblock = (a,b)\n\txml = []\n\tfor i in xrange(block[0],block[1]):\n\t\txml.append(data[i])\n\t\txmlString = ''.join(xml)\n\treturn xmlString\n\ndef parseXML(xmlString):\n\t# parser = e.XMLParser(strip_cdata = False)\n\t# xmlParsed = e.parse(xmlString,parser)\n\txmlParsed = e.fromstring(xmlString)\n\troot = xmlParsed\n\treturn root\n\ndef addItem(array,item):\n    array.append(item)\n    \ndef openFolder(array,folder):\n    for f in folder:\n        if f.tag=='Item':addItem(array,f)\n        if f.tag=='Folder':openFolder(array,f)\n\ndef getLayouts(itemsAndFolders):\n    _layoutName = []\n    _layoutID   = []\n    _items= []\n    for j,i in enumerate(itemsAndFolders[0]):\n        if i.attrib.has_key('type') == False:\n            if i.tag=='Item':addItem(_items,i)\n            if i.tag=='Folder':openFolder(_items,i)\n    for item in _items:\n        \n        _layoutName.append(item.attrib['title'])\n        _layoutID.append(item.attrib['id'])\n    sc.sticky['layoutNames'] = _layoutName\n    sc.sticky['layoutID'] = _layoutID\n    return _layoutName,_layoutID\n\ndef get_layouts():\n\t\"\"\"get bimx llayouts from sticky global\"\"\"\n\ttry:\n\t\t_layoutName = sc.sticky['layoutNames']\n\t\t_layoutID = sc.sticky['layoutID']\n\t\t\n\t\treturn dict(zip(_layoutName,_layoutID))\n\texcept:\n\t\treturn False\ndef set_global_toggle(on_off):\n\t\"\"\"\n\tglobal turnoff/on variable\n\tINPUT:\n\t\ton_off: list of integers\n\t\"\"\"\n\ttry:\n\t\tif isinstance(on_off,bool):\n\t\t\tsc.sticky['toggle'] = on_off\n\t\telse: \n\t\t\tsc.sticky['toggle'] = False\n\texcept:\n\t\tprint 'Run outside GH'\n\n\ndef get_global_toggle():\n\t\"\"\"Gets global toggle\"\"\"\n\ttry:\n\t\t_toggle = sc.sticky['toggle']\n\t\treturn _toggle\n\texcept:\n\t\treturn False\n\ndef set_active_port(ports):\n\t''' \n\t'''\n\tif isinstance(ports,int):\n\t\tports=[ports]\n\ttry:\n\t\tsc.sticky['activeports'] = ports\n\texcept:\n\t\tprint 'Run outside GH'\ndef get_active_port():\n\ttry:\n\t\treturn sc.sticky['activeports']\n\texcept:\n\t\treturn [19723]\n\ndef set_ports(ports):\n\t\"\"\"\n\tSaves ports to GH Sticky Global variable accessible to any node in a scheme\n\tINPUT:\n\t\tports: list of integers\n\t\"\"\"\n\ttry:\n\t\tsc.sticky['ports'] = ports\n\t\tprint('ports set')\n\texcept:\n\t\tprint 'Run outside GH'\n\ndef get_port():\n\t\"\"\"Gets list of ports saved in  GH sticky global variable or false if run outside GH \"\"\"\n\ttry:\n\t\t_ports = sc.sticky['ports']\n\t\tif isinstance(sc.sticky['ports'],int):\n\t\t\t_ports = [sc.sticky['ports']]\n\t\treturn _ports\n\texcept:\n\t\treturn False\n\n\n\ndef connect(json_definition,port):\n\t\"\"\"\n\tConnects to ARCHICAD API\n\t\"\"\"\n\ttry:\n\t\trequest = rq.Request ('http://127.0.0.1:{}'.format(port))\n\t\tresponse = rq.urlopen (request, json.dumps (json_definition).encode (\"UTF-8\"))\n\t\tResult = json.loads (response.read ())\n\t\treturn Result\n\texcept :\n\t\treturn False\n\ndef check_port(port):\n\t\"\"\"\n\tChecks if port is Alive\n\t\"\"\"\n\tcommand = {\n\t\"command\": \"API.IsAlive\"\n\t}\n\ttry:\n\t\tresp_to_json  = connect(command,port)\n\t\tisSuccess = resp_to_json['succeeded']\n\t# print ('Status:{0}'.format(isSuccess))s\n\t# if isSuccess == False:\n\texcept:\n\t\t# print ('Port not opened')\n\t\tisSuccess = False\n\t\t# print ('Error {0} - {1}'.format(resp_to_json['error']['code'],resp_to_json['error']['message']))\n\treturn isSuccess\n\ndef open_ports():\n\t\"\"\"\n\tScans scopes of ports and return list of open ports (open ARCHICAD copies)\n\t\"\"\"\n\tscope = (19723,19726)\n\t# scope = (19723,19743)\n\tports = [i for i in range(scope[0],scope[1]+1)if check_port(i)]\n\tset_ports(ports)\n\treturn ports\n\n\t\n\n\ndef pack(name,dictionary):\n\t\"\"\"\n\tPacking dictionary to json and dumps it to string\n\tINPUT:\n\t\tname: key name\n\t\tdictionary: data set to be send\n\t\"\"\"\n\tjson_def = {name:dictionary}\n\treturn json.dumps(json_def)\ndef packlist(_list):\n\t\"\"\"\n\tPacking list to json and dumps it to string\n\tINPUT:\n\t\tname: key name\n\t\tdictionary: data set to be send\n\t\"\"\"\n\tjson_def = _list\n\treturn json.dumps(json_def)\n\ndef unpack(json_def):\n\t\"\"\"\n\tUnpacking dumped json string into dictionary\n\tINPUT:\n\t\tjson_def: string to be parsed into dictionary\n\t\"\"\"\n\treturn json.loads(json_def)\n\n\n\n# # wrapping_index\ndef get_wrapped_value(current_index,lista):\n\t'''\n\twraps current_value to fit a lenght of a list\n\t'''\n\twrapped_index = 0\n\tif len(lista):\n\t\tmultiplication = int(current_index/len(lista)) \n\t\twrapped_index = current_index - (multiplication*len(lista))\n\treturn int(wrapped_index)\n\n\n\ndef show_menu(header_name,lista,current_index):\n\t'''\n\t\tdraws menu \n\t'''\n\theader = '''\n---------------\n{}\n---------------\n\t'''.format(header_name)\n\n\n\n\trows=[]\n\trows.append(header)\t\n\tfor i,j in enumerate(lista):\n\t\t\n\t\tif i == current_index:\n\t\t\tarrow = '<--pick ({})'.format(j)\n\t\telse:\n\t\t\tarrow = ''\n\t\trows.append('{} | {}     {}'.format(i,j,arrow))\n\n\tshow_content = '\\n'.join(rows)\n\t# print show_content\n\treturn show_content\n\ndef show_menu_two_inputs(header_name,lista,current_index,current_index2):\n\t'''\n\t\tdraws menu \n\t'''\n\theader = '''\n---------------\n{}\n---------------\n\t'''.format(header_name)\n\n\n\n\trows=[]\n\trows.append(header)\t\n\tfor i,j in enumerate(lista):\n\t\t\n\t\tif i == current_index:\n\t\t\tarrow = '<--IdField ({})'.format(j)\n\t\telse:\n\t\t\tarrow = ''\n\t\tif i == current_index2:\n\t\t\tarrow2 = '<--ValueField ({})'.format(j)\n\t\telse:\n\t\t\tarrow2 = ''\n\t\trows.append('{} | {}     {}     {}'.format(i,j,arrow,arrow2))\n\n\tshow_content = '\\n'.join(rows)\n\t# print show_content\n\treturn show_content\n\n\ndef getBuiltInPropertiesOfType(builtInPropertyNames,port,propType = 'General'):\n\t\"\"\"\n\tGets BuiltIn properties of Type\n\tinput:\n\t\tpropType: property type\n\t\tport: active port\n\t\"\"\"\n\tpropsOfType =[]\n\tfor prop in builtInPropertyNames:\n\t\tif propType in prop:\n\t\t\tpropsOfType.append(prop)\n\treturn propsOfType\n\ndef getBuiltInPropertyTypes(port):\n\t\"\"\"\n\tGets BuiltIn property Types for grouping\n\tinput:\n\t\tport: active port\n\t\"\"\"\n\n\tBuiltInPropertyTypes=[]\n\tjson_definition = {\n\t\"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\n\tfor _property in result['result']['properties']:\n\t\tif 'BuiltIn' in _property['type']:\n\t\t\tstring= _property['nonLocalizedName']\n\t\t\tBuiltInPropertyTypes.append(string.split('_')[0])\n\t\tBuiltInPropertyTypes = list(set(BuiltInPropertyTypes))\n\treturn BuiltInPropertyTypes\n\ndef getBuiltInPropertyNames(port):\n\t'''\n\tGets list of 'BuiltIn' property names\n\tinput: \n\t\tport: active port \n\t'''\n\tBuiltInPropertyNames =[]\n\tjson_definition = {\n    \"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\tfor _property in result['result']['properties']:\n\t\tif 'BuiltIn' in _property['type']:\n\t\t\tstring= _property['nonLocalizedName']\n\t\t\tBuiltInPropertyNames.append(string)\n\treturn BuiltInPropertyNames\n\ndef getUserDefinedPropertyId(group,propertyName,port):\n\t'''\n\tinput: \n\t\tproperty name,\n\t\tport\n\toutput:\n\t\tguid <str> of property\n\t'''\n\tcommand = {\n\t    \"command\": \"API.GetPropertyIds\",\n\t    \"parameters\": {\n\t        \"properties\": [\n\t            {\n\t                \"type\": \"UserDefined\",\n\t                \"localizedName\": [group,propertyName]\n\t        \t}\n\t        ]\n\t            \n\t    }\n\t}\n\n\tid = connect(command,port)\n\n\treturn id['result']['properties'][0]['propertyId']['guid']\n\n\ndef getBuiltInPropertyId(propertyName,port):\n\t'''\n\tinput: \n\t\tproperty name,\n\t\tport\n\toutput:\n\t\tguid <str> of property\n\t'''\n\tcommand = {\n\t    \"command\": \"API.GetPropertyIds\",\n\t    \"parameters\": {\n\t        \"properties\": [\n\t            {\n\t                \"type\": \"BuiltIn\",\n\t                \"nonLocalizedName\": propertyName\n\t        \t}\n\t        ]\n\t            \n\t    }\n\t}\n\n\tid = connect(command,port)\n\n\treturn id['result']['properties'][0]['propertyId']['guid']\n\n\ndef getUserDefinedPropertyGroups(port):\n\t\"\"\"\n\tGet all avaliable user defined property groups\n\tINPUT:\n\t\tport\n\tOutput (2 variables):\n\t\tgroups: list of groups names\n\t\tproperties: dictionary {group:list of properties names} \n\n\t\"\"\"\n\tjson_definition = {\n    \"command\": \"API.GetAllPropertyNames\"\n\t}\n\n\tresult =  connect(json_definition,port)\n\tuserDefGroups =[]\n\tuserDefProps =[]\n\tfor i in result['result']['properties']:\n\t\tif i['type'] == 'UserDefined':\n\t\t\tuserDefGroups.append(i['localizedName'][0])\n\t\t\tuserDefProps.append(i['localizedName'])\n\n\tuserDefGroups = list(set(userDefGroups))\n\n\tgroup_props={}\n\tfor group in userDefGroups:\n\t\t_props=[]\n\t\tfor prop in userDefProps:\n\t\t\tif prop[0] == group:\n\t\t\t\t_props.append(prop[1])\n\t\tgroup_props[group] = _props\n\n\t# return userDefProps\n\t# return userDefGroups\n\treturn userDefGroups,group_props\n\ndef getUserDefinedPropertiesOfGroup(port,group):\n\t\"\"\"\n\tGet all avaliable user defined properties in group\n\tINPUT:\n\t\tport int port avaliable\n\t\tgroup: string name\n\tOutput: list of properties in provided group\n\t\"\"\"\n\tprint \"props in group: {}\".format(group)\n\n\ndef getPropertyValue(elements,propertyId,port):\n\t'''\n\tgets property value\n\t'''\n\t_elements = elements#[0]\n\t_propertyId = propertyId#[0]\n\n\t_el = []\n\t_prop = []\n\tfor i in _elements:\n\n\t\t_el.append(\n\t\t\t{\n     \t\t \"elementId\": \n     \t\t \t{\n             \t\"guid\": i\n                }\n\t\t\t}\n\t\t\t)\n\n\tfor i in _propertyId:\n\n\t\t_prop.append(\n\t\t\t{\n     \t\t \"propertyId\": \n     \t\t \t{\n             \t\"guid\": i\n                }\n\t\t\t}\n\t\t\t)\n\n\tjson_definition = {\n        \"command\": \"API.GetPropertyValuesOfElements\",\n        \"parameters\": {\n            \"elements\":_el,\n            \"properties\": _prop\n        }\n\t}\n\n\tresult = connect(json_definition,port)\n\tval=[]\n\t\n\tif result['succeeded']:\n\t\tfor i in result['result']['propertyValuesForElements']:\n\t\t\t# print i['propertyValues'][0]['propertyValue']\n\t\t\t__val = i['propertyValues'][0]['propertyValue']\n\t\t\tval.append(__val)\n\t\treturn val\n\telse:\n\t\tprint result['error']['message']\n\t\treturn False\n\t\n\t# return result['result']\ndef getElementsTypes():\n\ttypes = [\n\t\"Wall\",\n\t\"Column\",\n\t\"Beam\",\n\t\"Window\",\n\t\"Door\",\n\t\"Object\",\n\t\"Lamp\",\n\t\"Slab\",\n\t\"Roof\",\n\t\"Mesh\",\n\t\"Zone\",\n\t\"CurtainWall\",\n\t\"Shell\",\n\t\"Skylight\",\n\t\"Morph\",\n\t\"Stair\",\n\t\"Railing\",\n\t\"Opening\"\n\t]\n\treturn types\n\ndef getAllElements(port):\n\t'''\n\t'''\n\tcommand = {\n\t\t\"command\": \"API.GetAllElements\"\n\t\t}\n\n\tresult = connect(command,port)\n\tif result['succeeded']:\n\t\telements=[]\n\t\tfor el in result['result']['elements']:\n\t\t\t# pass\n\t\t\telements.append(el['elementId']['guid'])\n\t\treturn json.dumps({'elements':elements})\n\telse:\n\t\treturn False\n\ndef getElementsByType(elementType,port):\n\tcommand = {\n\t\t\"command\": \"API.GetElementsByType\",\n\t\t\t\"parameters\": {\"elementType\": elementType\n\t\t\t}\n\t\t}\n\tresult = connect(command,port)\n\telements=[]\n\tfor e in result['result']['elements']:\n\t\telements.append(e['elementId']['guid'])\n\t_elements = json.dumps({'type':elementType,'elements':elements})\n\t# _elements = json.dumps({'elements':elements})\n\treturn _elements\n\n\ndef getClassificationSystems(port):\n\t\"\"\"\n\t\"\"\"\n\tjsn = {\n\t\"command\": \"API.GetAllClassificationSystems\"\n\t}\n\tresult = connect(jsn,port)\n\tsystems = [name for name in result['result']['classificationSystems']]\n\tnames = [name['name'] for name in systems]\n\tguids = [guid['classificationSystemId']['guid'] for guid in systems]\n\treturn dict(zip(names,guids))\n\ndef convert_types(value,type_name):\n\t# print value,type_name\n\tif type_name=='number':return float(value)\n\tif type_name=='string':return str(value)\n\tif type_name=='integer':\n\n\t\treturn int(value)\n\tif type_name=='boolean':return bool(value)\n\tif type_name=='area':return float(value)\n\tif type_name=='volume':return float(value)\n\tif type_name=='angle':return float(value)\n\tif type_name=='length':return float(value)\n\ndef prop_type(value,other_types=''):\n\tif other_types=='':\n\t\tif isinstance(value, str):\n\t\t\tif value == 'True'\t or value == 'False':\n\t\t\t\treturn'boolean'\n\t\t\telse:\n\t\t\t\treturn'string'.lower()\n\t\tif isinstance(value, int):return'integer'\n\t\tif isinstance(value, float):return'number'\n\t\tif isinstance(value, dict):return'singleEnum'\n\t\tif isinstance(value, list):return'multiEnum'\n\tif other_types=='area':return'area'\n\tif other_types=='volume':return'volume'\n\tif other_types=='length':return'length'\n\tif other_types=='angle':return'angle'\n\tif other_types=='boolean':return'boolean'\n\ndef setPropertyValue(e,p,v,port):\n\n\n\tjson_def = {}\n\tjson_def['command'] =  \"API.SetPropertyValuesOfElements\"\n\tjson_def['parameters'] =  {}\n\n \titem = {}\n\n \t\n \t\n \titems_list =[]\n\n \tk=0\n\n \tfor i in e:\n\t\t\n \t\t# items_list.append({'elementId':{'guid':i},'propertyId':{'guid':p},'propertyValue':v})\n \t\titems_list.append({'elementId':{'guid':i},'propertyId':{'guid':p},'propertyValue':{'type':v[k]['type'],'status':v[k]['status'],'value':v[k]['value']}})\n \t\tk=k+1\n\n\tjson_def['parameters']['elementPropertyValues'] =  items_list\n\tresult = connect(json_def,port)\n\t# print json_def\n\t# print result['succeeded']\t\t\n\n\treturn 'Set new Parameter value to {0} elements:{1} '.format(len(e),str(result['succeeded']))\n\t# # return result\n\t# # return json.dumps(json_def,indent=4,sort_keys=True)\n\n\n\n#-------- CLASSIFICATION SYSTEM\n\ndef getAllClassificationSystems(port):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.GetAllClassificationSystems\"\n\tresult = connect(json_def,port)\n\ttry:\n\t\tresponse = result['succeeded']\n\texcept:\n\t\tresponse = result\n\tif response:\n\t\t_system_details = result['result']['classificationSystems']\n\t\t_systems = []\n\t\tfor i in _system_details:\n\t\t\t_system  = {}\t\n\t\t\t_system['name']\t\t\t= i['name']\n\t\t\t_system['source']\t\t= i['source']  \n\t\t\t_system['version']\t\t= i['version']  \n\t\t\t_system['date']\t\t\t= i['date']  \n\t\t\t_system['description']\t= i['description']  \n\t\t\t_system['guid']\t\t\t= i['classificationSystemId']['guid']  \n\t\t\t_systems.append(_system)\n\t\treturn _systems\n\telse:\n\t\treturn False\n\ndef GetAllClassificationsInSystem(port,_classSystemID):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.GetAllClassificationsInSystem\"\n\tjson_def['parameters'] =  {\n\t\t\"classificationSystemId\": {\n            \"guid\": _classSystemID\n\t\t}\n\t}\n\tresult = connect(json_def,port)\n\n\ttry:\n\t\tresponse = result['succeeded']\n\texcept:\n\t\tresponse = result\n\t\treturn['message']['error']\n\tif response:\n\t\treturn result['result']['classificationItems']\n\n\n# def SetClassificationsOfElements():\ndef SetClassificationsOfElements(port,_elements,_systemID,_classificationID):\n\tjson_def = {}\n\tjson_def['command'] =  \"API.SetClassificationsOfElements\"\n\t_elementClassifications = []\n\tfor _el in _elements:\n\t\t_element_set = OrderedDict()\n\t\t_element_set[\"elementId\"]={\"guid\":_el}\n\t\t_element_set[\"classificationId\"]={\n\t\t\t\"classificationItemId\":\t\t{\"guid\":_classificationID},\n\t\t\t\"classificationSystemId\":\t{\"guid\":_systemID}\n\t\t}\n\t\t# _element_set[\"classificationSystemId\"]={\"guid\":_systemID}\n\t\t\n\t\t_elementClassifications.append(_element_set)\n\n\tjson_def['parameters'] = {\"elementClassifications\":_elementClassifications}\n\n\t# result = connect(json_def,port)\n\t\n\treturn json_def\n\ndef GetElementsByClassification(port,_classificationID):\n\tjson_def = {\n    \"command\": \"API.GetElementsByClassification\",\n    \"parameters\": {\n        \"classificationItemId\": {\n            \"guid\": _classificationID\n\t        }\n\t    }\n\t}\n\tresult = connect(json_def,port)\n\tif result['succeeded']:\n\t\telements=[]\n\t\tfor el in result['result']['elements']:\n\t\t\t# pass\n\t\t\telements.append(el['elementId']['guid'])\n\t\treturn json.dumps(elements)\n\telse:\n\t\treturn False\ndef attributes_names():\n\tatt = [\n\t'BuildingMaterial',\n\t'Composite',\n\t'Fill',\n\t'Layer',\n\t'LayerCombination',\n\t'Line',\n\t'PenTable',\n\t'Profile',\n\t'Surface',\n\t'ZoneCategory'\n\t]\n\treturn att\ndef GetAttributes(att_type,guid):\n\n\tcommands = {\n\t'BuildingMaterial':\"API.GetBuildingMaterialAttributes\",\n\t'Composite':\"API.GetCompositeAttributes\",\n\t'Fill':\"API.GetFillAttributes\",\n\t'Layer':\"API.GetLayerAttributes\",\n\t'LayerCombination':\"API.GetLayerCombinationAttributes\",\n\t'Line':\"API.GetLineAttributes\",\n\t'PenTable':\"API.GetPenTableAttributes\",\n\t'Profile':\"API.GetProfileAttributes\",\n\t'Surface':\"API.GetSurfaceAttributes\",\n\t'ZoneCategory':\"API.GetZoneCategoryAttributes\"\n\t}\n\n\n\t_guids=[]\n\tif isinstance(guid,str) or isinstance(guid,unicode):\n\t\tguid = [guid]\n\n\n\tfor g in guid:\n\t\t_guids.append({\"attributeId\": {\"guid\": g}})\n\n\tatt_def= {\n    \"command\": commands[att_type],\n    \"parameters\": {\"attributeIds\": _guids}\n    # \"parameters\": {\"attributeIds\": [{\"attributeId\": {\"guid\": guid}}]}\n    }\n\treturn att_def\n\ndef GetAttributesByType(att_type,port):\n\n\n\tjson_def = {\n    \"command\": \"API.GetAttributesByType\",\n    \"parameters\": {\n        \"attributeType\": att_type\n    \t}\n\t}\n\tresult = connect(json_def,port)\n# \tresult = connect(json_def,port)\n\tids =[id['attributeId']['guid'] for id in result['result']['attributeIds']]\n\treturn ids\n\t# print ids\n# \tjs = GetAttributes(att_type,ids[0])\n# \tatt = connect(js,19723) \n\t\n\t# return att['result']['attributes'][0]\n\ndef getAttributeDetails(attr,port):\n\t_surface_guid = api.GetAttributesByType(attr,port)\n\tf = api.GetAttributes(attr,_surface_guid)\n\tresult = api.connect(f,port)\n\treturn result['result']\n\n\nif __name__ == '__main__':\n\n\t# print r\n\n\tfor attr in attributes_names():\n\t# attr = 'Fill'\n\t\tattrByType = GetAttributesByType(attr, 19723)\n\t\tc = GetAttributes(attr,attrByType[0])\n\t\tr=connect(c,19723)\n\t\tprint '-'*10 + attr\n\t\tprint r\n# \tj = {\n#     \"command\": \"API.GetAttributesByType\",\n#     \"parameters\": {\n#         \"attributeType\": \"Layer\"\n#     }\n# }\n# \tlayers=[]\n# \tr= connect(j,19723)\n# \tfor i in r['result']['attributeIds']:\n# \t\tlayers.append(i['attributeId']['guid'])\n# \ti = 0 \n# \tfor i in range(len(layers)):\n# \t\tf= {\n# \t    \"command\": \"API.GetLayerAttributes\",\n# \t    \"parameters\": {\n# \t        \"attributeIds\": [\n# \t            {\n# \t                \"attributeId\": {\n# \t                    \"guid\": layers[i]\n# \t                }\n# \t            }\n# \t        ]\n# \t    }\n# \t}\n# \t\trr =connect(f,19723)\n# \t\tprint rr['result']['attributes'][0]['layerAttribute']['name']\n \t# print prop\n# # class Wrap():\n# # \t\"\"\"\n# # \tWrap type and guid to an object to send it wherever\n# # \t\"\"\"\n# # \tdef __init__(self,typ,guid,value=None):\n# # \t\tself.Type = typ\n# # \t\tself.Guid = guid\n# # \t\tself.Value = value\n\n\n\t\n\n\n\n\n# # def get_element_type_guid(element):\n# # \t# if isinstance(element, str) ==False:\n# # \telement_dict = {element.Type:element.Guid}\n# # \treturn element_dict\n\n\n\n\n\n\n\n\n\n\n\n# # def userDefined_properties(Result):\n# # \tuserdefined_properies ={}\n# # \tgroups=[]\n# # \tproperties=[]\n# # \tfor i in Result['result']['properties']:\n# # \t\tif 'UserDefined' in i['type']:\n# # \t\t\tgroups.append(i['localizedName'][0])\n# # \t\t\tproperties.append(i['localizedName'][1])\n# # \t\t\t# print i['localizedName'][0],'  |  ',i['localizedName'][1]\n# # \tgroups = set(groups)\n# # \tgroups = list(groups)\n\n\n\n\n# # def builtIn_properties(Result):\n# # \tbuiltin_properties =[]\n# # \tfor i in Result['result']['properties']:\n# # \t\tif 'BuiltIn' in i['type']:\n# # \t\t\tbuiltin_properties.append(i['nonLocalizedName'])\n\n\n# # \ttyp = []\n# # \tfor j in builtin_properties:\n# # \t\ttyp.append(j.split('_')[0])\n# # \ttyp = list(set(typ))\n# # \ttyp.sort()\n\n# # \tbuiltin_types = {}\n# # \tfor _typ in typ:\n# # \t\tprops_of_type =[]\n# # \t\tfor prop in builtin_properties:\n# # \t\t\tif prop.split('_')[0] == _typ:\n# # \t\t\t\tprops_of_type.append(prop)\n# # \t\tbuiltin_types[_typ] = props_of_type\n\n# # \treturn builtin_types\n\n\n\n\n# # def inputNormalizer(elementInput):\n# # \t'''\n# # \tnormalise two kind of element inputs:\n# # \t1. AC_Type passed by contener node\n# # \t2. archicad_api Wrap class\n# # \t'''\n# # \tt = str(elementInput[0].Type)\n# # \tprint 't: ',t \n# # \tsplited = t.split('_')\n# # \tif len(splited) > 1:\n# # \t\tname = splited[1]\n# # \t\t_elements = [str(el.Guid).upper() for el in elementInput]\n# # \t\t# print 'contaner',_elements\n# # \t\treturn Wrap(name,_elements)\n# # \telse:\n# # \t\tname = splited[0]\n# # \t\t# _elements = [el.Guid for el in elementInput]\n# # \t\t_elements = elementInput[0].Guid\n# # \t\t# print 'wrap',_elements\n# # \t\treturn Wrap(name,_elements)\n\n\n\n\n\n# # def AddInputParam(name,desc='Description'):\n# #     param = kernel.Parameters.Param_String()\n# #     param.NickName = name\n# #     param.Name = name\n# #     param.Description = desc\n# #     param.Access = kernel.GH_ParamAccess.list\n# #     index = self.Params.Input.Count\n# #     self.Params.RegisterInputParam(param,index)\n# #     self.Params.OnParametersChanged()\n\n\n\n# # def AddOutputParam(name,desc='Description'):\n# #     param = kernel.Parameters.Param_String()\n# #     param.NickName = name\n# #     param.Name = name\n# #     param.Description = desc\n# #     param.Access = kernel.GH_ParamAccess.list\n# #     index = self.Params.Output.Count\n  \n# #     self.Params.RegisterOutputParam(param,index)\n# #     self.Params.OnParametersChanged()\n\n\n\t\n# \t\t",
  "language": "python",
  "imports": [
    "scriptcontext"
  ],
  "has_docstring": false
}