{
  "source_url": "https://github.com/Zayn997/rhinoJavis/blob/a2c74101392480de73337c406cb5a612fb711b9d/rhino_controller_async.py",
  "repo": "Zayn997/rhinoJavis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "rhino_controller_async.py",
  "instruction": "Async Rhino Viewport Controller - Non-Blocking\nUses Rhino's event system to avoid blocking the UI",
  "code": "\"\"\"\nAsync Rhino Viewport Controller - Non-Blocking\nUses Rhino's event system to avoid blocking the UI\n\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport scriptcontext as sc\nimport json\nimport socket\nimport System\nimport System.Threading as threading\n\n# Global controller instance\n_controller = None\n_timer = None\n\n\nclass GestureController:\n    \"\"\"Controls Rhino viewport based on gestures - non-blocking\"\"\"\n\n    def __init__(self):\n        self.current_zoom = 1.0\n        self.base_target = None\n        self.base_camera = None\n        self.base_camera_up = None\n        self.base_distance = 0\n        self.sock = None\n        self.buffer = \"\"\n        self.sensitivity = 1.0  # Degrees of head movement to degrees of camera rotation\n\n        # Get active viewport - will capture current position when connect() is called\n        self.view = sc.doc.Views.ActiveView\n        if not self.view:\n            print(\"No active viewport found!\")\n            return\n\n        print(\"Gesture Controller created\")\n        print(\"Active viewport: {0}\".format(self.view.ActiveViewport.Name))\n\n    def capture_base_position(self):\n        \"\"\"Capture current viewport camera as the base reference position\"\"\"\n        if not self.view:\n            return False\n\n        viewport = self.view.ActiveViewport\n        self.base_camera = Rhino.Geometry.Point3d(viewport.CameraLocation)\n        self.base_target = Rhino.Geometry.Point3d(viewport.CameraTarget)\n        self.base_camera_up = Rhino.Geometry.Vector3d(viewport.CameraUp)\n\n        # Calculate base distance\n        direction_vector = self.base_target - self.base_camera\n        self.base_distance = direction_vector.Length\n\n        print(\"Base position captured:\")\n        print(\"  Camera: {0}\".format(self.base_camera))\n        print(\"  Target: {0}\".format(self.base_target))\n        print(\"  Distance: {0:.2f}\".format(self.base_distance))\n        return True\n\n    def connect(self):\n        \"\"\"Connect to WebSocket server and capture current camera position\"\"\"\n        try:\n            # First, capture the current viewport position as base\n            if not self.capture_base_position():\n                print(\"Failed to capture base camera position!\")\n                return False\n\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.connect((\"localhost\", 8765))\n            self.sock.setblocking(False)  # Non-blocking mode\n\n            # Send WebSocket handshake\n            handshake = (\n                \"GET / HTTP/1.1\\r\\n\"\n                \"Host: localhost:8765\\r\\n\"\n                \"Upgrade: websocket\\r\\n\"\n                \"Connection: Upgrade\\r\\n\"\n                \"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\"\n                \"Sec-WebSocket-Version: 13\\r\\n\"\n                \"\\r\\n\"\n            )\n            self.sock.send(handshake.encode())\n\n            print(\"Connected to gesture server!\")\n            return True\n\n        except Exception as e:\n            print(\"Connection failed: {0}\".format(e))\n            return False\n\n    def check_messages(self):\n        \"\"\"Check for new messages - non-blocking\"\"\"\n        if not self.sock:\n            return\n\n        try:\n            # Try to receive data\n            data = self.sock.recv(4096)\n\n            if data:\n                # Add to buffer\n                text = data.decode(\"utf-8\", errors=\"ignore\")\n                self.buffer += text\n\n                # Try to extract JSON messages\n                while \"{\" in self.buffer and \"}\" in self.buffer:\n                    start = self.buffer.find(\"{\")\n                    end = self.buffer.find(\"}\", start)\n\n                    if end > start:\n                        json_text = self.buffer[start : end + 1]\n                        self.buffer = self.buffer[end + 1 :]  # Remove processed part\n\n                        try:\n                            message = json.loads(json_text)\n                            self.process_message(message)\n                        except:\n                            pass  # Invalid JSON, skip\n                    else:\n                        break\n\n        except socket.error:\n            # No data available (non-blocking socket)\n            pass\n        except Exception as e:\n            print(\"Error checking messages: {0}\".format(e))\n\n    def process_message(self, data):\n        \"\"\"Process gesture, head pose, and hand pan messages\"\"\"\n        try:\n            msg_type = data.get(\"type\", \"\")\n\n            if msg_type == \"gesture\":\n                gesture_name = data.get(\"gesture\", \"\")\n                if gesture_name:\n                    self.handle_gesture(gesture_name)\n\n            elif msg_type == \"head_pose\":\n                pitch = data.get(\"pitch\", 0)\n                yaw = data.get(\"yaw\", 0)\n                roll = data.get(\"roll\", 0)\n                self.rotate_viewport(pitch, yaw, roll)\n\n            elif msg_type == \"hand_pan\":\n                delta_x = data.get(\"delta_x\", 0)\n                delta_y = data.get(\"delta_y\", 0)\n                self.pan_viewport(delta_x, delta_y)\n\n        except Exception as e:\n            print(\"Error processing: {0}\".format(e))\n\n    def handle_gesture(self, gesture_name):\n        \"\"\"Handle gesture command\"\"\"\n        print(\"Gesture: {0}\".format(gesture_name))\n\n        viewport = self.view.ActiveViewport if self.view else None\n        if not viewport:\n            return\n\n        if gesture_name == \"thumbs up\":\n            self.current_zoom = min(3.0, self.current_zoom * 1.2)\n            self.apply_zoom(self.current_zoom)\n            print(\"  -> Zoom IN: {0:.2f}x\".format(self.current_zoom))\n\n        elif gesture_name == \"thumbs down\":\n            self.current_zoom = max(0.5, self.current_zoom * 0.8)\n            self.apply_zoom(self.current_zoom)\n            print(\"  -> Zoom OUT: {0:.2f}x\".format(self.current_zoom))\n\n        elif gesture_name == \"peace\":\n            self.reset_view()\n            print(\"  -> View RESET\")\n\n        elif gesture_name == \"okay\":\n            viewport.ZoomExtents()\n            sc.doc.Views.Redraw()\n            print(\"  -> Zoom EXTENTS\")\n\n        elif gesture_name == \"stop\":\n            self.current_zoom = 1.0\n            self.apply_zoom(1.0)\n            print(\"  -> STOP\")\n\n    def apply_zoom(self, zoom_factor):\n        \"\"\"Apply zoom\"\"\"\n        if not self.view or not self.base_distance:\n            return\n\n        viewport = self.view.ActiveViewport\n        target = viewport.CameraTarget\n        camera_loc = viewport.CameraLocation\n\n        new_distance = self.base_distance / zoom_factor\n        cam_direction = camera_loc - target\n        cam_direction.Unitize()\n\n        new_camera = target + cam_direction * new_distance\n        viewport.SetCameraLocations(target, new_camera)\n        sc.doc.Views.Redraw()\n\n    def rotate_viewport(self, pitch, yaw, roll):\n        \"\"\"\n        Rotate viewport based on ABSOLUTE head angles (not cumulative).\n        Your head angle directly controls camera orientation relative to base position.\n        \"\"\"\n        if not self.view or not self.base_camera:\n            return\n\n        viewport = self.view.ActiveViewport\n        target = viewport.CameraTarget\n\n        # Get current distance (preserve zoom)\n        current_cam = viewport.CameraLocation\n        current_dir = target - current_cam\n        distance = current_dir.Length\n\n        # Start from base camera orientation\n        base_direction = self.base_target - self.base_camera\n        base_direction.Unitize()\n\n        # Apply yaw rotation (left/right) around world Z-axis at target\n        # Positive yaw = head turns left = camera rotates left around target\n        yaw_rad = Rhino.RhinoMath.ToRadians(yaw * self.sensitivity)\n        yaw_transform = Rhino.Geometry.Transform.Rotation(\n            yaw_rad, Rhino.Geometry.Vector3d.ZAxis, self.base_target\n        )\n\n        # Create a point at base camera offset from target\n        new_camera = Rhino.Geometry.Point3d(self.base_camera)\n        new_camera.Transform(yaw_transform)\n\n        # Now apply pitch rotation (up/down) around the horizontal right axis\n        # Compute right vector perpendicular to camera direction and world Z\n        temp_dir = new_camera - self.base_target\n        temp_dir.Unitize()\n        camera_right = Rhino.Geometry.Vector3d.CrossProduct(\n            Rhino.Geometry.Vector3d.ZAxis, temp_dir\n        )\n        camera_right.Unitize()\n\n        # Positive pitch = head tilts up = camera rotates down (look up)\n        pitch_rad = Rhino.RhinoMath.ToRadians(-pitch * self.sensitivity)\n        pitch_transform = Rhino.Geometry.Transform.Rotation(\n            pitch_rad, camera_right, self.base_target\n        )\n\n        new_camera.Transform(pitch_transform)\n\n        # Adjust distance to preserve zoom\n        final_dir = new_camera - target\n        final_dir.Unitize()\n        final_camera = target + final_dir * distance\n\n        # Update viewport\n        viewport.SetCameraLocations(target, final_camera)\n        sc.doc.Views.Redraw()\n\n    def pan_viewport(self, delta_x, delta_y):\n        \"\"\"\n        Pan viewport based on hand movement by moving the target.\n        Camera stays in place, only target moves.\n        delta_x: horizontal movement (-100 to +100, positive = right)\n        delta_y: vertical movement (-100 to +100, positive = down)\n        \"\"\"\n        if not self.view:\n            return\n\n        viewport = self.view.ActiveViewport\n        camera = viewport.CameraLocation\n        target = viewport.CameraTarget\n\n        # Get camera coordinate system\n        cam_dir = target - camera\n        cam_dir.Unitize()\n\n        # Right vector (perpendicular to camera direction and world Z)\n        cam_right = Rhino.Geometry.Vector3d.CrossProduct(\n            Rhino.Geometry.Vector3d.ZAxis, cam_dir\n        )\n        cam_right.Unitize()\n\n        # Up vector (perpendicular to camera direction and right)\n        cam_up = Rhino.Geometry.Vector3d.CrossProduct(cam_dir, cam_right)\n        cam_up.Unitize()\n\n        # Pan sensitivity (scale factor based on view distance)\n        distance = cam_dir.Length if cam_dir.Length > 0 else (target - camera).Length\n        pan_scale = (\n            distance * 4.0\n        )  # Increased from 0.001 to 0.02 for bigger movement (20x more sensitive)\n\n        # Calculate pan offset\n        # Right: positive delta_x = move right\n        # Up: negative delta_y = move up (screen Y is inverted)\n        pan_offset = cam_right * (delta_x * pan_scale) + cam_up * (-delta_y * pan_scale)\n\n        # Apply pan to TARGET ONLY (camera stays in place)\n        new_target = target + pan_offset\n\n        # Update viewport - camera stays at original position\n        viewport.SetCameraLocations(new_target, camera)\n        sc.doc.Views.Redraw()\n\n    def reset_view(self):\n        \"\"\"Reset view to initial position and zoom\"\"\"\n        if not self.view or not self.base_camera:\n            return\n\n        viewport = self.view.ActiveViewport\n        viewport.SetCameraLocations(self.base_target, self.base_camera)\n        if self.base_camera_up:\n            viewport.CameraUp = self.base_camera_up\n        self.current_zoom = 1.0\n        sc.doc.Views.Redraw()\n        print(\"View reset to initial position\")\n\n    def close(self):\n        \"\"\"Close connection\"\"\"\n        if self.sock:\n            try:\n                self.sock.close()\n            except:\n                pass\n        print(\"Connection closed\")\n\n\ndef on_timer(sender, e):\n    \"\"\"Timer callback - checks for messages periodically\"\"\"\n    global _controller\n\n    if _controller:\n        _controller.check_messages()\n\n\ndef start_gesture_control():\n    \"\"\"Start gesture control - non-blocking\"\"\"\n    global _controller, _timer\n\n    print(\"=\" * 60)\n    print(\"Starting Gesture Control (Non-Blocking)\")\n    print(\"=\" * 60)\n\n    # Create controller\n    _controller = GestureController()\n\n    if not _controller.connect():\n        print(\"\\nFailed to connect!\")\n        print(\"Make sure 'python main.py' is running!\\n\")\n        return False\n\n    print(\"\\nListening for gestures...\")\n    print(\"Rhino will remain responsive!\")\n    print(\"Run 'StopGestureControl()' to stop\\n\")\n\n    # Create timer - checks for messages every 100ms\n    _timer = System.Windows.Forms.Timer()\n    _timer.Interval = 100  # milliseconds\n    _timer.Tick += on_timer\n    _timer.Start()\n\n    return True\n\n\ndef stop_gesture_control():\n    \"\"\"Stop gesture control\"\"\"\n    global _controller, _timer\n\n    if _timer:\n        _timer.Stop()\n        _timer.Dispose()\n        _timer = None\n\n    if _controller:\n        _controller.close()\n        _controller = None\n\n    print(\"Gesture control stopped\")\n\n\n# Auto-start when script runs\nif __name__ == \"__main__\" or __name__ == \"<module>\":\n    start_gesture_control()\n\n    print(\"\\nTo stop, run: stop_gesture_control()\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}