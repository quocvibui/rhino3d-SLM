{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_penetration_generator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_penetration_generator.py",
  "instruction": "Penetration Generator for Grasshopper.",
  "code": "# File: scripts/gh_penetration_generator.py\n\"\"\"Penetration Generator for Grasshopper.\n\nGenerates penetration specifications for pipes passing through framing.\nThis is the third step in the MEP integration pipeline.\n\nKey Features:\n1. Penetration Detection\n   - Finds where pipe routes cross framing members (studs)\n   - Calculates intersection points\n\n2. Code Compliance\n   - Checks penetration size against member depth limits\n   - Flags oversized penetrations with warnings\n   - Identifies where reinforcement is required\n\n3. Geometry Output\n   - Creates circles representing hole locations\n   - Uses RhinoCommonFactory for proper assembly compatibility\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry creation\n    - Grasshopper: Component framework\n    - timber_framing_generator.mep.plumbing: Penetration generation logic\n    - timber_framing_generator.utils.geometry_factory: RhinoCommon geometry\n\nInput Requirements:\n    routes_json (routes_json) - str:\n        JSON from Pipe Router\n        Required: Yes\n        Access: Item\n\n    elements_json (elements_json) - str:\n        JSON with framing elements (from Framing Generator)\n        Required: Yes\n        Access: Item\n\n    run (run) - bool:\n        Execute toggle\n        Required: Yes\n        Access: Item\n\nOutputs:\n    penetrations_json (json) - str:\n        JSON with penetration specifications\n\n    penetration_points (pts) - list of Point3d:\n        Point3d at each penetration center\n\n    penetration_circles (circles) - list of Curves:\n        Circle curves representing holes\n\n    warnings (warnings) - list of str:\n        List of warning messages for problematic penetrations\n\n    debug_info (info) - str:\n        Processing summary and diagnostics\n\nAuthor: Claude AI Assistant\nVersion: 1.1.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport math\nimport traceback\n\n# Force reload of project modules (development only)\nFORCE_RELOAD = True\nif FORCE_RELOAD:\n    modules_to_reload = [k for k in sys.modules.keys()\n                         if 'timber_framing_generator' in k]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Penetration Generator\"\nCOMPONENT_NICKNAME = \"PenGen\"\nCOMPONENT_MESSAGE = \"v1.1\"\n\n# Project path\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\n# =============================================================================\n# Project Imports\n# =============================================================================\n\ntry:\n    from src.timber_framing_generator.mep.plumbing import generate_plumbing_penetrations\n    from src.timber_framing_generator.core import MEPRoute\n    from src.timber_framing_generator.utils.geometry_factory import get_factory\n    PROJECT_AVAILABLE = True\n    PROJECT_ERROR = None\nexcept ImportError as e:\n    PROJECT_AVAILABLE = False\n    PROJECT_ERROR = str(e)\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_info(message):\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs():\n    \"\"\"Validate component inputs.\"\"\"\n    if not PROJECT_AVAILABLE:\n        return False, f\"Project import error: {PROJECT_ERROR}\"\n\n    if not run:\n        return False, \"Toggle 'run' to True to execute\"\n\n    if not routes_json:\n        return False, \"No routes_json provided (connect from Pipe Router)\"\n\n    if not elements_json:\n        return False, \"No elements_json provided (connect from Framing Generator)\"\n\n    return True, None\n\n\ndef parse_routes(routes_json_str):\n    \"\"\"Parse routes from JSON string.\n\n    Returns:\n        tuple: (routes list, error message or None)\n    \"\"\"\n    try:\n        data = json.loads(routes_json_str)\n        route_list = data.get(\"routes\", [])\n\n        routes = []\n        for route_dict in route_list:\n            route = MEPRoute.from_dict(route_dict)\n            routes.append(route)\n\n        return routes, None\n    except json.JSONDecodeError as e:\n        return [], f\"JSON parse error: {e}\"\n    except Exception as e:\n        return [], f\"Error parsing routes: {e}\"\n\n\ndef extract_framing_elements(framing_data):\n    \"\"\"Extract framing elements from various JSON structures.\"\"\"\n    if isinstance(framing_data, list):\n        return framing_data\n\n    if isinstance(framing_data, dict):\n        if \"elements\" in framing_data:\n            return framing_data[\"elements\"]\n        if \"results\" in framing_data:\n            results = framing_data[\"results\"]\n            if isinstance(results, dict) and \"elements\" in results:\n                return results[\"elements\"]\n        if \"framing_elements\" in framing_data:\n            return framing_data[\"framing_elements\"]\n\n    return []\n\n\ndef create_penetration_geometry(penetrations, factory):\n    \"\"\"Create penetration points and circles using RhinoCommonFactory.\n\n    Args:\n        penetrations: List of penetration dictionaries\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        tuple: (points, circles) lists\n    \"\"\"\n    points = []\n    circles = []\n\n    for pen in penetrations:\n        loc = pen.get(\"location\", {})\n        diameter = pen.get(\"diameter\", 0.0833)\n\n        # Create point at penetration center\n        pt = factory.create_point3d(\n            loc.get(\"x\", 0),\n            loc.get(\"y\", 0),\n            loc.get(\"z\", 0)\n        )\n        points.append(pt)\n\n        # Create circle representing hole\n        # Circle in vertical plane (XZ plane, facing along Y)\n        radius = diameter / 2\n        circle = factory.create_circle(\n            center=(loc.get(\"x\", 0), loc.get(\"y\", 0), loc.get(\"z\", 0)),\n            radius=radius,\n            normal=(0, 1, 0)  # Facing along Y axis\n        )\n        if circle is not None:\n            circles.append(circle)\n\n    return points, circles\n\n\ndef collect_warnings(penetrations):\n    \"\"\"Collect warning messages from penetrations.\"\"\"\n    warnings = []\n\n    for pen in penetrations:\n        element_id = pen.get(\"element_id\", \"unknown\")\n\n        if not pen.get(\"is_allowed\", True):\n            warning_msg = pen.get(\"warning\", \"Penetration exceeds code limits\")\n            warnings.append(f\"{element_id}: {warning_msg}\")\n\n        elif pen.get(\"reinforcement_required\", False):\n            ratio = pen.get(\"penetration_ratio\", 0) * 100\n            warnings.append(f\"{element_id}: Reinforcement recommended ({ratio:.1f}% of depth)\")\n\n    return warnings\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize outputs\n    penetrations_json = \"{}\"\n    penetration_points = []\n    penetration_circles = []\n    warnings_list = []\n    debug_lines = []\n\n    debug_lines.append(\"=\" * 50)\n    debug_lines.append(\"PENETRATION GENERATOR\")\n    debug_lines.append(\"=\" * 50)\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs()\n        if not is_valid:\n            debug_lines.append(error_msg)\n            return penetrations_json, penetration_points, penetration_circles, warnings_list, \"\\n\".join(debug_lines)\n\n        # Parse routes\n        routes, parse_error = parse_routes(routes_json)\n        if parse_error:\n            debug_lines.append(parse_error)\n            return penetrations_json, penetration_points, penetration_circles, warnings_list, \"\\n\".join(debug_lines)\n\n        debug_lines.append(f\"Input routes: {len(routes)}\")\n\n        if not routes:\n            debug_lines.append(\"No routes in JSON data\")\n            return penetrations_json, penetration_points, penetration_circles, warnings_list, \"\\n\".join(debug_lines)\n\n        # Parse framing elements\n        try:\n            framing_data = json.loads(elements_json)\n            framing_elements = extract_framing_elements(framing_data)\n            debug_lines.append(f\"Input framing elements: {len(framing_elements)}\")\n        except json.JSONDecodeError as e:\n            debug_lines.append(f\"ERROR parsing elements_json: {e}\")\n            return penetrations_json, penetration_points, penetration_circles, warnings_list, \"\\n\".join(debug_lines)\n\n        # Generate penetrations\n        debug_lines.append(\"\")\n        debug_lines.append(\"Generating penetrations...\")\n\n        penetrations = generate_plumbing_penetrations(routes, framing_elements)\n        debug_lines.append(f\"Generated {len(penetrations)} penetrations\")\n\n        if not penetrations:\n            debug_lines.append(\"No penetrations generated\")\n            debug_lines.append(\"Routes may not cross any framing members\")\n\n        # Analyze penetrations\n        allowed_count = sum(1 for p in penetrations if p.get(\"is_allowed\", True))\n        disallowed_count = len(penetrations) - allowed_count\n        reinforcement_count = sum(1 for p in penetrations if p.get(\"reinforcement_required\", False))\n\n        debug_lines.append(\"\")\n        debug_lines.append(\"Penetration summary:\")\n        debug_lines.append(f\"  Total penetrations: {len(penetrations)}\")\n        debug_lines.append(f\"  Code-compliant: {allowed_count}\")\n        debug_lines.append(f\"  Requires review: {disallowed_count}\")\n        debug_lines.append(f\"  Reinforcement needed: {reinforcement_count}\")\n\n        # Collect warnings\n        warnings_list = collect_warnings(penetrations)\n\n        if warnings_list:\n            debug_lines.append(\"\")\n            debug_lines.append(f\"Warnings ({len(warnings_list)}):\")\n            for w in warnings_list[:5]:\n                debug_lines.append(f\"  - {w}\")\n            if len(warnings_list) > 5:\n                debug_lines.append(f\"  ... and {len(warnings_list) - 5} more\")\n\n        # Build JSON output\n        output_data = {\n            \"penetrations\": penetrations,\n            \"count\": len(penetrations),\n            \"allowed_count\": allowed_count,\n            \"disallowed_count\": disallowed_count,\n            \"reinforcement_count\": reinforcement_count,\n            \"source\": \"gh_penetration_generator\",\n        }\n        penetrations_json = json.dumps(output_data, indent=2)\n\n        # Create geometry using RhinoCommonFactory\n        factory = get_factory()\n        penetration_points, penetration_circles = create_penetration_geometry(penetrations, factory)\n\n        debug_lines.append(\"\")\n        debug_lines.append(f\"Created {len(penetration_points)} visualization points\")\n        debug_lines.append(f\"Created {len(penetration_circles)} hole circles\")\n\n        # Summary\n        debug_lines.append(\"\")\n        debug_lines.append(\"=\" * 50)\n        debug_lines.append(\"PENETRATION GENERATION COMPLETE\")\n        debug_lines.append(f\"Total penetrations: {len(penetrations)}\")\n        debug_lines.append(f\"Code-compliant: {allowed_count}\")\n        debug_lines.append(f\"Warnings: {len(warnings_list)}\")\n        debug_lines.append(\"=\" * 50)\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return penetrations_json, penetration_points, penetration_circles, warnings_list, \"\\n\".join(debug_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Define default input values if not provided by Grasshopper\nif 'run' not in dir():\n    run = False\n\nif 'routes_json' not in dir():\n    routes_json = \"\"\n\nif 'elements_json' not in dir():\n    elements_json = \"\"\n\n# Execute main and assign to output variables\npenetrations_json, penetration_points, penetration_circles, warnings, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}