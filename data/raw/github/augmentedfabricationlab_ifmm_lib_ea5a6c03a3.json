{
  "source_url": "https://github.com/augmentedfabricationlab/ifmm_lib/blob/1cc6e87f5b07e0d6bd144f8f24462cc0d0a70fdb/mmmesh/node_robobend.py",
  "repo": "augmentedfabricationlab/ifmm_lib",
  "repo_stars": 0,
  "repo_description": "In situ Fabricatr & Mesh Mould @ EMPA Nest 2017",
  "license": "unknown",
  "filepath": "mmmesh/node_robobend.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<  <<><><>  <<      ><  <<      ><   .\n.   <<  <<       < ><   ><<  < ><   ><<   .\n.   <<  <<><><>  << >< > ><  << >< > ><   .  \n.   <<  <<       <<  ><  ><  <<  ><  ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.   <<  <<       <<      ><  <<      ><   .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 02.11.2016\n\n@author: kathrind\n'''\n\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport math as m\nimport random\n\nclass Node:\n    \n    def __init__(self, node_type, layer_type, index_row, index_layer_list):\n        \n        self.node_type = node_type # can be \"exterior_srf1\", \"exterior_srf2\", \"interior\"\n        self.layer_type = layer_type\n        \n        self.index_row = index_row\n        self.index_col = None \n        self.index = None\n        self.index_layer_list = index_layer_list #position in one layer\n        \n        self.is_built = False\n        \n        self.plane_wrist = None # is also the plane to drive to, if no discrete element is inserted\n        #self.wrist_plane_for_inserting_tilted = None\n        self.plane_for_inserting = None\n        self.plane_for_bending = None\n        \n        self.absolute_bending_angle = 0\n        \n        self.axis = None # vector of continuous element\n        self.line_continuous_element = None # line of the element in the continuousdirection (= vertical direction)\n        \n        self.insert_discrete_element = False #if node has a discrete element to insert\n        self.line_discrete_element = None\n        \n        self.intersect_line_cont_disc = None\n        \n        self.collision = False\n        self.collision_geo = None\n        \n        # for the line estimation by the endeffector cameras\n        self.neighbor_node_for_est_01 = None \n        self.neighbor_node_for_est_02 = None\n        \n        #self.estimated_lines_in_cam_frame = []\n        self.lines_for_estimation_WCS = []\n        \n        self.estimate_with_eeff_cam = False\n        self.estimation_type = 0 # 1: front discrete wire, 2: back discrete wire, 3: match both wires\n        \n        self.estimated_lines_CCS = []\n        self.estimated_lines_WCS = []\n        \n        ### for comparison purposes\n        self.estimated_lines_WCS_after_corr = []\n        \n        ### just for testing purposes\n        #self.base_state_estimation_plane = None\n        \n        #self.estimated_lines_in_cam_frame_mtip = []\n        #self.estimated_lines_global_mtip = []\n        \n        #self.estimated_lines_global_before_corr = []\n        #self.estimated_lines_global_after_corr = []\n        #self.T_est_exp = None\n        \n        self.color = ghcomp.ColourRGB(100, 0, 0, 0)\n        \n        self.corr_val = 0\n        self.plane_for_inserting_corr = None\n        self.plane_for_bending_corr = None\n    \n    def set_built_state(self, built_state):\n        self.is_built = built_state\n    \n    def set_index(self, index):\n        self.index = index\n    \n    def set_index_col(self, index_col):\n        self.index_col = index_col\n    \n    def get_line_geo_with_colors(self):\n        geo = []\n        colors = []\n        if self.line_discrete_element: \n            geo.append(self.line_discrete_element)\n            colors.append(self.color)\n        if self.line_continuous_element: \n            geo.append(self.line_continuous_element)\n            colors.append(self.color)\n        \n        return geo, colors\n    \n    def get_line_geo(self):        \n        if self.line_discrete_element and self.line_continuous_element:\n            return [self.line_discrete_element, self.line_continuous_element]\n        elif self.line_discrete_element and self.line_continuous_element == None:\n            return [self.line_discrete_element]\n        elif self.line_discrete_element == None and self.line_continuous_element:\n            return [self.line_continuous_element]\n        else:\n            return []\n        \n    def fill_params(self, plane_wrist, axis = None, insert_discrete_element = False, plane_for_inserting = None, line_discrete_element = None, intersect_line_cont_disc = None):         \n        self.plane_wrist = plane_wrist\n        self.axis = axis\n        self.insert_discrete_element = insert_discrete_element\n        self.plane_for_inserting = plane_for_inserting  \n        self.line_discrete_element = line_discrete_element\n        self.intersect_line_cont_disc = intersect_line_cont_disc\n    \n    def get_lines_for_estimation_CCS(self, cam_plane_trfd_global, return_as_lines = False):\n        ''' this method returns the lines for the line estimation with the endeffector cameras in the camera frame\n        if return_as_lines = True > return the data as lines, otherwise as a list of 3*6 (= 18) floats\n        line 1 = line_c = line from discrete element 01 startpt to discrete element 02 startpt (= continuous element)\n        line 2 = line_d1 = line of discrete element 01 (= discrete element in front)\n        line 3 = line_d2 = line of discrete element 02 (= discrete element in the back)\n        '''\n        \n        lines_for_est_WCS = self.lines_for_estimation_WCS #[line_c, line_d_front, line_d_back]\n        line_c_WCS, line_d_front_WCS, line_d_back_WCS = lines_for_est_WCS\n        \n        T_from_world_to_cam = rg.Transform.ChangeBasis(rg.Plane.WorldXY, cam_plane_trfd_global)\n        lines_for_est_in_cam_frame = ghcomp.Transform(lines_for_est_WCS, T_from_world_to_cam)\n        \n        if return_as_lines:\n            return lines_for_est_in_cam_frame\n        \n        else:\n            \n            if line_d_front_WCS and line_d_back_WCS:\n                #node.estimation_type = 2\n            \n                l1, l2, l3 = lines_for_est_in_cam_frame\n                l1_values = [l1.FromX, l1.FromY, l1.FromZ, l1.ToX, l1.ToY, l1.ToZ] \n                l2_values = [l2.FromX, l2.FromY, l2.FromZ, l2.ToX, l2.ToY, l2.ToZ] #if l2 else [-1 for i in range(6)]\n                l3_values = [l3.FromX, l3.FromY, l3.FromZ, l3.ToX, l3.ToY, l3.ToZ] #if l3 else [-1 for i in range(6)]\n                l = l1_values + l2_values + l3_values\n            \n            elif line_d_front_WCS and line_d_back_WCS == None:\n                #node.estimation_type = 1\n                lc, ld = ghcomp.Transform([line_c_WCS, line_d_front_WCS], T_from_world_to_cam)\n                lc_values = [lc.FromX, lc.FromY, lc.FromZ, lc.ToX, lc.ToY, lc.ToZ] \n                ld_values = [ld.FromX, ld.FromY, ld.FromZ, ld.ToX, ld.ToY, ld.ToZ]\n                lempty_values = [-1 for i in range(6)]\n                \n                l = lc_values + ld_values + lempty_values\n\n                \n            elif line_d_front_WCS == None and line_d_back_WCS:\n                #node.estimation_type = 27\n                \n                lc, ld = ghcomp.Transform([line_c_WCS, line_d_back_WCS], T_from_world_to_cam)\n                lc_values = [lc.FromX, lc.FromY, lc.FromZ, lc.ToX, lc.ToY, lc.ToZ] \n                ld_values = [ld.FromX, ld.FromY, ld.FromZ, ld.ToX, ld.ToY, ld.ToZ]\n                lempty_values = [-1 for i in range(6)]\n                \n                l = lc_values + lempty_values + ld_values\n            \n            return [v/1000 for v in l]\n    \n    def get_sim_est_values_CCS(self, cam_plane_trfd_WCS, rval = 0.1, with_random = True):\n        \"\"\" just for testing the calculation of the line estimation\"\"\"\n        \n        line_c_CCS, line_d_front_CCS, line_d_back_CCS = self.get_lines_for_estimation_CCS(cam_plane_trfd_WCS, return_as_lines = True)\n        \n        m0_x, m0_y, m0_z = (line_c_CCS.PointAt(0.5).X, line_c_CCS.PointAt(0.5).Y, line_c_CCS.PointAt(0.5).Z)\n        v0 = line_c_CCS.Direction\n        v0.Unitize()\n        v0_x, v0_y, v0_z = v0\n        \n        if line_d_back_CCS:\n            m1_x, m1_y, m1_z = (line_d_back_CCS.PointAt(0.5).X, line_d_back_CCS.PointAt(0.5).Y, line_d_back_CCS.PointAt(0.5).Z)\n            v1 = line_d_back_CCS.Direction\n        else:\n            m1_x, m1_y, m1_z = (line_d_front_CCS.PointAt(0.5).X, line_d_front_CCS.PointAt(0.5).Y, line_d_front_CCS.PointAt(0.5).Z)\n            v1 = line_d_front_CCS.Direction\n        \n        v1.Unitize()\n        v1_x, v1_y, v1_z = v1    \n        \n        m2_x, m2_y, m2_z, v2_x, v2_y, v2_z = (-1,-1,-1,-1,-1,-1)\n        \n        if with_random: \n            rvec = rg.Vector3d(random.uniform(-rval,rval), random.uniform(-rval,rval), random.uniform(-rval,rval))\n            m0_x, m0_y, m0_z = rg.Point3d(m0_x, m0_y, m0_z) + rvec\n            m1_x, m1_y, m1_z = rg.Point3d(m1_x, m1_y, m1_z) + rvec\n\n        \n        line_est_values = m0_x, m0_y, m0_z, v0_x, v0_y, v0_z, m1_x, m1_y, m1_z, v1_x, v1_y, v1_z, m2_x, m2_y, m2_z, v2_x, v2_y, v2_z\n        \n        #if with_random:\n        #    line_est_values = [v+random.uniform(-rval,rval) for v in line_est_values]\n            \n        return line_est_values\n    \n    def get_lines_from_estimation_values_CCS(self, line_est_values):\n        \"\"\" return the lines from the estimation values from the tool vision system \n        m0: midpoint of the estimated continuous wire\n        v0: vector unitized of the estimated continuous wire\n        m1: midpoint of the estimated discrete wire (front or back, according to the estimation type)\n        v1: vector of the estimated discrete wire (front or back, according to the estimation type)\n        \"\"\"\n        \n        m0_x, m0_y, m0_z, v0_x, v0_y, v0_z, m1_x, m1_y, m1_z, v1_x, v1_y, v1_z, m2_x, m2_y, m2_z, v2_x, v2_y, v2_z  = line_est_values\n        len_c = self.lines_for_estimation_WCS[0].Length/2\n        len_d = self.lines_for_estimation_WCS[1].Length/2 if self.lines_for_estimation_WCS[1] else self.lines_for_estimation_WCS[2].Length/2\n        \n        cont_line_pt_mid = rg.Point3d(m0_x, m0_y, m0_z)\n        cont_line_vec = rg.Vector3d(v0_x, v0_y, v0_z)\n        cont_line_pt_from = cont_line_pt_mid - cont_line_vec * len_c\n        cont_line_pt_to = cont_line_pt_mid + cont_line_vec * len_c\n        cont_line_in_cam_frame = rg.Line(cont_line_pt_from, cont_line_pt_to)\n        \n        discrete_line_pt_mid = rg.Point3d(m1_x, m1_y, m1_z)\n        discrete_line_vec = rg.Vector3d(v1_x, v1_y, v1_z)\n        discrete_line_pt_from = discrete_line_pt_mid - discrete_line_vec * len_d\n        discrete_line_pt_to = discrete_line_pt_mid + discrete_line_vec * len_d\n        discrete_line_in_cam_frame = rg.Line(discrete_line_pt_from, discrete_line_pt_to)\n        \n        self.estimated_lines_CCS = [cont_line_in_cam_frame, discrete_line_in_cam_frame]\n        \n        return [cont_line_in_cam_frame, discrete_line_in_cam_frame]\n    \n    def get_lines_from_estimation_values_WCS(self, line_est_values, cam_plane_trfd_WCS):\n        \"\"\" return the lines from the estimation values from the tool vision system \n        in the world coordinate system\n        \"\"\"\n          \n        estimated_lines_CCS = self.get_lines_from_estimation_values_CCS(line_est_values)\n        \n        T_C_W = rg.Transform.ChangeBasis(cam_plane_trfd_WCS, rg.Plane.WorldXY)\n        self.estimated_lines_WCS = ghcomp.Transform(estimated_lines_CCS, T_C_W)\n        \n        return self.estimated_lines_WCS\n    \n    def get_corr_val(self, thresh_val=15):\n        \n        T_proj = rg.Transform.PlanarProjection(self.plane_for_inserting)\n        T_in_zero = rg.Transform.PlaneToPlane(self.plane_for_inserting, rg.Plane.WorldXY)\n        \n        mpoint_estimated_line_WCS = self.estimated_lines_WCS[0].PointAt(0.5)\n        mpoint_expected_line_WCS = self.lines_for_estimation_WCS[0].PointAt(0.5)\n        \n        l = rg.Line(mpoint_expected_line_WCS, mpoint_estimated_line_WCS)\n        l_proj = ghcomp.Transform(l, T_proj)\n\n        l_in_zero = ghcomp.Transform(l_proj, T_in_zero)\n        vec_in_zero = l_in_zero.Direction\n        \n        corr_val = vec_in_zero[1] * -1\n        \n        if corr_val > thresh_val:\n            corr_val = thresh_val\n        if corr_val < -thresh_val:\n            corr_val = -thresh_val\n        \n        self.corr_val = corr_val\n        \n        return corr_val, l_proj, l_in_zero\n    \n    def get_corr_planes(self, corr_val):\n         \n        self.plane_for_inserting_corr = rg.Plane(self.plane_for_inserting)\n        self.plane_for_bending_corr = rg.Plane(self.plane_for_bending) if self.plane_for_bending else self.plane_wrist\n        \n        \n        T_corr_i = rg.Transform.Translation(self.plane_for_inserting_corr.YAxis*corr_val)\n        T_corr_b = rg.Transform.Translation(self.plane_for_bending_corr.YAxis*corr_val)\n        self.plane_for_inserting_corr.Transform(T_corr_i)\n        self.plane_for_bending_corr.Transform(T_corr_b)\n        \n        return self.plane_for_inserting_corr, self.plane_for_bending_corr\n    \n    \"\"\"\n    def get_lines_from_estimation_values_in_cam_frame_old(self, line_est_values, lines_for_est_global):\n        \n        m0_x, m0_y, m0_z, v0_x, v0_y, v0_z, m1_x, m1_y, m1_z, v1_x, v1_y, v1_z, m2_x, m2_y, m2_z, v2_x, v2_y, v2_z  = line_est_values\n    \n        cont_line_pt_mid = rg.Point3d(m0_x, m0_y, m0_z)\n        cont_line_vec = rg.Vector3d(v0_x, v0_y, v0_z)\n        cont_line_pt_from = cont_line_pt_mid - cont_line_vec * lines_for_est_global[0].Length/2\n        cont_line_pt_to = cont_line_pt_mid + cont_line_vec * lines_for_est_global[0].Length/2\n        cont_line_in_cam_frame = rg.Line(cont_line_pt_from, cont_line_pt_to)\n        \n        discrete_line_pt_mid = rg.Point3d(m1_x, m1_y, m1_z)\n        discrete_line_vec = rg.Vector3d(v1_x, v1_y, v1_z)\n        discrete_line_pt_from = discrete_line_pt_mid - discrete_line_vec * lines_for_est_global[1].Length/2\n        discrete_line_pt_to = discrete_line_pt_mid + discrete_line_vec * lines_for_est_global[1].Length/2\n        discrete_line_in_cam_frame = rg.Line(discrete_line_pt_from, discrete_line_pt_to)\n        \n        self.estimated_lines_in_cam_frame = [cont_line_in_cam_frame, discrete_line_in_cam_frame]\n        \n        return self.estimated_lines_in_cam_frame\n    \"\"\"\n\n    \"\"\"    \n    def get_neighbor_data_for_est_global_old(self):\n        ''' this method returns the lines for the line estimation with the endeffector cameras\n        line 1 = line_c = line from discrete element 01 startpt to discrete element 02 startpt (= continuous element)\n        line 2 = line_d1 = line of discrete element 01 (= discrete element in front)\n        line 3 = line_d2 = line of discrete element 02 (= discrete element in the back)\n        '''\n        \n        if self.neighbor_node_for_est_01 or self.neighbor_node_for_est_02:\n            \n            if self.neighbor_node_for_est_01 and self.neighbor_node_for_est_02:\n                line_d1 = self.neighbor_node_for_est_01.line_discrete_element\n                line_d2 = self.neighbor_node_for_est_02.line_discrete_element\n                line_c = rg.Line(line_d1.From, line_d2.From)\n            elif self.neighbor_node_for_est_01 and self.neighbor_node_for_est_02 == None:\n                #print \"HELLO 1\"\n                line_d1 = self.neighbor_node_for_est_01.line_discrete_element\n                line_d2 = None #self.neighbor_node_for_est_01.line_discrete_element # \n                line_c = rg.Line(line_d1.From, self.line_discrete_element.To)\n            elif self.neighbor_node_for_est_01 == None and self.neighbor_node_for_est_02:\n                #print \"HELLO 2\"\n                line_d1 = None #self.neighbor_node_for_est_02.line_discrete_element # \n                line_d2 = self.neighbor_node_for_est_02.line_discrete_element\n                line_c = rg.Line(self.line_discrete_element.To, line_d2.From)\n\n        return [line_c, line_d1, line_d2]\n    \"\"\"\n    \n    \"\"\"\n    def get_neighbor_data_for_est_in_cam_frame_old(self, cam_plane_trfd_global, return_as_lines = False):\n        ''' this method returns the lines for the line estimation with the endeffector cameras in the camera frame\n        if return_as_lines = True > return the data as lines, otherwise as a list of 3*6 (= 18) floats\n        line 1 = line_c = line from discrete element 01 startpt to discrete element 02 startpt (= continuous element)\n        line 2 = line_d1 = line of discrete element 01 (= discrete element in front)\n        line 3 = line_d2 = line of discrete element 02 (= discrete element in the back)\n        '''\n        \n        lines_for_est_global = self.get_neighbor_data_for_est_global()\n        \n        #print len(lines_for_est_global)\n        #print lines_for_est_global\n        \n        T_from_world_to_cam = rg.Transform.ChangeBasis(rg.Plane.WorldXY, cam_plane_trfd_global)\n        lines_for_est_in_cam_frame = ghcomp.Transform(lines_for_est_global, T_from_world_to_cam)\n        #wire_for_estimation_in_cam_frame = \n        \n        if return_as_lines:\n            return lines_for_est_in_cam_frame\n        \n        else:\n            \n            if len(lines_for_est_in_cam_frame) == 3:\n            \n                l1, l2, l3 = lines_for_est_in_cam_frame\n                l1_values = [l1.FromX, l1.FromY, l1.FromZ, l1.ToX, l1.ToY, l1.ToZ] \n                l2_values = [l2.FromX, l2.FromY, l2.FromZ, l2.ToX, l2.ToY, l2.ToZ] #if l2 else [-1 for i in range(6)]\n                l3_values = [l3.FromX, l3.FromY, l3.FromZ, l3.ToX, l3.ToY, l3.ToZ] #if l3 else [-1 for i in range(6)]\n                l = l1_values + l2_values + l3_values\n                \n                return [v/1000 for v in l]\n            \n            else:\n                l1, l2 = lines_for_est_in_cam_frame\n                l1_values = [l1.FromX, l1.FromY, l1.FromZ, l1.ToX, l1.ToY, l1.ToZ] \n                l2_values = [l2.FromX, l2.FromY, l2.FromZ, l2.ToX, l2.ToY, l2.ToZ]\n                l3_values = [-1 for i in range(6)]\n                \n                if self.estimation_type == 1:\n                    l = l1_values + l2_values + l3_values\n                else:\n                    l = l1_values + l3_values + l2_values\n                \n                return [v/1000 for v in l]\n    \"\"\"  \n    \n    \"\"\"    \n    def get_lines_from_estimation_values_in_cam_frame_old(self, line_est_values, lines_for_est_global):\n        \n        m0_x, m0_y, m0_z, v0_x, v0_y, v0_z, m1_x, m1_y, m1_z, v1_x, v1_y, v1_z, m2_x, m2_y, m2_z, v2_x, v2_y, v2_z  = line_est_values\n    \n        cont_line_pt_mid = rg.Point3d(m0_x, m0_y, m0_z)\n        cont_line_vec = rg.Vector3d(v0_x, v0_y, v0_z)\n        cont_line_pt_from = cont_line_pt_mid - cont_line_vec * lines_for_est_global[0].Length/2\n        cont_line_pt_to = cont_line_pt_mid + cont_line_vec * lines_for_est_global[0].Length/2\n        cont_line_in_cam_frame = rg.Line(cont_line_pt_from, cont_line_pt_to)\n        \n        discrete_line_pt_mid = rg.Point3d(m1_x, m1_y, m1_z)\n        discrete_line_vec = rg.Vector3d(v1_x, v1_y, v1_z)\n        discrete_line_pt_from = discrete_line_pt_mid - discrete_line_vec * lines_for_est_global[1].Length/2\n        discrete_line_pt_to = discrete_line_pt_mid + discrete_line_vec * lines_for_est_global[1].Length/2\n        discrete_line_in_cam_frame = rg.Line(discrete_line_pt_from, discrete_line_pt_to)\n        \n        self.estimated_lines_in_cam_frame = [cont_line_in_cam_frame, discrete_line_in_cam_frame]\n        \n        return self.estimated_lines_in_cam_frame\n    \"\"\"\n    \"\"\"\n    def get_lines_from_estimation_values_global_old(self, line_est_values, lines_for_est_global, cam_plane_trfd_global):\n          \n        estimated_lines_in_cam_frame = self.get_lines_from_estimation_values_in_cam_frame(line_est_values, lines_for_est_global)\n        \n        T_from_cam_to_world = rg.Transform.ChangeBasis(cam_plane_trfd_global, rg.Plane.WorldXY)\n        self.estimated_lines_global = ghcomp.Transform(estimated_lines_in_cam_frame, T_from_cam_to_world)\n        \n        return self.estimated_lines_global\n    \"\"\"\n    \n    def get_closest_point_to_other_line(self, this_line, other_line):\n    \n        n = rg.Vector3d.CrossProduct(this_line.Direction, other_line.Direction)\n        n2 = rg.Vector3d.CrossProduct(other_line.Direction, n)\n        c1 = this_line.From + (( (other_line.From - this_line.From) * n2) / (this_line.Direction * n2)) * this_line.Direction\n        return c1\n    \n    def get_T_from_lines_exp_to_lines_est(self, lines_for_est_global, current_estimated_lines_global):\n        \n        #p1 = point on estimated line_c\n        #p2_a = closest point on estimated line_c to estimated line_d\n        #p2_b = closest point on estimated line_d to estimated line_c\n        #p3 = point on estimated line_d + vector from p2_a to p2_b\n\n        # 1. ----> get the approximated plane from the estimated lines\n        line_c_exp, line_d1_exp, line_d2_exp = lines_for_est_global\n        line_c_est, l_discrete_est = current_estimated_lines_global\n        \n        l_discrete_exp = line_d2_exp if self.estimation_type == 2 else line_d1_exp\n        \n        p1 = line_c_est.PointAt(0.5)\n        p2_a = self.get_closest_point_to_other_line(line_c_est, l_discrete_est) # get the point on the estimated line_continuous closest to the estimated line_d2\n        p2_b = self.get_closest_point_to_other_line(l_discrete_est, line_c_est) # get the point on the estimated line_d2 closest to the estimated line_continuous\n        v_p2_b_to_p2_a = rg.Vector3d(p2_a-p2_b)\n        p3 = l_discrete_est.PointAt(0.5) + v_p2_b_to_p2_a\n        \n        plane_from_est_lines = rg.Plane(p2_a, p1, p3)\n        \n        # 2. ----> get the approximated plane from the expected lines\n        p1 = line_c_exp.PointAt(0.5)\n        p2_a = self.get_closest_point_to_other_line(line_c_exp, l_discrete_exp) # get the point on the estimated line_continuous closest to the estimated line_d2\n        p2_b = self.get_closest_point_to_other_line(l_discrete_exp, line_c_exp) # get the point on the estimated line_d2 closest to the estimated line_continuous\n        v_p2_b_to_p2_a = rg.Vector3d(p2_a-p2_b)\n        p3 = l_discrete_exp.PointAt(0.5) + v_p2_b_to_p2_a\n        \n        plane_from_exp_lines = rg.Plane(p2_a, p1, p3)\n        \n        # 3. ----> now get the transformation from the expected line plane to the estimated line plane \n        T_exp_est = rg.Transform.PlaneToPlane(plane_from_exp_lines, plane_from_est_lines)\n        T_est_exp = rg.Transform.PlaneToPlane(plane_from_est_lines, plane_from_exp_lines)\n        \n        return plane_from_est_lines, plane_from_exp_lines, T_exp_est, T_est_exp\n    \n    \n    def get_T_from_lines_exp_to_lines_est_2(self, lines_for_est_global, current_estimated_lines_global):\n        \n        #p1 = point on estimated line_c\n        #p2_a = closest point on estimated line_c to estimated line_d\n        #p2_b = closest point on estimated line_d to estimated line_c\n        #p3 = point on estimated line_d + vector from p2_a to p2_b\n        \n        # 1. ----> get the approximated plane from the estimated lines\n        line_c_exp, line_d1_exp, line_d2_exp = lines_for_est_global\n        line_c_est, l_discrete_est = current_estimated_lines_global\n        \n        l_discrete_exp = line_d2_exp if self.estimation_type == 2 else line_d1_exp\n        \n        p1 = line_c_est.PointAt(0.5)\n        p2_a = self.get_closest_point_to_other_line(line_c_est, l_discrete_est) # get the point on the estimated line_continuous closest to the estimated line_d2\n        p2_b = self.get_closest_point_to_other_line(l_discrete_est, line_c_est) # get the point on the estimated line_d2 closest to the estimated line_continuous\n        v_p2_b_to_p2_a = rg.Vector3d(p2_a-p2_b)\n        p3 = l_discrete_est.PointAt(0.5) + v_p2_b_to_p2_a\n        \n        plane_from_est_lines = rg.Plane(p2_a, p1, p3)\n        \n        # 2. ----> get the approximated plane from the expected lines\n        p1 = line_c_exp.PointAt(0.5)\n        p2_a = self.get_closest_point_to_other_line(line_c_exp, l_discrete_exp) # get the point on the estimated line_continuous closest to the estimated line_d2\n        p2_b = self.get_closest_point_to_other_line(l_discrete_exp, line_c_exp) # get the point on the estimated line_d2 closest to the estimated line_continuous\n        v_p2_b_to_p2_a = rg.Vector3d(p2_a-p2_b)\n        \n        # now get the p3 approximated from the expected line\n        p3 = p2_a + l_discrete_exp.Direction\n        \n        plane_from_exp_lines = rg.Plane(p2_a, p1, p3)\n        \n        # 3. ----> now get the transformation from the expected line plane to the estimated line plane \n        T_exp_est = rg.Transform.PlaneToPlane(plane_from_exp_lines, plane_from_est_lines)\n        T_est_exp = rg.Transform.PlaneToPlane(plane_from_est_lines, plane_from_exp_lines)\n        \n        return plane_from_est_lines, plane_from_exp_lines, T_exp_est, T_est_exp\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}