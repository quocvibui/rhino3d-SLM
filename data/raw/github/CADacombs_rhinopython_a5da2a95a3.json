{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_BrepEdge_splitClosestPtToCrvEnds.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_BrepEdge_splitClosestPtToCrvEnds.py",
  "instruction": "Spb brep edge split closest pt to crv ends",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import print_function\r\n\r\n\"\"\"\r\n211112: Created.\r\n\"\"\"\r\n\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAllowWires'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAllowMatedEdges'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddRefs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList):\r\n\r\n        if key == 'fTolerance':\r\n            if cls.riOpts[key].CurrentValue <= 1e-9:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_EdgesToSplit():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select edges to split\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.EdgeFilter\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fTolerance')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n        if Opts.values['bDebug']:\r\n            addOption('bAddRefs')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            return (\r\n                objrefs,\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTolerance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getInput_Refs(objref_SrfToMod):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select reference edges\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.GeometryAttributeFilter = (\r\n            ri.Custom.GeometryAttributeFilter.EdgeCurve |\r\n            ri.Custom.GeometryAttributeFilter.BoundaryEdge)\r\n\r\n        if Opts.values['bAllowWires']:\r\n            go.GeometryAttributeFilter |= (\r\n                ri.Custom.GeometryAttributeFilter.WireCurve)\r\n\r\n        if Opts.values['bAllowMatedEdges']:\r\n            go.GeometryAttributeFilter |= (\r\n                ri.Custom.GeometryAttributeFilter.MatedEdge)\r\n\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fTolerance')\r\n        addOption('bAllowWires')\r\n        addOption('bAllowMatedEdges')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n        if Opts.values['bDebug']:\r\n            addOption('bAddRefs')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return (\r\n                objrefs,\r\n                Opts.values['fTolerance'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                Opts.values['bAddRefs'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fTolerance'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef processObjRefs(objrefs_M, objrefs_R, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTolerance = getOpt('fTolerance')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n    bAddRefs = getOpt('bAddRefs')\r\n\r\n\r\n    def groupObjrefsPerBrep(objrefs):\r\n        gBs = []\r\n        objrefs_PerB = []\r\n\r\n        for objref in objrefs:\r\n            if objref.ObjectId in gBs:\r\n                objrefs_PerB[gBs.index(objref.ObjectId)].append(objref)\r\n            else:\r\n                gBs.append(objref.ObjectId)\r\n                objrefs_PerB.append([objref])\r\n\r\n        return objrefs_PerB\r\n\r\n\r\n    objrefs_per_B = groupObjrefsPerBrep(objrefs_M)\r\n\r\n    rgCs_R = [o.Curve() for o in objrefs_R]\r\n\r\n    for objrefs_same_B in objrefs_per_B:\r\n\r\n        edges_M_In = [o.Edge() for o in objrefs_same_B]\r\n        idxs_Es = [e.EdgeIndex for e in edges_M_In]\r\n\r\n        edges_M_In = [e for i,e in sorted(zip(idxs_Es, edges_M_In), reverse=True)]\r\n\r\n        rgB_WIP = edges_M_In[0].Brep.DuplicateBrep()\r\n\r\n        edge_count_Start = rgB_WIP.Edges.Count\r\n\r\n        for edge in edges_M_In:\r\n\r\n            ts = []\r\n\r\n            for c_R in rgCs_R:\r\n                for bSuccess, t in (edge.ClosestPoint(c_R.PointAtStart), edge.ClosestPoint(c_R.PointAtEnd)):\r\n                    if not bSuccess: continue\r\n                    pt_Closest = edge.PointAt(t)\r\n                    if (\r\n                        (pt_Closest.DistanceTo(edge.PointAtStart) > fTolerance) and\r\n                        (pt_Closest.DistanceTo(edge.PointAtEnd) > fTolerance)\r\n                    ):\r\n                        ts.append(t)\r\n                        #sc.doc.Objects.AddPoint(pt_Closest)\r\n\r\n\r\n            rgB_WIP.Edges.SplitEdgeAtParameters(\r\n                edgeIndex=edge.EdgeIndex,\r\n                edgeParameters=ts)\r\n\r\n        rgB_WIP.Compact()\r\n\r\n        edge_count_End = rgB_WIP.Edges.Count\r\n\r\n        if edge_count_End == edge_count_Start:\r\n            print(\"No edges were split.\")\r\n            continue\r\n\r\n        bReplaced = sc.doc.Objects.Replace(\r\n            objectId=objrefs_same_B[0].ObjectId,\r\n            brep=rgB_WIP)\r\n\r\n        if bReplaced:\r\n            print(\"Edge count increase: {}\".format(edge_count_End-edge_count_Start))\r\n\r\n\r\ndef main():\r\n\r\n    rc = getInput_EdgesToSplit()\r\n    if rc is None: return\r\n\r\n    (\r\n        objrefs_M,\r\n        bEcho,\r\n        bDebug,\r\n       ) = rc\r\n\r\n\r\n    rc = getInput_Refs(objrefs_M)\r\n    if rc is None: return\r\n\r\n    (\r\n        objrefs_R,\r\n        fTolerance,\r\n        bEcho,\r\n        bDebug,\r\n        bAddRefs,\r\n        ) = rc\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    gBrep_Ret = processObjRefs(\r\n        objrefs_M,\r\n        objrefs_R,\r\n        fTolerance=fTolerance,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        bAddRefs=bAddRefs,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": false
}