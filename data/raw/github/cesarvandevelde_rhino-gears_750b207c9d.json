{
  "source_url": "https://github.com/cesarvandevelde/rhino-gears/blob/6327e843d369f5c563788de168a5b94805945345/src/helpers.py",
  "repo": "cesarvandevelde/rhino-gears",
  "repo_stars": 40,
  "repo_description": "RhinoGears is a plugin for Rhino3D that can be used to generate custom gears.",
  "license": "unknown",
  "filepath": "src/helpers.py",
  "instruction": "Helpers",
  "code": "from __future__ import division\nfrom math import sin, cos, asin, atan, radians, degrees, pi, sqrt\nfrom functools import partial\nimport rhinoscriptsyntax as rs\n\n\ndef generate_involute_pts(base_circle_diam,\n                          start_angle,\n                          end_angle,\n                          angle_mod,\n                          samples):\n    pts = []\n    step = (start_angle - angle_mod - end_angle) / samples\n    base_circle_r = base_circle_diam/2\n\n    # Calculate involute\n    for i in xrange(samples + 1):\n        pos = angle_mod + i * step\n        height = sqrt(pos**2 * base_circle_r**2 + base_circle_r**2)\n        height_angle = start_angle - pos + atan(pos)\n\n        pt = [height * cos(height_angle), height * sin(height_angle), 0]\n        pts.append(pt)\n\n    return pts\n\n\ndef tilt_pt_around_circle(pt, angle, circle_diam):\n    if angle == 0:\n        return pt\n\n    angle = radians(angle)\n    dist_to_circle = sqrt(pt[0]**2 + pt[1]**2) - (circle_diam/2)\n    xy_scale_factor = (circle_diam/2 + dist_to_circle * cos(angle))\n    xy_scale_factor = xy_scale_factor / (circle_diam/2 + dist_to_circle)\n\n    new_pt = [xy_scale_factor * pt[0],\n              xy_scale_factor * pt[1],\n              dist_to_circle * sin(angle)]\n\n    return new_pt\n\n\ndef generate_gear_crv(teeth,\n                      module,\n                      pressure_angle=20,\n                      cone_angle=0,\n                      clearance=0.167,\n                      involute_samples=5):\n    pressure_angle = radians(pressure_angle)\n\n    pitch_diam = module * teeth\n    base_circle = pitch_diam * cos(pressure_angle)\n    addendum = module\n    dedendum = (1 + clearance) * module\n    outside_diam = pitch_diam + 2*addendum\n    root_diam = pitch_diam - 2*dedendum\n    chordal_thickness = pitch_diam * sin((pi/2)/teeth)\n\n    # Partial function to transform point from xy plane to surface\n    # perpendicular to pitch cone surface. Used for bevel gears.\n    tilt = partial(tilt_pt_around_circle,\n                   angle=cone_angle/2,\n                   circle_diam=pitch_diam)\n\n    invol_start_angle = (pi/2 + asin(chordal_thickness/pitch_diam)\n                         - pressure_angle\n                         + sqrt((pitch_diam/base_circle)**2 - 1))\n    invol_end_angle = (invol_start_angle\n                       - sqrt((outside_diam/base_circle)**2 - 1))\n\n    if root_diam > base_circle:\n        invol_angle_mod = sqrt((root_diam/base_circle)**2 - 1)\n    else:\n        invol_angle_mod = 0\n\n    invol_pts = generate_involute_pts(\n                    base_circle_diam=base_circle,\n                    start_angle=invol_start_angle,\n                    end_angle=invol_end_angle,\n                    angle_mod=invol_angle_mod,\n                    samples=involute_samples)\n    invol_pts = map(tilt, invol_pts)\n\n    tooth_crvs = []\n\n    invol_crv1 = rs.AddInterpCurve(invol_pts, degree=3, knotstyle=1)\n    invol_crv2 = rs.MirrorObject(invol_crv1, [0, 0, 0], [0, 1, 0], copy=True)\n    top_arc = rs.AddArc3Pt(start=rs.CurveEndPoint(invol_crv1),\n                           end=rs.CurveEndPoint(invol_crv2),\n                           point_on_arc=tilt([0, outside_diam/2, 0]))\n\n    tooth_crvs.append(invol_crv1)\n    tooth_crvs.append(invol_crv2)\n    tooth_crvs.append(top_arc)\n\n    # Dedendum\n    if root_diam < base_circle:\n        pt = [root_diam/2 * cos(invol_start_angle),\n              root_diam/2 * sin(invol_start_angle),\n              0]\n        ded_crv1 = rs.AddLine(rs.CurveStartPoint(invol_crv1), tilt(pt))\n        ded_crv2 = rs.MirrorObject(ded_crv1, [0, 0, 0], [0, 1, 0], copy=True)\n\n        tooth_crvs.append(ded_crv1)\n        tooth_crvs.append(ded_crv2)\n\n    tooth = rs.JoinCurves(tooth_crvs, delete_input=True)[0]\n\n    # Tooth bottom\n    angle = 2*pi/teeth\n    start_pt = rs.CurveStartPoint(tooth)\n    end_pt = rs.CurveEndPoint(tooth)\n    end_pt = [end_pt[0]*cos(angle) - end_pt[1]*sin(angle),\n              end_pt[1]*cos(angle) + end_pt[0]*sin(angle),\n              end_pt[2]]\n    pt_on_arc = [-sin(angle/2) * (root_diam/2),\n                 cos(angle/2) * (root_diam/2),\n                 0]\n    bottom_arc = rs.AddArc3Pt(start_pt, end_pt, tilt(pt_on_arc))\n\n    tooth = rs.JoinCurves([tooth, bottom_arc], delete_input=True)[0]\n\n    # Copy and rotate tooth N times\n    crvs = [tooth]\n    for i in xrange(1, teeth):\n        crv = rs.RotateObject(tooth, [0, 0, 0], degrees(i*angle), copy=True)\n        crvs.append(crv)\n\n    crvs = rs.JoinCurves(crvs, delete_input=True)\n\n    return crvs\n\n\ndef generate_pitch_circle_crv(teeth, module):\n    pitch_diam = teeth * module\n    return rs.AddCircle([0, 0, 0], pitch_diam/2)\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}