{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhinoscript/transformation.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhinoscript/transformation.py",
  "instruction": "Transformation",
  "code": "import scriptcontext\nfrom . import utility as rhutil\nimport Rhino\nimport System.Guid, System.Array\nimport math\nfrom . import view as rhview\n\n\ndef IsXformIdentity(xform):\n    \"Verifies a matrix is the identity matrix\"\n    xform = rhutil.coercexform(xform, True)\n    return xform==Rhino.Geometry.Transform.Identity\n\n\ndef IsXformSimilarity(xform):\n    \"\"\"Verifies a matrix is a similarity transformation. A similarity\n    transformation can be broken into a sequence of dialations, translations,\n    rotations, and reflections\n    \"\"\"\n    xform = rhutil.coercexform(xform, True)\n    return xform.SimilarityType!=Rhino.Geometry.TransformSimilarityType.NotSimilarity\n\n\ndef IsXformZero(xform):\n    \"verifies that a matrix is a zero transformation matrix\"\n    xform = rhutil.coercexform(xform, True)\n    for i in range(4):\n        for j in range(4):\n            if xform[i,j]!=0: return False\n    return True\n\n\ndef XformChangeBasis(initial_plane, final_plane):\n    \"Returns a change of basis transformation matrix or None on error\"\n    initial_plane = rhutil.coerceplane(initial_plane, True)\n    final_plane = rhutil.coerceplane(final_plane, True)\n    xform = Rhino.Geometry.Transform.ChangeBasis(initial_plane, final_plane)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformChangeBasis2(x0,y0,z0,x1,y1,z1):\n    \"\"\"Returns a change of basis transformation matrix of None on error\n    Parameters:\n      x0,y0,z0 = initial basis\n      x1,y1,z1 = final basis\n    \"\"\"\n    x0 = rhutil.coerce3dvector(x0, True)\n    y0 = rhutil.coerce3dvector(y0, True)\n    z0 = rhutil.coerce3dvector(z0, True)\n    x1 = rhutil.coerce3dvector(x1, True)\n    y1 = rhutil.coerce3dvector(y1, True)\n    z1 = rhutil.coerce3dvector(z1, True)\n    xform = Rhino.Geometry.Transform.ChangeBasis(x0,y0,z0,x1,y1,z1)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformCompare(xform1, xform2):\n    \"\"\"Compares two transformation matrices\n    Parameters:\n      xform1, xform2 = matrices to compare\n    Returns:\n      -1 if xform1<xform2\n       1 if xform1>xform2\n       0 if xform1=xform2\n    \"\"\"\n    xform1 = rhutil.coercexform(xform1, True)\n    xform2 = rhutil.coercexform(xform2, True)\n    return xform1.CompareTo(xform2)\n\n\ndef XformCPlaneToWorld(point, plane):\n    \"\"\"Transform point from construction plane coordinates to world coordinates\n    Parameters:\n      point = A 3D point in construction plane coordinates.\n      plane = The construction plane\n    Returns:\n      A 3D point in world coordinates\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    plane = rhutil.coerceplane(plane, True)\n    return plane.Origin + point.X*plane.XAxis + point.Y*plane.YAxis + point.Z*plane.ZAxis\n\n\ndef XformDeterminant(xform):\n    \"\"\"Returns the determinant of a transformation matrix. If the determinant\n    of a transformation matrix is 0, the matrix is said to be singular. Singular\n    matrices do not have inverses.\n    \"\"\"\n    xform = rhutil.coercexform(xform, True)\n    return xform.Determinant\n\n\ndef XformDiagonal(diagonal_value):\n    \"\"\"Returns a diagonal transformation matrix. Diagonal matrices are 3x3 with\n    the bottom row [0,0,0,1]\n    \"\"\"\n    return Rhino.Geometry.Transform(diagonal_value)\n\n\ndef XformIdentity():\n    \"returns the identity transformation matrix\"\n    return Rhino.Geometry.Transform.Identity\n\n\ndef XformInverse(xform):\n    \"\"\"Returns the inverse of a non-singular transformation matrix\n    Returns None on error\n    \"\"\"\n    xform = rhutil.coercexform(xform, True)\n    rc, inverse = xform.TryGetInverse()\n    if not rc: return scriptcontext.errorhandler()\n    return inverse\n\n\ndef XformMirror(mirror_plane_point, mirror_plane_normal):\n    \"\"\"Creates a mirror transformation matrix\n    Parameters:\n      mirror_plane_point = point on the mirror plane\n      mirror_plane_normal = a 3D vector that is normal to the mirror plane\n    Returns:\n      mirror Transform\n    \"\"\"\n    point = rhutil.coerce3dpoint(mirror_plane_point, True)\n    normal = rhutil.coerce3dvector(mirror_plane_normal, True)\n    return Rhino.Geometry.Transform.Mirror(point, normal)\n\n\ndef XformMultiply(xform1, xform2):\n    \"\"\"Multiplies two transformation matrices, where result = xform1 * xform2\n    Returns:\n      result transformation on success\n    \"\"\"\n    xform1 = rhutil.coercexform(xform1, True)\n    xform2 = rhutil.coercexform(xform2, True)\n    return xform1*xform2\n\n\ndef XformPlanarProjection(plane):\n    \"\"\"Returns a transformation matrix that projects to a plane.\n    Parameters\n      plane = The plane to project to.\n    Returns:\n      The 4x4 transformation matrix.\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    return Rhino.Geometry.Transform.PlanarProjection(plane)\n\n\ndef XformRotation1(initial_plane, final_plane):\n    \"\"\"Returns a rotation transformation that maps initial_plane to final_plane.\n    The planes should be right hand orthonormal planes.\n    Returns:\n      The 4x4 transformation matrix.\n      None on error.\n    \"\"\"\n    initial_plane = rhutil.coerceplane(initial_plane, True)\n    final_plane = rhutil.coerceplane(final_plane, True)\n    xform = Rhino.Geometry.Transform.PlaneToPlane(initial_plane, final_plane)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformRotation2(angle_degrees, rotation_axis, center_point):\n    \"\"\"Returns a rotation transformation\n    Returns:\n      The 4x4 transformation matrix.\n      None on error.\n    \"\"\"\n    axis = rhutil.coerce3dvector(rotation_axis, True)\n    center = rhutil.coerce3dpoint(center_point, True)\n    angle_rad = math.radians(angle_degrees)\n    xform = Rhino.Geometry.Transform.Rotation(angle_rad, axis, center)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformRotation3( start_direction, end_direction, center_point ):\n    \"\"\"Calculate the minimal transformation that rotates start_direction to\n    end_direction while fixing center_point\n    Parameters:\n      start_direction, end_direction = 3d vectors\n      center_point = the rotation center\n    Returns:\n      The 4x4 transformation matrix.\n      None on error.\n    \"\"\"\n    start = rhutil.coerce3dvector(start_direction, True)\n    end = rhutil.coerce3dvector(end_direction, True)\n    center = rhutil.coerce3dpoint(center_point, True)\n    xform = Rhino.Geometry.Transform.Rotation(start, end, center)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformRotation4(x0, y0, z0, x1, y1, z1):\n    \"\"\"Returns a rotation transformation.\n    Paramters:\n      x0,y0,z0 = Vectors defining the initial orthonormal frame\n      x1,y1,z1 = Vectors defining the final orthonormal frame\n    Returns:\n      The 4x4 transformation matrix.\n      None on error.\n    \"\"\"\n    x0 = rhutil.coerce3dveector(x0, True)\n    y0 = rhutil.coerce3dveector(y0, True)\n    z0 = rhutil.coerce3dveector(z0, True)\n    x1 = rhutil.coerce3dveector(x1, True)\n    y1 = rhutil.coerce3dveector(y1, True)\n    z1 = rhutil.coerce3dveector(z1, True)\n    xform = Rhino.Geometry.Transform.Rotation(x0,y0,z0,x1,y1,z1)\n    if not xform.IsValid: return scriptcontext.errorhandler()\n    return xform\n\n\ndef XformScale(scale, point=None):\n    \"\"\"Creates a scale transformation\n    Parameters:\n      scale = single number, list of 3 numbers, Point3d, or Vector3d\n      point[opt] = center of scale. If omitted, world origin is used\n    Returns:\n      The 4x4 transformation matrix on success\n      None on error\n    \"\"\"\n    factor = rhutil.coerce3dpoint(scale)\n    if factor is None:\n        if type(scale) is int or type(scale) is float:\n            factor = (scale,scale,scale)\n        if factor is None: return scriptcontext.errorhandler()\n    if point: point = rhutil.coerce3dpoint(point, True)\n    else: point = Rhino.Geometry.Point3d.Origin\n    plane = Rhino.Geometry.Plane(point, Rhino.Geometry.Vector3d.ZAxis);\n    xf = Rhino.Geometry.Transform.Scale(plane, factor[0], factor[1], factor[2])\n    return xf\n\n\ndef XformScreenToWorld(point, view=None, screen_coordinates=False):\n    \"\"\"Transforms a point from either client-area coordinates of the specified view\n    or screen coordinates to world coordinates. The resulting coordinates are represented\n    as a 3-D point\n    Parameters:\n      point = 2D point\n      view[opt] = title or identifier of a view. If omitted, the active view is used\n      screen_coordinates[opt] = if False, point is in client-area coordinates. If True,\n      point is in screen-area coordinates\n    Returns:\n      3D point on success\n      None on error\n    \"\"\"\n    point = rhutil.coerce2dpoint(point, True)\n    view = rhview.__viewhelper(view)\n    viewport = view.MainViewport\n    xform = viewport.GetTransform(Rhino.DocObjects.CoordinateSystem.Screen, Rhino.DocObjects.CoordinateSystem.World)\n    point3d = Rhino.Geometry.Point3d(point.X, point.Y, 0)\n    if screen_coordinates:\n        screen = view.ScreenRectangle\n        point3d.X = point.X - screen.Left\n        point3d.Y = point.Y - screen.Top\n    point3d = xform * point3d\n    return point3d\n\n\ndef XformShear(plane, x, y, z):\n    \"\"\"Returns a shear transformation matrix\n    Parameters:\n      plane = plane[0] is the fixed point\n      x,y,z = each axis scale factor\n    Returns:\n      The 4x4 transformation matrix on success\n    \"\"\"\n    plane = rhutil.coerceplane(plane, True)\n    x = rhutil.coerce3dvector(x, True)\n    y = rhutil.coerce3dvector(y, True)\n    z = rhutil.coerce3dvector(z, True)\n    return Rhino.Geometry.Transform.Shear(plane,x,y,z)\n\n\ndef XformTranslation(vector):\n    \"Creates a translation transformation matrix\"\n    vector = rhutil.coerce3dvector(vector, True)\n    return Rhino.Geometry.Transform.Translation(vector)\n\n\ndef XformWorldtoCplane(point, plane):\n    \"\"\"Transforms a point from world coordinates to construction plane coordinates.\n    Parameters:\n      point = A 3D point in world coordinates.\n      plane = The construction plane\n    Returns:\n      A 3D point in construction plane coordinates\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    plane = rhutil.coerceplane(plane, True)\n    v = point - plane.Origin;\n    return Rhino.Geometry.Point3d(v*plane.XAxis, v*plane.YAxis, v*plane.ZAxis)\n\n\ndef XformWorldToScreen(point, view=None, screen_coordinates=False):\n    \"\"\"Transforms a point from world coordinates to either client-area coordinates of\n    the specified view or screen coordinates. The resulting coordinates are represented\n    as a 2D point\n    Parameters:\n      point = 3D point in world coordinates\n      view[opt] = title or identifier of a view. If omitted, the active view is used\n      screen_coordinates[opt] = if False, the function returns the results as\n        client-area coordinates. If True, the result is in screen-area coordinates\n    Returns:\n      2D point on success\n      None on error\n    \"\"\"\n    point = rhutil.coerce3dpoint(point, True)\n    view = rhview.__viewhelper(view)\n    viewport = view.MainViewport\n    xform = viewport.GetTransform(Rhino.DocObjects.CoordinateSystem.World, Rhino.DocObjects.CoordinateSystem.Screen)\n    point = xform * point\n    point = Rhino.Geometry.Point2d(point.X, point.Y)\n    if screen_coordinates:\n        screen = view.ScreenRectangle\n        point.X = point.X + screen.Left\n        point.Y = point.Y + screen.Top\n    return point\n\n\ndef XformZero():\n    \"Returns a zero transformation matrix\"\n    return Rhino.Geometry.Transform()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}