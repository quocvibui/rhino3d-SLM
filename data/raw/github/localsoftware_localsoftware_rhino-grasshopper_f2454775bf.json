{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/Rhino8_Scripts/import_GeoJSON.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "Rhino8_Scripts/import_GeoJSON.py",
  "instruction": "Imports geometry from GeoJSON files into grasshopper.",
  "code": "\"\"\"Imports geometry from GeoJSON files into grasshopper.\n\nPreserves layer hierarchy as data tree.\nThe Import GeoJSON component extracts the GIS attributes from the geoJSON files.\nBased on the work of Jackie Berry.\n   \n    Typical usage:\n        Input a path as a string.\n\n    Inputs:\n        Import: boolean to start import\n        geoJSONFolderPath: path to folder with GeoJSON files\n        siteNumber: int site number\n\n    Output:\n        Geometry: The imported geometry ingo gh space\n        Attributes: attributes of objects / layers\n        Values: evaluated values\n        LayerNames: list of layer names\"\"\"\n\n__author__ = \"palomagr\"\n__version__ = \"2020.07.09\"\n\n#ghenv.Component.Name = \"Import GeoJason\"\n#ghenv.Component.NickName = \"Import GeoJSON\"\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython, System, Rhino, json\n\n# Import standard library modules\nfrom Rhino.Geometry import *\nfrom scriptcontext import doc\n\n# import .NET libraries\nfrom System import Object\nimport rhinoscriptsyntax as rs\nimport sys, os\n\n# import GH dependencies\nfrom clr import AddReference as addr\naddr(\"Grasshopper\")\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\nfrom Rhino.Geometry import Point3d\n\n\n\nGeometry, Attributes, Values, LayerNames = None, None, None, None\ndef addRhinoLayer(layerName, layerColor=System.Drawing.Color.Black):\n    \"\"\"Creates a Layer in Rhino using a name and optional color. Returns the\n    index of the layer requested. If the layer\n    already exists, the color is updated and no new layer is created.\"\"\"\n    docLyrs = doc.Layers\n    layerIndex = docLyrs.Find(layerName, True)\n    if layerIndex == -1:\n        layerIndex = docLyrs.Add(layerName,layerColor)\n    else: # it exists\n        layer = docLyrs[layerIndex] # so get it\n        if layer.Color != layerColor: # if it has a different color\n            layer.Color = layerColor # reset the color\n    return layerIndex\n\n\ndef PointToRhinoPoint(coordinates):\n    if len(coordinates) > 2:\n        z = coordinates[2]\n    else:\n        z = 0.0\n    x, y = coordinates[0], coordinates[1]\n    return Point3d(x, y, z)\n\n\ndef MultiPointToRhinoPoint(coordinates):\n    rhPointList = []\n    for point in coordinates:\n        rhPointList.append(PointToRhinoPoint(point))\n    return rhPointList\n\n\ndef MeshToRhinoMesh(coordinates, faces):\n    rhMesh = Mesh()\n    for point in coordinates:\n        rhPoint = PointToRhinoPoint(point)\n        rhMesh.Vertices.Add(rhPoint)\n    for face in faces:\n        i, j, k = tuple(face)\n        mFace = MeshFace(i, j, k)\n        rhMesh.Faces.AddFace(mFace)\n    rhMesh.Normals.ComputeNormals()\n    rhMesh.Compact()\n    return rhMesh\n\n\ndef LineStringToRhinoCurve(coordinates):\n    rhPoints = MultiPointToRhinoPoint(coordinates)\n    return Curve.CreateControlPointCurve(rhPoints, 1)\n\n\ndef MultiLineStringToRhinoCurve(coordinates):\n    rhCurveList = []\n    for lineString in coordinates:\n        rhCurveList.append(LineStringToRhinoCurve(lineString))\n    return rhCurveList\n\n\ndef PolygonToRhinoCurve(coordinates):\n    # each ring is a separate list of coordinates\n    ringList = []\n    for ring in coordinates:\n        ringList.append(LineStringToRhinoCurve(ring))\n    return ringList\n\n\ndef MultiPolygonToRhinoCurve(coordinates):\n    polygonList = []\n    for polygon in coordinates:\n        polygonList.append(PolygonToRhinoCurve(polygon))\n    return polygonList\n\n\ndef GeometryCollectionToParser(geometries):\n    pass # I need to figure this one out still\n\n\ndef addPoint(rhPoint, objAtt):\n    return doc.Objects.AddPoint(rhPoint, objAtt)\n\n\ndef addPoints(rhPoints, objAtt):\n    guidList = []\n    for rhPoint in rhPoints:\n        guidList.append(doc.Objects.AddPoint(rhPoint, objAtt))\n    return guidList\n\n\ndef addCurve(rhCurve, objAtt):\n    return doc.Objects.AddCurve(rhCurve, objAtt)\n\n\ndef addCurves(rhCurves, objAtt):\n    guidList = []\n    for curve in rhCurves:\n        guidList.append(addCurve(curve, objAtt))\n    return guidList\n\n\ndef addPolygon(ringList, objAtt):\n    # for now this just makes curves\n    # but maybe it should make TrimmedSrfs\n    # or should group the rings\n    return addCurves(ringList, objAtt)\n\n\ndef addPolygons(polygonList, objAtt):\n    guidList = []\n    for polygon in polygonList:\n        # !! Extending the guid list !!!\n        guidList.extend(addPolygon(polygon, objAtt))\n    return guidList\n\n\ndef addMesh(rhMesh, objAtt):\n    return doc.Objects.AddMesh(rhMesh, objAtt)\n\n\ndef setUserKeys(properties, objAttributes):\n    for key in properties:\n        objAttributes.SetUserString(key, str(properties[key]))\n    return objAttributes\n\n\ndef jsonToRhinoCommon(jsonFeature):\n        # deal with the geometry\n        geom = jsonFeature['geometry']\n        geomType = geom['type'] # this will return a mappable string\n        coordinates = geom['coordinates']\n        # if this is a mesh, pass the faces\n        if geomType == 'Mesh':\n            faces = geom['faces']\n            rhFeature = geoJsonGeometryMap[geomType][0](coordinates, faces)\n        # translate the coordinates to Rhino.Geometry objects\n        else:\n            rhFeature = geoJsonGeometryMap[geomType][0](coordinates)\n        return rhFeature\n\n\ndef addJsonFeature(jsonFeature, objAttributes):\n        # deal with the properties\n        if jsonFeature['properties']:\n            objAttributes = setUserKeys(jsonFeature['properties'], objAttributes)\n        geomType = jsonFeature['geometry']['type']\n        rhFeature = jsonToRhinoCommon(jsonFeature)\n        # return the GUID(s) for the feature\n        return geoJsonGeometryMap[geomType][1](rhFeature, objAttributes)\n\n\ndef processGeoJson(parsedGeoJson,\n            destinationLayer=None,\n            destinationLayerColor=System.Drawing.Color.Black):\n    # get the features\n    jsonFeatures = parsedGeoJson['features']\n    guidResults = []\n    # set up object attributes\n    for jsonFeature in jsonFeatures: # for each feature\n        att = Rhino.DocObjects.ObjectAttributes()\n        # setup layer if requested\n        if destinationLayer != None:\n            destinationLayer = None\n            #att.LayerIndex = addRhinoLayer(destinationLayer,\n                                            #destinationLayerColor)\n        guidResults.append(addJsonFeature(jsonFeature, att))\n    # return all the guids\n    return guidResults\n\n\ndef load(rawJsonData,\n            prefix=None,\n            destinationLayer=None,\n            destinationLayerColor=System.Drawing.Color.Black):\n    # if the data already appears to be a dict literal ...\n    if type(rawJsonData) == dict:\n        jsonData = rawJsonData\n    else: # otherwise, just try to load it\n        jsonData = json.loads(rawJsonData)\n    # if this is just a GeoJSON ...\n    if jsonData[\"type\"] == \"FeatureCollection\":\n        # process the GeoJSON, pass the layer and color in\n        return processGeoJson(jsonData, destinationLayer,\n                                destinationLayerColor)\n    # or if this is a set of layers from PostSites ...\n    elif jsonData[\"type\"] == \"LayerCollection\":\n        # make a list for all the guids\n        allResults = []\n        layersList = jsonData['layers']\n        for layer in layersList: # for each layer\n            name = prefix + layer['name'] # get the name, modified to add filename to\n            if 'color' in layer: # get the color if it exists\n                color = layer['color']\n            else:\n                color = destinationLayerColor # or just make it black\n            geoJson = layer['contents'] # get the GeoJSON for this layer\n            # make it\n            layerResults = processGeoJson( geoJson, name, color )\n            allResults.append(layerResults)\n        return allResults, layersList\n    else:\n        return \"This doesn't look like correctly formatted GeoJSON data.\\nI'm not sure what to do with it, sorry.\"\n\n\ndef getAttsVals(id,path=None):\n    objct = doc.Objects.Find(id)\n    data = objct.Attributes.GetUserStrings()\n    d = {}\n    k = []\n    v = []\n    if path==None:\n        for u in sorted(data):\n            k.append(u)\n            d[u] = data[u]\n            v.append(d[u])\n        U = d\n        Atts = k\n        Vals = v\n        return Atts,Vals\n    if path:\n        for u in data:\n            k.append(u)\n            d[u] = data[u]\n            v.append(d[u])\n            Attributes.Add(u,path)\n            Values.Add(d[u],path)\n        return None,None\n\n\ndef importSitefolder(filepath):\n    f = str(int(SiteNumber))\n    prefix = str(f +\"_\")\n\n    try:\n        thisfilepath = os.path.join(filepath, f)\n        f = open(thisfilepath,'r')\n    except:\n        f = str(int(SiteNumber))+\".json\"\n        thisfilepath = os.path.join(filepath, f)\n        f = open(thisfilepath,'r')\n    myGeoJson = f.readline()\n    load(myGeoJson, prefix)\n    guidList,layersList = load(myGeoJson, prefix)\n    idsOut.append(guidList)\n    layerNamesOut.append(layersList)\n    f.close()\n\n\n\ndef constructTree():\n    ### NOTE: some problems with mutlipolygons being nested 'up' a level. This problem is rooted in 'loader'\n    ### it needs to be debugged out\n    for i in range (len(layerNamesOut[0])):\n        p = GH_Path(i)\n        LayerNames.Add(layerNamesOut[0][i]['name'],p)\n    for A in idsOut:#for each file\n        for i in range (len(A)):# for each layer\n            try:\n                p = GH_Path(i)#make a new data tree path\n                if (len(A[i])>1):# if the datatree path has more than one item\n                    for j in range (len(A[i])):# iterate\n                        try:\n                            thisId = A[i][j][0]\n                            pPrime = p.AppendElement(j)\n                            Geometry.Add(thisId,p)# add each feature to the path\n                            getAttsVals(thisId,pPrime)\n                        except:\n                            ### It must be a point (tuple), cannot subscript it, grab it directly\n                            try:\n                                thisId = A[i][j]\n                                pPrime = p.AppendElement(j)\n                                Geometry.Add(thisId,p)\n                                getAttsVals(thisId,pPrime)\n                            except:\n                                continue\n                else:#otherwise, the layer has only one item (it is either a 1 item layer or a multipolygon)\n                    #it is a single object layer\n                    try:\n                        thisId = A[i][0]\n                        pPrime = p.AppendElement(0)\n                        Geometry.Add(thisId,p)\n                        getAttsVals(thisId,pPrime)\n                    except: #multipolygon is nested one level\n                        print (\"Multipolygon found, some list-cleanup may be needed\")\n                        thisId = A[i][0][0]\n                        pPrime = p.AppendElement(0)\n                        Geometry.Add(thisId,p)\n                        getAttsVals(thisId,pPrime)\n            except:\n                print ('There were some problems importing a layer, please try again with a different set of layers')\n                continue\n    return\n\n\n\ngeoJsonGeometryMap = {\n        'Point':(PointToRhinoPoint, addPoint),\n        'MultiPoint':(MultiPointToRhinoPoint, addPoints),\n        'LineString':(LineStringToRhinoCurve, addCurve),\n        'MultiLineString':(MultiLineStringToRhinoCurve, addCurves),\n        'Polygon':(PolygonToRhinoCurve, addPolygon),\n        'MultiPolygon':(MultiPolygonToRhinoCurve, addPolygons),\n        'Mesh':(MeshToRhinoMesh, addMesh),\n        'GeometryCollection':(GeometryCollectionToParser),\n        }\n\n\n\"\"\"\nTo run the code\n\"\"\"\nif Import!= None and type(Import) == bool:\n    if Import == True:\n        try:\n            idsOut = []\n            layerNamesOut = []\n            importSitefolder(geoJSONFolderPath)\n\n            if idsOut != None:\n                Geometry = DataTree[Object]()\n                Attributes = DataTree[Object]()\n                Values = DataTree[Object]()\n                LayerNames = DataTree[Object]()\n                constructTree()\n                print ('You succesfully imported a geoJSON file!')\n            else:\n                print ('There was some problem with your geoJSON file, we imported as many layers as possible!')\n\n        except:\n            pass\nelse:\n    print ('To Import you need to input a boolean toggle')\n\n\n# return outputs if you have them; here I try it for you:\n# return (Geometry, Attributes, Values, LayerNames)\n# RunScript(Import, geoJSONFolderPath, SiteNumber)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}