{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_connector_diagnostics.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_connector_diagnostics.py",
  "instruction": "MEP Connector Diagnostics for Grasshopper.",
  "code": "# File: scripts/gh_connector_diagnostics.py\n\"\"\"MEP Connector Diagnostics for Grasshopper.\n\nThis diagnostic component extracts ALL available properties from Revit\nMEP connectors to help understand how connector directions work across\ndifferent plumbing fixture types.\n\nKey Questions to Investigate:\n1. What does CoordinateSystem.BasisZ represent for different fixtures?\n2. Does it vary by fixture type (faucet vs drain vs toilet)?\n3. What other properties might indicate routing direction?\n4. How does FlowDirection relate to physical pipe routing?\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n    Rhino.Inside.Revit\n\nInput Requirements:\n    plumbing_fixtures (fixtures) - list:\n        Revit FamilyInstance elements (sinks, toilets, etc.)\n        Required: Yes\n        Access: List\n\n    run (run) - bool:\n        Execute toggle\n        Required: Yes\n        Access: Item\n\nOutputs:\n    diagnostics_json (json) - str:\n        Full JSON dump of all connector properties\n\n    summary (summary) - str:\n        Human-readable summary of findings\n\n    debug_info (info) - str:\n        Processing log\n\nAuthor: Claude AI Assistant\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\nimport sys\nimport json\nimport traceback\n\n# Force reload\nFORCE_RELOAD = True\nif FORCE_RELOAD:\n    modules_to_reload = [k for k in sys.modules.keys()\n                         if 'timber_framing_generator' in k]\n    for mod_name in modules_to_reload:\n        del sys.modules[mod_name]\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Connector Diagnostics\"\nCOMPONENT_NICKNAME = \"ConnDiag\"\nCOMPONENT_MESSAGE = \"v1.0\"\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef get_element_info(element):\n    \"\"\"Extract basic element info.\"\"\"\n    info = {\n        \"id\": 0,\n        \"family_name\": \"Unknown\",\n        \"type_name\": \"Unknown\",\n        \"category\": \"Unknown\",\n    }\n\n    # Get ID\n    elem_id = getattr(element, 'Id', None)\n    if elem_id:\n        info[\"id\"] = int(getattr(elem_id, 'IntegerValue', 0))\n\n    # Get family/type names\n    try:\n        symbol = getattr(element, 'Symbol', None)\n        if symbol:\n            family = getattr(symbol, 'Family', None)\n            if family:\n                info[\"family_name\"] = str(getattr(family, 'Name', 'Unknown'))\n            info[\"type_name\"] = str(getattr(symbol, 'Name', 'Unknown'))\n    except:\n        pass\n\n    # Get category\n    try:\n        category = getattr(element, 'Category', None)\n        if category:\n            info[\"category\"] = str(getattr(category, 'Name', 'Unknown'))\n    except:\n        pass\n\n    return info\n\n\ndef extract_all_connector_properties(conn):\n    \"\"\"Extract ALL available properties from a connector for investigation.\"\"\"\n    props = {}\n\n    # Basic properties\n    props[\"id\"] = getattr(conn, 'Id', 0)\n\n    # Domain\n    domain = getattr(conn, 'Domain', None)\n    props[\"domain\"] = str(domain) if domain else None\n\n    # System type\n    pipe_sys = getattr(conn, 'PipeSystemType', None)\n    props[\"pipe_system_type\"] = str(pipe_sys) if pipe_sys else None\n\n    # Connection status\n    props[\"is_connected\"] = getattr(conn, 'IsConnected', None)\n\n    # Radius (for round connectors)\n    radius = getattr(conn, 'Radius', None)\n    if radius is not None:\n        props[\"radius_ft\"] = float(radius)\n        props[\"radius_in\"] = float(radius) * 12\n\n    # Flow direction\n    flow_dir = getattr(conn, 'FlowDirection', None)\n    props[\"flow_direction\"] = str(flow_dir) if flow_dir else None\n\n    # Shape\n    shape = getattr(conn, 'Shape', None)\n    props[\"shape\"] = str(shape) if shape else None\n\n    # Direction (might be different from BasisZ)\n    direction = getattr(conn, 'Direction', None)\n    if direction:\n        props[\"direction\"] = {\n            \"x\": float(getattr(direction, 'X', 0)),\n            \"y\": float(getattr(direction, 'Y', 0)),\n            \"z\": float(getattr(direction, 'Z', 0)),\n        }\n\n    # Origin\n    origin = getattr(conn, 'Origin', None)\n    if origin:\n        props[\"origin\"] = {\n            \"x\": float(getattr(origin, 'X', 0)),\n            \"y\": float(getattr(origin, 'Y', 0)),\n            \"z\": float(getattr(origin, 'Z', 0)),\n        }\n\n    # CoordinateSystem (this is what we've been using)\n    coord_sys = getattr(conn, 'CoordinateSystem', None)\n    if coord_sys:\n        props[\"coordinate_system\"] = {}\n\n        # BasisX\n        basis_x = getattr(coord_sys, 'BasisX', None)\n        if basis_x:\n            props[\"coordinate_system\"][\"basis_x\"] = {\n                \"x\": float(getattr(basis_x, 'X', 0)),\n                \"y\": float(getattr(basis_x, 'Y', 0)),\n                \"z\": float(getattr(basis_x, 'Z', 0)),\n            }\n\n        # BasisY\n        basis_y = getattr(coord_sys, 'BasisY', None)\n        if basis_y:\n            props[\"coordinate_system\"][\"basis_y\"] = {\n                \"x\": float(getattr(basis_y, 'X', 0)),\n                \"y\": float(getattr(basis_y, 'Y', 0)),\n                \"z\": float(getattr(basis_y, 'Z', 0)),\n            }\n\n        # BasisZ (what we've been using as \"direction\")\n        basis_z = getattr(coord_sys, 'BasisZ', None)\n        if basis_z:\n            props[\"coordinate_system\"][\"basis_z\"] = {\n                \"x\": float(getattr(basis_z, 'X', 0)),\n                \"y\": float(getattr(basis_z, 'Y', 0)),\n                \"z\": float(getattr(basis_z, 'Z', 0)),\n            }\n\n        # Origin from coordinate system\n        cs_origin = getattr(coord_sys, 'Origin', None)\n        if cs_origin:\n            props[\"coordinate_system\"][\"origin\"] = {\n                \"x\": float(getattr(cs_origin, 'X', 0)),\n                \"y\": float(getattr(cs_origin, 'Y', 0)),\n                \"z\": float(getattr(cs_origin, 'Z', 0)),\n            }\n\n    # Angle (if available)\n    angle = getattr(conn, 'Angle', None)\n    if angle is not None:\n        props[\"angle_rad\"] = float(angle)\n        props[\"angle_deg\"] = float(angle) * 180.0 / 3.14159265359\n\n    # Connector type\n    conn_type = getattr(conn, 'ConnectorType', None)\n    props[\"connector_type\"] = str(conn_type) if conn_type else None\n\n    # Description (if any)\n    description = getattr(conn, 'Description', None)\n    props[\"description\"] = str(description) if description else None\n\n    # AllRefs (connected elements)\n    try:\n        all_refs = getattr(conn, 'AllRefs', None)\n        if all_refs:\n            props[\"connected_count\"] = all_refs.Size\n    except:\n        pass\n\n    return props\n\n\ndef analyze_directions(connectors_data):\n    \"\"\"Analyze direction patterns across fixtures.\"\"\"\n    analysis = {\n        \"by_system_type\": {},\n        \"by_fixture_type\": {},\n        \"direction_patterns\": [],\n    }\n\n    for fixture_data in connectors_data:\n        fixture_type = fixture_data.get(\"family_name\", \"Unknown\")\n\n        for conn in fixture_data.get(\"connectors\", []):\n            sys_type = conn.get(\"pipe_system_type\", \"Unknown\")\n\n            # Track by system type\n            if sys_type not in analysis[\"by_system_type\"]:\n                analysis[\"by_system_type\"][sys_type] = []\n\n            basis_z = conn.get(\"coordinate_system\", {}).get(\"basis_z\", {})\n            direction = conn.get(\"direction\", {})\n            flow = conn.get(\"flow_direction\", \"Unknown\")\n\n            pattern = {\n                \"fixture\": fixture_type,\n                \"system_type\": sys_type,\n                \"flow_direction\": flow,\n                \"basis_z\": basis_z,\n                \"direction_prop\": direction,\n            }\n\n            analysis[\"by_system_type\"][sys_type].append(pattern)\n            analysis[\"direction_patterns\"].append(pattern)\n\n            # Track by fixture\n            if fixture_type not in analysis[\"by_fixture_type\"]:\n                analysis[\"by_fixture_type\"][fixture_type] = []\n            analysis[\"by_fixture_type\"][fixture_type].append(pattern)\n\n    return analysis\n\n\ndef create_summary(connectors_data, analysis):\n    \"\"\"Create human-readable summary.\"\"\"\n    lines = []\n    lines.append(\"=\" * 60)\n    lines.append(\"CONNECTOR DIRECTION ANALYSIS\")\n    lines.append(\"=\" * 60)\n\n    lines.append(\"\")\n    lines.append(f\"Total fixtures analyzed: {len(connectors_data)}\")\n    total_connectors = sum(len(f.get(\"connectors\", [])) for f in connectors_data)\n    lines.append(f\"Total connectors found: {total_connectors}\")\n\n    # By system type\n    lines.append(\"\")\n    lines.append(\"-\" * 40)\n    lines.append(\"DIRECTION ANALYSIS BY SYSTEM TYPE\")\n    lines.append(\"-\" * 40)\n\n    for sys_type, patterns in analysis[\"by_system_type\"].items():\n        lines.append(f\"\\n{sys_type} ({len(patterns)} connectors):\")\n\n        # Summarize BasisZ directions\n        z_values = [p.get(\"basis_z\", {}).get(\"z\", 0) for p in patterns]\n        avg_z = sum(z_values) / len(z_values) if z_values else 0\n\n        lines.append(f\"  Average BasisZ.z: {avg_z:.3f}\")\n        lines.append(f\"  Range: {min(z_values):.3f} to {max(z_values):.3f}\")\n\n        # Flow directions\n        flows = set(p.get(\"flow_direction\") for p in patterns)\n        lines.append(f\"  Flow directions: {flows}\")\n\n        # Sample connectors\n        lines.append(\"  Sample BasisZ vectors:\")\n        for p in patterns[:3]:\n            bz = p.get(\"basis_z\", {})\n            lines.append(f\"    {p['fixture']}: ({bz.get('x', 0):.3f}, {bz.get('y', 0):.3f}, {bz.get('z', 0):.3f})\")\n\n    # By fixture type\n    lines.append(\"\")\n    lines.append(\"-\" * 40)\n    lines.append(\"DIRECTION ANALYSIS BY FIXTURE TYPE\")\n    lines.append(\"-\" * 40)\n\n    for fixture_type, patterns in analysis[\"by_fixture_type\"].items():\n        lines.append(f\"\\n{fixture_type}:\")\n\n        for p in patterns:\n            bz = p.get(\"basis_z\", {})\n            sys = p.get(\"system_type\", \"?\")\n            flow = p.get(\"flow_direction\", \"?\")\n            lines.append(f\"  {sys} (flow={flow}): BasisZ=({bz.get('x', 0):.3f}, {bz.get('y', 0):.3f}, {bz.get('z', 0):.3f})\")\n\n    # Key observations\n    lines.append(\"\")\n    lines.append(\"-\" * 40)\n    lines.append(\"KEY QUESTIONS TO ANSWER\")\n    lines.append(\"-\" * 40)\n    lines.append(\"1. Do drain connectors consistently point DOWN (Z < 0)?\")\n    lines.append(\"2. Do supply connectors point toward pipe source?\")\n    lines.append(\"3. Is 'Direction' property different from BasisZ?\")\n    lines.append(\"4. Does FlowDirection correlate with physical routing?\")\n\n    return \"\\n\".join(lines)\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    # Initialize outputs\n    diagnostics_json = \"{}\"\n    summary = \"\"\n    debug_lines = []\n\n    debug_lines.append(\"=\" * 50)\n    debug_lines.append(\"CONNECTOR DIAGNOSTICS\")\n    debug_lines.append(\"=\" * 50)\n\n    try:\n        # Check run\n        if not run:\n            debug_lines.append(\"Toggle 'run' to True to execute\")\n            return diagnostics_json, summary, \"\\n\".join(debug_lines)\n\n        # Check input\n        if not plumbing_fixtures:\n            debug_lines.append(\"No plumbing fixtures provided\")\n            return diagnostics_json, summary, \"\\n\".join(debug_lines)\n\n        debug_lines.append(f\"Analyzing {len(plumbing_fixtures)} fixtures...\")\n\n        # Extract all connector data\n        all_fixture_data = []\n\n        for element in plumbing_fixtures:\n            element_info = get_element_info(element)\n            fixture_data = {\n                **element_info,\n                \"connectors\": [],\n            }\n\n            # Get MEP connectors\n            mep_model = getattr(element, 'MEPModel', None)\n            if mep_model is None:\n                debug_lines.append(f\"  {element_info['id']}: No MEPModel\")\n                continue\n\n            conn_manager = getattr(mep_model, 'ConnectorManager', None)\n            if conn_manager is None:\n                debug_lines.append(f\"  {element_info['id']}: No ConnectorManager\")\n                continue\n\n            connector_set = getattr(conn_manager, 'Connectors', None)\n            if connector_set is None:\n                continue\n\n            for conn in connector_set:\n                # Only plumbing connectors\n                domain = getattr(conn, 'Domain', None)\n                domain_str = str(domain) if domain else \"\"\n                if 'Piping' not in domain_str:\n                    continue\n\n                # Extract all properties\n                conn_props = extract_all_connector_properties(conn)\n                fixture_data[\"connectors\"].append(conn_props)\n\n            if fixture_data[\"connectors\"]:\n                all_fixture_data.append(fixture_data)\n                debug_lines.append(f\"  {element_info['family_name']}: {len(fixture_data['connectors'])} connectors\")\n\n        debug_lines.append(f\"\\nTotal fixtures with connectors: {len(all_fixture_data)}\")\n\n        # Analyze patterns\n        analysis = analyze_directions(all_fixture_data)\n\n        # Build output\n        output = {\n            \"fixtures\": all_fixture_data,\n            \"analysis\": analysis,\n        }\n        diagnostics_json = json.dumps(output, indent=2)\n\n        # Create summary\n        summary = create_summary(all_fixture_data, analysis)\n\n        debug_lines.append(\"\")\n        debug_lines.append(\"=\" * 50)\n        debug_lines.append(\"DIAGNOSTICS COMPLETE\")\n        debug_lines.append(\"=\" * 50)\n\n    except Exception as e:\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return diagnostics_json, summary, \"\\n\".join(debug_lines)\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif 'run' not in dir():\n    run = False\n\nif 'plumbing_fixtures' not in dir():\n    plumbing_fixtures = []\n\ndiagnostics_json, summary, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}