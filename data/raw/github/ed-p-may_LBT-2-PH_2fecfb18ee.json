{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/lbt_to_phpp.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/lbt_to_phpp.py",
  "instruction": "Lbt to phpp",
  "code": "import Grasshopper.Kernel as ghK\nimport ghpythonlib.components as ghc\nimport Rhino\nimport Rhino.Geometry.Vector2d\nimport rhinoscriptsyntax as rs\nimport math\nfrom collections import OrderedDict\nfrom collections import namedtuple\n\nimport LBT2PH.materials\nimport LBT2PH.assemblies\nimport LBT2PH.windows\nimport LBT2PH.spaces\nimport LBT2PH.ground\nimport LBT2PH.dhw\nimport LBT2PH.appliances\nimport LBT2PH.climate\nimport LBT2PH.summer_vent\nimport LBT2PH.heating_cooling\nimport LBT2PH.occupancy\nimport LBT2PH.surfaces\n\nreload(LBT2PH.materials)\nreload(LBT2PH.assemblies)\nreload(LBT2PH.windows)\nreload(LBT2PH.spaces)\nreload(LBT2PH.ground)\nreload(LBT2PH.dhw)\nreload(LBT2PH.appliances)\nreload(LBT2PH.climate)\nreload(LBT2PH.summer_vent)\nreload(LBT2PH.heating_cooling)\nreload(LBT2PH.occupancy)\nreload(LBT2PH.surfaces)\n\ntry:\n    import ladybug.epw as epw  \n    from ladybug_rhino.fromgeometry import from_face3d\n    from ladybug_rhino.togeometry import to_vector2d\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n\nclass PHPP_Zone:\n    def __init__(self, _room):\n        self.hb_room = _room\n        self.phpp_spaces = self._create_phpp_spaces()\n        self.ScheduleName = 'Schedule Name'\n        self.DesignFlowRate = 'Design Flow Rate'\n        self.FlowRatePerFloorArea = 'Flow per Zone Floor Area'\n        self.FlowRatePerSurfaceArea =  'Flow per Exterior Surface Area'\n        self.ACH = 'Air Changes per Hour'\n    \n    @property\n    def Name(self):\n        return self.hb_room.display_name\n\n    @property\n    def ZoneName(self):\n        return self.hb_room.display_name\n\n    @property\n    def floor_area_gross(self):\n        return self.hb_room.floor_area\n\n    @property\n    def n50(self):\n        # Get the basic parameters needed\n        blower_pressure = 50.0 #Pa\n        normal_avg_pressure = 4.0 #Pa\n        q50 = self.hb_room.properties.energy.infiltration.flow_per_exterior_area\n\n        # Determine the ACH from the q50 value\n        infil_flow_rate_at_normal_pressure = q50 * self.hb_room.exposed_area\n        factor =  math.pow((blower_pressure/normal_avg_pressure), 0.63)\n        infil_flow_rate_at_50PA = factor * infil_flow_rate_at_normal_pressure   # m3/s\n        infil_flow_rate_at_50PA = infil_flow_rate_at_50PA * 3600                # m3/hr\n        \n        if self.vn50:\n            n50 = infil_flow_rate_at_50PA / self.vn50\n            return n50\n        else:\n            return None\n\n    @property\n    def vn50(self):\n        vn50_total = sum([space.space_vn50 for space in self.phpp_spaces])\n        return vn50_total\n\n    def _create_phpp_spaces(self):\n        spaces = []\n        if not self.hb_room.user_data:\n            return spaces\n        \n        try:\n            phpp_spaces = self.hb_room.user_data.get('phpp', {}).get('spaces', {})\n            for space_dict in phpp_spaces.values():\n                new_space = LBT2PH.spaces.Space.from_dict(space_dict)\n                spaces.append( new_space )\n        except KeyError as e:\n            print(e)\n\n        return spaces\n\n    def __unicode__(self):\n        return u'A PHPP-Style Zone/HB-Room Object: < {self.Name} >'.format(self=self)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_room={!r})\".format(\n            self.__class__.__name__, self.hb_room)\n\ndef rhino_vector2d_from_angle(_angle=0):\n    \"\"\" Get a Rhino Vector2d from a numeric angle\n\n        Arguments:\n            _angle (float): Angle in degrees. Note, this should\n            be a positive value representing the degree of\n            rotation (about the Z axis) from Y. North 0=0\n            West=90, South=180, East=270\n    \"\"\"\n\n    if not _angle:\n        return None\n\n    # Use the Grasshopper rotate to create the new vector\n    # according to the numeric angle\n    origin = Rhino.Geometry.Point3d(0,0,0)\n    north_axis = Rhino.Geometry.Vector3d(0,1,0) \n    angle = ghc.Radians(_angle)\n    rotation_axis_vec = Rhino.Geometry.Vector3d(0,0,1)\n    rotation_axis_line = ghc.LineSDL(origin, rotation_axis_vec, 1)\n    north_vec = ghc.RotateAxis(north_axis, angle, rotation_axis_line).geometry\n\n    return north_vec\n\ndef _find_north( _north ):\n    if _north:\n        try:\n            # If the input is a vector, convert to ladybug vector2d\n            return to_vector2d( _north )\n        except AttributeError as e:  \n            # If its not an error, must be a number. So first create a Rhino vector\n            try:\n                rh_vec = rhino_vector2d_from_angle(float(_north))\n                return to_vector2d( rh_vec )\n            except Exception as e:\n                print(e)\n                raise e\n    else:\n        return to_vector2d( Rhino.Geometry.Vector2d(0,1) )\n\ndef get_zones_from_model(_model):\n    zones = []\n    \n    for room in _model.rooms:\n        new_room = PHPP_Zone(room)\n        zones.append(new_room)\n    \n    return zones\n\ndef get_exposed_surfaces_from_model(_model, _north, _ghenv):\n    exposed_surfaces = []\n\n    for room in _model.rooms: \n        room_name = room.display_name\n        room_id = room.identifier\n\n        for face in room:\n            bc = str(face.boundary_condition)\n\n            if bc == 'Surface': continue\n            phpp_srfc = LBT2PH.surfaces.PHPP_Surface(face, room_name, room_id, _north, _ghenv )\n            \n            # Pull out any custom attributes set within the GH scene\n            # Set Object Attributes using the Key / Value\n            if face.user_data:\n                custom_attributes = face.user_data.get('phpp', {})\n            \n                for k, v in custom_attributes.items():\n                    setattr(phpp_srfc, k, v)\n                \n            exposed_surfaces.append(phpp_srfc)\n\n    return exposed_surfaces\n\ndef get_opaque_materials_from_model(_model, _ghenv):\n    phpp_materials = {}\n    for face in _model.faces:\n        for ep_mat in face.properties.energy.construction.materials:\n            if ep_mat.display_name not in phpp_materials:\n                phpp_material = LBT2PH.materials.PHPP_Material_Opaque( ep_mat )\n                phpp_materials[ep_mat.display_name] = phpp_material\n            \n    return phpp_materials\n\ndef get_opaque_constructions_from_model(_model, _ghenv):\n    ep_constructions = {}\n    for face in _model.faces:\n        construction = face.properties.energy.construction\n        ep_constructions[construction.display_name] = construction\n    \n    phpp_constructions = []\n    for k, v in ep_constructions.items():\n        new_construction = LBT2PH.assemblies.PHPP_Construction(v)\n        phpp_constructions.append(new_construction)\n    \n    return phpp_constructions\n\ndef get_aperture_materials_from_model(_model):\n    ep_mats = OrderedDict()\n    for aperture in _model.apertures:\n        for mat in aperture.properties.energy.construction.materials:\n            ep_mats[mat.identifier] = mat\n    \n    phpp_materials = []\n    for i, (k, v) in enumerate(ep_mats.items()):\n        ud_num = i+1\n        new_window_material = LBT2PH.materials.PHPP_Material_Window_EP(v, ud_num)\n        phpp_materials.append(new_window_material)\n\n    return phpp_materials\n\ndef get_aperture_constructions_from_model(_model):\n    ep_constructions = {}\n    for aperture in _model.apertures:\n        construction = aperture.properties.energy.construction\n        ep_constructions[construction.identifier] = construction\n\n    phpp_constructions = []\n    for k, v in ep_constructions.items():\n        new_construction = LBT2PH.assemblies.PHPP_Construction(v)\n        phpp_constructions.append(new_construction)\n    \n    return phpp_constructions        \n\ndef get_aperture_surfaces_from_model(_model, _ghenv):\n    ''' Returns a list of PHPP_Window objects found in the HB Model '''\n    \n    phpp_apertures = []\n    \n    for hb_aperture in _model.apertures:\n        try:\n            window_dict = hb_aperture.user_data.get('phpp', {})\n            if not window_dict:\n                raise AttributeError\n\n            new_phpp_aperture = LBT2PH.windows.PHPP_Window.from_dict( window_dict )\n            new_phpp_aperture.aperture = hb_aperture\n            \n            phpp_apertures.append(new_phpp_aperture)\n        except AttributeError as e:\n            try:\n                msg = 'I did not find any user-determined info for window: < {} >.\\n'\\\n                    'I will use the basic Honeybee Aperture info for now, but to customize\\n'\\\n                    'this window you can use a PH-Tools \"Create PHPP Aperture\" Component\\n'\\\n                    'to apply specific PHPP style information to this element.'.format(hb_aperture.display_name)\n                _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Remark, msg)\n                \n                # Build a basic aperture from the Honeybee only\n                new_phpp_aperture = LBT2PH.windows.PHPP_Window.from_aperture(hb_aperture)\n                \n                phpp_apertures.append(new_phpp_aperture)\n            except Exception as e:\n                msg = 'Error trying to create the PHPP window for < {} >.\\n'\\\n                    'Make sure that you use a PH-Tools \"Create PHPP Aperture\" Component\\n'\\\n                    'to apply the PHPP style information to this element.'.format(hb_aperture.display_name)\n                _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Warning, msg)\n\n    return phpp_apertures\n\ndef get_spaces_from_model(_model, _ghdoc, _sort=False):\n    ''' Returns a list of PHPP_Space objects found in the HB Model '''\n    spaces = [] \n    \n    # -- sort\n    if _sort:\n        rooms = sorted(_model.rooms, key=lambda room: room.identifier)\n    else:\n        rooms = _model.rooms\n\n    # -- \n    for room in rooms:\n        if not room.user_data:\n            print('No User_Data dict found for room < {} >.\\n'\\\n            'Ignoring any Space/Room/TFA/Volume info for now.'.format(room.display_name))\n            return []\n        \n        spaces_dict = room.user_data.get('phpp', {}).get('spaces', {})\n        for space_data in spaces_dict.values():\n            space_obj = LBT2PH.spaces.Space.from_dict( space_data )\n            spaces.append(space_obj)\n    \n    return spaces\n\ndef get_ventilation_systems_from_model(_model, _ghenv):\n    model_vent_systems = set()\n    \n    for hb_room in _model.rooms:\n        \n        if not hb_room.user_data:\n            continue\n        \n        vent_system_dict = hb_room.user_data.get('phpp', {}).get('vent_system', {})\n        \n        if vent_system_dict:\n            room_vent_system = LBT2PH.ventilation.PHPP_Sys_Ventilation.from_dict(vent_system_dict, _ghenv)\n            model_vent_systems.add(room_vent_system)\n\n    return list(model_vent_systems)\n\ndef get_ground_from_model(_model, _ghenv):  \n    ground_objs = []\n    \n    for hb_room in _model.rooms:      \n        if not hb_room.user_data:\n            continue\n\n        ground_dict = hb_room.user_data.get('phpp', {}).get('ground', {})\n        if not ground_dict:\n            continue\n\n        ground_type = ground_dict.get('type', {})\n        if '1' in ground_type:\n            obj = LBT2PH.ground.PHPP_Ground_Slab_on_Grade.from_dict( ground_dict, _ghenv )\n        elif '2' in ground_type:\n            obj = LBT2PH.ground.PHPP_Ground_Heated_Basement.from_dict( ground_dict, _ghenv )\n        elif '3' in ground_type:\n            obj = LBT2PH.ground.PHPP_Ground_Unheated_Basement.from_dict( ground_dict, _ghenv )\n        elif '4' in ground_type:\n            obj = LBT2PH.ground.PHPP_Ground_Crawl_Space.from_dict( ground_dict, _ghenv )\n        else:\n            obj = None\n    \n        if obj:\n            ground_objs.append( obj )\n\n    return ground_objs\n\ndef get_dhw_systems(_model):\n    dhw_systems = []\n\n    for hb_room in _model.rooms:\n        if not hb_room.user_data:\n            continue\n\n        dhw_dict = hb_room.user_data.get('phpp', {}).get('dhw_systems', {})\n        for system in dhw_dict.values():\n            new_system = LBT2PH.dhw.PHPP_DHW_System.from_dict( system )\n            dhw_systems.append( new_system )\n\n    return dhw_systems\n\ndef get_appliances(_model):\n    appliance_objs = []\n\n    if not _model.user_data:\n        print('No User_Data dict found on the model. Ignoring Appliances for now')\n        return appliance_objs\n\n    appliances_set_dict = _model.user_data.get('phpp', {}).get('appliances', {})\n    appliances_set = LBT2PH.appliances.ApplianceSet.from_dict( appliances_set_dict )\n    for app_obj in appliances_set:\n        appliance_objs.append(app_obj)\n\n    return appliance_objs\n\ndef get_lighting(_model):\n    Lighting = namedtuple('Lighting', ['efficacy', 'hb_room_name', 'hb_room_tfa'])\n\n    out = []\n    for room in _model.rooms:\n        if not room.user_data:\n            continue\n        \n        appliances_dicts = room.user_data.get('phpp', {}).get('appliances', {})\n        spaces_dicts = room.user_data.get('phpp', {}).get('spaces', {})\n        if not appliances_dicts or not spaces_dicts:\n            continue\n        \n        name = room.display_name\n        efficacy =  float( appliances_dicts.get('lighting_efficacy', 50) )\n\n        space_tfas = []\n        for space_dict in spaces_dicts.values():\n            space_tfas.append( float( space_dict.get('_tfa', 0)) )\n        space_tfa = sum(space_tfas)\n\n        out.append( Lighting(efficacy, name, space_tfa) )\n\n    return out\n\ndef get_climate(_model, _epw_file):\n    if not _model.user_data:\n        # No user_data, so auto-find the nearest climate based on the EPW file location\n\n        print('No User_Data dict found on the model. Using automatic climate for now.')\n        return find_nearest_phpp_climate( _epw_file )\n    else:\n        # If there IS a user_dict on the model, try and pull the climate info out of it.\n        # Try and build a new UD-Climate obj from the dict data.\n        # If any of the dict data for Country, Region and Set are None, then\n        # use the EPW to find the nearest cliamte instead.\n\n        ud_climate_params = _model.user_data.get('phpp', {}).get('climate', None)\n\n        if ud_climate_params:\n            for climate_dict in ud_climate_params.values():\n                ud_climate_obj = LBT2PH.climate.PHPP_ClimateDataSet.from_dict( climate_dict )\n                \n                if ud_climate_obj:\n                    return [ ud_climate_obj ]\n                else:\n                    return find_nearest_phpp_climate( _epw_file )  \n        else:\n            return find_nearest_phpp_climate( _epw_file )  \n\ndef find_nearest_phpp_climate(_epw_file):\n    \"\"\" Finds the nearest PHPP Climate zone to the EPW Lat / Long \n    \n    Methodology copied from the PHPP v 9.6a (SI) Climate worksheet\n    \"\"\"\n    \n    #---------------------------------------------------------------------------\n    # Get the Long and Lat\n    if _epw_file:\n        try:\n            ep = epw.EPW(_epw_file)\n            location = ep.location\n            latitude = location.latitude\n            longitude = location.longitude\n        except Exception as e:\n            print(e)\n            print('Error reading Location from EPW for some reason?')\n    else:\n        latitude = 40\n        longitude = -74\n        print('No EPW file input? I will just use NYC then.')\n\n    #---------------------------------------------------------------------------\n    # Find the closest PHPP Climate/Location\n    climate_data = LBT2PH.climate.phpp_climate_data()\n    for each in climate_data:\n        eachLat = float(each.get('Latitude', 0))\n        eachLong = float(each.get('Longitude', 0))\n\n        a = math.sin(math.pi/180*eachLat)\n        b = math.sin(math.pi/180*latitude)\n        c = math.cos(math.pi/180*eachLat)\n        d = math.cos(math.pi/180*latitude)\n        e = math.cos(math.pi/180*(eachLong-longitude))\n        f = a * b + c * d * e\n        g = max([-1, f])\n        h = min([1, g])\n        j = math.acos(h)\n        kmFromEPWLocation = 6378 * j\n        \n        each['distToEPW'] = kmFromEPWLocation\n    \n    climate_data.sort(key=lambda e: e['distToEPW'])\n    climate_set_to_use = climate_data[0]\n    \n    dataSet = climate_set_to_use.get('Dataset', 'US0055b-New York')\n    alt = '=J23'\n    country = climate_set_to_use.get('Country', 'US-United States of America')\n    region = climate_set_to_use.get('Region', 'New York')\n    \n    climate_set_to_use = LBT2PH.climate.PHPP_ClimateDataSet(dataSet, alt, country, region)\n    \n    return [ climate_set_to_use ]\n\ndef get_footprint( _surfaces ):\n\n    # Finds the 'footprint' of the building for 'Primary Energy Renewable' reference\n    # 1) Re-build the Opaque Surfaces\n    # 2) Join all the surface Breps into a single brep\n    # 3) Find the 'box' for the single joined brep\n    # 4) Find the lowest Z points on the box, offset another 10 units 'down'\n    # 5) Make a new Plane at this new location\n    # 6) Projects the brep edges onto the new Plane\n    # 7) Split a surface using the edges, combine back into a single surface\n    \n    Footprint = namedtuple('Footprint', ['Footprint_surface', 'Footprint_area'])\n    \n    # This shit is all busted, just skip it until I can make it work....\n    return Footprint(None, 0)\n\n\n    #----- Build brep\n    surfaces = [from_face3d(surface.Srfc) for surface in _surfaces]\n    bldg_mass = ghc.BrepJoin( surfaces ).breps\n    \n    if isinstance(bldg_mass, list): # returns a list of breps if its 'open' sometimes\n        bldg_mass = ghc.BrepJoin( bldg_mass ).breps\n    else:\n        bldg_mass = ghc.BoundaryVolume(bldg_mass)\n    \n    if not bldg_mass:\n        return Footprint(bldg_mass, None)\n    \n    #------- Find Corners, Find 'bottom' (lowest Z)\n    bldg_mass_corners = [v for v in ghc.BoxCorners(bldg_mass)]\n    bldg_mass_corners.sort(reverse=False, key=lambda point3D: point3D.Z)\n    rect_pts = bldg_mass_corners[0:3]\n    \n    #------- Projection Plane\n    projection_plane1 = ghc.Plane3Pt(rect_pts[0], rect_pts[1], rect_pts[2])\n    projection_plane2 = ghc.Move(projection_plane1, ghc.UnitZ(-10)).geometry\n    matrix = rs.XformPlanarProjection(projection_plane2)\n    \n    #------- Project Edges onto Projection Plane\n    projected_edges = []\n    for edge in ghc.DeconstructBrep(bldg_mass).edges:\n        projected_edges.append( ghc.Transform( edge, matrix) )\n    \n    #------- Split the projection surface using the curves\n    l1 = ghc.Line(rect_pts[0], rect_pts[1])\n    l2 = ghc.Line(rect_pts[0], rect_pts[2])\n    max_length = max(ghc.Length(l1), ghc.Length(l2))\n\n    projection_surface = ghc.Polygon(projection_plane2, max_length*100, 4, 0).polygon\n    projected_surfaces = ghc.SurfaceSplit( projection_surface, projected_edges)\n\n    #------- Remove the biggest surface from the set(the background srfc)\n    projected_surfaces.sort( key=lambda x: x.GetArea()) \n    projected_surfaces.pop(-1)\n\n    #------- Join the new srfcs back together into a single one\n    \"\"\"\n    # \n    # Note: this was the 'old' solution.\n    # April 2021 Changed to use a Mesh technique to handle cases better\n    # Still not sure it works on all cases? Donuts, open Breps, etc...\n    # \n    unioned_breps = ghc.SolidUnion(projected_surfaces)\n    unioned_NURB = ghc.RegionUnion( unioned_breps )\n    \"\"\"\n\n    #------- Convert to Meshes -----NEW APRIL 2021\n    def join_building_surfaces( _surfaces_to_join ):\n        \"\"\"Takes in a set of surfaces and tries to join them into a single surface \n\n        -> A single surface (if it worked) or a list of surfaces (if it didn't work)\n\n        Args:\n            _surfaces_to_join: [itearble] A list of surfaces to join\n        Returns:\n            joined_surface: [surface] or [list] A single surface OR a list of surfaces\n        \"\"\"\n\n        mesh_srfcs = []\n        ms = Rhino.Geometry.MeshingParameters().Default\n        for srfc in projected_surfaces:\n            # Use list() and .extend Cus it returns an Array\n            mesh_srfcs.extend(list(Rhino.Geometry.Mesh.CreateFromBrep(srfc, ms)))\n\n        joined_mesh = ghc.MeshJoin(mesh_srfcs)\n        mesh_perim_crv = ghc.MeshEdges(joined_mesh).naked_edges\n        joined_surface = ghc.BoundarySurfaces(mesh_perim_crv)\n\n        return joined_surface\n\n    unioned_surface = join_building_surfaces(projected_surfaces)\n    \n    \"\"\"If it doesn't work, I'll get a list of surfaces instead of a single one. \n    Not sure what do do? I suppose I'll try and join them together somehow... \"\"\"\n    if isinstance(unioned_surface, list):\n        unioned_surface = join_building_surfaces(unioned_surface) # Try one more time\n        if isinstance(unioned_surface, list):\n            total_area = 0\n            for srfc in unioned_surface:\n                total_area += srfc.GetArea()\n\n            return Footprint(unioned_surface, total_area)\n\n    return Footprint(unioned_surface, unioned_surface.GetArea())\n\ndef get_thermal_bridges(_model, _ghenv):\n    results = []\n    try:\n        if not _model.user_data:\n            raise ValueError\n        \n        tb_dict = _model.user_data.get('phpp', {}).get('tb', {})\n        for tb_obj_dict in tb_dict.values():\n            new_obj = LBT2PH.tb.PHPP_ThermalBridge.from_dict( tb_obj_dict )\n            results.append( new_obj )\n    except TypeError as e:\n        msg = 'Error getting the PHPP/tb dict from the model.user_data?'\n        msg += str(e)\n        _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Warning, msg)\n    except ValueError:\n        print('No User_Data dict found on the model. Ignoring Thermal Bridging for now.')\n\n    return results\n\ndef get_settings(_model):\n    settings_obj = []\n    if not _model.user_data:\n        print('No User_Data dict found on the model. Ignoring PHPP Settings for now.')\n        return settings_obj\n\n\n    settings_dict = _model.user_data.get('phpp',{}).get('settings',None)\n    if settings_dict:\n        \n        for settings_params in settings_dict.values():\n            settings_obj.append( LBT2PH.phpp_setup.PHPP_Verification.from_dict( settings_params ) )\n        return settings_obj\n    else:\n        return settings_obj\n\ndef get_summ_vent(_model):\n    summ_vent_objs = []\n    for room in _model.rooms:\n        if not room.user_data:\n            continue\n        \n        summ_vent_d = room.user_data.get('phpp', {}).get('summ_vent', None)\n        if summ_vent_d:\n            for summ_vent_params in summ_vent_d.values():\n                new_obj = LBT2PH.summer_vent.PHPP_SummVent.from_dict( summ_vent_params )    \n                summ_vent_objs.append( new_obj )\n    \n    return summ_vent_objs\n\ndef get_heating_cooling(_model):\n    hc_objs = {}\n    for room in _model.rooms:\n        if not room.user_data:\n            continue\n\n        d = room.user_data.get('phpp', {}).get('heating_cooling')\n        if not d:\n            continue\n        \n        this_room = {}\n        for k, v in d.items():\n            if 'supply_air_cooling' in k:\n                this_room['supply_air_cooling'] = LBT2PH.heating_cooling.PHPP_Cooling_SupplyAir.from_dict(v)\n            elif 'recirc_air_cooling' in k:\n                this_room['recirc_air_cooling'] = LBT2PH.heating_cooling.PHPP_Cooling_RecircAir.from_dict(v)\n            elif 'addnl_dehumid' in k:\n                this_room['addnl_dehumid'] = LBT2PH.heating_cooling.PHPP_Cooling_Dehumid.from_dict(v)\n            elif 'panel_cooling' in k:\n                this_room['panel_cooling'] =  LBT2PH.heating_cooling.PHPP_Cooling_Panel.from_dict(v)\n            elif 'hp_heating' in k:\n                this_room['hp_heating'] = LBT2PH.heating_cooling.PHPP_HP_AirSource.from_dict(v)\n            elif 'hp_DHW_' in k:\n                this_room['hp_DHW'] = LBT2PH.heating_cooling.PHPP_HP_AirSource.from_dict(v)\n            elif 'hp_options_' in k:\n                this_room['hp_options'] = LBT2PH.heating_cooling.PHPP_HP_Options.from_dict(v)\n            elif 'hp_ground_' in k:\n                this_room['hp_ground'] = None\n            elif 'boiler' in k:\n                this_room['boiler'] = LBT2PH.heating_cooling.PHPP_Boiler.from_dict(v)\n            elif 'compact' in k:\n                this_room['compact'] = None\n            elif 'district_heat' in k:\n                this_room['district_heat'] = None\n\n        hc_objs[room.display_name] = this_room\n\n    return hc_objs\n\ndef get_PER( _model ):\n    per_objs = {}\n\n    for room in _model.rooms:\n        if not room.user_data:\n            continue\n        \n        d = room.user_data.get('phpp', {}).get('PER')\n        if not d:\n            continue\n        \n        per_params = d.values()[0]\n        per_params.update( {'room_floor_area':room.floor_area} )\n\n        per_objs.update( {room.display_name:per_params} )\n\n    return per_objs\n\ndef get_occupancy( _model ):\n    if not _model.user_data:\n        print('No User_Data dict found on the model. Ignoring PHPP Occupancy for now.')\n        return []\n\n    d = _model.user_data.get('phpp', {}).get('occupancy', None)\n    if not d:\n        return []\n        \n    return LBT2PH.occupancy.Occupancy.from_dict( d ) \n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}