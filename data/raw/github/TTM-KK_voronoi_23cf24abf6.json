{
  "source_url": "https://github.com/TTM-KK/voronoi/blob/fbd950eda81840c343df12d2c568719577652364/Main.py",
  "repo": "TTM-KK/voronoi",
  "repo_stars": 1,
  "repo_description": "voronoi & GA",
  "license": "unknown",
  "filepath": "Main.py",
  "instruction": "coding: utf-8",
  "code": "# coding: utf-8\nimport Rhino\nimport scriptcontext\nimport rhinoscriptsyntax as rs\nimport Tetrahedron\nimport Point\n\n\npoints_obj_list = []  # Pointのオブジェクトを保持。\ndivide_tetrahedron_list = []  # このリストに三角形分割を保持していく。[p1, p2, p3]\n\n\n# Rhino上の点群を取得し座標値を取得。\npoints = rs.GetObjects('select points to use 3D Delaunay', rs.filter.point)\n\nfor i in range(len(points)):\n    point = Point.Point(points[i])\n    point.system_guid_obj_to_coordinate()\n\n    points_obj_list.append(point)\n\n\n# ドロネー分割の前準備。\n# はじめの外接円を構成する点のインスタンス作成。この範囲内に点群を収めておく必要あり。\nP1 = Point.Point([0, 0, 800])\nP1.change_coordinate()\nP2 = Point.Point([0, 1000, -200])\nP2.change_coordinate()\nP3 = Point.Point([866.025, -500, -200])\nP3.change_coordinate()\nP4 = Point.Point([-866.025, -500, -200])\nP4.change_coordinate()\n\ntetrahedron = Tetrahedron.Tetrahedron(P1, P2, P3, P4)\ntetrahedron.cul_center_p_and_radius()\ndivide_tetrahedron_list.append(tetrahedron)\n\n\n# ドロネー分割のメインアルゴリズム\n# for _ in range(len(points_obj_list)):\nfor _ in range(len(points_obj_list)):\n\n    # 追加するポイントの選択。\n    select_point = points_obj_list.pop(0)\n\n    # 三角形の外接円内に追加したポイントが内包されていないか判定。内包されている場合はindexを保存。\n    temp_divide_tetrahedron = []\n    count = 0\n    for i in range(len(divide_tetrahedron_list)):\n        tri = divide_tetrahedron_list[i + count]\n        check = tri.check_point_include_circumsphere(select_point)\n        # print('chcek', check)\n        if check:\n            # 内包していた三角形の頂点を使用して再分割する。\n            new_tetrahedron1 = Tetrahedron.Tetrahedron(tri.p1, tri.p2, tri.p3, select_point)\n            new_tetrahedron2 = Tetrahedron.Tetrahedron(tri.p1, tri.p2, tri.p4, select_point)\n            new_tetrahedron3 = Tetrahedron.Tetrahedron(tri.p1, tri.p3, tri.p4, select_point)\n            new_tetrahedron4 = Tetrahedron.Tetrahedron(tri.p2, tri.p3, tri.p4, select_point)\n            new_tetrahedron1.cul_center_p_and_radius()\n            new_tetrahedron2.cul_center_p_and_radius()\n            new_tetrahedron3.cul_center_p_and_radius()\n            new_tetrahedron4.cul_center_p_and_radius()\n\n            temp_divide_tetrahedron.append(new_tetrahedron1)\n            temp_divide_tetrahedron.append(new_tetrahedron2)\n            temp_divide_tetrahedron.append(new_tetrahedron3)\n            temp_divide_tetrahedron.append(new_tetrahedron4)\n\n            del divide_tetrahedron_list[i + count]\n            count = count - 1\n        else:\n            pass\n\n    # 重複している三角形を削除\n\n    del_instances = []\n    for tetra in temp_divide_tetrahedron:\n        for tetra_check in temp_divide_tetrahedron:\n            if tetra == tetra_check:\n                continue\n            if tetra.radius == tetra_check.radius and tetra.center_p == tetra_check.center_p:\n                del_instances.append(tetra_check)\n                del_instances.append(tetra)\n\n    for del_instance in del_instances:\n        if del_instance in temp_divide_tetrahedron:\n            del temp_divide_tetrahedron[temp_divide_tetrahedron.index(del_instance)]\n\n    # 重複三角形を削除した後にappend\n    divide_tetrahedron_list.extend(temp_divide_tetrahedron)\n\n\n# はじめに作成した四面体の母点をもつ四面体分割を削除\n# del_instances = []\n# for tetra_check in divide_tetrahedron_list:\n#     if tetra_check.p1 == P1 or tetra_check.p1 == P2 or tetra_check.p1 == P3 or \\\n#             tetra_check.p1 == P4 or tetra_check.p2 == P1 or tetra_check.p2 == P2 or \\\n#             tetra_check.p2 == P3 or tetra_check.p2 == P4 or tetra_check.p3 == P1 or \\\n#             tetra_check.p3 == P2 or tetra_check.p3 == P3 or tetra_check.p3 == P4 or \\\n#             tetra_check.p4 == P1 or tetra_check.p4 == P2 or tetra_check.p4 == P3 or \\\n#             tetra_check.p4 == P4:\n#         del_instances.append(tetra_check)\n#\n# for del_instance in del_instances:\n#     if del_instance in divide_tetrahedron_list:\n#         del divide_tetrahedron_list[divide_tetrahedron_list.index(del_instance)]\n\n\n# ドロネー描画\nfor i in range(len(divide_tetrahedron_list)):\n    divide_tetrahedron_list[i].draw_divide_tetrahedron()\n\n\n# ボロノイ分割。\n# for i in range(len(divide_tetrahedron_list)):\n#     tri_1 = divide_tetrahedron_list[i]\n#     for j in range(len(divide_tetrahedron_list)):\n#         if i == j:\n#             continue\n#         tri_2 = divide_tetrahedron_list[j]\n#\n#         count = 0\n#         if tri_1.p1 == tri_2.p1 or tri_1.p1 == tri_2.p2 or tri_1.p1 == tri_2.p3 or tri_1.p1 == tri_2.p4:\n#             count += 1\n#         if tri_1.p2 == tri_2.p1 or tri_1.p2 == tri_2.p2 or tri_1.p2 == tri_2.p3 or tri_1.p2 == tri_2.p4:\n#             count += 1\n#         if tri_1.p3 == tri_2.p1 or tri_1.p3 == tri_2.p2 or tri_1.p3 == tri_2.p3 or tri_1.p3 == tri_2.p4:\n#             count += 1\n#         if tri_1.p4 == tri_2.p1 or tri_1.p4 == tri_2.p2 or tri_1.p4 == tri_2.p3 or tri_1.p4 == tri_2.p4:\n#             count += 1\n#\n#         if count == 3:\n#             line = Rhino.Geometry.Line(tri_1.center_p[0], tri_1.center_p[1], tri_1.center_p[2], tri_2.center_p[0],\n#                                        tri_2.center_p[1], tri_2.center_p[2])\n#             scriptcontext.doc.Objects.AddLine(line)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}