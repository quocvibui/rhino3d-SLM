{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/Main.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "Main.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\nfrom Generate import Generate\nimport rhinoscriptsyntax as rs\nimport time\n# import copy\n# import random as rnd\nimport sys\nfrom forMain import Sort\nfrom forMain import timberMethod\nfrom forMain import Instance\nfrom forMain import MoveObject\nimport Rhino.Geometry\nimport scriptcontext\nfrom forMain import drawInformatinon\n# from matplotlib import pyplot\nimport GA.Selection\nimport GA.Evaluation\nimport GA.Crossover\nimport GA.Method\nimport ReGenerate\n\n\nnum_timber = 30         # timberの総本数\nnum_base_timber = 10\ncantilever_num = 10     # 初期生成時の全体の中でのcantileverの数\nbridge_num = 10\n\ndivide_range = 5        # 次世代に継承する材の最低本数を指定\npop_num = 30            # 初期個体数。世代ごとの個体数　ttm add 181003\nelite_num = 2           # エリート選択における選択数。\ngeneration_num = 30     # 世代数\ntournament_size = 5     # トーナメントサイズ\ntournament_num = 3      # トーナメント選択の回数\nmutation_ratio = 3      # 突然変異の確率\ninitial_population_draw = False\nflag_high = True        # ソート昇順の場合True　降順の場合False\n\nconnect_count = 10      # 接合制約数\nname_list = []          # timberの名前\nprototype_ID = 0        # 試作個体の番号\npop_size = pop_num      # 交叉時に生成する個体数\ngenerate_range = 3000   # 生成可能範囲を指定。（現在は立方体） TODO 立方体以外にも対応したいところ。\nbetween_draw_rhino = generation_num  # generation_numを割り切れる数で指定すること。\n\n\nevaluate_list = []        # 各世代の評価値を保存しておくためのリスト\n# temp_center_line = []   # 複製した中心線のリスト\n# temp_surface = []       # 複製したサーフェスのリスト\n# temp_mark = []\ntimber_num = []           # Timberクラスの各インスタンスの通し番号を格納するリスト\nnew_gene_num_list = []\n\n# 制約条件\nlimit_degree = [45, 135]  # 接合角度制約\n\n\n# boolean\ninput_flag = False        # 再生成アルゴリズム用　デバック時に使用すると便利\nredraw_flag = False       # 描画を逐一見るためのフラグ。重くなると思うから普段はFalseで\ninformation_flag = False\nlayer_flag = False\n\n\nrs.AddLayer('all_pop_layer')\nrs.CurrentLayer('all_pop_layer')\n\n# Step0: rhino上のオブジェクトを取得。また通し番号を作成する。\nget_center_line = rs.GetObjects(\"select %s lines\" % num_timber, rs.filter.curve)\nget_surface = rs.GetObjects(\"Select %s Surfaces\" % num_timber, rs.filter.surface)\nget_obj = Sort.scanObjectSort(num_timber, get_center_line, get_surface)\n\nprogram_start = time.time()\n\n# メンバ変数に格納する\ncenter_line = get_obj[0]\nall_surface = get_obj[1]\n# all_mark = get_obj[2]\n\nfor i in range(0, num_timber):\n    name_list.append(i)\n\n\n# Step1: サーフィスと中心線を（個体数*Timberの種類）だけ複製。後でインスタンス変数に取り込むため、リストに格納する\ntemp_center_line = Instance.axis_instance(pop_num, center_line)\ntemp_surface = Instance.surface_instance(pop_num, all_surface)\n# temp_mark = inst.mark_instance(pop_num, all_mark)\n\n# print(\"temp_surface\", temp_surface)\n# print(\"temp_center_line\", temp_center_line)\n\n\n# Step2: Generateクラスのインスタンスを個体数だけ作成\ndic = {}\nfor foo in range(pop_num):\n    dic['generate' + str(foo)] = foo\n\nfor i in range(pop_num):\n    timber_num.append(i)\n\n# スキャンデータを生成クラスに渡し、インスタンス化\nfor i in range(pop_num):\n    dic['generate' + str(i)] = Generate(temp_center_line[i], temp_surface[i], name_list, num_timber, prototype_ID,\n                                        timber_num[i])\n\n\n# Step3: 各Generateクラスのインスタンス毎にTimberクラスのインスタンスを作成\nfor j in range(pop_num):\n    dic['generate' + str(j)].instantiate_timber()  # Timberクラスのインスタンスを作成するGenerateクラスのメソッド\n    dic['generate' + str(j)].pop_index = j  # 個体番号を振る\n    # print(\"pop_index\", dic['generate' + str(j)].pop_index)\n\n\nclosed_curve = rs.GetObjects(\"select closed curves, base timber generated\")\nobjects_curve = []\nif closed_curve:\n    for i in range(len(closed_curve)):\n        curve = rs.coercecurve(closed_curve[i])\n        objects_curve.append(curve)\nelse:\n    raise Exception('select closed curve is Error')\n\n\n# Step4 初期生成\nt1 = time.time()\nrs.EnableRedraw(False)\nfor i in range(pop_num):\n\n    for j in range(num_base_timber):\n        flag_gl = dic['generate' + str(i)].generate_ground_init(generate_range, objects_curve=objects_curve)\n        if flag_gl:\n            pass\n        else:\n            raise Exception('init_base_generation is fail')\n\n    for j in range(num_base_timber):\n        tim = dic['generate' + str(i)].used_list[j]\n\n        copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n        copy_to = Rhino.Geometry.Point3d((generate_range * 2) * i, - generate_range * 2, 0)\n        vec_move = copy_to - copy_from\n\n        MoveObject.MoveTimberObjects(vec_move, tim)\n\n    for j in range(cantilever_num):\n        flag_canti = dic['generate' + str(i)].cantilever(limit_degree)\n        if flag_canti:\n            pass\n        else:\n            raise Exception('cantilever is fail')\n\n    for j in range(bridge_num):\n        flag_bridge = dic['generate' + str(i)].bridge(limit_degree)\n        if flag_bridge:\n            pass\n        else:\n            raise Exception('bridge is fail')\n    \n    # # flag_success = False\n    # flag_success = dic['generate' + str(i)].cantilever(limit_degree)  # Initial Generate Method.\n    # # if not flag_success:\n    # #     input(\"initial cantilever not success\")\n    #\n    # tim1 = dic['generate' + str(i)].used_list[0]\n    # tim2 = dic['generate' + str(i)].used_list[1]\n    #\n    # copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n    # copy_to = Rhino.Geometry.Point3d((generate_range * 2) * i, - generate_range * 2, 0)\n    # vec_move = copy_to - copy_from\n    #\n    # MoveObject.MoveTimberObjects(vec_move, tim1, tim2)  # Moving Objects method for tim1,tim2\n    #\n    # if cantilever_num > num_timber - 2:  # if cantilever_num is not good, stop python script\n    #     sys.exit(\"cantilever_num is not suitable for num_timber\")\n    #\n    # cantilever_start = time.time()  # Initial Cantilever generate part\n    # for j in range(cantilever_num - 2):\n    #     # flag_success = False\n    #     flag_success = dic['generate' + str(i)].cantilever(limit_degree)\n    #     # if not flag_success:\n    #     #     input(\"line 128 cantilever not success\")\n    # cantilever_end = time.time()\n    # # print(\"Initial Cantilever Method end time: %s this is num %s population\" %(cantilever_end - cantilever_start, i))\n    #\n    # bridge_start = time.time()  # Initial Bridge generate part\n    # for j in range(num_timber - cantilever_num):\n    #     # flag_success = False\n    #     flag_success = dic['generate' + str(i)].bridge(limit_degree)\n    #     # if not flag_success:\n    #     #     input(\"line 137 bridge not success\")\n    # bridge_end = time.time()\n    # # print(\"Initial Bridge Method end time: %s this is num %s population\" %(bridge_end - bridge_start, i))\n\n\n# 初期個体が分裂していないか確認。\nfor i in range(pop_num):\n    pop = dic['generate' + str(i)]\n    flag_divide = GA.Method.confirm_pop_divide(num_timber, pop)\n    print(\"flag_divide : %s  Time: %s\" % flag_divide)\n\n\n# Rhinoに描画されるオブジェクとに置き換える。\nif initial_population_draw:\n    for i in range(pop_num):\n        for j in range(num_timber):\n            if layer_flag:\n                a = 'tim'\n                b = str(dic['generate' + str(i)].used_list[j].name)\n                rs.CurrentLayer(a+b)\n\n            sf = scriptcontext.doc.Objects.AddBrep(dic['generate' + str(i)].used_list[j].surface)\n            crv = scriptcontext.doc.Objects.AddCurve(dic['generate' + str(i)].used_list[j].center_line)\n\nt2 = time.time()\ninit_generation_time = t2 - t1  # time of Initial Generate\nprint(\"\\n\")\nprint(\"init generation time: %s\" % init_generation_time)\n\n\n# Step5: 遺伝子情報を生成し、Generateクラスのgene_infoにappendする。\nall_gene_info = []\nfor i in range(pop_num):\n    gene_info = []\n    for j in range(num_timber):\n        gene_info.append(dic['generate' + str(i)].used_list[j].name)\n    all_gene_info.append(gene_info)\n\nif information_flag:\n    print(\"\\n\")\n    print(\"All gene info\", all_gene_info)\n\nfor i in range(pop_num):\n    for j in range(num_timber):\n        dic['generate' + str(i)].gene_info.append(dic['generate' + str(i)].used_list[j].name)\n\n\n# Main Loop 開始\nfor main_loop in range(generation_num):\n\n    # Step6:  # EVALUATION　評価\n    evaluation_value = []  # 一世代分の評価値を格納するリスト\n    t3 = time.time()\n    for i in range(pop_num):\n        instance_pop = dic['generate' + str(i)]\n\n        # 評価関数　一個体ずつ評価値が帰ってくるように設計すること。\n        # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n        # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 10)\n        # evaluate_value = GA.Evaluation.pop_height_evaluate(num_timber, instance_pop)\n        evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop)\n\n        dic['generate' + str(i)].evaluation = evaluate_value\n        evaluation_value.append(dic['generate' + str(i)].evaluation)\n\n    evaluate_list.append(evaluation_value)  # 全世代の評価値を格納するリスト\n\n    t4 = time.time()\n    print(\"\\n\")\n    print(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (main_loop, evaluation_value))\n    print(\"Evaluation Time: %s\" % (t4 - t3))\n\n    # Step7:  # SELECTION  選択\n    selected_list = []\n    sort_generate_instance_list = []  # Genarateクラスインスタンスのリストを作成する。\n    for i in range(pop_num):\n        sort_generate_instance_list.append(dic['generate' + str(i)])\n\n    # リスト内のクラスインスタンスの保持する評価値に従いソートを行う\n    if flag_high:\n        GA.Selection.sort_high(sort_generate_instance_list)\n    else:\n        GA.Selection.sort_low(sort_generate_instance_list)\n\n    # elite selection\n    GA.Selection.eliteSelection(elite_num, sort_generate_instance_list, selected_list)\n\n    # tournament selection\n    GA.Selection.tournamentSelection_min(tournament_size, tournament_num, sort_generate_instance_list, selected_list)\n\n    # Step8: 交叉　再生成　\n    # 更新用リスト各位\n    temp_list_center_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_srf_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_select_domain_list_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    list_temp_partner_tim = [[[] for i in range(num_timber)] for j in range(pop_num)]  # partner_tim更新用のリストを作成\n    list_temp_gene_tim = []  # 次世代の遺伝子更新用リスト\n\n    # 前世代のpartner_timを保存する。\n    list_partner_tim_prior_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]  # 前世代のpartner_timを保存。\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if dic['generate' + str(i)].used_list[k].name == j:\n                    list_partner_tim_prior_generation[i][j].extend(dic['generate' + str(i)].used_list[j].partner_tim)\n                    break\n    print(\"list_partner_tim_prior_generation\", list_partner_tim_prior_generation)\n\n    for loop in range(pop_size):\n        if information_flag:\n            print(\"\\n\")\n            print(\"start regeneration No.%s\" % loop)\n            print(\"------------------------------------------------------------\")\n\n        # decide the 2 crossover point\n        divide_point1, divide_point2 = GA.Crossover.selectDividePoints(num_timber, divide_range)\n\n        # Get the index in the 'selected_list' of the individual used for crossover\n        pop_1, pop_2 = GA.Crossover.select2Poplation(selected_list)\n\n        # 2点交叉　Generateクラス変数の更新とlist_temp_gene_timに新しく生成した遺伝子情報をappendする。 継承する材の番号が格納されたリストをreturnする\n        already_regenerate = GA.Crossover.TwoPointCrossover(num_timber, pop_1, pop_2, divide_point1, divide_point2,\n                                                            list_temp_gene_tim)\n\n        # pop_2に関して継承する材を決定するアルゴリズム add　TODO　ここの関数を変更することによって継承する材を変更することができる\n        decide_inheritance_num_list, connect_list = GA.Method.decide_inheritance_timber(pop_1, pop_2, already_regenerate,\n                                                                                      generate_range)\n        # print('\\n')\n        # print('connect_list', connect_list)\n\n        # print(\"decide_inheritance_num_list %s\"%(decide_inheritance_num_list))\n\n        # 個体の保持する要素の保存。　　一旦pop_1をコピーしてオブジェクトを保存する。一つの個体生成がおわったら元に戻す。\n        list_srf_temp = []\n        list_center_line_temp = []\n        list_select_domain_temp = []\n        GA.Method.saveInstanceInformation(num_timber, pop_1, list_srf_temp, list_center_line_temp,\n                                          list_select_domain_temp)\n\n        # pop_2のTimber、select_domain_listのDomainを更新する  add 190218\n        GA.Method.RenewalPop2(pop_1, pop_2, decide_inheritance_num_list)\n\n        # select_domain_listの更新。　形態を引き継いでいる材の接合ドメインの更新を行う。前世代では使用していたが、空席になるドメインが生じるはずなので\n        GA.Method.selectDomainRenewal(already_regenerate, num_timber, pop_1)\n\n        # select_domain_listの更新2.\n        GA.Method.selectDomainRenewal2(decide_inheritance_num_list, num_timber, pop_1)\n\n        # print('inheritance form 1', already_regenerate)\n        # print('inheritance form 2', decide_inheritance_num_list)\n\n        # そのまま継承する材をMoveObjectでコピー、partnerを更新する\n        GA.Method.move_and_pop_update_for_already(already_regenerate, pop_1, generate_range, generation_num, between_draw_rhino,\n                                       main_loop, loop, list_temp_partner_tim)\n\n        # そのまま継承する材をMoveObjectでコピーし、partnerを更新する。　add 190220\n        GA.Method.move_and_pop_update_for_inheritance(decide_inheritance_num_list, pop_1, pop_2, generate_range, generation_num,\n                                        between_draw_rhino, main_loop, loop, list_temp_partner_tim)\n\n        # TODO ここに接合部を最適化させる関数を配置する。\n\n        # pop_2の材の位相関係を継承しながら再生成を行う。\n        for i in range(len(connect_list)):\n            index = decide_inheritance_num_list.index(connect_list[i][0])\n            del decide_inheritance_num_list[index]\n            already_regenerate.append(connect_list[i][0])\n        # print('check del inheritance form', decide_inheritance_num_list)\n\n        already_regenerate.extend(decide_inheritance_num_list)  # add 190220\n        # print('check already_regenerate', already_regenerate)\n        # print(\"already_regenerate_list : %s\"%(already_regenerate))\n        for i in range(len(connect_list)):\n            decide_inheritance_num_list.append(connect_list[i][0])\n\n        yet_regenerate = []\n        yet_regenerate.extend(pop_1.temp_yet_regenerate)\n\n        # print(\"before yet_regenerate_list : %s\"%(yet_regenerate))  # add 190220\n        for ex in range(len(decide_inheritance_num_list)):\n            index_ex = yet_regenerate.index(decide_inheritance_num_list[ex])\n            yet_regenerate.pop(index_ex)\n        # print(\"after yet_regenerate_list : %s\" % (yet_regenerate))\n\n        # partner_timの確認　check_timber_partner3と一致している必要がある。\n        # check_timber_partner1 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner1.append(pop_1.used_list[j].partner_tim)\n        #             break\n\n        # print(\"check_timber_partner1\", check_timber_partner1)\n\n        # pop1のpartner_listを更新する。\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    pop_1.used_list[j].partner_tim = []\n                    pop_1.used_list[j].partner_tim.extend(list_temp_partner_tim[loop][i])\n                    break\n\n        # partner_timの更新確認\n        # check_timber_partner2 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner2.append(pop_1.used_list[j].partner_tim)\n        #             break\n        # print(\"check temp timber partner : %s\" % (check_timber_partner2))\n        # print(\"list_temp_partner_tim\", list_temp_partner_tim)\n\n        # 再生成のプロセス\n        ReGenerate.regenerate(already_regenerate, yet_regenerate, pop_1, pop_2, num_timber, limit_degree,\n                              generation_num, main_loop, loop, between_draw_rhino, list_temp_partner_tim,\n                              mutation_ratio)\n\n        # 再生成した個体がバラバラに成っていないか確認する\n        t1_flag_divede = time.time()\n        flag_divide = GA.Method.confirm_pop_divide(num_timber, pop_1)\n        t2_flag_divide = time.time()\n        print(\"flag_divide : %s  Time: %s\" % (flag_divide, t2_flag_divide-t1_flag_divede))\n\n        # partner_timの確認\n        check_timber_partner3 = []\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    check_timber_partner3.append(pop_1.used_list[j].partner_tim)\n                    break\n\n        if check_timber_partner3 == list_temp_partner_tim[loop]:\n            pass\n        else:\n            raise ValueError('check_timber_partner3 & list_temp_partner_tim is not same, did not working')\n\n        # pop_1のpartner_timを再生成前の状態に戻す。\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[j].name == i:\n                    pop_1.used_list[j].partner_tim = []\n                    pop_1.used_list[j].partner_tim.extend(list_partner_tim_prior_generation[pop_1.population_num][i])\n                    break\n\n        # partner_timの更新確認 check_timber_partner1と一致している必要がある。\n        # check_timber_partner4 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner4.append(pop_1.used_list[j].partner_tim)\n        #             break\n        #\n        # print(\"check_timber_partner4\", check_timber_partner4)\n\n        # if check_timber_partner1 == check_timber_partner4:\n        #     pass\n        # else:\n        #     raise ValueError('check_timber_partner1 & check_timber_partner4 is not same')\n\n        # Generateクラスインスタンス変数の更新\n        # 戻す。　　次世代の個体生成前に保持していたGenerateクラスの変数に戻す。\n        GA.Method.RenewalInstanceInformationSameGeneration(pop_1, temp_list_srf_for_next_generation,\n                                                           temp_list_center_for_next_generation,\n                                                           temp_list_select_domain_list_for_next_generation,\n                                                           list_srf_temp, list_center_line_temp,\n                                                           list_select_domain_temp, loop)\n\n        rs.EnableRedraw(True)\n        rs.Redraw()\n        rs.EnableRedraw(False)\n\n        # print(\"list_temp_partner_tim\", list_temp_partner_tim)\n        # input(\"stop\")\n\n    # 全個体のGenerateインスタンス変数を更新する。\n    # srf, center_lineの更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            name_tim = dic['generate' + str(i)].used_list[j].name\n            # print(\"name_tim\", name_tim)\n            dic['generate' + str(i)].used_list[j].center_line = None  # listで問題ないっぽい\n            dic['generate' + str(i)].used_list[j].center_line = temp_list_center_for_next_generation[i][name_tim]\n\n            dic['generate' + str(i)].used_list[j].surface = None\n            dic['generate' + str(i)].used_list[j].surface = temp_list_srf_for_next_generation[i][name_tim]\n\n    #  partner_tim　の更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):  # TODO\n                if dic['generate' + str(i)].used_list[k].name == j:\n                    dic['generate' + str(i)].used_list[k].partner_tim = []\n                    dic['generate' + str(i)].used_list[k].partner_tim.extend(list_temp_partner_tim[i][j])\n\n            # print(\"update partner_tim\", dic['generate' + str(i)].used_list[j].partner_tim)\n\n            # 中心線を更新しているので、リスト内の値を更新するb\n            # print(\"check error\", dic['generate' + str(i)].used_list[j].center_line)\n            dic['generate' + str(i)].used_list[j].mesureLength_RhinoCommon()\n\n    # tim_distance の更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if k != j:\n                    timberMethod.distanceBetweenTimber_RhinoCommon(dic['generate' + str(i)].used_list[j],\n                                                                   dic['generate' + str(i)].used_list[k])\n                else:\n                    dic['generate' + str(i)].used_list[j].tim_distance[dic['generate' + str(i)].used_list[j].name] = []\n                    continue\n\n    # gene_information の更新\n    for i in range(pop_num):\n        dic['generate' + str(i)].gene_info = []\n        dic['generate' + str(i)].gene_info.extend(list_temp_gene_tim[i])\n\n    # select_domain_listの更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            dic['generate' + str(i)].used_list[j].select_domain_list = []\n            dic['generate' + str(i)].used_list[j].select_domain_list.extend(\n                temp_list_select_domain_list_for_next_generation[i][dic['generate' + str(i)].used_list[j].name])\n\n# Step10:  EVALUATION\nevaluation_value = []\nt3_1 = time.time()\nfor i in range(pop_num):\n    instance_pop = dic['generate' + str(i)]\n\n    # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n    # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 3)\n    evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop)\n\n    dic['generate' + str(i)].evaluation = evaluate_value\n\n    evaluation_value.append(dic['generate' + str(i)].evaluation)\n    # print('evaluation value Pop: %s : value is %s'%(i, dic['generate' + str(i)].evaluation))\nevaluate_list.append(evaluation_value)\n\n\n# 一番適応度が高い個体だけを描画する。ほかはレイヤーに隠す。\neva_high_index = evaluation_value.index(max(evaluation_value))\nfor i in range(pop_num):\n    rs.AddLayer('pop' + str(i))\n\n\nfor i in range(pop_num):\n    for j in range(num_timber):\n        center_line = scriptcontext.doc.Objects.AddCurve(dic['generate' + str(i)].used_list[j].center_line)\n        surface = scriptcontext.doc.Objects.AddBrep(dic['generate' + str(i)].used_list[j].surface)\n        rs.ObjectLayer(center_line, 'pop' + str(i))\n        rs.ObjectLayer(surface, 'pop' + str(i))\n\nfor i in range(pop_num):\n    if i == eva_high_index:\n        pass\n    else:\n        rs.LayerVisible('pop' + str(i), False)\n\nrs.CurrentLayer('pop' + str(eva_high_index))\nrs.LayerVisible('all_pop_layer', False)\n\n\nt4_1 = time.time()\nprint(\"\\n\")\nprint(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (generation_num, evaluation_value))\nprint(\"Evaluation Time: %s\" % (t4_1 - t3_1))\n\n\nprogram_finish = time.time()\nprint(\"\\n\")\nprint(\"EVALUATE : result --- %s\" % evaluate_list)\nprint(\"Processing Time : %s\" % (program_finish - program_start))\n\n\n# グラフに評価値の推移を描画\ndrawInformatinon.drawEvaluateValue(evaluate_list)\n\n#\n# partner_list = []\n# for i in range(len(pop_1.used_list)):\n#     partner_list.append(pop_1.used_list[i].partner_tim)\n# print(\"partner_list : %s\"%(partner_list))\n\n#\n# value = []\n# for i in range(pop_num):\n#     length = len(dic['generate' + str(i)].used_list)\n#     value.append(length)\n# sum_list = sum(value)\n# print(\"sum of used_timber_num\", sum_list)\n#\n# for i in range(pop_num):\n#     for j in range(num_timber):\n#         srf = dic['generate' + str(i)].used_list[j].surface\n#         print(\"srf\", srf)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}