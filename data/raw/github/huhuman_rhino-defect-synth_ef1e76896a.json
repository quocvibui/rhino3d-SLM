{
  "source_url": "https://github.com/huhuman/rhino-defect-synth/blob/aec9f34c7273f7dcfcfdce7893e8ad91d8771c06/utils_loc/cube_modeling.py",
  "repo": "huhuman/rhino-defect-synth",
  "repo_stars": 0,
  "repo_description": "Rhino Python scripts for parametric synthetic defect image generation",
  "license": "unknown",
  "filepath": "utils_loc/cube_modeling.py",
  "instruction": "Cube modeling",
  "code": "#! python 3\nimport Rhino\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport json\nimport os\nimport random\nimport numpy as np\nimport random\n\n# CUBE_LENGTH is the distance from origin to each face.\n# So the cube spans from -CUBE_LENGTH to +CUBE_LENGTH (edge length = 2 * CUBE_LENGTH).\nCUBE_LENGTH = 500.0  # mm\n\n\ndef __create_cube_faces():\n    \"\"\"\n    Create a cube from -CUBE_LENGTH to +CUBE_LENGTH in all axes,\n    explode it into 6 surfaces, and return a dict mapping\n    { \"+x\": id, \"-x\": id, \"+y\": id, \"-y\": id, \"+z\": id, \"-z\": id }.\n    All returned ids are surfaces (Brep).\n    \"\"\"\n    half = CUBE_LENGTH / 2\n\n    corners = [\n        (-half, -half, -half),\n        ( half, -half, -half),\n        ( half,  half, -half),\n        (-half,  half, -half),\n        (-half, -half,  half),\n        ( half, -half,  half),\n        ( half,  half,  half),\n        (-half,  half,  half),\n    ]\n\n    box_id = rs.AddBox(corners)  # polysurface (type 32)\n    srfs = rs.ExplodePolysurfaces(box_id, delete_input=True)  # 6 surfaces (type 16)\n\n    faces = {}\n    tol = 1e-3\n\n    for s in srfs:\n        bbox = rs.BoundingBox(s)\n        if not bbox:\n            continue\n        cx = sum(p[0] for p in bbox) / 8.0\n        cy = sum(p[1] for p in bbox) / 8.0\n        cz = sum(p[2] for p in bbox) / 8.0\n\n        if abs(cx - half) < tol:\n            faces[\"+x\"] = s\n        elif abs(cx + half) < tol:\n            faces[\"-x\"] = s\n        elif abs(cy - half) < tol:\n            faces[\"+y\"] = s\n        elif abs(cy + half) < tol:\n            faces[\"-y\"] = s\n        elif abs(cz - half) < tol:\n            faces[\"+z\"] = s\n        elif abs(cz + half) < tol:\n            faces[\"-z\"] = s\n\n    return faces\n\n\ndef read_contour_json(filepath):\n    \"\"\"\n    Read one JSON file and return a list of contours:\n    [\n        {\n            \"parent\": <whatever is in JSON>,\n            \"points\": numpy array of shape (N, 2) in mm\n        },\n        ...\n    ]\n    Assumes JSON:\n    {\n        \"pixel_size_cm\": 0.1,\n        \"contours\": [\n            { \"parent\": \"...\", \"points\": [[x_px, y_px], ...] },\n            ...\n        ]\n        \"severity\": \"CS1\" | \"CS2\" | \"CS3\"\n    }\n    \"\"\"\n    if not os.path.isfile(filepath):\n        raise IOError(\"File not found: {}\".format(filepath))\n\n    with open(filepath, \"r\") as f:\n        data = json.load(f)\n\n    try:\n        # convert pixel size to mm\n        pixel_size_mm = float(data[\"pixel_size_cm\"]) * 10.0\n    except KeyError:\n        raise KeyError('JSON must contain \"pixel_size_cm\".')\n    \n    global CUBE_LENGTH\n    try:\n        map_pixel = float(data.get(\"width_px\", 0) or data.get(\"height_px\", 0))\n        if map_pixel == 0:\n            raise ValueError(\"Both width_px and height_px are missing or zero\")\n    except (ValueError, TypeError):\n        raise KeyError('JSON must contain valid \"width_px\" or \"height_px\".')\n    CUBE_LENGTH = map_pixel * pixel_size_mm\n\n    if \"contours\" not in data:\n        raise KeyError('JSON must contain \"contours\".')\n\n    def _contour_conversion(item):\n        pts_px = np.array(item[\"points\"], dtype=float)\n        pts_mm = pts_px * pixel_size_mm\n        return {\n            \"parent\": item[\"parent\"],\n            \"points\": pts_mm\n        }\n\n    contours = [[_contour_conversion(item) for item in cnt_list] for cnt_list in data[\"contours\"]]\n    severities = data[\"severities\"]\n    erode_contours = [_contour_conversion(item) for item in data[\"expanded_contours\"]]\n    base_contours = [_contour_conversion(item) for item in data[\"base_contours\"]]\n    diff_contours = [[_contour_conversion(item) for item in cnt_list] for cnt_list in data[\"difference_contours\"]]\n\n    return contours, base_contours, erode_contours, diff_contours, severities\n\n\ndef center_2d_points(points_2d):\n    \"\"\"\n    Center the 2D points around (0,0) using their bounding box center.\n    points_2d: iterable of (x, y) (list or numpy array)\n    Returns a list of (x, y) tuples.\n    \"\"\"\n    centered = [(x - CUBE_LENGTH/2, y - CUBE_LENGTH/2) for (x, y) in points_2d]\n    return centered\n\n\ndef map_2d_to_cube_face(points_2d_mm, face):\n    \"\"\"\n    Map 2D points (in mm) to 3D coordinates on a cube face.\n\n    points_2d_mm : iterable of (x_mm, y_mm) in local 2D\n    face         : one of \"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"\n\n    Uses global CUBE_LENGTH as the face coordinate:\n      +x face is at X = +CUBE_LENGTH, etc.\n\n    Returns: list of (x, y, z) tuples.\n    \"\"\"\n    face = face.strip().lower()\n    pts_3d = []\n\n    for (u, v) in points_2d_mm:\n        if face == \"+x\":\n            pts_3d.append((CUBE_LENGTH/2, u, v))\n        elif face == \"-x\":\n            pts_3d.append((-CUBE_LENGTH/2, u, v))\n        elif face == \"+y\":\n            pts_3d.append((u, CUBE_LENGTH/2, v))\n        elif face == \"-y\":\n            pts_3d.append((u, -CUBE_LENGTH/2, v))\n        elif face == \"+z\":\n            pts_3d.append((u, v, CUBE_LENGTH/2))\n        elif face == \"-z\":\n            pts_3d.append((u, v, -CUBE_LENGTH/2))\n        else:\n            raise ValueError('Unknown face \"{}\". Use +x, -x, +y, -y, +z, -z.'.format(face))\n    return pts_3d\n\n\ndef add_polygon_curve(points_3d, close_curve=True):\n    \"\"\"\n    Create a polyline (and optionally close it) from 3D points in Rhino.\n    Returns the GUID of the polyline object.\n    \"\"\"\n    if not points_3d:\n        return None\n\n    pts = list(points_3d)\n    if len(pts) < 15:\n        return None\n\n    if close_curve and pts[0] != pts[-1]:\n        pts.append(pts[0])\n\n    poly_id = rs.AddPolyline(pts)\n    return poly_id\n\n\ndef face_dir_normal(face_dir):\n    \"\"\"Return a unit normal vector for a cube face direction string.\"\"\"\n    mapping = {\n        \"+x\": (1, 0, 0),\n        \"-x\": (-1, 0, 0),\n        \"+y\": (0, 1, 0),\n        \"-y\": (0, -1, 0),\n        \"+z\": (0, 0, 1),\n        \"-z\": (0, 0, -1),\n    }\n    return mapping.get(face_dir.lower())\n\n\ndef split_face_and_keep_outer(base_srf_id, cutters):\n    \"\"\"\n    Use RhinoCommon Brep.Split with *all* cutters at once,\n    then keep only the largest area piece (outer face).\n    base_srf_id : GUID of the face surface to split\n    cutters     : list of GUIDs (planar surfaces on the same plane)\n    \"\"\"\n    if not cutters:\n        return base_srf_id\n\n    tol = sc.doc.ModelAbsoluteTolerance\n\n    # Coerce base surface to Brep\n    base_brep = rs.coercebrep(base_srf_id)\n    if not base_brep:\n        print(\"Base surface is not a valid Brep:\", base_srf_id)\n        return base_srf_id\n\n    # Coerce all cutters to Breps\n    cutter_breps = []\n    for cid in cutters:\n        if not cid:\n            continue\n        b = rs.coercebrep(cid)\n        if b:\n            cutter_breps.append(b)\n        else:\n            print(\"Skipping non-brep cutter:\", cid, \"type:\", rs.ObjectType(cid))\n\n    if not cutter_breps:\n        print(\"No valid cutter Breps found.\")\n        return base_srf_id\n\n    # Do a single split in RhinoCommon\n    split_breps = base_brep.Split(cutter_breps, tol)\n    if not split_breps:\n        print(\"Brep.Split failed or produced no pieces.\")\n        return base_srf_id\n\n    # Add split pieces to the document\n    piece_ids = []\n    for b in split_breps:\n        pid = sc.doc.Objects.AddBrep(b)\n        piece_ids.append(pid)\n\n    # Delete original base surface\n    rs.DeleteObject(base_srf_id)\n\n    # Compute areas and keep largest\n    areas = []\n    for pid in piece_ids:\n        brep = rs.coercebrep(pid)\n        if not brep:\n            areas.append(0.0)\n            continue\n        amp = Rhino.Geometry.AreaMassProperties.Compute(brep)\n        areas.append(amp.Area if amp else 0.0)\n\n    if not areas:\n        print(\"No valid areas from split pieces.\")\n        return None\n\n    idx_max = areas.index(max(areas))\n    outer_id = piece_ids[idx_max]\n\n    # Delete all smaller pieces\n    for i, pid in enumerate(piece_ids):\n        if i != idx_max and rs.IsObject(pid):\n            rs.DeleteObject(pid)\n\n    return outer_id\n\n\ndef create_cube(cube_map_dir, start_face_index=0):\n    faces = __create_cube_faces()\n\n    filenames = sorted([e for e in os.listdir(cube_map_dir) if e.endswith(\".json\")])\n    filepaths = [os.path.join(cube_map_dir, filename) for filename in filenames[start_face_index:start_face_index+6]]\n\n    # Process each file / face\n    face_cracks = {}\n    for face_dir, filepath in zip(faces.keys(), filepaths):\n        face = faces[face_dir]\n        rs.HideObject(face)\n\n        contours, base_contours, erode_contours, diff_contours, severities = read_contour_json(filepath)\n\n        assert len(contours) == len(severities) == len(erode_contours) == len(base_contours) == len(diff_contours), \\\n            f\"Mismatch in number of contours ({len(contours)}), severities ({len(severities)}), erode contours ({len(erode_contours)}), base contours ({len(base_contours)}), or diff contours ({len(diff_contours)}).\"\n        n_bases = len(erode_contours)\n        cutters = []\n        crack_items = []\n        \n        for i in range(n_bases):\n            erode_pts_mm_centered = center_2d_points(erode_contours[i][\"points\"])\n            erode_pts_3d = map_2d_to_cube_face(erode_pts_mm_centered, face_dir)\n            erode_poly_id = add_polygon_curve(erode_pts_3d, close_curve=True)\n            if not erode_poly_id:\n                print(\"Skipping empty erode contour at index {} on face {}\".format(i, face_dir))\n                continue\n            \n            base_pts_mm_centered = center_2d_points(base_contours[i][\"points\"])\n            base_pts_3d = map_2d_to_cube_face(base_pts_mm_centered, face_dir)\n            base_poly_id = add_polygon_curve(base_pts_3d, close_curve=True)\n            if not base_poly_id:\n                print(\"Skipping empty base contour at index {} on face {}\".format(i, face_dir))\n                continue\n            \n            diff_poly_ids = []\n            for diff_cnt in diff_contours[i]:\n                diff_pts_mm_centered = center_2d_points(diff_cnt[\"points\"])\n                diff_pts_3d = map_2d_to_cube_face(diff_pts_mm_centered, face_dir)\n                diff_poly_id = add_polygon_curve(diff_pts_3d, close_curve=True)\n                if diff_poly_id:\n                    diff_poly_ids.append(diff_poly_id)\n\n            severity = severities[i]\n            layer_name = \"crack_{}\".format(severity)\n            if not rs.IsLayer(layer_name):\n                raise ValueError(\"Layer '{}' does not exist. Please run preparation step first.\".format(layer_name))\n\n            crack_poly_ids = []\n            noncrack_poly_ids = []\n            for contour in contours[i]:\n                pts_mm_centered = center_2d_points(contour[\"points\"])\n                pts_3d = map_2d_to_cube_face(pts_mm_centered, face_dir)\n                if len(pts_3d) < 3:\n                    continue\n                poly_id = add_polygon_curve(pts_3d, close_curve=True)\n                if poly_id:\n                    if contour[\"parent\"] != -1:\n                        noncrack_poly_ids.append(poly_id)\n                    else:\n                        crack_poly_ids.append(poly_id)\n\n            if not crack_poly_ids:\n                print(\"Skipping empty contour at index {} on face {}\".format(i, face_dir))\n                continue\n            \n            for poly_id in crack_poly_ids:\n                rs.ObjectLayer(poly_id, layer_name)\n            rs.ObjectLayer(erode_poly_id, layer_name)\n            offset_srf_id = rs.AddPlanarSrf(erode_poly_id)[0]\n            if offset_srf_id:\n                rs.ObjectLayer(offset_srf_id, layer_name)\n                cutters.append(offset_srf_id)\n                crack_items.append({\n                    \"offset_surface\": offset_srf_id,\n                    \"crack_polys\": crack_poly_ids,\n                    \"inside_polys\": noncrack_poly_ids,\n                    \"base_poly\": base_poly_id,\n                    \"offset_poly\": erode_poly_id,\n                    \"diff_polys\": diff_poly_ids,\n                })\n\n        split_face_and_keep_outer(face, cutters)\n        rs.ShowObject(face)\n        face_cracks[face_dir] = crack_items\n        print(\"Processed face {}: {} contours.\".format(face_dir, len(cutters)))\n    \n    for face in faces.values():\n        if rs.IsObject(face):\n            rs.DeleteObject(face)\n\n    return face_cracks\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}