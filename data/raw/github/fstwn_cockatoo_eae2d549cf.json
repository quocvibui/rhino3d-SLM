{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/modules/cockatoo/_knitnetworkbase.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "modules/cockatoo/_knitnetworkbase.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import OrderedDict\n\n# DUNDER ----------------------------------------------------------------------\n__all__ = [\n    \"KnitNetworkBase\"\n]\n\n# THIRD PARTY MODULE IMPORTS --------------------------------------------------\nimport networkx as nx\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\nfrom cockatoo.environment import RHINOINSIDE\n\n# RHINO IMPORTS ---------------------------------------------------------------\nif RHINOINSIDE:\n    import rhinoinside\n    rhinoinside.load()\n    from Rhino.Geometry import Curve as RhinoCurve\n    from Rhino.Geometry import Line as RhinoLine\n    from Rhino.Geometry import LineCurve as RhinoLineCurve\n    from Rhino.Geometry import Polyline as RhinoPolyline\nelse:\n    from Rhino.Geometry import Curve as RhinoCurve\n    from Rhino.Geometry import Line as RhinoLine\n    from Rhino.Geometry import LineCurve as RhinoLineCurve\n    from Rhino.Geometry import Polyline as RhinoPolyline\n\n# CLASS DECLARATION -----------------------------------------------------------\n\n\nclass KnitNetworkBase(nx.Graph):\n    \"\"\"\n    Abstract datastructure for representing a network (graph) consisting of\n    nodes with special attributes aswell as 'warp' edges, 'weft' edges and\n    contour edges which are neither 'warp' nor 'weft'.\n\n    Used as a base class for sharing behaviour between the KnitNetwork,\n    KnitMappingNetwork and KnitDiNetwork classes.\n\n    Inherits from :class:`networkx.Graph`.\n    For more info, see *NetworkX* [13]_.\n\n    References\n    ----------\n    .. [13] Hagberg, Aric A.; Schult, Daniel A.; Swart, Pieter J.\n            *Exploring Network Structure, Dynamics, and Function using\n            NetworkX* In: *Varoquaux, Vaught et al. (Hg.) 2008 - Proceedings\n            of the 7th Python in Science Conference* pp. 11-15\n\n            See: `NetworkX 1.5 <https://networkx.github.io/documentation/\n            networkx-1.5/>`_\n    \"\"\"\n\n    # REPRESENTATION OF NETWORK -----------------------------------------------\n\n    def __str__(self):\n        \"\"\"\n        Return the graph name if it is set, otherwise return a textual\n        description of the network.\n\n        Returns\n        -------\n        name : str\n            The name of the graph or a textual description of the network.\n        \"\"\"\n        if self.name != \"\":\n            return self.name\n        else:\n            return self.ToString()\n\n    def __repr__(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n        \"\"\"\n\n        if self.name != \"\":\n            name = self.name\n        else:\n            name = \"KnitNetworkBase\"\n\n        nn = len(self.nodes())\n        ce = len(self.contour_edges)\n        wee = len(self.weft_edges)\n        wae = len(self.warp_edges)\n        data = (\"({} Nodes, {} Contours, {} Weft, {} Warp)\")\n        data = data.format(nn, ce, wee, wae)\n\n        return name + data\n\n    def ToString(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n\n        Notes\n        -----\n        Used for overloading the Grasshopper display in data parameters.\n        \"\"\"\n\n        return repr(self)\n\n    def prepare_for_graphviz(self):\n        \"\"\"\n        Creates a new graph with attributes for visualising this network\n        using GraphViz.\n\n        Based on code by Anders Holden Deleuran\n        \"\"\"\n\n        # Set render variables\n        nodeFontSize = 10\n        edgeFontSize = 3.75\n        arrowSize = 0.4\n\n        # shapes\n        circle = \"circle\"\n\n        # colors\n        black = \"black\"\n        white = \"white\"\n        red = \"red\"\n        blue = \"blue\"\n\n        col_regular = \"black\"\n        col_start_leaf = \"seagreen\"\n        col_start_leaf_end = \"orange\"\n        col_start_end = \"darkgreen\"\n        col_end = \"blue\"\n        col_leaf = \"cyan\"\n        col_end_leaf = \"magenta\"\n        col_increase_end = \"purple\"\n        col_decrease_end = \"darkorchid4\"\n        col_increase = \"red\"\n        col_decrease = \"darkred\"\n\n        font = \"Helvetica\"\n\n        # choose graph type for new graph depending on current graph\n        if isinstance(self, nx.MultiGraph):\n            DotGraph = nx.MultiDiGraph()\n        else:\n            DotGraph = nx.DiGraph()\n\n        # get all nodes and all edges\n        network_nodes = self.nodes(data=True)\n        network_edges = self.edges(data=True)\n\n        # process all nodes and add them to the dot graph\n        for node in network_nodes:\n            ndata = node[1]\n\n            # END BUT NOT LEAF\n            if ndata[\"end\"] and not ndata[\"leaf\"]:\n                if not ndata[\"increase\"] and not ndata[\"decrease\"]:\n                    if ndata[\"start\"]:\n                        node_type = \"S\"\n                        node_color = col_start_end\n                        node_txt_color = black\n                    else:\n                        node_type = \"E\"\n                        node_color = col_end\n                        node_txt_color = white\n\n                elif ndata[\"increase\"] and not ndata[\"decrease\"]:\n                    node_type = \"Ei\"\n                    node_color = col_increase_end\n                    node_txt_color = black\n                elif not ndata[\"increase\"] and ndata[\"decrease\"]:\n                    node_type = \"Ed\"\n                    node_color = col_decrease_end\n                    node_txt_color = black\n\n                node_shape = circle\n\n            # LEAF BUT NOT END\n            elif ndata[\"leaf\"] and not ndata[\"end\"]:\n                if ndata[\"start\"]:\n                    node_type = \"SL\"\n                    node_color = col_start_leaf\n                else:\n                    node_type = \"L\"\n                    node_color = col_leaf\n\n                node_txt_color = black\n                node_shape = circle\n\n            # END AND LEAF\n            elif ndata[\"leaf\"] and ndata[\"end\"]:\n                if ndata[\"start\"]:\n                    node_type = \"SEL\"\n                    node_color = col_start_leaf_end\n                else:\n                    node_type = \"EL\"\n                    node_color = col_end_leaf\n\n                node_txt_color = black\n                node_shape = circle\n\n            # NO END NO LEAF\n            elif not ndata[\"leaf\"] and not ndata[\"end\"]:\n                # INCREASE\n                if ndata[\"increase\"] and not ndata[\"decrease\"]:\n                    node_type = \"i\"\n                    node_color = col_increase\n                # DECREASE\n                elif not ndata[\"increase\"] and ndata[\"decrease\"]:\n                    node_type = \"d\"\n                    node_color = col_decrease\n                else:\n                    node_type = \"R\"\n                    node_color = col_regular\n\n                node_txt_color = white\n                node_shape = circle\n\n            if node[1][\"segment\"]:\n                node_label = str(node[0]) + \"\\n\" + node_type + \"\\n\" + \\\n                             str(node[1][\"segment\"])\n            else:\n                node_label = str(node[0]) + node_type\n\n            # make pos attribute for orthogonal layouting\n            if ndata[\"z\"] > 0.0:\n                node_pos = (str(ndata[\"x\"]) + \", \" +\n                            str(ndata[\"y\"]) + \", \" +\n                            str(ndata[\"z\"]))\n            else:\n                node_pos = (str(ndata[\"x\"]) + \", \" +\n                            str(ndata[\"y\"]))\n\n            node_attributes = {\"pos\": node_pos,\n                               \"label\": node_label,\n                               \"shape\": node_shape,\n                               \"fontname\": font,\n                               \"style\": \"filled\",\n                               \"fillcolor\": node_color,\n                               \"fontcolor\": node_txt_color,\n                               \"fontsize\": nodeFontSize,\n                               \"margin\": 0.0001}\n\n            DotGraph.add_node(node[0], attr_dict=node_attributes)\n\n        # make edge types and labels and add them to the graph\n        for edge in network_edges:\n            padding = \"  \"\n            if edge[2][\"weft\"]:\n                edge_type = \"WP\"\n                edge_color = blue\n            elif edge[2][\"warp\"]:\n                edge_type = \"WT\"\n                edge_color = red\n            elif not edge[2][\"weft\"] and not edge[2][\"warp\"]:\n                edge_type = \"C\"\n                edge_color = black\n\n            edge_info = str(edge[0]) + \">\" + str(edge[1])\n            edge_segment = edge[2][\"segment\"]\n            if edge_segment:\n                edge_label = (padding + edge_info + edge_type + \"\\n\" +\n                              str(edge_segment))\n            else:\n                edge_label = padding + edge_info + edge_type\n\n            DotGraph.add_edge(\n                            edge[0],\n                            edge[1],\n                            label=edge_label,\n                            fontname=font,\n                            fontcolor=black,\n                            color=edge_color,\n                            fontsize=edgeFontSize,\n                            arrowsize=arrowSize)\n\n        return DotGraph\n\n    def prepare_for_gephi(self):\n        \"\"\"\n        Creates a new graph with attributes for visualising this network\n        using Gephi.\n\n        Based on code by Anders Holden Deleuran\n        \"\"\"\n\n        # colors\n        black = \"black\"\n        blue = \"blue\"\n        red = \"red\"\n        green = \"green\"\n        orange = \"orange\"\n\n        # node shapes\n        circle = \"circle\"\n\n        if isinstance(self, nx.MultiGraph):\n            GephiGraph = nx.MultiDiGraph()\n        else:\n            GephiGraph = nx.DiGraph()\n\n        network_nodes = self.nodes(data=True)\n        network_edges = self.edges(data=True)\n\n        # add all nodes to the render graph\n        for node in network_nodes:\n            if node[1][\"end\"] and not node[1][\"leaf\"]:\n                node_type = \"end\"\n                node_color = red\n                node_shape = circle\n\n            elif node[1][\"leaf\"] and not node[1][\"end\"]:\n                node_type = \"leaf\"\n                node_color = green\n                node_shape = circle\n\n            elif node[1][\"leaf\"] and node[1][\"end\"]:\n                node_type = \"end leaf\"\n                node_color = orange\n                node_shape = circle\n\n            else:\n                node_type = \"regular\"\n                node_color = black\n                node_shape = circle\n\n            nodeAttrs = {\"color\": node_color,\n                         \"shape\": node_shape,\n                         \"type\": node_type}\n\n            GephiGraph.add_node(node[0], attr_dict=nodeAttrs)\n\n        # ad all edges to the render graph\n        for edge in network_edges:\n            if edge[2][\"weft\"]:\n                edge_type = \"weft\"\n                edge_color = blue\n            elif edge[2][\"warp\"]:\n                edge_type = \"warp\"\n                edge_color = red\n            elif not edge[2][\"weft\"] and not edge[2][\"warp\"]:\n                continue\n\n            edgeAttrs = {\"color\": edge_color,\n                         \"type\": edge_type}\n\n            GephiGraph.add_edge(edge[0], edge[1], attr_dict=edgeAttrs)\n\n        return GephiGraph\n\n    # NODE CREATION -----------------------------------------------------------\n\n    def node_from_point3d(self, node_index, pt, position=None, num=None,\n                          leaf=False, start=False, end=False, segment=None,\n                          increase=False, decrease=False, color=None):\n        \"\"\"\n        Creates a network node from a Rhino Point3d and attributes.\n\n        Parameters\n        ----------\n        node_index : hashable\n            The index of the node in the network. Usually an integer is used.\n\n        pt : :class:`Rhino.Geometry.Point3d`\n            A RhinoCommon Point3d object.\n\n        position : hashable, optional\n            The 'position' attribute of the node identifying the underlying\n            contour edge of the network.\n\n            Defaults to ``None``.\n\n        num : int, optional\n            The 'num' attribute of the node representing its index in the\n            underlying contour edge of the network.\n\n            Defaults to ``None``.\n\n        leaf : bool, optional\n            The 'leaf' attribute of the node identifying it as a node on the\n            first or last course of the knitting pattern.\n\n            Defaults to ``False``.\n\n        start : bool, optional\n            The 'start' attribute of the node identifying it as the start of\n            a course.\n\n            Defaults to ``False``.\n\n        end : bool, optional\n            The 'end' attribute of the node identifying it as the end of a\n            segment or course.\n\n            Defaults to ``False``.\n\n        segment : :obj:`tuple` of :obj:`int`, optional\n            The 'segment' attribute of the node identifying its position\n            between two 'end' nodes.\n\n            Defaults to ``None``.\n\n        increase : bool, optional\n            The 'increase' attribute identifying the node as an increase\n            (needed for translation from dual to 2d knitting pattern).\n\n            Defaults to ``False``.\n\n        decrease : bool, optional\n            The 'decrease' attribute identifying the node as a decrease\n            (needed for translation from dual to 2d knitting pattern).\n\n            Defaults to ``False``.\n\n        color : :obj:`System.Drawing.Color`, optional\n            The 'color' attribute of the node, representing the color of the\n            pixel when translating the network to a 2d knitting pattern.\n\n            Defaults to ``None``.\n        \"\"\"\n\n        # extract node coordinates\n        nodeX = pt.X\n        nodeY = pt.Y\n        nodeZ = pt.Z\n\n        # compile node attributes\n        node_attributes = {\"x\": nodeX,\n                           \"y\": nodeY,\n                           \"z\": nodeZ,\n                           \"position\": position,\n                           \"num\": num,\n                           \"leaf\": leaf,\n                           \"start\": start,\n                           \"end\": end,\n                           \"segment\": segment,\n                           \"increase\": increase,\n                           \"decrease\": decrease,\n                           \"geo\": pt,\n                           \"color\": color}\n\n        # add the node to the network instance\n        self.add_node(node_index, attr_dict=node_attributes)\n\n    # NODE GEOMETRY -----------------------------------------------------------\n\n    def node_geometry(self, node_index):\n        \"\"\"\n        Gets the geometry from the 'geo' attribute of the supplied node.\n\n        Parameters\n        ----------\n        node_index : hashable\n            The unique identifier of the node, an int in most cases.\n\n        Returns\n        -------\n        geometry : data\n            The data of the 'geo' attribute of the specified node or ``None``\n            if the node is not present or has no 'geo' attribute.\n        \"\"\"\n        try:\n            return self.node[node_index][\"geo\"]\n        except KeyError:\n            return None\n\n    def node_coordinates(self, node_index):\n        \"\"\"\n        Gets the node coordinates from the 'x', 'y' and 'z' attributes of the\n        supplied node.\n\n        Parameters\n        ----------\n        node_index : hashable\n            The unique identifier of the node, an int in most cases.\n\n        Returns\n        -------\n        xyz : :obj:`tuple` of :obj:`int`\n            The XYZ coordinates of the node as a 3-tuple.\n        \"\"\"\n        try:\n            node_data = self.node[node_index]\n            NodeX = node_data[\"x\"]\n            NodeY = node_data[\"y\"]\n            NodeZ = node_data[\"z\"]\n            return (NodeX, NodeY, NodeZ)\n        except KeyError:\n            return None\n\n    # PROPERTIES --------------------------------------------------------------\n\n    def _get_total_positions(self):\n        \"\"\"\n        Gets the number of total positions (i.e. contours) inside the network.\n        \"\"\"\n\n        total = max([n[1][\"position\"] for n in self.nodes_iter(data=True)])+1\n        return total\n\n    total_positions = property(\n                            _get_total_positions,\n                            None,\n                            None,\n                            \"The total number of positions (i.e. contours) \" +\n                            \"inside the network\")\n\n    # NODES ON POSITION CONTOURS ----------------------------------------------\n\n    def nodes_on_position(self, position, data=False):\n        \"\"\"\n        Gets the nodes on a given position (i.e. contour) by returning all\n        nodes which share the given value as their 'position' attribute.\n\n        Parameters\n        ----------\n        position : hashable\n            The index of the position.\n\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list`\n            The nodes sharing the supplied 'position' attribute.\n        \"\"\"\n\n        nodes = [(n, d) for n, d in self.nodes_iter(data=True)\n                 if d[\"position\"] == position]\n\n        nodes.sort(key=lambda x: x[1][\"num\"])\n\n        if not data:\n            nodes = [n[0] for n in nodes]\n\n        return nodes\n\n    def all_nodes_by_position(self, data=False):\n        \"\"\"\n        Gets all the nodes of the network, ordered by the values of their\n        'position' attribute.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list` of :obj:`list`\n            All nodes grouped by their 'position' attribute\n        \"\"\"\n\n        allPositionNodes = sorted(\n                                [(n, d) for n, d in self.nodes_iter(data=True)\n                                 if d[\"position\"] != None],\n                                key=lambda x: x[1][\"position\"])\n\n        posdict = OrderedDict()\n        for n in allPositionNodes:\n            if n[1][\"position\"] not in posdict:\n                posdict[n[1][\"position\"]] = [n]\n            else:\n                posdict[n[1][\"position\"]].append(n)\n\n        anbp = []\n        for key in posdict:\n            posnodes = sorted(posdict[key], key=lambda x: x[1][\"num\"])\n            if data:\n                anbp.append(posnodes)\n            else:\n                anbp.append([pn[0] for pn in posnodes])\n\n        return anbp\n\n    # NODES ON SEGMENT CONTOURS -----------------------------------------------\n\n    def nodes_on_segment(self, segment, data=False):\n        \"\"\"\n        Gets all nodes on a given segment by finding all nodes which share the\n        specified value as their 'segment' attribute, ordered by the value of\n        their 'num' attribute.\n\n        Parameters\n        ----------\n        segment : hashable\n            The identifier of the segment to look for.\n\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list`\n            List of nodes sharing the supplied value as their 'segment'\n            attribute, ordered by their 'num' attribute.\n        \"\"\"\n\n        nodes = [(n, d) for n, d in self.nodes_iter(data=True)\n                 if d[\"segment\"] == segment]\n\n        nodes.sort(key=lambda x: x[1][\"num\"])\n\n        if data:\n            return nodes\n        else:\n            return [n[0] for n in nodes]\n\n    # LEAF NODES --------------------------------------------------------------\n\n    def _get_leaf_nodes(self):\n        \"\"\"\n        Gets all 'leaf' nodes of the network.\n\n        Returns\n        -------\n        nodes : :obj:`list`\n            List of all nodes for which the attribute 'leaf' is ``True``\n        \"\"\"\n\n        leaves = [(n, d) for n, d in self.nodes_iter(data=True)\n                  if d[\"leaf\"] == True]\n\n        return leaves\n\n    leaf_nodes = property(_get_leaf_nodes, None, None,\n                          \"All 'leaf' nodes of the network.\")\n\n    def leaves_on_position(self, position, data=False):\n        \"\"\"\n        Gets all 'leaf' nodes which share the supplied value as their\n        'position' attribute.\n\n        Parameters\n        ----------\n        position : hashable\n            The index / identifier of the position\n\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list`\n            List of all nodes for which the attribute 'leaf' is ``True`` and\n            which share the supplied value as their 'position' attribute\n        \"\"\"\n\n        leaves = [(n, d) for n, d\n                  in self.nodes_on_position(position, data=True)\n                  if d[\"leaf\"]]\n        if not data:\n            leaves = [n[0] for n in leaves]\n        return leaves\n\n    def all_leaves_by_position(self, data=False):\n        \"\"\"\n        Gets all 'leaf' nodes ordered by their 'position' attribute.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list` of :obj:`list`\n            All nodes for which the attribute 'leaf' is true, grouped by their\n            'position' attribute\n        \"\"\"\n\n        allPositionLeaves = sorted(\n                            [(n, d) for n, d in self.nodes_iter(data=True)\n                             if d[\"position\"] != None and d[\"leaf\"]],\n                            key=lambda x: x[1][\"position\"])\n\n        posdict = OrderedDict()\n        for n in allPositionLeaves:\n            if n[1][\"position\"] not in posdict:\n                posdict[n[1][\"position\"]] = [n]\n            else:\n                posdict[n[1][\"position\"]].append(n)\n\n        albp = []\n        for key in posdict:\n            posleaves = sorted(posdict[key], key=lambda x: x[1][\"num\"])\n            if data:\n                albp.append(posleaves)\n            else:\n                albp.append([pl[0] for pl in posleaves])\n\n        return albp\n\n    # END NODES ---------------------------------------------------------------\n\n    def _get_end_nodes(self):\n        \"\"\"\n        Gets all 'end' nodes of the network.\n        \"\"\"\n\n        ends = [(n, d) for n, d in self.nodes_iter(data=True)\n                if d[\"end\"]]\n\n        return ends\n\n    end_nodes = property(_get_end_nodes, None, None,\n                         \"All 'end' nodes of the network\")\n\n    def ends_on_position(self, position, data=False):\n        \"\"\"\n        Gets all 'end' nodes which share the supplied value as their 'position'\n        attribute.\n\n        Parameters\n        ----------\n        position : hashable\n            The index / identifier of the position\n\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list`\n            List of all nodes for which the attribute 'end' is ``True`` and\n            which share the supplied value as their 'position' attribute\n        \"\"\"\n\n        ends = [(n, d) for n, d in self.nodes_on_position(position, data=True)\n                if d[\"end\"]]\n        if not data:\n            return [n[0] for n in ends]\n        return ends\n\n    def all_ends_by_position(self, data=False):\n        \"\"\"\n        Gets all 'end' nodes ordered by their 'position' attribute.\n\n        Parameters\n        ----------\n        data : bool, optional\n            If ``True``, found nodes will be returned with their attribute\n            data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        nodes : :obj:`list` of :obj:`list`\n            All nodes for which the attribute 'end' is true, grouped by their\n            'position' attribute\n        \"\"\"\n\n        allPositionEnds = sorted(\n                            [(n, d) for n, d in self.nodes_iter(data=True)\n                             if d[\"position\"] != None and d[\"end\"]],\n                            key=lambda x: x[1][\"position\"])\n\n        posdict = OrderedDict()\n        for n in allPositionEnds:\n            if n[1][\"position\"] not in posdict:\n                posdict[n[1][\"position\"]] = [n]\n            else:\n                posdict[n[1][\"position\"]].append(n)\n\n        aebp = []\n        for key in posdict:\n            posends = sorted(posdict[key], key=lambda x: x[1][\"num\"])\n            if data:\n                aebp.append(posends)\n            else:\n                aebp.append([pe[0] for pe in posends])\n\n        return aebp\n\n    # POSITION CONTOUR METHODS ------------------------------------------------\n\n    def geometry_at_position_contour(self, position, as_crv=False):\n        \"\"\"\n        Gets the contour polyline at a given position by making a polyline\n        from all nodes which share the specified 'position' attribute.\n\n        Parameters\n        ----------\n        position : hashable\n            The index / identifier of the position\n\n        as_crv : bool, optional\n            If ``True``, will return a PolylineCurve instead of a Polyline.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        contour : :obj:`Rhino.Geometry.Polyline`\n            The contour as a Polyline if ``as_crv`` is ``False``.\n        contour : :obj:`Rhino.Geometry.PolylineCurve`\n            The contour as a PolylineCurve if ``as_crv`` is ``True``.\n        \"\"\"\n\n        points = [n[1][\"geo\"] for n in self.nodes_on_position(position, True)]\n        Contour = RhinoPolyline(points)\n        if as_crv:\n            Contour = Contour.ToPolylineCurve()\n        return Contour\n\n    def longest_position_contour(self):\n        \"\"\"\n        Gets the longest contour 'position', geometry andgeometric length.\n\n        Returns\n        -------\n        contour_data : :obj:`tuple`\n            3-tuple of the 'position' identifier, the contour geometry and its\n            length.\n        \"\"\"\n\n        longestLength = 0\n        longestContour = None\n        longestPosition = None\n        for i in range(self.total_positions):\n            contour = self.geometry_at_position_contour(i, True)\n            cl = contour.GetLength()\n            if cl > longestLength:\n                longestLength = cl\n                longestContour = contour.Duplicate()\n                longestPosition = i\n            contour.Dispose()\n        return (longestPosition, longestContour, longestLength)\n\n    # EDGE CREATION METHODS ---------------------------------------------------\n\n    def create_contour_edge(self, from_node, to_node):\n        \"\"\"\n        Creates an edge neither 'warp' nor 'weft' between two nodes in the\n        network.\n\n        Parameters\n        ----------\n        from_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            source node.\n        to_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            target node.\n\n        Returns\n        -------\n        success : bool\n            ``True`` if the edge has been successfully created,\n            ``False`` otherwise.\n        \"\"\"\n\n        # get node indices\n        fromNode = from_node[0]\n        toNode = to_node[0]\n\n        # get geometry from nodes\n        fromGeo = from_node[1][\"geo\"]\n        toGeo = to_node[1][\"geo\"]\n\n        # create edge geometry\n        edgeGeo = RhinoLine(fromGeo, toGeo)\n\n        # create edge attribute\n        edgeAttrs = {\"warp\": False,\n                     \"weft\": False,\n                     \"segment\": None,\n                     \"geo\": edgeGeo}\n\n        try:\n            self.add_edge(fromNode, toNode, attr_dict=edgeAttrs)\n        except Exception:\n            return False\n\n        return True\n\n    def create_weft_edge(self, from_node, to_node, segment=None):\n        \"\"\"\n        Creates a 'weft' edge between two nodes in the network.\n\n        Parameters\n        ----------\n        from_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            source node.\n        to_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            target node.\n        segment : :obj:`tuple`\n            3-tuple that will be used to set the 'segment' attribute of the\n            'weft' edge.\n\n        Returns\n        -------\n        success : bool\n            ``True`` if the edge has been successfully created.\n            ``False`` otherwise.\n        \"\"\"\n\n        # get node indices\n        fromNode = from_node[0]\n        toNode = to_node[0]\n\n        # get geometry from nodes\n        fromGeo = from_node[1][\"geo\"]\n        toGeo = to_node[1][\"geo\"]\n\n        # create edge geometry\n        edgeGeo = RhinoLine(fromGeo, toGeo)\n\n        # create edge attribute\n        edgeAttrs = {\"warp\": False,\n                     \"weft\": True,\n                     \"segment\": segment,\n                     \"geo\": edgeGeo}\n\n        try:\n            self.add_edge(fromNode, toNode, attr_dict=edgeAttrs)\n        except Exception:\n            return False\n\n        return True\n\n    def create_warp_edge(self, from_node, to_node):\n        \"\"\"\n        Creates a 'warp' edge between two nodes in the network.\n\n        Parameters\n        ----------\n        from_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            source node.\n        to_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            target node.\n\n        Returns\n        -------\n        success : bool\n            ``True`` if the edge has been successfully created.\n            ``False`` otherwise.\n        \"\"\"\n\n        # get node indices\n        fromNode = from_node[0]\n        toNode = to_node[0]\n\n        # get geometry from nodes\n        fromGeo = from_node[1][\"geo\"]\n        toGeo = to_node[1][\"geo\"]\n\n        # create edge geometry\n        edgeGeo = RhinoLine(fromGeo, toGeo)\n\n        # create edge attribute\n        edgeAttrs = {\"warp\": True,\n                     \"weft\": False,\n                     \"segment\": None,\n                     \"geo\": edgeGeo}\n\n        try:\n            self.add_edge(fromNode, toNode, attr_dict=edgeAttrs)\n        except Exception:\n            return False\n\n        return True\n\n    def create_segment_contour_edge(self, from_node, to_node,\n                                    segment_value, segment_geo):\n        \"\"\"\n        Creates a mapping edge between two 'end' nodes in the network. The\n        geometry of this edge will be a polyline built from all the given\n        former 'weft' edges. returns True if the edge has been successfully\n        created.\n\n        Parameters\n        ----------\n        from_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            source node.\n\n        to_node : :obj:`tuple`\n            2-tuple of (node_identifier, node_data) that represents the edges'\n            target node.\n\n        segment_value : :obj:`tuple` of :obj:`int`\n            3-tuple that will be used to set the 'segment' attribute of the\n            'weft' edge.\n\n        segment_geo : :obj:`list` of :class:`Rhino.Geometry.Line`\n            the geometry of all 'weft' edges that make this segment contour\n            edge\n\n        Returns\n        -------\n        success : bool\n            ``True`` if the edge has been successfully created,\n            ``False`` otherwise\n        \"\"\"\n\n        # get node indices\n        fromNode = from_node[0]\n        toNode = to_node[0]\n\n        # join geo together\n        segment_geo = [RhinoLineCurve(ln) for ln in segment_geo]\n        edgeGeo = RhinoCurve.JoinCurves(segment_geo)\n        if len(edgeGeo) > 1:\n            errMsg = (\"Segment geometry could not be joined into \" +\n                      \"one single curve for segment {}!\".format(segment_value))\n            print(errMsg)\n            return False\n\n        edgeGeo = edgeGeo[0].ToPolyline()\n        if not edgeGeo[0] == from_node[1][\"geo\"]:\n            edgeGeo.Reverse()\n\n        # create edge attribute\n        edgeAttrs = {\"warp\": False,\n                     \"weft\": False,\n                     \"segment\": segment_value,\n                     \"geo\": edgeGeo}\n\n        self.add_node(fromNode, attr_dict=from_node[1])\n        self.add_node(toNode, attr_dict=to_node[1])\n\n        try:\n            self.add_edge(fromNode, toNode, attr_dict=edgeAttrs)\n        except Exception:\n            return False\n\n        return True\n\n    # EDGE METHODS ------------------------------------------------------------\n\n    def edge_geometry_direction(self, u, v):\n        \"\"\"\n        Returns a given edge in order with reference to the direction of the\n        associated geometry (line).\n\n        Parameters\n        ----------\n        u : hashable\n            Hashable identifier of the edges source node.\n\n        v : hashable\n            Hashable identifier of the edges target node.\n\n        Returns\n        -------\n        edge : 2-tuple\n            2-tuple of (u, v) or (v, u) depending on the directions\n        \"\"\"\n\n        # get geometry data of the edge\n        edge_geo = self[u][v][\"geo\"]\n\n        # compare start and endpoint and return nodes in order accordingly\n        if (edge_geo.From == self.node[u][\"geo\"]\n                and edge_geo.To == self.node[v][\"geo\"]):\n            return (u, v)\n        else:\n            return (v, u)\n\n    # EDGE PROPERTIES ---------------------------------------------------------\n\n    def _get_contour_edges(self):\n        \"\"\"\n        Get all contour edges of the network that are neither 'weft' nor\n        'warp'.\n        \"\"\"\n\n        contour_edges = [(f, t, d) for f, t, d in self.edges_iter(data=True)\n                         if not d[\"weft\"] and not d[\"warp\"]]\n        for i, ce in enumerate(contour_edges):\n            if ce[0] > ce[1]:\n                contour_edges[i] = (ce[1], ce[0], ce[2])\n        return contour_edges\n\n    contour_edges = property(_get_contour_edges, None, None,\n                             \"The contour edges of the network marked \" +\n                             \"neither 'weft' nor 'warp'.\")\n\n    def _get_weft_edges(self):\n        \"\"\"\n        Get all 'weft' edges of the network.\n        \"\"\"\n\n        weft_edges = [(f, t, d) for f, t, d in self.edges_iter(data=True)\n                      if d[\"weft\"] and not d[\"warp\"]]\n        for i, we in enumerate(weft_edges):\n            if we[0] > we[1]:\n                weft_edges[i] = (we[1], we[0], we[2])\n        return weft_edges\n\n    weft_edges = property(_get_weft_edges, None, None,\n                          \"The edges of the network marked 'weft'.\")\n\n    def _get_warp_edges(self):\n        \"\"\"\n        Get all 'warp' edges of the network.\n        \"\"\"\n\n        warp_edges = [(f, t, d) for f, t, d in self.edges_iter(data=True)\n                      if not d[\"weft\"] and d[\"warp\"]]\n        for i, we in enumerate(warp_edges):\n            if we[0] > we[1]:\n                warp_edges[i] = (we[1], we[0], we[2])\n        return warp_edges\n\n    warp_edges = property(_get_warp_edges, None, None,\n                          \"The edges of the network marked 'warp'.\")\n\n    def _get_segment_contour_edges(self):\n        \"\"\"\n        Get all contour edges of the network marked neither 'warp' nor 'weft'\n        that have a 'segment' attribute assigned sorted by the 'segment'\n        attribute.\n        \"\"\"\n\n        segment_contour_edges = [(f, t, d) for f, t, d\n                                 in self.edges_iter(data=True)\n                                 if not d[\"weft\"] and\n                                 not d[\"warp\"]]\n        segment_contour_edges = [sce for sce in segment_contour_edges\n                                 if sce[2][\"segment\"]]\n\n        for i, sce in enumerate(segment_contour_edges):\n            if sce[0] > sce[1]:\n                segment_contour_edges[i] = (sce[1], sce[0], sce[2])\n\n        # sort them by their 'segment' attributes value\n        segment_contour_edges.sort(key=lambda x: x[2][\"segment\"])\n\n        return segment_contour_edges\n\n    segment_contour_edges = property(\n                        _get_segment_contour_edges,\n                        None,\n                        None,\n                        \"The edges of the network marked neither 'warp' \" +\n                        \"nor 'weft' and which have a 'segment' attribute \" +\n                        \"assigned to them.\")\n\n    # NODE EDGE METHODS -------------------------------------------------------\n\n    def node_weft_edges(self, node, data=False):\n        \"\"\"\n        Gets the 'weft' edges connected to a given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for 'weft' edges.\n\n        data : bool, optional\n            If ``True``, the edges will be returned as 3-tuples with their\n            associated attribute data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        edges : :obj:`list`\n            List of 'weft' edges connected to the given node. Each item in the\n            list will be either a 2-tuple of (u, v) identifiers or a 3-tuple\n            of (u, v, d) where d is the attribute data of the edge, depending\n            on the data parameter.\n        \"\"\"\n\n        weft_edges = [(s, e, d) for s, e, d in\n                      self.edges_iter(node, data=True) if d[\"weft\"]]\n\n        if data:\n            return weft_edges\n        else:\n            return [(e[0], e[1]) for e in weft_edges]\n\n    def node_warp_edges(self, node, data=False):\n        \"\"\"\n        Gets the 'warp' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for 'warp' edges.\n\n        data : bool, optional\n            If ``True``, the edges will be returned as 3-tuples with their\n            associated attribute data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        edges : :obj:`list`\n            List of 'warp' edges connected to the given node. Each item in the\n            list will be either a 2-tuple of (u, v) identifiers or a 3-tuple\n            of (u, v, d) where d is the attribute data of the edge, depending\n            on the data parameter.\n        \"\"\"\n\n        warp_edges = [(s, e, d) for s, e, d in\n                      self.edges_iter(node, data=True) if d[\"warp\"]]\n\n        if data:\n            return warp_edges\n        else:\n            return [(e[0], e[1]) for e in warp_edges]\n\n    def node_contour_edges(self, node, data=False):\n        \"\"\"\n        Gets the edges marked neither 'warp' nor 'weft' connected to the\n        given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for edges marked neither\n            'warp' nor 'weft'.\n\n        data : bool, optional\n            If ``True``, the edges will be returned as 3-tuples with their\n            associated attribute data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        edges : :obj:`list`\n            List of edges marked neither 'warp' nor 'weft' connected to the\n            given node. Each item in the list will be either a 2-tuple of\n            (u, v) identifiers or a 3-tuple of (u, v, d) where d is the\n            attribute data of the edge, depending on the data parameter.\n        \"\"\"\n\n        contour_edges = [(s, e, d) for s, e, d in\n                         self.edges_iter(node, data=True)\n                         if not d[\"warp\"] and not d[\"weft\"]]\n\n        if data:\n            return contour_edges\n        else:\n            return [(e[0], e[1]) for e in contour_edges]\n\n    # SEGMENT CONTOUR END NODE METHODS ----------------------------------------\n\n    def end_node_segments_by_start(self, node, data=False):\n        \"\"\"\n        Get all the edges with a 'segment' attribute marked neither 'weft' nor\n        'warp' and share a given 'end' node at the start, sorted by the values\n        of their 'segment' attribute.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for connected segments.\n\n        data : bool, optional\n            If ``True``, the edges will be returned as 3-tuples with their\n            associated attribute data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        edges : :obj:`list`\n            List of edges. Each item will be either a 2-tuple of (u, v)\n            identifiers or a 3-tuple of (u, v, d) where d is the attribute data\n            of the edge, depending on the data parameter.\n        \"\"\"\n\n        connected_segments = [(s, e, d) for s, e, d\n                              in self.edges_iter(node, data=True) if\n                              not d[\"warp\"] and not d[\"weft\"]]\n        connected_segments = [cs for cs in connected_segments\n                              if cs[2][\"segment\"]]\n        connected_segments = [cs for cs in connected_segments\n                              if cs[2][\"segment\"][0] == node]\n\n        connected_segments.sort(key=lambda x: x[2][\"segment\"])\n\n        if data:\n            return connected_segments\n        else:\n            return [(cs[0], cs[1]) for cs in connected_segments]\n\n    def end_node_segments_by_end(self, node, data=False):\n        \"\"\"\n        Get all the edges with a 'segment' attribute marked neither 'weft' nor\n        'warp' and share a given 'end' node at the end, sorted by the values\n        of their 'segment' attribute.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for connected segments.\n\n        data : bool, optional\n            If ``True``, the edges will be returned as 3-tuples with their\n            associated attribute data.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        edges : list\n            List of edges. Each item will be either a 2-tuple of (u, v)\n            identifiers or a 3-tuple of (u, v, d) where d is the attribute data\n            of the edge, depending on the data parameter.\n        \"\"\"\n\n        connected_segments = [(s, e, d) for s, e, d\n                              in self.edges_iter(node, data=True) if\n                              not d[\"warp\"] and not d[\"weft\"]]\n        connected_segments = [cs for cs in connected_segments\n                              if cs[2][\"segment\"]]\n        connected_segments = [cs for cs in connected_segments\n                              if cs[2][\"segment\"][1] == node]\n\n        connected_segments.sort(key=lambda x: x[2][\"segment\"])\n\n        if data:\n            return connected_segments\n        else:\n            return [(cs[0], cs[1]) for cs in connected_segments]\n\n# MAIN ------------------------------------------------------------------------\n\n\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}