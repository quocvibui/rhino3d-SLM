{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Bioclimatic%20Chart.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Bioclimatic Chart.py",
  "instruction": "This is the Bioclimactic Chart. It is based in the originally proposed chart by V. Olgyay and then in the chart presented in the book \"Sun, Climate and Architecture\" by Brown.\nUse this component to...",
  "code": "# Bioclimatic Chart\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Abraham Yezioro <ayez@ar.technion.ac.il> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nThis is the Bioclimactic Chart. It is based in the originally proposed chart by V. Olgyay and then in the chart presented in the book \"Sun, Climate and Architecture\" by Brown.\nUse this component to draw a Bioclimatic chart in the Rhino scene and evaluate a set of temperatures and humidity ratios in terms of indoor comfort. Connected data can include either outdoor temperature and humidty ratios from imported EPW weather data, indoor temperature and humidity ratios from an energy simulation, or indivdual numerical inputs of temperature and humidity.  The input data will be plotted alongside polygons on the chart representing comfort as well as polygons representing the efects of passive building strategies on comfort.\nReferences:\n    1. Olgyay, V., 1963. Design with Climate. Bioclimatic Approach to Architectural Regionalism. Van Nostrand reinhold, New York.\n    2. Givoni B., 1976. Man, Climate and Architecture. Applied Science Publishers, Ltd., London.\n    3. Murray M. and Givoni B., 1979. Architectural Design Based on Climate in Watson D. (ed), 1979. Energy COnservation Through Building Design. McGraw Hill Book Company.\n    4. Yezioro, A. & E. Shaviv. 1996. A Knowledge Based CAD System for Determining Thermal Comfort Design Strategies. Renewable Energy, 8: (1-4), (pp. 133-138).\n    5. Brown G.Z. and DeKay M., 2001. Sun, WInd & Light. Architectural Design Strategies (2nd edition). John WIley  & Sons, Inc.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _dryBulbTemperature: A number representing the dry bulb temperature of the air in degrees Celcius. This input can also accept a list of temperatures representing conditions at different times or the direct output of dryBulbTemperature from the Import EPW component.  Indoor temperatures from Honeybee energy simulations are also possible inputs.\n        _relativeHumidity: A number between 0 and 100 representing the relative humidity of the air in percentage. This input can also accept a list of relative humidity values representing conditions at different times or the direct output of relativeHumidity from of the Import EPW component.\n        ------------------------------: ...\n        metabolicRate_: A number representing the metabolic rate of the human subject in met. This input can also accept text inputs for different activities. Acceptable text inputs include Sleeping, Reclining, Sitting, Typing, Standing, Driving, Cooking, House Cleaning, Walking, Walking 2mph, Walking 3mph, Walking 4mph, Running 9mph, Lifting 10lbs, Lifting 100lbs, Shoveling, Dancing, and Basketball.  If no value is input here, the component will assume a metabolic rate of 1 met, which is the metabolic rate of a seated human being.\n        clothingLevel_: A number representing the clothing level of the human subject in clo. If no value is input here, the component will assume a clothing level of 1 clo, which is roughly the insulation provided by a 3-piece suit. A person dressed in shorts and a T-shirt has a clothing level of roughly 0.5 clo and a person in a thick winter jacket can have a clothing level as high as 2 to 4 clo.\n        passiveStrategy_: An optional text input of passive strategies to be laid over the Bioclimatic chart as polygons.  Text inputs include \"Passive Solar Heating\", \"Evaporative Cooling\", \"Thermal Mass + Night Vent\" and \"Natural Ventilation\". NOT WORKING RIGHT NOW!!\n        ------------------------------: ...\n        cullMesh_: Set to \"True\" to cull the colored mesh to where they have climatic data on them. See chartMesh output. Deafult \"False\"\n        calculateCharts_: Set to \"True\" to calculate and show a column type graph showing the percentage of time each strategy is capable of providing comfort conditions. See resultsChart output. Deafult \"False\"\n        ------------------------------: ...\n        analysisPeriodWinter_: An optional analysis period from the Analysis Period component. If no Analysis period is given and epw data from the ImportEPW component has been connected, the analysis will be run for the enitre year. ONLY WORKS FOR THE WHOLE YEAR RIGHT NOW!!\n        analysisPeriodSummer_: An optional analysis period from the Analysis Period component. If no Analysis period is given and epw data from the ImportEPW component has been connected, the analysis will be run for the enitre year. ONLY WORKS FOR THE WHOLE YEAR RIGHT NOW!!\n        basePoint_: An optional base point that will be used to place the Bioclimatic Chart in the Rhino scene. If no base point is provided, the base point will be the Rhino model origin.\n        scale_: An optional number to change the scale of the Bioclimatic chart in the Rhino scene. By default, this value is set to 1.\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\n        _runIt: Set to \"True\" to run the component and calculate the adaptive comfort metrics.\n    Returns:\n        readMe!: ...\n        ------------------------------: ...\n        comfortResults: The number of hours and percent of the input data that are inside all comfort and passive strategy polygons.\n        totalComfortOrNot: A list of 0's and 1's indicating, for each hour of the input data, if the hour is inside a comfort and/or strategy polygon (1) or not(0).\n        strategyOrNot: A list of 0's and 1's indicating, for each hour of the input temperature and humidity ratio, if the hour is inside (1) or not(0), for each passive strategy and comfort polygons.  If there are multiple comfort polyogns or passive strategies connected to the passiveStrategy_ input, this output will be a grafted list for each polygon.\n        ------------------------------: ...\n        chartGridAndTxt: The grid and text labels of the Bioclimatic chart.\n        chartMesh: A colored mesh showing the number of input hours happen in each part of the Bioclimatic chart.\n        chartHourPoints: Points representing each of the hours of input temperature and humidity ratio.  By default, this ouput is hidden and, to see it, you should connect it to a Grasshopper preview component.\n        hourPointColorsByComfort: Color the chartHourPoints above according to Comfort results. They can be hooked up to the \"Swatch\" input of a Grasshopper Preview component that has the hour points above connected as geometry.  By default, points are colored red if they lie inside comfort or strategy polygons and are colored blue if they do not meet such comfort criteria.\n        hourPointColorsByMonth: Colors that the chartHourPoints above according to each month. They can be hooked up to the \"Swatch\" input of a Grasshopper Preview component that has the hour points above connected as geometry.  By default, points are colored red if they lie inside comfort or strategy polygons and are colored blue if they do not meet such comfort criteria.\n        min_maxPoints: Plot each month's Minimal/Maximal values for Temperature and Relative Humidity. By default, this ouput is hidden and, to see it, you should connect it to a Grasshopper preview component.\n        comfort_strategyPolygons: A tree of polygons representing the comfort and passive strategies areas of the chart made comfortable.\n        legend: A colored legend showing the number of hours that correspond to each color for the chartMesh output.\n        legendBasePt: The legend base point, which can be used to move the legend in relation to the chart with the grasshopper \"move\" component.\n        ------------------------------: ...\n        resultsChart: A column type graph showing the percentage of time each strategy is capable of providing comfort conditions. These results are summarizing the whole year and each month. Each column shows three areas: \n        Comfort Zone (black), \n        Passive Solar Heating (yellow), as the only heating strategy for winter time\n        Evaporative Cooling or High Termal Mass with Night Ventilation or Natural Ventilation (green, red, blue) as the possible cooling strategies for summer time.\n\n\"\"\"\nghenv.Component.Name = \"Ladybug_Bioclimatic Chart\"\nghenv.Component.NickName = 'Bioclimatic Chart'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\n#ghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\n\nimport Grasshopper.Kernel as gh\nimport math\nimport scriptcontext as sc\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\nimport System\nfrom System import Object\nfrom clr import AddReference as addr\naddr(\"Grasshopper\")\n\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n###################################\nimport Rhino.Geometry as rg\n\n#Define Model Tolerance\ntol = sc.doc.ModelAbsoluteTolerance\n\nmeshingP = rc.Geometry.MeshingParameters.Coarse\nmeshingP.SimplePlanes = True\nlb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nlb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n\nMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\nMonthDays = [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n#MonthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\nStNames = ['ComfortZone', 'PassiveSolarHeating', 'EvaporativeCooling', 'HighTermalMass+NightVent', 'NaturalVentilation']\n\ndef checkInputs():\n    #Define a value that will indicate whether someone has hooked up epw data.\n    epwData = False\n    epwStr = []\n    \n    checkData1 = False\n    if _dryBulbTemperature and _relativeHumidity:\n        try:\n            #if str(_dryBulbTemperature[2]) == 'Dry Bulb Temperature' and \\\n            #   str(_relativeHumidity[2]) == 'Relative Humidity':\n            if \"Temperature\" in _dryBulbTemperature[2] and \"Humidity\" in _relativeHumidity[2]:\n                epwData = True\n                epwStr = _dryBulbTemperature[0:7]\n                checkData1 = True\n            else: pass\n        except: pass\n    else:\n        print 'Connect a temperature in degrees celcius for _dryBulbTemperature and relative humidity to the proper input items'\n\n    #Check the metabolic rate.\n    ##checkData2 = False\n    #if len(metabolicRate_) > 0:\n    #if metabolicRate_ > 9.5 or metabolicRate_ < 0.5:\n        #print 'metabolicRate_ ', metabolicRate_\n        #print 'You entered a probably invalid metabolic rate (%.1f met). Changed to Standing rate (1.2 met) ' (float(metabolicRate_))\n        #metabolicRate_ = 1.2\n        ##checkData2 = True\n    #else:\n        #print 'metabolicRate_ ', metabolicRate_\n        ##checkData2 = True\n\n    #Check the passive strategy inputs to be sure that they are correct.\n    checkData3 = True\n    if len(passiveStrategy_) > 0:\n        for item in passiveStrategy_:\n            if item == \"Passive Solar Heating\" or item == \"Evaporative Cooling\" or item == \"Thermal Mass + Night Vent\"  or item == \"Natural Ventilation\": pass\n            else: checkData3 = False\n    if checkData3 == False:\n        warning = 'Input for passiveStrategy_ is not valid.'\n        print warning\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #If all of the checkDatas have been good to go, let's give a final go ahead.\n    ##if checkData1 == True and checkData2 and checkData3 == True :\n    if checkData1 == True and checkData3 == True :\n        checkData = True\n    else:\n        checkData = False\n\n    #print 'checkData ', checkData\n    return checkData, epwData, epwStr\n\n\n#Define colors for the following output situations (points and legends): Month colored (12 colors), comfortNOcomfort (2 colors).\ndef colors():\n    customColors = [System.Drawing.Color.FromArgb(75, 107, 169),  System.Drawing.Color.FromArgb(115, 147, 202),\n                    System.Drawing.Color.FromArgb(170, 200, 247), System.Drawing.Color.FromArgb(193, 213, 208),\n                    System.Drawing.Color.FromArgb(245, 239, 103), System.Drawing.Color.FromArgb(252, 230, 74),\n                    System.Drawing.Color.FromArgb(239, 156, 21),  System.Drawing.Color.FromArgb(234, 123, 0),\n                    System.Drawing.Color.FromArgb(234, 74, 0),    System.Drawing.Color.FromArgb(234, 38, 0)]\n                \n    monthColors = [System.Drawing.Color.FromArgb(0, 0, 0),     System.Drawing.Color.FromArgb(0, 125, 0),\n                   System.Drawing.Color.FromArgb(0, 255, 0),   System.Drawing.Color.FromArgb(0, 125, 125),\n                   System.Drawing.Color.FromArgb(0, 125, 255), System.Drawing.Color.FromArgb(0, 255, 255),\n                   System.Drawing.Color.FromArgb(0, 0, 125),   System.Drawing.Color.FromArgb(0, 0, 255),\n                   System.Drawing.Color.FromArgb(125, 0, 0),   System.Drawing.Color.FromArgb(255, 0, 0),\n                   System.Drawing.Color.FromArgb(125, 125, 0), System.Drawing.Color.FromArgb(255, 125, 0)]\n    comfortNOcomfortColors = [System.Drawing.Color.FromArgb(75, 107, 169),    # Comfort \n                              System.Drawing.Color.FromArgb(234, 38, 0)]      # NoComfort\n    \n    strategiesColors = [System.Drawing.Color.FromArgb(50, 50, 50),    # CZ\n                        System.Drawing.Color.FromArgb(200, 200, 0),   # PSH or (220, 220, 50)\n                        System.Drawing.Color.FromArgb(50, 220, 50),   # EC\n                        System.Drawing.Color.FromArgb(220, 50, 50),   # HTM\n                        System.Drawing.Color.FromArgb(50, 50, 220)]   # NV\n    \n    return monthColors, comfortNOcomfortColors, strategiesColors\n\n\n#Define a function to offset curves and return things that will stand out on the Bioclimatic chart.\ndef outlineCurve(curve):\n    try:\n        offsetCrv = curve.Offset(rc.Geometry.Plane.WorldXY, 0.25, sc.doc.ModelAbsoluteTolerance, rc.Geometry.CurveOffsetCornerStyle.Sharp)[0]\n        finalBrep = (rc.Geometry.Brep.CreatePlanarBreps([curve, offsetCrv])[0])\n    except:\n        finalBrep = rc.Geometry.Brep.CreatePlanarBreps([curve])[0]\n        warning = \"Creating an outline of one of the comfort or strategy curves failed.  Component will return a solid brep.\"\n        print warning\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    return finalBrep\n\n\ndef createResultsLegend(orgX, orgY, orgZ, gridStep, monthStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, lb_preparation, legendFontSize, legendBold, legendFont, strategiesColors):\n    if legendFontSize == None: legendFontSize = 2\n    \n    #Make axis labels for the chart.\n    xAxisLabels = []\n    xAxisTxt = [\"Comfort Strategies\"]\n    xAxisPt = [rc.Geometry.Point3d(orgX + 0., orgY - 5.0, 0)]\n    xAxisLabels.extend(lb_visualization.text2srf(xAxisTxt, xAxisPt, legendFont, legendFontSize*1.25, legendBold)[0])\n\n        \n    # Make the percentage text for the chart Y axis.\n    percentText = []\n    percentLabels = []\n    percentLabelBasePts = []\n    percentNum = range(0, 110, 10)\n    for count, percent in enumerate(percentNum):\n        percentLabelBasePts.append(rc.Geometry.Point3d(orgX - 8, orgY + (percent)-0.75, 0))\n        percentText.append(str(percent)+\"%\")\n    for count, text in enumerate(percentText):\n        percentLabels.extend(lb_visualization.text2srf([text], [percentLabelBasePts[count]], legendFont, legendFontSize*.75, legendBold)[0])\n\n    # Make the Title at top.\n    titleLabels = []\n    titleTxt = \"Year Results\"\n    titlePt = [rc.Geometry.Point3d(orgX + 0., (100 + orgY + 1), 0)]\n\n    titleLabels.extend(lb_visualization.text2srf([titleTxt], [titlePt[0]], legendFont, legendFontSize*1.5, True)[0])\n    \n    #Months titles loop\n    step = monthStep\n    for m in range(0, len(MonthNames)):\n        #titleLabels = []\n        titleTxt = MonthNames[m]\n        titlePt = [rc.Geometry.Point3d(orgX + step, (100 + orgY + 1), 0)]\n        step += monthStep\n        titleLabels.extend(lb_visualization.text2srf([titleTxt], [titlePt[0]], legendFont, legendFontSize*1.5, legendBold)[0])\n    \n    \n    # Create legend with Strategies Names, at bottom right.\n    legLabels = []\n    legLabels1 = []\n    legResultstText = []\n    legPolygon = []\n    legLabelBasePts = []\n    legLabelBasePts1 = []\n    legColorLabelBasePts = []\n    legColorLabelBasePts1 = []\n    legNum = range(int(orgY), 50, 8)\n    radius = 2.0\n    segments = 4\n    for count, leg in enumerate(legNum):\n        legLabelBasePts.append(rc.Geometry.Point3d(xLineValue[12] + 50, leg + 1.50, 0))\n        legColorLabelBasePts.append(rc.Geometry.Point3d(xLineValue[12] + 46, leg + 1.25, 0))\n        legColorLabelBasePts1.append(rc.Geometry.Point3d(xLineValue[12] + 50, leg - 1.0, 0)) ####\n    for count, text in enumerate(strategyNames):\n        combString = '%.1f%% - %d hours' % (strategyPercent[count], strategyHours[count])\n        legResultstText.append(combString) #strategyPercent, strategyHours\n    for count, text in enumerate(legResultstText):\n        legLabels1.extend(lb_visualization.text2srf([text], [legColorLabelBasePts1[count]], legendFont, legendFontSize*.75, legendBold)[0])\n        \n    for count, text in enumerate(strategyNames):\n        if   count == 0: colorP = strategiesColors[0]    # CZ\n        elif count == 1: colorP = strategiesColors[1]    # PSH or (220, 220, 50)\n        elif count == 2: colorP = strategiesColors[2]    # EC\n        elif count == 3: colorP = strategiesColors[3]    # HTM\n        elif count == 4: colorP = strategiesColors[4]    # NV\n        else           : colorP = System.Drawing.Color.FromArgb(255, 255, 255, 255)\n        \n        legLabels.extend(lb_visualization.text2srf([text], [legLabelBasePts[count]], legendFont, legendFontSize*0.75, legendBold)[0])\n        legPol = drawPolygon(legColorLabelBasePts[count], radius, segments, colorP)\n        legPolygon.append(legPol)\n    \n    #Bring all legend and text together in one list.\n    restText = []\n    for item in percentLabels:\n        restText.append(item)\n    #for item in relHumidLabels:\n    #    restText.append(item)\n    for item in xAxisLabels:\n        restText.append(item)\n    #for item in yAxisLabels:\n    #    restText.append(item)\n    for item in titleLabels:\n        restText.append(item)\n    for item in legLabels:\n        restText.append(item)\n    for item in legLabels1:\n        restText.append(item)\n    for item in legPolygon:\n        restText.append(item)\n    \n    return restText\n\ndef createChartLayout(orgX, orgY, orgZ, location, legendFont, legendFontSize, legendBold):\n    if legendFontSize == None: legendFontSize = 2\n    \n    #Make axis labels for the chart.\n    xAxisLabels = []\n    xAxisTxt = [\"Humidity Ratio\"]\n    #xAxisPt = [rc.Geometry.Point3d(orgX + 35., orgY - 10.0, 0)]\n    xAxisPt = [rc.Geometry.Point3d(orgX, orgY - 10.0, 0)]\n    xAxisLabels.extend(lb_visualization.text2srf(xAxisTxt, xAxisPt, legendFont, legendFontSize*1.25, True)[0])\n        \n    yAxisLabels = []\n    yAxisTxt = [\"Dry Bulb Temperature\"]\n    #yAxisPt = [rc.Geometry.Point3d(orgX - 10.0, orgY + 35., 0)]\n    yAxisPt = [rc.Geometry.Point3d(orgX - 10.0, orgY, 0)]\n    yAxisLabels.extend(lb_visualization.text2srf(yAxisTxt, yAxisPt, legendFont, legendFontSize*1.25, True)[0])\n    #rotateTransf = rc.Geometry.Transform.Rotation(1.57079633, rc.Geometry.Point3d(orgX - 10.0, orgY + 35., 0))\n    rotateTransf = rc.Geometry.Transform.Rotation(1.57079633, rc.Geometry.Point3d(orgX - 10.0, orgY, 0))\n    for geo in yAxisLabels:\n        geo.Transform(rotateTransf)\n    \n    #tempNum = range(orgY + 5, 55, 5)\n    tempNum = range(int(orgY/2), 55, 5)\n    relHumidNum = range(0, 110, 10)\n    \n    # Make the relative humidity text for the chart.\n    relHumidBasePts = []\n    relHumidTxt = []\n    relHumidLabels = []\n    for count, humid in enumerate(relHumidNum):\n        #print 'count ', count, humid\n        relHumidBasePts.append(rc.Geometry.Point3d(humid - 2, orgY - 3, 0))\n        relHumidTxt.append(str(humid)+\"%\")\n    for count, text in enumerate(relHumidTxt):\n        relHumidLabels.extend(lb_visualization.text2srf([text], [relHumidBasePts[count]], legendFont, legendFontSize*.75, legendBold)[0])\n    \n    # Make the temperature text for the chart.\n    tempText = []\n    tempLabels = []\n    tempLabelBasePts = []\n    for count, temp in enumerate(tempNum):\n        #print 'count ', count, temp\n        tempLabelBasePts.append(rc.Geometry.Point3d(-5, (temp * 2)-0.75, 0))\n        tempText.append(str(temp))\n    for count, text in enumerate(tempText):\n        tempLabels.extend(lb_visualization.text2srf([text], [tempLabelBasePts[count]], legendFont, legendFontSize*.75, legendBold)[0])\n    \n    titleLabels = []\n    titleTxt = [\"Bio Climatic Chart\", location]\n    titlePt = [rc.Geometry.Point3d(orgX, 108, 0), \n    rc.Geometry.Point3d(orgX, 103, 0)]\n    for count, text in enumerate(titleTxt):\n        titleLabels.extend(lb_visualization.text2srf([text], [titlePt[count]], legendFont, legendFontSize*1.5, legendBold)[0])\n    \n    #Bring all text and curves together in one list.\n    chartLayout = []\n    for item in tempLabels:\n        chartLayout.append(item)\n    for item in relHumidLabels:\n        chartLayout.append(item)\n    for item in xAxisLabels:\n        chartLayout.append(item)\n    for item in yAxisLabels:\n        chartLayout.append(item)\n    for item in titleLabels:\n        chartLayout.append(item)\n    \n    return chartLayout\n\ndef createChartLegend(orgX, orgY, orgZ, strategyNames, lb_preparation, legendScale, legendFont, legendFontSize, legendBold, lb_visualization, strategiesColors, monthColors, comfortNOcomfortColors, customColors, totalComfortOrNot):\n    if legendFontSize == None: legendFontSize = 2\n    \n    # ************** Generate a legend for strategies ***********\n    legStrategyLabels = []\n    legLabelBasePts = []\n    finalLegPolyline = []\n    \n    legMonthLabels = []\n    legMonthLabelBasePts = []\n    \n    legComfLabels = []\n    legComfLabelBasePts = []\n\n    shiftY = -20 #-15\n    leg = int(orgY) + shiftY\n    #legNum = range(int(orgY) + shiftY, -23 + shiftY, -3) # [-25, -28, -31, -34, -37] Need 5 values for 5 strategies\n\n    legStrategyPolygons = []\n    for count, text in enumerate(strategyNames):\n        if   count == 0: color = strategiesColors[0]    # CZ\n        elif count == 1: color = strategiesColors[1]    # PSH or (220, 220, 50)\n        elif count == 2: color = strategiesColors[2]    # EC\n        elif count == 3: color = strategiesColors[3]    # HTM\n        elif count == 4: color = strategiesColors[4]    # NV\n        else           : color = System.Drawing.Color.FromArgb(255, 0, 255, 255)\n        \n        legLinePt = []\n        legLabelBasePts.append(rc.Geometry.Point3d(orgX + 10, leg + 0.0, 0)) # Base point for each strategy name\n        points = [orgX, leg + 0.75, 0.0],[orgX + 9.0, leg + 0.75, 0.0], [orgX + 9.0, leg + 0.751, 0.0], [orgX, leg + 0.751, 0.0], \\\n                 [orgX, leg + 0.75, 0.0] # Coords for the line in the strategies legend\n        for cc in range(0, len(points)):\n            legLinePt.append(rc.Geometry.Point3d(points[cc][0], points[cc][1], points[cc][2]))\n            \n        legPolyline = rc.Geometry.PolylineCurve(legLinePt)\n        leg += -3\n        \n        finalLegPolyline.append(outlineCurve(legPolyline)) # This is the element to use for coloring the legend\n        \n        legMesh = rc.Geometry.Mesh()\n        legMesh.Append(rc.Geometry.Mesh.CreateFromBrep(finalLegPolyline[count])[0])\n        legMesh.VertexColors.CreateMonotoneMesh(color)\n        legStrategyPolygons.append(legMesh)\n        \n        # Draw the strategies names\n        legStrategyLabels.extend(lb_visualization.text2srf([text], [legLabelBasePts[count]], legendFont, legendFontSize*0.75, legendBold)[0])\n    # ************** End Legend of strategies ***********\n    \n    \"\"\"\n    # ************** Generate a legend for comfortOrNot Using Chris's way from Psychrometric chart ***********\n    leg = int(orgY) + shiftY - 11.0\n    ##pointColors = []\n    legComfBasePts = rc.Geometry.Point3d(orgX + 45, leg, 0) # Base point comfortOrNot legend\n    \n    if str(totalComfortOrNot[0]) == \"key:location/dataType/units/frequency/startsAt/endsAt\":\n        totalComfortOrNot = totalComfortOrNot[7:]\n    ##pointColors.append(lb_visualization.gradientColor(totalComfortOrNot, 0, 1, customColors))\n    \n    legend = []\n    #legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(totalComfortOrNot, 0, 1, 2, \"Comfort\", lb_visualization.BoundingBoxPar, legComfBasePts, legendScale, legendFont, legendFontSize, decimalPlaces, removeLessThan)\n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(totalComfortOrNot, 0, 1, 2, \"Comfort or Not\", lb_visualization.BoundingBoxPar, legComfBasePts, .45, legendFont, 1.5, decimalPlaces, removeLessThan)\n    legendColors = lb_visualization.gradientColor(legendText[:-1], 0, 1, customColors)\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    legend.append(legendSrfs)\n    for list in legendTextCrv:\n        for item in list:\n            legend.append(item)\n    # ************** End Legend of comfortOrNot ***********\n    \"\"\"\n    \n    radius = 0.7\n    segments = 6\n    \n    # ************** Generate a legend for comfortOrNot ***********\n    leg = int(orgY) + shiftY\n    legComfCircle = []\n    circCenter = []\n    circPolyline = []\n    for m in range(0, 2):   # 0 to 2 for Comfort or NoComfort possibilities\n        if m == 0: text = \"No Comfort\"\n        else     : text = \"Comfort\"\n        circCenter.append(rc.Geometry.Point3d(orgX + 55, leg + radius/2, 0)) # Base point for each month circle\n        legComfLabelBasePts.append(rc.Geometry.Point3d(orgX + 57, leg + 0.0, 0)) # Base point for each month name\n        leg += -3\n        # Draw the comfortOrNot circles and value\n        cP, dataPolyline = circPoints(circCenter[m], radius, segments)\n        \n        circPolyline.append(outlineCurve(dataPolyline)) # This is the element to use for coloring the legend\n        legMesh = rc.Geometry.Mesh()\n        legMesh.Append(rc.Geometry.Mesh.CreateFromBrep(circPolyline[m])[0])\n        legMesh.VertexColors.CreateMonotoneMesh(comfortNOcomfortColors[m])\n        \n        legComfCircle.append(legMesh)\n        legComfLabels.extend(lb_visualization.text2srf([text], [legComfLabelBasePts[m]], legendFont, legendFontSize*0.75, legendBold)[0])\n    # ************** End Legend of comfortOrNot ***********\n    \n    # ************** Generate a legend for Month colored ***********\n    leg = int(orgY) + shiftY\n    legMonthsCircle = []\n    circCenter = []\n    circPolyline = []\n    for count, text in enumerate(MonthNames):\n        circCenter.append(rc.Geometry.Point3d(orgX + 85, leg + radius/2, 0)) # Base point for each month circle\n        legMonthLabelBasePts.append(rc.Geometry.Point3d(orgX + 87, leg + 0.0, 0)) # Base point for each month name\n        leg += -3\n        # Draw the Months circles and names\n        cP, dataPolyline = circPoints(circCenter[count], radius, segments)\n        \n        circPolyline.append(outlineCurve(dataPolyline)) # This is the element to use for coloring the legend\n        legMesh = rc.Geometry.Mesh()\n        legMesh.Append(rc.Geometry.Mesh.CreateFromBrep(circPolyline[count])[0])\n        legMesh.VertexColors.CreateMonotoneMesh(monthColors[count])\n        \n        legMonthsCircle.append(legMesh)\n        legMonthLabels.extend(lb_visualization.text2srf([text], [legMonthLabelBasePts[count]], legendFont, legendFontSize*0.75, legendBold)[0])\n    # ************** End Legend of Month colors ***********\n    \n    #Bring all text and curves together in one list.\n    chartLegend = []\n    for item in finalLegPolyline:\n        chartLegend.append(item)\n    for item in legStrategyPolygons:\n        chartLegend.append(item)\n    for item in legStrategyLabels:\n        chartLegend.append(item)\n    \n    #for item in legend: # This is for Chris's way - Keep commented/uncommented together with the block above\n    #    chartLegend.append(item)\n\n    for item in legComfCircle:\n        chartLegend.append(item)\n    for item in legComfLabels:\n        chartLegend.append(item)\n    \n    for item in legMonthsCircle:\n        chartLegend.append(item)\n    for item in legMonthLabels:\n        chartLegend.append(item)\n    \n    return chartLegend\n\n#def strategyDraw_Calc(name, shiftFactor, *points): # The x is for a list of points passed one by one\ndef strategyDraw_Calc(name, shiftFactor, points, hourPoints, tol, dryBulbTemperature, totalHrs, cR, cG, cB):\n    strategyID = [0 for x in range(totalHrs)] \n    \n    strategyPt = []\n    for x in range(0, len(points)):\n        strategyPt.append(rc.Geometry.Point3d(points[x][0], points[x][1] + shiftFactor, points[x][2] + 0.05))\n    \n    #Draw Polygon\n    strategyPolyline = rc.Geometry.PolylineCurve(strategyPt)\n    #meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(strategyPolyline.ToNurbsCurve(), meshingP)\n    \n    #Turn the comfort curve into a brep that will show up well on the chart.\n    #finalStrategyPolyline = []\n    finalStrategyPolyline = outlineCurve(strategyPolyline)\n\n    strategyPolygon  = rc.Geometry.Brep.CreatePlanarBreps(strategyPolyline)[0]\n###    try: strategyPolygon  = rc.Geometry.Brep.CreatePlanarBreps(strategyPolyline)[0]\n###    except: strategyPolygon  = None\n    \n    #Start STRATEGY statistics ********************************\n    #Find the hours in the STRATEGY.\n    strategyList = []\n    n = 0\n    for point in hourPoints:\n        containment = strategyPolyline.Contains(point, rc.Geometry.Plane.WorldXY, tol)\n        if str(containment) == 'Inside':\n            strategyList.append(1)\n            strategyID[n] = 1\n        else: strategyList.append(0)\n        n += 1\n    \n    #Find the STRATEGY Percentage.\n    numStrHrs = sum(strategyList)\n    totalHrs = len(dryBulbTemperature)\n    strPercent = (numStrHrs / totalHrs)*100\n    #End STRATEGY statistics ********************************\n\n    #return numStrHrs, strPercent, strategyID, strategyPolygon\n    return numStrHrs, strPercent, strategyID, strategyPolygon, finalStrategyPolyline\n    \ndef drawColorResults(czPt, pshPt, stPt, colorCZ, colorPSH, colorST):\n    \n    alpha = 255 # 0 = Transparent, 255 = Opaque ... supposed to be so\n    colResMesh = []\n    for count in range(3):\n        if count == 0:\n            color = colorCZ\n            #Draw each Result\n            dataPolyline = rc.Geometry.PolylineCurve(czPt)\n            meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n        elif count == 1:\n            color = colorPSH\n            dataPolyline = rc.Geometry.PolylineCurve(pshPt)\n            meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n        elif count == 2:\n            color = colorST\n            dataPolyline = rc.Geometry.PolylineCurve(stPt)\n            meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n\n        # generate the color list for all the vertices\n        repeatedColors = []\n        for face in range(meshedC.Faces.Count):\n            repeatedColors.append(color)\n        \n        #  use ladybug functions to color the circle\n        ##colMesh = lb_visualization.colorMesh(repeatedColors, meshedC)\n        if count == 0 :   colMesh1 = lb_visualization.colorMesh(repeatedColors, meshedC)\n        elif count == 1 : colMesh2 = lb_visualization.colorMesh(repeatedColors, meshedC)\n        elif count == 2 : colMesh3 = lb_visualization.colorMesh(repeatedColors, meshedC)\n        \n        ####colResMesh.append(colMesh)\n        #colResMesh[count] = colMesh\n        #print count, colMesh\n        \n    #Bring all legend and text together in one list.\n    ##colMeshGGraph = []\n    #for item in colResMesh:\n    #for item in colMesh:\n        #colMeshGGraph.append(item)\n    ##return colMesh\n    ####return colResMesh\n    return colMesh1, colMesh2, colMesh3\n    ##return colMeshGGraph\n    \n    \ndef graphResults(orgX, orgY, orgZ, gridStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, lb_preparation, legendFontSize, legendFont, strategiesColors):\n    \n    czBot = orgY\n    czTop = orgY + strategyPercent[0]\n    pshBot = czTop\n    pshTop = czTop + strategyPercent[1]\n    firstX = orgX\n    \n    colorCZ = strategiesColors[0]  # CZ\n    colorPSH = strategiesColors[1] # PSH\n    \n    stResGraph = []\n    seeChartResults = []\n    for count in range(2, len(strategyNames)): # Start from third strategy. First 2 are: CZ and PSH which are fixed\n        if   count == 0: colorST = strategiesColors[0]    # CZ\n        elif count == 1: colorST = strategiesColors[1]    # PSH\n        elif count == 2: colorST = strategiesColors[2]    # EC\n        elif count == 3: colorST = strategiesColors[3]    # HTM\n        elif count == 4: colorST = strategiesColors[4]    # NV\n        else           : colorST = [255, 255, 255]\n        czPt = []\n        pshPt = []\n        stPt = []\n        czPt.append(rc.Geometry.Point3d(firstX + 2.0, czBot, 0.0))\n        czPt.append(rc.Geometry.Point3d(firstX + 8.0, czBot, 0.0))\n        czPt.append(rc.Geometry.Point3d(firstX + 8.0, czTop, 0.0))\n        czPt.append(rc.Geometry.Point3d(firstX + 2.0, czTop, 0.0))\n        czPt.append(rc.Geometry.Point3d(firstX + 2.0, czBot, 0.0))\n        \n        pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshBot, 0.0))\n        pshPt.append(rc.Geometry.Point3d(firstX + 8.0, pshBot, 0.0))\n        pshPt.append(rc.Geometry.Point3d(firstX + 8.0, pshTop, 0.0))\n        pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n        pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshBot, 0.0))\n        \n        stTop = pshTop + strategyPercent[count]\n        stPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n        stPt.append(rc.Geometry.Point3d(firstX + 8.0, pshTop, 0.0))\n        stPt.append(rc.Geometry.Point3d(firstX + 8.0, stTop, 0.0))\n        stPt.append(rc.Geometry.Point3d(firstX + 2.0, stTop, 0.0))\n        stPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n        firstX = firstX + 10.0\n        \n        #Draw Polygon\n        strategyPolyline = rc.Geometry.PolylineCurve(stPt)\n        stResGraph.append(strategyPolyline)\n        \n        strategyPolyline = rc.Geometry.PolylineCurve(pshPt)\n        stResGraph.append(strategyPolyline)\n    \n        strategyPolyline = rc.Geometry.PolylineCurve(czPt)\n        stResGraph.append(strategyPolyline)\n        \n        #print colorCZ, colorPSH, colorST, colorKK\n        \n        ##colorResultsMesh = drawColorResults(czPt, pshPt, stPt, colorCZ, colorPSH, colorST) # Calling routine for drawing the results in color\n        ##stResGraph.append(colorResultsMesh)\n        colorResultsMesh1, colorResultsMesh2, colorResultsMesh3 = drawColorResults(czPt, pshPt, stPt, colorCZ, colorPSH, colorST) # Calling routine for drawing the results in color\n        stResGraph.append(colorResultsMesh1)\n        stResGraph.append(colorResultsMesh2)\n        stResGraph.append(colorResultsMesh3)\n        \n    #Bring all legend and text together in one list.\n    ##seeChartResults = []\n    for item in stResGraph:\n        seeChartResults.append(item)\n    \n    ##return seeChartResults\n    return stResGraph\n\n\ndef graphResultsMonth(orgX, orgY, orgZ, gridStep, monthStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, strategyMonth, lb_preparation, legendFontSize, legendFont, strategiesColors):\n    \n    colorCZ = strategiesColors[0]  # CZ\n    colorPSH = strategiesColors[1] # PSH\n    y = float()\n    \n    #Months titles loop\n    step = 0\n    seeChartResults = []\n    stResGraph = []\n    for month in range(0, len(MonthNames)):\n        step += monthStep\n        czBot  = orgY\n        for line in strategyMonth[0][month][0:1]: \n            if line == 0:\n                line = 0.01\n            czTop  = orgY  + line # CZ & Percentage in the list\n        pshBot = czTop\n        for line in strategyMonth[1][month][0:1]:\n            if line == 0:\n                line = 0.01\n            pshTop = czTop + line # PSH & Percentage in the list\n        firstX = orgX + step\n\n        ##for count in range(0, len(StNames)):\n        for count in range(2, len(strategyNames)):\n            #for count in range(2, len(strategyNames)): # Start from third strategy. First 2 are: CZ and PSH which are fixed\n            if   count == 0: colorST = strategiesColors[0]    # CZ\n            elif count == 1: colorST = strategiesColors[1]    # PSH\n            elif count == 2: colorST = strategiesColors[2]    # EC\n            elif count == 3: colorST = strategiesColors[3]    # HTM\n            elif count == 4: colorST = strategiesColors[4]    # NV\n            else           : colorST = [255, 255, 255]\n            \n            czPt = []\n            pshPt = []\n            stPt = []\n            czPt.append(rc.Geometry.Point3d(firstX + 2.0, czBot, 0.0))\n            czPt.append(rc.Geometry.Point3d(firstX + 8.0, czBot, 0.0))\n            czPt.append(rc.Geometry.Point3d(firstX + 8.0, czTop, 0.0))\n            czPt.append(rc.Geometry.Point3d(firstX + 2.0, czTop, 0.0))\n            czPt.append(rc.Geometry.Point3d(firstX + 2.0, czBot, 0.0))\n            \n            pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshBot, 0.0))\n            pshPt.append(rc.Geometry.Point3d(firstX + 8.0, pshBot, 0.0))\n            pshPt.append(rc.Geometry.Point3d(firstX + 8.0, pshTop, 0.0))\n            pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n            pshPt.append(rc.Geometry.Point3d(firstX + 2.0, pshBot, 0.0))\n            \n            for line in strategyMonth[count][month][0:1]: \n                if line == 0:\n                    line = 0.01\n                stTop = pshTop + float(line) # Strategy & Percentage in the list\n            #stTop = pshTop + strategyPercent[count]\n            stPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n            stPt.append(rc.Geometry.Point3d(firstX + 8.0, pshTop, 0.0))\n            stPt.append(rc.Geometry.Point3d(firstX + 8.0, stTop, 0.0))\n            stPt.append(rc.Geometry.Point3d(firstX + 2.0, stTop, 0.0))\n            stPt.append(rc.Geometry.Point3d(firstX + 2.0, pshTop, 0.0))\n            firstX = firstX + 10.0\n            \n            #Draw Polygon\n            strategyPolyline = rc.Geometry.PolylineCurve(stPt)\n            stResGraph.append(strategyPolyline)\n            \n            strategyPolyline = rc.Geometry.PolylineCurve(pshPt)\n            stResGraph.append(strategyPolyline)\n        \n            strategyPolyline = rc.Geometry.PolylineCurve(czPt)\n            stResGraph.append(strategyPolyline)\n            \n            ##colorResultsMesh = drawColorResults(czPt, pshPt, stPt, colorCZ, colorPSH, colorST) # Calling routine for drawing the results in color\n            ##stResGraph.append(colorResultsMesh)\n            colorResultsMesh1, colorResultsMesh2, colorResultsMesh3 = drawColorResults(czPt, pshPt, stPt, colorCZ, colorPSH, colorST) # Calling routine for drawing the results in color\n            stResGraph.append(colorResultsMesh1)\n            stResGraph.append(colorResultsMesh2)\n            stResGraph.append(colorResultsMesh3)\n        \n    #Bring all legend and text together in one list.\n    for item in stResGraph:\n        seeChartResults.append(item)\n    \n    #return stResGraph\n    return seeChartResults\n\n    \ndef showResults(basePoint_, mainLegHeight, strategyNames, strategyPercent, strategyHours, strategyMonth, \\\n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, lb_preparation, lb_visualization, strategiesColors):\n    gridLines = []\n    resultsChart = []\n    \n    shiftRes = 45\n    orgX = int(shiftRes + legendBasePoint[0])\n    orgY = int(legendBasePoint[1])\n    orgZ = int(legendBasePoint[2])\n    \n    monthStep = 40\n    resLimitX = monthStep * 13\n    \n    boundBoxX = 40\n    boundBoxY = abs(orgY) + 100\n    scaleLegBox = mainLegHeight / 100\n    #print 'BB = ', boundBoxX, boundBoxY, orgX, orgY, mainLegHeight, scaleLegBox\n    gridStep = 10\n    \n    # Grid Lines *******************************\n    #xLineValue = range(orgX, orgX + 50, 40)\n    xLineValue = range(orgX, orgX + resLimitX + monthStep, monthStep)\n    yLineValue = range(orgY, orgY + 110, gridStep)\n\n    #for m in range(0, len(MonthNames)+1):\n\n\n    for value in xLineValue: #Bottom to Top lines\n        gridLines.append(rc.Geometry.Line(value, orgY, 0, value, (100 + orgY), 0))\n        #print value-orgX\n        \n    for value in yLineValue: # Left to right lines\n        #gridLines.append(rc.Geometry.Line(orgX, value, 0, orgX + 40, value, 0))\n        gridLines.append(rc.Geometry.Line(orgX, value, 0, orgX + resLimitX, value, 0))\n    # End Grid Lines ****************************\n    # Print Title and legends in grid: X/Y axis ****************************\n    location = 'Results'\n    resText = createResultsLegend(orgX, orgY, orgZ, gridStep, monthStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, lb_preparation, legendFontSize, legendBold, legendFont, strategiesColors)\n    \n    # This is for Year results --- in the future this and the monthly results should be unified in one single routine\n    seeChartResults = graphResults(orgX, orgY, orgZ, gridStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, lb_preparation, legendFontSize, legendFont, strategiesColors)\n    # This is for monthly results\n    seeMonthChartResults = graphResultsMonth(orgX, orgY, orgZ, gridStep, monthStep, xLineValue, yLineValue, location, strategyNames, strategyPercent, strategyHours, strategyMonth, lb_preparation, legendFontSize, legendFont, strategiesColors)\n    \n    # Collect all Results, Legend and Gridlines in one list.\n    for item in gridLines:\n        resultsChart.append(item)\n    for item in resText:\n        resultsChart.append(item)\n    for item in seeChartResults:\n        resultsChart.append(item)\n    for item in seeMonthChartResults:\n        resultsChart.append(item)\n        \n    bPt = rc.Geometry.Point3d(20., -2., 0.)\n    #bPtSc = rc.Geometry.Point3d(0., 0., 0.)\n    scale = rc.Geometry.Transform.Scale(bPt, scaleLegBox)\n    move = rc.Geometry.Transform.Translation(bPt.X, bPt.Y, bPt.Z)\n    transformMtx = scale * move\n    for geo in resultsChart: geo.Transform(transformMtx)\n    \n    return resultsChart    \n\ndef circPoints(centerPt, radius, secs):\n    dt = 2.0 * math.pi / secs\n    div = 2*math.pi/secs\n    ang = 0\n    \n    cP = []\n    for n in range(0, secs+1):  # The +1 is to make the last point equal to the first, so the polygon will be closed\n        if n == secs+1:\n            ang = 0\n        ptX = (centerPt.X + radius * math.cos(ang))\n        ptY = (centerPt.Y + radius * math.sin(ang))\n        ptZ = (centerPt.Z)+ 0.1\n        cP.append(rc.Geometry.Point3d(ptX, ptY, ptZ))\n        ang += div\n        \n    #Draw each climatic data\n    dataPolyline = rc.Geometry.PolylineCurve(cP)\n    \n    return cP, dataPolyline\n    \ndef drawPolygon(centerPt, radius, secs, color):\n    dt = 2.0 * math.pi / secs\n    div = 2*math.pi/secs\n    ang = 0\n    \n    cP = []\n    for n in range(0, secs+1):  # The +1 is to make the last point equal to the first, so the polygon will be closed\n        if n == secs+1:\n            ang = 0\n        ptX = (centerPt.X + radius * math.cos(ang))\n        ptY = (centerPt.Y + radius * math.sin(ang))\n        ptZ = (centerPt.Z)+ 0.1\n        cP.append(rc.Geometry.Point3d(ptX, ptY, ptZ))\n        ang += div\n        \n    #Draw each climatic data\n    dataPolyline = rc.Geometry.PolylineCurve(cP)\n    meshedC = rc.Geometry.Mesh.CreateFromPlanarBoundary(dataPolyline.ToNurbsCurve(), meshingP)\n\n    # generate the color list for all the vertices\n    repeatedColors = []\n    for face in range(meshedC.Faces.Count):\n        repeatedColors.append(color)\n    \n    #  use ladybug functions to color the circle\n    colMesh = lb_visualization.colorMesh(repeatedColors, meshedC)\n    \n    return colMesh\n\n# Routine that gets monthly statistics and Min/Max values\ndef monthCalcs(totalHrs, comfID, pshID, ecID, htmID, nvID, dryBulbTemperature, relativeHumidity, monthPoints, monthColors, comfortNOcomfortColors):\n    stM = 0\n    pointMinMax = []\n    geoMinMax = []\n    allMinMax = []\n    \n    comfID_m = []\n    pshID_m = []\n    ecID_m = []\n    htmID_m = []\n    nvID_m = []\n    \n    colByComfort = []\n    colByMonth = []\n    \n    for m in range(0, len(monthPoints)):\n        geoMinMax.append([])\n        \n        comfID_m.append([])\n        pshID_m.append([])\n        ecID_m.append([])\n        htmID_m.append([])\n        nvID_m.append([])\n        cfZ = pshZ = ecZ = htmZ = nvZ = 0\n        colByComfort.append([])\n        colByMonth.append([])\n        \n        minTemp = 50.0\n        maxTemp = -50.0\n        minHum = 100.0\n        maxHum = 0.0\n        \n        monthHours = len(monthPoints[m])\n        for n in range(stM, stM + len(monthPoints[m])):  #Start the counter from the previos month hour\n            #for temp in dryBulbTemperature:\n            if dryBulbTemperature[n] < minTemp:\n                minTemp = dryBulbTemperature[n]\n            if dryBulbTemperature[n] > maxTemp:\n                maxTemp = dryBulbTemperature[n]\n            if relativeHumidity[n] < minHum:\n                minHum = relativeHumidity[n]\n            if relativeHumidity[n] > maxHum:\n                maxHum = relativeHumidity[n]\n                \n            # Summing up the points for each strategy\n            if comfID[n] == 1: cfZ  += 1\n            if pshID[n]  == 1: pshZ += 1\n            if ecID[n]   == 1: ecZ  += 1\n            if htmID[n]  == 1: htmZ += 1\n            if nvID[n]   == 1: nvZ  += 1\n            \n            # See if the point is in any comfort strategy and the use a color for Comfort/NotComfort\n            if comfID[n] == 1 or pshID[n]  == 1 or ecID[n]   == 1 or htmID[n]  == 1 or nvID[n]   == 1:\n                colByComfort[m].append(comfortNOcomfortColors[1])\n            else:\n                colByComfort[m].append(comfortNOcomfortColors[0])\n            \n            #colByMonth[m].append(colorP)\n            colByMonth[m].append(monthColors[m])\n             \n        # Calculate the effective percentage per month and number of comfort for each strategy\n        czM_Perc = cfZ * 100 / len(monthPoints[m])\n        comfID_m[m] = [czM_Perc, cfZ, monthHours]\n        \n        pshM_Perc = pshZ * 100 / len(monthPoints[m])\n        pshID_m[m] = [pshM_Perc, pshZ, monthHours]\n        \n        ecM_Perc = ecZ * 100 / len(monthPoints[m])\n        ecID_m[m] = [ecM_Perc, ecZ, monthHours]\n        \n        htmM_Perc = htmZ * 100 / len(monthPoints[m])\n        htmID_m[m] = [htmM_Perc, htmZ, monthHours]\n        \n        nvM_Perc = nvZ * 100 / len(monthPoints[m])\n        nvID_m[m] = [nvM_Perc, nvZ, monthHours]\n        \n        #print m, comfID_m[m], pshID_m[m], ecID_m[m], htmID_m[m], nvID_m[m]\n        \n        pointMinMax.append([minTemp * 2, maxTemp * 2, minHum, maxHum])\n        stM = stM + len(monthPoints[m])\n        geoMinMax[m].append(rc.Geometry.Line(pointMinMax[m][3], pointMinMax[m][0], 0, pointMinMax[m][2], pointMinMax[m][1], 0))    #Line connecting min-max\n        \n        colorP = System.Drawing.Color.FromArgb(0, 0, 0)\n        minPt = rc.Geometry.Point3d(pointMinMax[m][3], pointMinMax[m][0], 0)\n        maxPt = rc.Geometry.Point3d(pointMinMax[m][2], pointMinMax[m][1], 0)\n        \n        dataPolygon = drawPolygon (minPt, .8, 4, colorP)\n        geoMinMax[m].append(dataPolygon)\n        dataPolygon = drawPolygon (maxPt, .8, 4, colorP)\n        geoMinMax[m].append(dataPolygon)\n        \n        #geoMinMax[m].append(rc.Geometry.Circle(minPt, 0.5))\n        #geoMinMax[m].append(rc.Geometry.Circle(maxPt, 0.5))\n        \n    # Collect all monthly results for all strategies under one variable - in the future all calculations should be done under this variable\n    strategyMonth = []\n    for count in range(0, len(StNames)):\n        strategyMonth.append([])\n        for month in range(0, len(MonthNames)):\n            strategyMonth[count].append([])\n            if StNames[count]   == 'ComfortZone':\n                strategyMonth[count][month] = comfID_m[month]\n            elif StNames[count] == 'PassiveSolarHeating':\n                strategyMonth[count][month] = pshID_m[month]\n            elif StNames[count] == 'EvaporativeCooling':\n                strategyMonth[count][month] = ecID_m[month]\n            elif StNames[count] == 'HighTermalMass+NightVent':\n                strategyMonth[count][month] = htmID_m[month]\n            elif StNames[count] == 'NaturalVentilation':\n                strategyMonth[count][month] = nvID_m[month]\n            \n        \n    #Bring all set of lines and circles per month together in one list.\n    for item in geoMinMax:\n        allMinMax.append(item)\n    \n    #return allMinMax, strategyMonth, comfID_m, pshID_m, ecID_m, htmID_m, nvID_m\n    return allMinMax, strategyMonth, colByComfort, colByMonth\n\ndef monthForHour(hour):\n    for m in range(0, len(MonthNames)+1):\n        if int(hour) < ((MonthDays[m] * 24)):\n            hrCol = m\n            break\n    return hrCol\n\ndef seasonHours(period, totalHrs):\n    x = period.split(' ')\n\n    season = [[],[]]\n    season[0].append(int(x[0]) - 1) # Month\n    season[0].append(int(x[1]) - 1) # Day\n    season[0].append(int(x[2]) - 1) # Hour\n\n    season[1].append(int(x[3]) - 1) # Month\n    season[1].append(int(x[4]) - 1) # Day\n    season[1].append(int(x[5]) - 1) # Hour\n    \n    return season\n\ndef calcHourYear(season, i):\n    #    print 'in calcHourYear  ----- ----- ----- season is ', season[i]\n    JulDay = MonthDays[season[i][0]] + season[i][1]\n    HourYear = (JulDay) * 24 + season[i][2]\n    #    print '1. For month %d day %d hour %d Julian Day is %d HourYear is %d \\n' % (season[i][0], season[i][1], season[i][2], JulDay, HourYear)\n    return JulDay, HourYear\n\ndef assignHour2Season(start, end, totalHrs, iSeason, seasonID, dbtValue, rhValue):\n    #    seasonHrs = [[],[],[]]\n\n    if start > end:\n        hrs = totalHrs - start\n        numSeasHrs = hrs + end\n    else:\n        numSeasHrs = end - start\n    #    print 'St, End, totalHrs, numHrs, Season ', start, end, totalHrs, numSeasHrs, iSeason\n\n    ##############################\n    if start > end:\n        hrs = totalHrs - start\n        numSeasHrs = hrs + end\n        SeasHrs = range(start, totalHrs) + range(0, end + 1)\n    else:\n        numSeasHrs = end - start\n        SeasHrs = range(start, end + 1)\n    ##############################\n\n    ##for id in range(start, end):  #to iterate between start to end\n    for id, m in enumerate(SeasHrs):\n        #        print 'Serial id - Choosen Hour m ', id, m\n        seasonID[m] = iSeason\n        \n        #    return seasonHrs, seasonID\n    return seasonID\n\ndef setSeasonID(dryBulbTemperature, relativeHumidity, totalHrs):\n    #Define Model Tolerance\n    tol = sc.doc.ModelAbsoluteTolerance\n    \n    #Plot Point Values.\n    #******************\n    dbtValue = []\n    seasonID = [0 for x in range(totalHrs)] \n\n    for temp in dryBulbTemperature:\n        dbtValue.append(temp)\n    \n    rhValue = []\n    relativeHumidity = _relativeHumidity[7:]\n\n    for temp in relativeHumidity:\n        rhValue.append(temp)\n    \n    if analysisPeriodWinter_:\n        stMonth, stDay, stHour, endMonth, endDay, endHour = lb_preparation.readRunPeriod(analysisPeriodWinter_, False)\n        stringWinter = str(stMonth) + ' ' + str(stDay) + ' ' + str(stHour) + ' ' + str(endMonth) + ' ' + str(endDay) + ' ' + str(endHour)\n        periodWinter = stringWinter\n        \n        winterSeason = seasonHours(periodWinter, totalHrs)\n        \n        #        # Calling function to calculate Day of Year and Hour of Year for START-END period\n        JulDay1, hourWinterStart = calcHourYear(winterSeason, 0)\n        JulDay2, hourWinterEnd   = calcHourYear(winterSeason, 1)\n        #        seasonHrsWinter, seasonID = assignHour2Season(hourWinterStart, hourWinterEnd, totalHrs, 3, seasonID, dbtValue, rhValue)\n        seasonID = assignHour2Season(hourWinterStart, hourWinterEnd, totalHrs, 3, seasonID, dbtValue, rhValue)\n        ##        print 'Winter: Start %d End %d Total Hours %d \\n' % (hourWinterStart, hourWinterEnd, hourWinterEnd - hourWinterStart + 1)\n        #        print 'seasonHrsWinter ', seasonHrsWinter\n\n    if analysisPeriodSummer_:\n        stMonth, stDay, stHour, endMonth, endDay, endHour = lb_preparation.readRunPeriod(analysisPeriodSummer_, False)\n        stringSummer = str(stMonth) + ' ' + str(stDay) + ' ' + str(stHour) + ' ' + str(endMonth) + ' ' + str(endDay) + ' ' + str(endHour)\n        periodSummer = stringSummer\n        \n        summerSeason = seasonHours(periodSummer, totalHrs)\n\n        # Calling function to calculate Day of Year and Hour of Year for START-END period\n        JulDay1, hourSummerStart = calcHourYear(summerSeason, 0)\n        JulDay2, hourSummerEnd   = calcHourYear(summerSeason, 1)\n        #        seasonHrsSummer, seasonID = assignHour2Season(hourSummerStart, hourSummerEnd, totalHrs, 1, seasonID, dbtValue, rhValue)\n        seasonID = assignHour2Season(hourSummerStart, hourSummerEnd, totalHrs, 1, seasonID, dbtValue, rhValue)\n    ##        print 'Summer: Start %d End %d Total Hours %d \\n' % (hourSummerStart, hourSummerEnd, hourSummerEnd - hourSummerStart + 1)\n    #        print 'seasonHrsSummer ', seasonHrsSummer\n    \n    #    f = open(\"C:\\WorkingFolder\\Courses\\Rhino-Grasshopper-Diva\\PythonStuff\\BioclimaticChart\\dataTMP.csv\",\"wr\")\n    #    f.write('SeasonID,Temperature,RelativeHumidity\\n')\n    #    for m in range(0, totalHrs):\n    #        string = str(seasonID[m])+', '+str(dbtValue[m])+', '+str(rhValue[m])+','\n    #        f.write(string+'\\n')\n    #    f.close()\n             \n    #    print 'winterSeason ', winterSeason\n    #    print 'summerSeason ', summerSeason\n    ##    return seasonID, winterSeason, summerSeason\n    return seasonID\n\ndef createFrequencyMesh(orgY, dryBulbTemperature, relativeHumidity, cullMesh, lb_preparation, lb_visualization):\n    #Read Legend Parameters\n    if legendPar_ == None:\n        legendPar = [None, None, None, None, None, None, None, None]\n    else: legendPar = legendPar_\n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale,\\\n    legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    \n    hourPts = []\n    for count, ratio in enumerate(relativeHumidity):\n        hourPts.append(rc.Geometry.Point3d(dryBulbTemperature[count], relativeHumidity[count], 0))\n    \n    #Make a mesh.\n    gridSize = 5\n    joinedMesh = rc.Geometry.Mesh()\n    \n    meshPoints = []\n    for yVal in range(orgY, 100, gridSize):\n    #####for yVal in range(0, 100, gridSize):\n        for xVal in range(0, 100, gridSize):\n            point1 = rc.Geometry.Point3d(xVal, yVal, 0)\n            point2 = rc.Geometry.Point3d(xVal+gridSize, yVal, 0)\n            point3 = rc.Geometry.Point3d(xVal+gridSize, yVal+gridSize, 0)\n            point4 = rc.Geometry.Point3d(xVal, yVal+gridSize, 0)\n            meshPoints.append([point1, point2, point3, point4])\n    \n    for list in  meshPoints:\n        mesh = rc.Geometry.Mesh()\n        for point in list:\n            mesh.Vertices.Add(point)\n        \n        mesh.Faces.AddFace(0, 1, 2, 3)\n        joinedMesh.Append(mesh)\n    \n    polyCurveList = []\n    for list in  meshPoints:\n        pointList = [list[0], list[1], list[2], list[3],list[0]]\n        polyLine = rc.Geometry.PolylineCurve(pointList)\n        polyCurveList.append(polyLine)\n    \n    #Make a list to hold values for all of the mesh faces.\n    meshFrequency = []\n    for count, value in enumerate(range(orgY, 100, 5)):\n    ####for count, value in enumerate(range(0, 100, 5)):\n        meshFrequency.append([])\n        for face in range(0, 100, 5):\n            meshFrequency[count].append([])\n    \n    def getHumidityIndex(hour):\n        if   relativeHumidity[hour] < 5:  index = 0\n        elif relativeHumidity[hour] < 10: index = 1\n        elif relativeHumidity[hour] < 15: index = 2\n        elif relativeHumidity[hour] < 20: index = 3\n        elif relativeHumidity[hour] < 25: index = 4\n        elif relativeHumidity[hour] < 30: index = 5\n        elif relativeHumidity[hour] < 35: index = 6\n        elif relativeHumidity[hour] < 40: index = 7\n        elif relativeHumidity[hour] < 45: index = 8\n        elif relativeHumidity[hour] < 50: index = 9\n        elif relativeHumidity[hour] < 55: index = 10\n        elif relativeHumidity[hour] < 60: index = 11\n        elif relativeHumidity[hour] < 65: index = 12\n        elif relativeHumidity[hour] < 70: index = 13\n        elif relativeHumidity[hour] < 75: index = 14\n        elif relativeHumidity[hour] < 80: index = 15\n        elif relativeHumidity[hour] < 85: index = 16\n        elif relativeHumidity[hour] < 90: index = 17\n        elif relativeHumidity[hour] < 95: index = 18\n        else:                             index = 19\n        \n        return index\n    \n    addGridToIndex = abs(orgY/2)\n    module = gridSize/2\n    \n    for hour, temp in enumerate(dryBulbTemperature):\n        tempIndex = int((float(temp)+addGridToIndex) / module)\n        humIndex = getHumidityIndex(hour)\n        if tempIndex < 28:\n            meshFrequency[tempIndex][humIndex].append(1)\n        \n        \n    #Sum all of the lists together to get the frequency.\n    finalMeshFrequency = []\n    for templist in meshFrequency:\n        for humidlist in templist:\n            finalMeshFrequency.append(sum(humidlist))\n    \n    #Get a list of colors\n    colors = lb_visualization.gradientColor(finalMeshFrequency, lowB, highB, customColors)\n    \n    # color the mesh faces.\n    joinedMesh.VertexColors.CreateMonotoneMesh(System.Drawing.Color.Gray)\n    \n    for srfNum in range (joinedMesh.Faces.Count):\n        joinedMesh.VertexColors[4 * srfNum + 0] = colors[srfNum]\n        joinedMesh.VertexColors[4 * srfNum + 1] = colors[srfNum]\n        joinedMesh.VertexColors[4 * srfNum + 3] = colors[srfNum]\n        joinedMesh.VertexColors[4 * srfNum + 2] = colors[srfNum]\n    \n    # Remove the mesh faces that do not have any hour associated with them.\n    if cullMesh == True:\n        cullFaceIndices = []\n        for count, freq in enumerate(finalMeshFrequency):\n            if freq == 0:\n                cullFaceIndices.append(count)\n        joinedMesh.Faces.DeleteFaces(cullFaceIndices)\n    \n    #Return everything that's useful.\n    return hourPts, joinedMesh, finalMeshFrequency\n\ndef raggedListToDataTree(rl):\n    result = DataTree[System.Object]()\n    for i, leg in enumerate(rl):\n    #for i in range(len(rl)):\n        path = GH_Path(i)\n        temp = []\n        for j, leg in enumerate(rl[i]):\n            temp.append(rl[i][j])\n            #print 'J ', j, rl[i][j]\n        result.AddRange(temp, path)\n    return result\n\ndef checkComfortOrNot(strategyNames, totalHrs, comfID, pshID, ecID, htmID, nvID, epwData, epwStr):\n    totalComfortOrNot = []\n    comfHours = 0\n    for m in range(0, totalHrs):\n        if comfID[m] == 1 or pshID[m] == 1 or ecID[m] == 1 or htmID[m] == 1 or nvID[m] == 1:\n        #if comfID[m] == 1:\n        #if pshID[m] == 1:\n        #if ecID[m] == 1:\n        #if htmID[m] == 1:\n        #if nvID[m] == 1:\n            totalComfortOrNot.append(1)\n            comfHours += 1\n        else: totalComfortOrNot.append(0)\n    percComfTotal = comfHours / totalHrs * 100\n    ##print 'Comfortable Hours %d, which are %.2f%%' % (comfHours, percComfTotal)\n    #$#$comfortResults.append('CMF: ' + str(hrsCMF) + ' hours, ' + str(cmfPercent) + '%')\n    \n    totalComfortOrNot.insert(0, epwStr[6])\n    totalComfortOrNot.insert(0, epwStr[5])\n    totalComfortOrNot.insert(0, epwStr[4])\n    totalComfortOrNot.insert(0, \"Boolean Value\")\n    combString = '%.1f%% (%d hrs) Comfortable Hours in All Strategies,  ' % (percComfTotal, comfHours)\n    totalComfortOrNot.insert(0, combString)\n    totalComfortOrNot.insert(0, epwStr[1])\n    totalComfortOrNot.insert(0, epwStr[0])\n        \n    #Calculate wheather each strategy is in comfort or not for each hour. For output \"strategyOrNot\"        \n    #---------------------------------------------        \n    strategyOrNotList = []\n    comfHoursStrategy = []\n    percComfStrategy = []\n    for count, text in enumerate(strategyNames):\n        if   count == 0: stComf = list(comfID) # CZ\n        elif count == 1: stComf = list(pshID)  # PSH\n        elif count == 2: stComf = list(ecID)   # EC\n        elif count == 3: stComf = list(htmID)  # HTM\n        elif count == 4: stComf = list(nvID)   # NV\n        \n        comfHours = 0\n        strategyOrNotList.append([])\n        for m in range(0, totalHrs):\n            if stComf[m] == 1:\n                strategyOrNotList[count].append(1)\n                comfHours += 1\n            else: strategyOrNotList[count].append(0)\n        comfHoursStrategy.append(comfHours)\n        percComfStrategy.append(comfHoursStrategy[count] / totalHrs * 100)\n        \n        #print 'Comfortable Hours %d, which are %.2f%%' % (comfHoursStrategy[count], percComfStrategy[count])\n        strategyOrNotList[count].insert(0, epwStr[6])\n        strategyOrNotList[count].insert(0, epwStr[5])\n        strategyOrNotList[count].insert(0, epwStr[4])\n        strategyOrNotList[count].insert(0, \"Boolean Value\")\n        combString = '%.1f%% (%d hrs) Comfortable Hours in %s,  ' % (percComfStrategy[count], comfHoursStrategy[count], text)\n        strategyOrNotList[count].insert(0, combString)\n        strategyOrNotList[count].insert(0, epwStr[1])\n        strategyOrNotList[count].insert(0, epwStr[0])\n    #--------------------------------------------- \n    return totalComfortOrNot, strategyOrNotList\n# ****** END DEF *********************\n# ************************************\n\ndef main(epwData, epwStr):\n    if sc.sticky.has_key('ladybug_release'):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\n        \n        # Read the legend parameters.\n        lowB, highB, numSeg, customColors, legendBasePoint, legendScale, \\\n        legendFont, legendFontSize, legendBold, decimalPlaces, \\\n        removeLessThan= lb_preparation.readLegendParameters(legendPar_, False)\n        \n        if cullMesh_:\n            cullMesh = cullMesh_\n        else: \n            cullMesh = False\n        \n        # Fix MET and Clo factor for strategies position.\n        lowActivity = 3\n        highActivity = 4\n        defMet = 1.3\n        \n        winterClo = 2\n        SummerClo = 5\n        defClo = 0.8\n    \n        if basePoint_ != None:\n            basePoint = basePoint_\n            xP = 0.0 #basePoint_.X\n            yP = 0.0 #basePoint_.Y\n            zP = 0.0 #basePoint_.Z\n        else: \n            basePoint = rc.Geometry.Point3d(0,0,0)\n            xP, yP, zP = 0.0, 0.0, 0.0\n\n    \n        if metabolicRate_ :\n            metRate = metabolicRate_\n            if metabolicRate_ >= 2.0:\n                actShift = highActivity\n            else:\n                actShift = lowActivity\n            shiftFactorMet = (defMet - metRate) * actShift # Proof of concept. Need to fix later\n        else:\n            metRate_ = defMet\n            shiftFactorMet = 0\n    \n        if clothingLevel_:\n            cloLevel = clothingLevel_\n            shiftFactorClo = (defClo - clothingLevel_) * winterClo # Proof of concept. Need to fix later\n        else:\n            cloLevel_ = 0.8\n            shiftFactorClo = 0\n        \n        shiftFactor = shiftFactorMet + shiftFactorClo\n        #print 'shiftFactorMet %.2f, shiftFactorClo %.2f, shiftFactor %.2f' % (shiftFactorMet, shiftFactorClo, shiftFactor)\n        \n        #Define color palettes for outputs and legends.\n        monthColors, comfortNOcomfortColors, strategiesColors = colors()\n        \n        #Make chart curves.\n        \n        #Plot Point Values.\n        #******************\n        strategyNames = []\n        strategyNames.append('Comfort')\n        strategyNames.append('Passive Solar Heating')\n        strategyNames.append('Evaporative Cooling')\n        strategyNames.append('Thermal Mass + Night Vent')\n        strategyNames.append('Natural Ventilation')\n        \n        chartHourPoints = []\n        hourPointColorsByComfort = []\n        hourPointColorsByMonth = []\n        min_maxPoints = []\n        monthPoints = []\n        comfort_strategyPolygons = []\n        yPointValue = []\n        dbtValue = []\n        location = _dryBulbTemperature[1:2][0]\n        dryBulbTemperature = _dryBulbTemperature[7:]\n        totalHrs = len(dryBulbTemperature)\n        minTemp = 0.0\n        \n        for temp in dryBulbTemperature:\n            dbtValue.append(temp)\n            if temp < minTemp:\n                minTemp = temp\n                #print 'minTemp ', minTemp\n            yPointValue.append(temp*2 + yP)\n        gridSize = 5.0\n        addGrid = (int(math.ceil(abs(minTemp / gridSize))) * (-1) * gridSize) * 2 # This is for negative temperatures\n        #print 'minTemp %.1f addGrid %d' % (minTemp, addGrid)\n        \n        # Grid Lines *******************************\n        gridLines = []\n        orgX = int(0 + xP)\n        orgY = int(int(addGrid) + yP)\n        orgZ = int(0 + zP)\n        gridStep = 10\n        #print 'orgY ', orgY\n        \n        xLineValue = range(orgX, orgX + 110, gridStep)\n        yLineValue = range(orgY, 110, gridStep)\n        #starLine = rc.Geometry.Line(0, 0, 0, 0, 100, 0)\n        \n        for value in xLineValue:\n            gridLines.append(rc.Geometry.Line(value+xP, int(addGrid)+yP, 0+zP, value+xP, 100+yP, 0+zP))\n            \n        for value in yLineValue: # Left to right lines\n            gridLines.append(rc.Geometry.Line(0+xP, value+yP, 0+zP, 100+xP, value+yP, 0+zP))\n        # End Grid Lines ****************************\n        # Print Title and legends in grid: X/Y axis ****************************\n\n        chartLayout = createChartLayout(orgX, orgY, orgZ, location, legendFont, legendFontSize, legendBold)\n        \n        xPointValue = []\n        rhValue = []\n        relativeHumidity = _relativeHumidity[7:]\n        for temp in relativeHumidity:\n            rhValue.append(temp)\n            xPointValue.append(temp + xP)\n    \n        #stringSummer, stringWinter, seasonID = setSeasonID(dryBulbTemperature, relativeHumidity, totalHrs)\n        seasonID = setSeasonID(dryBulbTemperature, relativeHumidity, totalHrs)\n        # print 'SeasonID ', seasonID # Winter = 3, Summer = 1\n    \n        hourPoints = []\n        hourPointsCirc = []\n        ##hourColor = []\n        \n        colPnt1  = []\n        colPnt2  = []\n        colPnt3  = []\n        colPnt4  = []\n        colPnt5  = []\n        colPnt6  = []\n        colPnt7  = []\n        colPnt8  = []\n        colPnt9  = []\n        colPnt10 = []\n        colPnt11 = []\n        colPnt12 = []\n        \n        dataRadius = 0.4\n        nVert = 4\n        \n        #    for count, xVal in enumerate(xPointValue):\n        #        centerPt = rc.Geometry.Point3d(xVal+xP, yPointValue[count]+yP, 0+zP)\n        for hour in range(0, totalHrs):\n        ##for hour in range(0, totalHrs - 1):\n            # Colors according to Season\n            if seasonID[hour] == 3:    # Winter\n                colorP = [50, 50, 255]\n            elif seasonID[hour] == 1:    # Summer\n                colorP = [255, 255, 50]\n                \n            centerPt = rc.Geometry.Point3d(xPointValue[hour], yPointValue[hour]+yP, 0+zP)\n            hourPoints.append(rc.Geometry.Point3d(centerPt))\n            hourPointsCirc = rc.Geometry.Circle(centerPt, 0.25)\n            \n            # Colors according to Month\n            col = monthForHour(hour)\n            ##hourColor.append(col)   # Here you get the month that the hour belongs to\n            \n            if   col == 0:  colPnt1.append(hourPointsCirc)\n            elif col == 1:  colPnt2.append(hourPointsCirc)\n            elif col == 2:  colPnt3.append(hourPointsCirc)\n            elif col == 3:  colPnt4.append(hourPointsCirc)\n            elif col == 4:  colPnt5.append(hourPointsCirc)\n            elif col == 5:  colPnt6.append(hourPointsCirc)\n            elif col == 6:  colPnt7.append(hourPointsCirc)\n            elif col == 7:  colPnt8.append(hourPointsCirc)\n            elif col == 8:  colPnt9.append(hourPointsCirc)\n            elif col == 9:  colPnt10.append(hourPointsCirc)\n            elif col == 10: colPnt11.append(hourPointsCirc)\n            elif col == 11: colPnt12.append(hourPointsCirc)\n            \n        # Collect points according to MONTH\n        monthPoints.append(colPnt1)\n        monthPoints.append(colPnt2)\n        monthPoints.append(colPnt3)\n        monthPoints.append(colPnt4)\n        monthPoints.append(colPnt5)\n        monthPoints.append(colPnt6)\n        monthPoints.append(colPnt7)\n        monthPoints.append(colPnt8)\n        monthPoints.append(colPnt9)\n        monthPoints.append(colPnt10)\n        monthPoints.append(colPnt11)\n        monthPoints.append(colPnt12)\n        \n        hourPts, chartMesh, meshFaceValues = createFrequencyMesh(orgY, dryBulbTemperature, relativeHumidity, cullMesh, lb_preparation, lb_visualization)\n        \n        # Legend for Mesh of Colors from FrequencyMesh routine\n        if legendBasePoint == None:\n            ####legendBasePoint = lb_visualization.BoundingBoxPar[0]\n            #legendBasePoint = (rc.Geometry.Point3d(lb_visualization.BoundingBoxPar[0], lb_visualization.BoundingBoxPar[1], 0))\n            legendBasePoint = rc.Geometry.Point3d(orgX + 101, orgY, 0)\n\n        legendChartMesh = []\n        legendTitle = \"Hours\"\n        legendScale = .6 \n        #legendFontSize = 2\n        #lb_visualization.calculateBB(chartText, True)\n        lb_visualization.calculateBB(chartLayout[0:90], True) \n\n        legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(meshFaceValues, lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n        ##legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n        legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\n        legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n        legendChartMesh.append(legendSrfs)\n        for list in legendTextCrv:\n            for item in list:\n                legendChartMesh.append(item)\n\n        legendBasePoint = rc.Geometry.Point3d(orgX + 105, orgY, 0)\n\n        mainLegHeight = ((lb_visualization.BoundingBoxPar[2] / 10) * legendScale) * numSeg\n            \n        # ***********\n        #   List of Comfort Coordinates **************************\n        cf_Ptlist = [27.02+xP, 42.12+yP,0.0+zP],[18.27+xP,52.64+yP,0.0+zP], [64.03+xP,45.77+yP,0.0+zP],[80.00+xP,40.78+yP,0.0+zP],\\\n        [27.02+xP, 42.12+yP,0.0+zP]\n        \n        hrsCMF, cmfPercent, comfID, comfortPolygon, comfortPolyline = strategyDraw_Calc('COMF', shiftFactor, cf_Ptlist, hourPoints, tol, dryBulbTemperature, totalHrs, 30,30,30)\n        ##print 'Comf hours %d, Comf Percentage %.2f' % (hrsCMF, cmfPercent)\n        \n        # List of Passive Solar Heating Coordinates **************************\n        pshPtList = [1.07+xP,11.83+yP,0.00+zP],[1.07+xP,42.82+yP,0.00+zP],[98.97+xP,40.44+yP,0.00+zP],[98.97+xP,9.61+yP,0.00+zP], \\\n        [1.07+xP,11.83+yP,0.00+zP]\n    \n        hrsPSH, pshPercent, pshID, pshPolygon, pshPolyline = strategyDraw_Calc('PSH', shiftFactor, pshPtList, hourPoints, tol, dryBulbTemperature, totalHrs, 200, 200, 20)\n        \n        ##print 'PSH hours %d, PSH Percentage %.2f' % (hrsPSH, pshPercent)\n        \n        #List of Evaporative Cooling Coordinates **************************\n        ec_Ptlist = [16.62+xP,42.42+yP,0.0+zP],[1.07+xP,57.79+yP,0.0+zP], [1.07+xP,82.21+yP,0.0+zP],[11.18+xP,82.21+yP,0.0+zP],\\\n        [80.0+xP,45.79+yP,0.0+zP],[80.0+xP,40.78+yP,0.0+zP],[64.03+xP,45.77+yP,0.0+zP],[18.27+xP,52.64+yP,0.0+zP],\\\n        [27.02+xP,42.12+yP,0.0+zP], [16.62+xP,42.42+yP,0.0+zP]\n    \n        hrsEC, ecPercent, ecID, ecPolygon, ecPolyline = strategyDraw_Calc('EC', shiftFactor, ec_Ptlist, hourPoints, tol, dryBulbTemperature, totalHrs, 20, 220, 20)\n        ##print 'EC hours %d, EC Percentage %.2f' % (hrsEC, ecPercent)\n    \n        #List of High Termal Mass **************************\n        htmPtlist = [19.80+xP,42.35+yP,0.0+zP],[7.86+xP,71.28+yP,0.0+zP],[30.08+xP,71.28+yP,0.0+zP],[46.95+xP,66.03+yP,0.0+zP],\\\n        [80.0+xP,49.12+yP,0.0+zP],[80.0+xP,40.78+yP,0.0+zP],[64.03+xP,45.77+yP,0.0+zP],[18.27+xP,52.64+yP,0.0+zP],\\\n        [27.02+xP,42.12+yP,0.0+zP],[19.80+xP,42.35+yP,0.0+zP]\n    \n        hrsHTM, htmPercent, htmID, htmPolygon, htmPolyline = strategyDraw_Calc('HTM', shiftFactor, htmPtlist, hourPoints, tol, dryBulbTemperature, totalHrs, 180, 50, 50)\n        ##print 'HTM hours %d, HTM Percentage %.2f' % (hrsHTM, htmPercent)\n    \n        #List of Natural Ventilation **************************\n        nvPtlist = [18.27+xP,52.64+yP,0.0+zP],[18.08+xP,62.56+yP,0.0+zP],[45.56+xP,62.56+yP,0.0+zP],[97.91+xP,53.79+yP,0.0+zP],\\\n        [97.91+xP,40.47+yP,0.+zP], [80.0+xP,40.78+yP,0.0+zP],[64.03+xP,45.77+yP,0.0+zP],[18.27+xP,52.64+yP,0.0+zP]\n    \n        hrsNV, nvPercent, nvID, nvPolygon, nvPolyline  = strategyDraw_Calc('NV', shiftFactor, nvPtlist, hourPoints, tol, dryBulbTemperature, totalHrs, 50, 50, 180)\n        ##print 'NV hours %d, NV Percentage %.2f' % (hrsNV, nvPercent)\n    \n        # Collect all strategies and results\n        ##comfort_strategyPolygons.append(comfortPolygon)\n        ##comfort_strategyPolygons.append(pshPolygon)\n        ##comfort_strategyPolygons.append(ecPolygon)\n        ##comfort_strategyPolygons.append(htmPolygon)\n        ##comfort_strategyPolygons.append(nvPolygon)\n        \n        #This block draws the polygons with the same color. The block below this draws the strategies colored\n        #If wanted, uncomment this block and comment the block below\n        ###comfort_strategyPolygons.append(comfortPolyline)\n        ###comfort_strategyPolygons.append(pshPolyline)\n        ###comfort_strategyPolygons.append(ecPolyline)\n        ###comfort_strategyPolygons.append(htmPolyline)\n        ###comfort_strategyPolygons.append(nvPolyline)\n        \n        comfortMesh = rc.Geometry.Mesh()\n        comfortMesh.Append(rc.Geometry.Mesh.CreateFromBrep(comfortPolyline)[0])\n        comfortMesh.VertexColors.CreateMonotoneMesh(strategiesColors[0])\n        comfort_strategyPolygons.append(comfortMesh)\n        \n        pshMesh = rc.Geometry.Mesh()\n        pshMesh.Append(rc.Geometry.Mesh.CreateFromBrep(pshPolyline)[0])\n        pshMesh.VertexColors.CreateMonotoneMesh(strategiesColors[1])\n        comfort_strategyPolygons.append(pshMesh)\n        \n        ecMesh = rc.Geometry.Mesh()\n        ecMesh.Append(rc.Geometry.Mesh.CreateFromBrep(ecPolyline)[0])\n        ecMesh.VertexColors.CreateMonotoneMesh(strategiesColors[2])\n        comfort_strategyPolygons.append(ecMesh)\n        \n        htmMesh = rc.Geometry.Mesh()\n        htmMesh.Append(rc.Geometry.Mesh.CreateFromBrep(htmPolyline)[0])\n        htmMesh.VertexColors.CreateMonotoneMesh(strategiesColors[3])\n        comfort_strategyPolygons.append(htmMesh)\n        \n        nvMesh = rc.Geometry.Mesh()\n        nvMesh.Append(rc.Geometry.Mesh.CreateFromBrep(nvPolyline)[0])\n        nvMesh.VertexColors.CreateMonotoneMesh(strategiesColors[4])\n        comfort_strategyPolygons.append(nvMesh)\n\n\n        #for count, value in enumerat(evapCooling):\n        #    if comfortList[count] == 1:\n        #        value = 0\n        #    else: pass\n        \n        comfortResults = []\n        comfortResults.append('CMF: ' + str(hrsCMF) + ' hours, ' + str(cmfPercent) + '%')\n        comfortResults.append('PSH: ' + str(hrsPSH) + ' hours, ' + str(pshPercent) + '%')\n        comfortResults.append('EC:  ' + str(hrsEC)  + ' hours, ' + str(ecPercent)  + '%')\n        comfortResults.append('HTM: ' + str(hrsHTM) + ' hours, ' + str(htmPercent) + '%')\n        comfortResults.append('NV:  ' + str(hrsNV)  + ' hours, ' + str(nvPercent)  + '%')\n        \n        strategyPercent = []\n        strategyPercent.append(cmfPercent)\n        strategyPercent.append(pshPercent)\n        strategyPercent.append(ecPercent)\n        strategyPercent.append(htmPercent)\n        strategyPercent.append(nvPercent)\n        \n        strategyHours = []\n        strategyHours.append(hrsCMF)\n        strategyHours.append(hrsPSH)\n        strategyHours.append(hrsEC)\n        strategyHours.append(hrsHTM)\n        strategyHours.append(hrsNV)\n        \n        min_maxPointsList, strategyMonth, colByComfortList, colByMonthList = monthCalcs(totalHrs, comfID, pshID, ecID, htmID, nvID, dryBulbTemperature, relativeHumidity, monthPoints, monthColors, comfortNOcomfortColors)\n        \n        #f = open(\"C:\\WorkingFolder\\Courses\\Rhino-Grasshopper-Diva\\PythonStuff\\BioclimaticChart\\dataTMP.csv\",\"wr\")\n        #f.write('SeasonID,Temperature,RelativeHumidity, Comfort, PSH, EC, HTM, NV\\n')\n        #for m in range(0, totalHrs):\n        #    string = str(seasonID[m])+', '+str(dbtValue[m])+', '+str(rhValue[m])+', '+str(comfID[m])+', '+str(pshID[m])+', '+str(ecID[m])+', '+str(htmID[m])+', '+str(nvID[m])+','\n        #    f.write(string+'\\n')\n        #f.close()\n        \n        totalComfortOrNot, strategyOrNotList = checkComfortOrNot(strategyNames, totalHrs, comfID, pshID, ecID, htmID, nvID, epwData, epwStr)\n        \n        chartLegend = createChartLegend(orgX, orgY, orgZ, strategyNames, lb_preparation, legendScale, legendFont, legendFontSize, legendBold, lb_visualization, strategiesColors, monthColors, comfortNOcomfortColors, customColors, totalComfortOrNot)\n        \n        if calculateCharts_ == True:\n            resultsChart = showResults(basePoint_, mainLegHeight, strategyNames, strategyPercent, strategyHours, strategyMonth, \\\n            lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, lb_preparation, lb_visualization, strategiesColors)\n        else:\n            resultsChart = None\n             \n        #If the user has selected to scale or move the geometry, scale it all and/or move it all.\n        #if basePoint_ != None:\n            #basePoint = basePoint_\n        #else: basePoint = rc.Geometry.Point3d(0,0,0)\n        \n        if scale_ != None:\n            scale = scale_\n        else: scale = 1\n        \n        chartGridAndTxt = []\n        for item in gridLines: chartGridAndTxt.append(item)\n        for item in chartLayout: chartGridAndTxt.append(item) \n        for item in chartLegend: chartGridAndTxt.append(item) \n        \n        scaleFinal = rc.Geometry.Transform.Scale(basePoint, scale)\n        move = rc.Geometry.Transform.Translation(basePoint.X, basePoint.Y, basePoint.Z)\n        transformMtx = scaleFinal * move\n        for geo in comfort_strategyPolygons: geo.Transform(transformMtx)\n        chartMesh.Transform(transformMtx)\n        for geo in chartLayout: geo.Transform(transformMtx)\n        for geo in chartLegend: geo.Transform(transformMtx)\n        for geo in legendChartMesh: geo.Transform(transformMtx)\n        legendBasePoint.Transform(transformMtx)\n        for geo in gridLines: geo.Transform(transformMtx)\n        for geoList in monthPoints:\n            for geo in geoList:\n                geo.Transform(transformMtx)\n        for geoList in min_maxPointsList: \n            for geo in geoList:\n                geo.Transform(transformMtx)\n        if calculateCharts_ == True:\n            for geo in resultsChart: geo.Transform(transformMtx)\n        \n        #hourPointColorsByComfort = []\n        #hourPointColorsByMonth = []\n        \n        #Unpack the data tree of point colors. THIS WORKS FINE BUT I LEFT THE BELOW's OPTION.\n        #hourPointColorsByComfort = DataTree[Object]()\n        #for listCount, list in enumerate(colByComfortList):\n        #    for item in list:\n        #        hourPointColorsByComfort.Add(item, GH_Path(listCount))\n        \n        #print 'monthPoints ', len(monthPoints[0])\n        chartHourPoints          = raggedListToDataTree(monthPoints)\n        hourPointColorsByComfort = raggedListToDataTree(colByComfortList)\n        hourPointColorsByMonth   = raggedListToDataTree(colByMonthList)\n        \n        strategyOrNot = raggedListToDataTree(strategyOrNotList)\n        \n        ##monthPointsTree = raggedListToDataTree(monthPoints)\n        min_maxPoints            = raggedListToDataTree(min_maxPointsList)\n        \n        return comfortResults, totalComfortOrNot, strategyOrNot, \\\n        chartGridAndTxt, chartMesh, legendChartMesh, chartHourPoints, hourPointColorsByComfort, hourPointColorsByMonth, min_maxPoints, \\\n        comfort_strategyPolygons, legendComfortStrategies, legendBasePt, resultsChart\n        \n    else:\n        print \"You should first let the Ladybug fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n        return -1\n\n\n#Check the inputs.\ncheckData = False\nif _runIt == True:\n    checkData, epwData, epwStr = checkInputs()\n\n#If the inputs are good, run the function.\nif checkData == True:\n    comfortResults, totalComfortOrNot, strategyOrNot, \\\n    chartGridAndTxt, chartMesh, legendChartMesh, chartHourPoints, hourPointColorsByComfort, hourPointColorsByMonth, min_maxPoints, \\\n    comfort_strategyPolygons, legendComfortStrategies, legendBasePt, resultsChart = main(epwData, epwStr)\n    \n    \n#Hide/Show outnputs\nghenv.Component.Params.Output[6].Hidden  = False # Grid and Text\nghenv.Component.Params.Output[7].Hidden  = True  # Chart Mesh\nghenv.Component.Params.Output[8].Hidden  = True  # legendChartMesh\nghenv.Component.Params.Output[9].Hidden  = True  # chartHourPoints\n#ghenv.Component.Params.Output[10].Hidden  = True  # hourPointColorsByComfort - This is data\n#ghenv.Component.Params.Output[11].Hidden  = True  # hourPointColorsByMonth - This is data\nghenv.Component.Params.Output[12].Hidden = True  # min/max Points\nghenv.Component.Params.Output[13].Hidden = False # StrategyPolygons\nghenv.Component.Params.Output[14].Hidden = True  # legend\nghenv.Component.Params.Output[17].Hidden = True  # Results Chart\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}