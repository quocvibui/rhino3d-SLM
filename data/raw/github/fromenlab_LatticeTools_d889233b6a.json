{
  "source_url": "https://github.com/fromenlab/LatticeTools/blob/4ed52adaf55fdab72c4b6c9566f011a3bdc9f8d3/lattice/populate.py",
  "repo": "fromenlab/LatticeTools",
  "repo_stars": 1,
  "repo_description": "Components for generating lattice structures in Rhino®/Grasshopper®",
  "license": "NOASSERTION",
  "filepath": "lattice/populate.py",
  "instruction": "Populate",
  "code": "from ghpythonlib.componentbase import dotnetcompiledcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as ghcomp\nimport ghpythonlib.parallel\nimport ghpythonlib.treehelpers as th\n\ndef get_bounding_box(unit_cell):\n        precise_box = False\n        unit_cell_bounds = unit_cell[0].GetBoundingBox(precise_box)\n        for line in unit_cell:\n            box = line.GetBoundingBox(precise_box)\n            unit_cell_bounds = Rhino.Geometry.BoundingBox.Union(unit_cell_bounds, box)\n        return unit_cell_bounds\n\ndef check_inclusion(lattice_curve, mesh):\n    lattice_curve.Domain = Rhino.Geometry.Interval(0,1)\n    midpoint = lattice_curve.PointAt(0.5)\n    keep = mesh.IsPointInside(midpoint, 0.001, True)\n    return keep\n\ndef check_curve_parallel(curve):\n    curve = Rhino.Geometry.Curve.TryGetPolyline(curve)[1]\n    curve = Rhino.Geometry.PolylineCurve(curve)\n    intersection_points = Rhino.Geometry.Intersect.Intersection.MeshPolyline(primitive_global, curve)[0]\n    if intersection_points:\n        curve_params = []\n        for point in intersection_points:\n            curve_params.append(curve.ClosestPoint(point)[1])\n        split_curve = curve.Split(curve_params)\n        for section in split_curve:\n            if (check_inclusion(section, primitive_global)):\n                lattice_trimmed.append(section)\n    else:\n        if (check_inclusion(curve, primitive_global)):\n            lattice_trimmed.append(curve)\n\ndef populate_lattice_parallel(voxels):\n    lattice_structure = []\n    for curve in unit_cell_global:\n        mapped = ghcomp.BoxMapping(curve, unit_cell_bounds, voxels)[0]\n        lattice_structure.append(mapped)\n    return lattice_structure\n\ndef populate_connectivity_parallel(voxels):\n    connect = ghcomp.BoxMapping(connectivity_global, unit_cell_bounds, voxels)[0]\n    return connect\n\ndef populate_skin_parallel(voxels):\n    connect = ghcomp.BoxMapping(connectivity_global, unit_cell_bounds, voxels)[0]\n    # curves = Rhino.Geometry.Intersect.Intersection.MeshMeshAccurate(connect, primitive,  Rhino.RhinoMath.SqrtEpsilon*10)\n    curves = ghcomp.MeshXMesh(primitive_global, connect)\n    return curves\n\n\nclass UniformLattice(component):\n    def __new__(cls):\n        instance = Grasshopper.Kernel.GH_Component.__new__(cls,\n            \"Populate - Lattice (Uniform)\", \"UniformLattice\", \"\"\"Population for a uniform strut lattice\"\"\", \"LatticeTools\", \"Lattice\")\n        return instance\n    \n    def get_ComponentGuid(self):\n        return System.Guid(\"a9dc427c-2a24-4b06-82f9-19d7fd58c75e\")\n    \n    def SetUpParam(self, p, name, nickname, description):\n        p.Name = name\n        p.NickName = nickname\n        p.Description = description\n        p.Optional = True\n    \n    def RegisterInputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"core_voxels\", \"core_voxels\", \"Voxels to populate with unit cell only\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"boundary_voxels\", \"boundary_voxels\", \"Voxels to populate with unit cell and get connectivity\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_Curve()\n        self.SetUpParam(p, \"unit_cell\", \"unit_cell\", \"Lines and curves making up the repeat unit\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.list\n        self.Params.Input.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"connectivity\", \"connectivity\", \"Unit cell connectivity\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"primitive\", \"primitive\", \"Trimming boundary\")\n        p.Access = Grasshopper.Kernel.GH_ParamAccess.item\n        self.Params.Input.Add(p)\n        \n    \n    def RegisterOutputParams(self, pManager):\n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"lattice_core\", \"lattice_core\", \"Core voxels populated with unit cells\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"lattice_boundary\", \"lattice_boundary\", \"Boundary voxels populated with unit cells\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"lattice_trimmed\", \"lattice_trimmed\", \"Trimmed lattice within primitive\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"lattice_boundary_connect\", \"lattice_boundary_connect\", \"Boundary voxels populated with connectivity\")\n        self.Params.Output.Add(p)\n        \n        p = Grasshopper.Kernel.Parameters.Param_GenericObject()\n        self.SetUpParam(p, \"lattice_skin\", \"lattice_skin\", \"Net skin of the lattice\")\n        self.Params.Output.Add(p)\n        \n    \n    def SolveInstance(self, DA):\n        p0 = self.marshal.GetInput(DA, 0)\n        p1 = self.marshal.GetInput(DA, 1)\n        p2 = self.marshal.GetInput(DA, 2)\n        p3 = self.marshal.GetInput(DA, 3)\n        p4 = self.marshal.GetInput(DA, 4)\n        result = self.RunScript(p0, p1, p2, p3, p4)\n\n        if result is not None:\n            if not hasattr(result, '__getitem__'):\n                self.marshal.SetOutput(result, DA, 0, True)\n            else:\n                self.marshal.SetOutput(result[0], DA, 0, True)\n                self.marshal.SetOutput(result[1], DA, 1, True)\n                self.marshal.SetOutput(result[2], DA, 2, True)\n                self.marshal.SetOutput(result[3], DA, 3, True)\n                self.marshal.SetOutput(result[4], DA, 4, True)\n        \n    def get_Internal_Icon_24x24(self):\n        o = \"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY/l8WUAAAS8SURBVEhLrVX7T5NnFC4ttNAbIDTQVsootKW0pdgrLQOj7GoGWUQuNSgjblUh4ChbpHKpCIzFwYhu3DYXEoXpfgDkoqKOYNwfsMtvS7ZFh2QK49KPQgRa2DmldB1BRtie5Eme933OOe/3vVfSDkAFpgPNfgG0Rr+AoPOgDwEjgP8JPHqk8JvI5LcdoqO1E+qzN54l1z9wIlFLTBfGIwyHp5h8aTPEBq6n7BQUyiu81DxCX//tSsrH360ZPxpzxeXZiATzZw75e5fnRabaP5MbHjrRwxh+Wv5TSMr0ZG8LMlOgaJaZW1c0Nbec+uo7S9rKPgcjUjwIXqI4zzYnOWqbAy1j8EU3tdab83rb8LKucsglN19aDeKJe8Dzw0JbIogn6tbXjriUZVeXecbcFWPDmCskVncfLEzi+AzAwT70MIb38hFXUkmXS2+7s8p8SdEE3lbw1ynMbc8TS7pWWNGyFV3NkEOYWeZiRivusWOUA0yBfCSh4BMi4Z1mAjX2Qdx9YWa5U1MzvMiKlq9hrvxUmwMmIt9T1As//oGC33BO/w9yDVlOqIl/uY4QkbYkufbearji4EQAY8+w4nTrtDinyk4LiWjZIDU4vF1iqrPHH2uwU4M5Hb5eXNa5RdnJz2f8GXsGw5Xp41gL/qjOUx72Y2rOr6qzvXaQ7wOLNFWDBPQ9cpt/I2zTGniBsVpr3wJIC/BMUvk1J9d4+A/Q7gUnS0y2JzEZJU9ACyiBrE5j48O1UImxH00fvHCAUKmhF3MoQewuaEYL0k84xbnVk6CN6EepLF/PcFSv4QBRrFj1D8b6sVUKjXER2mKgEPuBUp8BpEAcxE1yILMCc9hxmp+wzdn36rjS0o0zkk+i0FmHkuvGnLLCpnlMTizuIAx1o8uoN1Nt7bOrrf32rTzYrkuYi1r2bguB25dMYxWSyLSgYvcAJz4l8AvlRZ2zGIx6M9UVvTBAn30rzwA5yuKvpkU5lc/jC5oWoA0D0AvhL0gH1OXXJzlJbzwGHcYSqr7H3/Wns89h24ciLIRfCFri621MEStO8yO0+ThFSR/emALtPg/02OzKqei3Sn8HHbOrRYZY9yIHsr6ApiA6o3Tcs8h73QE8o3eblgFP45bjp5nwj3yxzTbNe4xbG2QR8IzG2jsXmZb3s9tEMLjiDv2FUWd44sEJf0bogOxk2yzM5SKVzblCDeF0UoMj2lB7Dxqb8yUtOPLSBmNzqwj5qfbJAGbYbTysWIsdo8Ap9kLATTNNb3Xsd0P+ftMzqInr4wvKm/Dli+7LTiBf01YNz+NFxhRI77IEin5mlOy29PhFIqGgiUDt7gNPmGFx4sXIipIvKUqvOLEG1HrdU/SfYEbFX9bZ7jqTLD0LeAXjQxMSpxkFiwzcfF2T0cMYvNpVH1x3YC5TkNAC3gtBgTehRwZXrrZ6eMX9mFTdmmXwxUPgKX0GkOMjpLUOzOtsI4sYl1jUTsATOwAefsy/wd+wd//xR94ns/GBS2Q6T+BzqTC3zovg+cQ+9HBBuSm5MCjliCd5x6DAo1LJTc3+JTbHOq0quzaDJx65z9I9K8qumOUas54GceOuQmzoesruQQFKyYH0Y2QarQR0CpCNxvYgkf4CQTF57xDRx98AAAAASUVORK5CYII=\"\n        return System.Drawing.Bitmap(System.IO.MemoryStream(System.Convert.FromBase64String(o)))\n\n    def RunScript(self, core_voxels, boundary_voxels, unit_cell, connectivity, primitive):\n        global unit_cell_bounds\n        global unit_cell_global\n        global connectivity_global\n        global primitive_global\n        global lattice_trimmed\n\n        unit_cell_global = unit_cell\n        connectivity_global = connectivity\n        primitive_global = primitive\n        unit_cell_bounds = get_bounding_box(unit_cell)\n        unit_cell = Rhino.Geometry.Curve.JoinCurves(unit_cell)\n        if core_voxels:\n            lattice_core = ghpythonlib.parallel.run(populate_lattice_parallel, core_voxels, True)\n        else:\n            lattice_core = []\n        if boundary_voxels:\n            lattice_boundary = ghpythonlib.parallel.run(populate_lattice_parallel, boundary_voxels, True)\n            lattice_boundary_connect = ghpythonlib.parallel.run(populate_connectivity_parallel, boundary_voxels, True)\n            lattice_skin = ghpythonlib.parallel.run(populate_skin_parallel, boundary_voxels, True)\n        else:\n            lattice_boundary = []\n            lattice_boundary_connect = []\n            lattice_skin = []\n\n        lattice_trimmed = []\n        lattice_combined = list(lattice_core) + list(lattice_boundary)\n        valid_curves = list(filter(None, lattice_combined))\n        ghpythonlib.parallel.run(check_curve_parallel, valid_curves, False)\n\n        return lattice_core, lattice_boundary, lattice_trimmed, lattice_boundary_connect, lattice_skin",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}