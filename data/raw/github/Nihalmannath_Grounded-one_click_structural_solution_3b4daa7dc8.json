{
  "source_url": "https://github.com/Nihalmannath/Grounded-one_click_structural_solution/blob/94373d5c3a0ea210040d9de1195b23acb6fba0c2/Experiments/2/TERM%203/20250519_TERM%203_RHINO_GLB_JSON/src/integrated_workflow.py",
  "repo": "Nihalmannath/Grounded-one_click_structural_solution",
  "repo_stars": 0,
  "repo_description": "Research studio/term_2",
  "license": "unknown",
  "filepath": "Experiments/2/TERM 3/20250519_TERM 3_RHINO_GLB_JSON/src/integrated_workflow.py",
  "instruction": "Integrated Workflow for 3D Structural Analysis\n---------------------------------------------\nThis script combines the functionality of:\n1. Rhino_to_mesh.py - Converting Rhino 3DM models to OBJ...",
  "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nIntegrated Workflow for 3D Structural Analysis\n---------------------------------------------\nThis script combines the functionality of:\n1. Rhino_to_mesh.py - Converting Rhino 3DM models to OBJ meshes\n2. obj_combiner.py - Managing and combining OBJ mesh layers\n3. structural_grid.py - Generating and visualizing structural grids\n\nAuthor: GitHub Copilot\nDate: April 27, 2025\n\"\"\"\n\nimport os\nimport sys\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox, ttk, simpledialog\nimport numpy as np\nimport glob\nfrom pathlib import Path\n\n# Try to import dependencies\ntry:\n    import rhino3dm\n    HAS_RHINO3DM = True\nexcept ImportError:\n    HAS_RHINO3DM = False\n    print(\"Warning: rhino3dm module not found. 3DM import functionality will be disabled.\")\n\ntry:\n    import trimesh\n    import pyvista as pv\n    HAS_VISUALIZATION = True\nexcept ImportError:\n    HAS_VISUALIZATION = False\n    print(\"Warning: trimesh or pyvista modules not found. Visualization functionality will be limited.\")\n\n# Import local modules\ntry:\n    from obj_combiner import ObjCombiner\n    HAS_OBJ_COMBINER = True\nexcept ImportError:\n    HAS_OBJ_COMBINER = False\n    print(\"Warning: obj_combiner.py not found in the current directory.\")\n\ntry:\n    from structural_grid import StructuralGridGenerator\n    HAS_STRUCTURAL_GRID = True\nexcept ImportError:\n    HAS_STRUCTURAL_GRID = False\n    print(\"Warning: structural_grid.py not found in the current directory.\")\n\n\nclass RhinoMeshConverter:\n    \"\"\"Handles the conversion of Rhino 3DM files to OBJ meshes.\"\"\"\n    \n    def __init__(self):\n        if not HAS_RHINO3DM:\n            raise ImportError(\"rhino3dm module is required for 3DM conversion\")\n        \n        self.model = None\n        self.output_dir = None\n        self.layer_objs = []  # Stores paths to generated OBJs\n    \n    def load_3dm(self, file_path):\n        \"\"\"Load a Rhino 3DM file.\"\"\"\n        try:\n            self.model = rhino3dm.File3dm.Read(file_path)\n            print(f\"Loaded 3DM file with {len(self.model.Objects)} objects across {len(self.model.Layers)} layers\")\n            return True\n        except Exception as e:\n            print(f\"Error loading 3DM file: {str(e)}\")\n            return False\n    \n    def mesh_brep(self, brep, mesh_type=rhino3dm.MeshType.Default):\n        \"\"\"Mesh a Brep object from Rhino.\"\"\"\n        meshes = []\n        for face in brep.Faces:\n            try:\n                m = face.GetMesh(mesh_type)\n            except Exception:\n                continue\n            if m:\n                meshes.append(m)\n        return meshes\n    \n    def export_layers_to_obj(self, output_dir=None):\n        \"\"\"Export each layer from the 3DM file to separate OBJ files.\"\"\"\n        if self.model is None:\n            print(\"No 3DM model loaded!\")\n            return False\n        \n        # Set output directory\n        self.output_dir = output_dir or './input model/meshed_layers_obj'\n        os.makedirs(self.output_dir, exist_ok=True)\n        self.layer_objs = []\n        \n        # Process each layer\n        for lyr in self.model.Layers:\n            meshes = []\n            for obj in self.model.Objects:\n                if obj.Attributes.LayerIndex != lyr.Index:\n                    continue\n                geom = obj.Geometry\n                if isinstance(geom, rhino3dm.Mesh):\n                    meshes.append(geom)\n                elif isinstance(geom, rhino3dm.Brep):\n                    meshes.extend(self.mesh_brep(geom))\n            \n            print(f\"Layer [{lyr.Index}] '{lyr.Name}' -> {len(meshes)} mesh(es)\")\n            if not meshes:\n                continue\n            \n            # Write OBJ file\n            safe_name = lyr.Name.replace(' ', '_')\n            obj_path = os.path.join(self.output_dir, f'meshed_layer_{lyr.Index}_{safe_name}.obj')\n            with open(obj_path, 'w') as f:\n                # Write a comment header\n                f.write(f\"# Layer {lyr.Index}: {lyr.Name}\\n\")\n                vertex_offset = 0\n                \n                # Write vertices and faces\n                for mesh in meshes:\n                    # Vertices\n                    for v in mesh.Vertices:\n                        f.write(f\"v {v.X} {v.Y} {v.Z}\\n\")\n                    # Faces\n                    for face in mesh.Faces:\n                        if isinstance(face, tuple):\n                            idxs = face\n                        else:\n                            if getattr(face, \"IsQuad\", False):\n                                idxs = (face.A, face.B, face.C, face.D)\n                            else:\n                                idxs = (face.A, face.B, face.C)\n                        # OBJ indexing is 1-based\n                        idxs = [i + 1 + vertex_offset for i in idxs]\n                        f.write(f\"f {' '.join(map(str, idxs))}\\n\")\n                    vertex_offset += len(mesh.Vertices)\n            \n            self.layer_objs.append(obj_path)\n            print(f\"  Saved OBJ: {obj_path}\")\n        \n        return len(self.layer_objs) > 0\n\n\nclass IntegratedWorkflow:\n    \"\"\"Main class that integrates the Rhino converter, OBJ combiner, and structural grid functionality.\"\"\"\n    \n    def __init__(self):\n        self.rhino_converter = None if not HAS_RHINO3DM else RhinoMeshConverter()\n        self.obj_combiner = None if not HAS_OBJ_COMBINER else ObjCombiner()\n        self.struct_generator = None if not HAS_STRUCTURAL_GRID else StructuralGridGenerator()\n        \n        self.current_3dm_file = None\n        self.current_obj_files = []\n        self.current_combined_obj = None\n        self.current_struct_grid = None\n    \n    def import_3dm_model(self, file_path=None, output_dir=None):\n        \"\"\"Import a 3DM model and convert to OBJ meshes.\"\"\"\n        if not HAS_RHINO3DM:\n            print(\"rhino3dm module is required for this functionality\")\n            return False\n        \n        if file_path is None:\n            # Ask user to select file if not provided\n            file_path = filedialog.askopenfilename(\n                title=\"Select Rhino 3DM File\",\n                filetypes=[(\"Rhino 3DM\", \"*.3dm\"), (\"All Files\", \"*.*\")]\n            )\n            if not file_path:\n                return False\n        \n        # Set current 3DM file\n        self.current_3dm_file = file_path\n        \n        # Load and convert the model\n        if self.rhino_converter.load_3dm(file_path):\n            if self.rhino_converter.export_layers_to_obj(output_dir):\n                # Store generated OBJs\n                self.current_obj_files = self.rhino_converter.layer_objs\n                return True\n        \n        return False\n    \n    def select_obj_files(self, directory=None):\n        \"\"\"Select OBJ files to work with.\"\"\"\n        if directory is None:\n            # Ask user to select directory if not provided\n            directory = filedialog.askdirectory(\n                title=\"Select Directory with OBJ Files\"\n            )\n            if not directory:\n                return False\n        \n        # Scan directory for OBJ files\n        obj_files = glob.glob(os.path.join(directory, '*.obj'))\n        if obj_files:\n            self.current_obj_files = obj_files\n            return True\n        \n        return False\n    \n    def combine_objs(self, export_path=None):\n        \"\"\"Combine selected OBJ files.\"\"\"\n        if not HAS_OBJ_COMBINER:\n            print(\"obj_combiner.py is required for this functionality\")\n            return False\n        \n        if not self.current_obj_files:\n            print(\"No OBJ files selected!\")\n            return False\n        \n        # Load and combine meshes\n        if self.obj_combiner.load_obj_files(self.current_obj_files):\n            if self.obj_combiner.combine_meshes():\n                if export_path:\n                    if self.obj_combiner.export_combined_obj(export_path):\n                        self.current_combined_obj = export_path\n                        return True\n                else:\n                    # Just combine without exporting\n                    return True\n        \n        return False\n    \n    def visualize_objs(self, combine=False):\n        \"\"\"Visualize selected OBJ files.\"\"\"\n        if not HAS_OBJ_COMBINER or not HAS_VISUALIZATION:\n            print(\"obj_combiner.py and visualization libraries are required for this functionality\")\n            return False\n        \n        if not self.current_obj_files:\n            print(\"No OBJ files selected!\")\n            return False\n        \n        # Load and visualize meshes\n        if self.obj_combiner.load_obj_files(self.current_obj_files):\n            self.obj_combiner.visualize(show_combined=combine)\n            return True\n        \n        return False\n    \n    def generate_structural_grid(self, mesh_file=None, mesh_files=None):\n        \"\"\"Generate structural grid from a mesh file or multiple mesh files.\"\"\"\n        if not HAS_STRUCTURAL_GRID:\n            print(\"structural_grid.py is required for this functionality\")\n            return False\n        \n        # Handle multiple mesh files\n        if mesh_files and len(mesh_files) > 0:\n            if self.struct_generator.load_multiple_meshes(mesh_files):\n                # Process the grid with combined meshes\n                if (self.struct_generator.generate_grid() and \n                    self.struct_generator.filter_points() and \n                    self.struct_generator.generate_structures()):\n                    return True\n            return False\n        \n        # Handle single mesh file if no multiple files provided\n        if mesh_file is None and not mesh_files:\n            # If no specific mesh file is provided, use the combined OBJ if available\n            if self.current_combined_obj:\n                mesh_file = self.current_combined_obj\n            # Otherwise use the first OBJ in the list\n            elif self.current_obj_files:\n                mesh_file = self.current_obj_files[0]\n            else:\n                print(\"No mesh file available!\")\n                return False\n        \n        # Load mesh\n        if self.struct_generator.load_mesh(mesh_file):\n            # Set parameters\n            spacing = self.struct_generator.voxel_pitch  # Use default or let the generator calculate it\n            num_floors = self.struct_generator.num_floors  # Use default\n            \n            # Process the grid\n            if (self.struct_generator.generate_grid() and \n                self.struct_generator.filter_points() and \n                self.struct_generator.generate_structures()):\n                return True\n        \n        return False\n    \n    def visualize_structural_grid(self, allow_grid_movement=True):\n        \"\"\"Visualize the generated structural grid with optional interactive grid movement controls.\"\"\"\n        if not HAS_STRUCTURAL_GRID or not HAS_VISUALIZATION:\n            print(\"structural_grid.py and visualization libraries are required for this functionality\")\n            return False\n        \n        if self.struct_generator is None:\n            print(\"No structural grid generator available!\")\n            return False\n        \n        # Visualize the grid with interactive controls if requested\n        return self.struct_generator.visualize(interactive=allow_grid_movement)\n    def export_structural_grid(self, filepath=None):\n        \"\"\"Export the structural grid elements to a JSON file.\"\"\"\n        if not HAS_STRUCTURAL_GRID:\n            print(\"structural_grid.py is required for this functionality\")\n            return False\n        \n        if self.struct_generator is None:\n            print(\"No structural grid generator available!\")\n            return False\n        \n        if filepath is None:            # Ask user to select file if not provided\n            filepath = filedialog.asksaveasfilename(\n                title=\"Save Structural Elements As\",\n                initialdir=os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), \"output\", \"json\"),\n                defaultextension=\".json\",\n                filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")]\n            )\n            if not filepath:\n                return False\n        \n        # Export the structural elements\n        return self.struct_generator.export_structures(filepath)\n\n\ndef run_gui():\n    \"\"\"Run the integrated workflow application with a GUI.\"\"\"\n    root = tk.Tk()\n    root.title(\"Integrated Structural Workflow\")\n    root.geometry(\"800x650\")\n    root.resizable(True, True)\n    \n    app = IntegratedWorkflow()\n    \n    # Create main frame\n    main_frame = ttk.Frame(root, padding=\"10 10 10 10\")\n    main_frame.pack(fill=tk.BOTH, expand=True)\n    \n    # Main content area\n    content_frame = ttk.Frame(main_frame)\n    content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n    \n    # Status bar\n    status_frame = ttk.Frame(main_frame)\n    status_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=5)\n    status_label = ttk.Label(status_frame, text=\"Ready\", relief=tk.SUNKEN, anchor=tk.W)\n    status_label.pack(fill=tk.X)\n    \n    # Create a notebook for workflow steps\n    notebook = ttk.Notebook(content_frame)\n    notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n    \n    # --- Step 1: Rhino Import Tab ---\n    rhino_frame = ttk.Frame(notebook)\n    notebook.add(rhino_frame, text=\"1. Import Rhino\")\n    \n    rhino_content = ttk.Frame(rhino_frame, padding=\"10 10 10 10\")\n    rhino_content.pack(fill=tk.BOTH, expand=True)\n    \n    ttk.Label(rhino_content, text=\"Import Rhino 3DM models and convert to OBJ meshes.\").pack(anchor=tk.W, pady=5)\n    \n    def import_3dm():\n        file_path = filedialog.askopenfilename(\n            title=\"Select Rhino 3DM File\",\n            filetypes=[(\"Rhino 3DM\", \"*.3dm\"), (\"All Files\", \"*.*\")]\n        )\n        if file_path:\n            output_dir = filedialog.askdirectory(\n                title=\"Select Output Directory for OBJ Files\",\n                initialdir=os.path.dirname(file_path)\n            )\n            if output_dir:\n                if app.import_3dm_model(file_path, output_dir):\n                    status_label.config(text=f\"Imported {file_path} and generated {len(app.current_obj_files)} OBJ files\")\n                    messagebox.showinfo(\"Import Complete\", f\"Successfully generated {len(app.current_obj_files)} OBJ files in {output_dir}\")\n                    # Switch to the next tab\n                    notebook.select(1)\n                else:\n                    status_label.config(text=\"Error importing 3DM model\")\n    \n    ttk.Button(rhino_content, text=\"Import 3DM File\", command=import_3dm).pack(anchor=tk.W, pady=5)\n    \n    # Disable the tab if rhino3dm is not available\n    if not HAS_RHINO3DM:\n        rhino_disabled_label = ttk.Label(rhino_content, text=\"rhino3dm module not available.\\nPlease install it with: pip install rhino3dm\", foreground=\"red\")\n        rhino_disabled_label.pack(anchor=tk.CENTER, pady=20)\n    \n    # --- Step 2: OBJ Selection Tab ---\n    obj_frame = ttk.Frame(notebook)\n    notebook.add(obj_frame, text=\"2. OBJ Selection\")\n    \n    obj_content = ttk.Frame(obj_frame, padding=\"10 10 10 10\")\n    obj_content.pack(fill=tk.BOTH, expand=True)\n    \n    ttk.Label(obj_content, text=\"Select OBJ files to work with or use the ones generated from Rhino.\").pack(anchor=tk.W, pady=5)\n    \n    # List to display loaded files\n    file_frame = ttk.LabelFrame(obj_content, text=\"Selected OBJ Files\")\n    file_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n    \n    file_listbox = tk.Listbox(file_frame)\n    file_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n    \n    def update_obj_list():\n        file_listbox.delete(0, tk.END)\n        for file_path in app.current_obj_files:\n            file_listbox.insert(tk.END, os.path.basename(file_path))\n    \n    def select_obj_directory():\n        directory = filedialog.askdirectory(\n            title=\"Select Directory with OBJ Files\"\n        )\n        if directory:\n            if app.select_obj_files(directory):\n                update_obj_list()\n                status_label.config(text=f\"Selected {len(app.current_obj_files)} OBJ files from {directory}\")\n            else:\n                status_label.config(text=\"No OBJ files found in the selected directory\")\n    \n    def select_obj_files():\n        files = filedialog.askopenfilenames(\n            title=\"Select OBJ Files\",\n            filetypes=[(\"OBJ Files\", \"*.obj\"), (\"All Files\", \"*.*\")]\n        )\n        if files:\n            app.current_obj_files = list(files)\n            update_obj_list()\n            status_label.config(text=f\"Selected {len(app.current_obj_files)} OBJ files\")\n    \n    def visualize_separate():\n        if app.visualize_objs(combine=False):\n            status_label.config(text=\"Visualizing OBJ files separately\")\n        else:\n            status_label.config(text=\"Error visualizing OBJ files\")\n    \n    button_frame = ttk.Frame(obj_content)\n    button_frame.pack(fill=tk.X, padx=5, pady=5)\n    \n    ttk.Button(button_frame, text=\"Select Directory\", command=select_obj_directory).pack(side=tk.LEFT, padx=5)\n    ttk.Button(button_frame, text=\"Select OBJ Files\", command=select_obj_files).pack(side=tk.LEFT, padx=5)\n    ttk.Button(button_frame, text=\"Visualize Separate\", command=visualize_separate).pack(side=tk.LEFT, padx=5)\n    \n    # --- Step 3: OBJ Combining Tab ---\n    combine_frame = ttk.Frame(notebook)\n    notebook.add(combine_frame, text=\"3. Combine OBJs\")\n    \n    combine_content = ttk.Frame(combine_frame, padding=\"10 10 10 10\")\n    combine_content.pack(fill=tk.BOTH, expand=True)\n    \n    ttk.Label(combine_content, text=\"Combine multiple OBJ files into a single mesh for structural analysis.\").pack(anchor=tk.W, pady=5)\n    \n    def combine_and_visualize():\n        if app.visualize_objs(combine=True):\n            status_label.config(text=\"Visualizing combined OBJ\")\n        else:\n            status_label.config(text=\"Error visualizing combined OBJ\")\n    \n    def combine_and_export():\n        filepath = filedialog.asksaveasfilename(\n            title=\"Save Combined OBJ As\",\n            defaultextension=\".obj\",\n            filetypes=[(\"OBJ Files\", \"*.obj\"), (\"All Files\", \"*.*\")]\n        )\n        if filepath:\n            if app.combine_objs(filepath):\n                status_label.config(text=f\"Combined and exported to {filepath}\")\n                # Offer to proceed to the next step\n                if messagebox.askyesno(\"Continue\", \"Proceed to structural grid generation?\"):\n                    notebook.select(3)\n            else:\n                status_label.config(text=\"Error combining OBJ files\")\n    \n    ttk.Button(combine_content, text=\"Combine & Visualize\", command=combine_and_visualize).pack(anchor=tk.W, pady=5)\n    ttk.Button(combine_content, text=\"Combine & Export\", command=combine_and_export).pack(anchor=tk.W, pady=5)\n    \n    # --- Step 4: Structural Grid Tab ---\n    struct_frame = ttk.Frame(notebook)\n    notebook.add(struct_frame, text=\"4. Structural Grid\")\n    \n    struct_content = ttk.Frame(struct_frame, padding=\"10 10 10 10\")\n    struct_content.pack(fill=tk.BOTH, expand=True)\n    \n    ttk.Label(struct_content, text=\"Generate and visualize a structural grid from the combined mesh.\").pack(anchor=tk.W, pady=5)\n    \n    # Grid settings frame\n    settings_frame = ttk.LabelFrame(struct_content, text=\"Grid Settings\")\n    settings_frame.pack(fill=tk.X, padx=5, pady=5)\n    \n    # Create a reference to the struct_generator for settings\n    struct_generator = app.struct_generator\n    \n    # Grid spacing setting\n    ttk.Label(settings_frame, text=\"Grid Spacing:\").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)\n    spacing_var = tk.StringVar(value=\"Auto\")\n    spacing_entry = ttk.Entry(settings_frame, textvariable=spacing_var, width=10)\n    spacing_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)\n    \n    # Number of floors setting\n    ttk.Label(settings_frame, text=\"Number of Floors:\").grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)\n    floors_var = tk.StringVar(value=\"3\")\n    floors_entry = ttk.Entry(settings_frame, textvariable=floors_var, width=10)\n    floors_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)\n    \n    def set_grid_settings():\n        if struct_generator:\n            try:\n                # Set spacing if not \"Auto\"\n                spacing_value = spacing_var.get()\n                if spacing_value != \"Auto\":\n                    struct_generator.voxel_pitch = float(spacing_value)\n                else:\n                    struct_generator.voxel_pitch = None  # Let the generator calculate it\n                \n                # Set number of floors\n                struct_generator.num_floors = int(floors_var.get())\n                \n                status_label.config(text=f\"Grid settings updated: Spacing={spacing_value}, Floors={floors_var.get()}\")\n                return True\n            except ValueError as e:\n                messagebox.showerror(\"Invalid Setting\", f\"Invalid grid setting: {str(e)}\")\n                return False\n        return False\n    \n    ttk.Button(settings_frame, text=\"Apply Settings\", command=set_grid_settings).grid(row=0, column=2, rowspan=2, padx=5, pady=5)\n    \n    def select_and_generate():        # Let user select a mesh file\n        mesh_file = filedialog.askopenfilename(\n            title=\"Select Mesh File\",\n            filetypes=[(\"OBJ Files\", \"*.obj\"), (\"GLB Files\", \"*.glb\"), (\"All Mesh Files\", \"*.obj;*.stl;*.ply;*.glb\"), (\"All Files\", \"*.*\")]\n        )\n        if mesh_file:\n            # Apply grid settings\n            set_grid_settings()\n            \n            # Generate grid\n            if app.generate_structural_grid(mesh_file):\n                status_label.config(text=f\"Generated structural grid for {os.path.basename(mesh_file)}\")\n                if messagebox.askyesno(\"Visualization\", \"Visualize the generated structural grid?\"):\n                    app.visualize_structural_grid()\n            else:\n                status_label.config(text=\"Error generating structural grid\")\n    \n    def select_multiple_and_generate():        # Let user select multiple mesh files\n        mesh_files = filedialog.askopenfilenames(\n            title=\"Select Multiple Mesh Files\",\n            filetypes=[(\"OBJ Files\", \"*.obj\"), (\"GLB Files\", \"*.glb\"), (\"All Mesh Files\", \"*.obj;*.stl;*.ply;*.glb\"), (\"All Files\", \"*.*\")]\n        )\n        if mesh_files and len(mesh_files) > 0:\n            # Sort the files to prioritize column meshes\n            sorted_mesh_files = sorted(mesh_files, \n                                      key=lambda path: 0 if \"column\" in os.path.basename(path).lower() else 1)\n            \n            # Apply grid settings\n            set_grid_settings()\n            \n            # Generate grid with multiple meshes\n            if app.generate_structural_grid(mesh_files=list(sorted_mesh_files)):\n                # Find if there were any column meshes to highlight in status\n                column_files = [f for f in sorted_mesh_files if \"column\" in os.path.basename(f).lower()]\n                if column_files:\n                    status_label.config(text=f\"Generated grid using column mesh as reference\")\n                else:\n                    status_label.config(text=f\"Generated structural grid from {len(mesh_files)} mesh files\")\n                \n                if messagebox.askyesno(\"Visualization\", \"Visualize the generated structural grid?\"):\n                    app.visualize_structural_grid()\n            else:\n                status_label.config(text=\"Error generating structural grid\")\n    \n    def generate_from_combined():\n        if not app.current_combined_obj and not app.current_obj_files:\n            messagebox.showerror(\"No Mesh File\", \"No combined or individual mesh files available.\")\n            return\n        \n        # Apply grid settings\n        set_grid_settings()\n        \n        # Generate grid using default file selection logic\n        if app.generate_structural_grid():\n            status_label.config(text=\"Generated structural grid\")\n            if messagebox.askyesno(\"Visualization\", \"Visualize the generated structural grid?\"):\n                app.visualize_structural_grid()\n        else:\n            status_label.config(text=\"Error generating structural grid\")\n    \n    button_frame = ttk.Frame(struct_content)\n    button_frame.pack(fill=tk.X, padx=5, pady=10)\n    \n    ttk.Button(button_frame, text=\"Select Mesh & Generate\", command=select_and_generate).pack(side=tk.LEFT, padx=5)\n    ttk.Button(button_frame, text=\"Select Multiple Meshes\", command=select_multiple_and_generate).pack(side=tk.LEFT, padx=5)\n    ttk.Button(button_frame, text=\"Generate from Combined\", command=generate_from_combined).pack(side=tk.LEFT, padx=5)\n    \n    # Add separate buttons for visualization with and without grid movement\n    def visualize_grid_with_movement():\n        if app.visualize_structural_grid(allow_grid_movement=True):\n            status_label.config(text=\"Visualizing structural grid with interactive grid movement controls\")\n        else:\n            status_label.config(text=\"Error visualizing structural grid\")\n    \n    def visualize_grid_without_movement():\n        if app.visualize_structural_grid(allow_grid_movement=False):\n            status_label.config(text=\"Visualizing fixed structural grid\")\n        else:\n            status_label.config(text=\"Error visualizing structural grid\")\n    \n    # Define the export_grid function\n    def export_grid():\n        filepath = filedialog.asksaveasfilename(\n            title=\"Export Structural Elements\",\n            defaultextension=\".json\",\n            filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")]\n        )\n        if filepath:\n            if app.export_structural_grid(filepath):\n                status_label.config(text=f\"Exported structural elements to {filepath}\")\n            else:\n                status_label.config(text=\"Error exporting structural elements\")\n            \n    visualization_frame = ttk.Frame(struct_content)\n    visualization_frame.pack(fill=tk.X, padx=5, pady=5)\n    \n    ttk.Label(visualization_frame, text=\"Visualization Options:\").pack(anchor=tk.W, padx=5)\n    \n    visualization_buttons = ttk.Frame(visualization_frame)\n    visualization_buttons.pack(fill=tk.X, padx=5, pady=5)\n    \n    ttk.Button(visualization_buttons, text=\"Interactive Grid Movement\", \n              command=visualize_grid_with_movement).pack(side=tk.LEFT, padx=5)\n    ttk.Button(visualization_buttons, text=\"Fixed Grid Visualization\", \n              command=visualize_grid_without_movement).pack(side=tk.LEFT, padx=5)\n    \n    ttk.Button(button_frame, text=\"Export Grid (JSON)\", command=export_grid).pack(side=tk.LEFT, padx=5)\n    \n    # Help text with updated information about grid movement\n    help_frame = ttk.Frame(struct_content)\n    help_frame.pack(fill=tk.X, padx=5, pady=10)\n    \n    help_text = tk.Text(help_frame, height=8, width=50, wrap=tk.WORD)\n    help_text.pack(fill=tk.X, padx=5, pady=5)\n    help_text.insert(tk.END, \"This tab allows you to generate a structural grid from a mesh file.\\n\\n\"\n                    \"1. Adjust grid spacing (or leave as 'Auto') and number of floors\\n\"\n                    \"2. Select a mesh file or use the previously combined one\\n\"\n                    \"3. Generate the structural grid\\n\"\n                    \"4. Visualize and export the grid as needed\\n\\n\"\n                    \"NEW: Use 'Interactive Grid Movement' to adjust grid positions during visualization. \"\n                    \"Sliders will appear at the bottom of the 3D view to control X/Y offsets and spacing.\")\n    help_text.config(state=tk.DISABLED)\n    \n    # Initialize by updating the OBJ list if files are already loaded\n    if app.current_obj_files:\n        update_obj_list()\n\n    root.mainloop()\n\n\ndef run_cmd():\n    \"\"\"Run the integrated workflow from command line.\"\"\"\n    if len(sys.argv) < 2:\n        print(\"\"\"\nUsage: python integrated_workflow.py [options]\n\nOptions:\n  --import-3dm <file.3dm> [output_dir]   Import a Rhino 3DM file and convert to OBJs\n  --select-objs <dir or file1,file2,...>  Select OBJ files to work with\n  --combine-objs [output.obj]             Combine selected OBJs\n  --visualize-objs [--combined]           Visualize selected OBJs (separate or combined)\n  --generate-grid [mesh.obj] [spacing] [floors]  Generate structural grid\n  --visualize-grid                        Visualize structural grid\n  --export-grid <output.json>              Export structural grid to JSON\n        \"\"\")\n        return\n    \n    app = IntegratedWorkflow()\n    \n    i = 1\n    while i < len(sys.argv):\n        arg = sys.argv[i]\n        \n        if arg == \"--import-3dm\":\n            if i + 1 < len(sys.argv):\n                file_path = sys.argv[i + 1]\n                output_dir = sys.argv[i + 2] if i + 2 < len(sys.argv) and not sys.argv[i + 2].startswith(\"--\") else None\n                app.import_3dm_model(file_path, output_dir)\n                i += 2 if output_dir is None else 3\n            else:\n                print(\"Error: Missing file path after --import-3dm\")\n                return\n        \n        elif arg == \"--select-objs\":\n            if i + 1 < len(sys.argv):\n                source = sys.argv[i + 1]\n                if os.path.isdir(source):\n                    app.select_obj_files(source)\n                else:\n                    # Comma-separated list of files\n                    app.current_obj_files = source.split(\",\")\n                i += 2\n            else:\n                print(\"Error: Missing source after --select-objs\")\n                return\n        \n        elif arg == \"--combine-objs\":\n            output_file = sys.argv[i + 1] if i + 1 < len(sys.argv) and not sys.argv[i + 1].startswith(\"--\") else None\n            app.combine_objs(output_file)\n            i += 1 if output_file is None else 2\n        \n        elif arg == \"--visualize-objs\":\n            combined = sys.argv[i + 1] == \"--combined\" if i + 1 < len(sys.argv) else False\n            app.visualize_objs(combined)\n            i += 1 if not combined else 2\n        \n        elif arg == \"--generate-grid\":\n            mesh_file = sys.argv[i + 1] if i + 1 < len(sys.argv) and not sys.argv[i + 1].startswith(\"--\") else None\n            spacing = float(sys.argv[i + 2]) if i + 2 < len(sys.argv) and not sys.argv[i + 2].startswith(\"--\") else None\n            floors = int(sys.argv[i + 3]) if i + 3 < len(sys.argv) and not sys.argv[i + 3].startswith(\"--\") else None\n            \n            if spacing is not None and app.struct_generator is not None:\n                app.struct_generator.voxel_pitch = spacing\n            if floors is not None and app.struct_generator is not None:\n                app.struct_generator.num_floors = floors\n                \n            app.generate_structural_grid(mesh_file)\n            i += 1\n            if mesh_file is not None: i += 1\n            if spacing is not None: i += 1\n            if floors is not None: i += 1\n        \n        elif arg == \"--visualize-grid\":\n            app.visualize_structural_grid()\n            i += 1\n        \n        elif arg == \"--export-grid\":\n            if i + 1 < len(sys.argv):\n                app.export_structural_grid(sys.argv[i + 1])\n                i += 2\n            else:\n                print(\"Error: Missing output file after --export-grid\")\n                return\n        \n        else:\n            print(f\"Unknown option: {arg}\")\n            i += 1\n\n\nif __name__ == \"__main__\":\n    # Check if running in command line mode or GUI mode\n    if len(sys.argv) > 1:\n        run_cmd()\n    else:\n        run_gui()",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}