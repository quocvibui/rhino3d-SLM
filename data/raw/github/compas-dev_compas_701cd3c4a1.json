{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/conversions/breps.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/conversions/breps.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport Rhino.Geometry  # type: ignore  # noqa: F401\nimport scriptcontext as sc  # type: ignore\n\nimport compas\nimport compas.geometry  # noqa: F401\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Brep\nfrom compas.tolerance import TOL\n\nfrom .exceptions import ConversionError\nfrom .extrusions import extrusion_to_compas_box\nfrom .geometry import point_to_compas\nfrom .shapes import cone_to_compas\nfrom .shapes import cylinder_to_compas\nfrom .shapes import sphere_to_compas\nfrom .surfaces import surface_to_compas\n\nif not compas.IPY:\n    from typing import Callable  # noqa: F401\n    from typing import Type  # noqa: F401\n\n# =============================================================================\n# To Rhino\n# =============================================================================\n\n\ndef brep_to_rhino(brep):\n    # type: (Brep) -> Rhino.Geometry.Brep\n    \"\"\"Convert a COMPAS Brep to a Rhino Brep.\n\n    Parameters\n    ----------\n    brep : :class:`compas.geometry.Brep`\n\n    Returns\n    -------\n    :rhino:`Rhino.Geometry.Brep`\n\n    \"\"\"\n    return brep.native_brep\n\n\n# =============================================================================\n# To COMPAS\n# =============================================================================\n\n\ndef brep_to_compas(brep):\n    # type: (Rhino.Geometry.Brep) -> Brep\n    \"\"\"Convert a Rhino Brep to a COMPAS Brep.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Brep`\n\n    \"\"\"\n    return Brep.from_native(brep)\n\n\n# =============================================================================\n# To COMPAS Shapes\n# =============================================================================\n\n\ndef brep_to_compas_box(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Box\n    \"\"\"Convert a Rhino brep to a COMPAS box.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Box`\n\n    \"\"\"\n    return extrusion_to_compas_box(brep.Geometry)\n\n\ndef brep_to_compas_cone(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Cone\n    \"\"\"Convert a Rhino brep to a COMPAS cone.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Cone`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    if brep.Faces.Count > 2:\n        raise ConversionError(\"Brep cannot be converted to a cone.\")\n\n    for face in brep.Faces:\n        if face.IsCone():\n            result, cone = face.TryGetCone()\n            if result:\n                return cone_to_compas(cone)\n\n    raise ConversionError(\"Brep cannot be converted to a cone.\")\n\n\ndef brep_to_compas_cylinder(brep, tol=None):\n    # type: (Rhino.Geometry.Brep, float | None) -> compas.geometry.Cylinder\n    \"\"\"Convert a Rhino brep to a COMPAS cylinder.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Cylinder`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    tol = tol or sc.doc.ModelAbsoluteTolerance\n\n    if brep.Faces.Count > 3:\n        raise ConversionError(\"Brep cannot be converted to a cylinder.\")\n\n    for face in brep.Faces:\n        # being too strict about what is considered a cylinder\n        # results in cylinders created by Rhino itself\n        # to not be recognized...\n        if face.IsCylinder(tol):\n            result, cylinder = face.TryGetFiniteCylinder(tol)\n            if result:\n                return cylinder_to_compas(cylinder)\n\n    raise ConversionError(\"Brep cannot be converted to a cylinder.\")\n\n\ndef brep_to_compas_sphere(brep):\n    # type: (Rhino.Geometry.Brep) -> compas.geometry.Sphere\n    \"\"\"Convert a Rhino brep to a COMPAS sphere.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.Sphere`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    if brep.Faces.Count != 1:\n        raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n    face = brep.Faces.Item[0]\n    if not face.IsSphere():\n        raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n    result, sphere = face.TryGetSphere()\n    if result:\n        return sphere_to_compas(sphere)\n\n    raise ConversionError(\"Brep cannot be converted to a sphere.\")\n\n\n# =============================================================================\n# To COMPAS Surface\n# =============================================================================\n\n\ndef brep_to_compas_surface(brep, tol=None):\n    # type: (Rhino.Geometry.Brep, float | None) -> compas.geometry.NurbsSurface\n    \"\"\"Convert a Rhino brep to a COMPAS surface.\n\n    Parameters\n    ----------\n    brep : :rhino:`Rhino.Geometry.Brep`\n\n    Returns\n    -------\n    :class:`compas.geometry.NurbsSurface`\n\n    Raises\n    ------\n    ConversionError\n\n    \"\"\"\n    tol = tol or sc.doc.ModelAbsoluteTolerance\n\n    if brep.Faces.Count != 1:\n        raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n    face = brep.Faces.Item[0]\n\n    if not face.HasNurbsForm():\n        raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n    result, surface = face.ToNurbsSurface(tol)\n    if result:\n        return surface_to_compas(surface)\n\n    raise ConversionError(\"Brep cannot be converted to a surface.\")\n\n\n# =============================================================================\n# To COMPAS Mesh\n# =============================================================================\n\n\ndef brep_to_compas_mesh(brep, facefilter=None, cleanup=False, cls=None):\n    # type: (Rhino.Geometry.Brep, Callable | None, bool, Type[Mesh] | None) -> Mesh\n    \"\"\"Convert the face loops of a Rhino brep to a COMPAS mesh.\n\n    Parameters\n    ----------\n    brep : :class:`Rhino.Geometry.Brep`\n        A Rhino brep.\n    facefilter : callable, optional\n        A filter for selection which Brep faces to include.\n        If provided, the filter should return True or False per face.\n        A very simple filter that includes all faces is ``def facefilter(face): return True``.\n        Default parameter value is None in which case all faces are included.\n    cleanup : bool, optional\n        Flag indicating to clean up the result.\n        Cleaning up means to remove isolated faces and unused vertices.\n        Default is False.\n    cls : :class:`compas.datastructures.Mesh`, optional\n        The type of COMPAS mesh.\n\n    Returns\n    -------\n    :class:`compas.datastructures.Mesh`\n        The resulting mesh.\n\n    \"\"\"\n    if facefilter and callable(facefilter):\n        brepfaces = [face for face in brep.Faces if facefilter(face)]\n    else:\n        brepfaces = brep.Faces\n\n    # vertex maps and face lists\n    gkey_xyz = {}\n    faces = []\n    for face in brepfaces:\n        loop = face.OuterLoop\n        curve = loop.To3dCurve()\n        segments = list(curve.Explode())\n        a = point_to_compas(segments[0].PointAtStart)\n        b = point_to_compas(segments[0].PointAtEnd)\n        a_gkey = TOL.geometric_key(a)\n        b_gkey = TOL.geometric_key(b)\n        gkey_xyz[a_gkey] = a\n        gkey_xyz[b_gkey] = b\n        face = [a_gkey, b_gkey]\n        for segment in segments[1:-1]:\n            b = point_to_compas(segment.PointAtEnd)\n            b_gkey = TOL.geometric_key(b)\n            face.append(b_gkey)\n            gkey_xyz[b_gkey] = b\n        faces.append(face)\n\n    # vertices and faces\n    gkey_index = {gkey: index for index, gkey in enumerate(gkey_xyz)}\n    vertices = [list(xyz) for gkey, xyz in gkey_xyz.items()]\n    faces = [[gkey_index[gkey] for gkey in face] for face in faces]\n\n    # remove duplicates from vertexlist\n    polygons = []\n    for temp in faces:\n        face = []\n        for vertex in temp:\n            if vertex not in face:\n                face.append(vertex)\n        polygons.append(face)\n\n    # define mesh type\n    cls = cls or Mesh\n    # create mesh\n    mesh = cls.from_vertices_and_faces(vertices, polygons)\n\n    # remove isolated faces\n    if cleanup:\n        if mesh.number_of_faces() > 1:\n            for face in list(mesh.faces()):\n                if not mesh.face_neighbors(face):\n                    mesh.delete_face(face)\n        mesh.remove_unused_vertices()\n\n    return mesh\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}