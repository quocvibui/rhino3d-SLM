{
  "source_url": "https://github.com/lm2-me/CORE/blob/6dd1d257c7701d255cbda9a6c4d75d843bda2fde/unpack/hops/prog_place/helpers.py",
  "repo": "lm2-me/CORE",
  "repo_stars": 0,
  "repo_description": null,
  "license": "GPL-3.0",
  "filepath": "unpack/hops/prog_place/helpers.py",
  "instruction": "Helpers",
  "code": "import enum\nfrom math import sqrt\nfrom types import NoneType\nfrom typing import Dict, List\nimport rhino3dm as r3d\nimport math as m\nimport copy\nimport numpy as np\n\ndef list_to_tree(l):\n    out = {}\n    for i,r in enumerate(l):\n        out['{}'.format(i)] = r\n    return out\n\ndef line_closest_point(line: r3d.Line, point):\n    ep1 = line.From\n    ep2 = line.To\n\n    distance = abs((ep2.X - ep1.X) * (ep1.Y - point.Y) - (ep1.X - point.X)*(ep2.Y - ep1.Y)) / (m.sqrt(m.pow((ep2.X - ep1.X),2) + m.pow((ep2.Y - ep1.Y),2)))\n    distance_rounded = round(distance,2)\n\n    return distance_rounded\n\ndef tree_to_matrix(tree: Dict[str, List[str]]):\n    out = []\n    tree_to_list = [(int(k[1:-1]),v) for k,v in tree.items()]\n    tree_to_list.sort()\n    for _,b in tree_to_list:\n        out.append(b)\n    return out\n\ndef tree_to_list(tree: Dict[str, List[str]]):\n    tree_to_list = [(int(k[1:-1]),v) for k,v in tree.items()]\n    tree_to_list.sort()\n    return [x[1] for x in tree_to_list]\n    \ndef matrix_str2floats(matrix: List[List[str]]):\n    out = copy.deepcopy(matrix)\n    for i in range(len(matrix)):\n        if matrix[i][0] == 'None' or matrix[i][0] == None or matrix[i] == 'None' or matrix[i] == None:\n            out[i] = None\n        else: \n            for j in range(len(matrix[i])):\n                out[i][j] = [float(v) for v in matrix[i][j].split(',')]\n    return out\n\ndef matrix_floats2str(matrix: List[List[float]]):\n    out = []\n    for i in range(len(matrix)):\n        rowpts = []\n        for j in range(len(matrix[i])):\n            rowpts.append('{0},{1}'.format(matrix[i][j][0], matrix[i][j][1]))\n        out.append(rowpts)\n\n    return out\n\ndef matrix_mask(matrix, mask_values):\n    out = copy.deepcopy(matrix)\n    mask_values_str = mask_values.split(',')\n    mask_values_int = []\n\n    for v in mask_values_str:\n        mask_values_int.append(int(v))\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            out[i][j] = mask_values_int\n    \n    return out\n\ndef vector3d_2pts(pt1, pt2):\n\n    out = r3d.Vector3d(pt2.X - pt1.X, pt2.Y - pt1.Y, pt2.Z - pt1.Z)\n\n    return out\n\ndef corners(geometry: r3d.Surface):\n    bbox = geometry.GetBoundingBox()\n    btm_left = bbox.Min\n    tp_right = bbox.Max\n    tp_left = r3d.Point3d(btm_left.X, tp_right.Y, 0)\n    btm_right = r3d.Point3d(tp_right.X, btm_left.Y, 0)\n\n    return btm_left, tp_left, tp_right, btm_right, [btm_left, tp_left, tp_right, btm_right]\n\ndef divide_surface_inset(surface, grid_size):\n    srf_u_start = int(surface.Domain(0).T0)\n    srf_u_end = int(surface.Domain(0).T1)\n    srf_v_start = int(surface.Domain(1).T0)\n    srf_v_end = int(surface.Domain(1).T1)\n\n    srfpts = []\n\n    for y in range(srf_v_end-int(grid_size), srf_v_start, -int(grid_size)):\n        rowpts = []\n        for x in range(srf_u_start+int(grid_size), srf_u_end, int(grid_size)):\n            point = r3d.Point3d(surface.PointAt(x,y).X,surface.PointAt(x,y).Y,0)\n            rowpts.append(point)\n                        \n        srfpts.append(rowpts)\n\n    return srfpts\n\ndef divide_surface(surface, grid_size):\n    srf_u_start = int(surface.Domain(0).T0)\n    srf_u_end = int(surface.Domain(0).T1)\n    srf_v_start = int(surface.Domain(1).T0)\n    srf_v_end = int(surface.Domain(1).T1)\n\n    srfpts = []\n\n    for y in range(srf_v_end, srf_v_start-int(grid_size), -int(grid_size)):\n        rowpts = []\n        for x in range(srf_u_start, srf_u_end+int(grid_size), int(grid_size)):\n            point = r3d.Point3d(surface.PointAt(x,y).X,surface.PointAt(x,y).Y,0)\n            rowpts.append(point)\n                        \n        srfpts.append(rowpts)\n    \n    srfpts_np = np.array(srfpts)\n    midpoints = srfpts_np[1:-1, 1:-1].tolist()\n    \n    edge =  np.concatenate((srfpts_np[0,:], srfpts_np[1:,-1], srfpts_np[-1,:-1], srfpts_np[1:-1,0])).tolist()\n    \n    return midpoints, edge\n\ndef location_closest_grid_point(srfpts_matrix, points):\n    out_location = []\n    for row, l in enumerate(srfpts_matrix):\n        for column, pt1 in enumerate(l):\n            if isinstance(points, list):\n                for pt2 in points:\n                    distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (pt2.X, pt2.Y, pt2.Z)))\n                    if distance < 0.1:\n                        out_location.append([row, column])\n                    if len(out_location) == len(points):\n                        break\n                    else: continue\n            else:\n                distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (points.X, points.Y, points.Z)))\n                if distance < 0.1:\n                    out_location.append(row)\n                    out_location.append(column)\n                    break\n                else: continue\n    while len(out_location) < len(points) and len(out_location) < 10:\n        out_location.append(None)\n\n    return out_location\n\ndef update_label(label_array_np, srfpts_matrix, pts_to_update, new_label):\n    for row, l in enumerate(srfpts_matrix):\n        for column1, pt1 in enumerate(l):\n            for pt2 in pts_to_update:\n                if isinstance(pt2, list):\n                    for pts in pt2:\n                        distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (pts.X, pts.Y, pts.Z)))\n                        if distance < 0.05:\n                            label_array_np[row][column1] = new_label\n                else: \n                    distance = abs(m.dist((pt1.X, pt1.Y, pt1.Z), (pt2.X, pt2.Y, pt2.Z)))\n                    if distance < 0.05:\n                        label_array_np[row][column1] = new_label\n                    else:\n                        continue\n    \n    return label_array_np\n\n\ndef convert_interior_boundaries(arr_base: np.ndarray):\n    arr_base_mask = np.where((arr_base == 'b') | (arr_base == 'i'), 1, 0)\n    arr_base_mask_padded = np.pad(arr_base_mask, ((1,1), (1,1)), 'constant')\n\n    arr_interior_mask = arr_base_mask * arr_base_mask_padded[2:,2:] * arr_base_mask_padded[2:,:-2] * arr_base_mask_padded[:-2,2:] * arr_base_mask_padded[:-2, :-2]\n    arr_updated_mask = np.where(arr_interior_mask == 1, 'i', arr_base)\n\n    return arr_base\n\ndef rotate_point(origin, point, angle):\n    origin_x = origin.X\n    origin_y = origin.Y\n    point_x = point.X\n    point_y = point.Y\n\n    rotated_x = round(origin_x + m.cos(angle) * (point_x - origin_x) - m.sin(angle) * (point_y - origin_y))\n    rotated_y = round(origin_y + m.sin(angle) * (point_x - origin_x) + m.cos(angle) * (point_y - origin_y))\n    return rotated_x, rotated_y\n\ndef normalize_weight(weights):\n    norm_weights = copy.deepcopy(weights)\n    min_value = m.inf\n    max_value = 0\n    num_weights = len(weights[0][0])\n\n    for num in range(num_weights):\n        for row in weights:\n            for costs in row:\n                if costs[num] < min_value:\n                    min_value = costs[num]\n                if costs[num] > max_value:\n                    max_value = costs[num]\n        \n        for i, row in enumerate(weights):\n            for j, costs in enumerate(row):\n                normalized_weight = (costs[num] - min_value) / (max_value-min_value)\n                norm_weights[i][j][num] = normalized_weight\n\n    return norm_weights",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}