{
  "source_url": "https://github.com/mcneel/compute.rhino3d/blob/677087c3683fb307c9d3a6e55651377c28c41e92/src/ghhops-server-py/ghhops_server/base.py",
  "repo": "mcneel/compute.rhino3d",
  "repo_stars": 378,
  "repo_description": "REST geometry server based on RhinoCommon and headless Rhino",
  "license": "NOASSERTION",
  "filepath": "src/ghhops-server-py/ghhops_server/base.py",
  "instruction": "Base types for Hops middleware",
  "code": "\"\"\"Base types for Hops middleware\"\"\"\nimport sys\nimport traceback\nimport os\nimport os.path as op\nimport inspect\nimport json\nimport base64\nfrom typing import Tuple\n\nfrom ghhops_server.logger import hlogger\nfrom ghhops_server.component import HopsComponent\n\n\nDEFAULT_CATEGORY = \"Hops\"\nDEFAULT_SUBCATEGORY = \"Hops Python\"\n\n\nclass HopsBase:\n    \"\"\"Base class for all Hops middleware implementations\"\"\"\n\n    ROOT_ROUTE = \"/\"\n    SOLVE_ROUTE = \"/solve\"\n\n    BUILTIN_ROUTES = [ROOT_ROUTE, SOLVE_ROUTE]\n\n    ERROR_PAGE_405 = \"\"\"<!doctype html>\n<html lang=en>\n<title>405 Method Not Allowed</title>\n<h1>Method Not Allowed</h1>\n<p>The method is not allowed for the requested URL.</p>\"\"\"\n\n    def __init__(self, app):\n        self.app = app\n        # components dict store each components two times under\n        # two keys get uri and solve uri, for faster lookups in query and solve\n        # it is assumed that uri and solve uri and both unique to the component\n        self._components: dict[str, HopsComponent] = {}\n\n    def handles(self, request):\n        uri = request.path\n        return uri in HopsBase.BUILTIN_ROUTES or uri in self._components\n\n    def handle_HEAD(self, _):\n        return self._prep_response(200, \"Success\")\n\n    def handle_GET(self, request):\n        uri = request.path\n\n        # if calling GET /solve, respond 405\n        if self._is_solve_uri(uri):\n            return self._return_method_not_allowed()\n\n        # if component exists, return component data\n        res, results = self.query(uri=uri)\n        if res:\n            response = self._prep_response()\n            response.data = results\n\n        # otherwise return 404\n        else:\n            response = self._prep_response(404, \"Unknown URI\")\n\n        return response\n\n    def handle_POST(self, request):\n        uri = request.path\n\n        # if POST on component uri, return 405\n        if self._is_comp_uri(uri):\n            return self._return_method_not_allowed()\n\n        # otherwise try to solve with payload\n        data = request.data\n        res, results = self.solve(uri=uri, payload=data)\n        if res:\n            response = self._prep_response()\n            response.data = results.encode(encoding=\"utf_8\")\n\n        # otherwise return 404\n        else:\n            response = self._prep_response(404, \"Execution Error\")\n            response.data = results.encode(encoding=\"utf_8\")\n\n        return response\n\n    def _is_solve_uri(self, uri):\n        return uri == HopsBase.SOLVE_ROUTE\n\n    def _is_comp_uri(self, uri):\n        return uri in self._components\n\n    def query(self, uri) -> Tuple[bool, str]:\n        \"\"\"Get information on given uri\"\"\"\n        # try to find a component registered for this uri\n        # returns one object {}\n        comp = self._components.get(uri, None)\n        if comp:\n            hlogger.debug(\"Getting component metadata: %s\", comp)\n            return True, self._get_comp_data(comp)\n\n        # try to find a collection of components in this uri\n        # returns list of objects [{},{},...]\n        comps = [c for c in self._components.values() if c.uri.startswith(uri)]\n        if comps:\n            hlogger.debug(\"Getting a list of all registered components\")\n            return True, self._get_comps_data(comps)\n\n        return False, self._return_with_err(\"Unknown Hops url\")\n\n    def solve(self, uri, payload) -> Tuple[bool, str]:\n        \"\"\"Perform Solve on given uri\"\"\"\n        if uri == HopsBase.ROOT_ROUTE:\n            hlogger.debug(\"Nothing to solve on root\")\n            return False, self._return_with_err(\"Nothing to solve on root\")\n\n        # FIXME: remove support for legacy solve behaviour\n        elif uri == HopsBase.SOLVE_ROUTE:\n            data = json.loads(payload)\n            comp_uri = data[\"pointer\"]\n            if not comp_uri.startswith(HopsBase.ROOT_ROUTE):\n                comp_uri = HopsBase.ROOT_ROUTE + comp_uri\n            for comp in self._components.values():\n                if comp_uri == comp.uri:\n                    hlogger.info(\"Solving using legacy API: %s\", comp)\n                    return self._process_solve_request(comp, payload)\n\n        # FIXME: test this new api\n        else:\n            comp = self._components.get(uri, None)\n            if comp:\n                hlogger.info(\"Solving: %s\", comp)\n                return self._process_solve_request(comp, payload)\n        return False, self._return_with_err(\"Unknown Hops component url\")\n\n    def _return_with_err(self, err_msg, res_dict=None):\n        err_res = res_dict\n        if err_res:\n            err = err_res.get(\"errors\", None)\n            if isinstance(err, list):\n                err.append(err_msg)\n            else:\n                err_res[\"errors\"] = [err_msg]\n        else:\n            err_res = {\"values\": [], \"errors\": [err_msg]}\n\n        return json.dumps(err_res, cls=_HopsEncoder)\n\n    def _return_method_not_allowed(self):\n        response = self._prep_response(405, \"Method Not Allowed\")\n        response.data = HopsBase.ERROR_PAGE_405.encode(encoding=\"utf_8\")\n        return response\n\n    def _get_all_comps_data(self):\n        # return json formatted string of all components metadata\n        return json.dumps(list(self._components.values()), cls=_HopsEncoder)\n\n    def _get_comps_data(self, comps):\n        # return json formatted string of all components metadata\n        return json.dumps(comps, cls=_HopsEncoder)\n\n    def _get_comp_data(self, comp):\n        # return json formatted string of component metadata\n        return json.dumps(comp, cls=_HopsEncoder)\n\n    def _prepare_icon(self, resource_path, icon_file_path):\n        # return icon data in base64 for embedding in http results\n        # determine possible icon paths\n        possible_icon_paths = []\n        if op.isabs(icon_file_path):\n            possible_icon_paths.append(icon_file_path)\n        else:\n            process_icon_file_path = op.join(os.getcwd(), icon_file_path)\n            possible_icon_paths.append(process_icon_file_path)\n            if resource_path:\n                sidecar_icon_file_path = op.join(resource_path, icon_file_path)\n                possible_icon_paths.append(sidecar_icon_file_path)\n\n        for icon_path in possible_icon_paths:\n            if op.exists(icon_path):\n                with open(icon_path, \"rb\") as image_file:\n                    base64_bytes = base64.b64encode(image_file.read())\n                    return base64_bytes.decode(\"ascii\")\n\n        hlogger.error(\n            \"Can not find icon file at %s\",\n            \", \".join(possible_icon_paths)\n        )\n\n    def _process_solve_request(self, comp, payload) -> Tuple[bool, str]:\n        # parse payload for inputs\n        res, inputs = self._prepare_inputs(comp, payload)\n        if not res:\n            hlogger.debug(\"Bad inputs: %s\", inputs)\n            return res, self._return_with_err(\"Bad inputs\")\n\n        # run\n        try:\n            solve_returned = self._solve(comp, inputs)\n            hlogger.debug(\"Return data: %s\", solve_returned)\n            res, outputs = self._prepare_outputs(comp, solve_returned)\n            return (\n                res,\n                outputs if res else self._return_with_err(\"Bad outputs\"),\n            )\n        except Exception as solve_ex:\n            # try to grab traceback data and create err msg\n            _, _, exc_traceback = sys.exc_info()\n            try:\n                fmt_tb = traceback.format_tb(exc_traceback)\n                # FIXME: can we safely assume we are only 2 levels in stack?\n                ex_msg = \"\\n\".join(fmt_tb[2:])\n                ex_msg = str(solve_ex) + f\"\\n{ex_msg}\"\n            except Exception:\n                # otherwise use exception str as msg\n                ex_msg = str(solve_ex)\n\n            hlogger.debug(\"Exception occured in handler: %s\", ex_msg)\n            return False, self._return_with_err(\n                \"Exception occured in handler:\\n%s\" % ex_msg\n            )\n\n    def _prepare_inputs(self, comp, payload) -> Tuple[bool, list]:\n        # parse input payload\n        data = json.loads(payload)\n\n        # grab input param data and value items\n        # FIXME: this works on a single branch only? [\"0\"][0]\n        param_values = {}\n        for item in data[\"values\"]:\n            param_values[item[\"ParamName\"]] = item\n\n        inputs = []\n        for in_param in comp.inputs:\n            if in_param.name not in param_values and not in_param.optional:\n                return (\n                    False,\n                    f\"Missing value for required input {in_param.name}\",\n                )\n            in_param_data = param_values[in_param.name]\n            value = in_param.from_input(in_param_data)\n            inputs.append(value)\n\n        if len(comp.inputs) != len(param_values):\n            return (\n                False,\n                \"Input count does not match number of inputs for component\",\n            )\n\n        return True, inputs\n\n    def _solve(self, comp, inputs):\n        return comp.handler(*inputs)\n\n    def _prepare_outputs(self, comp, returns) -> Tuple[bool, str]:\n        outputs = []\n        if not isinstance(returns, tuple):\n            returns = (returns,)\n        for out_param, out_result in zip(comp.outputs, returns):\n            output_data = out_param.from_result(out_result)\n            outputs.append(output_data)\n        payload = {\"values\": outputs}\n        hlogger.debug(\"Return payload: %s\", payload)\n        return True, json.dumps(payload, cls=_HopsEncoder)\n\n    def component(\n        self,\n        rule=None,\n        name=None,\n        nickname=None,\n        description=None,\n        category=None,\n        subcategory=None,\n        icon=None,\n        inputs=None,\n        outputs=None,\n    ):\n        \"\"\"Decorator for Hops middleware\"\"\"\n\n        def __func_wrapper__(comp_func):\n            # determine path of the caller file\n            # this is used for resource resolution\n            frame = inspect.stack()[1]\n            module = inspect.getmodule(frame[0])\n            resource_path = None\n            if module and module.__file__:\n                resource_path = op.dirname(module.__file__)\n\n            # register python func as Hops component\n            if inputs:\n                # inspect default parameters in function signature\n                f_sig = inspect.signature(comp_func)\n                f_params = f_sig.parameters.values()\n                if len(inputs) != len(f_params):\n                    raise Exception(\n                        \"Number of function parameters is \"\n                        \"different from defined Hops inputs\"\n                    )\n                # apply function param default values in order\n                # to defined Hops inputs. this will override any\n                # previously defined default values\n                for hinput, fparam in zip(inputs, f_params):\n                    if fparam.default != inspect.Parameter.empty:\n                        hinput.default = fparam.default\n\n            # determine name, and uri\n            comp_name = name or comp_func.__qualname__\n            uri = rule or f\"/{comp_name}\"\n            # grab icon data\n            icon_data = None\n            if icon:\n                icon_data = self._prepare_icon(resource_path, icon)\n            # create component instance\n            comp = HopsComponent(\n                uri=uri,\n                name=comp_name,\n                nickname=nickname,\n                desc=description or comp_func.__doc__,\n                cat=category or DEFAULT_CATEGORY,\n                subcat=subcategory or DEFAULT_SUBCATEGORY,\n                icon=icon_data,\n                inputs=inputs or [],\n                outputs=outputs or [],\n                handler=comp_func,\n            )\n            hlogger.debug(\"Component registered: %s\", comp)\n            # register by uri and solve uri, for fast lookup on query and solve\n            self._components[uri] = comp\n            self._components[comp.solve_uri] = comp\n            return comp_func\n\n        return __func_wrapper__\n\n\nclass _HopsEncoder(json.JSONEncoder):\n    \"\"\"Custom json encoder to properly encode RhinoCommon and Hops types\"\"\"\n\n    def default(self, o):\n        if hasattr(o, \"Encode\"):\n            return o.Encode()\n        elif hasattr(o, \"encode\"):\n            return o.encode()\n        return json.JSONEncoder.default(self, o)\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}