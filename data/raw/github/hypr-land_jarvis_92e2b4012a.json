{
  "source_url": "https://github.com/hypr-land/jarvis/blob/5ef9aa1eca9e49e5ae3be74d5ac27d487100c3c3/modules/intent_module.py",
  "repo": "hypr-land/jarvis",
  "repo_stars": 2,
  "repo_description": "jarvis, from iron man, just maybe worse?",
  "license": "NOASSERTION",
  "filepath": "modules/intent_module.py",
  "instruction": "intent_module.py\nJust there to exist",
  "code": "#!/usr/bin/env python3\n\"\"\"intent_module.py\nJust there to exist\n\nExample\n-------\n>>> from modules.intent_module import RhinoIntentRecognizer\n>>> def on_intent(inf):\n...     print(inf)\n>>> rec = RhinoIntentRecognizer(\n...     context_path=\"contexts/smart_lighting_linux.rhn\",\n...     access_key=\"<PICOVOICE_ACCESS_KEY>\",\n...     inference_callback=on_intent)\n>>> rec.start()  # will run until rec.stop() is called\n\nThe design purposefully keeps the public surface **very small**:\n    • start() / stop()\n    • is_running\n    • context_info / version properties\n    • Optional reset() \n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport threading\nimport struct\nfrom typing import Callable, Optional, Dict, Any\n\nimport pyaudio\n\ntry:\n    import pvrhino as rhino\n    RHINO_AVAILABLE = True\nexcept ImportError:  # pragma: no cover – runtime fallback\n    rhino = None  # type: ignore\n    RHINO_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\n\n\nInferenceDict = Dict[str, Any]\nInferenceCallback = Callable[[InferenceDict], None]\n\n\nclass RhinoIntentRecognizer:\n    \"\"\"Background microphone listener that emits Rhino inferences.\n\n    Parameters\n    ----------\n    context_path: str\n        Absolute path to the `.rhn` context file.\n    access_key: str\n        Picovoice *AccessKey* obtained from the console.\n    model_path: Optional[str]\n        Path to a non-default Rhino model (e.g. for other languages).\n    sensitivity: float, default 0.5\n        Trade-off between miss rate (0) and false alarms (1).\n    endpoint_duration_sec: float, default 1.0\n        Amount of trailing silence to detect endpoint.\n    require_endpoint: bool, default True\n        If *False* Rhino returns an inference even without silence.\n    audio_device_index: Optional[int]\n        PyAudio device index to use (None = system default).\n    inference_callback: Callable[[dict], None]\n        Callback invoked **from the background thread** whenever an\n        inference is finalised. Receives a dictionary with keys:\n            • is_understood: bool\n            • intent: str | None\n            • slots: dict[str, str]\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        context_path: str,\n        access_key: str,\n        model_path: Optional[str] = None,\n        sensitivity: float = 0.5,\n        endpoint_duration_sec: float = 1.0,\n        require_endpoint: bool = True,\n        audio_device_index: Optional[int] = None,\n        inference_callback: Optional[InferenceCallback] = None,\n    ) -> None:\n        if not RHINO_AVAILABLE:\n            raise ImportError(\n                \"pvrhino is not installed. Install with `pip install pvrhino`.\"\n            )\n\n        self._inference_cb = inference_callback or (lambda _: None)\n        self._running = False\n        self._thread: Optional[threading.Thread] = None\n\n        # Create Rhino handle\n        logger.info(\"Initialising Rhino (context=%s)…\", context_path)\n        self._rhino = rhino.create(\n            access_key=access_key,\n            context_path=context_path,\n            model_path=model_path,\n            sensitivity=sensitivity,\n            endpoint_duration_sec=endpoint_duration_sec,\n            require_endpoint=require_endpoint,\n        )\n\n        # PyAudio stream config\n        self._pa = pyaudio.PyAudio()\n        self._pa_stream = self._pa.open(\n            rate=self._rhino.sample_rate,\n            channels=1,\n            format=pyaudio.paInt16,\n            input=True,\n            frames_per_buffer=self._rhino.frame_length,\n            input_device_index=audio_device_index,\n        )\n\n    @property\n    def context_info(self) -> str:\n        \"\"\"Human-readable description of the loaded context.\"\"\"\n        return getattr(self._rhino, \"context_info\", \"\")\n\n    @property\n    def version(self) -> str:\n        \"\"\"Rhino library version string.\"\"\"\n        return getattr(self._rhino, \"version\", \"unknown\")\n\n    @property\n    def is_running(self) -> bool:  # noqa: D401 – property style\n        \"\"\"True while the background capture thread is active.\"\"\"\n        return self._running\n\n    def start(self) -> None:\n        \"\"\"Begin microphone capture and intent processing in background.\"\"\"\n        if self._running:\n            return\n        self._running = True\n        self._thread = threading.Thread(target=self._run, daemon=True)\n        self._thread.start()\n        logger.info(\"RhinoIntentRecognizer started\")\n\n    def stop(self) -> None:\n        \"\"\"Stop background capture and free resources.\"\"\"\n        self._running = False\n        if self._thread and self._thread.is_alive():\n            self._thread.join(timeout=2.0)\n        self._cleanup()\n        logger.info(\"RhinoIntentRecognizer stopped\")\n\n    def reset(self) -> None:\n        \"\"\"Reset internal Rhino state (discard current utterance).\"\"\"\n        try:\n            self._rhino.reset()\n        except Exception as exc:  # pragma: no cover\n            logger.warning(\"Rhino reset failed: %s\", exc)\n\n    def _run(self) -> None:  # pragma: no cover – IO loop\n        try:\n            while self._running:\n                pcm = self._pa_stream.read(\n                    self._rhino.frame_length, exception_on_overflow=False\n                )\n                pcm_int16 = struct.unpack_from(\n                    f\"{self._rhino.frame_length}h\", pcm\n                )\n                try:\n                    finalized = self._rhino.process(pcm_int16)\n                except Exception as exc:\n                    logger.error(\"Rhino process error: %s\", exc)\n                    continue\n\n                if finalized:\n                    try:\n                        inf = self._rhino.get_inference()\n                        data: InferenceDict = {\n                            \"is_understood\": inf.is_understood,\n                            \"intent\": inf.intent if inf.is_understood else None,\n                            \"slots\": inf.slots if inf.is_understood else {},\n                        }\n                        self._inference_cb(data)\n                    except Exception as exc:  # pragma: no cover – edge\n                        logger.error(\"Failed to fetch inference: %s\", exc)\n                    finally:\n                        # Prepare for next utterance\n                        self._rhino.reset()\n        except Exception as exc:  # pragma: no cover\n            logger.error(\"Rhino thread crashed: %s\", exc)\n        finally:\n            self._cleanup()\n\n    def _cleanup(self):\n        try:\n            if self._pa_stream is not None:\n                self._pa_stream.stop_stream()\n                self._pa_stream.close()\n            if self._pa is not None:\n                self._pa.terminate()\n            if self._rhino is not None:\n                try:\n                    self._rhino.delete()  # pyright: ignore [reportUnknownMemberType]\n                except AttributeError:\n                    pass ",
  "language": "python",
  "imports": [],
  "has_docstring": true
}