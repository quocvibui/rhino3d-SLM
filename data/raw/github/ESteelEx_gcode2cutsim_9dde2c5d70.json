{
  "source_url": "https://github.com/ESteelEx/gcode2cutsim/blob/95aa5678ec3848954cd855838198d3c5a8802a51/RhinoInterface/addPoints.py",
  "repo": "ESteelEx/gcode2cutsim",
  "repo_stars": 2,
  "repo_description": "- gcode 2 cutsim code for 3D Simulation with Verifier Engine",
  "license": "unknown",
  "filepath": "RhinoInterface/addPoints.py",
  "instruction": "Add points",
  "code": "import threading\n\ntry:\n    import Rhino\n    import rhinoscriptsyntax as rs\n    import scriptcontext\n    import math\n    import System.Guid, System.Array, System.Enum\n    from System.Drawing import *\n    from Rhino import *\n    from Rhino.DocObjects import *\n    from Rhino.DocObjects.Tables import *\n    from Rhino.Geometry import *\n    from Rhino.Input import *\n    from Rhino.Commands import *\n    from Rhino.UI.Dialogs import ShowColorDialog\n    from scriptcontext import doc\nexcept:\n    pass\n\n\n# ----------------------------------------------------------------------------------------------------------------------\ndef getRGBfromI(RGBint):\n    blue = RGBint & 255\n    green = (RGBint >> 8) & 255\n    red = (RGBint >> 16) & 255\n    return red, green, blue\n\n# ----------------------------------------------------------------------------------------------------------------------\ndef getIfromRGB(rgb):\n    red = rgb[0]\n    green = rgb[1]\n    blue = rgb[2]\n    RGBint = (red << 16) + (green << 8) + blue\n    return RGBint\n\n# ----------------------------------------------------------------------------------------------------------------------\ndef AddPolyline(points, layer, replace_id=None, objColor=(0, 0, 0), segment=''):\n    \"\"\"Adds a polyline to the current CAD scene\n    Parameters:\n      points = list of 3D points. Duplicate, consecutive points found in\n               the array will be removed. The array must contain at least\n               two points. If the array contains less than four points,\n               then the first point and the last point must be different.\n      replace_id[opt] = If set to the id of an existing object, the object\n                        will be replaced by this polyline\n    Returns:\n      id of the new curve object if successful\n    \"\"\"\n\n    points = rs.coerce3dpointlist(points, True)\n    if replace_id:\n        replace_id = rs.coerceguid(replace_id, True)\n\n    rc = System.Guid.Empty\n    if replace_id:\n        pl = Rhino.Geometry.Polyline(points)\n        plColor = Rhino.Input.Custom.GetObject.Color\n        if scriptcontext.doc.Objects.Replace(replace_id, pl):\n            rc = replace_id\n    else:\n        rc = Polyline(points)\n        attributes = ObjectAttributes()\n        attributes.ObjectColor = ColorTranslator.FromOle(getIfromRGB(objColor))\n        attributes.ColorSource = ObjectColorSource.ColorFromObject\n        zero_str = '000000'\n        objName = 'Layer: ' + zero_str[:-len(str(layer))] + str(layer) + ' ' + segment  # str(layer)\n        attributes.Name = objName\n        lIdx = scriptcontext.doc.Layers.Find('MW 3D Printer Perimeter', 1)\n        attributes.LayerIndex = lIdx\n        doc.Objects.AddPolyline(rc, attributes)\n\n    if rc == System.Guid.Empty:\n        raise Exception(\"Unable to add polyline to document\")\n\n    return rc\n\n# ----------------------------------------------------------------------------------------------------------------------\ndef proof_z_level_change(line, first_move_in_layer):\n    pass\n\n# ----------------------------------------------------------------------------------------------------------------------\nclass addPoints(threading.Thread):\n    def __init__(self, pluginPath, corePath):\n        self.pluginPath = pluginPath\n        self.corePath = corePath\n        self.INI_CONFIG = self.corePath + r'\\Mesh.ini'\n        self.runstat = True\n        self.segmentIdxDict = {}\n        self.colorDict = {'Wall': (0, 0, 0),\n                          'DenseInfill': (255, 0, 255),\n                          'SparseInfill': (0, 255, 255),\n                          'Brim': (230, 230, 230),\n                          'Skirt': (200, 230, 200),\n                          'Support': (250, 250, 250)}\n\n        threading.Thread.__init__(self)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    def run(self):\n        self.flush_data()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    def inject_runstat(self, status):\n        self.runstat = status\n\n    # ------------------------------------------------------------------------------------------------------------------\n    def flush_data(self):\n\n        print 'Adding polylines to CAD environment ... wait'\n\n        _FILE = self.corePath + r'\\Mesh.gcode'\n\n        pl = []  # polyline list\n        pc = []  # pointcloud list\n        poly_fail = 0\n\n        _add_point_cloud = False\n\n        _z_level_change = False\n        first_z_move_in_layer = True\n\n        # it is possible to define a layer range that is displayed in CAD\n        # default is layer 1 to end -> [1, -1]\n        layer_start = 0\n        layer_end = -1\n        _from_to_layer = [layer_start, layer_end]\n\n        _layer = 1\n        LayerPoints = {}\n        line_in_file = 0\n\n        end_of_file = False\n\n        # check if a previous calculation exists\n        if rs.IsLayer('MW 3D Printer PointCloud'):\n            if rs.IsLayer('MW 3D Printer PointCloud_OLD'):\n                rs.PurgeLayer('MW 3D Printer PointCloud_OLD')\n                rs.RenameLayer('MW 3D Printer PointCloud', 'MW 3D Printer PointCloud_OLD')\n                rs.LayerVisible('MW 3D Printer PointCloud_OLD', visible=False)\n            else:\n                rs.RenameLayer('MW 3D Printer PointCloud', 'MW 3D Printer PointCloud_OLD')\n                rs.LayerVisible('MW 3D Printer PointCloud_OLD', visible=False)\n            rs.AddLayer(name='MW 3D Printer PointCloud', visible=False)\n        else:\n            rs.AddLayer(name='MW 3D Printer PointCloud', visible=False)\n\n        if rs.IsLayer('MW 3D Printer Perimeter'):\n            if rs.IsLayer('MW 3D Printer Perimeter_OLD'):\n                rs.PurgeLayer('MW 3D Printer Perimeter_OLD')\n                rs.RenameLayer('MW 3D Printer Perimeter', 'MW 3D Printer Perimeter_OLD')\n                rs.LayerVisible('MW 3D Printer Perimeter_OLD', visible=False)\n            else:\n                rs.RenameLayer('MW 3D Printer Perimeter', 'MW 3D Printer Perimeter_OLD')\n                rs.LayerVisible('MW 3D Printer Perimeter_OLD', visible=False)\n            rs.AddLayer(name='MW 3D Printer Perimeter', visible=True)\n        else:\n            rs.AddLayer(name='MW 3D Printer Perimeter', visible=True)\n\n        # open G-Code\n        fid = open(_FILE, 'r')\n        # Begin G-Code processing\n        last_pos = []\n        last_pos.append(fid.tell())\n        for line in fid:\n            last_pos.append(fid.tell())\n            line_in_file += 1\n\n            if len(line) == 1:\n                continue\n\n            if self.runstat:  # external functions can inject a command to stop threading\n\n                # proof if there is a comment with layer information\n                if line.strip()[0] == ';':\n\n                    if line.find('gCode file finished') != -1:\n                        end_of_file = True\n\n                    if line.find('WARNING') == -1:  # if we do NOT find a WARNING\n                        split_line = line.split(',')\n                        _segment = split_line[0][1:].strip().rstrip()\n                        _backplot_width = split_line[0][1:].strip().rstrip()\n\n                        if _segment not in self.segmentIdxDict:\n                            self.segmentIdxDict[_segment] = 0\n\n                        segment = _segment + str(self.segmentIdxDict[_segment])\n                    else:\n                        pass\n                        # print 'WARNING'\n\n                # coordinates of G1 and G0 moves are processed\n                if line[0:3] == 'G1 ' or line[0:3] == 'G0 ':\n\n                    # filter z coordinates and proof if its the first inital or the next layer\n                    pos_Z = line.find('Z')\n                    if pos_Z != -1:\n                        pos_ws = line[pos_Z:].find(' ')\n                        if pos_ws == -1:\n                            Z = float(line[pos_Z + 1:])\n                        else:\n                            try:\n                                Z = float(line[pos_Z + 1:pos_ws + pos_Z + 1])\n                            except:\n                                Z = float(line[pos_Z + 1:pos_ws + pos_Z + 1])\n                        if first_z_move_in_layer:\n                            first_z_move_in_layer = False\n                        else:\n                            _z_level_change = True\n                            fid.seek(last_pos[-3])  # revert file position\n                            last_pos.pop()\n                            last_pos.pop()\n                            last_pos.pop()\n                            line_in_file = line_in_file - 2\n\n\n                    if not _z_level_change:\n                        # filter coordinates from G1 move\n                        if line[0:3] == 'G1 ':\n                            pos_X = line.find('X')\n                            if pos_X != -1:\n                                pos_ws = line[pos_X:].find(' ')\n                                X = float(line[pos_X+1:pos_ws+pos_X+1])\n\n                            pos_Y = line.find('Y')\n                            if pos_Y != -1:\n                                pos_ws = line[pos_Y:].find(' ')\n                                if pos_ws == -1:\n                                    Y = float(line[pos_Y + 1:])\n                                else:\n                                    Y = float(line[pos_Y + 1:pos_ws + pos_Y+1])\n\n                        # filter coordinates from G0 move\n                        elif line[0:3] == 'G0 ':\n                            pos_X = line.find('X')\n                            if pos_X != -1:\n                                pos_ws = line[pos_X:].find(' ')\n                                X_G0 = float(line[pos_X + 1:pos_ws + pos_X + 1])\n\n                            pos_Y = line.find('Y')\n                            if pos_Y != -1:\n                                pos_ws = line[pos_Y:].find(' ')\n                                if pos_ws == -1:\n                                    Y_G0 = float(line[pos_Y + 1:])\n                                else:\n                                    Y_G0 = float(line[pos_Y + 1:pos_ws + pos_Y + 1])\n\n                        # add coordinates to layer dictionary\n                        if _layer >= _from_to_layer[0]:\n                            if line[0:3] == 'G0 ':\n                                if _segment in self.segmentIdxDict:\n                                    self.segmentIdxDict[_segment] += 1\n                                else:\n                                    self.segmentIdxDict[_segment] = 0\n\n                                segment = _segment + str(self.segmentIdxDict[_segment])\n                                LayerPoints[segment] = [[X_G0, Y_G0, Z]]  # first point of next segment\n                            else:\n                                if len(LayerPoints) == 0:\n                                    LayerPoints[segment] = [[X, Y, Z]]\n                                else:\n                                    if segment in LayerPoints:\n                                        LayerPoints[segment].append([X, Y, Z])\n\n                # add lines and points to Rhino environment\n                if _z_level_change and self.runstat or end_of_file:\n\n                    try:\n                        if _layer >= _from_to_layer[0]:\n                            if len(LayerPoints) > 1:\n                                for segment, points in LayerPoints.iteritems():\n                                    if self.runstat:\n                                        if len(points) > 1:\n                                            try:\n                                                # .NET\n                                                try:\n                                                    int(segment[-1])\n                                                    lenIdx = 1\n                                                    int(segment[-2:])\n                                                    lenIdx = 2\n                                                    int(segment[-3:])\n                                                    lenIdx = 3\n                                                    int(segment[-4:])\n                                                    lenIdx = 4\n                                                except:\n                                                    pass\n\n                                                if segment[:-lenIdx] in self.colorDict:\n                                                    pl.append(AddPolyline(points,\n                                                                          _layer,\n                                                                          objColor=self.colorDict[segment[:-lenIdx]],\n                                                                          segment=segment))\n                                                else:\n                                                    pl.append(AddPolyline(points,\n                                                                          _layer,\n                                                                          objColor=(255, 0, 0),\n                                                                          segment=segment))\n\n                                                    # print 'Segment not found'\n\n                                                # add point cloud\n                                                if _add_point_cloud:\n                                                    pc.append(rs.AddPointCloud(points))\n\n                                            except:\n                                                raise\n                                                poly_fail += 1\n\n                        LayerPoints = {}  # clear point information from dict\n                        self.segmentIdxDict = {}  # clear segment counter dict\n                        _z_level_change = False\n                        _layer += 1\n                        first_z_move_in_layer = True\n\n                    except:\n                        raise\n                        pass\n\n                if _from_to_layer[1] != -1:\n                    if _layer == _from_to_layer[1]:\n                        break\n\n        scriptcontext.doc.Views.Redraw()\n        # rs.ObjectLayer(pl, layer='MW 3D Printer Perimeter')\n\n        print 'Flushing path data finished.'\n        print 'Polylines ignored: ' + str(poly_fail)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}