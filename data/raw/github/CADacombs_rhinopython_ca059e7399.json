{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_inflections.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_inflections.py",
  "instruction": "190703: Created.\r\n190707: Now, inflection points found within ModelAbsoluteTolerance of ends of curves are skipped.\r\n190708: Curves are now processed only as NurbsCurves.\r\n191010: Now, preselected...",
  "code": "\"\"\"\r\n190703: Created.\r\n190707: Now, inflection points found within ModelAbsoluteTolerance of ends of curves are skipped.\r\n190708: Curves are now processed only as NurbsCurves.\r\n191010: Now, preselected curves are immediately processed.\r\n191203: Modified number input in UI and modified printed output.\r\n191208: Modified output of getInflectionParameters for ArcCurves and LineCurves from None to [].\r\n191219: Bug fix that caused some curves to be deleted.  Modified some return value options of processCurve.\r\n200114: Replaced main routine to find maximums with code from McNeel.  (Search for 'github' for link.)\r\n        Same/similar code is supposed to be available in V7's RhinoCommon.\r\n        Refactored.\r\n200419: Bug fix.\r\n\r\nTODO:\r\nAdd code for and enable bIncludeEndsOfLinearSpans?  Add a linear tolerance?\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System.Collections.Generic import List\r\nfrom System.Drawing import Color\r\nfrom System import Guid\r\nfrom System import Math\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bIncludeEndsOfLinearSpans'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddPts'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSplitCrv'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDeleteInput'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"Get edges with optional input.\"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select curves\")\r\n    go.GeometryFilter = rd.ObjectType.Curve # Curve is also used for brep edges.\r\n    \r\n    go.AcceptNumber(True, True)\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        #key = 'bIncludeEndsOfLinearSpans'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bAddPts'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bSplitCrv'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        if Opts.values['bSplitCrv']:\r\n            key = 'bDeleteInput'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef getInflectionParameters(curve):\r\n    \"\"\"\r\n    Returns:\r\n        list(float(Parameters)) on success.\r\n        None on failure.\r\n    This is a translation and modification of code at\r\n    https://github.com/mcneel/rhino-developer-samples/blob/6/rhinocommon/cs/SampleCsCommands/SampleCsExtractInflectionPoints.cs\r\n    \"\"\"\r\n\r\n\r\n\r\n    def findInflection(nurb, t0, t1, k0, k1, epsilon):\r\n        \"\"\"\r\n        Returns:\r\n            Success: float(Parameter)\r\n            Failure: None\r\n        \"\"\"\r\n\r\n        if not nurb: return\r\n\r\n        t_Out = None\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            t = (t0 + t1) * 0.5\r\n            k = nurb.CurvatureAt(t)\r\n            if not k.IsValid:\r\n                break\r\n\r\n            if k.IsTiny() or t1 - t0 < epsilon:\r\n                t_Out = t\r\n                break\r\n\r\n            if k * k0 < 0.0:\r\n                t1 = t\r\n                k1 = k\r\n                continue\r\n\r\n            if k * k1 < 0.0:\r\n                t0 = t\r\n                k0 = k\r\n                continue\r\n\r\n            break\r\n\r\n        return t_Out\r\n\r\n\r\n\r\n    on_zero_tolerance = 2.3283064365386962890625e-10 # Why is this used instead of \r\n\r\n    nurb = curve.ToNurbsCurve()\r\n    if not nurb: return\r\n\r\n    count = nurb.Points.Count * 4\r\n    mul = 1.0 / count\r\n    epsilon = (on_zero_tolerance if nurb.Domain.Length > 1.0\r\n               else nurb.Domain.Length * on_zero_tolerance)\r\n\r\n    t0 = 0.0\r\n    k0 = rg.Vector3d.Unset\r\n    start_set = False\r\n    ts = []\r\n\r\n    for i in xrange(count+1):\r\n        t1 = nurb.Domain.ParameterAt(i * mul)\r\n        k1 = nurb.CurvatureAt(t1)\r\n        if k1.IsValid:\r\n            if k1.IsTiny(): continue\r\n\r\n            if not start_set:\r\n                t0 = t1\r\n                k0 = k1\r\n                start_set = True\r\n                continue\r\n\r\n            if k0 * k1 < 0.0:\r\n                t = findInflection(nurb, t0, t1, k0, k1, epsilon)\r\n                if t is not None: ts.Add(t)\r\n\r\n            k0 = k1\r\n            t0 = t1\r\n\r\n    return ts\r\n\r\n\r\ndef getInflectionPoints(curve):\r\n\r\n    ts = getInflectionParameters(curve)\r\n    if not ts: return ts\r\n\r\n    return [curve.PointAt(t) for t in ts]\r\n\r\n\r\ndef processCurves(curvesAndEdges0, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bIncludeEndsOfLinearSpans = getOpt('bIncludeEndsOfLinearSpans')\r\n    bAddPts = getOpt('bAddPts')\r\n    bSplitCrv = getOpt('bSplitCrv')\r\n    bDeleteInput = getOpt('bDeleteInput')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n    def splitCurve():\r\n        \"\"\"\r\n        Returns:\r\n            Success: list(GUIDs of curves from split), None\r\n            Fail: None, str(Failure)\r\n        \"\"\"\r\n        gCrvs_Split = []\r\n        rgNurbsCrvs2_Split = rgCrv0.Split(ts_Inflection)\r\n        rgCrv0.Dispose()\r\n        if rgNurbsCrvs2_Split is None:\r\n            return None, \"Curve could not be split.\"\r\n        if len(rgNurbsCrvs2_Split) == 1:\r\n            return None, \"Curve was split into just one curve.  Inflection point must be too close to an endpoint.\"\r\n        \r\n        attr0 = rdCrv0.Attributes if bDeleteInput else None\r\n        bFail = False\r\n        for rgCrv_Split in rgNurbsCrvs2_Split:\r\n            gCrv_Split = sc.doc.Objects.AddCurve(rgCrv_Split, attr0)\r\n            rgCrv_Split.Dispose()\r\n            if gCrv_Split != Guid.Empty:\r\n                gCrvs_Split.append(gCrv_Split)\r\n            else:\r\n                bFail = True\r\n        if not bFail:\r\n            sc.doc.Objects.Delete(gCrv0, quiet=False)\r\n            if bEcho: print \"Curve was successfully split into {}.\".format(len(rgNurbsCrvs2_Split))\r\n        else:\r\n            if bDeleteInput:\r\n                s  = \"Curve was not deleted because\"\r\n                s += \"not all split curves could be added.\"\r\n                print s\r\n            else:\r\n                print \"Not all split curves could be added to the document.\"\r\n        for rgCrv_Split in rgNurbsCrvs2_Split: rgCrv_Split.Dispose()\r\n        return gCrvs_Split, None\r\n\r\n\r\n    gCrvs0 = []\r\n    for curveOrEdge0 in curvesAndEdges0:\r\n        gCrv0 = rs.coerceguid(curveOrEdge0)\r\n        if gCrv0:\r\n            gCrvs0.append(gCrv0)\r\n    \r\n    gNcs_Split_perCrv0 = []\r\n    pts_Inflection_All = []\r\n    gPts_Inflection_Nested = []\r\n    \r\n    sFails = []\r\n    \r\n    idxs_AtTenths = [int(round(0.1*i*len(curvesAndEdges0),0)) for i in range(10)]\r\n\r\n    bEcho_inLoop = bEcho if len(curvesAndEdges0) == 1 else False\r\n    \r\n    for iC, curveOrEdge0 in enumerate(curvesAndEdges0):\r\n        if iC in idxs_AtTenths:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                    \"Processing curve {} ...\".format(\r\n                    \"\" if len(curvesAndEdges0) == 1 else \"{} of {} \".format(\r\n                        iC+1, len(curvesAndEdges0))))\r\n\r\n        rgCrv0 = rs.coercecurve(curveOrEdge0) # Will return various rg.Curves, including rg.BrepEdge.\r\n        if rgCrv0 is None:\r\n            sFails.append(\"Geometry not found for {}.\".format(curveOrEdge0))\r\n            continue\r\n\r\n        if isinstance(rgCrv0, rg.BrepEdge):\r\n            bDeleteInput = False\r\n        else:\r\n            gCrv0 = rs.coerceguid(curveOrEdge0)\r\n            rdCrv0 = rs.coercerhinoobject(curveOrEdge0)\r\n    \r\n        ts_Inflection = getInflectionParameters(rgCrv0)\r\n\r\n        if ts_Inflection is None:\r\n            s  = \"getInflectionParameters returned None\"\r\n            sFails.append(s)\r\n            s += \" for {}.\".format(curveOrEdge0)\r\n            s += \"  Bad input Curve?\"\r\n            if bEcho_inLoop: print s\r\n            continue\r\n    \r\n        if bEcho_inLoop:\r\n            print \"{} inflection(s) found.\".format(len(ts_Inflection))\r\n\r\n        if not ts_Inflection: continue\r\n\r\n        pts_Inflection = [rgCrv0.PointAt(t) for t in ts_Inflection]\r\n\r\n        pts_Inflection_All.extend(pts_Inflection)\r\n\r\n        if bAddPts:\r\n            gPts = []\r\n            for pt in pts_Inflection:\r\n                gPt = sc.doc.Objects.AddPoint(pt)\r\n                if gPt != Guid.Empty: gPts.append(gPt)\r\n            gPts_Inflection_Nested.append(gPts)\r\n\r\n        if bSplitCrv:\r\n            gNcs_Split, sFail = splitCurve()\r\n            if gNcs_Split: gNcs_Split_perCrv0.append(gNcs_Split)\r\n            if sFail: sFails.append(sFail)\r\n            gNcs_Split_perCrv0.append(gNcs_Split)\r\n\r\n        rgCrv0.Dispose()\r\n\r\n\r\n    if bEcho and len(curvesAndEdges0) > 1:\r\n        s = \"Out of {} curves selected:\".format(len(curvesAndEdges0))\r\n        for sFail in set(sFails):\r\n            s += \"\\n[{}] {}\".format(sFails.count(sFail), sFail)\r\n        if pts_Inflection_All:\r\n            s += \"\\n{} inflection point(s) found.\".format(pts_Inflection_All)\r\n        if gPts_Inflection_Nested:\r\n            s += \"\\n{} points added.\".format(\r\n                len(gNcs_Split_perCrv0), sum([len(gs) for gs in gNcs_Split_perCrv0]))\r\n        if gNcs_Split_perCrv0:\r\n            s += \"\\n{} curves were replaced with {}.\".format(\r\n                len(gNcs_Split_perCrv0), sum([len(gs) for gs in gNcs_Split_perCrv0]))\r\n        if not gNcs_Split_perCrv0:\r\n            s += \"\\nNo curves were added or replaced.\"\r\n        print s\r\n    \r\n    return gNcs_Split_perCrv0\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    objrefs = rc[0]\r\n    \r\n    if Opts.values['bDebug']:\r\n        pass\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    rc = processCurves(curvesAndEdges0=objrefs)\r\n    if not rc: return\r\n    \r\n    gNcs_Split_perCrv0 = rc\r\n    \r\n    if gNcs_Split_perCrv0:\r\n        for gs in gNcs_Split_perCrv0:\r\n            for g in gs:\r\n                sc.doc.Objects.Select(objectId=g)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}