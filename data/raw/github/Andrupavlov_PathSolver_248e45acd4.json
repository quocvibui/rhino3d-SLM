{
  "source_url": "https://github.com/Andrupavlov/PathSolver/blob/5f457d1db60473b4bd7e8fb0d7fbaa1237d869e5/PathSolver_PY/PathSolver.py",
  "repo": "Andrupavlov/PathSolver",
  "repo_stars": 4,
  "repo_description": "Rhinoceros + Grasshopper algorithm for the behavior of points on the surface of a 3D object.",
  "license": "GPL-3.0",
  "filepath": "PathSolver_PY/PathSolver.py",
  "instruction": "PathSolver-v0.03.3\n    Inputs:\n        SOLVER: type solver \"ByGravity\" or \"ByDirect\" (str)\n        START_POINT_LIST: start point for solver (Point3d: list)\n        MESH: one mash for solver (mesh)\n  ...",
  "code": "\"\"\" PathSolver-v0.03.3\n    Inputs:\n        SOLVER: type solver \"ByGravity\" or \"ByDirect\" (str)\n        START_POINT_LIST: start point for solver (Point3d: list)\n        MESH: one mash for solver (mesh)\n        -\n        START_VEC_PROJ: point projection direction vector\n                        at the start of the script (Vector3d: list)\n                        Default value = (0,0,-1)\n        START_VEC_DIR:  for \"ByDirect\". Starting direction for the\n                        salt pan in the mode (Vector3d: list)\n                        Default value = (1,0,0)\n        -\n        MOVE_DIST: moving a point relative to the normal to\n                   the mesh surface (float)\n                   Default value = 10\n        N_STEP: number of steps (int)\n                Default value = 300\n        MIN_RAY_DIST: for \"ByGravity\". minimum distance between\n                      points after which the execution will be stopped\n                      Default value = 0.0\n        MAX_RAY_DIST: for \"ByDirect\". Maximum distance between\n                      points after which the execution will be stopped\n                      Default value = 10.0\n        RUN: on/off script\n    Output:\n        wayPoints: path points (Point3d: list)\n        wayNormal: normal from every point on the surface (Vector3d: list)\n        wayOutsidePoints: point at the edge of the surface (Point3d: list)\n\"\"\"\n\n__author__ = \"AndriiPavlov\"\n__version__ = \"2022.09.14\"\n\n\nimport Rhino.Geometry as rg\nimport Rhino.UI as ui\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as gh\nimport ghpythonlib.treehelpers as th\nimport math as ma\n#import Rhino as r\n#import copy\n#import time\n#import System\n#import os\n\nif not SOLVER:\n    SOLVER = \"ByGravity\"\n\nif not START_VEC_PROJ:\n    START_VEC_PROJ = [rg.Vector3d(0,0,-1)]\n\nif not START_VEC_DIR:\n    START_VEC_DIR = [rg.Vector3d(1,0,0)]\n\nif not MOVE_DIST:\n    MOVE_DIST = 10\n\nif not N_STEP:\n    N_STEP = 300\n\nif not MIN_RAY_DIST:\n    MIN_RAY_DIST = 0.00\n\nif not MAX_RAY_DIST:\n    MAX_RAY_DIST = 10.0\n\n\ndef SameLengthList(list1, List2):\n    \"\"\"\n    Збільшує List2 до розміру List1\n    :param list1: - еталонний список\n    :param List2: - той шо треба збільшити\n    :return: - новій список\n    \"\"\"\n    temp = []\n    for i in range(len(list1)):\n        temp.append(List2[-1])\n    return temp\n\nif len(START_POINT_LIST) != len(START_VEC_PROJ) and len(START_VEC_PROJ) == 1:\n    START_VEC_PROJ = SameLengthList(START_POINT_LIST, START_VEC_PROJ)\n\nif len(START_POINT_LIST) != len(START_VEC_DIR) and len(START_VEC_DIR) == 1:\n    START_VEC_DIR = SameLengthList(START_POINT_LIST, START_VEC_DIR)\n\n\ndef pointDistans(p1, p2):\n    \"\"\"\n    Distance between points\n    :param p1: point #1\n    :param p2: point #2\n    :return: - distance\n    \"\"\"\n    return ma.sqrt((p1.X - p2.X)**2 + (p1.Y - p2.Y)**2 + (p1.Z - p2.Z)**2)\n\n\n\nclass Solver():\n\n    def __init__(self, startPoint, startVectorProj, startVectorDirection):\n        self.startPoint = startPoint\n        self.vecProj = startVectorProj\n        self.vecDirection = startVectorDirection\n\n        self.moveDist = MOVE_DIST\n        self.mesh = MESH\n        self.wayPointsList = []\n        self.wayOutsidePoints = []\n        self.wayNormal = []\n\n    def GetWayPointList(self):\n        return self.wayPointsList\n\n    def GetWayOutsidePoints(self):\n        return self.wayOutsidePoints\n\n    def GetWayNormal(self):\n        return self.wayNormal\n\n    def SetVecProj(self, vec):\n        self.vecProj = vec\n\n    def SetVecDirection(self, vec):\n        self.vecDirection = vec\n\n    def StepOne(self, point):\n        ray = rg.Intersect.Intersection.MeshRay(self.mesh, rg.Ray3d(point, self.vecProj))\n        rayPoint = rg.Point3d(point.X + self.vecProj.X * ray,\n                              point.Y + self.vecProj.Y * ray,\n                              point.Z + self.vecProj.Z * ray\n                              )\n        if ray < 0:\n            if self.wayPointsList:\n                self.wayOutsidePoints.append(self.wayPointsList[-1])\n            return None\n\n        if len(self.wayPointsList) > 2:\n            if pointDistans(rayPoint, self.wayPointsList[-1]) < MIN_RAY_DIST:\n                return None\n\n        self.wayPointsList.append(rayPoint)\n\n        meshPoint = self.mesh.ClosestMeshPoint(rayPoint, 100000.0)\n        normal = self.mesh.NormalAt(meshPoint)\n        normal.Unitize()\n\n        self.wayNormal.append(normal)\n\n        ptMoveBNormal = rg.Point3d(rayPoint.X + normal.X * self.moveDist,\n                                   rayPoint.Y + normal.Y * self.moveDist,\n                                   rayPoint.Z + normal.Z * self.moveDist\n                                   )\n        return ptMoveBNormal\n\n    def StepOneByDirect(self, point):\n        ray = rg.Intersect.Intersection.MeshRay(self.mesh, rg.Ray3d(point, self.vecProj))\n        rayPoint = rg.Point3d(point.X + self.vecProj.X * ray,\n                              point.Y + self.vecProj.Y * ray,\n                              point.Z + self.vecProj.Z * ray\n                              )\n        if ray < 0:\n            if self.wayPointsList:\n                self.wayOutsidePoints.append(self.wayPointsList[-1])\n            return None\n\n        # if len(self.wayPointsList) > 2:\n        #     if pointDistans(rayPoint, self.wayPointsList[-1]) < MIN_RAY_DIST:\n        #         return None\n\n        if len(self.wayPointsList) > 2:\n            if pointDistans(rayPoint, self.wayPointsList[-1]) >= MAX_RAY_DIST:\n                return None\n\n        self.wayPointsList.append(rayPoint)\n\n        meshPoint = self.mesh.ClosestMeshPoint(rayPoint, 100000.0)\n        normal = self.mesh.NormalAt(meshPoint)\n        normal.Unitize()\n        self.wayNormal.append(normal)\n\n        normalVecRev = rg.Vector3d(normal.X, normal.Y, normal.Z)\n        normalVecRev.Reverse()\n        self.SetVecProj(rg.Vector3d(normalVecRev.X,\n                                    normalVecRev.Y,\n                                    normalVecRev.Z\n                                    ))\n\n        normAndDir = rg.Vector3d(normal.X + self.vecDirection.X,\n                                 normal.Y + self.vecDirection.Y,\n                                 normal.Z + self.vecDirection.Z\n                                 )\n\n        normAndDir.Unitize()\n\n        ptMoveBNormal = rg.Point3d(rayPoint.X + normAndDir.X * self.moveDist,\n                                   rayPoint.Y + normAndDir.Y * self.moveDist,\n                                   rayPoint.Z + normAndDir.Z * self.moveDist\n                                   )\n\n        if len(self.wayPointsList) > 3:\n            tempPt_1 = self.wayPointsList[-1]\n            tempPt_2 = self.wayPointsList[-3]\n            self.SetVecDirection(rg.Vector3d(tempPt_1.X - tempPt_2.X,\n                                             tempPt_1.Y - tempPt_2.Y,\n                                             tempPt_1.Z - tempPt_2.Z\n                                             ))\n\n        return ptMoveBNormal\n\n    def SolverForMultiplePoints(self, startPt, nStep):\n        tempPt = startPt\n        for i in range(nStep):\n            if tempPt:\n                if SOLVER == \"ByGravity\":\n                    tempPt = self.StepOne(tempPt)\n                if SOLVER == \"ByDirect\":\n                    tempPt = self.StepOneByDirect(tempPt)\n            else:\n                break\n\n\n\n\nif RUN:\n    wayPoints = []\n    wayOutsidePoints = []\n    wayNormal = []\n\n    for i in range(len(START_POINT_LIST)):\n        solver = Solver(START_POINT_LIST[i], START_VEC_PROJ[i], START_VEC_DIR[i])\n        solver.SolverForMultiplePoints(START_POINT_LIST[i], N_STEP)\n\n        if len(solver.GetWayPointList()) > 0:\n            wayPoints.append(solver.GetWayPointList())\n            wayOutsidePoints.append(solver.GetWayOutsidePoints())\n            wayNormal.append(solver.GetWayNormal())\n\n    wayPoints = th.list_to_tree(wayPoints)\n    wayOutsidePoints = th.list_to_tree(wayOutsidePoints)\n    wayNormal = th.list_to_tree(wayNormal)\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}