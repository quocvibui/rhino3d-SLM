{
  "source_url": "https://github.com/SHLFab/shl-toolbox/blob/268349a38b254c507c73a5a12f81f05d8af3acfc/commands/shlCutTerrain.py",
  "repo": "SHLFab/shl-toolbox",
  "repo_stars": 1,
  "repo_description": "SHL Fabrication tools",
  "license": "AGPL-3.0",
  "filepath": "commands/shlCutTerrain.py",
  "instruction": "Shl cut terrain",
  "code": "import rhinoscriptsyntax as rs\nimport Rhino\nfrom scriptcontext import doc, sticky\nimport System as sys\n\nimport itertools\n\nimport shl_toolbox_lib.layers as wla\nreload(wla)\nimport shl_toolbox_lib.util as wut\nreload(wut)\nimport shl_toolbox_lib.rhino_util as wrh\nreload(wrh)\nimport shl_toolbox_lib.geo as wge\nreload(wge) \n\n\ndef set_globals():\n\tglobal SHORT_GUIDE, LONG_GUIDE\n\tglobal D_TOL, A_TOL\n\tD_TOL = doc.ActiveDoc.ModelAbsoluteTolerance\n\tA_TOL = doc.ActiveDoc.ModelAngleToleranceDegrees\n\t\n\tglobal LASER_GAP\n\tLASER_GAP = 4\n\t\n\tglobal THICKNESS, BORDER_THICKNESS, BORDER_BOOL\n\tglobal LCUT_INDICES\n\tglobal JOIN_ERROR, JOIN_DIST\n\tJOIN_ERROR = False\n\tJOIN_DIST = 0\n\n\ndef get_section_division(height,thickness):\n\tnum_sections = int(height/thickness)\n\tremainder = height%thickness\n\treturn [num_sections,remainder]\n\n\ndef get_section_planes(brep,thickness):\n\tbb = rs.BoundingBox(brep)\n\t\n\tstart_height = bb[0].Z\n\tend_height = bb[4].Z\n\txy_plane = rs.WorldXYPlane()\n\theights = wut.frange(start_height,end_height,thickness)\n\t\n\tplanes = [rs.MovePlane(xy_plane, [0,0,z]) for z in heights]\n\t\n\treturn planes\n\n\ndef get_section(brep,plane):\n\tg = Rhino.Geometry.Intersect.Intersection.BrepPlane(brep,plane,D_TOL)\n\treturn g[1]\n\n\ndef extrude_down_srf(srf,height=None):\n\t\"\"\"if no height input, extrude down by the bounding box height*2.\"\"\"\n\tif height == None:\n\t\tbb = rs.BoundingBox(srf)\t\n\t\theight = rs.Distance(bb[0],bb[4])*2\n\tif height < D_TOL:\n\t\treturn None\n\t\n\tpath_line = rs.AddLine([0,0,0],[0,0,-height])\n\txy_plane = rs.WorldXYPlane()\n\textruded_srf = rs.ExtrudeSurface(srf,path_line,True)\n\trs.DeleteObject(path_line)\n\treturn extruded_srf\n\n\ndef get_frame_brep(outline_srf,border_thickness,thickness):\n\t\"\"\"get the frame brep. This is a solid that is booleaned with the slices of\n\tterrain to make a border when border mode is on.\"\"\"\n\tedge_crvs = rs.DuplicateEdgeCurves(outline_srf)\n\toutline_crv = rs.JoinCurves(edge_crvs)\n\tpt, _ = rs.CurveAreaCentroid(outline_crv)\n\tinner_crv = rs.OffsetCurve(outline_crv,pt,border_thickness,[0,0,1])\n\trs.MoveObjects([outline_crv,inner_crv],[0,0,thickness*2])\n\t\n\tpath_line = rs.AddLine([0,0,0],[0,0,-thickness*4])\n\tinner_brep = rs.ExtrudeCurve(inner_crv,path_line)\n\touter_brep = rs.ExtrudeCurve(outline_crv,path_line)\n\trs.CapPlanarHoles(inner_brep)\n\trs.CapPlanarHoles(outer_brep)\n\t\n\tframe_brep = rs.BooleanDifference([outer_brep],[inner_brep])\n\trs.DeleteObjects([outline_crv,inner_crv])\n\trs.DeleteObjects(edge_crvs)\n\trs.DeleteObject(path_line)\n\treturn frame_brep\n\n\ndef get_lowest_curve_info(brep, h_tol):\n\t#currently hardcoded to not deal with multiple breps at the final step. to revise if needed.\n\tbdims = wge.get_bounding_dims(brep)\n\tRhino.Geometry.Brep.MergeCoplanarFaces(brep,D_TOL)\n\tbrep_faces = wge.get_extreme_srf(brep, h_tol,False)\n\n\tcrvs_by_brep = []\n\n\tfor f in brep_faces:\n\t\tcrvs = []\n\t\tinds = f.AdjacentEdges()\n\t\tfor i in inds:\n\t\t\tk = brep.Edges\n\t\t\tcrvs.append(brep.Edges[i])\n\t\tcrvs = Rhino.Geometry.Curve.JoinCurves(crvs,D_TOL)\n\tcrvs_by_brep.append(crvs)\n\n\tcrvs_by_brep = crvs_by_brep[0] #to fix this later. only deals w one brep for now\n\tlist_curves = []\n\tfor pc in crvs_by_brep:\n\t\tif pc.GetType() != Rhino.Geometry.PolyCurve:\n\t\t\tpc = wru.polylinecurve_to_polycurve(pc)\n\n\t\twge.make_pcurve_ccw(pc)\n\t\tlist_curves.append(pc)\n\n\treturn [list_curves,bdims]\n\n\ndef get_breps_on_layer(layername):\n\tbuildings = rs.ObjectsByLayer(layername)\n\tbreps = []\n\tfor b in buildings:\n\t\tif rs.ObjectType(b) == 16 or rs.ObjectType(b) == 1073741824: breps.append(b)\n\treturn breps\n\n\ndef get_curves_on_layer(layername):\n\tobjs = rs.ObjectsByLayer(layername)\n\tcrvs = []\n\tfor o in objs:\n\t\tif rs.ObjectType(o) == 4: crvs.append(o)\n\treturn crvs\n\n\ndef get_building_booleans(building_breps,planes):\n\t\"\"\"make slices of the building that will be booleaneddifferenced out of the\n\tterrain slices.\"\"\"\n\tif not building_breps:\n\t\treturn None\n\t\n\tbldg_intersection_boolean_breps = []\n\tbldg_intersection_breps = []\n\t\n\tsections = []\n\t#get the sections organized by level\n\tfor i, plane in enumerate(planes):\n\t\tsections_level = []\n\t\tfor b in building_breps:\n\t\t\tplane_sections = get_section(rs.coercebrep(b),plane)\n\t\t\tif not plane_sections: continue\n\t\t\telse: sections_level.append(plane_sections)\n\t\tsections.append(sections_level)\n\t\n\t#extrude the sections organized by level\n\tboolean_breps = []\n\tfor i,level in enumerate(sections):\n\t\tboolean_breps_level = []\n\t\tfor section in level:\n\t\t\tpb = Rhino.Geometry.Brep.CreatePlanarBreps(section)\n\t\t\tpb = pb[0]\n\t\t\tsrf_added = wrh.add_brep_to_layer(pb,LCUT_IND[4])\n\t\t\tb = rs.ExtrudeSurface(srf_added,SHORT_GUIDE)\n\t\t\tcentroid, _ = rs.SurfaceAreaCentroid(b)\n\t\t\tb = rs.ScaleObject(b,centroid,[1.0,1.0,1.5])\n\t\t\t#rs.ObjectLayer(b,\"s7\")\n\t\t\tboolean_breps_level.append(b)\n\t\t\trs.DeleteObject(srf_added)\n\t\t\t\n\t\tboolean_breps.append(boolean_breps_level)\n\t\n\treturn boolean_breps\n\n\ndef get_building_footprints(building_breps,planes):\n\t\"\"\"extract the footprints from the buildings\"\"\"\n\t#rs.EnableRedraw()\n\tplane_sections = []\n\tslice_depth = []\n\tfor b in building_breps:\n\t\tfor i,p in enumerate(planes):\n\t\t\ts = get_section(rs.coercebrep(b),p)\n\t\t\tif s:\n\t\t\t\tplane_sections.append(s[0])\n\t\t\t\tslice_depth.append(i)\n\t\t\t\tbreak\n\t\n\tfor section,d in zip(plane_sections,slice_depth):\n\t\tk = wrh.add_curve_to_layer(section,1)\n\t\t#rs.ObjectLayer(k,\"Default\")\n\t\t#print section\n\tm = zip(plane_sections,slice_depth)\n\tnew_boolean_list = []\n\tfor item in m:\n\t\tif item[1] > 0:\n\t\t\ttransformation = Rhino.Geometry.Transform.Translation(rs.coerce3dvector([0,0,-THICKNESS]))\n\t\t\tnew_crv = item[0].Transform(transformation)\n\t\t\tnew_level = item[1] - 1\n\t\t\tnew_boolean_list.append((new_crv,new_level))\n\t\telse:\n\t\t\tnew_boolean_list.append(item)\n\t\n\ta,b = zip(*new_boolean_list)\n\t#for section,d in zip(a,b):\n\t#\tprint section, d\n\t\t\n\t#rs.Redraw()\n\t#rs.EnableRedraw(False)\n\treturn\n\n\ndef cut_building_volumes(terrain_section_breps,bldg_section_breps):\n\t\"\"\"\n\tinput: list of lists of extruded terrain breps and section breps.\n\tfirst level of list is section heights, second level is breps.\n\toutput: the new terrain breps\n\t\"\"\"\n\t#boolean problem is caused by non-manifold error. need to scale the B_breps prior to booleaning.\n\tnew_terrain_section_breps = []\n\tfor i,brep_level in enumerate(terrain_section_breps):\n\t\tnew_level_terrain_section_breps = []\n\t\tfor A_brep in brep_level:\n\t\t\t#rs.ObjectLayer(A_brep,\"s10\") #debug\n\t\t\tB_breps = rs.CopyObjects(bldg_section_breps[i])\n\t\t\t#[rs.ObjectLayer(B_brep,\"s11\") for B_brep in B_breps] #debug\n\t\t\tboolean_result = rs.BooleanDifference([A_brep],B_breps,False)\n\t\t\tif boolean_result:\n\t\t\t\tc = [rs.CopyObject(x) for x in boolean_result]\n\t\t\t\trs.DeleteObjects(boolean_result)\n\t\t\t\tnew_level_terrain_section_breps.extend(c)\n\t\t\telse: \n\t\t\t\tnew_level_terrain_section_breps.append(rs.CopyObject(A_brep))\n\t\t\t#print new_level_terrain_section_breps\n\t\t\trs.DeleteObjects(A_brep)\n\t\t\trs.DeleteObjects(B_breps)\n\t\trs.DeleteObjects(B_breps) #possibly not needed\n\t\trs.DeleteObjects(boolean_result)\n\t\t#rs.ObjectLayer(new_level_terrain_section_breps,\"s3\")\n\t\tnew_terrain_section_breps.append(new_level_terrain_section_breps)\n\treturn new_terrain_section_breps\n\n\ndef project_etching(etch_crvs,surfaces):\n\tif not etch_crvs:\n\t\treturn []\n\t\n\tpc = rs.ProjectCurveToSurface(etch_crvs,surfaces,[0,0,-1])\n\tif pc:\n\t\treturn pc\n\telse:\n\t\treturn []\n\n\ndef rc_getinput():\n\t\n\tgo = Rhino.Input.Custom.GetObject()\n\tgo.GeometryFilter = Rhino.DocObjects.ObjectType.Brep\n\t\n\tdefault_thickness = sticky[\"Thickness\"] if sticky.has_key(\"Thickness\") else 2\n\tdefault_borderThickness = sticky[\"borderThickness\"] if sticky.has_key(\"borderThickness\") else 10\n\tdefault_borderBool = sticky[\"borderBool\"] if sticky.has_key(\"borderBool\") else False\n\t\n\topt_thickness = Rhino.Input.Custom.OptionDouble(default_thickness,0.2,1000)\n\topt_borderthickness = Rhino.Input.Custom.OptionDouble(default_borderThickness,0.2,1000)\n\topt_border = Rhino.Input.Custom.OptionToggle(default_borderBool,\"No\",\"Yes\")\n\t\n\tgo.SetCommandPrompt(\"Select terrain surface. (Note: Border Mode is in beta and may fail)\")\n\tgo.AddOptionDouble(\"MaterialThickness\", opt_thickness)\n\tgo.AddOptionDouble(\"BorderThickness\",opt_borderthickness)\n\tgo.AddOptionToggle(\"Border\", opt_border)\n\t\n\tgo.GroupSelect = True\n\tgo.SubObjectSelect = False\n\tgo.AcceptEnterWhenDone(True)\n\tgo.EnableClearObjectsOnEntry(False)\n\tgo.EnableUnselectObjectsOnExit(False)\n\tgo.GroupSelect = True\n\tgo.SubObjectSelect = False\n\tgo.DeselectAllBeforePostSelect = False\n\t\n\tres = None\n\tbHavePreselectedObjects = False\n\t\n\twhile True:\n\t\tres = go.Get()\n\t\t#If new option entered, redraw a possible result\n\t\tif res == Rhino.Input.GetResult.Option:\n\t\t\tgo.EnablePreSelect(False, True)\n\t\t\tcontinue\n\t\t#If not correct\n\t\telif res != Rhino.Input.GetResult.Object:\n\t\t\treturn Rhino.Commands.Result.Cancel\n\t\tif go.ObjectsWerePreselected:\n\t\t\tbHavePreselectedObjects = True\n\t\t\tgo.EnablePreSelect(False, True)\n\t\t\tcontinue\n\t\tbreak\n\t\n\t#rs.EnableRedraw(False)\n\tglobal THICKNESS\n\tTHICKNESS = opt_thickness.CurrentValue\n\tglobal BORDER_THICKNESS\n\tBORDER_THICKNESS = opt_borderthickness.CurrentValue\n\tglobal BORDER_BOOL\n\tBORDER_BOOL = opt_border.CurrentValue\n\tglobal LCUT_INDICES\n\tLCUT_INDICES = wla.get_lcut_layers()\n\t\n\t#set guides\n\tglobal SHORT_GUIDE, LONG_GUIDE\n\tSHORT_GUIDE = rs.AddLine([0,0,0],[0,0,-THICKNESS])\n\tLONG_GUIDE = rs.AddLine([0,0,0],[0,0,-THICKNESS*4])\n\trs.LockObjects([SHORT_GUIDE,LONG_GUIDE])\n\t\n\t#set layers\n\tglobal LCUT_IND\n\tLCUT_IND = wla.get_lcut_layers()\n\t\n\t#get topography object\n\tbrep_obj = go.Object(0).Object()\n\t\n\tsticky[\"Thickness\"] = THICKNESS\n\tsticky[\"borderThickness\"] = BORDER_THICKNESS\n\tsticky[\"borderBool\"] = BORDER_BOOL\n\t\n\trs.LockObject(brep_obj.Id)\n\tbuilding_brep_guids = rs.GetObjects(\"Select breps representing buildings\",filter=16)\n\tengraving_crv_guids = rs.GetObjects(\"Select curves to engrave on terrain\",filter=4)\n\trs.UnlockObject(brep_obj.Id)\n\t\n\treturn brep_obj,building_brep_guids,engraving_crv_guids\n\n\ndef get_surface_outline(b_geo):\n\t\"\"\"get the surface outline and project to the surface's baseplane.\"\"\"\n\tinitial_boundary_guids = []\n\tinitial_boundary_crv = []\n\tbb = rs.BoundingBox(b_geo)\n\tproj_plane = Rhino.Geometry.Plane.WorldXY\n\tproj_plane.Translate(rs.coerce3dvector([0,0,bb[0].Z]))\n\tfor e in b_geo.Edges:\n\t\tinitial_boundary_crv.append(Rhino.Geometry.Curve.ProjectToPlane(e.EdgeCurve,proj_plane))\n\tjoined_boundary_crv = Rhino.Geometry.Curve.JoinCurves(initial_boundary_crv,D_TOL)\n\tif len(joined_boundary_crv) == 1:\n\t\treturn joined_boundary_crv\n\telse:\n\t\tprint \"Script Error: more than one surface boundary outline. Please save this file and report error.\"\n\t\treturn None\n\n\ndef cut_frame_from_brep(brep,frame):\n\tbdiff = rs.BooleanDifference(brep,frame,False)\n\tif bdiff:\n\t\trs.DeleteObject(brep)\n\t\tbrep = bdiff\n\treturn brep\n\n\ndef rc_terraincut2(b_obj,building_guids,etching_guids):\n\t\n\tjoin_dist = 0\n\tif str(b_obj.ObjectType) != \"Brep\":\n\t\tb_geo = extrusion_to_brep(b_obj.Geometry)\n\telse:\n\t\tb_geo = b_obj.Geometry\n\t\n\toutline_crv = get_surface_outline(b_geo)\n\t#wrh.add_curves_to_layer(outline_crv,1)\n\t\n\t#extrude down the topography surface in order to take sections\n\tbool_merged = Rhino.Geometry.Brep.MergeCoplanarFaces(b_geo,D_TOL)\n\textruded_srf_id = extrude_down_srf(wrh.docobj_to_guid(b_obj))\n\textruded_srf = rs.coercebrep(extruded_srf_id)\n\t\n\t#get planes for sectioning.\n\tplanes = get_section_planes(b_geo,THICKNESS)\n\t\n\t#get the section curves and the section srfs\n\t#rs.Redraw()\n\tsection_srfs = []\n\tfor i,plane in enumerate(planes):\n\t\t#print i\n\t\t#if first level, get brep outline\n\t\tif i > 0:\n\t\t\tplane_sections = get_section(extruded_srf,plane)\n\t\telse:\n\t\t\tplane_sections = outline_crv\n\t\t###DEBUG STARTS####\n\t\tcurrent_level_srfs = []\n\t\tfor crv in plane_sections:\n\t\t\tclosed = crv.IsClosed\n\t\t\tif not closed:\n\t\t\t\tdist = rs.Distance(crv.PointAtStart, crv.PointAtEnd)\n\t\t\t\tres = crv.MakeClosed(dist*2)\n\t\t\t\tjoin_dist = dist if dist > join_dist else join_dist\n\t\t\t\tif res == False: return 0\n\t\t\tnew_brep = Rhino.Geometry.Brep.CreatePlanarBreps(crv)[0]\n\t\t\tcurrent_level_srfs.append(new_brep)\n\t\t\t#new_brep_added = doc.Objects.AddBrep(new_brep)\n\t\t\t#rs.ObjectLayer(new_brep_added,\"s15\")\n\t\t###DEBUG ENDS###\n\t\tsection_srfs.append(current_level_srfs)\n\trs.DeleteObject(extruded_srf_id)\n\t\n\t#get extrusions of section srfs\n\textruded_section_breps = []\n\tboolean_section_breps = []\n\tframe_base_surface = None\n\tfor i,brep_level in enumerate(section_srfs):\n\t\textruded_breps = []\n\t\tfor brep in brep_level:\n\t\t\tsrf_added = wrh.add_brep_to_layer(brep,LCUT_IND[2])\n\t\t\tif i == 0: frame_base_surface = rs.CopyObject(srf_added)\n\t\t\textruded_breps.append(rs.ExtrudeSurface(srf_added,SHORT_GUIDE))\n\t\t\trs.DeleteObject(srf_added)\n\t\textruded_section_breps.append(extruded_breps)\n\t\n\t#rs.Redraw()\n\t#make voids for existing buildings\n\tbuilding_breps = building_guids\n\tbldg_subtraction_breps = get_building_booleans(building_breps,planes)\n\tif bldg_subtraction_breps:\n\t\textruded_section_breps = cut_building_volumes(extruded_section_breps,bldg_subtraction_breps)\n\t\t[rs.DeleteObjects(x) for x in bldg_subtraction_breps] #purge the building breps\n\t\n\tnum_divisions = len(section_srfs)\n\tframe_brep = get_frame_brep(frame_base_surface,BORDER_THICKNESS,THICKNESS*num_divisions)\n\trs.DeleteObject(frame_base_surface)\n\t#boolean out the features\n\tfinal_breps = []\n\tfor i, brep_level in enumerate(extruded_section_breps):\n\t\tboolean_level_ind = i+2\n\t\tfinal_level_breps = []\n\t\tif boolean_level_ind < len(extruded_section_breps):\n\t\t\tfor A_brep in brep_level:\n\t\t\t\tfinal_brep = None\n\t\t\t\tB_breps = []\n\t\t\t\tfor B_srf in section_srfs[boolean_level_ind]:\n\t\t\t\t\tB_breps.append(rs.ExtrudeSurface(B_srf,LONG_GUIDE))\n\t\t\t\t#truncate the B_breps\n\t\t\t\tif BORDER_BOOL: B_breps = [cut_frame_from_brep(b,frame_brep) for b in B_breps]\n\t\t\t\t#rs.AddLayer(\"debug6\",[50,200,50]) #debug\n\t\t\t\t#rs.ObjectLayer(B_breps,\"debug6\")\n\t\t\t\t#handle a bug creating lists of lists sometimes.\n\t\t\t\tif isinstance(B_breps[0],(list,)): B_breps = B_breps[0]\n\t\t\t\tboolean_result = rs.BooleanDifference([A_brep],B_breps,False)\n\t\t\t\trs.DeleteObjects(B_breps)\n\t\t\t\tif boolean_result:\n\t\t\t\t\tfinal_brep = boolean_result\n\t\t\t\telse:\n\t\t\t\t\tfinal_brep = rs.CopyObjects([A_brep])\n\t\t\t\trs.DeleteObjects([A_brep])\n\t\t\t\t#rs.ObjectLayer(B_breps,\"debug6\")\n\t\t\t\t#rs.AddLayer(\"s11\",[200,200,50]) #debug\n\t\t\t\t#rs.ObjectLayer(final_brep,\"s11\") #debug\n\t\t\t\tfinal_level_breps.extend(final_brep)\n\t\telse:\n\t\t\t#rs.ObjectLayer(A_brep,\"s11\")\n\t\t\tfinal_level_breps.extend(brep_level)\n\t\tfinal_breps.append(final_level_breps)\n\t\n\t#get the final surfaces by iterating through the final section breps and extracting the top faces.\n\tfinal_srfs = []\n\tfor i,breplevel in enumerate(final_breps):\n\t\tfinal_srfs_level = []\n\t\tfor brep in breplevel:\n\t\t\txsrf = wge.get_extreme_srf(rs.coercebrep(brep),5)\n\t\t\tfinal_srfs_level.append(doc.Objects.Add(xsrf[0].DuplicateFace(False))) #must properly type the faces\n\t\t#rs.ObjectLayer(final_srfs_level,\"s4\")\n\t\tfinal_srfs.append(final_srfs_level)\n\t\n\t[rs.DeleteObjects(x) for x in final_breps] #DEBUG\n\t#project etching layers to final srfs\t\n\tfinal_srfs.reverse()\n\t\n\t#get the boundary curves\n\tmain_curves = []\n\tguide_curves = []\n\tetch_curves = []\n\tfor i, srflevel in enumerate(final_srfs):\n\t\tmain_curves_level = []\n\t\tguide_curves_level = []\n\t\tetch_curves_level = []\n\t\t\n\t\tfor srf in srflevel:\n\t\t\tsb = rs.DuplicateSurfaceBorder(srf)\n\t\t\tsb_outer = rs.DuplicateSurfaceBorder(srf,1)\n\t\t\tif sb:\n\t\t\t\tmain_curves_level.extend(sb)\n\t\t\tif i < len(final_srfs)-1 and sb_outer:\n\t\t\t\t\tp = rs.ProjectCurveToSurface(sb_outer, final_srfs[i+1],[0,0,-1])\n\t\t\t\t\tif p: guide_curves_level.extend(p)\n\t\t\t\t\trs.DeleteObject(sb_outer)\n\t\t\tif sb_outer: rs.DeleteObject(sb_outer) #refactor...\n\t\tetch_curves_level = project_etching(etching_guids,srflevel)\n\t\t\n\t\tetch_curves.append(etch_curves_level)\n\t\tmain_curves.append(main_curves_level)\n\t\tguide_curves.append(guide_curves_level)\n\t\n\tflat_srf_list = [item for sublist in final_srfs for item in sublist]\n\t\n\tetch_curves.reverse()\n\tmain_curves.reverse()\n\tguide_curves.reverse()\n\t\n\tbb=rs.BoundingBox(b_geo)\n\tlayout_dist = rs.Distance(bb[0],bb[3]) + LASER_GAP\n\tpreview_dist = rs.Distance(bb[0],bb[1]) + LASER_GAP\n\tmovement_range = [(i+1)*layout_dist for i in xrange(len(main_curves))]\n\tfor i,level_list in enumerate(main_curves):\n\t\tcp_main = rs.CurvePlane(level_list[0])\n\t\trs.MoveObjects(level_list,[0,movement_range[i],-cp_main.OriginZ])\n\t\t\n\t\tif etch_curves[i]:\n\t\t\trs.MoveObjects(etch_curves[i],[0,movement_range[i],-cp_main.OriginZ])\n\t\t\n\t\tif i>0:\n\t\t\tcp_guide = rs.CurvePlane(guide_curves[i][0])\n\t\t\trs.MoveObjects(guide_curves[i],[0,movement_range[i-1],-cp_guide.OriginZ])\n\t\n\tmain_curves = [item for sublist in main_curves for item in sublist]\n\tguide_curves = [item for sublist in guide_curves for item in sublist]\n\tetch_curves = [item for sublist in etch_curves for item in sublist]\n\t\n\tpreview_geo = [item for sublist in final_srfs for item in sublist]\n\trs.MoveObjects(preview_geo,[preview_dist,0,0])\n\t\n\t#close the boundary curves\n\tcb_crvs = []\n\tfor c in guide_curves:\n\t\tif not rs.IsCurveClosed(c):\n\t\t\tif rs.IsCurveClosable(c,D_TOL):\n\t\t\t\tcb_curves.append(rs.CloseCurve(rs.CopyObject(c)))\n\t\telse:\n\t\t\tcb_crvs.append(rs.CopyObject(c))\n\t\n\tetch_curves = wge.trim_boundary(etch_curves,cb_crvs,D_TOL)\n\trs.DeleteObjects(cb_crvs)\n\trs.DeleteObject(frame_brep)\n\t\n\trs.ObjectLayer(main_curves,\"XXX_LCUT_01-CUT\")\n\trs.ObjectLayer(guide_curves,\"XXX_LCUT_03-LSCORE\")\n\trs.ObjectLayer(etch_curves,\"XXX_LCUT_04-ENGRAVE\")\n\trs.ObjectLayer(preview_geo,\"XXX_LCUT_00-GUIDES\")\n\tif join_dist > 0:\n\t\ts = \"Had to force-close gaps up to a distance of \" + str(join_dist)\n\t\tRhino.RhinoApp.WriteLine(s)\n\treturn 1\n\n\nif __name__ == \"__main__\":\n\tset_globals()\n\tresult = rc_getinput()\n\t\n\tif isinstance(result, Rhino.Commands.Result):\n\t\tprint \"Invalid Input: no surface selected\"\n\telse:\n\t\tsurface_geometry = result[0]\n\t\tb = result[1]\n\t\te = result[2]\n\t\trs.EnableRedraw(False)\n\t\tresult = rc_terraincut2(surface_geometry, b, e)\n\t\tif result == 0:\n\t\t\tprint \"ERROR: topography slicing error. Try rebuilding the input surface with more control points and trying again.\"\n\t\trs.EnableRedraw(True)\n\t\trs.UnlockObjects([SHORT_GUIDE,LONG_GUIDE])\n\t\trs.DeleteObjects([SHORT_GUIDE,LONG_GUIDE])\n\t\trs.Redraw()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}