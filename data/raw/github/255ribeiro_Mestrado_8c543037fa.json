{
  "source_url": "https://github.com/255ribeiro/Mestrado/blob/07e9939e80a3217834a7cd6707bda1bf5fb46389/python/Algoritmo%20de%20gera%C3%A7%C3%A3o%20dos%20eixos.py",
  "repo": "255ribeiro/Mestrado",
  "repo_stars": 0,
  "repo_description": "Arquivos da Dissertação de Mestrado",
  "license": "unknown",
  "filepath": "python/Algoritmo de geração dos eixos.py",
  "instruction": "Algoritmo de geração dos eixos",
  "code": "﻿from __future__ import division\n#importando bibliotecas do Rhinoceros:\n#Rhino Common, rhinoscriptsintax e ghpythonlib\nfrom Rhino.Geometry import Point3d, Line, NurbsCurve\nimport rhinoscriptsyntax as rs\nimport ghpythonlib.components as gh\n\ndef EixosVigas(BZ,DiagN,d1,od1,d2,od2):\n    #----Diagnoais----\n    #dividir o banzo superior 1 em 2 x (numero de diagonais de v)\n    ptB1 = rs.DivideCurve(BZ,(2*DiagN))\n    #a variável EPcurv armazena o start point do eixo do banzo superior\n    SPCurv = ptB1[0]\n #exclui o primeiro valor da lista (start point da curva do banzo superior)\n    ptB1 = ptB1[1:]\n    #pAux é o ponto de partida do eixo do banzo inferior\n    pAux = gh.Move(Point3d(SPCurv),-d2*eY)[0]\n    #Offsets da curva do banzo sup nas distancias d1 e d2\n    cAux1 = rs.OffsetCurve(BZ,od1,d1,eZ)\n    cAux2 = rs.OffsetCurve(BZ,od2,d2,eZ)\n    #-aplicando mascara binária\n    #ptB1 = lista dos nós do banzo sup\n    ptB1 = gh.Dispatch(ptB1,[False,True,False,False])[0]\n    # iniciando lista dos nós do bazo infeirior\n    apoio=pAux\n    ptB2=[pAux]\n    #-calculando nós do banzo inferior\n    #contador FOR do primeiro ao penultimo item de ptb1\n    for i in range(len(ptB1)-1):\n    #desenha linhas etrne o ponto atual e próximo ponto de ptB1\n        linAux = Line(ptB1[i],ptB1[i+1])\n    #pAux = ponto médio de linAux\n        pAux3 = linAux.PointAt(.5)\n    #calcula ponto em cAux1 mais proximo de pAux\n    #pAux1 =[(coordenadas do pto),(parametro do pto),(distância pto-crv)]\n        pAux1 = gh.CurveClosestPoint(pAux3,rs.coercecurve(cAux1))\n        #idem - cAux2\n        #pAux2 = idem\n        pAux2 = gh.CurveClosestPoint(pAux3,rs.coercecurve(cAux2))\n        #linha entre os pontos equivalentes das curvas cAux1 e cAux2\n        linAux2 = Line(pAux2[0],pAux1[0])\n        #cAux3 = cAux1 cortada (trim) no ponto pAux1\n        cAux3= rs.TrimCurve(cAux1,(0,pAux1[1]),False)\n    #razão entre o comprimento da curva cAux1 até o ponto pAux1\n    #e o compriento total de cAux1\n        prmt = rs.CurveLength(cAux3)/rs.CurveLength(cAux1)\n        #ponto que interpola as alturas VH1 e VH2\n        pAux =linAux2.PointAt(prmt)\n        #coloca o pto pAux na lista dos nós \n        ptB2.append(pAux)\n #o ponto final do banzo inferior é colocado no final da lista ptB2\n    ptB2.append(rs.CurveEndPoint(cAux1))\n    #-ajuste do ultimo ponto da treliça\n    nosD = gh.Weave([0,1],ptB2,ptB1)\n    \n    if DiagN%2 == 0:\n        ptB1.append(rs.CurveEndPoint(BZ))\n    else:\n        del nosD[-1]\n    #desenha diagonais\n    lDiag = rs.AddPolyline(nosD)\n    \n    #desenha banzo inferior\n    bzInf = rs.AddPolyline(ptB2)\n    #desenha banzo superior\n    bzSup=rs.AddPolyline(ptB1)\n    return lDiag,bzSup,bzInf,nosD,ptB1,ptB2,apoio\n\ndef EixosShed(BZ,DiagN,pto):\n    \n    #----Shed----\n    #dividir o banzo superior 1 em 2 x (numero de diagonais de v3)\n    ptB1 = rs.DivideCurve(BZ,(DiagN))\n    \n    #exclui o primeiro valor da lista (start point da curva do banzo superior)\n    if DiagN%2==0:\n        mask = [True,False]\n    else:\n        SPCurv=ptB1[0]\n        mask = [False,True]\n    #calcula ponto em cAux1 mais proximo de pAux\n    #pAux =[(coordenadas do pto),(parametro do pto),(distância pto-crv)]\n    pAux = gh.CurveClosestPoint(pto,BZ)\n    #Offsets da curva do banzo sup no ponto pto\n    cAux1 = rs.OffsetCurve(BZ,pto,pAux[2])\n\n    #c.append(rs.coercecurve(cAux1))\n    #-aplicando mascara binária\n    #ptB1 = lista dos nós do banzo sup\n    ptB1 = gh.Dispatch(ptB1,mask)[0]\n    ptB2=[pto]\n    #-calculando nós do banzo inferior\n    #contador FOR do primeiro ao penultimo item de ptb1\n    for i in range(len(ptB1)-1):\n    #desenha linhas etrne o ponto atual e próximo ponto de ptB1\n        linAux = Line(ptB1[i],ptB1[i+1])\n    #pAux = ponto médio de linAux\n        pAux3 = linAux.PointAt(.5)\n    #calcula ponto em cAux1 mais proximo de pAux\n    #pAux1 =[(coordenadas do pto),(parametro do pto),(distância pto-crv)]\n        pAux1 = gh.CurveClosestPoint(pAux3,rs.coercecurve(cAux1))\n        #idem - cAux2\n        #pAux2 = idem\n        pAux2 = gh.CurveClosestPoint(pAux3,BZ)\n        #linha entre os pontos equivalentes das curvas cAux1 e cAux2\n        linAux2 = Line(pAux1[0],pAux2[0])\n        #a.append(linAux2)\n        #cAux2 = cAux1 cortada (trim) no ponto pAux1\n        cAux2= rs.TrimCurve(cAux1,(0,pAux1[1]),False)\n    #razão entre o comprimento da curva cAux1 até o ponto pAux1\n    #e o compriento total de cAux1\n        prmt = rs.CurveLength(cAux2)/rs.CurveLength(cAux1)\n        #ponto que interpola as alturas VH1 e VH2\n        pAux =linAux2.PointAt(prmt*.75)\n        #coloca o pto pAux na lista dos nós \n        ptB2.append(pAux)\n    #-desenhando diagonais e banzo inf\n    #combina lista dos nós, inferiores e superiores\n    #ordenados na sequancia das diagonais\n    nosD = gh.Weave([0,1],ptB2,ptB1)\n    if  DiagN%2==0:\n        del nosD[0]\n    else:\n        ptB1.insert(0,SPCurv)\n    \n    #desenha diagonais\n    lDiag = rs.AddPolyline(nosD)\n    #desenha banzo Superior\n    bzSup = rs.AddPolyline(ptB1)\n    #desenha banzo inferior\n    bzInf = rs.AddPolyline(ptB2)\n    return  lDiag,bzSup,bzInf,nosD,ptB1,ptB2,\n    \n\n#-Listas de saida\n#criando listas globais vazias para os outputs\nDiagonais=[]\nBanzo_Sup=[]\nBanzo_Inf=[]\nEixos_do_Conector=[]\nApoios=[]\nCobertura=[]\n\n#variavel de tolerância\ntol=.0001\n\n####--MAIN--####\n\n\n#atribuindo valores as variáveis opcionais\nif not HV2:\n    HV2=HV1\nif not HV3:\n    HV3=HV1\nif not DiagV2:\n    DiagV2=DiagV1\nif not DiagV3:\n    DiagV3=9\nif not No_Shed:\n    No_Shed = 2\nif not Plano:\n    Plano = rs.WorldXYPlane()\n\n#decompoe o plano de trabalho nos componentes Origem e os eixos xyz\npOr, eX, eY, eZ = Plano\n\n\n#-Copiando Curva inicial\nCurva = rs.CopyObjects(Curva,10*eY)\nBzSup1 = rs.coercecurve(Curva)\n\n#----Primeiro ponto do Eixo de Simetria----\n#A variável Eixo_de_Simetria por entrada um float entre o e 1 ou\n#uma reta que intercepta a Curva no ponto do eixo\n#caso seja um float:\nif type(Eixo_de_Simetria) == float:\n    #ptX1 = coordenadas da curva no ponto de interceção com o eixo de simetria\n    #vct1 = tangente da curva no ponto\n    #prm1 = parametro da curva no ponto\n    ptX1, vtc1, prm1 = gh.EvaluateLength(BzSup1,Eixo_de_Simetria,True)\n    ptAux = gh.Move(ptX1,-eY)[0]\n    #-desenhando linha do Exio de simetria\n    Eixo_de_Simetria = rs.AddLine(ptX1,ptAux)\n#caso seja uma linha\nelif str(type(Eixo_de_Simetria))== \"<type 'Guid'>\":\n    #ptX1 = coordenadas do ponto de interceção da Curva com o eixo de simetria\n    #prm1 = parametro da curva no ponto\n    #count = conta o número de interceções\n    ptX1,prm1,count = gh.CurveXLine(BzSup1,rs.coerceline(Eixo_de_Simetria))\n    ptAux = gh.Move(ptX1,-eY)[0]\n#caso o vão da viga seja definido pela variavel VigaDist\nif VigaDist:\n    ptobase = rs.CurveStartPoint(Curva)\n    ptoAux = rs.LineClosestPoint(Eixo_de_Simetria, ptobase)\n    dist1 = rs.Distance(ptobase,ptoAux)\n    escala = (VigaDist/2)/dist1\n    escala=[escala,escala,escala]\n    Curva,Eixo_de_Simetria = rs.ScaleObjects((Curva,Eixo_de_Simetria),ptobase,escala)\n    #ptX1 = coordenadas do ponto de interceção da Curva com o eixo de simetria\n    #prm1 = parametro da curva no ponto\n    #count = conta o número de interceções\n    BzSup1 = rs.coercecurve(Curva)\n    ptX1,prm1,count = gh.CurveXLine(BzSup1,rs.coerceline(Eixo_de_Simetria))\n    ptAux = gh.Move(ptX1,-eY)[0]\n#desenha um seguimento no eixo de simetria da treliça\nlAux=rs.coerceline(Eixo_de_Simetria)\ncAux = rs.OffsetCurve(BzSup1,ptAux,HV1,eZ)\nptX2 = gh.CurveXLine(rs.coercecurve(cAux),lAux)[0]\n#eixo do conector\nEixoSimetria = rs.AddLine(ptX1,ptX2)\nEixos_do_Conector.append(EixoSimetria)\n#----Linhas auxiliares dos Banzos Superiores----\n#Ponto de corte (trim) do banzo sup. de V1\n#ptY1 = [ponto,parametro,dist]\nptY1,paramY1,distY1 = gh.CurveClosestPoint(ptX2,BzSup1)\n#corte (trim) do banzo sup v1\nBS1 = rs.TrimCurve(BzSup1,[0,paramY1],False)\nBS1 = rs.coercecurve(BS1)\n#-espelhando (mirror) eixo sup de v1\n#plano de espelhamento\nmirplano = rs.PlaneFromNormal(ptX1, eX,eZ)\n#BS2 = eixo banzo sup de v2\nBS2 = gh.Mirror(rs.coercecurve(BS1),mirplano)[0]\n#cortando a curva incicial no eixo de simetria\nBS3 = rs.TrimCurve(BzSup1,[prm1,0],False)\nBS3 = rs.coercecurve(BS3)\n#bordas do conector\nptY2 = (rs.CurveEndPoint(BS2))\nNos_do_Conector = [ptX1,ptY1,ptX2,ptY2]\nconect = rs.AddPolyline(Nos_do_Conector+Nos_do_Conector[:1])\nEixos_do_Conector.append(conect)\n#eixos da viga v1\nDiag1, BzS1, BzI1, nDiag1, nBs1, nBi1, apoio1= EixosVigas(BS1,DiagV1,HV1,ptX2,HV2,ptX2)\nV1 =[BzS1,Diag1,BzI1]\nApoios.append(apoio1)\n#eixos da viga v2\nDiag2, BzS2, BzI2, nDiag2, nBs2, nBi2, apoio2 = EixosVigas(BS2,DiagV2,HV1,ptX2,HV3,ptX2)\nV2 =[BzS2,Diag2,BzI2]\nApoios.append(apoio2)\n#eixos do shed (viga v3)\nDiag3, BzS3, BzI3, nDiag3, nBs3, nBi3 = EixosShed(BS3,DiagV3,ptY2,)\nV3 =[BzS3,Diag3,BzI3]\n#saida Eixos\nEixos = V1 + V2 + V3 + Eixos_do_Conector\n#---checando se a treliça e estaticamente estavel\n#numero de barras das vigas + 5 barras do conetor\nnBarras = len(rs.ExplodeCurves((BzI1,BzI2,BzI3,BzS1,BzS2,BzS3,Diag1,Diag2,Diag3)))+5\n#número de nos na treliça - 2 nós pertencententes a 2 banzos\nnNos = len(nBs1+nBs2+nBs3+nBi1+nBi2+nBi3)-2\n#testando determinação estática\nif (nNos*2)-3 == nBarras:\n    print 'Treliça Estaticamente Determinada'\n#Mostrando númerod e nós e de barras\nprint 'Número de Nos = ', nNos\nprint 'Número de Barras = ', nBarras\n#--- desenhando cobertura\ncob1 = rs.OffsetCurve(BzSup1,ptX2,-.2,eZ)\ncob1 = rs.coercecurve(cob1)\nCobertura.append(cob1)\n#abertura do shed\nif No_Shed >= len(nBs2):\n    No_Shed = len(nBs2)\ncob2 = rs.OffsetCurve(BS2,ptX2,-.2,eZ)\nptShed = rs.CurveClosestPoint(cob2,nBs2[-No_Shed])\ncob2 = rs.TrimCurve(cob2,[0,ptShed],False)\nCobertura.append(cob2)\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}