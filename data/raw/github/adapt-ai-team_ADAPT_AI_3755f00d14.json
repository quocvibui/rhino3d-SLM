{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/mesh_simplify.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/mesh_simplify.py",
  "instruction": "Mesh simplify",
  "code": "import rhino3dm\nimport os\n\ntry:\n    import pymeshlab\nexcept ImportError:\n    raise ImportError(\"pymeshlab is not installed. Install it with 'pip install pymeshlab'.\")\n\n# Input and output paths\ninput_3dm = r\"D:\\ADAPT_AI\\spz_analysis2\\merged_model (3).3dm\"  # <- Replace with your 3DM file path\noutput_obj = r\"D:\\ADAPT_AI\\spz_analysis2\\merged_model (3)_allmeshes_with_simplified.obj\"\noutput_glb = r\"D:\\ADAPT_AI\\spz_analysis2\\merged_model (3)_allmeshes_with_simplified.glb\"\ntarget_faces = 2500\n\n# Load .3dm file and get the last mesh\nmodel = rhino3dm.File3dm.Read(input_3dm)  # type: ignore  # rhino3dm uses dynamic bindings\n# Find all meshes\nall_meshes = [obj.Geometry for obj in model.Objects if type(obj.Geometry).__name__ == \"Mesh\"]\n\nif not all_meshes:\n    raise RuntimeError(\"No mesh found in .3dm file\")\n\n# Print stats about all meshes\nprint(\"Mesh face counts in the .3dm file:\")\nfor idx, m in enumerate(all_meshes):\n    print(f\"  Mesh {idx+1}: {len(m.Faces)} faces\")\n\nmesh = all_meshes[-1]  # Simplify only the last mesh\noriginal_face_count = len(mesh.Faces)\n# More aggressive simplification: target 2% of original, but at least 200 faces, at most 500\nsimplification_ratio = 0.04\ncalculated_target = max(200, min(1500, int(original_face_count * simplification_ratio)))\ntarget_faces = calculated_target\nprint(f\"\\nSimplifying the last mesh (Mesh {len(all_meshes)}) with {original_face_count} faces.\")\nprint(f\"Target face count for simplification: {target_faces}\")\n\n# Extract vertices and faces\nvertices = [(v.X, v.Y, v.Z) for v in mesh.Vertices]\nfaces = []\n\nfor f in mesh.Faces:\n    if len(f) == 4:\n        faces.append([f[0], f[1], f[2]])\n        faces.append([f[0], f[2], f[3]])\n    elif len(f) == 3:\n        faces.append([f[0], f[1], f[2]])\n\n# Write temporary .obj\ntemp_obj = \"temp.obj\"\nwith open(temp_obj, \"w\") as f:\n    for v in vertices:\n        f.write(f\"v {v[0]} {v[1]} {v[2]}\\n\")\n    for face in faces:\n        f.write(f\"f {face[0]+1} {face[1]+1} {face[2]+1}\\n\")  # OBJ is 1-indexed\n\n# Load with PyMeshLab and simplify, clean, and smooth\nms = pymeshlab.MeshSet()  # type: ignore\nms.load_new_mesh(temp_obj)\n\n# First pass: moderate reduction\nms.meshing_decimation_quadric_edge_collapse(\n    targetfacenum=20000,\n    preservenormal=True,\n    preserveboundary=True,\n    preservetopology=True,\n    planarquadric=True\n)\n# Second pass: aggressive reduction\nms.meshing_decimation_quadric_edge_collapse(\n    targetfacenum=10000,\n    preservenormal=True,\n    preserveboundary=True,\n    preservetopology=True,\n    planarquadric=True\n)\nprint(\"Decimation complete.\")\n\n# Clean mesh: remove duplicate faces, unreferenced vertices\nms.meshing_remove_duplicate_faces()\nms.meshing_remove_unreferenced_vertices()\n# Try to remove isolated pieces if available\nif hasattr(ms, 'meshing_remove_isolated_pieces'):\n    ms.meshing_remove_isolated_pieces(mincomponentsize=10)\nprint(\"Cleaning complete.\")\n\n# Smooth mesh (try Taubin, then Laplacian if available)\nsmoothed = False\nif hasattr(ms, 'meshing_taubin_smooth'):\n    ms.meshing_taubin_smooth()\n    smoothed = True\nif hasattr(ms, 'meshing_laplacian_smooth'):\n    ms.meshing_laplacian_smooth(iterations=2)\n    smoothed = True\nif smoothed:\n    print(\"Smoothing complete.\")\nelse:\n    print(\"No smoothing filter available.\")\n\n# Recompute normals for better shading\nif hasattr(ms, 'compute_normals_for_faces'):\n    ms.compute_normals_for_faces()\n    print(\"Normals recomputed.\")\n\n# Export simplified mesh to temp OBJ\nsimplified_obj = \"temp_lastmesh_simplified.obj\"\nms.save_current_mesh(simplified_obj)\n\n# Read back the simplified mesh for merging\nwith open(simplified_obj, \"r\") as f:\n    lines = f.readlines()\n\n# Prepare OBJ parts\nobj_parts = []\nvertex_offset = 0\nfor idx, m in enumerate(all_meshes):\n    if idx == len(all_meshes) - 1:\n        part = [f\"o mesh_{idx+1}_simplified\\n\"]\n        v_count = 0\n        for line in lines:\n            if line.startswith(\"v \"):\n                part.append(line)\n                v_count += 1\n        for line in lines:\n            if line.startswith(\"f \"):\n                # Only use the vertex index before any '/' (OBJ can be v/vt/vn)\n                nums = [int(n.split('/')[0]) for n in line.strip().split()[1:]]\n                nums = [n + vertex_offset for n in nums]\n                part.append(f\"f {' '.join(str(n) for n in nums)}\\n\")\n        obj_parts.extend(part)\n        vertex_offset += v_count\n        # Print comparison\n        simplified_face_count = sum(1 for line in lines if line.startswith(\"f \"))\n        print(f\"Simplified mesh face count: {simplified_face_count}\")\n        print(f\"Reduction: {original_face_count} -> {simplified_face_count} faces (target: {target_faces})\")\n    else:\n        vertices = [(v.X, v.Y, v.Z) for v in m.Vertices]\n        faces = []\n        for f in m.Faces:\n            if len(f) == 4:\n                faces.append([f[0], f[1], f[2]])\n                faces.append([f[0], f[2], f[3]])\n            elif len(f) == 3:\n                faces.append([f[0], f[1], f[2]])\n        part = [f\"o mesh_{idx+1}\\n\"]\n        for v in vertices:\n            part.append(f\"v {v[0]} {v[1]} {v[2]}\\n\")\n        for face in faces:\n            part.append(f\"f {face[0]+1+vertex_offset} {face[1]+1+vertex_offset} {face[2]+1+vertex_offset}\\n\")\n        obj_parts.extend(part)\n        vertex_offset += len(vertices)\n\n# Write combined OBJ\nwith open(output_obj, \"w\") as f:\n    f.writelines(obj_parts)\nprint(f\"Combined OBJ with all original meshes and the simplified last mesh saved as {output_obj}\")\n\n# Optionally convert to GLB\ntry:\n    import trimesh\n    mesh = trimesh.load(output_obj)\n    mesh.export(output_glb)\n    print(f\"Converted mesh saved as {output_glb}\")\nexcept ImportError:\n    print(\"trimesh is not installed. To convert OBJ to GLB, run:\\n  pip install trimesh\\nThen use:\\n  import trimesh; mesh = trimesh.load('your.obj'); mesh.export('your.glb')\")\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}