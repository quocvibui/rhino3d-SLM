{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/solar_new.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/solar_new.py",
  "instruction": "Solar new",
  "code": "import rhino3dm\nimport numpy as np\nimport trimesh\nimport matplotlib.pyplot as plt\nimport math\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom ladybug.analysisperiod import AnalysisPeriod\nfrom ladybug.dt import DateTime\nfrom ladybug_geometry.geometry3d.mesh import Mesh3D\nfrom ladybug_geometry.geometry3d.pointvector import Point3D\nimport os\nimport multiprocessing as mp\nfrom tqdm import tqdm\nimport tempfile\nimport requests\nimport argparse\nimport logging\nfrom typing import List, Tuple, Optional\nimport pymeshlab\n\n# --- Logging Setup ---\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- Helper Functions ---\ndef resolve_path(relative_path: str) -> str:\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(script_dir, relative_path)\n\ndef get_local_path(path_or_url: str, suffix: str) -> str:\n    if path_or_url.startswith('http://') or path_or_url.startswith('https://'):\n        logger.info(f\"Downloading {path_or_url} ...\")\n        response = requests.get(path_or_url)\n        response.raise_for_status()\n        tmp = tempfile.NamedTemporaryFile(delete=False, suffix=suffix)\n        tmp.write(response.content)\n        tmp.close()\n        logger.info(f\"Downloaded to {tmp.name}\")\n        return tmp.name\n    else:\n        return path_or_url\n\ndef sample_sun_positions(sunpath: Sunpath, months, days, hours, minutes) -> List:\n    positions = []\n    for month in months:\n        for day in days:\n            for hour in hours:\n                for minute in minutes:\n                    dt = DateTime(month, day, hour, minute)\n                    sun = sunpath.calculate_sun_from_date_time(dt)\n                    if sun.altitude > 0:\n                        positions.append(sun)\n    return positions\n\ndef triangulate_and_color_mesh(mesh: Mesh3D, colors: Optional[List[List[int]]], default_color=[180,180,180,200]) -> trimesh.Trimesh:\n    vertices_np = np.array([[v.x, v.y, v.z] for v in mesh.vertices])\n    triangulated_faces = []\n    adjusted_colors = []\n    for i, face in enumerate(mesh.faces):\n        if len(face) == 3:\n            triangulated_faces.append(list(face))\n            adjusted_colors.append(colors[i] if colors is not None else default_color)\n        elif len(face) == 4:\n            triangulated_faces.append([face[0], face[1], face[2]])\n            triangulated_faces.append([face[0], face[2], face[3]])\n            if colors is not None:\n                adjusted_colors.append(colors[i])\n                adjusted_colors.append(colors[i])\n            else:\n                adjusted_colors.append(default_color)\n                adjusted_colors.append(default_color)\n    faces_np = np.array(triangulated_faces)\n    tri_mesh = trimesh.Trimesh(vertices=vertices_np, faces=faces_np)\n    tri_mesh.visual.face_colors = adjusted_colors\n    return tri_mesh\n\ndef process_meshes(meshes: List) -> Tuple[List[Tuple[float, float, float]], List[List[int]]]:\n    all_vertices = []\n    all_faces = []\n    vertex_offset = 0\n    for rhino_mesh in meshes:\n        vertices = [(pt.X, pt.Y, pt.Z) for pt in rhino_mesh.Vertices]\n        mesh_faces = []\n        for face in rhino_mesh.Faces:\n            if len(face) == 4:\n                mesh_faces.append([face[0] + vertex_offset, face[1] + vertex_offset, face[2] + vertex_offset, face[3] + vertex_offset])\n            else:\n                mesh_faces.append([face[0] + vertex_offset, face[1] + vertex_offset, face[2] + vertex_offset])\n        all_vertices.extend(vertices)\n        all_faces.extend(mesh_faces)\n        vertex_offset += len(vertices)\n    return all_vertices, all_faces\n\ndef create_ladybug_mesh(vertices: List[Tuple[float, float, float]], faces: List[List[int]]) -> Mesh3D:\n    lb_vertices = [Point3D(*vertex) for vertex in vertices]\n    lb_faces = []\n    for face in faces:\n        if len(face) == 4 and face[2] != face[3]:\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], lb_vertices[face[2]], lb_vertices[face[3]]])\n        else:\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], lb_vertices[face[2]]])\n    return Mesh3D.from_face_vertices(lb_faces)\n\ndef calculate_radiation_vectorized(face_normals, sun_positions, solar_data) -> np.ndarray:\n    sun_vectors = np.array([(-1 * s.sun_vector_reversed).to_array() for s in sun_positions])\n    solar_data = np.array(solar_data[:len(sun_vectors)])\n    normals_np = np.array([[n.x, n.y, n.z] for n in face_normals])\n    dot_products = np.dot(normals_np, sun_vectors.T)\n    angle_factors = np.maximum(0, dot_products)\n    radiation_matrix = angle_factors * solar_data\n    total_radiation = np.sum(radiation_matrix, axis=1)\n    return total_radiation\n\ndef validate_solar_analysis(radiation_values: List[float], lb_mesh: Mesh3D):\n    logger.info(\"\\n=== VALIDATION CHECKS ===\")\n    north_facing = []\n    south_facing = []\n    for i, normal in enumerate(lb_mesh.face_normals):\n        if normal.y < -0.7:\n            north_facing.append(radiation_values[i])\n        elif normal.y > 0.7:\n            south_facing.append(radiation_values[i])\n    if north_facing and south_facing:\n        north_avg = sum(north_facing) / len(north_facing)\n        south_avg = sum(south_facing) / len(south_facing)\n        north_south_ratio = north_avg / south_avg if south_avg > 0 else 0\n        logger.info(f\"North-facing surfaces avg radiation: {north_avg:.1f}\")\n        logger.info(f\"South-facing surfaces avg radiation: {south_avg:.1f}\")\n        logger.info(f\"North/South ratio: {north_south_ratio:.2f} (should be < 1.0)\")\n        logger.info(f\"Plausibility: {'GOOD' if north_south_ratio < 0.8 else ' SUSPICIOUS'}\")\n    logger.info(f\"Radiation range: {min(radiation_values):.1f} - {max(radiation_values):.1f} kWh/m²\")\n    expected_min_val = 100\n    expected_max_val = 2000\n    logger.info(f\"Range check: {'GOOD' if min(radiation_values) > expected_min_val and max(radiation_values) < expected_max_val else 'SUSPICIOUS'}\")\n    std_dev = np.std(radiation_values)\n    mean_val = np.mean(radiation_values)\n    cv = std_dev / mean_val if mean_val != 0 else float('nan')\n    logger.info(f\"Statistical variation (CV): {cv:.2f}\")\n    logger.info(f\"Variation check: {' GOOD' if cv < 0.8 else ' HIGH VARIATION'}\")\n    return north_south_ratio, cv\n\ndef create_solar_path_visualization(sunpath: Sunpath, scale=500) -> List[trimesh.Trimesh]:\n    paths = []\n    dates = [ (6, 21), (12, 21), (3, 21), (9, 21) ]\n    path_colors = [ [255, 128, 0, 255], [0, 128, 255, 255], [0, 255, 0, 255], [255, 255, 0, 255] ]\n    for (month, day), color in zip(dates, path_colors):\n        day_points = []\n        for hour in range(24):\n            for minute in [0, 30]:\n                dt = DateTime(month, day, hour, minute)\n                sun = sunpath.calculate_sun_from_date_time(dt)\n                if sun.altitude > 0:\n                    alt_rad = math.radians(sun.altitude)\n                    azm_rad = math.radians(sun.azimuth - 180)\n                    x = scale * math.cos(alt_rad) * math.sin(azm_rad)\n                    y = scale * math.cos(alt_rad) * math.cos(azm_rad)\n                    z = scale * math.sin(alt_rad)\n                    day_points.append([x, y, z])\n        for i in range(len(day_points) - 1):\n            direction = np.array(day_points[i+1]) - np.array(day_points[i])\n            length = np.linalg.norm(direction)\n            cylinder = trimesh.creation.cylinder(radius=2.0, height=length, sections=8)\n            direction = direction / length\n            rot = trimesh.geometry.align_vectors([0, 0, 1], direction)\n            cylinder.apply_transform(rot)\n            trans = trimesh.transformations.translation_matrix(day_points[i])\n            cylinder.apply_transform(trans)\n            cylinder.visual.face_colors = color\n            paths.append(cylinder)\n    return paths\n\n# --- Main Execution ---\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--user_id\", required=True)\nparser.add_argument(\"--project_id\", required=True)\nparser.add_argument(\"--epw_url\", required=True)\nparser.add_argument(\"--mesh_url\", required=True)\nparser.add_argument(\"--processes\", type=int, default=max(1, mp.cpu_count()-1), help=\"Number of parallel processes for radiation calculation\")\nargs = parser.parse_args()\n\nlocal_epw = get_local_path(args.epw_url, \".epw\")\nlocal_mesh = get_local_path(args.mesh_url, \".3dm\")\noutput_glb = \"solar_radiation.glb\"\nif not local_epw or not local_mesh or not output_glb:\n    raise RuntimeError(\"Missing required file paths: epw, mesh, or output\")\n\n# --- 1. Load Climate Data ---\nepw = EPW(local_epw)\nlocation = epw.location\nsolar_data = epw.global_horizontal_radiation\nlogger.info(f\"np.minimum type: {type(np.minimum)}, np.maximum type: {type(np.maximum)}\")\nlogger.info(f\"Solar data min: {min(solar_data)}, max: {max(solar_data)}\")\n\n# --- 2. Compute Solar Position ---\nsunpath = Sunpath(location.latitude, location.longitude, location.time_zone)\n# Use a much larger and more varied set of sun positions\nsun_positions = []\nfor month in [6, 12, 3, 9]:\n    for day in [7, 14, 21]:\n        for hour in range(6, 19):\n            dt = DateTime(month, day, hour, 0)\n            sun = sunpath.calculate_sun_from_date_time(dt)\n            if sun.altitude > 0:\n                sun_positions.append(sun)\nlogger.info(f\"Using {len(sun_positions)} sun positions for analysis.\")\n\n# --- 3. Load Mesh Geometry and Simplify Last Mesh ---\nmodel = rhino3dm.File3dm.Read(local_mesh)  # type: ignore\nif not model:\n    raise RuntimeError(f\"Failed to read 3DM file: {local_mesh}\")\nall_meshes = []\nfor obj in model.Objects:\n    geom = obj.Geometry\n    if type(geom).__name__ == \"Mesh\":\n        name = obj.Attributes.Name if obj.Attributes.Name else \"unnamed\"\n        all_meshes.append((geom, name))\nif not all_meshes:\n    raise RuntimeError(\"No meshes found in the model file\")\n\nlogger.info(\"Mesh face counts in the .3dm file:\")\nfor idx, (m, n) in enumerate(all_meshes):\n    logger.info(f\"  Mesh {idx+1}: {len(m.Faces)} faces\")\n\n# Simplify only the last mesh\nmesh = all_meshes[-1][0]\noriginal_face_count = len(mesh.Faces)\nsimplification_ratio = 0.5  # 20% of original\ncalculated_target = max(5000, min(20000, int(original_face_count * simplification_ratio)))\ntarget_faces = calculated_target\nlogger.info(f\"\\nSimplifying the last mesh (Mesh {len(all_meshes)}) with {original_face_count} faces.\")\nlogger.info(f\"Target face count for simplification: {target_faces}\")\n\nvertices = [(v.X, v.Y, v.Z) for v in mesh.Vertices]\nfaces = []\nfor f in mesh.Faces:\n    if len(f) == 4:\n        faces.append([f[0], f[1], f[2]])\n        faces.append([f[0], f[2], f[3]])\n    elif len(f) == 3:\n        faces.append([f[0], f[1], f[2]])\n\ntemp_obj = \"temp_solar_mesh.obj\"\nwith open(temp_obj, \"w\") as f:\n    for v in vertices:\n        f.write(f\"v {v[0]} {v[1]} {v[2]}\\n\")\n    for face in faces:\n        f.write(f\"f {face[0]+1} {face[1]+1} {face[2]+1}\\n\")\n\nms = pymeshlab.MeshSet()  # type: ignore\nms.load_new_mesh(temp_obj)\nms.meshing_decimation_quadric_edge_collapse(\n    targetfacenum=target_faces,\n    preservenormal=True,\n    preserveboundary=True,\n    preservetopology=True,\n    planarquadric=True\n)\nlogger.info(\"Decimation complete.\")\nms.meshing_remove_duplicate_faces()\nms.meshing_remove_unreferenced_vertices()\nif hasattr(ms, 'meshing_remove_isolated_pieces'):\n    ms.meshing_remove_isolated_pieces(mincomponentsize=10)\nlogger.info(\"Cleaning complete.\")\nif hasattr(ms, 'compute_normals_for_faces'):\n    ms.compute_normals_for_faces()\n    logger.info(\"Normals recomputed.\")\n\nsimplified_obj = \"temp_solar_mesh_simplified.obj\"\nms.save_current_mesh(simplified_obj)\nwith open(simplified_obj, \"r\") as f:\n    lines = f.readlines()\n\nsimple_vertices = []\nsimple_faces = []\nfor line in lines:\n    if line.startswith(\"v \"):\n        parts = line.strip().split()\n        simple_vertices.append((float(parts[1]), float(parts[2]), float(parts[3])))\n    elif line.startswith(\"f \"):\n        nums = [int(n.split('/')[0]) - 1 for n in line.strip().split()[1:]]\n        simple_faces.append(nums)\n\nclass DummyPt:\n    def __init__(self, x, y, z):\n        self.X = x\n        self.Y = y\n        self.Z = z\nclass DummyMesh:\n    pass\nsimple_mesh = DummyMesh()\nsimple_mesh.Vertices = [DummyPt(*v) for v in simple_vertices]\nsimple_mesh.Faces = simple_faces\nall_meshes[-1] = (simple_mesh, all_meshes[-1][1])\ntarget_meshes = [all_meshes[-1][0]]\ncontext_meshes = [mesh[0] for mesh in all_meshes[:-1]]\nlogger.info(f\"Using the last mesh '{all_meshes[-1][1]}' as target (simplified), and {len(context_meshes)} other meshes as context\")\n\n# --- 4. Process Meshes ---\ntarget_vertices, target_faces = process_meshes(target_meshes)\ntarget_lb_mesh = create_ladybug_mesh(target_vertices, target_faces)\ncontext_vertices, context_faces = process_meshes(context_meshes)\ncontext_lb_mesh = create_ladybug_mesh(context_vertices, context_faces)\n\n# --- 5. Compute Solar Radiation (vectorized, all faces) ---\nface_centroids = target_lb_mesh.face_centroids\nface_normals = target_lb_mesh.face_normals\nnum_faces = len(target_lb_mesh.faces)\nlogger.info(f\"Calculating solar radiation for {num_faces} faces using single-threaded mode...\")\nlogger.info(f\"Sample normals: {[str(n) for n in face_normals[:5]]}\")\nradiation_values = calculate_radiation_vectorized(face_normals, sun_positions, solar_data)\nmin_val = np.amin(radiation_values)\nmax_val = np.amax(radiation_values)\nlogger.info(f\"Radiation min: {min_val}, max: {max_val}\")\nif max_val > min_val:\n    norm_radiation = (radiation_values - min_val) / (max_val - min_val)\nelse:\n    norm_radiation = np.zeros_like(radiation_values)\n\nvalidation_results = validate_solar_analysis(radiation_values, target_lb_mesh)\ncmap = plt.get_cmap(\"jet\")\ntarget_colors = [(int(r * 255), int(g * 255), int(b * 255), 255) for r, g, b in [cmap(val)[:3] for val in norm_radiation]]\n\n# --- 6. High Radiation Face Analysis ---\nsorted_radiation = np.sort(radiation_values)[::-1]\nhigh_threshold = sorted_radiation[int(len(sorted_radiation) * 0.1)]\nhigh_rad_positions = []\nhigh_rad_normals = []\nfor i, rad in enumerate(radiation_values):\n    if rad >= high_threshold:\n        high_rad_positions.append([face_centroids[i].x, face_centroids[i].y, face_centroids[i].z])\n        high_rad_normals.append([face_normals[i].x, face_normals[i].y, face_normals[i].z])\n\ntarget_trimesh = triangulate_and_color_mesh(target_lb_mesh, target_colors)\ncontext_vertices_np = np.array([[v.x, v.y, v.z] for v in context_lb_mesh.vertices])\ncontext_trimesh = triangulate_and_color_mesh(context_lb_mesh, None)\n\nbounds = target_trimesh.bounds\nmodel_center = np.mean(bounds, axis=0)\nmodel_height = bounds[1][2]\nclearance = 20\nhigh_rad_center = np.mean(high_rad_positions, axis=0) if high_rad_positions else model_center\nhigh_rad_normal = np.mean(high_rad_normals, axis=0) if high_rad_normals else [0, 1, 0]\nhigh_rad_normal = high_rad_normal / np.linalg.norm(high_rad_normal)\nvec = np.array(high_rad_center[:2]) - np.array(model_center[:2])\nother_side_point = [model_center[0] - vec[0], model_center[1] - vec[1], model_height + clearance]\n\n# --- 7. Solar Path Visualization ---\nlogger.info(\"Generating solar path visualization...\")\nsolar_paths = create_solar_path_visualization(sunpath, scale=500)\nfor path in solar_paths:\n    translation = trimesh.transformations.translation_matrix(other_side_point)\n    path.apply_transform(translation)\nrotation_matrix = trimesh.transformations.rotation_matrix(angle=np.pi, direction=[0, 1, 0], point=model_center)\nfor path in solar_paths:\n    path.apply_transform(rotation_matrix)\n\nall_meshes = [target_trimesh, context_trimesh]\nall_meshes.extend(solar_paths)\ncombined_mesh = trimesh.util.concatenate(all_meshes)\ncombined_mesh.export(output_glb)\nlogger.info(f\"Model with solar paths saved as {output_glb}\")\n\n# --- 8. Export 2D Legend Image ---\nlogger.info(\"Generating 2D legend image...\")\nfig, ax = plt.subplots(figsize=(2, 6))\nax.set_visible(False)\nnorm = plt.Normalize(min_val, max_val)\nsm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\nsm.set_array([])\ncbar = plt.colorbar(sm, ax=ax)\ncbar.set_label('Radiation (kWh/m²)')\ncbar.set_ticks(np.linspace(min_val, max_val, 10))\ncbar.set_ticklabels([f\"{val:.0f}\" for val in np.linspace(min_val, max_val, 10)])\nplt.title('Solar Radiation\\n(kWh/m²)')\nplt.figtext(0.1, 0.01, f\"N/S ratio: {validation_results[0]:.2f}\\nCV: {validation_results[1]:.2f}\", fontsize=8)\nplt.figtext(0.1, 0.2, 'Solar Paths:', fontsize=8)\nplt.figtext(0.1, 0.17, 'Summer Solstice', color='orange', fontsize=8)\nplt.figtext(0.1, 0.14, 'Winter Solstice', color='blue', fontsize=8)\nplt.figtext(0.1, 0.11, 'Spring Equinox', color='green', fontsize=8)\nplt.figtext(0.1, 0.08, 'Fall Equinox', color='yellow', fontsize=8)\nlegend_image = output_glb.replace('.glb', '_legend.png')\nplt.savefig(legend_image, bbox_inches='tight', dpi=300)\nlogger.info(f\"Legend image saved as {legend_image}\")",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}