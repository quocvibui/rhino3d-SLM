{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Srf_radius.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Srf_radius.py",
  "instruction": "Spb srf radius",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160419: Created.\r\n...\r\n210612: Rewrote the routine in constantRadiusOfSurface that checks curvature/radii at various points.\r\n        constantRadiusOfSurface now returns a negative radius for rounds.\r\n210617: constantRadiusOfSurface now handles surfaces with flat spots.\r\n220613: Now states the face's shape if a cylinder, sphere, or torus.\r\n221108: Now, fRadTol is also used for getting primitive shape.  Refactored.\r\n230210: Now, tolerance for getting primitive shape is maximized at 0.1 * ModelAbsoluteTolerance.\r\n230403,07: Bug fix.\r\n240622: Added NegSign option.\r\n241231: Bug and efficiency fixes.\r\n250723: Added option to output the diameter for dots.\r\n250727: Added option to for the dot text to be the 2nd dual unit instead of the model unit (inch vs. mm only).\r\n        Added option to add unit label to dot text.\r\n\r\nTODO:\r\n    Obtain face's shape only once.  Refer to 220613 revision.  Another script calls relevant function.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport time\r\n\r\nimport xBlock\r\nimport xBrepFace_tryGetPrimitiveShape\r\nimport xSurface\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'TolForConstRad'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bPickPt'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'PostPickPtForVarRad'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDualUnits'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'PrintDualUnits'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDot_Height'; keys.append(key)\r\n    values[key] = 11\r\n    names[key] = 'Height'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot_Dia_notRad'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Segment'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Radius', 'Diameter')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot_IncludePrefix'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'IncludePrefix'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot_NegSign'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'NegSign'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot_2ndUnit'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Unit'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'ModelOnly', '2ndOnly')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDot_DecPlaces'; keys.append(key)\r\n    values[key] = sc.doc.ModelDistanceDisplayPrecision - 2\r\n    names[key] = 'DecPlaces'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=-1)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bDot_UnitLabel'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'UnitLabel'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\ndef closestFaceToPoint(rgBrep, pt3d):\r\n    if rgBrep.Faces.Count == 1: return rgBrep.Faces[0]\r\n    fDist_Min = sc.doc.ModelAbsoluteTolerance * 1000.0\r\n    idxFace_Closest = None\r\n    for f, rgFace in enumerate(rgBrep.Faces):\r\n        bPt, u, v = rgFace.ClosestPoint(pt3d)\r\n        if rgFace.IsPointOnFace(u, v): # Works because values are 0 for Exterior, 1 for Interior, 2 for Boundary\r\n            ptOn = rgFace.PointAt(u, v)\r\n            fDist = pt3d.DistanceTo(ptOn)\r\n            if fDist < fDist_Min:\r\n                idxFace_Closest = f\r\n                fDist_Min = fDist\r\n    return rgBrep.Faces[idxFace_Closest] if idxFace_Closest is not None else None\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get surface with optional input\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select face\")\r\n\r\n    go.GeometryFilter = (\r\n        rd.ObjectType.Surface |\r\n        rd.ObjectType.Brep |\r\n        rd.ObjectType.InstanceReference)\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.EnableHighlight(False)\r\n\r\n    #go.SubObjectSelect = False # This was used when RC6's\r\n    # ObjRef.SelectionPoint() was not at the absolute coordinates of the pick.\r\n    # It was instead at a point per the block definition.\r\n    # Fixed in Rhino 6 8/30/16 WIP.\r\n    \r\n    rgFace = None\r\n    \r\n    idxs_Opts = {}\r\n\r\n    def addOption(ric, key): idxs_Opts[key] = Opts.addOption(ric, key)\r\n\r\n    while rgFace is None:\r\n        while True:\r\n            go.ClearCommandOptions()\r\n\r\n            idxs_Opts.clear()\r\n\r\n            addOption(go, 'fRadTol')\r\n            addOption(go, 'bPickPt')\r\n            addOption(go, 'bDualUnits')\r\n            addOption(go, 'bAddDot')\r\n            if Opts.values['bAddDot']:\r\n                idxs_Opts['DotSettings'] = go.AddOption('DotSettings')\r\n            addOption(go, 'bEcho')\r\n            addOption(go, 'bDebug')\r\n\r\n            res = go.Get()\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                go.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Object:\r\n                break\r\n\r\n            if res == ri.GetResult.Number:\r\n                key = 'fRadTol'\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n                Opts.setValue(key)\r\n                continue\r\n\r\n            if Opts.values['bAddDot'] and go.Option().Index == idxs_Opts['DotSettings']:\r\n                #idxs_Opts.clear()\r\n\r\n                go_Dot = ri.Custom.GetOption()\r\n                go_Dot.SetCommandPrompt(\"Set dot options\")\r\n\r\n                while True:\r\n                    go_Dot.ClearCommandOptions()\r\n                    idxs_Opts.clear()\r\n\r\n                    addOption(go_Dot, 'iDot_Height')\r\n                    addOption(go_Dot, 'bDot_Dia_notRad')\r\n                    addOption(go_Dot, 'bDot_IncludePrefix')\r\n                    addOption(go_Dot, 'bDot_NegSign')\r\n                    addOption(go_Dot, 'bDot_2ndUnit')\r\n                    addOption(go_Dot, 'iDot_DecPlaces')\r\n                    addOption(go_Dot, 'bDot_UnitLabel')\r\n\r\n                    res = go_Dot.Get()\r\n\r\n                    if res != ri.GetResult.Option:\r\n                        break\r\n\r\n                    for key in idxs_Opts:\r\n                        if go_Dot.Option().Index == idxs_Opts[key]:\r\n                            Opts.setValue(key, go_Dot.Option().CurrentListOptionIndex)\r\n                            break\r\n\r\n                go_Dot.Dispose()\r\n\r\n                continue\r\n\r\n\r\n            for key in idxs_Opts:\r\n                if go.Option().Index == idxs_Opts[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n        objref = go.Object(0)\r\n        # Rhino 6: When sub-object selecting, go.Object(0).Geometry() is the geometry.\r\n        rdObj = objref.Object() # Rhino 6: When selecting a block instance, this is 'ModelGeometry: (unnamed) (0)'.\r\n        # Rhino 6: When selecting a block instance, regardless of SubObjectSelect, rdObj.ObjectType is 'InstanceReference'.\r\n        ptPicked = objref.SelectionPoint() #; sc.doc.Objects.AddPoint(ptPicked)\r\n        \r\n        if go.ObjectsWerePreselected:\r\n            if rdObj.ObjectType == rd.ObjectType.Brep:\r\n                rgObj = rdObj.BrepGeometry\r\n            elif rdObj.ObjectType == rd.ObjectType.Extrusion:\r\n                rgObj = rdObj.Geometry.ToBrep()\r\n            else:\r\n                sc.doc.Objects.UnselectAll() # Necessary if instance reference was preselected.\r\n                sc.doc.Views.Redraw()\r\n                continue\r\n            if rgObj.Faces.Count == 1:\r\n                rgFace = rgObj.Faces[0]\r\n            else:\r\n                sc.doc.Objects.UnselectAll() # Necessary to avoid getting stuck in endless loop if brep has more than 1 face.\r\n                sc.doc.Views.Redraw()\r\n            continue\r\n        rgObj = go.Object(0).Geometry()\r\n        \r\n        if (rdObj.ObjectType == rd.ObjectType.Brep or \r\n                rdObj.ObjectType == rd.ObjectType.InstanceReference):\r\n            if rgObj.ObjectType == rd.ObjectType.Brep: # For Rhino 6, not 5.\r\n                rgFace = closestFaceToPoint(rgObj, ptPicked)\r\n            elif rgObj.ObjectType == rd.ObjectType.InstanceReference: # For both Rhino 5 & 6.\r\n                rgFace, ptPicked = xBlock.tryPickedFaceOfBlock(rdObj, ptPicked)\r\n        else: rgFace = objref.Face() # This also works for ExtrusionObject.\r\n        \r\n        if rgFace is None: sc.doc.Objects.UnselectAll() # Necessary when go.Get() is repeated.\r\n\r\n    go.Dispose()\r\n\r\n    return rgFace, ptPicked\r\n\r\n\r\ndef curvaturesAtNormalizedParameters(rgSrf, u_Norm, v_Norm):\r\n    \"\"\"\r\n    Returns:\r\n        Radius of abs(maximum curvature) (minimum radius)\r\n        Radius of abs(maximum curvature) (minimum radius)\r\n    \"\"\"\r\n    fDomain_u = rgSrf.Domain(0); fDomain_v = rgSrf.Domain(1)\r\n    fRh0 = Rhino.RhinoMath.ZeroTolerance\r\n    \r\n    kappa_Max = kappa_Min = 0\r\n    u = (fDomain_u[1] - fDomain_u[0]) * u_Norm + fDomain_u[0]\r\n    v = (fDomain_v[1] - fDomain_v[0]) * v_Norm + fDomain_v[0]\r\n    c = rgSrf.CurvatureAt(u, v)\r\n    if c is not None: # None will happen at singularities.\r\n        fK_Max = c.Kappa(0)\r\n        fK_Min = c.Kappa(1)\r\n        if abs(fK_Max) > fRh0: kappa_Max = fK_Max\r\n        if abs(fK_Min) > fRh0: kappa_Min = fK_Min\r\n    return kappa_Max, kappa_Min\r\n\r\n\r\ndef constantRadiusOfSurface(rgFace, fRadTol=None, bAlsoReturnShape=False, bDebug=False):\r\n    \"\"\"\r\n    Even if surface has 2 constant radii, returns only the average of the minima.\r\n    TODO: In the case of having 2 constant radii, return both,\r\n    and modify code (internal and external) referencing this function.\r\n    \"\"\"\r\n\r\n    if bDebug: print('constantRadiusOfSurface()')\r\n    \r\n    \r\n    def radiusOfPrimitiveShape(rgPrimitive, bDebug=False):\r\n        \"\"\"\r\n        \"\"\"\r\n        typeShape = rgPrimitive.GetType()\r\n        if bDebug: print(typeShape)\r\n        if typeShape == rg.Plane:\r\n            return 0.0\r\n        if typeShape == rg.Cylinder:\r\n            rgCir = rgPrimitive.CircleAt(0.)\r\n            return rgCir.Radius\r\n        elif typeShape == rg.Sphere:\r\n            return rgPrimitive.Radius\r\n        elif typeShape == rg.Torus:\r\n            return rgPrimitive.MinorRadius\r\n    \r\n    \r\n    if fRadTol is None: fRadTol = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    \r\n    fTolerance_Shape = min(fRadTol, 1e-6)\r\n    \r\n    # Frist, check for planarity.\r\n    rc = xBrepFace_tryGetPrimitiveShape.tryGetPrimitiveShape(\r\n        rgFace,\r\n        bMatchToShrunkFace=False,\r\n        bPlane=True,\r\n        bCylinder=False,\r\n        bCone=True,\r\n        bSphere=False,\r\n        bTorus=False,\r\n        fTolerance=1e-9,\r\n        bDebug=bDebug)\r\n    if rc and rc[0]:\r\n        return\r\n    \r\n    # If the face is of a cylinder, sphere, or torus, obtain the shape's radius.\r\n    rc = xBrepFace_tryGetPrimitiveShape.tryGetPrimitiveShape(\r\n        rgFace,\r\n        bMatchToShrunkFace=True,\r\n        bPlane=False,\r\n        bCylinder=True,\r\n        bCone=False,\r\n        bSphere=True,\r\n        bTorus=True,\r\n        fTolerance=fTolerance_Shape,\r\n        bDebug=bDebug)\r\n    if rc and rc[0]:\r\n        rgPrimitive, fTol_Used, sShrunkOrNot = rc[0]\r\n\r\n        radius = radiusOfPrimitiveShape(rgPrimitive)\r\n        if radius is not None:\r\n            kappa_Max, kappa_Min = (\r\n                    curvaturesAtNormalizedParameters(rgFace, 0.5, 0.5))\r\n            if rgFace.OrientationIsReversed:\r\n                kappa_Max, kappa_Min = -kappa_Max, -kappa_Min\r\n            if kappa_Max < 0.0:\r\n                if bAlsoReturnShape:\r\n                    return -radius, rgPrimitive\r\n                else:\r\n                    return -radius\r\n            if bAlsoReturnShape:\r\n                return radius, rgPrimitive\r\n            else:\r\n                return radius\r\n    \r\n    #\r\n    # If a single singularity or short senw exists,\r\n    # the face is probably the end of a fillet chain.\r\n    # Only points on the border opposite the (near) singularity will be\r\n    # checked for a constant radius.\r\n    \r\n    iSenwsWithSingularityOrAlmost = [side for side in (0,1,2,3) if\r\n            rgFace.IsSingular(side)]\r\n    rgNurbsSrf = rgFace.ToNurbsSurface()\r\n    iSenwsWithSingularityOrAlmost.extend(\r\n            xSurface.shortSenws(rgNurbsSrf, sc.doc.ModelAbsoluteTolerance)\r\n    )\r\n    rgNurbsSrf.Dispose()\r\n    iSenwsWithSingularityOrAlmost = list(set(iSenwsWithSingularityOrAlmost))\r\n    if len(iSenwsWithSingularityOrAlmost) == 1:\r\n        # Create normalized parameter generator.\r\n        iSenw = iSenwsWithSingularityOrAlmost[0]\r\n        numShort = 2 # Number of columns of samples to take on end opposite of singularity progressing toward singularity.\r\n        numFull = 5 # Number of rows of samples to take on end opposite of singularity traversing parallel with singularity.\r\n        m = 1./(numFull-1) # Division multiplier\r\n        if iSenw == 0:\r\n            #print('South')\r\n            uvs = ((m*u, m*v) for u in xrange(0, numFull) for\r\n                    v in xrange(numFull-numShort, numFull))\r\n        elif iSenw == 1:\r\n            #print('East')\r\n            uvs = ((m*u, m*v) for u in xrange(0, numShort) for\r\n                    v in xrange(0, numFull))\r\n        elif iSenw == 2:\r\n            #print('North')\r\n            uvs = ((m*u, m*v) for u in xrange(0, numFull) for\r\n                    v in xrange(0, numShort))\r\n        elif iSenw == 3:\r\n            #print('West')\r\n            uvs = ((m*u, m*v) for u in xrange(numFull-numShort, numFull) for\r\n                    v in xrange(0, numFull))\r\n        else:\r\n            print(\"What happened?\")\r\n            return\r\n        \r\n        radii_Signed = []\r\n        for u,v in uvs:\r\n    #            print(u, v)\r\n    #            sc.doc.Objects.AddPoint(rgFace.PointAt(\r\n    #                    rgFace.Domain(0).ParameterAt(u),\r\n    #                    rgFace.Domain(1).ParameterAt(v)))\r\n    #            sc.doc.Views.Redraw()\r\n            kappa_Max, kappa_Min = curvaturesAtNormalizedParameters(\r\n                rgFace, u, v)\r\n\r\n            if bDebug: sEval = 'kappa_Max'; print(sEval + ':', eval(sEval))\r\n            if kappa_Max == 0: break\r\n\r\n            if rgFace.OrientationIsReversed:\r\n                kappa_Max, kappa_Min = -kappa_Max, -kappa_Min\r\n\r\n            radii_Signed.append(1.0/kappa_Max)\r\n            # Check whether radii extents are within fRadTol of a mean value.\r\n            if not Rhino.RhinoMath.EpsilonEquals(\r\n                    min(radii_Signed), max(radii_Signed), 2.0*fRadTol):\r\n                break\r\n        else:\r\n            if bAlsoReturnShape:\r\n                return sum(radii_Signed) / float(len(radii_Signed)), None\r\n            else:\r\n                return sum(radii_Signed) / float(len(radii_Signed))\r\n    \r\n    #\r\n    \r\n    #\r\n    # Sample various points across diagonal of surface to check for constant radius.\r\n    \r\n    rh0 = Rhino.RhinoMath.ZeroTolerance\r\n    \r\n    uAndV = 0.5\r\n    if bDebug: sEval='uAndV'; print(sEval+':',eval(sEval))\r\n    \r\n    \r\n    kappa_Max, kappa_Min = curvaturesAtNormalizedParameters(rgFace, uAndV, uAndV)\r\n\r\n    if rgFace.OrientationIsReversed:\r\n        kappa_Max, kappa_Min = -kappa_Max, -kappa_Min\r\n\r\n\r\n    if bDebug:\r\n        sEval='kappa_Max'; print(sEval+':',eval(sEval),)\r\n        sEval='1.0/kappa_Max'; print(sEval+':',eval(sEval))\r\n        sEval='kappa_Min'; print(sEval+':',eval(sEval),)\r\n        sEval='1.0/kappa_Min'; print(sEval+':',eval(sEval))\r\n\r\n    if abs(kappa_Max) > rh0:\r\n        radii_Minima_signed = [1.0/kappa_Max]\r\n    else:\r\n        radii_Minima_signed = []\r\n\r\n    if abs(kappa_Min) > rh0:\r\n        radii_Maxima_signed = [1.0/kappa_Min]\r\n    else:\r\n        radii_Maxima_signed = []\r\n\r\n    #radii_Signed = list(radii_Signed_MidT)\r\n\r\n    for uAndV in 0.1,0.2,0.3,0.4,0.6,0.7,0.8,0.9:\r\n        # Notice that points along borders of surface are skipped to avoid creating a special case for singularities.\r\n        \r\n        if bDebug:\r\n            sEval='uAndV'; print(sEval+':',eval(sEval))\r\n        \r\n        kappa_Max, kappa_Min = curvaturesAtNormalizedParameters(rgFace, uAndV, uAndV)\r\n\r\n        if rgFace.OrientationIsReversed:\r\n            kappa_Max, kappa_Min = -kappa_Max, -kappa_Min\r\n\r\n        if bDebug:\r\n            sEval='kappa_Max'; print(sEval+':',eval(sEval),)\r\n            sEval='1.0/kappa_Max'; print(sEval+':',eval(sEval))\r\n            sEval='kappa_Min'; print(sEval+':',eval(sEval),)\r\n            sEval='1.0/kappa_Min'; print(sEval+':',eval(sEval))\r\n\r\n        if abs(kappa_Max) > rh0:\r\n            radii_Minima_signed.append(1.0/kappa_Max)\r\n\r\n        if abs(kappa_Min) > rh0:\r\n            radii_Maxima_signed.append(1.0/kappa_Min)\r\n\r\n        if len(radii_Minima_signed) == 0 and len(radii_Maxima_signed) == 0:\r\n            print(\"Flat spot detected on surface, so it has no constant radius.\"\r\n                  \" Should the face be split?\")\r\n            return\r\n\r\n        if abs(max(radii_Minima_signed) - min(radii_Minima_signed)) > fRadTol:\r\n            if radii_Maxima_signed and abs(max(radii_Maxima_signed) - min(radii_Maxima_signed)) > fRadTol:\r\n                # No constant radius for either maxima or minima.\r\n                return\r\n\r\n        #        if abs(kappa_Max) > rh0 and abs(abs(1.0/kappa_Max) - abs(radii_Signed_MidT[0])) <= fRadTol:\r\n        #            if abs(kappa_Min) > rh0 and abs(abs(1.0/kappa_Min) - abs(radii_Signed_MidT[-1])) <= fRadTol:\r\n        #                # Both curvatures of current sample point match those at first sample point.\r\n        #                # Record radius with largest magnitude.\r\n        #                if abs(1.0/kappa_Max) > abs(1.0/kappa_Min):\r\n        #                    radii_Signed.append(1.0/kappa_Max)\r\n        #                else:\r\n        #                    radii_Signed.append(1.0/kappa_Min)\r\n        #            else:\r\n        #                # Only kappa_Max matches.\r\n        #                radii_Signed.append(1.0/kappa_Max)\r\n        #        elif abs(kappa_Min) > rh0 and abs(abs(1.0/kappa_Min) - abs(radii_Signed_MidT[-1])) <= fRadTol:\r\n        #            radii_Signed.append(1.0/kappa_Min)\r\n        #        else:\r\n        #            # No curvatures match between first and second sample points.\r\n        #            return\r\n\r\n    if bDebug:\r\n        sEval='min(radii_Minima_signed)'; print(sEval+':',eval(sEval))\r\n        sEval='max(radii_Minima_signed)'; print(sEval+':',eval(sEval))\r\n        sEval='min(radii_Maxima_signed)'; print(sEval+':',eval(sEval))\r\n        sEval='max(radii_Maxima_signed)'; print(sEval+':',eval(sEval))\r\n        print\r\n\r\n    if abs(max(radii_Minima_signed) - min(radii_Minima_signed)) <= fRadTol:\r\n        if bAlsoReturnShape:\r\n            return sum(radii_Minima_signed) / float(len(radii_Minima_signed)), None\r\n        else:\r\n            return sum(radii_Minima_signed) / float(len(radii_Minima_signed))\r\n\r\n    return\r\n\r\n\r\n\r\n    #    if abs(max(radii_Maxima_signed) - min(radii_Maxima_signed)) <= fRadTol:\r\n    #        return sum(radii_Maxima_signed) / float(len(radii_Maxima_signed))\r\n\r\n    #    # Check whether radii extents are within fRadTol of midrange.\r\n    #    if not Rhino.RhinoMath.EpsilonEquals(\r\n    #            min(radii_Signed), max(radii_Signed), 2.0*fRadTol\r\n    #    ):\r\n    #        return\r\n    #\r\n    #    return abs(sum(radii_Signed) / len(radii_Signed))\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    rgFace0, ptPicked = rc\r\n\r\n\r\n    fRadTol = Opts.values['fRadTol']\r\n    bPickPt = Opts.values['bPickPt']\r\n    bDualUnits = Opts.values['bDualUnits']\r\n    bAddDot = Opts.values['bAddDot']\r\n    iDot_Height = Opts.values['iDot_Height']\r\n    bDot_Dia_notRad = Opts.values['bDot_Dia_notRad']\r\n    bDot_IncludePrefix = Opts.values['bDot_IncludePrefix']\r\n    bDot_NegSign = Opts.values['bDot_NegSign']\r\n    bDot_2ndUnit = Opts.values['bDot_2ndUnit']\r\n    iDot_DecPlaces = Opts.values['iDot_DecPlaces']\r\n    bDot_UnitLabel = Opts.values['bDot_UnitLabel']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    def deleteTempRdObjs(gTemp):\r\n        if not gTemp: return\r\n        idBreps1_NETList = List[Guid](gTemp)\r\n        sc.doc.UndoRecordingEnabled = False\r\n        sc.doc.Objects.Delete(idBreps1_NETList, True)\r\n        sc.doc.UndoRecordingEnabled = True\r\n\r\n\r\n    bDocWasAlreadyModified = sc.doc.Modified\r\n    \r\n    rgBrep_1Face = rgFace0.DuplicateFace(True) # Used for highlighting and pick point boundary constraint.\r\n    rgFace0.Brep.Dispose()\r\n    rgBrep_1Face.Faces.ShrinkFaces()\r\n    rgFace1_From1FaceB = rgBrep_1Face.Faces[0]\r\n\r\n    if not bAddDot and ptPicked[0] != Rhino.RhinoMath.UnsetValue:\r\n        # Alternative\r\n        ## Add and highlight duplicate of face.\r\n        #idBrep = sc.doc.Objects.AddBrep(rgBrep_1Face)\r\n        #rdBrep = sc.doc.Objects.Find(idBrep)\r\n        #rdBrep.Attributes.WireDensity = -1\r\n        #rdBrep.Highlight(True)\r\n        \r\n        # Add and highlight duplicates of face border curves.\r\n        sc.doc.UndoRecordingEnabled = False\r\n        necs = rgBrep_1Face.DuplicateNakedEdgeCurves(nakedOuter=True, nakedInner=True)\r\n        gCrvs_FaceBorders = [sc.doc.Objects.AddCurve(c) for c in necs]\r\n        sc.doc.UndoRecordingEnabled = True\r\n        \r\n        for c in gCrvs_FaceBorders:\r\n            co = sc.doc.Objects.FindId(c) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(c)\r\n            co.Highlight(True),\r\n        \r\n        sc.doc.Views.Redraw()\r\n        time.sleep(0.05)\r\n    else: gCrvs_FaceBorders = None #idBrep = None\r\n    \r\n    bPlanar = rgFace1_From1FaceB.IsPlanar(1e-6)\r\n    \r\n    if bPlanar:\r\n        s = \"Surface is planar.\"\r\n    else:\r\n        fRad_Srf = None\r\n        rv = constantRadiusOfSurface(\r\n            rgFace=rgFace1_From1FaceB,\r\n            fRadTol=fRadTol,\r\n            bAlsoReturnShape=True,\r\n            bDebug=bDebug,\r\n            )\r\n        if rv is not None:\r\n            fRad_Srf, rgPrimitive = rv\r\n            if rgPrimitive is not None:\r\n                sPrimitive = rgPrimitive.GetType().Name\r\n                if sPrimitive == \"Cylinder\":\r\n                    s = \"Cylindrical face\"\r\n                elif sPrimitive == \"Sphere\":\r\n                    s = \"Spherical face\"\r\n                elif sPrimitive == \"Torus\":\r\n                    s = \"Toric face\"\r\n            else:\r\n                s = \"Face has a constant radius.\"\r\n        else:\r\n            if bPickPt or ptPicked[0] == Rhino.RhinoMath.UnsetValue:\r\n                ptPicked = None\r\n                gp = ri.Custom.GetPoint()\r\n                gp.SetCommandPrompt(\"Point on surface to analyze radius\")\r\n                gp.Constrain(rgBrep_1Face, -1, -1, False)\r\n                gp.Get()\r\n                if gp.CommandResult() == Rhino.Commands.Result.Success:\r\n                    ptPicked = gp.Point()\r\n                gp.Dispose()\r\n            \r\n            if ptPicked is not None:\r\n                bPt, u, v = rgFace1_From1FaceB.ClosestPoint(ptPicked)\r\n                if bPt:\r\n                    surface_curvature = rgFace1_From1FaceB.CurvatureAt(u, v)\r\n                    fK_Max = abs(surface_curvature.Kappa(0))\r\n                    if fK_Max > 0.0:\r\n                        fRad_Srf = 1.0 / fK_Max\r\n                        s = \"At picked point:\"\r\n                    else:\r\n                        s = \"Surface is planar at picked point.\"\r\n            else:\r\n                deleteTempRdObjs(gCrvs_FaceBorders)\r\n                rgBrep_1Face.Dispose()\r\n                return\r\n        \r\n        if fRad_Srf:\r\n            if bAddDot:\r\n                if bDot_Dia_notRad:\r\n                    sPrefix = chr(216) if bDot_IncludePrefix else ''\r\n                    fDotValue = 2.0 * fRad_Srf\r\n                else:\r\n                    sPrefix = 'R' if bDot_IncludePrefix else ''\r\n                    fDotValue = fRad_Srf\r\n                if not bDot_NegSign and fDotValue < 0.0:\r\n                    fDotValue = abs(fDotValue)\r\n                sSuffix = ''\r\n                if bDot_2ndUnit:\r\n                    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n                        fDotValue *= Rhino.RhinoMath.UnitScale(\r\n                            Rhino.UnitSystem.Inches,\r\n                            Rhino.UnitSystem.Millimeters)\r\n                        if bDot_UnitLabel:\r\n                            sSuffix = 'mm'\r\n                    elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n                        fDotValue *= Rhino.RhinoMath.UnitScale(\r\n                            Rhino.UnitSystem.Millimeters,\r\n                            Rhino.UnitSystem.Inches)\r\n                        if bDot_UnitLabel:\r\n                             sSuffix = '\"'\r\n                elif bDot_UnitLabel:\r\n                    if sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n                       sSuffix = '\"'\r\n                    else:\r\n                        sSuffix = sc.doc.GetUnitSystemName(\r\n                            modelUnits=True,\r\n                            capitalize=False,\r\n                            singular=True,\r\n                            abbreviate=True)\r\n\r\n                rgDot = rg.TextDot(\r\n                    '{0}{1:.{2}f}{3}'.format(\r\n                        sPrefix,\r\n                        fDotValue,\r\n                        iDot_DecPlaces,\r\n                        sSuffix),\r\n                    location=ptPicked)\r\n                rgDot.FontHeight = iDot_Height\r\n                sc.doc.Objects.AddTextDot(rgDot)\r\n                rgDot.Dispose()\r\n\r\n            if fRad_Srf > 0.0:\r\n                s += \"  concave (e.g., fillet) (Positive value)\"\r\n            else:\r\n                s += \"  convex (e.g., round) (Negative value)\"\r\n\r\n            if (not bDualUnits or\r\n                (sc.doc.ModelUnitSystem != Rhino.UnitSystem.Inches\r\n                 and\r\n                 sc.doc.ModelUnitSystem != Rhino.UnitSystem.Millimeters)\r\n            ):\r\n                s += \"\\nDiameter = {0:.{1}f} {2}\".format(\r\n                        2.0*fRad_Srf, sc.doc.ModelDistanceDisplayPrecision, sc.doc.ModelUnitSystem)\r\n                s += \"\\nRadius = {0:.{1}f} {2}\".format(\r\n                        fRad_Srf, sc.doc.ModelDistanceDisplayPrecision, sc.doc.ModelUnitSystem)\r\n            elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Inches:\r\n                s += \"\\nDiameter = {0:.{1}f} inches\".format(\r\n                        2.0*fRad_Srf, sc.doc.ModelDistanceDisplayPrecision)\r\n                s += ' [{0:.{1}f} mm]'.format(\r\n                        2.0*fRad_Srf*25.4, sc.doc.ModelDistanceDisplayPrecision-1)\r\n                s += \"\\nRadius = {0:.{1}f} inches\".format(\r\n                        fRad_Srf, sc.doc.ModelDistanceDisplayPrecision)\r\n                s += ' [{0:.{1}f} mm]'.format(\r\n                        fRad_Srf*25.4, sc.doc.ModelDistanceDisplayPrecision-1)\r\n            elif sc.doc.ModelUnitSystem == Rhino.UnitSystem.Millimeters:\r\n                s += \"\\nDiameter = {0:.{1}f} mm\".format(\r\n                        2.0*fRad_Srf, sc.doc.ModelDistanceDisplayPrecision)\r\n                s += ' [{0:.{1}f} inches]'.format(\r\n                        2.0*fRad_Srf/25.4, sc.doc.ModelDistanceDisplayPrecision+1)\r\n                s += \"\\nRadius = {0:.{1}f} mm\".format(\r\n                        fRad_Srf, sc.doc.ModelDistanceDisplayPrecision)\r\n                s += ' [{0:.{1}f} inches]'.format(\r\n                        fRad_Srf/25.4, sc.doc.ModelDistanceDisplayPrecision+1)\r\n    \r\n    print(s)\r\n    \r\n    # Alternative\r\n    #if idBrep is not None: sc.doc.Objects.Delete(idBrep, True)\r\n    \r\n    deleteTempRdObjs(gCrvs_FaceBorders)\r\n    \r\n    sc.doc.Views.Redraw()\r\n    \r\n    if not bDocWasAlreadyModified and not bAddDot: sc.doc.Modified = False\r\n    \r\n    rgBrep_1Face.Dispose()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}