{
  "source_url": "https://discourse.mcneel.com/t/domainsurface-u-v-vs-actual-sizes-creating-a-grid-of-points-on-surface/16902",
  "topic_id": 16902,
  "title": "DomainSurface U,V Vs. Actual Sizes (Creating a grid of points on surface)",
  "question": "Hello,\n\n\nI’ve been writing a python script to create a grid of points on a flat square surface, using the surface domain command and very similar to the one in the help.\n\n\ndef DivideSurface(): \n    srf = rs.GetObject(\"Pick surface to divide\",rs.filter.surface)\n    spacing = rs.GetInteger(\"Spacing:\")\n    offset = rs.GetInteger(\"Offset:\")\n    u = rs.SurfaceDomain(srf,0)\n    v = rs.SurfaceDomain(srf,1)\n    \n    # Calculate the number of points we want to divide our surface into\n    udiv = int(int(max(u))/spacing)\n    vdiv = int(int(max(v))/spacing)\n     \n    # Turn off redraw\n    rs.EnableRedraw(False)\n    # Divide our surface up based on number of points required \n    for i in range(0, udiv+1, 1):\n        for j in range(0, vdiv+1, 1):\n            pt = (i/udiv,j/vdiv,0)\n            srfP = rs.SurfaceParameter(srf,pt)\n            newpt = rs.EvaluateSurface(srf,srfP[0],srfP[1])\n            matrix = rs.XformTranslation((0,0,offset))\n            newpt = rs.PointTransform(newpt, matrix)\n            pts.append(rs.AddPoint(newpt))\n    rs.EnableRedraw(True)\n    return pts\n\n\n\nNow the problem is that this works but the points can be created outside the surface. I’ve spent a couple of days now searching and fiddling around with the code but I’m none the wiser as to why the u,v lengths are different to the length and width of the actual surface. I’m clearly missing something fundamental about how this works but I can’t seem to crack it. I’ve tried adding tests for pointsinsurface, which does work but then it messes up the amount of points I need.\n\n\nI’ve come to the conclusion if I could somehow get the accurate u,v values for the surface then it would achieve the grid as I want it but I don’t seem to be able to do so.\n\n\nIf you look at the below screenshot, I want the grid of points to all be neatly contained and centred within the surface. Any help would be greatly appreciated.",
  "code_blocks": [
    {
      "code": "import rhinoscriptsyntax as rs\n\ndef DivideSurface(): \n    srf = rs.GetObject(\"Pick surface to divide\",rs.filter.surface)\n    spacing = rs.GetInteger(\"Spacing:\")\n    offset = rs.GetInteger(\"Offset:\")\n    u = rs.SurfaceDomain(srf,0)\n    v = rs.SurfaceDomain(srf,1)\n\n    # Calculate the number of points we want to divide our surface into\n    udiv = (u[1]-u[0])/spacing\n    vdiv = (v[1]-v[0])/spacing\n\n    # Turn off redraw\n    rs.EnableRedraw(False)\n    # Divide our surface up based on number of points required \n    pts = []\n    for i in range(spacing+1):\n        for j in range(spacing+1):\n            up = u[0]+(udiv*i)\n            vp = v[0]+(vdiv*j)\n            newpt = rs.EvaluateSurface(srf,up,vp)\n            matrix = rs.XformTranslation((0,0,offset))\n            newpt = rs.PointTransform(newpt, matrix)\n            pts.append(rs.AddPoint(newpt))\n    rs.EnableRedraw(True)\n    return pts\n    \nDivideSurface()",
      "language": "python",
      "author": "Jess",
      "post_number": 3,
      "is_solution": false
    },
    {
      "code": "import rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\n\ndef DivideSurface(): \n    brepId = rs.GetObject(\"Pick surface to divide\",rs.filter.surface)\n    brep = rs.coercebrep(brepId)\n    brep.Faces.ShrinkFaces()\n    srf = brep.Faces[0]\n    spacing = rs.GetInteger(\"Spacing: \", 10)\n    offset = rs.GetInteger(\"Offset: \", 10)\n    u = rs.SurfaceDomain(brepId,0)\n    v = rs.SurfaceDomain(brepId,1)\n    \n    # Calculate the number of points we want to divide our surface into\n    udiv = (u[1]-u[0])/spacing\n    vdiv = (v[1]-v[0])/spacing\n    \n    # Turn off redraw\n    rs.EnableRedraw(False)\n    # Divide our surface up based on number of points required \n    pts = []\n    for i in range(spacing+1):\n        for j in range(spacing+1):\n            up = u[0]+(udiv*i)\n            vp = v[0]+(vdiv*j)\n            newpt = rs.EvaluateSurface(srf,up,vp)\n            matrix = rs.XformTranslation((0,0,offset))\n            newpt = rs.PointTransform(newpt, matrix)\n            pts.append(rs.AddPoint(newpt))\n    rs.EnableRedraw(True)\n\nDivideSurface()",
      "language": "python",
      "author": "djordje",
      "post_number": 7,
      "is_solution": false
    },
    {
      "code": "import rhinoscriptsyntax as rs\nimport math\n\ndef DivideSurface(GroupName): \n\tbrepId = rs.GetObject(\"Pick surface to divide\",rs.filter.surface)\n\tif not brepId: return\n\trs.SelectObject(brepId)\n\trs.Command(\"_Reparameterize A _Enter\")\n\trs.Command(\"_SelNone\")\n\tbrep = rs.coercebrep(brepId)\n\tbrep.Faces.ShrinkFaces()\n\tsrf = brep.Faces[0]\n\t#udiv = rs.GetInteger(\"Number of Divisions in U\",10)\n\t#vdiv = rs.GetInteger(\"Number of Divisions in V\",10)\n\tspacing = 250\n\toffset = 750\n\tspacing = rs.GetInteger(\"Spacing:\",500)\n\toffset = rs.GetInteger(\"Offset:\",650)\n\tu = rs.SurfaceDomain(srf,0) # Get length/width of surface\n\tv = rs.SurfaceDomain(srf,1)\t# Get length/width of surface\n\t\n\t# Calculate the number of points we want to divide our surface into\n\tudiv = int(round(abs(max(u)/spacing))) + 1# Make sure its positive abs(), coords can be -ve\n\tvdiv = int(round(abs(max(v)/spacing))) + 1\n\t# Calculate spacing between points\n\tspaceu = abs((u[1]-u[0])/(udiv+1))\n\tspacev = abs((v[1]-v[0])/(vdiv+1))\n\t# Calculate length of grid\n\tgridu = udiv * spaceu\n\tgridv = vdiv * spacev\n\n\t# First get boundary points to find which way the surface is\n\tpt0 = rs.EvaluateSurface(srf,u[0], v[0])\n\tpt1 = rs.EvaluateSurface(srf,u[0], v[1])\n\tpt2 = rs.EvaluateSurface(srf,u[1], v[1])\n\tpt3 = rs.EvaluateSurface(srf,u[1], v[0])\n\tptc = rs.EvaluateSurface(srf,u[1]/2, v[1]/2)\n\tptu = rs.EvaluateSurface(srf,u[1]/2, v[1]+500)\n\tptv = rs.EvaluateSurface(srf,u[1]+500, v[1]/2)\n\trs.AddLine(pt0,pt1)\n\trs.AddLine(pt1,pt2)\n\trs.AddLine(pt2,pt3)\n\trs.AddLine(pt3,pt0)\n\trs.AddPoint(pt0)\n\trs.AddPoint(pt1)\n\trs.AddPoint(pt2)\n\trs.AddPoint(pt3)\n\trs.AddPoint(ptc)\n\trs.AddText(\"0\",pt0,height=250)\n\trs.AddText(\"1\",pt1,height=250)\n\trs.AddText(\"2\",pt2,height=250)\n\trs.AddText(\"3\",pt3,height=250)\n\trs.AddText(\"C\",ptc,height=250)\n\trs.AddText(\"U\",ptu,height=250)\n\trs.AddText(\"V\",ptv,height=250)\n\t# Get Angle to determine if we need to rotate offset\n\trAngle1 = rs.Angle(pt0,pt1) # u \n\trAngle2 = rs.Angle(pt0,pt3) # v\n\trAngle3 = rs.Angle(pt0,pt2)\t# h\n\tprint(\"Angle 1: \" + str(rAngle1[0]) + \"Angle 2: \" + str(rAngle2[0]) + \" Angle 3: \" + str(rAngle3[0]))\n\t# Check whether the object is rotated too far on axis to get\n\trAngle = rAngle2[0]\n\tdAngle = math.radians(rAngle)\n\tuoffset = (((u[1]-u[0])/2) - (gridu/2))\n\tvoffset = (((v[1]-v[0])/2) - (gridv/2))\n\tprint(\"Uoffset: \" + str(uoffset) + \" Voffset: \" + str(voffset) + \" Angle: \" + str(math.cos(dAngle)))\n\tprint(rAngle)\n\tif rAngle > 1:\n\t\t# Calc hypo of offset\n\t\th = math.sqrt(pow(uoffset*2,2) + pow(voffset*2,2))\n\t\tnewang = rAngle + (90 - math.degrees(math.atan(voffset/uoffset)))\n\t\t# Generate offsets\n\t\tuoffset = abs((h * math.sin(math.radians(newang)))/2)\n\t\tvoffset = abs((h * math.cos(math.radians(newang)))/2)\n\t\tprint(\"rAngle: \" + str(rAngle) + \" Tan Angle: \" + str(math.degrees(math.atan(uoffset/voffset))))\n\t\tprint(\" Hypotenuse: \" + str(h) + \" Angle: \" + str(newang))\n\t# Pt0 should be bottom left hand one\n\t# Check u condition\n\tif abs(pt0[0]) > abs(pt2[0]):\n\t\tprint(\"Flipping u\")\n\t\tuoffset = -uoffset\n\t# Check v condition\n\tif abs(pt0[1]) < abs(pt2[1]):\n\t\tprint(\"Flipping v\")\n\t\tvoffset = -voffset\n\n\t# Debug Print\n\tprint(\"Point 0: \" + str(pt0[0]) + \" , \" + str(pt0[1]))\n\tprint(\"Point 1: \" + str(pt1[0]) + \" , \" + str(pt1[1]))\n\tprint(\"Point 2: \" + str(pt2[0]) + \" , \" + str(pt2[1]))\n\tprint(\"Point 3: \" + str(pt3[0]) + \" , \" + str(pt3[1]))\n\tprint(\"Angle Between Them: \" + str(rAngle) + \" Deg: \" + str(dAngle))\n\tprint(\"U Length: \" + str(u[1]) + \" Divisions: \" + str(udiv) + \" Spacing: \" +  str(spaceu) + \" Grid Size: \" + str(gridu) + \" Uoff: \" + str(uoffset*2))\n\tprint(\"V Length: \" + str(v[1]) + \" Divisions: \" + str(vdiv) + \" Spacing: \" +  str(spacev) + \" Grid Size: \" + str(gridv) + \" Voff: \" + str(voffset*2))\n\t# Create points list\n\tpts = []\n\t\n\t# Turn off redraw - otherwise routine is very slow\n\trs.EnableRedraw(False)\n\tn = 0\n\t\n\t# Divide our surface up based on number of points required \n\t# First loop through points on row then each column\n\n\t# Function\n\tfor i in range(0, udiv, 1):\n\t\tfor j in range(0, vdiv, 1):\n\t\t\t# Keep track of total points\n\t\t\tn = n + 1\n\t\t\t# Work out point coordinates\n\t\t\tpt = (i/(udiv+1),j/(vdiv+1),0)\n\n\t\t\t# Converts a normalized surface parameter to a surface parameter; one within the surface's domain.\n\t\t\tsrfP = rs.SurfaceParameter(srf,pt)\n\n\t\t\t# Evaluates a surface at a U,V parameter.\n\t\t\tnewpt = rs.EvaluateSurface(srf,srfP[0],srfP[1])\t\n\n\t\t\t# Creates a translation transformation matrix.\n\t\t\t# Move it on the surface only so we can test whether the point is on the surface\n\t\t\tmatrix = rs.XformTranslation((uoffset,voffset,0))\n\n\t\t\t# Transforms a 3-D point.\n\t\t\tnewpt = rs.PointTransform(newpt, matrix)\n\t\t\n\t\t\t# Test whether this point is on the surface\n\t\t\ttest = rs.IsPointOnSurface(srf,newpt)\n\t\t\tif test:\n\t\t\t\t# Create a matrix to move AFFL\n\t\t\t\tmatrix = rs.XformTranslation((uoffset,voffset,750))\n\t\t\t\t# Transforms a 3-D point.\n\t\t\t\tnewpt = rs.PointTransform(newpt, matrix)\n\t\t\t\t# Add the new point to our list\n\t\t\t\tpts.append(rs.AddPoint(newpt))\n\tprint(\"Points: \", str(len(pts)), \" Not on surface: \", str(n-len(pts)))\n\t# Turn on redraw\n\trs.EnableRedraw(True)\n\t# Check if GroupName is not empty, if it isn't automatically rename our group\n\tif GroupName:\n\t\tgrpname = rs.AddGroup(GroupName)\n\telse:\n\t\tstrgrpname = rs.StringBox(\"Name of calculation:\")\n\t\tgrpname = rs.AddGroup(strgrpname)\n\tprint(\"Group added: \" + str(grpname))\n\trs.AddObjectsToGroup(pts, grpname)\n\treturn pts, grpname\n    \nDivideSurface(\"\")",
      "language": "python",
      "author": "Tokyo",
      "post_number": 8,
      "is_solution": false
    },
    {
      "code": "def DivideSurface(): \n    srf = rs.GetObject(\"Pick surface to divide\",rs.filter.surface)\n    spacing = rs.GetInteger(\"Spacing:\")\n    offset = rs.GetInteger(\"Offset:\")\n    u = rs.SurfaceDomain(srf,0)\n    v = rs.SurfaceDomain(srf,1)\n    \n    # Calculate the number of points we want to divide our surface into\n    udiv = int(int(max(u))/spacing)\n    vdiv = int(int(max(v))/spacing)\n     \n    # Turn off redraw\n    rs.EnableRedraw(False)\n    # Divide our surface up based on number of points required \n    for i in range(0, udiv+1, 1):\n        for j in range(0, vdiv+1, 1):\n            pt = (i/udiv,j/vdiv,0)\n            srfP = rs.SurfaceParameter(srf,pt)\n            newpt = rs.EvaluateSurface(srf,srfP[0],srfP[1])\n            matrix = rs.XformTranslation((0,0,offset))\n            newpt = rs.PointTransform(newpt, matrix)\n            pts.append(rs.AddPoint(newpt))\n    rs.EnableRedraw(True)\n    return pts",
      "language": "python",
      "author": "Tokyo",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "python",
    "rhinoscriptsyntax",
    "selection",
    "transformation",
    "ui"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 8,
  "views": 2966
}