{
  "source_url": "https://github.com/chinsohyun/MMGModeler/blob/f9e8fb18e08fc9ac13d56a9abd5158315ef4facc/Archives/MMG_form-finder_250107.py",
  "repo": "chinsohyun/MMGModeler",
  "repo_stars": 0,
  "repo_description": "3D Interface for Minimal Making Grammar",
  "license": "unknown",
  "filepath": "Archives/MMG_form-finder_250107.py",
  "instruction": "Mmg form finder 250107",
  "code": "import rhinoscriptsyntax as rs\nimport Eto.Forms as forms\nimport Eto.Drawing as drawing\n\n# class StopRecursionException(Exception):\n#     pass\n\nclass RemoteControlPanel(forms.Form):\n    def __init__(self):\n        self.Title = \"A Minimal Making Grammar\"\n        self.ClientSize = drawing.Size(300, 115)\n\n        self.seed_label = forms.Label(Text=\"Seed type(0-4):\")\n        self.seed_input = forms.NumericUpDown(Value=0, MinValue=0, MaxValue=4)\n\n        self.mode_label = forms.Label(Text=\"Mode:\")\n        self.mode_input = forms.ComboBox()\n        self.mode_input.Items.Add(\"Mode 1\")\n        self.mode_input.Items.Add(\"Mode 2\")\n        self.mode_input.Items.Add(\"Mode 3\")\n        self.mode_input.SelectedIndex = 2 \n\n        self.threshold_label = forms.Label(Text=\"Threshold(# of generation):\")\n        self.threshold_input = forms.TextBox()\n\n        self.run_button = forms.Button(Text=\"Run\")\n        self.run_button.Click += self.on_run_button_click\n\n#        self.break_button = forms.Button(Text=\"Break\")\n#        self.break_button.Click += self.on_break_button_click\n#        self.break_button.Enabled = False  \n        \n        layout = forms.DynamicLayout()\n        layout.AddRow(self.seed_label, self.seed_input)\n        layout.AddRow(self.mode_label, self.mode_input)\n        layout.AddRow(self.threshold_label, self.threshold_input)\n        layout.AddRow(None, self.run_button)\n#        layout.AddRow(None, self.break_button)\n        \n        self.Content = layout\n        \n        self.stop_flag = False\n\n        \n    def on_run_button_click(self, sender, e):\n        try:\n            seed = int(self.seed_input.Value)\n            mode = self.mode_input.SelectedIndex  \n            threshold_str = self.threshold_input.Text\n            if threshold_str == \"\":  # Ensure threshold is not empty\n                rs.MessageBox(\"Threshold value is required.\")\n                return\n            threshold = int(threshold_str)\n    \n            center_cord = (0, 0, 0)   \n            container = [center_cord]\n                    \n            if mode == 0: #mode 1\n                ps_box = [] \n                c_box = [] \n                brep = rs.AddSphere((0, 0, 0), 30)\n                # brep = rs.GetObject(\"select 3D object\")\n                cuboctahedron_symmetry(center_cord, 0, seed, threshold, container, brep, ps_box, c_box)\n                rs.DeleteObject(brep)\n            elif mode == 1: #mode 2\n                cuboctahedron(center_cord, 0, seed, threshold, container)\n    \n            elif mode == 2: #mode 3\n                three_set = []  \n                center_pt = rs.AddPoint( (0, 0, 0) )\n                center_cord = rs.PointCoordinates(center_pt)   \n                container = [center_cord]\n                cuboctahedron_unit(center_cord, 0, seed, threshold, container, three_set)\n                \n        # except StopRecursionException:\n        #     # Handle stop recursion exception to exit gracefully\n        #     rs.MessageBox(\"Process was stopped.\")\n            \n        except Exception as ex:\n            # Handle unexpected errors gracefully\n            rs.MessageBox(\"An error occurred: {}\".format(str(ex)))\n        \n#        finally:\n#            # Disable the break button once the process is done\n#            self.stop_flag = True\n#            self.break_button.Enabled = False\n            \n\n###############################################################################\n\ndef square(w, l, offset, pt_cord, next_cord): #3\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2] * 2 * w/l))\n        pt1a = rs.AddPoint((a, b + offset[1] * 0.2, c + offset[2]* (1-2 * w/l))) \n        pt2 = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* (1-2 * w/l)))\n        pt2a = rs.AddPoint((a, b + offset[1] * 0.8 , c + offset[2]* 2 * w/l))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        ptb = rs.AddPoint((a, b, next_cord[2]))\n        nptb = rs.AddPoint((next_cord[0], next_cord[1], c))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.2))\n        pt1a = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.2))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.8))\n        pt2a = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.8))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n        ptb = rs.AddPoint((next_cord[0], b, c))\n        nptb = rs.AddPoint((a, next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * 2 * w/l, c))\n        pt1a = rs.AddPoint((a + offset[0] * 0.2, b + offset[1] * (1-2 * w/l), c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * (1-2 * w/l), c))\n        pt2a = rs.AddPoint((a + offset[0] * 0.8, b + offset[1] * 2 * w/l, c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n        ptb = rs.AddPoint((a, next_cord[1], c))\n        nptb = rs.AddPoint((next_cord[0], b, next_cord[2]))\n\n    rect = [pt1, pt1a, pt2, pt2a, pt1]\n    big_rect = [pt_cord, ptb, next_cord, nptb, pt_cord]\n#    poly_points = [pt0, pt1, pt1a, pt2, pt2a, npt]\n    rs.HideObjects(rect)\n    rs.HideObjects([ptb, nptb])\n#    polyline = rs.AddPolyline(rect)\n    polyline1 = rs.AddPolyline(big_rect)\n    \n    polyline2 = rs.AddPolyline([pt0, pt1, pt2, npt])\n#    rs.AddSweep2(big_rect, big_rect, False )\n    return [polyline1, polyline2]\n    \ndef diagonal(w, l, offset, pt_cord, next_cord): #0\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.1, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.9, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.1))\n        pt2 = rs.AddPoint((a + offset[0] *(1-2 * w/l), b, c + offset[2] * 0.9))\n        npt = rs.AddPoint((a + offset[0] *(1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.1, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.9, b + offset[1]  * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2*w/l), next_cord[2]))\n\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n        \ndef triangle_shape(w, l, offset, pt_cord, next_cord): #2\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n        \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.95 , c + offset[2]* (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2]* (1-2 * w/l)))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.95))\n        npt = rs.AddPoint((a + offset[0]* (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.95, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    rs.HideObjects(poly_points)\n    polyline = rs.AddPolyline(poly_points)\n    return polyline\n    \ndef z_shape(w, l, offset, pt_cord, next_cord): #1\n    rs.DefaultRenderer(False)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    \n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b , c + offset[2] * 2 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * 2 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 0.5, c + offset[2] * (1-2 * w/l)))\n        npt = rs.AddPoint((next_cord[0], next_cord[1], c + offset[2] * (1-2 * w/l)))\n\n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 2 * w/l, b, c + offset[2] * 0.5))\n        pt2 = rs.AddPoint((a + offset[0] * (1-2 * w/l), b, c + offset[2] * 0.5))\n        npt = rs.AddPoint((a + offset[0] * (1-2 * w/l), next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 2 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * 2 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 0.5, b + offset[1] * (1-2 * w/l), c))\n        npt = rs.AddPoint((next_cord[0], b + offset[1] * (1-2 * w/l), next_cord[2]))\n\n    poly_points = [pt0, pt1, pt2, npt]\n    \n    polyline = rs.AddPolyline(poly_points)\n    rs.DeleteObjects(poly_points)\n    return polyline\n\ndef surface(w, l, offset, pt_cord, next_cord): #4\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    if offset[0] == 0:\n        pt0 = rs.AddPoint((a, b, c + offset[2] * 4 * w/l))\n        pt1 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c + offset[2] * 4 * w/l))\n        pt2 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c))\n        \n        pt3 = rs.AddPoint((a, b + offset[1], c + offset[2] * (1-4 * w/l)))\n        pt4 = rs.AddPoint((a, b + offset[1] * (1-4 * w/l), c + offset[2] * (1-4 * w/l)))\n        pt5 = rs.AddPoint((a, b + offset[1] * (1-4 * w/l), c + offset[2]))\n        \n        ptb = rs.AddPoint((a, b, next_cord[2]))\n        nptb = rs.AddPoint((next_cord[0], next_cord[1], c))\n        \n    elif offset[1] == 0:\n        pt0 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c))\n        pt1 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c + offset[2] * 4 * w/l))\n        pt2 = rs.AddPoint((a, b, c + offset[2] * 4 * w/l))\n        \n        pt3 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b, c + offset[2]))\n        pt4 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b, c + offset[2] * (1-4 * w/l)))\n        pt5 = rs.AddPoint((a + offset[0], b, c + offset[2] * (1-4 * w/l)))\n        \n        ptb = rs.AddPoint((next_cord[0], b, c))\n        nptb = rs.AddPoint((a, next_cord[1], next_cord[2]))\n\n    elif offset[2] == 0:\n        pt0 = rs.AddPoint((a, b + offset[1] * 4 * w/l, c))\n        pt1 = rs.AddPoint((a + offset[0] * 4 * w/l, b + offset[1] * 4 * w/l, c))\n        pt2 = rs.AddPoint((a + offset[0] * 4 * w/l, b, c))\n        \n        pt3 = rs.AddPoint((a + offset[0], b + offset[1] * (1-4 * w/l), c))\n        pt4 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b + offset[1] * (1-4 * w/l), c))\n        pt5 = rs.AddPoint((a + offset[0] * (1-4 * w/l), b + offset[1], c))\n\n        ptb = rs.AddPoint((a, next_cord[1], c))\n        nptb = rs.AddPoint((next_cord[0], b, next_cord[2]))\n\n    big_rect = [pt_cord, ptb, next_cord, nptb, pt_cord]\n    small_rect1 = [pt_cord, pt0, pt1, pt2, pt_cord]\n    small_rect2 = [next_cord, pt3, pt4, pt5, next_cord]\n    rs.HideObjects([pt0, pt1, pt2, pt3, pt4, pt5, nptb, ptb])\n    square1 = rs.AddPolyline(big_rect)\n    point = rs.CurveAreaCentroid(square1)\n    \n    square2 = rs.ScaleObject(square1, point[0], [0.8, 0.8, 0.8])\n    square3 = rs.AddPolyline(small_rect1)\n    square4 = rs.AddPolyline(small_rect2)\n\n    rs.HideObjects([square1, square2, square3, square4])\n    assemble = rs.CurveBooleanUnion([square2, square3, square4])\n    \n    return assemble\n\ndef cuboctahedron_symmetry(pt_cord, rotation, mode, number, container, boundary, ps_box, c_box):\n    rs.DefaultRenderer(False)\n    \n    if rotation >= number:\n        return\n\n    length = 30\n    width = 1\n    \n    container.append(pt_cord)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    x = length/2\n    \n    offsets = [\n            (x, x, 0), (x, -x, 0), (-x, x, 0), (-x, -x, 0),  # p_xy plane\n            (0, x, x), (0, x, -x), (0, -x, x), (0, -x, -x),  # p_yz plane\n            (x, 0, x), (-x, 0, x), (x, 0, -x), (-x, 0, -x)   # p_zx plane\n    ]\n            \n    for offset in offsets:\n        next_pt = rs.AddPoint((a + offset[0], b + offset[1], c + offset[2]))\n        rs.HideObject(next_pt)\n        next_cord = rs.PointCoordinates(next_pt)\n\n        if rs.IsPointInSurface(boundary, next_cord):\n            if next_cord not in container:\n                if mode in [0, 1, 2]:\n                    if mode == 0:\n                            polyline = diagonal(width, length, offset, pt_cord, next_cord)\n            \n                    elif mode == 1:\n                            polyline = z_shape(width, length, offset, pt_cord, next_cord)\n    \n                    elif mode == 2:\n                            polyline = triangle_shape(width, length, offset, pt_cord, next_cord)\n    \n                    rs.HideObjects(polyline)\n    \n                    if offset[0] == 0:\n                        pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n                        pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n                    if offset[1] == 0:\n                        pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n                        pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n                    if offset[2] == 0:\n                        pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n                        pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n                    shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n                    shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n                    ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n                    rs.DeleteObjects([shape1, pl1, shape2, pl2])\n                else:\n                    if mode == 3:\n                        polylines = square(width, length, offset, pt_cord, next_cord)\n                    \n                    elif mode == 4:\n                        polylines = surface(width, length, offset, pt_cord, next_cord)\n                    \n                        ps = rs.AddPlanarSrf(polylines)\n                    if type(polylines) == list:\n                        rs.DeleteObjects(polylines)\n                    else:\n                        rs.DeleteObject(polylines)\n                c_box.append(next_cord)\n                ps_box.append(ps)\n                \n                cuboctahedron_symmetry(next_cord, rotation + 1, mode, number, container, boundary, ps_box, c_box)\n\n\ndef cuboctahedron(pt_cord, rotation, mode, number, container):\n    rs.DefaultRenderer(False)\n    if rotation >= number:\n        return\n        \n    len = 30\n    width = 1\n    \n    container.append(pt_cord)\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n\n    x = len/2\n    \n    offsets = [\n            (x, x, 0), (x, -x, 0), (-x, x, 0), (-x, -x, 0),  # p_xy plane\n            (0, x, x), (0, x, -x), (0, -x, x), (0, -x, -x),  # p_yz plane\n            (x, 0, x), (-x, 0, x), (x, 0, -x), (-x, 0, -x)   # p_zx plane\n    ]\n    \n    next_pts = []\n    for offset in offsets:\n        next_pt = rs.AddPoint((a + offset[0], b + offset[1], c + offset[2]))\n        next_pts.append(next_pt)\n        next_cord = rs.PointCoordinates(next_pt)\n        \n        if next_cord not in container:\n            if mode in [0, 1, 2]:\n                if mode == 0:\n                     polyline = diagonal(width, len, offset, pt_cord, next_cord)\n        \n                elif mode == 1:\n                     polyline = z_shape(width, len, offset, pt_cord, next_cord)\n\n                elif mode == 2:\n                     polyline = triangle_shape(width, len, offset, pt_cord, next_cord)\n\n                rs.HideObjects(polyline)\n                #offset\n                if offset[0] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n                if offset[1] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n                if offset[2] == 0:\n                    pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n                    pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n                shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n                shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n                \n                ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n            else:\n                 if mode == 3:\n                    polylines = square(width, len, offset, pt_cord, next_cord)\n                 \n                 elif mode == 4:\n                    polylines = surface(width, len, offset, pt_cord, next_cord)\n                    \n                    rs.AddPlanarSrf(polylines)\n    pick_pt = rs.GetPoint(\"Select the next point: \", (0, 0, 0))\n    \n    cuboctahedron(pick_pt, rotation + 1, mode, number, container)\n\n\ndef point_set(pt_cord, len):\n    x = len/2\n    a = pt_cord[0]\n    b = pt_cord[1]\n    c = pt_cord[2]\n    offset_cords = [\n        (a + x, b + x, c), (a + x, b - x, c), (a - x, b + x, c), (a - x, b - x, c),  # p_xy plane\n        (a, b + x, c + x), (a, b + x, c - x), (a, b - x, c + x), (a, b - x, c - x),  # p_yz plane\n        (a + x, b, c + x), (a - x, b, c + x), (a + x, b, c - x), (a - x, b, c - x)   # p_zx plane\n    ]\n    return offset_cords\n\ndef draw_mode(mode, width, len, offset, pt_cord, next_cord):\n    \n    if mode in [0, 1, 2]:\n        if mode == 0:\n             polyline = diagonal(width, len, offset, pt_cord, next_cord)\n\n        elif mode == 1:\n             polyline = z_shape(width, len, offset, pt_cord, next_cord)\n\n        elif mode == 2:\n             polyline = triangle_shape(width, len, offset, pt_cord, next_cord)\n\n        rs.HideObjects(polyline)\n        #offset\n        if offset[0] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [1, 0, 0])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [1, 0, 0])\n        if offset[1] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 1, 0])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 1, 0])\n        if offset[2] == 0:\n            pl1 = rs.OffsetCurve(polyline, pt_cord, width, [0, 0, 1])\n            pl2 = rs.OffsetCurve(polyline, pt_cord, -width, [0, 0, 1])\n        shape1 = rs.AddLine(rs.CurveStartPoint(pl1), rs.CurveStartPoint(pl2))\n        shape2 = rs.AddLine(rs.CurveEndPoint(pl1), rs.CurveEndPoint(pl2))\n        \n        ps = rs.AddPlanarSrf([shape1, pl1, shape2, pl2])\n        \n    else:\n         if mode == 3:\n            polylines = square(width, len, offset, pt_cord, next_cord)\n         \n         elif mode == 4:\n            polylines = surface(width, len, offset, pt_cord, next_cord)\n         ps = rs.AddPlanarSrf(polylines)\n    return ps\n\n#def point_set_when_rotation_1(point):\n#    pass\n\n\ndef cuboctahedron_unit(pt_cord, rotation, mode, threshold, container, three_set):\n\n    if rotation >= threshold:\n        return\n        \n    len = 30\n    width = 1\n    offset_cords = point_set(pt_cord, len)\n    \n    #s_points\n    temp_circle = []\n    if rotation == 3:\n        rotation = 0\n        s_points= []\n        for s_point in container:\n            s_points.append(rs.AddPoint(s_point))\n            \n            temp_circle.append(rs.AddCircle(s_point, 3))\n            \n        #pt_cord updated\n        pt_cord = rs.GetPoint(\"Select a new center: \", container[-1])\n        rs.DeleteObjects(temp_circle)\n        #update offset_cords\n        offset_cords = point_set(pt_cord, len)\n        #hide s_points\n        rs.HideObjects(s_points)\n        \n        \n    #n_points\n    n_points = []\n    \n    if rotation == 1:  ###############\n\n        pt1 = pt_cord\n        pt2 = container[-1] #selected point just before\n        vec = pt2 - pt1\n        a = vec[0]\n        b = vec[1]\n        c = vec[2]\n        x = len/2\n        if a == 0:\n            offset_cords = [[(a + x, b, 0), (a - x, b, 0)], #perpendicular\n                        [(a + x, 0, c), (a - x, 0, c)],\n                        [(a + x, b, 0), (a, b, -c)], #extension\n                        [(a - x, b, 0), (a, b, -c)],\n                        [(a + x, 0, c), (a, -b, c)],\n                        [(a - x, 0, c), (a, -b, c)]]\n        if b == 0:\n            offset_cords = [[(a, b + x, 0), (a, b - x, 0)],\n                        [(0, b + x, c), (0, b - x, c)],\n                        [(a, b + x, 0), (a, b, -c)], #extension\n                        [(a, b - x, 0), (a, b, -c)],\n                        [(0, b + x, c), (-a, b, c)],\n                        [(0, b - x, c), (-a, b, c)]]\n        if c == 0:\n            offset_cords = [[(0, b, c + x), (0, b, c - x)],\n                        [(a, 0, c + x), (a, 0, c - x)],\n                        [(0, b, c + x), (-a, b, c)], #extension\n                        [(0, b, c - x), (-a, b, c)],\n                        [(a, 0, c + x), (a, -b, c)],\n                        [(a, 0, c - x), (a, -b, c)]]\n        \n        for set in offset_cords:\n            for point in set:\n                n_point = rs.AddPoint(rs.VectorAdd(point, pt1))\n                n_points.append(n_point)\n        next_cord = rs.GetPoint(\"Select the next point: \", n_points[0])\n        \n        rs.HideObjects(n_points)\n        \n        #save the three sets\n        for set in offset_cords:\n            three_set.append(set)\n\n        offset = [0,0,0]\n        for i in range(3):\n            offset[0] = next_cord[0] - pt_cord[0]\n            offset[1] = next_cord[1] - pt_cord[1]\n            offset[2] = next_cord[2] - pt_cord[2]\n        #condition unecessary\n        ps = draw_mode(mode, width, len, offset, pt_cord, next_cord)\n\n    elif rotation == 2:###############\n\n        for set in three_set:\n            #if statement necessary\n            for item in set:\n                #condition unecessary\n                n_point = rs.AddPoint(rs.VectorAdd(item, pt_cord))\n                n_points.append(n_point)\n        next_cord = rs.GetPoint(\"Select the next point: \", n_points[0])\n        print(tuple(next_cord), tuple(pt_cord))\n        rs.HideObjects(n_points)\n        \n        offset = [0,0,0]\n        for i in range(3):\n            offset[0] = next_cord[0] - pt_cord[0]\n            offset[1] = next_cord[1] - pt_cord[1]\n            offset[2] = next_cord[2] - pt_cord[2]\n        #condition unecessary\n        ps = draw_mode(mode, width, len, offset, pt_cord, next_cord)\n        three_set=[]\n        \n    else: ###############\n\n        for cord in offset_cords:\n            point = rs.AddPoint(cord)\n            n_points.append(point)\n            \n        next_cord = rs.GetPoint(\"Select the next point: \", n_points[0])\n        rs.HideObjects(n_points)\n        offset = next_cord - pt_cord\n        \n        #start draw according to the mode\n        if next_cord not in container:\n            ps = draw_mode(mode, width, len, offset, pt_cord, next_cord)\n\n            \n    container.append(next_cord)\n    cuboctahedron_unit(pt_cord, rotation + 1, mode, threshold, container, three_set)\n        \n\nform = RemoteControlPanel()\nform.Show()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}