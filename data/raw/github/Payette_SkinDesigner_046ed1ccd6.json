{
  "source_url": "https://github.com/Payette/SkinDesigner/blob/f53b5e9262a1e7a3da19c58d90c773e7cdb953d6/src/SkinDesigner_SkinDesigner.py",
  "repo": "Payette/SkinDesigner",
  "repo_stars": 9,
  "repo_description": "SkinDesigner facade panelization tool for Grasshopper",
  "license": "GPL-3.0",
  "filepath": "src/SkinDesigner_SkinDesigner.py",
  "instruction": "This is the main SkinDesigner component which contains the Panel, Skin and BaseDesignFunction APIs. \n-\n    Args:",
  "code": "# SkinDesigner: A Plugin for Building Skin Design (GPL) started by Santiago Garay \n\n# This file is part of SkinDesigner.(Rhino 6)\n# \n# Copyright (c) 2017, Santiago Garay <sgaray1970@gmail.com> \n# SkinDesigner is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# SkinDesigner is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with SkinDesigner; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n# By Santiago Garay\n# SkinDesigner_SkinDesigner\n\n\n\"\"\"\nThis is the main SkinDesigner component which contains the Panel, Skin and BaseDesignFunction APIs. \n-\n    Args:\n\n\n    Returns:\n\n\n\"\"\"\n\nghenv.Component.Name = \"SkinDesigner_SkinDesigner\"\nghenv.Component.NickName = 'SkinDesigner'\nghenv.Component.Message = 'VER 0.1.18\\nMar_15_2018'\nghenv.Component.Category = \"SkinDesigner\"\nghenv.Component.SubCategory = \"01 | Construction\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\n# push ladybug component to back\nghenv.Component.OnPingDocument().SelectAll()\nghenv.Component.Attributes.Selected = False\nghenv.Component.OnPingDocument().BringSelectionToTop()\nghenv.Component.OnPingDocument().DeselectAll()\n\nimport rhinoscriptsyntax as rs\nimport copy\nfrom types import *\nimport scriptcontext as sc\nimport Rhino\nimport Rhino.Geometry as rg\nimport random\nimport math\n\n\n\n\n#init set up global variables\n\nsc.doc = Rhino.RhinoDoc.ActiveDoc\nunitSystem = sc.doc.ModelUnitSystem\n_UNIT_COEF = 1\nif unitSystem == Rhino.UnitSystem.Feet: _UNIT_COEF = 3.28084\nif unitSystem == Rhino.UnitSystem.Inches: _UNIT_COEF = 3.28084*12\nif unitSystem == Rhino.UnitSystem.Millimeters: _UNIT_COEF = 1000\nsc.doc = ghdoc\n\n\n\nclass Panel:\n    \n    \n    \n    #----------------------------------------------------------------------------------------------------------------------\n    #CONSTRUCTOR ----------------------------------------------------------------------------------------------------------------------\n    def __init__(self):\n        \n        #Doc Parameters\n        self.__m_unitCoef = _UNIT_COEF #Coeficient used to adjust dimensions used inside Panel Class (Meter is 1)\n        self.__m_dimRoundCoef = 1.01  #Coeficient ot absorb panel grid dimensions rounding errors\n        \n        #Skin Context Parameters\n        self.__m_SkinParent = None\n        self.__m_SkinParentName = None\n        self.__m_SkinPlacementType = None\n\n        #Panel Parameters\n        self.__m_strName = \"\"\n        self.__m_arrBlockInstances=[]\n        self.__m_strDrawMode = \"DEFAULT\"\n        self.__m_warningData = [] # panel warning data will be stored here\n        \n        #Wall Default Parameters\n        self.__m_dblHeight = 3.5 * self.__m_unitCoef\n        self.__m_dblWidth = 1.5 * self.__m_unitCoef\n        self.__m_dblWallThickness = 0.1 * self.__m_unitCoef\n        self.__m_blnShowWall = True\n        self.__m_arrWallObjects = [0]\n        self.__m_arrWallBreps = [0] \n        \n        #Pane Parameters (default feet units)\n        self.__m_strPaneName = \"Default-Pane\"\n        self.__m_dblPaneThickness = 0.02 * self.__m_unitCoef\n        self.__m_dblPaneOffset = 0.06 * self.__m_unitCoef\n        self.__m_dblPaneOffsetEdge = 0\n        self.__m_blnShowPane = False\n        self.__m_arrPaneObjects = [0]\n        self.__m_arrPaneBreps = [0]\n        self.__m_dblPaneTileWidth = 0\n        self.__m_dblPaneTileHeight = 0\n        self.__m_dblPaneTileThickness = 0\n        self.__m_dblPaneTileGap = 0\n    \n        #Window\n        self.__m_arrWindowPoints = [0,0,0,0]\n        self.__m_dblWinGlassThickness = 0    #: Glass Thickness\n        self.__m_dblWinGlassOffset = 0       #: Distance From Outer Surface of Glass to Outer Surface of Wall\n        self.__m_arrWindowObjects = [0]\n        self.__m_arrWindowBreps = [0]\n        self.__m_blnShowWindow = False\n        self.__m_arrWindowUserData = dict(width=0, height=0, fromLeft=0, fromBottom=0, recess = 0, thickness = 0)\n        \n        #Mulions Parameters (default feet units)\n        self.__m_dblMullionWidth = 0.05 * self.__m_unitCoef\n        self.__m_dblMullionThickness = 0.1 * self.__m_unitCoef\n        self.__m_dblMullionCapThickness = 0.05 * self.__m_unitCoef\n        self.__m_blnShowMullions = False\n        self.__m_blnShowMullionsCap = False\n        \n        #Initialize mullion data\n        self.__m_arrMullionHorObjects = [0]\n        self.__m_arrMullionVertObjects = [0]\n        self.__m_arrMullionHorBreps = [[0]]\n        self.__m_arrMullionVertBreps = [[0]]\n        \n        self.__m_arrMullionVertUserData = [[],[],[],[],[]]\n        self.__m_arrMullionHorUserData = [[],[],[],[],[]]\n        \n        \n        #Init Shading data\n        self.__m_blnShowShading = False\n        self.__m_arrShadingObjects = [0]\n        self.__m_arrShadingUserData = [[],[],[],[],[],[],[],[],[],[]]\n        #--------------------------------------------------------\n        #Deform Paramters\n        \n        self.__m_arrDeformBox=[]\n        self.__m_arrBoundingBox=[]\n        self.__m_blnShowDeform = False\n        self.__m_arrBoundingBox = self.__ResetBoundingBox()\n        \n        self.__m_ConditionalDefinitions = dict()\n        #----------------------------------------------------------------------------\n        \n        #CustomGeometry Paramters\n        self.__m_blnShowCustomGeo = 0\n        self.__m_CustomGeoBreps = []\n        self.__m_CustomGeoBaseData = []\n        self.__m_CustomGeoDrawBreps = []\n        self.__m_CustomGeoObjects = []\n        self.__m_CG_vecPlacement = rg.Vector3d(0,0,0)\n        self.__m_CG_vecScaleFactor = rg.Vector3d(1,1,1)\n        self.__m_CG_vecUpVector = rg.Vector3d(0,0,1)\n        self.__m_CG_blnTilable = False\n        self.__m_CG_dblRotation = 0\n        self.__m_CG_windowDepth = 0\n        self.__m_CG_trimToPanelSize = False\n        \n        #-----------------------------------------------------------------------------        \n        #Ladybug Parameters\n        self.__m_LadybugShadeThresh = 0.1 * self.__m_unitCoef   # min value (in meters) for shading/mullions caps to be created in \"LADYBUG\"  draw mode)\n        \n        #---------------------------------------------------------------------\n        \n    def __del__(self):\n        #print \"adios!\"\n        pass\n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #--------PROPERTIES SECTION------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def GetName(self):\n        return self.__m_strName        \n        \n    def SetName(self, someName):\n        if \"\\n\" in someName : self.__m_warningData.append(\"Invalid Name - data ignored\"); return False \n        self.__m_strName = someName\n        \n    def GetHeight(self):\n        return self.__m_dblHeight\n        \n    def SetHeight(self, someHeight):\n\n        if type(someHeight) == StringType : someHeight = eval(someHeight)\n        \n        if someHeight <= 0 : return\n        self.__m_dblHeight = someHeight\n        self.__m_arrBoundingBox = self.__ResetBoundingBox()\n                \n        self.UpdateWindow() #Check if window does fit in panel\n        \n    def GetWidth(self):\n        return self.__m_dblWidth\n        \n        \n    def SetWidth(self, someWidth):\n        \n        if someWidth <= 0 : return\n        \n        if type(someWidth) == StringType : someWidth = eval(someWidth)\n        \n        self.__m_dblWidth = someWidth\n        self.__m_arrBoundingBox = self.__ResetBoundingBox()\n        \n        self.UpdateWindow() #Check if window does fit in panel\n        \n    def GetThickness(self):\n        return self.__m_dblWallThickness\n        \n        \n    def SetThickness(self, someThickness):\n        \n        if type(someThickness) == StringType : someThickness = eval(someThickness)\n        \n        if someThickness == 0 : \n            self.__m_dblWallThickness = 0.001\n        else: self.__m_dblWallThickness = someThickness\n        \n        self.__m_arrBoundingBox = self.__ResetBoundingBox()\n        \n        \n    def SetDrawMode(self, strMode):\n        if strMode in [\"DEFAULT\", \"LADYBUG\"] : self.__m_strDrawMode = strMode\n        \n    def GetDrawMode(self):\n        return self.__m_strDrawMode\n        \n    def GetPanelProperty(self, strPropName):\n        properties= [\"PanelHeight\", \"PanelWidth\", \"PanelThickness\", 'WindowData', \"WindowVisibility\", \"SkinPlacement\", \\\n            \"BoundingBox\", \"BlockInstances\", \"WarningData\"]\n        if strPropName in  properties :\n            return self.__GetPanelProperty(strPropName)\n        \n    def __GetPanelProperty(self, strPropName):\n\n        PanelProperty = None\n        \n        #Panel Data        \n        if strPropName == \"PanelHeight\":PanelProperty = self.__m_dblHeight\n        elif strPropName ==  \"PanelWidth\":PanelProperty = self.__m_dblWidth\n        #Wall Data\n        elif strPropName ==  \"PanelThickness\":PanelProperty = self.__m_dblWallThickness\n        elif strPropName ==  \"WallVisibility\":PanelProperty = self.__m_blnShowWall\n        elif strPropName ==  \"WallObjects\":PanelProperty = self.__m_arrWallBreps\n        #Deform Data\n        elif strPropName == \"BoundingBox\":PanelProperty = self.__m_arrBoundingBox\n        elif strPropName ==  \"DeformVisibility\":PanelProperty = self.__m_blnShowDeform\n        elif strPropName ==  \"DeformBox\":PanelProperty = self.__m_arrDeformBox\n       #Blocks Data\n        elif strPropName == \"BlockInstances\":PanelProperty = self.__m_arrBlockInstances\n       #Pane Data\n        elif strPropName ==  \"PaneName\":PanelProperty = self.__m_strPaneName\n        elif strPropName ==  \"PaneVisibility\":PanelProperty = self.__m_blnShowPane\n        elif strPropName ==  \"PaneThickness\":PanelProperty = self.__m_dblPaneThickness\n        elif strPropName ==  \"PaneOffset\":PanelProperty = self.__m_dblPaneOffset\n        elif strPropName ==  \"PaneOffsetEdge\":PanelProperty = self.__m_dblPaneOffsetEdge\n        elif strPropName ==  \"PaneObjects\":PanelProperty = self.__m_arrPaneBreps\n        elif strPropName ==  \"PaneTileWidth\":PanelProperty = self.__m_dblPaneTileWidth\n        elif strPropName ==  \"PaneTileHeight\":PanelProperty = self.__m_dblPaneTileHeight\n        elif strPropName ==  \"PaneTileThickness\":PanelProperty = self.__m_dblPaneTileThickness\n        elif strPropName ==  \"PaneTileGap\":PanelProperty = self.__m_dblPaneTileGap\n        #Window Data\n        elif strPropName ==  \"WindowPoints\":PanelProperty = self.__m_arrWindowPoints \n        elif strPropName ==  \"WindowVisibility\":PanelProperty = self.__m_blnShowWindow\n        elif strPropName ==  \"WindowGlassThickness\":PanelProperty = self.__m_dblWinGlassThickness\n        elif strPropName ==  \"WindowGlassOffset\":PanelProperty = self.__m_dblWinGlassOffset\n        elif strPropName ==  \"WindowObjects\":PanelProperty = self.__m_arrWindowBreps\n        elif strPropName == \"WindowWidth\":PanelProperty = self.__m_arrWindowPoints[1][0]-self.__m_arrWindowPoints[0][0]\n        elif strPropName == \"WindowHeight\":PanelProperty = self.__m_arrWindowPoints[2][2]-self.__m_arrWindowPoints[1][2]\n        elif strPropName == \"WindowBottom\":PanelProperty = self.__m_arrWindowPoints[0][2]\n        elif strPropName == \"WindowTop\":PanelProperty = self.GetHeight()-self.__m_arrWindowPoints[2][2]\n        elif strPropName == \"WindowLeft\":PanelProperty = self.__m_arrWindowPoints[0][0]\n        elif strPropName == \"WindowRight\":PanelProperty = self.GetWidth()-self.__m_arrWindowPoints[1][0]\n        elif strPropName == \"WindowData\":PanelProperty = self.__m_arrWindowUserData\n        #Mullion Data\n        elif strPropName ==  \"MullionWidth\":PanelProperty = self.__m_dblMullionWidth\n        elif strPropName ==  \"MullionThickness\":PanelProperty = self.__m_dblMullionThickness\n        elif strPropName ==  \"MullionCapThickness\":PanelProperty = self.__m_dblMullionCapThickness\n        elif strPropName ==  \"MullionVisibility\":PanelProperty = self.__m_blnShowMullions \n        elif strPropName ==  \"MullionCapVisibility\":PanelProperty = self.__m_blnShowMullionsCap\n        elif strPropName ==  \"MullionHorNum\":PanelProperty = len(self.__m_arrMullionHorBreps)\n        elif strPropName ==  \"MullionVertNum\":PanelProperty = len(self.__m_arrMullionVertBreps)\n        elif strPropName ==  \"MullionHorDataNum\":PanelProperty = len(self.__m_arrMullionHorUserData)\n        elif strPropName ==  \"MullionVertDataNum\":PanelProperty = len(self.__m_arrMullionVertUserData)\n        #Shading Data\n        elif strPropName ==  \"ShadingVisibility\":PanelProperty = self.__m_blnShowShading \n        elif strPropName ==  \"ShadingObjects\":PanelProperty = self.__m_arrShadingBreps\n        elif strPropName ==  \"ShadingDataNum\":PanelProperty = len(self.__m_arrShadingUserData)  \n        #Conditional definitions\n        elif strPropName ==  \"ConditionalDefinitions\":PanelProperty = self.__m_ConditionalDefinitions\n        #CustomGeometry Parameters\n        elif strPropName == \"CustomGeoVisibility\":PanelProperty = self.__m_blnShowCustomGeo\n        elif strPropName == \"CustomGeoBrep\":PanelProperty = self.__m_CustomGeoBreps\n        elif strPropName == \"CustomGeoOriginalBrep\":PanelProperty = self.__m_CustomGeoBaseData  \n        elif strPropName == \"CustomGeoPlacement\":PanelProperty = self.__m_CG_vecPlacement \n        elif strPropName == \"CustomGeoScaleFactor\":PanelProperty = self.__m_CG_vecScaleFactor\n        elif strPropName == \"CustomGeoUpVector\":PanelProperty = self.__m_CG_vecUpVector\n        elif strPropName == \"CustomGeoTilable\":PanelProperty = self.__m_CG_blnTilable\n        elif strPropName == \"CustomGeoRotation\":PanelProperty = self.__m_CG_dblRotation\n        elif strPropName == \"CustomGeoWindowDepth\":PanelProperty = self.__m_CG_windowDepth\n        elif strPropName == \"CustomGeoTrimToPanel\":PanelProperty = self.__m_CG_trimToPanelSize\n        #Energy Analysis Parameters\n        elif strPropName == \"LB_ShadeThreshold\":PanelProperty = self.__m_LadybugShadeThresh    \n        #Skin Context Paramters\n        elif strPropName == \"SkinParent\":PanelProperty = self.__m_SkinParent\n        elif strPropName == \"SkinParentName\":PanelProperty = self.__m_SkinParentName\n        elif strPropName == \"SkinPlacement\":PanelProperty = self.__m_SkinPlacementType\n        #Misc. parameters\n        elif strPropName == \"WarningData\":PanelProperty = self.__m_warningData\n            \n        return PanelProperty\n        \n            \n    def __GetPanelPropertyArray(self, strPropName, arrayIndex):\n        \n        if strPropName ==  \"MullionHorObjArray\":PanelPropertyArray = self.__m_arrMullionHorBreps[arrayIndex]\n        elif strPropName ==  \"MullionVertObjArray\":PanelPropertyArray = self.__m_arrMullionVertBreps[arrayIndex]\n        elif strPropName ==  \"MullionHorDataArray\":PanelPropertyArray = self.__m_arrMullionHorUserData[arrayIndex]\n        elif strPropName ==  \"MullionVertDataArray\":PanelPropertyArray = self.__m_arrMullionVertUserData[arrayIndex]\n        elif strPropName ==  \"ShadingDataArray\":PanelPropertyArray = self.__m_arrShadingUserData[arrayIndex]\n            \n        return PanelPropertyArray\n\n\n    def SetPanelProperty(self, strPropName, value ):\n        if strPropName in [\"DrawMode\", \"SkinPlacement\", \"LB_ShadeThreshold\", \"SkinParentName\"] :\n            self.__SetPanelProperty(strPropName, value)\n        else:\n            self.__m_warningData.append(\"Panel Parameter \"+ strPropName + \" is not valid\")\n            \n    def __SetPanelProperty(self, strPropName, value ):\n        \n        #Panel Data        \n        if strPropName == \"PanelHeight\":self.__m_dblHeight = value\n        elif strPropName ==  \"PanelWidth\":self.__m_dblWidth = value\n        #Wall Data\n        elif strPropName ==  \"PanelThickness\":self.__m_dblWallThickness = value\n        elif strPropName ==  \"WallVisibility\":self.__m_blnShowWall = value\n       #Pane Data\n        elif strPropName ==  \"PaneName\":self.__m_strPaneName = value\n        elif strPropName ==  \"PaneVisibility\":self.__m_blnShowPane = value\n        elif strPropName ==  \"PaneThickness\":self.__m_dblPaneThickness = value\n        elif strPropName ==  \"PaneOffset\":self.__m_dblPaneOffset = value\n        elif strPropName ==  \"PaneOffsetEdge\":self.__m_dblPaneOffsetEdge = value\n        elif strPropName ==  \"PaneTileWidth\":self.__m_dblPaneTileWidth = value\n        elif strPropName ==  \"PaneTileHeight\":self.__m_dblPaneTileHeight = value\n        elif strPropName ==  \"PaneTileThickness\":self.__m_dblPaneTileThickness = value\n        elif strPropName ==  \"PaneTileGap\":self.__m_dblPaneTileGap = value\n        #Window Data\n        elif strPropName ==  \"WindowPoints\":self.__m_arrWindowPoints = value\n        elif strPropName ==  \"WindowVisibility\":self.__m_blnShowWindow = value\n        elif strPropName ==  \"WindowGlassThickness\":self.__m_dblWinGlassThickness = value\n        elif strPropName ==  \"WindowGlassOffset\":self.__m_dblWinGlassOffset = value\n        elif strPropName == \"WindowWidth\":self.__m_arrWindowUserData['width'] = value\n        elif strPropName == \"WindowHeight\":self.__m_arrWindowUserData['height'] = value\n        elif strPropName == \"WindowBottom\":self.__m_arrWindowUserData['fromBottom'] = value\n        elif strPropName == \"WindowLeft\":self.__m_arrWindowUserData['fromLeft'] = value\n        elif strPropName == \"WindowData\":self.__m_arrWindowUserData = value\n        #Mullion Data\n        elif strPropName ==  \"MullionWidth\":self.__m_dblMullionWidth = value\n        elif strPropName ==  \"MullionThickness\":self.__m_dblMullionThickness = value\n        elif strPropName ==  \"MullionCapThickness\":self.__m_dblMullionCapThickness = value\n        elif strPropName ==  \"MullionVisibility\":self.__m_blnShowMullions = value \n        elif strPropName ==  \"MullionCapVisibility\":self.__m_blnShowMullionsCap = value\n        #Shading Data\n        elif strPropName ==  \"ShadingVisibility\":self.__m_blnShowShading = value\n        #array value format: [index, array data]\n        elif strPropName ==  \"ShadingIndexArray\": self.__m_arrShadingUserData[value[0]] = value[1]\n        #Conditional Defintitions\n        elif strPropName ==  \"ConditionalDefinitions\": self.__m_ConditionalDefinitions = value\n        #CustomGeometry Parameters\n        elif strPropName == \"CustomGeoVisibility\":self.__m_blnShowCustomGeo = value\n        elif strPropName == \"CustomGeoBrep\":self.__m_CustomGeoBreps = value\n        elif strPropName == \"CustomGeoOriginalBrep\":self.__m_CustomGeoBaseData = value   \n        elif strPropName == \"CustomGeoPlacement\":self.__m_CG_vecPlacement = value\n        elif strPropName == \"CustomGeoScaleFactor\":self.__m_CG_vecScaleFactor = value\n        elif strPropName == \"CustomGeoUpVector\":self.__m_CG_vecUpVector = value\n        elif strPropName == \"CustomGeoTilable\":self.__m_CG_blnTilable = value\n        elif strPropName == \"CustomGeoRotation\":self.__m_CG_dblRotation = value\n        elif strPropName == \"CustomGeoWindowDepth\":self.__m_CG_windowDepth = value\n        elif strPropName == \"CustomGeoTrimToPanel\":self.__m_CG_trimToPanelSize = value\n        #Energy Anlaysis Parameters\n        elif strPropName == \"LB_ShadeThreshold\":self.__m_LadybugShadeThresh = value\n        #Skin Context Parameters\n        elif strPropName == \"SkinParent\":self.__m_SkinParent = value\n        elif strPropName == \"SkinParentName\":self.__m_SkinParentName = value\n        elif strPropName == \"SkinPlacement\":self.__m_SkinPlacementType = value\n        else: self.__m_warningData.append(\"Invalid panel property: \" + strPropName)\n        \n        return\n        \n\n\n\n\n    def __ResetBoundingBox(self):\n        return [[0, 0, 0], [self.__m_dblWidth, 0, 0], [self.__m_dblWidth, self.__m_dblWallThickness, 0], \\\n            [0, self.__m_dblWallThickness, 0], [0, 0, self.__m_dblHeight], [self.__m_dblWidth, 0, self.__m_dblHeight], \\\n            [self.__m_dblWidth, self.__m_dblWallThickness, self.__m_dblHeight], [0, self.__m_dblWallThickness, self.__m_dblHeight]]\n            \n            \n    #----------------------------------------------------------------------------------------------------------------------\n    #--------UTILITIES SECTION------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    #Copy properties (not geometry) of provided panel\n    \n    def Copy(self, myPanel):\n        \n        #General panel properties\n        self.__m_SkinParent = myPanel.__GetPanelProperty(\"SkinParent\")\n        self.__m_SkinParentName = myPanel.__GetPanelProperty(\"SkinParentName\")        \n        self.__m_SkinPlacementType = myPanel.__GetPanelProperty(\"SkinPlacement\")\n\n        self.__m_strName = myPanel.GetName()\n        self.__m_dblHeight = myPanel.__GetPanelProperty(\"PanelHeight\") #: Wall Height\n        self.__m_dblWidth = myPanel.__GetPanelProperty(\"PanelWidth\") # Wall Width  \n        \n        self.__m_strDrawMode = myPanel.GetDrawMode()\n        self.__m_ConditionalDefinitions = copy.deepcopy(myPanel.__GetPanelProperty(\"ConditionalDefinitions\"))\n        \n        #Wall properties\n        self.__m_dblWallThickness = myPanel.__GetPanelProperty(\"PanelThickness\") #: Wall Depth\n        self.__m_blnShowWall = myPanel.__GetPanelProperty(\"WallVisibility\")\n        \n        #Pane parameters\n        self.__m_blnShowPane = myPanel.__GetPanelProperty(\"PaneVisibility\")\n        self.__m_strPaneName = myPanel.__GetPanelProperty(\"PaneName\")\n        self.__m_dblPaneThickness = myPanel.__GetPanelProperty(\"PaneThickness\")\n        self.__m_dblPaneOffset = myPanel.__GetPanelProperty(\"PaneOffset\")\n        self.__m_dblPaneOffsetEdge = myPanel.__GetPanelProperty(\"PaneOffsetEdge\")\n        \n        self.__m_dblPaneTileWidth  = myPanel.__GetPanelProperty(\"PaneTileWidth\")\n        self.__m_dblPaneTileHeight = myPanel.__GetPanelProperty(\"PaneTileHeight\")\n        self.__m_dblPaneTileThickness = myPanel.__GetPanelProperty(\"PaneTileThickness\")\n        self.__m_dblPaneTileGap = myPanel.__GetPanelProperty(\"PaneTileGap\")\n        \n        \n        #Window Parameters\n        self.__m_blnShowWindow = myPanel.__GetPanelProperty(\"WindowVisibility\") \n        self.__m_dblWinGlassThickness = myPanel.__GetPanelProperty(\"WindowGlassThickness\")\n        self.__m_dblWinGlassOffset = myPanel.__GetPanelProperty(\"WindowGlassOffset\")\n        self.__m_arrWindowPoints = copy.deepcopy(myPanel.__GetPanelProperty(\"WindowPoints\"))\n        self.__m_arrWindowUserData = copy.deepcopy(myPanel.__GetPanelProperty(\"WindowData\"))\n        \n        #Mullion Parameters\n        self.__m_blnShowMullions = myPanel.__GetPanelProperty(\"MullionVisibility\") \n        self.__m_blnShowMullionsCap = myPanel.__GetPanelProperty(\"MullionCapVisibility\")\n        self.__m_dblMullionWidth = myPanel.__GetPanelProperty(\"MullionWidth\")\n        self.__m_dblMullionThickness = myPanel.__GetPanelProperty(\"MullionThickness\") \n        self.__m_dblMullionCapThickness = myPanel.__GetPanelProperty(\"MullionCapThickness\") \n\n        #Copy mullions Data\n        self.__m_arrMullionVertUserData = []\n        self.__m_arrMullionHorUserData = []\n        \n        for i in range(myPanel.__GetPanelProperty(\"MullionHorDataNum\")):\n            arrMullions = copy.deepcopy(myPanel.__GetPanelPropertyArray(\"MullionHorDataArray\", i))\n            if type(arrMullions) == ListType :\n                self.__m_arrMullionHorUserData.append(arrMullions)\n                \n        for i in range(myPanel.__GetPanelProperty(\"MullionVertDataNum\")):\n            arrMullions = copy.deepcopy(myPanel.__GetPanelPropertyArray(\"MullionVertDataArray\", i))\n            if type(arrMullions) == ListType :\n                self.__m_arrMullionVertUserData.append(arrMullions)\n                \n                \n        #shading Parameetrs\n        self.__m_blnShowShading = myPanel.__GetPanelProperty(\"ShadingVisibility\")    \n        \n        self.__m_arrShadingUserData = []\n        for i in range(myPanel.__GetPanelProperty(\"ShadingDataNum\")):\n            arrShadingData = copy.deepcopy(myPanel.__GetPanelPropertyArray(\"ShadingDataArray\", i))\n            if type(arrShadingData) == ListType :\n                self.__m_arrShadingUserData.append(arrShadingData)\n\n        #CustomGeometry Parameters\n        self.__m_blnShowCustomGeo = myPanel.__GetPanelProperty(\"CustomGeoVisibility\")\n        self.__m_CustomGeoBreps = myPanel.__GetPanelProperty(\"CustomGeoBrep\")\n        self.__m_CustomGeoBaseData = myPanel.__GetPanelProperty(\"CustomGeoOriginalBrep\")\n        self.__m_CG_vecPlacement = myPanel.__GetPanelProperty(\"CustomGeoPlacement\")\n        self.__m_CG_vecScaleFactor = myPanel.__GetPanelProperty(\"CustomGeoScaleFactor\")\n        self.__m_CG_vecUpVector = myPanel.__GetPanelProperty(\"CustomGeoUpVector\")\n        self.__m_CG_blnTilable = myPanel.__GetPanelProperty(\"CustomGeoTilable\")\n        self.__m_CG_dblRotation = myPanel.__GetPanelProperty(\"CustomGeoRotation\")\n        self.__m_CG_windowDepth = myPanel.__GetPanelProperty(\"CustomGeoWindowDepth\")\n        self.__m_CG_trimToPanelSize = myPanel.__GetPanelProperty(\"CustomGeoTrimToPanel\")\n        \n        #Deform parameters\n        self.__m_arrDeformBox = copy.deepcopy(myPanel.__GetPanelProperty(\"DeformBox\")) # Wall Location\n        self.__m_arrBoundingBox = copy.deepcopy(myPanel.__GetPanelProperty(\"BoundingBox\"))\n        self.__m_blnShowDeform = myPanel.__GetPanelProperty(\"DeformVisibility\")\n        \n        #Energy Analysis\n        self.__m_LadybugShadeThresh = myPanel.__GetPanelProperty(\"LB_ShadeThreshold\")\n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    \n    \n\n    def CreateBlockCopy(self, strBlockName, arrAreaPanelPoints, blnFitToArea):\n        \n        blnNewBlock = False\n        \n        parentLayerName = \"SKIN_DESIGNER\"\n        if self.__m_SkinParentName <> None: parentLayerName = self.__m_SkinParentName.split(\"::\")[0]\n        if not rs.IsLayer(parentLayerName) : rs.AddLayer(parentLayerName)\n\n        currentLayer = rs.CurrentLayer() \n        \n        if not rs.IsLayer(parentLayerName+\"::_P_0\") : rs.AddLayer(\"_P_0\", parent=parentLayerName)\n        \n        rs.CurrentLayer(parentLayerName+\"::_P_0\")\n        \n        #create block if not created already\n        if not rs.IsBlock(strBlockName) :\n            \n            blnNewBlock = True\n            \n            self.DrawSceneObjects()\n            \n            arrBlockObjects = []\n            if  self.__m_arrWallObjects and not type(self.__m_arrWallObjects[0]) == IntType and rs.IsObject(self.__m_arrWallObjects[0]):\n                arrBlockObjects += self.__m_arrWallObjects\n\n            if  self.__m_arrWindowObjects and not type(self.__m_arrWindowObjects[0]) == IntType and rs.IsObject(self.__m_arrWindowObjects[0]):\n                arrBlockObjects +=  self.__m_arrWindowObjects\n            \n            if  self.__m_arrPaneObjects and not type(self.__m_arrPaneObjects[0]) == IntType and rs.IsObject(self.__m_arrPaneObjects[0]):\n                arrBlockObjects += self.__m_arrPaneObjects\n\n            if self.__m_arrMullionHorObjects and not type(self.__m_arrMullionHorObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionHorObjects[0]):\n                arrBlockObjects += self.__m_arrMullionHorObjects\n            \n            if self.__m_arrMullionVertObjects and not type(self.__m_arrMullionVertObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionVertObjects[0]):\n                arrBlockObjects += self.__m_arrMullionVertObjects\n            \n            if self.__m_arrShadingObjects and not type(self.__m_arrShadingObjects[0]) == IntType and rs.IsObject(self.__m_arrShadingObjects[0]):\n                arrBlockObjects +=  self.__m_arrShadingObjects\n            \n            if self.__m_CustomGeoObjects and type(self.__m_CustomGeoObjects) == ListType and len(self.__m_CustomGeoObjects) > 0 and rs.IsObject(self.__m_CustomGeoObjects[0]):\n                arrBlockObjects += self.__m_CustomGeoObjects\n            \n            rs.AddBlock(arrBlockObjects, self.__m_arrBoundingBox[0], strBlockName)\n            self.DeleteSceneObjects()\n            \n        #Translate and Scale based on grid points\n        \n        #Start from Panel Original Bounding Box\n        arrBoxPoints = self.__m_arrBoundingBox\n        \n        #Move Bounding Box to new locatation Plane (to avoid panel depth distortions)\n        arrStartPlane = rs.PlaneFromPoints(arrBoxPoints[0], arrBoxPoints[1], arrBoxPoints[4]) #Create Plane from current Boundng Box points\n        arrEndPlane = rs.PlaneFromPoints(arrAreaPanelPoints[0], arrAreaPanelPoints[1], arrAreaPanelPoints[2])#Create Plane from Panels Area points\n        \n        #Apply Transf. Matrix from planes on Bounding Box\n        arrXform = rs.XformRotation1(arrStartPlane, arrEndPlane)\n        arrNewBoxPoints = rs.PointArrayTransform(arrBoxPoints, arrXform)\n        \n        if blnFitToArea : #scale to fit area only if specified\n            arrScaleXform = rs.XformScale([(rs.Distance(arrNewBoxPoints[0], arrAreaPanelPoints[1]) / rs.Distance(arrNewBoxPoints[0], arrNewBoxPoints[1])), 1,\\\n                (rs.Distance(arrNewBoxPoints[0], arrAreaPanelPoints[2]) / rs.Distance(arrNewBoxPoints[0], arrNewBoxPoints[4]))])\n            arrXform = rs.XformMultiply(arrXform, arrScaleXform)\n        \n        \n        #Create Copy and move to location\n        if rs.IsBlock(strBlockName) :\n            self.__m_arrBlockInstances.append(rs.InsertBlock2(strBlockName, arrXform))\n            \n        rs.CurrentLayer(currentLayer)\n        return blnNewBlock\n    \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def DeleteBlockCopies(self):\n\n        if self.__m_arrBlockInstances :\n            \n            if rs.IsBlockInstance(self.__m_arrBlockInstances[0]):\n                rs.BlockInstanceName(self.__m_arrBlockInstances[0])\n                rs.DeleteBlock(rs.BlockInstanceName(self.__m_arrBlockInstances[0]))\n                \n            __m_arrBlockInstances = []\n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def DeleteSceneObjects(self):\n\n        if  type(self.__m_arrWallObjects) == ListType and not type(self.__m_arrWallObjects[0]) == IntType and rs.IsObject(self.__m_arrWallObjects[0]): \n            rs.DeleteObjects(self.__m_arrWallObjects)\n     \n        if  self.__m_arrPaneObjects and not type(self.__m_arrPaneObjects[0]) == IntType and rs.IsObject(self.__m_arrPaneObjects[0]):\n            rs.DeleteObjects(self.__m_arrPaneObjects)\n             \n        if  self.__m_arrWindowObjects and not type(self.__m_arrWindowObjects[0]) == IntType and rs.IsObject(self.__m_arrWindowObjects[0]): \n            rs.DeleteObjects(self.__m_arrWindowObjects)\n\n        if self.__m_arrMullionHorObjects and not type(self.__m_arrMullionHorObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionHorObjects[0]):\n            rs.DeleteObjects(self.__m_arrMullionHorObjects)\n        \n        if self.__m_arrMullionVertObjects and not type(self.__m_arrMullionVertObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionVertObjects[0]):\n            rs.DeleteObjects(self.__m_arrMullionVertObjects)\n                \n        if  self.__m_arrShadingObjects and not type(self.__m_arrShadingObjects[0]) == IntType and rs.IsObject(self.__m_arrShadingObjects[0]): \n            rs.DeleteObjects(self.__m_arrShadingObjects)\n            \n        if self.__m_CustomGeoObjects and type(self.__m_CustomGeoObjects) == ListType and len(self.__m_CustomGeoObjects) > 0 and rs.IsObject(self.__m_CustomGeoObjects[0]):\n            rs.DeleteObjects(self.__m_CustomGeoObjects)\n\n    #----------------------------------------------------------------------------------------------------------------------\t \n    #PANEL TRANSFORMATION SECTION\n    #----------------------------------------------------------------------------------------------------------------------\n    \n    #Distort/transform Morphing Bounding Box only, leave data ready for DrawMorph command\n    def MorphPanel(self, arrAreaPanelPoints):\n        \n        \n        #Start from Panel Original Bounding Box\n        arrBoxPoints = self.__m_arrBoundingBox\n        \n        #Move Bounding Box to new locatation Plane (to avoid panel depth distortions)\n        arrStartPlane = rs.PlaneFromPoints(arrBoxPoints[0], arrBoxPoints[1], arrBoxPoints[4]) #Create Plane from current Boundng Box points\n        arrEndPlane = rs.PlaneFromPoints(arrAreaPanelPoints[0], arrAreaPanelPoints[1], arrAreaPanelPoints[2])#Create Plane from Panels Area points\n        \n        #Apply Transf. Matrix from planes on Bounding Box\n        arrRotXform = rs.XformRotation1(arrStartPlane, arrEndPlane)\n        arrNewBoxPoints = rs.PointArrayTransform(arrBoxPoints, arrRotXform)\n        \n        arrScaleXform = rs.XformScale([(rs.Distance(arrNewBoxPoints[0], arrAreaPanelPoints[1]) / rs.Distance(arrNewBoxPoints[0], arrNewBoxPoints[1])), 1.0,\\\n            (rs.Distance(arrNewBoxPoints[0], arrAreaPanelPoints[2]) / rs.Distance(arrNewBoxPoints[0], arrNewBoxPoints[4]))])\n        arrXform = rs.XformMultiply(arrRotXform, arrScaleXform)\n        \n        self.__m_TransformMatrix = arrXform\n        \n        # Move panel corners to fill new area\n        #TopLeft\n        #arrTransVector = rs.VectorCreate(arrAreaPanelPoints[2], arrNewBoxPoints[4])\n        #arrTransPointXform = rs.XformTranslation(arrTransVector)\n        #arrNewBoxPoints[4] = rs.PointTransform(arrNewBoxPoints[4], arrTransPointXform)\n        #arrNewBoxPoints[7] = rs.PointTransform(arrNewBoxPoints[7], arrTransPointXform)\n        #TopRight\n        #arrTransVector = rs.VectorCreate(arrAreaPanelPoints[3], arrNewBoxPoints[5])\n        #arrTransPointXform = rs.XformTranslation(arrTransVector)\n        #arrNewBoxPoints[5] = rs.PointTransform(arrNewBoxPoints[5], arrTransPointXform)\n        #arrNewBoxPoints[6] = rs.PointTransform(arrNewBoxPoints[6], arrTransPointXform)\n        #BottomRight'\n        #arrTransVector = rs.VectorCreate(arrAreaPanelPoints[1], arrNewBoxPoints[1])\n        #arrTransPointXform = rs.XformTranslation(arrTransVector)\n        #arrNewBoxPoints[1] = rs.PointTransform(arrNewBoxPoints[1], arrTransPointXform)\n        #arrNewBoxPoints[2] = rs.PointTransform(arrNewBoxPoints[2], arrTransPointXform)\n        \n        \n        #Store new Bounding Box ready for Draw()\n        self.__m_arrDeformBox = arrNewBoxPoints\n        self.__m_blnShowDeform = True\n\n\n    #----------------------------------------------------------------------------------------------------------------------\t \n    #PANEL CONDITIONAL DEFINITIONS SECTION\n    #Data Matrix with panel properties-based conditionals and Function-based Definitions (ex: \"PanelWidth < 1.0\", \"DeleteWindow()\")    \n    #----------------------------------------------------------------------------------------------------------------------\n\n    def AddConditionalDefinition(self, strCondition, strAction):\n        \n        \n        if strCondition not in self.__m_ConditionalDefinitions:\n            self.__m_ConditionalDefinitions[strCondition] = []\n        self.__m_ConditionalDefinitions[strCondition].append(strAction)\n\n\n\n    def DeleteConditionalDefinition(self, strCondition, strAction=\"All\"):\n        \n        if strCondition not in self.__m_ConditionalDefinitions: return False\n        \n        if strAction == \"All\" : \n            del self.__m_ConditionalDefinitions[strCondition]\n            return True\n            \n        tmpDefList = self.__m_ConditionalDefinitions[strCondition]\n        if  strAction in tmpCondef : \n            tmpDefList.remove(strAction)\n            return True\n            \n        return False\n    \n    \n    \n    def GetConditionalDefinition(self, strCondition=\"All\"):\n        if strCondition == \"All\":\n            return copy.deepcopy(self.__m_ConditionalDefinitions)\n        else: \n            return copy.deepcopy(self.__m_ConditionalDefinitions[strCondition])\n    \n    \n    def RunConditionalDefinition(self, strCondition=None):\n\n        conditionList = []\n        if strCondition <> None:\n            if strCondition not in self.__m_ConditionalDefinitions: return False\n            conditionList = [strCondition]\n        else: \n            conditionList = self.__m_ConditionalDefinitions.keys()\n            \n        for condition in conditionList:\n            parsedList = condition.split()\n            parsedCondition = \"if self.GetPanelProperty('\"+parsedList[0]+\"') \"+parsedList[1]+\" \"+parsedList[2]+\" : \"\n            \n            actionList = self.__m_ConditionalDefinitions[condition]\n            for strAction in actionList:\n                strConditionalAction = parsedCondition + \"self.\" + strAction\n                #print strConditionalAction\n                exec(strConditionalAction)\n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #--------ADDING/REMOVING/MODIFYING ELEMENTS SECTION------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n            \n            \n    def AddWindow(self, width=1*_UNIT_COEF, height=1*_UNIT_COEF, fromLeft=\"C\", fromBottom=\"C\", recess=0, thickness=0.02*_UNIT_COEF):\n        \n        self.__m_arrWindowUserData = dict(width=width, height=height, fromLeft=fromLeft, fromBottom=fromBottom, recess = recess, thickness = thickness)\n        #Panel variables\n        PanelWidth = self.GetWidth()\n        PanelHeight = self.GetHeight()\n        \n        if type(width) == StringType : width = eval(width)\n        if type(height) == StringType : height = eval(height)\n        if type(recess) == StringType : recess = eval(recess)\n        \n        dblGlassWidth = width ; dblGlassHeight = height\n        dblGlassThickness = thickness ; dblGlassRecess = recess\n        \n        #Window variables\n        Window = dict(width=width, height=height, fromLeft=fromLeft, fromBottom=fromBottom, recess = recess, thickness = thickness)\n\n        if type(fromLeft) is StringType :\n            if fromLeft == 'C' : dblGlassDisLeft = (PanelWidth-width)/2.0\n            else : dblGlassDisLeft = eval(fromLeft)\n        elif type(fromLeft) is FloatType or type(fromLeft) is IntType :\n            dblGlassDisLeft = fromLeft\n        else: dblGlassDisLeft = (PanelWidth-width)/2.0\n            \n        if type(fromBottom) is StringType:\n            if fromBottom == 'C' : dblGlassDisBottom = (PanelHeight-height)/2.0 \n            else : dblGlassDisBottom = eval(fromBottom)\n        elif type(fromBottom) is FloatType or type(fromBottom) is IntType :\n            dblGlassDisBottom = fromBottom \n        else: dblGlassDisBottom = (PanelHeight-height)/2.0 \n        \n        #Check window dimensions, hide window if invalid\n        if dblGlassWidth <= 0 or dblGlassHeight <= 0 or \\\n            (dblGlassDisLeft + dblGlassWidth) > self.__GetPanelProperty(\"PanelWidth\")*self.__m_dimRoundCoef or \\\n            dblGlassDisBottom + dblGlassHeight > self.__GetPanelProperty(\"PanelHeight\")*self.__m_dimRoundCoef: \n            self.HideWindow(); print \">>> Panel \" + self.GetName()+\" - Window fixed size won't fit in panel - window erased\"; return\n        \n        #load processed data in window array\n        self.__m_arrWindowPoints[0] = [dblGlassDisLeft, 0, dblGlassDisBottom]\n        self.__m_arrWindowPoints[1] = [dblGlassDisLeft + dblGlassWidth, 0, dblGlassDisBottom]\n        self.__m_arrWindowPoints[2] = [dblGlassDisLeft + dblGlassWidth, 0, dblGlassDisBottom + dblGlassHeight]\n        self.__m_arrWindowPoints[3] = [dblGlassDisLeft, 0, dblGlassDisBottom + dblGlassHeight]\n        self.__m_dblWinGlassThickness = dblGlassThickness\n        self.__m_dblWinGlassOffset = dblGlassRecess\n            \n        self.ShowWindow()\n        \n        \n    def ModifyWindow(self, width=None, height=None, fromLeft=None, fromBottom=None, recess=None, thickness=None):\n        \n        if self.__m_arrWindowPoints == [0,0,0,0] : return False\n        \n        self.__m_arrWindowUserData['width'] = width if width<>None else self.__m_arrWindowUserData['width'] \n        self.__m_arrWindowUserData['height'] = height if height<>None else self.__m_arrWindowUserData['height'] \n        self.__m_arrWindowUserData['fromLeft'] = fromLeft if fromLeft<>None else self.__m_arrWindowUserData['fromLeft'] \n        self.__m_arrWindowUserData['fromBottom'] = fromBottom if fromBottom<>None else self.__m_arrWindowUserData['fromBottom'] \n        self.__m_arrWindowUserData['recess'] = recess if recess<>None else self.__m_arrWindowUserData['recess']\n        self.__m_arrWindowUserData['thickness'] = thickness if thickness<>None else self.__m_arrWindowUserData['thickness']        \n                                \n        Window = self.__m_arrWindowUserData\n        self.AddWindow(width=Window['width'], height=Window['height'], fromLeft=Window['fromLeft'], fromBottom=Window['fromBottom'], recess=Window['recess'], thickness=Window['thickness'])\n        \n        \n        \n    def UpdateWindow(self):\n        if self.__m_arrWindowPoints == [0,0,0,0] : return False\n        Window = self.__m_arrWindowUserData\n        self.AddWindow(width=Window['width'], height=Window['height'], fromLeft=Window['fromLeft'], fromBottom=Window['fromBottom'], recess=Window['recess'], thickness=Window['thickness'])\n        \n        \n    def DeleteWindow(self):\n        self.HideWindow()\n        self.__m_arrWindowPoints = [0,0,0,0]\n        self.__m_arrWindowObjects = [0]\n        self.__m_arrWindowBreps = [0]\n        self.__m_blnShowWindow = False\n        self.__m_arrWindowUserData = dict(width=0, height=0, fromLeft=0, fromBottom=0, recess = 0, thickness = 0)\n\n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n        \n        \n    def AddPane(self, paneName=\"_P_DefaultPane\", thickness=0.02*_UNIT_COEF, offset=0.02*_UNIT_COEF, offsetEdge=0, tileWidth=0, tileHeight=0, tileThickness=0, tileGap=0.01*_UNIT_COEF):\n        \n        self.__m_strPaneName = str(paneName)\n        self.__m_dblPaneThickness = float(thickness)\n        self.__m_dblPaneOffset = float(offset)\n        self.__m_dblPaneOffsetEdge = float(offsetEdge)\n        self.__m_dblPaneTileWidth = float(tileWidth)\n        self.__m_dblPaneTileHeight = float(tileHeight)\n        self.__m_dblPaneTileThickness = float(tileThickness)\n        self.__m_dblPaneTileGap = float(tileGap)\n        \n        self.__m_blnShowPane = True\n\n\n    #----------------------------------------------------------------------------------------------------------------------\n    # Mullions Actions\n    #----------------------------------------------------------------------------------------------------------------------\n    def AddBaseMullions(self, width=0.05*_UNIT_COEF, thickness=0.1*_UNIT_COEF, capThickness=0.05*_UNIT_COEF):\n\n        #Storing panel generic values using provided data\n        if width > 0 : self.__m_dblMullionWidth = width\n        if thickness > 0 : self.__m_dblMullionThickness = thickness\n        \n        #Caps also?\n        \n        if capThickness > 0.0 :\n            self.__m_dblMullionCapThickness = capThickness\n            self.__m_blnShowMullionsCap = True\n        else :\n            self.__m_blnShowMullionsCap = False\n            \n        if  self.__m_blnShowWindow :\n            MullionTypes = [\"PanelLeft\", \"PanelRight\", \"PanelBottom\", \"PanelTop\", \\\n                \"WindowLeft\",\"WindowRight\",\"WindowBottom\",\"WindowTop\"]\n        else : MullionTypes = [\"PanelLeft\", \"PanelRight\", \"PanelBottom\", \"PanelTop\"]\n            \n            \n        for strType in MullionTypes :\n            self.AddMullionType(strType, width, thickness, width, capThickness)\n\n        self.__m_blnShowMullions = True\n\n\n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def AddWindowMullions(self, width=0.05*_UNIT_COEF, thickness=0.1*_UNIT_COEF, capThickness=0.05*_UNIT_COEF):\n        MullionTypes = [\"WindowLeft\",\"WindowRight\",\"WindowBottom\",\"WindowTop\"]\n        for strType in MullionTypes :\n            self.AddMullionType(strType, width, thickness, width, capThickness)\n\n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def AddPanelMullions(self, width=0.05*_UNIT_COEF, thickness=0.1*_UNIT_COEF, capThickness=0.05*_UNIT_COEF):\n        MullionTypes = [\"PanelLeft\", \"PanelRight\", \"PanelBottom\", \"PanelTop\"]\n        for strType in MullionTypes :\n            self.AddMullionType(strType, width, thickness, width, capThickness)\n            \n            \n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    #Use to add a predefined mullion Type\n\n    def AddMullionType(self, strType, width=0.05*_UNIT_COEF, thickness=0.1*_UNIT_COEF, capWidth=None, capThickness=0.05*_UNIT_COEF):\n        \n        if strType not in [\"WindowLeft\",\"WindowRight\",\"WindowBottom\",\"WindowTop\", \"PanelLeft\", \"PanelRight\", \"PanelBottom\", \"PanelTop\"] and \\\n            \"Hor_fromBottom=\" not in strType and \"Vert_fromLeft=\" not in strType: return\n        try:\n            if type(width) == ListType: width = width[0]\n            width = float(width)\n        except:\n            self.__m_warningData.append(\"Wrong width parameter on mullion \"+ strType) ; return\n        try:\n            if type(capWidth) == ListType: capWidth = capWidth[0]\n            if capWidth <> None : capWidth = float(capWidth)\n        except:\n            self.__m_warningData.append(\"Wrong capWidth parameter on mullion \"+ strType) ; return\n\n        try:  \n            if type(thickness) == ListType : thickness = list(float(num) for num in thickness)\n            else: thickness = float(thickness)\n        except:\n            self.__m_warningData.append(\"Wrong thickness parameter on mullion \"+ strType) ; return\n        try:  \n            if type(capThickness) == ListType : capThickness = list(float(num) for num in capThickness)\n            else: capThickness = float(capThickness)\n        except:\n            self.__m_warningData.append(\"Wrong capThickness parameter on mullion \"+ strType) ; return\n            \n        if capWidth == None : capWidth = width \n        \n        if \"Bottom\" in strType or \"Top\" in strType or \"Hor_fromBottom=\" in strType:\n            self.__m_arrMullionHorUserData[0] = self.__m_arrMullionHorUserData[0] + [strType]\n            self.__m_arrMullionHorUserData[1] = self.__m_arrMullionHorUserData[1] + [width]\n            self.__m_arrMullionHorUserData[2] = self.__m_arrMullionHorUserData[2] + [thickness]\n            self.__m_arrMullionHorUserData[3] = self.__m_arrMullionHorUserData[3] + [capWidth]\n            self.__m_arrMullionHorUserData[4] = self.__m_arrMullionHorUserData[4] + [capThickness]\n\n\n        if \"Left\" in strType or \"Right\" in strType or \"Vert_fromLeft=\" in strType:\n            self.__m_arrMullionVertUserData[0] = self.__m_arrMullionVertUserData[0] + [strType]\n            self.__m_arrMullionVertUserData[1] = self.__m_arrMullionVertUserData[1] + [width]\n            self.__m_arrMullionVertUserData[2] = self.__m_arrMullionVertUserData[2] + [thickness]\n            self.__m_arrMullionVertUserData[3] = self.__m_arrMullionVertUserData[3] + [capWidth]\n            self.__m_arrMullionVertUserData[4] = self.__m_arrMullionVertUserData[4] + [capThickness]\n            \n    \n        self.__m_blnShowMullions = True\n\n    #-----------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    def AddMullionAt(self, direction=None, distance=\"C\", width=0.05*_UNIT_COEF, thickness=0.1*_UNIT_COEF, capThickness=0.05*_UNIT_COEF) :\n        \n        strType = \"\"\n        if  (direction == \"horizontal\" or direction == \"Horizontal\") and distance :\n            if distance == \"C\" : distance = self.__GetPanelProperty(\"PanelHeight\")/2.0\n            strType = \"Hor_fromBottom=\" + str(distance)\n        elif  direction == \"vertical\" or direction == \"Vertical\" and distance:\n            if distance == \"C\" : distance = self.__GetPanelProperty(\"PanelWidth\")/2.0 \n            strType = \"Vert_fromLeft=\" + str(distance)\n        else: \n            self.__m_warningData.append(\"Wrong 'direction' parameter on mullion: \" + str(direction)) ; return\n            \n        self.AddMullionType(strType, width, thickness, width, capThickness)\n        self.__m_blnShowMullions = True\n        \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n\n    def ChangeMullionType(self, strType=None, width=None, thickness=None, capThickness=None):\n\n\n        if len(self.__m_arrMullionHorUserData[0]) :\n            for i in range(len(self.__m_arrMullionHorUserData[0])):\n                if  self.__m_arrMullionHorUserData[0][i] == strType or strType in self.__m_arrMullionHorUserData[0][i]:\n                    if width <> None : self.__m_arrMullionHorUserData[1][i] = width\n                    if thickness <> None : self.__m_arrMullionHorUserData[2][i] = thickness\n                    if width <> None: self.__m_arrMullionHorUserData[3][i] = width\n                    if capThickness <> None : self.__m_arrMullionHorUserData[4][i] = capThickness\n                \n                \n        if len(self.__m_arrMullionVertUserData[0]) :\n            for i in range(len(self.__m_arrMullionVertUserData[0])) :\n                if  self.__m_arrMullionVertUserData[0][i] == strType or strType in self.__m_arrMullionVertUserData[0][i] :\n                    if  width <> None : self.__m_arrMullionVertUserData[1][i] = width\n                    if  thickness <> None : self.__m_arrMullionVertUserData[2][i] = thickness\n                    if width <> None : self.__m_arrMullionVertUserData[3][i] = width\n                    if  capThickness <> None : self.__m_arrMullionVertUserData[4][i] = capThickness\n                \n                \n    #------------------------------------------------------------------------------------------------------------------------------------\n    # ------------------------------------------------------------------------------------------------------------------------------------\n    # Delete functions:  Deletes objects and data structures based on objects' parameters----\n    \n    def DeleteMullionType(self, strType):\n    \n        if strType in self.__m_arrMullionHorUserData[0] :\n            i = self.__m_arrMullionHorUserData[0].index(strType)\n            del self.__m_arrMullionHorUserData[0][i]\n            del self.__m_arrMullionHorUserData[1][i]\n            del self.__m_arrMullionHorUserData[2][i]\n            del self.__m_arrMullionHorUserData[3][i]\n            del self.__m_arrMullionHorUserData[4][i]\n        elif strType in self.__m_arrMullionVertUserData[0] :\n            i = self.__m_arrMullionVertUserData[0].index(strType)\n            del self.__m_arrMullionVertUserData[0][i]\n            del self.__m_arrMullionVertUserData[1][i]\n            del self.__m_arrMullionVertUserData[2][i]\n            del self.__m_arrMullionVertUserData[3][i]\n            del self.__m_arrMullionVertUserData[4][i]\n        else: return\n        \n        if len(self.__m_arrMullionHorUserData[0]) == 0 and  len(self.__m_arrMullionVertUserData[0]) == 0 :\n             self.__m_blnShowMullions = False\n             \n        self.DeleteMullionType(strType)\n\n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n\n    def DeleteWindowMullions(self):\n        self.DeleteMullionType(\"WindowTop\")\n        self.DeleteMullionType(\"WindowBottom\")\n        self.DeleteMullionType(\"WindowLeft\")\n        self.DeleteMullionType(\"WindowRight\")\n\n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    \n    def DeleteMullionAt(self, direction, distance=None):\n        \n        strType = \"\"\n        \n        if  direction == \"horizontal\" or direction == \"Horizontal\" :\n            if  distance <> None:\n                if distance == \"C\" : distance = self.__GetPanelProperty(\"PanelHeight\")/2.0\n                elif  strType(distance) <> StringType : strType = \"Hor_fromBottom=\" + str(distance)\n            else: strType = \"Hor_\"\n            \n            i=0\n            while i < len(self.__m_arrMullionHorUserData[0]):\n                if  strType in self.__m_arrMullionHorUserData[0][i]:\n                    del self.__m_arrMullionHorUserData[0][i]\n                    del self.__m_arrMullionHorUserData[1][i]\n                    del self.__m_arrMullionHorUserData[2][i]\n                    del self.__m_arrMullionHorUserData[3][i]\n                    del self.__m_arrMullionHorUserData[4][i]\n                else: i+=1\n            return\n\n        if  direction == \"vertical\" or direction == \"Vertical\" :\n            if  distance <> None:\n                if distance == \"C\" : distance = self.__GetPanelProperty(\"PanelWidth\")/2.0\n                elif  strType(distance) <> StringType : strType = \"Vert_fromLeft=\" + str(distance)\n            else: strType = \"Vert_\"   \n            \n            i=0\n            while i < len(self.__m_arrMullionVertUserData[0]):\n                if  strType in self.__m_arrMullionVertUserData[0][i]:\n                    del self.__m_arrMullionVertUserData[0][i]\n                    del self.__m_arrMullionVertUserData[1][i]\n                    del self.__m_arrMullionVertUserData[2][i]\n                    del self.__m_arrMullionVertUserData[3][i]\n                    del self.__m_arrMullionVertUserData[4][i]\n                else: i+=1\n                \n        if len(self.__m_arrMullionHorUserData[0]) == 0 and  len(self.__m_arrMullionVertUserData[0]) == 0 :\n             self.__m_blnShowMullions = False\n             \n             \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #Shading actions\n    #------------------------------------------------------------------------------------------------------------------------------------\n\n\n    def AddShadingType(self, strShadingType, layerName=\"_P_Shading\", fromLeftBottom=[0.0,0.0], fromRightTop=[0.0,0.0], fromEdge = 0.0, \\\n        width=.05*_UNIT_COEF, thickness=0.05*_UNIT_COEF, offset=0.0, spacing=.1*_UNIT_COEF, rotation=0.0, shiftEnds=[None, None]) :\n\n        \n        if  thickness <= 0 or width <= 0 : return\n        \n        #handling predefined variables as string paramters\n        Window = self.__m_arrWindowUserData\n        PanelWidth = self.GetWidth()\n        PanelHeight = self.GetHeight()\n        if type(fromLeftBottom) == StringType : fromLeftBottom = eval(fromLeftBottom)\n        if type(fromRightTop) == StringType : fromRightTop = eval(fromRightTop)\n        \n        if type(fromLeftBottom) <> ListType or (type(fromLeftBottom[0]) <> FloatType and type(fromLeftBottom[0]) <> IntType) or \\\n            (type(fromLeftBottom[1]) <> FloatType and type(fromLeftBottom[1])<> IntType):\n            self.__m_warningData.append(\"Wrong Shading fromLeftBottom parameter: \"+ str(fromLeftBottom) + \" at \"+ strShadingType)  ; return\n        if type(fromEdge) == StringType : fromEdge = eval(fromEdge)\n        if type(fromEdge) <> FloatType and type(fromEdge) <> IntType:\n            self.__m_warningData.append(\"Wrong Shading fromEdge parameter: \"+ strShadingType)  ; return        \n        if type(fromRightTop) == StringType : fromRightTop = eval(fromRightTop)        \n        if type(fromRightTop) <> ListType or (type(fromRightTop[0]) <> FloatType and type(fromRightTop[0])<> IntType) or \\\n            (type(fromRightTop[1]) <> FloatType and type(fromRightTop[1])<> IntType) :\n            self.__m_warningData.append(\"Wrong Shading fromRightTop parameter: \"+ strShadingType)  ; return\n        \n        ShadingTypes = [\"HorizontalShade\",\"VerticalShade\", \"HorizontalLouver\", \"VerticalLouver\", \"HorizontalWindowShade\", \"VerticalWindowShade\", \"HorizontalWindowLouver\", \"VerticalWindowLouver\"]\n        if strShadingType not in ShadingTypes: self.__m_warningData.append(\"Wrong shading type: \"+ strShadingType) ;return   \n               \n         #Check for valid possible methods to specify sunshade values       \n        if strShadingType in [\"HorizontalLouver\", \"VerticalLouver\"] :\n            #if type(fromRightTop) <> ListType or type(fromLeftBottom[0]) <> FloatType: \n                #self.__m_warningData.append(\"Wrong Shading parameter fromRightTop: \"+ strShadingType)  ; return\n            if spacing < width : spacing = width\n            if spacing < 0.02*self.__m_unitCoef : spacing = 0.02*self.__m_unitCoef\n            fromEdge = None\n        elif strShadingType in [\"HorizontalShade\", \"VerticalShade\", \"HorizontalWindowShade\", \"VerticalWindowShade\"] :\n            if fromEdge == None : self.__m_warningData.append(\"Wrong Shading parameter fromEdge: \"+ strShadingType) ; return\n            fromRightTop = None\n        elif strShadingType in [\"HorizontalWindowShade\", \"VerticalWindowShade\", \"HorizontalWindowLouver\", \"VerticalWindowLouver\"]:\n            if self.__m_arrWindowPoints == [0,0,0,0]: self.__m_warningData.append(\"Window shading type ignored, no window present: \" + strShadingType) ; return\n            \n        self.__m_arrShadingUserData[0] = self.__m_arrShadingUserData[0] + [strShadingType]\n        self.__m_arrShadingUserData[1] = self.__m_arrShadingUserData[1] + [fromLeftBottom]\n        \n        if fromRightTop <> None : self.__m_arrShadingUserData[2] += [fromRightTop]\n        else : self.__m_arrShadingUserData[2] += [fromEdge]\n        \n        self.__m_arrShadingUserData[3] += [width]\n        self.__m_arrShadingUserData[4] += [thickness]\n        self.__m_arrShadingUserData[5] += [offset]\n        self.__m_arrShadingUserData[6] += [spacing]\n        self.__m_arrShadingUserData[7] += [rotation]\n        self.__m_arrShadingUserData[8] += [layerName]\n        self.__m_arrShadingUserData[9] += [shiftEnds]\n\n        self.__m_blnShowShading = True\n\n\n\n    #------------------------------------------------------------------------------------------------------------------------------------\n    # ------------------------------------------------------------------------------------------------------------------------------------\n    def DeleteShadingType(self, type):\n    \n        if type not in self.__m_arrShadingUserData[0] : return\n        \n        i = self.__m_arrShadingUserData[0].index(type)\n        for arrIndex in range(len(self.__m_arrShadingUserData)) :\n            del self.__m_arrShadingUserData[arrIndex][i]\n       \n        if len(self.__m_arrShadingUserData[0]) == 0 : self.__m_blnShowShading = False\n        \n        self.DeleteShadingType(type) #Check again for more cases \n            \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    \n    def DeleteShading(self):\n    \n        for type in self.__m_arrShadingUserData[0]:\n            self.DeleteShadingType(type)\n            \n        self.__m_arrShadingObjects = [0]\n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    def RotateShadingType(self, type, rotation):\n    \n        if type not in self.__m_arrShadingUserData[0] : return\n        \n        i = self.__m_arrShadingUserData[0].index(type)\n        self.__m_arrShadingUserData[7][i] = rotation\n            \n            \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    def ModifyShadingType(self, type, fromLeftBottom=None,fromLeft=None, fromBottom=None, fromRightTop=None, fromRight=None,\\\n        fromTop=None, fromEdge=None, width=None, thickness=None, offset=None, spacing=None, rotation=None, layerName=None, \\\n        shiftEnds=None ,shiftEnd1=None, shiftEnd2=None, shiftEnd1X = None, shiftEnd1Y = None, shiftEnd1Z=None, shiftEnd2X = None,\\\n        shiftEnd2Y = None, shiftEnd2Z=None):\n        \n        if type not in self.__m_arrShadingUserData[0] : return\n        \n        shadingIndex = self.__m_arrShadingUserData[0].index(type)\n        \n        self.ModifyShadingIndex( shadingIndex, None, fromLeftBottom, fromLeft, fromBottom, fromRightTop, fromRight, fromTop, fromEdge,\\\n            width, thickness, offset, spacing, rotation, layerName, shiftEnds,shiftEnd1, shiftEnd2, shiftEnd1X, shiftEnd1Y, shiftEnd1Z,\\\n            shiftEnd2X, shiftEnd2Y, shiftEnd2Z)\n        \n    \n    def ModifyShadingIndex(self, index, type=None, fromLeftBottom=None, fromLeft=None, fromBottom=None, fromRightTop=None, fromRight=None,\\\n        fromTop=None, fromEdge=None, width=None, thickness=None, offset=None, spacing=None, rotation=None, layerName=None, shiftEnds=None,\\\n        shiftEnd1=None, shiftEnd2=None, shiftEnd1X = None, shiftEnd1Y = None, shiftEnd1Z=None, shiftEnd2X = None, shiftEnd2Y = None, shiftEnd2Z=None):\n              \n        if index >= len(self.__m_arrShadingUserData[0]) : return\n        \n        i = index \n        if type  <> None : self.__m_arrShadingUserData[0][i] = type        \n        if fromLeftBottom  <> None : self.__m_arrShadingUserData[1][i] = fromLeftBottom\n        if fromLeft  <> None : self.__m_arrShadingUserData[1][i][0] = fromLeft       \n        if fromBottom  <> None : self.__m_arrShadingUserData[1][i][1] = fromBottom   \n        if fromRightTop <> None : self.__m_arrShadingUserData[2][i] = fromRightTop\n        if fromRight  <> None : self.__m_arrShadingUserData[2][i][0] = fromRight      \n        if fromTop  <> None : self.__m_arrShadingUserData[2][i][1] = fromTop  \n        if fromEdge <> None : self.__m_arrShadingUserData[2][i] = fromEdge\n        if width <> None : self.__m_arrShadingUserData[3][i] = width\n        if thickness <> None : self.__m_arrShadingUserData[4][i] = thickness\n        if offset <> None : self.__m_arrShadingUserData[5][i] = offset\n        if spacing <> None : self.__m_arrShadingUserData[6][i] = spacing\n        if rotation<> None : self.__m_arrShadingUserData[7][i] = rotation\n        if layerName <> None : self.__m_arrShadingUserData[8][i] = layerName\n        if shiftEnds <> None : self.__m_arrShadingUserData[9][i] = shiftEnds\n\n        currShiftEnds = self.__m_arrShadingUserData[9][i] \n        if shiftEnd1 <> None : currShiftEnds[0] = shiftEnd1\n        if shiftEnd2 <> None : currShiftEnds[1] = shiftEnd2\n        if (shiftEnd1X <> None or shiftEnd1Y<>None or shiftEnd1Z<>None) and not isinstance(currShiftEnds[0], list):\n            currShiftEnds[0]=[0,0,0]\n        if (shiftEnd2X <> None or shiftEnd2Y<>None or shiftEnd2Z<>None) and not isinstance(currShiftEnds[1], list):\n            currShiftEnds[1]=[0,0,0]\n        if shiftEnd1X <> None : currShiftEnds[0][0] = shiftEnd1X\n        if shiftEnd1Y <> None : currShiftEnds[0][1] = shiftEnd1Y\n        if shiftEnd1Z <> None : currShiftEnds[0][2] = shiftEnd1Z\n        if shiftEnd2X <> None : currShiftEnds[1][0] = shiftEnd2X\n        if shiftEnd2Y <> None : currShiftEnds[1][1] = shiftEnd2Y\n        if shiftEnd2Z <> None : currShiftEnds[1][2] = shiftEnd2Z\n        \n\n    def UpdateShading(self):\n        shadingUserData = copy.deepcopy(self.__m_arrShadingUserData)\n        if len(shadingUserData[0]) :\n            self.DeleteShading()\n            for i in range(len(shadingUserData[0])) :\n                if shadingUserData[0][i] in [\"HorizontalLouver\", \"VerticalLouver\", \"HorizontalWindowLouver\", \"VerticalWindowLouver\"]:\n                    self.AddShadingType(shadingUserData[0][i], layerName=shadingUserData[8][i], fromLeftBottom=shadingUserData[1][i], fromRightTop=shadingUserData[2][i],\\\n                        width=shadingUserData[3][i], thickness=shadingUserData[4][i], offset=shadingUserData[5][i], spacing=shadingUserData[6][i],\\\n                        rotation=shadingUserData[7][i], shiftEnds=shadingUserData[9][i])\n                if shadingUserData[0][i] in [\"HorizontalShade\", \"VerticalShade\", \"HorizontalWindowShade\", \"VerticalWindowShade\"]:\n                    self.AddShadingType(shadingUserData[0][i], layerName=shadingUserData[8][i], fromLeftBottom=shadingUserData[1][i], fromEdge=shadingUserData[2][i],\\\n                        width=shadingUserData[3][i], thickness=shadingUserData[4][i], offset=shadingUserData[5][i], spacing=shadingUserData[6][i],\\\n                        rotation=shadingUserData[7][i], shiftEnds=shadingUserData[9][i])\n                        \n\n    #------------------------------------------------------------------------------------------------------------------------------------\n    #Custom Geometry actions\n    #------------------------------------------------------------------------------------------------------------------------------------\n\n\n    def AddCustomGeometry(self, brepCustomGeo, vecPlacement=None, vecScaleFactors=None, vecUpVector=None, blnTilable=None, \\\n        dblRotation=None, windowDepth=None, trimToPanelSize=None):\n        \n        if str(type(brepCustomGeo)) <> \"<type 'instance'>\" and  type(brepCustomGeo) <> ListType: \n            self.__m_warningData.append(\"Panel '\"+self.GetName()+\"': Invalid Custom Geometry Object\"); return\n            \n        if brepCustomGeo == None or  brepCustomGeo == []: \n            self.__m_warningData.append(\"Panel '\"+self.GetName()+\"': Invalid Custom Geometry Object\"); return\n        \n        #store parameters\n        self.__m_CustomGeoBaseData = brepCustomGeo      \n        \n        if str(type(self.__m_CustomGeoBaseData)) == \"<type 'instance'>\" : \n            self.__m_CustomGeoBreps = self.__m_CustomGeoBaseData.Run()\n            if self.__m_CustomGeoBreps == None : self.__m_CustomGeoBreps = [rg.Brep()]\n        else:\n            self.__m_CustomGeoBreps = list(brep.DuplicateBrep() for brep in self.__m_CustomGeoBaseData)\n        \n        if vecPlacement : self.__m_CG_vecPlacement = vecPlacement\n        if vecUpVector.IsUnitVector : self.__m_CG_vecUpVector = vecUpVector\n        self.__m_CG_blnTilable = blnTilable\n        if dblRotation <> None : self.__m_CG_dblRotation = dblRotation\n        if windowDepth <> None : self.__m_CG_windowDepth = windowDepth\n        if trimToPanelSize <> None: self.__m_CG_trimToPanelSize = trimToPanelSize\n        \n        #get size data\n        tmpGeoBBox = rg.Brep().GetBoundingBox(True)\n        for brep in self.__m_CustomGeoBreps:\n            tmpGeoBBox.Union(brep.GetBoundingBox(True))\n        tmpGeoSize = tmpGeoBBox.Max - tmpGeoBBox.Min\n        \n        #place custom geometry at coordinates origon 0,0,0 (actually 0.001, 0.001, 0.001 to avoid potential boolean errors)       \n        vecTranslate = rg.Vector3d(tmpGeoBBox.Min)\n        for brep in self.__m_CustomGeoBreps: \n            brep.Translate(-vecTranslate)\n            #brep.Translate(rg.Vector3d(0.001,0.001,0.001))\n            \n        #rotate based on Z up value\n        if self.__m_CG_vecUpVector.X == 1 :\n            ptOrigin = rg.Point3d(0,tmpGeoSize.Y,0)\n            ptVectorX = rg.Point3d(0,tmpGeoSize.Y-1,0)\n            ptVectorY = rg.Point3d(1,tmpGeoSize.Y,0)\n        elif self.__m_CG_vecUpVector.X == -1 :\n            ptOrigin = rg.Point3d(tmpGeoSize.X,0,0)\n            ptVectorX = rg.Point3d(tmpGeoSize.X,1,0)\n            ptVectorY = rg.Point3d(tmpGeoSize.X-1,0,0)\n        elif self.__m_CG_vecUpVector.Y == 1 :\n            ptOrigin = rg.Point3d(0,0,0)\n            ptVectorX = rg.Point3d(1,0,0)\n            ptVectorY = rg.Point3d(0,1,0)\n        elif self.__m_CG_vecUpVector.Y == -1 :\n            ptOrigin = rg.Point3d(tmpGeoSize.X, tmpGeoSize.Y,0)\n            ptVectorX = rg.Point3d(tmpGeoSize.X-1, tmpGeoSize.Y,0)\n            ptVectorY = rg.Point3d(tmpGeoSize.X, tmpGeoSize.Y-1,0)\n        elif self.__m_CG_vecUpVector.Z == 1 :\n            ptOrigin = rg.Point3d(0, tmpGeoSize.Y, 0)\n            ptVectorX = rg.Point3d(1, tmpGeoSize.Y, 0)\n            ptVectorY = rg.Point3d(0, tmpGeoSize.Y, 1)\n        elif self.__m_CG_vecUpVector.Z == -1 :\n            ptOrigin = rg.Point3d(tmpGeoSize.X, tmpGeoSize.Y, tmpGeoSize.Z)\n            ptVectorX = rg.Point3d(tmpGeoSize.X-1, tmpGeoSize.Y, tmpGeoSize.Z)\n            ptVectorY = rg.Point3d(tmpGeoSize.X, tmpGeoSize.Y, tmpGeoSize.Z-1)\n            \n        #apply vectorUp orientation\n        plFrom = rg.Plane(ptOrigin, ptVectorX, ptVectorY)\n        plTo = rg.Plane(rg.Point3d(0,0,0), rg.Point3d(1,0,0), rg.Point3d(0,0,1))\n        brepTransform = rg.Transform.PlaneToPlane(plFrom, plTo)\n        for brep in self.__m_CustomGeoBreps: brep.Transform(brepTransform)\n            \n        #scale based on scale factor\n        if vecScaleFactors <> rg.Vector3d(1,1,1) : \n            self.__m_CG_vecScaleFactor = vecScaleFactors\n            plOrigin = rg.Plane(rg.Point3d(0,0,0), rg.Point3d(1,0,0), rg.Point3d(0,1,0))\n            brepTransform = rg.Transform.Scale(plOrigin, self.__m_CG_vecScaleFactor.X, self.__m_CG_vecScaleFactor.Y, self.__m_CG_vecScaleFactor.Z)\n            for brep in self.__m_CustomGeoBreps: brep.Transform(brepTransform)\n            # flip normals if negative scaling\n            flipCG = False\n            if self.__m_CG_vecScaleFactor.X < 0 : flipCG = not flipCG\n            if self.__m_CG_vecScaleFactor.Y < 0 : flipCG = not flipCG\n            if self.__m_CG_vecScaleFactor.Z < 0: flipCG = not flipCG\n            if flipCG : \n                for brep in self.__m_CustomGeoBreps: brep.Flip()\n            \n        #move based on placement data\n        if not self.__m_CG_vecPlacement.IsZero:\n            for brep in self.__m_CustomGeoBreps: brep.Translate(self.__m_CG_vecPlacement)\n        \n        #create rotation transformation based on rotation data\n        rotXform = rg.Transform.Rotation(math.radians(self.__m_CG_dblRotation), rg.Vector3d(0,1,0), rg.Point3d(self.GetWidth()/2,0,self.GetHeight()/2))\n        \n        #tile geometry if turned on\n        if self.__m_CG_blnTilable:\n            #define tiling base area\n            tileAreaWidth = self.GetWidth()\n            tileAreaHeight = self.GetHeight()\n            tolerance = sc.doc.ModelAbsoluteTolerance\n            #recalculate required area to tile based on customGeo rotation\n            if self.__m_CG_dblRotation <> 0:\n                tilePlane = rg.Plane(rg.Point3d(0,0,0), rg.Point3d(1,0,0), rg.Point3d(0,0,1))\n                tileAreaBox =  rg.Box(tilePlane, [rg.Point3d(0,0,0), rg.Point3d(self.GetWidth(),0,0),rg.Point3d(0,0,self.GetHeight())]) \n                tileAreaBox.Transform(rotXform)      \n                tileAreaBBox = tileAreaBox.BoundingBox\n                tileAreaSize = tileAreaBBox.Max - tileAreaBBox.Min\n                tileAreaWidth = tileAreaSize.X\n                tileAreaHeight = tileAreaSize.Z\n            tmpGeoBBox = rg.Brep().GetBoundingBox(True)\n            for brep in self.__m_CustomGeoBreps:\n                tmpGeoBBox.Union(brep.GetBoundingBox(True))\n            tmpGeoSize = tmpGeoBBox.Max - tmpGeoBBox.Min\n            #process tiling for each brep in list\n            tmpCustomGeoBreps = []\n            for index, brep in enumerate(self.__m_CustomGeoBreps):\n                #move geometry to the left if not at origin\n                xPos = round(tmpGeoBBox.Min.X, 3); xStep = round(tmpGeoSize.X, 3)\n                vecWidth = rg.Vector3d(-xStep,0,0)            \n                while xPos > 0 :\n                    brep.Translate(vecWidth)\n                    xPos -= xStep\n                #move geometry to the bottom if not at origin\n                zPos = round(tmpGeoBBox.Min.Z, 3); zStep = round(tmpGeoSize.Z, 3)\n                vecHeight = rg.Vector3d(0, 0, -zStep)\n                while zPos > 0 :\n                    brep.Translate(vecHeight)\n                    zPos -= zStep\n                #create array of breps to cover panel\n                tmpGeoList = []\n                xTrans = 0; zTrans = 0\n                while True:\n                    while xPos < tileAreaWidth:        \n                        tmpGeo = brep.DuplicateBrep()\n                        vecWidth = rg.Vector3d(xTrans,0,zTrans)                    \n                        tmpGeo.Translate(vecWidth)\n                        tmpGeoList.append(tmpGeo)\n                        xPos += xStep ; xTrans += xStep\n                    zPos += zStep ; zTrans += zStep\n                    if zPos < tileAreaHeight: xPos -= xTrans; xTrans =0     \n                    else: break\n                tmpCustomGeoBreps += tmpGeoList\n                \n            self.__m_CustomGeoBreps = tmpCustomGeoBreps\n            # relocate tiles brep to right location before rotation\n            if self.__m_CG_dblRotation <> 0: \n                for brep in self.__m_CustomGeoBreps: brep.Translate(tileAreaBBox.Min.X, 0, tileAreaBBox.Min.Z)\n                \n        # perform rotation on final brep\n        if self.__m_CG_dblRotation <> 0: \n            for brep in self.__m_CustomGeoBreps: brep.Transform(rotXform)\n        \n        self.__m_blnShowCustomGeo = True\n        \n        \n        \n    def ModifyCustomGeometry(self, brepCustomGeo=None, vecPlacement=None,placementX=None, placementY=None,placementZ=None,\\\n        vecScaleFactors=None, scaleX=None, scaleY=None, scaleZ=None, vecUpVector=None, upVectorX=None, upVectorY=None, upVectorZ=None,\\\n        blnTilable=None, rotation=None, windowDepth=None, dynamicGeoParams=None, trimToPanelSize = None):\n        \n        if brepCustomGeo == None : brepCustomGeo = self.__m_CustomGeoBaseData\n        \n        #set dynamic geometry parameters if available\n        if dynamicGeoParams <> None and str(type(self.__m_CustomGeoBaseData)) == \"<type 'instance'>\" : \n            if type(dynamicGeoParams) == ListType:\n                \n                for param, value in dynamicGeoParams: self.__m_CustomGeoBaseData.SetParameter(param, value)\n            else: self.__m_CustomGeoBaseData.SetParameter(dynamicGeoParams)\n        \n        if vecPlacement == None : \n            vecPlacement = self.__m_CG_vecPlacement\n            if placementX <> None : vecPlacement.X = placementX\n            if placementY <> None : vecPlacement.Y = placementY\n            if placementZ <> None : vecPlacement.Z = placementZ\n        \n        if vecScaleFactors == None : \n            vecScaleFactors = self.__m_CG_vecScaleFactor\n            if scaleX <> None : vecScaleFactors.X = scaleX\n            if scaleY <> None : vecScaleFactors.Y = scaleY\n            if scaleZ <> None : vecScaleFactors.Z = scaleZ\n        \n        if vecUpVector == None : \n            vecUpVector = self.__m_CG_vecUpVector\n            if upVectorX <> None : vecUpVector.X = upVectorX\n            if upVectorY <> None : vecUpVector.Y = upVectorY\n            if upVectorZ <> None : vecUpVector.Z = upVectorZ\n            \n        #if vecScaleFactors == None : vecScaleFactors = self.__m_CG_vecScaleFactor\n        if vecUpVector == None : vecUpVector = self.__m_CG_vecUpVector      \n        if blnTilable == None : blnTilable = self.__m_CG_blnTilable\n        if rotation == None : rotation = self.__m_CG_dblRotation\n        if windowDepth == None : windowDepth = self.__m_CG_windowDepth\n        if trimToPanelSize == None : trimToPanelSize = self.__m_CG_trimToPanelSize\n\n        self.AddCustomGeometry(brepCustomGeo, vecPlacement, vecScaleFactors, vecUpVector, blnTilable, rotation, windowDepth, trimToPanelSize)\n        \n    #----------------------------------------------------------------------------------------------------------------------            \n    #PANEL ELEMENTS HIDE/SHOW SECTION--Deletes objects and \"Show\" varialbles set to off, data strcutures left undtouched----\n    #----------------------------------------------------------------------------------------------------------------------    \n    #----------------------------------------------------------------------------------------------------------------------\n    \n    def ShowWall(self):\n        if not self.__m_blnShowWall :\n            self.__m_blnShowWall = True \n            #self.DrawWall()\n\n    def HideWall(self):\n        #Delete Old Wall If Exists.\n        if self.__m_arrWallObjects and not type(self.__m_arrWallObjects[0]) == IntType and rs.IsObject(self.__m_arrWallObjects[0]):\n           rs.DeleteObjects(self.__m_arrWallObjects)\n            \n        self.__m_blnShowWall = False\n            \n            \n            \n    #----------------------------------------------------------------------------------------------------------------------\t\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def ShowPane(self):\n        if not self.__m_blnShowPane :\n            self.__m_blnShowPane = True \n            #self.DrawPane()\t\n\n    def HidePane(self):\n        #Delete Old Wall Cover objects if exists.\n        if self.__m_arrPaneObjects and not type(self.__m_arrPaneObjects[0]) == IntType and rs.IsObject(self.__m_arrPaneObjects[0]): \n            rs.DeleteObjects(self.__m_arrPaneObjects)\n        self.__m_blnShowPane = False\n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\t\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def ShowWindow(self):\n        if not self.__m_blnShowWindow and self.__m_arrWindowPoints <> [0,0,0,0]:\n            self.__m_blnShowWindow = True\n            #self.ShowMullions()\n            #self.Draw()\n        \n        \n    def HideWindow(self):\n        #Delete Window if Exists.\n        if self.__m_arrWindowObjects and not type(self.__m_arrWindowObjects[0]) == IntType and rs.IsObject(self.__m_arrWindowObjects[0]): \n            rs.DeleteObjects(self.__m_arrWindowObjects)\n        self.__m_blnShowWindow = False\n        \n\n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n        \n    def ShowMullions(self):\n        if not self.__m_blnShowMullions :\n            self.__m_blnShowMullions = True  \n            #self.DrawMullions()\n        \n        \n    def HideMullions(self):\n        \n        #Delete Mullions if Exist.\n\n        if self.__m_arrMullionHorObjects and not type(self.__m_arrMullionHorObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionHorObjects[0]):\n            rs.DeleteObjects(self.__m_arrMullionHorObjects)\n\n        \n        if self.__m_arrMullionVertObjects and not type(self.__m_arrMullionVertObjects[0]) == IntType and rs.IsObject(self.__m_arrMullionVertObjects[0]):\n            rs.DeleteObjects(self.__m_arrMullionVertObjects)\n\n            \n        self.__m_blnShowMullions = False\n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def ShowShading(self):\n        if not self.__m_blnShowShading :\n            self.__m_blnShowShading = True\n            #self.DrawShading()\n        \n        \n    def HideShading(self):\n        #Delete Shadnig if Exists.\n        if self.__m_arrShadingObjects and not type(self.__m_arrShadingObjects[0]) == IntType and rs.IsObject(self.__m_arrShadingObjects[0]): \n            rs.DeleteObjects(self.__m_arrShadingObjects)\n            \n        self.__m_arrShadingObjects = [0]\n        self.__m_blnShowShading = False\n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n        \n    def ShowCustomGeometry(self):\n        if not self.__m_blnShowCustomGeo :\n            self.__m_blnShowCustomGeo = True\n        \n        \n    def HideCustomGeometry(self):\n        #Delete Shadnig if Exists.\n        if self.__m_CustomGeoObjects and len(self.__m_CustomGeoObjects) > 0 and rs.IsObject(self.__m_CustomGeoObjects[0]) : \\\n            rs.DeleteObjects(self.__m_CustomGeoObjects)\n            \n        self.__m_CustomGeoObjects  = []\n        self.__m_blnShowCustomGeo = False\n        \n    \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def HideAll(self):\n        self.HideMullions()\n        self.HideWindow()\n        self.HidePane()\n        self.HideWall()\n        self.HideShading()\n        self.HideCustomGeometry()        \n\n\n    #----------------------------------------------------------------------------------------------------------------------\n    #DRAW GEOMETRY SECTION-------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n\n    def Draw(self, sceneObjects = False):\n        \n        if self.__m_blnShowWall : self.DrawWall()\n        \n        if self.__m_blnShowWindow : self.DrawWindow()\n        \n        if self.__m_blnShowPane : self.DrawPane()\n        \n        if self.__m_blnShowMullions : self.DrawMullions()\n        \n        if self.__m_blnShowShading : self.DrawShading()\n        \n        if self.__m_blnShowCustomGeo : self.DrawCustomGeometry()\n        \n        if self.__m_blnShowDeform : self.DrawMorph()\n        \n        if sceneObjects : self.DrawSceneObjects()\n            \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n        \n    def DrawWall(self):\n        \n        \n        #Ignore draw wall if window is as large as panel\n        if self.__GetPanelProperty(\"WindowVisibility\") and self.GetWidth() <= self.__GetPanelProperty(\"WindowWidth\") and \\\n            self.GetHeight() <= self.__GetPanelProperty(\"WindowHeight\"):\n            return \n        \n        if self.GetDrawMode() == \"LADYBUG\" : #Wall as single sided in Ladybug draw mode\n            cornerPt1 = rg.Point3d(0,0,0)\n            cornerPt2 = rg.Point3d(self.__m_dblWidth,0,0)\n            cornerPt3 = rg.Point3d(self.__m_dblWidth, 0, self.__m_dblHeight)\n            cornerPt4 = rg.Point3d(0, 0, self.__m_dblHeight)\n            self.__m_arrWallBreps[0] = rg.Brep.CreateFromCornerPoints(cornerPt1, cornerPt2, cornerPt3, cornerPt4, sc.doc.ModelAbsoluteTolerance)\n            \n        else: #DEFAULT MODE \n            #create opposite corner points for box and wall Geometry\n            cornerPt1 = rg.Point3d(0,0,0)\n            cornerPt2 = rg.Point3d(self.__m_dblWidth, self.__m_dblWallThickness, self.__m_dblHeight)   \n            self.__m_arrWallBreps[0] = rg.Brep.CreateFromBox(rg.BoundingBox(cornerPt1, cornerPt2))\n            \n        self.__m_blnShowWall = True\n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    \n    def DrawPane(self):\n        \n            \n        #Ignore draw pane if window is as large as panel\n        if self.__GetPanelProperty(\"WindowVisibility\") and self.GetWidth() <= self.__GetPanelProperty(\"WindowWidth\") and \\\n            self.GetHeight() <= self.__GetPanelProperty(\"WindowHeight\"):\n            return \n            \n        if self.GetDrawMode() == \"LADYBUG\" : return   #pane excluded from Ladybug draw mode\n        \n        GlsSurface = 0          # Surface of Subtracting Object\n        CoverSurface = 0        # Surface of Wall Cover \n        strExtrCurve = 0        #: Path is used to Extude, Length of line is equal to Thickness of Wall Cover\n        strExtrCurve2 = 0       #: Path is used to Extude Surface of Subtracting Object, Length of line is equal to Thickness of Wall Cover+ Distance between Wall Cover and wall\n        OpeningObject = 0\n        arrPaneObjects = []\n        \n        \n        #set up pane overal dimensions\n        \n        if type(self.__m_dblPaneOffsetEdge)==ListType :                 #if a list was provided\n            paneOffset = self.__m_dblPaneOffsetEdge     \n            for i in range(len(paneOffset),4): paneOffset.append(0)         #complete with ceros if less than 4 values.\n        else:  #else repeat 4 times the number\n            paneOffset = [self.__m_dblPaneOffsetEdge, self.__m_dblPaneOffsetEdge, self.__m_dblPaneOffsetEdge, self.__m_dblPaneOffsetEdge]\n\n        #Create pane base object\n        rcTolerance = sc.doc.ModelAbsoluteTolerance\n        pt1 = [paneOffset[0], 0, paneOffset[1]]\n        pt2 = [self.__m_dblWidth-paneOffset[2], 0, paneOffset[1]]\n        pt3 = [self.__m_dblWidth-paneOffset[2], 0, self.__m_dblHeight-paneOffset[3]]\n        pt4 = [paneOffset[0], 0, self.__m_dblHeight-paneOffset[3]]\n        CoverSurface = rg.Brep.CreateFromCornerPoints(rg.Point3d(pt1[0],pt1[1],pt1[2]), rg.Point3d(pt2[0],pt2[1],pt2[2]),\\\n            rg.Point3d(pt3[0],pt3[1],pt3[2]), rg.Point3d(pt4[0],pt4[1],pt4[2]), rcTolerance)\n        self.__m_arrPaneBreps[0] = CoverSurface.Faces.Item[0].CreateExtrusion(\\\n            rg.LineCurve(rg.Point3d(0,0,0), rg.Point3d(0, self.__m_dblPaneThickness, 0)), True)\n\n        #Create pane tiles if parameters configured\n        if self.__m_dblPaneTileWidth and self.__m_dblPaneTileHeight and self.__m_dblPaneTileThickness :\n            \n            y = -self.__m_dblPaneTileThickness # lay tiles in front of pane base object\n            tileHeight = self.__m_dblPaneTileHeight\n            z = tileHeight/2 + paneOffset[1]; zStep = tileHeight + self.__m_dblPaneTileGap\n            \n            while z-tileHeight/2 < (self.__m_dblHeight-paneOffset[3]) : #loop through vertical spacing\n                if z + tileHeight/2 >  (self.__m_dblHeight-paneOffset[3]) : #create custom piece height at the top\n                    tileHeight = (self.__m_dblHeight-paneOffset[3]) - (z-tileHeight/2)\n                    z = (self.__m_dblHeight-paneOffset[3]) - tileHeight/2\n                x = paneOffset[0] ; xStep = self.__m_dblPaneTileWidth + self.__m_dblPaneTileGap\n                while x <  (self.__m_dblWidth-paneOffset[2]) : #loop through horizontal spacing\n                    start = [x,y,z] ; end = [x+self.__m_dblPaneTileWidth,y,z]\n                    if end[0] > (self.__m_dblWidth-paneOffset[2]) : end[0] = (self.__m_dblWidth-paneOffset[2]) #create custom piece width at the right end\n                    #create tile\n                    member = self.DrawMember(start, end, tileHeight, self.__m_dblPaneTileThickness)\n                    if member : self.__m_arrPaneBreps.append(member)\n                    x += xStep\n                z += zStep\n                \n        #Move to place(front of wall)\n        #rs.MoveObjects(self.__m_arrPaneObjects, [0, -1 * self.__m_dblPaneOffset, 0]) # Move Objects Forward in front of the Wall\n        for obj in self.__m_arrPaneBreps: obj.Translate(0, -1 * self.__m_dblPaneOffset, 0)\n        \n        \n        #Create Opening\n        if self.__m_blnShowWindow :                #: If Window exists we need to subtract Window from panel base and tiles.\n            arrOpeningPoints = copy.deepcopy(self.__m_arrWindowPoints)\n\n            #Avoid boolean error when subraction boxes align with panel edges\n            if round(self.__GetPanelProperty(\"WindowLeft\"),3) == 0 : arrOpeningPoints[0][0] = arrOpeningPoints[3][0] = -.1*self.__m_unitCoef\n            if round(self.__GetPanelProperty(\"WindowRight\"),3) == 0 : arrOpeningPoints[1][0] = arrOpeningPoints[2][0] = self.GetWidth()+.1*self.__m_unitCoef\n            if round(self.__GetPanelProperty(\"WindowBottom\"),3) == 0 : arrOpeningPoints[0][2] = arrOpeningPoints[1][2] = -.1*self.__m_unitCoef \n            if round(self.__GetPanelProperty(\"WindowTop\"),3) == 0 : arrOpeningPoints[2][2] = arrOpeningPoints[3][2] = self.GetHeight()+.1*self.__m_unitCoef\n            \n\n            pt1, pt2, pt3, pt4 = arrOpeningPoints\n            GlsSurface = rg.Brep.CreateFromCornerPoints(rg.Point3d(pt1[0],pt1[1],pt1[2]), rg.Point3d(pt2[0],pt2[1],pt2[2]),\\\n                rg.Point3d(pt3[0],pt3[1],pt3[2]), rg.Point3d(pt4[0],pt4[1],pt4[2]), rcTolerance)\n            OpeningObject = GlsSurface.Faces.Item[0].CreateExtrusion(\\\n                rg.LineCurve(rg.Point3d(0,0,0), rg.Point3d(0, 4*self.__m_unitCoef, 0)), True)\n            OpeningObject.Translate(0,-2*self.__m_unitCoef,0)\n            \n            arrPaneObjects = self.__m_arrPaneBreps\n            self.__m_arrPaneBreps = []\n            for index, obj in enumerate(arrPaneObjects):\n                if OpeningObject.GetBoundingBox(True).Contains(obj.GetBoundingBox(True), False) :\n                    continue\n                #boolean only works on large pane object(first item), use split on tiles\n                if  index == 0 : \n                    boolResult = list(rg.Brep.CreateBooleanDifference(obj, OpeningObject, rcTolerance))\n                else:    \n                    boolResult = list(rg.Brep.Split(obj, OpeningObject , rcTolerance))\n                \n                if not len(boolResult) :self.__m_arrPaneBreps += [obj]\n                \n                for piece in boolResult : \n                    bbox = OpeningObject.GetBoundingBox(True)\n                    bbox.Inflate(.02*self.__m_unitCoef)\n                    if bbox.Contains(piece.GetBoundingBox(True), False): continue\n                    if index > 0 : piece.Flip() #flip boolean result of pane tiles (bug)\n                    self.__m_arrPaneBreps += [piece]\n                \n        self.__m_blnShowPane = True\n        \n    \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    \n    def DrawWindow(self):\n        \n        GlsSurface = 0                #:Surface of Glass\n        strExtrCurve = 0              #:Path used to Extrude Subtracting Object, Lenght equal to Wall Depth\n        GlassObjectTemp = 0\n        wallObjectTemp = 0 #bollean window operation result\n        \n        #Create Window Panel\n        rcTolerance = sc.doc.ModelAbsoluteTolerance\n        pt1, pt2, pt3, pt4 = self.__m_arrWindowPoints\n        GlsSurface = rg.Brep.CreateFromCornerPoints(rg.Point3d(pt1[0],pt1[1],pt1[2]), rg.Point3d(pt2[0],pt2[1],pt2[2]),\\\n            rg.Point3d(pt3[0],pt3[1],pt3[2]), rg.Point3d(pt4[0],pt4[1],pt4[2]), rcTolerance)\n        \n        if self.GetDrawMode() == \"LADYBUG\" and self.__m_dblWinGlassThickness > 0:\n            self.__m_arrWindowBreps[0] = GlsSurface #in LADYBUG mode only glass pane is drawn\n            #Move to place\n            self.__m_arrWindowBreps[0].Translate(0, -self.__m_dblWinGlassOffset, 0)\n            self.__m_blnShowWindow = True\n            if self.__m_blnShowWall and self.__m_arrWallBreps <> [0]:\n                tmpObject = rg.Brep.CreateBooleanDifference(self.__m_arrWallBreps[0], GlsSurface, rcTolerance)\n                if tmpObject : self.__m_arrWallBreps = tmpObject\n                \n            return\n            \n        if self.__m_dblWinGlassThickness > 0 : #create glass pane if thickness > 0 otherwise just create opening\n            self.__m_arrWindowBreps[0]= GlsSurface.Faces.Item[0].CreateExtrusion(\\\n                rg.LineCurve(rg.Point3d(0,0,0), rg.Point3d(0, self.__m_dblWinGlassThickness, 0)), True)\n            #Move to place\n            self.__m_arrWindowBreps[0].Translate(0, -self.__m_dblWinGlassOffset, 0)\n\n            \n        #Create Opening if wall is visible\n        if self.__m_blnShowWall and self.__m_arrWallBreps <> [0]:\n\n            GlassObjectTemp = GlsSurface.Faces.Item[0].CreateExtrusion(\\\n                rg.LineCurve(rg.Point3d(0,0,0), rg.Point3d(0, self.__m_dblWallThickness, 0)), True)\n            wallObjectTemp = self.__m_arrWallBreps[0]\n            wallBreps = rg.Brep.CreateBooleanDifference(wallObjectTemp, GlassObjectTemp, rcTolerance)\n            if wallBreps : self.__m_arrWallBreps = list(wallBreps)\n            else: self.__m_arrWallBreps = [0]\n\n        self.__m_blnShowWindow = True\n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n        \n    def DrawMullions(self):\n        \n            \n        self.__m_arrMullionHorBreps = []\n        self.__m_arrMullionVertBreps = []\n            \n        #Populate array with new mullions based on Mullion Data array\n        #Horizontal\n        if len(self.__m_arrMullionHorUserData[0]) :\n            for i in range(len(self.__m_arrMullionHorUserData[0])) :\n                mullionObjList = self.DrawMullionType(self.__m_arrMullionHorUserData[0][i], self.__m_arrMullionHorUserData[1][i], self.__m_arrMullionHorUserData[2][i],\\\n                    self.__m_arrMullionHorUserData[3][i], self.__m_arrMullionHorUserData[4][i])\n                if type(mullionObjList) == ListType and mullionObjList[0]: \n                    self.__m_arrMullionHorBreps.append(mullionObjList)\n\n                \n        #Vertical\n        if len(self.__m_arrMullionVertUserData[0])  :\n            for i in range(len(self.__m_arrMullionVertUserData[0])):\n                mullionObjList = self.DrawMullionType(self.__m_arrMullionVertUserData[0][i], self.__m_arrMullionVertUserData[1][i], self.__m_arrMullionVertUserData[2][i],\\\n                    self.__m_arrMullionVertUserData[3][i], self.__m_arrMullionVertUserData[4][i])\n                if type(mullionObjList) == ListType and mullionObjList[0]: \n                    self.__m_arrMullionVertBreps.append(mullionObjList)\n                    \n        if not self.__m_arrMullionHorBreps : self.__m_arrMullionHorBreps = [0]\n        if not self.__m_arrMullionVertBreps : self.__m_arrMullionVertBreps = [0]\n        \n        \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    #    Mullion/Cap creation data based on their type \n    \n    def DrawMullionType(self, strMullionType, dblWidth, dblThickness, dblCapWidth, dblCapThickness):\n        \n        if dblThickness == 0 or dblWidth == 0 : return None\n        if not self.__m_blnShowWindow and \"Window\" in strMullionType : return #ignore window mullions if no window\n        \n        arrHorPoints = [] #'Four Horizontal  points defined by panel width and window location stored as(X,0,0) \n        arrVertPoints = [] #'Four Vertical  points defined by panel width and window location stored as (0,0,Z)\n        arrDeltaPoint = [] # 'Distance from 0,0,0 depending the mullion type (an X value for vertical mullions, Z value for Horizonal)\n\n        arrMullionPoints = [] \n        arrCapMullionPoints= [] #'The final points that result from adding arrDeltaPoint to arrVertPoints or arrHorPoints\n        \n        arrXform = [] #'Transformation Matrix needed for the addition of arrDeltaPont\n        arrMullions = [] # 'array storing the mullions\n\n        dblYOffset = -self.__m_dblPaneOffset + self.__m_dblPaneThickness + .004 * self.__m_unitCoef ###Use this version to tie panel to mullion face.###\n        #dblYOffset = self.__m_dblPaneThickness + 0.125 / 12 / 2.54 # Mullion Y location (2.54 converting feet to meters)\n        \n        bWindowFrame = False #sets on window frame mode (vs mullion mode)\n        \n        #Populating array with panel dimensions (no window points divisions)\n        arrHorPoints = [[0, 0, 0], [self.__m_dblWidth, 0, 0]]\n        arrVertPoints = [[0, 0, 0], [0, 0, self.__m_dblHeight]]\n        \n\n        if self.__m_blnShowWindow :\n            #elif not self.__m_blnShowPane :#only punched window mullion type\n            if (type(dblThickness) == ListType or type(dblCapThickness) == ListType):\n                if (type(dblThickness) == ListType and len(dblThickness) > 1) or (type(dblCapThickness) == ListType and len(dblCapThickness) > 1):\n                    #3-piece mullions if curtain-wall with opening\n                    arrHorPoints = [[0, 0, 0], [self.__m_arrWindowPoints[0][0], 0, 0],[self.__m_arrWindowPoints[1][0], 0, 0], [self.__m_dblWidth, 0, 0]]  \n                    arrVertPoints = [[0, 0, 0], [0, 0, self.__m_arrWindowPoints[0][2]],[0, 0, self.__m_arrWindowPoints[2][2]], [0, 0, self.__m_dblHeight]]\n                else: #if one list item will be used for Window frame only    \n                    bWindowFrame = True\n            #if full window panel? (no pane object) also use window frame settings\n            if not self.__m_arrPaneBreps or self.__m_arrPaneBreps == [0] :\n                if type(dblThickness) == ListType and len(dblThickness) > 1 : dblThickness = dblThickness[1]\n                if type(dblCapThickness) == ListType and len(dblCapThickness) > 1 : dblCapThickness = dblCapThickness[1]\n                bWindowFrame = True \n\n            if bWindowFrame == True :\n                dblYOffset = -self.__m_dblWinGlassOffset + self.__m_dblWinGlassThickness + .004 * self.__m_unitCoef\n                arrHorPoints = [[self.__m_arrWindowPoints[0][0], 0, 0],[self.__m_arrWindowPoints[1][0], 0, 0]]\n                arrVertPoints = [[0, 0, self.__m_arrWindowPoints[0][2]],[0, 0, self.__m_arrWindowPoints[2][2]]]   \n        \n        \n        #Mullion type specific settings\n        if strMullionType ==  \"PanelBottom\":\n           arrMullionPoints = arrHorPoints     #start from the base horizontal or vertical points depending if its hor or vert mullion \n           arrDeltaPoint = [0, dblYOffset, 0]  # Store the appropiate distance from 0 based on the mullion type/location \n        elif strMullionType ==  \"WindowBottom\":\n            arrMullionPoints = arrHorPoints\n            arrDeltaPoint = [0, dblYOffset, self.__m_arrWindowPoints[0][2]]\n        elif strMullionType ==  \"WindowTop\":\n            arrMullionPoints = arrHorPoints\n            arrDeltaPoint = [0, dblYOffset, self.__m_arrWindowPoints[2][2]]\n        elif strMullionType ==  \"PanelTop\":\n            arrMullionPoints = arrHorPoints\n            arrDeltaPoint = [0, dblYOffset, self.__m_dblHeight]\n            \n        elif strMullionType ==  \"PanelLeft\":\n            arrMullionPoints = arrVertPoints\n            arrDeltaPoint = [0, dblYOffset, 0]\n        elif strMullionType ==  \"WindowLeft\":\n            arrMullionPoints = arrVertPoints\n            arrDeltaPoint = [self.__m_arrWindowPoints[0][0], dblYOffset, 0]\n        elif strMullionType ==  \"WindowRight\":\n            arrMullionPoints = arrVertPoints\n            arrDeltaPoint =[self.__m_arrWindowPoints[1][0], dblYOffset, 0]\n        elif strMullionType ==  \"PanelRight\":\n            arrMullionPoints = arrVertPoints\n            arrDeltaPoint = [self.__m_dblWidth, dblYOffset, 0]\n            \n            #if Hor : format is Hor_fromBottom=number. Compile line to use value\n        elif \"Hor_\" in strMullionType :\n            arrMullionPoints = arrHorPoints\n            fromBottom=0\n            strData = strMullionType[4:len(strMullionType)]\n            codeObj= compile(strData,'<string>','single')\n            eval(codeObj)\n            arrDeltaPoint = [0, dblYOffset, fromBottom]\n            \n            #if Vert : format is Vert_fromLeft=number. Compile line to use value\n        elif \"Vert_\" in strMullionType :\n            arrMullionPoints = arrVertPoints\n            fromLeft=0\n            strData = strMullionType[5:len(strMullionType)]\n            codeObj= compile(strData,'<string>','single')\n            eval(codeObj)\n            arrDeltaPoint = [fromLeft, dblYOffset, 0]\n            \n        else:\n            self.__m_warningData.append(\"Wrong mullion type\" + strMullionType)\n            return\n    \n        arrXform = rs.XformTranslation(arrDeltaPoint) # create matrix from vector to add delta(distance) to base points in one line\n        arrMullionPoints = rs.PointArrayTransform(arrMullionPoints, arrXform) # add delta(distance) to base mullions to get final 4 points locations\n        \n        \n        #Create 1 or 3 mullions using the obtained points sending them in pairs (end points of each mullion)\n\n        for i in range(len(arrMullionPoints)-1) :\n            \n            if rs.PointCompare(arrMullionPoints[i], arrMullionPoints[i + 1]) :\n                continue #skip if points on same location\n            \n            #detect if thickness is one value or three(varying thinkness along mullion)\n            if type(dblThickness) is ListType and len(dblThickness)> i: mullThickness = dblThickness[i]\n            else : mullThickness = dblThickness\n            \n            if mullThickness > 0 and self.GetDrawMode() <> \"LADYBUG\" : \n                \n                arrMullions.append(self.DrawMember(arrMullionPoints[i], arrMullionPoints[i + 1], dblWidth, mullThickness))\n\n            #else:\n                #arrMullions.append(rs.AddPoint(self.__m_arrBoundingBox[0])) #just a point as placeholder at Panel origin\n            \n            if  dblCapWidth > 0.0 :\n                #detect if thickness is one value or three(varying thinkness along mullion)\n                if type(dblCapThickness) is ListType and len(dblCapThickness)> i: capThickness = dblCapThickness[i]\n                else : capThickness = dblCapThickness\n                if  capThickness > 0.0 : #Cap data?\n                    if self.GetDrawMode() <> \"LADYBUG\" or (self.GetDrawMode() == \"LADYBUG\" and capThickness >= self.__m_LadybugShadeThresh) :\n                        # create matrix with  translation to get cap Y location\n                        arrXform = rs.XformTranslation([0, -capThickness - (self.__m_dblWinGlassThickness if bWindowFrame else self.__m_dblPaneThickness) - .008 * self.__m_unitCoef, 0])\n                        arrCapMullionPoints = rs.PointArrayTransform(arrMullionPoints, arrXform) # new points location\n                        arrMullions.append(self.DrawMember(arrCapMullionPoints[i], arrCapMullionPoints[i + 1], dblCapWidth, capThickness))\n                        \n            #else:\n                #arrMullions.append(rs.AddPoint(self.__m_arrBoundingBox[0])) #just a point as placeholder at Panel origin\n        \n        \n        if arrMullions == [] : arrMullions = None       \n        #return the array of mullions back to function call\n        return arrMullions\n        \n        \n    #------------------------------------------------------------------------------------------------------------------------------------\n    #------------------------------------------------------------------------------------------------------------------------------------\n    \n    #Member creation using start/end, width, thickness parameters\n    \n    def DrawMember(self, arrStartPoint, arrEndPoint, dblWidth, dblThickness, dblRotation=0, arrOffsetStart=None, arrOffsetEnd=None) :\n\n        if rs.PointCompare(arrStartPoint, arrEndPoint) : return #return if same points start,end\n        \n        \n        #To create 4 surface points based on 2 points a vertical or horizontal offset need to be defined\n        #depending on member type:horizontal or verical\n        if arrStartPoint[0] == arrEndPoint[0] :     #Is Vertical?\n            cornerPt1 = rg.Point3d(arrStartPoint[0]-dblWidth/2, arrStartPoint[1]+dblThickness, arrStartPoint[2])\n            cornerPt2 = rg.Point3d(cornerPt1[0], arrStartPoint[1], cornerPt1[2])\n            cornerPt3 = rg.Point3d(cornerPt2[0], cornerPt2[1], arrEndPoint[2])\n            cornerPt4 = rg.Point3d(cornerPt1[0], cornerPt1[1], cornerPt3[2])\n            \n            ptExtrusion = rg.Point3d(dblWidth,0,0)\n            vecRot = rg.Vector3d(0,0,1) #for rotation\n            \n        elif arrStartPoint[2] == arrEndPoint[2] :   #Is Horizontal?\n            cornerPt1 = rg.Point3d(arrStartPoint[0], arrStartPoint[1]+dblThickness, arrStartPoint[2]-dblWidth/2)\n            cornerPt2 = rg.Point3d(cornerPt1[0], arrStartPoint[1], cornerPt1[2])\n            cornerPt3 = rg.Point3d(arrEndPoint[0], cornerPt2[1], cornerPt2[2])\n            cornerPt4 = rg.Point3d(cornerPt3[0], cornerPt1[1], cornerPt3[2])\n            \n            ptExtrusion = rg.Point3d(0,0,dblWidth)\n            vecRot = rg.Vector3d(1,0,0) #for rotation\n        else:\n            return\n        \n        #apply offset values on outside points of object.\n        if arrOffsetStart : \n            cornerPt2 = cornerPt2 + rg.Point3d(arrOffsetStart[0], arrOffsetStart[1], arrOffsetStart[2] )\n        if arrOffsetEnd :\n            cornerPt3 = cornerPt3 + rg.Point3d(arrOffsetEnd[0], arrOffsetEnd[1], arrOffsetEnd[2] )     \n        \n        rcTolerance = sc.doc.ModelAbsoluteTolerance\n        #create ocorner points for surface\n        brepMember = rg.Brep.CreateFromCornerPoints(cornerPt1 ,cornerPt2, cornerPt3, cornerPt4, rcTolerance)\n        brepMember = brepMember.Faces.Item[0].CreateExtrusion(rg.LineCurve(rg.Point3d(0,0,0), ptExtrusion), True)    \n        \n        if dblRotation <> 0 : \n            ptCenter = rg.Point3d(arrStartPoint[0],arrStartPoint[1]+dblThickness/2,arrStartPoint[2])            \n            brepMember.Rotate(math.radians(dblRotation), vecRot, ptCenter)\n            \n        return brepMember\n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def DrawShading(self):\n\n        \n        self.__m_arrShadingBreps = []\n\n        #Populate array with new shadine elements based on Data array\n        if len(self.__m_arrShadingUserData[0]) :\n            self.__m_arrShadingBreps = []\n            for i in range(len(self.__m_arrShadingUserData[0])) :\n                tmpShadingObjects = self.DrawShadingType(self.__m_arrShadingUserData[0][i], self.__m_arrShadingUserData[1][i], self.__m_arrShadingUserData[2][i],\\\n                    self.__m_arrShadingUserData[3][i], self.__m_arrShadingUserData[4][i], self.__m_arrShadingUserData[5][i], self.__m_arrShadingUserData[6][i],\\\n                    self.__m_arrShadingUserData[7][i], self.__m_arrShadingUserData[9][i])\n                if tmpShadingObjects <> None : self.__m_arrShadingBreps.append(tmpShadingObjects)\n        if not self.__m_arrShadingBreps or self.__m_arrShadingBreps[0] == None : self.__m_arrShadingBreps = [0]\n        \n        \n    def DrawShadingType(self,  strShadingType, fromLeftBottomCorner, fromRightTop, width=.05*_UNIT_COEF, thickness=0.05*_UNIT_COEF, offset=0, spacing=.1*_UNIT_COEF, rotation=0, shiftEnds=[None,None]):\n        \n        if thickness <= 0 or width <= 0 : return\n        \n        #----Setting up parameters common to all shading types\n        start = [0,0,0]; end = [0,0,0]\n        start[1] = -offset-thickness; end[1] = -offset-thickness\n        tmpFromLeftBottomCorner = copy.deepcopy(fromLeftBottomCorner)\n        tmpFromRightTop = copy.deepcopy(fromRightTop)\n        #----Setting up parameters based on shading type\n        #Single Shade options:\n        if strShadingType in [\"HorizontalShade\", \"HorizontalWindowShade\"]:  #---Single Vertical Shade\n            if strShadingType == \"HorizontalWindowShade\":\n                if self.__m_blnShowWindow : \n                    # - negative value defines distance from window head \n                    if tmpFromLeftBottomCorner[1] < 0 :  tmpFromLeftBottomCorner[1] = self.__GetPanelProperty(\"WindowHeight\") + tmpFromLeftBottomCorner[1]\n                    if tmpFromLeftBottomCorner[0] < 0 :  tmpFromLeftBottomCorner[0] = self.__GetPanelProperty(\"WindowWidth\") + tmpFromLeftBottomCorner[0]\n                    # add values to remap distances from window lower left corner\n                    tmpFromLeftBottomCorner[0] += self.__GetPanelProperty(\"WindowLeft\")\n                    tmpFromLeftBottomCorner[1] += self.__GetPanelProperty(\"WindowBottom\")\n                    tmpFromRightTop  += self.__GetPanelProperty(\"WindowRight\")\n                else: return\n            start[0] = tmpFromLeftBottomCorner[0]; start[2] = tmpFromLeftBottomCorner[1]\n            end[0] = self.__GetPanelProperty(\"PanelWidth\")-tmpFromRightTop\n            end[2] = tmpFromLeftBottomCorner[1]\n            if start[0] >= end[0] or start[0] < 0 or start[0] > self.GetWidth()*self.__m_dimRoundCoef or start[2] < 0 or start[2] > self.GetHeight()*self.__m_dimRoundCoef:\n                self.__m_warningData.append(\"Invalid \"+ strShadingType + \" data\"); return None #check for wrong data\n            if  rotation <> 0 : #adjust start-end points of shade to offset rotation from center of sunshade to side closer to panel.\n                start[2] -= math.sin(math.radians(rotation))*thickness/2\n                end[2] -= math.sin(math.radians(rotation))*thickness/2\n                start[1] += thickness/2 - math.cos(math.radians(rotation))*thickness/2\n                end[1] += thickness/2 - math.cos(math.radians(rotation))*thickness/2\n            return [self.DrawMember(start, end, width, thickness, rotation, shiftEnds[0], shiftEnds[1])]\n            \n        elif strShadingType in [\"VerticalShade\", \"VerticalWindowShade\"]: #---Single Horizontal Shade\n            if strShadingType == \"VerticalWindowShade\":\n                if self.__m_blnShowWindow:\n                   # - negative value defines distance from window head and right jamb\n                    if tmpFromLeftBottomCorner[1] < 0 :  tmpFromLeftBottomCorner[1] = self.__GetPanelProperty(\"WindowHeight\") + tmpFromLeftBottomCorner[1]\n                    if tmpFromLeftBottomCorner[0] < 0 :  tmpFromLeftBottomCorner[0] = self.__GetPanelProperty(\"WindowWidth\") + tmpFromLeftBottomCorner[0]\n                    # add values to remap distances from window lwer left corner\n                    tmpFromLeftBottomCorner[0] += self.__GetPanelProperty(\"WindowLeft\")\n                    tmpFromLeftBottomCorner[1] += self.__GetPanelProperty(\"WindowBottom\")\n                    tmpFromRightTop  += self.__GetPanelProperty(\"WindowTop\")\n                else: return               \n            start[0] = tmpFromLeftBottomCorner[0]; start[2] = tmpFromLeftBottomCorner[1]\n            end[0] = tmpFromLeftBottomCorner[0]\n            end[2] = self.__GetPanelProperty(\"PanelHeight\")-tmpFromRightTop\n            if start[2] >= end[2] or start[0] < 0 or start[0] > self.GetWidth()*self.__m_dimRoundCoef or start[2] < 0 or start[2] > self.GetHeight()*self.__m_dimRoundCoef:\n                self.__m_warningData.append(\"Invalid \"+ strShadingType + \" data\"); return None #check for wrong data\n            if  rotation <> 0 : #adjust start-end points of shade to offset rotation from center of sunshade to side closer to panel.\n                start[0] += math.sin(math.radians(rotation))*thickness/2\n                end[0] += math.sin(math.radians(rotation))*thickness/2\n                start[1] += thickness/2 - math.cos(math.radians(rotation))*thickness/2\n                end[1] += thickness/2 - math.cos(math.radians(rotation))*thickness/2\n            return [self.DrawMember(start, end, width, thickness, rotation, shiftEnds[0], shiftEnds[1])]\n            \n        #Louver type options:\n        elif strShadingType in [\"HorizontalLouver\", \"HorizontalWindowLouver\"] : #---VerticalLouvers\n            if strShadingType == \"HorizontalWindowLouver\":\n                if self.__m_blnShowWindow : \n                    tmpFromLeftBottomCorner[0] += self.__GetPanelProperty(\"WindowLeft\")\n                    tmpFromLeftBottomCorner[1] += self.__GetPanelProperty(\"WindowBottom\")\n                    tmpFromRightTop[0]  += self.__GetPanelProperty(\"WindowRight\")\n                    tmpFromRightTop[1]  += self.__GetPanelProperty(\"WindowTop\")\n                else: return\n            start[0] = tmpFromLeftBottomCorner[0]; start[2] = tmpFromLeftBottomCorner[1]        \n            end[0] = self.__GetPanelProperty(\"PanelWidth\")-tmpFromRightTop[0]\n            valZ = start[2]\n            endZ = self.__GetPanelProperty(\"PanelHeight\")-tmpFromRightTop[1]\n            if start[0] >= end[0] or start[2] < 0 or start[2] > self.GetHeight()*self.__m_dimRoundCoef: return None #check for wrong data\n            arrLouvers = []\n            #adjust start-end points of shade to offset rotation from center of sunshade to side closer to panel.\n            offsetZ = 0; offsetY = 0\n            if  rotation <> 0 : \n                offsetZ = math.sin(math.radians(rotation))*thickness/2\n                offsetY = thickness/2 - math.cos(math.radians(rotation))*thickness/2\n                start[1] += offsetY; end[1] += offsetY\n            while valZ <= endZ :\n                start[2] = end[2] = valZ - offsetZ\n                arrLouvers.append(self.DrawMember(start, end, width, thickness, rotation, shiftEnds[0], shiftEnds[1]))\n                valZ += spacing\n            return arrLouvers\n            \n        if strShadingType in [\"VerticalLouver\", \"VerticalWindowLouver\" ]: #---Horizontal Louvers\n            if strShadingType == \"VerticalWindowLouver\":\n                if self.__m_blnShowWindow:\n                    tmpFromLeftBottomCorner[0] += self.__GetPanelProperty(\"WindowLeft\")\n                    tmpFromLeftBottomCorner[1] += self.__GetPanelProperty(\"WindowBottom\")\n                    tmpFromRightTop[0]  += self.__GetPanelProperty(\"WindowRight\")\n                    tmpFromRightTop[1]  += self.__GetPanelProperty(\"WindowTop\")\n                else: return               \n            start[0] = tmpFromLeftBottomCorner[0]; start[2] = tmpFromLeftBottomCorner[1]        \n            end[2] = self.__GetPanelProperty(\"PanelHeight\")-tmpFromRightTop[1]\n            valX = start[0]\n            endX = self.__GetPanelProperty(\"PanelWidth\")-tmpFromRightTop[0]\n            if start[2] >= end[2] or start[0] < 0 or start[0] > self.GetWidth()*self.__m_dimRoundCoef: return None #check for wrong data\n            arrLouvers = []\n            #adjust start-end points of shade to offset rotation from center of sunshade to side closer to panel.\n            offsetX = 0; offsetY = 0\n            if  rotation <> 0 : \n                offsetX = math.sin(math.radians(rotation))*thickness/2\n                offsetY = thickness/2 - math.cos(math.radians(rotation))*thickness/2\n                start[1] += offsetY; end[1] += offsetY\n            \n            while valX <= endX :\n                start[0] = end[0] = valX+offsetX\n                arrLouvers.append(self.DrawMember(start, end, width, thickness, rotation, shiftEnds[0], shiftEnds[1]))\n                valX += spacing\n            return arrLouvers\n            \n        else: self.__m_warningData.append(\"Incorrect louver type: \" + strShadingType) ; return\n        \n        \n        \n        \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def DrawCustomGeometry(self):\n\n\n        if self.__m_CustomGeoBreps == None or self.__m_CustomGeoBreps == [] : return\n        tolerance = sc.doc.ModelAbsoluteTolerance\n        self.__m_CustomGeoDrawBreps = []\n  \n        for brep in self.__m_CustomGeoBreps:\n            tmpCustomGeo = brep.DuplicateBrep()\n            customGeoBBox = tmpCustomGeo.GetBoundingBox(True)\n            customGeoMin = customGeoBBox.Min\n            customGeoMax = customGeoBBox.Max\n            customGeoSize = customGeoMax - customGeoMin\n            \n            # if Trim enabled, trim Custom Geometry to match panel size if extends beyond  \n            if self.__m_CG_trimToPanelSize:\n                if round(customGeoMin.X, 3) < 0 or round(customGeoMax.X, 3) > self.GetWidth() or \\\n                    round(customGeoMin.Y, 3) < 0 or round(customGeoMax.Y, 3) > self.GetHeight():\n                    #create substraction object and subract\n                    pt1 = rg.Point3d(0,-customGeoSize.Y*self.__m_CG_vecScaleFactor.Y+self.__m_CG_vecPlacement.Y-2,0)\n                    pt2 = rg.Point3d(self.GetWidth(), self.__m_CG_vecPlacement.Y+1, self.GetHeight())\n                    tmpBBox = rg.BoundingBox(pt1, pt2)\n                    tmpBoxBrep = rg.Brep.CreateFromBox(tmpBBox)\n                    tmpBrepList = rg.Brep.CreateBooleanIntersection(tmpCustomGeo, tmpBoxBrep, tolerance)\n                    \n                    if tmpBrepList == None : self.__m_warningData.append(\"Panel '\"+self.GetName()+\"': Panel sizing boolean Error - discarding custom geometry\") ; return\n                    \n                    for index in range(len(tmpBrepList)-1):\n                        tmpBrepList[0].Append(tmpBrepList[index+1])\n                    if tmpBrepList : tmpCustomGeo = tmpBrepList[0]\n                    else: tmpCustomGeo = None\n                \n            # if window exists and Window Void enabled subtract window from custom geometry\n            if self.__m_CG_windowDepth and tmpCustomGeo and self.__m_blnShowWindow:\n                arrOpeningPoints = copy.deepcopy(self.__m_arrWindowPoints)\n    \n                #Avoid boolean error when subraction boxes align with panel edges\n                if round(self.__GetPanelProperty(\"WindowLeft\"),3) == 0 : arrOpeningPoints[0][0] = arrOpeningPoints[3][0] = -.1 \n                if round(self.__GetPanelProperty(\"WindowRight\"),3) == 0 : arrOpeningPoints[1][0] = arrOpeningPoints[2][0] = self.GetWidth()+.1 \n                if round(self.__GetPanelProperty(\"WindowBottom\"),3) == 0 : arrOpeningPoints[0][2] = arrOpeningPoints[1][2] = -.1 \n                if round(self.__GetPanelProperty(\"WindowTop\"),3) == 0 : arrOpeningPoints[2][2] = arrOpeningPoints[3][2] = self.GetHeight()+.1\n              \n                #create subraction object\n                voidDepth = 0\n                if self.__m_CG_windowDepth == \"True\" : voidDepth = -customGeoSize.Y * self.__m_CG_vecScaleFactor.Y + self.__m_CG_vecPlacement.Y\n                else : voidDepth = -self.__m_CG_windowDepth+self.__m_CG_vecPlacement.Y\n                pt1 = rg.Point3d(arrOpeningPoints[0][0], voidDepth - self.__m_dblWinGlassOffset, arrOpeningPoints[0][2])\n                pt2 = rg.Point3d(arrOpeningPoints[2][0], self.__m_CG_vecPlacement.Y-self.__m_dblWinGlassOffset, arrOpeningPoints[2][2])\n                tmpWinBox = rg.BoundingBox(pt1, pt2)\n    \n                #check if both window and custom geometry overlap before creating opening\n                tmpGeoBBox = tmpCustomGeo.GetBoundingBox(True)\n                if tmpGeoBBox.Min.X < tmpWinBox.Max.X and tmpGeoBBox.Min.Z < tmpWinBox.Max.Z: \n                    tmpWinBoxBrep = rg.Brep.CreateFromBox(tmpWinBox)\n                    tmpBrepList = rg.Brep.CreateBooleanDifference(tmpCustomGeo, tmpWinBoxBrep, tolerance)\n                    #unify pieces in one brep\n                    if tmpBrepList <> None : \n                        for index in range(len(tmpBrepList)-1):\n                            tmpBrepList[0].Append(tmpBrepList[index+1])\n                        if tmpBrepList : tmpCustomGeo = tmpBrepList[0] \n                    else : \n                        self.__m_warningData.append(\"Panel '\"+self.GetName()+\"': Window Boolean error - discarding boolean\")\n                \n            if tmpCustomGeo : self.__m_CustomGeoDrawBreps.append(tmpCustomGeo)\n        \n        #if in Ladybug draw mode check if custom geometry projection off facade is les than Ladybug shading threshhold \n        if self.GetDrawMode() == \"LADYBUG\" :\n            bbox = rg.BoundingBox.Empty\n            for  brep in self.__m_CustomGeoDrawBreps:\n                bbox.Union(brep.GetBoundingBox(True))\n                if bbox.Max.Y-bbox.Min.Y < self.__m_LadybugShadeThresh: \n                    self.__m_CustomGeoDrawBreps = []\n                    return\n    \n    #----------------------------------------------------------------------------------------------------------------------\n    #----------------------------------------------------------------------------------------------------------------------\n    def DrawMorph(self):\n        \n        panelBrepList = self.GetBreps()\n        self.BoxMorphObject(panelBrepList)\n        \n        #Store deform box as new panel bounding box\n        self.__m_arrBoundingBox = self.__m_arrDeformBox\n        \n        \n    #Work around Phyton not implementing yet morphing func(BoxMorphObject) used in DrawMorph()------------------------------------------------\n    def BoxMorphObject(self, arrObjects):\n        \n        for obj in arrObjects : \n            obj.Transform(self.__m_TransformMatrix)\n    \n    \n    def GetBreps(self, objectType=None):\n        \n        brepList = []\n        \n        if objectType == \"Wall\" or objectType == None :\n            if  self.__m_blnShowWall and len(self.__m_arrWallBreps) and self.__m_arrWallBreps <> [0]: \n                if objectType == \"Wall\" : return self.__m_arrWallBreps\n                brepList += self.__m_arrWallBreps\n\n        if objectType == \"Window\" or objectType == None :                \n            if  self.__m_blnShowWindow and self.__m_dblWinGlassThickness and self.__m_arrWindowBreps <> [0]:\n                if objectType == \"Window\" : return self.__m_arrWindowBreps\n                brepList += self.__m_arrWindowBreps\n\n        if objectType == \"Pane\" or objectType == None :\n            if  self.__m_blnShowPane and len(self.__m_arrPaneBreps) and self.__m_arrPaneBreps <> [0]:\n                if objectType == \"Pane\" : return self.__m_arrPaneBreps\n                brepList += self.__m_arrPaneBreps\n\n        if objectType == \"Mullions\" or objectType == None :\n            if  self.__m_blnShowMullions :\n                brepObjects = []\n                if len(self.__m_arrMullionHorBreps) and self.__m_arrMullionHorBreps[0]:\n                    for i in range(self.__GetPanelProperty(\"MullionHorNum\")):\n                        arrMullions = self.__GetPanelPropertyArray(\"MullionHorObjArray\", i)\n                        if arrMullions and arrMullions[0] and not type(arrMullions[0]) == IntType:\n                            brepObjects.extend(arrMullions)\n                if len(self.__m_arrMullionVertBreps) and self.__m_arrMullionVertBreps[0]:\n                    for i in range(self.__GetPanelProperty(\"MullionVertNum\")):\n                        arrMullions = self.__GetPanelPropertyArray(\"MullionVertObjArray\", i)\n                        if arrMullions and arrMullions[0] and not type(arrMullions[0]) == IntType:\n                            brepObjects.extend(arrMullions)\n                if objectType == \"Mullions\" : return brepObjects\n                brepList += brepObjects\n                \n        if objectType == \"Shading\" or objectType == None :\n            if  self.__m_blnShowShading and self.__m_arrShadingBreps and self.__m_arrShadingBreps <> [0]:\n                brepObjects = []\n                for arrShading in self.__m_arrShadingBreps : brepObjects += arrShading\n                if objectType == \"Shading\" : return brepObjects\n                brepList += brepObjects\n                \n        if objectType == \"CustomGeometry\" or objectType == None :\n            if  self.__m_blnShowCustomGeo:\n                if objectType == \"CustomGeometry\" : return self.__m_CustomGeoDrawBreps        \n                brepList += self.__m_CustomGeoDrawBreps\n            \n        return brepList\n        \n        \n        \n    def DrawSceneObjects(self, objectType=None):\n        \n        parentLayerName = \"SKIN_DESIGNER\"\n        if self.__m_SkinParentName <> None : parentLayerName = self.__m_SkinParentName.split(\"::\")[0]\n        if not rs.IsLayer(parentLayerName) : rs.AddLayer(parentLayerName)\n        \n        currentLayer = rs.CurrentLayer()\n        \n        \n        if objectType == \"Wall\" or objectType == None:\n            #Delete Old Wall If Exists\n            if  type(self.__m_arrWallObjects) == ListType and not type(self.__m_arrWallObjects[0]) == IntType and rs.IsObject(self.__m_arrWallObjects[0]): \n                rs.DeleteObjects(self.__m_arrWallObjects)\n            if  self.__m_blnShowWall and len(self.__m_arrWallBreps) and self.__m_arrWallBreps <> [0]: \n                if not rs.IsLayer(parentLayerName+\"::_P_Wall\") : rs.AddLayer(\"_P_Wall\", parent=parentLayerName)\n                rs.CurrentLayer(parentLayerName+\"::_P_Wall\")\n                self.__m_arrWallObjects = []\n                for brep in self.__m_arrWallBreps : self.__m_arrWallObjects += [sc.doc.Objects.AddBrep(brep)]\n            \n        if objectType == \"Pane\" or objectType == None:\n            if  type(self.__m_arrPaneObjects) == ListType and not type(self.__m_arrPaneObjects[0]) == IntType \\\n                and rs.IsObject(self.__m_arrPaneObjects[0]): rs.DeleteObjects(self.__m_arrPaneObjects)\n            if  self.__m_blnShowPane and len(self.__m_arrPaneBreps) and self.__m_arrPaneBreps <> [0]:\n                if not rs.IsLayer(parentLayerName+\"::\"+self.__m_strPaneName) : rs.AddLayer(self.__m_strPaneName, parent=parentLayerName)\n                rs.CurrentLayer(parentLayerName+\"::\"+self.__m_strPaneName)\n                self.__m_arrPaneObjects = []\n                for brep in self.__m_arrPaneBreps : self.__m_arrPaneObjects += [sc.doc.Objects.AddBrep(brep)]\n                \n        if objectType == \"Window\" or objectType == None:\n            if type(self.__m_arrWindowObjects) == ListType and not type(self.__m_arrWindowObjects[0]) == IntType \\\n                and rs.IsObject(self.__m_arrWindowObjects[0]) : rs.DeleteObjects(self.__m_arrWindowObjects)\n            if  self.__m_blnShowWindow and self.__m_dblWinGlassThickness and self.__m_arrWindowBreps <> [0]:\n                if not rs.IsLayer(parentLayerName+\"::_P_Glass\") : rs.AddLayer(\"_P_Glass\", parent=parentLayerName)\n                rs.CurrentLayer(parentLayerName+\"::_P_Glass\")\n                self.__m_arrWindowObjects = []\n                for brep in self.__m_arrWindowBreps : self.__m_arrWindowObjects += [sc.doc.Objects.AddBrep(brep)]\n                \n        if objectType == \"Mullions\" or objectType == None:\n            #Horizontal mullions\n            if type(self.__m_arrMullionHorObjects) == ListType and len(self.__m_arrMullionHorObjects) and not type(self.__m_arrMullionHorObjects[0]) == IntType \\\n                and rs.IsObject(self.__m_arrMullionHorObjects[0]) : rs.DeleteObjects(self.__m_arrMullionHorObjects)\n            if len(self.__m_arrMullionHorBreps) and self.__m_arrMullionHorBreps[0]:\n                self.__m_arrMullionHorObjects = []\n                if not rs.IsLayer(parentLayerName+\"::_P_Mullions\") : rs.AddLayer(\"_P_Mullions\", parent=parentLayerName)\n                rs.CurrentLayer(parentLayerName+\"::_P_Mullions\")\n                for i in range(self.__GetPanelProperty(\"MullionHorNum\")):\n                    arrMullions = self.__GetPanelPropertyArray(\"MullionHorObjArray\", i)\n                    if arrMullions and arrMullions[0] and not type(arrMullions[0]) == IntType:\n                        for brep in arrMullions : self.__m_arrMullionHorObjects += [sc.doc.Objects.AddBrep(brep)]\n\n            #Delete Verticals mullions\n            if type(self.__m_arrMullionVertObjects) == ListType and len(self.__m_arrMullionVertObjects) and not type(self.__m_arrMullionVertObjects[0]) == IntType \\\n                and rs.IsObject(self.__m_arrMullionVertObjects[0]) : rs.DeleteObjects(self.__m_arrMullionVertObjects)\n            if len(self.__m_arrMullionVertBreps) and self.__m_arrMullionVertBreps[0]:\n                self.__m_arrMullionVertObjects = []\n                if not rs.IsLayer(parentLayerName+\"::_P_Mullions\") : rs.AddLayer(\"_P_Mullions\", parent=parentLayerName)\n                rs.CurrentLayer(parentLayerName+\"::_P_Mullions\")\n                for i in range(self.__GetPanelProperty(\"MullionVertNum\")):\n                    arrMullions = self.__GetPanelPropertyArray(\"MullionVertObjArray\", i)\n                    if arrMullions and arrMullions[0] and not type(arrMullions[0]) == IntType:\n                        for brep in arrMullions : self.__m_arrMullionVertObjects += [sc.doc.Objects.AddBrep(brep)]\n                \n        if objectType == \"Shading\" or objectType == None:\n            #Detlete Shading\n            if type(self.__m_arrShadingObjects) == ListType and not type(self.__m_arrShadingObjects[0]) == IntType \\\n                and rs.IsObject(self.__m_arrShadingObjects[0]) : rs.DeleteObjects(self.__m_arrShadingObjects)\n            if  self.__m_blnShowShading and self.__m_arrShadingBreps and self.__m_arrShadingBreps <> [0]:\n                self.__m_arrShadingObjects = []; i=0\n                for arrShading in self.__m_arrShadingBreps :\n                    if not rs.IsLayer(parentLayerName+\"::\"+self.__m_arrShadingUserData[8][i]) : rs.AddLayer(self.__m_arrShadingUserData[8][i], parent=parentLayerName)\n                    rs.CurrentLayer(parentLayerName+\"::\"+self.__m_arrShadingUserData[8][i])\n                    for brep in arrShading : self.__m_arrShadingObjects += [sc.doc.Objects.AddBrep(brep)]\n                    i += 1\n                    \n        if objectType == \"CustomGeometry\" or objectType == None:\n            if type(self.__m_CustomGeoObjects) == ListType and len(self.__m_CustomGeoObjects) > 0 \\\n                and rs.IsObject(self.__m_CustomGeoObjects[0]) : rs.DeleteObjects(self.__m_CustomGeoObjects)\n            self.__m_CustomGeoObjects = []\n            if  self.__m_blnShowCustomGeo and self.__m_CustomGeoDrawBreps <> [] :\n                for brep in self.__m_CustomGeoDrawBreps:\n                    CGLayerName = brep.GetUserString(\"Layer\")\n                    if CGLayerName == None or CGLayerName == \"\": CGLayerName = \"CustomGeo\"\n                    if not rs.IsLayer(parentLayerName+\"::_P_\"+CGLayerName) : rs.AddLayer(\"_P_\"+CGLayerName, parent=parentLayerName)\n                    rs.CurrentLayer(parentLayerName+\"::_P_\"+CGLayerName)\n                    self.__m_CustomGeoObjects.append(sc.doc.Objects.AddBrep(brep))\n            \n        rs.CurrentLayer(currentLayer)\n        \n#----------------------------------------------------------------------------------------------------------------------\n\nSGLibPanel = Panel\n\n\n\n\nclass Skin:\n    \n    __m_skinGenName = \"\" # Name id (avoids overlapping block names between skin instances\n    __m_GeneratePanelsOnly = False\n    \n    __m_dblOffsetLevel = 0  #Offset in elevation from path to be considered bottom of panel. Any value > 0 creates custom panel. \n    __m_dblOffsetPath = 0 #Offset x distance of first panel at segments.Use list for different dimensions at each segment\n    __m_blnSkinWrap = True #Wrap at corners or create custom corner panels\n    \n    \n    __m_resetBayAtPoints = True #Start new bay at new segment\n    \n    __m_dblFloorToFloor = 4 * _UNIT_COEF #Floor height\n    __m_dblMinPanelWidth = 0 #if surface cell width is below this number it will be ignored and panel won't be created.\n    __m_dblMinPanelHeight = 0 #if surface cell height is below this number will be ignored and panel won't be created.\n        \n    \n    __m_flatMode = False  #Low geoemtry mode\n    __m_drawMode = \"\"   #\"LADYBUG\", \"DEFAULT\" \n    __m_random = None #Global Random generator object\n    \n    __m_bayList = None # bays used in skin - 'None' will use all panel bays connected\n\n    # Internal members\n    __m_objSkinSurface = None #skin surface from skin generator\n    __m_surfCurves = [] #top and bottom curves of validated surface\n    __m_userData = [] #user parameters stored in skin surface\n    __m_panelBays = [] #panel bay data from skin generator\n    __m_DesignFunctions = [] \n    \n    __m_arrBayMatrix = [] #surface matrix of bay points\n    __m_intRows = 0 #number of rows on surface\n    __m_intColumns = 0 #number of columns on surface\n    __m_intCurrCellColumn = 0\n    __m_intCurrCellRow = 0\n    __m_intCurrBayIndex = 0\n    __m_intCurrBayPanelIndex = 0\n    \n    __m_arrCornerPoints = []\n    \n    __m_PanelData = {}\n    __m_BayData = {}\n    __m_warningData = []\n    \n    \n    \n    def __init__(self, skinName = \"DEFAULT\", objSkinSurface=None, panelBays=None, designFunctions=None):\n        \n        #Skin generator paramters\n        self.__m_skinGenName = skinName \n        \n        #create rc geometry if it's a document object and extract user surface paramters\n        geo = None; objData = None        \n        if str(type(objSkinSurface)) == \"<type 'Guid'>\" :\n            if  not rs.IsObject(objSkinSurface) : return False #Abort skin creation if object is not valid\n            objData = rs.ObjectName(objSkinSurface) #extract data if any\n            self.__m_objSkinSurface = Rhino.DocObjects.ObjRef(objSkinSurface).Brep()\n            \n        elif type(objSkinSurface) ==  Rhino.Geometry.Brep :\n            self.__m_objSkinSurface = objSkinSurface\n            objData = objSkinSurface.GetUserString('Data')\n            \n        else: return False #Abort skin creation if object is not valid\n        \n        if  self.__m_objSkinSurface == None : return False #Abort skin creation if object is not valid\n        \n        #parse user surface-specific parameters (stored on brep user string or object name)\n        if  objData : self.__m_userData = list(objData.rsplit(\"/\"))  \n\n\n        self.__m_surfCurves = self.ExtractEdges(self.__m_objSkinSurface)\n        \n        self.__m_panelBays = panelBays\n        self.__m_DesignFunctions = designFunctions\n        self.__m_GeneratePanelsOnly = False\n        \n        self.__m_dblOffsetLevel = 0\n        self.__m_dblOffsetPath = 0\n        self.__m_blnSkinWrap = True\n        \n        self.__m_resetBayAtPoints = True\n        \n        self.__m_dblFloorToFloor = panelBays[0][0].GetPanelProperty(\"PanelHeight\")\n        self.__m_dblMinPanelWidth = .1 * _UNIT_COEF\n        self.__m_dblMinPanelHeight = .1 * _UNIT_COEF\n        \n        self.__m_flatMode = False\n        self.__m_drawMode = \"DEFAULT\" \n        self.__m_objRandom = random.Random() \n        \n        self.__m_bayList = None \n      \n        #Internal members        \n        self.__m_arrBayMatrix = [] \n        self.__m_intRows = 0  \n        self.__m_intColumns = 0\n        self.__m_intCurrCellColumn = 0\n        self.__m_intCurrCellRow = 0\n        self.__m_intCurrBayIndex = 0\n        self.__m_intCurrBayPanelIndex = 0\n        self.__m_arrCornerPoints = []\n        self.__m_warningData = []\n        \n        self.__m_PanelData = {}\n        self.__m_BayData = {'BayCounter':[], 'PanelIndices':[], 'BayIndices':[]}\n        self.__m_BayData['BayCounter'] = self.__m_panelBays + [0 for x in self.__m_panelBays] #bay counters in format [list of bays, list of  counters]\n        \n        return True\n\n    def __del__(self):\n        #print \"adios!\"\n        pass\n        \n        \n    def ExtractEdges(self, surface):\n\n            \n        #get flat base curves and heights of single surfaces\n        curveList = []; elevList = []\n        for face in  surface.Faces:\n            curve, elev = self.GetParametersFromFace(face)\n            curveList.append(curve)\n            elevList.append(elev)\n            \n        #unify bottom and top edges to one common top/bottom elevation\n        sortedCurves = sorted(curveList, key=lambda curve: curve.PointAtStart.Z)\n        sortedElevs = sorted(elevList) \n        bottomElev = sortedCurves[-1].PointAtStart.Z\n        for curve in sortedCurves:\n            deltaElev =  bottomElev - curve.PointAtStart.Z\n            curve.Translate(Rhino.Geometry.Vector3d(0,0,deltaElev))\n        bottomCurve = Rhino.Geometry.Curve.JoinCurves(sortedCurves, sc.doc.ModelAbsoluteTolerance, False)[0]\n        #create offset of bottom curve for top curve\n        topCurve = bottomCurve.DuplicateCurve()\n        topCurve.Translate(Rhino.Geometry.Vector3d(0,0,sortedElevs[0]-bottomCurve.PointAtStart.Z))\n        \n        return [bottomCurve, topCurve]\n        \n        \n\n    def GetParametersFromFace(self, face):\n        \n        #Create valid 2d versions of 3d curves\n        def MakeValidEdge(edge, type):\n            \n            ptStart = edge.PointAtStart\n            ptEnd = edge.PointAtEnd\n            if ptStart.Z == ptEnd.Z: return edge\n            else: \n                if  type == \"Bottom\" : curveElev = max(ptStart.Z,ptEnd.Z)\n                elif type == \"Top\" : curveElev = min(ptStart.Z,ptEnd.Z)\n                else: return None\n                plane = Rhino.Geometry.Plane(Rhino.Geometry.Point3d(0,0, curveElev), Rhino.Geometry.Vector3d(0,0,1))\n                return Rhino.Geometry.Curve.ProjectToPlane(edge, plane)\n        \n        #find top/bottom curves and make them 2D\n        edges = face.DuplicateFace(False).DuplicateEdgeCurves()\n        sortedEdges = sorted(edges, key=lambda edge: edge.PointAtNormalizedLength(0.5).Z)\n        bottomEdge = MakeValidEdge(sortedEdges[0].DuplicateCurve(), \"Bottom\")\n        topEdge = MakeValidEdge(sortedEdges[-1].DuplicateCurve(), \"Top\")\n        topElev = topEdge.PointAtStart.Z\n            \n        return bottomEdge, topElev\n        \n        \n        \n    def LoadSurfaceProperties(self):\n        \n        #if self.__m_objSkinSurface == None : return\n        \n        # init from stored paramters\n        OFFSET_LEVEL = self.__m_dblOffsetLevel\n        OFFSET_PATH = self.__m_dblOffsetPath\n        SKIN_WRAP = self.__m_blnSkinWrap\n        PATTERN = self.__m_bayList\n        \n        #look for Surface-specific parameters stored on object name \n        #with format: OFFSET_LEVEL=float/OFFSET_PATH=float/SKIN_WRAP=bool/PATTERN = [int,..]\n        for data in self.__m_userData : \n            if 'OFFSET_LEVEL' in data or 'OFFSET_PATH' in data or 'SKIN_WRAP' in data or 'PATTERN' in data :\n                codeObj= compile(data,'<string>','single') ; eval(codeObj)\n        \n        # parameters update\n        self.__m_dblOffsetLevel = OFFSET_LEVEL\n        self.__m_dblOffsetPath = OFFSET_PATH\n        self.__m_blnSkinWrap = SKIN_WRAP\n        self.__m_bayList = PATTERN if type(PATTERN) == ListType else self.__m_bayList\n              \n        \n        \n    def SetProperty(self, strProperty, value):\n    \n        if strProperty in [\"SKIN_NAME\", \"OFFSET_LEVEL\", \"OFFSET_PATH\", \"SKIN_WRAP\", \"RESET_BAY_AT_POINTS\", \\\n            \"FLAT_MODE\", \"DRAW_MODE\", \"BAY_LIST\", \"MIN_PANEL_WIDTH\", \"MIN_PANEL_HEIGHT\", \"RANDOM_OBJECT\", \\\n            \"FLOOR_HEIGHT\", \"GENERATE_PANELS_ONLY\"] :\n            self.__SetProperty(strProperty, value)\n        else:\n            \"Skin Parameter \"+ strProperty + \" is not valid\"\n        #elif strProperty == \"SKIN_SURFACE\" : self.__m_objSkinSurface = value\n        #elif strProperty == \"PANEL_BAY_LIST\" : self.__m_panelBays = value\n        #elif strProperty == \"DESIGN_FUNCTIONS\" : self.__m_DesignFunctions = value\n        \n    def __SetProperty(self, strProperty, value):\n    \n        if strProperty == \"SKIN_NAME\" : self.__m_skinGenName = value\n        elif strProperty == \"OFFSET_LEVEL\" : self.__m_dblOffsetLevel = value\n        elif strProperty == \"OFFSET_PATH\" : self.__m_dblOffsetPath = value\n        elif strProperty == \"SKIN_WRAP\" : self.__m_blnSkinWrap = value\n        elif strProperty == \"RESET_BAY_AT_POINTS\" : self.__m_resetBayAtPoints = value\n        elif strProperty == \"FLAT_MODE\" : self.__m_flatMode = value\n        elif strProperty == \"DRAW_MODE\" : self.__m_drawMode = value\n        elif strProperty == \"BAY_LIST\" : self.__m_bayList = value\n        elif strProperty == \"MIN_PANEL_WIDTH\" : self.__m_dblMinPanelWidth = value\n        elif strProperty == \"MIN_PANEL_HEIGHT\" : self.__m_dblMinPanelHeight = value        \n        elif strProperty == \"RANDOM_OBJECT\" : self.__m_objRandom = value\n        elif strProperty == \"FLOOR_HEIGHT\" : \n            if value > 0 : self.__m_dblFloorToFloor = value\n        elif strProperty == \"GENERATE_PANELS_ONLY\" : self.__m_GeneratePanelsOnly = value   \n        \n        elif strProperty == \"SKIN_SURFACE\" : self.__m_objSkinSurface = value\n        elif strProperty == \"PANEL_BAY_LIST\" : self.__m_panelBays = value\n        elif strProperty == \"DESIGN_FUNCTIONS\" : self.__m_DesignFunctions = value\n        elif strProperty == \"PANEL_DATA\" : self.__m_PanelData = value\n        elif strProperty == \"BAY_DATA\" : self.__m_BayData = value\n        \n        \n    def GetProperty(self, strProperty):\n        \n        #if strProperty == \"SKIN_SURFACE\" : return self.__m_objSkinSurface\n        if strProperty == \"SKIN_NAME\" : return self.__m_skinGenName\n        elif strProperty == \"SKIN_SURFACE_TYPE\" : return str(type(self.__m_objSkinSurface))\n        elif strProperty == \"SKIN_CELL_ROWS\" : return self.__m_intRows\n        elif strProperty == \"SKIN_CELL_COLUMNS\" : return self.__m_intColumns\n        elif strProperty == \"SKIN_CURRENT_CELL_COLUMN\" : return self.__m_intCurrCellColumn\n        elif strProperty == \"SKIN_CURRENT_CELL_ROW\" : return self.__m_intCurrCellRow       \n        elif strProperty == \"SKIN_CURRENT_BAY_INDEX\" : return self.__m_intCurrBayIndex      \n        elif strProperty == \"SKIN_CURRENT_BAY_PANEL_INDEX\" : return self.__m_intCurrBayPanelIndex   \n        elif strProperty == \"BAY_LIST\" : return copy.deepcopy(self.__m_bayList)\n        elif strProperty == \"FLOOR_HEIGHT\" : return self.__m_dblFloorToFloor\n        elif strProperty == \"WARNING_DATA\": return self.__m_warningData\n            \n    #--------------------------------------------------------------------------------\n    #Retrieves a range of Bay and Panel Properties given cell data. \n    #Needs panel number within bay for specific panel data.\n    #--------------------------------------------------------------------------------    \n    def GetCellProperty(self, intRow, intColumn,  strProperty, bayPanelIndex=0):\n        \n        \n        #TYPE 1 - Cell properties\n        \n        try:\n            bayCornerPts = [self.__m_arrBayMatrix[intRow][intColumn], self.__m_arrBayMatrix[intRow][intColumn + 1],\\\n                self.__m_arrBayMatrix[intRow + 1][intColumn], self.__m_arrBayMatrix[intRow + 1][intColumn + 1]]    \n        except:\n            self.__m_warningData.append(\"GetCellPreoperty: Invalid row/column cell data\") \n            return None\n        \n        #Properties\n        if strProperty == \"CELL_CORNER_POINTS\": return bayCornerPts\n        if strProperty == \"CELL_PLANE\" or strProperty == \"PANEL_PLANE\": \n            return Rhino.Geometry.Plane(bayCornerPts[0], bayCornerPts[1], bayCornerPts[2])\n        if strProperty == \"CELL_NORMAL_VECTOR\" or strProperty == \"PANEL_NORMAL_VECTOR\": \n            return  Rhino.Geometry.Plane(bayCornerPts[0], bayCornerPts[1], bayCornerPts[2]).Normal\n\n        #TYPE 2 - Cell Bay assigment properties\n        #Bay ID assignement\n        cellBayIDsAssigned = list((id for id, points in self.__m_BayData['BayIndices']))\n        cellBayPtsAssigned = list((points for id, points in self.__m_BayData['BayIndices']))\n        bayIndexAssigned = cellBayIDsAssigned[cellBayPtsAssigned.index(bayCornerPts)]\n        #Panel specific vertex data\n        bayPanelMatrix = self.GetPanelMatrix(self.__m_arrBayMatrix, intRow, intColumn, self.__m_panelBays[bayIndexAssigned]) #array of panels corner points in bay\n        \n        \n        #Properties\n        if strProperty == \"BAY_INDEX\" : return bayIndexAssigned\n        if strProperty == \"BAY_POINTS_PANELS\" : return bayPanelMatrix \n        if strProperty == \"BAY_BASE_PANELS\" : return self.__m_panelBays[bayIndexAssigned]\n        if strProperty == \"BAY_NUM_PANELS\" : return len(bayPanelMatrix[0])-1\n        \n        #Type 3 - Panel instance properties\n        \n        try: panelCornerPts = self.GetPanelCorners(bayPanelMatrix, bayPanelIndex)\n        except: panelCornerPts = None\n        #current cell data assigned\n        try: cellPtsAssigned = list((pts for pts, n in self.__m_BayData['PanelIndices'] ))\n        except: cellPtsAssigned = None\n        try: cellNamesAssigned = list((n for pts, n in self.__m_BayData['PanelIndices'] ))\n        except: cellNamesAssigned = None\n        \n        #current panel instance data\n        try:\n            skinPanelList = []\n            for panelGroup in self.__m_PanelData.values():\n                for panel in panelGroup: skinPanelList += [panel]                            \n            panelsCreated = list((panel for panel, changeFlag in skinPanelList))\n            panelNamesCreated = list((panel.GetName() for panel in panelsCreated))\n            panelChgFlagCreated = list((changeFlag for panel, changeFlag in skinPanelList))\n        except: panelNamesCreated = panelChgFlagCreated = None        \n        \n        #Properties\n        if strProperty == \"PANEL_CORNER_POINTS\":\n            if panelCornerPts: return panelCornerPts\n            else: self.__m_warningData.append(\"GetCellProperty: invalid panel index in bay\"); return None\n        \n        if strProperty == \"PANEL_NAME\":\n            if cellPtsAssigned and cellNamesAssigned :\n                panelIndex = cellPtsAssigned.index(panelCornerPts)\n                return cellNamesAssigned[panelIndex]\n            else: \n                self.__m_warningData.append(\"GetCellProperty: cell name data not found\")\n                return None\n                \n        if strProperty == \"PANEL_CELL_ID\":\n            if  cellPtsAssigned : return cellPtsAssigned.index(panelCornerPts)\n            else:\n                self.__m_warningData.append(\"GetCellProperty: cell id data not found\")\n                return None\n                \n        if strProperty == \"PANEL_INSTANCE\":\n            if  cellNamesAssigned and cellPtsAssigned and panelNamesCreated:\n                cellIndex = cellPtsAssigned.index(panelCornerPts)\n                name = cellNamesAssigned[cellIndex]\n                panelIndex = panelNamesCreated.index(name)\n                return panelsCreated[panelIndex]\n            else: \n                self.__m_warningData.append(\"GetCellProperty: panel instance data not found\")\n                return None\n                \n        if strProperty == \"PANEL_CHANGE_FLAG\":\n            if  cellNamesAssigned and cellPtsAssigned and panelChgFlagCreated:\n                try: cellIndex = cellPtsAssigned.index(panelCornerPts)\n                except: self.__m_warningData.append(\"GetCellProperty: panel change flag data not found\"); return None\n                name = cellNamesAssigned[cellIndex]\n                panelIndex = panelNamesCreated.index(name)\n                return panelChgFlagCreated[panelIndex]\n            else: \n                self.__m_warningData.append(\"GetCellProperty: panel change flag data not found\")\n                return None\n                \n        self.__m_warningData.append(\"GetCellProperty: Invalid property: \"+ strProperty)\n        \n        \n        \n        \n    #--------------------------------------------------------------------------------\n    #Generate matrix of corner points of a surface based on panel bay dimensions\n    #--------------------------------------------------------------------------------\n    def GeneratePanelMatrix(self, dblBayWidth, dblFloorToFloor):\n        \n        \n        #use surface floor to floor value if provided\n        if self.__m_dblFloorToFloor > 0 : dblFloorToFloor = self.__m_dblFloorToFloor\n        \n        \n        self.__m_arrBayMatrix = [] #Stores array of bay corner points\n        \n        CurveBottom = Rhino.RhinoDoc.ActiveDoc.Objects.AddCurve(self.__m_surfCurves[0])\n        CurveTop = Rhino.RhinoDoc.ActiveDoc.Objects.AddCurve(self.__m_surfCurves[1])\n        \n        #Create top/bottom curves from Surface(only extruded curves are evalid at the moment)\n        #paramU = rs.SurfaceDomain(self.__m_objSkinSurface,0)   \n        #paramV = rs.SurfaceDomain(self.__m_objSkinSurface,1)\n        #CurveBottom = rs.ExtractIsoCurve (self.__m_objSkinSurface, [paramU[0],paramV[0]], 0)\n        #CurveTop = rs.ExtractIsoCurve (self.__m_objSkinSurface, [paramU[1],paramV[1]], 0)\n\n        #Create points based on panelwidth on top/bottom two curves\n        \n        arrPointsBottom = self.DividePoints(CurveBottom, dblBayWidth, self.__m_dblOffsetPath, self.__m_blnSkinWrap)\n        arrPointsTop = self.DividePoints(CurveTop, dblBayWidth, self.__m_dblOffsetPath, self.__m_blnSkinWrap)\n        rs.DeleteObjects([CurveBottom,CurveTop])\n        \n        #Create plane to define panel grid Vertical points\n        arrPlane = rs.WorldXYPlane()\n        dblFloorTop = arrPointsTop[0][2]\n        \n        if self.__m_dblOffsetLevel: dblFloorLevel = arrPointsBottom[0][2] + self.__m_dblOffsetLevel\n        else: dblFloorLevel = arrPointsBottom[0][2] + dblFloorToFloor\n        \n        #Initialize array to store grid points\n        self.__m_arrBayMatrix.append(arrPointsBottom)\n        intLevel = 0\n        \n        #Create array of grid points\n        while dblFloorLevel < dblFloorTop :\n    \n            arrPlane = rs.WorldXYPlane()\n            levelMove = rs.XformTranslation([0, 0, dblFloorLevel])\n            arrPlane = rs.PlaneTransform(arrPlane, levelMove)\n            pointIndex = 0\n            arrInterPoints = [] #Intersection points in current level\n            \n            for arrPoint in arrPointsTop:\n                \n                #if intLevel == 0 : rs.AddLine(arrPointsBottom[pointIndex], arrPointsTop[pointIndex]) #--to visualize vertical lines\n                arrLine = [arrPointsBottom[pointIndex], arrPointsTop[pointIndex]]  #Create Line from Top / bottom curves\n                arrIntPoint = rs.LinePlaneIntersection(arrLine, arrPlane)#Intersect with level plane to obtain vertial points\n                \n                arrInterPoints.append(arrIntPoint)\n                pointIndex = pointIndex + 1\n    \n            intLevel = intLevel + 1\n            self.__m_arrBayMatrix.append(arrInterPoints)\n            \n            #rs.AddPolyline(self.__m_arrBayMatrix[intLevel]) #--to visualize horizontal lines\n            dblFloorLevel = dblFloorLevel + dblFloorToFloor\n            \n        self.__m_arrBayMatrix.append(arrPointsTop)\n        self.__m_intRows = intLevel+1\n        self.__m_intColumns = len(self.__m_arrBayMatrix[0])-1\n        \n    \n    #--------------------------------------------------------------------------------\n    #Select and divide curve in specific segments\n    #--------------------------------------------------------------------------------\n    def DividePoints(self, strObject, dblLength, dblOffset, skinWrap) :\n        \n        if not rs.IsCurve(strObject) : self.__m_warningData.append(\"DividePoints: Invalid Curve\") ; return\n        \n        newPoints = [] ; segmentList = []\n        \n        if  not skinWrap and rs.CurvePointCount(strObject) > 2 : segmentList = rs.ExplodeCurves(strObject)#create individual segements to avoid wrapping\n        else : segmentList.append(rs.CopyObject(strObject)) #treat as a single segment\n\n        #store corner points to use on panel placement data\n        self.__m_arrCornerPoints = []\n        for segment in segmentList:\n            self.__m_arrCornerPoints.append(rs.CurveStartPoint(segment))\n        self.__m_arrCornerPoints.append(rs.CurveEndPoint(segment))\n\n        #process each segment individually\n        for i in range(len(segmentList)):\n    \n            #----If offset used create new curve to divide at offset start point\n            offset = 0\n            if type(dblOffset)== ListType :\n                if len(dblOffset) > i : offset = dblOffset[i]\n                else: offset = dblOffset[len(dblOffset)-1]\n            else : offset = dblOffset\n            \n            if offset and offset <> round(rs.CurveLength(segmentList[i]),4):\n                \n                domain = rs.CurveDomain(segmentList[i])\n                newPoints.append(rs.CurveStartPoint(segmentList[i]))\n                coefOffset = (dblLength/(dblLength/offset))/rs.CurveLength(segmentList[i])\n                domain[0] = rs.CurveParameter(segmentList[i], coefOffset)\n                tmpSegment = segmentList[i]\n                segmentList[i] = rs.TrimCurve(tmpSegment,domain, True)\n                \n            newPoints.extend(rs.DivideCurveEquidistant(segmentList[i], dblLength))\n            \n            #Adjusting last Panel to absorb leftover dimension(not working)\n            #remainderDist = rs.Distance(newPoints[len(newPoints)-1], rs.CurveEndPoint(segmentList[i]))\n            #if  remainderDist > MIN_PANEL_WIDTH  : newPoints[len(newPoints)-1] = rs.CurveEndPoint(segmentList[i])\n            \n        #remainderDist = rs.Distance(newPoints[len(newPoints)-1], rs.CurveEndPoint(strObject))\n        #if  remainderDist > MIN_PANEL_WIDTH  : newPoints.append(rs.CurveEndPoint(strObject))\n        newPoints.append(rs.CurveEndPoint(strObject))\n        \n        \n        # remove duplicate points\n        index=1\n        while index < len(newPoints):\n            if rs.PointCompare(newPoints[index], newPoints[index-1], 0.01) : del newPoints[index]\n            else: index += 1 \n            \n        \n        #--Wrap up----------------------------------------\n    \n        rs.DeleteObjects(segmentList)\n    \n        return newPoints\n    \n    \n    \n    \n    def GeneratePanelBlocks(self, PanelTypes, BayData):\n        \n        #INIT SECTION-------------------------------------------------------------------------\n        print \"> Skin \"+ self.GetProperty(\"SKIN_NAME\")\n        #load created panel/bay data already created on previous surfaces\n        self.__SetProperty(\"PANEL_DATA\", PanelTypes)\n        self.__SetProperty(\"BAY_DATA\", BayData)\n        \n        #Design functions class variables issue - fixed by replacing them with local variables\n        myPanelBays = self.__m_panelBays \n        randomObj = self.__m_objRandom \n        bayList = self.__m_bayList #bay indices used in skin [1 based]\n        \n        #intial loop settings\n        currBayPanel = None ; bayPanelIndex = -1  #Holds current panel in bay; Holds index of current panel in use \n        currentBay = self.__m_panelBays[0] ; self.__m_intCurrBayIndex = -1 # Stores current bay; Stores index of current bay \n        PanelDef = None #Stores current panel of the bay used\n        BlockName = \"\" #Holds block name based on panel data  \n         \n        intLevels = self.__m_intRows-1\n        self.__m_intCurrCellRow = 0 ; self.__m_intCurrCellColumn = -1          #init level and index counters \n        intBaysPerLevel = len(self.__m_arrBayMatrix[0])        \n        \n        #Change flags store specific panel modifications to ID'd when stored and loaded from database\n        ChangeFlag = [0, 0, dict()]     #[panel height , panel width , PropertyDictionary]\n        \n        blnFloorPanelHeight = False #change panel height to match floor to floor height\n        \n        #-----------------------Iteration through skin Bay grid---------------------------------------------------------\n        #-----------------------BAY & PANEL selection, design and generation--------------------------------------------\n        while True :\n            \n            bayPanelIndex += 1 # next panel of current bay\n            \n            if bayPanelIndex == len(currentBay) or bayPanelIndex == 0: #when done with current bay panels\n                bayPanelIndex = 0; self.__m_intCurrBayIndex += 1 #move on to next panel bay\n                if self.__m_intCurrBayIndex == len(self.__m_panelBays) : self.__m_intCurrBayIndex = 0  #and loop when done with all bays\n                \n                #------------BAY SECTION---------------------------------------------------\n                self.__m_intCurrCellColumn +=  1 # move to next cell on row\n                \n                #--------Level End detection and action\n                if self.__m_intCurrCellColumn == intBaysPerLevel-1 :\n                    self.__m_intCurrCellColumn = 0 ; self.__m_intCurrCellRow += 1 ; #start next row up\n                    intBaysPerLevel = len(self.__m_arrBayMatrix[self.__m_intCurrCellRow])\n                    if self.__m_resetBayAtPoints : bayPanelIndex = 0; currentBay = self.__m_panelBays[0]; self.__m_intCurrBayIndex=-1 #reset bay at beginng of row\n                    if self.__m_intCurrCellRow > intLevels : break        #exit at end of grid\n                    \n                #---------Run BAY-TYPE Design Functions (run when a new bay is started)\n                \n                #store current bay corner points (needed by some functions)\n                bayCornerPoints = [self.__m_arrBayMatrix[self.__m_intCurrCellRow][self.__m_intCurrCellColumn], self.__m_arrBayMatrix[self.__m_intCurrCellRow][self.__m_intCurrCellColumn + 1],\\\n                        self.__m_arrBayMatrix[self.__m_intCurrCellRow + 1][self.__m_intCurrCellColumn], self.__m_arrBayMatrix[self.__m_intCurrCellRow + 1][self.__m_intCurrCellColumn + 1]]    \n                #Run default function on bay first.        \n                currentBay, self.__m_intCurrBayIndex = self.DesFunc_Default_Panel_Bays(self.__m_panelBays, bayList)\n                \n                #Run all bay-type Design Functions available\n                if self.__m_DesignFunctions: \n                    for dsFunc in self.__m_DesignFunctions:\n                        if dsFunc and dsFunc.IsLayoutType() : currentBay, self.__m_intCurrBayIndex = dsFunc.Run(myPanelBays, currentBay, self)\n                \n                #----------Update Bay data\n                BayDataCounter = self.__m_BayData['BayCounter']\n                BayDataCounter[BayDataCounter.index(currentBay)+len(self.__m_panelBays)] += 1 #update bay type counters\n                self.__m_BayData['BayIndices'].append([self.__m_panelBays.index(currentBay), bayCornerPoints])\n                \n                panelMatrix = self.GetPanelMatrix(self.__m_arrBayMatrix, self.__m_intCurrCellRow, self.__m_intCurrCellColumn, currentBay) #get array of corner points of all panels in bay\n                \n            \n            #---------------PANEL SECTION------------------------------------------------------------------------------------------------\n            PanelDef = None     #reset variable (needed by panel-type function calls)\n            currBayPanel = currentBay[bayPanelIndex] \n            if bayPanelIndex > len(panelMatrix[0])-2  : continue #skip rest of bay if not finished at end of row\n            \n            #store panel corner points in skin\n            arrAreaPanelPoints = self.GetPanelCorners(panelMatrix, bayPanelIndex)\n            \n            #----------------Panel Profile: Flagging Size data\n            ChangeFlag = [0, 0, dict(), \"\"]     #[panel height , panel width , Property_Dictionary, skin_placement (string)]\n            \n            #ChangeFlag[0]stores panel height number (in unit/1000), used to store and retrieve panels in database \n            panelHeight = rs.Distance(arrAreaPanelPoints[0], arrAreaPanelPoints[2])\n            # panel height limited to current panel height, regardless of floor to floor value\n            if not blnFloorPanelHeight and panelHeight >= currBayPanel.GetHeight() - sc.doc.ModelAbsoluteTolerance : panelHeight = currBayPanel.GetHeight() \n            ChangeFlag[0] = int(round(panelHeight,3)*1000)\n            \n            #ChangeFlag[1] stores panel width number (in unit/1000 ), used to store and retrieve panels in database \n            panelWidth = rs.Distance(arrAreaPanelPoints[0],arrAreaPanelPoints[1])\n            ChangeFlag[1] = int(round(panelWidth,3)*1000)\n            \n            #Check first if panel size is large enough\n            if panelHeight < self.__m_dblMinPanelHeight or panelWidth < self.__m_dblMinPanelWidth :\n                print \">>>  Panel [Floor:\"+str(self.__m_intCurrCellRow)+\" Bay:\"+str(self.__m_intCurrCellColumn)+\" Panel:\"+str(bayPanelIndex)+\\\n                    \"] under minimum size (\"+str(round(panelWidth,4))+\",\"+str(round(panelHeight,4))+\") Discarded\"\n                continue\n                \n                \n            #--------------Panel Profile:Flagging placement data in ChangeFlag[3] \n            strSkinPlacement = 'Field'\n            placementList = ['Left', 'Right']\n            for side in [0,1]: #corner detection    \n                indexPoint = rs.PointArrayClosestPoint(self.__m_arrCornerPoints, arrAreaPanelPoints[side])\n                cornerPoint = copy.deepcopy(self.__m_arrCornerPoints[indexPoint])\n                cornerPoint[2] = arrAreaPanelPoints[side][2]\n                if rs.PointCompare(cornerPoint, arrAreaPanelPoints[side], self.__m_dblMinPanelWidth + sc.doc.ModelAbsoluteTolerance) :\n                    if strSkinPlacement == 'Field': strSkinPlacement = placementList[side]\n                    elif strSkinPlacement == 'Left': strSkinPlacement += placementList[side]\n            #tagging placement\n            ChangeFlag[3] = strSkinPlacement\n            \n            #---------Run PANEL DESIGN FUNCTION First call / Flagging Changes in ChangeFlag[2] - run in every panel.\n            if self.__m_DesignFunctions: #Run all Panel Design Functions available\n                for dsFunc in self.__m_DesignFunctions:\n                    if dsFunc and dsFunc.IsPanelType() : dsFunc.Run_Flag(self, ChangeFlag, currBayPanel)\n                    \n                     \n            \n            #---------Search Panel Type and Profile in Panel Database\n            #Checks for same panel type with same changeFlags.\n            #Database format: Dictionary = {BasePanelType_Name_A:[[PanelType Object 1, ChangeFlag],[PanelType Object 2, ChangeFlag],.....],\n            #                               BasePanelType_Name_B:[[PanelType Object 1, ChangeFlag],.....], BasePanelType_Name_C:....}\n            \n            \n            if currBayPanel.GetName() in self.__m_PanelData : #found panel type?\n                for pIndex in range(len(self.__m_PanelData[currBayPanel.GetName()])):\n                    if self.__m_PanelData[currBayPanel.GetName()][pIndex][1] == ChangeFlag : #found same profile?\n                        PanelDef = self.__m_PanelData[currBayPanel.GetName()][pIndex][0] #retrieve panel object stored\n                        if  len(PanelDef.GetPanelProperty(\"BlockInstances\")) == 0 : BlockName = \"\"; break #panels with empty blocks (ex.Ladybug) are skipped\n                        BlockName = rs.BlockInstanceName(PanelDef.GetPanelProperty(\"BlockInstances\")[0])\n                        break\n                \n            else: self.__m_PanelData[currBayPanel.GetName()] = [] \n            #----------------------------------------------------------------------------------------------------\n            #NEW PANEL TYPE: A new panel type is generated if no match found in database\n            if PanelDef == None :\n                \n                #-----Create panel copy if unique ----------------------------\n                #PanelTypeCount += 1\n                PanelDef = SGLibPanel()\n                PanelDef.Copy(currBayPanel)\n                \n                #PANEL DESIGN FUNCTION SECTION - Second Call / Apply custom properties based on ChangeFlag[2] data\n                tmpChangeFlag = copy.deepcopy(ChangeFlag) #create a copy (protect from Design Functions modif.) \n                if self.__m_DesignFunctions: #Run all Panel Design Functions available\n                    for dsFunc in self.__m_DesignFunctions:\n                        if dsFunc and dsFunc.IsPanelType() : dsFunc.Run_Modify(tmpChangeFlag, PanelDef)\n                        \n                        \n                #ChangeFlag = tmpChangeFlag #restore change flag data\n                \n                #CUSTOM PANEL SIZE SECTION (automated edge conditions)\n                #-----Name tag panel (used by Panel Inventory component) \n\n                PanelDef.SetName(PanelDef.GetName() + \" \"+strSkinPlacement)\n                if round(panelHeight,3) <> round(PanelDef.GetPanelProperty(\"PanelHeight\"),3) : \n                    PanelDef.SetName(PanelDef.GetName() + \" -Height:\"+str(round(panelHeight,2)))\n                if round(panelWidth,3) <> round(PanelDef.GetPanelProperty(\"PanelWidth\"),3) : \n                    PanelDef.SetName(PanelDef.GetName() + \" -Width:\"+str(round(panelWidth,2)))\n                #-----Resize panel ----\n                PanelDef.SetHeight(panelHeight)\n                PanelDef.SetWidth(panelWidth)\n                #----Skin Context Paramters----\n                PanelDef.SetPanelProperty(\"SkinPlacement\", strSkinPlacement)\n                \n                \n                #CONDITIONAL DEFINITIONS SECTION\n                #----Run Conditional definitions on Panel (from panel component input)\n                PanelDef.RunConditionalDefinition()\n                \n                \n                #Draw panel geometry to create block\n                PanelDef.Draw() \n                \n                #Add new panel type to Database\n                CurrBayList = self.__m_PanelData.get(currBayPanel.GetName())\n                CurrBayList.append([PanelDef, copy.deepcopy(ChangeFlag)])\n                self.__m_PanelData[currBayPanel.GetName()] = CurrBayList\n                \n                #-----Generate new Panel Block params --------------------------------------------------\n                \n                BlockName = \"_P_ID-\" + self.__m_skinGenName + \"_\" + str(ChangeFlag) + currBayPanel.GetName()\n                \n            #-----Create Block instance with current panel design\n            if not self.__m_GeneratePanelsOnly:\n                PanelDef.CreateBlockCopy(BlockName, arrAreaPanelPoints, False)\n            \n            PanelIndeces = self.__m_BayData ['PanelIndices']\n            PanelIndeces.append([arrAreaPanelPoints, PanelDef.GetName()])\n            \n        #cRow = 1;cCol = 3; cPanel =0 \n        #bayBasePanels = self.GetCellProperty(cRow,cCol,\"BAY_BASE_PANELS\") ; bayPoints = self.GetCellProperty(cRow,cCol,\"BAY_POINTS_PANELS\")\n        #for i,p in enumerate(bayBasePanels): print [\"bay panels & points\", p.GetName()]\n        \n        #print list((p for pts in bayPoints for p in pts ))\n        #for index in range(self.GetCellProperty(cRow,cCol,\"BAY_NUM_PANELS\")): \n            #print [\"panel instance & chngflag\", self.GetCellProperty(cRow,cCol,\"PANEL_INSTANCE\",index).GetName(), self.GetCellProperty(cRow,cCol,\"PANEL_CHANGE_FLAG\",index)]\n        #print self.__m_BayData['BayIndices']\n        return self.__m_PanelData, self.__m_BayData\n    \n    \n    #--------------------------------------------------------------------------------\n    #Retrieve corner points of each panel in cell (bays have 1+ panels)\n    #--------------------------------------------------------------------------------\n    def GetPanelMatrix(self, bayMatrix, intLevel, intBayID, currentBay):\n        \n        arrAreaBayPoints = [bayMatrix[intLevel][intBayID], bayMatrix[intLevel][intBayID + 1],\\\n            bayMatrix[intLevel + 1][intBayID], bayMatrix[intLevel + 1][intBayID + 1]]\n        panelMatrix = []\n        bayLength = 0\n        for panel in currentBay :\n            bayLength += panel.GetPanelProperty(\"PanelWidth\")        \n            \n        linesBay = [0,0]\n        for pairIndex in [0,1]:\n            linesBay[pairIndex]= rs.AddLine(arrAreaBayPoints[pairIndex*2], arrAreaBayPoints[pairIndex*2+1])\n            lengthLine = rs.CurveLength(linesBay[pairIndex])\n            coefLength = 1\n            lengthTotals = 0\n            for panel in currentBay :\n                \n                if intBayID == len(bayMatrix[intLevel])-2:\n                    prevCoefLength = 1\n                    if intBayID > 0 :\n                        prevCoefLength = rs.Distance(bayMatrix[intLevel][intBayID-1], bayMatrix[intLevel][intBayID])/bayLength\n                    if (bayLength-lengthTotals)< panel.GetPanelProperty(\"PanelWidth\")*prevCoefLength:\n                        coefLength = lengthLine/bayLength\n                lengthTotals += panel.GetPanelProperty(\"PanelWidth\")*coefLength\n                if lengthTotals < lengthLine : rs.InsertCurveKnot(linesBay[pairIndex], lengthTotals)\n                \n            panelMatrix.append(rs.CurveEditPoints(linesBay[pairIndex]))\n            rs.DeleteObject(linesBay[pairIndex])\n        \n        return panelMatrix\n        \n        \n        \n    \n    #--------------------------------------------------------------------------------\n    #Retrieve 4 cornes on grid array of skin\n    #--------------------------------------------------------------------------------\n    def GetPanelCorners(self, arrPanelMatrix, bayPanelIndex):\n    \n        return [arrPanelMatrix[0][bayPanelIndex], arrPanelMatrix[0][bayPanelIndex + 1],\\\n            arrPanelMatrix[1][bayPanelIndex], arrPanelMatrix[1][bayPanelIndex + 1]]\n    \n    \n    \n    #--------------------------------------------------------------------------------------------------\n    # DESIGN FUNCTIONS SECTION\n    #--------------------------------------------------------------------------------------------------\n    def DesFunc_Default_Panel_Bays(self, PanelBay_List, defaultBayList=None):\n\n        validBayList = copy.deepcopy(defaultBayList)\n        \n        # Define new current bay index based on the exclude bays listed \n        if  validBayList:   \n            for index in range(len(validBayList)) : validBayList[index] -=1 #cero based indexes\n        else: validBayList = range(len(PanelBay_List))\n        \n        while True:\n            if  self.__m_intCurrBayIndex in validBayList : break\n            self.__m_intCurrBayIndex +=1\n            if self.__m_intCurrBayIndex == len(PanelBay_List) : self.__m_intCurrBayIndex = min(validBayList)\n                \n        if self.__m_intCurrBayIndex >= len(PanelBay_List) : \n            self.__m_warningData.append(\"DesFunc_Default_Panel_Bays: Invalid bay index, using bay 1\")\n            return [PanelBay_List[0], 0]\n        return  [PanelBay_List[self.__m_intCurrBayIndex], self.__m_intCurrBayIndex]\n        \n\n# Design Function  Class\n# Base class used for all DesignFunctions\n\nclass BaseDesignFunction:\n    \n    \n    #CONSTRUCTOR -------------------------------------------------------------------------------------------\n    def __init__(self):\n        pass\n      \n    def IsLayoutType(self):\n        pass\n        \n    def IsPanelType(self):\n        pass  \n    \n    def Reset(self):\n        pass\n        \n    #Layout Design Function\n    def Run(self, PanelBay_List, currentBay, skinInstance):\n        pass\n        \n    #Panel Design Function\n    def Run_Flag(self, skinInstance, ChangeFlag, BasePanel):\n        pass\n        \n    #Panel Deisgn Function\n    def Run_Modify(self, ChangeFlag, BasePanel):\n        pass\n        \n\nsc.sticky[\"SGLib_Panel\"] = Panel\n\nsc.sticky[\"SGLib_Skin\"] = Skin\n\nsc.sticky[\"SGLib_DesignFunction\"] = BaseDesignFunction\n\n\nprint \"SkinDesigner Running...\"",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}