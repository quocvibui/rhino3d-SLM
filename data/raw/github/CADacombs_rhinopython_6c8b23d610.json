{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_radiusMinima.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_radiusMinima.py",
  "instruction": "190703-04: Created. \r\n190708: Refactored.\r\n190908: Added bAddDot and iDotHeight.\r\n...\r\n200121-28: Created a more accurate routine that finds parameters.\r\n        Added bIncludeArcs and function that...",
  "code": "\"\"\"\r\n190703-04: Created. \r\n190708: Refactored.\r\n190908: Added bAddDot and iDotHeight.\r\n...\r\n200121-28: Created a more accurate routine that finds parameters.\r\n        Added bIncludeArcs and function that finds and returns mid points of arc-shaped segments.\r\n200307: Changed a tolerance value from 1e-12 to 1e-9 for determining curvature in a linear section.\r\n200319: Stopped using ZeroTolerance in many places since that value is different in V7 than it is in V5 & V6.\r\n200420: Further improved parameters/points found by refining tolerances used.\r\n200803: Fixed variable name typo.\r\n210315: Now processes ArcCurves in PolyCurves.\r\n\r\nThe intention of the script is to provide minimum radius (maximum curvature) data\r\nwithin a practical (design for manufacturability) tolerance,\r\nnot to provide the most accurate results.\r\n\r\nTODO:\r\n    Test a routine with 1e-12 in V7.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nfrom Rhino import RhinoMath as rm # This style allows IntelliSense, etc. in VS editor.\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System.Collections.Generic import List\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'fMinRadToReport'; keys.append(key)\r\n    values[key] = 0.0\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fMaxRadToReport'; keys.append(key)\r\n    values[key] = 0.0\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fRadEqTol'; keys.append(key)\r\n    values[key] = 10.0*sc.doc.ModelAbsoluteTolerance\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bIncludeArcs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddPt'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotHeight'; keys.append(key)\r\n    values[key] = 11\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddOnlyMinimumPt'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = \"At\"\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='AllMinima', onValue='Minimum')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddOnlyMinimumPtOfAllCrvs'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = \"Of\"\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='EachCrv', onValue='AllCrvs')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get edges and options values.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve # Curve is also used for brep edges.\r\n\r\n    go.AcceptNumber(True, True)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    print \"0 for {} or {} will disable that limit.\".format(\r\n        Opts.names['fMinRadToReport'], Opts.names['fMaxRadToReport'])\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        key = 'fMinRadToReport'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'fMaxRadToReport'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'fRadEqTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bIncludeArcs'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bAddPt'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bAddDot'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'iDotHeight'; idxs_Opts[key] = (Opts.riAddOpts[key](go) if Opts.values['bAddDot']\r\n                                              else None)\r\n        key = 'bAddOnlyMinimumPt'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bAddOnlyMinimumPtOfAllCrvs'; idxs_Opts[key] = (Opts.riAddOpts[key](go)\r\n                                                              if Opts.values['bAddOnlyMinimumPt']\r\n                                                              else None)\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        else:\r\n            # An option was selected or a number was entered.\r\n            key = 'fMinRadToReport'\r\n            if res == ri.GetResult.Number:\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n            if Opts.riOpts[key].CurrentValue < 0.0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            \r\n            key = 'fMaxRadToReport'\r\n            if Opts.riOpts[key].CurrentValue < 0.0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            \r\n            key = 'fRadEqTol'\r\n            if Opts.riOpts[key].CurrentValue < 2.0**(-53):\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            \r\n            Opts.setValues()\r\n            Opts.saveSticky()\r\n            go.ClearCommandOptions()\r\n\r\n\r\ndef tryGetArcDataFromWholeCrv(crv, tolerance=None):\r\n\r\n    if tolerance is None:\r\n        tolerance = 0.001 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    if isinstance(crv, rg.ArcCurve):\r\n        arc = crv.Arc\r\n        ts = crv.DivideByCount(segmentCount=2, includeEnds=False)\r\n        return crv.PointAt(ts[0]), arc.Radius\r\n\r\n    bSuccess, arc = crv.TryGetArc(tolerance=tolerance)\r\n    if bSuccess:\r\n        #sc.doc.Objects.AddArc(arc); sc.doc.Views.Redraw(); 1/0\r\n        ts = crv.DivideByCount(segmentCount=2, includeEnds=False)\r\n        return crv.PointAt(ts[0]), arc.Radius\r\n    else:\r\n        pass\r\n        #sc.doc.Objects.AddCurve(crv)\r\n        #sc.doc.Views.Redraw()\r\n\r\n\r\ndef getMinimumRadiiData_ArcSegments(rgCrv0, bDebug=False):\r\n    \"\"\"\r\n    Returns:\r\n        On success: list(Point3ds of midpoint of arc intervals), list(floats of arc radii)\r\n        On fail: None\r\n    \"\"\"\r\n\r\n\r\n    if not isinstance(rgCrv0, rg.Curve):\r\n        raise ValueError(\"{} not an accepted input for getArcData.\".format(rgCrv0.GetType().Name))\r\n\r\n    sType = rgCrv0.GetType().Name\r\n\r\n    if sType == 'BrepEdge':\r\n        crvTemp = rgCrv0.EdgeCurve\r\n        sType = crvTemp.GetType().Name\r\n    else:\r\n        crvTemp = rgCrv0.DuplicateCurve()\r\n\r\n    if sType in ('LineCurve', 'PolylineCurve'):\r\n        crvTemp.Dispose()\r\n        return\r\n\r\n    if crvTemp.IsLinear(1.0 / 2.0**32):\r\n        crvTemp.Dispose()\r\n        return\r\n\r\n\r\n    def tryGetArcDataFromNurbsSpans(nc):\r\n        pOut = []\r\n        rOut = []\r\n        for iSpan in range(nc.SpanCount):\r\n            seg = nc.Trim(domain=nc.SpanDomain(iSpan))\r\n            rc = tryGetArcDataFromWholeCrv(seg)\r\n            if rc:\r\n                pOut.append(rc[0])\r\n                rOut.append(rc[1])\r\n            seg.Dispose()\r\n        return pOut, rOut\r\n\r\n\r\n\r\n    rc = tryGetArcDataFromWholeCrv(crvTemp)\r\n    if rc:\r\n        crvTemp.Dispose()\r\n        return [rc[0]], [rc[1]]\r\n\r\n\r\n    pts_Out = []\r\n    radii_Out = []\r\n\r\n    if sType == 'NurbsCurve':\r\n        rc = tryGetArcDataFromNurbsSpans(crvTemp)\r\n        if rc[0]:\r\n            pts_Out.extend(rc[0])\r\n            radii_Out.extend(rc[1])\r\n    else:\r\n        #'PolyCurve'\r\n        crvTemp.RemoveNesting()\r\n        for seg in crvTemp.DuplicateSegments():\r\n            rc = tryGetArcDataFromWholeCrv(seg)\r\n            if rc:\r\n                pts_Out.append(rc[0])\r\n                radii_Out.append(rc[1])\r\n            elif isinstance(seg, rg.NurbsCurve):\r\n                rc = tryGetArcDataFromNurbsSpans(seg)\r\n                if rc[0]:\r\n                    pts_Out.extend(rc[0])\r\n                    radii_Out.extend(rc[1])\r\n            seg.Dispose()\r\n\r\n    crvTemp.Dispose()\r\n\r\n    return pts_Out, radii_Out\r\n\r\n\r\ndef getMinimumRadiiData_NurbsCrv(rgCrv0, bDebug=False):\r\n    \"\"\"\r\n    Analyzes 6 divisions between each Greville parameter.\r\n\r\n    Returns:\r\n        On success: list(float(ts_Maxima)), list(float(radii))\r\n        On fail: None, str(Feedback)\r\n    \"\"\"\r\n\r\n\r\n    def isAcceptableNurbsCurve(rgCrv0):\r\n        sType = rgCrv0.GetType().Name\r\n        if sType in (\"ArcCurve\", \"LineCurve\", \"PolylineCurve\"): return False\r\n        if rgCrv0.IsArc(1.0 / 2.0**32): return False\r\n        if rgCrv0.IsLinear(1.0 / 2.0**32): return False\r\n        return True\r\n    if not isAcceptableNurbsCurve(rgCrv0): return\r\n\r\n\r\n    def f2s(f):\r\n        return \"{:.17e}\".format(f)\r\n\r\n\r\n    cross = rg.Vector3d.CrossProduct\r\n\r\n\r\n    def curvatureAt(t, bRightSide):\r\n        side = (\r\n            rg.CurveEvaluationSide.Above if bRightSide\r\n            else rg.CurveEvaluationSide.Below)\r\n        ds = nc.DerivativeAt(t, derivativeCount=2, side=side)\r\n        return cross(cross(ds[1], ds[2]), ds[1]) / ds[1].Length**4.0\r\n\r\n\r\n    # rm.ZeroTolerance ==\r\n    #   V5 & V6: 1e-12\r\n    #   V7: 2.3283064365386962890625e-10 (1.0 / 2.0**32)\r\n    eps_ON = 1.0 / 2.0**32 # OpenNURBS ZeroTolerance.\r\n    eps_param = 1e-9\r\n\r\n    # Machine epsilon per C, C++, and Python ( https://en.wikipedia.org/wiki/Machine_epsilon )\r\n    eps_Mach = 2.0**(-52) #2.2204460492503130808472633361816e-16\r\n\r\n    # eps_toUse was determined through trial and error.\r\n    # Based on results of future executions of this script,\r\n    # it may be determined that this value will need to be increased.\r\n    eps_toUse = 2.0**(-42) # 2.27373675443232059478759765625e-13\r\n\r\n\r\n    def areEpsilonEqual(a, b, epsilon):\r\n        if abs(a) <= epsilon and abs(b) <= epsilon: return True\r\n        delta = abs(a-b)\r\n        #if 0.55147058823529 < a < 0.551470588235295:\r\n        #    print f2s(delta)\r\n        if delta <= epsilon: return True\r\n        # A relative comparison is used for other values.\r\n        fRelComp = delta/max(abs(a), abs(b))\r\n        #print f2s(fRelComp)\r\n        return fRelComp <= epsilon\r\n\r\n\r\n    def findParameter(tL_Start, tR_Start):\r\n\r\n        tL = tL_Start\r\n        tM = None # For debugging.\r\n        tR = tR_Start\r\n        \r\n        tM = 0.5*tL + 0.5*tR\r\n\r\n        j_forDebug = 18\r\n\r\n        j = 0\r\n\r\n        while True:\r\n            if sc.escape_test(False):\r\n                print \"Break at iT of {} and j of {}.\".format(iT, j)\r\n                sEval = 'tL_Start'; print sEval+':',f2s(eval(sEval))\r\n                sEval = 'tL'; print sEval+':',f2s(eval(sEval))\r\n                sEval = 'tR'; print sEval+':',f2s(eval(sEval))\r\n                sEval = 'tR_Start'; print sEval+':',f2s(eval(sEval))\r\n                return\r\n\r\n            if tR > 0.5294:\r\n                pass\r\n\r\n            if iT == iT_forDebug and j == j_forDebug:\r\n                pass\r\n\r\n            Kl = curvatureAt(tL, True)\r\n            if not Kl.IsValid:\r\n                print \"Curvature vector of left test point is invalid,\" \\\r\n                    \" so no results will be returned.\"\r\n                return\r\n\r\n            Km = curvatureAt(tM, False) # False or True shouldn't make a difference.\r\n            if not Km.IsValid:\r\n                print \"Curvature vector of left test point is invalid,\" \\\r\n                    \" so no results will be returned.\"\r\n                return\r\n\r\n            Kr = curvatureAt(tR, False)\r\n            if not Kr.IsValid:\r\n                print \"Curvature vector of right test point is invalid,\" \\\r\n                    \" so no results will be returned.\"\r\n                return\r\n\r\n            kL = Kl.Length\r\n            kM = Km.Length\r\n            kR = Kr.Length\r\n\r\n            rad_kL = 1.0/(kL) if kL > eps_param else None\r\n            rad_kM = 1.0/(kM) if kM > eps_param else None\r\n            rad_kR = 1.0/(kR) if kR > eps_param else None\r\n\r\n            if rad_kL is None and rad_kR is None:\r\n                raise ValueError(\"Both rad_kL and rad_kR are None!\")\r\n\r\n            if rad_kL is None or rad_kR is None:\r\n                #sEval = 'tL_Start'; print sEval+':',eval(sEval)\r\n                #sc.doc.Objects.AddPoint(nc.PointAt(tL_Start))\r\n                #sEval = 'tR_Start'; print sEval+':',eval(sEval)\r\n                #sc.doc.Objects.AddPoint(nc.PointAt(tR_Start))\r\n                if rad_kL is None:\r\n                    #sEval = 'tL'; print sEval+':',eval(sEval)\r\n                    #sc.doc.Objects.AddPoint(nc.PointAt(tL))\r\n                    tL = 0.75*tL + 0.25*tR\r\n                elif rad_kR is None:\r\n                    #sEval = 'tR'; print sEval+':',eval(sEval)\r\n                    #sc.doc.Objects.AddPoint(nc.PointAt(tR))\r\n                    tR = 0.25*tL + 0.75*tR\r\n                #sc.doc.Views.Redraw()\r\n                continue\r\n\r\n            #if iT == iT_forDebug and j >= j_forDebug:\r\n                #print '='*20\r\n                #tX = 0.24137988639995100 # For debug.\r\n                #print \"{} {} {} {} {}\".format(f2s(tL), f2s(rad_kL)                          , f2s(kL), f2s(nc.CurvatureAt(tL).Length), f2s(nc.CurvatureAt(tL)*nc.CurvatureAt(tL)))\r\n                #print \"{} {} {} {} {}\".format(f2s(tX), f2s(1.0/curvatureAt(tX, False).Length), f2s(0.0), f2s(nc.CurvatureAt(tX).Length), f2s(nc.CurvatureAt(tX)*nc.CurvatureAt(tX)))\r\n                #print \"{} {} {} {} {}\".format(f2s(tR), f2s(rad_kR)                          , f2s(kR), f2s(nc.CurvatureAt(tR).Length), f2s(nc.CurvatureAt(tR)*nc.CurvatureAt(tR)))\r\n                #if tL > tX or tR < tX:\r\n                #    pass\r\n\r\n            # Example found where tL is showing to be larger than tR is where\r\n            # difference is about 3.79696274421804e-14 larger than kR.\r\n\r\n\r\n            if areEpsilonEqual(tR, tL, eps_toUse):\r\n                #if tL > 0.5294:\r\n                #    print f2s(tR)\r\n                #    print f2s(tL)\r\n                return tL, tR, kL, kR\r\n\r\n\r\n            # Not accurate enough for uniform (or with only internal monoknot?) curves.\r\n            #if abs(rad_kL - rad_kR) < (0.1 * sc.doc.ModelAbsoluteTolerance):\r\n            #    return tL, tR, kL, kR\r\n\r\n            #if areEpsilonEqual(rad_kL, rad_kR, eps_toUse):\r\n            #    return tL, tR, kL, kR\r\n\r\n\r\n            if areEpsilonEqual(Kl*Kl, Kr*Kr, eps_toUse):\r\n                return tL, tR, kL, kR\r\n\r\n\r\n            # Example found where kL is showing to be larger than kR is where\r\n            # kL is about 2.63618080391892e-15 larger than kR.\r\n\r\n            if areEpsilonEqual(kL, kR, eps_toUse):\r\n                return tL, tR, kL, kR\r\n\r\n            if kL > kM > kR:\r\n                tR = tM\r\n            elif kR > kM > kL:\r\n                tL = tM\r\n            elif kM > kL > kR:\r\n                tR = tM\r\n            elif kM > kR > kL:\r\n                tL = tM\r\n            elif kL > kR and kM == kR:\r\n                tR = tM\r\n            elif kR > kL and kM == kL:\r\n                tL = tM\r\n            else:\r\n                # Possibly approaching a curvature minimum / radius maximum.\r\n                return tL, tR, kL, kR\r\n                print '='*20\r\n                print \"Fine results of curvature, etc., cannot be trusted.\"\r\n                print \"tL:{} kL:{}\".format(f2s(tL), f2s(kL))\r\n                print \"{} {}\".format(f2s(tM), f2s(kM))\r\n                print \"tR:{} kR{}\".format(f2s(tR), f2s(kR))\r\n                print \"delta t:{}\".format(f2s(tR-tL))\r\n                print \"delta k:{}\".format(f2s(abs(kR-kL)))\r\n                print \"delta rad:{}\".format(f2s(abs(rad_kR-rad_kL)))\r\n                if kR > kL:\r\n                    return tR, tR, kR, kR\r\n                else:\r\n                    return tL, tL, kL, kL\r\n\r\n            tM = 0.5*tL + 0.5*tR\r\n\r\n            # For debug.\r\n            if tL > 0.241379886:\r\n                pass\r\n\r\n            j += 1\r\n\r\n\r\n    nc = rgCrv0.ToNurbsCurve()\r\n    domain_notNormal = nc.Domain\r\n\r\n    # Work with parameters in domain [0.0, 1.0]\r\n    # to avoid certain floating point accuracy errors.\r\n    nc.Domain = rg.Interval(0.0,1.0)\r\n\r\n\r\n    def getParametersToCheck(nc):\r\n        if nc.IsPeriodic:\r\n            ts_Grev = [t for t in nc.GrevilleParameters() if 0.0 <= t <= 1.0]\r\n        else:\r\n            ts_Grev = nc.GrevilleParameters()\r\n    \r\n    \r\n        # Determine fractional divisions between Grevilles.\r\n        total_divs_btwGrevs = 6\r\n        precision_of_divs = 0.125 # Use an exact floating point value, e.g. 0.125, not 0.1.\r\n        divs_btwGrevs = []\r\n        for i in range(1, total_divs_btwGrevs):\r\n            divs_btwGrevs.append(\r\n                round(\r\n                ((1.0 / precision_of_divs) * float(i) / float(total_divs_btwGrevs)), 0) *\r\n                precision_of_divs)\r\n    \r\n    \r\n        ts_toUse = []\r\n        for iT in range(len(ts_Grev)-1):\r\n            ts_toUse.append(ts_Grev[iT])\r\n            for div in divs_btwGrevs:\r\n                ts_toAdd = (1.0-div)*ts_Grev[iT] + div*ts_Grev[iT+1]\r\n                #sc.doc.Objects.AddPoint(rg.NurbsCurve.PointAt(nc, t=ts_toAdd))\r\n                ts_toUse.append(ts_toAdd)\r\n        ts_toUse.append(ts_Grev[-1])\r\n    \r\n    \r\n        # Add non-full polyknots parameters since radius can be different on each side.\r\n        ts_NonFullPolyKnot = []\r\n        iKnot = 0\r\n        t = 0.0\r\n        while t < 1.0:\r\n            t = nc.Knots[iKnot]\r\n            if t < 0.0: continue\r\n            multi = nc.Knots.KnotMultiplicity(iKnot)\r\n            if 1 < multi < nc.Degree:\r\n                ts_NonFullPolyKnot.append(t)\r\n            iKnot += multi\r\n        ts_toUse += ts_NonFullPolyKnot\r\n        ts_toUse = sorted(ts_toUse)\r\n    \r\n        return ts_toUse\r\n\r\n\r\n    ts_toUse = getParametersToCheck(nc)\r\n\r\n    #for t in ts_toUse:\r\n        #sc.doc.Objects.AddPoint(rgCrv0.PointAt(domain_notNormal.ParameterAt(t)))\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n\r\n    ts_Pass_Norm = []\r\n    radii_Out = []\r\n    \r\n    bLastFoundWasOnRight = False\r\n    bFoundAtStartOfPeriodic = False\r\n    \r\n    # Furthest left parameter is not continuous at T0\r\n    # and at a non-continuous break.\r\n    bOkToAddOnLeft = True\r\n\r\n    iT_forDebug = 4\r\n\r\n    for iT in range(len(ts_toUse)-1):\r\n        \r\n        # For bDebug:\r\n        if iT == iT_forDebug:\r\n            pass\r\n        \r\n        #print \"{}:\".format(iT),\r\n        tL_Start = ts_toUse[iT]\r\n        tL = tL_Start\r\n        tR = None # This is here for its placement in debugging variable list.\r\n        tR_Start = ts_toUse[iT+1]\r\n        tR = tR_Start\r\n\r\n        if tL_Start > 0.2413:\r\n            pass\r\n\r\n        Kl = curvatureAt(tL, True)\r\n        if not Kl.IsValid:\r\n            print \"Curvature vector of left test point is invalid,\" \\\r\n                \" so no results will be returned.\"\r\n            return\r\n        \r\n        Kr = curvatureAt(tR, False)\r\n        if not Kr.IsValid:\r\n            print \"Curvature vector of right test point is invalid,\" \\\r\n                \" so no results will be returned.\"\r\n            return\r\n        \r\n        kL_Start = None\r\n        kL = Kl.Length\r\n        kR = Kr.Length\r\n\r\n        kL_Start = kL\r\n        kR_Start = kR\r\n        kL_Start_NextCrv = None\r\n        \r\n        # Test for linear interval.\r\n        if abs(kL_Start) < eps_param or abs(kR_Start) < eps_param:\r\n            bOkToAddOnLeft = True\r\n            continue\r\n\r\n        fRadL_Start = 1.0/kL_Start\r\n        fRadR_Start = 1.0/kR_Start\r\n\r\n        # Testing for circular arc interval.\r\n        if areEpsilonEqual(fRadL_Start, fRadR_Start, 0.001*sc.doc.ModelAbsoluteTolerance):\r\n            bOkToAddOnLeft = True\r\n            continue\r\n\r\n        kL_Start_NextCrv = curvatureAt(tR_Start, True).Length\r\n        \r\n        #sEval = 'kL_Start_NextCrv'; print sEval+':',eval(sEval)\r\n        \r\n        if kL_Start_NextCrv < eps_toUse:\r\n            # Start of linear interval.\r\n            # Greatest curvature is already kL_Start.\r\n            pass\r\n        else:\r\n            # For bDebug:\r\n            if iT == iT_forDebug:\r\n                pass\r\n\r\n            fRadL_Start_NextCrv = 1.0 / kL_Start_NextCrv # This variable is used for viewing in the debugger.\r\n\r\n            rc = findParameter(tL_Start, tR_Start)\r\n            if not rc: return\r\n\r\n            tL, tR, kL, kR = rc\r\n\r\n\r\n        #print abs(tL-tL_Start)\r\n        #print abs(tL-tL_Start)/max(abs(tL),abs(tL_Start))\r\n\r\n\r\n        #if tL_Start > 0.5294:\r\n        #    print f2s(tL)\r\n        #    print f2s(tL_Start)\r\n        #    pass\r\n\r\n        # For bDebug:\r\n        if iT == iT_forDebug:\r\n            pass\r\n\r\n        if areEpsilonEqual(tL, tL_Start, eps_ON):\r\n            #print f2s(abs(tL - tL_Start))\r\n            if bOkToAddOnLeft:\r\n                if bDebug: print \"{}: Left start\".format(iT)\r\n                ts_Pass_Norm.append(tL_Start)\r\n                rad = 1.0/kL_Start\r\n                radii_Out.append(rad)\r\n            bLastFoundWasOnRight = False\r\n            \r\n            if iT == 0 and nc.IsPeriodic:\r\n                bFoundAtStartOfPeriodic = True\r\n            elif bFoundAtStartOfPeriodic and iT == len(ts_toUse)-2:\r\n                ts_Pass_Norm = ts_Pass_Norm[1:]\r\n                radii_Out = radii_Out[1:]\r\n                print \"T0 removed from passing parameters\" \\\r\n                    \" since a smaller radius was found\" \\\r\n                    \" in the last division of the curve.\"\r\n        elif areEpsilonEqual(tR, tR_Start, eps_ON):\r\n            #print f2s(abs(tR - tR_Start))\r\n            if iT == len(ts_toUse)-2:\r\n                if nc.IsPeriodic:\r\n                    print \"Passing parameter already found\" \\\r\n                        \" at beginning of periodic domain\" \\\r\n                        \" and will not be added to other parameters.\"\r\n                elif nc.IsClosed and areEpsilonEqual(1.0/kR_Start, radii_Out[0], eps_toUse):\r\n                    print \"Passing parameter already found\" \\\r\n                        \" at beginning of closed domain\" \\\r\n                        \" at the same radius minima\" \\\r\n                        \" and will not be added to other parameters.\"\r\n                else:\r\n                    if bDebug: print \"{}: Right start at end of entire curve.\".format(iT)\r\n                    ts_Pass_Norm.append(tR_Start)\r\n                    rad = 1.0/kR_Start\r\n                    radii_Out.append(rad)\r\n            else:\r\n                if not areEpsilonEqual(kR_Start, kL_Start_NextCrv, eps_toUse):\r\n                    if bDebug:\r\n                        print \"{}: Right start at kink.\".format(iT)\r\n                        #print f2s(kR_Start)\r\n                        #print f2s(kL_Start_NextCrv)\r\n                        #print '*'*4\r\n                        #print f2s(abs(kR_Start - kL_Start_NextCrv))\r\n                        #print '*'*4\r\n                    ts_Pass_Norm.append(tR_Start)\r\n                    rad = 1.0/kR_Start\r\n                    radii_Out.append(rad)\r\n            bLastFoundWasOnRight = True\r\n        else:\r\n            if bDebug: print \"{}: Not at a starting left or right parameter.\".format(iT)\r\n            if abs(tL-tR) <= eps_toUse:\r\n                ts_Pass_Norm.append(tR)\r\n                rad = 1.0/kR\r\n                radii_Out.append(rad)\r\n            elif eps_toUse < abs(tL-tR) < eps_ON:\r\n                print \"eps_toUse < abs(tL-tR) < eps_ON\"\r\n                ts_Pass_Norm.append(0.5*tL + 0.5*tR)\r\n                rad = 1.0/(0.5*kL + 0.5*kR)\r\n                radii_Out.append(rad)\r\n            else:\r\n                length = nc.GetLength(subdomain=rg.Interval(tL, tR))\r\n                if bDebug:\r\n                    s  = \"Normalized parameter space between L and R: {}\".format(\r\n                        f2s(abs(tL-tR)))\r\n                    s += \"  Length: {}\".format(f2s(length))\r\n                    print s\r\n                if length >= sc.doc.ModelAbsoluteTolerance:\r\n                    pass\r\n                    #sc.doc.Objects.AddPoint(nc.PointAt(tL))\r\n                    #sc.doc.Objects.AddPoint(nc.PointAt(tR))\r\n                    #sc.doc.Views.Redraw()\r\n                    \r\n                    #print \"Curve length between points having same curvature is {}.\".format(length)\r\n                ts_Pass_Norm.append(0.5*tL + 0.5*tR)\r\n                rad = 1.0/(0.5*kL + 0.5*kR)\r\n                radii_Out.append(rad)\r\n            bLastFoundWasOnRight = False\r\n\r\n            if bFoundAtStartOfPeriodic and iT == len(ts_toUse)-2:\r\n                ts_Pass_Norm = ts_Pass_Norm[1:]\r\n                radii_Out = radii_Out[1:]\r\n                print \"T0 removed from passing parameters\" \\\r\n                    \" since a smaller radius was found\" \\\r\n                    \" in the last division of the curve.\"\r\n\r\n        bOkToAddOnLeft = (\r\n            bLastFoundWasOnRight or\r\n            not areEpsilonEqual(kR_Start, kL_Start_NextCrv, eps_toUse))\r\n\r\n    ts_Out = [domain_notNormal.ParameterAt(t) for t in ts_Pass_Norm]\r\n\r\n    nc.Dispose()\r\n\r\n    return ts_Out, radii_Out\r\n\r\n\r\ndef getMinimumRadiiPoints(curve, bIncludeArcs=True, bDebug=False):\r\n\r\n    rc = tryGetArcDataFromWholeCrv(curve)\r\n    if rc:\r\n        return [rc[0]], [rc[1]]\r\n\r\n    rcNurbs= getMinimumRadiiData_NurbsCrv(curve, bDebug)\r\n\r\n    rc_forArcs = getMinimumRadiiData_ArcSegments(curve, bDebug) if bIncludeArcs else None\r\n\r\n    if not ((rcNurbs and rcNurbs[0]) or (rc_forArcs and rc_forArcs[0])): return\r\n\r\n\r\n    pts_Out = []\r\n    radii_Out = []\r\n\r\n    if rcNurbs and rcNurbs[0]:\r\n        ts, radii_Out = rcNurbs\r\n        for t in ts:\r\n            pts_Out.append(curve.PointAt(t))\r\n\r\n    if rc_forArcs and rc_forArcs[0]:\r\n        pts_Out.extend(rc_forArcs[0])\r\n        radii_Out.extend(rc_forArcs[1])\r\n\r\n    return pts_Out, radii_Out\r\n\r\n\r\ndef getMinimumRadii(rgCrv0, bIncludeArcs=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    sType_rgCrv0 = rgCrv0.GetType().Name\r\n\r\n    if sType_rgCrv0 == \"ArcCurve\":\r\n        return [rgCrv0.Radius] if bIncludeArcs else None\r\n    elif sType_rgCrv0 == \"LineCurve\":\r\n        return [Rhino.RhinoMath.UnsetValue]\r\n    elif sType_rgCrv0 == \"PolylineCurve\":\r\n        return [Rhino.RhinoMath.UnsetValue]\r\n    \r\n    rc = getMinimumRadiiData_NurbsCrv(rgCrv0, bDebug)\r\n    if not rc or not rc[0]: return\r\n\r\n    ts, radii = rc\r\n\r\n    return radii\r\n\r\n\r\ndef getMinimumRadius(rgCrv0, bIncludeArcs=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rc = getMinimumRadii(rgCrv0, bDebug)\r\n\r\n    if rc is None: return\r\n\r\n    return min(rc)\r\n\r\n\r\ndef getFormattedDistance(fDistance):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef processCurves(curvesAndEdges0, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fMinRadToReport = getOpt('fMinRadToReport')\r\n    fMaxRadToReport = getOpt('fMaxRadToReport')\r\n    fRadEqTol = getOpt('fRadEqTol')\r\n    bIncludeArcs = getOpt('bIncludeArcs')\r\n    bAddPt = getOpt('bAddPt')\r\n    bAddDot = getOpt('bAddDot')\r\n    iDotHeight = getOpt('iDotHeight')\r\n    bAddOnlyMinimumPt = getOpt('bAddOnlyMinimumPt')\r\n    bAddOnlyMinimumPtOfAllCrvs = getOpt('bAddOnlyMinimumPtOfAllCrvs')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    gCrvs0 = []\r\n    for curveOrEdge0 in curvesAndEdges0:\r\n        gCrv0 = rs.coerceguid(curveOrEdge0)\r\n        if gCrv0:\r\n            gCrvs0.append(gCrv0)\r\n    \r\n    rgCrvs0_Found_All = []\r\n    pts_Pass_perCrv = []\r\n    radii_Pass_perCrv = []\r\n    \r\n    sFails = []\r\n    \r\n    radii_Accepted_AllCrvs = []\r\n    \r\n    len_curvesAndEdges0 = len(curvesAndEdges0)\r\n    \r\n    idxs_AtTenths = [int(round(0.1*i*len_curvesAndEdges0,0)) for i in range(10)]\r\n    \r\n    for iC, curveOrEdge0 in enumerate(curvesAndEdges0):\r\n        if iC in idxs_AtTenths:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                    \"Processing curve {} ...\".format(\r\n                    \"\" if len_curvesAndEdges0 == 1 else \"{} of {} \".format(\r\n                        iC+1, len_curvesAndEdges0)))\r\n        \r\n        rgCrv0 = rs.coercecurve(curveOrEdge0) # Will return various rg.Curves, including rg.BrepEdge.\r\n        if rgCrv0 is None: return None, \"Geometry for {} not found!\".format(rgCrv0)\r\n        \r\n        if isinstance(rgCrv0, rg.BrepEdge):\r\n            bDeleteInput = False\r\n        else:\r\n            gCrv0 = rs.coerceguid(curveOrEdge0)\r\n            rdCrv0 = rs.coercerhinoobject(curveOrEdge0)\r\n        \r\n        if isinstance(curveOrEdge0, rd.ObjRef):\r\n            rd.ObjRef.GeometryComponentIndex\r\n        \r\n        sType_rgCrv0 = rgCrv0.GetType().Name\r\n        \r\n        \r\n        \r\n        rc = getMinimumRadiiPoints(rgCrv0, bIncludeArcs, bDebug)\r\n        if rc is None:\r\n            sFails.append(\"getMinMaxRadiusPoints returned None.\")\r\n            rgCrv0.Dispose()\r\n            continue\r\n\r\n        pts_Minima, radii_Maxima = rc\r\n\r\n        if not pts_Minima:\r\n            sFails.append(\"getMinMaxRadiusPoints returned no points.\")\r\n            rgCrv0.Dispose()\r\n            continue\r\n        \r\n\r\n        if fMinRadToReport or fMaxRadToReport:\r\n            pts_Pass_ThisCrv = []\r\n            radii_Pass_ThisCrv = []\r\n            for iT in range(len(pts_Minima)):\r\n                pt = pts_Minima[iT]\r\n                radius = radii_Maxima[iT]\r\n                if fMinRadToReport and radius >= (fMinRadToReport - fRadEqTol):\r\n                    pts_Pass_ThisCrv.append(pt)\r\n                    radii_Pass_ThisCrv.append(radius)\r\n                elif fMaxRadToReport and radius <= (fMaxRadToReport + fRadEqTol):\r\n                    pts_Pass_ThisCrv.append(pt)\r\n                    radii_Pass_ThisCrv.append(radius)\r\n            if radii_Pass_ThisCrv:\r\n                radii_Accepted_AllCrvs.extend(radii_Pass_ThisCrv)\r\n                rgCrvs0_Found_All.append(rgCrv0)\r\n                pts_Pass_perCrv.append(pts_Pass_ThisCrv)\r\n                radii_Pass_perCrv.append(radii_Pass_ThisCrv)\r\n            else:\r\n                sFail  = \"No radii found\"\r\n                if fMinRadToReport:\r\n                    sFail += \" above {}\".format(fMinRadToReport)\r\n                if fMaxRadToReport:\r\n                    if fMinRadToReport:\r\n                        sFail += \", and\"\r\n                    sFail += \" below {}\".format(fMaxRadToReport)\r\n                sFail += \".\"\r\n                sFails.append(sFail)\r\n                rgCrv0.Dispose()\r\n                continue\r\n        else:\r\n            rgCrvs0_Found_All.append(rgCrv0)\r\n            pts_Pass_perCrv.append(pts_Minima)\r\n            radii_Pass_perCrv.append(radii_Maxima)\r\n    \r\n\r\n    if not pts_Pass_perCrv:\r\n        s  = \"No minimum radii found\"\r\n        if fMinRadToReport:\r\n            s += \" above {}\".format(fMinRadToReport)\r\n            if fMaxRadToReport: s += \",\"\r\n        if fMaxRadToReport:\r\n            s += \" below {}\".format(fMaxRadToReport)\r\n        s += \".\"\r\n        print s\r\n        return\r\n\r\n    if bEcho:\r\n        if len_curvesAndEdges0 == 1:\r\n            s =  \"{} radius minima found.\".format(len(radii_Maxima))\r\n            if fMinRadToReport or fMaxRadToReport:\r\n                s += \"  {} are\".format(\r\n                        sum([len(rads) for rads in radii_Pass_perCrv]))\r\n                if fMinRadToReport:\r\n                    s += \" above {}\".format(fMinRadToReport)\r\n                    if fMaxRadToReport: s += \",\"\r\n                if fMaxRadToReport:\r\n                    s += \" below {}\".format(fMaxRadToReport)\r\n                s += \".\"\r\n            s += \"  Minimum is {}.\".format(\r\n                    getFormattedDistance(min(radii_Maxima)))\r\n            if sFails: s += '\\n' + sFails[0]\r\n            print s\r\n        elif len_curvesAndEdges0 > 1:\r\n            s = \"Out of {} curves selected:\".format(len_curvesAndEdges0)\r\n            for sFail in set(sFails):\r\n                s += \"\\n[{}] {}\".format(sFails.count(sFail), sFail)\r\n            if fMinRadToReport:\r\n                s += \"  {0} radius minima [{2:.{4}f},{3:.{4}f}] are less than {1}.\".format(\r\n                        len(radii_Accepted_AllCrvs), fMinRadToReport,\r\n                        min(radii_Accepted_AllCrvs), max(radii_Accepted_AllCrvs),\r\n                        sc.doc.ModelDistanceDisplayPrecision+1)\r\n            else:\r\n                s += \"\\n{} radius minima found.\".format(\r\n                        sum([len(_) for _ in radii_Pass_perCrv]))\r\n            print s\r\n\r\n    if not (bAddDot or bAddPt): return\r\n\r\n    if bAddDot:\r\n        attrib_Red = rd.ObjectAttributes()\r\n        attrib_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        attrib_Red.ObjectColor = Color.Red\r\n\r\n    if radii_Pass_perCrv:\r\n        pts_toAdd = []\r\n        dots_toAdd = []\r\n        \r\n        if bAddOnlyMinimumPt:\r\n            if bAddOnlyMinimumPtOfAllCrvs:\r\n                radius_Mininum_AllCrvs = min([__ for _ in radii_Pass_perCrv for __ in _])\r\n                sMinRad = \"R{0:.{1}f}\".format(\r\n                        radius_Mininum_AllCrvs,\r\n                        sc.doc.ModelDistanceDisplayPrecision)\r\n                \r\n                # Include all minima within tolerance to minimum.\r\n                for iC in range(len(rgCrvs0_Found_All)):\r\n                    rgCrv0 = rgCrvs0_Found_All[iC]\r\n                    pts_Minima = pts_Pass_perCrv[iC]\r\n                    radii_Minima_PerCrv = radii_Pass_perCrv[iC]\r\n\r\n                    for iR in range(len(radii_Minima_PerCrv)):\r\n                        radius = radii_Minima_PerCrv[iR]\r\n                        if abs(radius - radius_Mininum_AllCrvs) <= fRadEqTol:\r\n                            pt = pts_Minima[iR]\r\n                            if pt not in pts_toAdd:\r\n                                pts_toAdd.append(pt)\r\n                            if bAddDot:\r\n                                rgDot = rg.TextDot(sMinRad, pt)\r\n                                rgDot.FontHeight = iDotHeight\r\n                                sc.doc.Objects.AddTextDot(rgDot, attrib_Red)\r\n                s  = \"{} points added\".format(len(pts_toAdd))\r\n                s += \" {} added\".format(\r\n                    'points' if (bAddPt and not bAddDot) else 'dots')\r\n                s += \" at {}, minimum radius of all curves.\".format(sMinRad)\r\n            else:\r\n                # Add a minimum of each curve.\r\n                for iC in range(len(rgCrvs0_Found_All)):\r\n                    rgCrv0 = rgCrvs0_Found_All[iC]\r\n                    pts_Minima = pts_Pass_perCrv[iC]\r\n                    radii_Minima_PerCrv = radii_Pass_perCrv[iC]\r\n\r\n                    for iR in range(len(radii_Minima_PerCrv)):\r\n                        radius = radii_Minima_PerCrv[iR]\r\n                        if abs(radius - min(radii_Minima_PerCrv)) <= fRadEqTol:\r\n                            pt = pts_Minima[iR]\r\n                            if bAddPt:\r\n                                if pt not in pts_toAdd:\r\n                                    pts_toAdd.append(pt)\r\n                            if bAddDot:\r\n                                sMinRad = \"R{0:.{1}f}\".format(\r\n                                        radius,\r\n                                        sc.doc.ModelDistanceDisplayPrecision)\r\n                                rgDot = rg.TextDot(sMinRad, pt)\r\n                                rgDot.FontHeight = iDotHeight\r\n                                dots_toAdd.append(rgDot)\r\n                s  = \"{} points added at each curve's minimum radius.\".format(\r\n                        len(pts_toAdd),\r\n                        'points' if (bAddPt and not bAddDot) else 'dots')\r\n        else:\r\n            for iC in range(len(rgCrvs0_Found_All)):\r\n                rgCrv0 = rgCrvs0_Found_All[iC]\r\n                pts_Minima = pts_Pass_perCrv[iC]\r\n                radii_Minima_PerCrv = radii_Pass_perCrv[iC]\r\n\r\n                for iR in range(len(radii_Minima_PerCrv)):\r\n                    radius = radii_Minima_PerCrv[iR]\r\n                    pt = pts_Minima[iR]\r\n                    if bAddPt:\r\n                        # TODO: Test this in V7 since its ZeroTolerance is different.\r\n                        if not pts_toAdd or not rg.Point3d.EpsilonEquals(pt, pts_toAdd[0], epsilon=1.0e-12):\r\n                            pts_toAdd.append(pt)\r\n                    if bAddDot:\r\n                        sMinRad = \"R{0:.{1}f}\".format(\r\n                                radius,\r\n                                sc.doc.ModelDistanceDisplayPrecision)\r\n                        rgDot = rg.TextDot(sMinRad, pt)\r\n                        rgDot.FontHeight = iDotHeight\r\n                        dots_toAdd.append(rgDot)\r\n\r\n    if bAddDot:\r\n        for dot in dots_toAdd:\r\n            sc.doc.Objects.AddTextDot(dot, attrib_Red)\r\n        if bAddOnlyMinimumPt:\r\n            if bAddOnlyMinimumPtOfAllCrvs:\r\n                s  = \"{} dot\".format(len(pts_toAdd))\r\n                s += \" added at minimum radius of all curves: \"\r\n                s += sMinRad\r\n                s += \".\"\r\n            else:\r\n                s  = \"{} total dots added at minimum radius of each curve.\".format(\r\n                        len(dots_toAdd))\r\n        else:\r\n            s  = \"{} total dots added at all radius minima.\".format(\r\n                    len(dots_toAdd))\r\n\r\n    if bAddPt:\r\n        sc.doc.Objects.AddPoints(List[rg.Point3d](pts_toAdd)) # Python list has to be converted to .NET list for AddPoints.\r\n        if bAddOnlyMinimumPt:\r\n            if bAddOnlyMinimumPtOfAllCrvs:\r\n                s  = \"{} points\".format(len(pts_toAdd))\r\n                s += \" added at {}, minimum radius of all curves.\".format(sMinRad)\r\n            else:\r\n                s  = \"{} total points added at minimum radius of each curve.\".format(\r\n                        len(pts_toAdd))\r\n        else:\r\n            s  = \"{} total point(s) added at all radius minima.\".format(\r\n                    len(pts_toAdd))\r\n\r\n    if bEcho: print s\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    objrefs = rc[0]\r\n    \r\n    if Opts.values['bDebug']:\r\n        pass\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    rc = processCurves(curvesAndEdges0=objrefs)\r\n    if not rc: return\r\n    \r\n    rgCrvs0_Found_All = rc\r\n    \r\n    if rgCrvs0_Found_All:\r\n        [sc.doc.Objects.Select(objectId=__) for _ in rgCrvs0_Found_All for __ in _]\r\n    \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}