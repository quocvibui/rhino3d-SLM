{
  "source_url": "https://github.com/architecture-building-systems/honey-badger/blob/c59d21e7836616785492ac82cef6d8f5ae6f7b0a/parameter_compiler.py",
  "repo": "architecture-building-systems/honey-badger",
  "repo_stars": 8,
  "repo_description": "honey-badger is a build system for Python based Rhino/Grasshopper plugins",
  "license": "MIT",
  "filepath": "parameter_compiler.py",
  "instruction": "Compile parameters to a \".gha\" assembly. Currently, this only supports the parameter-type \"ValueList\". This\nwill produce subclasses of \"GH_ValueList\" with a pre-compiled list of values.",
  "code": "\"\"\"\nCompile parameters to a \".gha\" assembly. Currently, this only supports the parameter-type \"ValueList\". This\nwill produce subclasses of \"GH_ValueList\" with a pre-compiled list of values.\n\nWhy? Because GhPython only works for subclasses of \"DotNetCompiledComponent\" - So we're using Reflection.Emit to\ncreate a dll (a .gha _is_ a dll, just renamed...) with the types we want.\n\"\"\"\nimport os\nimport csv\nimport json\nimport clr\n\nclr.AddReference(\"IronPython\")\nclr.AddReference(\"System\")\nclr.AddReference(\"System.Reflection\")\n\nfrom System import Array, Type, AppDomain\nfrom System.Reflection import (AssemblyName, TypeAttributes, MethodInfo, MethodAttributes, CallingConventions,\n                               PropertyAttributes)\nfrom System.Reflection.Emit import AssemblyBuilderAccess, OpCode, OpCodes\n\nimport System.IO\n\n\ndef setup(rhino_version):\n    \"\"\"\n    Loads the RhinoCommon and Grasshopper libraries based on the desired/installed Rhino version.\n    Also loads the HoneyBadgerRuntime dll since it was somehow not working when imported above (maybe needs the Rhino dlls loaded first?)..\n    \"\"\"\n    global GH_AssemblyInfo\n    clr.AddReferenceToFileAndPath(os.path.join(os.path.expandvars(\"${PROGRAMFILES}\"),\n                         \"Rhino {v}\".format(v=rhino_version),\n                         \"Plug-ins\", \"Grasshopper\", \"Grasshopper.dll\"))\n    clr.AddReferenceToFileAndPath(os.path.join(os.path.expandvars(\"${PROGRAMFILES}\"),\n                            \"Rhino {v}\".format(v=rhino_version),\n                            \"System\", \"RhinoCommon.dll\"))\n    from Grasshopper.Kernel import GH_AssemblyInfo\n    \n    global HoneyBadgerRuntimeInfo, HoneyBadgerValueList\n    \n    hbrt_path = os.path.join(os.path.dirname(os.path.normpath(os.path.abspath(__file__))), \"honey-badger-runtime\", \"bin\",\n                            \"honey-badger-runtime.dll\")\n    clr.AddReferenceToFileAndPath(hbrt_path)\n    from HoneyBadgerRuntime import HoneyBadgerValueList, HoneyBadgerRuntimeInfo\n\n\n\ndef compile_parameters(badger_config, badger_dir, dll_path):\n    \"\"\"Compile ValueList parameters and save them to a .gha assembly.\"\"\"\n    # https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder?view=netframework-4.8\n    parameters = badger_config[\"parameters\"]\n    base_constructor = clr.GetClrType(HoneyBadgerValueList).GetConstructor(Array[Type]([str, str, str, str, str, str]))\n\n    dll_folder = os.path.dirname(dll_path)\n    dll_name = os.path.splitext(os.path.basename(dll_path))[0]\n    assembly_name = AssemblyName(dll_name)\n    assembly_builder = AppDomain.CurrentDomain.DefineDynamicAssembly(assembly_name, AssemblyBuilderAccess.RunAndSave, dll_folder)\n    module_builder = assembly_builder.DefineDynamicModule(assembly_name.Name, assembly_name.Name + \".gha\")\n    for parameter in parameters:\n        assert parameter[\"parameter-type\"] == \"ValueList\", \"honey-badger can only produce ValueList parameters\"\n        keys, values = read_values(badger_dir, parameter[\"csv\"])\n        type_builder = module_builder.DefineType(parameter[\"class-name\"],\n                                                 TypeAttributes.Public,\n                                                 HoneyBadgerValueList)\n        constructor_builder = type_builder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard,\n                                                             Type.EmptyTypes)\n        il_generator = constructor_builder.GetILGenerator()\n        il_generator.Emit(OpCodes.Ldarg_0)  # load \"this\" onto stack\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"name\"])  # load constructor args (name)\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"abbreviation\"])  # load constructor args (nickname)\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"description\"])  # load constructor args (description)\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"category\"])  # load constructor args (category)\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"subcategory\"])  # load constructor args (subCategory)\n        il_generator.Emit(OpCodes.Ldstr, parameter[\"id\"])  # load constructor args (guid)\n        il_generator.Emit(OpCodes.Call, base_constructor)  # call constructor, consumes args and \"this\"\n        il_generator.Emit(OpCodes.Ret)  # return from constructor\n\n        override_load_value_list(type_builder, keys=keys, values=values)\n\n        if \"icon\" in parameter:\n            # convert icon (a path) to a base64 string\n            icon_path = os.path.join(badger_dir, parameter[\"icon\"])\n            assert os.path.exists(icon_path), \"Could not find icon file: {}\".format(icon_path)\n            override_get_icon_string(type_builder, icon_path)            \n\n        type_builder.CreateType()\n\n    # add a GH_AssemblyInfo to the assembly...\n    create_gh_assembly_info(badger_config, module_builder)\n\n    assembly_builder.Save(assembly_name.Name + \".gha\")\n\n\ndef override_load_value_list(type_builder, keys, values):\n    \"\"\"Override HoneyBadgerValueList.LoadValues to load the keys and corresponding values\"\"\"\n    add_list_item = clr.GetClrType(HoneyBadgerValueList).GetMethod(\"AddListItem\", Array[Type]([str, str]))\n    method_attributes = (MethodAttributes.Public | MethodAttributes.Virtual)\n    method_builder = type_builder.DefineMethod(\"LoadValueList\", method_attributes, CallingConventions.Standard,\n                                               None, None)\n    il_generator = method_builder.GetILGenerator()\n    for key, value in zip(keys, values):\n        il_generator.Emit(OpCodes.Ldarg_0)  # this\n        il_generator.Emit(OpCodes.Ldstr, str(key))\n        il_generator.Emit(OpCodes.Ldstr, json.dumps(value))\n        il_generator.Emit.Overloads[OpCode, MethodInfo](OpCodes.Call, add_list_item)\n\n    il_generator.Emit(OpCodes.Ret)\n\ndef override_get_icon_string(type_builder, icon_path):    \n    bytes = System.IO.File.ReadAllBytes(icon_path)\n    icon_base64 = System.Convert.ToBase64String(bytes)    \n    method_attributes = (MethodAttributes.Public | MethodAttributes.Virtual)\n    method_builder = type_builder.DefineMethod(\"GetIconString\", method_attributes, CallingConventions.Standard,\n                                               clr.GetClrType(System.String), None)\n    il_generator = method_builder.GetILGenerator()\n    # il_generator.Emit(OpCodes.Ldarg_0)  # this\n    il_generator.Emit(OpCodes.Ldstr, icon_base64)\n    il_generator.Emit(OpCodes.Ret)\n\n\ndef create_gh_assembly_info(badger_config, module_builder):\n    \"\"\"Create a GH_AssemblyInfo subclass for the assembly, as it seems we need to directly subclass it.\"\"\"\n    type_builder = module_builder.DefineType(badger_config[\"name\"] + \"AssemblyInfo\", TypeAttributes.Public,\n                                             GH_AssemblyInfo)\n\n    # create an empty constructor\n    constructor_builder = type_builder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard,\n                                                         Type.EmptyTypes)\n    il_generator = constructor_builder.GetILGenerator()\n    il_generator.Emit(OpCodes.Ret)\n\n    # create the properties\n    create_string_property(\"Name\", badger_config[\"name\"] + \"Parameters\", type_builder)\n    create_string_property(\"Version\", badger_config[\"version\"], type_builder)\n    create_string_property(\"Description\", badger_config[\"description\"], type_builder)\n\n    # create the Version property\n    type_builder.CreateType()\n\n\ndef create_string_property(name, value, type_builder):\n    \"\"\"Override a (string) property getter\"\"\"\n    property_builder = type_builder.DefineProperty(name, PropertyAttributes.HasDefault, str, None)\n    getter_attributes = (MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig\n                         | MethodAttributes.Virtual)\n    getter = type_builder.DefineMethod(\"get_{name}\".format(name=name), getter_attributes, str, None)\n    il_generator = getter.GetILGenerator()\n    il_generator.Emit(OpCodes.Ldstr, value)\n    il_generator.Emit(OpCodes.Ret)  # return from constructor\n    property_builder.SetGetMethod(getter)\n\n\ndef read_values(badger_dir, csv_file):\n    \"\"\"Import the value_producer module relative to badger_dir and return the results of running the main() function.\"\"\"\n    with open(os.path.join(badger_dir, csv_file)) as csv_fp:\n        reader = csv.DictReader(csv_fp)\n        keys = []\n        values = []\n        for row in reader:\n            keys.append(row[reader.fieldnames[0]])\n            values.append(floatify(row))\n        return keys, values\n\n\ndef floatify(dict):\n    \"\"\"convert as many values to float as possible\"\"\"\n    for key in dict.keys():\n        try:\n           dict[key] = float(dict[key])\n        except ValueError:\n            pass\n        except SystemError:\n            print dict\n    return dict\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}