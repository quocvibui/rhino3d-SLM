{
  "source_url": "https://github.com/legioner9/NPython/blob/067db1e573342e9e1c76075da8a7bffd0fdd65a1/Pala/py_wiki/MoinMoin/moin-1.9.11/MoinMoin/packages.py",
  "repo": "legioner9/NPython",
  "repo_stars": 0,
  "repo_description": "edu python",
  "license": "unknown",
  "filepath": "Pala/py_wiki/MoinMoin/moin-1.9.11/MoinMoin/packages.py",
  "instruction": "MoinMoin - Package Installer",
  "code": "# -*- coding: iso-8859-1 -*-\n\"\"\"\n    MoinMoin - Package Installer\n\n    @copyright: 2005 MoinMoin:AlexanderSchremmer,\n                2007-2010 MoinMoin:ReimarBauer\n    @license: GNU GPL, see COPYING for details.\n\"\"\"\n\nimport os, re, sys\nimport zipfile\n\nfrom MoinMoin import config, wikiutil, caching, user\nfrom MoinMoin.Page import Page\nfrom MoinMoin.PageEditor import PageEditor\nfrom MoinMoin.logfile import editlog, eventlog\nfrom MoinMoin.util import filesys\n\nMOIN_PACKAGE_FILE = 'MOIN_PACKAGE'\nMAX_VERSION = 1\n\n\n# Exceptions\nclass PackageException(Exception):\n    \"\"\" Raised if the package is broken. \"\"\"\n    pass\n\nclass ScriptException(Exception):\n    \"\"\" Raised when there is a problem in the script. \"\"\"\n\n    def __unicode__(self):\n        \"\"\" Return unicode error message \"\"\"\n        if isinstance(self.args[0], str):\n            return unicode(self.args[0], config.charset)\n        else:\n            return unicode(self.args[0])\n\nclass RuntimeScriptException(ScriptException):\n    \"\"\" Raised when the script problem occurs at runtime. \"\"\"\n\nclass ScriptExit(Exception):\n    \"\"\" Raised by the script commands when the script should quit. \"\"\"\n\ndef event_logfile(self, pagename, pagefile):\n    # add event log entry\n    eventtype = 'SAVENEW'\n    mtime_usecs = wikiutil.timestamp2version(os.path.getmtime(pagefile))\n    elog = eventlog.EventLog(self.request)\n    elog.add(self.request, eventtype, {'pagename': pagename}, 1, mtime_usecs)\n\ndef edit_logfile_append(self, pagename, pagefile, rev, action, logname='edit-log', comment=u'', author=u\"Scripting Subsystem\"):\n    glog = editlog.EditLog(self.request, uid_override=author)\n    pagelog = Page(self.request, pagename).getPagePath(logname, use_underlay=0, isfile=1)\n    llog = editlog.EditLog(self.request, filename=pagelog,\n                               uid_override=author)\n    mtime_usecs = wikiutil.timestamp2version(os.path.getmtime(pagefile))\n    host = '::1'\n    extra = u''\n    glog.add(self.request, mtime_usecs, rev, action, pagename, host, comment)\n    llog.add(self.request, mtime_usecs, rev, action, pagename, host, extra, comment)\n    event_logfile(self, pagename, pagefile)\n\n# Parsing and (un)quoting for script files\ndef packLine(items, separator=\"|\"):\n    \"\"\" Packs a list of items into a string that is separated by `separator`. \"\"\"\n    return '|'.join([item.replace('\\\\', '\\\\\\\\').replace(separator, '\\\\' + separator) for item in items])\n\ndef unpackLine(string, separator=\"|\"):\n    \"\"\" Unpacks a string that was packed by packLine. \"\"\"\n    result = []\n    token = None\n    escaped = False\n    for char in string:\n        if token is None:\n            token = \"\"\n        if escaped and char in ('\\\\', separator):\n            token += char\n            escaped = False\n            continue\n        escaped = (char == '\\\\')\n        if escaped:\n            continue\n        if char == separator:\n            result.append(token)\n            token = \"\"\n        else:\n            token += char\n    if token is not None:\n        result.append(token)\n    return result\n\ndef str2boolean(string):\n    \"\"\"\n    Converts the parameter to a boolean value by recognising different\n    truth literals.\n    \"\"\"\n    return (string.lower() in ('yes', 'true', '1'))\n\nclass ScriptEngine:\n    \"\"\"\n    The script engine supplies the needed commands to execute the installation\n    script.\n    \"\"\"\n\n    def _extractToFile(self, source, target):\n        \"\"\" Extracts source and writes the contents into target. \"\"\"\n        # TODO, add file dates\n        target_file = open(target, \"wb\")\n        target_file.write(self.extract_file(source))\n        target_file.close()\n\n    def __init__(self):\n        self.themename = None\n        self.ignoreExceptions = False\n        self.goto = 0\n\n        #Satisfy pylint\n        self.msg = getattr(self, \"msg\", \"\")\n        self.request = getattr(self, \"request\", None)\n\n    def do_addattachment(self, zipname, filename, pagename, author=u\"Scripting Subsystem\", comment=u\"\"):\n        \"\"\"\n        Installs an attachment\n\n        @param pagename: Page where the file is attached. Or in 2.0, the file itself.\n        @param zipname: Filename of the attachment from the zip file\n        @param filename: Filename of the attachment (just applicable for MoinMoin < 2.0)\n        \"\"\"\n        if self.request.user.may.write(pagename):\n            _ = self.request.getText\n\n            attachments = Page(self.request, pagename).getPagePath(\"attachments\", check_create=1)\n            filename = wikiutil.taintfilename(filename)\n            zipname = wikiutil.taintfilename(zipname)\n            target = os.path.join(attachments, filename)\n            page = PageEditor(self.request, pagename, do_editor_backup=0, uid_override=author)\n            rev = page.current_rev()\n            path = page.getPagePath(check_create=0)\n            if not os.path.exists(target):\n                self._extractToFile(zipname, target)\n                if os.path.exists(target):\n                    filesys.chmod(target, 0666 & config.umask)\n                    action = 'ATTNEW'\n                    edit_logfile_append(self, pagename, path, rev, action, logname='edit-log',\n                                       comment=u'%(filename)s' % {\"filename\": filename}, author=author)\n                self.msg += u\"%(filename)s attached \\n\" % {\"filename\": filename}\n            else:\n                self.msg += u\"%(filename)s not attached \\n\" % {\"filename\": filename}\n        else:\n            self.msg += u\"action add attachment: not enough rights - nothing done \\n\"\n\n    def do_delattachment(self, filename, pagename, author=u\"Scripting Subsystem\", comment=u\"\"):\n        \"\"\"\n        Removes an attachment\n\n        @param pagename: Page where the file is attached. Or in 2.0, the file itself.\n        @param filename: Filename of the attachment (just applicable for MoinMoin < 2.0)\n        \"\"\"\n        if self.request.user.may.write(pagename):\n            _ = self.request.getText\n\n            attachments = Page(self.request, pagename).getPagePath(\"attachments\", check_create=1)\n            filename = wikiutil.taintfilename(filename)\n            target = os.path.join(attachments, filename)\n            page = PageEditor(self.request, pagename, do_editor_backup=0, uid_override=author)\n            rev = page.current_rev()\n            path = page.getPagePath(check_create=0)\n            if os.path.exists(target):\n                os.remove(target)\n                action = 'ATTDEL'\n                edit_logfile_append(self, pagename, path, rev, action, logname='edit-log',\n                                    comment=u'%(filename)s' % {\"filename\": filename}, author=author)\n                self.msg += u\"%(filename)s removed \\n\" % {\"filename\": filename}\n            else:\n                self.msg += u\"%(filename)s does not exist \\n\" % {\"filename\": filename}\n        else:\n            self.msg += u\"action delete attachment: not enough rights - nothing done \\n\"\n\n    def do_print(self, *param):\n        \"\"\" Prints the parameters into output of the script. \"\"\"\n        self.msg += '; '.join(param) + \"\\n\"\n\n    def do_exit(self):\n        \"\"\" Exits the script. \"\"\"\n        raise ScriptExit\n\n    def do_ignoreexceptions(self, boolean):\n        \"\"\" Sets the ignore exceptions setting. If exceptions are ignored, the\n        script does not stop if one is encountered. \"\"\"\n        self.ignoreExceptions = str2boolean(boolean)\n\n    def do_ensureversion(self, version, lines=0):\n        \"\"\"\n        Ensures that the version of MoinMoin is greater or equal than\n        version. If lines is unspecified, the script aborts. Otherwise,\n        the next lines (amount specified by lines) are not executed.\n\n        @param version: required version of MoinMoin (e.g. \"1.3.4\")\n        @param lines: lines to ignore\n        \"\"\"\n        _ = self.request.getText\n\n        from MoinMoin.version import release\n        version_int = [int(x) for x in version.split(\".\")]\n        # use a regex here to get only the numbers of the release string (e.g. ignore betaX)\n        release = re.compile('\\d+').findall(release)[0:3]\n        release = [int(x) for x in release]\n        if version_int > release:\n            if lines > 0:\n                self.goto = lines\n            else:\n                raise RuntimeScriptException(_(\"The package needs a newer version\"\n                                               \" of MoinMoin (at least %s).\") %\n                                             version)\n\n    def do_setthemename(self, themename):\n        \"\"\" Sets the name of the theme which will be altered next. \"\"\"\n        self.themename = wikiutil.taintfilename(str(themename))\n\n    def do_copythemefile(self, filename, ftype, target):\n        \"\"\" Copies a theme-related file (CSS, PNG, etc.) into a directory of the\n        current theme.\n\n        @param filename: name of the file in this package\n        @param ftype:   the subdirectory of the theme directory, e.g. \"css\"\n        @param target: filename, e.g. \"screen.css\"\n        \"\"\"\n        _ = self.request.getText\n        if self.themename is None:\n            raise RuntimeScriptException(_(\"The theme name is not set.\"))\n\n        from MoinMoin.web.static import STATIC_FILES_PATH as htdocs_dir\n        if not os.access(htdocs_dir, os.W_OK):\n            raise RuntimeScriptException(_(\"Theme files not installed! Write rights missing for %s.\") % htdocs_dir)\n\n        theme_file = os.path.join(htdocs_dir, self.themename,\n                                  wikiutil.taintfilename(ftype),\n                                  wikiutil.taintfilename(target))\n        theme_dir = os.path.dirname(theme_file)\n        if not os.path.exists(theme_dir):\n            os.makedirs(theme_dir)\n        self._extractToFile(filename, theme_file)\n\n    def do_installplugin(self, filename, visibility, ptype, target):\n        \"\"\"\n        Installs a python code file into the appropriate directory.\n\n        @param filename: name of the file in this package\n        @param visibility: 'local' will copy it into the plugin folder of the\n            current wiki. 'global' will use the folder of the MoinMoin python\n            package.\n        @param ptype: the type of the plugin, e.g. \"parser\"\n        @param target: the filename of the plugin, e.g. wiki.py\n        \"\"\"\n        visibility = visibility.lower()\n        ptype = wikiutil.taintfilename(ptype.lower())\n\n        if visibility == 'global':\n            basedir = os.path.dirname(__import__(\"MoinMoin\").__file__)\n        elif visibility == 'local':\n            basedir = self.request.cfg.plugin_dir\n\n        target = os.path.join(basedir, ptype, wikiutil.taintfilename(target))\n\n        self._extractToFile(filename, target)\n        wikiutil._wiki_plugins = {}\n\n    def do_installpackage(self, pagename, filename):\n        \"\"\"\n        Installs a package.\n\n        @param pagename: Page where the file is attached. Or in 2.0, the file itself.\n        @param filename: Filename of the attachment (just applicable for MoinMoin < 2.0)\n        \"\"\"\n        _ = self.request.getText\n\n        attachments = Page(self.request, pagename).getPagePath(\"attachments\", check_create=0)\n        package = ZipPackage(self.request, os.path.join(attachments, wikiutil.taintfilename(filename)))\n\n        if package.isPackage():\n            if not package.installPackage():\n                raise RuntimeScriptException(_(\"Installation of '%(filename)s' failed.\") % {\n                    'filename': filename} + \"\\n\" + package.msg)\n        else:\n            raise RuntimeScriptException(_('The file %s is not a MoinMoin package file.') % filename)\n\n        self.msg += package.msg\n\n    def do_addrevision(self, filename, pagename, author=u\"Scripting Subsystem\", comment=u\"\", trivial=u\"No\"):\n        \"\"\" Adds a revision to a page.\n\n        @param filename: name of the file in this package\n        @param pagename: name of the target page\n        @param author:   user name of the editor (optional)\n        @param comment:  comment related to this revision (optional)\n        @param trivial:  boolean, if it is a trivial edit\n        \"\"\"\n        _ = self.request.getText\n        trivial = str2boolean(trivial)\n        if self.request.user.may.write(pagename):\n            page = PageEditor(self.request, pagename, do_editor_backup=0)\n            try:\n                page.saveText(self.extract_file(filename).decode(\"utf-8\"), 0, trivial=trivial, comment=comment)\n            except PageEditor.Unchanged:\n                pass\n            else:\n                self.msg += u\"%(pagename)s added \\n\" % {\"pagename\": pagename}\n        else:\n            self.msg += u\"action add revision: not enough rights - nothing done \\n\"\n\n    def do_renamepage(self, pagename, newpagename, author=u\"Scripting Subsystem\", comment=u\"Renamed by the scripting subsystem.\"):\n        \"\"\" Renames a page.\n\n        @param pagename: name of the target page\n        @param newpagename: name of the new page\n        @param author:   user name of the editor (optional)\n        @param comment:  comment related to this revision (optional)\n        \"\"\"\n        if self.request.user.may.write(pagename):\n            _ = self.request.getText\n            page = PageEditor(self.request, pagename, do_editor_backup=0, uid_override=author)\n            if not page.exists():\n                raise RuntimeScriptException(_(\"The page %s does not exist.\") % pagename)\n            newpage = PageEditor(self.request, newpagename)\n            page.renamePage(newpage.page_name, comment=u\"Renamed from '%s'\" % (pagename))\n            self.msg += u'%(pagename)s renamed to %(newpagename)s\\n' % {\n                            \"pagename\": pagename,\n                            \"newpagename\": newpagename}\n        else:\n            self.msg += u\"action rename page: not enough rights - nothing done \\n\"\n\n    def do_deletepage(self, pagename, comment=\"Deleted by the scripting subsystem.\"):\n        \"\"\" Marks a page as deleted (like the DeletePage action).\n\n        @param pagename: page to delete\n        @param comment:  the related comment (optional)\n        \"\"\"\n        if self.request.user.may.write(pagename):\n            _ = self.request.getText\n            page = PageEditor(self.request, pagename, do_editor_backup=0)\n            if not page.exists():\n                raise RuntimeScriptException(_(\"The page %s does not exist.\") % pagename)\n            page.deletePage(comment)\n        else:\n            self.msg += u\"action delete page: not enough rights - nothing done \\n\"\n\n    def do_replaceunderlayattachment(self, zipname, filename, pagename, author=u\"Scripting Subsystem\", comment=u\"\"):\n        \"\"\"\n        overwrite underlay attachments\n\n        @param pagename: Page where the file is attached. Or in 2.0, the file itself.\n        @param zipname: Filename of the attachment from the zip file\n        @param filename: Filename of the attachment (just applicable for MoinMoin < 2.0)\n        \"\"\"\n        if self.request.user.may.write(pagename):\n            _ = self.request.getText\n            filename = wikiutil.taintfilename(filename)\n            zipname = wikiutil.taintfilename(zipname)\n            page = PageEditor(self.request, pagename, do_editor_backup=0, uid_override=author)\n            pagedir = page.getPagePath(use_underlay=1, check_create=1)\n            attachments = os.path.join(pagedir, 'attachments')\n            if not os.path.exists(attachments):\n                os.mkdir(attachments)\n            target = os.path.join(attachments, filename)\n            self._extractToFile(zipname, target)\n            if os.path.exists(target):\n                filesys.chmod(target, 0666 & config.umask)\n        else:\n            self.msg += u\"action replace underlay attachment: not enough rights - nothing done \\n\"\n\n    def do_replaceunderlay(self, filename, pagename):\n        \"\"\"\n        Overwrites underlay pages. Implementational detail: This needs to be\n        kept in sync with the page class.\n\n        @param filename: name of the file in the package\n        @param pagename: page to be overwritten\n        \"\"\"\n        page = Page(self.request, pagename)\n\n        pagedir = page.getPagePath(use_underlay=1, check_create=1)\n\n        revdir = os.path.join(pagedir, 'revisions')\n        cfn = os.path.join(pagedir, 'current')\n\n        revstr = '%08d' % 1\n        if not os.path.exists(revdir):\n            os.mkdir(revdir)\n\n        currentf = open(cfn, 'w')\n        currentf.write(revstr + \"\\n\")\n        currentf.close()\n\n        pagefile = os.path.join(revdir, revstr)\n        self._extractToFile(filename, pagefile)\n        # Clear caches\n        # TODO Code from MoinMoin/script/maint/cleancache.py may be used\n\n    def runScript(self, commands):\n        \"\"\" Runs the commands.\n\n        @param commands: list of strings which contain a command each\n        @return True on success\n        \"\"\"\n        _ = self.request.getText\n\n        headerline = unpackLine(commands[0])\n\n        if headerline[0].lower() != \"MoinMoinPackage\".lower():\n            raise PackageException(_(\"Invalid package file header.\"))\n\n        self.revision = int(headerline[1])\n        if self.revision > MAX_VERSION:\n            raise PackageException(_(\"Package file format unsupported.\"))\n\n        lineno = 1\n        success = True\n\n        for line in commands[1:]:\n            lineno += 1\n            if self.goto > 0:\n                self.goto -= 1\n                continue\n\n            if line.startswith(\"#\") or len(line) == 0:\n                continue\n            elements = unpackLine(line)\n            fnname = elements[0].strip().lower()\n            if fnname == '':\n                continue\n            try:\n                if fnname in self.request.cfg.packagepages_actions_excluded:\n                    self.msg += u\"action package %s: excluded \\n\" % elements[0].strip()\n                    success = False\n                    continue\n                else:\n                    fn = getattr(self, \"do_\" + fnname)\n            except AttributeError:\n                self.msg += u\"Exception RuntimeScriptException: %s\\n\" % (\n                        _(\"Unknown function %(func)s in line %(lineno)i.\") %\n                        {'func': elements[0], 'lineno': lineno}, )\n                success = False\n                break\n\n            try:\n                fn(*elements[1:])\n            except ScriptExit:\n                break\n            except TypeError, e:\n                self.msg += u\"Exception %s (line %i): %s\\n\" % (e.__class__.__name__, lineno, unicode(e))\n                success = False\n                break\n            except RuntimeScriptException, e:\n                if not self.ignoreExceptions:\n                    self.msg += u\"Exception %s (line %i): %s\\n\" % (e.__class__.__name__, lineno, unicode(e))\n                    success = False\n                    break\n\n        return success\n\nclass Package:\n    \"\"\" A package consists of a bunch of files which can be installed. \"\"\"\n    def __init__(self, request):\n        self.request = request\n        self.msg = \"\"\n\n    def installPackage(self):\n        \"\"\" Opens the package and executes the script. \"\"\"\n\n        _ = self.request.getText\n\n        if not self.isPackage():\n            raise PackageException(_(\"The file %s was not found in the package.\") % MOIN_PACKAGE_FILE)\n\n        commands = self.getScript().splitlines()\n\n        return self.runScript(commands)\n\n    def getScript(self):\n        \"\"\" Returns the script. \"\"\"\n        return self.extract_file(MOIN_PACKAGE_FILE).decode(\"utf-8\").replace(u\"\\ufeff\", \"\")\n\n    def extract_file(self, filename):\n        \"\"\" Returns the contents of a file in the package. \"\"\"\n        raise NotImplementedError\n\n    def filelist(self):\n        \"\"\" Returns a list of all files. \"\"\"\n        raise NotImplementedError\n\n    def isPackage(self):\n        \"\"\" Returns true if this package is recognised. \"\"\"\n        raise NotImplementedError\n\nclass ZipPackage(Package, ScriptEngine):\n    \"\"\" A package that reads its files from a .zip file. \"\"\"\n    def __init__(self, request, filename):\n        \"\"\" Initialise the package.\n\n        @param request: RequestBase instance\n        @param filename: filename of the .zip file\n        \"\"\"\n\n        Package.__init__(self, request)\n        ScriptEngine.__init__(self)\n        self.filename = filename\n\n        self._isZipfile = zipfile.is_zipfile(filename)\n        if self._isZipfile:\n            self.zipfile = zipfile.ZipFile(filename)\n        # self.zipfile.getinfo(name)\n\n    def extract_file(self, filename):\n        \"\"\" Returns the contents of a file in the package. \"\"\"\n        _ = self.request.getText\n        try:\n            return self.zipfile.read(filename.encode(\"cp437\"))\n        except KeyError:\n            raise RuntimeScriptException(_(\n                \"The file %s was not found in the package.\") % filename)\n\n    def filelist(self):\n        \"\"\" Returns a list of all files. \"\"\"\n        return self.zipfile.namelist()\n\n    def isPackage(self):\n        \"\"\" Returns true if this package is recognised. \"\"\"\n        return self._isZipfile and MOIN_PACKAGE_FILE in self.zipfile.namelist()\n\ndef main():\n    args = sys.argv\n    if len(args)-1 not in (2, 3) or args[1] not in ('l', 'i'):\n        print >> sys.stderr, \"\"\"MoinMoin Package Installer v%(version)i\n\n%(myname)s action packagefile [request URL]\n\naction      - Either \"l\" for listing the script or \"i\" for installing.\npackagefile - The path to the file containing the MoinMoin installer package\nrequest URL - Just needed if you are running a wiki farm, used to differentiate\n              the correct wiki.\n\nExample:\n\n%(myname)s i ../package.zip\n\n\"\"\" % {\"version\": MAX_VERSION, \"myname\": os.path.basename(args[0])}\n        raise SystemExit\n\n    packagefile = args[2]\n    if len(args) > 3:\n        request_url = args[3]\n    else:\n        request_url = None\n\n    # Setup MoinMoin environment\n    from MoinMoin.web.contexts import ScriptContext\n    request = ScriptContext(url=request_url)\n\n    package = ZipPackage(request, packagefile)\n    if not package.isPackage():\n        print \"The specified file %s is not a package.\" % packagefile\n        raise SystemExit\n\n    if args[1] == 'l':\n        print package.getScript()\n    elif args[1] == 'i':\n        if package.installPackage():\n            print \"Installation was successful!\"\n        else:\n            print \"Installation failed.\"\n        if package.msg:\n            print package.msg\n\nif __name__ == '__main__':\n    main()\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}