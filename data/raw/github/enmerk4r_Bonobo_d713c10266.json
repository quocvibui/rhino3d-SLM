{
  "source_url": "https://github.com/enmerk4r/Bonobo/blob/0ef4d7c8a7030248ee0a93112d884ebb974553f5/Bonobo.Py/run_simulation.py",
  "repo": "enmerk4r/Bonobo",
  "repo_stars": 3,
  "repo_description": "A Grasshopper bridge for Blender simulations",
  "license": "MIT",
  "filepath": "Bonobo.Py/run_simulation.py",
  "instruction": "Run simulation",
  "code": "\nimport bpy\nimport json\nimport rhino3dm\nfrom pprint import pprint\nimport mathutils\nimport argparse\nimport uuid\nimport os\n\ndef load_simulation(path, steps, start, end):\n    # Clear the scene\n    candidate_list = [item.name for item in bpy.data.objects if item.type == \"MESH\"]\n\n    # select them only.\n    for object_name in candidate_list:\n      bpy.data.objects[object_name].select_set(True)\n\n    # remove all selected.\n    bpy.ops.object.delete()\n\n    # remove the meshes, they have no users anymore.\n    for item in bpy.data.meshes:\n      bpy.data.meshes.remove(item)\n\n\n    with open(path, \"r\") as f:\n        mesh_list = json.load(f)\n        \n        \n    ## Create Rigid Body Sim\n    for mesh_string in mesh_list:   \n        mesh = json.loads(mesh_string)\n        m = rhino3dm.CommonObject.Decode(json.loads(mesh[\"mesh\"]))\n\n\n        vertices = []\n        edges = []\n        faces = []\n\n        for i in range(len(m.Vertices)):\n            v = m.Vertices[i]\n            vertices.append((v.X, v.Y, v.Z))\n            \n\n        for i in range(len(m.Faces)):\n            faces.append(m.Faces[i])\n\n\n        new_mesh = bpy.data.meshes.new('new_mesh')  \n        new_mesh.from_pydata(vertices, edges, faces)\n\n\n            \n        new_mesh.update()\n\n        new_object = bpy.data.objects.new('new_object', new_mesh)\n        new_object.data = new_mesh    \n\n        new_collection = bpy.data.collections[0]\n        # add object to scene collection\n        new_collection.objects.link(new_object)\n\n        bpy.context.view_layer.objects.active = new_object\n        new_object.select_set(True)\n\n        bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')\n        cursor = bpy.context.scene.cursor\n\n        bpy.ops.rigidbody.object_add()\n        bpy.context.object.rigid_body.mass = mesh[\"mass\"]\n        bpy.context.object.rigid_body.collision_shape = mesh[\"collision_shape\"]\n        bpy.context.object.rigid_body.friction = mesh[\"friction\"]\n        bpy.context.object.rigid_body.use_margin = mesh[\"use_margin\"]\n        bpy.context.object.rigid_body.collision_margin = mesh[\"collision_margin\"]\n        bpy.context.object.rigid_body.linear_damping = mesh[\"linear_damping\"]\n        bpy.context.object.rigid_body.angular_damping = mesh[\"angular_damping\"]\n        if mesh[\"is_active\"]:\n            bpy.context.object.rigid_body.type = 'ACTIVE'\n        else:\n            bpy.context.object.rigid_body.type = 'PASSIVE'\n        \n            \n    bpy.context.scene.rigidbody_world.steps_per_second =  steps\n    bpy.context.scene.frame_start = start\n    bpy.context.scene.frame_end = end\n        \n    bpy.context.scene.rigidbody_world.point_cache.frame_start = start\n    bpy.context.scene.rigidbody_world.point_cache.frame_end = end\n    \n\ndef export_frame(frame, directory):\n    rhinoMeshes = []\n    for obj in bpy.data.objects:\n        if (obj.type == 'MESH'):\n            mesh = obj.data\n            \n            rhinoMesh = rhino3dm.Mesh()\n            \n            for v in mesh.vertices:\n                c = obj.matrix_world @ v.co\n                rhinoMesh.Vertices.Add(c.x, c.y, c.z)\n            \n            for p in mesh.polygons:           \n                face = []\n                for v in (p.vertices):\n                    face.append(v)\n                if len(face) == 3:\n                    rhinoMesh.Faces.AddFace(face[0], face[1], face[2])\n                elif len(face) == 4:\n                    rhinoMesh.Faces.AddFace(face[0], face[1], face[2], face[3])\n                    \n            \n            rhinoMeshes.append(rhinoMesh)\n\n    stringList = []\n    for m in rhinoMeshes:\n        stringList.append(json.dumps(rhino3dm.CommonObject.Encode(m)))\n        \n    \n    \n\n    frame = bpy.data.scenes[0].frame_current\n\n    with open(\"{0}\\\\{1}.json\".format(directory, frame), \"w\") as f:\n        f.write(json.dumps(stringList))\n    \n    \ndef export_scene(rootDir, folderName):\n    path = os.path.join(rootDir, folderName)\n    os.mkdir(path)\n    \n    scene = bpy.context.scene\n    for f in range(scene.frame_start, scene.frame_end + 1):\n        bpy.context.scene.frame_set(f)\n        export_frame(f, path)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('sim_path', metavar='P', type=str, help='Path to the simulation JSON', nargs=\"?\")\n    parser.add_argument('steps', metavar='s', type=str, help='Simulation steps per second', nargs=\"?\")\n    parser.add_argument('start', metavar='S', type=str, help='Simulation start frame', nargs=\"?\")\n    parser.add_argument('end', metavar='E', type=str, help='Simulation end frame', nargs=\"?\")\n    parser.add_argument('root', metavar='R', type=str, help='Root folder for exported meshes', nargs=\"?\")\n    parser.add_argument('folder_name', metavar='F', type=str, help='Destination folder for exported meshes', nargs=\"?\")\n\n    args = parser.parse_args()\n\n    a = {\n        \"sim_path\": args.sim_path,\n        \"steps\" : args.steps,\n        \"start\" : args.start,\n        \"end\" : args.end,\n        \"root\" : args.root,\n        \"folder_name\" : args.folder_name\n        }\n\n    pprint(a)\n    \n    load_simulation(args.sim_path, int(args.steps), int(args.start), int(args.end))\n    export_scene(args.root, args.folder_name)\n\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}