{
  "source_url": "https://github.com/PeHaash/PerspectiveProjection/blob/b5154dd9d7eefc0c90820d3a328b3b553b5fd8ff/Python/Sourcecode.py",
  "repo": "PeHaash/PerspectiveProjection",
  "repo_stars": 1,
  "repo_description": "A personal project to create manual perspective projections in Rhino3D with the help of Grasshopper, Implemented in Python and C#",
  "license": "unknown",
  "filepath": "Python/Sourcecode.py",
  "instruction": "Sourcecode",
  "code": "import ghpythonlib.components as gh\r\nfrom math import sqrt\r\n\r\nif False:\r\n    ACTIVATE = \"\"\r\n\r\n    # two point perspective\r\n    P2_ACTIVATE = \"\"\r\n    P2_PROJECTION_CENTER = \"\"\r\n    P2_PROJECTION_WIDTH = \"\"\r\n    P2_PROJECTION_HEIGHT = \"\"\r\n    P2_PLANE = \"\"\r\n    P2_EYE_HEIGHT = \"\"\r\n\r\n    # three point perspective\r\n    P3_ACTIVATE = \"\"\r\n    P3_GEOMETRIC_POINTS = \"\"\r\n    P3_PROJECTED_POINTS = \"\"\r\n    P3_PERSPECTIVE_FACTORS = \"\"\r\n\r\n    # fish eye perspective\r\n    FE_ACTIVATE = \"\"\r\n    FE_EYE = \"\"\r\n    FE_TARGET = \"\"\r\n    FE_DESTINATION_CENTER = \"\"\r\n    FE_DESTINATION_RADIUS = \"\"\r\n\r\n    # projection variables\r\n    MESH_DEFAULT_COLOR = \"\"\r\n    TOLERANCE = \"\"\r\n\r\n    # input data\r\n    POINTS = \"\"\r\n    POLYLINES = \"\"\r\n    MESHES = \"\"\r\n\r\n    # output data\r\n    OUTPUT_POINTS = \"\"\r\n    OUTPUT_POLYLINES = \"\"\r\n    OUTPUT_MESHES = \"\"\r\n\r\n\r\ndef Flatten(list_of_lists):\r\n    if len(list_of_lists) == 0:\r\n        return list_of_lists\r\n    if isinstance(list_of_lists[0], list):\r\n        return Flatten(list_of_lists[0]) + Flatten(list_of_lists[1:])\r\n    return list_of_lists[:1] + Flatten(list_of_lists[1:])\r\n\r\n\r\nclass point_temp(object):\r\n    def __init__(self, x, y):\r\n        self.X = x\r\n        self.Y = y\r\n\r\n\r\ndef Middle(p1, p2, t2=1, t1=1):\r\n    return point_temp((p1.X * t1 + p2.X * t2) / (t1 + t2), (p1.Y * t1 + p2.Y * t2) / (t1 + t2))\r\n\r\n\r\ndef Intersection4Points(p1, p2, p3, p4):  # point in intersections of line(p1,p2)--line(p3,p4)\r\n    point = point_temp(0, 0)\r\n    dist = (p1.X - p2.X) * (p3.Y - p4.Y) - (p1.Y - p2.Y) * (p3.X - p4.X)\r\n    point.X = ((p1.X * p2.Y - p1.Y * p2.X) * (p3.X - p4.X) - (p1.X - p2.X) * (p3.X * p4.Y - p3.Y * p4.X)) / dist\r\n    point.Y = ((p1.X * p2.Y - p1.Y * p2.X) * (p3.Y - p4.Y) - (p1.Y - p2.Y) * (p3.X * p4.Y - p3.Y * p4.X)) / dist\r\n    return point\r\n\r\n\r\nclass TwoPointPerspective:\r\n    def __init__(self, plane, eye_height, p_center, p_width, p_height):\r\n\r\n        if eye_height == 0:\r\n            raise ArithmeticError\r\n        self.Plane = plane\r\n        self.EyeHeight = eye_height\r\n        self.HorizonY = p_center.Y\r\n        horizon_vector = gh.VectorXYZ(p_width, 0, 0)[0]\r\n        n_sign = (-1 if eye_height > 0 else 1)\r\n        self.PointO = gh.Move(p_center, gh.VectorXYZ(0, n_sign * p_height, 0)[0])[0]\r\n        self.vpLeft = gh.Move(p_center, -horizon_vector)[0]\r\n        self.vpRight = gh.Move(p_center, horizon_vector)[0]\r\n        self.horizon_line = gh.Line(self.vpRight, self.vpLeft)\r\n\r\n        point_1 = gh.Move(p_center, gh.VectorXYZ(-1, -n_sign * 2, 0)[0])[0]\r\n        point_2 = gh.Move(p_center, gh.VectorXYZ(1, -n_sign * 2, 0)[0])[0]\r\n\r\n        point_r = Intersection4Points(self.PointO, self.vpRight, p_center, point_1)\r\n        point_l = Intersection4Points(self.PointO, self.vpLeft, p_center, point_2)\r\n\r\n        self.ModuleLenght = abs(eye_height) / sqrt(2)\r\n        self.PointL = gh.ConstructPoint(point_l.X, point_l.Y, 0)\r\n        self.PointR = gh.ConstructPoint(point_r.X, point_r.Y, 0)\r\n\r\n    def Project(self, point):\r\n        X, Y, Z = gh.PlaneCoordinates(point, self.Plane)\r\n        x = X / self.ModuleLenght\r\n        y = Y / self.ModuleLenght\r\n        x_on_module = Middle(self.PointL, self.PointR, x, (1 - x))\r\n        y_on_module = Middle(self.PointR, self.PointL, y, (1 - y))\r\n        base = Intersection4Points(self.vpRight, y_on_module, self.vpLeft, x_on_module)\r\n        y_final = (Z * (self.HorizonY - base.Y) / self.EyeHeight) + base.Y\r\n        return gh.ConstructPoint(base.X, y_final, -(X * X + Y * Y + Z * Z))\r\n\r\n\r\nclass ThreePointPerspective:\r\n    def __init__(self, geometric_points, projected_points, perspective_factors):\r\n        geo_o, geo_x, geo_y, geo_z = geometric_points\r\n        pro_o, pro_x, pro_y, pro_z = projected_points\r\n        fact_x, fact_y, fact_z = perspective_factors\r\n\r\n        v_x = gh.Vector2Pt(geo_o, geo_x, False)[0]\r\n        v_y = gh.Vector2Pt(geo_o, geo_y, False)[0]\r\n        v_z = gh.Vector2Pt(geo_o, geo_z, False)[0]\r\n\r\n        matrix = gh.ConstructMatrix(3, 3, [v_x.X, v_y.X, v_z.X,\r\n                                           v_x.Y, v_y.Y, v_z.Y,\r\n                                           v_x.Z, v_y.Z, v_z.Z])\r\n\r\n        inverted_matrix, is_success = gh.InvertMatrix(matrix, 0)\r\n        if not is_success:\r\n            raise ArithmeticError\r\n\r\n        self.Matrix = inverted_matrix\r\n        self.PointO = geo_o\r\n        self.BoxO, self.BoxX, self.BoxY, self.BoxZ = pro_o, pro_x, pro_y, pro_z\r\n\r\n        self.PersPoX = gh.Move(pro_o, gh.Vector2Pt(pro_o, pro_x, False)[0] * fact_x)[0]\r\n        self.PersPoY = gh.Move(pro_o, gh.Vector2Pt(pro_o, pro_y, False)[0] * fact_y)[0]\r\n        self.PersPoZ = gh.Move(pro_o, gh.Vector2Pt(pro_o, pro_z, False)[0] * fact_z)[0]\r\n\r\n    def Project(self, point):\r\n        position = gh.Vector2Pt(self.PointO, point, False)[0]\r\n        X, Y, Z = gh.DeconstructMatrix(gh.Multiplication(self.Matrix, position))[2]\r\n        x_on_triangle = Middle(self.BoxY, self.BoxX, X, (1 - X))\r\n        y_on_triangle = Middle(self.BoxZ, self.BoxY, Y, (1 - Y))\r\n        z_on_triangle = Middle(self.BoxX, self.BoxZ, Z, (1 - Z))\r\n        x_on_axis = Intersection4Points(self.BoxO, self.PersPoX, self.PersPoY, x_on_triangle)\r\n        y_on_axis = Intersection4Points(self.BoxO, self.PersPoY, self.PersPoZ, y_on_triangle)\r\n        z_on_axis = Intersection4Points(self.BoxO, self.PersPoZ, self.PersPoX, z_on_triangle)\r\n        intersec1 = Intersection4Points(self.PersPoZ, x_on_axis, self.PersPoX, z_on_axis)\r\n        intersec2 = Intersection4Points(self.PersPoZ, y_on_axis, self.PersPoY, z_on_axis)\r\n        projected_point = Intersection4Points(intersec1, self.PersPoY, intersec2, self.PersPoX)\r\n        return gh.ConstructPoint(projected_point.X, projected_point.Y, -(X * X + Y * Y + Z * Z))\r\n\r\n\r\nclass FishEyePerspective:\r\n    def __init__(self, eye, target, destination_center, destination_radius):\r\n        self.X0, self.Y0, self.Z0 = gh.Deconstruct(destination_center)\r\n        self.Radius = destination_radius\r\n        self.Plane = self.MakePlane(eye, target)\r\n\r\n    def MakePlane(self, eye, target):\r\n        vector_1 = gh.Vector2Pt(eye, target, True)[0]\r\n        if vector_1.X == 0 and vector_1.Y == 0:\r\n            # is looking at sky\r\n            plane_temp = gh.XYPlane(eye)\r\n            if eye.Z < target.Z:\r\n                plane_temp = gh.FlipPlane(plane_temp, False, False, True)\r\n            return plane_temp  # -gh.XYPlane(eye)  # if eye.Z < target.Z else gh.XYPlane(eye)\r\n        vector_2 = gh.CrossProduct(vector_1, gh.UnitZ(1), False)[0]\r\n        plane_temp = gh.ConstructPlane(eye, vector_1, vector_2)\r\n        plane_temp = gh.AdjustPlane(plane_temp, vector_1)\r\n        plane_final = gh.FlipPlane(plane_temp, False, False, True)\r\n        return plane_final\r\n\r\n    def Project(self, point):\r\n        x, y, z = gh.PlaneCoordinates(point, self.Plane)\r\n        dis = sqrt(x * x + y * y + z * z)\r\n        proj_x = x / dis * self.Radius\r\n        proj_y = y / dis * self.Radius\r\n        if z > 0:\r\n            dist_to_cent = sqrt(proj_x * proj_x + proj_y * proj_y)\r\n            return gh.ConstructPoint(self.X0 + proj_x * self.Radius / dist_to_cent,\r\n                                     self.Y0 + proj_y * self.Radius / dist_to_cent, self.Z0 - dis)\r\n        return gh.ConstructPoint(self.X0 + proj_x, self.Y0 + proj_y, self.Z0 - dis)\r\n\r\n\r\ndef ProjectSegment(segment, perspective_system, tolerance):\r\n    open_or_closed = gh.Closed(segment)[0]\r\n    divide_number = gh.Length(segment) // tolerance + 1\r\n    points = gh.DivideCurve(segment, divide_number, False)[0]\r\n    return gh.PolyLine([perspective_system.Project(point) for point in points], open_or_closed)\r\n\r\n\r\ndef ProjectPolyline(polyline, perspective_system, tolerance):\r\n    segments = gh.Explode(polyline, True)[0]\r\n    if not isinstance(segments, list):\r\n        segments = [segments]\r\n    return (gh.JoinCurves([ProjectSegment(seg, perspective_system, tolerance) for seg in segments], False))\r\n\r\n\r\ndef ProjectMesh(mesh, perspective_system, default_color):\r\n    vertices, faces, colors, normals = gh.DeconstructMesh(mesh)\r\n    if colors is None:\r\n        colors = default_color\r\n    return gh.ConstructMesh([perspective_system.Project(vertex) for vertex in vertices], faces, colors)\r\n\r\n\r\nif ACTIVATE:\r\n    perspective_systems = []\r\n    if P2_ACTIVATE:\r\n        try:\r\n            pers2p = TwoPointPerspective(P2_PLANE, P2_EYE_HEIGHT, P2_PROJECTION_CENTER, P2_PROJECTION_WIDTH, P2_PROJECTION_HEIGHT)\r\n            perspective_systems.append(pers2p)\r\n        except ArithmeticError:\r\n            print(\"Error: P2_EYE_HEIGHT cannot be zero\")\r\n    if P3_ACTIVATE:\r\n        try:\r\n            pers3p = ThreePointPerspective(P3_GEOMETRIC_POINTS, P3_PROJECTED_POINTS, P3_PERSPECTIVE_FACTORS)\r\n            perspective_systems.append(pers3p)\r\n        except ArithmeticError:\r\n            print(\"Error: Cannot Invert the Matrix: problem with P3_GEOMETRIC_POINTS\")\r\n    if FE_ACTIVATE:\r\n        pers5p = FishEyePerspective(FE_EYE, FE_TARGET, FE_DESTINATION_CENTER, FE_DESTINATION_RADIUS)\r\n        perspective_systems.append(pers5p)\r\n\r\n    OUTPUT_POINTS = []\r\n    OUTPUT_POLYLINES = []\r\n    OUTPUT_MESHES = []\r\n    for system in perspective_systems:\r\n        OUTPUT_POINTS.extend([system.Project(point) for point in POINTS])\r\n        OUTPUT_POLYLINES.extend(Flatten([ProjectPolyline(polyline, system, TOLERANCE) for polyline in POLYLINES]))\r\n        OUTPUT_MESHES.extend([ProjectMesh(mesh, system, MESH_DEFAULT_COLOR) for mesh in MESHES])\r\n",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": false
}