{
  "source_url": "https://github.com/compas-dev/compas/blob/HEAD/src/compas_rhino/geometry/surfaces/nurbs.py",
  "repo": "compas-dev/compas",
  "repo_stars": 352,
  "repo_description": "Main library of the COMPAS framework and CAD integrations for Rhino/GH and Blender.",
  "license": "MIT",
  "filepath": "src/compas_rhino/geometry/surfaces/nurbs.py",
  "instruction": null,
  "code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom itertools import groupby\n\nimport Rhino.Geometry  # type: ignore\n\nfrom compas.geometry import NurbsSurface\nfrom compas.geometry import knots_and_mults_to_knotvector\nfrom compas.itertools import flatten\nfrom compas_rhino.conversions import cylinder_to_rhino\nfrom compas_rhino.conversions import frame_to_rhino_plane\nfrom compas_rhino.conversions import plane_to_rhino\nfrom compas_rhino.conversions import point_to_compas\nfrom compas_rhino.conversions import point_to_rhino\nfrom compas_rhino.conversions import sphere_to_rhino\n\nfrom .surface import RhinoSurface\n\n\nclass ControlPoints(object):\n    def __init__(self, surface):\n        self.native_surface = surface\n\n    @property\n    def points(self):\n        points = []\n        for i in range(self.native_surface.Points.CountU):\n            row = []\n            for j in range(self.native_surface.Points.CountV):\n                row.append(point_to_compas(self.native_surface.Points.GetControlPoint(i, j).Location))\n            points.append(row)\n        return points\n\n    def __getitem__(self, index):\n        try:\n            u, v = index\n        except TypeError:\n            return self.points[index]\n        else:\n            point = self.native_surface.Points.GetControlPoint(u, v).Location\n            return point_to_compas(point)\n\n    def __setitem__(self, index, point):\n        u, v = index\n        self.native_surface.Points.SetControlPoint(u, v, Rhino.Geometry.ControlPoint(point_to_rhino(point)))\n\n    def __len__(self):\n        return self.native_surface.Points.CountU\n\n    def __iter__(self):\n        return iter(self.points)\n\n\ndef native_surface_from_parameters(\n    points,\n    weights,\n    knots_u,\n    knots_v,\n    mults_u,\n    mults_v,\n    degree_u,\n    degree_v,\n    is_periodic_u=False,\n    is_periodic_v=False,\n):\n    order_u = degree_u + 1\n    order_v = degree_v + 1\n    pointcount_u = len(points)\n    pointcount_v = len(points[0])\n    is_rational = any(weight != 1.0 for weight in flatten(weights))\n    dimensions = 3\n\n    native_surface = Rhino.Geometry.NurbsSurface.Create(\n        dimensions,\n        is_rational,\n        order_u,\n        order_v,\n        pointcount_u,\n        pointcount_v,\n    )\n\n    if not native_surface:\n        message = \"dimensions: {} is_rational: {} order_u: {} order_v: {} u_points: {} v_points: {}\".format(\n            dimensions,\n            is_rational,\n            order_u,\n            order_v,\n            pointcount_u,\n            pointcount_v,\n        )\n        raise ValueError(\"Failed to create NurbsSurface with params:\\n{}\".format(message))\n\n    knotvector_u = knots_and_mults_to_knotvector(knots_u, mults_u)\n    knotvector_v = knots_and_mults_to_knotvector(knots_v, mults_v)\n    # account for superfluous knots\n    # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n    if len(knotvector_u) == pointcount_u + order_u:\n        knotvector_u[:] = knotvector_u[1:-1]\n    if len(knotvector_v) == pointcount_v + order_v:\n        knotvector_v[:] = knotvector_v[1:-1]\n    # add knots\n    for index, knot in enumerate(knotvector_u):\n        native_surface.KnotsU[index] = knot\n    for index, knot in enumerate(knotvector_v):\n        native_surface.KnotsV[index] = knot\n    # add control points\n    for i in range(pointcount_u):\n        for j in range(pointcount_v):\n            native_surface.Points.SetPoint(i, j, point_to_rhino(points[i][j]), weights[i][j])\n    return native_surface\n\n\nclass RhinoNurbsSurface(RhinoSurface, NurbsSurface):\n    \"\"\"Class representing a NURBS surface.\n\n    Attributes\n    ----------\n    points: list[list[:class:`compas.geometry.Point`]]\n        The control points of the surface.\n    weights: list[list[float]]\n        The weights of the control points.\n    knots_u: list[float]\n        The knot vector, in the U direction, without duplicates.\n    knots_v: list[float]\n        The knot vector, in the V direction, without duplicates.\n    mults_u: list[int]\n        The multiplicities of the knots in the knot vector of the U direction.\n    mults_v: list[int]\n        The multiplicities of the knots in the knot vector of the V direction.\n    degree_u: int\n        The degree of the polynomials in the U direction.\n    degree_v: int\n        The degree of the polynomials in the V direction.\n\n    \"\"\"\n\n    # ==============================================================================\n    # Data\n    # ==============================================================================\n\n    @property\n    def __data__(self):\n        # add superfluous knots\n        # for compatibility with all/most other NURBS implementations\n        # https://developer.rhino3d.com/guides/opennurbs/superfluous-knots/\n        mults_u = self.mults_u[:]  # type: ignore\n        mults_v = self.mults_v[:]  # type: ignore\n        mults_u[0] += 1\n        mults_u[-1] += 1\n        mults_v[0] += 1\n        mults_v[-1] += 1\n        return {\n            \"points\": [[point.__data__ for point in row] for row in self.points],  # type: ignore\n            \"weights\": self.weights,\n            \"knots_u\": self.knots_u,\n            \"knots_v\": self.knots_v,\n            \"mults_u\": mults_u,\n            \"mults_v\": mults_v,\n            \"degree_u\": self.degree_u,\n            \"degree_v\": self.degree_v,\n            \"is_periodic_u\": self.is_periodic_u,\n            \"is_periodic_v\": self.is_periodic_v,\n        }\n\n    # ==============================================================================\n    # Properties\n    # ==============================================================================\n\n    @property\n    def points(self):\n        if self.native_surface:\n            if not hasattr(self, \"_points\"):\n                self._points = ControlPoints(self.native_surface)\n            return self._points\n\n    @property\n    def weights(self):\n        if self.native_surface:\n            weights = []\n            for i in range(self.native_surface.Points.CountU):\n                row = []\n                for j in range(self.native_surface.Points.CountV):\n                    row.append(self.native_surface.Points.GetWeight(i, j))\n                weights.append(row)\n            return weights\n\n    @property\n    def knots_u(self):\n        if self.native_surface:\n            return [key for key, _ in groupby(self.native_surface.KnotsU)]\n\n    @property\n    def mults_u(self):\n        if self.native_surface:\n            return [len(list(group)) for _, group in groupby(self.native_surface.KnotsU)]\n\n    @property\n    def knotvector_u(self):\n        if self.native_surface:\n            return list(self.native_surface.KnotsU)\n\n    @property\n    def knots_v(self):\n        if self.native_surface:\n            return [key for key, _ in groupby(self.native_surface.KnotsV)]\n\n    @property\n    def mults_v(self):\n        if self.native_surface:\n            return [len(list(group)) for _, group in groupby(self.native_surface.KnotsV)]\n\n    @property\n    def knotvector_v(self):\n        if self.native_surface:\n            return list(self.native_surface.KnotsV)\n\n    @property\n    def degree_u(self):\n        if self.native_surface:\n            return self.native_surface.Degree(0)\n\n    @property\n    def degree_v(self):\n        if self.native_surface:\n            return self.native_surface.Degree(1)\n\n    # ==============================================================================\n    # Constructors\n    # ==============================================================================\n\n    @classmethod\n    def from_corners(cls, corners):\n        \"\"\"Creates a NURBS surface using the given 4 corners.\n\n        The order of the given points determins the normal direction of the generated surface.\n\n        Parameters\n        ----------\n        corners : list(:class:`compas.geometry.Point`)\n            4 points in 3d space to represent the corners of the planar surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        rhino_points = [Rhino.Geometry.Point3d(corner.x, corner.y, corner.z) for corner in corners]\n        return cls.from_native(Rhino.Geometry.NurbsSurface.CreateFromCorners(*rhino_points))\n\n    @classmethod\n    def from_cylinder(cls, cylinder):\n        \"\"\"Create a NURBS surface from a cylinder.\n\n        Parameters\n        ----------\n        cylinder : :class:`compas.geometry.Cylinder`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        cylinder = cylinder_to_rhino(cylinder)\n        surface = Rhino.Geometry.NurbsSurface.CreateFromCylinder(cylinder)\n        return cls.from_native(surface)\n\n    @classmethod\n    def from_fill(cls, curve1, curve2):\n        \"\"\"Construct a NURBS surface from the infill between two NURBS curves.\n\n        Parameters\n        ----------\n        curve1 : :class:`compas.geometry.NurbsCurve`\n        curve2 : :class:`compas.geometry.NurbsCurve`\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        native_surface = Rhino.Geometry.NurbsSurface.CreateRuledSurface(curve1, curve2)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_frame(cls, frame, domain_u=(0, 1), domain_v=(0, 1), degree_u=1, degree_v=1, pointcount_u=2, pointcount_v=2):\n        \"\"\"Creates a planar surface from a frame and parametric domain information.\n\n        Parameters\n        ----------\n        frame : :class:`compas.geometry.Frame`\n            A frame with point at the center of the wanted plannar surface and\n            x and y axes the direction of u and v respectively.\n        domain_u : tuple[int, int], optional\n            The domain of the U parameter.\n        domain_v : tuple[int, int], optional\n            The domain of the V parameter.\n        degree_u : int, optional\n            Degree in the U direction.\n        degree_v : int, optional\n            Degree in the V direction.\n        pointcount_u : int, optional\n            Number of control points in the U direction.\n        pointcount_v : int, optional\n            Number of control points in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        plane = frame_to_rhino_plane(frame)\n        du = Rhino.Geometry.Interval(*domain_u)\n        dv = Rhino.Geometry.Interval(*domain_v)\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPlane(plane, du, dv, degree_u, degree_v, pointcount_u, pointcount_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_native(cls, native_surface):\n        \"\"\"Construct a NURBS surface from an existing Rhino surface.\n\n        Parameters\n        ----------\n        native_surface : :rhino:`Rhino.Geometry.Surface`\n            A Rhino surface.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        return cls(native_surface)\n\n    @classmethod\n    def from_parameters(\n        cls,\n        points,\n        weights,\n        knots_u,\n        knots_v,\n        mults_u,\n        mults_v,\n        degree_u,\n        degree_v,\n        is_periodic_u=False,\n        is_periodic_v=False,\n    ):\n        \"\"\"Construct a NURBS surface from explicit parameters.\n\n        Parameters\n        ----------\n        points : list[list[:class:`compas.geometry.Point`]]\n            The control points.\n        weights : list[list[float]]\n            The weights of the control points.\n        knots_u : list[float]\n            The knots in the U direction, without multiplicity.\n        knots_v : list[float]\n            The knots in the V direction, without multiplicity.\n        mults_u : list[int]\n            Multiplicity of the knots in the U direction.\n        mults_v : list[int]\n            Multiplicity of the knots in the V direction.\n        degree_u : int\n            Degree in the U direction.\n        degree_v : int\n            Degree in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        native_surface = native_surface_from_parameters(points, weights, knots_u, knots_v, mults_u, mults_v, degree_u, degree_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_plane(cls, plane, domain_u=(0, 1), domain_v=(0, 1), degree_u=1, degree_v=1, pointcount_u=2, pointcount_v=2):\n        \"\"\"Construct a surface from a plane.\n\n        Parameters\n        ----------\n        plane : :class:`compas.geometry.Plane`\n            The plane.\n        domain_u : tuple[int, int], optional\n            The domain of the U parameter.\n        domain_v : tuple[int, int], optional\n            The domain of the V parameter.\n        degree_u : int, optional\n            Degree in the U direction.\n        degree_v : int, optional\n            Degree in the V direction.\n        pointcount_u : int, optional\n            Number of control points in the U direction.\n        pointcount_v : int, optional\n            Number of control points in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        plane = plane_to_rhino(plane)\n        du = Rhino.Geometry.Interval(*domain_u)\n        dv = Rhino.Geometry.Interval(*domain_v)\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPlane(plane, du, dv, degree_u, degree_v, pointcount_u, pointcount_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_points(cls, points, degree_u=3, degree_v=3):\n        \"\"\"Construct a NURBS surface from control points.\n\n        Parameters\n        ----------\n        points : list[list[:class:`compas.geometry.Point`]]\n            The control points.\n        degree_u : int\n            Degree in the U direction.\n        degree_v : int\n            Degree in the V direction.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        # this of course depends on the order in which the points are given.\n        # with the current convention this should not be needed.\n        points = list(zip(*points))\n\n        pointcount_u = len(points)\n        pointcount_v = len(points[0])\n        points[:] = [point_to_rhino(point) for row in points for point in row]\n        native_surface = Rhino.Geometry.NurbsSurface.CreateFromPoints(points, pointcount_u, pointcount_v, degree_u, degree_v)\n        return cls.from_native(native_surface)\n\n    @classmethod\n    def from_sphere(cls, sphere):\n        \"\"\"Creates a NURBS surface from a sphere.\n\n        Parameters\n        ----------\n        sphere : :class:`compas.geometry.Sphere`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        sphere = sphere_to_rhino(sphere)\n        surface = Rhino.Geometry.NurbsSurface.CreateFromSphere(sphere)\n        return cls.from_native(surface)\n\n    @classmethod\n    def from_torus(cls, torus):\n        \"\"\"Create a NURBS surface from a torus.\n\n        Parameters\n        ----------\n        torus : :class:`compas.geometry.Torus`\n            The surface's geometry.\n\n        Returns\n        -------\n        :class:`compas_rhino.geometry.RhinoNurbsSurface`\n\n        \"\"\"\n        raise NotImplementedError\n\n    # ==============================================================================\n    # Conversions\n    # ==============================================================================\n\n    # ==============================================================================\n    # Methods\n    # ==============================================================================\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}