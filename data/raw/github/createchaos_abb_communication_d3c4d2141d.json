{
  "source_url": "https://github.com/createchaos/abb_communication/blob/740ea3c6bf93b9b0d03e63a6d56ee8ad748e4e38/src/abb_communication/geometry/vector.py",
  "repo": "createchaos/abb_communication",
  "repo_stars": 3,
  "repo_description": "communication library for abb robot control",
  "license": "NOASSERTION",
  "filepath": "src/abb_communication/geometry/vector.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << ><...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . . \n.                                         .\n.   <<      ><  <<      ><  <<  <<><><>   .\n.   < ><   ><<  < ><   ><<  <<  <<        .\n.   << >< > ><  << >< > ><  <<  <<><><>   .  \n.   <<  ><  ><  <<  ><  ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.   <<      ><  <<      ><  <<  <<        .\n.                                         .\n.             GKR 2016/17                 .\n. . . . . . . . . . . . . . . . . . . . . .\n\nCreated on 02.11.2016\n\n@author: kathrind\n'''\n\nimport math\nfrom mas_lib.useful import clamp\nimport Rhino.Geometry as rg\n\ndef get_vector_sum(vectors):\n    ''' returns the sum up all vectors'''\n    return reduce(lambda x, y: x + y, vectors)\n\ndef get_vector_sum_Vector3d(vectors):\n    ''' returns the sum up all vectors'''\n    return rg.Vector3d(reduce(lambda x, y: x + y, vectors))\n\ndef angle_between_vectors(v1, v2):\n    v1u = rg.Vector3d(v1.X, v1.Y, v1.Z)\n    v2u = rg.Vector3d(v2.X, v2.Y, v2.Z)\n    v1u.Unitize()\n    v2u.Unitize()\n    dot = v1u * v2u\n    dot = clamp(dot, -1.0, 1.0)\n    radians = math.acos(dot)\n    return radians\n    \ndef signed_angle_between_vectors(v1, v2, normal=None):\n    '''Returns the signed angle between vectors, but only if you give a normal.'''\n    v1u = rg.Vector3d(v1.X, v1.Y, v1.Z)\n    v2u = rg.Vector3d(v2.X, v2.Y, v2.Z)\n    v1u.Unitize()\n    v2u.Unitize()\n    dot = v1u * v2u\n    dot = clamp(dot, -1.0, 1.0)\n    radians = math.acos(dot)\n    if not normal:\n        return radians\n    else:\n        # check weather positive or negative\n        v1u.Rotate(radians, normal) # now v1u must be v2u\n        d = (v1u - v2u).Length\n        if d < 0.01:\n            return radians\n        else:\n            v1u.Rotate(- 2 *radians, normal)\n            return -radians\n    \ndef project_point_onto_line(point, lineA, lineB):\n    s = lineA - lineB\n    v = point - lineA\n    pproj = lineA + s * (v * s)/(s * s) \n    return pproj\n\ndef get_fillet_radius_by_distance(start_pt, corner_pt, end_pt, distance):\n    ''' Returns the radius for a fillet curve in a corner with distance \n    between corner point and tangent point. '''\n    alpha = angle_between_vectors(start_pt - corner_pt, end_pt - corner_pt)\n    beta = math.pi/2 - alpha/2\n    radius = distance/math.sin(beta) * math.sin(alpha/2)\n    return radius\n\n\nif __name__ == \"__main__\":\n    print \"hello\"",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}