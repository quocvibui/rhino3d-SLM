{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/core/dc_xform.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/core/dc_xform.py",
  "instruction": "Dc xform",
  "code": "from decodes.core import *\nfrom . import dc_base, dc_vec, dc_point, dc_cs, dc_line, dc_mesh, dc_pgon\n\n\nif VERBOSE_FS: print(\"xform.py loaded\")\n\nclass Xform(object):\n    \"\"\"\n        A transformation matrix class.\n    \"\"\"\n    def __init__(self,matrix=None):\n        \"\"\"XForm Constructor\n            \n            :param matrix: Matrix\n            :type matrix: list\n            :result: XForm object.\n            :rtype: XForm\n        \"\"\"\n        if matrix is not None :\n            self._m = matrix\n        else :\n            self._m = [0.0]*16\n            self.c11 = 1.0\n            self.c22 = 1.0\n            self.c33 = 1.0\n            self.c44 = 1.0\n            \n    def __repr__(self):\n        return ( \"xform\\t[{},{},{},{}]\".format(self.c11,self.c12,self.c13,self.c14) +\n        \"\\n\\t\\t[{},{},{},{}]\".format(self.c21,self.c22,self.c23,self.c24) +\n        \"\\n\\t\\t[{},{},{},{}]\".format(self.c31,self.c32,self.c33,self.c34) +\n        \"\\n\\t\\t[{},{},{},{}]\".format(self.c41,self.c42,self.c43,self.c44) )\n    \n    def strip_translation(self):\n        m = list(self._m)\n        xf = Xform(matrix = m)\n        xf.c14 = 0\n        xf.c24 = 0\n        xf.c34 = 0\n        return xf\n    \n    @staticmethod\n    def translation(vec):\n        \"\"\"Translates an object by a given Vector.\n\n            :param vec: Vector to apply a translation.\n            :type vec: Vec\n            :result: Translates an object.\n            :rtype: Geometry\n        \"\"\"\n        xf = Xform()\n        xf.c14 = vec.x\n        xf.c24 = vec.y\n        xf.c34 = vec.z\n        return xf\n\n    @staticmethod\n    def scale(factor, origin=None):\n        \"\"\"Scales an object by a given factor.\n\n            :param factor: Factor to scale by.\n            :type factor: float\n            :result: Scaled object.\n            :rtype: Geometry\n        \"\"\"\n        if not origin:\n            xf = Xform()\n            xf.c11 = factor\n            xf.c22 = factor\n            xf.c33 = factor\n            return xf\n        else:\n            xf = Xform()\n            xf.c11 = factor\n            xf.c22 = factor\n            xf.c33 = factor\n\n            xf.c14 = (1-factor)*origin.x\n            xf.c24 = (1-factor)*origin.y\n            xf.c34 = (1-factor)*origin.z\n            return xf\n\n    @staticmethod\n    def mirror(plane=\"world_xy\"):\n        \"\"\"Produces mirror transform. Can pass in \"world_xy\", \"world_yz\", or \"world_xz\". Or, pass in an arbitrary cs (produces mirror about XYplane of CS).\n        \n            :param plane: Plane to mirror the object with. Defaults to world XY plane.\n            :type plane: Plane\n            :result: Mirrored object.\n            :rtype: Geometry\n            \n            .. warning:: When mirroring about an arbitrary plane, this method currently relies on access to the Rhinocommon Kernel.  It will not work in other contexts.\n            .. todo:: Re-implement this method without using the Rhinocommon Kernel.\n            \n        \"\"\"\n        #TODO: Re-implement this method without using the Rhinocommon Kernel\n        \n        xf = Xform()\n        \n        if isinstance(plane, str):\n            if plane==\"world_xy\" : xf.c33 *= -1\n            elif plane==\"world_xz\" : xf.c22 *= -1\n            elif plane==\"world_yz\" : xf.c11 *= -1\n            else: \n                raise NotImplementedError(\"Xform.mirror accepts only the following string values for 'plane':/n'world_xy','world_xz','world_yz'\")\n            return xf\n        \n        nx,ny,nz = plane._vec.x, plane._vec.y, plane._vec.z\n        origin = plane.origin\n        xf_plane = Xform()\n        xf_plane.m00 = 1-2*nx*nx\n        xf_plane.m01 = -2*nx*ny\n        xf_plane.m02 = -2*nx*nz\n        xf_plane.m10 = -2*nx*ny\n        xf_plane.m11 = 1-2*ny*ny\n        xf_plane.m12 = -2*ny*nz\n        xf_plane.m20 = -2*nx*nz\n        xf_plane.m21 = -2*ny*nz\n        xf_plane.m22 = 1-2*nz*nz\n        xf_o = Xform.translation(Vec(origin))\n        xf_minuso = Xform.translation(-Vec(origin))\n        return xf_o*xf_plane*xf_minuso           \n        \n        \"\"\"\n            if isinstance(plane, CS) : \n                #TODO: do this ourselves instead\n                import Rhino\n                from ..io.rhino_out import to_rgvec, to_rgpt\n                from ..io.rhino_in import from_rgtransform\n                rh_xform = Rhino.Geometry.Transform.Mirror(to_rgpt(plane.origin),to_rgvec(plane.zAxis))       \n                return from_rgtransform(rh_xform)\n        \n        raise NotImplementedError(\"Xform.mirror currently accepts the following values for 'plane':/n'world_xy','world_xz','world_yz'\")\n        \"\"\"\n        \n    @staticmethod\n    def rotation(**kargs):\n        \"\"\" Rotates an object around by a center and a rotation angle OR by a center, an axis and a rotation angle. \n            \n            :param \\**kargs: Function that accepts multiple parameters to be passed. Parameters include center and axis of rotation and a rotation angle. \n            :type \\**kargs: Point, Vec, float\n            :result: Rotated object.\n            :rtype: Geometry\n\n            .. warning:: This method currently relies on access to the Rhinocommon Kernel. It will not work in other contexts.            \n            \n        \"\"\"\n       # TODO:: Re-implement this method without using the Rhinocommon Kernel.\n\n       # TODO:: Rotation about an axis ought to take in a linear entity, not a vector.\n        \n        try:\n            try:\n                axis = kargs[\"axis\"].normalized()\n            except:\n                axis = Vec(0,0,1)\n\n            if \"angle\" in kargs and not \"center\" in kargs :\n                xf = Xform()\n                u,v,w = axis.x,axis.y,axis.z\n                uv,uw,vw = u*v,u*w,v*w\n                u2,v2,w2 = u**2,v**2,w**2\n                cost = math.cos(kargs[\"angle\"])\n                sint = math.sin(kargs[\"angle\"])\n\n                xf.c11 = u2+(1-u2)*cost\n                xf.c12 = uv*(1-cost)- w * sint\n                xf.c13 = uw*(1-cost)+ v * sint\n\n                xf.c21 = uv*(1-cost)+ w * sint\n                xf.c22 = v2+(1-v2) * cost\n                xf.c23 = vw*(1-cost)- u * sint\n\n                xf.c31 = uw*(1-cost)- v * sint\n                xf.c32 = vw*(1-cost)+ u * sint\n                xf.c33 = w2+(1-w2)*cost\n                return xf\n            else:\n                raise\n        except:\n            if all (k in kargs for k in (\"angle\",\"axis\",\"center\")) :\n                # rotation by center, rotation angle, and rotation axis\n                import Rhino\n                from ..io.rhino_out import to_rgvec, to_rgpt\n                from ..io.rhino_in import from_rgtransform\n                center = to_rgpt(kargs[\"center\"]) if \"center\" in kargs else to_rgpt(Point(0,0,0))\n                rh_xform = Rhino.Geometry.Transform.Rotation(kargs[\"angle\"],to_rgvec(kargs[\"axis\"]),center)\n            elif all (k in kargs for k in (\"center\",\"angle\")) :\n                # rotation by center and rotation angle\n                import Rhino\n                from ..io.rhino_out import to_rgvec, to_rgpt\n                from ..io.rhino_in import from_rgtransform\n                rh_xform = Rhino.Geometry.Transform.Rotation(kargs[\"angle\"],to_rgpt(kargs[\"center\"]))\n            else :\n                raise AttributeError(\"Could not construct a rotation transfer with these arguments\")\n            return from_rgtransform(rh_xform)\n            \n    @staticmethod\n    def change_basis(cs_src,cs_tar):\n        \"\"\" Changes the plane basis of an object.            \n            \n            :param cs_src: CS source of the object.\n            :type cs_src: CS\n            :param cs_tar: CS plane of the object.\n            :type cs_tar: CS\n            :result: Transformation Matrix.\n            :rtype: Xform\n            \n        \"\"\"\n        xg, yg, zg = Vec(1,0,0), Vec(0,1,0), Vec(0,0,1) # global coordinate basis vectors\n        xs, ys, zs = cs_src.x_axis, cs_src.y_axis, cs_src.z_axis\n        xt, yt, zt = cs_tar.x_axis, cs_tar.y_axis, cs_tar.z_axis\n        xf_gs = Xform(matrix=[xs.dot(xg),xs.dot(yg),xs.dot(zg),0,ys.dot(xg),ys.dot(yg),ys.dot(zg),0,zs.dot(xg),zs.dot(yg),zs.dot(zg),0,0,0,0,1])\n        xf_gs *= Xform.translation(-cs_src.origin) \n        xf_st = Xform(matrix=[xg.dot(xt),xg.dot(yt),xg.dot(zt),0,yg.dot(xt),yg.dot(yt),yg.dot(zt),0,zg.dot(xt),zg.dot(yt),zg.dot(zt),0,0,0,0,1])\n        return Xform.translation(cs_tar.origin)* (xf_st * xf_gs )\n    \n    def __mul__(self, other):\n        \"\"\"| Multiplies this Geometry by another Matrix, or by any piece of geometry.\n           | This function must be kept up to date with every new class of DC geom.\n            \n           :param other: Matrix to multiply or Geometry to transform.\n           :type other: object\n           :result: multiplied object\n           :rtype: object\n        \"\"\"\n        if isinstance(other, Xform) : \n            xf = Xform()\n            xf._m = [\n                self.c11 * other.c11 + self.c12 * other.c21 + self.c13 * other.c31 + self.c14 * other.c41,\n                self.c11 * other.c12 + self.c12 * other.c22 + self.c13 * other.c32 + self.c14 * other.c42,\n                self.c11 * other.c13 + self.c12 * other.c23 + self.c13 * other.c33 + self.c14 * other.c43,\n                self.c11 * other.c14 + self.c12 * other.c24 + self.c13 * other.c34 + self.c14 * other.c44,\n                self.c21 * other.c11 + self.c22 * other.c21 + self.c23 * other.c31 + self.c24 * other.c41,\n                self.c21 * other.c12 + self.c22 * other.c22 + self.c23 * other.c32 + self.c24 * other.c42,\n                self.c21 * other.c13 + self.c22 * other.c23 + self.c23 * other.c33 + self.c24 * other.c43,\n                self.c21 * other.c14 + self.c22 * other.c24 + self.c23 * other.c34 + self.c24 * other.c44,\n                self.c31 * other.c11 + self.c32 * other.c21 + self.c33 * other.c31 + self.c34 * other.c41,\n                self.c31 * other.c12 + self.c32 * other.c22 + self.c33 * other.c32 + self.c34 * other.c42,\n                self.c31 * other.c13 + self.c32 * other.c23 + self.c33 * other.c33 + self.c34 * other.c43,\n                self.c31 * other.c14 + self.c32 * other.c24 + self.c33 * other.c34 + self.c34 * other.c44,\n                self.c41 * other.c11 + self.c42 * other.c21 + self.c43 * other.c31 + self.c44 * other.c41,\n                self.c41 * other.c12 + self.c42 * other.c22 + self.c43 * other.c32 + self.c44 * other.c42,\n                self.c41 * other.c13 + self.c42 * other.c23 + self.c43 * other.c33 + self.c44 * other.c43,\n                self.c41 * other.c14 + self.c42 * other.c24 + self.c43 * other.c34 + self.c44 * other.c44,\n            ]\n            return xf\n        \n        return self.transform(other)\n        \n\n    def transform(self,other):\n        \"\"\"| Multiplies any appropriate piece of geometry by this XForm\n           | This function must be kept up to date with every new class of DC geom.\n            \n           :param other: geometry to transform.\n           :type other: Geometry\n           :result: multiplied object\n           :rtype: Geometry\n        \"\"\"\n        # HASPTS GEOMETRY\n        # applies transformation to the verts, leaving the basis intact\n        if isinstance(other, HasPts) : \n            #raise NotImplementedError(\"can't xform a haspts\")\n            other._verts = [v*self for v in other._verts]\n            return other\n            # TODO: deal with applying transformations to haspts geometry\n            \n\n        # BASED GEOMETRY\n        # all objects that are not HASPTS but are HASBASIS and have a basis defined and are capable of applying their basis... must do so before transforming points\n        # this condition only applies to Based Points at the moment, may apply to Tetrahedron class\n        # TODO: move this functionality down to Based Points\n        if isinstance(other, HasBasis) and (not other.is_baseless): \n            try:\n                o = other.basis_applied()\n                o.copy_props(other)\n                other = o\n            except:\n                pass\n        \n        if isinstance(other, LinearEntity) : \n            pt = other._pt*self\n            xf = self.strip_translation()\n            vec = other._vec*xf\n            if isinstance(other, Line) : return Line(pt,vec)\n            if isinstance(other, Ray) : return Ray(pt,vec)\n            if isinstance(other, Segment) : return Segment(pt,vec)\n            \n        if isinstance(other, CS) : \n            cs = other\n            tup = self._xform_tuple(cs.origin.to_tuple())\n            origin = Point(tup[0],tup[1],tup[2])\n            \n            xf = self.strip_translation()\n            tup = xf._xform_tuple(cs.x_axis.to_tuple())\n            x_axis = Vec(tup[0],tup[1],tup[2])\n            tup = xf._xform_tuple(cs.y_axis.to_tuple())\n            y_axis = Vec(tup[0],tup[1],tup[2])\n            \n            \n            ret = CS(origin, x_axis, y_axis)\n            ret.copy_props(other)\n            return ret\n        \n        if isinstance(other, Arc) : \n        \n            cs = other._basis\n            tup = self._xform_tuple(cs.origin.to_tuple())\n            origin = Point(tup[0],tup[1],tup[2])\n            xf = self.strip_translation()\n            tup = xf._xform_tuple(cs.x_axis.to_tuple())\n            x_axis = Vec(tup[0],tup[1],tup[2])\n            tup = xf._xform_tuple(cs.y_axis.to_tuple())\n            y_axis = Vec(tup[0],tup[1],tup[2])\n            \n            \n            ret = Arc(CS(origin, x_axis, y_axis),other.rad,other.angle)\n            ret.copy_props(other)\n            return ret\n        \n        if isinstance(other, Point) : \n            tup = self._xform_tuple(other.to_tuple())\n            pt = Point(tup[0],tup[1],tup[2])\n            pt.copy_props(other)\n            return pt\n        \n        if isinstance(other, Vec) : \n            tup = self._xform_tuple(other.to_tuple())\n            vec = Vec(tup[0],tup[1],tup[2])\n            vec.copy_props(other)\n            return vec\n        \n        if isinstance(other, Circle) :\n            pln = other.plane * self\n            cir = Circle(pln,other.rad)\n            cir.copy_props(other)\n            return cir \n        \n        if isinstance(other, Plane) : \n            pln = other\n            tup = self._xform_tuple(pln.origin.to_tuple())\n            origin = Point(tup[0],tup[1],tup[2])\n            \n            xf = self.strip_translation()\n            tup = xf._xform_tuple(pln.normal.to_tuple())\n            normal = Vec(tup[0],tup[1],tup[2]).normalized()\n            \n            pln = Plane(origin, normal)\n            pln.copy_props(other)\n            return pln\n\n        \n        raise NotImplementedError(\"can't xform an object of type {}\".format(type(other)))\n        \n        \n        \n    def _xform_tuple(self,tup):\n\n        return (\n            tup[0] * self._m[0] + tup[1] * self._m[1] + tup[2] * self._m[2]     + self._m[3],\n            tup[0] * self._m[4] + tup[1] * self._m[5] + tup[2] * self._m[6]     + self._m[7],\n            tup[0] * self._m[8] + tup[1] * self._m[9] + tup[2] * self._m[10]    + self._m[11]\n            )\n    \n    @property \n    def c11(self): return self._m[0]\n    @c11.setter\n    def c11(self,value): self._m[0] = value\n    @property\n    def c12(self): return self._m[1]\n    @c12.setter\n    def c12(self,value): self._m[1] = value\n    @property\n    def c13(self): return self._m[2]\n    @c13.setter\n    def c13(self,value): self._m[2] = value\n    @property\n    def c14(self):  return self._m[3]\n    @c14.setter\n    def c14(self,value): self._m[3] = value\n    \n    @property\n    def c21(self):  return self._m[4]\n    @c21.setter\n    def c21(self,value): self._m[4] = value\n    @property\n    def c22(self): return self._m[5]\n    @c22.setter\n    def c22(self,value): self._m[5] = value\n    @property\n    def c23(self): return self._m[6]\n    @c23.setter\n    def c23(self,value): self._m[6] = value\n    @property\n    def c24(self): return self._m[7]\n    @c24.setter\n    def c24(self,value): self._m[7] = value\n    \n    @property\n    def c31(self): return self._m[8]\n    @c31.setter\n    def c31(self,value): self._m[8] = value\n    @property\n    def c32(self): return self._m[9]\n    @c32.setter\n    def c32(self,value):  self._m[9] = value\n    @property\n    def c33(self):  return self._m[10]\n    @c33.setter\n    def c33(self,value): self._m[10] = value\n    @property\n    def c34(self): return self._m[11]\n    @c34.setter\n    def c34(self,value):  self._m[11] = value\n    \n    @property\n    def c41(self): return self._m[12]\n    @c41.setter\n    def c41(self,value): self._m[12] = value\n    @property\n    def c42(self): return self._m[13]\n    @c42.setter\n    def c42(self,value): self._m[13] = value\n    @property\n    def c43(self): return self._m[14]\n    @c43.setter\n    def c43(self,value): self._m[14] = value\n    @property\n    def c44(self): return self._m[15]\n    @c44.setter\n    def c44(self,value): self._m[15] = value        \n    \n    \n    \n    \n    \n    @property \n    def m00(self): return self._m[0]\n    @m00.setter\n    def m00(self,value): self._m[0] = value\n    @property\n    def m01(self): return self._m[1]\n    @m01.setter\n    def m01(self,value): self._m[1] = value\n    @property\n    def m02(self): return self._m[2]\n    @m02.setter\n    def m02(self,value): self._m[2] = value\n    @property\n    def m03(self):  return self._m[3]\n    @m03.setter\n    def m03(self,value): self._m[3] = value\n    \n    @property\n    def m10(self):  return self._m[4]\n    @m10.setter\n    def m10(self,value): self._m[4] = value\n    @property\n    def m11(self): return self._m[5]\n    @m11.setter\n    def m11(self,value): self._m[5] = value\n    @property\n    def m12(self): return self._m[6]\n    @m12.setter\n    def m12(self,value): self._m[6] = value\n    @property\n    def m13(self): return self._m[7]\n    @m13.setter\n    def m13(self,value): self._m[7] = value\n    \n    @property\n    def m20(self): return self._m[8]\n    @m20.setter\n    def m20(self,value): self._m[8] = value\n    @property\n    def m21(self): return self._m[9]\n    @m21.setter\n    def m21(self,value):  self._m[9] = value\n    @property\n    def m22(self):  return self._m[10]\n    @m22.setter\n    def m22(self,value): self._m[10] = value\n    @property\n    def m23(self): return self._m[11]\n    @m23.setter\n    def m23(self,value):  self._m[11] = value\n    \n    @property\n    def m30(self): return self._m[12]\n    @m30.setter\n    def m30(self,value): self._m[12] = value\n    @property\n    def m31(self): return self._m[13]\n    @m31.setter\n    def m31(self,value): self._m[13] = value\n    @property\n    def m32(self): return self._m[14]\n    @m32.setter\n    def m32(self,value): self._m[14] = value\n    @property\n    def m33(self): return self._m[15]\n    @m33.setter\n    def m33(self,value): self._m[15] = value    \n    \n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}