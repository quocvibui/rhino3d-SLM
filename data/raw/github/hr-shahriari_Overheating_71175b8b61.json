{
  "source_url": "https://github.com/hr-shahriari/Overheating/blob/330deab48b76a554c5971aa53cf7e3971a5c80ce/SAP_Standalone/SAP.py",
  "repo": "hr-shahriari/Overheating",
  "repo_stars": 2,
  "repo_description": "Providing custom GHpyhon plugins in order to calculate the risk of overheating in the early stages of design according to \"SAP 2012 Appendix\" and \"NTA 8800 TOjuli\" assessment methods",
  "license": "MIT",
  "filepath": "SAP_Standalone/SAP.py",
  "instruction": null,
  "code": "﻿\r\n\"\"\"Use this plugin to take any list of closed brep masses to calculate the risk of overheating. By Hamidreza Shahriari\r\n    Inputs:\r\n        North: A vector to represent the North direction. If not provided the default Y axis will be selected as North\r\n        Latitude: Latitude of the locatation of the building\r\n        masses: A list of closed Breps to perform the overheating study on the building masses\r\n        g_value: g_value of the windows\r\n        bld_type: Building type according to the SAP Table p1. The values: {\"single story dwelling with possibility of cross ventilation\" = 0 , \"single story dwelling cross ventilation not possible\" = 1, \"Dwelling of two or more storeys windows open upstairs and downstairs Cross ventilation possible\" = 2, \"Dwelling of two or more storeys windows open upstairs and downstairs Cross ventilation not possible\" =3} \r\n        solar_access: Percentage of Sky blocked by obstecles. {\"Heavy\" > 80, \"More than avarage\" >60 & <80, \"average or Unknown\" >20 & <60, \"very little\" <20} \r\n        U_window: Total U_value of the window system\r\n        U_wall : U_value of the walls.\r\n        WWR: Window to WAll Ratio\r\n        solar_flux: solar flux on the horizontal surface during the summer period\r\n        Roof: Set to True if there is roof\r\n        max_roof_angle: Maximum angle of the pitched roof\r\n        U_roof: U_value of the roof\r\n        overhangs: Overhang depth from the glass (in meter)\r\n        curt_blind: Selcet the type of blinds, curtains or external shutters to calculate the shading factor according to SAP table P3: {\"Net curtain (covering whole window)\" = 0, \" Net curtain (covering half window)\" = 1, \" Dark-coloured curtain or roller blind (note 1)\" = 2, \" Light-coloured curtain or roller blind (note 1)\" = 3, \" Dark-coloured venetian blind (note 2)\" = 4,\" Light-coloured venetian blind (note 2)” = 5, “Dark-coloured external shutter, window closed (notes 1, 3)\" = 6, “White external shutter, window closed (notes 1, 3)” = 7, “Dark-coloured external shutter, window fully open (notes 1, 3)” = 8, “White external shutter, window fully open (notes 1, 3)” = 9}\r\n        opn_type: Ventilation Opening type according to the SAP Table p1.he values: {\"Trickle vents only\" = 0 , \"Windows slightly open (50 mm)\" = 1, \"Windows open half the time\" = 2,\"Windows fully open\" = 3}\r\n        TMP: Thermal mass parameter\r\n        FF: The frame factor for windows and doors (fraction of opening that is glazed). Frame factor according to material: {\"wood\" = 0.7, \"metal\" = 0.8, PVC-U = 0.7} \r\n        ex_t_average: The mean external temperature for the selected summer month and climate region.\r\n        time_fraction: fraction of the daylight hours that shading blinds are in use\r\n        window_height: The height of the window frame\r\n        month_Solar_declination: \r\n    Outputs:\r\n        results: Likelihood of high internal temperature during hot weather.\r\n        preview: Colored mesh preview\r\n\"\"\"\r\n#Copyright (c) 2021, Hamidreza Shahriari \r\n__author__ = \"Hamidreza\"\r\n\r\n\r\n\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as rg\r\nimport ghpythonlib.components as ghc\r\nimport math\r\nimport Grasshopper.Kernel.GH_Convert as ghconvert\r\nfrom scriptcontext import doc\r\n\r\nif not max_roof_angle:\r\n    max_roof_angle = 1\r\n\r\ndef air_change_rate(op_type,bld_type):\r\n    # calculating air change rate according to the guide lines in SAP 2012 Appendix P\r\n    if (op_type == 0) and (bld_type == 0):\r\n        return float(0.1)\r\n    elif (op_type == 0) and (bld_type == 1):\r\n        return float(0.1)\r\n    elif (op_type == 0) and (bld_type == 2):\r\n        return float(0.2)\r\n    elif (op_type == 0) and (bld_type == 3):\r\n        return float(0.1)\r\n    elif (op_type == 1) and (bld_type == 0):\r\n        return float(0.8)\r\n    elif (op_type == 1) and (bld_type == 1):\r\n        return float(0.5)\r\n    elif (op_type == 1) and (bld_type == 2):\r\n        return float(1)\r\n    elif (op_type == 1) and (bld_type == 3):\r\n        return float(0.6)\r\n    elif (op_type == 2) and (bld_type == 0):\r\n        return float(3)\r\n    elif (op_type == 2) and (bld_type == 1):\r\n        return float(2)\r\n    elif (op_type == 2) and (bld_type == 2):\r\n        return float(4)\r\n    elif (op_type == 2) and (bld_type == 3):\r\n        return float(2.5)\r\n    elif (op_type == 3) and (bld_type == 0):\r\n        return float(6)\r\n    elif (op_type == 3) and (bld_type == 1):\r\n        return float(4)\r\n    elif (op_type == 3) and (bld_type == 2):\r\n        return float(8)\r\n    elif (op_type == 3) and (bld_type == 3):\r\n        return float(5)\r\n    else:\r\n        print(\"Please enter the building type and opening type according to the guide line\")\r\n        \r\ndef guid_to_brep(breps):\r\n    # this definition converts the brep list to GUID in order to be used for union process\r\n    list = []\r\n    for brep in breps:\r\n        list.append(doc.Objects.AddBrep(brep))\r\n    return list\r\n\r\n\r\ndef solar_flux_calculator(surface, s_flux, latitude, North, max_roof_angle, month_Solar_declination):\r\n    if not North:\r\n        North = rg.Vector3d.YAxis\r\n    else:\r\n        North = North\r\n    k_values = { 'North' : [26.3,-38.5,14.8,-16.5,27.3 ,-11.9,-1.06, 0.0872, -0.191],\r\n    'South' : [-0.66,-0.106,2.93,3.63,-0.374,-7.4,-2.71,-0.991,4.59],\r\n    'SE' : [-2.95,2.89,1.17,5.67,-3.54,-4.28,-2.72,-0.25,3.07],\r\n    'East' : [1.44,-2.36,1.07,-0.514,1.89,-1.64,-0.542,-0.757,0.604],\r\n    'NE' : [0.165,-3.68,3.0 ,6.38 ,-4.53 ,-0.405 ,-4.38 ,4.89 ,-1.99]}\r\n            \r\n    surface_vector = surface.NormalAt(0.5,0.5)\r\n    delta = math.radians(latitude - month_Solar_declination)\r\n    # calculating surface inclination\r\n    srf_incl = rg.Vector3d.VectorAngle(surface_vector, rg.Vector3d.ZAxis) * 180 / math.pi\r\n            \r\n    # calculating conveting factor\r\n    if srf_incl <= max_roof_angle:\r\n        Rh = 1\r\n        key = 0\r\n    else:\r\n        # calculating the orientation\r\n        vector_angle = rg.Vector3d.VectorAngle(surface_vector, North) * 180 / math.pi\r\n        if vector_angle < 36:\r\n            key = 'North'\r\n        if vector_angle >= 36 and vector_angle < 72:\r\n            key = 'NE'\r\n        if vector_angle >= 72 and vector_angle < 108:\r\n            key = 'East'\r\n        if vector_angle >= 108 and vector_angle < 144:\r\n            key = 'SE'\r\n        if vector_angle >= 144 and vector_angle <= 180:\r\n            key = 'South'\r\n    A = k_values[key][0] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][1] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][2] * (math.radians(srf_incl/2))\r\n    B = k_values[key][3] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][4] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][5] * (math.radians(srf_incl/2))\r\n    C = k_values[key][6] * (math.sin(math.radians(srf_incl/2)) ** 3) + k_values[key][7] * ((math.radians(srf_incl/2)) ** 2) + k_values[key][8] * (math.radians(srf_incl/2)) + 1\r\n    Rh = (A * (math.cos(delta)**2)) + (B * (math.cos(delta))) + C\r\n    return (s_flux * Rh, key, srf_incl)\r\n\r\n\r\ndef z_summer(surface, window_height, z_blinds, solar_acces, overhang, time_fraction, orientation, srf_incl, WWR, max_roof_angle):\r\n    if srf_incl < max_roof_angle:\r\n        return 1\r\n    if solar_acces > 80:\r\n         solar_acces_factor = 0.5\r\n    elif solar_acces > 60 and solar_acces <= 80:\r\n        solar_acces_factor = 0.7\r\n    elif solar_acces > 20 and solar_acces <= 60:\r\n        solar_acces_factor = 0.9\r\n    elif solar_acces <= 20:\r\n        solar_acces_factor = 1\r\n    if not overhang and not z_blinds and not time_fraction:\r\n        return solar_acces_factor\r\n    if not window_height:\r\n        window_height = math.sqrt(surface.GetSurfaceSize()[2])\r\n    # defining a dictionary for Shading factors for blinds, curtains or external shutters according to SAP table P3\r\n    blind_dic = { '0' : 0.8 , '1' : 0.9, '2' : 0.85, '3' : 0.6, '4' : 0.88 , '5' : 0.7, '6' : 0.27, '7' : 0.24, '8' : 0.85, '9' : 0.65}\r\n    # Defining the shading factor of the blinds according to the fraction of the daylight hours\r\n    if time_fraction and z_blinds:\r\n        blind_factor = time_fraction * blind_dic ['{}'.format(z_blinds)] + (1 - time_fraction)\r\n    elif not time_fraction and z_blinds:\r\n        blind_factor = blind_dic ['{}'.format(z_blinds)]\r\n    elif not z_blinds:\r\n        blind_factor = 1\r\n    # finding the depth factor of the overhang window \r\n    d_factor = overhang / window_height\r\n    if d_factor < 0.1:\r\n        depth_factor = 'zr'\r\n    elif d_factor >= 0.1 and d_factor < 0.3:\r\n        depth_factor = 'two'\r\n    elif d_factor >= 0.3 and d_factor < 0.5:\r\n        depth_factor = 'four'\r\n    elif d_factor >= 0.5 and d_factor < 0.7:\r\n        depth_factor = 'six'\r\n    elif d_factor >= 0.7 and d_factor < 0.9:\r\n        depth_factor = 'eight'\r\n    elif d_factor >= 0.9 and d_factor < 1.1:\r\n        depth_factor = 'ten'\r\n    else:\r\n        depth_factor = 'twlv'\r\n    window_width = surface.GetSurfaceSize()[1]\r\n    if overhang/window_width < 2:\r\n        overhang_dic = {'Northzr': 1, 'NEzr': 1, 'Eastzr': 1, 'SEzr': 1, 'Southzr': 1, \r\n        'Northtwo': 0.94, 'NEtwo': 0.91, 'Easttwo': 0.89, 'SEtwo': 0.84, 'Southtwo': 0.79,\r\n        'Northfour': 0.9, 'NEfour': 0.85, 'Eastfour': 0.79, 'SEfour': 0.72, 'Southfour': 0.64,\r\n        'Northsix': 0.88, 'NEsix': 0.81, 'Eastsix': 0.72, 'SEsix': 0.62, 'Southsix': 0.53,\r\n        'Northeight': 0.86, 'NEeight': 0.79, 'Easteight': 0.66, 'SEeight': 0.55, 'Southeight': 0.5,\r\n        'Northten': 0.85, 'NEten': 0.77, 'Eastten': 0.61, 'SEten': 0.52, 'Southten': 0.49,\r\n        'Northtwlv': 0.84, 'NEtwlv': 0.76, 'Easttwlv': 0.57, 'SEtwlv': 0.5, 'Southtwlv': 0.48}\r\n    else:\r\n        overhang_dic = {'Northzr': 1, 'NEzr': 1, 'Eastzr': 1, 'SEzr': 1, 'Southzr': 1, \r\n        'Northtwo': 0.92, 'NEtwo': 0.89, 'Easttwo': 0.88, 'SEtwo': 0.83, 'Southtwo': 0.79,\r\n        'Northfour': 0.85, 'NEfour': 0.8, 'Eastfour': 0.76, 'SEfour': 0.67, 'Southfour': 0.55,\r\n        'Northsix': 0.79, 'NEsix': 0.72, 'Eastsix': 0.66, 'SEsix': 0.54, 'Southsix': 0.38,\r\n        'Northeight': 0.73, 'NEeight': 0.65, 'Easteight': 0.58, 'SEeight': 0.43, 'Southeight': 0.32,\r\n        'Northten': 0.69, 'NEten': 0.59, 'Eastten': 0.51, 'SEten': 0.36, 'Southten': 0.3,\r\n        'Northtwlv': 0.66, 'NEtwlv': 0.55, 'Easttwlv': 0.46, 'SEtwlv': 0.31, 'Southtwlv': 0.29}\r\n    return float(blind_factor * (solar_acces_factor+ overhang_dic[orientation + depth_factor] - 1))\r\n\r\ndef temprature_threshold(TMP, Summer_ratio, ex_t_average):\r\n    # Obtaining the threshold internal temperature which is used to estimate likelihood of high internal temperature.\r\n    if TMP < 285:\r\n        delta_t_mass = 2.0 - 0.007 * TMP\r\n    else:\r\n        delta_t_mass = 0\r\n    temp_thresh = ex_t_average + Summer_ratio + delta_t_mass\r\n    if temp_thresh < 20.5:\r\n        overheating = 'Not significant'\r\n        color = \"3,166,90\"\r\n    elif temp_thresh >= 20.5 and temp_thresh < 22:\r\n        overheating = 'Slight'\r\n        color = \"242,191,39\"\r\n    elif temp_thresh >= 22 and temp_thresh < 23.5:\r\n        overheating = 'Medium'\r\n        color = \"217,121,4\"\r\n    else:\r\n        overheating = 'High'\r\n        color = \"191,4,4\"\r\n    return overheating, color\r\n\r\n\r\n# making the union of the breps to exclude the inner partions of the faces\r\nb1 = rs.BooleanUnion(guid_to_brep(masses))\r\n\r\n# convering the new unioned brep GUID into brep class\r\nbrep_union = rs.coercebrep(b1)\r\n\r\nresults = []\r\npreview = []\r\n\r\nfor i, brep in enumerate(masses):\r\n    loss  = 0\r\n    gain = 0\r\n    for face in brep_union.Faces:\r\n        # Calculating the Trimed faces center points in order to find which zone the new face belongs to \r\n        center_point = rg.AreaMassProperties.Compute(face).Centroid\r\n        # Calculating the heat gain and heat loss of each external surface\r\n        if ghc.PointInBrep(brep, center_point, False) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) < 170) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) > max_roof_angle):\r\n            s_flux, key, srf_incl = solar_flux_calculator(face, solar_flux, Latitude, North, max_roof_angle, month_Solar_declination)\r\n            wall_area = rg.AreaMassProperties.Compute(face).Area\r\n            shade_factor = z_summer(face, window_height, curt_blind, solar_access, overhangs, time_fraction, key, srf_incl, WWR, max_roof_angle)\r\n            s_gain = 0.9 * wall_area * WWR * FF * s_flux * shade_factor * g_value\r\n            gain += s_gain\r\n            heat_loss = (wall_area * (1-WWR) * U_wall) + (wall_area * WWR * U_window) + 0.15 * wall_area\r\n            loss += heat_loss\r\n        elif ghc.PointInBrep(brep, center_point, False) and ((rg.Vector3d.VectorAngle(face.NormalAt(0.5,0.5), rg.Vector3d.ZAxis) * 180 / math.pi) <= max_roof_angle) and Roof:\r\n            loss += (rg.AreaMassProperties.Compute(face).Area) * (U_roof+0.15)\r\n        else:\r\n            continue\r\n    # calculating the volume of the space\r\n    vol = rg.VolumeMassProperties.Compute(brep).Volume\r\n    # calculating ventilation heat loss:\r\n    n = air_change_rate(opn_type,bld_type)\r\n    vent_loss = 0.33 * n * vol\r\n    loss += vent_loss\r\n    ratio = gain / loss\r\n    results.append(temprature_threshold(TMP, ratio, ex_t_average)[0])\r\n    # coloring the mesh according to the temprature threshold\r\n    for mesh in rg.Mesh.CreateFromBrep(brep):\r\n        preview.append(ghc.MeshColours(mesh,(temprature_threshold(TMP, ratio, ex_t_average)[1])))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}