{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_Drape.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_Drape.py",
  "instruction": "This script is an alternative to _Drape. It uses Greville point locations for fitting to\r\nthe target object and allows selection of a starting surface.\r\n\r\nStarting surface's control points' X and Y...",
  "code": "\"\"\"\r\nThis script is an alternative to _Drape. It uses Greville point locations for fitting to\r\nthe target object and allows selection of a starting surface.\r\n\r\nStarting surface's control points' X and Y are maintained.\r\nStarting surface's Greville points are used for fitting analysis.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n191018-19: Created.\r\n...\r\n210718: Starting surface can no longer be selected from one of the breps to fit.\r\n210730-0808: Reduced wavy output along elevation transitions of target.\r\n210808: Now, active CPlane's Z axis is used for drape direction.\r\n250115: Added support for meshes as objects over which to drape. Refactored.\r\n250116: Fixed bug for highest elevation in ...HighToLow function. Refactored.\r\n250117: WIP: Started a rewrite of the HighToLow routine.\r\n250118: Fixed a bug in creating the starting surface. It was previously adding an extra knot outside of the bounding box.\r\n        Now, starting surface must be an open, degree-3 NURBS with only multiplicity-of-1 interior knots.\r\n250119: Replaced the 2 bool options for missed targets to a 3-choice list.\r\n        Now, negative values are allowed for SpansBeyondEachSide.\r\n250120-21: Added routine for assign lowest neighbor to target misses.\r\n\r\n\r\nTODO:\r\n    Create new HighToLow routine with a slightly new approach.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Drawing import Color\r\n\r\n#import itertools\r\nimport pprint\r\nimport random\r\n\r\n\r\nclass Data:\r\n    def __init__(self):\r\n        self\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bFlipCPlane'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'DrapeDir'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'NegCPlaneZAxis', 'PosCPlaneZAxis')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUserProvidesStartingSrf'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'StartingSrf'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Create', 'UserProvides')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSpanSpacing'; keys.append(key)\r\n    if sc.doc.ModelUnitSystem.Inches:\r\n        values[key] = 1.0\r\n    else:\r\n        values[key] = 25.0 * Rhino.RhinoMath.UnitScale(\r\n            Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iSpansBeyondEachSide'; keys.append(key)\r\n    values[key] = 3\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iTargetMisses'; keys.append(key)\r\n    values[key] = 1\r\n    listValues[key] = (\r\n        'FixToStartingSrf',\r\n        'UseLowestNeighborHits',\r\n        'LinearlyExtrapolateFromHits',\r\n        )\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeleteStartingSrf'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fSpanSpacing':\r\n            if cls.riOpts[key].CurrentValue <= 10.0*sc.doc.ModelAbsoluteTolerance:\r\n                print(\"Invalid input for tolerance.\")\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n\r\n        if key == 'fTolerance':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_ObjsToDrapeOver():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select target breps or meshes\")\r\n    go.GeometryFilter = rd.ObjectType.Brep | rd.ObjectType.Mesh\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bFlipCPlane')\r\n        addOption('fTolerance')\r\n        addOption('bUserProvidesStartingSrf')\r\n        if not Opts.values['bUserProvidesStartingSrf']:\r\n            addOption('fSpanSpacing')\r\n            addOption('iSpansBeyondEachSide')\r\n        addOption('iTargetMisses')\r\n        if Opts.values['bUserProvidesStartingSrf']:\r\n            addOption('bDeleteStartingSrf')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            #rdBreps = [rs.coercerhinoobject(o) for o in objrefs]\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            if Opts.values['bUserProvidesStartingSrf']:\r\n                print(\"Numeric input ignored.\")\r\n                continue\r\n            key = 'fSpanSpacing'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _doesNurbsSrfContainInteriorKnotsWithMultiplictyGT1(ns):\r\n    for iDir in 0,1:\r\n        knots = ns.KnotsV if iDir else ns.KnotsU\r\n        degree = ns.Degree(iDir)\r\n        iK = 0 if ns.IsPeriodic(iDir) else degree\r\n        while iK < (knots.Count if ns.IsPeriodic(iDir) else knots.Count - degree):\r\n            sc.escape_test()\r\n            if knots.KnotMultiplicity(iK) > 1:\r\n                return True\r\n            iK += 1\r\n\r\n    return False\r\n\r\n\r\ndef _isStartingSrfSupported(ns):\r\n    \"\"\"\r\n    Supported means surface must be an open, degree-3 NURBS with only multiplicity-of-1 interior knots.\r\n    \"\"\"\r\n\r\n    if not isinstance(ns, rg.NurbsSurface):\r\n        return False\r\n\r\n    if ns.Degree(0) != 3:\r\n        return False\r\n\r\n    if ns.Degree(1) != 3:\r\n        return False\r\n\r\n    if ns.IsClosed(0):\r\n        return False\r\n\r\n    if ns.IsClosed(1):\r\n        return False\r\n\r\n    if _doesNurbsSrfContainInteriorKnotsWithMultiplictyGT1(ns):\r\n        return False\r\n\r\n    return True\r\n\r\n\r\ndef getInput_StartingSurface(gObjs_toDrapeOver):\r\n    \"\"\"\r\n    Get Surface with optional input.\r\n    \"\"\"\r\n\r\n    if sc.doc.Objects.SelectedObjectsExist(objectType=rd.ObjectType.AnyObject, checkSubObjects=True):\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select starting surface\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n\r\n    while True:\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n\r\n            sc.doc.Objects.UnselectAll()\r\n            sc.doc.Views.Redraw()\r\n\r\n            if objref.ObjectId in gObjs_toDrapeOver:\r\n                print(\"Starting surface cannot be one of the objects to fit\")\r\n                go = ri.Custom.GetObject()\r\n                go.SetCommandPrompt(\"Select starting surface\")\r\n                go.GeometryFilter = rd.ObjectType.Surface\r\n                continue\r\n\r\n            # Check that surface is Degree 3 and contains only simple knots.\r\n            if not _isStartingSrfSupported(objref.Surface().UnderlyingSurface()):\r\n                print(\"Starting surface must be an open, degree-3 NURBS with only multiplicity-of-1 interior knots.\")\r\n                go = ri.Custom.GetObject()\r\n                go.SetCommandPrompt(\"Select starting surface\")\r\n                go.GeometryFilter = rd.ObjectType.Surface\r\n                continue\r\n\r\n            return objref\r\n\r\n\r\ndef _prompt(sPrompt, bDebug=False):\r\n    if bDebug: print(sPrompt)\r\n    Rhino.RhinoApp.SetCommandPrompt(sPrompt)\r\n    Rhino.RhinoApp.Wait()\r\n\r\n\r\ndef _promptDone(bAddWorking=True, bDebug=False):\r\n    if bDebug: print(Rhino.RhinoApp.CommandPrompt + \" done.\")\r\n    if bAddWorking:\r\n        Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n        Rhino.RhinoApp.Wait()\r\n\r\n\r\ndef _print_nested_list(lst, level=0, max_items=3):\r\n    \"\"\"\r\n    Prints the first few items of each nested list.\r\n    Modification to AI-generated code.\r\n    \"\"\"\r\n\r\n    #sEval = \"level\"; print(sEval,'=',eval(sEval))\r\n\r\n    deepest = level\r\n\r\n    if level==0:\r\n        print(\"  \"*level + \"[\")\r\n\r\n    elif level==1:\r\n        pass\r\n\r\n    for i, item in enumerate(lst):\r\n        if i >= max_items:\r\n            print(\"  \"*level + \"...\")\r\n            print(\"  \"*level + \"]\")\r\n            break\r\n\r\n        if isinstance(item, list):\r\n            print(\"  \"*(level+1) + \"[\")\r\n            depth = _print_nested_list(item, level + 1, max_items)\r\n            if depth > level:\r\n                deepest = depth\r\n        else:\r\n            print(\"  \"*level + str(item))\r\n\r\n    return deepest\r\n\r\n\r\ndef _createStartingSurface(rgObjs_Ref, cPlane=rg.Plane.WorldXY, fSpanSpacing=1.0, iSpansBeyondEachSide=4, bDebug=False):\r\n    \"\"\"\r\n    Returns\r\n        rg.NurbsSurface that is degree-3 and has 2 interior knots beyond the target bounding box on each of the 4 sides.\r\n    \"\"\"\r\n\r\n    bb = rg.BoundingBox.Unset\r\n\r\n    if cPlane == rg.Plane.WorldXY:\r\n        xform_toW = xform_fromW = None\r\n        for rgObj_Ref in rgObjs_Ref:\r\n            bb.Union(rgObj_Ref.GetBoundingBox(accurate=True))\r\n    else:\r\n        xform_toW = rg.Transform.PlaneToPlane(cPlane, rg.Plane.WorldXY)\r\n        for rgObj_Ref in rgObjs_Ref:\r\n            rgObj_Ref_Dup = rgObj_Ref.Duplicate()\r\n            rgObj_Ref_Dup.Transform(xform_toW)\r\n            bb.Union(rgObj_Ref_Dup.GetBoundingBox(accurate=True))\r\n            rgObj_Ref_Dup.Dispose()\r\n        xform_fromW = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, cPlane)\r\n\r\n    #sc.doc.Objects.AddBox(rg.Box(bb))\r\n\r\n    degree = 3\r\n\r\n    dim_bb_x = bb.Diagonal.X\r\n    starting_srf_X_dim = round(dim_bb_x + 2.0*float(iSpansBeyondEachSide)*fSpanSpacing, 0)\r\n    uInterval = rg.Interval(0.0, starting_srf_X_dim)\r\n    uPointCount = int(starting_srf_X_dim / fSpanSpacing) + degree\r\n\r\n    dim_bb_y = bb.Diagonal.Y\r\n    starting_srf_Y_dim = round(dim_bb_y + 2.0*float(iSpansBeyondEachSide)*fSpanSpacing, 0)\r\n    vInterval = rg.Interval(0.0, starting_srf_Y_dim)\r\n    vPointCount = int(starting_srf_Y_dim / fSpanSpacing) + degree\r\n\r\n    origin = rg.Point3d(\r\n        bb.Center.X-starting_srf_X_dim/2.0,\r\n        bb.Center.Y-starting_srf_Y_dim/2.0,\r\n        bb.Max.Z)\r\n\r\n    plane = rg.Plane(origin=origin, normal=rg.Vector3d.ZAxis)\r\n\r\n    ns = rg.NurbsSurface.CreateFromPlane(\r\n        plane=plane,\r\n        uInterval=uInterval,\r\n        vInterval=vInterval,\r\n        uDegree=degree,\r\n        vDegree=degree,\r\n        uPointCount=uPointCount,\r\n        vPointCount=vPointCount)\r\n\r\n    #sc.doc.Objects.AddSurface(ns); sc.doc.Views.Redraw(); 1/0\r\n\r\n    if xform_fromW:\r\n        ns.Transform(xform_fromW)\r\n\r\n    return ns\r\n\r\n\r\ndef _coerceSurface(rhObj):\r\n    if isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        #print(rhObj.GeometryComponentIndex.ComponentIndexType)\r\n        geom = rhObj.Geometry()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n    else:\r\n        return\r\n\r\n    srf = None\r\n    if isinstance(geom, rg.BrepFace):\r\n        srf = geom.UnderlyingSurface()\r\n    elif isinstance(geom, rg.Surface):\r\n        srf = geom\r\n    elif isinstance(geom, rg.Brep):\r\n        if geom.Faces.Count == 1:\r\n            srf = geom.Faces[0].UnderlyingSurface()\r\n\r\n    return srf\r\n\r\n\r\ndef _getGrevillePoints(ns):\r\n    pts_out = []\r\n\r\n    for iU in range(ns.Points.CountU):\r\n        pts_out.append([])\r\n        for iV in range(ns.Points.CountV):\r\n            u, v = ns.Points.GetGrevillePoint(iU, iV)\r\n            pt = ns.PointAt(u, v)\r\n            pts_out[-1].append(pt)\r\n\r\n    return pts_out\r\n\r\n\r\ndef _projectPts_toObjs(pts_In, rgObjs_Targets, bDebug=False):\r\n    \"\"\"\r\n    Parameters\r\n        rgObjs_Targets: rd.ObjRef, rd.RhinoObject, GUID, or Rhino.Geometry, but all must be of the same type.\r\n        pts_In: list of rg.Point3d\r\n        bDebug: bool\r\n\r\n    Returns\r\n        list of mix of rg.Point3ds and None (for misses)\r\n    \"\"\"\r\n\r\n    _prompt(\"Creating target points ...\", bDebug=bDebug)\r\n\r\n    rgBreps_Targets = []\r\n    rgMeshes_Targets = []\r\n    for rgObj in rgObjs_Targets:\r\n        if isinstance(rgObj, rg.Brep):\r\n            rgBreps_Targets.append(rgObj)\r\n        elif isinstance(rgObj, rg.Mesh):\r\n            rgMeshes_Targets.append(rgObj)\r\n        else:\r\n            raise Exception()\r\n\r\n    pts_Out = []\r\n    \r\n    for iU in range(len(pts_In)):\r\n        pts_Out.append([])\r\n        for iV in range(len(pts_In[0])):\r\n            if sc.escape_test(throw_exception=False):\r\n                print(\"User break.\")\r\n                return\r\n\r\n            pts_Projected = []\r\n\r\n            if rgMeshes_Targets:\r\n                rv = rg.Intersect.Intersection.ProjectPointsToMeshes(\r\n                    meshes=rgMeshes_Targets,\r\n                    points=[pts_In[iU][iV]],\r\n                    direction=rg.Vector3d.ZAxis,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n                if rv:\r\n                    pts_Projected.extend(rv)\r\n\r\n            if rgBreps_Targets:\r\n                rv = rg.Intersect.Intersection.ProjectPointsToBreps(\r\n                    breps=rgBreps_Targets,\r\n                    points=[pts_In[iU][iV]],\r\n                    direction=rg.Vector3d.ZAxis,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n                if rv:\r\n                    pts_Projected.extend(rv)\r\n\r\n            if len(pts_Projected) == 0:\r\n                pt_Out = None\r\n            elif len(pts_Projected) == 1:\r\n                pt_Out = pts_Projected[0]\r\n            else:\r\n                pts = pts_Projected\r\n                zs = []\r\n                for pt in pts:\r\n                    zs.append(pt.Z)\r\n                    dist = pt.DistanceTo(pts_In[iU][iV])\r\n                winning_Z = max(zs)\r\n                pt_Out = pts[zs.index(winning_Z)]\r\n\r\n            pts_Out[-1].append(pt_Out)\r\n\r\n    _promptDone(bDebug=bDebug)\r\n\r\n    return pts_Out\r\n\r\n\r\ndef _get_orthogonal_neighbor_count_of_point(pts, iU, iV):\r\n    \"\"\"\r\n    Parameters:\r\n        pts: u list of v lists of pts\r\n        iU: int Index in u (top-level list)\r\n        iV: int Index of v (nested list)\r\n    Returns:\r\n        int (0, 1, 2, 3, or 4)\r\n    \"\"\"\r\n\r\n    idx_MaxU = len(pts)-1\r\n    idx_MaxV = len(pts[0])-1\r\n\r\n    ct = 0\r\n\r\n    if iU-1 >= 0 and pts[iU-1][iV] is not None:\r\n        ct += 1\r\n    if iU+1 <= idx_MaxU and pts[iU+1][iV] is not None:\r\n        ct += 1\r\n    if iV-1 >= 0 and pts[iU][iV-1] is not None:\r\n        ct += 1\r\n    if iV+1 <= idx_MaxV and pts[iU][iV+1] is not None:\r\n        ct += 1\r\n\r\n    return ct\r\n\r\n\r\ndef _getBorderPointIndices(pts_Target):\r\n    \"\"\"\r\n    Returns flat list of tuples of column, row indices of target points\r\n    whose value is None and have any neighbors whose value is not None.\r\n    In other words, the pattern(s) of points will be 1-point wide and\r\n    outline(s) the target hits.\r\n    \"\"\"\r\n\r\n    idxs_borderPts = []\r\n    for iU in range(len(pts_Target)):\r\n        for iV in range(len(pts_Target[0])):\r\n            if (\r\n                pts_Target[iU][iV] is None and\r\n                _get_orthogonal_neighbor_count_of_point(pts_Target, iU, iV) > 0\r\n            ):\r\n                idxs_borderPts.append((iU,iV))\r\n    return idxs_borderPts\r\n\r\n\r\ndef _createZAxisLinesAtGrevilles(pts_Greville_toProject):\r\n    \"\"\"\r\n    Returns\r\n        list of lists of lines\r\n    \"\"\"\r\n    lines = []\r\n    for iU in range(len(pts_Greville_toProject)):\r\n        lines.append([])\r\n        for iV in range(len(pts_Greville_toProject[0])):\r\n            line = rg.Line(\r\n                    start=pts_Greville_toProject[iU][iV],\r\n                    span=rg.Vector3d.ZAxis)\r\n            #sc.doc.Objects.AddLine(line)\r\n            lines[-1].append(line)\r\n    return lines\r\n\r\n\r\ndef _hasMissingPoints(pts):\r\n    return any([pt is None for ptsV in pts for pt in ptsV])\r\n\r\n\r\ndef _flattenNestedList(pts_in):\r\n    \"\"\"Returns: Flattened list of 1-level nested lists\"\"\"\r\n    pts_out = []\r\n    for iU in range(len(pts_in)):\r\n        for iV in range(len(pts_in[iU])):\r\n            pts_out.append(pts_in[iU][iV])\r\n    return pts_out\r\n\r\n\r\ndef _sort2ListsPer1st(list1, list2):\r\n    sorted_zipped = sorted(zip(list1, list2), reverse=True)\r\n    sorted1, sorted2 = zip(*sorted_zipped)\r\n    return sorted1, sorted2\r\n\r\n\r\ndef _sortAndGroupTargetsByElevation_High_to_low_NEW(pts, fElevTol=1e-6, bDebug=False):\r\n    \"\"\"\r\n    Parameters\r\n        pts: list of lists of mix of rg.Point3d or None\r\n        fElevTol: float  Should be tighter than general tolerance to minimize tolerance stack up.\r\n\r\n    Returns\r\n        tuple of\r\n            list of lists of z values rounded per fElevTol\r\n            list of lists of u and v index tuples whose z's are within fElevTol\r\n    \"\"\"\r\n\r\n    sEval = \"fElevTol\"; print(sEval,'=',eval(sEval))\r\n\r\n    _prompt(\"Sorting target points by elevation ...\", bDebug=bDebug)\r\n\r\n    uvs_Flat = [(u,v) for u in range(len(pts)) for v in range(len(pts[0]))]\r\n    pts_Flat = _flattenNestedList(pts)\r\n    zs_Flat_perPts = [pt.Z for pt in pts_Flat]\r\n\r\n    zs_Flat_Sorted, uvs_Flat_Sorted = _sort2ListsPer1st(zs_Flat_perPts, uvs_Flat)\r\n    sEval = \"uvs_Flat_Sorted[:9]\"; print(sEval,'=',eval(sEval))\r\n    sEval = \"zs_Flat_Sorted[:9]\"; print(sEval,'=',eval(sEval))\r\n\r\n    # Group per fElevTol.\r\n    zs_1perElevGroup = [zs_Flat_Sorted[0]]\r\n    uvs_Sorted_and_grouped_per_z = [[]]\r\n    for iZ, z in enumerate(zs_Flat_Sorted):\r\n        z_Lowest_for_group = zs_1perElevGroup[-1] - fElevTol\r\n        if z >= z_Lowest_for_group:\r\n            uvs_Sorted_and_grouped_per_z[-1].append(uvs_Flat_Sorted[iZ])\r\n            continue\r\n        # New group.\r\n        zs_1perElevGroup.append(z)\r\n        uvs_Sorted_and_grouped_per_z.append([uvs_Flat_Sorted[iZ]])\r\n\r\n    return zs_1perElevGroup, uvs_Sorted_and_grouped_per_z\r\n\r\n\r\ndef _sortAndGroupTargetsByElevation_High_to_low(pts, fElevTol=1e-6, bDebug=False):\r\n    \"\"\"\r\n    Parameters\r\n        pts: list of lists of mix of rg.Point3d or None\r\n\r\n    Returns\r\n        list of lists of u and v index tuples whose z's are within fElevTol\r\n    \"\"\"\r\n\r\n    _prompt(\"Sorting target points by elevation ...\", bDebug=bDebug)\r\n\r\n    pts_Flat = _flattenNestedList(pts)\r\n    zs_Flat_perPts = [pt.Z for pt in pts_Flat]\r\n    zs_Flat_HiToLo = sorted(zs_Flat_perPts, reverse=True)\r\n    iZs_Used = []\r\n    iZs_Sorted_Grouped_Flat = []\r\n    z_LastTolStart = float(\"inf\")\r\n    for i, z in enumerate(zs_Flat_HiToLo):\r\n        if zs_Flat_perPts.index(z) in iZs_Used:\r\n            continue\r\n        iZs_NewElevation = [j for j, x in enumerate(zs_Flat_perPts) if x == z]\r\n        if abs(z_LastTolStart-z) > fElevTol:\r\n            iZs_Sorted_Grouped_Flat.append(iZs_NewElevation)\r\n            z_LastTolStart = z\r\n        else:\r\n            iZs_Sorted_Grouped_Flat[-1].extend(iZs_NewElevation)\r\n        iZs_Used.extend(iZs_NewElevation)\r\n\r\n    countV = len(pts[0])\r\n    iUiVs_Sorted = []\r\n    for z_Group in iZs_Sorted_Grouped_Flat:\r\n        iUiVs_Sorted.append([])\r\n        for iZ in z_Group:\r\n            iUiVs_Sorted[-1].append(((iZ // countV), (iZ % countV)))\r\n            #sc.doc.Objects.AddPoint(pts[iU][iV])\r\n\r\n    _promptDone(bDebug=False)\r\n\r\n    return iUiVs_Sorted\r\n\r\n\r\ndef _getNeighborsPerElevationGroup(ns, uvs_Target_Groups, zs_Targets, zs_Min_AdjustedPerNeighbors, bDebug=False):\r\n    \"\"\"\r\n    Returns list of lists of tuples of index pairs\r\n    Also modifies zs_Min_AdjustedPerNeighbors\r\n    \"\"\"\r\n\r\n    _prompt(\"Determining neighbors of targets ...\", bDebug=bDebug)\r\n\r\n    iUiVs_Sorted_Flat = _flattenNestedList(uvs_Target_Groups)\r\n    #zs_Targets_Flat = _flattenNestedList(zs_Targets)\r\n    uvs_Neighbors_PerElevGroup_Flat = []\r\n    iDirs = -1, 0, 1\r\n    # 8 directions from each index location.\r\n    neighbor_dir_deltas = [[iU_N, iV_N] for iU_N in iDirs for iV_N in iDirs if not (iU_N == iV_N == 0) ]\r\n    uvs_Neighbors_PerElevGroup = []\r\n\r\n    for iGroup, uvs_Target_Group in enumerate(uvs_Target_Groups):\r\n        sc.escape_test()\r\n        uvs_Neighbors_PerElevGroup.append([])\r\n        for uT, vT in uvs_Target_Group:\r\n            #print(\"T:\", uT, vT)\r\n            for uD, vD in neighbor_dir_deltas:\r\n                uN = uT + uD\r\n                vN = vT + vD\r\n                #print(\"N:\", uN, vN)\r\n                if (uN, vN) in uvs_Target_Group:\r\n                    # Neighbor cannot be in current target group.\r\n                    #sEval = \"iGroup,uD,vD\"; print(sEval,'=',eval(sEval))\r\n                    continue\r\n                if uD == 0 and vD == 0:\r\n                    raise Exception(\"When does this happen? The previous if should have continued this. This condition should be removed from neighbor_dir_deltas.\")\r\n                if (uN, vN) in uvs_Neighbors_PerElevGroup_Flat:\r\n                    continue\r\n                if not (2 < uN < (ns.Points.CountU-3)):\r\n                    continue\r\n                if not (2 < vN < (ns.Points.CountV-3)):\r\n                    continue\r\n                uvs_Neighbors_PerElevGroup[-1].append((uN, vN))\r\n                uvs_Neighbors_PerElevGroup_Flat.append((uN, vN))\r\n                z_Min_AdjustedPerNeighbors = zs_Min_AdjustedPerNeighbors[uN][vN]\r\n                z_Target = zs_Targets[uT][vT]\r\n                if z_Min_AdjustedPerNeighbors < z_Target:\r\n                    zs_Min_AdjustedPerNeighbors[uN][vN] = z_Target\r\n\r\n    _promptDone(bDebug=bDebug)\r\n\r\n    #sEval = \"len(uvs_Neighbors_PerElevGroup)\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"len(uvs_Neighbors_PerElevGroup[0])\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"len(uvs_Neighbors_PerElevGroup[0][0])\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"uvs_Neighbors_PerElevGroup[0]\"; print(sEval,'=',eval(sEval))\r\n    #sEval = \"uvs_Neighbors_PerElevGroup[0][0]\"; print(sEval,'=',eval(sEval))\r\n    #1/0\r\n\r\n    return uvs_Neighbors_PerElevGroup\r\n\r\n\r\ndef _highestElevation(pts):\r\n    bb = rg.BoundingBox(points=[pt for pt in _flattenNestedList(pts) if pt is not None])\r\n    return bb.Max.Z\r\n\r\n    # Alternative routine.\r\n    zMax = -float('inf')\r\n    for us in pts:\r\n        for v in us:\r\n            if v is None:\r\n                continue\r\n            if v.Z > zMax:\r\n                zMax = v.Z\r\n    return zMax\r\n\r\n\r\ndef _fit_NEW_High_to_low(ns_In=None, pts_Target=None, fTolerance=None, bDebug=False):\r\n    \"\"\"\r\n    WIP to possibly replace other High_to_low\r\n    \"\"\"\r\n\r\n    ns_Out = ns_In.Duplicate() if ns_In.IsDocumentControlled else ns_In\r\n\r\n    zs_1perElevGroup, uvs_Sorted_and_grouped_per_z = _sortAndGroupTargetsByElevation_High_to_low_NEW(\r\n        pts_Target,\r\n        fElevTol=0.1*min((sc.doc.ModelAbsoluteTolerance, fTolerance)),\r\n        bDebug=bDebug)\r\n\r\n    sEval = \"len(zs_1perElevGroup)\"; print(sEval,'=',eval(sEval))\r\n    sEval = \"len(uvs_Sorted_and_grouped_per_z)\"; print(sEval,'=',eval(sEval))\r\n    sEval = \"zs_1perElevGroup[:9]\"; print(sEval,'=',eval(sEval))\r\n    sEval = \"uvs_Sorted_and_grouped_per_z[:9]\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n\r\ndef _fit_Iter_transl_High_to_low_9pts(pts_Target, ns_In, fTolerance, bDebug=False):\r\n    \"\"\"\r\n    The 9-point groups are for degree-3 NurbsSrfs with simple interior knots.\r\n    Not all groups are 9 points; points already in higher elevation groups are not included.\r\n    These are not the elevation groups. Those are for reducing the amount of absolute\r\n    elevation differences, be combining targets within a tolerance.\r\n    \"\"\"\r\n\r\n    #return _fit_NEW_High_to_low(\r\n    #    ns_In=ns_In,\r\n    #    pts_Target=pts_Target,\r\n    #    fTolerance=fTolerance,\r\n    #    bDebug=bDebug)\r\n\r\n    ns_Out = ns_In.Duplicate() if ns_In.IsDocumentControlled else ns_In\r\n\r\n\r\n    #map(sc.doc.Objects.AddPoint, [pt for pts_V in pts_Target for pt in pts_V]); sc.doc.Views.Redraw()\r\n\r\n\r\n    uvs_Targets_InElevGroups = _sortAndGroupTargetsByElevation_High_to_low(\r\n        pts_Target,\r\n        fElevTol=0.1*min((sc.doc.ModelAbsoluteTolerance, fTolerance)),\r\n        bDebug=bDebug)\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"uvs_Targets_InElevGroups[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"uvs_Targets_InElevGroups[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"uvs_Targets_InElevGroups[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n    if bDebug: sEval = 'len(uvs_Targets_InElevGroups)'; print(sEval+':',eval(sEval))\r\n    if bDebug: sEval = 'uvs_Targets_InElevGroups'; print(sEval+':',eval(sEval))\r\n    #return\r\n\r\n    zs_HighestPerElevGroup = []\r\n    for uvsGroup in uvs_Targets_InElevGroups:\r\n        zs = []\r\n        for u,v in uvsGroup:\r\n            zs.append(pts_Target[u][v].Z)\r\n        zs_HighestPerElevGroup.append(max(zs))\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"zs_HighestPerElevGroup\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"len(zs_HighestPerElevGroup)\"; print(sEval,'=',eval(sEval))\r\n\r\n    #    print('-'*20)\r\n    #    sEval = \"uvs_Targets_InElevGroups[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"uvs_Targets_InElevGroups[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"uvs_Targets_InElevGroups[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n    #for pts_V in pts_Target:\r\n    #    for pt in pts_V:\r\n    #        sc.doc.Objects.AddPoint(pt)\r\n    #    sc.doc.Views.Redraw()\r\n    #return\r\n\r\n\r\n    #attr = rd.ObjectAttributes()\r\n    #attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    #for iUiV_Group in uvs_Targets_InElevGroups:\r\n    #    attr.ObjectColor = Color.FromArgb(\r\n    #            red=random.randint(0, 255),\r\n    #            green=random.randint(0, 255),\r\n    #            blue=random.randint(0, 255))\r\n    #    for iU, iV in iUiV_Group:\r\n    #        sc.doc.Objects.AddPoint(pts_Target[iU][iV], attr)\r\n    #sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n    zs_Targets = [[pt.Z for pt in ptsV] for ptsV in pts_Target]\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"zs_Targets[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Targets[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Targets[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n    # Set zs_Targets in elevation groups to highest elevation.\r\n    # This allows better control point selection in resultant surface.\r\n    for iGroup, uvsGroup in enumerate(uvs_Targets_InElevGroups):\r\n        for u, v in uvsGroup:\r\n            zs_Targets[u][v] = zs_HighestPerElevGroup[iGroup]\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"zs_Targets[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Targets[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Targets[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n    zs_Min_AdjustedPerNeighbors = [zsV[:] for zsV in zs_Targets]\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n    uvs_Neighbors_PerElevGroup = _getNeighborsPerElevationGroup(\r\n        ns_In,\r\n        uvs_Targets_InElevGroups,\r\n        zs_Targets,\r\n        zs_Min_AdjustedPerNeighbors,\r\n        bDebug=bDebug)\r\n\r\n    #if bDebug:\r\n    #    print('-'*20)\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[8][22:27]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[9][22:29]\"; print(sEval,'=',eval(sEval))\r\n    #    sEval = \"zs_Min_AdjustedPerNeighbors[9][22:27]\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n    #print(uvs_Targets_InElevGroups[:10])\r\n    if bDebug: sEval = 'len(uvs_Neighbors_PerElevGroup)'; print(sEval+':',eval(sEval))\r\n\r\n\r\n    # TESTING: TODO: Remove this comment if this block of code is successful.\r\n    #zMax = _highestElevation(pts_Target)\r\n    #sEval = 'zMax'; print(sEval+':',eval(sEval))\r\n\r\n    #for iU in range(ns_Out.Points.CountU):\r\n    #    for iV in range(ns_Out.Points.CountV):\r\n    #        cp = ns_Out.Points.GetControlPoint(iU, iV)\r\n    #        cp.Z = zMax\r\n    #        ns_Out.Points.SetControlPoint(iU, iV, cp)\r\n\r\n    #sc.doc.Objects.AddSurface(ns_Out); sc.doc.Views.Redraw()\r\n\r\n\r\n    # Set highest elevation group\r\n\r\n\r\n    zMax = _highestElevation(pts_Target)\r\n\r\n\r\n    # Set highest elevation group to max Z.\r\n    for (iU, iV) in uvs_Targets_InElevGroups[0]:\r\n        #sEval = 'iU,iV'; print(sEval+':',eval(sEval))\r\n        cp = ns_In.Points.GetControlPoint(iU, iV)\r\n        cp.Z = zMax\r\n        ns_Out.Points.SetControlPoint(iU, iV, cp)\r\n\r\n\r\n    # Set highest elevation group neighbors to max Z.\r\n    for (iU, iV) in uvs_Neighbors_PerElevGroup[0]:\r\n        #sEval = 'iU,iV'; print(sEval+':',eval(sEval))\r\n        cp = ns_In.Points.GetControlPoint(iU, iV)\r\n        #zs_Min_AdjustedPerNeighbors[iU][iV] = cp.Location.Z\r\n        cp.Z = zMax #z_Low\r\n        ns_Out.Points.SetControlPoint(iU, iV, cp)\r\n\r\n\r\n    if bDebug: sEval = 'len(zs_Min_AdjustedPerNeighbors)'; print(sEval+':',eval(sEval))\r\n    if bDebug: sEval = 'zs_Min_AdjustedPerNeighbors'; print(sEval+':',eval(sEval))\r\n    #return\r\n\r\n\r\n    # Start loop at level 1, not 0, because\r\n    # top elevations and neighbors stay at highest elevation.\r\n\r\n    uvs_Neighbors_Cum_prev_Flat = []\r\n\r\n    for iGroup in range(1, len(uvs_Targets_InElevGroups)):\r\n        if iGroup > 1:\r\n            _promptDone(False, bDebug=False)\r\n\r\n        _prompt(\"Fitting elevation level {} of {} ...\".format(\r\n            iGroup+1, len(uvs_Targets_InElevGroups)), bDebug=False)\r\n            \r\n        uvs_Target_Group = uvs_Targets_InElevGroups[iGroup]\r\n        uvs_NeighborsOfGroup = uvs_Neighbors_PerElevGroup[iGroup]\r\n        uvs_Neighbors_Cum_prev_Flat.extend(uvs_Neighbors_PerElevGroup[iGroup-1])\r\n\r\n        # Set CP locations of targets only if not already set as a neighbor.\r\n        for uT,vT in uvs_Target_Group:\r\n            if (uT, vT) in uvs_Neighbors_Cum_prev_Flat:\r\n                continue\r\n            cp = ns_Out.Points.GetControlPoint(uT, vT)\r\n            cp.Z = pts_Target[uT][vT].Z\r\n            ns_Out.Points.SetControlPoint(uT, vT, cp)\r\n\r\n\r\n        ## Translate neighbors as low as possible to their target Z.\r\n\r\n        # First, translate neighbors to their ? Z.\r\n        for uN,vN in uvs_NeighborsOfGroup:\r\n\r\n            # Do not modify first group.\r\n            if (uN, vN) in uvs_Neighbors_PerElevGroup[0]:\r\n                #print(\"Skipped {} {}\".format(uN, vN))\r\n                continue\r\n\r\n            cp = ns_Out.Points.GetControlPoint(uN, vN)\r\n            #z_Low = pts_Target[uN][vN].Z\r\n            z_Low = zs_Min_AdjustedPerNeighbors[uN][vN]\r\n            cp.Z = z_Low\r\n            ns_Out.Points.SetControlPoint(uN, vN, cp)\r\n\r\n            if (uN,vN) == (6,5):\r\n                pass\r\n\r\n            #    for uT,vT in uvs_Target_Group:\r\n            #        sc.doc.Objects.AddPoint(pts_Target[uT][vT])\r\n            #    sc.doc.Views.Redraw(); return\r\n\r\n\r\n        # Test whether Greville points of elevation group are still on or above target.\r\n\r\n        for uT,vT in uvs_Target_Group:\r\n            uG, vG = ns_Out.Points.GetGrevillePoint(uT, vT)\r\n            #print(uT, vT)\r\n            #if (uT,vT) == (6,5):\r\n            #    pass\r\n            #    sc.doc.Objects.AddSurface(ns_Out); sc.doc.Views.Redraw(); return\r\n            pt_Greville = ns_Out.PointAt(uG, vG)\r\n            zG = pt_Greville.Z\r\n            zT = pts_Target[uT][vT].Z\r\n            if (zG + 0.001*fTolerance) >= zT:\r\n                continue\r\n\r\n            #sc.doc.Objects.AddSurface(ns_Out)\r\n            #sc.doc.Objects.AddPoint(pt_Greville)\r\n            #sc.doc.Views.Redraw()\r\n            #raise Exception(\"This still occurs. When?\")\r\n\r\n            break\r\n        else:\r\n            # No change to zs_Min_AdjustedPerNeighbors.\r\n\r\n            #if bDebug:\r\n            #    _prompt(\"All Grevilles are on or above target.\", bDebug=False)\r\n            #sc.doc.Objects.AddPoint(pts_Target[u][vN])\r\n\r\n            continue # to next elevation group.\r\n        #sc.doc.Views.Redraw(); 1/0\r\n\r\n        ##\r\n\r\n\r\n        #if bDebug:\r\n        #    _prompt(\"Binary search the correct elevation.\", bDebug=False)\r\n        fraction_L = 0.0\r\n        fraction_H = 1.0\r\n\r\n        while True:\r\n            sc.escape_test()\r\n\r\n            #if bDebug: print(\"L,H 'fraction': {}, {}\".format(fraction_L, fraction_H))\r\n\r\n            fraction_M = 0.5*fraction_L + 0.5*fraction_H\r\n\r\n            for uN,vN in uvs_NeighborsOfGroup:\r\n                # Translate point as low as possible to its target Z.\r\n                cp = ns_Out.Points.GetControlPoint(uN,vN)\r\n                z_Lowest = zs_Min_AdjustedPerNeighbors[uN][vN]\r\n\r\n                # Instead of starting surface, use elevation of closest\r\n                # neighbor in uvs_Targets_InElevGroups.\r\n                #def getElevationOfClosestTarget():\r\n                #    dists = []\r\n                #    for (uT, vT) in uvs_Targets_InElevGroups[iGroup]:\r\n                #        dist = ((float(uN - uT))**2 + (float(vN - vT))**2)**0.5\r\n                #        dists.append(dist)\r\n                #        dist_Min = min(dists)\r\n                #    zs_Winners = []\r\n                #    for i, dist in enumerate(dists):\r\n                #        if abs(dist_Min-dist) <= 1e-9:\r\n                #            zs_Winners.append(zs_PerElevGroup[iGroup][i])\r\n                #    return sum(zs_Winners) / float(len(zs_Winners))\r\n\r\n                # Instead of starting surface, use highest elevation of\r\n                # neighbors.\r\n                def getHighestElevationOfNeighbors():\r\n                    iDirs = -1, 0, 1\r\n                    # 8 directions from each index location.\r\n                    delta_dirs = [[u, v] for u in iDirs for v in iDirs if not (u == v == 0)]\r\n\r\n                    zs_Neighbors = []\r\n\r\n                    for uD, vD in delta_dirs:\r\n                        #print(uD, vD)\r\n                        uNN = uN + uD\r\n                        vNN = vN + vD\r\n                        zs_Neighbors.append(zs_Targets[uNN][vNN])\r\n                    #1/0\r\n                    return max(zs_Neighbors)\r\n\r\n                z_Highest = getHighestElevationOfNeighbors()\r\n\r\n\r\n                cp.Z = z_Lowest + (z_Highest-z_Lowest)*fraction_M\r\n                ns_Out.Points.SetControlPoint(uN,vN,cp)\r\n\r\n            for uT,vT in uvs_Target_Group:\r\n                uG,vG = ns_Out.Points.GetGrevillePoint(uT, vT)\r\n                zG = ns_Out.PointAt(uG, vG).Z\r\n                zT = pts_Target[uT][vT].Z\r\n                if zG >= zT:\r\n                    continue\r\n                # Greville is too low.\r\n                fraction_L = fraction_M\r\n                break\r\n            else:\r\n                # All Grevilles are on or above target.\r\n                fraction_H = fraction_M\r\n\r\n            if abs(fraction_H - fraction_L) <= 0.001:\r\n                #sc.doc.Objects.AddSurface(ns_Out); sc.doc.Views.Redraw(); 1/0\r\n                break # out of while / binary search.\r\n\r\n        for uN,vN in uvs_NeighborsOfGroup:\r\n            # Translate point as low as possible to its target Z.\r\n            cp = ns_Out.Points.GetControlPoint(uN,vN)\r\n            zs_Min_AdjustedPerNeighbors[uN][vN] = cp.Location.Z\r\n\r\n        #sc.doc.Objects.AddSurface(ns_Out); sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n    if bDebug:\r\n        print(\"Iteratived through {} elevation groups.\".format(iGroup+1))\r\n        print(\"Position points not within 3 from border nor are already translated.\")\r\n\r\n    uvs_done_Flat = uvs_Targets_InElevGroups[0] + [(uN, vN) for uvs in uvs_Neighbors_PerElevGroup for (uN, vN) in uvs]\r\n\r\n    for uN in range(3, ns_In.Points.CountU-3):\r\n        for vN in range(3, ns_In.Points.CountV-3):\r\n            if (uN, vN) not in uvs_done_Flat:\r\n                cp = ns_Out.Points.GetControlPoint(uN,vN)\r\n                cp.Z = pts_Target[uN][vN].Z\r\n                ns_Out.Points.SetControlPoint(uN,vN,cp)\r\n\r\n\r\n    return ns_Out\r\n\r\n\r\ndef _fit_Iter_transl_indiv_pts(pts, ns_In, fTolerance):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    ns_Out = ns_In.Duplicate()\r\n\r\n    # Initially, move control points whose Grevilles are not within tolerance of their targets.\r\n    for iU in range(ns_In.Points.CountU):\r\n        for iV in range(ns_In.Points.CountV):\r\n            uv_Gr = ns_Out.Points.GetGrevillePoint(iU, iV)\r\n            pt_Gr = ns_Out.PointAt(uv_Gr[0], uv_Gr[1])\r\n            dist = pt_Gr.DistanceTo(pts[iU][iV])\r\n            vect = pts[iU][iV] - pt_Gr\r\n            if vect.Length <= fTolerance:\r\n                continue\r\n\r\n            ns_Out.Points.SetControlPoint(iU,iV,pts[iU][iV])\r\n\r\n    for i in xrange(200):\r\n        bTransPts = False\r\n        for iU in range(ns_In.Points.CountU):\r\n            for iV in range(ns_In.Points.CountV):\r\n                uv_Gr = ns_Out.Points.GetGrevillePoint(iU, iV)\r\n                pt_Gr = ns_Out.PointAt(uv_Gr[0], uv_Gr[1])\r\n                dist = pt_Gr.DistanceTo(pts[iU][iV])\r\n                vect = pts[iU][iV] - pt_Gr\r\n                if vect.Length <= fTolerance:\r\n                    continue\r\n                #print(dist, vect)\r\n                cp = ns_Out.Points.GetControlPoint(iU,iV)\r\n                ns_Out.Points.SetControlPoint(iU,iV,cp.Location+vect)\r\n                bTransPts = True\r\n        if not bTransPts:\r\n            print(\"{} iterations for Grevilles to lie on target(s) within {}.\".format(\r\n                i+1, fTolerance))\r\n            return ns_Out\r\n\r\n    print(\"After {} iterations, Grevilles still do not lie on target(s) within {}.\".format(\r\n        i+1, fTolerance))\r\n\r\n    return ns_Out\r\n\r\n\r\ndef _addObject(rgObj, xform):\r\n    if xform:\r\n        if isinstance(rgObj, rg.GeometryBase):\r\n            rgObj_Dup = rgObj.Duplicate()\r\n            rgObj_Dup.Transform(xform)\r\n            sc.doc.Objects.Add(rgObj)\r\n        elif isinstance(rgObj, rg.Point3d):\r\n            rgPt3d_Dup = rg.Point3d(rgObj)\r\n            rgPt3d_Dup.Transform(xform)\r\n            sc.doc.Objects.AddPoint(rgPt3d_Dup)\r\n        else:\r\n            raise Exception(\"{} not supported yet.\".format(rgObj.GetType().Name))\r\n    else:\r\n        if isinstance(rgObj, rg.GeometryBase):\r\n            sc.doc.Objects.Add(rgObj)\r\n        elif isinstance(rgObj, rg.Point3d):\r\n            sc.doc.Objects.AddPoint(rgObj)\r\n\r\n\r\ndef _closestPointsOfNeighborsOnNormalLines(pts_In, pts_Greville, iU, iV, iMinNeighborCt=1, bDiag=True, bLineExts=True):\r\n    \"\"\"\r\n    bLineExts:\r\n        When True: If neighbor's point and its neighbor's point in the same\r\n        direction are both available, create a line through those points\r\n        and get the ClosestPoint of that line on the normal line.\r\n    \"\"\"\r\n\r\n    lines_thruStartingSrfGrevilles = _createZAxisLinesAtGrevilles(pts_Greville)\r\n\r\n    #for col in lines_thruStartingSrfGrevilles:\r\n    #    for line in col:\r\n    #        sc.doc.Objects.AddLine(line)\r\n    #sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n    pts_Out = []\r\n\r\n    idx_MaxU = len(pts_In)-1\r\n    idx_MaxV = len(pts_In[0])-1\r\n\r\n    #attr.ObjectColor = Color.FromArgb(\r\n    #        red=random.randint(0, 255),\r\n    #        green=random.randint(0, 255),\r\n    #        blue=random.randint(0, 255))\r\n\r\n    # West (Previous U).\r\n    if iU-1 >= 0 and pts_In[iU-1][iV] is not None:\r\n        pt = None\r\n        if bLineExts and iU-2 >= 0 and pts_In[iU-2][iV] is not None:\r\n            line_ThruNeighbors = rg.Line(pts_In[iU-2][iV], pts_In[iU-1][iV])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                pts_In[iU-1][iV],\r\n                limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # East (Next U).\r\n    if iU+1 <= idx_MaxU and pts_In[iU+1][iV] is not None:\r\n        pt = None\r\n        if bLineExts and iU+2 <= idx_MaxU and pts_In[iU+2][iV] is not None:\r\n            line_ThruNeighbors = rg.Line(pts_In[iU+2][iV], pts_In[iU+1][iV])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU+1][iV],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # South (Previous V).\r\n    if iV-1 >= 0 and pts_In[iU][iV-1] is not None:\r\n        pt = None\r\n        if bLineExts and iV-2 >= 0 and pts_In[iU][iV-2] is not None:\r\n            line_ThruNeighbors = rg.Line(pts_In[iU][iV-2], pts_In[iU][iV-1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU][iV-1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # North (Next V).\r\n    if iV+1 <= idx_MaxV and pts_In[iU][iV+1] is not None:\r\n        pt = None\r\n        if bLineExts and iV+2 <= idx_MaxV and pts_In[iU][iV+2] is not None:\r\n            line_ThruNeighbors = rg.Line(pts_In[iU][iV+2], pts_In[iU][iV+1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU][iV+1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # Southwest (Previous U, Previous V).\r\n    if (\r\n            bDiag and\r\n            iU-1 >= 0 and\r\n            iV-1 >= 0 and\r\n            pts_In[iU-1][iV-1] is not None\r\n    ):\r\n        pt = None\r\n        if (\r\n                bLineExts and\r\n                iU-2 >= 0 and\r\n                iV-2 >= 0 and\r\n                pts_In[iU-2][iV-2] is not None\r\n        ):\r\n            line_ThruNeighbors = rg.Line(pts_In[iU-2][iV-2], pts_In[iU-1][iV-1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU-1][iV-1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # Southeast (Next U, Previous V).\r\n    if (\r\n            bDiag and\r\n            iU+1 <= idx_MaxU and\r\n            iV-1 >= 0 and\r\n            pts_In[iU+1][iV-1] is not None\r\n    ):\r\n        pt = None\r\n        if (\r\n                bLineExts and\r\n                iU+2 <= idx_MaxU and\r\n                iV-2 >= 0 and\r\n                pts_In[iU+2][iV-2] is not None\r\n        ):\r\n            line_ThruNeighbors = rg.Line(pts_In[iU+2][iV-2], pts_In[iU+1][iV-1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU+1][iV-1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # Northwest (Previous U, Next V).\r\n    if (\r\n            bDiag and\r\n            iU-1 >= 0 and\r\n            iV+1 <= idx_MaxV and\r\n            pts_In[iU-1][iV+1] is not None\r\n    ):\r\n        pt = None\r\n        if (\r\n                bLineExts and\r\n                iU-2 >= 0 and\r\n                iV+2 <= idx_MaxV and\r\n                pts_In[iU-2][iV+2] is not None\r\n        ):\r\n            line_ThruNeighbors = rg.Line(pts_In[iU-2][iV+2], pts_In[iU-1][iV+1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU-1][iV+1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    # Northeast (Next U, Next V).\r\n    if (\r\n            bDiag and\r\n            iU+1 <= idx_MaxU and\r\n            iV+1 <= idx_MaxV and\r\n            pts_In[iU+1][iV+1] is not None\r\n    ):\r\n        pt = None\r\n        if (\r\n                bLineExts and\r\n                iU+2 <= idx_MaxU and\r\n                iV+2 <= idx_MaxV and\r\n                pts_In[iU+2][iV+2] is not None\r\n        ):\r\n            line_ThruNeighbors = rg.Line(pts_In[iU+2][iV+2], pts_In[iU+1][iV+1])\r\n            line_ThruNeighbors.Length *= 2.0\r\n            #sc.doc.Objects.AddLine(line_ThruNeighbors, attr)\r\n            rc = rg.Intersect.Intersection.LineLine(\r\n                    lineA=lines_thruStartingSrfGrevilles[iU][iV],\r\n                    lineB=line_ThruNeighbors)\r\n            if rc[0]:\r\n                pt = lines_thruStartingSrfGrevilles[iU][iV].PointAt(rc[1])\r\n        else:\r\n            pt = lines_thruStartingSrfGrevilles[iU][iV].ClosestPoint(\r\n                    pts_In[iU+1][iV+1],\r\n                    limitToFiniteSegment=False)\r\n        if pt: pts_Out.append(pt)\r\n\r\n    if len(pts_Out) < iMinNeighborCt:\r\n        return []\r\n\r\n    return pts_Out\r\n\r\n\r\ndef _addMissingPointsAlongBorder(pts_In, pts_Greville, idxs_pt_filter=None, iMinNeighborCt=1, bDiag=False, bLineExts=True):\r\n    \"\"\"\r\n    Parameters\r\n        pts_In: list of lists of Point3d\r\n\r\n    Returns\r\n        list of lists of Point3d if modified.\r\n    \"\"\"\r\n\r\n    # Modify a copy of the list so that new points do not affect subsequent ones in this function call.\r\n    pts_Out = [ptsV[:] for ptsV in pts_In]\r\n\r\n    bModificationOccured = False\r\n\r\n    for iU in range(len(pts_In)):\r\n        for iV in range(len(pts_In[0])):\r\n            if idxs_pt_filter and not (iU, iV) in idxs_pt_filter: continue\r\n\r\n            if pts_Out[iU][iV] is not None: continue\r\n\r\n            pts = _closestPointsOfNeighborsOnNormalLines(\r\n                pts_Out,\r\n                pts_Greville,\r\n                iU,\r\n                iV,\r\n                iMinNeighborCt=iMinNeighborCt,\r\n                bDiag=bDiag,\r\n                bLineExts=bLineExts)\r\n            if not pts: continue\r\n\r\n            pt_Sum = None\r\n            for pt in pts:\r\n                pt_Sum = pt if pt_Sum is None else pt_Sum + pt\r\n\r\n            pt = pt_Sum / float(len(pts))\r\n            #sc.doc.Objects.AddPoint(pt, attr)\r\n\r\n            pts_Out[iU][iV] = pt\r\n\r\n            bModificationOccured = True\r\n\r\n    # Modify original list.\r\n    #for iU in range(len(pts0)):\r\n    #    for iV in range(len(pts0[0])):\r\n    #        pts0[iU][iV] = pts_Out[iU][iV]\r\n\r\n    if bModificationOccured:\r\n        return pts_Out\r\n\r\n\r\ndef _addSrfGrevillPtsForMissing(pts_In, ns):\r\n    \"\"\"\r\n    Parameters\r\n        pts_In: list of lists of rg.Point3d\r\n        ns: rg.NurbsSurface with Greville counts of len(pts_In) x len(pts_In[0])\r\n    Returns\r\n        list of lists of Point3d\r\n    \"\"\"\r\n\r\n    max_nesting_level_of_list = _print_nested_list(pts_In)\r\n    sEval = \"max_nesting_level_of_list\"; print(sEval,'=',eval(sEval))\r\n\r\n    pts_Out = []\r\n    for iU in range(len(pts_In)):\r\n        pts_Out.append([])\r\n        for iV in range(len(pts_In[0])):\r\n            if pts_In[iU][iV] is None:\r\n                u, v = ns.Points.GetGrevillePoint(iU, iV)\r\n                pt = ns.PointAt(u, v)\r\n                pts_Out[-1].append(pt)\r\n            else:\r\n                pts_Out[-1].append(pts_In[iU][iV])\r\n    return pts_Out\r\n\r\n\r\ndef _get_zs_of_orthogonal_neighbors(pts, iU, iV):\r\n    \"\"\"\r\n    Parameters:\r\n        pts: u list of v lists of pts\r\n        iU: int Index in u (top-level list)\r\n        iV: int Index of v (nested list)\r\n    Returns:\r\n        list of z values of counts 0, 1, 2, 3, or 4\r\n    \"\"\"\r\n\r\n    idx_MaxU = len(pts)-1\r\n    idx_MaxV = len(pts[0])-1\r\n\r\n    zs = []\r\n\r\n    if iU-1 >= 0:\r\n        pt = pts[iU-1][iV]\r\n        if pt is not None:\r\n            zs.append(pt.Z)\r\n    if iU+1 <= idx_MaxU:\r\n        pt = pts[iU+1][iV]\r\n        if pt is not None:\r\n            zs.append(pt.Z)\r\n    if iV-1 >= 0:\r\n        pt = pts[iU][iV-1]\r\n        if pt is not None:\r\n            zs.append(pt.Z)\r\n    if iV+1 <= idx_MaxV:\r\n        pt = pts[iU][iV+1]\r\n        if pt is not None:\r\n            zs.append(pt.Z)\r\n\r\n    return zs\r\n\r\n\r\ndef _addMissingPoints_LowestNeighbors_Border(pts_Target_In, pts_Greville):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    pts_Target_Out = [ptsV[:] for ptsV in pts_Target_In]\r\n\r\n    iCt_Pts_added = 0\r\n\r\n    for iU in range(len(pts_Target_In)):\r\n        for iV in range(len(pts_Target_In[0])):\r\n            if pts_Target_In[iU][iV] is not None:\r\n                continue\r\n            zs = _get_zs_of_orthogonal_neighbors(pts_Target_In, iU, iV)\r\n            if not zs:\r\n                continue\r\n            pts_Target_Out[iU][iV] = pts_Greville[iU][iV]\r\n            pts_Target_Out[iU][iV].Z = min(zs)\r\n            iCt_Pts_added += 1\r\n\r\n    #sEval = \"iCt_Pts_added\"; print(sEval,'=',eval(sEval))\r\n\r\n    if iCt_Pts_added:\r\n        return pts_Target_Out\r\n\r\n\r\ndef _addMissingPoints_LowestNeighbors_All(pts_Target_In, pts_Greville):\r\n\r\n    rvs = _addMissingPoints_LowestNeighbors_Border(pts_Target_In, pts_Greville)\r\n    if not rvs:\r\n        return\r\n\r\n    while rvs:\r\n        sc.escape_test()\r\n        pts_Target_Out = rvs\r\n        rvs = _addMissingPoints_LowestNeighbors_Border(pts_Target_Out, pts_Greville)\r\n\r\n    return pts_Target_Out\r\n\r\n\r\ndef _extrapolateHitsForMisses(pts_Target_In, pts_Greville):\r\n\r\n    idxs_borderPts = _getBorderPointIndices(pts_Target_In)\r\n\r\n    #for iU,iV in idxs_borderPts:\r\n    #    sc.doc.Objects.AddPoint(pts_Greville[iU][iV])\r\n    #sc.doc.Views.Redraw(); 1/0\r\n\r\n    attr = rd.ObjectAttributes()\r\n    attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n\r\n    #for bDiag1, bDiag2, bLineExts1, bLineExts2 in itertools.product(\r\n    #            (False, True), (False, True), (False, True), (False, True)):\r\n    for bLineExts1, bLineExts2 in ((True, False),):\r\n    #for bLineExts1, bLineExts2 in itertools.product(\r\n    #            (False, True), (False, True)):\r\n\r\n        pts_Target_Out = [ptsV[:] for ptsV in pts_Target_In]\r\n\r\n\r\n        #for iMinNeighborCt in 4,3,2,1: #(1,): #\r\n\r\n        #    _addMissingPointsAlongBorder(\r\n        #            pts_Target,\r\n        #            idxs_pt_filter=idxs_borderPts,\r\n        #            iMinNeighborCt=iMinNeighborCt,\r\n        #            bDiag=True,\r\n        #            bLineExts=bLineExts1)\r\n\r\n        #    if not hasMissingPoints(pts_Target):\r\n        #        break\r\n\r\n\r\n        while _hasMissingPoints(pts_Target_Out):\r\n            sc.escape_test()\r\n\r\n            pts_Target_Out = _addMissingPointsAlongBorder(\r\n                pts_Target_Out,\r\n                pts_Greville,\r\n                bDiag=False,\r\n                bLineExts=bLineExts2)\r\n\r\n            #sEval = \"bPointsWereAdded\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n        # Fill any remaining missing points with the\r\n        # starting surface control point locations.\r\n\r\n        #idxs_Pts_SameAsStartingSrf = []\r\n        #for iU in range(len(pts_Target)):\r\n        #    for iV in range(len(pts_Target[0])):\r\n        #        if pts_Target[iU][iV] is None:\r\n        #            pts_Target[iU][iV] = ns_Starting.Points.GetControlPoint(iU,iV).Location\r\n        #            idxs_Pts_SameAsStartingSrf.append((iU,iV))\r\n\r\n\r\n        # Fill any remaining missing points with the\r\n        # starting surface border elevation.\r\n        for iU in range(len(pts_Target_Out)):\r\n            for iV in range(len(pts_Target_Out[0])):\r\n                if pts_Target_Out[iU][iV] is None:\r\n                    raise Exception(\"Why are points missing?\")\r\n                    pts_Target_Out[iU][iV] = rg.Point3d(\r\n                        ns_WIP.Points.GetControlPoint(iU,iV).X,\r\n                        ns_WIP.Points.GetControlPoint(iU,iV).Y,\r\n                        ns_WIP.Points.GetControlPoint(0,0).Z)\r\n\r\n        return pts_Target_Out\r\n\r\n\r\ndef processGeometry(rgObjs_toDrapeOver, srf_Starting, cPlane=rg.Plane.WorldXY, fTolerance=None, iTargetMisses=1, bDebug=False):\r\n    \"\"\"\r\n    Parameters\r\n        iTargetMisses: int  0 to fix on starting surface, 1 to use lowest hit neighbor, 2 to extrapolate linearly from nearest hits\r\n    \"\"\"\r\n\r\n    if fTolerance is None:\r\n        fTolerance = sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    data = Data()\r\n\r\n    ns_WIP = srf_Starting.ToNurbsSurface()\r\n\r\n    #sEval = \"cPlane\"; print(sEval,'=',eval(sEval))\r\n    #return\r\n\r\n    if cPlane == rg.Plane.WorldXY:\r\n        xform_toW = xform_fromW = None\r\n    else:\r\n        xform_toW = rg.Transform.PlaneToPlane(cPlane, rg.Plane.WorldXY)\r\n        if not all([rgObjs_toDrapeOver[i].Transform(xform_toW) for i in range(len(rgObjs_toDrapeOver))]):\r\n            raise Exception(\"No all objects to drape over can be transformed.\")\r\n        if not ns_WIP.Transform(xform_toW):\r\n            raise Exception(\"Starting surface cannot be transformed.\")\r\n\r\n        # Prepare xform for output.\r\n        xform_fromW = rg.Transform.PlaneToPlane(rg.Plane.WorldXY, cPlane)\r\n        #[sc.doc.Objects.AddBrep(rgBreps_ProjectTo[i]) for i in range(len(rgBreps_ProjectTo))]\r\n        #sc.doc.Objects.AddSurface(ns_WIP); sc.doc.Views.Redraw()#; return\r\n\r\n\r\n    uvs_All = [(u, v)\r\n               for u in range(ns_WIP.Points.CountU)\r\n               for v in range(ns_WIP.Points.CountV)]\r\n\r\n\r\n    #ns_WIP = addKnotsToSurface(ns_WIP)\r\n\r\n\r\n    pts_Greville = _getGrevillePoints(ns_WIP)\r\n\r\n    #[sc.doc.Objects.AddPoint(pts_Greville[u][v]) for u, v in uvs_All if pts_Greville[u][v] is not None]\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n    pts_Target = _projectPts_toObjs(\r\n        pts_In=pts_Greville,\r\n        rgObjs_Targets=rgObjs_toDrapeOver,\r\n        bDebug=bDebug,\r\n        )\r\n    if not pts_Target:\r\n        print(\"Projected points were not obtained.\")\r\n        return\r\n\r\n\r\n    #[_addObject(pts_Target[u][v], xform_fromW) for u, v in uvs_All if pts_Target[u][v] is not None]\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n    #for iU in range(len(pts_Target)):\r\n    #    for iV in range(len(pts_Target[iU])):\r\n    #        #print(iU, iV, pts_Target[iU][iV]))\r\n    #        if pts_Target[iU][iV] is None:\r\n    #            continue\r\n    #        sc.doc.Objects.AddPoint(pts_Target[iU][iV])\r\n            #line = rg.Line(start=pts_Target[iU][iV], span=norms_Projected[iU][iV])\r\n            #sc.doc.Objects.AddLine(line)\r\n    #sc.doc.Views.Redraw(); return\r\n\r\n\r\n\r\n    # Set all the control points of the output surface to the highest elevation.\r\n    # It is to simulate flattening then dropping the material onto the objects.\r\n    zMax = _highestElevation(pts_Target)\r\n\r\n\r\n    # This checks for ns_WIP being planar, has normal parallel to World Z axis, and origin Z at max Z of targets.\r\n    # The starting surface created by this script is this except the Z coordinate is the top of the bounding box of the objects that are draped over.\r\n    #def is_NS_flattened_at_top_of_target(ns, z):\r\n    #    bSuccess, plane = ns.TryGetPlane()\r\n    #    if not bSuccess:\r\n    #        return False\r\n    #    if (plane.Origin.Z - z) >= 1e-6:\r\n    #        return False\r\n    #    iIsParallelTo = plane.Normal.IsParallelTo(\r\n    #        other=rg.Vector3d.ZAxis,\r\n    #        angleTolerance=Rhino.RhinoMath.ToRadians(1e-6))\r\n    #    return iIsParallelTo == 1\r\n\r\n\r\n    #print(is_NS_flattened_at_top_of_target(ns_WIP, zMax))\r\n    #return\r\n\r\n    for iU in range(ns_WIP.Points.CountU):\r\n        for iV in range(ns_WIP.Points.CountV):\r\n            cp = ns_WIP.Points.GetControlPoint(iU, iV)\r\n            cp.Z = zMax\r\n            ns_WIP.Points.SetControlPoint(iU, iV, cp)\r\n\r\n\r\n\r\n    if _hasMissingPoints(pts_Target):\r\n\r\n        # Making a duplicate for debugging, etc.\r\n        pts_Target_HasMissing = [ptsV[:] for ptsV in pts_Target]\r\n\r\n\r\n        if iTargetMisses==0:\r\n            # Fill any remaining missing points with the\r\n            # starting surface control point locations.\r\n            pts_Target = _addSrfGrevillPtsForMissing(\r\n                pts_Target_HasMissing,\r\n                ns_WIP)\r\n        elif iTargetMisses==1:\r\n            pts_Target = _addMissingPoints_LowestNeighbors_All(\r\n                pts_Target_HasMissing,\r\n                pts_Greville)\r\n        elif iTargetMisses==2:\r\n            pts_Target = _extrapolateHitsForMisses(\r\n                pts_Target_HasMissing,\r\n                pts_Greville)\r\n            #for col in pts_Target:\r\n            #    for pt in col:\r\n            #        sc.doc.Objects.AddPoint(pt)\r\n            #sc.doc.Views.Redraw()\r\n            #return\r\n        else:\r\n            raise Exception(\"iTargetMisses must be 0, 1, or 2.\")\r\n\r\n\r\n    #ns_Out = _fit_Iter_transl_High_to_low_9pts(\r\n    #    pts_Target,\r\n    #    ns_WIP,\r\n    #    fTolerance,\r\n    #    bDebug=bDebug)\r\n\r\n    # TODO: Reevaluate using a different approach for fitting to a single surface.\r\n    if (\r\n        len(rgObjs_toDrapeOver) == 1 and\r\n        isinstance(rgObjs_toDrapeOver, rg.Brep) and\r\n        rgObjs_toDrapeOver[0].Faces.Count == 1\r\n    ):\r\n        ns_Out = _fit_Iter_transl_indiv_pts(\r\n            pts_Target,\r\n            ns_WIP,\r\n            fTolerance,\r\n            bDebug=bDebug)\r\n    else:\r\n        ns_Out = _fit_Iter_transl_High_to_low_9pts(\r\n            pts_Target,\r\n            ns_WIP,\r\n            fTolerance,\r\n            bDebug=bDebug)\r\n\r\n    if xform_fromW:\r\n        ns_Out.Transform(xform_fromW)\r\n\r\n    return ns_Out\r\n\r\n\r\ndef processDocObject(rhObjs_toDrapeOver, objref_srf_Starting=None, cPlane=rg.Plane.WorldXY, **kwargs):\r\n    \"\"\"\r\n    Parameters\r\n        rhObjs_toDrapeOver: rd.ObjRef[] or rd.RhinoObject[]\r\n        iTargetMisses: int  0 to fix on starting surface, 1 to use lowest hit neighbor, 2 to extrapolate linearly from nearest hits\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTolerance = getOpt('fTolerance')\r\n    fSpanSpacing = getOpt('fSpanSpacing')\r\n    iSpansBeyondEachSide = getOpt('iSpansBeyondEachSide')\r\n    iTargetMisses = getOpt('iTargetMisses')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n    rgObjs_toDrapeOver = []\r\n    for rhObj in rhObjs_toDrapeOver:\r\n        rgObj_toDrapeOver = rs.coercegeometry(rhObj)\r\n        if not isinstance(rgObj_toDrapeOver, (rg.Brep, rg.Mesh)):\r\n            print(\"{} is not supported for an object to drape over.\".format(rgObj_toDrapeOver.GetType().Name))\r\n            continue\r\n        rgObjs_toDrapeOver.append(rgObj_toDrapeOver)\r\n\r\n\r\n    if objref_srf_Starting is None:\r\n        ns_Starting = _createStartingSurface(\r\n            rgObjs_toDrapeOver,\r\n            cPlane=cPlane,\r\n            fSpanSpacing=fSpanSpacing,\r\n            iSpansBeyondEachSide=iSpansBeyondEachSide,\r\n            bDebug=bDebug)\r\n        #sc.doc.Objects.AddSurface(ns_Starting); sc.doc.Views.Redraw(); return\r\n    else:\r\n        srf_Starting = _coerceSurface(objref_srf_Starting)\r\n        ns_Starting = srf_Starting.ToNurbsSurface()\r\n\r\n\r\n    if bEcho or bDebug:\r\n        point_count = ns_Starting.Points.CountU * ns_Starting.Points.CountV\r\n        if point_count > 10000:\r\n            print(\"Start surface has {} points.\".format(point_count))\r\n\r\n    ns_Res = processGeometry(\r\n        rgObjs_toDrapeOver=rgObjs_toDrapeOver,\r\n        srf_Starting=ns_Starting,\r\n        cPlane=cPlane,\r\n        fTolerance=fTolerance,\r\n        iTargetMisses=iTargetMisses,\r\n        bDebug=bDebug\r\n        )\r\n\r\n\r\n    for brep in rgObjs_toDrapeOver: brep.Dispose()\r\n    if objref_srf_Starting is not None: srf_Starting.Dispose()\r\n\r\n\r\n    if not ns_Res: return\r\n\r\n    g_ns1 = sc.doc.Objects.AddSurface(ns_Res)\r\n\r\n    ns_Res.Dispose()\r\n\r\n    if g_ns1 == Guid.Empty: return\r\n\r\n    sc.doc.Views.Redraw()\r\n    return g_ns1\r\n\r\n\r\ndef main():\r\n\r\n    objrefs_toDrapeOver = getInput_ObjsToDrapeOver()\r\n    if objrefs_toDrapeOver is None: return\r\n\r\n    cPlane = sc.doc.Views.ActiveView.ActiveViewport.ConstructionPlane()\r\n\r\n    bFlipCPlane = Opts.values['bFlipCPlane']\r\n    fTolerance = Opts.values['fTolerance']\r\n    bUserProvidesStartingSrf = Opts.values['bUserProvidesStartingSrf']\r\n    fSpanSpacing = Opts.values['fSpanSpacing']\r\n    iSpansBeyondEachSide = Opts.values['iSpansBeyondEachSide']\r\n    iTargetMisses = Opts.values['iTargetMisses']\r\n    bDeleteStartingSrf = Opts.values['bDeleteStartingSrf']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if bFlipCPlane:\r\n        cPlane.Flip()\r\n\r\n    if not bUserProvidesStartingSrf:\r\n        objref_srf_Starting = None\r\n    else:\r\n        gObjs_toDrapeOver = [_.ObjectId for _ in objrefs_toDrapeOver]\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n        sc.doc.Views.Redraw()\r\n\r\n        objref_srf_Starting = getInput_StartingSurface(gObjs_toDrapeOver)\r\n        if objref_srf_Starting is None: return\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.CommandPrompt = \"Working ...\"\r\n\r\n    processDocObject(\r\n        rhObjs_toDrapeOver=objrefs_toDrapeOver,\r\n        objref_srf_Starting=objref_srf_Starting,\r\n        cPlane=cPlane,\r\n        fTolerance=fTolerance,\r\n        fSpanSpacing=fSpanSpacing,\r\n        iSpansBeyondEachSide=iSpansBeyondEachSide,\r\n        iTargetMisses=iTargetMisses,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}