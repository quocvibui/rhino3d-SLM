{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Radiation%20Rose.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Radiation Rose.py",
  "instruction": "Use this component to make a radiation rose in the Rhino scene.  Radiation roses give a sense of how much radiation comes from the different cardinal directions, which will give an initial idea of...",
  "code": "# Radiation Rose\r\n#\r\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\r\n# \r\n# This file is part of Ladybug.\r\n# \r\n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \r\n# Ladybug is free software; you can redistribute it and/or modify \r\n# it under the terms of the GNU General Public License as published \r\n# by the Free Software Foundation; either version 3 of the License, \r\n# or (at your option) any later version. \r\n# \r\n# Ladybug is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\n# GNU General Public License for more details.\r\n# \r\n# You should have received a copy of the GNU General Public License\r\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\r\n# \r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\n\r\n\r\n\"\"\"\r\nUse this component to make a radiation rose in the Rhino scene.  Radiation roses give a sense of how much radiation comes from the different cardinal directions, which will give an initial idea of where glazing should be minimized, shading applied, or solar collectors placed.\r\n\r\n-\r\nProvided by Ladybug 0.0.69\r\n    \r\n    Args:\r\n        north_: Input a vector to be used as a true North direction for the sun path or a number between 0 and 360 that represents the degrees off from the y-axis to make North.  The default North direction is set to the Y-axis (0 degrees).\r\n        _selectedSkyMtx: The output from the selectSkyMtx component.\r\n        context_: Optional breps or meshes representing context surrounding the point at the center of the radiation rose.  This context geometry will block the radiation that shows up in the rose.\r\n        _numOfArrows_: An interger that sets the number of arrows (or cardingal directions) in the radiation rose. The default is set to 36.\r\n        _surfaceTiltAngle_: A number between 0 and 90 that sets the tilt angle in degrees of the analysis plane (0 = roof, 90 = vertical wall). The defult is set to 90 for a radiation study of a wall (ie. radiation on a curtain wall).\r\n        _centerPoint_: A point that sets the location of the radiation rose.  The default is set to the Rhino origin (0,0,0).\r\n        _scale_: Use this input to change the scale of the radiation rose.  The default is set to 1 for any selSkyMtx that is longer than a day and 1000 for any selSkyMtx that is less than a day.\r\n        _arrowHeadScale_: Use this input to change the scale of the arrow heads of the radiation rose.  The default is set to 1.\r\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.\r\n        showTotalOnly_: Set to \"True\" to only show a radiation rose with the total radiation.  The default is \"False\", which will produce 3 radiation roses: one of diffuse radiation, one of direct radiation, and one of the total radiation.\r\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\r\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\r\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \r\n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\r\n        _runIt: Set to \"True\" to run the component and generate a radiation rose.\r\n    Returns:\r\n        readMe!: ...\r\n        radiationArrowsMesh: A colored mesh representing the intensity of radiation from different cardinal directions.\r\n        radRoseBaseCrvs: A set of guide curves that mark the directions of radiation analysis.\r\n        legend:  A legend of the radiation rose. Connect this output to a grasshopper \"Geo\" component in order to preview the legend separately in the Rhino scene.  \r\n        legendBasePts: The legend base point(s), which can be used to move the legend(s) in relation to the rose with the grasshopper \"move\" component.\r\n        radRoseEndPts: The end points of the rose arrows.\r\n        radRoseValues: The radiation values in kWh/m2 for each rose arrow.\r\n\"\"\"\r\n\r\nghenv.Component.Name = \"Ladybug_Radiation Rose\"\r\nghenv.Component.NickName = 'radiationRose'\r\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\nghenv.Component.Category = \"LB-Legacy\"\r\nghenv.Component.SubCategory = \"2 | VisualizeWeatherData\"\r\n#compatibleLBVersion = VER 0.0.59\\nJAN_24_2016\r\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\r\nexcept: pass\r\n\r\n\r\nimport scriptcontext as sc\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino as rc\r\nfrom System import Object\r\nfrom clr import AddReference\r\nAddReference('Grasshopper')\r\nimport Grasshopper.Kernel as gh\r\nfrom Grasshopper import DataTree\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\n\r\ndef main(north, genCumSkyResult, context, numOfArrows, surfaceTiltAngle, centerPoint, scale, arrowHeadScale, legendPar, showTotalOnly, bakeIt):\r\n    # import the classes\r\n    if sc.sticky.has_key('ladybug_release'):\r\n        try:\r\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\r\n            if sc.sticky['ladybug_release'].isInputMissing(ghenv.Component): return -1\r\n        except:\r\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\r\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\r\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\r\n            \"into canvas and try again.\"\r\n            w = gh.GH_RuntimeMessageLevel.Warning\r\n            ghenv.Component.AddRuntimeMessage(w, warning)\r\n            return -1\r\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\r\n        lb_mesh = sc.sticky[\"ladybug_Mesh\"]()\r\n        lb_runStudy_GH = sc.sticky[\"ladybug_RunAnalysis\"]()\r\n        lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\r\n        \r\n        conversionFac = lb_preparation.checkUnits()\r\n        \r\n        \r\n        # north direction\r\n        northAngle, northVector = lb_preparation.angle2north(north)\r\n        \r\n        # copy the custom code here\r\n        # check the input data\r\n        try:\r\n            if genCumSkyResult[2][:11] == 'Sky Patches': checkData = True\r\n            else: checkData = False\r\n        except: checkData = False\r\n        \r\n        if checkData:\r\n            # separate the data\r\n            indexList, listInfo = lb_preparation.separateList(genCumSkyResult, lb_preparation.strToBeFound)\r\n            \r\n            if indexList[-1] == 456: patchesNormalVectors = list(lb_preparation.TregenzaPatchesNormalVectors)\r\n            elif indexList[-1] == 1752: patchesNormalVectors = list(lb_preparation.getReinhartPatchesNormalVectors())\r\n            \r\n            # check num of arrows\r\n            if not numOfArrows or int(numOfArrows) < 4: numOfArrows = 36\r\n            else:\r\n                try: numOfArrows = int(numOfArrows)\r\n                except: numOfArrows = 36\r\n            \r\n            # define angles\r\n            roseAngles = rs.frange(0,360,(360/numOfArrows));\r\n            if round(roseAngles[-1]) == 360: roseAngles.remove(roseAngles[-1])\r\n    \r\n            # check the scale\r\n            if scale:\r\n                HOY1 = lb_preparation.date2Hour(listInfo[0][5][0], listInfo[0][5][1], listInfo[0][5][1])\r\n                HOY2 = lb_preparation.date2Hour(listInfo[0][6][0], listInfo[0][6][1], listInfo[0][6][1])\r\n                if HOY2 - HOY1 > 24:\r\n                    scale = 1*scale/conversionFac\r\n                else:\r\n                    scale = 1000*scale/conversionFac\r\n            else:\r\n                HOY1 = lb_preparation.date2Hour(listInfo[0][5][0], listInfo[0][5][1], listInfo[0][5][1])\r\n                HOY2 = lb_preparation.date2Hour(listInfo[0][6][0], listInfo[0][6][1], listInfo[0][6][1])\r\n                if HOY2 - HOY1 > 24:\r\n                    scale = 1/conversionFac\r\n                else:\r\n                    scale = 1000/conversionFac\r\n            internalScale = 0.3\r\n            \r\n            # check vertical surface angle\r\n            if surfaceTiltAngle == None: surfaceTiltAngle = 90\r\n            else:\r\n                try: surfaceTiltAngle = float(surfaceTiltAngle)\r\n                except: surfaceTiltAngle = 90 \r\n            \r\n            #separate total, diffuse and direct radiations\r\n            separatedLists = []\r\n            for i in range(len(indexList)-1):\r\n                selList = []\r\n                [selList.append(float(x)) for x in genCumSkyResult[indexList[i] + 7:indexList[i+1]]]\r\n                separatedLists.append(selList)\r\n            \r\n            \r\n            ######################\r\n            # start visualization#\r\n            ######################\r\n            \r\n            # generate the legend\r\n            legendTitles = [listInfo[0][3], listInfo[1][3], listInfo[2][3]]\r\n            customHeading = ['Total Radiation('+ listInfo[0][3]+')', 'Diffuse Radiation(' + listInfo[1][3] + ')', 'Direct Radiation(' + listInfo[2][3] + ')']\r\n            \r\n            def visualizeData(i, northAngle, northVector, results, arrows, legendTitle, legendPar, bakeIt, cenPt):\r\n                movingVector = rc.Geometry.Vector3d(i * movingDist, 0, 0)\r\n                overwriteScale = False\r\n                if legendPar == []: overwriteScale = True\r\n                elif legendPar[5] == None: overwriteScale = True\r\n                \r\n                lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\r\n                if overwriteScale: legendScale = 0.9\r\n                \r\n                legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(results\r\n                , lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\r\n                \r\n                titleTextCurve, titleStr, titlebasePt = lb_visualization.createTitle([listInfo[i]], lb_visualization.BoundingBoxPar, legendScale, customHeading[i], False, legendFont, legendFontSize, legendBold)\r\n                \r\n                compassCrvs, compassTextPts, compassText = lb_visualization. compassCircle(cenPt, northVector, 0.3 * scale * legendMax[i], roseAngles, 1.2*textSize, True)\r\n                numberCrvs = lb_visualization.text2srf(compassText, compassTextPts, 'Times New Romans', textSize/1.7, False)\r\n                compassCrvs = compassCrvs + lb_preparation.flattenList(numberCrvs)\r\n                \r\n                movingTransform = rc.Geometry.Transform.Translation(movingVector)\r\n                for pt in compassTextPts: pt.Transform(movingTransform)\r\n                \r\n                for crv in legendTextCrv + [compassCrvs]:\r\n                    for c in crv:\r\n                        c.Translate(movingVector) # move it to the right place\r\n                \r\n                for crv in titleTextCurve:\r\n                    for c in crv: c.Translate(movingVector) # move it to the right place\r\n                \r\n                textPt.append(titlebasePt)\r\n                \r\n                ptCount  = 0\r\n                for pt in textPt:\r\n                    ptLocation = rc.Geometry.Point(pt)\r\n                    ptLocation.Translate(movingVector) # move it to the right place\r\n                    textPt[ptCount] = rc.Geometry.Point3d(ptLocation.Location)\r\n                    ptCount += 1\r\n                    \r\n                # generate legend colors\r\n                legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors)\r\n                # color legend surfaces\r\n                legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\r\n                legendSrfs.Translate(movingVector) # move it to the right place\r\n                \r\n                # generate dome patches colors\r\n                totalRadiationColors = lb_visualization.gradientColor(results, lowB, highB, customColors)\r\n                arrowsJoined = rc.Geometry.Mesh();\r\n                # mesh the patches\r\n                meshParam = rc.Geometry.MeshingParameters.Smooth\r\n                \r\n                cenPtMoved = rc.Geometry.Point3d.Add(cenPt, movingVector)\r\n                \r\n                colForMesh = []; arrowsEndPts = []\r\n                \r\n                for arrow in arrows:\r\n                    arrow.Flip(True, True, True)\r\n                    newMesh = arrow.DuplicateMesh()\r\n                    if newMesh:\r\n                        newMesh.Translate(movingVector) # move it to the right place\r\n                        arrowsJoined.Append(newMesh) # append to the main mesh\r\n                        endPt = newMesh.Vertices[2]\r\n                        # if endPt.X < cenPtMoved.X:\r\n                        endPt = rc.Geometry.Point3d.Add(endPt, -1.1*textSize* rc.Geometry.Vector3d.XAxis)\r\n                        arrowsEndPts.append(endPt)\r\n                        newMesh.Dispose() # delete the polysurface\r\n                \r\n                # color the meshed patches\r\n                domeMeshed = lb_visualization.colorMesh(totalRadiationColors, arrowsJoined, False)\r\n                \r\n                placeName = listInfo[i][1]\r\n                skyTypes = ['Total_Radiation' + placeName[:3], 'Diffuse_Radiation' + placeName[:3], 'Direct_Radiation' + placeName[:3]]\r\n                \r\n                if legendBasePoint == None:\r\n                    nlegendBasePoint = lb_visualization.BoundingBoxPar[0]\r\n                    movedLegendBasePoint = rc.Geometry.Point3d.Add(nlegendBasePoint, movingVector);\r\n                else:\r\n                    movedLegendBasePoint = rc.Geometry.Point3d.Add(legendBasePoint, movingVector);\r\n                \r\n                \r\n                if bakeIt > 0:\r\n                    #Put all of the curves together.\r\n                    finalCrvs = []\r\n                    for crv in compassCrvs:\r\n                        try:\r\n                            testPt = crv.PointAtEnd\r\n                            finalCrvs.append(crv)\r\n                        except: pass\r\n                    #Put the text together\r\n                    legendText.append(titleStr)\r\n                    legendText.extend(compassText)\r\n                    textPt.extend(compassTextPts)\r\n                    # check the study type\r\n                    studyLayerName = 'RADIATION_ROSE'\r\n                    newLayerIndex, l = lb_visualization.setupLayers(skyTypes[i], 'LADYBUG', placeName, studyLayerName, False, False, 0, 0)\r\n                    \r\n                    if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, domeMeshed, legendSrfs, legendText, textPt, textSize, legendFont, finalCrvs, decimalPlaces, True)\r\n                    else: lb_visualization.bakeObjects(newLayerIndex, domeMeshed, legendSrfs, legendText, textPt, textSize, legendFont, finalCrvs, decimalPlaces, False)\r\n                \r\n                return domeMeshed, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], compassCrvs, arrowsEndPts, movedLegendBasePoint\r\n            \r\n            if not showTotalOnly: skyTypes = 3\r\n            else: skyTypes = 1\r\n            \r\n            zVector = (0,0,1)\r\n            # calculate the vectors\r\n            # this is a copy-paste from the old version\r\n            NVecTilted = rs.VectorRotate(zVector, -float(surfaceTiltAngle), (1,0,0))\r\n            movingVectors = []; tiltedRoseVectors = []\r\n            for angle in roseAngles:\r\n                movingVectors.append(rs.VectorRotate(northVector, float(angle), (0,0,1)))\r\n                tiltedRoseVectors.append(rs.VectorRotate(NVecTilted, float(angle), (0,0,1)))\r\n            \r\n            \r\n            ## mesh the context geometires\r\n            if len(context)!=0:\r\n                ## clean the geometry and bring them to rhinoCommon separated as mesh and Brep\r\n                contextMesh, contextBrep = lb_preparation.cleanAndCoerceList(context)\r\n                \r\n                ## mesh Brep\r\n                contextMeshedBrep = lb_mesh.parallel_makeContextMesh(contextBrep)\r\n                \r\n                ## Flatten the list of surfaces\r\n                contextMeshedBrep = lb_preparation.flattenList(contextMeshedBrep)\r\n                contextSrfs = contextMesh + contextMeshedBrep\r\n                \r\n                # join the mesh\r\n                if contextSrfs: contextSrfs = lb_mesh.joinMesh(contextSrfs)\r\n                \r\n            else: contextSrfs = []\r\n            \r\n\r\n            radResult = []\r\n            for i in range(skyTypes):\r\n                if centerPoint == None: cenPt = rc.Geometry.Point3d.Origin\r\n                else: cenPt = centerPoint\r\n                \r\n                # rotating the vectors\r\n                if northVector != rc.Geometry.Vector3d.YAxis:\r\n                    rotatoionAngle= rc.Geometry.Vector3d.VectorAngle(northVector, rc.Geometry.Vector3d.YAxis, rc.Geometry.Plane.WorldXY)\r\n                    for vectorCount, vec in enumerate(tiltedRoseVectors):\r\n                        rcVector = rc.Geometry.Vector3d(vec)\r\n                        rcVector.Rotate(rotatoionAngle, rc.Geometry.Vector3d.ZAxis)\r\n                        patchesNormalVectors[vectorCount] = (rcVector.X, rcVector.Y, rcVector.Z)\r\n                        \r\n                    if contextSrfs!=[]: contextSrfs.Rotate(rotatoionAngle, rc.Geometry.Vector3d.ZAxis, cenPt)\r\n                    \r\n                radResult.append(lb_runStudy_GH.calRadRoseRes(tiltedRoseVectors, patchesNormalVectors, separatedLists[i], cenPt, contextSrfs))\r\n            \r\n            normLegend = False; res = [[], [], [], [], [], []];\r\n            if not showTotalOnly:\r\n                legendMax = [max(radResult[0]), max(radResult[1] + radResult[2]), max(radResult[1] + radResult[2])]\r\n                legendMin = [0,0,0]\r\n            else:\r\n                legendMax = [max(radResult[0])]\r\n                legendMin = [0]\r\n            \r\n            for i in range(skyTypes):\r\n                # fix the bake\r\n                try:\r\n                    if legendPar[1] is None or normLegend:\r\n                        legendPar[1] = legendMax[i]\r\n                        legendPar[0] = legendMin[i]\r\n                        normLegend = True\r\n                except:\r\n                    # make an initial legend parameter to replace the max\r\n                    legendPar = [None,None,None,[],None, None, None, None, None, None, None]\r\n                    legendPar[1] = legendMax[i]\r\n                    legendPar[0] = legendMin[i]\r\n                    normLegend = True\r\n                \r\n                \r\n                # generate arrows\r\n                cenPt = lb_preparation.getCenPt(centerPoint)\r\n                arrows = lb_preparation.genRadRoseArrows(movingVectors, radResult[i], cenPt, float(scale), internalScale, arrowHeadScale)\r\n                \r\n                tempCircle = rc.Geometry.Circle(cenPt, 1.2 * internalScale * float(scale)*max(radResult[i])).ToNurbsCurve()\r\n                # calculate the bounding box for the skyDome\r\n                if i == 0:\r\n                    try:\r\n                        lb_visualization.calculateBB([tempCircle]) #arrows)\r\n                        movingDist = 1.5 * lb_visualization.BoundingBoxPar[1] # moving distance for radiation rose\r\n                    except:\r\n                        print \"Input Radiation values are all 0\"\r\n                        w = gh.GH_RuntimeMessageLevel.Warning\r\n                        ghenv.Component.AddRuntimeMessage(w, \"Input Radiation values are all 0\")\r\n                        return -1\r\n                \r\n                arrowsColored, leg, compassCrvs, arrowsEndPts, legendBsePt= visualizeData(i, northAngle, northVector, radResult[i], arrows, legendTitles[i], legendPar, bakeIt, cenPt)\r\n                \r\n                res[0].append(arrowsColored)\r\n                res[1].append(leg)\r\n                res[2].append(compassCrvs)\r\n                res[3].append(legendBsePt)\r\n                res[4].append(arrowsEndPts)\r\n                strResult = []\r\n                [strResult.append(\"%.2f\"%num) for num in radResult[i]]\r\n                res[5].append(strResult)\r\n            # remove the sky polysurfaces\r\n            for arrow in arrows: arrow.Dispose()\r\n            \r\n            return res\r\n        else:\r\n            print \"Please provide valid selctedSkyMtx!\"\r\n            w = gh.GH_RuntimeMessageLevel.Warning\r\n            ghenv.Component.AddRuntimeMessage(w, \"Please provide valid selctedSkyMtx!\")\r\n            return -1\r\n    else:\r\n        print \"You should first let the Ladybug fly...\"\r\n        w = gh.GH_RuntimeMessageLevel.Warning\r\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\r\n        return -1\r\n\r\n\r\nif _runIt:\r\n    result = main(north_, _selectedSkyMtx, context_, _numOfArrows_, _surfaceTiltAngle_, _centerPoint_,\r\n                   _scale_, _arrowHeadScale_, legendPar_, showTotalOnly_, bakeIt_)\r\n    \r\n    if result!= -1:\r\n        legend = DataTree[Object]()\r\n        radiationArrowsMesh = DataTree[Object]()\r\n        radRoseBaseCrvs = DataTree[Object]()\r\n        legendBasePts = DataTree[Object]()\r\n        radRoseEndPts = DataTree[Object]()\r\n        radRoseValues = DataTree[Object]()\r\n        for i, leg in enumerate(result[1]):\r\n            p = GH_Path(i)\r\n            radiationArrowsMesh.Add(result[0][i], p)\r\n            radRoseBaseCrvs.AddRange(result[2][i], p)\r\n            legend.Add(leg[0], p)\r\n            legend.AddRange(leg[1], p)\r\n            legendBasePts.Add(result[3][i], p)\r\n            radRoseEndPts.AddRange(result[4][i], p)\r\n            radRoseValues.AddRange(result[5][i], p)\r\n        ghenv.Component.Params.Output[4].Hidden = True       \r\n        ghenv.Component.Params.Output[5].Hidden = True\r\nelse: print \"Set _runIt to True!\"\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}