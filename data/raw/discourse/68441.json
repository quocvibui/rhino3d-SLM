{
  "source_url": "https://discourse.mcneel.com/t/how-to-trigger-updates-down-only-selected-outputs-of-component/68441",
  "topic_id": 68441,
  "title": "How to trigger updates down only selected outputs of component?",
  "question": "Hi everyone!\n\n\nSo, the high-level questions is: is there any way to select which outputs of a component trigger an update?\n\n\nExample: I have a custom-made component that takes an input \nmutableIn\n whichever, and outputs \nmutableOut\n and \nimmutableOut\n. Given any change in the output of \nmutableIn\n, I want the output  of \nmutableOut\n to change (and trigger new solver instances down the graph), but the value of \nimmutableOut\n to remain the same \nand not trigger solve instances down its graph\n.\n\n\nUnder this assumption, in the following example, the data recorder on \nimmutableOut\n should remain with one single instance of “immutable” no matter how much we fiddled with the slider:\n\n\nimage\n1608×588 60.8 KB\n\n\nThe big picture: I am trying to develop a WebSocket listener with periodic updates which should only trigger selected updates if the value of the stream of messages that is receiving changes over a certain threshold…\n\n\nThanks!\n\n\nJL",
  "code_blocks": [
    {
      "code": "using System;\nusing Grasshopper.Kernel;\nusing Grasshopper.Kernel.Data;\nusing Grasshopper.Kernel.Types;\n\nnamespace TestComponent\n{\n  public sealed class SmartUpdateComponent : GH_Component\n  {\n    public SmartUpdateComponent()\n      : base(\"Smart Update\", \"Smupdate\", \"Only trigger an update if a value changes.\", \"Test\", \"Test\")\n    {\n      UpdateOutput = true;\n      PreviousData = \"none\";\n    }\n    public override Guid ComponentGuid => new Guid(\"{60F1F671-78F5-4A23-87EA-CC2BF6B6C296}\");\n\n    protected override void RegisterInputParams(GH_InputParamManager pManager)\n    {\n      pManager.AddIntegerParameter(\"Input\", \"In\", \"Data input.\", GH_ParamAccess.tree);\n      pManager[0].Optional = true;\n    }\n    protected override void RegisterOutputParams(GH_OutputParamManager pManager)\n    {\n      pManager.AddIntegerParameter(\"Output\", \"Out\", \"Data output.\", GH_ParamAccess.tree);\n    }\n\n    /// <summary>\n    /// Gets or sets whether the immutable output ought to be assigned.\n    /// </summary>\n    private bool UpdateOutput { get; set; }\n    /// <summary>\n    /// Gets or sets the cached data from last time.\n    /// </summary>\n    private string PreviousData { get; set; }\n\n    protected override void ExpireDownStreamObjects()\n    {\n      if (UpdateOutput)\n        Params.Output[0].ExpireSolution(false);\n    }\n    protected override void SolveInstance(IGH_DataAccess access)\n    {\n      // This stops the component from assigning nulls \n      // if we don't assign anything to an output.\n      access.DisableGapLogic();\n\n      // Get the current tree and immediately assign it to the output.\n      // Better safe than sorry. Since we only selectively expire the\n      // output we should still prevent updates, however there is no\n      // reason to not have the most recent data always in the output.\n      access.GetDataTree(0, out GH_Structure<GH_Integer> tree);\n      access.SetDataTree(0, tree);\n\n      string currentData = tree.DataDescription(false, true);\n\n      // If we were supposed to update the output (meaning it was expired), \n      // then we know for sure that we don't have to update again.\n      if (UpdateOutput)\n      {\n        UpdateOutput = false;\n        PreviousData = currentData;\n        return;\n      }\n\n      // If the current data differs from the last time,\n      // we need to remember that the output needs updating and\n      // we need to schedule a new solution so we can actually do this.\n      if (!string.Equals(PreviousData, currentData))\n      {\n        UpdateOutput = true;\n        PreviousData = currentData;\n\n        var doc = OnPingDocument();\n        doc?.ScheduleSolution(5, Callback);\n      }\n    }\n    private void Callback(GH_Document doc)\n    {\n      // The logic is all in our expiration method, but we do have \n      // to expire this component.\n      if (UpdateOutput)\n        ExpireSolution(false);\n    }\n  }\n}",
      "language": "csharp",
      "author": "DavidRutten",
      "post_number": 4,
      "is_solution": false
    },
    {
      "code": "using System;\nusing System.Collections.Generic;\n\nusing Grasshopper.Kernel;\nusing Grasshopper.Kernel.Data;\nusing Grasshopper.Kernel.Types;\nusing Rhino.Geometry;\n\nnamespace MachinaGrasshopper.Bridge\n{\n    // From: https://discourse.mcneel.com/t/how-to-trigger-updates-down-only-selected-outputs-of-component/68441\n    public sealed class SmartUpdateComponentMultipleInputs : GH_Component\n    {\n        /// <summary>\n        /// Number of IOs this component will have. \n        /// Must be hardcoded in the component since RegisterInputParams runs before the constructor.\n        /// </summary>\n        private const int IOCount = 4;\n\n        /// <summary>\n        /// Gets or sets whether the immutable output ought to be assigned.\n        /// </summary>\n        public bool[] UpdateOutput { get; set; }\n\n        /// <summary>\n        /// Gets or sets the cached data from last time.\n        /// </summary>\n        public string[] PreviousData { get; set; }\n\n        public SmartUpdateComponentMultipleInputs()\n          : base(\"Smart Update Multiple Inputs\", \"SmupdateMI\", \"Only trigger an update if a value changes.\", \"Test\", \"Test\")\n        {\n            UpdateOutput = new bool[IOCount];\n            PreviousData = new string[IOCount];\n            for (int i = 0; i < IOCount; i++)\n            {\n                UpdateOutput[i] = true;\n                PreviousData[i] = \"nastideplasti\";\n            }\n        }\n        public override Guid ComponentGuid => new Guid(\"3736547e-360a-4fff-9ed5-a05406cc43c1\");\n\n        protected override void RegisterInputParams(GH_InputParamManager pManager)\n        {\n            for (int i = 0; i < IOCount; i++)\n            {\n                pManager.AddIntegerParameter(\"in\" + i, \"in\" + i, \"Data Input \" + i, GH_ParamAccess.tree);\n                pManager[i].Optional = true;\n            }\n        }\n        protected override void RegisterOutputParams(GH_OutputParamManager pManager)\n        {\n            for (int i = 0; i < IOCount; i++)\n            {\n                pManager.AddIntegerParameter(\"out\" + i, \"out\" + i, \"Data Output \" + i, GH_ParamAccess.tree);\n                pManager[i].Optional = true;\n            }\n        }\n\n\n        /// <summary>\n        /// Override the behavior of when outputs are expired\n        /// </summary>\n        protected override void ExpireDownStreamObjects()\n        {\n            for (int i = 0; i < IOCount; i++)\n            {\n                if (UpdateOutput[i])\n                {\n                    Params.Output[i].ExpireSolution(false);\n                }\n            }\n\n        }\n\n        protected override void SolveInstance(IGH_DataAccess access)\n        {\n            // This stops the component from assigning nulls \n            // if we don't assign anything to an output.\n            access.DisableGapLogic();\n\n\n            // Get the current tree and immediately assign it to the output.\n            // Better safe than sorry. Since we only selectively expire the\n            // output we should still prevent updates, however there is no\n            // reason to not have the most recent data always in the output.\n            bool doneWithUpdates = false;\n            GH_Structure<GH_Integer> tree;\n            string[] currentData = new string[IOCount];\n            for (int i = 0; i < IOCount; i++)\n            {\n                // Check if any input was flagged for an update.\n                doneWithUpdates |= UpdateOutput[i];\n\n                access.GetDataTree(i, out tree);\n                access.SetDataTree(i, tree);\n\n                currentData[i] = tree.DataDescription(false, true);\n\n                // Unflag inputs that were due for updates. \n                if (UpdateOutput[i])\n                {\n                    UpdateOutput[i] = false;\n                    PreviousData[i] = currentData[i];\n                }\n\n            }\n\n            // If any input was flagged for an update, the program is\n            // executing the second solution and should stop solving,\n            // e.g. if we were supposed to update the output (meaning it \n            // was expired), then we know for sure that we don't have to \n            // update again.\n            if (doneWithUpdates)\n            {\n                return;\n            }\n\n            // If the current data differs from the last time,\n            // we need to remember that the output needs updating and\n            // we need to schedule a new solution so we can actually do this.\n            bool scheduleSolution = false;\n            for (int i = 0; i < IOCount; i++)\n            {\n                // Compare int trees by using string description including tree info\n                if (!string.Equals(PreviousData[i], currentData[i]))\n                {\n                    UpdateOutput[i] = true;\n                    PreviousData[i] = currentData[i];\n                }\n\n                // If flagged any UpdateOutput, we will need to schedule a new solution.\n                scheduleSolution |= UpdateOutput[i];\n            }\n\n            // Schedule new solution if any ouput needed an update\n            if (scheduleSolution)\n            {\n                var doc = OnPingDocument();\n                doc?.ScheduleSolution(5, Callback);\n            }\n        }\n\n        private void Callback(GH_Document doc)\n        {\n            // The logic is all in our expiration method, but we do have \n            // to expire this component.\n            bool expire = false;\n            foreach(var up in UpdateOutput)\n            {\n                if (up)\n                {\n                    expire = up;\n                    break;\n                }\n            }\n\n            if (expire)\n                ExpireSolution(false);\n        }\n    }\n}",
      "language": "csharp",
      "author": "garciadelcastillo",
      "post_number": 7,
      "is_solution": true
    }
  ],
  "tags": [
    "csharp",
    "grasshopper",
    "rhinocommon"
  ],
  "has_accepted_answer": true,
  "category_id": 8,
  "posts_count": 11,
  "views": 5073
}