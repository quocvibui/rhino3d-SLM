{
  "source_url": "https://discourse.mcneel.com/t/nature-of-code-force-attracto/100536",
  "topic_id": 100536,
  "title": "Nature of code - force, attracto",
  "question": "I want to implement the following:\n\n\n2.6: Gravitational Attraction - The Nature of Code\n\n\n \n\n\n\n\n !\n\nby rhino, grasshopper, python\n\n\nalso I Referenced:\n\n\n\n\n\n\n\n\nGitHub\n\n\n\n\n\n\n\n\nnature-of-code/noc-examples-python\n\n\nPython port (via processing.py) of The Nature of Code Examples - nature-of-code/noc-examples-python\n\n\n\n\n\n\n\n\n\n\n\n\nbut it didn’t work well…\n\nit have to go round, but it comes out straight.\n\n\nHere is my script\n\n\nPlease advise…\n\n\ncoding train, python.gh\n (5.7 KB) \nmover.3dm\n (23.5 KB)\n\n\nasd|452x424\n \n\n\nasdf\n582×922 36.7 KB",
  "code_blocks": [
    {
      "code": "import Rhino.Geometry as rg\nimport Grasshopper as gh\nimport scriptcontext as sc\n\n\nWIDTH = 100 # Global volume width\nDEPTH = 100 # Global volume depth\nHEIGHT = 100 # Gobal volume height\nG = 1 # Global gravitational constant\n\n\nclass Mover():\n    def __init__(self, position):\n        global WIDTH, DEPTH, HEIGHT\n        self.position = position\n        self.velocity = rg.Vector3d.Zero\n        self.acceleration = rg.Vector3d.Zero\n        self.mass = 1\n        self.max_speed = 10\n        \n    def apply_force(self, force):\n        #Newton's 2nd Law with mass!\n        self.acceleration += force / self.mass\n\n    def update(self):\n        #update location, velocity\n        self.velocity += self.acceleration\n        self.position += self.velocity\n        print \"Acceleration: \", self.acceleration\n        self.acceleration *= 0.0\n\n    def check_edges(self):\n        bounce = -1\n        if self.position.X >= WIDTH or self.position.X <= 0:\n            self.velocity.X = self.velocity.X * bounce\n        if self.position.Y >= DEPTH or self.position.Y <= 0:\n            self.velocity.Y = self.position.Y * bounce\n        if self.position.Z >= HEIGHT or self.position.Z <= 0:\n            self.velocity.Z = self.velocity.Z * bounce\n            \n    def display(self):\n        return self.position\n\n\nclass Attractor():\n    def __init__(self):\n        global WIDTH, DEPTH, HEIGHT, G\n        self.position = rg.Vector3d(WIDTH / 2, DEPTH / 2, HEIGHT / 2)\n        self.mass = 20 # Mass, tied to size\n        \n    def attract(self, mover):\n        # Calculate the direction of force vector\n        force = self.position - mover.position\n        # Constrain the magnitude of the force vector to eliminate \n        # \"extreme\" results for very close or very far objects\n        force = vector_constrain(force, 5.0, 25.0)\n        dist = force.Length # constrained distance/magnitude\n        # Normalize the force vector (distance doesn't matter here, we just\n        # want this vector for direction)\n        force.Unitize()\n        # Calculate the gravitational force magnitude \n        strength = (G * self.mass * mover.mass) / dist**2\n        # Get the force vector (magnitude x direction)\n        force *= strength\n        return force\n        \n    def display(self):\n        return rg.Sphere(rg.Point3d(self.position), self.mass / 2)\n\n\n################################################################################\n\n\ndef vector_constrain(vec, min_mag=0, max_mag=20):\n    \"\"\"Returns a vector whose magnitude is constrained \n        inbetween a minimum and maximum value.\"\"\"\n    if (vec.Length <= max_mag and vec.Length >= min_mag):\n        return vec\n    if (vec.Length > max):\n        mag = max_mag\n    if (vec.Length < min):\n        mag = min_mag\n    vec.Unitize()\n    vec *= mag\n    return vec\n\n\ndef update_component():\n    \"\"\"Updates this GH component, similar to using a Grasshopper timer.\"\"\"\n    def call_back(e):\n        \"\"\"Defines a callback action.\"\"\"\n        ghenv.Component.ExpireSolution(False)\n    # Get the Grasshopper document\n    ghDoc = ghenv.Component.OnPingDocument() \n    # Schedule this component to expire\n    ghDoc.ScheduleSolution(1, gh.Kernel.GH_Document.GH_ScheduleDelegate(call_back))\n\n\n################################################################################\n\n\nif Reset or \"count\" not in globals():\n    sc.sticky.pop(\"Simulation\", None)\n    count = 0\n    print count\n    ghenv.Component.Message = \"Reset\"\n\nif Run:\n    # Setup the simulation\n    if not \"Simulation\" in sc.sticky.keys():\n        # Initialise a new mover and attractor\n        mv = Mover(Location)\n        a = Attractor()\n    else:\n        # Get the existing mover and attractor\n        mv = sc.sticky[\"Simulation\"][\"Mover\"]\n        a = sc.sticky[\"Simulation\"][\"Attractor\"]\n    \n    # Update/draw the simulation\n    f = a.attract(mv)\n    mv.apply_force(f)\n    mv.update()\n    count += 1\n    \n    # Store the current iteration/frame in the sticky dictionary\n    sc.sticky[\"Simulation\"] = {\"Mover\": mv, \"Attractor\": a}\n    \n    if count < MaxCount:\n        update_component()\n        ghenv.Component.Message = \"Running...\"\n    else:\n        ghenv.Component.Message = \"Converged\"\n    \n    print count\n    \n    # Display/outputs\n    MPos = mv.display()\n    AGeo = a.display()\n\nelse:\n    # Pause the simulation\n    if \"Simulation\" in sc.sticky.keys():\n        # Get the existing mover and attractor, and pause\n        mv = sc.sticky[\"Simulation\"][\"Mover\"]\n        a = sc.sticky[\"Simulation\"][\"Attractor\"]\n        \n        ghenv.Component.Message = \"Paused\"\n        \n        print count\n        \n        # Display/outputs\n        MPos = mv.display()\n        AGeo = a.display()",
      "language": "python",
      "author": "diff-arch",
      "post_number": 2,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 2,
  "posts_count": 5,
  "views": 1026
}