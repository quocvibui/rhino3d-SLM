{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/converters/render_mesh.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/converters/render_mesh.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2018-2024 Nathan Letwory, Joel Putnam, Tom Svilans, Lukas Fertig\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport bpy\nimport rhino3dm as r3d\nfrom . import utils\nimport bpy\nimport bmesh\nimport bpy.app\n\nimport traceback\n\n\ndef import_render_mesh(context, ob, name, scale, options):\n    # concatenate all meshes from all (brep) faces,\n    # adjust vertex indices for faces accordingly\n    # first get all render meshes\n    og = ob.Geometry\n    oa = ob.Attributes\n\n    needs_welding = True\n\n    msh_tex = list()\n    if og.ObjectType == r3d.ObjectType.Extrusion:\n        msh = [og.GetMesh(r3d.MeshType.Any)]\n    elif og.ObjectType == r3d.ObjectType.Mesh:\n        msh = [og]\n    elif og.ObjectType == r3d.ObjectType.SubD:\n        msh = [r3d.Mesh.CreateFromSubDControlNet(og, False)]\n        msh_tex = [r3d.Mesh.CreateFromSubDControlNet(og, True)]\n    elif og.ObjectType == r3d.ObjectType.Brep:\n        msh = [og.Faces[f].GetMesh(r3d.MeshType.Any) for f in range(len(og.Faces)) if type(og.Faces[f])!=list]\n    fidx = 0\n    faces = []\n    vertices = []\n    coords = []\n    vcls = []\n\n    # now add all faces and vertices to the main lists\n    for m in msh:\n        if not m:\n            continue\n        faces.extend([list(map(lambda x: x + fidx, m.Faces[f])) for f in range(len(m.Faces))])\n\n        # Rhino always uses 4 values to describe faces, which can lead to\n        # invalid faces in Blender. Tris will have a duplicate index for the 4th\n        # value.\n        for f in faces:\n            if f[-1] == f[-2]:\n                del f[-1]\n\n        fidx = fidx + len(m.Vertices)\n        vertices.extend([(m.Vertices[v].X * scale, m.Vertices[v].Y * scale, m.Vertices[v].Z * scale) for v in range(len(m.Vertices))])\n        coords.extend([(m.TextureCoordinates[v].X, m.TextureCoordinates[v].Y) for v in range(len(m.TextureCoordinates))])\n        vcls.extend((m.VertexColors[v][0], m.VertexColors[v][1], m.VertexColors[v][2], m.VertexColors[v][3]) for v in range(len(m.VertexColors)))\n\n    tags = utils.create_tag_dict(oa.Id, oa.Name)\n    mesh = utils.get_or_create_iddata(context.blend_data.meshes, tags, None)\n    mesh.clear_geometry()\n    mesh.from_pydata(vertices, [], faces, shade_flat=False)\n\n    coords_tex = list()\n    for mt in msh_tex:\n        if not mt:\n            continue\n        coords_tex.extend([(mt.TextureCoordinates[v].X, mt.TextureCoordinates[v].Y) for v in range(len(mt.TextureCoordinates))])\n\n    if mesh.loops:  # and len(coords) == len(vertices):\n        # todo:\n        # * check for multiple mappings and handle them\n        # * get mapping name (missing from rhino3dm)\n        # * rhino assigns a default mapping to unmapped objects, so if nothing is specified, this will be imported\n\n        #create a new uv_layer and copy texcoords from input mesh\n        mesh.uv_layers.new(name=\"RhinoUVMap\")\n\n        if sum(len(x) for x in faces) == len(mesh.uv_layers[\"RhinoUVMap\"].data):\n            uvl = mesh.uv_layers[\"RhinoUVMap\"].data[:]\n\n            for loop in mesh.loops:\n                try:\n                    if coords_tex:\n                        uvl[loop.index].uv = coords_tex[loop.index]\n                    elif coords:\n                        # print(loop.index, loop.vertex_index, len(uvl), len(coords))\n                        uvl[loop.index].uv = coords[loop.vertex_index]\n                    else:\n                        print(\"no tex coords\")\n                except IndexError:\n                    print(name)\n                    print(traceback.format_exc())\n\n            mesh.validate()\n            mesh.update()\n\n        else:\n            #in case there was a data mismatch, cleanup the created layer\n            mesh.uv_layers.remove(mesh.uv_layers[\"RhinoUVMap\"])\n\n    if len(vcls) == len(vertices):\n        mesh.attributes.new(\"RhinoColor\", \"FLOAT_COLOR\", \"POINT\")\n        rcl = mesh.attributes[\"RhinoColor\"]\n        for i in range(len(vcls)):\n            vcl = vcls[i]\n            rcl.data[i].color =  (vcl[0] / 255.0, vcl[1] / 255.0, vcl[2] / 255.0, vcl[3] / 255.0)\n\n        mesh.validate()\n        mesh.update()\n\n    if needs_welding:\n        bm = bmesh.new()\n        bm.from_mesh(mesh)\n        bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=0.001)\n        bm.to_mesh(mesh)\n        bm.free()\n        if bpy.app.version >= (4, 1):\n            mesh.set_sharp_from_angle(angle=0.523599) # 30deg\n        else:\n            mesh.use_auto_smooth = True\n\n    # done, now add object to blender\n    return mesh\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}