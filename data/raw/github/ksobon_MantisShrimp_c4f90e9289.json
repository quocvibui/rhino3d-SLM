{
  "source_url": "https://github.com/ksobon/MantisShrimp/blob/9b3d1ef747a04f75f3542c38550c4e29b9d08c8f/Grasshopper/mantisshrimp.py",
  "repo": "ksobon/MantisShrimp",
  "repo_stars": 39,
  "repo_description": "A interop project for bridging the gap between Rhino/Grasshopper and Revit/Dynamo",
  "license": "unknown",
  "filepath": "Grasshopper/mantisshrimp.py",
  "instruction": "Copyright(c) 2015, Konrad Sobon\n@arch_laboratory, http://archi-lab.net",
  "code": "\"\"\"\nCopyright(c) 2015, Konrad Sobon\n@arch_laboratory, http://archi-lab.net\n\nGrasshopper and Dynamo interop library\n\n\"\"\"\nimport clr\nimport sys\nsys.path.append(r\"C:\\Program Files\\Dynamo 0.9\")\nclr.AddReference('ProtoGeometry')\n\npyt_path = r'C:\\Program Files (x86)\\IronPython 2.7\\Lib'\nsys.path.append(pyt_path)\n\nimport os\nimport os.path\nappDataPath = os.getenv('APPDATA')\nmsPath = appDataPath + r\"\\Dynamo\\0.9\\packages\\Mantis Shrimp\\extra\"\nif msPath not in sys.path:\n        sys.path.Add(msPath)\ntxtFilePath = appDataPath + r\"\\Dynamo\\0.9\\packages\\Mantis Shrimp\\extra\\rhPath.txt\"\nif not os.path.isfile(txtFilePath):\n\tmessage = \"Provide valid RhinoCommon.dll path.\"\nelse:\n\tfile = open(txtFilePath, 'r+')\n\trhDllPath = file.readline()\n\tclr.AddReferenceToFileAndPath(rhDllPath)\n\tfile.close()\n\nfrom System import *\nfrom System.Collections.Generic import *\nimport Autodesk.DesignScript as ds\nimport Rhino as rc\nimport pickle\n\n\"\"\" Misc Functions \"\"\"\ndef process_list(_func, _list):\n    return map( lambda x: process_list(_func, x) if type(x)==list else _func(x), _list )\n\n#join/group curves function\ndef groupCurves(Line_List): \n\tignore_distance = 0.1\n\tGrouped_Lines = [] \n\tQueue = set() \n\twhile Line_List: \n\t\tShape = [] \n\t\tQueue.add(Line_List.pop())\n\t\twhile Queue: \n\t\t\tCurrent_Line = Queue.pop() \n\t\t\tShape.append(Current_Line) \n\t\t\tfor Potential_Match in Line_List: \n\t\t\t\tPoints = (Potential_Match.StartPoint, Potential_Match.EndPoint)\n\t\t\t\tfor P1 in Points: \n\t\t\t\t\tfor P2 in (Current_Line.StartPoint, Current_Line.EndPoint): \n\t\t\t\t\t\tdistance = P1.DistanceTo(P2) \n\t\t\t\t\t\tif distance <= ignore_distance: \n\t\t\t\t\t\t\tQueue.add(Potential_Match) \n\t\t\tLine_List = [item for item in Line_List if item not in Queue]\n\t\tGrouped_Lines.append(Shape) \n\treturn Grouped_Lines\n\n\n\"\"\" Rhino Interop Functions \"\"\"\n#point/control point conversion function\ndef rhPointToPoint(rhPoint):\n\trhPointX = rhPoint.Location.X\n\trhPointY = rhPoint.Location.Y\n\trhPointZ = rhPoint.Location.Z\n\treturn ds.Geometry.Point.ByCoordinates(rhPointX, rhPointY, rhPointZ)\n\n#3dPoint Conversion function\ndef rhPoint3dToPoint(rhPoint):\n\trhPointX = rhPoint.X\n\trhPointY = rhPoint.Y\n\trhPointZ = rhPoint.Z\n\treturn ds.Geometry.Point.ByCoordinates(rhPointX, rhPointY, rhPointZ)\n\n#Vector3d conversion function\ndef rhVector3dToVector(rhVector):\n\tVectorX = rhVector.X\n\tVectorY = rhVector.Y\n\tVectorZ = rhVector.Z\n\treturn ds.Geometry.Vector.ByCoordinates(VectorX, VectorY, VectorZ)\n\n#Plane conversion function\ndef rhPlaneToPlane(rhPlane):\n\tnormal = rhVector3dToVector(rhPlane.Normal)\n\torigin = rhPoint3dToPoint(rhPlane.Origin)\n\tdsPlane = ds.Geometry.Plane.ByOriginNormal(origin, normal)\n\tnormal.Dispose()\n\torigin.Dispose()\n\treturn dsPlane\n\n#arc conversion function\ndef rhArcToArc(rhArc):\n\tdsStartPoint = rhPoint3dToPoint(rhArc.Arc.StartPoint)\n\tdsEndPoint = rhPoint3dToPoint(rhArc.Arc.EndPoint)\n\tdsCenter = rhPoint3dToPoint(rhArc.Arc.Center)\n\tdsArc = ds.Geometry.Arc.ByCenterPointStartPointEndPoint(dsCenter, dsStartPoint, dsEndPoint)\n\tdsStartPoint.Dispose()\n\tdsEndPoint.Dispose()\n\tdsCenter.Dispose()\n\treturn dsArc\n\n#LineCurve & Line conversion functions\ndef rhLineToLine(rhCurve):\n\ttry:\n\t\tdsStartPoint = rhPoint3dToPoint(rhCurve.From)\n\t\tdsEndPoint = rhPoint3dToPoint(rhCurve.To)\n\texcept:\n\t\tdsStartPoint = rhPoint3dToPoint(rhCurve.PointAtStart)\n\t\tdsEndPoint = rhPoint3dToPoint(rhCurve.PointAtEnd)\n\t\tpass\n\treturn ds.Geometry.Line.ByStartPointEndPoint(dsStartPoint, dsEndPoint)\n\n#circle conversion function\ndef rhCircleToCircle(rhCurve):\n\trhCircle = rhCurve.TryGetCircle()[1]\n\tradius = rhCircle.Radius\n\tplane = rhPlaneToPlane(rhCircle.Plane)\n\tdsCircle = ds.Geometry.Circle.ByPlaneRadius(plane, radius)\n\tplane.Dispose()\n\treturn dsCircle\n\n#ellipse conversion function\ndef rhEllipseToEllipse(item):\n\tpt0 = rhPointToPoint(item.Points[0])\n\tpt2 = rhPointToPoint(item.Points[2])\n\tpt4 = rhPointToPoint(item.Points[4])\n\torigin = ds.Geometry.Line.ByStartPointEndPoint(pt0, pt4).PointAtParameter(0.5)\n\tvector1 = ds.Geometry.Vector.ByTwoPoints(origin, pt2)\n\tvector2 = ds.Geometry.Vector.ByTwoPoints(origin, pt4)\n\tellipse = ds.Geometry.Ellipse.ByOriginVectors(origin, vector1, vector2)\n\tpt0.Dispose()\n\tpt2.Dispose()\n\tpt4.Dispose()\n\torigin.Dispose()\n\tvector1.Dispose()\n\tvector2.Dispose()\n\treturn ellipse\n\n#multi span nurbs curve comversion function\ndef rhMultiSpanNurbsCurveToCurve(rhCurve):\n\tdsNurbsCurve, rhSubCurve = [], []\n\tspanCount = rhCurve.SpanCount\n\tfor i in range(0, spanCount, 1):\n\t\trhCurveSubdomain = rhCurve.SpanDomain(i)\n\t\trhSubCurve.append(rhCurve.ToNurbsCurve(rhCurveSubdomain))\n\tfor curve in rhSubCurve:\n\t\tptArray, weights, knots = [], [], []\n\t\trhControlPoints = curve.Points\n\t\tfor rhPoint in rhControlPoints:\n\t\t\tdsPoint = rhPointToPoint(rhPoint)\n\t\t\tptArray.append(dsPoint)\n\t\t\tweights.append(rhPoint.Weight)\n\t\tptArray = List[ds.Geometry.Point](ptArray)\n\t\tweights = Array[float](weights)\n\t\tdegree = curve.Degree\n\t\trhKnots = curve.Knots\n\t\tfor i in rhKnots:\n\t\t\tknots.append(i)\n\t\tknots.insert(0, knots[0])\n\t\tknots.insert(len(knots), knots[(len(knots)-1)])\n\t\tknots = Array[float](knots)\n\t\tdsNurbsCurve.append(ds.Geometry.NurbsCurve.ByControlPointsWeightsKnots(ptArray, weights, knots, degree))\n\t\tcurveArray = List[ds.Geometry.Curve](dsNurbsCurve)\n\t\tpolyCurve = ds.Geometry.PolyCurve.ByJoinedCurves(curveArray)\n\t\tcurveArray.Clear()\n\t\tptArray.Clear()\n\t\tArray.Clear(weights, 0, len(weights))\n\t\tArray.Clear(knots, 0, len(knots))\n\t\t\n\treturn polyCurve\n\tdel dsNurbsCurve[:]\n\n#single span nurbs curve conversion function\ndef rhSingleSpanNurbsCurveToCurve(rhCurve):\t\t\n\tptArray, weights, knots = [], [], []\n\trhControlPoints = rhCurve.Points\n\tfor rhPoint in rhControlPoints:\n\t\tdsPoint = rhPointToPoint(rhPoint)\n\t\tptArray.append(dsPoint)\n\t\tweights.append(rhPoint.Weight)\n\tptArray = List[ds.Geometry.Point](ptArray)\n\tweights = Array[float](weights)\n\tdegree = rhCurve.Degree\n\trhKnots = rhCurve.Knots\n\tfor i in rhKnots:\n\t\tknots.append(i)\n\tknots.insert(0, knots[0])\n\tknots.insert(len(knots), knots[(len(knots)-1)])\n\tknots = Array[float](knots)\n\tdsNurbsCurve = ds.Geometry.NurbsCurve.ByControlPointsWeightsKnots(ptArray, weights, knots, degree)\n\tptArray.Clear()\n\tArray.Clear(weights, 0, len(weights))\n\tArray.Clear(knots, 0, len(knots))\n\treturn dsNurbsCurve\n\n#polyline conversion function\ndef rhPolylineToPolyCurve(rhCurve):\n\tsegments = rhCurve.GetSegments()\n\tlineArray = List[ds.Geometry.Curve]()\n\tfor i in segments:\n\t\tlineArray.Add(rhLineToLine(i))\n\tdsPolyline = ds.Geometry.PolyCurve.ByJoinedCurves(lineArray)\n\tlineArray.Clear()\n\treturn dsPolyline\n\n#poly curve conversion function\ndef rhCurveToPolyCurve(rhCurve):\n\tptArray = []\n\tpCount = rhCurve.PointCount\n\tfor i in range(0, pCount):\n\t\tdsPoint = rhPoint3dToPoint(rhCurve.Point(i))\n\t\tptArray.append(dsPoint)\n\tdsPolyCurve = ds.Geometry.PolyCurve.ByPoints(ptArray)\n\tdel ptArray[:]\n\treturn dsPolyCurve\n\n#rh polycurve conversion function\ndef rhPolyCurveToPolyCurve(rhCurve):\n\tdsSubCurves = []\n\tsegmentCount = rhCurve.SegmentCount\n\tfor i in range(0, segmentCount, 1):\n\t\tcurve = rhCurve.SegmentCurve(i)\n\t\tif curve.ToString() == \"Rhino.Geometry.LineCurve\":\n\t\t\tdsSubCurves.append(rhLineToLine(curve))\n\t\telif curve.ToString() == \"Rhino.Geometry.PolylineCurve\":\n\t\t\tdsSubCurves.append(rhCurveToPolyCurve(curve))\n\t\telif curve.ToString() == \"Rhino.Geometry.ArcCurve\":\n\t\t\tdsSubCurves.append(rhArcToArc(curve))\n\t\telif curve.ToString() == \"Rhino.Geometry.NurbsCurve\" and curve.SpanCount==1:\n\t\t\tdsSubCurves.append(rhSingleSpanNurbsCurveToCurve(curve))\n\t\telif curve.ToString() == \"Rhino.Geometry.NurbsCurve\" and curve.SpanCount > 1:\n\t\t\tdsSubCurves.append(rhMultiSpanNurbsCurveToCurve(curve))\n\t\telif curve.ToString() == \"Rhino.Geometry.PolyCurve\":\n\t\t\tsubPolyCurves = rhMultiSpanNurbsCurveToCurve(curve.ToNurbsCurve())\n\t\t\tfor curve in subPolyCurves:\n\t\t\t\tdsSubCurves.append(curve)\n\tdsPolyCurve = ds.Geometry.PolyCurve.ByJoinedCurves(dsSubCurves)\n\tdel dsSubCurves[:]\n\treturn dsPolyCurve\n\n#brep/nurbs surface conversion function\ndef rhNurbsSurfaceToSurface(rhNurbsSurface):\n\tdsNurbsSurfaces = []\n\tdsControlPoints = []\n\tdsWeights = []\n\trhControlPoints = rhNurbsSurface.Points\n\tfor point in rhControlPoints:\n\t\tdsControlPoints.append(rhPointToPoint(point))\n\t\tdsWeights.append(point.Weight)\n\trhKnotsU = rhNurbsSurface.KnotsU\n\tdsKnotsU = []\n\tfor i in rhKnotsU:\n\t\tdsKnotsU.append(i)\n\tdsKnotsU.insert(0, dsKnotsU[0])\n\tdsKnotsU.insert(len(dsKnotsU), dsKnotsU[len(dsKnotsU)-1])\n\tdsKnotsU = Array[float](dsKnotsU)\n\trhKnotsV = rhNurbsSurface.KnotsV\n\tdsKnotsV = []\n\tfor i in rhKnotsV:\n\t\tdsKnotsV.append(i)\n\tdsKnotsV.insert(0, dsKnotsV[0])\n\tdsKnotsV.insert(len(dsKnotsV), dsKnotsV[len(dsKnotsV)-1])\n\tdsKnotsV = Array[float](dsKnotsV)\n\tdsDegreeU = (rhNurbsSurface.OrderU) - 1 \n\tdsDegreeV = (rhNurbsSurface.OrderV) - 1\n\tuCount = rhNurbsSurface.SpanCount(0) + 3\n\tvCount = rhNurbsSurface.SpanCount(1) + 3\n\tnewControlPoints = [dsControlPoints[i:i+vCount] for i  in range(0, len(dsControlPoints), vCount)]\n\tnewWeights = [dsWeights[i:i+vCount] for i  in range(0, len(dsWeights), vCount)]\n\tweightsArrayArray = Array[Array[float]](map(tuple, newWeights))\n\tcontrolPointsArrayArray = Array[Array[ds.Geometry.Point]](map(tuple, newControlPoints))\n\tdsNurbsSurface = ds.Geometry.NurbsSurface.ByControlPointsWeightsKnots(controlPointsArrayArray, weightsArrayArray, dsKnotsU, dsKnotsV, dsDegreeU, dsDegreeV)\n\treturn dsNurbsSurface\n\n#brep conversion function\ndef rhBrepToPolySurface(brep):\n\tdsSubCurves, faceIndicies, trimLoops, dsFaces, trimLoop  = [], [], [], [], []\n\tfaces = brep.Faces\n\tfor face in faces:\n\t\tif face.IsSurface:\n\t\t\tdsFaces.append(rhNurbsSurfaceToSurface(face.ToNurbsSurface()))\n\t\telse:\n\t\t\ttrimFace = rhNurbsSurfaceToSurface(face.UnderlyingSurface().ToNurbsSurface())\n\t\t\tfaceLoops = face.Loops\n\t\t\tfor loop in faceLoops:\n\t\t\t\ttrims = loop.Trims\n\t\t\t\tfor trim in trims:\n\t\t\t\t\tif trim.TrimType != rc.Geometry.BrepTrimType.Seam:\n\t\t\t\t\t\tedgeIndex = trim.Edge.EdgeIndex\n\t\t\t\t\t\tedge = brep.Edges.Item[edgeIndex]\n\t\t\t\t\t\tif edge.ObjectType.ToString() == \"Curve\" and edge.SpanCount > 1:\n\t\t\t\t\t\t\tdsSubCurves.append(rhMultiSpanNurbsCurveToCurve(edge))\n\t\t\t\t\t\telif edge.ObjectType.ToString() == \"Curve\" and edge.SpanCount == 1:\n\t\t\t\t\t\t\tif edge.IsArc():\n\t\t\t\t\t\t\t\tarc = edge.TryGetArc()\n\t\t\t\t\t\t\t\tdsSubCurves.append(rhArcToArc(arc[1]))\n\t\t\t\t\t\t\telif edge.IsPolyline():\n\t\t\t\t\t\t\t\tpolyline = edge.TryGetPolyline()\n\t\t\t\t\t\t\t\tdsSubCurves.append(rhPolylineToPolyCurve(polyline[1]))\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tdsSubCurves.append(rhSingleSpanNurbsCurveToCurve(edge.ToNurbsCurve()))\t\n\t\t\ttry:\n\t\t\t\tcurveArray = List[ds.Geometry.Curve](dsSubCurves)\n\t\t\t\ttrimLoop.append(ds.Geometry.PolyCurve.ByJoinedCurves(curveArray))\n\t\t\t\tdsFaces.append(trimFace.TrimWithEdgeLoops(trimLoop))\n\t\t\t\tdel dsSubCurves[:]\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tif len(trimLoop) == 0:\n\t\t\t\tsubCurveSet = set(dsSubCurves)\n\t\t\t\tdel dsSubCurves[:]\n\t\t\t\tgroupedCurves = groupCurves(subCurveSet)\n\t\t\t\tfor i in groupedCurves:\n\t\t\t\t\tcurveArray = List[ds.Geometry.Curve](i)\n\t\t\t\t\tif curveArray.Count > 1:\n\t\t\t\t\t\ttrimLoops.append(ds.Geometry.PolyCurve.ByJoinedCurves(curveArray))\n\t\t\t\t\telse:\n\t\t\t\t\t\ttrimLoops.append(curveArray[0])\n\t\t\t\tdsFaces.append(trimFace.TrimWithEdgeLoops(trimLoops))\n\t\t\t\tdel trimLoops[:]\n\t\t\t\tdel groupedCurves[:]\n\t\t\telse:\n\t\t\t\tdel trimLoop[:]\n\ttry:\n\t\tdsSurface = ds.Geometry.PolySurface.ByJoinedSurfaces(dsFaces)\n\texcept:\n\t\tpass\n\tdel dsFaces[:]\n\treturn dsSurface\n\ndef rhMeshToMesh(rhMesh):\n\tvertexPositions, indices, indexGroups = [], [], []\n\tfaces = rhMesh.Faces\n\ttopologyVerticesList = rhMesh.TopologyVertices\n\tfor i in range(0, rhMesh.Faces.Count, 1):\n\t\tindices.append(faces.GetTopologicalVertices(i))\n\tfor i in range(0, topologyVerticesList.Count, 1):\n\t\tvertexPositions.append(rhPoint3dToPoint(topologyVerticesList.Item[i]))\n\tfor i in indices:\n\t\tif len(i) == 3:\n\t\t\ta = i[0]\n\t\t\tb = i[1]\n\t\t\tc = i[2]\n\t\t\tindexGroups.append(ds.Geometry.IndexGroup.ByIndices(a,b,c))\n\t\telif len(i) == 4:\n\t\t\ta = i[0]\n\t\t\tb = i[1]\n\t\t\tc = i[2]\n\t\t\td = i[3]\n\t\t\tindexGroups.append(ds.Geometry.IndexGroup.ByIndices(a,b,c,d))\n\tdsMesh = ds.Geometry.Mesh.ByPointsFaceIndices(vertexPositions, indexGroups)\n\tfor i in vertexPositions:\n\t\ti.Dispose()\n\treturn dsMesh\n\n\n\"\"\" Data Class \"\"\"\nclass MSData(object):\n\n        def __init__(self, _data = None):\n                self.data = _data\n        def addData(self, data):\n                self.data = data\n\n\"\"\" Geometry Classes \"\"\"            \nclass MSVector(object):\n\n        def __init__(self, x= None, y= None, z= None):\n                self.x = x\n                self.y = y\n                self.z = z\n        def addData(self, data):\n                self.data = data\n        def toDSVector(self):\n                dsVector = ds.Geometry.Vector.ByCoordinates(self.x, self.y, self.z)\n                return dsVector\n        def toRHVector3d(self):\n                rhVector = rc.Geometry.Vector3d(self.x, self.y, self.z)\n                return rhVector\n\nclass MSPoint(object):\n\n        def __init__( self, x= None, y= None, z =None):\n                self.x = x\n                self.y = y\n                self.z = z\n        def addData(self, data):\n                self.data = data\n        def toDSPoint(self):\n                dsPoint = ds.Geometry.Point.ByCoordinates(self.x, self.y, self.z)\n                return dsPoint\n        def toRHPoint3d(self):\n                rhPoint = rc.Geometry.Point3d(self.x, self.y, self.z)\n                return rhPoint\n\nclass MSPoint4d(object):\n\n        def __init__( self, x= None, y= None, z= None, weight= None):\n                self.x = x\n                self.y = y\n                self.z = z\n                self.weight = weight\n        def addData(self, data):\n                self.data = data\n        def toDSPoint(self):\n                dsPoint = ds.Geometry.Point.ByCoordinates(self.x, self.y, self.z)\n                return dsPoint\n        def toRHPoint4d(self):\n                rhPoint4d = rc.Geometry.Point4d(self.x, self.y, self.z, self.weight)\n                return rhPoint4d\n\nclass MSPlane(object):\n\n        def __init__(self, origin= None, vector= None):\n                self.origin = origin\n                self.vector = vector\n        def addData(self, data):\n                self.data = data\n        def toDSPlane(self):\n                dsOrigin = self.origin.toDSPoint()\n                dsVector = self.vector.toDSVector()\n                dsPlane = ds.Geometry.Plane.ByOriginNormal(dsOrigin, dsVector)\n                return dsPlane\n        def toRHPlane(self):\n                rhOrigin = self.origin.toRHPoint3d()\n                rhVector = self.vector.toRHVector3d()\n                rhPlane = rc.Geometry.Plane(rhOrigin, rhVector)\n                return rhPlane\n\nclass MSLine(object):\n\n        def __init__( self, start= None, end= None):\n                self.start = start\n                self.end = end\n        def addData(self, data):\n                self.data = data\n        def toDSLine(self):\n                dsStartPt = self.start.toDSPoint()\n                dsEndPt = self.end.toDSPoint()\n                dsLine = ds.Geometry.Line.ByStartPointEndPoint(dsStartPt, dsEndPt)\n                return dsLine\n        def toRHLineCurve(self):\n                rhStartPt = self.start.toRHPoint3d()\n                rhEndPt = self.end.toRHPoint3d()\n                rhLine = rc.Geometry.LineCurve(rhStartPt, rhEndPt)\n                return rhLine\n\nclass MSCircle(object):\n\n        def __init__(self, plane= None, radius= None):\n                self.plane = plane\n                self.radius = radius\n        def addData(self, data):\n                self.data = data\n        def toDSCircle(self):\n                dsPlane = self.plane.toDSPlane()\n                dsCircle = ds.Geometry.Circle.ByPlaneRadius(dsPlane, self.radius)\n                return dsCircle\n        def toRHCircle(self):\n                rhPlane = self.plane.toRHPlane()\n                rhCircle = rc.Geometry.Circle(rhPlane, self.radius)\n                return rhCircle\n\nclass MSEllipse(object):\n\n        def __init__(self, origin=None, ptX=None, ptY=None, plane=None, xRadius=None, yRadius=None):\n                self.origin = origin\n                self.ptX = ptX\n                self.ptY = ptY\n                self.plane = plane\n                self.xRadius = xRadius\n                self.yRadius = yRadius\n        def addData(self, data):\n                self.data = data\n        def toDSEllipse(self):\n                origin = self.origin.toDSPoint()\n                ptX = self.ptX.toDSPoint()\n                ptY = self.ptY.toDSPoint()\n                vectorX = ds.Geometry.Vector.ByTwoPoints(origin, ptX)\n                vectorY = ds.Geometry.Vector.ByTwoPoints(origin, ptY)\n                return ds.Geometry.Ellipse.ByOriginVectors(origin, vectorX, vectorY)\n        def toRHEllipse(self):\n                rhOrigin = self.origin.toRHPoint3d()\n                rhX = self.ptX.toRHPoint3d()\n                rhY = self.ptY.toRHPoint3d()\n                return rc.Geometry.Ellipse(center=rhOrigin, second=rhX, third=rhY)\n\nclass MSArc(object):\n\n        def __init__(self, startPoint= None, centerPoint= None, endPoint= None):\n                self.centerPoint = centerPoint\n                self.startPoint = startPoint\n                self.endPoint = endPoint\n        def addData(self, data):\n                self.data = data\n        def toDSArc(self):\n                dsStartPt = self.startPoint.toDSPoint()\n                dsEndPt = self.endPoint.toDSPoint()\n                dsCenterPt = self.centerPoint.toDSPoint()\n                return ds.Geometry.Arc.ByCenterPointStartPointEndPoint(dsCenterPt, dsStartPt, dsEndPt)\n        def toRHArc(self):\n                rhStartPt = self.startPoint.toRHPoint3d()\n                rhEndPt = self.endPoint.toRHPoint3d()\n                rhMidPt = self.centerPoint.toRHPoint3d()\n                return rc.Geometry.Arc(rhStartPt, rhMidPt, rhEndPt)\n\nclass MSPolyLine(object):\n\n        def __init__( self, segments = None):\n                self.segments = segments\n        def addData(self, data):\n                self.data = data\n        def toDSPolyCurve(self):\n                dsLines = []\n                for line in self.segments:\n                        dsLines.append(line.toDSLine())\n                dsPolyCurve = ds.Geometry.PolyCurve.ByJoinedCurves(dsLines)\n                return dsPolyCurve\n        def toRHPolyCurve(self):\n                rhPolyCurve = rc.Geometry.PolyCurve()\n                for line in self.segments:\n                        rhPolyCurve.Append(line.toRHLineCurve())\n                return rhPolyCurve\n\nclass MSNurbsCurve(object):\n\n        def __init__( self, points= None, weights= None, knots= None, degree= None):\n                self.points = points\n                self.weights = weights\n                self.knots = knots\n                self.degree = degree\n        def addData(self, data):\n                self.data = data\n        def toDSNurbsCurve(self):\n                dsPoints = []\n                dsWeights = []\n                for index, pt in enumerate(self.points):\n                        dsPoints.append(pt.toDSPoint())\n                        dsWeights.append(float(pt.weight))\n                dsPtArray = Array[ds.Geometry.Point](dsPoints)\n                dsWeightsArray = Array[float](dsWeights)\n                dsKnots = []\n                for i in self.knots:\n                        dsKnots.append(i)\n                dsKnots.insert(0, dsKnots[0])\n                dsKnots.insert(len(dsKnots), dsKnots[(len(dsKnots)-1)])\n                dsKnotsArray = Array[float](dsKnots)\n                dsNurbsCurve = ds.Geometry.NurbsCurve.ByControlPointsWeightsKnots(dsPtArray, dsWeightsArray, dsKnotsArray, self.degree)\n                return dsNurbsCurve\n        def toRHNurbsCurve(self):\n                rhNurbsCurve = rc.Geometry.NurbsCurve(int(self.degree), int(len(self.points)))\n                for index, pt in enumerate(self.points):\n                        rhNurbsCurve.Points.SetPoint(index, pt.toRHPoint4d())\n                rhKnots = []\n                for i in self.knots:\n                     rhKnots.append(i)\n                del rhKnots[0]\n                del rhKnots[-1]\n                for index, knot in enumerate(rhKnots):\n                        rhNurbsCurve.Knots[index] = knot\n                return rhNurbsCurve\n\nclass MSPolyCurve(object):\n\n        def __init__(self, curves= None):\n                self.curves = curves\n        def addData(self, data):\n                self.data = data\n        def toDSPolyCurve(self):\n                dsSubCurves = []\n                for crv in self.curves:\n                        if type(crv) == MSLine:\n                                dsSubCurves.append(crv.toDSLine())\n                        elif type(crv) == MSArc:\n                                dsSubCurves.append(crv.toDSArc())\n                        elif type(crv) == MSPolyLine:\n                                dsSubCurves.append(crv.toDSPolyCurve())\n                        elif type(crv) == MSNurbsCurve:\n                                dsSubCurves.append(crv.toDSNurbsCurve().ToNurbsCurve())\n                dsPolyCurve = ds.Geometry.PolyCurve.ByJoinedCurves(dsSubCurves)\n                return dsPolyCurve\n        def toRHPolyCurve(self):\n                rhPolyCurve = rc.Geometry.PolyCurve()\n                for j in self.curves:\n                        if type(j) == MSLine:\n                                rhPolyCurve.Append(j.toRHLineCurve())\n                        elif type(j) == MSArc:\n                                rhPolyCurve.Append(j.toRHArc())\n                        elif type(j) == MSNurbsCurve:\n                                rhPolyCurve.Append(j.toRHNurbsCurve())\n                return rhPolyCurve\n\nclass MSMesh(object):\n\n        def __init__(self, points = None, faceTopology = None):\n                self.points = points\n                self.faceTopology = faceTopology\n        def addData(self, data):\n                self.data = data\n        def toDSMesh(self):\n                dsIndexGroups = []\n                for i in self.faceTopology:\n                        if len(i) == 3:\n                                dsIndexGroups.append(ds.Geometry.IndexGroup.ByIndices(i[0], i[1], i[2]))\n                        else:\n                                dsIndexGroups.append(ds.Geometry.IndexGroup.ByIndices(i[0], i[1], i[2], i[3]))\n                dsVertexPositions = []\n                for i in self.points:\n                        dsVertexPositions.append(i.toDSPoint())\n                dsMesh = ds.Geometry.Mesh.ByPointsFaceIndices(dsVertexPositions, dsIndexGroups)\n                return dsMesh\n        def toRHMesh(self):\t\n                rhMesh = rc.Geometry.Mesh()\t\t\n                for pt in self.points:\t\t\n                        rhMesh.Vertices.Add(pt.toRHPoint3d())\t\t\n                rhFaces = []\n                for face in self.faceTopology:\n        \t\tif len(face)==3:\n\t\t\t\trhMeshFace = rc.Geometry.MeshFace(face[0], face[1], face[2])\n\t\t\telse:\n\t\t\t\trhMeshFace = rc.Geometry.MeshFace(face[0], face[1], face[2], face[3])\n                        rhFaces.append(rhMeshFace)\t\t\n                rhFaceArray = Array[rc.Geometry.MeshFace](rhFaces)\t\t\n                rhMesh.Faces.AddFaces(rhFaceArray)\t\t\n                return rhMesh\n\n\nclass MSNurbsSurface(object):\n\n        def __init__(self, points= None, weights = None, knotsU= None, knotsV= None, degreeU= None, degreeV= None, countU= None, countV= None, rational= None):\n                self.points = points\n                self.weights = weights\n                self.knotsU = knotsU\n                self.knotsV = knotsV\n                self.degreeU = degreeU\n                self.degreeV = degreeV\n                self.countU = countU\n                self.countV = countV\n                self.rational = rational\n        def addData(self, data):\n                self.data = data\n        def toDSNurbsSurface(self):\n                # DS Requires Control Points to be in .Net typed arrays\n                # convert Rhino Control Points to ArrayArray\n                # get control points and weights \n                dsControlPoints, dsWeights = [], []\n                for pt in self.points:\n                        dsControlPoints.append(pt.toDSPoint())\n                        dsWeights.append(pt.weight)\n                # get knotsU and knotsV\n                # convert list of knots to Array\n                dsKnotsU, dsKnotsV = [], []\n                for i in self.knotsU:\n                        dsKnotsU.append(i)\n                dsKnotsU.insert(0,dsKnotsU[0])\n                dsKnotsU.insert(len(dsKnotsU), dsKnotsU[len(dsKnotsU)-1])\n                dsKnotsU = Array[float](dsKnotsU)\n                for i in self.knotsV:\n                        dsKnotsV.append(i)\n                dsKnotsV.insert(0, dsKnotsV[0])\n                dsKnotsV.insert(len(dsKnotsV), dsKnotsV[len(dsKnotsV)-1])\n                dsKnotsV = Array[float](dsKnotsV)\n                # get degreeU and degreeV via Order - 1\n                dsDegreeU = self.degreeU - 1\n                dsDegreeV = self.degreeV - 1\n                # compute number of UV Control Points\n                uCount = self.countU + 3\n                vCount = self.countV + 3\n                #split control points into sublists of UV points\n                #convert list of lists to Array[Array[point]]\n                newControlPoints = [dsControlPoints[i:i+vCount] for i  in range(0, len(dsControlPoints), vCount)]\n                controlPointsArrayArray = Array[Array[ds.Geometry.Point]](map(tuple, newControlPoints))\n                newWeights = [dsWeights[i:i+vCount] for i  in range(0, len(dsWeights), vCount)]\n                weightsArrayArray = Array[Array[float]](map(tuple, newWeights))\n                # create DS NurbsSurface\n                dsNurbsSurface = ds.Geometry.NurbsSurface.ByControlPointsWeightsKnots(controlPointsArrayArray, weightsArrayArray, dsKnotsU, dsKnotsV, dsDegreeU, dsDegreeV)\n                return dsNurbsSurface\n        def toRHNurbsSurface(self):\n                # Rhino uses something called Order instead of Degree. Order = Degree + 1\n                rhOrderU = self.degreeU + 1\n                rhOrderV = self.degreeV + 1\n                dim = 3\n                # Creates internal uninitialized arrays for \n                # control points and knot\n                rhNurbsSurface = rc.Geometry.NurbsSurface.Create(dim, self.rational, rhOrderU, rhOrderV, self.countU, self.countV)\n                # Dynamo uses superfluous knots so first and last need to be deleted\n                # number of Knots = Degree + CountU - 1\n                rhKnotsU, rhKnotsV = [], []\n                for i in list(self.knotsU):\n                        rhKnotsU.append(i)\n                del rhKnotsU[0]\n                del rhKnotsU[-1]\n                for i in list(self.knotsV):\n                        rhKnotsV.append(i)\n                del rhKnotsV[0]\n                del rhKnotsV[-1]\n                # add the knots\n                for i in range(0, rhNurbsSurface.KnotsU.Count, 1):\n                        rhNurbsSurface.KnotsU[i] = rhKnotsU[i]\n                for j in range(0, rhNurbsSurface.KnotsV.Count, 1):\n                        rhNurbsSurface.KnotsV[j] = rhKnotsV[j]\n                # add the control points\n                controlPts = [[] for i in range(len(list(self.points)))]\n                for index, ptList in enumerate(self.points):\n                        for pt in ptList:\n                                controlPts[index].append(pt.toRHPoint4d())\n                for i, _list in enumerate(controlPts):\n                        for j, _item in enumerate(_list):\n                              rhNurbsSurface.Points.SetControlPoint(i,j, rc.Geometry.ControlPoint(_item))\n                return rhNurbsSurface\n\nclass MSMultiSpanNurbsCurve(object):\n\n        def __init__(self, curves = None):\n                self.curves = curves\n        def addData(self, data):\n                self.data = data\n        def toDSPolyCurve(self):\n                nurbsCurves = []\n                for i in self.curves:\n                        nurbsCurves.append(i.toDSNurbsCurve())\n                dsPolyCurve = ds.Geometry.PolyCurve.ByJoinedCurves(nurbsCurves)\n                return dsPolyCurve\n\nclass MSBrep(object):\n\n        def __init__(self, faces = None, trims = None):\n                self.faces = faces\n                self.trims = trims\n        def addData(self, data):\n                self.data = data\n        def toDSPolySurface(self):\n                dsFaces = []\n                for face, loop in zip(self.faces, self.trims):\n                        dsFace = face.toDSNurbsSurface()\n                        if len(loop) != 0:\n                                trimLoops = []\n                                for trim in loop:\n                                        dsTrims = []\n                                        for curve in trim:\n                                                if type(curve) == MSNurbsCurve:\n                                                        dsTrims.append(curve.toDSNurbsCurve())\n                                                elif type(curve) == MSMultiSpanNurbsCurve:\n                                                        for i in curve.curves:\n                                                                dsTrims.append(i.toDSNurbsCurve())\n                                                elif type(curve) == MSLine:\n                                                        dsTrims.append(curve.toDSLine())\n                                                elif type(curve) == MSCircle:\n                                                        dsTrims.append(curve.toDSCircle())\n                                                elif type(curve) == MSArc:\n                                                        dsTrims.append(curve.toDSArc())\n                                                elif type(curve) == MSEllipse:\n                                                        dsTrims.append(curve.toDSEllipse())\n                                                elif type(curve) == MSPolyCurve:\n                                                        dsTrims.append(curve.toDSPolyCurve())\n                                                elif type(curve) == MSPolyLine:\n                                                        dsTrims.append(curve.toDSPolyCurve())\n                                        curveArray = List[ds.Geometry.Curve](dsTrims)\n                                        trimLoops.append(ds.Geometry.PolyCurve.ByJoinedCurves(curveArray))\n                                dsFaces.append(dsFace.TrimWithEdgeLoops(trimLoops))\n                        else:\n                                dsFaces.append(dsFace)\n                return ds.Geometry.PolySurface.ByJoinedSurfaces(dsFaces)\n        def toRHBrep(self):\n            rhFaces = []\n            brep = rc.Geometry.Brep()\n            bFaces = brep.Faces\n            for i in self.faces:\n                bFaces.Add(i.toRHNurbsSurface())\n            return brep\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}