{
  "source_url": "https://github.com/969flash/OpenspaceAutomation/blob/f5e2574cae25af33c915c7077c954863d1413f6e/main.py",
  "repo": "969flash/OpenspaceAutomation",
  "repo_stars": 0,
  "repo_description": "OpenspaceAutomation Example",
  "license": "MIT",
  "filepath": "main.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional\nexcept ImportError:\n    pass\n\nimport Rhino.Geometry as geo  # type: ignore\nimport scriptcontext as sc  # type: ignore\nimport Rhino  # type: ignore\nimport ghpythonlib.components as ghcomp  # type: ignore\nimport utils\n\n# 모듈 새로고침\nimport importlib\n\nimportlib.reload(utils)\n\n\nclass Lot:\n    def __init__(self, region: geo.Curve, district_use: str) -> None:\n        self.region = region\n        self.district_use = district_use\n        self.area = geo.AreaMassProperties.Compute(region).Area\n\n\nclass Road:\n    def __init__(self, curve: geo.Curve) -> None:\n        self.curve = curve\n\n\nclass Building:\n    def __init__(self, regions: List[geo.Curve], floor_count: int, use: str) -> None:\n        self.regions = regions\n        self.floor_area = sum(\n            geo.AreaMassProperties.Compute(region).Area for region in regions\n        )\n        self.floor_count = floor_count\n        self.total_area = self.floor_area * floor_count\n        self.use = use\n\n\nclass OpenspaceRequirement:\n    \"\"\"공개공지 설치 조건\"\"\"\n\n    MIN_AREA = 90.0  # type: float\n    MIN_DEPTH = 9.0  # type: float\n    AREA_RATIO = 0.1  # type: float\n    # 최대 넓이 도로변과 4분의1이상 접할 것\n    ROAD_ADJUST_RATIO = 0.25  # type: float\n\n    def __init__(self, lot: Lot, building: Building) -> None:\n        self.area = 0  # type: float\n        self._get_target_information(lot, building)\n\n    def _get_target_information(self, lot: Lot, building: Building) -> None:\n        # 공개공지 설치 조건\n        # 1. 대지의 용도 조건\n        if lot.district_use not in (\n            \"일반주거지역\",\n            \"준주거지역\",\n            \"상업지역\",\n            \"준공업지역\",\n        ):\n            return\n        # 2. 건축물의 용도 조건\n        if building.use not in (\n            \"문화시설\",\n            \"집회시설\",\n            \"종교시설\",\n            \"판매시설\",\n            \"운수시설\",\n            \"업무시설\",\n            \"숙박시설\",\n        ):\n            return\n\n        # 3. 건축물의 연면적 조건\n        if building.total_area < 5000:\n            return\n\n        # 공개공지 면적 = 대지면적의 10%이상(최소 90m2)\n        self.area = max(lot.area * self.AREA_RATIO, self.MIN_AREA)\n\n\nclass OepnspaceGenerator:\n    def __init__(\n        self,\n        lot: Lot,\n        roads: List[Road],\n        building: Building,\n        parking_region: geo.Curve,\n        requirement: OpenspaceRequirement,\n    ) -> None:\n        self.lot = lot\n        self.roads = roads\n        self.building = building\n        self.parking_region = parking_region\n        self.requirement = requirement\n\n    def get_openspace(self) -> List[geo.Curve]:\n        # 공개공지 생성 로직\n        # 1. 후보 지역 생성\n        candidates = self.get_candidate_regions()\n\n        # 2. 후보 지역 필터링\n        filtered_candidates = self.filter_candidate_regions(candidates)\n\n        # 3. 후보 지역 정렬\n        sorted_candidates = self.sort_candidate_regions(filtered_candidates)\n\n        # 4. 후보 지역 조정(축소)\n        openspace_regions = self.adjust_candidate_regions(sorted_candidates)\n\n        return openspace_regions\n\n    def get_candidate_regions(self) -> List[geo.Curve]:\n        \"\"\"공개공지 최소 조건을 만족하는 영역 생성\"\"\"\n        # 최소 폭 조거늘 만족하는 영역 확보\n        # 오프셋 in and out 을 통해 확보\n        inward_regions = utils.offset_regions_inward(\n            [self.lot.region, self.parking_region] + self.building.regions,\n            self.requirement.MIN_DEPTH / 2,\n        )\n\n        # 빌딩영역과 교차가 있는 경우 필터링 geo.Curve.PlanarCurveCollision 사용\n        filtered_inward_regions = []\n        for region in inward_regions:\n            if any(\n                utils.has_region_intersection(region, other_region)\n                for other_region in self.building.regions\n            ):\n                continue\n            filtered_inward_regions.append(region)\n\n        candidate_regions = utils.offset_regions_outward(\n            filtered_inward_regions, self.requirement.MIN_DEPTH / 2\n        )\n\n        return candidate_regions\n\n    def filter_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        \"\"\"후보 지역 필터링\"\"\"\n\n        def is_road_adjacent(candidate: geo.Curve) -> bool:\n            # 도로와 후보 지역의 접촉 여부 확인\n            for road in self.roads:\n                candidate_overlap_length = utils.get_overlap_length(\n                    candidate, road.curve\n                )\n                lot_overlap_length = utils.get_overlap_length(\n                    self.lot.region, road.curve\n                )\n                if (\n                    candidate_overlap_length\n                    > lot_overlap_length * self.requirement.ROAD_ADJUST_RATIO\n                ):\n                    return True\n\n            return False\n\n        # 도로와 4분의 1 이상 접하는 후보 지역 필터링\n        filtered_candidates = filter(lambda x: is_road_adjacent(x), candidates)\n\n        # 공개공지 면적 조건 필터링\n        filtered_candidates = filter(\n            lambda x: geo.AreaMassProperties.Compute(x).Area\n            >= self.requirement.MIN_AREA,\n            filtered_candidates,\n        )\n\n        return list(filtered_candidates)\n\n    def sort_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        # 후보 지역 정렬 로직\n        sorted_candidates = sorted(\n            candidates,\n            key=lambda x: geo.AreaMassProperties.Compute(x).Area,\n            reverse=True,\n        )\n        return sorted_candidates\n\n    def adjust_candidate_regions(self, candidates: List[geo.Curve]) -> List[geo.Curve]:\n        # 후보 지역 조정 로직\n        def reduce_region(region: geo.Curve, target_area: float) -> geo.Curve:\n            # 후보 지역을 목표 면적에 맞게 조정\n            region = region.Duplicate()\n            area = geo.AreaMassProperties.Compute(region).Area\n            if area <= target_area:\n                return region\n            scale_factor = (target_area / area) ** 0.5\n            center_of_scale = utils.get_overlap_crv(region, self.lot.region)[0].PointAt(\n                0.5\n            )\n            return ghcomp.Scale(region, center_of_scale, scale_factor).geometry\n\n        adjusted_candidates = []\n        total_area = 0.0\n        # 후보 영역을 목표 면적에 도달할때 까지 확보\n        for candidate in candidates:\n            area = geo.AreaMassProperties.Compute(candidate).Area\n            if total_area + area > self.requirement.area:\n                candidate = reduce_region(candidate, self.requirement.area - total_area)\n                area = geo.AreaMassProperties.Compute(candidate).Area\n\n            adjusted_candidates.append(candidate)\n            total_area += area\n\n            if total_area >= self.requirement.area:\n                break\n\n        return adjusted_candidates\n\n\n####### 인풋 데이터 예시 #######\n# 대지, 도로, 건물, 주차장 영역을 정의합니다.\nlot = Lot(lot_region, \"일반주거지역\")  # type: geo.Curve\nroads = [Road(region) for region in road_regions]  # type: List[Road]\nbuilding = Building(building_regions, 5, \"업무시설\")  # Placeholder for building\nrequirement = OpenspaceRequirement(lot, building)  # Placeholder for requirement\nopenspace_generator = OepnspaceGenerator(\n    lot, roads, building, parking_region, requirement\n)  # type: OepnspaceGenerator\n##############################\n\n\nopenspace_regions = openspace_generator.get_openspace()\n\nopenspace_area = sum(\n    geo.AreaMassProperties.Compute(region).Area for region in openspace_regions\n)\nprint(f\"Total Openspace Area: {openspace_area} m2\")\nprint(f\"Lot Area: {lot.area} m2\")\nprint(f\"Building Area: {building.total_area} m2\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}