{
  "source_url": "https://github.com/mcneel/S2F2025-script-to-deploy/blob/09cfcc835bcf84016d539f45e29c18bb98873442/source/02_Command/PaintHeights.py",
  "repo": "mcneel/S2F2025-script-to-deploy",
  "repo_stars": 2,
  "repo_description": "Repository for the Shape to Fabrication 2025 workshop: Script to Deploy",
  "license": "MIT",
  "filepath": "source/02_Command/PaintHeights.py",
  "instruction": "https://www.nuget.org/packages/EasingFunctions https://github.com/emmauss/easing-functions r \"nuget: EasingFunctions, 1.0.1\"",
  "code": "#! python3\n# https://www.nuget.org/packages/EasingFunctions\n# https://github.com/emmauss/easing-functions\n#r \"nuget: EasingFunctions, 1.0.1\"\nimport sys\nimport System\nfrom System.Drawing import Color\n\nimport Rhino\nfrom Rhino.Input import RhinoGet\nfrom Rhino.Input.Custom import GetPoint, OptionDouble\nfrom Rhino.DocObjects import ObjectType\nfrom Rhino.Commands import Result\nfrom Rhino.Geometry import Point3d, Ray3d, Circle, Plane, Transform, Line\n\nfrom Eto.Forms import Keyboard, Keys\n\nfrom Easing import Quartic, Vector\n\nclass Brush(GetPoint):\n    def __init__(self, brush_surface):\n        super().__init__()\n        self.SetCommandPrompt(\"Paint\")\n\n        self._bsurface = brush_surface\n\n        # Default values\n        self._size = 68.0\n        self._falloff = 128.0\n        self._strength = 0.5\n        self._maxValue = 60.0\n        self._minValue = 1.0\n        self._mouseDown = False\n\n        # this does not work\n        #self._ease = Quartic(Vector(self._falloff - self._size, self._strength));\n        \n        # so, do this:\n        v = Vector()\n        v.x = self._falloff - self._size;\n        v.y = self._strength;\n\n        self._ease = Quartic(v)\n\n        # Options with range\n        self.optsizedouble = OptionDouble(self._size, 1.0, 100.0)\n        self.optfalloffdouble = OptionDouble(self._falloff, 1.0, 100.0)\n        self.optstrengthdouble = OptionDouble(self._strength, 0.1, 10.0)\n\n        # Adding options\n        self.sizeIndex, _ = self.AddOptionDouble(\"BrushSize\", self.optsizedouble)\n        self.fosizeIndex, _ = self.AddOptionDouble(\"FalloffSize\", self.optfalloffdouble)\n        self.strengthIndex, _ = self.AddOptionDouble(\"Strength\", self.optstrengthdouble)\n\n    def DoPaint(self):\n        res = None\n        while res != Rhino.Input.GetResult.Cancel:\n            res = self.Get(True)\n            if res == Rhino.Input.GetResult.Option:\n                opt = self.Option()\n                if opt.Index == self.sizeIndex:\n                    self._size = self.optsizedouble.CurrentValue\n                elif opt.Index == self.fosizeIndex:\n                    self._falloff = self.optfalloffdouble.CurrentValue\n                elif opt.Index == self.strengthIndex:\n                    self._strength = self.optstrengthdouble.CurrentValue\n                # update the easing function\n                v = Vector()\n                v.x = self._falloff - self._size;\n                v.y = self._strength;\n                self._ease.Scale = v;\n\n    def OnMouseMove(self, e):\n        self._mouseDown = e.LeftButtonDown\n\n    def OnDynamicDraw(self, e):\n        if not e.Viewport:\n            return\n        \n        p = e.CurrentPoint\n        cp = e.Viewport.WorldToClient(p)\n        success, line = e.Viewport.GetFrustumLine(cp.X, cp.Y)\n        if success:\n            line.Flip()\n            ray = Ray3d(line.From, line.Direction)\n\n            closest_on_mesh = sys.maxsize\n            head = None\n            falloff = None\n\n            for mesh in self._bsurface.GetMeshes(Rhino.Geometry.MeshType.Render):\n                t = Rhino.Geometry.Intersect.Intersection.MeshRay(mesh, ray)\n                if t >= 0:\n                    closest_on_mesh = t\n                    hit_point = ray.PointAt(t)\n                    mp = mesh.ClosestMeshPoint(hit_point, sys.maxsize)\n                    norm = mesh.NormalAt(mp)\n                    head_plane = Plane(hit_point, norm)\n                    head = Circle(head_plane, self._size)\n                    falloff = Circle(head_plane, self._falloff)\n\n            if closest_on_mesh != sys.maxsize:\n                e.Display.DrawCircle(head, Color.Blue, 3)\n                if self._falloff != self._size:\n                    e.Display.DrawCircle(falloff, Color.LightGray, 2)\n\n            if self._mouseDown:\n                reverse = Keyboard.Modifiers.HasFlag(Keys.Shift)\n                self.ApplyBrush(e.RhinoDoc, p, reverse)\n\n    def ApplyBrush(self, doc, at, reverse):\n        for robj in doc.Objects.FindByObjectType(ObjectType.Extrusion):\n            bbox = robj.Geometry.GetBoundingBox(True)\n            pp = bbox.Min\n            dist = at.DistanceTo(pp)\n            if dist < self._falloff:\n                height = bbox.Max.Z - bbox.Min.Z\n                value = self.ComputeValue(dist, height, reverse)\n                xform = Transform.Scale(Plane.WorldXY, 1.0, 1.0, value / height)\n                doc.Objects.Transform(robj, xform, True)\n\n    def ComputeValue(self, dist, start, reverse):\n        value = start\n        incr = self._strength if dist < self._size else self._ease.Out(self._falloff - dist);\n        value += -incr if reverse else incr\n        value = min(max(value, self._minValue), self._maxValue)\n        return value\n\n\nsuccess, obj_ref = RhinoGet.GetOneObject(\"Select Brush Plane\", False, filter=ObjectType.Brep | ObjectType.Mesh)\nif success == Result.Success:\n    brush_surface = obj_ref.Object()\n    brush = Brush(brush_surface)\n    brush.DoPaint()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}