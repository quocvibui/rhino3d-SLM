{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/src/compas_rhino/geometry/surface.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/src/compas_rhino/geometry/surface.py",
  "instruction": "Surface",
  "code": "from compas_rhino.exceptions import RhinoSurfaceError\n\nfrom compas.geometry import subtract_vectors\n\ntry:\n    import rhinoscriptsyntax as rs\n    import scriptcontext as sc\n\n    from Rhino.Geometry import Point3d\n\n    find_object = sc.doc.Objects.Find\n\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__     = ['Tom Van Mele', ]\n__copyright__  = 'Copyright 2014, BLOCK Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__email__      = 'vanmelet@ethz.ch'\n\n\nclass RhinoSurface(object):\n    \"\"\"\"\"\"\n\n    def __init__(self, guid=None):\n        self.guid = guid\n        self.surface = find_object(guid)\n        self.geometry = self.surface.Geometry\n        self.attributes = self.surface.Attributes\n        self.otype = self.geometry.ObjectType\n\n    def space(self, density=10):\n        \"\"\"\"\"\"\n        try:\n            du, dv = density\n        except TypeError:\n            du = density\n            dv = density\n\n        density_u = int(du)\n        density_v = int(dv)\n        uv = []\n\n        rs.EnableRedraw(False)\n\n        if rs.IsPolysurface(self.guid):\n            faces = rs.ExplodePolysurfaces(self.guid)\n        elif rs.IsSurface(self.guid):\n            faces = [self.guid]\n        else:\n            raise RhinoSurfaceError('object is not a surface')\n\n        for face in faces:\n            domain_u = rs.SurfaceDomain(face, 0)\n            domain_v = rs.SurfaceDomain(face, 1)\n            du = (domain_u[1] - domain_u[0]) / (density_u - 1)\n            dv = (domain_v[1] - domain_v[0]) / (density_v - 1)\n\n            for i in xrange(density_u):\n                for j in xrange(density_v):\n                    uv.append((domain_u[0] + i * du, domain_v[0] + j * dv))\n\n        if len(faces) > 1:\n            rs.DeleteObjects(faces)\n\n        rs.EnableRedraw(True)\n\n        return uv\n\n    def heightfield(self, density=10, over_space=True):\n        \"\"\"\"\"\"\n        try:\n            du, dv = density\n        except TypeError:\n            du = density\n            dv = density\n\n        du = int(du)\n        dv = int(dv)\n\n        xyz = []\n\n        rs.EnableRedraw(False)\n\n        if rs.IsPolysurface(self.guid):\n            faces = rs.ExplodePolysurfaces(self.guid)\n        elif rs.IsSurface(self.guid):\n            faces = [self.guid]\n        else:\n            raise RhinoSurfaceError('object is not a surface')\n\n        if over_space:\n            for guid in faces:\n                face = RhinoSurface(guid)\n                uv = face.space(density)\n                for u, v in uv:\n                    xyz.append(list(rs.EvaluateSurface(face.guid, u, v)))\n        else:\n            for guid in faces:\n                bbox = rs.BoundingBox(guid)\n                xmin = bbox[0][0]\n                xmax = bbox[1][0]\n                ymin = bbox[0][1]\n                ymax = bbox[3][1]\n                xstep = 1.0 * (xmax - xmin) / (du - 1)\n                ystep = 1.0 * (ymax - ymin) / (dv - 1)\n                seeds = []\n                for i in xrange(du):\n                    for j in xrange(dv):\n                        seed = xmin + i * xstep, ymin + j * ystep, 0\n                        seeds.append(seed)\n                points = map(list, rs.ProjectPointToSurface(seeds, guid, [0, 0, 1]))\n                xyz += points\n\n        if len(faces) > 1:\n            rs.DeleteObjects(faces)\n\n        rs.EnableRedraw(True)\n\n        return xyz\n\n    def descent(self, points=None):\n        \"\"\"\"\"\"\n        if not points:\n            points = self.heightfield()\n\n        tol = rs.UnitAbsoluteTolerance()\n\n        descent = []\n\n        if rs.IsPolysurface(self.guid):\n            rs.EnableRedraw(False)\n            faces = {}\n            for p0 in points:\n                p = p0[:]\n                p[2] -= 2 * tol\n                bcp = rs.BrepClosestPoint(self.guid, p)\n                uv = bcp[1]\n                index = bcp[2][1]\n                try:\n                    face = faces[index]\n                except (TypeError, IndexError):\n                    face = rs.ExtractSurface(self.guid, index, True)\n                    faces[index] = face\n                p1 = rs.EvaluateSurface(face, uv[0], uv[1])\n                vector = [p1[_] - p0[_] for _ in range(3)]\n                descent.append((p0, vector))\n            rs.DeleteObjects(faces.values())\n            rs.EnableRedraw(True)\n        elif rs.IsSurface(self.guid):\n            for p0 in points:\n                p = p0[:]\n                p[2] -= 2 * tol\n                bcp = rs.BrepClosestPoint(self.guid, p)\n                uv = bcp[1]\n                p1 = rs.EvaluateSurface(self.guid, uv[0], uv[1])\n                vector = [p1[_] - p0[_] for _ in range(3)]\n                descent.append((p0, vector))\n        else:\n            raise RhinoSurfaceError('object is not a surface')\n\n        return descent\n\n    def curvature(self, points=None):\n        \"\"\"\"\"\"\n        if not points:\n            points = self.heightfield()\n\n        curvature = []\n\n        if rs.IsPolysurface(self.guid):\n            rs.EnableRedraw(False)\n            faces = {}\n            for point in points:\n                bcp = rs.BrepClosestPoint(self.guid, point)\n                uv = bcp[1]\n                index = bcp[2][1]\n                try:\n                    face = faces[index]\n                except (TypeError, IndexError):\n                    face = rs.ExtractSurface(self.guid, index, True)\n                    faces[index] = face\n                props = rs.SurfaceCurvature(face, uv)\n                curvature.append((point, (props[1], props[3], props[5])))\n            rs.DeleteObjects(faces.values())\n            rs.EnableRedraw(False)\n        elif rs.IsSurface(self.guid):\n            for point in points:\n                bcp = rs.BrepClosestPoint(self.guid, point)\n                uv = bcp[1]\n                props = rs.SurfaceCurvature(self.guid, uv)\n                curvature.append((point, (props[1], props[3], props[5])))\n        else:\n            raise RhinoSurfaceError('object is not a surface')\n\n        return curvature\n\n    def borders(self):\n        \"\"\"\"\"\"\n        border = rs.DuplicateSurfaceBorder(self.guid, type=1)\n        curves = rs.ExplodeCurves(border, delete_input=True)\n        return curves\n\n    def project_points(self, points):\n        projections = []\n        for point in points:\n            ppoints = rs.ProjectPointToSurface(point, self.guid, [0, 0, 1])\n            if not ppoints:\n                raise RhinoSurfaceError('Could not project point to surface.')\n            ppoint = ppoints[0]\n            projections.append(list(ppoint))\n        return projections\n\n    def closest_point(self, point, maxdist=None):\n        point = self.geometry.ClosestPoint(Point3d(*point))\n        return list(point)\n\n    def closest_points(self, points, maxdist=None):\n        return [self.closest_point(point) for point in points]\n\n    def pull_mesh(self, mesh, fixed=None, d=1.0):\n        if not fixed:\n            fixed = []\n        fixed = set(fixed)\n        for key, attr in mesh.vertices(True):\n            if key in fixed:\n                continue\n            xyz = mesh.vertex_coordinates(key)\n            point = self.closest_point(xyz)\n            dx, dy, dz = subtract_vectors(point, xyz)\n            mesh.vertex[key]['x'] += d * dx\n            mesh.vertex[key]['y'] += d * dy\n            mesh.vertex[key]['z'] += d * dz\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == '__main__':\n\n    import compas_rhino\n\n    guid = compas_rhino.select_surface()\n\n    surface = RhinoSurface(guid)\n\n    points = []\n    for xyz in surface.heightfield():\n        points.append({\n            'pos'   : xyz,\n            'name'  : 'heightfield',\n            'color' : (0, 255, 0),\n        })\n\n    compas_rhino.xdraw_points(points, layer='Layer 01', clear=True, redraw=True)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}