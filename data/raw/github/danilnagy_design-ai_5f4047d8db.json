{
  "source_url": "https://github.com/danilnagy/design-ai/blob/3937e930b1c3dd86d86e721f31a640d62c9786a3/docs/projects/packing/packing.py",
  "repo": "danilnagy/design-ai",
  "repo_stars": 2,
  "repo_description": null,
  "license": "MIT",
  "filepath": "docs/projects/packing/packing.py",
  "instruction": "Packing",
  "code": "import Rhino.Geometry as rh\n\n\nclass Agent:\n\n    def __init__(self, pt, r):\n\n        self.cp = pt\n        self.radius = r\n        self.neighbors = []\n\n    # method for adding another instance to a list of neighbors\n    def add_neighbor(self, other):\n        self.neighbors.append(other)\n\n    # method for checking distance to other room object and moving apart if they are overlapping\n    def collide(self, other, alpha):\n\n        d = self.cp.DistanceTo(other.cp)\n\n        amount = 0\n\n        if d < self.radius + other.radius:\n\n            pt_2 = other.cp\n            pt_1 = self.cp\n\n            # get vector from self to other\n            v = pt_2 - pt_1\n\n            # change vector magnitude to 1\n            v.Unitize()\n            # set magnitude to half the overlap distance\n            v *= (self.radius + other.radius - d) / 2\n            # multiply by alpha parameter to control\n            # amount of movement at each time step\n            v *= alpha\n\n            amount = v.Length\n\n            # move other object\n            t = rh.Transform.Translation(v)\n            pt_2.Transform(t)\n\n            # reverse vector and move self same amount\n            # in opposite direction\n            v.Reverse()\n            t = rh.Transform.Translation(v)\n            pt_1.Transform(t)\n\n        return amount\n\n    # method for checking distance to other instance and moving closer if they are not touching\n    def cluster(self, other, alpha):\n\n        d = self.cp.DistanceTo(other.cp)\n\n        amount = 0\n\n        if d > self.radius + other.radius:\n\n            pt_2 = other.cp\n            pt_1 = self.cp\n\n            # get vector from self to other\n            v = pt_2 - pt_1\n\n            # change vector magnitude to 1\n            v.Unitize()\n            # set magnitude to half the overlap distance\n            v *= (d - (self.radius + other.radius)) / 2\n            # multiply by alpha parameter to control\n            # amount of movement at each time step\n            v *= alpha\n\n            amount = v.Length\n\n            # move self\n            t = rh.Transform.Translation(v)\n            pt_1.Transform(t)\n\n            # reverse vector and move other object same amount\n            # in opposite direction\n            v.Reverse()\n            t = rh.Transform.Translation(v)\n            pt_2.Transform(t)\n\n        return amount\n\n    def get_circle(self):\n        return rh.Circle(self.cp, self.radius)\n\n\ndef run(pts, radii, max_iters, alpha, adjacencies):\n\n    print(adjacencies)\n\n    agents = []\n\n    for i, pt in enumerate(pts):\n        my_agent = Agent(pt, radii[i])\n        agents.append(my_agent)\n\n    # for each agent in the list, add the previous agent as its neighbor\n    for i in range(len(agents)):\n        agents[i].add_neighbor(agents[i-1])\n\n    for i in range(max_iters):\n\n        total_amount = 0\n\n        for j, agent_1 in enumerate(agents):\n\n            # cluster to all agent's neighbors\n            for agent_2 in agent_1.neighbors:\n                total_amount += agent_1.cluster(agent_2, alpha)\n\n            # collide with all agents after agent in list\n            for agent_2 in agents[j+1:]:\n                # add extra multiplier to decrease effect of cluster\n                total_amount += agent_1.collide(agent_2, alpha/5)\n\n        if total_amount < .01:\n            break\n\n    iters = i\n\n    print(\"process ran for {} iterations\".format(i))\n\n    circles = []\n\n    for agent in agents:\n        circles.append(agent.get_circle())\n\n    return circles, iters\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}