{
  "source_url": "https://github.com/Nihawl/DC-TowerProject/blob/c7c313efa7c772023ea11650ad3fe5b7f14b282c/Tower-Project-Module06.py",
  "repo": "Nihawl/DC-TowerProject",
  "repo_stars": 0,
  "repo_description": "Tower Skin 3D Model in Python - Part of \"Design Computing\" Course in Coursera ",
  "license": "MIT",
  "filepath": "Tower-Project-Module06.py",
  "instruction": "3D SURFACE MATRIX import modules",
  "code": "#3D SURFACE MATRIX\r\n#import modules\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\ndef SurfacePoints(STRSRF, INTU, INTV):\r\n    #create empty dictionary\r\n    ptMTX = {}\r\n    srfNorm01 = {}\r\n    srfNorm02 = {}\r\n    \r\n    #find surface domain\r\n    Udomain = rs.SurfaceDomain(STRSRF,0)\r\n    Vdomain = rs.SurfaceDomain(STRSRF,1)\r\n    \r\n    #find step size\r\n    UStep = (Udomain[1] - Udomain[0])/ INTU\r\n    VStep = (Vdomain[1] - Vdomain[0])/ INTV\r\n    \r\n    #find exponential step value\r\n    expStep = DivideExponentially((Udomain[1]-Udomain[0]), INTU)\r\n    \r\n    #PLOT POINTS ON SURFACE\r\n    for i in range(INTU+1):\r\n        for j in range(INTV+1):\r\n            #define u and v in terms of i and j\r\n            #u = Udomain[0] + UStep*i\r\n            u = expStep[i]\r\n            v = Vdomain[0] + VStep*j\r\n            \r\n            #evaluate surface\r\n            point = rs.EvaluateSurface(STRSRF, u,v)\r\n            #print point\r\n            ptMTX[(i,j)] = point\r\n            \r\n            #find surface normals\r\n            vecNorm = rs.SurfaceNormal(STRSRF, (u,v))\r\n            print vecNorm\r\n            #unitize vector for scaling\r\n            vecNorm = rs.VectorUnitize(vecNorm)\r\n            #make scale a factor of distance from plane\r\n            plane = rs.WorldXYPlane()\r\n            distance = rs.DistanceToPlane(plane, point)\r\n            vecNorm = rs.VectorScale(vecNorm, 1.4)\r\n            #add to srfNorm01\r\n            srfNorm01[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            #unitize and scale vector\r\n            vecNorm= rs.VectorUnitize(vecNorm)\r\n            vecNorm = rs.VectorScale(vecNorm, 1)\r\n            #add to srfNorm02\r\n            srfNorm02[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            \r\n    #call function to generate geometry\r\n    GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV)\r\n\r\ndef   GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV):\r\n    #LOOP TO GENERATE GEOMETRY\r\n        for i in range(INTU + 1):\r\n            for j in range(INTV + 1):\r\n                if i > 0 and  j > 0 :\r\n                    ### Create Back Curve ### \r\n                    backCrv = rs.AddCurve((ptMTX[(i,j-1)],ptMTX[(i,j)],ptMTX[(i-1,j)],\r\n                    ptMTX[(i-1,j-1)],ptMTX[(i,j-1)]),1)\r\n                    #Set \"t\" value\r\n                    t = 0.02*i\r\n                    ##Back points\r\n                    backPts = []\r\n                    backCentroid = MidPt(ptMTX[(i,j-1)],ptMTX[(i-1,j)])\r\n                    midPt01 = MidPt(ptMTX[(i,j-1)],ptMTX[(i,j)])\r\n                    midPt02 = MidPt(ptMTX[(i,j)],ptMTX[(i-1,j)])\r\n                    midPt03 = MidPt(ptMTX[(i-1,j)],ptMTX[(i-1,j-1)])\r\n                    midPt04 = MidPt(ptMTX[(i-1,j-1)],ptMTX[(i,j-1)])\r\n                    backLn01 = rs.AddLine(midPt01,backCentroid)\r\n                    backLn02 = rs.AddLine(midPt02,backCentroid)\r\n                    backLn03 = rs.AddLine(midPt03,backCentroid)\r\n                    backLn04 = rs.AddLine(midPt04,backCentroid)\r\n                    backPt01 = rs.EvaluateCurve(backLn01,(rs.CurveParameter(backLn01,t*0.5)))\r\n                    backPt02 = rs.EvaluateCurve(backLn02,(rs.CurveParameter(backLn02,t*0.5)))\r\n                    backPt03 = rs.EvaluateCurve(backLn03,(rs.CurveParameter(backLn04,t*0.5)))\r\n                    backPt04 = rs.EvaluateCurve(backLn04,(rs.CurveParameter(backLn04,t*0.5)))\r\n                    \r\n                    ##Front points\r\n                    frontPts = []\r\n                    frontCentroid = MidPt(srfNorm01[(i,j-1)],srfNorm01[(i-1,j)])\r\n                    frontLn01 = rs.AddLine(srfNorm01[(i,j-1)],frontCentroid)\r\n                    frontLn02 = rs.AddLine(srfNorm01[(i,j)],frontCentroid)\r\n                    frontLn03 = rs.AddLine(srfNorm01[(i-1,j)],frontCentroid)\r\n                    frontLn04 = rs.AddLine(srfNorm01[(i-1,j-1)],frontCentroid)\r\n                    frontPt01 = rs.EvaluateCurve(frontLn01,(rs.CurveParameter(frontLn01,t*2)))\r\n                    frontPt02 = rs.EvaluateCurve(frontLn02,(rs.CurveParameter(frontLn02,t*2)))\r\n                    frontPt03 = rs.EvaluateCurve(frontLn03,(rs.CurveParameter(frontLn03,t*2)))\r\n                    frontPt04 = rs.EvaluateCurve(frontLn04,(rs.CurveParameter(frontLn04,t*2)))\r\n                    \r\n                    ## Create Surfaces\r\n                    srf01 = rs.AddSrfPt((midPt01,backPt01,frontPt01,ptMTX[(i,j-1)]))\r\n                    #srf02 = rs.AddSrfPt((ptMTX[(i,j-1)],midPt04,backPt04,frontPt01))\r\n                    srf02 = rs.AddSrfPt((midPt04,ptMTX[(i,j-1)],frontPt01,backPt04))\r\n                    srf03 = rs.AddSrfPt((ptMTX[(i-1,j-1)],midPt04,backPt04,frontPt04))\r\n                    srf04 = rs.AddSrfPt((ptMTX[(i-1,j-1)],midPt04,backPt04,frontPt04))\r\n                    #srf05 = rs.AddSrfPt((ptMTX[(i-1,j-1)],midPt03,backPt03,frontPt04))\r\n                    srf05 = rs.AddSrfPt((midPt03,ptMTX[(i-1,j-1)],frontPt04,backPt03))\r\n                    srf06 = rs.AddSrfPt((ptMTX[(i-1,j)],midPt03,backPt03,frontPt03))\r\n                    #srf07 = rs.AddSrfPt((ptMTX[(i-1,j)],midPt02,backPt02,frontPt03))\r\n                    srf07 = rs.AddSrfPt((midPt02,ptMTX[(i-1,j)],frontPt03,backPt02))\r\n                    srf08 = rs.AddSrfPt((ptMTX[(i,j)],midPt02,backPt02,frontPt02))\r\n                    #srf09 = rs.AddSrfPt((ptMTX[(i,j)],midPt01,backPt01,frontPt02))\r\n                    srf09 = rs.AddSrfPt((midPt01,ptMTX[(i,j)],frontPt02,backPt01))\r\n                    \r\n                    #Delete Objects\r\n                    rs.DeleteObjects((backLn01,backLn02,backLn03,backLn04,frontLn01,\r\n                    frontLn02,frontLn03,frontLn04))\r\n                    \r\n                    \r\n\r\n\r\n\r\n\r\n\r\ndef MidPt(PT01, PT02):\r\n    \r\n    point = None\r\n    point = [(PT01[0] + PT02[0])/2,(PT01[1] + PT02[1])/2,(PT01[2] + PT02[2])/2]\r\n    return point\r\n\r\ndef DivideExponentially(maxLength, Divisions):\r\n    #set-up lists\r\n    point = []\r\n    yVal = []\r\n    \r\n    #create point where x is .72 of Vdomain and y and z are 0 (point[0])\r\n    pt = ([(maxLength*.72), 0, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where x and y are .12 of model curve length and z is 0 (point[1])\r\n    pt = ([(maxLength*.12), (maxLength*.12), 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where y is model curve length and x and z are 0 (point[2])\r\n    pt = ([0, maxLength, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #draw a curve between the three points (GRAPHcrvGUID)\r\n    GRAPHcrvGUID = rs.AddCurve(point)\r\n    \r\n    #divide (GRAPHcrvGUID)\r\n    GRAPHpoints = rs.DivideCurve(GRAPHcrvGUID, Divisions, False, True)\r\n    \r\n    #delete curve\r\n    rs.DeleteObject(GRAPHcrvGUID)\r\n    \r\n    #collect y values in a list\r\n    for i in range(len(GRAPHpoints)):\r\n        yVal.append(GRAPHpoints[i][1])\r\n        \r\n    return yVal\r\n                  \r\ndef main():\r\n    #collect data\r\n    #strSRF = rs.GetObject('select surface', rs.filter.surface)\r\n    strSRFs = rs.GetObjects('select surfaces', rs.filter.surface)\r\n    intU = rs.GetInteger('how many U intervals?', 8)\r\n    intV = rs.GetInteger('how many V intervals?', 2)\r\n    #    rs.HideObject(strSRF)\r\n    #    #call function\r\n    #    rs.EnableRedraw(False)\r\n    #    SurfacePoints(strSRF, intU, intV)\r\n    #    rs.EnableRedraw(True)\r\n    \r\n    #call function with multiple surfaces\r\n    rs.EnableRedraw(False)\r\n    for strSRF in strSRFs:\r\n        rs.HideObject(strSRF)\r\n        #call function\r\n        SurfacePoints(strSRF, intU, intV)\r\n    rs.EnableRedraw(True)\r\n\r\nmain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}