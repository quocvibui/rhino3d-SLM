{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/modules/cockatoo/_knitdinetwork.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "modules/cockatoo/_knitdinetwork.py",
  "instruction": "PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------",
  "code": "# PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import OrderedDict\nimport math\n\n# DUNDER ----------------------------------------------------------------------\n__all__ = [\n    \"KnitDiNetwork\"\n]\n\n# LOCAL MODULE IMPORTS --------------------------------------------------------\nfrom cockatoo._knitnetworkbase import KnitNetworkBase\nfrom cockatoo.environment import RHINOINSIDE\nfrom cockatoo.exception import KnitNetworkTopologyError\nfrom cockatoo.utilities import is_ccw_xy\nfrom cockatoo.utilities import pairwise\nfrom cockatoo.utilities import tween_planes\n\n# THIRD PARTY MODULE IMPORTS --------------------------------------------------\nimport networkx as nx\n\n# RHINO IMPORTS ---------------------------------------------------------------\nif RHINOINSIDE:\n    import rhinoinside\n    rhinoinside.load()\n    from Rhino.Geometry import Mesh as RhinoMesh\n    from Rhino.Geometry import MeshNgon as RhinoMeshNgon\n    from Rhino.Geometry import NurbsSurface as RhinoNurbsSurface\n    from Rhino.Geometry import Plane as RhinoPlane\n    from Rhino.Geometry import Vector3d as RhinoVector3d\nelse:\n    from Rhino.Geometry import Mesh as RhinoMesh\n    from Rhino.Geometry import MeshNgon as RhinoMeshNgon\n    from Rhino.Geometry import NurbsSurface as RhinoNurbsSurface\n    from Rhino.Geometry import Plane as RhinoPlane\n    from Rhino.Geometry import Vector3d as RhinoVector3d\n\n# CLASS DECLARATION -----------------------------------------------------------\n\n\nclass KnitDiNetwork(nx.DiGraph, KnitNetworkBase):\n    \"\"\"\n    Datastructure representing a directed graph of nodes aswell as 'weft'\n    and 'warp' edges. Used in the automatic generation of knitting patterns.\n\n    Inherits from :class:`networkx.DiGraph`, :class:`KnitNetworkBase`.\n    For more info, see *NetworkX* [13]_.\n\n    Notes\n    -----\n    The implemented algorithms are strongly based on the paper\n    *Automated Generation of Knit Patterns for Non-developable Surfaces* [1]_.\n    Also see *KnitCrete - Stay-in-place knitted formworks for complex concrete\n    structures* [2]_.\n\n    The implementation was further influenced by concepts and ideas presented\n    in the papers *Automatic Machine Knitting of 3D Meshes* [3]_,\n    *Visual Knitting Machine Programming* [4]_ and\n    *A Compiler for 3D Machine Knitting* [5]_.\n    \"\"\"\n\n    # INITIALIZATION ----------------------------------------------------------\n\n    def __init__(self, data=None, **attr):\n        \"\"\"\n        Initialize a KnitNetwork (inherits NetworkX graph with edges, name,\n        graph attributes.\n\n        Parameters\n        ----------\n        data : input graph\n            Data to initialize graph.  If data=None (default) an empty\n            graph is created.  The data can be an edge list, or any\n            NetworkX graph object.  If the corresponding optional Python\n            packages are installed the data can also be a NumPy matrix\n            or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.\n\n        name : string, optional (default='')\n            An optional name for the graph.\n\n        attr : keyword arguments, optional (default= no attributes)\n            Attributes to add to graph as key=value pairs.\n        \"\"\"\n\n        # initialize using original init method\n        super(KnitDiNetwork, self).__init__(data=data, **attr)\n\n        # also copy the mapping_network attribute if it is already available\n        if data and isinstance(data, KnitDiNetwork) and data.mapping_network:\n            self.mapping_network = data.mapping_network\n        else:\n            self.mapping_network = None\n\n        # also copy or initialize the halfedge dict for finding faces\n        if data and isinstance(data, KnitDiNetwork) and data.halfedge:\n            self.halfedge = data.halfedge\n        else:\n            self.halfedge = {}\n\n    # TEXTUAL REPRESENTATION OF NETWORK ---------------------------------------\n\n    def __repr__(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n        \"\"\"\n\n        if self.name != \"\":\n            name = self.name\n        else:\n            name = \"KnitDiNetwork\"\n\n        nn = len(self.nodes())\n        ce = len(self.contour_edges)\n        wee = len(self.weft_edges)\n        wae = len(self.warp_edges)\n        data = (\"({} Nodes, {} Segment Contours, {} Weft, {} Warp)\")\n        data = data.format(nn, ce, wee, wae)\n\n        return name + data\n\n    def ToString(self):\n        \"\"\"\n        Return a textual description of the network.\n\n        Returns\n        -------\n        description : str\n            A textual description of the network.\n\n        Notes\n        -----\n        Used for overloading the Grasshopper display in data parameters.\n        \"\"\"\n\n        return repr(self)\n\n    # NODE WEFT EDGE METHODS --------------------------------------------------\n\n    def node_weft_edges_out(self, node, data=False):\n        \"\"\"\n        Gets the outgoing 'weft' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for outgoing 'weft' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of outgoing 'weft' edges.\n        \"\"\"\n\n        weft_edges = [e for e in\n                      self.edges_iter(node, data=True) if e[2][\"weft\"]]\n\n        if data:\n            return weft_edges\n        else:\n            return [(e[0], e[1]) for e in weft_edges]\n\n    def node_weft_edges_in(self, node, data=False):\n        \"\"\"\n        Gets the incoming 'weft' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming 'weft' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming 'weft' edges.\n        \"\"\"\n\n        weft_edges = [e for e in\n                      self.in_edges_iter(node, data=True) if e[2][\"weft\"]]\n\n        if data:\n            return weft_edges\n        else:\n            return [(e[0], e[1]) for e in weft_edges]\n\n    def node_weft_edges(self, node, data=False):\n        \"\"\"\n        Gets incoming and outgoing 'weft' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming and outgoing\n            'weft' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming and outgoing 'weft' edges.\n        \"\"\"\n\n        weft_edges = [e for e in\n                      self.edges_iter(node, data=True) if e[2][\"weft\"]]\n        weft_edges.extend(e for e in\n                          self.in_edges_iter(node, data=True) if e[2][\"weft\"])\n\n        if data:\n            return weft_edges\n        else:\n            return [(e[0], e[1]) for e in weft_edges]\n\n    # NODE WARP EDGE METHODS --------------------------------------------------\n\n    def node_warp_edges_out(self, node, data=False):\n        \"\"\"\n        Gets the outgoing 'warp' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for outgoing 'warp' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of outgoing 'warp' edges.\n        \"\"\"\n\n        warp_edges = [e for e in\n                      self.edges_iter(node, data=True) if e[2][\"warp\"]]\n\n        if data:\n            return warp_edges\n        else:\n            return [(e[0], e[1]) for e in warp_edges]\n\n    def node_warp_edges_in(self, node, data=False):\n        \"\"\"\n        Gets the incoming 'warp' edges connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming 'warp' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming 'warp' edges.\n        \"\"\"\n\n        warp_edges = [e for e in\n                      self.in_edges_iter(node, data=True) if e[2][\"warp\"]]\n\n        if data:\n            return warp_edges\n        else:\n            return [(e[0], e[1]) for e in warp_edges]\n\n    def node_warp_edges(self, node, data=False):\n        \"\"\"\n        Gets the incoming and outgoing 'warp' edges connected to the given\n        node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming and outgoing\n            'warp' edges.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming and outgoing 'warp' edges.\n        \"\"\"\n\n        warp_edges = [e for e in\n                      self.edges_iter(node, data=True) if e[2][\"warp\"]]\n        warp_edges.extend(e for e in\n                          self.in_edges_iter(node, data=True) if e[2][\"warp\"])\n\n        if data:\n            return warp_edges\n        else:\n            return [(e[0], e[1]) for e in warp_edges]\n\n    # NODE CONTOUR EDGE METHODS -----------------------------------------------\n\n    def node_contour_edges_out(self, node, data=False):\n        \"\"\"\n        Gets the outgoing edges marked neither 'warp' nor 'weft' connected to\n        the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for outgoing edges neither\n            'weft' nor 'warp'.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of outgoing edges neither 'weft' nor 'warp'.\n        \"\"\"\n\n        contour_edges = [(s, e, d) for s, e, d in\n                         self.edges_iter(node, data=True)\n                         if not d[\"warp\"] and not d[\"weft\"]]\n\n        if data:\n            return contour_edges\n        else:\n            return [(e[0], e[1]) for e in contour_edges]\n\n    def node_contour_edges_in(self, node, data=False):\n        \"\"\"\n        Gets the incoming edges marked neither 'warp' nor 'weft' connected to\n        the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming edges neither\n            'weft' nor 'warp'.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming edges neither 'weft' nor 'warp'.\n        \"\"\"\n\n        contour_edges = [(s, e, d) for s, e, d in\n                         self.in_edges_iter(node, data=True)\n                         if not d[\"warp\"] and not d[\"weft\"]]\n\n        if data:\n            return contour_edges\n        else:\n            return [(e[0], e[1]) for e in contour_edges]\n\n    def node_contour_edges(self, node, data=False):\n        \"\"\"\n        Gets the incoming and outcoing edges marked neither 'warp' nor 'weft'\n        connected to the given node.\n\n        Parameters\n        ----------\n        node : hashable\n            Hashable identifier of the node to check for incoming and outgoing\n            edges neither 'weft' nor 'warp'.\n\n        data : bool, optional\n            If ``True``, will also return the edges associated data attribute\n            dictionary.\n\n            Defaults to ``False``.\n\n        Returns\n        -------\n        weft_edges : :obj:`list`\n            List of incoming and outgoing edges neither 'weft' nor 'warp'.\n        \"\"\"\n\n        contour_edges = [(s, e, d) for s, e, d in\n                         self.edges_iter(node, data=True)\n                         if not d[\"warp\"] and not d[\"weft\"]]\n        contour_edges.extend([(s, e, d) for s, e, d in\n                              self.in_edges_iter(node, data=True)\n                              if not d[\"warp\"] and not d[\"weft\"]])\n\n        if data:\n            return contour_edges\n        else:\n            return [(e[0], e[1]) for e in contour_edges]\n\n    # FIND FACES (CYCLES) OF NETWORK ------------------------------------------\n\n    def _sort_node_neighbors(self, key, nbrs, xyz, geo,\n                             cbp, nrm, mode=-1, ccw=True):\n        \"\"\"\n        Sort the neighbors of a network node.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [7]_.\n\n        References\n        ----------\n        .. [7] Van Mele, Tom et al. *COMPAS: A framework for computational\n               research in architecture and structures*.\n\n               See: `sort_node_neighbors() inside COMPAS <https://github.com/\n               compas-dev/compas/blob/e313502995b0dd86d460f86e622cafc0e29d1b75/\n               src/compas/datastructures/network/duality.py#L132>`_\n        \"\"\"\n\n        # if there is only one neighbor we don't need to sort anything\n        if len(nbrs) == 1:\n            return nbrs\n\n        # initialize the ordered list of neighbors with the first node\n        ordered_nbrs = nbrs[0:1]\n\n        # retrieve coordinates for current node\n        a = xyz[key]\n\n        # compute local orientation if reference geometry data is present\n        # CASE 1: Plane is determined by mesh normal of origin node\n        if cbp and nrm and mode == 0:\n            # construct local reference plane and map coordinates to plane\n            # space\n            a_geo = geo[key]\n            localplane = RhinoPlane(a_geo, nrm[key])\n            a_local = localplane.RemapToPlaneSpace(a_geo)[1]\n            a = (a_local.X, a_local.Y, a_local.Z)\n            # compute local plane coordinates for all neighbors\n            xyz_local = {}\n            for nbr in nbrs:\n                # find closest point on plane and remap to plane space\n                nbr_cp = localplane.ClosestPoint(geo[nbr])\n                local_nbr = localplane.RemapToPlaneSpace(nbr_cp)[1]\n                nbr_coords = (local_nbr.X, local_nbr.Y, local_nbr.Z)\n                # set coordinate dict value\n                xyz_local[nbr] = nbr_coords\n            # reassign coordinate dictionary for neighbor sorting\n            xyz = xyz_local\n        # CASE 2: Plane is determined by average normal of origin node and nbrs\n        elif cbp and nrm and mode == 1:\n            # construct local reference plane and map coordinates to plane\n            # space\n            a_geo = geo[key]\n            # get average normal\n            avg_nrm = nrm[key]\n            nbr_nrms = [nrm[n] for n in nbrs]\n            for nv in nbr_nrms:\n                avg_nrm += nv\n            # construct plane based on average normal\n            localplane = RhinoPlane(a_geo, avg_nrm)\n            a_local = localplane.RemapToPlaneSpace(a_geo)[1]\n            a = (a_local.X, a_local.Y, a_local.Z)\n            # compute local plane coordinates for all neighbors\n            xyz_local = {}\n            for nbr in nbrs:\n                # find closest point on plane and remap to plane space\n                nbr_cp = localplane.ClosestPoint(geo[nbr])\n                local_nbr = localplane.RemapToPlaneSpace(nbr_cp)[1]\n                nbr_coords = (local_nbr.X, local_nbr.Y, local_nbr.Z)\n                # set coordinate dict value\n                xyz_local[nbr] = nbr_coords\n            # reassign coordinate dictionary for neighbor sorting\n            xyz = xyz_local\n        # CASE 3: Plane is determined by avg between fitplane and avg meshplane\n        elif cbp and nrm and mode == 2:\n            # construct local reference plane and map coordinates to plane\n            # space\n            a_geo = geo[key]\n            # get average normal\n            avg_nrm = nrm[key]\n            nbr_nrms = [nrm[n] for n in nbrs]\n            for nv in nbr_nrms:\n                avg_nrm += nv\n            # construct plane based on average normal\n            localplane = RhinoPlane(a_geo, avg_nrm)\n            fitplane = RhinoPlane.FitPlaneToPoints([geo[n] for n in nbrs])[1]\n            # align fitplane with localplane\n            if fitplane.Normal * localplane.Normal < 0:\n                fitplane.Flip()\n            # tween the planes and set origin\n            tweenplane = tween_planes(localplane, fitplane, 0.5)\n            tweenplane.Origin = a_geo\n            # remap origin node to plane space\n            a_local = tweenplane.RemapToPlaneSpace(a_geo)[1]\n            a = (a_local.X, a_local.Y, a_local.Z)\n            # compute local plane coordinates for all neighbors\n            xyz_local = {}\n            for nbr in nbrs:\n                # find closest point on plane and remap to plane space\n                nbr_cp = tweenplane.ClosestPoint(geo[nbr])\n                local_nbr = tweenplane.RemapToPlaneSpace(nbr_cp)[1]\n                nbr_coords = (local_nbr.X, local_nbr.Y, local_nbr.Z)\n                # set coordinate dict value\n                xyz_local[nbr] = nbr_coords\n            # reassign coordinate dictionary for neighbor sorting\n            xyz = xyz_local\n\n        # loop over all neighbors except the first one\n        for i, nbr in enumerate(nbrs[1:]):\n            c = xyz[nbr]\n            pos = 0\n            b = xyz[ordered_nbrs[pos]]\n            while not is_ccw_xy(a, b, c):\n                pos += 1\n                if pos > i:\n                    break\n                b = xyz[ordered_nbrs[pos]]\n            if pos == 0:\n                pos -= 1\n                b = xyz[ordered_nbrs[pos]]\n                while is_ccw_xy(a, b, c):\n                    pos -= 1\n                    if pos < -len(ordered_nbrs):\n                        break\n                    b = xyz[ordered_nbrs[pos]]\n                pos += 1\n            ordered_nbrs.insert(pos, nbr)\n\n        # return the ordered neighbors in cw or ccw order\n        if not ccw:\n            return ordered_nbrs[::-1]\n        return ordered_nbrs\n\n    def _sort_neighbors(self, mode=-1, ccw=True):\n        \"\"\"\n        Sort the neighbors of all network nodes.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [8]_.\n\n        References\n        ----------\n        .. [8] Van Mele, Tom et al. *COMPAS: A framework for computational\n               research in architecture and structures*.\n\n               See: `sort_neighbors() inside COMPAS <https://github.com/\n               compas-dev/compas/blob/e313502995b0dd86d460f86e622cafc0e29d1b75/\n               src/compas/datastructures/network/duality.py#L121>`_\n        \"\"\"\n\n        # initialize sorted neighbors dict\n        sorted_neighbors = {}\n\n        # get dictionary of all coordinates by node index\n        xyz = {k: (d[\"x\"], d[\"y\"], d[\"z\"]) for k, d in self.nodes_iter(True)}\n        geo = {k: d[\"geo\"] for k, d in self.nodes_iter(True)}\n\n        # compute local orientation data when reference geometry is present\n        try:\n            reference_geometry = self.graph[\"reference_geometry\"]\n        except KeyError:\n            reference_geometry = None\n\n        if not reference_geometry:\n            cbp = None\n            nrm = None\n        elif isinstance(reference_geometry, RhinoMesh):\n            cbp = {k: reference_geometry.ClosestMeshPoint(geo[k], 0)\n                   for k in self.nodes_iter()}\n            nrm = {k: reference_geometry.NormalAt(cbp[k])\n                   for k in self.nodes_iter()}\n        elif isinstance(reference_geometry, RhinoNurbsSurface):\n            cbp = {k: reference_geometry.ClosestPoint(geo[k])[1:]\n                   for k in self.nodes_iter()}\n            nrm = {k: reference_geometry.NormalAt(cbp[k][0], cbp[k][1])\n                   for k in self.nodes_iter()}\n\n        # loop over all nodes in network\n        for key in self.nodes_iter():\n            nbrs = self[key].keys()\n            sorted_neighbors[key] = self._sort_node_neighbors(\n                                                            key,\n                                                            nbrs,\n                                                            xyz,\n                                                            geo,\n                                                            cbp,\n                                                            nrm,\n                                                            mode=mode,\n                                                            ccw=ccw)\n\n        # set the sorted neighbors list as an attribute to the nodes\n        for key, nbrs in sorted_neighbors.items():\n            self.node[key][\"sorted_neighbors\"] = nbrs[::-1]\n\n        # return the sorted neighbors dict\n        return sorted_neighbors\n\n    def _find_first_node_neighbor(self, key):\n        \"\"\"\n        Find the first neighbor for a given node in the network.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [9]_.\n\n        References\n        ----------\n        .. [9] Van Mele, Tom et al. *COMPAS: A framework for computational\n               research in architecture and structures*.\n\n               See: `find_first_node_neighbor() inside COMPAS <https://\n               github.com/compas-dev/compas/blob/\n               e313502995b0dd86d460f86e622cafc0e29d1b75/src/compas/\n               datastructures/network/duality.py#L103>`_\n        \"\"\"\n\n        # get all node neighbors\n        nbrs = self[key].keys()\n\n        # if there is only one neighbor, we have already found our candidate\n        if len(nbrs) == 1:\n            return nbrs[0]\n\n        ab = [-1.0, -1.0, 0.0]\n        rhino_ab = RhinoVector3d(*ab)\n        a = self.node_coordinates(key)\n        b = [a[0] + ab[0], a[1] + ab[1], 0]\n\n        angles = []\n        for nbr in nbrs:\n            c = self.node_coordinates(nbr)\n            ac = [c[0] - a[0], c[1] - a[1], 0]\n            rhino_ac = RhinoVector3d(*ac)\n            alpha = RhinoVector3d.VectorAngle(rhino_ab, rhino_ac)\n            if is_ccw_xy(a, b, c, True):\n                alpha = (2 * math.pi) - alpha\n            angles.append(alpha)\n\n        return nbrs[angles.index(min(angles))]\n\n    def _find_edge_cycle(self, u, v):\n        \"\"\"\n        Find a cycle based on the given edge.\n\n        Parameters\n        ----------\n        u : hashable\n            Index of the start node of the origin edge for the cycle.\n\n        v : hashable\n            Index of the end node of the origin edge for the cycle.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [6]_.\n\n        References\n        ----------\n        .. [6] Van Mele, Tom et al. *COMPAS: A framework for computational\n               research in architecture and structures*.\n\n               See: `find_edge_cycle() inside COMPAS <https://github.com/\n               compas-dev/compas/blob/09153de6718fb3d49a4650b89d2fe91ea4a9fd4a/\n               src/compas/datastructures/network/duality.py#L161>`_\n        \"\"\"\n        cycle = [u]\n        while True:\n            cycle.append(v)\n            nbrs = self.node[v][\"sorted_neighbors\"]\n            nbr = nbrs[nbrs.index(u) - 1]\n            u, v = v, nbr\n            if v == cycle[0]:\n                break\n        return cycle\n\n    def find_cycles(self, mode=-1):\n        \"\"\"\n        Finds the cycles (faces) of this network by utilizing a wall-follower\n        mechanism.\n\n        Parameters\n        ----------\n        mode : int, optional\n            Determines how the neighbors of each node are sorted when finding\n            cycles for the network.\n\n            ``-1`` equals to using the world XY plane.\n\n            ``0`` equals to using a plane normal to the origin nodes closest\n            point on the reference geometry.\n\n            ``1`` equals to using a plane normal to the average of the origin\n            and neighbor nodes' closest points on the reference geometry.\n\n            ``2`` equals to using an average plane between a plane fit to the\n            origin and its neighbor nodes and a plane normal to the origin\n            nodes closest point on the reference geometry.\n\n            Defaults to ``-1``.\n\n        Warning\n        -------\n        Modes other than -1 (default) are only possible if this network has an\n        underlying reference geometry in form of a Mesh or NurbsSurface. The\n        reference geometry should be assigned when initializing the network by\n        assigning the geometry to the \"reference_geometry\" attribute of the\n        network.\n\n        Notes\n        -----\n        Based on an implementation inside the COMPAS framework.\n        For more info see [17]_.\n\n        References\n        ----------\n        .. [17] Van Mele, Tom et al. *COMPAS: A framework for computational\n               research in architecture and structures*.\n\n               See: `find_cycles() inside COMPAS <https://github.com/\n               compas-dev/compas/blob/09153de6718fb3d49a4650b89d2fe91ea4a9fd4a/\n               src/compas/datastructures/network/duality.py#L20>`_\n        \"\"\"\n\n        # initialize the halfedge dict of the directed network\n        for u, v in self.edges_iter():\n            try:\n                self.halfedge[u][v] = None\n            except KeyError:\n                self.halfedge[u] = {}\n                self.halfedge[u][v] = None\n            try:\n                self.halfedge[v][u] = None\n            except KeyError:\n                self.halfedge[v] = {}\n                self.halfedge[v][u] = None\n\n        # sort the all the neighbors for each node of the network\n        self._sort_neighbors(mode=mode)\n\n        # find start node\n        # sort leaf nodes by y and x coordinates\n        # leaves = self.leaf_nodes\n        # if leaves:\n        #     u = sorted(leaves, key=lambda n: (n[1][\"y\"], n[1][\"x\"]))[0][0]\n        # else:\n        #     u = sorted(self.nodes_iter(data=True),\n        #                key=lambda n: (n[1][\"y\"], n[1][\"x\"]))[0][0]\n\n        # find start node\n        # sort leaf nodes by node identifier / index\n        leaves = self.leaf_nodes\n        if leaves:\n            u = sorted(leaves, key=lambda n: n[0])[0][0]\n        else:\n            u = sorted(self.nodes_iter(data=True), key=lambda n: n[0])[0][0]\n\n        # initialize found and cycles dict\n        cycles = {}\n        found = {}\n        ckey = 0\n\n        # find the very first cycle\n        v = self._find_first_node_neighbor(u)\n        cycle = self._find_edge_cycle(u, v)\n        frozen = frozenset(cycle)\n        found[frozen] = ckey\n        cycles[ckey] = cycle\n\n        # set halfedge dict\n        for a, b in pairwise(cycle + cycle[:1]):\n            self.halfedge[a][b] = ckey\n        ckey += 1\n\n        # loop over all edges and find cycles\n        for u, v in self.edges_iter():\n            # find cycles for u -> v edges\n            if self.halfedge[u][v] == None:\n                cycle = self._find_edge_cycle(u, v)\n                frozen = frozenset(cycle)\n                if frozen not in found:\n                    found[frozen] = ckey\n                    cycles[ckey] = cycle\n                    ckey += 1\n                for a, b in pairwise(cycle + cycle[:1]):\n                    self.halfedge[a][b] = found[frozen]\n            # find cycles for v -> u edges\n            if self.halfedge[v][u] == None:\n                cycle = self._find_edge_cycle(v, u)\n                frozen = frozenset(cycle)\n                if frozen not in found:\n                    found[frozen] = ckey\n                    cycles[ckey] = cycle\n                    ckey += 1\n                for a, b in pairwise(cycle + cycle[:1]):\n                    self.halfedge[a][b] = found[frozen]\n\n        return cycles\n\n    # MESHING -----------------------------------------------------------------\n\n    def create_mesh(self, mode=-1, max_valence=4):\n        \"\"\"\n        Constructs a mesh from this network by finding cycles and using them as\n        mesh faces.\n\n        Parameters\n        ----------\n        mode : int, optional\n            Determines how the neighbors of each node are sorted when finding\n            cycles for the network.\n\n            ``-1`` equals to using the world XY plane.\n\n            ``0`` equals to using a plane normal to the origin nodes closest\n            point on the reference geometry.\n\n            ``1`` equals to using a plane normal to the average of the origin\n            and neighbor nodes' closest points on the reference geometry.\n\n            ``2`` equals to using an average plane between a plane fit to the\n            origin and its neighbor nodes and a plane normal to the origin\n            nodes closest point on the reference geometry.\n\n            Defaults to ``-1``.\n\n        max_valence : int, optional\n            Sets the maximum edge valence of the faces. If this is set to > 4,\n            n-gon faces (more than 4 edges) are allowed. Otherwise, their\n            cycles are treated as invalid and will be ignored.\n\n            Defaults to ``4``.\n\n        Warning\n        -------\n        Modes other than ``-1`` are only possible if this network has an\n        underlying reference geometry in form of a Mesh or NurbsSurface. The\n        reference geometry should be assigned when initializing the network by\n        assigning the geometry to the \"reference_geometry\" attribute of the\n        network.\n        \"\"\"\n\n        # get cycles dict of this network\n        cycles = self.find_cycles(mode=mode)\n\n        # create an empty mesh\n        Mesh = RhinoMesh()\n\n        # intialize mapping of network nodes to mesh vertices\n        node_to_vertex = {}\n        vcount = 0\n\n        # fill mesh and map network nodes to mesh vertices\n        for node, data in self.nodes_iter(data=True):\n            node_to_vertex[node] = vcount\n            Mesh.Vertices.Add(data[\"x\"], data[\"y\"], data[\"z\"])\n            vcount += 1\n\n        # loop over cycles and add faces to the mesh\n        fcount = 0\n        for ckey in cycles.keys():\n            cycle = cycles[ckey]\n            c_len = len(cycle)\n            if c_len > 4:\n                if c_len > max_valence:\n                    continue\n                # find centroid of ngon nodes\n                cycle_coords = [[self.node[k][\"x\"],\n                                 self.node[k][\"y\"],\n                                 self.node[k][\"z\"]] for k in cycle]\n                # compute centroid\n                c_x, c_y, c_z = zip(*cycle_coords)\n                centroid = [sum(c_x) / c_len,\n                            sum(c_y) / c_len,\n                            sum(c_z) / c_len]\n                # add centroid to mesh\n                Mesh.Vertices.Add(*centroid)\n                # create triangle with centroid for every pair in cycle\n                closed_cycle = cycle[:]\n                closed_cycle.append(cycle[0])\n                ngon_faces = []\n                for a, b in pairwise(closed_cycle):\n                    Mesh.Faces.AddFace(node_to_vertex[a],\n                                       node_to_vertex[b],\n                                       vcount)\n                    ngon_faces.append(fcount)\n                    fcount += 1\n                ngon_cycle = [node_to_vertex[n] for n in cycle]\n                RhinoMeshNgon.Create(ngon_cycle, ngon_faces)\n                # increment mesh vertex counter\n                vcount += 1\n            elif c_len < 3:\n                continue\n            else:\n                mesh_cycle = [node_to_vertex[n] for n in cycle]\n                Mesh.Faces.AddFace(*mesh_cycle)\n                fcount += 1\n\n        # unify the normals of the mesh\n        Mesh.UnifyNormals()\n\n        return Mesh\n\n    # CONVERSION TO 2D-KNITTINGPATTERN (PIXEL IMAGE) --------------------------\n\n    def verify_dual_form(self):\n        \"\"\"\n        Verifies this network to have the correct form of a dual as needed for\n        representing this network as a 2d knitting pattern.\n\n        Returns\n        -------\n        bool\n            ``True`` on success, ``False`` otherwise.\n        \"\"\"\n\n        # check every single node\n        for node in self.nodes_iter():\n            # verify if all nodes have the correct keys for attributes\n            try:\n                start = self.node[node][\"start\"]\n                end = self.node[node][\"end\"]\n                inc = self.node[node][\"increase\"]\n                dec = self.node[node][\"decrease\"]\n                lfn = self.node[node][\"leaf\"]\n                geo = self.node[node][\"geo\"]\n            except KeyError:\n                return False\n\n            # get all neighbors\n            prd = self.predecessors(node)\n            lpr = len(prd)\n            # check for nodes with more than two predecessors\n            if lpr > 2:\n                return False\n\n            suc = self.successors(node)\n            lsu = len(suc)\n            # check for nodes with more than two successors\n            if lsu > 2:\n                return False\n\n            nbr = prd + suc\n            lnn = len(nbr)\n            # check for disconnected nodes\n            if not lnn:\n                return False\n\n            # maximum connections per node is four\n            elif lnn > 4:\n                return False\n\n        return True\n\n    def make_pattern_data(self, consolidate=False):\n        \"\"\"\n        Topological sort this network to represent it as 2d knitting pattern\n        consisting of rows and columns.\n\n        Parameters\n        ----------\n        consolidate : bool\n            If ``True``, will consolidate the final pattern data.\n            Defaulst to ``False``.\n\n        Returns\n        -------\n        pattern_data : :obj:`list` of :obj:`list`\n            List (rows) of lists (column values) where every value represents\n            a node.\n\n        Raises\n        ------\n        KnitNetworkTopologyError\n            if the network does not satisfy the topology constraints needed for\n            this operation and the outcome would be unfeasible or\n            unpredictable.\n\n        Notes\n        -----\n        Closely resembles the implementation described in *Automated Generation\n        of Knit Patterns for Non-developable Surfaces* [1]_. Also see\n        *KnitCrete - Stay-in-place knitted formworks for complex concrete\n        structures* [2]_.\n        \"\"\"\n\n        # initialize dict for seen nodes and list for storage of rows\n        seenrows = {}\n        seencols = {}\n        rows = []\n        cols = []\n\n        # initialize mapping dicts for ordering of rows and columns\n        id2row = OrderedDict()\n        id2col = OrderedDict()\n        node2rowid = OrderedDict()\n        node2colid = OrderedDict()\n\n        # BUILD ROWS ----------------------------------------------------------\n\n        # every 'end' node defines the start of a row\n        # loop over all 'end' nodes\n        for node, data in self.end_nodes:\n            # continue if this node has already been visited\n            if node in seenrows:\n                continue\n\n            # get outgoing 'weft' edges of the current 'end' node\n            nodeweft_out = self.node_weft_edges_out(node, data=True)\n            nodeweft_in = self.node_weft_edges_in(node, data=True)\n\n            # skip 'end' nodes which have only incoming 'weft' edges\n            if nodeweft_in and not nodeweft_out:\n                continue\n\n            # if there is more than one outgoing 'weft' edge, we have a problem\n            if len(nodeweft_out) > 1:\n                errMsg = \"More than one outgoing 'weft' edge at \" + \\\n                         \"first row node {}!\".format(node)\n                raise KnitNetworkTopologyError(errMsg)\n            # if this is a singular node, it is a separate row.\n            elif len(nodeweft_out) == 0 and len(nodeweft_in) == 0:\n                # append it as a row to the list of rows\n                rows.append([node])\n                # set the mapping dictionaries\n                row_id = (node, node)\n                id2row[row_id] = [node]\n                node2rowid.update({node: row_id})\n                # set the seen marker and continue to next 'end' node\n                seenrows[node] = True\n                continue\n            # if there is exactly one 'weft' edge, traverse until next node\n            elif len(nodeweft_out) == 1:\n                # get the connected node to the current node\n                connected_node = (nodeweft_out[0][1],\n                                  self.node[nodeweft_out[0][1]])\n                # define initial row nodes with nodes of the first edge\n                row_nodes = [node, connected_node[0]]\n                # traverse as long as there is an outgoing next 'weft' edge\n                # until an 'end' node is discovered\n                while True:\n                    # get 'weft' edges of last node in row nodes\n                    next_weft = self.node_weft_edges_out(row_nodes[-1])\n                    # if there is more than one connected 'weft' edge, we\n                    # have a problem\n                    if len(next_weft) > 1:\n                        errMsg = \"More than one outgoing 'weft' edge at \" + \\\n                                 \"row node {}!\".format(node)\n                        raise KnitNetworkTopologyError(errMsg)\n                    # if there are no next 'weft' edges, row is complete\n                    elif len(next_weft) == 0:\n                        if self.node[row_nodes[-1]][\"end\"]:\n                            # this is the finishing 'end' node; set it seen\n                            # and complete this row by breaking\n                            seenrows[row_nodes[-1]] = True\n                            break\n                        # if there are no next 'weft' edges but this is not\n                        # an 'end' node, we have a problem\n                        else:\n                            # see if there are incoming 'weft' edges at the\n                            # current node which are not the way we came from\n                            next_weft = [nw for nw in self.node_weft_edges_in(\n                                         row_nodes[-1], data=True)\n                                         if nw[0] != row_nodes[-2]]\n\n                            # try to reverse them as a failsafe for imperfect\n                            # topological dual graphs\n                            if len(next_weft) == 1:\n                                # flip geometry first, then the graph edge\n                                nwe = next_weft[0]\n                                nw_attr = nwe[2].copy()\n                                nw_attr[\"geo\"].Flip()\n                                self.remove_edge(nwe[0], nwe[1])\n                                self.add_edge(nwe[1],\n                                              nwe[0],\n                                              attr_dict=nw_attr)\n                            else:\n                                errMsg = (\"Unexpected end of row. Missing \" +\n                                          \"'end' attribute at node {}!\")\n                                errMsg.format(row_nodes[-1])\n                                raise KnitNetworkTopologyError(errMsg)\n\n                    # if there is a next node over a 'weft' edge, append to\n                    # row and continue\n                    if len(next_weft) == 1:\n                        row_nodes.append(next_weft[0][1])\n                        continue\n                # append the completed row to the list of rows\n                rows.append(row_nodes)\n                # set the mapping dictionaries\n                row_id = (row_nodes[0], row_nodes[-1])\n                id2row[row_id] = row_nodes\n                node2rowid.update({node: row_id for node in row_nodes})\n                # finally, set the current node as seen\n                seenrows[node] = True\n\n        # BUILD COLUMNS -------------------------------------------------------\n\n        # every 'end' node defines the start of a row\n        # loop over all 'end' nodes\n        col_sources = [(n, d) for n, d in self.nodes_iter(data=True)\n                       if d[\"increase\"] or d[\"leaf\"] or d[\"end\"]]\n        for node, data in col_sources:\n            # continue if this node has already been visited\n            if node in seencols:\n                continue\n\n            # get outgoing 'warp' edges of the current node\n            nodewarp_out = self.node_warp_edges_out(node, data=True)\n            nodewarp_in = self.node_warp_edges_in(node, data=True)\n\n            # skip nodes which have incoming 'warp' edges\n            if nodewarp_in:\n                continue\n\n            # if there is more than one outgoing 'warp' edge, we have a problem\n            if len(nodewarp_out) > 1:\n                errMsg = \"More than one outgoing 'warp' edge at \" + \\\n                         \"first column node {}!\".format(node)\n                raise KnitNetworkTopologyError(errMsg)\n            # if this is a singular node, it is a separate column (?)\n            elif len(nodewarp_out) == 0 and len(nodewarp_in) == 0:\n                # errMsg = (\"Absolutely no 'warp' edges at \" +\n                #           \"node {}!\".format(node))\n                # raise KnitNetworkTopologyError(errMsg)\n\n                # append it as a column to the list of columns\n                cols.append([node])\n                # set the mapping dictionaries\n                col_id = (node, node)\n                id2col[col_id] = [node]\n                node2colid.update({node: col_id})\n                # set the seen marker and continue to next node\n                seencols[node] = True\n                continue\n            # if there is exactly one 'warp' edge, traverse until next node\n            elif len(nodewarp_out) == 1:\n                # get the connected node to the current node\n                connected_node = (nodewarp_out[0][1],\n                                  self.node[nodewarp_out[0][1]])\n                # define initial column nodes with nodes of the first edge\n                col_nodes = [node, connected_node[0]]\n                # traverse as long as there is an outgoing next 'warp' edge\n                while True:\n                    # get 'warp' edges of last node in row nodes\n                    next_warp = self.node_warp_edges_out(col_nodes[-1])\n                    # if there is more than one connected 'warp' edge, we\n                    # have a problem\n                    if len(next_warp) > 1:\n                        errMsg = \"More than one outgoing 'warp' edge at \" + \\\n                                 \"col node {}!\".format(node)\n                        raise KnitNetworkTopologyError(errMsg)\n                    # if there are no next 'warp' edges, column is complete\n                    elif len(next_warp) == 0:\n                        seencols[col_nodes[-1]] = True\n                        break\n                    # if there is a next node over a 'warp' edge, append to\n                    # column and continue\n                    elif len(next_warp) == 1:\n                        col_nodes.append(next_warp[0][1])\n                        continue\n                # append the completed column to the list of columns\n                cols.append(col_nodes)\n                # set the mapping dictionaries\n                col_id = (col_nodes[0], col_nodes[-1])\n                id2col[col_id] = col_nodes\n                node2colid.update({node: col_id for node in col_nodes})\n                # finally, set the current node as seen\n                seencols[node] = True\n\n        # BUILD ROW MAPPING FOR TOPOLOGICAL SORT ------------------------------\n\n        # initialize mapping for topological sort of rows\n        row_map = nx.DiGraph()\n        row_ids = id2row.keys()\n        # find all targets of all rows by checking all row nodes\n        # for targets and getting the corresponding row\n        for row_id in row_ids:\n            # get row from mapping dict\n            row = id2row[row_id]\n            # initialize list for storage of targets\n            target_ids = []\n            # loop over all nodes in the current row\n            for node in row:\n                # check the node for outgoing 'warp' edges and get its\n                # successor\n                try:\n                    node_suc = self.node_warp_edges_out(node)[0][1]\n                except IndexError:\n                    continue\n                # find the id of the row which contains the 'warp' edge\n                # successor node\n                target_id = node2rowid[node_suc]\n                # if we already found this id before, continue\n                if target_id in target_ids:\n                    continue\n                # if its a new id, append it to the list of found target ids\n                target_ids.append(target_id)\n\n            [row_map.add_edge(row_id, tid) for tid in target_ids]\n\n        # BUILD COLUMN MAPPING FOR TOPOLOGICAL SORT ---------------------------\n\n        # initialize mapping for backtracking of columns\n        col_map = nx.DiGraph()\n        col_ids = id2col.keys()\n        # find all targets of all columns by checking all column nodes\n        # for targets and getting the corresponding column\n        for col_id in col_ids:\n            # get column from mapping dict\n            col = id2col[col_id]\n            # initialize list for storage of targets\n            target_ids = []\n            # loop over all nodes in the current column\n            for node in col:\n                # check the node for outgoing 'weft' edges and get its\n                # successor\n                try:\n                    node_suc = self.node_weft_edges_out(node)[0][1]\n                except IndexError:\n                    continue\n                # find the id of the column which contains the 'weft' edge\n                # successor node\n                target_id = node2colid[node_suc]\n                # if we already found this id before, continue\n                if target_id in target_ids:\n                    continue\n                # if its a new id, append it to the list of found target ids\n                target_ids.append(target_id)\n\n            [col_map.add_edge(col_id, tid) for tid in target_ids]\n\n        # TOPOLOGICAL SORT OF ROWS --------------------------------------------\n\n        # own method of topological sort for rows (in utilities)\n        # ordered_row_stack = resolve_order_by_backtracking(row_map)\n\n        # use nx topological sort for rows\n        try:\n            ordered_row_ids = nx.topological_sort(row_map)\n        except nx.NetworkXError as e:\n            raise KnitNetworkTopologyError(str(e.message))\n        except nx.NetworkXUnfeasible as e:\n            raise KnitNetworkTopologyError(str(e.message))\n\n        # get the rows with the topological sorted result\n        toposort_rows = [id2row[id] for id in ordered_row_ids]\n        for i, row in enumerate(toposort_rows):\n            for n in row:\n                self.node[n][\"chain\"] = i\n\n        if consolidate:\n            # HORIZONTAL CONSOLIDATION ----------------------------------------\n            consolidated_rows = []\n            for i, row in enumerate(toposort_rows):\n                # if we are at the first row, just insert it\n                if i == 0:\n                    consolidated_rows.append(row)\n                    continue\n\n                # else get the previously inserted rows\n                prevrows = reversed(consolidated_rows)\n                # find first incoming warp edge that connects to a previous row\n                for prevrow in prevrows:\n                    row_found = False\n                    for node in row:\n                        warp_in = self.node_warp_edges_in(node)\n                        if warp_in:\n                            if warp_in[0][0] not in prevrow:\n                                continue\n                            connection_node = warp_in[0][1]\n                            connection_index = row.index(connection_node)\n                            prevrow_connection_node = warp_in[0][0]\n                            prevrow_connection_index = prevrow.index(\n                                                    prevrow_connection_node)\n                            row_found = True\n                    if row_found:\n                        break\n\n                # compute offset\n                if connection_index == prevrow_connection_index:\n                    offset = 0\n                else:\n                    offset = prevrow_connection_index - connection_index\n\n                # execute offset and append to consolidated rows\n                if offset == 0:\n                    consolidated_rows.append(row)\n                elif offset < 0:\n                    for consrow in consolidated_rows:\n                        for o in range(abs(offset)):\n                            consrow.insert(0, -1)\n                    consolidated_rows.append(row)\n                elif offset > 0:\n                    offset_list = [-1] * abs(offset)\n                    offset_list.extend(row)\n                    consolidated_rows.append(offset_list)\n\n            # fill to minlength\n            minrl = max([len(row) for row in consolidated_rows])\n            for row in consolidated_rows:\n                if len(row) != minrl:\n                    row.extend([-1] * (minrl - len(row)))\n\n            # VERTICAL CONSOLIDATION ------------------------------------------\n            vert_consolidated_rows = []\n            for i, row in enumerate(consolidated_rows):\n                if i == 0:\n                    vert_consolidated_rows.append(row)\n                    continue\n\n                # get the first index that is not -1\n                rowstart = None\n                rowend = None\n                for j, nodevalue in enumerate(row):\n                    if nodevalue != -1 and rowstart == None:\n                        rowstart = j\n                        if j == len(row) - 1:\n                            rowend = rowstart\n                            break\n                        continue\n                    elif nodevalue == -1 and rowstart != None:\n                        rowend = j\n                        break\n                    elif (nodevalue != -1 and\n                          j == len(row) - 1 and\n                          rowstart != None):\n                        rowend = j\n                        break\n\n                # get previous inserted rows and loop over them\n                prevrows = reversed(vert_consolidated_rows)\n\n                insertion_index = None\n                for j, prevrow in enumerate(prevrows):\n                    # get window\n                    window = prevrow[rowstart:rowend]\n                    # check if the window on the previous row is free\n                    if window == [-1] * len(window):\n                        insertion_index = len(vert_consolidated_rows) - 1 - j\n                        continue\n                    else:\n                        break\n\n                if insertion_index != None:\n                    insertion_row = vert_consolidated_rows[insertion_index]\n                    merged_row = insertion_row[:rowstart]\n                    merged_row.extend(row[rowstart:rowend + 1])\n                    merged_row.extend(insertion_row[rowend + 1:])\n\n                    vert_consolidated_rows[insertion_index] = merged_row\n                else:\n                    vert_consolidated_rows.append(row)\n\n            return vert_consolidated_rows\n\n        else:\n            # TOPOLOGICAL SORT OF COLUMNS -------------------------------------\n\n            # own method of topological sort for columns (in utilities)\n            # ordered_column_stack = resolve_order_by_backtracking(col_map)\n\n            # use nx topological sort for columns\n            try:\n                ordered_column_stack = nx.topological_sort(col_map)\n            except nx.NetworkXError as e:\n                raise KnitNetworkTopologyError(str(e.message))\n            except nx.NetworkXUnfeasible as e:\n                raise KnitNetworkTopologyError(str(e.message))\n\n            # SPREAD OUT BY FILLING WITH -1 FILLER ----------------------------\n\n            # fill all the rows to minimum row length with\n            # placeholder values (-1)\n            minrl = max([len(row) for row in rows])\n            # loop over all rows and fill until minimum length\n            for key in id2row.keys():\n                row = id2row[key]\n                for j in range(minrl):\n                    try:\n                        node = row[j]\n                    except IndexError:\n                        row.append(-2)\n                id2row[key] = row\n\n            # spread out rows according to toposorted columns\n            for i, col in enumerate(ordered_column_stack):\n                # get column nodes\n                colnodes = id2col[col]\n                # loop over all rows\n                for j, row in enumerate(toposort_rows):\n                    # check the entry at the current column index\n                    # if this entry is not in colnodes, shift it to the right\n                    entry = row[i]\n                    if entry in colnodes:\n                        toposort_rows[j].append(-2)\n                    elif entry not in colnodes:\n                        toposort_rows[j].insert(i, -1)\n\n            # trim final topological sorted rows\n            trim = toposort_rows[0].index(-2)\n            toposort_rows = [btr[:trim] for btr in toposort_rows]\n\n        # return all sorted rows\n        return toposort_rows\n\n# MAIN ------------------------------------------------------------------------\n\n\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}