{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Loft.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Loft.py",
  "instruction": "This script creates lofts or loft-like surfaces by choice of 3 methods:\r\n    1. Standard loft.  This was added to the script to utilize the script's UX.\r\n    2.",
  "code": "\"\"\"\r\nThis script creates lofts or loft-like surfaces by choice of 3 methods:\r\n    1. Standard loft.  This was added to the script to utilize the script's UX.\r\n    2. \r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n200404: Created.\r\n200515: Now aligns duplicates of the input curves.\r\n211127: Added 2 more lofting methods from other scripts as options.\r\n220322: Bug fix in resetting options.  UX improvements.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Enum\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bAlignCrvDirs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iLoftMethod'; keys.append(key)\r\n    values[key] = 1\r\n    listValues[key] = 'Standard', 'Iterative', 'SrfPtGrid'\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iLoftType'; keys.append(key)\r\n    values[key] = 0\r\n    listValues[key] = Enum.GetNames(rg.LoftType)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDegree'; keys.append(key)\r\n    values[key] = 5\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], lowerLimit=1, upperLimit=11)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDistTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bClosed'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPeriodic'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iGContinuity'; keys.append(key)\r\n    values[key] = -1\r\n    names[key] = 'MaxGContAdjustmentAtLoftEnds'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'iDegree':\r\n            if cls.riOpts[key].CurrentValue <= 0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Curves():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    sk_PrevSel = 'UsePrevSelection({})({})'.format(__file__, sc.doc.Name)\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt = {}\r\n\r\n        go.SetCommandPrompt(\"Select curves in lofting order\")\r\n\r\n        if (sk_PrevSel in sc.sticky) and sc.sticky[sk_PrevSel]:\r\n            key = 'UsePrevSelection'; idxs_Opt[key] = go.AddOption(key)\r\n\r\n        key = 'ResetOptions'; idxs_Opt[key] = go.AddOption(key)\r\n\r\n        res = go.GetMultiple(minimumNumber=2, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            sc.sticky[sk_PrevSel] = objrefs\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if go.Option().Index == idxs_Opt['UsePrevSelection']:\r\n            objrefs = sc.sticky[sk_PrevSel]\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n\r\n        if go.Option().Index == idxs_Opt['ResetOptions']:\r\n            for key in Opts.keys:\r\n                if key in Opts.riOpts:\r\n                    Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n\r\n\r\ndef _alignCrvDirs(crvs_In):\r\n    \"\"\"\r\n    Returns list of new curves.\r\n    \"\"\"\r\n    crvs_Out = [c.Duplicate() for c in crvs_In]\r\n    for i in range(1, len(crvs_Out)):\r\n        if not rg.Curve.DoDirectionsMatch(crvs_Out[0], crvs_Out[i]):\r\n            crvs_Out[i].Reverse()\r\n    return crvs_Out\r\n\r\n\r\ndef createLoft_CreateFromLoft(crvs, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        crvs\r\n        bAlignCrvDirs\r\n        iLoftType\r\n        bClosed\r\n        bPeriodic\r\n        iGContinuity\r\n        bEcho\r\n        bDebug\r\n    Returns on success: Rhino.Geometry.NurbsSurface\r\n    Returns on fail: None\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAlignCrvDirs = getOpt('bAlignCrvDirs')\r\n    iLoftType = getOpt('iLoftType')\r\n    bClosed = getOpt('bClosed')\r\n    bPeriodic = getOpt('bPeriodic')\r\n    iGContinuity = getOpt('iGContinuity')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    loftType = Enum.ToObject(rg.LoftType, iLoftType)\r\n\r\n\r\n    if bAlignCrvDirs:\r\n        crvs = _alignCrvDirs(crvs)\r\n\r\n    for i in range(1, len(crvs)):\r\n        if not rg.Curve.DoDirectionsMatch(crvs[0], crvs[i]):\r\n            print(crvs[i].Reverse())\r\n\r\n    rgBreps_fromLoft = rg.Brep.CreateFromLoft(\r\n        curves=crvs,\r\n        start=rg.Point3d.Unset,\r\n        end=rg.Point3d.Unset,\r\n        loftType=loftType,\r\n        closed=bClosed if len(crvs) > 2 else False)\r\n\r\n    if not rgBreps_fromLoft:\r\n        return\r\n\r\n    if len(rgBreps_fromLoft) == 1:\r\n        return rgBreps_fromLoft[0]\r\n\r\n    rgBs_Joined = rg.Brep.JoinBreps(rgBreps_fromLoft)\r\n    if len(rgBs_Joined) > 1:\r\n        raise ValueError(\"More than one Brep resulted from Join.\")\r\n    return rgBs_Joined[0]\r\n\r\n\r\ndef createLoft_MatchGrevilles(ncs, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        ncs\r\n        bAlignCrvDirs\r\n        iDegree\r\n        fDistTol\r\n        bClosed\r\n        bPeriodic\r\n        iGContinuity\r\n        bEcho\r\n        bDebug\r\n    Returns on success: Rhino.Geometry.NurbsSurface\r\n    Returns on fail: None\r\n    \"\"\"\r\n\r\n\r\n    if len(ncs) < 2:\r\n        return\r\n\r\n    for nc in ncs:\r\n        if not isinstance(nc, Rhino.Geometry.NurbsCurve):\r\n            print(\"Not all input curves are NURBS curves.\")\r\n            return\r\n\r\n    for i in range(1, len(ncs)):\r\n        if ncs[i].Degree != ncs[0].Degree:\r\n            print(\"Various degrees in input curves.\")\r\n            return\r\n        if ncs[i].Points.Count != ncs[0].Points.Count:\r\n            print(\"Various point counts in input curves.\")\r\n            return\r\n\r\n    for i in range(1, len(ncs)):\r\n        if (\r\n            ncs[i].SpanCount > 1 and\r\n            ncs[i].Knots.KnotStyle != rg.KnotStyle.QuasiUniform\r\n        ):\r\n            print(\"Non-uniform curve in input.  Check results.\")\r\n            break\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAlignCrvDirs = getOpt('bAlignCrvDirs')\r\n    iDegree = getOpt('iDegree')\r\n    fDistTol = getOpt('fDistTol')\r\n    bClosed = getOpt('bClosed')\r\n    bPeriodic = getOpt('bPeriodic')\r\n    iGContinuity = getOpt('iGContinuity')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if bAlignCrvDirs:\r\n        ncs = _alignCrvDirs(ncs)\r\n\r\n\r\n    if (iDegree == 2) and (len(ncs) == 2):\r\n        breps = rg.Brep.CreateFromLoft(ncs, start=rg.Point3d.Unset, end=rg.Point3d.Unset, loftType=rg.LoftType.Straight)\r\n        if len(breps) > 1:\r\n            return\r\n        brep = breps[0]\r\n        if brep.Surfaces.Count > 1:\r\n            return\r\n        return brep.Surfaces[0]\r\n\r\n\r\n    pts_InCols = []\r\n\r\n    for nc in ncs:\r\n        # TODO: Add support to maintain periodic knots in V direction.\r\n        if nc.IsPeriodic: nc.Knots.ClampEnd(rg.CurveEnd.Both)\r\n        pts_Col = [pt for pt in nc.GrevillePoints(all=nc.IsClosed)]\r\n        pts_InCols.append(pts_Col)\r\n\r\n    pts_Flat = [pt for pts_Col in pts_InCols for pt in pts_Col]\r\n\r\n\r\n    uDegree = iDegree\r\n    if (len(ncs) - 1) < uDegree:\r\n        uDegree = len(ncs) - 1\r\n        print(\"Degree along loft is made {} due to number of input curves.\".format(uDegree))\r\n\r\n\r\n    # Using CreateThroughPoints to create starting surface due to resultant\r\n    # proximity of Grevilles points between surface and curves for later matching.\r\n    ns = Rhino.Geometry.NurbsSurface.CreateFromPoints(\r\n        points=pts_Flat,\r\n        uCount=len(pts_InCols),\r\n        vCount=len(pts_InCols[0]),\r\n        uDegree=uDegree,\r\n        vDegree=ncs[0].Degree)\r\n        #uClosed=False,\r\n        #vClosed=ncs[0].IsClosed)\r\n\r\n    ns.KnotsU.CreateUniformKnots(knotSpacing=1.0)\r\n\r\n    if ns.SpanCount(1) > 1:\r\n        if ncs[0].Knots.KnotStyle == rg.KnotStyle.QuasiUniform:\r\n            ns.KnotsV.CreateUniformKnots(knotSpacing=1.0)\r\n        else:\r\n            for iK in range(ncs[0].Knots.Count):\r\n                ns.KnotsV[iK] = ncs[0].Knots[iK]\r\n\r\n    #for i, pt in enumerate(pts_Flat):\r\n    #    dot = rg.TextDot(\"[{}]\".format(i), pt)\r\n    #    sc.doc.Objects.AddTextDot(dot)\r\n    #return\r\n\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Matching surface to curves ...\")\r\n\r\n\r\n    # Match first and last column CP locations to those of first and last curves, respectively.\r\n    for iV in range(ncs[0].Points.Count):\r\n        ns.Points.SetControlPoint(0,iV,ncs[0].Points[iV])\r\n        ns.Points.SetControlPoint(ns.Points.CountU-1,iV,ncs[-1].Points[iV])\r\n\r\n\r\n    iteration = 0\r\n\r\n    zipped = zip(range(ns.Points.CountU), range(ns.Points.CountV))\r\n    \r\n    while True:\r\n        if sc.escape_test(throw_exception=False):\r\n            Rhino.RhinoApp.Wait()\r\n            return\r\n        \r\n        bMovedPt = False\r\n        \r\n        iPt = 0\r\n\r\n        for u in range(ns.Points.CountU):\r\n            for v in range(ns.Points.CountV):\r\n                pt_Target = pts_Flat[iPt]\r\n                pt2d_Gr = ns.Points.GetGrevillePoint(u,v)\r\n                pt3d_Gr = ns.PointAt(pt2d_Gr.X, pt2d_Gr.Y)\r\n                dist = pt3d_Gr.DistanceTo(pt_Target)\r\n                #print(pt3d_Gr, pt_Target, dist)\r\n                if dist <= fDistTol:\r\n                    iPt += 1\r\n                    continue\r\n                vect = pt_Target - pt3d_Gr\r\n                pt_cp = ns.Points.GetControlPoint(u,v).Location\r\n                ns.Points.SetControlPoint(u,v,rg.ControlPoint(pt_cp+vect))\r\n                bMovedPt = True\r\n                iPt += 1\r\n\r\n        if not bMovedPt:\r\n            print(\"Solution found after {} iterations.\".format(iteration))\r\n            break # out of while loop.\r\n\r\n        iteration += 1\r\n\r\n\r\n    return ns\r\n\r\n\r\ndef createLoft_CreateThroughPoints(ncs, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        ncs\r\n        iDegree\r\n        bClosed\r\n        bPeriodic\r\n        iGContinuity\r\n        bEcho\r\n        bDebug\r\n    Returns on success: Rhino.Geometry.NurbsSurface\r\n    Returns on fail: None\r\n    \"\"\"\r\n\r\n\r\n    if len(ncs) < 2:\r\n        return\r\n\r\n    for nc in ncs:\r\n        if not isinstance(nc, Rhino.Geometry.NurbsCurve):\r\n            print(\"Not all input curves are NURBS curves.\")\r\n            return\r\n\r\n    for i in range(1, len(ncs)):\r\n        if ncs[i].Degree != ncs[0].Degree:\r\n            print(\"Various degrees in input curves.\")\r\n            return\r\n        if ncs[i].Points.Count != ncs[0].Points.Count:\r\n            print(\"Various point counts in input curves.\")\r\n            return\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAlignCrvDirs = getOpt('bAlignCrvDirs')\r\n    iDegree = getOpt('iDegree')\r\n    bClosed = getOpt('bClosed')\r\n    bPeriodic = getOpt('bPeriodic')\r\n    iGContinuity = getOpt('iGContinuity')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if bAlignCrvDirs:\r\n        ncs = _alignCrvDirs(ncs)\r\n\r\n\r\n    if bClosed:\r\n        ncs.append(ncs[0])\r\n    else:\r\n        bPeriodic = False\r\n\r\n\r\n    uDegree = iDegree\r\n\r\n    if bClosed or iGContinuity < 0:\r\n        iAdditionalCps = 0\r\n        if (len(ncs) - 1) < uDegree:\r\n            uDegree = len(ncs) - 1\r\n            print(\"Degree along loft is made {} due to number of input curves and\" \\\r\n                \" required end continuity.\".format(uDegree))\r\n    else:\r\n        iAdditionalCps = uDegree//2 + iGContinuity + uDegree%2\r\n\r\n        if len(ncs) + iAdditionalCps <= uDegree:\r\n            while True:\r\n                sc.escape_test()\r\n                uDegree -= 1\r\n                iAdditionalCps = uDegree//2 + iGContinuity + uDegree%2\r\n                if len(ncs) + iAdditionalCps > uDegree:\r\n                    break\r\n            print(\"Degree along loft is made {} due to number of input curves and\" \\\r\n                \" required end continuity.\".format(uDegree))\r\n\r\n    if bDebug: sEval = \"iAdditionalCps\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n    pts_InCols = []\r\n\r\n    for nc in ncs:\r\n        pts_Col = [pt for pt in nc.GrevillePoints(all=False)]\r\n        pts_InCols.append(pts_Col)\r\n\r\n\r\n    def insertAdditionalCps():\r\n        cols_to_insert_NearT0 = []\r\n        cols_to_insert_NearT1 = []\r\n\r\n        numerator = 0.0\r\n        denominator = float(iAdditionalCps**2 + 3*iAdditionalCps + 2) / 2.0\r\n        if bDebug: sEval = \"denominator\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n        for iDiv in range(1, iAdditionalCps+1):\r\n            col_to_insert_NearT0 = []\r\n            col_to_insert_NearT1 = []\r\n            numerator += float(iDiv)\r\n            ratioFromEnd = numerator/denominator\r\n\r\n            for i in range(len(pts_InCols[0])):\r\n                pt = (1.0 - ratioFromEnd) * pts_InCols[0][i] + (ratioFromEnd) * pts_InCols[1][i]\r\n                col_to_insert_NearT0.append(pt)\r\n\r\n                pt = (1.0 - ratioFromEnd) * pts_InCols[-1][i] + (ratioFromEnd) * pts_InCols[-2][i]\r\n                col_to_insert_NearT1.append(pt)\r\n\r\n            cols_to_insert_NearT0.append(col_to_insert_NearT0)\r\n            cols_to_insert_NearT1.append(col_to_insert_NearT1)\r\n\r\n        for i, col_to_insert_NearT0 in enumerate(cols_to_insert_NearT0):\r\n            pts_InCols.insert(1+i, col_to_insert_NearT0)\r\n\r\n        for i, col_to_insert_NearT1 in enumerate(cols_to_insert_NearT1):\r\n            pts_InCols.insert(-1-i, col_to_insert_NearT1)\r\n\r\n    if iAdditionalCps:\r\n        insertAdditionalCps()\r\n\r\n\r\n    #for pts_Col in pts_InCols:\r\n    #    for pt in pts_Col:\r\n    #        sc.doc.Objects.AddPoint(pt)\r\n\r\n    if bDebug:\r\n        sEval = \"len(ncs)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"len(pts_Col[0])\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    #print(pts_InCols)\r\n\r\n\r\n\r\n    def idx_flat_to_uv(iCountV, idx):\r\n        return idx // iCountV, idx % iCountV\r\n\r\n\r\n    def idx_uv_to_flat(iCountV, idxU, idxV):\r\n        return idxU * iCountV + idxV\r\n\r\n\r\n\r\n    pts_Flat = [pt for pts_Col in pts_InCols for pt in pts_Col]\r\n\r\n    if bDebug:\r\n        for pt in pts_Flat:\r\n            sc.doc.Objects.AddPoint(pt)\r\n\r\n\r\n    return Rhino.Geometry.NurbsSurface.CreateThroughPoints(\r\n        points=pts_Flat,\r\n        uCount=len(pts_InCols),\r\n        vCount=len(pts_InCols[0]),\r\n        uDegree=uDegree,\r\n        vDegree=ncs[0].Degree,\r\n        uClosed=bPeriodic,\r\n        vClosed=ncs[0].IsClosed)\r\n\r\n\r\nclass DrawBrepConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.color = sc.doc.Layers.CurrentLayer.Color\r\n        self.brep = None\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        if self.brep:\r\n            self.bbox = self.brep.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n        if self.brep:\r\n            drawEventArgs.Display.DrawBrepWires(\r\n                brep=self.brep,\r\n                color=self.color,\r\n                wireDensity=1)\r\n            drawEventArgs.Display.DrawBrepShaded(\r\n                brep=self.brep,\r\n                material=Rhino.Display.DisplayMaterial(diffuse=self.color))\r\n\r\n\r\ndef _createLoft_interactively(ncs_In):\r\n    \"\"\"\r\n    Returns\r\n        None to cancel.\r\n        False to indicate to create objects with current options.\r\n        True to indicate to regenerate geometry and return to this function.\r\n    \"\"\"\r\n    \r\n    valuesBefore = {}\r\n\r\n    go = ri.Custom.GetOption()\r\n\r\n    go.SetCommandPromptDefault(\"Accept\") \r\n\r\n    go.AcceptNothing(True)\r\n\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__)\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n    else:\r\n        conduit = DrawBrepConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n    idxs_Opt = {}\r\n\r\n    bRecalc = True\r\n\r\n    while True:\r\n\r\n        sCurrentMethod = Opts.listValues['iLoftMethod'][Opts.values['iLoftMethod']]\r\n\r\n        rgB_Out = None\r\n\r\n        if not bRecalc:\r\n            conduit.Enabled = True\r\n            sc.doc.Views.Redraw()\r\n        else:\r\n            if sCurrentMethod == 'Standard':\r\n                rgB_Out = createLoft_CreateFromLoft(ncs_In)\r\n            elif sCurrentMethod == 'Iterative':\r\n                ns_Res = createLoft_MatchGrevilles(ncs_In)\r\n                if ns_Res:\r\n                    rgB_Out = ns_Res.ToBrep()\r\n            elif sCurrentMethod == 'SrfPtGrid':\r\n                ns_Res = createLoft_CreateThroughPoints(ncs_In)\r\n                if ns_Res:\r\n                    rgB_Out = ns_Res.ToBrep()\r\n            else:\r\n                raise ValueError(\"LoftMethod value error.\")\r\n\r\n            if rgB_Out:\r\n                conduit.brep = rgB_Out\r\n                conduit.Enabled = True\r\n                sc.doc.Views.Redraw()\r\n            else:\r\n                print(\"Loft was not created at current settings.\")\r\n\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        go.SetCommandPrompt(\"{}\".format(sCurrentMethod))\r\n\r\n        for i, key in enumerate(Opts.listValues['iLoftMethod']):\r\n            #if i == Opts.values['iLoftMethod']:\r\n            #    idxs_Opt[key] = None\r\n            #    continue\r\n            idxs_Opt[key] = go.AddOption(key)\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bAlignCrvDirs')\r\n        if sCurrentMethod == 'Standard':\r\n            go.AcceptNumber(False, acceptZero=True)\r\n\r\n            addOption('iLoftType')\r\n            if len(ncs_In) > 2:\r\n                addOption('bClosed')\r\n        elif sCurrentMethod == 'Iterative':\r\n            go.AcceptNumber(True, acceptZero=True)\r\n\r\n            addOption('iDegree')\r\n            addOption('fDistTol')\r\n        elif sCurrentMethod == 'SrfPtGrid':\r\n            go.AcceptNumber(True, acceptZero=True)\r\n\r\n            addOption('iDegree')\r\n            if len(ncs_In) > 2:\r\n                addOption('bClosed')\r\n                if Opts.values['bClosed']:\r\n                    addOption('bPeriodic')\r\n                else:\r\n                    addOption('iGContinuity')\r\n            else:\r\n                addOption('iGContinuity')\r\n        else:\r\n            raise ValueError(\"LoftMethod value error.\")\r\n\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        for key in Opts.keys:\r\n            valuesBefore[key] = Opts.values[key]\r\n\r\n        res = go.Get()\r\n\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            # Accept current result.\r\n            go.Dispose()\r\n            return rgB_Out\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iDegree'\r\n            iNewDeg = abs(int(go.Number()))\r\n            if not (0 < iNewDeg < 12):\r\n                continue\r\n            Opts.riOpts[key].CurrentValue = iNewDeg\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        def getLoftMethodChange():\r\n            for key in Opts.listValues['iLoftMethod']:\r\n                if go.Option().Index == idxs_Opt[key]:\r\n                    return key\r\n\r\n        rc = getLoftMethodChange()\r\n        if rc:\r\n            key = rc\r\n            if key == Opts.listValues['iLoftMethod'][Opts.values['iLoftMethod']]:\r\n                print(\"No change.\")\r\n                bRecalc = False\r\n            Opts.setValue(\r\n                'iLoftMethod',\r\n                Opts.listValues['iLoftMethod'].index(key))\r\n            bRecalc = True\r\n            continue\r\n\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                bRecalc = True\r\n                break\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput_Curves()\r\n    if not objrefs: return\r\n    \r\n    ncs_FromIn = [o.Curve().ToNurbsCurve() for o in objrefs]\r\n\r\n    rc = _createLoft_interactively(ncs_FromIn)\r\n\r\n    if rc is None:\r\n        # Cancel.\r\n        return\r\n    if not rc:\r\n        # Create objects.\r\n        return\r\n\r\n    sc.doc.Objects.AddBrep(rc)\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}