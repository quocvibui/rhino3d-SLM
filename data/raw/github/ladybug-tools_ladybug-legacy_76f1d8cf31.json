{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Recolor%20Mesh.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Recolor Mesh.py",
  "instruction": "Use this component to re-color a mesh with new a numerical data set whose length corresponds to the number of faces in the _inputMesh.\nThis component is useful if you have post-processed any of the...",
  "code": "# This component re-color the mesh based on new parameters\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <Sadeghipour@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to re-color a mesh with new a numerical data set whose length corresponds to the number of faces in the _inputMesh.\nThis component is useful if you have post-processed any of the numerical data out of the Ladybug components using Grasshopper math components.\nIt is also necessary to view results from the Ladybug Real Time Radiation Analysis.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _analysisResult: A numerical data set whose length corresponds to the number of faces in the _inputMesh.  This data will be used to re-color the _inputMesh.\n        _inputMesh: An already-colored mesh from one of the Ladybug components which you would like to re-color based on data in the _analysisResult.\n        heightDomain_: Optional height domain to create a 3D mesh result. Use Construct Domain component to create a domain\n        legendPar_: Optional legend parameters from the Ladybug Legend Parameters component.  Legend Parameters can be used to change the colors, numerical range, and/or number of divisions of any Ladybug legend along with the corresponding colored mesh.\n        analysisTitle_: Text representing a new title for the re-colored mesh.  If no title is input here, the default will read \"unnamed.\"\n        legendTitle_: Text representing a new legend title for re-colored mesh. Legends are usually titled with the units of the _analysisResult.  If no text is provided here, the default title will read \"unkown units.\"\n        bakeIt_ : An integer that tells the component if/how to bake the bojects in the Rhino scene.  The default is set to 0.  Choose from the following options:\n            0 (or False) - No geometry will be baked into the Rhino scene (this is the default).\n            1 (or True) - The geometry will be baked into the Rhino scene as a colored hatch and Rhino text objects, which facilitates easy export to PDF or vector-editing programs. \n            2 - The geometry will be baked into the Rhino scene as colored meshes, which is useful for recording the results of paramteric runs as light Rhino geometry.\n        layerName_: If bakeIt_ is set to \"True\", input Text here corresponding to the Rhino layer onto which the resulting mesh and legend should be baked.\n        lowBoundColor_: A color representing the higher boundary of the legend's numerical range, use the Swatch component to specify a color.\n        highBoundColor_: A color representing the lowest boundary of the legend's numerical range, use the Swatch component to specify a color.\n    Returns:\n        readMe!: ...\n        newMesh: A new mesh that has been re-colored based on the _analysisResult data.\n        newLegend: A new legend that that corresponds to the colors of the newMesh. Connect this output to a grasshopper \"Geo\" component in order to preview this legend separately in the Rhino scene.  \n        legendBasePt: The legend base point, which can be used to move the legend in relation to the newMesh with the grasshopper \"move\" component.\n        meshColors: The colors associated with each face of the newMesh.\n        legendColors: The colors associated with each segment of the newLegend.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Recolor Mesh\"\nghenv.Component.NickName = 'reColorMesh'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"5 | Extra\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n#compatibleLBVersion = VER 0.0.59\\nJAN_02_2017\n\nimport scriptcontext as sc\nimport Rhino as rc\nimport System\nfrom math import pi as PI\n\nfrom clr import AddReference\nAddReference('Grasshopper')\nimport Grasshopper.Kernel as gh\n\n\ndef main(analysisResult, inputMesh, heightDomain, legendPar, analysisTitle, legendTitle, bakeIt, layerName, lowBoundColor, highBoundColor, lb_preparation, lb_visualization):\n    conversionFac = lb_preparation.checkUnits()\n    \n    if inputMesh.Faces.Count == len(analysisResult):\n        meshStruct = 0\n    elif inputMesh.Vertices.Count == len(analysisResult):\n        meshStruct = 1\n    else:\n        warning = 'length of the results [=' + str(len(analysisResult)) + '] is not equal to the number of mesh faces [=' + str(inputMesh.Faces.Count) + '] or mesh vertices[=' + str(inputMesh.Vertices.Count) + '].'\n        print warning\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    lowB, highB, numSeg, customColors, legendBasePoint, legendScale, legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan = lb_preparation.readLegendParameters(legendPar, False)\n    colors = lb_visualization.gradientColor(analysisResult, lowB, highB, customColors,lowBoundColor,highBoundColor)\n    coloredChart = lb_visualization.colorMesh(colors, inputMesh, True, meshStruct)\n    \n    if heightDomain!=None:\n        coloredChart = lb_visualization.create3DColoredMesh(coloredChart, analysisResult, heightDomain, colors, meshStruct)\n    \n    lb_visualization.calculateBB([coloredChart], True)\n    \n    if not legendTitle:  legendTitle = 'unknown units  '\n    if not analysisTitle: analysisTitle = '\\nno title'\n    \n    legendSrfs, legendText, legendTextCrv, textPt, textSize = lb_visualization.createLegend(analysisResult\n        , lowB, highB, numSeg, legendTitle, lb_visualization.BoundingBoxPar, legendBasePoint, legendScale\n        , legendFont, legendFontSize, legendBold, decimalPlaces, removeLessThan)\n    \n    # generate legend colors\n    legendColors = lb_visualization.gradientColor(legendText[:-1], lowB, highB, customColors,lowBoundColor,highBoundColor)\n    \n    # color legend surfaces\n    legendSrfs = lb_visualization.colorMesh(legendColors, legendSrfs)\n    \n    titlebasePt = lb_visualization.BoundingBoxPar[-2]\n    if legendFont == None: legendFont = 'Veranda'\n    if legendFontSize == None: legendFontSize = legendScale * (lb_visualization.BoundingBoxPar[2]/20)\n    titleTextCurve = lb_visualization.text2srf([\"\\n\\n\" + analysisTitle], [titlebasePt], legendFont, legendFontSize, legendBold)\n    \n    if legendBasePoint == None: legendBasePoint = lb_visualization.BoundingBoxPar[0]\n    \n    if bakeIt > 0:\n        formatString = \"%.\"+str(decimalPlaces)+\"f\"\n        for count, item in enumerate(legendText):\n            try:\n                legendText[count] = formatString % item\n            except:pass\n        legendText.append(analysisTitle)\n        textPt.append(titlebasePt)\n        studyLayerName = 'CUSTOM_PRESENTATION'\n        if layerName == None: layerName = 'Custom'\n        # check the study type\n        newLayerIndex, l = lb_visualization.setupLayers('Modified Version', 'LADYBUG', layerName, studyLayerName)\n        if bakeIt == 1: lb_visualization.bakeObjects(newLayerIndex, coloredChart, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, True)\n        else: lb_visualization.bakeObjects(newLayerIndex, coloredChart, legendSrfs, legendText, textPt, textSize, legendFont, None, decimalPlaces, False)\n    return coloredChart, [legendSrfs, lb_preparation.flattenList(legendTextCrv + titleTextCurve)], legendBasePoint, colors, legendColors\n\n\n\n# import the classes\ninitCheck = True\nif sc.sticky.has_key('ladybug_release'):\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = False\n    except:\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n                 \"Use updateLadybug component to update userObjects.\\n\" + \\\n                 \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n                 \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        initCheck = False\n    \n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nelse:\n    print \"You should let the Ladybug fly first...\"\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"You should let the Ladybug fly first...\")\n    initCheck = False\n\n\n\nif initCheck == True and _inputMesh and len(_analysisResult)!=0:\n    result = main(_analysisResult, _inputMesh, heightDomain_, legendPar_, analysisTitle_, legendTitle_, bakeIt_, layerName_, lowBoundColor_, highBoundColor_, lb_preparation, lb_visualization)\n    if result!= -1:\n        newLegend= []\n        newMesh = result[0]\n        [newLegend.append(item) for item in lb_visualization.openLegend(result[1])]\n        legendBasePt = result[2]\n        meshColors = result[3]\n        legendColors = result[4]\n        \n        # Hide output\n        ghenv.Component.Params.Output[3].Hidden = True\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}