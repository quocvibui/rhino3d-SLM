{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrep_selectOthersByAttribute.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrep_selectOthersByAttribute.py",
  "instruction": "201030: Created, starting with xBreps_similar.py.\r\n201102: Added support for Extrusions.  Now considers Attributes.ColorSource.  Added feedback for when analyzing large data sets.\r\n201105: Improved...",
  "code": "\"\"\"\r\n201030: Created, starting with xBreps_similar.py.\r\n201102: Added support for Extrusions.  Now considers Attributes.ColorSource.  Added feedback for when analyzing large data sets.\r\n201105: Improved efficency of volume checking and open breps are now skipped for volume matching.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nsAttrs = [\r\n    'Colour',\r\n    'Name',\r\n    'Layer',\r\n    'Volume',\r\n    ]\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n    \r\n    key = 'fFloatTol'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key], setLowerLimit=True, limit=sc.doc.ModelAbsoluteTolerance)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    # Get Brep/Extrusion with optional input.\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select source brep/extrusion\")\r\n    go.GeometryFilter = rd.ObjectType.Brep # Brep will also filter Extrusions ( https://discourse.mcneel.com/t/restriction-of-objecttype-in-rhinocommon/73603/5 )\r\n    go.SubObjectSelect = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        key = 'fFloatTol'; idxs_Opt[key] = Opts.addOption(go, key)\r\n        key = 'bEcho'; idxs_Opt[key] = Opts.addOption(go, key)\r\n        key = 'bDebug'; idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n\r\n            go = ri.Custom.GetOption()\r\n            go.SetCommandPrompt(\"Select matching attribute\")\r\n\r\n\r\n            idxs_Opt = {}\r\n\r\n            while True:\r\n                for key in sAttrs:\r\n                    idxs_Opt[key] = go.AddOption(key)\r\n                key = 'fFloatTol'; idxs_Opt[key] = Opts.addOption(go, key)\r\n                key = 'bEcho'; idxs_Opt[key] = Opts.addOption(go, key)\r\n                key = 'bDebug'; idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n                res = go.Get()\r\n\r\n                if res == ri.GetResult.Object:\r\n                    objref = go.Object(0)\r\n                    go.Dispose()\r\n                    return tuple([objref] + [Opts.values[key] for key in Opts.keys])\r\n                elif res == ri.GetResult.Cancel:\r\n                    go.Dispose()\r\n                    return\r\n                else:\r\n                    # An option was selected or a number was entered.\r\n                    for key in sAttrs:\r\n                        if go.OptionIndex() == idxs_Opt[key]:\r\n                            return tuple([objref] + [key] + [Opts.values[key] for key in Opts.keys])\r\n\r\n                Opts.setValues()\r\n                Opts.saveSticky()\r\n                go.ClearCommandOptions()\r\n\r\n        elif res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        else:\r\n            # An option was selected.\r\n            pass\r\n\r\n        Opts.saveSticky()\r\n\r\n\r\ndef getMatches(objref_toMatch, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def setOpt(key, value=None):\r\n        if key in kwargs:\r\n            return kwargs[key]\r\n        elif key in Opts.riOpts:\r\n            return Opts.riOpts[key].InitialValue\r\n        else:\r\n            return value\r\n\r\n\r\n    sAttr = setOpt('sAttr')\r\n    fFloatTol = setOpt('fFloatTol')\r\n    bEcho = setOpt('bEcho')\r\n    bDebug = setOpt('bDebug')\r\n\r\n\r\n    objref0 = objref_toMatch\r\n\r\n    bToMatch_IsExtrusion = bool(objref0.Surface())\r\n\r\n    if sAttr == \"Colour\":\r\n        rdRhObj0 = objref0.Object()\r\n\r\n        if rdRhObj0.Attributes.ColorSource == rd.ObjectColorSource.ColorFromMaterial:\r\n            print \"Colour from material not supported yet.\"\r\n            return\r\n        elif rdRhObj0.Attributes.ColorSource == rd.ObjectColorSource.ColorFromObject:\r\n            colorRhObj0 = rdRhObj0.Attributes.ObjectColor\r\n        else:\r\n            if rdRhObj0.Attributes.ColorSource == rd.ObjectColorSource.ColorFromLayer:\r\n                pass\r\n            else:\r\n                # Color from parent.\r\n                # Use layer color unless object is within a block definition.\r\n                pass\r\n\r\n            li = rdRhObj0.Attributes.LayerIndex\r\n            layer = sc.doc.Layers.FindIndex(li)\r\n            colorRhObj0 = layer.Color\r\n\r\n\r\n    elif sAttr == 'Volume':\r\n        rgBrep0 = objref0.Brep() # Brep is also returned when objref0 contains an Extrusion.\r\n\r\n        if not rgBrep0.IsValid:\r\n            print \"Reference {} {} is invalid.  Repair it then rerun this script.\".format(\r\n                \"Extrusion\" if bToMatch_IsExtrusion else \"Brep\",\r\n                objref0.ObjectId)\r\n            rgBrep0.Dispose()\r\n            return\r\n\r\n        if not rgBrep0.IsSolid:\r\n            print \"Reference {} {} is open.  Its 'Volume' will not be matched.\".format(\r\n                \"Extrusion\" if bToMatch_IsExtrusion else \"Brep\",\r\n                objref0.ObjectId)\r\n            rgBrep0.Dispose()\r\n            return\r\n\r\n        fVol0 = rgBrep0.GetVolume()\r\n        if not fVol0:\r\n            print \"Volume can not be calculated.  Repair {} {}.\".format(\r\n                \"Extrusion\" if bToMatch_IsExtrusion else \"Brep\",\r\n                objref0.ObjectId)\r\n            rgBrep0.Dispose()\r\n            return\r\n\r\n        iToMatch_FaceCt = rgBrep0.Faces.Count\r\n\r\n        rgBrep0.Dispose()\r\n    \r\n    gBreps_ToSearch = []\r\n    rgBreps_ToSearch = []\r\n    iCts_Faces_ToSearch = []\r\n    fEdgeLens_ToSearch = []\r\n\r\n    iter = rd.ObjectEnumeratorSettings()\r\n    iter.NormalObjects = True\r\n    iter.LockedObjects = False\r\n    iter.IncludeLights = False\r\n    iter.IncludeGrips = False\r\n    iter.ObjectTypeFilter = rd.ObjectType.Brep | rd.ObjectType.Extrusion\r\n\r\n    gBreps_MatchesFound = [] # Also can include Extrusions.\r\n\r\n    iBrepExtrCt = 0\r\n    for rdObj in sc.doc.Objects.GetObjectList(iter):\r\n        iBrepExtrCt += 1\r\n\r\n    iOpenBrepCt = 0\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*iBrepExtrCt,0)) for i in range(10)]\r\n\r\n    for i, rdRhObjX in enumerate(sc.doc.Objects.GetObjectList(iter)):\r\n        if sc.escape_test(throw_exception=False):\r\n            print \"*** Analysis interrupted by user.\" \\\r\n                \"  Selected breps/extrusions are of partial results.\"\r\n            return gBreps_MatchesFound\r\n\r\n        if rdRhObjX.Id == objref0.ObjectId: continue\r\n\r\n        if iBrepExtrCt > 10:\r\n            if i in idxs_AtTenths:\r\n                Rhino.RhinoApp.SetCommandPrompt(\"Analysis at {:d}% of {} breps/extrusions ...\".format(\r\n                    int(100.0 * (i+1) / iBrepExtrCt), iBrepExtrCt))\r\n        elif iBrepExtrCt > 1:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                \"Analysis at {} of {} breps/extrusions\".format(\r\n                    i+1, iBrepExtrCt))\r\n        else:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analyzing other brep/extrusion ...\")\r\n\r\n\r\n        if sAttr == 'Colour':\r\n            if rdRhObjX.Attributes.ColorSource == rd.ObjectColorSource.ColorFromObject:\r\n                colorRhObjX = rdRhObjX.Attributes.ObjectColor\r\n            elif rdRhObjX.Attributes.ColorSource == rd.ObjectColorSource.ColorFromMaterial:\r\n                print \"Colour from material not supported yet.\"\r\n                return\r\n            else:\r\n                if rdRhObjX.Attributes.ColorSource == rd.ObjectColorSource.ColorFromLayer:\r\n                    pass\r\n                else:\r\n                    # Color from parent.\r\n                    # Use layer color unless object is within a block definition.\r\n                    pass\r\n\r\n                li = rdRhObjX.Attributes.LayerIndex\r\n                layer = sc.doc.Layers.FindIndex(li)\r\n                colorRhObjX = layer.Color\r\n\r\n            if colorRhObjX == colorRhObj0:\r\n                gBreps_MatchesFound.append(rdRhObjX.Id)\r\n        elif sAttr == 'Name':\r\n            if rdRhObjX.Attributes.Name == objref0.Object().Attributes.Name:\r\n                gBreps_MatchesFound.append(rdRhObjX.Id)\r\n        elif sAttr == 'Layer':\r\n            if rdRhObjX.Attributes.LayerIndex == objref0.Object().Attributes.LayerIndex:\r\n                gBreps_MatchesFound.append(rdRhObjX.Id)\r\n        elif sAttr == 'Volume':\r\n\r\n            bToCheck_IsExtrusion = isinstance(rdRhObjX, rd.ExtrusionObject)\r\n\r\n            rgGeomX = rdRhObjX.Geometry\r\n\r\n            if not rgGeomX.IsValid:\r\n                print \"{} {} is invalid.  Fix first.\".format(\r\n                    rdRhObjX.GetType().Name,\r\n                    rdRhObjX.Id)\r\n                rgGeomX.Dispose()\r\n                continue\r\n\r\n            if bToCheck_IsExtrusion:\r\n                rgBrepX = rgGeomX.ToBrep(splitKinkyFaces=True)\r\n                rgGeomX.Dispose()\r\n            else:\r\n                rgBrepX = rgGeomX\r\n\r\n            if not rgBrepX.IsSolid:\r\n                iOpenBrepCt += 1\r\n                rgBrepX.Dispose()\r\n                continue\r\n\r\n            ## This significantly speeds up the analysis.\r\n            #if rdRhObjX.ObjectType == rd.ObjectType.Brep:\r\n            #    if rgBrepX.Faces.Count != iToMatch_FaceCt:\r\n            #        rgBrepX.Dispose()\r\n            #        continue\r\n\r\n            fVol = rgBrepX.GetVolume() # GetVolume may be faster than VolumeMassProperties.Compute.\r\n            if not fVol:\r\n                print \"Volume can not be calculated.  Repair {} {}.\".format(\r\n                    rdRhObjX.GetType().Name,\r\n                    rdRhObjX.Id)\r\n                rgBrepX.Dispose()\r\n                continue\r\n\r\n            rgBrepX.Dispose()\r\n\r\n            fVolDiff = abs(fVol - fVol0)\r\n            if bDebug: print \"Volume:\", fVol0, fVolDiff\r\n            if fVolDiff > fFloatTol:\r\n                continue\r\n\r\n            gBreps_MatchesFound.append(rdRhObjX.Id)\r\n\r\n\r\n    if sAttr == 'Volume':\r\n        if iOpenBrepCt:\r\n            print \"{} open breps skipped for volume matching.\".format(iOpenBrepCt)\r\n        else:\r\n            print \"No open breps are present.\"\r\n\r\n\r\n    return gBreps_MatchesFound\r\n\r\n\r\ndef main():\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n            objref_toMatch,\r\n            sAttr,\r\n            fFloatTol,\r\n            bEcho,\r\n            bDebug,\r\n    ) = rc\r\n    \r\n    if bDebug:\r\n        pass\r\n        #reload()\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    #print list(sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False))\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    rc = getMatches(\r\n            objref_toMatch=objref_toMatch,\r\n            sAttr=sAttr,\r\n            fFloatTol=fFloatTol,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug,\r\n            )\r\n    if not rc:\r\n        print \"No matches found.  No objects are selected.\"\r\n        return\r\n    \r\n    gBreps_MatchesFound = rc\r\n    \r\n    sc.doc.Objects.Select(objectIds=[objref_toMatch.ObjectId] + gBreps_MatchesFound)\r\n\r\n    rdObjs_Sel = list(sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False))\r\n\r\n    if rdObjs_Sel:\r\n        print \"{} [{}] breps / [{}] extrusions are selected.\".format(\r\n            len(rdObjs_Sel),\r\n            len([rdObj for rdObj in rdObjs_Sel if rdObj.ObjectType == rd.ObjectType.Brep]),\r\n            len([rdObj for rdObj in rdObjs_Sel if rdObj.ObjectType == rd.ObjectType.Extrusion]))\r\n    else:\r\n        print \"No objects are selected.\"\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}