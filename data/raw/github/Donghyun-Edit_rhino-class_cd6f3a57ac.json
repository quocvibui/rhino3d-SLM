{
  "source_url": "https://github.com/Donghyun-Edit/rhino-class/blob/7df8a730d15f1aaa485b522ea971ca574c5781ed/logic/exercise/triangle_panel.py",
  "repo": "Donghyun-Edit/rhino-class",
  "repo_stars": 0,
  "repo_description": "강의에서 사용되는 라이노와 파이썬 세팅",
  "license": "MIT",
  "filepath": "logic/exercise/triangle_panel.py",
  "instruction": "Triangle panel",
  "code": "import math\nimport itertools\nimport Rhino.Geometry as geo\n\n\nclass TriPanel:\n    def __init__(\n        self,\n        pt_base: geo.Point3d,\n        pt_foot: geo.Point3d,\n        pt_vertical: geo.Point3d,\n        perp_vec: geo.Vector3d,\n    ):\n        self.pt_base = pt_base\n        self.pt_foot = pt_foot\n        self.pt_vertical = pt_vertical\n        self.foot_length = pt_vertical.DistanceTo(pt_foot)\n\n        self.perp_vec = perp_vec\n\n    @property\n    def crv(self) -> geo.Curve:\n        return geo.PolylineCurve(\n            [self.pt_base, self.pt_foot, self.pt_vertical, self.pt_base]\n        )\n\n    def move(self, ratio: float):\n        # type: (...) -> TriPanel\n        if ratio <= 0:\n            return self\n\n        height = self.foot_length * ratio\n        pt_vertical = self.pt_vertical + self.perp_vec * height  # type: ignore\n\n        moved_pts = []  # type: list[geo.Point3d]\n        for pt in [self.pt_base, self.pt_foot]:\n            vec = pt - self.pt_vertical  # type: ignore\n            vec.Unitize()\n\n            seg_length = pt.DistanceTo(self.pt_vertical)\n            if seg_length > height:\n                move_length = math.sqrt(seg_length**2 - height**2)\n            else:\n                move_length = 0.0\n            moved_pts.append(self.pt_vertical + vec * move_length)\n\n        return TriPanel(moved_pts[0], moved_pts[1], pt_vertical, self.perp_vec)\n\n\nclass TriModule:\n    def __init__(self, pt_a: geo.Point3d, pt_b: geo.Point3d, pt_c: geo.Point3d):\n        self.pt_a = pt_a\n        self.pt_b = pt_b\n        self.pt_c = pt_c\n\n        self.incenter = self.get_incenter()\n        self.perp_vec = self.get_perp_vec()\n\n        self.base_panels = self.get_tri_panels()\n\n    @property\n    def crv(self) -> geo.Curve:\n        return geo.PolylineCurve([self.pt_a, self.pt_b, self.pt_c, self.pt_a])\n\n    @property\n    def crvs(self) -> list[geo.Curve]:\n        return [panel.crv for panel in self.base_panels]\n\n    def get_incenter(self):\n        # type: (...) -> geo.Point3d\n        pt_a, pt_b, pt_c = self.pt_a, self.pt_b, self.pt_c\n        ab = pt_a.DistanceTo(pt_b)\n        bc = pt_b.DistanceTo(pt_c)\n        ca = pt_c.DistanceTo(pt_a)\n        incenter = geo.Point3d((pt_a * bc + pt_b * ca + pt_c * ab) / (ab + bc + ca))  # type: ignore\n        return incenter\n\n    def get_perp_vec(self):\n        # type: (...) -> geo.Vector3d\n        vec_ab = self.pt_b - self.pt_a  # type: ignore\n        vec_bc = self.pt_c - self.pt_b  # type: ignore\n        vec_perp = geo.Vector3d.CrossProduct(vec_ab, vec_bc)\n        vec_perp.Unitize()\n        return vec_perp\n\n    def get_tri_panels(self):\n        # type: (...) -> list[TriPanel]\n        pts = [self.pt_a, self.pt_b, self.pt_c]\n        incenter = self.incenter\n\n        tri_panels = []  # type: list[TriPanel]\n        for bases in itertools.combinations(pts, 2):\n            line = geo.Line(*bases)  # type: ignore\n            foot = line.ClosestPoint(incenter, True)\n            if not foot:\n                raise ValueError(\"Impossible Triangle\")\n            tri_panels += [\n                TriPanel(base, foot, incenter, self.perp_vec) for base in bases\n            ]\n\n        return tri_panels\n\n    def crvs_at_ratio(self, ratio: float):\n        # type: (...) -> list[geo.Curve]\n        return [panel.move(ratio).crv for panel in self.base_panels]\n\n\nclass TriFacade:\n    def __init__(self, tri_modules: list[TriModule]):\n        self.tri_modules = tri_modules\n\n    def get_breps(self, sunlight_vec: geo.Vector3d):\n        # type: (...) -> list[geo.Brep]\n        crvs = []  # type: list[geo.Curve]\n        standard_vec = -sunlight_vec  # type: ignore\n        for tri_module in self.tri_modules:\n            cos_val = tri_module.perp_vec * standard_vec\n            remap_val = (cos_val + 1) / 2\n            crvs += tri_module.crvs_at_ratio(remap_val)\n        return geo.Brep.CreatePlanarBreps(crvs, 0.001)\n\n\nclass Triangulizer:\n    def __init__(self, mass: geo.Brep):\n        self.mass = mass\n\n    def calculate_angle(self, vec: geo.Vector3d):\n        # type: (...) -> float\n        return math.atan2(vec.Y, vec.X)  # atan2는 각도를 -pi에서 pi 사이로 반환\n\n    def get_contours(self, height: float):\n        # type: (...) -> list[geo.Curve]\n        max_z = geo.Box(geo.Plane.WorldXY, self.mass).Z.Max  # type: ignore\n        divide_count = math.floor(max_z / height)\n\n        contour_crvs = []  # type: list[geo.Curve]\n\n        for i in range(divide_count + 1):\n            transform = geo.Transform.Translation(geo.Vector3d.ZAxis * i * height)  # type: ignore\n            cutter_plane = geo.Plane.WorldXY\n            cutter_plane.Transform(transform)\n            crvs = list(geo.Brep.CreateContourCurves(self.mass, cutter_plane))  # type: ignore\n            contour_crvs += crvs\n\n        return contour_crvs\n\n    def get_facade(self, divide_count: int, height: float):\n        # type: (...) -> TriFacade\n        contours = self.get_contours(height)\n        pt_center = geo.AreaMassProperties.Compute(contours[0]).Centroid  # type: ignore\n        transform = geo.Transform.Rotation(math.pi / divide_count, pt_center)  # type: ignore\n\n        contour_pts = {}  # type: dict[geo.Curve, list[geo.Point3d]]\n        for i, contour in enumerate(contours):\n            params = contour.DivideByCount(divide_count, True)\n            pts = [contour.PointAt(param) for param in params]\n            if i % 2 == 1:\n                pts = [transform * pt for pt in pts]\n            contour_pts[contour] = pts\n\n        tri_modules = []  # type: list[TriModule]\n        for bottom_crv, top_crv in zip(contours[:-1], contours[1:]):\n            pts = contour_pts[bottom_crv] + contour_pts[top_crv]\n            pts.sort(key=lambda pt: self.calculate_angle(pt - pt_center))\n\n            for i, pt_0 in enumerate(pts):\n                pt_1 = pts[(i + 1) % len(pts)]\n                pt_2 = pts[(i + 2) % len(pts)]\n\n                if (pt_1 - pt_0).Z > 0:  # type: ignore\n                    pt_0, pt_1, pt_2 = pt_2, pt_1, pt_0\n                tri_modules.append(TriModule(pt_0, pt_1, pt_2))\n\n        return TriFacade(tri_modules)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}