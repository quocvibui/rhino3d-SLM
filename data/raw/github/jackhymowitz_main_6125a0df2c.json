{
  "source_url": "https://github.com/jackhymowitz/main/blob/7325131db23094f1a28bd184b6a68f864f41a729/01_GH_Components/py/BT_2PDF_BuildTable.py",
  "repo": "jackhymowitz/main",
  "repo_stars": 0,
  "repo_description": "IDF2PH is a free open source toolkit for working with E+ and PHPP Energy Models",
  "license": "GPL-3.0",
  "filepath": "01_GH_Components/py/BT_2PDF_BuildTable.py",
  "instruction": "Ref: https://developer.rhino3d.com/samples/rhinocommon/overlay-text-display-conduit/\r\r\n-\r\r\nEM Mar. 7, 2020\r\r\n    Args:\r\r\n        _header: (List) The names for the Header (first) row. The length of...",
  "code": "#\r\r\n# IDF2PHPP: A Plugin for exporting an EnergyPlus IDF file to the Passive House Planning Package (PHPP). Created by blgdtyp, llc\r\r\n# \r\r\n# This component is part of IDF2PHPP.\r\r\n# \r\r\n# Copyright (c) 2020, bldgtyp, llc <info@bldgtyp.com> \r\r\n# IDF2PHPP is free software; you can redistribute it and/or modify \r\r\n# it under the terms of the GNU General Public License as published \r\r\n# by the Free Software Foundation; either version 3 of the License, \r\r\n# or (at your option) any later version. \r\r\n# \r\r\n# IDF2PHPP is distributed in the hope that it will be useful,\r\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \r\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \r\r\n# GNU General Public License for more details.\r\r\n# \r\r\n# For a copy of the GNU General Public License\r\r\n# see <http://www.gnu.org/licenses/>.\r\r\n# \r\r\n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\r\r\n#\r\r\n\"\"\"\r\r\nRef: https://developer.rhino3d.com/samples/rhinocommon/overlay-text-display-conduit/\r\r\n-\r\r\nEM Mar. 7, 2020\r\r\n    Args:\r\r\n        _header: (List) The names for the Header (first) row. The length of this input list should correspond to the length of each branch in '_rows'\r\r\n        _rows: (Tree) The data to plot. Each Branch on the input tree will correspond to one row in the final table\r\r\n        preview_: (Int) Input an Integer value corresponding to the BranchNumber of the zone you'd like to preview in the _rows DataTree input. If none input will not preview. Note - probably want to turn this off for any printing.  \r\r\n        tableOrigin_: (Point3d) <Optional> A starting point for the table (upper left corner). If no input uses 0,0,0\r\r\n        rowHeight_: (Float) If printing to a page (8.5x11, 11x17, etc..) try ~5.0 (typical range from 1.0<-->5.0)\r\r\n        columnWidths_: (Float) A value for the Column widths. Try ~15<-->20\r\r\n        txtHeight_: (Float) If printing to a page (8.5x11, 11x17, etc..) try ~2.0 (typical range from 1.0<-->5.0)\r\r\n    Returns:\r\r\n        tables: A tree of the output tables, one table per Branch. Input this into the '_tablesToBake' input on a '2PDF | Print' component to print this to a PDF.\r\r\n\"\"\"\r\r\n\r\r\nghenv.Component.Name = \"BT_2PDF_BuildTable\"\r\r\nghenv.Component.NickName = \"2PDF | Make Table\"\r\r\nghenv.Component.Message = 'MAR_07_2020'\r\r\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\r\r\nghenv.Component.Category = \"BT\"\r\r\nghenv.Component.SubCategory = \"03 | PDF\"\r\r\n\r\r\nimport Rhino\r\r\nimport ghpythonlib.components as ghc\r\r\nimport rhinoscriptsyntax as rs\r\r\nimport scriptcontext as sc\r\r\nfrom contextlib import contextmanager\r\r\nfrom System import Object\r\r\nimport System.Drawing\r\r\nimport Grasshopper.Kernel as ghK\r\r\nfrom Grasshopper import DataTree\r\r\nfrom Grasshopper.Kernel.Data import GH_Path\r\r\n\r\r\n@contextmanager\r\r\ndef docContext():\r\r\n    try:\r\r\n        sc.doc = Rhino.RhinoDoc.ActiveDoc\r\r\n        yield\r\r\n    finally:\r\r\n        sc.doc = ghdoc\r\r\n\r\r\nclass CustomConduit(Rhino.Display.DisplayConduit):\r\r\n    def DrawForeground(self, e):\r\r\n        color = System.Drawing.Color.Blue\r\r\n        numCol = 'B' # Exclude the 'Room Num' column (B)\r\r\n        \r\r\n        for key in self.Cells.keys():\r\r\n            if numCol in key:\r\r\n                txtStr = str(self.Cells[key].Value) \r\r\n            else:\r\r\n                try:\r\r\n                    val = float(self.Cells[key].Value)\r\r\n                    txtStr = '{:.2f}'.format(val)\r\r\n                except:\r\r\n                    txtStr = str(self.Cells[key].Value)\r\r\n                \r\r\n            Text3dEntity = Rhino.Display.Text3d( txtStr )\r\r\n            Text3d_Origin = self.Cells[key].Location\r\r\n            Text3d_Normal = Rhino.Geometry.Vector3d(0,0,1)\r\r\n            Text3dEntity.TextPlane = Rhino.Geometry.Plane(origin=Text3d_Origin, normal=Text3d_Normal)\r\r\n            Text3dEntity.Height = self.Cells[key].TextHeight\r\r\n            align = Rhino.DocObjects.TextHorizontalAlignment()\r\r\n            Rhino.DocObjects.TextHorizontalAlignment.value__.SetValue(align, 1) #1=Center\r\r\n            Text3dEntity.HorizontalAlignment = align\r\r\n            \r\r\n            e.Display.Draw3dText(Text3dEntity, color)\r\r\n            #e.Display.Draw2dText(str(self.Cells[key].Value), color, self.Cells[key].Location, False)\r\r\n\r\r\ndef showafterscript(_cells, _preview):\r\r\n    newConduit = None\r\r\n    newConduit = CustomConduit()\r\r\n    newConduit.Cells = _cells\r\r\n    \r\r\n    if not _preview:\r\r\n        if sc.sticky.has_key('myconduit'):\r\r\n            oldConduit = sc.sticky['myconduit']\r\r\n            oldConduit.Enabled = False\r\r\n            newConduit.Enabled = False\r\r\n    else:\r\r\n        if sc.sticky.has_key('myconduit'):\r\r\n            oldConduit = sc.sticky['myconduit']\r\r\n            oldConduit.Enabled = False\r\r\n            newConduit.Enabled = True\r\r\n            sc.sticky['myconduit'] = newConduit\r\r\n        else:\r\r\n            newConduit.Enabled = True\r\r\n            sc.sticky['myconduit'] = newConduit\r\r\n    \r\r\n    if newConduit.Enabled: print('Conduit Enabled!')\r\r\n    else: print('Conduit Disabled!')\r\r\n    \r\r\n    sc.doc.Views.Redraw()\r\r\n\r\r\nclass Table_Cell:\r\r\n    \r\r\n    def __init__(self, _range, _value=None, _txtHeight=1):\r\r\n        self.Range = _range\r\r\n        self.Column = self.Range[0]\r\r\n        self.ColumnAsInt = ord(self.Column)-65\r\r\n        self.Row = self.Range[1:]\r\r\n        self.Value = _value\r\r\n        self.Location = Rhino.Geometry.Point3d(0,0,0)\r\r\n        self.TextHeight = _txtHeight\r\r\n        self.valueFormat()\r\r\n        \r\r\n    def valueFormat(self):\r\r\n        \"\"\"Sets the cell's 'ValueFormated' parameter\"\"\"\r\r\n        \r\r\n        try:\r\r\n            float(self.Value)\r\r\n            self.ValueFormated = '{:.02f}'.format(self.Value)\r\r\n        except:\r\r\n            self.ValueFormated = self.Value\r\r\n    \r\r\n    def __repr__(self):\r\r\n        return '{}: {}'.format(self.Range, self.Value)\r\r\n\r\r\nclass Table:\r\r\n    \r\r\n    def __init__(self):\r\r\n        self.Name = None\r\r\n        self.Origin = None\r\r\n        self.Cells = {}\r\r\n        self.ColumnWidths = {}\r\r\n        self.RowSpacing = 1\r\r\n        self.TextHeight = 1\r\r\n    \r\r\n    def addCell(self, _key, _cell):\r\r\n        self.Cells[_key] = _cell\r\r\n        self.ColumnWidths[_key[0]] = 1 # Default\r\r\n        \r\r\n    def __repr__(self):\r\r\n        txt = 'Data Table [{}]: \\n'.format(self.Name)\r\r\n        for key in sorted(self.Cells.keys()):\r\r\n            txt = txt + '{} \\n'.format( self.Cells[key])\r\r\n        return txt\r\r\n    \r\r\n    def sortToColumns(self):\r\r\n        \"\"\"Sorts the Table's cells to columns based on Alpha char\r\r\n        \r\r\n        something, something. Don't really remember now.\r\r\n        \"\"\"\r\r\n        newDict = {}\r\r\n        \r\r\n        for key in sorted(self.Cells.keys()):\r\r\n            col = key[0]\r\r\n            \r\r\n            if col in newDict.keys():\r\r\n                newDict[col].append(self.Cells[key])\r\r\n            else:\r\r\n                newDict[col] = [self.Cells[key]]\r\r\n        \r\r\n        return newDict\r\r\n    \r\r\n    def locateCells(self, _colWidths, _default=10):\r\r\n        \"\"\"Set the self.Locate of each Cell Object in the Table\r\r\n        \r\r\n        Sets the right location for each cell in the table based on the\r\r\n        input values of 'columnWidths_' and 'rowHeight_'. Will go through\r\r\n        and change the 'Location' parameter for each Cell object found\r\r\n        \"\"\"\r\r\n        \r\r\n        self.udColWidths = { chr(k+65):v for k,v in enumerate(_colWidths) } #+65 to get to Capital Alphas\r\r\n        \r\r\n        for keyCount, key in enumerate(sorted(self.ColumnWidths.keys())):\r\r\n            width = self.udColWidths.get(key, self.udColWidths.get('A', _default))\r\r\n            self.ColumnWidths[key] = float(width)\r\r\n        \r\r\n        # Set the Cell Centers Based on the Column Widths\r\r\n        if not self.Origin:\r\r\n            self.Origin = Rhino.Geometry.Point3d(0,0,0)\r\r\n        \r\r\n        data = self.sortToColumns()\r\r\n        colXPos = 0 + self.Origin.X\r\r\n        for col in sorted(data.keys()):\r\r\n            colYPos = 0 + self.Origin.Y\r\r\n            for cell in data[col]:\r\r\n                cell.Location = Rhino.Geometry.Point3d(colXPos,colYPos,0)\r\r\n                colYPos = colYPos - self.RowSpacing\r\r\n            colXPos = colXPos + self.ColumnWidths[col]\r\r\n    \r\r\n    def getHeaders(self):\r\r\n        \"\"\"Finds all the unique Header values in the Table\r\r\n        \r\r\n        Sets the self.Headers of the Instance. Looks for any Column with a '01'\r\r\n        as the last values in the Column string, uses those as the headers\r\r\n        (assumes this first line is the header line)\r\r\n        \"\"\"\r\r\n        \r\r\n        self.Headers = {}\r\r\n        for key in self.Cells.keys():\r\r\n            if '01' in key:\r\r\n                self.Headers[key] = self.Cells[key].Value\r\r\n    \r\r\n    def findUniqueZoneNames(self):\r\r\n        \"\"\"Finds all the unique Zone values in the Table\r\r\n        \r\r\n        Sets the Object Instance 'ZoneList' param as a list of all the unique\r\r\n        Zone names found in the cells. Looks for any 'Zone' header and uses\r\r\n        that column's values to evaluate\r\r\n        \"\"\"\r\r\n        \r\r\n        # Find the Zone index of the passed in headers, if there is one\r\r\n        self.getHeaders()\r\r\n        for key, val in self.Headers.items():\r\r\n            if 'ZONE' in val.upper():\r\r\n                zoneIndex = ord(key[0])-65\r\r\n            else:\r\r\n                zoneIndex = 0\r\r\n        \r\r\n        # Find all the Unique zones passed in\r\r\n        uniqueZones = []\r\r\n        for key in sorted(myTable.Cells.keys()):\r\r\n            if '01' not in key: # Don't include the header row\r\r\n                if key[0] == chr(zoneIndex+65):\r\r\n                    uniqueZones.append(myTable.Cells[key].Value)\r\r\n        \r\r\n        self.ZoneList = sorted(set(uniqueZones))\r\r\n        return self.ZoneList\r\r\n    \r\r\n    def getCellsByZone(self):\r\r\n        \"\"\"Split the table by Zone name\r\r\n        \r\r\n        Splits an existing table based on the unique Zones found\r\r\n        Note will not adjust the cell locations though.... grr.....\r\r\n        So not that usefull.....\r\r\n        \"\"\"\r\r\n        \r\r\n        cellsByZone = DataTree[Object]()\r\r\n        self.findUniqueZoneNames()\r\r\n        \r\r\n        for zoneCount, zone in enumerate(self.ZoneList):\r\r\n            for zoneKey in sorted(self.Cells.keys()):\r\r\n                if zone in str(self.Cells[zoneKey].Value):\r\r\n                    # Found the Row's number. Now pull all the cells for that row\r\r\n                    row = []\r\r\n                    for key in sorted(self.Cells.keys()):\r\r\n                        if zoneKey[1:] == self.Cells[key].Row:\r\r\n                            row.append( self.Cells[key] )\r\r\n                    cellsByZone.Add(row, GH_Path(zoneCount))\r\r\n        \r\r\n        return cellsByZone\r\r\n\r\r\ndef validateInputs(_header, _rows, _columnWidths, _rowHeight, _txtHeight):\r\r\n    _rowHeight = _rowHeight if _rowHeight else 5\r\r\n    _txtHeight = _txtHeight if _txtHeight else 2\r\r\n    \r\r\n    dataMatchError = False\r\r\n    if _header and _rows.BranchCount > 0:\r\r\n        # Check data and header lengths....\r\r\n        for branchCount, branch in enumerate(_rows.Branches):\r\r\n            if len(branch) == len(_header):\r\r\n                pass\r\r\n            else:\r\r\n                dataMatchError = True\r\r\n                warning = \"The length of the '_header' input doesn't match the length of the data in branch numer: {}\".format(branchCount)\r\r\n                ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\r\r\n                break\r\r\n        \r\r\n        # Check columnWidths_ inputs....\r\r\n        if len(_columnWidths) == 0:\r\r\n            _columnWidths =  [20] * len(_header)\r\r\n        elif len(_columnWidths) > 0 and  len(_columnWidths) != len(_header):\r\r\n            _columnWidths =  [_columnWidths[0]] * len(_header)\r\r\n    \r\r\n    return dataMatchError, _columnWidths, _rowHeight, _txtHeight\r\r\n\r\r\ndataMatchError, columnWidths_, rowHeight_, txtHeight_ = validateInputs(_header, _rows, columnWidths_, rowHeight_, txtHeight_)\r\r\ntables = DataTree[Object]()\r\r\n\r\r\nif _rows.BranchCount > 0 and not dataMatchError:\r\r\n    # Get all the unique Zone Names\r\r\n    # Item row[0] is used assuming the first item is always the zone name?\r\r\n    zoneNames = sorted(set([row[0] for row in _rows.Branches]))\r\r\n    \r\r\n    # Create the Zone Data Tables and add to output Tree\r\r\n    for zoneNum, zoneName in enumerate(zoneNames):\r\r\n        # Get the this Zone's data as a List of lists\r\r\n        zoneData = [row for row in _rows.Branches if row[0] == zoneName]\r\r\n        \r\r\n        # Build a table from the Zone Data\r\r\n        myTable = Table()\r\r\n        myTable.Name = zoneName\r\r\n        myTable.Origin = rs.coerce3dpoint(tableOrigin_) if rs.coerce3dpoint(tableOrigin_) else None\r\r\n        myTable.RowSpacing = rowHeight_\r\r\n        myTable.TextHeight = txtHeight_\r\r\n        \r\r\n        for columnCount, header in enumerate(_header):\r\r\n            # Get the Headers, add to the table\r\r\n            try: headerTxt = header\r\r\n            except: headerTxt = 'Missing'\r\r\n            range = '{}{:02d}'.format(chr(columnCount+65), 1)\r\r\n            myTable.addCell(range, Table_Cell(range, headerTxt, myTable.TextHeight))\r\r\n            \r\r\n            # Get the Table Data, add to the table\r\r\n            for rowCount, rowData in enumerate(zoneData):\r\r\n                if len(rowData) != 0:\r\r\n                    range = '{}{:02d}'.format(chr(columnCount+65), rowCount+2) # data row\r\r\n                    myTable.addCell(range, Table_Cell(range, rowData[columnCount], myTable.TextHeight))\r\r\n            myTable.locateCells(columnWidths_)\r\r\n            \r\r\n        tables.Add(myTable, GH_Path(zoneNum))\r\r\n\r\r\n# Table Preview\r\r\nif preview_ !=None and _rows.BranchCount > 0 and header:\r\r\n    showPreview = True\r\r\n    previewTable = tables.Branch(int(preview_))[0].Cells\r\r\nelse:\r\r\n    showPreview = False\r\r\n    previewTable = None\r\r\nshowafterscript(previewTable, showPreview)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}