{
  "source_url": "https://github.com/6849-2020/Kirigami-Folded-Core/blob/ea2d07a5df611f12bd7d5ab1d1ae1e18a7dd662b/StableV3.py",
  "repo": "6849-2020/Kirigami-Folded-Core",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "StableV3.py",
  "instruction": "Stable v3",
  "code": "import rhinoscriptsyntax as rs\nimport math\n\n'''\nThis tool generates a Kirigami modified Miura inspired core with some new features that provides more materiability.\nThe development of this tool as a detailed strategy explanation lives here:\n\nhttps://alfonso.pages.cba.mit.edu/geometric-folding-algorithms/index.html\n\nThe tool will ask the user to select an upper surface, a lower surface, a starting point and the number of voxels to\nfill.\n\nIt will evaluate locally the upper surface step by step, decide if it is a positive slope or a negative slope and\naccording to that it will generate the cell. At the same time, every time the cell has been finished, it will read it\nand will generate the unfolded drawing.\n\nAny question related to the project contact me at aprubio [at] mit [dot] edu\n\n'''\n\n# Parameters\n\npitch = 75 #(mm)\nrivet_distance = 14.3\nrivet_diameter = 2.5\n#Maybe use this guy as an imput?\nitems = 5 # numbers of voxels in a row\nangle = 70 #degrees\ncenterwidth = 6\nouterwidth = 14\n#Functions\n\ndef slope(line, upper):\n    '''\n\n    Given the base line and the top line, this function returns True if is positive and False if is negative.\n\n    '''\n    points =  rs.DivideCurve(line, 4)\n    intersections = []\n    lengths = []\n\n    for point in points:\n        locline = rs.AddLine(point, (point[0], point[1], 100000))\n        intersection = rs.CurveCurveIntersection(locline, upper, tolerance=-1)\n        lengths.append(rs.Distance(point,(intersection[0][1])))\n    #print(lengths)\n\n    if lengths[1]<lengths[3]:  # Defining if the slope is positive or negative. It will return True if its positive and False if its negative\n        return True\n    else:\n        return False\n\n\ndef baselines(cell_range):\n\n    point1,point2, point3, point4\n\n\ndef corrugate_lines(base, upper, angle, outerwidth, centerwidth):\n    '''\n\n    :return:\n    '''\n    angle = math.radians(angle)\n    upper_copy = rs.CopyObject(upper, translation=(0,pitch/2,0))\n    slope_value = slope(base, upper_curve)\n    lx0, ly0, lz0 =  rs.CurveStartPoint(base)\n\n\n    p0 = rs.AddPoint((lx0 + pitch/2, ly0 , lz0))\n\n\n    p0 = (rs.PointCoordinates(p0))\n    p1 = [p0[0] + rivet_distance, p0[1], p0[2]]\n    p2 = [p0[0] + pitch - rivet_distance, p0[1], p0[2]]\n    p3 = [p0[0] + pitch, p0[1], p0[2]]\n\n    p0s = [p0[0] - pitch / 2, p0[1] + pitch/2, p0[2]]\n    p1s = [p1[0] - pitch / 2, p1[1] + pitch / 2, p1[2]]\n    p2s = [p2[0] - pitch / 2, p2[1] + pitch / 2, p2[2]]\n    p3s = [p3[0] - pitch / 2, p3[1] + pitch / 2, p3[2]]\n\n\n\n    if slope_value == True :\n        a = rs.AddLine(p0, p1)\n        b = rs.AddLine(p1, (p1[0]+400*math.cos(angle), p1[1], p1[2]+400*math.sin(angle)))\n        d = rs.AddLine(p2, (p2[0] - 400 * math.cos(angle), p2[1], p2[2] + 400 * math.sin(angle)))\n        c = rs.AddLine((rs.CurveCurveIntersection(b,upper)[0][1]), (rs.CurveCurveIntersection(d,upper)[0][1]))\n        e = rs.AddLine(p2,p3)\n\n        b = rs.AddLine(p1, rs.CurveCurveIntersection(b , upper)[0][1])\n        d = rs.AddLine(rs.CurveCurveIntersection(d ,upper)[0][1] , p2)\n\n        f = rs.AddLine(p0s, p1s)\n        g = rs.AddLine(p1s, (p1s[0]+400*math.cos(angle), p1s[1], p1s[2]+400*math.sin(angle)))\n        i = rs.AddLine(p2s, (p2s[0] - 400 * math.cos(angle), p2s[1], p2s[2] + 400 * math.sin(angle)))\n        h = rs.AddLine((rs.CurveCurveIntersection(g,upper_copy)[0][1]), (rs.CurveCurveIntersection(i,upper_copy)[0][1]))\n        j = rs.AddLine(p2s,p3s)\n\n        g = rs.AddLine(p1s, rs.CurveCurveIntersection(g , upper_copy)[0][1])\n        i = rs.AddLine(rs.CurveCurveIntersection(i ,upper_copy)[0][1] , p2s)\n\n        domain = rs.CurveDomain(h)\n        parameter = domain[1] / 2.0\n        h1, h2 = rs.SplitCurve(h, parameter)\n\n        pathsim =(rs.AddLine(p0s, (p0s[0],p0s[1]- centerwidth, p0s[2] )))\n        pathout =(rs.AddLine(p0s, (p0s[0],p0s[1] + outerwidth, p0s[2] )))\n\n        A = rs.ExtrudeCurve(a, pathout)\n        B = rs.ExtrudeCurve(b, pathout)\n        C = rs.ExtrudeCurve(c, pathout)\n        D = rs.ExtrudeCurve(d, pathout)\n        E = rs.ExtrudeCurve(e, pathout)\n        F = rs.ExtrudeCurve(f, pathsim)\n        G = rs.ExtrudeCurve(g, pathsim)\n        H1 = rs.ExtrudeCurve(h1, pathsim)\n        H2 = rs.ExtrudeCurve(h2, pathsim)\n        I = rs.ExtrudeCurve(i, pathsim)\n        J = rs.ExtrudeCurve(j, pathsim)\n        \n\n\n\n\n\n\n\n\n\n\n\n    return None\n\n\n\n\n\n\n\n\n\n\n\n# Reading Curves and Origin.\n\nupper_curve = rs.GetObject(\"Click Upper Line\")\norigin = rs.GetObject(\"Select Origin\")\norx, ory, orz = rs.PointCoordinates(origin)\n\n\n\n\n\n#Drawing the pitch cells lines\ncells_range = []\n\nfor i in range(items):\n    line = rs.AddLine((orx + i*1.5 *pitch, ory, orz), (orx +i* 1.5 *pitch + 1.5* pitch, ory, orz ))\n    cells_range.append(line)\n\n\n\n\n\n\n\n\n\n\n\ncorrugate_lines(cells_range[0], upper_curve, angle, outerwidth, centerwidth)",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}