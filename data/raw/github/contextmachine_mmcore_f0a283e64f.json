{
  "source_url": "https://github.com/contextmachine/mmcore/blob/4b576006c47d569253e2f11fc5c107d390e9ba0f/examples/toys/skeleton_drawings/skeleton_drawings.py",
  "repo": "contextmachine/mmcore",
  "repo_stars": 8,
  "repo_description": "The modern CAD engine",
  "license": "Apache-2.0",
  "filepath": "examples/toys/skeleton_drawings/skeleton_drawings.py",
  "instruction": "Skeleton drawings",
  "code": "\nimport sys\n\nimport numpy as np\n\ntry:\n    from google.colab.patches import cv2_imshow\nexcept ModuleNotFoundError as err:\n    pass  # We do not in colab\nexcept ImportError as err:\n    pass  # We do not in colab\n\n# @title Check trace_skeleton {\"run\":\"auto\",\"vertical-output\":true,\"display-mode\":\"form\"}\n\n\"\"\"## Start coding here\"\"\"\n\nimport trace_skeleton\nimport sys\nfrom pathlib import Path\nimport rhino3dm as rg\n\nsys.path.extend([Path(__file__).parent.__str__()])\n\n\ndef next_name(name, i=0):\n    \"\"\"\n    Changes name to name-i if name already exists in the directory.For example:\n    If untitled.txt exists, returns untitled-1.txt\n    If untitled-1.txt also exists, returns untitled-2.txt.\n    and so on ad infinitum\n    \"\"\"\n    name_path = Path(name)\n    if i == 0:\n        pth = (name_path.parent / f'{name_path.stem}{\"\".join(name_path.suffixes)}').resolve()\n    else:\n        pth = (name_path.parent / f'{name_path.stem}-{i}{\"\".join(name_path.suffixes)}').resolve()\n    if pth.exists():\n        return next_name(name, i + 1)\n    return pth.__str__()\n\n\nfrom mmcore.geom.nurbs import NURBSCurve, greville_abscissae\nfrom mmcore.numeric import evaluate_curvature\nfrom mmcore.numeric.vectors import norm  # High performance vectorized norm\n\n\ndef pts_curves(pts):\n    if len(pts) == 1:\n        pts = pts[0]\n\n    if isinstance(pts, (tuple, list)) and isinstance(pts[0], (float, int)):\n        return pts\n\n    elif isinstance(pts, (tuple, list)):\n\n        lst = [pts_curves(pt) for pt in pts]\n\n        if len(lst) == 1:\n            return lst\n\n        if isinstance(lst[0], (tuple, list, np.ndarray)) and len(lst[0]) == 2 and isinstance(lst[0][0], (int, float)):\n\n            degree = max(min(len(lst) - 1, 3), 1)\n\n            crv = NURBSCurve(np.array([(*pts, 0.) for pts in lst], dtype=float), degree)\n\n            return crv\n\n        else:\n\n            return lst\n    else:\n        raise ValueError(f'Unknown {pts}')\n\n\ndef curvature_vector(crv, t):\n    return evaluate_curvature(crv.derivative(t), crv.second_derivative(t))[1]\n\n\ndef curvature(curvature_vector):\n    return np.linalg.norm(curvature_vector)\n\n\ndef reduce_control_points(curve, threshold=0.1):\n    \"\"\"\n        :param curve: Curve\n        :param threshold:maximum curvature value at which the curve will be approximated into a straight line\n        Experiment with this parameter to find the best option for your case\n     \"\"\"\n    params = np.array(greville_abscissae(curve.knots, curve.degree))\n    curvature_in_params = np.array(norm(\n        np.array([evaluate_curvature(curve.derivative(param), curve.second_derivative(param))[1] for param in params])))\n    mask = ~(curvature_in_params < threshold)\n    mask[0] = True\n    mask[-1] = True\n    reduced_cpts = curve.control_points[mask]\n    pts, indices = list(zip(*sorted(zip(*np.unique(reduced_cpts, axis=0, return_index=True)), key=lambda x: x[1])))\n    return np.array(pts)\n\n\ndef reduce_nurbs_curve(curve, threshold=0.1):\n    \"\"\"\n    :param curve: Curve\n    :param threshold:maximum curvature value at which the curve will be approximated into a straight line\n    Experiment with this parameter to find the best option for your case\n    \"\"\"\n    cpts = reduce_control_points(curve, threshold)\n    degree = max(min(len(cpts) - 1, 3), 1)\n\n    return NURBSCurve(cpts, degree)\n\n\ndef mmcore_curve_to_rhino(curve: NURBSCurve) -> rg.NurbsCurve:\n    rcrv = rg.NurbsCurve.CreateControlPointCurve([rg.Point3d(*pt) for pt in curve.control_points\n                                                  ], degree=curve.degree).ToNurbsCurve()\n    for i in range(1, len(curve.knots) - 2):\n        rcrv.Knots[i - 1] = curve.knots[i]\n    if not rcrv.IsValid:\n        raise ValueError('Invalid Rhino Curve created.')\n    return rcrv\n\n\n\nimport cv2\n\npath = Path(__file__).parent / \"data/image-25.png\"\nim = cv2.imread(path.__str__(), 0)\nblurred = cv2.GaussianBlur(im, (3, 3), 0)\ndenoised = cv2.bilateralFilter(blurred, 3, 75, 75)\n_, im = cv2.threshold(denoised, 90, 255, cv2.THRESH_BINARY);\n\ncsizeCustom = 1\nmaxIterCustom = 75000\n\npolys = trace_skeleton.from_numpy(im, csize=csizeCustom, maxIter=maxIterCustom);\n\n# Creating NURBS Curves\ncurves = pts_curves(\n    polys\n)\n\nmodel = rg.File3dm()\n\nfor curve in curves:\n\n    cpts_count=len(curve.control_points)\n    # Reduce NURBS Curve control points\n    reduced_curve=reduce_nurbs_curve(curve)\n    print(f\"Reduce control points count from {cpts_count} to {len(reduced_curve.control_points)}\")\n\n    # Convert mmcore NURBSCurve to Rhino NurbsCurve\n    rhino_curve = mmcore_curve_to_rhino(reduced_curve)\n    # Add Rhino curve in 3dm\n    model.Objects.AddCurve(rhino_curve)\n\n# Write 3dm file\nnm = next_name(\"drawings.3dm\")\n\nmodel.Write(nm, version=7)\nprint(\"\\nSaved to:\",nm)\n\n# success, model, curves = write_rhino(polys)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}