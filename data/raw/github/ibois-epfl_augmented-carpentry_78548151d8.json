{
  "source_url": "https://github.com/ibois-epfl/augmented-carpentry/blob/414eeb93984fad40a4e57daa60e1bb268cbd406c/py/pypi/ACPy/main.py",
  "repo": "ibois-epfl/augmented-carpentry",
  "repo_stars": 15,
  "repo_description": "Main repository hosting the main AR software developed for Augmented Carpentry rersearch at Ibois, Epfl.",
  "license": "GPL-3.0",
  "filepath": "py/pypi/ACPy/main.py",
  "instruction": null,
  "code": "#! python2\n\nimport Rhino as rc\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport datetime as dt\nimport math\n\nimport log\nimport acim\nimport hole\nimport cut\nimport util\n\nimport visual_debug as vd\n\ndef get_lowest_brep_vertex(brep):\n    \"\"\" Get the the vertex with the lowest y,x and z values \"\"\"\n    biggest_vertices = brep.Vertices\n    lowest_x = 0\n    lowest_y = 0\n    lowest_z = 0\n    for vertex in biggest_vertices:\n        if vertex.Location.X < lowest_x:\n            lowest_x = vertex.Location.X\n        if vertex.Location.Y < lowest_y:\n            lowest_y = vertex.Location.Y\n        if vertex.Location.Z < lowest_z:\n            lowest_z = vertex.Location.Z\n    return rc.Geometry.Point3d(lowest_x, lowest_y, lowest_z)\n\ndef pln_2_pln_world_transform(brep):\n    \"\"\" Transform a brep to the world plane \"\"\"\n    log.info(\"Computing Oriented Bounding Boxes...\")\n\n    # find the longest edge of the brep\n    edges = brep.Edges\n    longest_edge = None\n    longest_edge_length = 0\n    for edge in edges:\n        if edge.GetLength() > longest_edge_length:\n            longest_edge_length = edge.GetLength()\n            longest_edge = edge\n\n    # find biggest face\n    face_indices = longest_edge.AdjacentFaces()\n    faces = [brep.Faces[face_index] for face_index in face_indices]\n    biggest_face = None\n    biggest_face_area = 0\n    for face in faces:\n        if rg.AreaMassProperties.Compute(face).Area > biggest_face_area:\n            biggest_face_area = rg.AreaMassProperties.Compute(face).Area\n            biggest_face = face\n    \n    # get the plane of the biggest face\n    if biggest_face.TryGetPlane()[0] is False:\n        log.error(\"Could not find plane for longest edge. Exiting...\")\n        return\n    plane_src = biggest_face.TryGetPlane()[1]\n    plane_tgt = rc.Geometry.Plane.WorldXY\n    log.info(\"Found plane for longest edge: \" + str(plane_src))\n\n    # plane to plane transformation\n    plane_to_world = rc.Geometry.Transform.PlaneToPlane(plane_src, plane_tgt)\n    brep.Transform(plane_to_world)\n\n    # adjust to x,y,z positive\n    lowest_vertex = get_lowest_brep_vertex(brep)\n    lowest_vertex_transform = rc.Geometry.Transform.Translation(rg.Vector3d(-lowest_vertex))\n    brep.Transform(lowest_vertex_transform)\n\n    bbox = brep.GetBoundingBox(True)\n    bbox_corners = bbox.GetCorners()\n    y_val_sum = 0\n    x_val_sum = 0\n    for corner in bbox_corners:\n        y_val_sum += corner.Y\n        x_val_sum += corner.X\n\n    if x_val_sum > y_val_sum:\n        log.info(\"Bounding box is alligned to x axis. No rotation needed.\")\n    else:\n        log.info(\"Bounding box is not alligned to y axis. A 90 deg rotation is needed.\")\n        rot_90_z = rc.Geometry.Transform.Rotation(math.radians(90), rg.Vector3d.ZAxis, rg.Point3d.Origin)\n        brep.Transform(rot_90_z)\n        lowest_vertex = get_lowest_brep_vertex(brep)\n\n        lowest_vertex_transform = rc.Geometry.Transform.Translation(rg.Vector3d(-lowest_vertex))\n        brep.Transform(lowest_vertex_transform)\n\n    vd.addBrep(brep, clr=(255, 0, 0, 30))\n\ndef distinguish_holes_cuts(breps):\n    \"\"\" \n        Analyse the result breps from the boolean difference operation\n        and distinguish between holes and cuts\n    \"\"\"\n    is_hole = False\n    is_cut = False\n    is_mix = False\n    holes_b = []\n    cuts_b = []\n    mix_b = []\n\n    # parse holes, cuts and mix\n    for b in breps:\n        is_cut = True\n        for f in b.Faces:\n            f_brep = f.ToBrep()\n            f = f_brep.Faces[0]\n            if not f.IsPlanar():\n                is_cut = False\n                is_hole = True\n                b_faces = util.explode_brep(b)\n                for b_face in b_faces:\n                    if b_face.Faces[0].IsPlanar():\n                        b_face_edges = b_face.Edges\n                        for b_face_edge in b_face_edges:\n                            if not b_face_edge.IsClosed:\n                                is_mix = True\n                                is_hole = False\n                                break\n                        if is_mix:\n                            break\n                break\n\n        if is_hole:\n            holes_b.append(b)\n        elif is_cut: \n            cuts_b.append(b)\n        elif is_mix:\n            mix_b.append(b)\n\n        is_hole = False\n        is_cut = False\n        is_mix = False\n    \n    # deal with mix\n    candidate_cuts = []\n    candidate_holes = []\n    for b in mix_b:\n        # -- algorithm draft --\n        # (1) explode\n        # (2) seperate in tow list flat surfaces (cuts + cylinder's bases) and non flat surfaces (cylinders)\n        # (3) cap each object in both lists\n        # (4) boolunion every object in both lists\n        # (5) check if closed, if it is \n        # ----------------------\n        # (1) explode\n        faces_b = util.explode_brep(b)\n\n        # (2) seperate in tow list flat surfaces (cuts + cylinder's bases) and non flat surfaces (cylinders)\n        flat_faces_b = []\n        non_flat_faces_b = []\n        for f_b in faces_b:\n            if f_b.Faces[0].IsPlanar():\n                flat_faces_b.append(f_b)\n            else:\n                non_flat_faces_b.append(f_b)\n  \n        # (*) cap the cylinders\n        non_flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in non_flat_faces_b]\n        \n        # (4) boolunion every object in both lists\n        flat_faces_b = rc.Geometry.Brep.CreateBooleanUnion(flat_faces_b, sc.doc.ModelAbsoluteTolerance)\n        non_flat_faces_b = rc.Geometry.Brep.CreateBooleanUnion(non_flat_faces_b, sc.doc.ModelAbsoluteTolerance)\n\n        # (3) cap candidate cuts\n        flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in flat_faces_b]\n        # non_flat_faces_b = [f_b.CapPlanarHoles(sc.doc.ModelAbsoluteTolerance) for f_b in non_flat_faces_b]\n\n        # (*) merge all coplanar faces in breps cut candidates\n        for f_b in flat_faces_b:\n            if f_b is not None:\n                f_b.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance)\n\n        # (5) check if closed, if it is add to cuts, if not add to holes\n        for f_b in flat_faces_b:\n            if f_b is not None:\n                if f_b.IsSolid:\n                    cuts_b.append(f_b)\n        for f_b in non_flat_faces_b:\n            if f_b is not None:\n                if f_b.IsSolid:\n                    holes_b.append(f_b)\n\n    return holes_b, cuts_b\n\ndef main():\n\n    vd.set_on()\n    print(vd.__IS_VDEBUG__)\n\n    log.info(\".acim exporter started\")\n    rh_doc_path = rs.DocumentPath()\n    timestamp = dt.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    acim_path = rh_doc_path + timestamp\n    log.info(\"Creating ACIM file at: \" + acim_path)\n    ACIM = acim.ACIM(acim_path)\n\n    pieces = rs.GetObjects(\"Select pieces to be exported\", rs.filter.polysurface, preselect=True)\n    if not pieces:\n        log.error(\"No pieces selected. Exiting...\")\n        return\n    log.info(\"Selected \" + str(len(pieces)) + \" pieces.\")\n\n    for p_GUID in pieces:\n        log.info(\"Processing piece: \" + str(p_GUID))\n        ACIM.add_timber(str(p_GUID))\n        ACIM.add_timber_state(str(p_GUID), 0)\n        brep = rs.coercebrep(p_GUID)\n        \n        # transform to world plane\n        pln_2_pln_world_transform(brep)\n\n        # compute the bounding box\n        bbox = brep.GetBoundingBox(True)\n        bbox_b = bbox.ToBrep()\n        ACIM.add_bbox(str(p_GUID), bbox.GetCorners())\n\n        # boolean difference between the bounding box and the brep transformed\n        brep_result = rc.Geometry.Brep.CreateBooleanDifference(bbox_b, brep, sc.doc.ModelAbsoluteTolerance)\n        if brep_result is None or len(brep_result) == 0:\n            log.error(\"No breps found after boolean difference. Exiting...\")\n            return\n\n        # get holes and cuts breps\n        holes_b, cuts_b = distinguish_holes_cuts(brep_result)\n        log.info(\"Found:\\n\" \\\n            + \"\\t --holes: \" +  str(len(holes_b)) + \"\\n\" \\\n            + \"\\t --cuts: \" + str(len(cuts_b)) + \"\\n\")\n\n        ############################################################\n        # analyse and loading holes and cuts into .acim\n        if holes_b.__len__() != 0:\n            for hole_b in holes_b:\n                vd.addBrep(hole_b, clr=(255, 255, 0, 30))\n                log.info(\"Processing hole: \" + str(hole_b))\n                hole.parse_data_from_brep(ACIM, str(p_GUID), hole_b, bbox_b)\n\n        if cuts_b.__len__() != 0:\n            cut_counter = 1\n            for cut_b in cuts_b:\n                vd.addBrep(cut_b, clr=(255, 0, 255, 30))\n                log.info(\"Processing cut: \" + str(cut_b))\n                cut.parse_data_from_brep(ACIM, str(p_GUID), cut_b, bbox_b)\n\n                vd.addSingleDot(cut_b.GetBoundingBox(True).Center, str(cut_counter), (0,0,255))\n                cut_counter += 1\n\n        sc.doc.Views.Redraw()\n    ACIM.dump_data()\n\n\nif __name__ == '__main__':\n    main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}