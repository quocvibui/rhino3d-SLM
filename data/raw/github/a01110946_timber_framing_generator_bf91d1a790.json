{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_revit_assembly_creator.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_revit_assembly_creator.py",
  "instruction": "Revit Assembly Creator for Grasshopper.",
  "code": "# File: scripts/gh_revit_assembly_creator.py\n\"\"\"Revit Assembly Creator for Grasshopper.\n\nCreates Revit Assemblies from framing and sheathing elements grouped by panel_id.\nThis component sits at the end of the pipeline after the Revit Baker and RiR\nbaking components (Add Structural Column, Add Structural Framing). It correlates\nthe baking_data_json geometry_index mapping with actual Revit ElementIds and\ngroups them into Assemblies per panel or per wall.\n\nKey Features:\n1. Element Grouping by Panel\n   - Correlates baking_data_json geometry_index with Revit ElementIds\n   - Groups columns, beams, and sheathing by panel_id\n   - Falls back to one assembly per wall if panels_json is not provided\n\n2. Two-Transaction Assembly Creation\n   - Transaction 1: Create AssemblyInstance (commit immediately)\n   - Transaction 2: Rename type, fix orientation, create views (type only exists after T1 commit)\n   - Handles Revit API requirement for separate transactions\n\n3. Optional Assembly Views with Configurable Settings\n   - Creates 3D, front/top elevation, and material takeoff views per assembly\n   - Controlled by create_views toggle and optional view_config_json\n   - Configurable detail level (Coarse/Medium/Fine) and display style\n   - Material takeoff disabled by default (appears under Schedules, not Assembly node)\n\n4. Assembly Orientation Fix\n   - Rotates assembly transform so BasisX aligns with wall direction\n   - Ensures ElevationFront shows actual front view, not side view\n   - Automatically derived from baking data beam centerlines\n\n5. Structured JSON Output\n   - Reports assembly_id, status, element_count per panel\n   - Summary with total/successful/failed counts\n   - Full diagnostic info output\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Grasshopper: Component framework and runtime messages\n    - RhinoCommon: CLR reference for .NET interop\n    - RhinoInside.Revit: Revit document access (conditional)\n    - timber_framing_generator.assemblies.assembly_creator: Grouping and creation logic\n\nPerformance Considerations:\n    - Each assembly requires two Revit transactions (~0.5-1s per assembly)\n    - View creation adds ~1-2s per assembly (if enabled)\n    - For >20 panels, expect 30-60 seconds total execution time\n    - Run only when ready (use the run toggle)\n\nUsage:\n    1. Connect 'baking_data_json' from Revit Baker component\n    2. Connect 'column_ids' from RiR \"Add Structural Column\" output\n    3. Connect 'beam_ids' from RiR \"Add Structural Framing\" output\n    4. Optionally connect 'panels_json' for panel-level grouping\n    5. Connect 'framing_json' from Framing Generator for accurate panel grouping\n    6. Optionally connect 'sheathing_ids' and 'sheathing_data_json'\n    7. Set 'run' to True to create assemblies\n    8. Optionally connect 'view_config_json' to customize view settings\n    9. Check 'assembly_json' and 'info' for results\n\nInput Requirements:\n    Baking Data JSON (baking_data_json) - str:\n        JSON string from gh_revit_baker.py with geometry_index mapping\n        per member, organized by wall. Contains classification, centerline,\n        and geometry_index fields for each element.\n        Required: Yes\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Panels JSON (panels_json) - str:\n        JSON from panel decomposer with panel boundaries and element_ids.\n        If not provided, falls back to one assembly per wall.\n        Required: No\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Column IDs (column_ids) - list:\n        Revit ElementIds from RiR \"Add Structural Column\" output.\n        Must be in geometry_index order matching baking_data_json.\n        Required: Yes (at least column_ids or beam_ids must have elements)\n        Access: List\n        Type hint: No type hint (set via GH UI)\n\n    Beam IDs (beam_ids) - list:\n        Revit ElementIds from RiR \"Add Structural Framing\" output.\n        Must be in geometry_index order matching baking_data_json.\n        Required: Yes (at least column_ids or beam_ids must have elements)\n        Access: List\n        Type hint: No type hint (set via GH UI)\n\n    Sheathing IDs (sheathing_ids) - list:\n        Revit ElementIds from sheathing baking. Optional.\n        Required: No\n        Access: List\n        Type hint: No type hint (set via GH UI)\n\n    Sheathing Data JSON (sheathing_data_json) - str:\n        JSON mapping sheathing elements to panel_ids.\n        Required only if sheathing_ids is provided.\n        Required: No\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Naming Prefix (naming_prefix) - str:\n        Prefix for assembly names (e.g., \"W\" -> \"W1-P01\").\n        Required: No (defaults to \"W\")\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Create Views (create_views) - bool:\n        Whether to create 3D, section, and takeoff views per assembly.\n        Required: No (defaults to False)\n        Access: Item\n        Type hint: bool (set via GH UI)\n\n    View Config JSON (view_config_json) - str:\n        Optional JSON string configuring assembly views. Keys:\n        - include_3d (bool, default True)\n        - include_front_elevation (bool, default True)\n        - include_top_elevation (bool, default False)\n        - include_material_takeoff (bool, default False)\n        - detail_level (\"Coarse\"|\"Medium\"|\"Fine\", default \"Fine\")\n        - display_style (\"Wireframe\"|\"HiddenLine\"|\"Shaded\"|\"Realistic\", default \"HiddenLine\")\n        Omitted keys use defaults. Empty/missing uses all defaults.\n        Required: No\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Framing JSON (framing_json) - str:\n        JSON from Framing Generator (gh_framing_generator.py) with panel_id\n        on each element. When provided, enriches panels_json with element_ids\n        for accurate panel-level grouping. Without this, falls back to\n        geometry-based grouping which can misassign elements near panel\n        boundaries.\n        Required: No (but strongly recommended for panel-level assemblies)\n        Access: Item\n        Type hint: str (set via GH UI)\n\n    Run (run) - bool:\n        Boolean toggle to trigger execution. Assembly creation modifies\n        the Revit document, so this acts as a safety guard.\n        Required: Yes\n        Access: Item\n        Type hint: bool (set via GH UI)\n\nOutputs:\n    Assembly JSON (assembly_json) - str:\n        JSON with assembly results: per-panel assembly_id, status,\n        element_count, views_created. Also includes summary.\n\n    Assembly IDs (assembly_ids) - list of int:\n        List of created assembly ElementIds as integers.\n        Empty list if none created.\n\n    Info (info) - str:\n        Processing information with counts and per-assembly status.\n\nTechnical Details:\n    - Uses group_elements_by_panel() for pure-Python element correlation\n    - Uses create_assemblies() for Revit API calls (two-transaction pattern)\n    - AssemblyInstance.Create requires ICollection<ElementId> as .NET List, not Python list\n    - Assembly type is only assigned AFTER first transaction commits\n    - Reads inputs by parameter index (NickName injection is unreliable)\n    - Wall directions derived from baking_data via _derive_wall_axis() for orientation fix\n    - AssemblyViewConfig controls view types, detail level, and display style\n\nError Handling:\n    - Missing baking_data_json: returns empty outputs with warning\n    - No column_ids and no beam_ids: returns empty outputs with warning\n    - Revit unavailable: returns empty outputs with error\n    - Per-assembly failures: logged individually, batch continues\n    - All errors reported via dual logging (console + GH runtime messages)\n\nAuthor: Fernando Maytorena\nVersion: 1.3.0\n\"\"\"\n\nimport sys\nimport json\nimport traceback\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n# Clear cached modules to ensure fresh imports when script changes.\n# IMPORTANT: Must also clear 'src' package -- other GH components may have\n# loaded it from a different PROJECT_PATH, and its __path__ would point there.\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k or k == 'src']\nfor _mod in _modules_to_clear:\n    del sys.modules[_mod]\nprint(\"[RELOAD] Cleared %d cached modules\" % len(_modules_to_clear))\n\n# =============================================================================\n# .NET / CLR\n# =============================================================================\n\nimport clr\n\nclr.AddReference('RhinoCommon')\nclr.AddReference('Grasshopper')\n\n# Conditional RhinoInside.Revit import\nREVIT_AVAILABLE = False\nREVIT_DOC = None\n\ntry:\n    clr.AddReference('RhinoInside.Revit')\n    from RhinoInside.Revit import Revit\n    REVIT_DOC = Revit.ActiveDBDocument\n    if REVIT_DOC is not None:\n        REVIT_AVAILABLE = True\nexcept Exception as _revit_err:\n    print(\"[INFO] RhinoInside.Revit not available: %s\" % str(_revit_err))\n\n# =============================================================================\n# Rhino / Grasshopper\n# =============================================================================\n\nimport Grasshopper\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\nPROJECT_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\nif PROJECT_PATH not in sys.path:\n    sys.path.insert(0, PROJECT_PATH)\n\nfrom src.timber_framing_generator.assemblies.assembly_creator import (\n    enrich_panels_with_framing_data,\n    group_elements_by_panel,\n    create_assemblies,\n    _derive_wall_axis,\n)\nfrom src.timber_framing_generator.assemblies.assembly_views import (\n    AssemblyViewConfig,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Revit Assembly Creator\"\nCOMPONENT_NICKNAME = \"AssemCr\"\nCOMPONENT_MESSAGE = \"v1.3\"\nCOMPONENT_CATEGORY = \"TFG\"\nCOMPONENT_SUBCATEGORY = \"Revit\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message: str, level: str = \"info\") -> None:\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log (ASCII only -- no unicode)\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    print(\"[%s] %s\" % (level.upper(), message))\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message: str) -> None:\n    \"\"\"Log debug message (console only).\"\"\"\n    print(\"[DEBUG] %s\" % message)\n\n\ndef log_info(message: str) -> None:\n    \"\"\"Log info message (console only).\"\"\"\n    print(\"[INFO] %s\" % message)\n\n\ndef log_warning(message: str) -> None:\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message: str) -> None:\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component() -> None:\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Sets component metadata, input parameters, and output parameters.\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1].\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type.\n    Required type hints:\n        baking_data_json: str\n        panels_json: str\n        column_ids: No type hint (GH default)\n        beam_ids: No type hint (GH default)\n        sheathing_ids: No type hint (GH default)\n        sheathing_data_json: str\n        naming_prefix: str\n        create_views: bool\n        view_config_json: str\n        framing_json: str\n        run: bool\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: NickName becomes the Python variable name\n    # Format: (DisplayName, variable_name, Description, Access)\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        (\"Baking Data JSON\", \"baking_data_json\",\n         \"JSON from Revit Baker with geometry_index mapping\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Panels JSON\", \"panels_json\",\n         \"JSON from Panel Decomposer with panel boundaries (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Column IDs\", \"column_ids\",\n         \"Revit ElementIds from RiR Add Structural Column\",\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        (\"Beam IDs\", \"beam_ids\",\n         \"Revit ElementIds from RiR Add Structural Framing\",\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        (\"Sheathing IDs\", \"sheathing_ids\",\n         \"Revit ElementIds from sheathing baking (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.list),\n        (\"Sheathing Data JSON\", \"sheathing_data_json\",\n         \"JSON mapping sheathing elements to panels (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Naming Prefix\", \"naming_prefix\",\n         \"Prefix for assembly names, default 'W' (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Create Views\", \"create_views\",\n         \"Whether to create assembly views, default False (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"View Config JSON\", \"view_config_json\",\n         \"JSON configuring assembly views (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Framing JSON\", \"framing_json\",\n         \"JSON from Framing Generator with panel_id per element (optional, enables accurate panel grouping)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\",\n         \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        (\"Assembly JSON\", \"assembly_json\",\n         \"JSON with assembly results and summary\"),\n        (\"Assembly IDs\", \"assembly_ids\",\n         \"List of created assembly ElementIds as integers\"),\n        (\"Info\", \"info\",\n         \"Processing information\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef _get_first_branch(param):\n    \"\"\"Get the first branch of data from a GH parameter's VolatileData.\n\n    Handles both typed (GH_Structure[GH_String]) and untyped\n    (GH_Structure[IGH_Goo]) parameters. CPython3/pythonnet does not\n    always expose .Branch() on the generic IGH_Goo variant.\n\n    Args:\n        param: A GH input parameter object\n\n    Returns:\n        List-like branch data, or None if empty\n    \"\"\"\n    data = param.VolatileData\n\n    # Try .Branch(0) first (works for typed parameters)\n    if hasattr(data, 'Branch'):\n        try:\n            return data.Branch(0)\n        except Exception:\n            pass\n\n    # Try get_Branch (pythonnet explicit getter)\n    if hasattr(data, 'get_Branch'):\n        try:\n            return data.get_Branch(0)\n        except Exception:\n            pass\n\n    # Fallback: iterate Branches property\n    if hasattr(data, 'Branches'):\n        try:\n            branches = list(data.Branches)\n            if branches:\n                return branches[0]\n        except Exception:\n            pass\n\n    # Last resort: AllData gives flat list of all items\n    if hasattr(data, 'AllData'):\n        try:\n            all_items = data.AllData(True)\n            return all_items\n        except Exception:\n            pass\n\n    return None\n\n\ndef _read_string_input(inputs, index):\n    \"\"\"Read a string value from a GH input by parameter index.\n\n    Args:\n        inputs: ghenv.Component.Params.Input collection\n        index: Zero-based parameter index\n\n    Returns:\n        str or None if input is empty or missing\n    \"\"\"\n    if index >= inputs.Count:\n        return None\n    if inputs[index].VolatileDataCount == 0:\n        return None\n    branch = _get_first_branch(inputs[index])\n    if branch is None or len(branch) == 0:\n        return None\n    item = branch[0]\n    val = item.Value if hasattr(item, 'Value') else item\n    if val is None:\n        return None\n    return str(val)\n\n\ndef _read_bool_input(inputs, index, default=False):\n    \"\"\"Read a boolean value from a GH input by parameter index.\n\n    Args:\n        inputs: ghenv.Component.Params.Input collection\n        index: Zero-based parameter index\n        default: Default value if input is empty\n\n    Returns:\n        bool\n    \"\"\"\n    if index >= inputs.Count:\n        return default\n    if inputs[index].VolatileDataCount == 0:\n        return default\n    branch = _get_first_branch(inputs[index])\n    if branch is None or len(branch) == 0:\n        return default\n    item = branch[0]\n    val = item.Value if hasattr(item, 'Value') else item\n    if val is None:\n        return default\n    return bool(val)\n\n\ndef _read_list_input(inputs, index):\n    \"\"\"Read a list of values from a GH input by parameter index.\n\n    Args:\n        inputs: ghenv.Component.Params.Input collection\n        index: Zero-based parameter index\n\n    Returns:\n        list of values (may be empty)\n    \"\"\"\n    result = []\n    if index >= inputs.Count:\n        return result\n    if inputs[index].VolatileDataCount == 0:\n        return result\n    branch = _get_first_branch(inputs[index])\n    if branch is None:\n        return result\n    for item in branch:\n        val = item.Value if hasattr(item, 'Value') else item\n        result.append(val)\n    return result\n\n\ndef validate_inputs(baking_data_json_val, column_ids_val, beam_ids_val, run_val):\n    \"\"\"Validate component inputs.\n\n    Args:\n        baking_data_json_val: Raw baking data JSON string\n        column_ids_val: List of column ElementIds\n        beam_ids_val: List of beam ElementIds\n        run_val: Boolean run toggle\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run_val:\n        return False, \"Set 'run' to True to execute\"\n\n    if baking_data_json_val is None or not baking_data_json_val.strip():\n        return False, \"baking_data_json is required\"\n\n    # Validate JSON is parseable\n    try:\n        data = json.loads(baking_data_json_val)\n        if not isinstance(data, dict):\n            return False, \"baking_data_json must be a JSON object\"\n        walls = data.get(\"walls\", {})\n        if not walls:\n            return False, \"baking_data_json contains no walls\"\n    except json.JSONDecodeError as e:\n        return False, \"Invalid JSON in baking_data_json: %s\" % str(e)\n\n    # At least one set of element IDs required\n    has_columns = column_ids_val and len(column_ids_val) > 0\n    has_beams = beam_ids_val and len(beam_ids_val) > 0\n    if not has_columns and not has_beams:\n        return False, \"At least column_ids or beam_ids must have elements\"\n\n    # Check Revit availability\n    if not REVIT_AVAILABLE:\n        return False, \"Revit document is not available (RhinoInside.Revit required)\"\n\n    return True, None\n\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the Revit Assembly Creator component.\n\n    Coordinates the overall workflow:\n    1. Read inputs by parameter index\n    2. Setup component metadata (display only)\n    3. Validate inputs\n    4. Group elements by panel using baking_data_json correlation\n    5. Create Revit assemblies via two-transaction pattern\n    6. Return results as JSON, IDs, and info\n\n    Returns:\n        tuple: (assembly_json, assembly_ids, info)\n    \"\"\"\n    # Default outputs\n    default_outputs = (\"\", [], \"\")\n\n    # -----------------------------------------------------------------\n    # Read inputs by parameter index (CRITICAL: NickName injection is unreliable)\n    # -----------------------------------------------------------------\n    inputs = ghenv.Component.Params.Input\n\n    baking_data_json_val = _read_string_input(inputs, 0)\n    panels_json_val = _read_string_input(inputs, 1)\n    column_ids_val = _read_list_input(inputs, 2)\n    beam_ids_val = _read_list_input(inputs, 3)\n    sheathing_ids_val = _read_list_input(inputs, 4)\n    sheathing_data_json_val = _read_string_input(inputs, 5)\n    naming_prefix_val = _read_string_input(inputs, 6)\n    create_views_val = _read_bool_input(inputs, 7, default=False)\n    view_config_json_val = _read_string_input(inputs, 8)\n    framing_json_val = _read_string_input(inputs, 9)\n    run_val = _read_bool_input(inputs, 10, default=False)\n\n    # -----------------------------------------------------------------\n    # Setup component metadata (display only, AFTER inputs are captured)\n    # -----------------------------------------------------------------\n    setup_component()\n\n    try:\n        # -----------------------------------------------------------------\n        # Validate inputs\n        # -----------------------------------------------------------------\n        is_valid, error_msg = validate_inputs(\n            baking_data_json_val, column_ids_val, beam_ids_val, run_val,\n        )\n\n        if not is_valid:\n            if run_val:\n                log_warning(error_msg)\n            else:\n                log_info(error_msg or \"Component disabled (run=False)\")\n            return (\"\", [], error_msg or \"Not running\")\n\n        # -----------------------------------------------------------------\n        # Build diagnostic info\n        # -----------------------------------------------------------------\n        info_lines = [\n            \"Revit Assembly Creator v1.3\",\n            \"=\" * 40,\n        ]\n\n        # Apply defaults for optional inputs\n        prefix = naming_prefix_val if naming_prefix_val else \"W\"\n        do_create_views = create_views_val\n\n        # Parse view config JSON\n        view_config = None\n        if view_config_json_val:\n            try:\n                config_data = json.loads(view_config_json_val)\n                view_config = AssemblyViewConfig.from_dict(config_data)\n                log_info(\"View config: %s\" % str(config_data))\n            except (json.JSONDecodeError, Exception) as e:\n                log_warning(\"Invalid view_config_json, using defaults: %s\" % str(e))\n                view_config = None\n\n        info_lines.append(\"Naming Prefix: %s\" % prefix)\n        info_lines.append(\"Create Views: %s\" % str(do_create_views))\n        if view_config:\n            info_lines.append(\"View Config: detail=%s, display=%s\"\n                              % (view_config.detail_level, view_config.display_style))\n        info_lines.append(\"Revit Document: %s\" % (REVIT_DOC.Title if REVIT_DOC else \"N/A\"))\n\n        # Count input elements\n        info_lines.append(\"\")\n        info_lines.append(\"Input Counts:\")\n        info_lines.append(\"  Column IDs: %d\" % len(column_ids_val))\n        info_lines.append(\"  Beam IDs: %d\" % len(beam_ids_val))\n        info_lines.append(\"  Sheathing IDs: %d\" % len(sheathing_ids_val))\n        info_lines.append(\"  Panels JSON: %s\" % (\"provided\" if panels_json_val else \"not provided (wall-level grouping)\"))\n        info_lines.append(\"  Sheathing Data JSON: %s\" % (\"provided\" if sheathing_data_json_val else \"not provided\"))\n\n        # Parse baking data for summary\n        baking_data = json.loads(baking_data_json_val)\n        wall_count = len(baking_data.get(\"walls\", {}))\n        total_members = sum(\n            len(w.get(\"members\", []))\n            for w in baking_data.get(\"walls\", {}).values()\n        )\n        info_lines.append(\"\")\n        info_lines.append(\"Baking Data:\")\n        info_lines.append(\"  Walls: %d\" % wall_count)\n        info_lines.append(\"  Members: %d\" % total_members)\n\n        # -----------------------------------------------------------------\n        # Enrich panels with element_ids from framing data\n        # -----------------------------------------------------------------\n        # The panel decomposer runs before the framing generator, so\n        # panels_json has empty element_ids. If framing_json is provided,\n        # map each element's panel_id back to its panel's element_ids list.\n        # This enables the reliable element-ID-based grouping path.\n        enriched_panels_json = panels_json_val\n        if framing_json_val and panels_json_val:\n            try:\n                enriched_panels_json = enrich_panels_with_framing_data(\n                    panels_json_val, framing_json_val,\n                )\n                log_info(\"Enriched panels with framing element_ids\")\n                info_lines.append(\"  Framing JSON: provided (panels enriched with element_ids)\")\n            except Exception as e:\n                log_warning(\"Failed to enrich panels: %s\" % str(e))\n                enriched_panels_json = panels_json_val\n                info_lines.append(\"  Framing JSON: provided but enrichment failed: %s\" % str(e))\n        elif framing_json_val:\n            info_lines.append(\"  Framing JSON: provided but no panels_json to enrich\")\n        else:\n            info_lines.append(\"  Framing JSON: not provided (using geometry-based grouping)\")\n\n        # -----------------------------------------------------------------\n        # Group elements by panel\n        # -----------------------------------------------------------------\n        log_info(\"Grouping elements by panel...\")\n\n        groups = group_elements_by_panel(\n            baking_data_json_val,\n            enriched_panels_json,\n            column_ids_val,\n            beam_ids_val,\n            sheathing_ids_val if sheathing_ids_val else None,\n            sheathing_data_json_val,\n        )\n\n        info_lines.append(\"\")\n        info_lines.append(\"Grouping Results:\")\n        info_lines.append(\"  Groups created: %d\" % len(groups))\n        total_grouped = sum(g.element_count for g in groups)\n        info_lines.append(\"  Total elements grouped: %d\" % total_grouped)\n\n        for g in groups:\n            info_lines.append(\n                \"  %s: %d cols, %d beams, %d sheathing\"\n                % (g.panel_id, len(g.column_element_ids),\n                   len(g.beam_element_ids), len(g.sheathing_element_ids))\n            )\n\n        # Check for duplicate Revit ElementIds across groups\n        if groups:\n            all_eid_strs = []\n            eid_to_panel = {}\n            dup_samples = []\n            for g in groups:\n                for eid in g.all_element_ids:\n                    eid_str = str(eid)\n                    if eid_str in eid_to_panel:\n                        if len(dup_samples) < 10:\n                            dup_samples.append(\n                                (eid_str, eid_to_panel[eid_str], g.panel_id)\n                            )\n                    else:\n                        eid_to_panel[eid_str] = g.panel_id\n                    all_eid_strs.append(eid_str)\n\n            unique_count = len(eid_to_panel)\n            dup_count = len(all_eid_strs) - unique_count\n            info_lines.append(\"\")\n            info_lines.append(\"Duplicate Element Check:\")\n            info_lines.append(\n                \"  Total element refs: %d, Unique: %d, Duplicates: %d\"\n                % (len(all_eid_strs), unique_count, dup_count)\n            )\n            if dup_count > 0:\n                log_warning(\n                    \"DUPLICATE ELEMENTS: %d elements shared across panels!\"\n                    % dup_count\n                )\n                for eid_str, first_panel, second_panel in dup_samples:\n                    info_lines.append(\n                        \"  ElementId '%s': in '%s' AND '%s'\"\n                        % (eid_str, first_panel, second_panel)\n                    )\n            else:\n                info_lines.append(\"  No duplicates -- all elements unique\")\n\n        if not groups:\n            msg = \"No element groups created -- check baking_data_json and panels_json\"\n            log_warning(msg)\n            info_lines.append(\"\")\n            info_lines.append(\"WARNING: %s\" % msg)\n\n            # Diagnostic: show sample data to help identify the mismatch\n            info_lines.append(\"\")\n            info_lines.append(\"=== DIAGNOSTIC: Sample Data ===\")\n\n            # Sample baking member IDs\n            sample_member_ids = []\n            for wid, wd in baking_data.get(\"walls\", {}).items():\n                for m in wd.get(\"members\", [])[:3]:\n                    sample_member_ids.append(m.get(\"id\", \"?\"))\n                if sample_member_ids:\n                    break\n            info_lines.append(\"Baking member IDs (first 3): %s\" % sample_member_ids)\n\n            # Sample baking member panel_ids\n            sample_panel_ids = []\n            for wid, wd in baking_data.get(\"walls\", {}).items():\n                for m in wd.get(\"members\", [])[:3]:\n                    sample_panel_ids.append(m.get(\"panel_id\", \"MISSING\"))\n                if sample_panel_ids:\n                    break\n            info_lines.append(\"Baking member panel_ids (first 3): %s\" % sample_panel_ids)\n\n            # Sample baking wall IDs\n            baking_wall_ids = list(baking_data.get(\"walls\", {}).keys())[:3]\n            info_lines.append(\"Baking wall IDs: %s\" % baking_wall_ids)\n\n            # Panels data\n            if panels_json_val:\n                try:\n                    panels_raw = json.loads(panels_json_val)\n                    info_lines.append(\"Panels JSON type: %s\" % type(panels_raw).__name__)\n                    if isinstance(panels_raw, dict):\n                        info_lines.append(\"Panels JSON keys: %s\" % list(panels_raw.keys()))\n                        nested = panels_raw.get(\"panels\", [])\n                        if nested:\n                            p0 = nested[0]\n                            info_lines.append(\"First panel keys: %s\" % list(p0.keys()))\n                            info_lines.append(\"First panel id: %s\" % p0.get(\"id\", \"MISSING\"))\n                            info_lines.append(\"First panel element_ids (first 3): %s\"\n                                              % p0.get(\"element_ids\", [])[:3])\n                    elif isinstance(panels_raw, list) and panels_raw:\n                        p0 = panels_raw[0]\n                        info_lines.append(\"First item keys: %s\" % list(p0.keys()))\n                        if \"panels\" in p0:\n                            nested = p0.get(\"panels\", [])\n                            if nested:\n                                info_lines.append(\"First nested panel id: %s\"\n                                                  % nested[0].get(\"id\", \"MISSING\"))\n                                info_lines.append(\"First nested panel element_ids (first 3): %s\"\n                                                  % nested[0].get(\"element_ids\", [])[:3])\n                except Exception as diag_err:\n                    info_lines.append(\"Failed to parse panels_json: %s\" % diag_err)\n            else:\n                info_lines.append(\"Panels JSON: not provided\")\n\n            info_lines.append(\"Column IDs sample (first 3): %s\"\n                              % [str(c) for c in column_ids_val[:3]])\n            info_lines.append(\"Beam IDs sample (first 3): %s\"\n                              % [str(b) for b in beam_ids_val[:3]])\n            info_lines.append(\"=== END DIAGNOSTIC ===\")\n\n            return (\"\", [], \"\\n\".join(info_lines))\n\n        # -----------------------------------------------------------------\n        # Extract wall directions for orientation fix\n        # -----------------------------------------------------------------\n        wall_directions = {}\n        for wall_id, wall_data in baking_data.get(\"walls\", {}).items():\n            members = wall_data.get(\"members\", [])\n            if members:\n                origin, direction = _derive_wall_axis(members)\n                if direction is not None:\n                    wall_directions[wall_id] = direction\n\n        if wall_directions:\n            info_lines.append(\"  Wall directions extracted: %d\" % len(wall_directions))\n\n        # -----------------------------------------------------------------\n        # Create assemblies\n        # -----------------------------------------------------------------\n        log_info(\"Creating %d assemblies (create_views=%s)...\" % (len(groups), do_create_views))\n\n        result = create_assemblies(\n            REVIT_DOC,\n            groups,\n            naming_prefix=prefix,\n            create_views=do_create_views,\n            view_config=view_config,\n            wall_directions=wall_directions if wall_directions else None,\n        )\n\n        # -----------------------------------------------------------------\n        # Build output\n        # -----------------------------------------------------------------\n        assembly_json_val = json.dumps(result.to_dict(), indent=2)\n\n        assembly_ids_val = [\n            r.assembly_id\n            for r in result.results\n            if r.assembly_id is not None\n        ]\n\n        info_lines.append(\"\")\n        info_lines.append(\"Assembly Creation Results:\")\n        info_lines.append(\"  Total: %d\" % result.total_assemblies)\n        info_lines.append(\"  Created: %d\" % result.successful)\n        info_lines.append(\"  Failed: %d\" % result.failed)\n        info_lines.append(\"\")\n\n        for r in result.results:\n            if r.status == \"created\":\n                status_str = \"[OK]\"\n            else:\n                status_str = \"[FAIL]\"\n            line = \"  %s %s (%d elements)\" % (status_str, r.assembly_name, r.element_count)\n            if r.error:\n                line += \" - %s\" % r.error\n            if r.views_created:\n                line += \" views: %s\" % \", \".join(r.views_created)\n            info_lines.append(line)\n\n        # Summary GH message\n        if result.failed == 0 and result.successful > 0:\n            log_message(\n                \"Created %d assemblies successfully\" % result.successful,\n                \"remark\",\n            )\n        elif result.failed > 0 and result.successful > 0:\n            log_warning(\n                \"Partial: %d created, %d failed\" % (result.successful, result.failed)\n            )\n        elif result.successful == 0:\n            log_error(\n                \"All %d assemblies failed\" % result.failed\n            )\n\n        info_val = \"\\n\".join(info_lines)\n        return (assembly_json_val, assembly_ids_val, info_val)\n\n    except Exception as e:\n        error_msg = \"Unexpected error: %s\" % str(e)\n        log_error(error_msg)\n        log_debug(traceback.format_exc())\n        return (\"\", [], error_msg + \"\\n\" + traceback.format_exc())\n\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif __name__ == \"__main__\":\n    assembly_json, assembly_ids, info = main()\n    # Print info to console so it's always visible regardless of output binding\n    if info:\n        print(info)\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}