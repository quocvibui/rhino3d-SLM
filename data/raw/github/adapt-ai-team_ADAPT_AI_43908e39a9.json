{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/solar_new_2.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/solar_new_2.py",
  "instruction": "Solar new 2",
  "code": "import rhino3dm\nimport numpy as np\nimport trimesh\nimport matplotlib.pyplot as plt\nfrom ladybug.epw import EPW\nfrom ladybug.sunpath import Sunpath\nfrom ladybug.dt import DateTime\nfrom ladybug_geometry.geometry3d.mesh import Mesh3D\nfrom ladybug_geometry.geometry3d.pointvector import Point3D\nimport time\nimport multiprocessing as mp\nfrom tqdm import tqdm\n\n# --- Configuration ---\nepw_file = r\"D:\\spz_analysis2\\newyork.epw\"  # Path to EPW weather file\nmesh_file = r\"D:\\spz_pipeline\\pipeline_outputs\\merged_model.3dm\"  # Path to 3DM mesh file\noutput_glb = r\"D:\\spz_pipeline\\pipeline_outputs\\solar_radiation_example_image.glb\"  # Output .glb file\noffset_dist = 0.1  # Offset for analysis points\n\ndef calculate_radiation(args):\n    i, center, normal, sun_positions, solar_data = args\n    total_radiation = 0\n    for j, sun_pos in enumerate(sun_positions):\n        sun_vector = -1 * sun_pos.sun_vector_reversed\n        angle_factor = max(0, normal.dot(sun_vector))\n        radiation_value = solar_data[j % len(solar_data)] * angle_factor\n        total_radiation += radiation_value\n    return total_radiation\n\ndef validate_solar_analysis(radiation_values, lb_mesh):\n    print(\"\\n=== VALIDATION CHECKS ===\")\n    north_facing = []\n    south_facing = []\n    for i, normal in enumerate(lb_mesh.face_normals):\n        if normal.y < -0.7:\n            north_facing.append(radiation_values[i])\n        elif normal.y > 0.7:\n            south_facing.append(radiation_values[i])\n    if north_facing and south_facing:\n        north_avg = sum(north_facing) / len(north_facing)\n        south_avg = sum(south_facing) / len(south_facing)\n        north_south_ratio = north_avg / south_avg if south_avg > 0 else 0\n        print(f\"North-facing surfaces avg radiation: {north_avg:.1f}\")\n        print(f\"South-facing surfaces avg radiation: {south_avg:.1f}\")\n        print(f\"North/South ratio: {north_south_ratio:.2f} (should be < 1.0)\")\n        print(f\"Plausibility: {'✅ GOOD' if north_south_ratio < 0.8 else '❌ SUSPICIOUS'}\")\n    print(f\"Radiation range: {min(radiation_values):.1f} - {max(radiation_values):.1f} kWh/m²\")\n    expected_min = 100\n    expected_max = 2000\n    print(f\"Range check: {'✅ GOOD' if min(radiation_values) > expected_min and max(radiation_values) < expected_max else '❌ SUSPICIOUS'}\")\n    std_dev = np.std(radiation_values)\n    mean_val = np.mean(radiation_values)\n    cv = std_dev / mean_val\n    print(f\"Statistical variation (CV): {cv:.2f}\")\n    print(f\"Variation check: {'✅ GOOD' if cv < 0.8 else '❌ HIGH VARIATION'}\")\n    return north_south_ratio, cv\n\ndef add_color_legend(mesh, min_val, max_val, colors, position=None):\n    \"\"\"Add a color legend to the 3D scene\"\"\"\n    # Default position (adjust based on your model bounds)\n    if position is None:\n        bounds = mesh.bounds\n        position = [bounds[1][0] + 100, bounds[0][1], bounds[0][2]]  # Right side of model\n    \n    # Create legend dimensions\n    legend_height = 50\n    legend_width = 10\n    legend_depth = 1\n    text_height = 10\n    \n    # Create legend base geometry\n    legend_vertices = []\n    legend_faces = []\n    legend_colors = []\n    \n    # Create the color bar with gradient\n    segments = 20\n    for i in range(segments):\n        # Calculate corners of this segment\n        z_bottom = i * (legend_height / segments)\n        z_top = (i + 1) * (legend_height / segments)\n        \n        # Add vertices\n        base_idx = len(legend_vertices)\n        legend_vertices.extend([\n            [position[0], position[1], position[2] + z_bottom],              # front bottom left\n            [position[0] + legend_width, position[1], position[2] + z_bottom], # front bottom right\n            [position[0] + legend_width, position[1], position[2] + z_top],    # front top right\n            [position[0], position[1], position[2] + z_top]                  # front top left\n        ])\n        \n        # Add face\n        legend_faces.append([base_idx, base_idx + 1, base_idx + 2, base_idx + 3])\n        \n        # Add color (reverse order to have high values at top)\n        color_idx = segments - i - 1\n        color = colors[int(color_idx / segments * (len(colors)-1))]\n        legend_colors.append(color)\n    \n    # Create text labels (in separate rendering step)\n    # For GLB, we can't easily add text, so we'll create markers at min, mid, max\n    \n    # Create a trimesh for the legend\n    legend_mesh = trimesh.Trimesh(\n        vertices=np.array(legend_vertices),\n        faces=np.array(legend_faces),\n        face_colors=legend_colors,\n        process=False\n    )\n    \n    # Combine with main mesh\n    combined = trimesh.util.concatenate([mesh, legend_mesh])\n    \n    # Create text values for separate display\n    text_values = {\n        \"min\": f\"{min_val:.1f} kWh/m²\",\n        \"max\": f\"{max_val:.1f} kWh/m²\",\n        \"position\": [position[0] + legend_width + 5, position[1], position[2]]\n    }\n    \n    return combined, text_values\n\ndef create_color_legend(min_val, max_val, cmap_name=\"jet\", size=None):\n    \"\"\"Create a standalone color legend mesh\"\"\"\n    if size is None:\n        size = (10, 50, 1)  # width, height, depth\n    \n    # Position at origin\n    position = [0, 0, 0]\n    \n    # Create legend dimensions\n    legend_width, legend_height, legend_depth = size\n    \n    # Create legend base geometry\n    vertices = []\n    faces = []\n    colors = []\n    \n    # Get colormap\n    cmap = plt.get_cmap(cmap_name)\n    \n    # Create the color bar with gradient\n    segments = 20\n    for i in range(segments):\n        # Calculate corners of this segment\n        z_bottom = i * (legend_height / segments)\n        z_top = (i + 1) * (legend_height / segments)\n        \n        # Add vertices\n        base_idx = len(vertices)\n        vertices.extend([\n            [position[0], position[1], position[2] + z_bottom],\n            [position[0] + legend_width, position[1], position[2] + z_bottom],\n            [position[0] + legend_width, position[1], position[2] + z_top],\n            [position[0], position[1], position[2] + z_top]\n        ])\n        \n        # Add face\n        faces.append([base_idx, base_idx + 1, base_idx + 2, base_idx + 3])\n        \n        # Add color (reverse order to have high values at top)\n        color_idx = segments - i - 1\n        color_value = color_idx / (segments - 1)\n        color_rgb = cmap(color_value)[:3]  # Get RGB (ignore alpha)\n        color_rgba = [int(c * 255) for c in color_rgb] + [255]  # Add alpha channel\n        colors.append(color_rgba)\n    \n    # Create a trimesh for the legend\n    legend_mesh = trimesh.Trimesh(\n        vertices=np.array(vertices),\n        faces=np.array(faces),\n        face_colors=np.array(colors)\n    )\n    \n    return legend_mesh, min_val, max_val\n\ndef main():\n    # --- 1. Load Climate Data ---\n    epw = EPW(epw_file)\n    location = epw.location\n    solar_data = [val * 0.1 for val in epw.direct_normal_radiation]\n    solar_data = epw.global_horizontal_radiation\n\n    # --- 2. Compute Solar Position ---\n    sunpath = Sunpath(location.latitude, location.longitude, location.time_zone)\n    solar_positions = []\n    for month in range(6, 13):\n        for day in [7, 14, 21]:\n            for hour in range(6, 19):\n                for minute in [0, 30]:\n                    dt = DateTime(month, day, hour, minute)\n                    sun = sunpath.calculate_sun_from_date_time(dt)\n                    if sun.altitude > 0:\n                        solar_positions.append(sun)\n    print(f\"Generated {len(solar_positions)} sun positions for analysis\")\n\n    # --- 3. Load Mesh Geometry ---\n    model = rhino3dm.File3dm.Read(mesh_file)\n    if not model:\n        raise RuntimeError(f\"Failed to read 3DM file: {mesh_file}\")\n    rhino_meshes = [obj.Geometry for obj in model.Objects if isinstance(obj.Geometry, rhino3dm.Mesh)]\n    if not rhino_meshes:\n        raise RuntimeError(\"No mesh found in the file.\")\n    print(f\"Found {len(rhino_meshes)} meshes in the file\")\n\n    # Merging all meshes before analysis\n    print(\"Merging all meshes before analysis...\")\n    all_vertices = []\n    all_faces = []\n    vertex_offset = 0\n    for rhino_mesh in rhino_meshes:\n        vertices = [(pt.X, pt.Y, pt.Z) for pt in rhino_mesh.Vertices]\n        all_vertices.extend(vertices)\n        for i in range(rhino_mesh.Faces.Count):\n            face = rhino_mesh.Faces[i]\n            if face[2] == face[3]:  # Triangle\n                all_faces.append([face[0] + vertex_offset, face[1] + vertex_offset, face[2] + vertex_offset])\n            else:  # Quad\n                all_faces.append([face[0] + vertex_offset, face[1] + vertex_offset, face[2] + vertex_offset, face[3] + vertex_offset])\n        vertex_offset += len(vertices)\n    combined_mesh = trimesh.Trimesh(vertices=np.array(all_vertices), faces=np.array(all_faces))\n    print(f\"Created combined mesh with {len(combined_mesh.vertices)} vertices and {len(combined_mesh.faces)} faces\")\n\n    # Convert combined mesh to Ladybug format\n    lb_vertices = [Point3D(*vertex) for vertex in combined_mesh.vertices]\n    lb_faces = []\n    for face in combined_mesh.faces:\n        if len(face) == 3:\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], lb_vertices[face[2]]])\n        elif len(face) == 4:\n            lb_faces.append([lb_vertices[face[0]], lb_vertices[face[1]], lb_vertices[face[2]], lb_vertices[face[3]]])\n    lb_mesh = Mesh3D.from_face_vertices(lb_faces)\n    print(f\"Created Ladybug mesh with {len(lb_mesh.faces)} faces\")\n\n    # --- 4. Compute Solar Radiation (with multiprocessing) ---\n    face_centroids = lb_mesh.face_centroids\n    face_normals = lb_mesh.face_normals\n    print(\"\\nCalculating solar radiation using multiprocessing...\")\n    start_time = time.time()\n    args_list = [(i, face_centroids[i], face_normals[i], solar_positions, solar_data) for i in range(len(lb_mesh.faces))]\n    with mp.Pool(processes=max(1, mp.cpu_count()-1)) as pool:\n        radiation_values = list(tqdm(pool.imap(calculate_radiation, args_list), total=len(args_list), desc=\"Processing faces\", bar_format=\"{desc}: {percentage:3.1f}% |{bar}| {n_fmt}/{total_fmt} faces [ETA: {remaining}, {rate_fmt}]\"))\n    print(f\"\\nCompleted radiation analysis in {time.time() - start_time:.1f} seconds\")\n\n    # After calculating radiation_values\n    validation_results = validate_solar_analysis(radiation_values, lb_mesh)\n    min_radiation, max_radiation = min(radiation_values), max(radiation_values)\n    norm_radiation = [(val - min_radiation) / (max_radiation - min_radiation) if max_radiation > min_radiation else 0 for val in radiation_values]\n    cmap = plt.get_cmap(\"jet\")\n    colors = [cmap(val)[:3] for val in norm_radiation]\n    colors = [(int(r * 255), int(g * 255), int(b * 255), 255) for r, g, b in colors]\n\n    # --- 5. Export as .glb File ---\n    import os\n    output_dir = os.path.dirname(output_glb)\n    main_output = os.path.join(output_dir, \"solar_radiation_example_image.glb\")\n    lb_vertices_np = np.array([[v.x, v.y, v.z] for v in lb_mesh.vertices])\n    triangulated_faces = []\n    adjusted_colors = []\n    for i, face in enumerate(lb_mesh.faces):\n        if len(face) == 3:\n            triangulated_faces.append(list(face))\n            adjusted_colors.append(colors[i])\n        elif len(face) == 4:\n            triangulated_faces.append([face[0], face[1], face[2]])\n            triangulated_faces.append([face[0], face[2], face[3]])\n            adjusted_colors.append(colors[i])\n            adjusted_colors.append(colors[i])\n    lb_faces_np = np.array(triangulated_faces)\n    mesh = trimesh.Trimesh(vertices=lb_vertices_np, faces=lb_faces_np)\n    mesh.visual.face_colors = adjusted_colors\n    mesh.export(main_output)\n    print(f\"✅ Model saved as {main_output}\")\n\n    # Create standalone legend using a different method\n    print(\"Creating color legend...\")\n    legend_mesh = trimesh.creation.box(extents=[10, 1, 50])\n    print(\"Generating 2D legend image...\")\n    fig, ax = plt.subplots(figsize=(2, 6))\n    ax.set_visible(False)\n    norm = plt.Normalize(min_radiation, max_radiation)\n    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n    sm.set_array([])\n    cbar = plt.colorbar(sm, ax=ax)\n    cbar.set_label('Radiation (kWh/m²)')\n    cbar.set_ticks(np.linspace(min_radiation, max_radiation, 10))\n    cbar.set_ticklabels([f\"{val:.0f}\" for val in np.linspace(min_radiation, max_radiation, 10)])\n    plt.title('Solar Radiation\\n(kWh/m²)')\n    plt.figtext(0.1, 0.01, f\"N/S ratio: {validation_results[0]:.2f}\\nCV: {validation_results[1]:.2f}\", fontsize=8)\n    plt.savefig(output_glb.replace('.glb', '_legend.png'), bbox_inches='tight', dpi=300)\n    print(f\"✅ Legend image saved as {output_glb.replace('.glb', '_legend.png')}\")\n    validate_solar_analysis(radiation_values, lb_mesh)\n\nif __name__ == '__main__':\n    import multiprocessing\n    multiprocessing.freeze_support()\n    main()",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}