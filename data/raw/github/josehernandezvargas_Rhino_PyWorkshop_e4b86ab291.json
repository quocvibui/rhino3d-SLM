{
  "source_url": "https://github.com/josehernandezvargas/Rhino_PyWorkshop/blob/e061b54b86ef8e5b118408d00081d26c723b2c28/scripts/filament_mesh.py",
  "repo": "josehernandezvargas/Rhino_PyWorkshop",
  "repo_stars": 1,
  "repo_description": "A personal collection of Python tools for Rhino / Grasshopper",
  "license": "AGPL-3.0",
  "filepath": "scripts/filament_mesh.py",
  "instruction": "Filament mesh",
  "code": "#! python3\n\nimport Rhino.Geometry as rg\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport math\n\n# GH Python inputs:\ncurve: rg.Curve               # rail for sweep\nwidth: float                  # filament width\nheight: float                 # filament height\nsubdivs: float                # corner subdivisions (will be forced to int)\nsection_tolerance: float      # max deviation tolerance for curve sampling\nclosed: bool                  # close loft\ncaps: int                     # 0 = none, 1 = flat end caps\n\n# Output:\n# a: rg.Mesh (filament sweep mesh)\n\n# --------------------- MeshLoft (inlined) ---------------------\nclass MeshLoft:\n    def __init__(self, polylines, close_loft=False, cap_loft=0):\n        self.polylines = polylines\n        self.close_loft = close_loft\n        self.cap_loft = cap_loft\n        self.mesh = self._build_mesh()\n\n    def _build_mesh(self):\n        # flatten vertices\n        verts = [pt for pl in self.polylines for pt in pl]\n        # build faces\n        faces = []\n        count = len(self.polylines[0])\n        num = len(self.polylines)\n        for i in range(num - 1 + int(self.close_loft)):\n            i_next = (i + 1) % num\n            for j in range(count - 1):\n                v1 = i * count + j\n                v2 = i * count + j + 1\n                v3 = i_next * count + j + 1\n                v4 = i_next * count + j\n                faces.append((v1, v2, v3, v4))\n        mesh = rg.Mesh()\n        for v in verts:\n            mesh.Vertices.Add(v)\n        for f in faces:\n            mesh.Faces.AddFace(*f)\n        if self.cap_loft:\n            # flat caps\n            for pl in (self.polylines[0], self.polylines[-1]):\n                cap_mesh = rg.Mesh.CreateFromClosedPolyline(pl)\n                mesh.Append(cap_mesh)\n        mesh.Normals.ComputeNormals()\n        mesh.Compact()\n        return mesh\n\n# --------------------- Sweep Functions ---------------------\n\ndef create_rounded_rectangle(width, height, subdivs):\n    \"\"\"\n    Port of the rhinoscriptsyntax rounded_rectangle: uses only RhinoCommon.\n    subdivisions: number of segments per corner fillet.\n    If subdivisions == 0, returns a sharp rectangle.\n    Returns: rg.Polyline\n    \"\"\"\n    if subdivs < 0:\n        raise ValueError(\"subdivs cannot be negative\")\n    sub = int(subdivs)\n    half_w = width * 0.5\n    half_h = height * 0.5\n    pts = []\n    # sharp rectangle\n    if sub == 0:\n        rect = [\n            rg.Point3d( half_w,  half_h, 0),\n            rg.Point3d(-half_w,  half_h, 0),\n            rg.Point3d(-half_w, -half_h, 0),\n            rg.Point3d( half_w, -half_h, 0),\n        ]\n        pts.extend(rect)\n        pts.append(pts[0])\n        return rg.Polyline(pts)\n    # fillet radius = half height\n    radius = half_h\n    # compute corner centers offset by radius\n    centers = [\n        ( half_w - radius,  half_h - radius, 0),  # top right\n        (-half_w + radius,  half_h - radius, 0),  # top left\n        (-half_w + radius, -half_h + radius, 0),  # bottom left\n        ( half_w - radius, -half_h + radius, 0),  # bottom right\n    ]\n    # arc angles in radians\n    arc_bases = [\n        (0,   math.pi/2),    # top right\n        (math.pi/2, math.pi), # top left\n        (math.pi, 3*math.pi/2),# bottom left\n        (3*math.pi/2, 2*math.pi) # bottom right\n    ]\n    # sample each corner arc\n    for idx in range(4):\n        cx, cy, cz = centers[idx]\n        a_start, a_end = arc_bases[idx]\n        for j in range(sub + 1):\n            t = j / float(sub)\n            ang = (1 - t) * a_start + t * a_end\n            x = cx + radius * math.cos(ang)\n            y = cy + radius * math.sin(ang)\n            pts.append(rg.Point3d(x, y, cz))\n    pts.append(pts[0])\n    return rg.Polyline(pts)\n\n    # filleted rectangle\n    radius = min(half_w, half_h)\n    # corner centers and their arc angles\n    corner_data = [\n        ( half_w - radius,  half_h - radius,  0.0,      math.pi/2),\n        ( half_w - radius, -half_h + radius, -math.pi/2, 0.0),\n        (-half_w + radius, -half_h + radius, math.pi,   -math.pi/2),\n        (-half_w + radius,  half_h - radius, math.pi/2,  math.pi)\n    ]\n    for cx, cy, a0, a1 in corner_data:\n        # sample the arc between a0 and a1\n        for i in range(subdivs + 1):\n            t = i / float(subdivs)\n            ang = a0 + (a1 - a0) * t\n            x = cx + math.cos(ang) * radius\n            y = cy + math.sin(ang) * radius\n            pts.append(rg.Point3d(x, y, 0))\n    pts.append(pts[0])\n    return rg.Polyline(pts)\n    # filleted rectangle\n    radius = min(half_w, half_h)\n    # define corner centers and start/end angles for arcs\n    corner_data = [\n        # center_x, center_y, start_angle, end_angle\n        ( half_w - radius,  half_h - radius,  0.0,      math.pi/2),\n        ( half_w - radius, -half_h + radius, -math.pi/2, 0.0),\n        (-half_w + radius, -half_h + radius, math.pi,   -math.pi/2),\n        (-half_w + radius,  half_h - radius, math.pi/2,  math.pi)\n    ]\n    for cx, cy, a0, a1 in corner_data:\n        for i in range(subdivs + 1):\n            t = i / subdivs\n            ang = a0 + (a1 - a0) * t\n            x = cx + math.cos(ang) * radius\n            y = cy + math.sin(ang) * radius\n            pts.append(rg.Point3d(x, y, 0))\n    pts.append(pts[0])\n    return rg.Polyline(pts)\n    radius = min(half_w, half_h)\n    # generate fillet arcs and straight segments\n    corners = [(half_w - radius,  half_h - radius,  0.0, 0.0),\n               ( half_w - radius, -half_h + radius,  0.0, -1.0),\n               (-half_w + radius, -half_h + radius, -1.0,  0.0),\n               (-half_w + radius,  half_h - radius,  0.0,  1.0)]\n    for cx, cy, dx, dy in corners:\n        # center of fillet arc\n        for i in range(subdivs + 1):\n            angle = math.atan2(dy, dx) + (math.pi/2) * (i / subdivs)\n            x = cx + math.cos(angle) * radius\n            y = cy + math.sin(angle) * radius\n            pts.append(rg.Point3d(x, y, 0))\n    pts.append(pts[0])\n    return rg.Polyline(pts)\n\n\ndef sample_frames(crv, tol):\n    \"\"\"Divide curve by length/tolerance and return list of perpendicular frames.\"\"\"\n    length = crv.GetLength()\n    count = max(int(round(length / tol)), 1)\n    points = rs.DivideCurve(crv, count)\n    frames = []\n    for pt in points:\n        ok, param = crv.ClosestPoint(pt)\n        _, frame = crv.PerpendicularFrameAt(param)\n        frames.append(frame)\n    return frames\n\n# --------------------- Main ---------------------\n\ndef main():\n    crv = rs.coercecurve(curve)\n    if not crv:\n        raise ValueError(\"Invalid curve input\")\n    fillet_count = int(subdivs)\n    profile = create_rounded_rectangle(width, height, fillet_count)\n    frames = sample_frames(crv, section_tolerance)\n    # orient sections\n    sections = []\n    for frame in frames:\n        pl = rg.Polyline(profile)\n        pl.Transform(rg.Transform.PlaneToPlane(rg.Plane.WorldXY, frame))\n        sections.append(pl)\n    # mesh loft\n    loft = MeshLoft(sections, close_loft=closed, cap_loft=caps)\n    return loft.mesh\n\n# execute and output\na = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}