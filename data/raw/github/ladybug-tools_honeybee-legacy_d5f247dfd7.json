{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Add%20Internal%20Mass%20to%20Zone.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Add Internal Mass to Zone.py",
  "instruction": "Use this component to assign internal thermal masses to zones, which can be used to account for the effects of furniture inside zones or massive building components like hearths and chimneys.\n_\nThe...",
  "code": "# This component assigns internal masses to zones\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to assign internal thermal masses to zones, which can be used to account for the effects of furniture inside zones or massive building components like hearths and chimneys.\n_\nThe component accepts either surfaces of Rhino geometry (representing furniture or building elements) or a numerical value of the mass's surface area.  Several of these components can be used in a series to descibe internal masses (or furniture) made of different materials).\n_\nNote that internal masses assigned this way cannot \"see\" solar radiation that may potentially hit them and, as such, caution should be taken when using this component with internal mass objects that are not always in shade.\nMasses are only factored into the the thermal calculations of the zone by undergoing heat transfer with the indoor air.\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _HBZones: HBZones for which internal masses are to be assigned.\n        internalMassName_: An optional text name for the internal mass.  This can be useful for keeping track of different internal mass types if you use several of this component in series.\n        _srfsOrSrfArea: A list of Rhino breps representing the surfaces of internal masses (or furniture) that are exposed to the air of the zone.  Alternatively, this can be a number or list of numbers representing the surface area of the internal masses (or furniture) that are exposed to the zone air.\n            _\n            In the case of breps representing the surfaces of internal masses, this component is smart enough to know which zone the surfaces are in.  However, all surfaces must lie COMPLETELY inside a single zone and cannot span between zones or span outside the building.  If you have an object that lies between two zones, please split it in two along the boundary between the zones.\n            _\n            In the case of numbers representing the the surface area of the internal masses, inputs can be either a single number (which will be used to put internal masses into all zones using the specified surface area), or it can be a list of numbers that matches the input zones, which can be used to assign different levels of mass surface area to different zones.\n        _EPConstruction: An EnergyPlus Construction that represents the type of material that the thermal mass is composed of.  This can be either a construction from the \"Call from EP Construction Library\" component or a custom construction from the \"EnergyPlus Construction\" component.\n    Returns:\n        HBZones: HBZones with internal masses assigned.\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Add Internal Mass to Zone\"\nghenv.Component.NickName = 'addInternalMass'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"10 | Energy | Energy\"\n#compatibleHBVersion = VER 0.0.56\\nDEC_15_2017\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"2\"\nexcept: pass\n\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport uuid\nimport Rhino as rc\nimport rhinoscriptsyntax as rs\n\nw = gh.GH_RuntimeMessageLevel.Warning\ntol = sc.doc.ModelAbsoluteTolerance\n\n\ndef checkTheInputs():\n    #Call the necessary HB functions from the hive.\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n    \n    #Have a function to duplicate data.\n    def duplicateData(data, calcLength):\n        dupData = []\n        for count in range(calcLength):\n            dupData.append(data[0])\n        return dupData\n    \n    #Create lists to be filled.\n    srfAreas = []\n    \n    #Check to see if the input in the _srfsOrSrfArea is a number of geometry.\n    checkData1 = False\n    try:\n        #Object is a surface area number.\n        srfArea = float(_srfsOrSrfArea[0])\n        srfMethod = 1\n        \n        #Number is a single value to applied to all connected zones.\n        if len(_srfsOrSrfArea) == 1:\n            srfAreas = duplicateData([float(_srfsOrSrfArea[0])], len(_HBZones))\n            checkData1 = True\n        #Number is list of numbers that match the connected zones.\n        elif len(_srfsOrSrfArea) == len(_HBZones):\n            srfMethod = 0\n            for item in _srfsOrSrfArea:\n                srfAreas.append(float(item))\n            checkData1 = True\n        else:\n            warning = \"Numerical inputs for _srfsOrSrfArea must be either a list that matches the number of HBZones or a single value to be applied to all HBZones.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n    except:\n        try:\n            #Object is a set of surfaces.\n            srfBreps = []\n            srfVerts = []\n            for item in _srfsOrSrfArea:\n                srfBrep = [rs.coercegeometry(srfBrep) for srfBrep in [item]][0]\n                srfVert = srfBrep.DuplicateVertices()\n                srfBreps.append(srfBrep)\n                srfVerts.append(srfVert)\n            \n            checkData1 = True\n            \n            #Create a list to hold the total surface areas inside each zone.\n            brepZoneCount = []\n            for zone in _HBZones:\n                brepZoneCount.append(0)\n                srfAreas.append(0)\n            \n            #Test to see if any of the breps lie completely inside a zone.\n            for count, brep in enumerate(srfBreps):\n                brepZoneCounter = brepZoneCount[:]\n                for zoneCount, zone in enumerate(_HBZones):\n                    for vertex in srfVerts[count]:\n                        if zone.IsPointInside(rc.Geometry.Point3d(vertex), tol, False):\n                            brepZoneCounter[zoneCount] += 1\n                    if brepZoneCounter[zoneCount] == len(srfVerts[count]):\n                        #The surface is completely inside the zone.\n                        area = rc.Geometry.AreaMassProperties.Compute(brep).Area*sc.sticky[\"honeybee_ConversionFactor\"]*sc.sticky[\"honeybee_ConversionFactor\"]\n                        srfAreas[zoneCount] += area\n                \n                #Give a warning if a surface was not found to lie completely inside any zone.\n                if len(srfVerts[count]) not in brepZoneCounter:\n                    checkData1 = False\n                    warning = \"One of the surfaces input to _srfsOrSrfArea does not lie completely in a single HBZone. \\n All surfaces must lie COMPLETELY inside a single zone and cannot span between zones or span outside the building. \\n If you have an object that lies between two zones, please split it in two along the boundary between the zones.\"\n                    print warning\n                    ghenv.Component.AddRuntimeMessage(w, warning)\n        except:\n            warning = \"Input for _srfsOrSrfArea is invalid.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    #Check to be sure that the EPConstruction is in the library or can be added to the library.\n    checkData2 = True\n    # if it is just the name of the material make sure it is already defined\n    if len(_EPConstruction.split(\"\\n\")) == 1:\n        # if the material is not in the library add it to the library\n        if not hb_EPObjectsAux.isEPConstruction(_EPConstruction):\n            warningMsg = \"Can't find \" + _EPConstruction + \" in EP Construction Library.\\n\" + \\\n                        \"Add the construction to the library and try again.\"\n            print warningMsg\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warningMsg)\n            checkData2 = False\n        else:\n            EPConstruction = _EPConstruction\n    else:\n        # It is a full string\n        added, EPConstruction = hb_EPObjectsAux.addEPObjectToLib(_EPConstruction, overwrite = True)\n        \n        if not added:\n            msg = _EPConstruction + \" is not added to the project library!\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n            print msg\n            checkData2 = False\n    \n    #Check to be sure that the HBZones are valid HBZones.\n    checkData3 = True\n    try:\n        HBZones = hb_hive.callFromHoneybeeHive(_HBZones)\n    except:\n        HBZones = []\n        checkData3 = False\n        warning = \"Connected _HBZones are not valid.\"\n        print warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    #Check to see if there is an internalMassName_ attached.\n    massNames = []\n    if internalMassName_ != None:\n        for zone in HBZones:\n            massName = zone.name + \"-\" + internalMassName_\n            massNames.append(massName)\n    else:\n        for zone in HBZones:\n            massName = zone.name + \"-\" + \"Mass\" + str(len(zone.internalMassNames))\n            massNames.append(massName)\n    \n    #Check to be sure that everything is ok.\n    if checkData1 == True and checkData2 == True and checkData3 == True:\n        checkData = True\n    else: checkData = False\n    \n    \n    return checkData, HBZones, srfAreas, EPConstruction, massNames\n\n\ndef main(HBZones, srfAreas, EPConstruction, massNames):\n    # call the objects from the lib\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    \n    \n    # assign the values\n    for zoneCount, zone in enumerate(HBZones):\n        if srfAreas[zoneCount] != 0:\n            zone.internalMassNames.append(massNames[zoneCount])\n            zone.internalMassSrfAreas.append(srfAreas[zoneCount])\n            zone.internalMassConstructions.append(EPConstruction)\n            message = zone.name + \" has been assigned an internal mass with an area of (\" + str(round(srfAreas[zoneCount],2)) + \" Square \" + str(sc.doc.ModelUnitSystem) + \") and a construction of \" + str(EPConstruction)\n            print message\n    \n    # send the zones back to the hive\n    HZonesFinal  = hb_hive.addToHoneybeeHive(HBZones, ghenv.Component)\n    \n    return HZonesFinal\n\n\n\n\n#If Honeybee is not flying, give a warning.\ninitCheck = False\nif sc.sticky.has_key('honeybee_release') == True:\n    initCheck = True\nelse:\n    print \"You should first let Honeybee fly...\"\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee fly...\")\n\n\n#Run the Component\ncheckData = False\nif _HBZones != [] and _srfsOrSrfArea != [] and _EPConstruction != None and initCheck == True:\n    if _HBZones[0] != None:\n        checkData, HBZonesFromHive, srfAreas, EPConstruction, massNames = checkTheInputs()\n        \n        if checkData == True:\n            zones = main(HBZonesFromHive, srfAreas, EPConstruction, massNames)\n            \n            if zones!=-1:\n                HBZones = zones\n\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}