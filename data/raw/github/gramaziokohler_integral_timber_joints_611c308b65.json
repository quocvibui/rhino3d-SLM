{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/assembly_artist.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/assembly_artist.py",
  "instruction": "Assembly artist",
  "code": "import uuid\n\nimport Rhino.Geometry as rg\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc  # type: ignore\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Cylinder, Polyhedron, Shape\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_breps, draw_cylinders, draw_mesh\nfrom compas_rhino.geometry.transformations import xform_from_transformation\nfrom Rhino.DocObjects.ObjectColorSource import ColorFromObject  # type: ignore\nfrom System.Drawing import Color  # type: ignore\n\nfrom integral_timber_joints.assembly import Assembly\nfrom integral_timber_joints.rhino.artist import mesh_to_brep, vertices_and_faces_to_brep_struct, draw_shapes_as_brep_get_guids\nfrom integral_timber_joints.rhino.utility import purge_objects\n\nadd_brep = sc.doc.Objects.AddBrep\nfind_object = sc.doc.Objects.Find\n\nTOL = sc.doc.ModelAbsoluteTolerance\n\nguid = uuid.UUID\n\n\nclass AssemblyNurbsArtist(object):\n    \"\"\" Artist to draw Beams of an Assembly in Rhino with Nurbs geometry\n    Items are drawn in specific layers for quickly turning them on and off.\n    Beam Brep : layer = itj::beams_brep         name = beam_id\n\n    Dictionary keep track of the objects drawn in Rhino:\n    self.beam_guids\n\n    Beams are drawn in their final location.\n\n    \"\"\"\n\n    def __init__(self, assembly, beam_layer_name='itj::beams_brep::final'):\n        # type: (Assembly, str) -> None\n        \"\"\"Create new AssemblyNurbsArtist for an Assembly in Rhino Context\"\"\"\n\n        self.assembly = assembly  # type: Assembly\n\n        # # Create guid in dictionary to store geometries added to Rhino document\n        self._beam_guids = {}  # type: dict[str, list[str]]\n\n        self.beam_layer_name = beam_layer_name\n\n        # Empty existing layers and create them if not existing.\n        # This also creates the guid dictionary\n        if self.assembly is not None:\n            self.empty_layers()\n\n    @property\n    def all_layer_names(self):\n        yield self.beam_layer_name\n\n    def beam_guids(self, beam_id):\n        # type: (str) -> list[guid]\n        \"\"\"Returns the guids of a beam.\n        Creates dictionary entry if it is not yet tracked.\n        \"\"\"\n        if beam_id not in self._beam_guids:\n            self._beam_guids[beam_id] = []\n        return self._beam_guids[beam_id]\n\n    def empty_layers(self):\n        # type:() -> None\n        \"\"\"Clear the default artist layers in Rhino.\n        Create those layers if doesnt exist\n        Gguid dictionary is reset to all empty lists.\n        \"\"\"\n        # Clear layer if exist otherwise, create new layer\n        for layer_name in self.all_layer_names:\n            if not rs.IsLayer(layer_name):\n                rs.AddLayer(layer_name)\n            else:\n                clear_layer(layer_name)\n\n        # Create new guid dictionary / clear out previously-saved guids.\n        for beam_id in self.assembly.beam_ids():\n            self.delete_beam(beam_id, redraw=False)\n\n    def delete_beam(self, beam_id, redraw=True):\n        # type:(str, bool) -> None\n        \"\"\" Delete visualization geometry geometry (brep, mesh, tag etc) related to a beam.\n        Tools are not affected.\n        Stored guid reference is also removed.\n\n        If beam_id is not yet tracked in self.guid, the new entry will be created.\n        \"\"\"\n        rs.EnableRedraw(False)\n        if beam_id in self.assembly.beam_ids():\n            if len(self.beam_guids(beam_id)) > 0:\n                purge_objects(self.beam_guids(beam_id), redraw=False)\n                del self.beam_guids(beam_id)[:]\n        if redraw:\n            rs.EnableRedraw(True)\n\n    def draw_beam(self, beam_id, delete_old=False, redraw=True, other_feature_shapes=[], verbose=False):\n        # type: (str, bool, bool, list[Shape], bool) -> None\n        \"\"\"Function to draw specified beam with nurbs.\n\n        By default `delete_old` is False.\n\n        `redraw` triggers the Rhino canvas to refresh.\n        \"\"\"\n        rs.EnableRedraw(False)\n\n        def vprint(str):\n            if verbose:\n                print(str)\n\n        # If not delete_old, and there are already items drawn, we preserve them.\n        if len(self.beam_guids(beam_id)) > 0 and not delete_old:\n            guids = self.beam_guids(beam_id)\n        else:\n            # Delete old\n            if len(self.beam_guids(beam_id)) > 0 and delete_old:\n                self.delete_beam(beam_id, redraw=False)\n\n            # Layer\n            rs.CurrentLayer(self.beam_layer_name)\n\n            # Positive geometry is the uncut beam mesh\n            mesh_box = self.assembly.beam(beam_id).draw_uncut_mesh()\n            positive_brep_guids = draw_breps(mesh_to_brep(mesh_box), join=True, redraw=False)\n\n            # Retrieve all the negative features\n            negative_shapes = self.assembly.get_beam_negative_shapes(beam_id)\n            negative_shapes += other_feature_shapes\n\n            guids = []  # Hold the guids of the final boolean result\n            if len(negative_shapes) > 0:\n                # Get the negative meshes from the features and convert them to nurbs\n                negative_brep_guids = draw_shapes_as_brep_get_guids(negative_shapes)\n\n                # Perform Boolean Difference\n                positive_breps = [rs.coercebrep(guid) for guid in positive_brep_guids]\n                negative_breps = [rs.coercebrep(guid) for guid in negative_brep_guids]\n\n                # Perform MergeCoplanarFaces before boolean to reduce chance of failure\n                [brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance) for brep in negative_breps]\n\n                vprint(\"negative_breps : %s\" % negative_breps)\n                # ! First attempt at boolean all objects together\n                boolean_result = rg.Brep.CreateBooleanDifference(positive_breps, negative_breps, TOL)\n\n                # ! Second attempt at boolean objects one by one\n                if boolean_result is None:\n                    vprint(\"WARNING: AssemblyNurbArtist draw_beam(%s) Group Boolean Failure\" % beam_id)\n                    pos = positive_breps\n                    for neg in negative_breps:\n                        pos = rg.Brep.CreateBooleanDifference(pos, [neg], TOL)\n                        if pos is None:\n                            vprint(\"WARNING: AssemblyNurbArtist draw_beam(%s) Iterative Boolean Failure\" % beam_id)\n                            break\n                    boolean_result = pos\n\n                if boolean_result is None:\n                    print(\"ERROR: AssemblyNurbArtist draw_beam(%s) Boolean All Failure\" % beam_id)\n                    # delete_objects(positive_brep_guids + negative_brep_guids, purge=True, redraw=False)\n                    # delete_objects(negative_brep_guids, purge=True, redraw=False)\n                    # [sc.doc.Objects.AddBrep(brep) for brep in negative_breps]\n                else:\n                    for brep in boolean_result:\n                        # Perform MergeCoplanarFaces after boolean to clean up\n                        brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance)\n                        # New guids from boolean results\n                        guid = add_brep(brep)\n                        if guid:\n                            guids.append(guid)\n\n                    # Delete the original boolean set geometries\n                    delete_objects(positive_brep_guids + negative_brep_guids, purge=True, redraw=False)\n            else:\n                guids = positive_brep_guids\n\n            # Rename newly created object with beam_id\n            for guid in guids:\n                obj = find_object(guid)\n                attr = obj.Attributes\n                attr.Name = beam_id\n                obj.CommitChanges()\n\n            # Save resulting guid(s) into guid dictionary and also return them\n            self.beam_guids(beam_id).extend(guids)\n\n            # Enable redraw\n            if redraw:\n                rs.EnableRedraw(True)\n\n        return guids\n\n    def draw_beam_at_position(self, beam_id, beam_position, delete_old=False, redraw=True, verbose=False):\n        # * Draws the beam at final position\n        guids = self.draw_beam(beam_id, delete_old=delete_old, redraw=False, verbose=verbose)\n\n        find_object = sc.doc.Objects.Find\n        for guid in guids:\n            obj = find_object(guid)\n\n            # Transform it to target location\n            t = self.assembly.get_beam_transformaion_to(beam_id, beam_position)\n            xform = xform_from_transformation(t)\n            sc.doc.Objects.Transform(obj, xform, True)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}