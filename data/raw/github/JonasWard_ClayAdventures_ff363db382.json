{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/v2/polylineClass.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/v2/polylineClass.py",
  "instruction": "polylineInterfaceClass",
  "code": "# polylineInterfaceClass\n\nimport Rhino.Geometry as rg\nfrom ghpythonlib.components import Area as gh_area\nimport math\n\nclass ClayPolyline(object):\n\n    def __init__(self, pt_set, closed = False):\n\n        self.pts = pt_set\n        self.closed = closed\n\n        self.cnt = len(self.pts)\n\n        self.has_crv_rep = False\n\n        self.tolerance = .01\n\n\n    def __add__(self, other):\n\n        if isinstance(other, list):\n\n            other = ClayPolyline(other)\n\n        return ClayPolyline(self.pts + other.pts)\n\n\n    def __updatePolyline__(self, new_set = None):\n\n        if not(new_set == None):\n        \n            self.pts = new_set\n\n        if self.has_crv_rep:\n\n            self.GetCurve()\n\n        self.cnt = len(self.pts)\n\n    @ staticmethod\n    def StartIndex(self):\n\n        return 0\n\n    @ staticmethod\n    def Start(self):\n\n        return self.pts[self.StartIndex]\n\n    @ staticmethod\n    def EndIndex(self):\n\n        return len(self.pts) - 1\n\n    @ staticmethod\n    def End(self):\n\n        return self.pts[self.EndIndex]\n\n\n    def GetLength(self):\n\n        if not(self.has_crv_rep):\n\n            self.GetCurve()\n\n        return self.crv_rep.GetLength()\n\n    def GetArea(self):\n\n        # this is a hack using the rhino grasshopper component\n        area, _ = gh_area(x)\n\n        return area\n\n    def Reverse(self):\n\n        self.__updatePolyline__(self.pts[::-1])\n\n\n    def GetCurve(self):\n\n        self.has_crv_rep = True\n\n        self.crv_rep = rg.Polyline(self.pts + self.Start if self.closed else self.pts).ToNurbsCurve()\n\n        return self.crv_rep\n\n\n    def ClosestPoint(self):\n\n        if not(self.has_crv_rep):\n\n            self.GetCurve()\n\n\n    def PointAtLength(self, val, return_index = False):\n\n        if val < 0.0:\n\n            print(\"you gave me a negative value, here is the first point\")\n\n            new_pt = self.Start\n            i = self.StartIndex\n\n        elif val > self.GetLength():\n\n            print(\"\"\"you gave me a value larger than the length of the curve /n\"\n            therefore I return you the last point!\"\"\")\n\n            new_pt = self.End\n            i = self.EndIndex\n\n        else:\n\n            length = 0.0\n\n            for i in range(self.StartIndex, self.EndIndex, 1):\n\n                pt_0 = self.pts[i]\n                pt_1 = self.pts[i + 1]\n\n                local_length = pt_0.DistanceTo(pt_1)\n\n                if length + local_length > val:\n\n                    break\n\n                else:\n\n                    length += local_length\n\n            new_pt = interpolatePts(pt_0, pt_1, val - length)\n\n        if return_index:\n\n            return new_pt, i\n\n        else:\n\n            return new_pt\n    \n    def ReaseamAt(self, value, index_or_length = \"index\"):\n\n        if self.closed:\n\n            if index_or_length == \"index\":\n\n                pl_a, pl_b = self.SplitAtIndex(value)\n\n    def SplitAtIndex(self, *indexes):\n\n        indexes = list(indexes).sort()\n        indexes.reverse()\n\n        pl_list = []\n\n        local_pt_list = self.pts[:]\n\n        for index in indexes:\n\n            end = math.floor(index)\n            start = math.ceil(index)\n\n            delta = index - end\n\n            if delta < self.tolerance:\n\n                # case that the polyline is very short\n\n                pass\n\n\n    def SplitAtLength(self, *lengths):\n\n        pass\n\n    def Orient(self):\n\n        if self.closed:\n            \n            \n\n        else:\n\n            print(\"I can not be oriented\")\n\n\n    def Shorten(self, length, side = \"start\"):\n\n        polyline_length = self.GetLength()\n\n        # length check:\n\n        length = abs(length)\n\n        half_pl_length = polyline_length * .5\n\n        if length > half_pl_length:\n\n            # reducing the length value to a mod of the polyline\n\n            length = length % half_pl_length\n\n        if side == \"start\" or side == \"both\":\n\n            new_pt, pt_index = self.PointAtLength(length, True)\n\n            self.__updatePolyline__([new_pt] + self.pts[pt_index + 1:])\n\n        if side == \"end\" or side == \"both\":\n\n            new_pt, pt_index = self.PointAtLength(polyline_length - length, True)\n\n            self.__updatePolyline__(self.pts[:pt_index] + [new_pt])\n\n    def RemoveIndex(self, *index_args):\n\n        indexes = list(index_args).sort()\n        indexes.reverse()\n\n        for index in indexes:\n\n            if index > len(self.pts):\n\n                print(\"You can only remove points at a certain index if that index is within the domain ...\")\n\n            else:\n\n                self.pts.pop(index)\n\n        self.__updatePolyline__()\n\n    def AddPoint(self, *pt_args):\n\n        self.pts += list(pt_args)\n\n        self.__updatePolyline__()\n\n    def Offset(self, *offset_args):\n\n        offset_set = []\n\n        for offset_val in offset_args:\n\n            offset_crv = self.crv_rep.Offset(pln, offset_val, .01, o_type)[0]\n            offset_crv = offset_crv.ToPolyline()\n\n        offset_set.append(offset_crv)\n\n        if len(offset_set) == 1:\n\n            return offset_set[0]\n\n        else:\n\n            return offset_set\n\n    def Close(self, collapse_distance = 1.0):\n\n        if not self.closed:\n\n            print(\"I have to be closed\")\n\n        if self.Start.DistanceTo(self.End) < collapse_distance:\n\n            print(\"& I have to collapse onto myself\")\n\n            self.RemoveIndex(self.cnt - 1)\n        \n\n\n\n    \n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}