{
  "source_url": "https://github.com/ThomasAn73/Rhino3D_scripts/blob/da372781a099dbc9a79973a5b101ede6bea6aed6/GearGen/GearFromCircle.py",
  "repo": "ThomasAn73/Rhino3D_scripts",
  "repo_stars": 6,
  "repo_description": "VB scripts for the Rhino3D modelling software",
  "license": "MIT",
  "filepath": "GearGen/GearFromCircle.py",
  "instruction": "GearFromCircle Python script by Thomas An 2020.09.08 https://developer.rhino3d.com/guides/rhinopython/ https://developer.rhino3d.com/api/RhinoScriptSyntax/ Script calculations were informed by: Technical Drawing With Engineering Graphics 14edition (Giesecke, Mitchell, Spencer, Hill, Dygdon, Novak, Lockhart)",
  "code": "#GearFromCircle Python script by Thomas An 2020.09.08\r\n#https://developer.rhino3d.com/guides/rhinopython/\r\n#https://developer.rhino3d.com/api/RhinoScriptSyntax/\r\n#Script calculations were informed by: Technical Drawing With Engineering Graphics 14edition (Giesecke, Mitchell, Spencer, Hill, Dygdon, Novak, Lockhart)\r\n\r\nimport rhinoscriptsyntax as rs, Rhino, math\r\n\r\n#CLASS SECTION==================================================================\r\nclass TypeGear:\r\n    def __init__(self):\r\n        self.epsilon      = rs.UnitAbsoluteTolerance()\r\n        self.curve        = None   #Holds the Rhino pitch curve object\r\n        self.crvLen       = None\r\n        self.isClosed     = None\r\n        self.isCircle     = None\r\n        self.PD           = 1.0    #Pitch diameter = given                      (propagate to -> MDL, BC, Tc)\r\n        self.PA           = 20.0   #Pressure angle = 14.5, 20.0, 25.0           (propagate to -> minN, BC, DED)\r\n        self.MDL          = 0.0588 #Module = PD / N                             (propagate to -> ADD, DED, OD, CP)\r\n        self.N            = 17     #Number of teeth                             (propagate to -> MDL, Tc)\r\n        self.maxN         = 1000\r\n        self.minN         = 17     #Min number of teeth (depends on pressure angle) -> 2/sin^2(PA*pi/180)\r\n        self.BC           = 0.9397 #Base circle = PD*cos(pi*PA/180). The bigger the pressure angle the further BC is to PD\r\n        self.ADD          = 0.0588 #Addendum = MDL\r\n        self.DED          = 0.0735 #Dedendum = 1.250*MDL use 1.157 for 14.5 PA  (propagate to -> RD)\r\n        self.OD           = 1.1176 #Outside diameter = PD+2*MDL\r\n        self.RD           = 0.8529 #Root diameter = PD-2*DED\r\n        self.Tc           = 0.0922 #Chordal thickness = PD*sin(pi/(2*N))\r\n        self.CP           = 0.1848 #Circular pitch = pi*MDL or crvLen/N          (propagate to -> MDL )\r\n        self.CA           = 0.0    #Cone angle (0 to 90)\r\n        self.origin       = None   #Pitch circle origin (world coordinates)\r\n        self.normal       = None   #The normal of the plane the gear is on (this 3D point assumes world 0,0,0 as the first vector point)\r\n        self.plane        = None   #The local plane where the gear is on. Origin of plane is set at center of gear.\r\n        self.smpl         = 5      #Involute point samples (3 to 40)\r\n        self.error        = False  #Setting this to true will cause exit without draw\r\n        self.show         = {\r\n          \"PitchCir\": False, \r\n          \"BCcircle\": False, \r\n          \"ODcircle\": False, \r\n          \"RDcircle\": False}\r\n        self.involute     = {\r\n          \"startAngle\" : None,\r\n          \"endAngle\"   : None,\r\n          \"angleMod\"   : None,\r\n          \"pointsLeft\" : [],\r\n          \"pointsRight\": [],\r\n          \"pointsTop\"  : [],\r\n          \"ptsLeftDed\" : [],\r\n          \"ptsRightDed\": []}        #points are stored in world coordinates\r\n    \r\n    #Internal methods ----------------------------------------------------------\r\n    \r\n    #Compute the involute parameters\r\n    def CalcInvolute(self):\r\n        self.involute[\"startAngle\"] = math.pi/2 + math.asin(self.Tc/self.PD) - self.PA*math.pi/180 + math.sqrt(math.pow(self.PD/self.BC,2) -1)\r\n        self.involute[\"endAngle\"]   = self.involute[\"startAngle\"] - math.sqrt( math.pow(self.OD/self.BC,2) -1)\r\n        self.involute[\"angleMod\"]   = math.sqrt(math.pow(self.RD/self.BC,2) -1) if (self.RD > self.BC) else 0 \r\n\r\n        loopStep = (self.involute[\"startAngle\"] - self.involute[\"angleMod\"] - self.involute[\"endAngle\"])/self.smpl\r\n        \r\n        #Compute the left and right involute points and store them into their arrays (in world coordinates)\r\n        for n in range(self.smpl+1):\r\n          involuteHeight = math.sqrt( math.pow(self.BC/2 ,2)*(math.pow( n*loopStep + self.involute[\"angleMod\"] ,2) + 1) )\r\n          involuteHeightAngle = self.involute[\"startAngle\"] - self.involute[\"angleMod\"] - n*loopStep + math.atan( n*loopStep +  self.involute[\"angleMod\"])\r\n      \r\n          samplePoint = self.CalcBevelPoint( [involuteHeight*math.cos(involuteHeightAngle), involuteHeight*math.sin(involuteHeightAngle), 0] )\r\n          samplePtMir = [-samplePoint[0],samplePoint[1],samplePoint[2]] #Mirror about the Y-axis\r\n          self.involute[\"pointsLeft\"].append(rs.XformCPlaneToWorld(samplePoint, self.plane))\r\n          self.involute[\"pointsRight\"].append(rs.XformCPlaneToWorld(samplePtMir,self.plane))\r\n        \r\n        #Compute the top arc points and store them in their array (in world coordinates)\r\n        midTopPoint = self.CalcBevelPoint([0,self.OD/2,0])\r\n        self.involute[\"pointsTop\"].append(self.involute[\"pointsLeft\"][-1])\r\n        self.involute[\"pointsTop\"].append(self.involute[\"pointsRight\"][-1])\r\n        self.involute[\"pointsTop\"].append(rs.XformCPlaneToWorld(midTopPoint,self.plane))\r\n           \r\n        #Compute the line segments for the dedendum\r\n        if (self.RD < self.BC):\r\n          samplePoint = self.CalcBevelPoint( [self.RD/2 * math.cos(self.involute[\"startAngle\"]), self.RD/2 * math.sin(self.involute[\"startAngle\"]), 0] )\r\n          samplePtMir = [-samplePoint[0],samplePoint[1],samplePoint[2]] #Mirror about the Y-axis\r\n          self.involute[\"ptsLeftDed\"].append(self.involute[\"pointsLeft\"][0])\r\n          self.involute[\"ptsLeftDed\"].append(rs.XformCPlaneToWorld(samplePoint,self.plane))\r\n          self.involute[\"ptsRightDed\"].append(self.involute[\"pointsRight\"][0])\r\n          self.involute[\"ptsRightDed\"].append(rs.XformCPlaneToWorld(samplePtMir,self.plane))\r\n\r\n    #Receives a 3Dpoint and tilts it by some angle\r\n    def CalcBevelPoint (self, oldPoint):\r\n        if (self.CA == 0): return oldPoint\r\n        \r\n        newPoint    = [0,0,0]\r\n        delta       = [0,0]\r\n        delta[1]    = math.sqrt( oldPoint[0]*oldPoint[0] + oldPoint[1]*oldPoint[1] ) - self.PD/2\r\n        newPoint[2] = delta[1] * math.sin( self.CA * math.pi/180 )\r\n        delta[0]    = delta[1] * math.cos( self.CA * math.pi/180 )\r\n        newPoint[0] = (self.PD/2+delta[0]) / (self.PD/2+delta[1]) * oldPoint[0]\r\n        newPoint[1] = (self.PD/2+delta[0]) / (self.PD/2+delta[1]) * oldPoint[1]\r\n        return newPoint\r\n        \r\n    #Set methods ---------------------------------------------------------------\r\n    def SetPlanarCurve(self, type=\"Any\", guid=None):\r\n        if (type==\"Any\"): prompt = \"Select a planar pitch curve\" \r\n        elif (type==\"Circle\"): prompt = \"Select the pitch circle\"\r\n        \r\n        newCurve = rs.GetCurveObject(prompt, True, True) if guid is None else [guid]\r\n        if (newCurve is None): Rhino.RhinoApp.WriteLine(\"Exit: No curve was selected\"); return False\r\n        isPlanar = rs.IsCurvePlanar(newCurve[0])\r\n        if (isPlanar == False): newCurve = None; Rhino.RhinoApp.WriteLine(\"Exit: Selected curve was not planar\"); return False\r\n\r\n        self.curve = newCurve #Accept the curve into the object because the curve exists and it is planar\r\n        self.isClosed = rs.IsCurveClosed(self.curve[0])\r\n        self.normal = rs.CurveNormal(self.curve[0]) #For non planar curves the script already exited.\r\n        \r\n        self.isCircle = rs.IsCircle(self.curve[0])\r\n        if (type==\"Circle\" and self.isCircle != True): Rhino.RhinoApp.WriteLine(\"Exit: Selected curve was not a circle\"); return False\r\n\r\n        self.crvLen = rs.CurveLength(self.curve[0])\r\n        if (self.isCircle == True): \r\n          Rhino.RhinoApp.WriteLine(\"Selected: Circle\")\r\n          self.origin=rs.CircleCenterPoint(self.curve[0])\r\n          self.plane = rs.PlaneFromNormal(self.origin, self.normal, rs.CurveStartPoint(self.curve[0])-self.origin) #PlaneFromNormal(origin, normal, xaxis=None)\r\n          self.SetPD() #Propagate the value updates\r\n          self.SetBC() #Propagate the value updates\r\n          return \r\n        if (self.isClosed == True): Rhino.RhinoApp.WriteLine(\"Selected: Closed non-circular planar curve\"); return\r\n        else: Rhino.RhinoApp.WriteLine(\"Selected: Open planar curve\")\r\n    \r\n    #Set Pitch Diameter\r\n    def SetPD(self, newPD=None):\r\n        if (newPD is None and not self.isCircle): return #nothing to do\r\n        if (newPD is None and self.isCircle): newPD = 2*rs.CircleRadius(self.curve[0]) #simple update/refresh of values\r\n        if (newPD <= 0.0): Rhino.RhinoApp.WriteLine(\"Exit: Invalid Pitch Diameter\"); return #nothing to do\r\n        if (newPD == self.PD): return #Nothing to do\r\n        \r\n        self.PD = float(newPD)\r\n        self.SetMDL(); self.SetBC(); self.SetTc()  #Propagate values refresh\r\n    \r\n    #Set Base circle\r\n    def SetBC(self, newBC=None):\r\n        if (newBC is None): self.BC = self.PD*math.cos(math.pi*self.PA/180); return #simple update/refresh of values\r\n        if (newBC == self.BC): return #Nothing to do\r\n    \r\n    #Set Module\r\n    def SetMDL(self, newMDL=None):\r\n        if (newMDL is None): self.MDL = self.PD/self.N; self.SetADD(); self.SetDED(); self.SetOD(); self.SetCP(); return #simple update/refresh of values and propagate\r\n        if (newMDL<=0): Rhino.RhinoApp.WriteLine(\"Module cannot be less than or 0.0\"); return #Nothing to do\r\n        if (newMDL==self.MDL): return #Nothing to do\r\n        \r\n        maxMDL  = self.PD/self.minN #so that gear teeth do not drop bellow min when preserving PitchCircle\r\n        minMDL  = self.PD/self.maxN #so that gear teeth do not rise above max when preserving PitchCircle\r\n        newN    = self.PD/newMDL    #the number of teeth needed with this new module\r\n        newNint = int(round(newN,0))\r\n        if (newMDL<minMDL or newMDL>maxMDL): self.SetPD(newMDL*self.N); return #Preserve the teeth by default\r\n        \r\n        #if the module value is within the min and max range then there is ambiguity about whether to preserve the PD or N in the expression\r\n        #Ask the user\r\n        Rhino.RhinoApp.WriteLine(\"[CurrentTeeth = \"+str(self.N)+\"]. [PitchCircleSize fits \"+str(newNint)+\" teeth]. Either option affects pitch diameter\")\r\n        strPromptMDL = \"Prefer\"\r\n        strOption1   = \"CurrentTeeth\"    #Preserve original teeth number and keep the exact module\r\n        strOption2   = \"PitchCircleSize\" #Preserve the new integer teeth number and keep the exact module\r\n        strPrommptMDLoptions = [strOption1,strOption2]\r\n        strPreservePick = rs.GetString(strPromptMDL,strPrommptMDLoptions[0],strPrommptMDLoptions)\r\n        \r\n        if(strPreservePick==strOption1): self.SetPD(newMDL*self.N); return #the newMDL value will be kept and stored after PD propagation\r\n        if(strPreservePick==strOption2): self.SetN(newN); self.SetPD(newMDL*newNint); return #the MDL value will be kept and stored after PD propagation\r\n        #if(strPreservePick==\"PitchCircle\"): self.SetN(newN); return #the newMDL value will be altered after N propagation\r\n        \r\n    def SetN(self, newN=None):\r\n        if (newN is None or newN==self.N): return #nothing to do\r\n        if (newN>self.maxN or newN<self.minN): Rhino.RhinoApp.WriteLine(\"Teeth number out of bounds: (\"+str(self.minN)+\" to \"+str(self.maxN)+\")\"); return\r\n        if (newN == self.N): return #Nothing to do\r\n        self.N = int(round(newN,0))\r\n        self.SetTc()\r\n        self.SetMDL() #Propagate values refresh\r\n     \r\n    #Set Addendum\r\n    def SetADD(self, newADD=None):\r\n        if (newADD is None): self.ADD = self.MDL; return #simple update/refresh of values\r\n        if (newADD == self.ADD): return #Nothing to do\r\n    \r\n    #Set Deddendum\r\n    def SetDED(self, newDED=None):\r\n        if (newDED is None): self.DED = 1.250*self.MDL if self.PA>14.5 else 1.157*self.MDL; self.SetRD(); return #simple update/refresh of values and propagate\r\n        if (newDED == self.DED): return #Nothing to do\r\n    \r\n    #Set Root Diameter\r\n    def SetRD(self, newRD=None):\r\n        if (newRD is None): self.RD = self.PD-2*self.DED; return #simple update/refresh of values\r\n        if (newRD == self.RD): return #Nothing to do\r\n    \r\n    #Set Outside Diameter\r\n    def SetOD(self, newOD=None):\r\n        if (newOD is None): self.OD = self.PD+2*self.MDL; return #simple update/refresh of values\r\n        if (newOD == self.OD): return #Nothing to do\r\n    \r\n    #Set Circular Pitch\r\n    def SetCP(self, newCP=None):\r\n        if (newCP is None): self.CP = math.pi*self.MDL; return #simple update/refresh of values\r\n        if (newCP<=0): Rhino.RhinoApp.WriteLine(\"Circular Pitch cannot be less than or 0.0\"); return #Nothing to do\r\n        if (newCP==self.CP): return #Nothing to do\r\n        \r\n        self.SetMDL(newCP/math.pi) #Actual CP value will change inside the MDL method\r\n    \r\n    #Set Chordal Thickness\r\n    def SetTc(self, newTc=None):\r\n        if (newTc is None): self.Tc = self.PD*math.sin(math.pi/(2*self.N)); return #simple update/refresh of values\r\n        if (newTc == self.Tc): return #Nothing to do\r\n    \r\n    #Set Cone angle\r\n    def SetCA(self, newCA=None):\r\n        if (newCA is None or newCA == self.CA): return #Nothing to do\r\n        if (newCA<0 or newCA>90): Rhino.RhinoApp.WriteLine(\"Gear teeth cone-angle out of range (0-90deg)\"); return\r\n        self.CA = newCA\r\n    \r\n    #Set Tooth involute curve point count\r\n    def Setsmpl(self, newsmpl=None):\r\n        if (newsmpl is None or newsmpl == self.smpl): return #Nothing to do\r\n        if (newsmpl<3 or newsmpl>40): Rhino.RhinoApp.WriteLine(\"Involute curve point count out of range (range: 3-40samples)\"); return\r\n        self.smpl = newsmpl\r\n    \r\n    #Set Pressure angle\r\n    def SetPA(self, newPA=None):\r\n        PAchoices = (14.5,20.0,25.0)\r\n        if (newPA is None or newPA==self.PA): return #Nothing to do (PA is not computed from anything else)\r\n        if (newPA == self.PA): return #Nothing to do\r\n        if (not newPA in PAchoices): Rhino.RhinoApp.WriteLine(\"Pressure angle was not one of these\"+str(PAchoices)); return\r\n        self.PA = newPA\r\n        self.SetminN(); self.SetBC(); self.SetDED() #Propagate changes\r\n        \r\n    #Set Min number of teeth\r\n    def SetminN(self, newminN=None):\r\n        absoluteMin = int(2/(math.sin(self.PA*math.pi/180)**2));\r\n        if (newminN is None): self.minN = absoluteMin; return #simple update/refresh of values\r\n        if (newMin == self.minN): return #Nothing to do\r\n        if (newMin < absoluteMin or newMin>maxN-1): Rhino.RhinoApp.WriteLine(\"Chosen minimum teeth number is out of range (\"+str(absoluteMin)+\", \"+str(self.maxN)+\")\"); return\r\n        self.minN = newMin\r\n\r\n    def SetError(self):\r\n        self.error = True\r\n    \r\n    #Get methods\r\n    def GetSummary(self):\r\n        infoStr  = 'Summary: '\r\n        infoStr += '[Pitch Diam='+str(round(self.PD,3))+'] '\r\n        infoStr += '[Teeth='+str(int(self.N))+'] '\r\n        infoStr += '[Module='+str(round(self.MDL,3))+'] '\r\n        infoStr += '[CircPitch='+str(round(self.CP,3))+', ToothThickness='+str(round(self.Tc,3))+'] '\r\n        infoStr += '[Pressure angle='+str(round(self.PA,1))+'] '\r\n        infoStr += '[Bevel angle='+str(round(self.CA,1))+'] '\r\n        infoStr += '[Samples='+str(int(self.smpl))+']'\r\n        \r\n        Rhino.RhinoApp.WriteLine(infoStr)\r\n    \r\n    def GetFullInfo(self):\r\n        infoStr  = 'Curve is closed = '+str(self.isClosed)+'\\n'\r\n        infoStr += 'Curve is circle = '+str(self.isCircle)+'\\n'\r\n        infoStr += 'Pitch diameter = '+str(self.PD)+'\\n'\r\n        infoStr += 'Pressure angle = '+str(self.PA)+'\\n'\r\n        infoStr += 'Module = '+str(self.MDL)+'\\n'\r\n        infoStr += 'Number of teeth = '+str(self.N)+'\\n'\r\n        infoStr += 'Max number of teeth = '+str(self.maxN)+'\\n'\r\n        infoStr += 'Min number of teeth = '+str(self.minN)+'\\n'\r\n        infoStr += 'Base circle diameter = '+str(self.BC)+'\\n'\r\n        infoStr += 'Addendum = '+str(self.ADD)+'\\n'\r\n        infoStr += 'Dedendum = '+str(self.DED)+'\\n'\r\n        infoStr += 'Outside diamter = '+str(self.OD)+'\\n'\r\n        infoStr += 'Root diameter = '+str(self.RD)+'\\n'\r\n        infoStr += 'Chordal thickness = '+str(self.Tc)+'\\n'\r\n        infoStr += 'Circular pitch = '+str(self.CP)+'\\n'\r\n        infoStr += 'Cone angle = '+str(self.CA)+'\\n'\r\n        \r\n        rs.MessageBox(infoStr)\r\n    \r\n    #Draw the gear on the Rhino viewport\r\n    def Draw(self):\r\n      if (self.error == True): return #Nothing to do\r\n      self.CalcInvolute()\r\n      \r\n      rs.EnableRedraw(False)\r\n      #Show various gear related circles on the viewport\r\n      if (self.show[\"PitchCir\"]==True or math.fabs(self.PD/2 - rs.CircleRadius(self.curve[0])) > self.epsilon): rs.SelectObject(rs.AddCircle(self.plane,self.PD/2)) #if the pitch circle has changed --> show it\r\n      if (self.show[\"BCcircle\"]==True): rs.SelectObject(rs.AddCircle(self.plane,self.BC/2))\r\n      if (self.show[\"ODcircle\"]==True): rs.SelectObject(rs.AddCircle(self.plane,self.OD/2))\r\n      if (self.show[\"RDcircle\"]==True): rs.SelectObject(rs.AddCircle(self.plane,self.RD/2))\r\n      \r\n      #Make the first gear tooth\r\n      #Note: (gearTooth is an array of curve IDs [left involute, right involute, top arc, leftDedendumLine, RightDedendumLine])\r\n      gearTooth = [rs.AddInterpCurve(self.involute[\"pointsLeft\"],3,1), rs.AddInterpCurve(self.involute[\"pointsRight\"],3,1)]\r\n      gearTooth.append(rs.AddArc3Pt(self.involute[\"pointsTop\"][0], self.involute[\"pointsTop\"][1], self.involute[\"pointsTop\"][2]))\r\n      if (len(self.involute[\"ptsLeftDed\"])>0): gearTooth.append(rs.AddLine(self.involute[\"ptsLeftDed\"][0], self.involute[\"ptsLeftDed\"][1]) )\r\n      if (len(self.involute[\"ptsRightDed\"])>0): gearTooth.append(rs.AddLine(self.involute[\"ptsRightDed\"][0], self.involute[\"ptsRightDed\"][1]) )\r\n      \r\n      #Join all curves of the first tooth and add it in the wholeGear array\r\n      wholeGear = [rs.JoinCurves(gearTooth, True)[0],[]] #contains the first tooth and space for its right root arc\r\n      \r\n      #Create a datum point (in local coordinates) on the root circle and to the right of the first gear tooth\r\n      #This becomes the seed for all midPoints of the root arcs\r\n      datumPoint = rs.VectorRotate([0, self.RD/2, 0], -180/self.N, [0,0,1]) #VectorRotate works in degrees\r\n      \r\n      #Loop through each gear tooth\r\n      for n in range(1, self.N+1):\r\n        \r\n        #Compute the midpoint of the root arc\r\n        midPoint = rs.VectorRotate(datumPoint, n*360/self.N, [0,0,1]) #local coordinates\r\n        midPoint = rs.XformCPlaneToWorld(self.CalcBevelPoint(midPoint), self.plane) #world coordinates\r\n        \r\n        if (n < self.N):\r\n          wholeGear.append( rs.RotateObject(wholeGear[0], self.plane[0], n*360/self.N, self.plane[3], True) ) #Rotate and copy (in world coordinates) \r\n          wholeGear.append( rs.AddArc3Pt(rs.CurveEndPoint(wholeGear[-1]), rs.CurveStartPoint(wholeGear[-3]), midPoint) )  #AddArc3Pt(start, end, point_on_arc)\r\n        else:\r\n          wholeGear[1] = ( rs.AddArc3Pt(rs.CurveEndPoint(wholeGear[0]), rs.CurveStartPoint(wholeGear[-2]), midPoint) )  \r\n      \r\n      #Join the all the gear curves together\r\n      wholeGear = rs.JoinCurves(wholeGear, True)[0]\r\n      rs.UnselectObject(self.curve[0])\r\n      rs.SelectObject(wholeGear)\r\n      rs.EnableRedraw(True)\r\n\r\n#FUNCTIONS SECTION==============================================================\r\n#User input---------------------------------------------------------------------\r\ndef UserInput(gear):\r\n\r\n    #Get a circle curve from the user\r\n    if (gear.SetPlanarCurve(\"Circle\")==False): gear.SetError(); return\r\n\r\n    strMainMenu = \"Main menu\"\r\n    strMainOptions = [\"Teeth\", \"Module\", \"Pitch\", \"PressureAngle\", \"BevelAngle\", \"Accuracy\"]\r\n    \r\n    while True:\r\n      gear.GetSummary();\r\n      strMainMenuPick = rs.GetString(strMainMenu,None,strMainOptions)\r\n\r\n      if (strMainMenuPick == \"Teeth\"): \r\n        strPrompt = \"Number of teeth (\"+str(gear.minN)+\" to \"+str(gear.maxN)+\")\"\r\n        teethCount = rs.GetInteger(strPrompt, gear.N, gear.minN, gear.maxN)\r\n        gear.SetN(teethCount)\r\n        continue\r\n      if (strMainMenuPick == \"Module\"):\r\n        maxMDL = gear.PD/gear.minN #so that gear teeth do not drop bellow min\r\n        minMDL = gear.PD/gear.maxN #so that gear teeth do not rise above max\r\n        Rhino.RhinoApp.WriteLine(\"Module must be within range [\"+str(round(minMDL,4))+\", \"+str(round(maxMDL,4))+\"] otherwise the PitchCircle will be affected\")\r\n        fltPrompt = \"Gear Module (PitchDia/Teeth)\"\r\n        module = rs.GetReal(fltPrompt,gear.MDL)\r\n        gear.SetMDL(module)\r\n        continue\r\n      if (strMainMenuPick == \"Pitch\"):\r\n        maxCP = math.pi*gear.PD/gear.minN #so that gear teeth do not drop bellow min\r\n        minCP = math.pi*gear.PD/gear.maxN #so that gear teeth do not rise above max\r\n        Rhino.RhinoApp.WriteLine(\"The current pitch-circle can support pitch in the range [\"+str(round(minCP,4))+\", \"+str(round(maxCP,4))+\"] otherwise the PitchCircle will be affected\")\r\n        fltPrompt = \"Circular Pitch (tooth to tooth)\"\r\n        pitch = rs.GetReal(fltPrompt,gear.CP)\r\n        gear.SetCP(pitch)\r\n        continue\r\n      if (strMainMenuPick == \"PressureAngle\"):\r\n        strPAprompt = \"Pressure angle choices (low = 14.5, mid = 20.0, high = 25.0)\"\r\n        strPAoptions = [\"low\",\"mid\",\"high\"]\r\n        PAchoice = rs.GetString (strPAprompt,strPAoptions[1],strPAoptions) #Rhino.GetOption(strPAprompt,strPAoptions[1],strPAoptions)\r\n        if (PAchoice==\"low\"): PAchoice=14.5\r\n        elif (PAchoice==\"mid\"): PAchoice=20.0\r\n        elif (PAchoice==\"high\"): PAchoice=25.0\r\n        gear.SetPA(PAchoice)\r\n        continue\r\n      if (strMainMenuPick == \"BevelAngle\"):\r\n        strPrompt = \"Gear teeth cone angle (0\"+u'\\xb0'+\" - 90\"+ u'\\xb0'+\")\"\r\n        bevelChoice = rs.GetInteger(strPrompt, gear.CA, 0, 90)\r\n        gear.SetCA(bevelChoice)\r\n        continue\r\n      if (strMainMenuPick == \"Accuracy\"):\r\n        strPrompt = \"Tooth involute curve point count (3-40samples)\"\r\n        curveSamples = rs.GetInteger(strPrompt, gear.smpl, 3, 40)\r\n        gear.Setsmpl(curveSamples)\r\n        continue\r\n      if (strMainMenuPick == \"\"):\r\n        break\r\n      if (strMainMenuPick is None):\r\n        Rhino.RhinoApp.WriteLine (\"Script Aborted\")\r\n        gear.error = True;\r\n        break\r\n\r\n#MAIN function------------------------------------------------------------------\r\ndef GearFromCircle():\r\n    gear = TypeGear() #Gear object\r\n    UserInput(gear)   #Collect user choices for the gear\r\n    gear.Draw()       #Draw the involute gear on the Rhino viewport\r\n    \r\n    #Wrap up\r\n    if (gear.error == False):\r\n      Rhino.RhinoApp.WriteLine (\"Script completed successfully\")\r\n      gear.GetSummary()\r\n\r\n#RUN program\r\nGearFromCircle()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}