{
  "source_url": "https://github.com/969flash/FindSimilarLot/blob/688087497328cb355752c24f637ee6523b19a537/main.py",
  "repo": "969flash/FindSimilarLot",
  "repo_stars": 0,
  "repo_description": "유사한 형태의 필지를 찾는다.",
  "license": "unknown",
  "filepath": "main.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Optional\nexcept ImportError:\n    pass\n\nimport functools\nimport Rhino.Geometry as geo  # ignore\nimport ghpythonlib.components as ghcomp  # ignore\nfrom tqdm import tqdm\n\nimport utils\n\n# 모듈 새로고침\nimport importlib\n\nimportlib.reload(utils)\n\nBIGNUM = 100000\n\n\nclass Lot:\n    def __init__(self, crv: geo.Curve, record: List[str]):\n        self.crv = crv\n        self.record = record\n        result = geo.AreaMassProperties.Compute(crv)\n        self.area = result.Area\n        self.centroid = result.Centroid\n\n    def __repr__(self):\n        return f\"Lot(area={self.area})\"\n\n    def __lt__(self, other):\n        return self.area < other.area\n\n    def __eq__(self, other):\n        return self.area == other.area\n\n\ndef is_similar(base: Lot, other: Lot, tol: float = 0.2):\n    \"\"\"\n    두 Curve를 중심점 정렬 후, offset 기반 교차 여부로 유사성 판단\n    \"\"\"\n\n    # 1. 평행이동 벡터 계산 (other을 base 중심으로 정렬)\n    move_vector = geo.Vector3d(base.centroid - other.centroid)\n    aligned_other = other.crv.DuplicateCurve()\n    aligned_other.Translate(move_vector)\n\n    # 2. base offset 수행\n    offset_result = utils.Offset().polyline_offset(base.crv, tol, BIGNUM)\n    if not offset_result.holes or not offset_result.contour:\n        return False\n\n    offset_bases = [offset_result.holes[0], offset_result.contour[0]]\n\n    # 3. 안팎으로 offset 영역과 정렬된 other이 교차하는지 확인\n    intersects = any(\n        geo.Curve.PlanarCurveCollision(\n            offset_base, aligned_other, geo.Plane.WorldXY, 0.01\n        )\n        for offset_base in offset_bases\n    )\n\n    return not intersects  # 교차하지 않으면 유사하다고 판단\n\n\ndef find_all_groups(lots: List[Lot]) -> List[List[Lot]]:\n    visited = set()\n    groups = []\n\n    for i, base in tqdm(enumerate(lots), total=len(lots), desc=\"유사 필지 그룹화\"):\n        if i in visited:\n            continue\n\n        group = [base]\n        visited.add(i)\n\n        for j, other in enumerate(lots):\n            if j == i or j in visited:\n                continue\n            try:\n                if utils.is_similar(base, other):\n                    print(f\"[find_all_groups] {i}과 {j} 유사 필지 발견\")\n                    group.append(other)\n                    visited.add(j)\n            except Exception as e:\n                print(f\"[find_all_groups 오류] {i}-{j} 비교 중 오류: {e}\")\n\n        groups.append(group)\n\n    return groups\n\n\ndef cluster_lots_by_area(\n    lots: List[Lot], bin_size: int\n) -> Dict[Tuple[int, int], List[Lot]]:\n\n    clusters = {}\n    for idx, lot in enumerate(lots):\n        bin_idx = int(lot.area // bin_size)\n        start = bin_idx * bin_size\n        end = start + bin_size\n        key = (start, end)\n        clusters.setdefault(key, []).append(lots[idx])\n\n    return clusters\n\n\n# --- 실행 영역 ---\n# lot_crvs: Rhino.Geometry.Curve 객체 리스트가 여기에 있어야 함\nlots = [Lot(curve, record) for curve, record in zip(lot_crvs, records)]\n\nclusters = cluster_lots_by_area(lots, bin_size=5)\n\n# 상위 10개 클러스터 출력\ntop_clusters = sorted(clusters.items(), key=lambda x: len(x[1]), reverse=True)[:10]\nfor i, (key, lot_list) in enumerate(top_clusters, 1):\n    print(f\"{i}. 구간 {key}: {len(lot_list)}개 필지\")\n\n# 가장 큰 클러스터에서 유사 그룹 탐색\ntarget_cluster = top_clusters[0][1]\nresult = find_all_groups(target_cluster)\n\n# 가장 큰 유사 그룹 출력\nlargest_group = max(result, key=lambda g: len(g))\nprint(f\"\\n가장 큰 유사 그룹: {len(largest_group)}개 필지\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}