{
  "source_url": "https://github.com/M-Jafarkhani/LabCourseAI/blob/7dfca840b9f213e2ac7e31bc7893f11236b11560/FinalProject/SyntheticDataset/building_generator.py",
  "repo": "M-Jafarkhani/LabCourseAI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "FinalProject/SyntheticDataset/building_generator.py",
  "instruction": "Building Generator",
  "code": "\"\"\"Building Generator\"\"\"\n\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\nimport random\nimport math\n\nclass Building:\n    class Building:\n    \"\"\"\n    Procedural Building Generator for Rhino/Grasshopper\n\n    This class generates a randomized building geometry using procedural methods, tailored for use\n    within Rhino/Grasshopper via the RhinoCommon geometry library. It provides methods to generate \n    the site, building volume, storeys, slabs, walls, and columns, producing valid Brep objects \n    and DataTrees suitable for parametric workflows.\n\n    Attributes:\n        site (rg.Polyline or None): Polyline representing the building site.\n        volume (rg.Brep or None): The main building volume as a Brep.\n        storeys (list[rg.Brep]): Breps for each building storey.\n        slabs (list[rg.Brep]): Breps for all slabs (floor, intermediate, roof).\n        floor_slab (rg.Brep or None): Ground floor slab Brep.\n        roof_slab (rg.Brep or None): Roof slab Brep.\n        walls (list[list[rg.Brep]]): Nested list of wall Breps per storey.\n        columns (list[list[rg.Brep]]): Nested list of column Breps per storey.\n\n    Main Parameters (private):\n        __target_area (float): Desired site area (m²).\n        __min_length (float): Minimum side length for site and rectangles.\n        __area_tolerance (float): Allowed deviation for site area.\n        __min_height, __max_height (float): Min/max building height (m).\n        __slab_thickness (float): Slab thickness (randomized per building).\n        __min_wall_thickness, __max_wall_thickness (float): Wall thickness range (m).\n        __max_wall_tilt_deg (float): Maximum wall tilt angle (degrees).\n        __site_margin (float): Margin for offsetting site interior (m).\n\n    Methods:\n        generate_site(max_attempts=100): Creates a rectangular site polyline close to the target area.\n        generate_volume(): Lofts between random base/roof curves to form the building volume.\n        generate_storeys(): Splits volume into storeys by intersection with extruded planes.\n        generate_slabs(): Generates slabs for each level and roof.\n        generate_walls(): Produces 1–2 random wall Breps per storey as DataTree.\n        generate_columns(): Creates 1–3 column Breps per storey as DataTree.\n        to_gh_tree(nested_list): Utility to convert nested lists to Grasshopper DataTrees.\n\n    Usage:\n        Instantiate the class, call generation methods in sequence to procedurally construct\n        a randomized building, then access the attributes for geometry output.\n        \n        Example:\n            bldg = Building()\n            bldg.generate_site()\n            bldg.generate_volume()\n            bldg.generate_storeys()\n            bldg.generate_slabs()\n            bldg.generate_walls()\n            bldg.generate_columns()\n    \"\"\"\n    \n    def __init__(self):\n        # --- Site and area parameters ---\n        self.__target_area = 300.0         # Target site area in m²\n        self.__min_length = 12.0           # Minimum site side length in meters\n        self.__area_tolerance = 1.0        # Allowed deviation from target area\n\n        # --- Building height parameters ---\n        self.__min_height = 8.0            # Minimum building height (m)\n        self.__max_height = 20.0           # Maximum building height (m)\n        self.__height = None               # Actual building height (set later)\n\n        # --- Slab parameters ---\n        self.__min_slab_thickness = 0.15   # Minimum slab thickness (m)\n        self.__max_slab_thickness = 0.35   # Maximum slab thickness (m)\n        self.__slab_thickness = random.uniform(\n            self.__min_slab_thickness, self.__max_slab_thickness\n        )                                  # Random slab thickness for this building\n\n        self.floor_slab = None             # Ground floor slab Brep\n        self.slabs = []                    # Intermediate slab Breps\n        self.roof_slab = None              # Roof slab Brep\n\n        # --- Wall parameters ---\n        self.__min_wall_thickness = 0.15   # Minimum wall thickness (m)\n        self.__max_wall_thickness = 0.35   # Maximum wall thickness (m)\n        self.__max_wall_tilt_deg = 5.0     # Maximum wall tilt in degrees\n\n        self.walls = []                    # List of lists of wall Breps (per storey)\n\n        # --- Site and volume geometry ---\n        self.site = None                   # Site polyline\n        self.__site_margin = 3.0           # Margin for offsetting inside site (m)\n        self.volume = None                 # Building volume Brep\n\n    def generate_site(self, max_attempts=100):\n        \"\"\"\n        Generates a rectangular site polyline with area close to the target.\n        Returns the site polyline or None if not successful.\n        \"\"\"\n        for _ in range(max_attempts):\n            # Randomly choose width, then compute height to match target area\n            width = random.uniform(self.__min_length, self.__target_area / self.__min_length)\n            height = self.__target_area / width\n            if height >= self.__min_length:\n                area = width * height\n                # Check if area is within tolerance\n                if abs(area - self.__target_area) <= self.__area_tolerance:\n                    # Create closed rectangular polyline\n                    self.site = rg.Polyline([\n                        rg.Point3d(0, 0, 0),\n                        rg.Point3d(width, 0, 0),\n                        rg.Point3d(width, height, 0),\n                        rg.Point3d(0, height, 0),\n                        rg.Point3d(0, 0, 0)\n                    ])\n                    return self.site\n        # Return None if no valid site found\n        return None\n\n    def __random_rectangle_in_site(self, z=0.0, max_attempts=1000):\n        \"\"\"\n        Generates a random rectangle (with jittered corners) inside the site boundary at elevation z.\n        Returns either a Polyline or a periodic interpolated Curve.\n        \"\"\"\n        # Offset the site curve inward to define a safe region for the rectangle\n        site_crv = rg.PolylineCurve(self.site).Offset(\n            rg.Plane.WorldXY, -self.__site_margin, 0.01, rg.CurveOffsetCornerStyle.Sharp\n        )[0]\n        bbox = site_crv.GetBoundingBox(True)\n\n        for _ in range(max_attempts):\n            # Randomly choose rectangle size within bounding box limits\n            max_width = bbox.Max.X - bbox.Min.X\n            max_height = bbox.Max.Y - bbox.Min.Y\n            width = random.uniform(self.__min_length, max_width * 0.8)\n            height = random.uniform(self.__min_length, max_height * 0.8)\n\n            # Randomly choose lower-left corner\n            x = random.uniform(bbox.Min.X, bbox.Max.X - width)\n            y = random.uniform(bbox.Min.Y, bbox.Max.Y - height)\n\n            # Define rectangle corner points\n            rect_pts = [\n                rg.Point3d(x, y, z),\n                rg.Point3d(x + width, y, z),\n                rg.Point3d(x + width, y + height, z),\n                rg.Point3d(x, y + height, z)\n            ]\n\n            # Apply jitter to each corner for irregularity\n            jitter_range = 0.1 * min(width, height)\n            jittered_pts = [\n                rg.Point3d(pt.X + random.uniform(-jitter_range, jitter_range),\n                           pt.Y + random.uniform(-jitter_range, jitter_range),\n                           z)\n                for pt in rect_pts\n            ]\n            jittered_pts.append(jittered_pts[0])  # Close the loop\n\n            # Ensure all points are inside the offset site curve\n            if all(site_crv.Contains(p, rg.Plane.WorldXY, 0.01) == rg.PointContainment.Inside for p in jittered_pts):\n                # Randomly return either a Polyline or a periodic interpolated curve\n                if random.random() < 0.5:\n                    return rg.Polyline(jittered_pts)\n                else:\n                    curve = rg.Curve.CreateInterpolatedCurve(jittered_pts[:-1], 3)\n                    return rg.Curve.CreatePeriodicCurve(curve)\n        return None\n\n    def generate_volume(self):\n        \"\"\"\n        Generates the main building volume by lofting between a random base and roof curve\n        (either polyline or spline), both contained within the site boundary.\n        Sets self.__height and self.volume.\n        Returns the resulting Brep or None if unsuccessful.\n        \"\"\"\n        if not self.site:\n            return None\n\n        # Generate random base and roof curves (can be polyline or spline)\n        base = self.__random_rectangle_in_site(z=0.0)\n        self.__height = random.uniform(self.__min_height, self.__max_height)\n        roof = self.__random_rectangle_in_site(z=self.__height)\n\n        if not base or not roof:\n            return None\n\n        # Ensure both are curves (convert polylines if needed)\n        base_crv = base if isinstance(base, rg.Curve) else rg.PolylineCurve(base)\n        roof_crv = roof if isinstance(roof, rg.Curve) else rg.PolylineCurve(roof)\n\n        # Loft between base and roof to create the main volume\n        loft = rg.Brep.CreateFromLoft(\n            [base_crv, roof_crv],\n            rg.Point3d.Unset,\n            rg.Point3d.Unset,\n            rg.LoftType.Normal,\n            False\n        )\n\n        if loft and len(loft) > 0:\n            # Cap planar holes to make a solid if possible\n            capped = loft[0].CapPlanarHoles(0.01)\n            if capped and capped.IsSolid:\n                self.volume = capped\n            else:\n                self.volume = loft[0]  # fallback to uncapped loft\n            return self.volume\n\n        return None\n\n    def generate_storeys(self):\n        \"\"\"\n        Splits the building volume into storeys by extruding the site curve at random heights,\n        then intersecting each extruded box with the main volume.\n        Returns a list of Breps, one per storey, and stores them in self.storeys.\n        \"\"\"\n        if not self.site or not self.volume or not self.__height:\n            return None\n\n        # --- PARAMETERS: ceiling height range (in meters) ---\n        min_ceiling = 2.8\n        max_ceiling = 4.2\n\n        # 1. Generate random level heights that sum to the total building height\n        level_heights = []\n        remaining = self.__height\n        while remaining - min_ceiling > min_ceiling:\n            h = random.uniform(min_ceiling, min(max_ceiling, remaining))\n            level_heights.append(h)\n            remaining -= h\n        # Add the last level to use up the remaining height\n        if remaining > 0.5:\n            level_heights.append(remaining)\n\n        # 2. For each level, extrude the site curve to create a box at the correct elevation\n        site_crv = self.site if isinstance(self.site, rg.Curve) else rg.PolylineCurve(self.site)\n        storeys = []\n        elevation = 0.0\n\n        for height in level_heights:\n            # Move the site curve up to the current elevation\n            moved_crv = site_crv.DuplicateCurve()\n            moved_crv.Translate(rg.Vector3d(0, 0, elevation))\n\n            # Try to create a planar Brep from the moved curve\n            extrusion = moved_crv.ToNurbsCurve().Offset(rg.Plane.WorldXY, 0.0, 0.01, rg.CurveOffsetCornerStyle.Sharp)\n            if extrusion and len(extrusion) > 0:\n                brep = rg.Brep.CreatePlanarBreps(extrusion[0])\n                if brep and len(brep) > 0:\n                    # Create a box Brep for the storey using the site corners at base and top\n                    cap = rg.Brep.CreateFromBox(\n                        [rg.Point3d(p.X, p.Y, elevation) for p in self.site[:-1]] +\n                        [rg.Point3d(p.X, p.Y, elevation + height) for p in self.site[:-1]]\n                    )\n                else:\n                    cap = None\n            else:\n                # Fallback: extrude the curve to create the storey volume\n                cap = rg.Extrusion.Create(moved_crv, height, True).ToBrep()\n\n            # 3. Intersect the storey box with the main building volume to get the actual storey shape\n            if cap:\n                inter = rg.Brep.CreateBooleanDifference(cap, self.volume, 0.01)\n                if inter and len(inter) > 0:\n                    storeys.append(inter[0])\n            elevation += height\n\n        # Store and return the list of storey Breps\n        self.storeys = storeys\n        return storeys\n\n    def generate_slabs(self):\n        \"\"\"\n        Generates slabs for the building:\n        - Ground floor slab at the base of the first storey\n        - Intermediate slabs at the base of each upper storey\n        - Roof slab at the top of the building volume\n        Returns a list: [floor_slab, ...intermediate_slabs..., roof_slab]\n        \"\"\"\n        if not hasattr(self, \"storeys\") or not self.storeys:\n            return None\n\n        self.slabs = []\n\n        # --- Ground floor slab: use the lowest face of the first storey ---\n        base_faces = self.storeys[0].Faces\n        base_face = min(\n            base_faces,\n            key=lambda f: 0.5 * (f.GetBoundingBox(True).Max.Z - f.GetBoundingBox(True).Min.Z)\n        )\n        base_edge = base_face.OuterLoop.To3dCurve()\n        base_extr = rg.Extrusion.Create(base_edge, -self.__slab_thickness, True)\n        self.floor_slab = base_extr.ToBrep() if base_extr else None\n\n        # --- Intermediate slabs: use the lowest face of each upper storey ---\n        for storey in self.storeys[1:]:\n            faces = storey.Faces\n            bottom_face = min(\n                faces,\n                key=lambda f: 0.5 * (f.GetBoundingBox(True).Max.Z - f.GetBoundingBox(True).Min.Z)\n            )\n            bottom_crv = bottom_face.OuterLoop.To3dCurve()\n            slab_extr = rg.Extrusion.Create(bottom_crv, -self.__slab_thickness, True)\n            if slab_extr:\n                self.slabs.append(slab_extr.ToBrep())\n\n        # --- Roof slab: use the top face of the main building volume ---\n        top_face = sorted(self.volume.Faces, key=lambda f: 0.5*(f.GetBoundingBox(True).Max.Z - f.GetBoundingBox(True).Min.Z))[0]\n        roof_crv = top_face.OuterLoop.To3dCurve()\n        roof_extr = rg.Extrusion.Create(roof_crv, -self.__slab_thickness, True)\n        self.roof_slab = roof_extr.ToBrep() if roof_extr else None\n\n        return [self.floor_slab] + self.slabs + [self.roof_slab]\n\n    def __random_tilted_vector(self):\n        \"\"\"\n        Generates a random 3D vector tilted from the vertical (Z axis) by up to the maximum allowed wall tilt.\n        The tilt is applied in the XZ plane (Y=0).\n        Returns:\n            Rhino.Geometry.Vector3d: The resulting unit vector.\n        \"\"\"\n        # Random tilt angle in degrees within allowed range\n        angle_deg = random.uniform(-self.__max_wall_tilt_deg, self.__max_wall_tilt_deg)\n        angle_rad = math.radians(angle_deg)\n        # X component is the sine of the tilt angle, Z is the cosine (always positive for upward direction)\n        x = math.sin(angle_rad)\n        z = abs(math.cos(angle_rad))\n        return rg.Vector3d(x, 0, z)\n\n    def __make_wall_profile(self, curve, thickness):\n        \"\"\"\n        Creates a closed wall profile curve by offsetting the input curve and connecting the ends.\n        Args:\n            curve (rg.Curve): The centerline curve of the wall.\n            thickness (float): Wall thickness (offset distance).\n        Returns:\n            rg.Curve or None: Closed profile curve, or None if failed.\n        \"\"\"\n        # Offset the curve inward (negative thickness)\n        offsets = curve.Offset(rg.Plane.WorldXY, -thickness, 0.01, rg.CurveOffsetCornerStyle.Sharp)\n        if not offsets or len(offsets) == 0:\n            return None\n        offset_crv = offsets[0]\n\n        # Get start/end points of original and offset curves\n        p_start_orig = curve.PointAtStart\n        p_start_off = offset_crv.PointAtStart\n        p_end_orig = curve.PointAtEnd\n        p_end_off = offset_crv.PointAtEnd\n\n        # Create lines to cap the ends between original and offset\n        cap_start = rg.Line(p_start_orig, p_start_off).ToNurbsCurve()\n        cap_end = rg.Line(p_end_orig, p_end_off).ToNurbsCurve()\n\n        # Join all segments into a closed profile\n        joined = rg.Curve.JoinCurves([curve, cap_end, offset_crv, cap_start])\n        if joined and len(joined) > 0 and joined[0].IsClosed:\n            return joined[0]\n        return None\n\n\n    def to_gh_tree(self, nested_list):\n        \"\"\"\n        Converts a nested Python list (list of lists) into a Grasshopper DataTree.\n        Each sublist becomes a branch in the DataTree.\n\n        Args:\n            nested_list (list of lists): The nested list to convert.\n\n        Returns:\n            Grasshopper.DataTree[object]: The resulting DataTree.\n        \"\"\"\n        tree = DataTree[object]()\n        for i, sublist in enumerate(nested_list):\n            path = GH_Path(i)  # Each sublist gets its own branch path\n            for item in sublist:\n                tree.Add(item, path)\n        return tree\n\n    def generate_walls(self):\n        \"\"\"\n        For each storey, generates 1–2 random wall Breps as extruded closed profiles (from random lines).\n        Returns a Grasshopper DataTree of wall Breps.\n        \"\"\"\n        if not hasattr(self, \"storeys\") or not self.storeys:\n            return None\n\n        self.walls = []\n\n        def get_valid_wall_line(base_crv, z, inset=1.25, max_attempts=100):\n            \"\"\"\n            Generates a random line (as a NurbsCurve) between two points inside an inset offset of the base curve.\n            \"\"\"\n            offset_crvs = base_crv.Offset(rg.Plane.WorldXY, inset, 0.01, rg.CurveOffsetCornerStyle.Sharp)\n            if not offset_crvs or len(offset_crvs) == 0:\n                return None\n            offset_crv = offset_crvs[0]\n            bbox = offset_crv.GetBoundingBox(True)\n\n            def random_point_in_crv():\n                for _ in range(max_attempts):\n                    x = random.uniform(bbox.Min.X, bbox.Max.X)\n                    y = random.uniform(bbox.Min.Y, bbox.Max.Y)\n                    pt = rg.Point3d(x, y, z)\n                    if offset_crv.Contains(pt, rg.Plane.WorldXY, 0.01) == rg.PointContainment.Inside:\n                        return pt\n                return None\n\n            pt1 = random_point_in_crv()\n            pt2 = random_point_in_crv()\n            if pt1 and pt2:\n                return rg.Polyline([pt1, pt2]).ToNurbsCurve()\n            return None\n\n        for i, storey in enumerate(self.storeys):\n            # Use the lowest face (by height) as the base for wall generation\n            base_face = sorted(\n                storey.Faces,\n                key=lambda f: 0.5 * (f.GetBoundingBox(True).Max.Z - f.GetBoundingBox(True).Min.Z)\n            )[0]\n            base_crv = base_face.OuterLoop.To3dCurve()\n            base_brep = rg.Brep.CreatePlanarBreps(base_crv)\n            if not base_brep or len(base_brep) == 0:\n                self.walls.append([])\n                continue\n\n            base = base_brep[0]\n            base_bbox = base.GetBoundingBox(True)\n            walls_this_storey = []\n\n            num_lines = random.randint(1, 2)\n            for _ in range(num_lines):\n                # Generate a random wall line inside the storey base\n                curve = get_valid_wall_line(base_crv, base_bbox.Min.Z)\n                if not curve:\n                    continue\n\n                # Create a closed wall profile by offsetting the curve\n                thickness = random.uniform(self.__min_wall_thickness, self.__max_wall_thickness)\n                curve_offset = self.__make_wall_profile(curve, thickness)\n                if not curve_offset:\n                    continue\n\n                # Determine extrusion height (up to next storey or roof)\n                try:\n                    top_z = self.storeys[i + 1].GetBoundingBox(True).Min.Z\n                except IndexError:\n                    top_z = self.__height\n\n                base_z = base_bbox.Min.Z\n                height = top_z - base_z\n\n                # Apply a random tilt to the wall extrusion vector\n                vector = self.__random_tilted_vector()\n                vector.Unitize()\n                vector *= (height - self.__slab_thickness)\n\n                # Move wall profile up by slab thickness to avoid overlap\n                curve_offset.Translate(self.__slab_thickness * rg.Vector3d.ZAxis)\n\n                # Extrude the wall profile along the tilted vector\n                extrusion = rg.Extrusion.Create(curve_offset, vector.Length, True)\n                if extrusion:\n                    walls_this_storey.append(extrusion.ToBrep())\n\n            self.walls.append(walls_this_storey)\n\n        return self.to_gh_tree(self.walls)\n\n    def generate_columns(self):\n        \"\"\"\n        For each storey, creates 1–3 columns as extruded profile curves (rectangle or spline, periodic).\n        Returns a Grasshopper DataTree of column Breps.\n        \"\"\"\n        if not hasattr(self, \"storeys\") or not self.storeys:\n            return None\n\n        self.columns = []\n\n        def get_valid_column_point(base_crv, z, inset=1.25, max_attempts=100):\n            \"\"\"\n            Finds a random point inside an inset offset of the base curve at elevation z.\n            \"\"\"\n            offset_crvs = base_crv.Offset(rg.Plane.WorldXY, inset, 0.01, rg.CurveOffsetCornerStyle.Sharp)\n            if not offset_crvs or len(offset_crvs) == 0:\n                return None\n            offset_crv = offset_crvs[0]\n            bbox = offset_crv.GetBoundingBox(True)\n            for _ in range(max_attempts):\n                x = random.uniform(bbox.Min.X, bbox.Max.X)\n                y = random.uniform(bbox.Min.Y, bbox.Max.Y)\n                pt = rg.Point3d(x, y, z)\n                if offset_crv.Contains(pt, rg.Plane.WorldXY, 0.01) == rg.PointContainment.Inside:\n                    return pt\n            return None\n\n        for i, storey in enumerate(self.storeys):\n            # Use the lowest face as the base for column generation\n            base_face = sorted(\n                storey.Faces,\n                key=lambda f: 0.5 * (f.GetBoundingBox(True).Max.Z - f.GetBoundingBox(True).Min.Z)\n            )[0]\n            base_crv = base_face.OuterLoop.To3dCurve()\n            base_brep = rg.Brep.CreatePlanarBreps(base_crv)\n            if not base_brep or len(base_brep) == 0:\n                self.columns.append([])\n                continue\n\n            base = base_brep[0]\n            base_bbox = base.GetBoundingBox(True)\n            columns_this_storey = []\n\n            num_columns = random.randint(1, 3)\n            for _ in range(num_columns):\n                pt = get_valid_column_point(base_crv, base_bbox.Min.Z)\n                if not pt:\n                    continue\n\n                # Create column profile at the point: rectangle or periodic spline\n                size_x = random.uniform(0.3, 0.7)\n                size_y = random.uniform(0.3, 0.7)\n                plane = rg.Plane(pt, rg.Vector3d.ZAxis)\n                rect_crv = rg.Rectangle3d(plane, size_x, size_y).ToNurbsCurve()\n                if random.random() < 0.5:\n                    # Use periodic spline profile\n                    corners = [\n                        plane.PointAt(size_x / 2, size_y / 2),\n                        plane.PointAt(-size_x / 2, size_y / 2),\n                        plane.PointAt(-size_x / 2, -size_y / 2),\n                        plane.PointAt(size_x / 2, -size_y / 2),\n                        plane.PointAt(size_x / 2, size_y / 2)\n                    ]\n                    spline = rg.Curve.CreateInterpolatedCurve(corners, 3)\n                    profile = rg.Curve.CreatePeriodicCurve(spline)\n                else:\n                    # Use rectangle profile\n                    profile = rect_crv\n\n                # Determine extrusion height (up to next storey or roof)\n                try:\n                    top_z = self.storeys[i + 1].GetBoundingBox(True).Min.Z\n                except IndexError:\n                    top_z = self.__height\n\n                base_z = pt.Z\n                height = top_z - base_z\n                if height <= 0.01:\n                    continue\n\n                # Apply random tilt and move profile up by slab thickness\n                vector = self.__random_tilted_vector()\n                vector.Unitize()\n                vector *= (height - self.__slab_thickness)\n                profile.Translate(self.__slab_thickness * rg.Vector3d.ZAxis)\n\n                # Extrude the profile along the tilted vector\n                extrusion = rg.Extrusion.Create(profile, vector.Length, True)\n                if extrusion:\n                    columns_this_storey.append(extrusion.ToBrep())\n\n            self.columns.append(columns_this_storey)\n\n        return self.to_gh_tree(self.columns)\n\nif run:\n    # Instantiate and generate site\n    bldg = Building()\n    site = bldg.generate_site()\n    volume = bldg.generate_volume()\n    storeys = bldg.generate_storeys()\n    slabs = bldg.generate_slabs()\n    walls = bldg.generate_walls()\n    columns = bldg.generate_columns()\n\n    # Building object\n    building = bldg\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}