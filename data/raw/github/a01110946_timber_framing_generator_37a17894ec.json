{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/row_blocking.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/row_blocking.py",
  "instruction": "Row blocking generation for timber framing.",
  "code": "# File: timber_framing_generator/framing_elements/row_blocking.py\n\n\"\"\"\nRow blocking generation for timber framing.\n\nRow blocking (also called \"solid blocking\") refers to horizontal framing members \ninstalled between vertical studs to provide lateral support, prevent stud rotation/twisting, \nadd structural rigidity, and provide nailing surfaces for wall finishes.\n\nThis module handles the calculation and creation of row blocking geometry based on\ncell decomposition and stud positions.\n\"\"\"\n\nimport sys\nfrom typing import Dict, List, Any, Optional, Tuple\nimport math\nimport Rhino.Geometry as rg\nfrom src.timber_framing_generator.utils.safe_rhino import safe_get_length, safe_get_bounding_box\n\nfrom src.timber_framing_generator.config.framing import (\n    FRAMING_PARAMS,\n    PROFILES,\n    BlockingPattern,\n    get_profile_for_wall_type,\n    get_framing_param\n)\nfrom src.timber_framing_generator.framing_elements.blocking_parameters import (\n    BlockingParameters,\n    BlockingLayerConfig\n)\n\n\nclass RowBlockingGenerator:\n    \"\"\"\n    Generates row blocking elements between studs based on cell decomposition.\n    \n    Row blocking consists of horizontal members installed between studs to provide\n    lateral support and prevent stud rotation. This class uses the cell system to\n    properly place blocking elements within appropriate spatial boundaries.\n    \n    Attributes:\n        wall_data: Dictionary with wall information including cells\n        stud_positions: Dictionary of stud positions by cell type\n        blocking_params: Parameters for blocking configuration\n        debug_geometry: Storage for debug visualization\n    \"\"\"\n    \n    def __init__(\n        self, \n        wall_data: Dict[str, Any], \n        studs: Optional[List[Any]] = None, \n        king_studs: Optional[List[Any]] = None, \n        trimmers: Optional[List[Any]] = None,\n        header_cripples: Optional[List[Any]] = None,\n        sill_cripples: Optional[List[Any]] = None,\n        blocking_pattern: Optional[str] = None,\n        include_blocking: Optional[bool] = None,\n        block_spacing: Optional[float] = None,\n        first_block_height: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        Initialize the row blocking generator.\n        \n        Args:\n            wall_data: Dictionary containing wall configuration data\n            studs: List of standard studs\n            king_studs: List of king studs\n            trimmers: List of trimmer studs\n            header_cripples: List of header cripple studs\n            sill_cripples: List of sill cripple studs\n            blocking_pattern: Pattern for blocking (inline, staggered, etc.)\n            include_blocking: Flag to enable/disable blocking\n            block_spacing: Spacing between blocks in feet\n            first_block_height: Height of first block row in feet\n        \"\"\"\n        self.wall_data = wall_data\n        self.wall_base_elevation = wall_data.get(\"wall_base_elevation\", 0)\n        self.wall_top_elevation = wall_data.get(\"wall_top_elevation\", 0)\n        \n        # Store the provided framing elements\n        self.studs = studs or []\n        self.king_studs = king_studs or []\n        self.trimmers = trimmers or []\n        self.header_cripples = header_cripples or []\n        self.sill_cripples = sill_cripples or []\n        \n        # Initialize blocking parameters\n        self.blocking_params = BlockingParameters()\n        \n        # Explicitly handle blocking pattern conversion\n        if blocking_pattern is not None:\n            if isinstance(blocking_pattern, str):\n                print(f\"Row blocking received pattern: {blocking_pattern}, type: {type(blocking_pattern)}\")\n                \n                pattern_str = blocking_pattern.upper().strip()\n                if pattern_str == \"STAGGERED\":\n                    self.blocking_params.pattern = BlockingPattern.STAGGERED\n                    print(f\"Explicitly set pattern to STAGGERED\")\n                else:\n                    self.blocking_params.pattern = BlockingPattern.INLINE\n                    print(f\"Explicitly set pattern to INLINE\")\n            else:\n                self.blocking_params.pattern = blocking_pattern\n        \n        # Override specific parameters if provided\n        if include_blocking is not None:\n            self.blocking_params.include_blocking = include_blocking\n            print(f\"Set blocking param include_blocking = {include_blocking}\")\n            \n        if block_spacing is not None:\n            self.blocking_params.block_spacing = block_spacing\n            print(f\"Set blocking param block_spacing = {block_spacing}\")\n            \n        if first_block_height is not None:\n            self.blocking_params.first_block_height = first_block_height\n            print(f\"Set blocking param first_block_height = {first_block_height}\")\n        \n        # Initialize stud positions dictionary\n        self.stud_positions = {}\n        \n        # Get wall and block profiles\n        self.wall_profile = get_profile_for_wall_type(wall_data.get(\"wall_type\", \"2x4\"))\n        self.block_profile_name = self.blocking_params.get_block_profile(self.wall_profile.name)\n        self.block_profile = PROFILES.get(self.block_profile_name, self.wall_profile)\n        \n        # Try to get blocking height thresholds from config, otherwise use defaults\n        # Uses wall_data config if available (for material-specific dimensions)\n        self.blocking_height_threshold_1 = get_framing_param(\"blocking_row_height_threshold_1\", wall_data, 48/12)  # 48 inches in feet\n        self.blocking_height_threshold_2 = get_framing_param(\"blocking_row_height_threshold_2\", wall_data, 96/12)  # 96 inches in feet\n        \n        # Calculate minimum cell height for blocking from profile or default\n        try:\n            dims = self.block_profile.get_dimensions()\n            self.blocking_min_height = dims[\"width\"] * 3  # Use block width (vertical dimension) * 3\n        except (AttributeError, KeyError):\n            # Default to 3x nominal width of framing (e.g., 4.5\" for 2x4)\n            self.blocking_min_height = 4.5/12 * 3  # 13.5 inches in feet\n            \n        # Storage for debug geometry\n        self.debug_geometry = {\n            \"points\": [],\n            \"planes\": [],\n            \"profiles\": [],\n            \"paths\": []\n        }\n        \n    def set_stud_positions(self, stud_positions: Dict[str, List[float]]) -> None:\n        \"\"\"\n        Set or update the stud positions by cell type.\n        \n        Args:\n            stud_positions: Dictionary mapping cell IDs to stud position lists\n        \"\"\"\n        if stud_positions is not None:\n            self.stud_positions = stud_positions\n            print(f\"Updated stud positions: cells={len(self.stud_positions.keys())}\")\n            for cell_id, positions in self.stud_positions.items():\n                print(f\"  Cell {cell_id}: {len(positions)} studs\")\n        else:\n            print(\"Warning: No stud position data provided\")\n            self.stud_positions = {}\n    \n    def generate_blocking(self) -> List[rg.Brep]:\n        \"\"\"\n        Generate row blocking elements for a wall based on cell decomposition.\n        \n        Returns:\n            List of Brep geometries representing blocking elements\n        \"\"\"\n        print(\"\\n===== ROW BLOCKING DIAGNOSTIC INFO =====\")\n        print(f\"Include blocking flag: {self.blocking_params.include_blocking}\")\n        print(f\"Wall height: {self.wall_top_elevation - self.wall_base_elevation}\")\n        print(f\"Wall elevations: base={self.wall_base_elevation}, top={self.wall_top_elevation}\")\n    \n        # Skip if blocking is disabled\n        if not self.blocking_params.include_blocking:\n            print(\"Blocking is disabled, skipping generation\")\n            return []\n        \n        # Get wall cells\n        cells = self.wall_data.get(\"cells\", [])\n        if not cells:\n            print(\"No cells found in wall data, cannot generate blocking\")\n            return []\n            \n        # Get base plane for coordinate transformations\n        base_plane = self.wall_data.get(\"base_plane\")\n        if not base_plane:\n            print(\"Missing wall base plane, cannot generate blocking\")\n            return []\n        \n        # Get dimensions for stud width adjustment\n        try:\n            dims = self.block_profile.get_dimensions()\n            block_width = dims[\"width\"]  # Vertical dimension (usually 1.5\" for 2x4)\n            block_thickness = dims[\"thickness\"]  # Horizontal dimension (usually 3.5\" for 2x4)\n            print(f\"Block profile dimensions: {dims}\")\n        except (AttributeError, KeyError) as e:\n            # Fallback to direct attributes if get_dimensions not available\n            print(f\"Using direct profile attributes - get_dimensions failed: {str(e)}\")\n            try:\n                # Try nominal_width/nominal_depth\n                block_width = self.block_profile.nominal_width\n                block_thickness = self.block_profile.nominal_depth\n            except AttributeError:\n                # Last resort - try width/depth directly\n                try:\n                    block_width = self.block_profile.width\n                    block_thickness = self.block_profile.depth\n                except AttributeError:\n                    # Default to 3x nominal width of framing (e.g., 4.5\" for 2x4)\n                    print(\"WARNING: Could not determine block dimensions, using defaults for 2x4\")\n                    block_width = 1.5 / 12.0  # 1.5 inches in feet\n                    block_thickness = 3.5 / 12.0  # 3.5 inches in feet\n                    \n        print(f\"Block profile: {self.block_profile_name}, width: {block_width}, thickness: {block_thickness}\")\n\n        # Get stud width for adjusting block lengths\n        # Uses wall_data config if available (for material-specific dimensions)\n        stud_width = get_framing_param(\"stud_width\", self.wall_data, 1.5 / 12)  # Default to 1.5 inches in feet\n\n        # Store all generated blocks\n        all_blocks = []\n\n        # First, process regular studs and assign them to SC cells\n        # This is the PRIMARY source of blocking positions\n        print(\"\\nProcessing regular studs:\")\n        regular_stud_count = len(self.studs)\n        print(f\"Total regular studs found: {regular_stud_count}\")\n\n        for i, stud in enumerate(self.studs):\n            try:\n                # Get the bounding box of the stud\n                bbox = safe_get_bounding_box(stud, True)\n                if not bbox:\n                    print(f\"  Stud {i+1}: Could not get bounding box\")\n                    continue\n\n                # Use CENTER of bounding box for accurate stud position\n                # Using Min would give left edge, shifting blocking left by half stud width\n                center_pt = bbox.Center\n\n                # Get the u-coordinate (position along wall length)\n                u_coord = self._project_point_to_u_coordinate(center_pt, base_plane)\n\n                # Find the SC cell this stud belongs to\n                assigned = False\n                for cell in cells:\n                    # Try both \"id\" and \"cell_id\" keys (JSON uses \"id\", internal uses \"cell_id\")\n                    cell_id = cell.get(\"id\", cell.get(\"cell_id\", \"\"))\n                    cell_type = cell.get(\"cell_type\", cell.get(\"type\", \"\"))\n\n                    # Only process Stud Cells (SC)\n                    if cell_type != \"SC\":\n                        continue\n\n                    # Get cell bounds directly from cell data\n                    u_start = cell.get(\"u_start\", 0)\n                    u_end = cell.get(\"u_end\", 0)\n\n                    # Check if stud position is within cell bounds with a small tolerance\n                    if u_start - 0.1 <= u_coord <= u_end + 0.1:\n                        # Initialize the dict for this cell if not already done\n                        # Store both positions AND vertical bounds for filtering block heights\n                        if cell_id not in self.stud_positions:\n                            v_start = cell.get(\"v_start\", 0)\n                            v_end = cell.get(\"v_end\", self.wall_top_elevation - self.wall_base_elevation)\n                            self.stud_positions[cell_id] = {\n                                'positions': [],\n                                'v_start': v_start,\n                                'v_end': v_end,\n                                'cell_type': cell_type\n                            }\n\n                        # Add the stud position to this cell\n                        self.stud_positions[cell_id]['positions'].append(u_coord)\n                        assigned = True\n                        break  # Each stud belongs to one cell\n\n                if not assigned:\n                    # Stud might be a king stud or trimmer at cell boundary - skip silently\n                    pass\n            except Exception as e:\n                print(f\"  Error processing stud {i+1}: {str(e)}\")\n\n        # Also process king studs (they define cell boundaries)\n        print(\"\\nProcessing king studs:\")\n        king_stud_count = len(self.king_studs)\n        print(f\"Total king studs found: {king_stud_count}\")\n\n        for i, stud in enumerate(self.king_studs):\n            try:\n                bbox = safe_get_bounding_box(stud, True)\n                if not bbox:\n                    print(f\"  King stud {i+1}: Could not get bounding box\")\n                    continue\n\n                # Use center of bounding box for more accurate position\n                center_pt = bbox.Center\n                u_coord = self._project_point_to_u_coordinate(center_pt, base_plane)\n                print(f\"  King stud {i+1}: u_coord={u_coord:.4f}\")\n\n                # King studs are at SC cell boundaries - add to adjacent SC cells\n                for cell in cells:\n                    # Try both \"id\" and \"cell_id\" keys\n                    cell_id = cell.get(\"id\", cell.get(\"cell_id\", \"\"))\n                    cell_type = cell.get(\"cell_type\", cell.get(\"type\", \"\"))\n\n                    if cell_type != \"SC\":\n                        continue\n\n                    u_start = cell.get(\"u_start\", 0)\n                    u_end = cell.get(\"u_end\", 0)\n\n                    # King studs are at boundaries - use larger tolerance for edge matching\n                    # Account for stud width (0.125 ft = 1.5 inches)\n                    tolerance = 0.3  # ~3.6 inches tolerance\n                    at_start = abs(u_coord - u_start) < tolerance\n                    at_end = abs(u_coord - u_end) < tolerance\n\n                    if at_start or at_end:\n                        if cell_id not in self.stud_positions:\n                            v_start = cell.get(\"v_start\", 0)\n                            v_end = cell.get(\"v_end\", self.wall_top_elevation - self.wall_base_elevation)\n                            self.stud_positions[cell_id] = {\n                                'positions': [],\n                                'v_start': v_start,\n                                'v_end': v_end,\n                                'cell_type': cell_type\n                            }\n                        # Check if position is not already in list (with tolerance)\n                        already_exists = any(abs(u_coord - pos) < 0.1 for pos in self.stud_positions[cell_id]['positions'])\n                        if not already_exists:\n                            self.stud_positions[cell_id]['positions'].append(u_coord)\n                            edge = \"start\" if at_start else \"end\"\n                            print(f\"    Added king stud to {cell_id} at {edge} edge\")\n            except Exception as e:\n                print(f\"  Error processing king stud {i+1}: {str(e)}\")\n\n        # Process trimmers (they define SCC cell boundaries)\n        print(\"\\nProcessing trimmers:\")\n        trimmer_count = len(self.trimmers)\n        print(f\"Total trimmers found: {trimmer_count}\")\n\n        for i, trimmer in enumerate(self.trimmers):\n            try:\n                bbox = safe_get_bounding_box(trimmer, True)\n                if not bbox:\n                    print(f\"  Trimmer {i+1}: Could not get bounding box\")\n                    continue\n\n                # Use center of bounding box for position\n                center_pt = bbox.Center\n                u_coord = self._project_point_to_u_coordinate(center_pt, base_plane)\n                print(f\"  Trimmer {i+1}: u_coord={u_coord:.4f}\")\n\n                # Trimmers are at SCC cell boundaries - add to SCC cells\n                for cell in cells:\n                    cell_id = cell.get(\"id\", cell.get(\"cell_id\", \"\"))\n                    cell_type = cell.get(\"cell_type\", cell.get(\"type\", \"\"))\n\n                    if cell_type != \"SCC\":\n                        continue\n\n                    u_start = cell.get(\"u_start\", 0)\n                    u_end = cell.get(\"u_end\", 0)\n\n                    # Check if trimmer is at this cell's edges\n                    tolerance = 0.3\n                    at_start = abs(u_coord - u_start) < tolerance\n                    at_end = abs(u_coord - u_end) < tolerance\n\n                    if at_start or at_end:\n                        if cell_id not in self.stud_positions:\n                            v_start = cell.get(\"v_start\", 0)\n                            v_end = cell.get(\"v_end\", self.wall_top_elevation - self.wall_base_elevation)\n                            self.stud_positions[cell_id] = {\n                                'positions': [],\n                                'v_start': v_start,\n                                'v_end': v_end,\n                                'cell_type': cell_type\n                            }\n                        # Check if position is not already in list (with tolerance)\n                        already_exists = any(abs(u_coord - pos) < 0.1 for pos in self.stud_positions[cell_id]['positions'])\n                        if not already_exists:\n                            self.stud_positions[cell_id]['positions'].append(u_coord)\n                            edge = \"start\" if at_start else \"end\"\n                            print(f\"    Added trimmer to {cell_id} at {edge} edge\")\n            except Exception as e:\n                print(f\"  Error processing trimmer {i+1}: {str(e)}\")\n\n        print(f\"\\nAfter processing regular and king studs: {len(self.stud_positions)} cells with stud positions\")\n        for cell_id, cell_data in self.stud_positions.items():\n            positions = cell_data['positions']\n            v_start = cell_data['v_start']\n            v_end = cell_data['v_end']\n            print(f\"  Cell {cell_id}: {len(positions)} studs, v_range=[{v_start:.2f}, {v_end:.2f}]\")\n\n        # Process header cripples and assign them to cells\n        print(\"\\nProcessing header cripples:\")\n        header_cripple_count = len(self.header_cripples)\n        print(f\"Total header cripples found: {header_cripple_count}\")\n        \n        for i, cripple in enumerate(self.header_cripples):\n            try:\n                # Get the bounding box of the cripple\n                bbox = safe_get_bounding_box(cripple, True)\n                if not bbox:\n                    print(f\"  Header Cripple {i+1}: Could not get bounding box\")\n                    continue\n\n                # Use CENTER for accurate position (not Min which gives left edge)\n                center_pt = bbox.Center\n\n                # Get the u-coordinate (position along wall length)\n                u_coord = self._project_point_to_u_coordinate(center_pt, base_plane)\n                print(f\"  Header Cripple {i+1}: u-coordinate = {u_coord:.4f}, height: {center_pt.Z:.4f}\")\n                \n                # Find the HCC cell this cripple belongs to\n                assigned = False\n                for cell in cells:\n                    # Try both \"id\" and \"cell_id\" keys\n                    cell_id = cell.get(\"id\", cell.get(\"cell_id\", \"\"))\n                    cell_type = cell.get(\"cell_type\", cell.get(\"type\", \"\"))\n                    \n                    # Only process HeaderCrippleCells\n                    if cell_type != \"HCC\":\n                        continue\n                        \n                    # Get cell bounds directly from cell data\n                    u_start = cell.get(\"u_start\", 0)\n                    u_end = cell.get(\"u_end\", 0)\n                    \n                    # Check if cripple position is within cell bounds with a small tolerance\n                    if u_start - 0.1 <= u_coord <= u_end + 0.1:\n                        # Initialize the dict for this cell if not already done\n                        if cell_id not in self.stud_positions:\n                            v_start = cell.get(\"v_start\", 0)\n                            v_end = cell.get(\"v_end\", self.wall_top_elevation - self.wall_base_elevation)\n                            self.stud_positions[cell_id] = {\n                                'positions': [],\n                                'v_start': v_start,\n                                'v_end': v_end,\n                                'cell_type': cell_type\n                            }\n\n                        # Add the cripple position to this cell\n                        self.stud_positions[cell_id]['positions'].append(u_coord)\n                        print(f\"    Assigned header cripple at position {u_coord:.4f} to cell {cell_id} (u_start={u_start}, u_end={u_end})\")\n                        assigned = True\n                \n                if not assigned:\n                    print(f\"    WARNING: Could not assign header cripple at position {u_coord:.4f} to any HCC cell\")\n            except Exception as e:\n                print(f\"  Error processing header cripple {i+1}: {str(e)}\")\n        \n        # Process sill cripples and assign them to cells\n        print(\"\\nProcessing sill cripples:\")\n        sill_cripple_count = len(self.sill_cripples)\n        print(f\"Total sill cripples found: {sill_cripple_count}\")\n        \n        for i, cripple in enumerate(self.sill_cripples):\n            try:\n                # Get the bounding box of the cripple\n                bbox = safe_get_bounding_box(cripple, True)\n                if not bbox:\n                    print(f\"  Sill Cripple {i+1}: Could not get bounding box\")\n                    continue\n\n                # Use CENTER for accurate position (not Min which gives left edge)\n                center_pt = bbox.Center\n\n                # Get the u-coordinate (position along wall length)\n                u_coord = self._project_point_to_u_coordinate(center_pt, base_plane)\n                print(f\"  Sill Cripple {i+1}: u-coordinate = {u_coord:.4f}, height: {center_pt.Z:.4f}\")\n                \n                # Find the SCC cell this cripple belongs to\n                assigned = False\n                for cell in cells:\n                    # Try both \"id\" and \"cell_id\" keys\n                    cell_id = cell.get(\"id\", cell.get(\"cell_id\", \"\"))\n                    cell_type = cell.get(\"cell_type\", cell.get(\"type\", \"\"))\n                    \n                    # Only process SillCrippleCells\n                    if cell_type != \"SCC\":\n                        continue\n                        \n                    # Get cell bounds directly from cell data\n                    u_start = cell.get(\"u_start\", 0)\n                    u_end = cell.get(\"u_end\", 0)\n                    \n                    # Check if cripple position is within cell bounds with a small tolerance\n                    if u_start - 0.1 <= u_coord <= u_end + 0.1:\n                        # Initialize the dict for this cell if not already done\n                        if cell_id not in self.stud_positions:\n                            v_start = cell.get(\"v_start\", 0)\n                            v_end = cell.get(\"v_end\", self.wall_top_elevation - self.wall_base_elevation)\n                            self.stud_positions[cell_id] = {\n                                'positions': [],\n                                'v_start': v_start,\n                                'v_end': v_end,\n                                'cell_type': cell_type\n                            }\n\n                        # Add the cripple position to this cell\n                        self.stud_positions[cell_id]['positions'].append(u_coord)\n                        print(f\"    Assigned sill cripple at position {u_coord:.4f} to cell {cell_id} (u_start={u_start}, u_end={u_end})\")\n                        assigned = True\n\n                if not assigned:\n                    print(f\"    WARNING: Could not assign sill cripple at position {u_coord:.4f} to any SCC cell\")\n            except Exception as e:\n                print(f\"  Error processing sill cripple {i+1}: {str(e)}\")\n        \n        print(\"\\nCompleted processing header and sill cripples\")\n        print(f\"Total cells with stud positions: {len(self.stud_positions)}\")\n        \n        # Generate and return the blocking elements\n        all_blocks = self._generate_row_blocking(self.stud_positions, block_width, block_thickness, base_plane)\n        print(f\"Total blocks created: {len(all_blocks)}\")\n        print(\"===== END ROW BLOCKING DIAGNOSTIC INFO =====\")\n        return all_blocks\n    \n    def _project_point_to_u_coordinate(self, point: rg.Point3d, base_plane: rg.Plane) -> float:\n        \"\"\"\n        Project a 3D point onto the wall base plane and get the U coordinate.\n        \n        Args:\n            point: 3D point to project\n            base_plane: Wall base plane\n            \n        Returns:\n            U coordinate along the wall length\n        \"\"\"\n        try:\n            # Convert world coordinates to a u-coordinate\n            # We need to get the distance from the base plane origin along the X-axis direction\n            \n            # Create vector from plane origin to the point\n            vector_to_point = rg.Vector3d(point - base_plane.Origin)\n\n            # Project this vector onto the X-axis of the base plane\n            # The dot product gives us the scalar projection\n            u_coordinate = vector_to_point * base_plane.XAxis\n\n            return u_coordinate\n\n        except Exception as e:\n            # Use direct coordinate extraction as fallback\n            try:\n                # Just extract X coordinate (assumes wall is aligned with world X axis)\n                return point.X\n            except Exception as e2:\n                print(f\"Fallback also failed: {str(e2)}\")\n                return 0.0\n    \n    def _process_cripples(self, cells, hcc_cells, scc_cells):\n        \"\"\"\n        Process header and sill cripples, assigning them to appropriate cells.\n        \n        Args:\n            cells: Dictionary of cells\n            hcc_cells: Output dictionary to store cells with header cripples\n            scc_cells: Output dictionary to store cells with sill cripples\n        \"\"\"\n        print(\"\\nProcessing header cripples:\")\n        header_cripples_found = 0\n        \n        base_plane = self.wall_data.get('base_plane')\n        print(f\"Base plane: Origin({base_plane.Origin.X:.4f}, {base_plane.Origin.Y:.4f}, {base_plane.Origin.Z:.4f})\")\n        print(f\"Base plane X-axis: ({base_plane.XAxis.X:.4f}, {base_plane.XAxis.Y:.4f}, {base_plane.XAxis.Z:.4f})\")\n        print(f\"Base plane Y-axis: ({base_plane.YAxis.X:.4f}, {base_plane.YAxis.Y:.4f}, {base_plane.YAxis.Z:.4f})\")\n        \n        # Process header cripples\n        for hc in self.header_cripples:\n            header_cripples_found += 1\n            \n            # Get the u-coordinate and height range\n            try:\n                # For Brep objects, we need to extract the centerpoint\n                if isinstance(hc, rg.Brep):\n                    # Get the bounding box and use its center point\n                    bbox = safe_get_bounding_box(hc, True)\n                    hc_point = bbox.Center\n                    print(f\"  HC{header_cripples_found} using bounding box center: ({hc_point.X:.4f}, {hc_point.Y:.4f}, {hc_point.Z:.4f})\")\n                else:\n                    # Try to use centerline method if available\n                    if hasattr(hc, 'get_centerline_start_point'):\n                        hc_point = hc.get_centerline_start_point()\n                        print(f\"  HC{header_cripples_found} using centerline start point\")\n                    else:\n                        # Fallback to center of mass if neither available\n                        hc_point = rg.AreaMassProperties.Compute(hc).Centroid\n                        print(f\"  HC{header_cripples_found} using centroid: ({hc_point.X:.4f}, {hc_point.Y:.4f}, {hc_point.Z:.4f})\")\n            except Exception as e:\n                print(f\"  Error getting point for header cripple: {str(e)}\")\n                continue\n            \n            print(f\"  HC{header_cripples_found} point: ({hc_point.X:.4f}, {hc_point.Y:.4f}, {hc_point.Z:.4f})\")\n            \n            # Get the u-coordinate (position along wall length)\n            u_coord = self._project_point_to_u_coordinate(hc_point, base_plane)\n            print(f\"  Header Cripple {header_cripples_found}: u-coordinate = {u_coord:.4f}, height range: {hc_point.Z:.4f} to {hc_point.Z:.4f}\")\n            \n            # Find the HCC cell this cripple belongs to\n            found_cell = False\n            for cell_key, cell in cells.items():\n                if not cell_key.startswith(\"HCC_\"):\n                    continue\n                    \n                # Extract u-range from cell key (format: HCC_start_end)\n                parts = cell_key.split(\"_\")\n                if len(parts) >= 3:\n                    try:\n                        u_start = float(parts[1])\n                        u_end = float(parts[2])\n                        \n                        # Check if cripple is in this cell's range\n                        if u_start <= u_coord <= u_end:\n                            # Add the u-coordinate to the cell's vertical elements\n                            if 'vertical_elements' not in cell:\n                                cell['vertical_elements'] = []\n                            \n                            # Add as string to match format from framing generator\n                            u_str = f\"{u_coord:.4f}\"\n                            if u_str not in cell['vertical_elements']:\n                                cell['vertical_elements'].append(u_str)\n                                \n                            # Also add to HCC cells dictionary\n                            hcc_cells[cell_key] = cell\n                            found_cell = True\n                            \n                            print(f\"    Assigned header cripple at position {u_coord:.4f} to cell {cell_key}\")\n                    except (ValueError, IndexError):\n                        continue\n            \n            if not found_cell:\n                print(f\"    WARNING: Could not assign header cripple at position {u_coord:.4f} to any HCC cell\")\n        \n        print(f\"Total header cripples found: {header_cripples_found}\")\n        \n        # Process sill cripples\n        print(\"\\nProcessing sill cripples:\")\n        sill_cripples_found = 0\n        \n        for sc in self.sill_cripples:\n            sill_cripples_found += 1\n            \n            # Get the u-coordinate and height range\n            try:\n                # For Brep objects, we need to extract the centerpoint\n                if isinstance(sc, rg.Brep):\n                    # Get the bounding box and use its center point\n                    bbox = safe_get_bounding_box(sc, True)\n                    sc_point = bbox.Center\n                    print(f\"  SC{sill_cripples_found} using bounding box center: ({sc_point.X:.4f}, {sc_point.Y:.4f}, {sc_point.Z:.4f})\")\n                else:\n                    # Try to use centerline method if available\n                    if hasattr(sc, 'get_centerline_start_point'):\n                        sc_point = sc.get_centerline_start_point()\n                        print(f\"  SC{sill_cripples_found} using centerline start point\")\n                    else:\n                        # Fallback to center of mass if neither available\n                        sc_point = rg.AreaMassProperties.Compute(sc).Centroid\n                        print(f\"  SC{sill_cripples_found} using centroid: ({sc_point.X:.4f}, {sc_point.Y:.4f}, {sc_point.Z:.4f})\")\n            except Exception as e:\n                print(f\"  Error getting point for sill cripple: {str(e)}\")\n                continue\n            \n            print(f\"  SC{sill_cripples_found} point: ({sc_point.X:.4f}, {sc_point.Y:.4f}, {sc_point.Z:.4f})\")\n            \n            # Get the u-coordinate (position along wall length)\n            u_coord = self._project_point_to_u_coordinate(sc_point, base_plane)\n            print(f\"  Sill Cripple {sill_cripples_found}: u-coordinate = {u_coord:.4f}, height range: {sc_point.Z:.4f} to {sc_point.Z:.4f}\")\n            \n            # Find the SCC cell this cripple belongs to\n            found_cell = False\n            for cell_key, cell in cells.items():\n                if not cell_key.startswith(\"SCC_\"):\n                    continue\n                    \n                # Extract u-range from cell key (format: SCC_start_end)\n                parts = cell_key.split(\"_\")\n                if len(parts) >= 3:\n                    try:\n                        u_start = float(parts[1])\n                        u_end = float(parts[2])\n                        \n                        # Check if cripple is in this cell's range\n                        if u_start <= u_coord <= u_end:\n                            # Add the u-coordinate to the cell's vertical elements\n                            if 'vertical_elements' not in cell:\n                                cell['vertical_elements'] = []\n                            \n                            # Add as string to match format from framing generator\n                            u_str = f\"{u_coord:.4f}\"\n                            if u_str not in cell['vertical_elements']:\n                                cell['vertical_elements'].append(u_str)\n                                \n                            # Also add to SCC cells dictionary\n                            scc_cells[cell_key] = cell\n                            found_cell = True\n                            \n                            print(f\"    Assigned sill cripple at position {u_coord:.4f} to cell {cell_key}\")\n                    except (ValueError, IndexError):\n                        continue\n            \n            if not found_cell:\n                print(f\"    WARNING: Could not assign sill cripple at position {u_coord:.4f} to any SCC cell\")\n        \n        print(f\"Total sill cripples found: {sill_cripples_found}\")\n        print(f\"Completed processing header and sill cripples\")\n    \n    def _generate_row_blocking(self, cells, block_width, block_thickness, base_plane):\n        \"\"\"\n        Generate row blocking elements for the given cells.\n        \n        Args:\n            cells: Dictionary of cells with vertical elements\n            block_width: Width of blocking elements\n            block_thickness: Thickness of blocking elements\n            base_plane: Base plane of the wall\n            \n        Returns:\n            List of row blocking Brep elements\n        \"\"\"\n        blocks = []\n        include_blocking = self.blocking_params.include_blocking\n        if not include_blocking:\n            print(\"Blocking is disabled via parameters\")\n            return blocks\n        \n        # Get blocking heights based on wall height\n        wall_height = self.wall_top_elevation - self.wall_base_elevation\n        print(f\"Wall height: {wall_height}\")\n        print(f\"Wall elevations: base={self.wall_base_elevation}, top={self.wall_top_elevation}\")\n        \n        # Get block heights from pattern or calculate them\n        if self.blocking_params.first_block_height:\n            first_block_height = self.blocking_params.first_block_height\n            block_heights = [first_block_height]\n            \n            # If wall is higher than twice the first block height, add additional blocks\n            remaining_height = wall_height - first_block_height\n            spacing = self.blocking_params.block_spacing\n            \n            if remaining_height > spacing:\n                num_additional_blocks = int(remaining_height / spacing)\n                for i in range(num_additional_blocks):\n                    block_heights.append(first_block_height + spacing * (i + 1))\n        else:\n            # Default to 1/3 and 2/3 of wall height\n            block_heights = [wall_height / 3, 2 * wall_height / 3]\n        \n        print(f\"Block profile dimensions: {{'thickness': {block_thickness}, 'width': {block_width}}}\")\n        print(f\"Block profile: 2x4, width: {block_width}, thickness: {block_thickness}\")\n        print(f\"Calculated block heights: {block_heights}\")\n        \n        # Process header and sill cripples\n        hcc_cells = {}\n        scc_cells = {}\n        self._process_cripples(cells, hcc_cells, scc_cells)\n        \n        # For each cell type, create blocks between studs\n        cells_with_studs = 0\n        for cell_key, cell_data in cells.items():\n            # Handle both old format (list) and new format (dict with 'positions')\n            if isinstance(cell_data, dict):\n                stud_positions = cell_data.get('positions', [])\n                cell_v_start = cell_data.get('v_start', 0)\n                cell_v_end = cell_data.get('v_end', wall_height)\n                cell_type = cell_data.get('cell_type', 'SC')\n            else:\n                # Old format: just a list of positions\n                stud_positions = cell_data\n                cell_v_start = 0\n                cell_v_end = wall_height\n                cell_type = 'SC'\n\n            # Skip cells without stud positions\n            if not stud_positions:\n                continue\n\n            print(f\"Processing cell {cell_key} ({cell_type}) with {len(stud_positions)} vertical elements, v_range=[{cell_v_start:.2f}, {cell_v_end:.2f}]\")\n            cells_with_studs += 1\n\n            # Filter block heights to only those within the cell's vertical bounds\n            # Add a small margin (half block width) to avoid blocks at exact boundaries\n            margin = block_width / 2\n            valid_block_heights = [\n                h for h in block_heights\n                if (cell_v_start + margin) < h < (cell_v_end - margin)\n            ]\n\n            if not valid_block_heights:\n                print(f\"  No valid block heights within cell vertical bounds [{cell_v_start:.2f}, {cell_v_end:.2f}]\")\n                continue\n\n            print(f\"  Valid block heights for this cell: {valid_block_heights}\")\n\n            # Create a cell dictionary with the required structure\n            cell_dict = {\n                'vertical_elements': stud_positions,\n                'cell_id': cell_key\n            }\n\n            blocks_in_cell = self._create_blocking_for_cell(\n                cell_dict,\n                valid_block_heights,  # Use filtered heights\n                block_thickness,\n                block_width,\n                base_plane\n            )\n            blocks.extend(blocks_in_cell)\n        \n        print(f\"Total cells with stud positions: {cells_with_studs}\")\n        print(f\"Total blocks created: {len(blocks)}\")\n        return blocks\n    \n    def _create_blocking_for_cell(self, cell, block_heights, block_thickness, block_width, base_plane):\n        \"\"\"\n        Create blocking elements for a single cell.\n        \n        Args:\n            cell: Dictionary with cell data\n            block_heights: List of heights for blocking elements\n            block_thickness: Thickness of blocking elements\n            block_width: Width of blocking elements\n            base_plane: Base plane of the wall\n            \n        Returns:\n            List of blocking Brep elements\n        \"\"\"\n        blocks = []\n        \n        # Extract vertical elements (stud positions)\n        # Sometimes these are stored as strings, so convert to floats\n        vertical_elements = cell.get('vertical_elements', [])\n        \n        # Try to handle both list and string formats\n        stud_positions = []\n        for pos in vertical_elements:\n            try:\n                # Handle string representation\n                if isinstance(pos, str):\n                    stud_positions.append(float(pos))\n                else:\n                    stud_positions.append(float(pos))\n            except (ValueError, TypeError) as e:\n                print(f\"Error converting stud position {pos}: {str(e)}\")\n                # Skip this position\n                continue\n        \n        # Sort stud positions\n        stud_positions = sorted(stud_positions)\n        \n        if len(stud_positions) < 2:\n            cell_id = cell.get('cell_id', 'unknown')\n            print(f\"Not enough studs in cell {cell_id} to create blocking. Found {len(stud_positions)} positions.\")\n            return blocks  # Need at least 2 studs to create blocking\n        \n        # Create blocking between adjacent studs\n        for i in range(len(stud_positions) - 1):\n            left_stud_pos = stud_positions[i]\n            right_stud_pos = stud_positions[i + 1]\n            \n            # Skip if studs are too close\n            if right_stud_pos - left_stud_pos < 0.5:  # Minimum 6\" between studs\n                continue\n            \n            # Create a block at each height\n            for block_height in block_heights:\n                # block_height is relative to wall base, pass directly as v_coordinate\n                # (the method handles transformation to world coordinates via base_plane)\n\n                # Create center point for the block\n                center_u = (left_stud_pos + right_stud_pos) / 2\n                center_point = self._create_point_at_u_coordinate(\n                    center_u, block_height, base_plane\n                )\n                \n                # Calculate length (span between studs minus stud width)\n                block_length = right_stud_pos - left_stud_pos - 0.125\n                \n                # Create the block\n                block = self._create_block_brep(\n                    center_point, \n                    block_length, \n                    block_width, \n                    block_thickness,\n                    base_plane\n                )\n                \n                if block:\n                    blocks.append(block)\n                    print(f\"Created block between studs at {left_stud_pos:.4f} and {right_stud_pos:.4f} at height {block_height:.4f}\")\n        \n        return blocks\n        \n    def _create_point_at_u_coordinate(self, u_coordinate, v_coordinate, base_plane):\n        \"\"\"\n        Create a 3D point at the given U and V coordinates in wall space.\n\n        Args:\n            u_coordinate: U coordinate along the wall (horizontal)\n            v_coordinate: V coordinate relative to wall base (vertical height above base)\n            base_plane: Base plane of the wall\n\n        Returns:\n            3D point in world coordinates\n        \"\"\"\n        try:\n            # Start at the origin of the base plane\n            point = rg.Point3d(base_plane.Origin)\n\n            # Move along the X axis of the base plane by u_coordinate\n            x_vector = rg.Vector3d(base_plane.XAxis)\n            x_vector *= u_coordinate\n            point += x_vector\n\n            # Move along the Y axis (wall vertical) by v_coordinate\n            # Note: v_coordinate is height above wall base, NOT world Z\n            y_vector = rg.Vector3d(base_plane.YAxis)\n            y_vector *= v_coordinate\n            point += y_vector\n\n            return point\n        except Exception as e:\n            print(f\"Error creating point at u-coordinate: {str(e)}\")\n\n            # Use direct coordinate extraction as fallback\n            try:\n                # Just extract X coordinate (assumes wall is aligned with world X axis)\n                print(f\"Using fallback coordinate extraction, point X: {u_coordinate}\")\n                # Use world Z for vertical in fallback\n                return rg.Point3d(u_coordinate, 0, self.wall_base_elevation + v_coordinate)\n            except Exception as e2:\n                print(f\"Fallback also failed: {str(e2)}\")\n                return None\n            \n    def _create_block_brep(self, center_point, length, width, thickness, base_plane):\n        \"\"\"\n        Create a block Brep at the specified location.\n        \n        Args:\n            center_point: Center point of the block\n            length: Length of the block (along wall)\n            width: Width of the block (perpendicular to wall)\n            thickness: Thickness of the block (height)\n            base_plane: Base plane of the wall\n            \n        Returns:\n            Block Brep\n        \"\"\"\n        try:\n            # Create a box centered at the point\n            half_length = length / 2\n            half_width = width / 2\n            half_thickness = thickness / 2\n            \n            # Create transform from world to wall coordinates\n            plane_at_center = rg.Plane(center_point, base_plane.XAxis, base_plane.YAxis)\n            \n            # Create the box\n            block = rg.Box(plane_at_center, \n                          rg.Interval(-half_length, half_length),\n                          rg.Interval(-half_width, half_width),\n                          rg.Interval(-half_thickness, half_thickness))\n            \n            return block.ToBrep()\n        except Exception as e:\n            print(f\"Error creating block brep: {str(e)}\")\n            return None\n\n    def generate(self) -> List[rg.Brep]:\n        \"\"\"\n        Generate row blocking elements based on configured cells and studs.\n        \n        Returns:\n            List of row blocking Brep elements\n        \"\"\"\n        blocks = []\n        include_blocking = self.blocking_params.include_blocking\n        if not include_blocking:\n            print(\"Blocking is disabled via parameters\")\n            return blocks\n            \n        # Get wall height\n        wall_height = self.wall_top_elevation - self.wall_base_elevation\n        print(f\"Wall height: {wall_height}\")\n        print(f\"Wall elevations: base={self.wall_base_elevation}, top={self.wall_top_elevation}\")\n        \n        # Get block heights from pattern or calculate them\n        if self.blocking_params.first_block_height:\n            first_block_height = self.blocking_params.first_block_height\n            block_heights = [first_block_height]\n            \n            # If wall is higher than twice the first block height, add additional blocks\n            remaining_height = wall_height - first_block_height\n            spacing = self.blocking_params.block_spacing\n            \n            if remaining_height > spacing:\n                num_additional_blocks = int(remaining_height / spacing)\n                for i in range(num_additional_blocks):\n                    block_heights.append(first_block_height + spacing * (i + 1))\n        else:\n            # Default to 1/3 and 2/3 of wall height\n            block_heights = [wall_height / 3, 2 * wall_height / 3]\n        \n        # Get blocking pattern\n        pattern = self.blocking_params.pattern\n        \n        # Get base plane from wall data - always use this for consistency\n        base_plane = self.wall_data.get(\"base_plane\")\n        if base_plane is None:\n            print(\"No base plane found in wall data, using WorldXY\")\n            base_plane = rg.Plane.WorldXY\n        \n        # Get dimensions for stud width adjustment\n        try:\n            dims = self.block_profile.get_dimensions()\n            block_width = dims[\"width\"]  # Vertical dimension (usually 1.5\" for 2x4)\n            block_thickness = dims[\"thickness\"]  # Horizontal dimension (usually 3.5\" for 2x4)\n            print(f\"Using block profile dimensions: {dims}\")\n        except (AttributeError, KeyError) as e:\n            # Fallback to direct attributes if get_dimensions not available\n            print(f\"Using direct profile attributes - get_dimensions failed: {str(e)}\")\n            try:\n                # Try nominal_width/nominal_depth\n                block_width = self.block_profile.nominal_width\n                block_thickness = self.block_profile.nominal_depth\n            except AttributeError:\n                # Last resort - try width/depth directly\n                try:\n                    block_width = self.block_profile.width\n                    block_thickness = self.block_profile.depth\n                except AttributeError:\n                    # Default to standard 2x4 dimensions\n                    print(\"WARNING: Could not determine block dimensions, using defaults for 2x4\")\n                    block_width = 1.5 / 12.0  # 1.5 inches in feet\n                    block_thickness = 3.5 / 12.0  # 3.5 inches in feet\n            \n        print(f\"Using block dimensions: width={block_width}, thickness={block_thickness}\")\n            \n        if pattern == BlockingPattern.STAGGERED:\n            print(\"Using STAGGERED blocking pattern\")\n            # Create cells dictionary from stud_positions\n            cells_dict = {}\n            for cell_id, positions in self.stud_positions.items():\n                if positions:  # Only include cells with stud positions\n                    cells_dict[cell_id] = positions\n            \n            if cells_dict:\n                blocks = self._create_staggered_blocking(cells_dict, block_heights, block_thickness, block_width, base_plane)\n            else:\n                print(\"No cells with stud positions found for staggered blocking\")\n        elif pattern == BlockingPattern.INLINE:\n            print(\"Using INLINE blocking pattern\")\n            \n            # Check if we have stud positions\n            if self.stud_positions:\n                blocks = self._generate_row_blocking(self.stud_positions, block_width, block_thickness, base_plane)\n            else:\n                print(\"No stud positions found for inline blocking\")\n        else:\n            print(f\"Unsupported blocking pattern: {pattern}\")\n        \n        print(f\"Generated {len(blocks)} blocking elements\")\n        return blocks\n    \n    def _create_staggered_blocking(self, cells, block_heights, block_thickness, block_width, base_plane):\n        \"\"\"\n        Create staggered pattern blocking across cells.\n        \n        Args:\n            cells: Dictionary of cells\n            block_heights: List of block heights\n            block_thickness: Thickness of blocking\n            block_width: Width of blocking\n            base_plane: Base plane for coordinates\n            \n        Returns:\n            List of blocking Brep elements\n        \"\"\"\n        blocks = []\n        pattern = self.blocking_params.pattern\n        \n        print(f\"Creating staggered blocking with pattern: {pattern}\")\n        \n        # TODO: Implement staggered blocking pattern\n        \n        return blocks\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}