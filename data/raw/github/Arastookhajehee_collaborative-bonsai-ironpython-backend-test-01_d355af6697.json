{
  "source_url": "https://github.com/Arastookhajehee/collaborative-bonsai-ironpython-backend-test-01/blob/51d4b7fbee6d81bf75935e0ed84669429cc7e7db/server.py",
  "repo": "Arastookhajehee/collaborative-bonsai-ironpython-backend-test-01",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "server.py",
  "instruction": "Server",
  "code": "import os\nimport clr\nclr.AddReference(\"System\")\nclr.AddReference(\"System.Data.Sqlite\")\nclr.AddReference(\"Newtonsoft.Json\")\nfrom System.Net import HttpListener\nfrom System.IO import StreamReader, StreamWriter\nimport json\nimport System\nimport math\nimport Rhino.Geometry as rg\nfrom System import Guid\nfrom Rhino.Geometry import Plane, Brep, Mesh, Curve, Box, Point3d, Vector3d, Interval\nfrom System.Drawing import Color\n# Newtonsoft dll is in the same folder\nimport Newtonsoft.Json\nfrom Newtonsoft.Json import JsonConvert\nfrom System.Data.SQLite import SQLiteConnection\nfrom Rhino.FileIO import SerializationOptions\nimport rhinoscriptsyntax as rs\nfrom System.Threading import ThreadPool, WaitCallback\n\n# using IronPython, set a websocket client\nclr.AddReference(\"WebsocketSharp.Core\")\nfrom WebSocketSharp import WebSocket\n\n# Create a WebSocket client\nws = WebSocket(\"ws://127.0.0.1:12541/\")  # replace with your WebSocket server URL\n\n# Define event handlers\ndef on_open(sender, e):\n    print(\"Connected to the server.\")\n\ndef on_message(sender, e):\n    # e.Data holds the received message.\n    print(\"Received message: {0}\".format(e.Data))\n\ndef on_error(sender, e):\n    print(\"Error: {0}\".format(e.Message))\n\ndef on_close(sender, e):\n    print(\"Connection closed. Code: {0}, Reason: {1}\".format(e.Code, e.Reason))\n\n\ndef plane_from_csv(csv):\n    parts = csv.split(',')\n    pnt = rg.Point3d(float(parts[0]),float(parts[1]),float(parts[2]))\n    vec1 = rg.Vector3d(float(parts[3]),float(parts[4]),float(parts[5]))\n    vec2 = rg.Vector3d(float(parts[6]),float(parts[7]),float(parts[8]))\n\n    return rg.Plane(pnt,vec1,vec2)\n\ndef PlaneToStick(placementPlane):\n    width = 18;\n    length = 300;\n    thickness = 18;\n    xInterval = rg.Interval(-width / 2, width / 2);\n    yInterval = rg.Interval(-length / 2, length / 2);\n    zInterval = rg.Interval(-thickness / 2, thickness / 2);\n    stick = rg.Box(placementPlane, xInterval, yInterval, zInterval).ToBrep();\n    return stick\n\ndef StickToPlane(stick):\n    sorted_faces = SortStickFaces(stick)\n    sides = GetSides(sorted_faces)\n    tips = GetTips(sorted_faces)\n    stick_plane = GetStickPlane(sides, tips)\n    rotated_stick_plane = rg.Plane(stick_plane.Origin, stick_plane.XAxis, stick_plane.ZAxis)\n    return rotated_stick_plane\n\ndef ScaleLine(line, factor):\n    linevec = rg.Vector3d(line[1]-line[0])\n    linemid = (line[0]+line[1])/2\n    lineplane = rg.Plane(linemid,rg.Plane.WorldXY.ZAxis)\n    line.Transform(rg.Transform.Scale(lineplane,factor,factor,factor))\n\ndef SortStickFaces(stick):\n    faces = stick.Faces\n    areas=[rg.AreaMassProperties.Compute(face).Area for face in faces]\n    faces_and_areas = zip(faces,areas)\n    sorted_faces = sorted(faces_and_areas, key=lambda x: x[1])\n    return sorted_faces\n\ndef GetSides(sorted_faces):\n    sides = [face[0] for face in sorted_faces[2:]]\n    return sides\n\ndef GetTips(sorted_faces):\n    tips = [face[0] for face in sorted_faces[:2]]\n    return tips\n\ndef GetThickness(tips):\n    area = rg.AreaMassProperties.Compute(tips[0]).Area\n    thickness = math.sqrt(area)\n    return thickness\n\ndef GetLength(tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    length = top.DistanceTo(bottom)\n    return length\n\ndef GetStickPlane(sides, tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    center = (top+bottom)/2\n    z_axis = rg.Vector3d(top-bottom)\n    x_axis = sides[0].NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef GetSidePlane(sides, side_id, stick_plane):\n    side = sides[side_id]\n    center = rg.AreaMassProperties.Compute(side).Centroid\n    x_axis = stick_plane.ZAxis\n    z_axis = side.NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef GetSharedPlane(side_plane_a, side_plane_b, shift_ab):\n    shared_line = rg.Intersect.Intersection.PlanePlane(side_plane_a,side_plane_b)[1]\n    ScaleLine(shared_line,100)\n    shared_vector = rg.Vector3d(shared_line[1]-shared_line[0])\n    shared_vector.Unitize()\n    shared_line = shared_line.ToNurbsCurve()\n    shared_line.Domain = rg.Interval(0,1)\n    shared_plane = rg.Plane(shared_line.PointAt(shift_ab),shared_vector)\n    return shared_plane\n    \ndef GetSharedLine(side_plane_a, side_plane_b, shift_ab):\n    shared_line = rg.Intersect.Intersection.PlanePlane(side_plane_a,side_plane_b)[1]\n    ScaleLine(shared_line,100)\n    shared_vector = rg.Vector3d(shared_line[1]-shared_line[0])\n    shared_vector.Unitize()\n    shared_line = shared_line.ToNurbsCurve()\n    shared_line.Domain = rg.Interval(0,1)\n    return shared_line\n\ndef CreateNewStick(stick, stick_plane, side_plane, shared_plane, shared_line, thickness, length, flip, shift):\n    line = rg.Intersect.Intersection.PlanePlane(shared_plane,side_plane)[1]\n    ScaleLine(line,100)\n    overlap = rg.Intersect.Intersection.CurveBrep(line.ToNurbsCurve(),stick,0.0001)[1]\n    if len(overlap)>0:\n        point = (overlap[0].PointAtStart+overlap[0].PointAtEnd)/2\n    else: point = (line[0]+line[1])/2\n    point = (point+shared_plane.Origin)/2\n    vector = rg.Vector3d(shared_line.PointAtEnd-shared_line.PointAtStart)\n    new_stick_plane = rg.Plane(point,vector,side_plane.ZAxis)\n    new_stick = stick.Duplicate()\n    new_stick.Transform(rg.Transform.PlaneToPlane(stick_plane,new_stick_plane))\n    new_stick.Transform(rg.Transform.Translation(thickness/2*new_stick_plane.YAxis))\n    new_stick.Transform(rg.Transform.Translation(flip*thickness/2*shared_plane.ZAxis))\n    new_stick.Transform(rg.Transform.Translation(length*shift*new_stick_plane.ZAxis))\n    return new_stick\n\ndef AdjustP1(sides,side_id,shared_plane):\n    face = sides[side_id]\n    edge = face.OuterLoop.To3dCurve()\n    segments = edge.DuplicateSegments()\n    vertices = [segment.PointAtStart for segment in segments]\n    distances = [vertice.DistanceTo(rg.Plane.ClosestPoint(shared_plane, vertice)) for vertice in vertices]\n    return (min(distances), max(distances))\n\ndef GenerateLink(stick_a,stick_b,side_id_a,side_id_b, shift_ab, flip, shift_a, shift_b):\n\n    # Get Planes\n    sorted_faces_a = SortStickFaces(stick_a)\n    sides_a = GetSides(sorted_faces_a)\n    tips_a = GetTips(sorted_faces_a)\n    sorted_faces_b = SortStickFaces(stick_b)\n    sides_b = GetSides(sorted_faces_b)\n    tips_b = GetTips(sorted_faces_b)\n    thickness_a = GetThickness(tips_a)\n    length_a = GetLength(tips_a)\n    thickness_b = GetThickness(tips_b)\n    length_b = GetLength(tips_b)\n    stick_plane_a = GetStickPlane(sides_a, tips_a)\n    center_a = stick_plane_a.Origin\n    stick_plane_b = GetStickPlane(sides_b, tips_b)\n    center_b = stick_plane_b.Origin\n    side_plane_a = GetSidePlane(sides_a, side_id_a, stick_plane_a)\n    side_plane_b = GetSidePlane(sides_b, side_id_b, stick_plane_b)\n    temp=(side_plane_a,side_plane_b)\n    \n    shared_plane = GetSharedPlane(side_plane_a, side_plane_b, 0)\n    shared_line = GetSharedLine(side_plane_a, side_plane_b, 0)\n\n    # Adjust P1\n    min_distance_a = AdjustP1(sides_a,side_id_a,shared_plane)[0]\n    max_distance_a = AdjustP1(sides_a,side_id_a,shared_plane)[1]\n    min_distance_b = AdjustP1(sides_b,side_id_b,shared_plane)[0]\n    max_distance_b = AdjustP1(sides_b,side_id_b,shared_plane)[1]\n    min_distance = max((min_distance_a, min_distance_b))\n    max_distance = min((max_distance_a, max_distance_b))\n    translation = shift_ab*min_distance+(1-shift_ab)*max_distance\n    shared_plane.Translate(translation*shared_plane.ZAxis)\n\n    # Create sticks\n    if flip is True: flip = 1\n    else: flip = -1\n    stick_c = CreateNewStick(stick_a, stick_plane_a, side_plane_a, shared_plane, shared_line, thickness_a, length_a, flip, shift_a)\n    stick_d = CreateNewStick(stick_b, stick_plane_b, side_plane_b, shared_plane, shared_line, thickness_b, length_b, -flip, shift_b)\n    #return stick_c, stick_d, shared_line, stick_line_c, stick_line_d\n    return (stick_c, stick_d)\n\ndef process_planes(branch_a, branch_b, shift_ab, shift_a, shift_b):\n    vec1 = branch_a.ZAxis\n    vec2 = branch_b.ZAxis\n    errors_txt = []\n    #print vec1.IsParallelTo(vec2, 0.01)\n    #print vec1.IsPerpendicularTo(vec2, 0.01)\n    #if vec1.IsParallelTo(vec2, 0.01) == 0 or vec1.IsPerpendicularTo(vec2, 0.01) is False:\n    stick_a = PlaneToStick(branch_a)\n    stick_b = PlaneToStick(branch_b)\n    sorted_faces_a = SortStickFaces(stick_a)\n    sides_a = GetSides(sorted_faces_a)\n    tips_a = GetTips(sorted_faces_a)\n    thickness_a = GetThickness(tips_a)\n    length_a = GetLength(tips_a)\n    min_glue_area = thickness_a**2\n    configurations = []\n    for i in range(4): # 4 sides_a\n        for j in range(4): # 4 sides_b\n            for k in [True, False]: # flip = True or False\n                try:\n                    configurations.append(GenerateLink(stick_a,stick_b,i,j, shift_ab, k, shift_a, shift_b))\n                except:\n                    configurations.append(None)\n    valid_configurations = []\n    other_configurations = []\n    valid_ids = []\n    n=0\n    for configuration in configurations:\n        if configuration != None:\n            stick_c, stick_d = configuration[0:2]\n            temp = stick_c, stick_d\n            flag = False\n            if len(rg.Intersect.Intersection.BrepBrep(stick_a, stick_d, 0.001)[1]) == 0:\n                if len(rg.Intersect.Intersection.BrepBrep(stick_b, stick_c, 0.001)[1]) == 0:\n                    if len(rg.Intersect.Intersection.BrepBrep(stick_c, stick_d, 0.001)[1]) > 0:\n                        if len(rg.Intersect.Intersection.BrepBrep(stick_a, stick_c, 0.001)[1]) > 0:\n                            if len(rg.Intersect.Intersection.BrepBrep(stick_b, stick_d, 0.001)[1]) > 0:\n                                cd = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_c, stick_d, 0.001)[1]))\n                                ac = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_a, stick_c, 0.001)[1]))\n                                bd = rg.Brep.CreatePlanarBreps(rg.Curve.JoinCurves(rg.Intersect.Intersection.BrepBrep(stick_b, stick_d, 0.001)[1]))\n                                if cd is not None and ac is not None and bd is not None:\n                                    if rg.AreaMassProperties.Compute(cd).Area > min_glue_area and rg.AreaMassProperties.Compute(ac).Area > min_glue_area and rg.AreaMassProperties.Compute(bd).Area > min_glue_area:\n                                            valid_configurations.append(configuration)\n                                            valid_ids.append(n)\n                                            flag = True\n                                            errors_txt.append(None)\n                                    else: errors_txt.append(\"insufficient contact\")\n                                else: errors_txt.append(\"insufficient contact\")\n                            else: errors_txt.append(\"no contact\")\n                        else: errors_txt.append(\"no contact\")\n                    else: errors_txt.append(\"no contact\")\n                else: errors_txt.append(\"collision\")\n            else: errors_txt.append(\"collision\")\n            if flag is False:\n                other_configurations.append(configuration)\n        n+=1\n    #else: errors_txt.append(\"Coplanar sticks...\")\n    return valid_configurations, configurations, valid_ids, errors_txt\n\ndef StickToPlane(stick):\n    sorted_faces = SortStickFaces(stick)\n    sides = GetSides(sorted_faces)\n    tips = GetTips(sorted_faces)\n    stick_plane = GetStickPlane(sides, tips)\n    rotated_stick_plane = rg.Plane(stick_plane.Origin, stick_plane.XAxis, stick_plane.ZAxis)\n    return rotated_stick_plane\n\ndef SortStickFaces(stick):\n    faces = stick.Faces\n    areas=[rg.AreaMassProperties.Compute(face).Area for face in faces]\n    faces_and_areas = zip(faces,areas)\n    sorted_faces = sorted(faces_and_areas, key=lambda x: x[1])\n    return sorted_faces\n\ndef GetSides(sorted_faces):\n    sides = [face[0] for face in sorted_faces[2:]]\n    return sides\n\ndef GetTips(sorted_faces):\n    tips = [face[0] for face in sorted_faces[:2]]\n    return tips\n\ndef GetStickPlane(sides, tips):\n    top = rg.AreaMassProperties.Compute(tips[0]).Centroid\n    bottom = rg.AreaMassProperties.Compute(tips[1]).Centroid\n    center = (top+bottom)/2\n    z_axis = rg.Vector3d(top-bottom)\n    x_axis = sides[0].NormalAt(0,0)\n    y_axis = rg.Vector3d.CrossProduct(z_axis, x_axis)\n    plane = rg.Plane(center,x_axis,y_axis)\n    return plane\n\ndef process_sticks(run, only_valid, valid_configurations, configurations,valid_ids,errors_txt, browse=0):\n    if run:\n        #if errors_txt[0] != \"Coplanar sticks...\":\n        if only_valid:\n            if len(valid_configurations) > 0:\n                browse = browse%len(valid_configurations)\n                stick_c, stick_d = valid_configurations[browse]\n                plane_c = StickToPlane(stick_c)\n                plane_d = StickToPlane(stick_d)\n                conf_id = \"configuration number: \"+ str(valid_ids[browse])\n                return plane_c, plane_d\n            else:\n                conf_id = \"no valid configurations\"\n                return None, None\n        \n        else:\n            stick_c, stick_d = configurations[browse]\n            plane_c = StickToPlane(stick_c)\n            plane_d = StickToPlane(stick_d)\n            return plane_c, plane_d\n            print(errors_txt[browse])\n        #else:\n            #print(errors_txt[0])\n            #plane_c=branch_a.placementPlane\n            #plane_d=branch_b.placementPlane\n    else:\n        conf_id = \"please select two sticks\"\n\ndef csv_from_plane(plane01):\n    plane01csv = str.format(\n        \"{},{},{},{},{},{},{},{},{}\",\n        plane01.Origin.X, \n        plane01.Origin.Y, \n        plane01.Origin.Z, \n        plane01.XAxis.X, \n        plane01.XAxis.Y, \n        plane01.XAxis.Z, \n        plane01.YAxis.X, \n        plane01.YAxis.Y, \n        plane01.YAxis.Z, \n    )\n    return plane01csv\n\ndef process_bridge(branch_a_csv, branch_b_csv, shift_ab= -4.95, shift_a = 0.146, shift_b= -0.186,browse = 0,only_valid = False):\n    branch_a = plane_from_csv(branch_a_csv)\n    branch_b = plane_from_csv(branch_b_csv)\n    valid_configurations, configurations, valid_ids, errors_txt = process_planes(branch_a, branch_b, shift_ab, shift_a, shift_b)\n    plane_c, plane_d = process_sticks(True, only_valid, valid_configurations, configurations,valid_ids,errors_txt, browse)\n    \n    return plane_c, plane_d\n\n\n\n\n# Hook up the event handlers\nws.OnOpen += on_open\nws.OnMessage += on_message\nws.OnError += on_error\nws.OnClose += on_close\n\n# Connect to the WebSocket server\nws.Connect()\n\n# Send an initial message (for example, a \"ping\" or your request)\nws.Send(\"ping\")\n\n\n\n\nfrom TimberBranch import TimberBranch\n\n\n\n\ndef send_data_to_websocket(ws_client, id, width, length, thickness, placement_plane,\n                                 duplicate_plane, orientable_planes, mesh_box, user, color, state,\n                                 parent_ids, child_ids, selected, build_on_plane, message,\n                                 design_time_stamp, modification_time_stamp, physical_time_stamp,\n                                 fabricated_time_stamp, fabrication_fail, placement_glue_shift,\n                                 placement_shift, designer):\n    data = {\n        \"type\": \"InsertData\",\n        \"ID\": id, \"width\": width, \"length\": length, \"thickness\": thickness,\n        \"placementPlane\": placement_plane, \"duplicatePlane\": duplicate_plane,\n        \"orientablePlanes\": orientable_planes, \"meshBox\": mesh_box, \"user\": user,\n        \"color\": color, \"state\": state, \"parentIDs\": parent_ids, \"childIDs\": child_ids,\n        \"selected\": selected, \"buildOnPlane\": build_on_plane, \"message\": message,\n        \"designTimeStamp\": design_time_stamp, \"modificationTimeStamp\": modification_time_stamp,\n        \"physicalTimeStamp\": physical_time_stamp, \"fabricatedTimeStamp\": fabricated_time_stamp,\n        \"fabricationFail\": fabrication_fail, \"placementGlueShift\": placement_glue_shift,\n        \"placementShift\": placement_shift, \"designer\": designer\n    }\n\n    ws_client.Send(json.dumps(data))\n    print(\"Data sent to WebSocket server.\")\n\n\n\nclass sqlite_db:\n    \n    @staticmethod\n    def db_exists(path):\n        return os.path.exists(path)\n    \n    @staticmethod\n    def save_stick_to_db(save, t_branch, db_path):\n        # connection = SQLiteConnection(\"Data Source='{}';Version=3;\".format(db_path))\n        # connection.Open()\n        \n        new_meshes = []\n        \n        for item in t_branch:\n            s = item\n            op = SerializationOptions()\n            \n            ms_box = s.meshBox\n            ms_box.Flip(True, True, True)\n            \n            iv_x = Interval(-150, 150)\n            iv_yz = Interval(-9, 9)\n            bx = Box(s.placementPlane, iv_yz, iv_x, iv_yz)\n            \n            new_ms_box = Mesh.CreateFromBox(bx, 3, 18, 3)\n            new_meshes.append(new_ms_box)\n            \n            if save:\n                send_data_to_websocket(\n                    ws, str(s.ID), s.width, s.length, s.thickness,\n                    sqlite_db.plane_to_string(s.placementPlane), sqlite_db.plane_to_string(s.placementPlane), \"\",\n                    new_ms_box.ToJSON(op), s.user, sqlite_db.rgb_to_string(s.color), s.state, \"\", \"\",\n                    s.selected, sqlite_db.plane_to_string(s.buildOnPlane), s.message, s.designTimeStamp,\n                    s.modificationTimeStamp, s.physicalTimeStamp, s.fabricatedTimeStamp,\n                    s.fabricationFail, s.placementGlueShift, s.placementShift, s.user\n                )\n        # connection.Close()\n    \n    @staticmethod\n    def plane_to_string(plane):\n        og = plane.Origin\n        vec_x = plane.XAxis\n        vec_y = plane.YAxis\n        return \"{},{},{},{},{},{},{},{},{}\".format(og.X, og.Y, og.Z, vec_x.X, vec_x.Y, vec_x.Z, vec_y.X, vec_y.Y, vec_y.Z)\n    \n    @staticmethod\n    def string_to_plane(plane_str):\n        plane = plane_str.split(\",\")\n        origin = Point3d(float(plane[0]), float(plane[1]), float(plane[2]))\n        x_axis = Vector3d(float(plane[3]), float(plane[4]), float(plane[5]))\n        y_axis = Vector3d(float(plane[6]), float(plane[7]), float(plane[8]))\n        return Plane(origin, x_axis, y_axis)\n\n    @staticmethod\n    def rgb_to_string(color):\n        return \"{},{},{}\".format(color.R, color.G, color.B)\n    \n    @staticmethod\n    def string_to_rgb(color_str):\n        rgb = color_str.split(\",\")\n        return Color.FromArgb(int(rgb[0]), int(rgb[1]), int(rgb[2]))\n    \n    @staticmethod\n    def get_placement_with_id(db_path, id):\n        plane_data = None\n        connection_string = \"Data Source='{}';Version=3;\".format(db_path)\n    \n        with SQLiteConnection(connection_string) as connection:\n            connection.Open()\n            with connection.CreateCommand() as select_command:\n                select_command.CommandText = \"SELECT placementPlane FROM GEOMETRIES WHERE ID = @id\"\n                select_command.Parameters.AddWithValue(\"@id\", id)\n    \n                with select_command.ExecuteReader() as reader:\n                    if reader.Read():\n                        plane_data = reader.GetString(0)\n    \n        rh_plane = sqlite_db.string_to_plane(plane_data) if plane_data else None\n        return rh_plane\n\n    @staticmethod\n    def insert_data(connection, id, width, length, thickness, placement_plane,\n                    duplicate_plane, orientable_planes, mesh_box, user, color, state,\n                    parent_ids, child_ids, selected, build_on_plane, message,\n                    design_time_stamp, modification_time_stamp, physical_time_stamp,\n                    fabricated_time_stamp, fabrication_fail, placement_glue_shift,\n                    placement_shift, designer):\n        \n        with connection.CreateCommand() as insert_command:\n            insert_command.CommandText = \"\"\"\n            INSERT INTO GEOMETRIES\n            (ID, width, length, thickness, placementPlane, duplicatePlane, orientablePlanes,\n            meshBox, user, color, state, parentIDs, childIDs, selected, buildOnPlane,\n            message, designTimeStamp, modificationTimeStamp, physicalTimeStamp,\n            fabricatedTimeStamp, fabricationFail, placementGlueShift, placementShift, designer)\n            VALUES\n            (@id, @width, @length, @thickness, @placementPlane, @duplicatePlane, @orientablePlanes,\n            @meshBox, @user, @color, @state, @parentIDs, @childIDs, @selected, @buildOnPlane,\n            @message, @designTimeStamp, @modificationTimeStamp, @physicalTimeStamp,\n            @fabricatedTimeStamp, @fabricationFail, @placementGlueShift, @placementShift, @designer)\n            \"\"\"\n            \n            params = [\n                (\"@id\", id), (\"@width\", width), (\"@length\", length), (\"@thickness\", thickness),\n                (\"@placementPlane\", placement_plane), (\"@duplicatePlane\", duplicate_plane),\n                (\"@orientablePlanes\", orientable_planes), (\"@meshBox\", mesh_box), (\"@user\", user),\n                (\"@color\", color), (\"@state\", state), (\"@parentIDs\", parent_ids), (\"@childIDs\", child_ids),\n                (\"@selected\", selected), (\"@buildOnPlane\", build_on_plane), (\"@message\", message),\n                (\"@designTimeStamp\", design_time_stamp), (\"@modificationTimeStamp\", modification_time_stamp),\n                (\"@physicalTimeStamp\", physical_time_stamp), (\"@fabricatedTimeStamp\", fabricated_time_stamp),\n                (\"@fabricationFail\", fabrication_fail), (\"@placementGlueShift\", placement_glue_shift),\n                (\"@placementShift\", placement_shift), (\"@designer\", designer)\n            ]\n            \n            for param, value in params:\n                insert_command.Parameters.AddWithValue(param, value)\n            \n            insert_command.ExecuteNonQuery()\n\n\ndef get_proper_plane_for_point(plane, input_plane,offset):\n    pnt = input_plane.Origin\n    pl2 = rg.Plane(plane)\n    pl2.Rotate(math.pi / 2, plane.YAxis, plane.Origin)\n\n    high_dot = float('-inf')\n    best = rg.Plane.Unset\n    vec = pnt - plane.Origin\n\n    \n\n    for i in range(4):\n        pl3 = rg.Plane(plane)\n        pl3.Rotate(math.pi / 2 * i, plane.YAxis, plane.Origin)\n        \n        dot = vec * pl3.ZAxis\n        if dot > high_dot:\n            high_dot = dot\n            best = pl3\n\n    projection = best.ClosestPoint(pnt) + best.ZAxis * offset\n\n    planar_trs = rg.Transform.PlanarProjection(best)\n    input_plane.Transform(planar_trs)\n\n    final = rg.Plane(projection, input_plane.XAxis, input_plane.YAxis)\n    final.Origin = projection\n\n    return final\n\n\ndef get_proper_plane_aligned(plane, input_plane,offset = 18):\n    \n    dist_0, dist_dif_0 = pnt_z_distance(plane, input_plane)\n    \n    plane01 = Plane(input_plane)\n    plane02 = Plane(input_plane)\n    \n    plane01.Translate(plane01.ZAxis * dist_dif_0)\n    plane02.Translate(plane02.ZAxis * -dist_dif_0)\n    \n    \n    temp, dif_1 = pnt_z_distance(plane,plane01)\n    temp, dif_2 = pnt_z_distance(plane,plane02)\n    \n    if dif_1 < 0.0001:\n        return plane01\n    else:    \n        return plane02\n\ndef pnt_z_distance(plane, input_plane,offset = 18):\n    \n    target_og = plane.Origin\n    projected_tgt = input_plane.ClosestPoint(target_og)\n    \n    dist = target_og.DistanceTo(projected_tgt)\n    dist_dif = abs(offset - dist)\n    return dist, dist_dif\n\n\ndef get_proper_plane_from_quaternion(q_x, q_y, q_z, q_w, p_x, p_y, p_z):\n    plane = rg.Plane.WorldZX\n    \n    quaternion = rg.Quaternion(q_y, q_w, q_z, q_x)\n    \n    transform_box = clr.StrongBox[rg.Transform](rg.Transform.Unset)\n    success = quaternion.GetRotation(transform_box)\n\n    if success:\n        plane.Transform(transform_box.Value)\n\n    plane.Origin = rg.Point3d(p_x, p_y, p_z)\n\n    return plane\n\n\n# Create and configure the HttpListener\nlistener = HttpListener()\nlistener.Prefixes.Add(\"http://127.0.0.1:5632/\")\nlistener.Start()\n\nprint(\"IronPython HTTP Server is running on http://192.168.1.101:5632/\")\n\ndef MakeBranchFromData(data,db_path):\n    plane = sqlite_db.string_to_plane(data[\"placementPlane\"])\n    designer = data[\"designer\"]\n    color = sqlite_db.string_to_rgb(data[\"color\"])\n    parentID = data[\"parentID\"]\n    \n    \n    \n    if sqlite_db.db_exists(db_path):\n        # get the parent branch\n        parent_plane = sqlite_db.get_placement_with_id(db_path,parentID)\n        \n        # get the proper plane for the parent branch\n        # proper_plane = get_proper_plane_for_point(plane, parent_plane,18)\n#                    proper_plane = get_proper_plane_from_quaternion(data[\"q_x\"],data[\"q_y\"],data[\"q_z\"],data[\"q_w\"],data[\"p_x\"],data[\"p_y\"],data[\"p_z\"])\n        \n        proper_plane = get_proper_plane_aligned(parent_plane, plane,18)\n        \n        \n        branch = TimberBranch(placement_plane=proper_plane , user=designer, color=color, state=\"virtual\", branch=None, parentIDs=[parentID])\n        branch.ID = data[\"ID\"]\n        return branch\n\ndef MakeBridgeFromData(data,db_path):\n    plane_01 = sqlite_db.string_to_plane(data[\"plane_03\"])\n    plane_02 = sqlite_db.string_to_plane(data[\"plane_04\"])\n    designer = data[\"designer\"]\n    color = sqlite_db.string_to_rgb(data[\"color\"])\n    parentID_01 = data[\"parent_ID_01\"]\n    parentID_02 = data[\"parent_ID_02\"]\n    \n    \n    \n    if sqlite_db.db_exists(db_path):\n        # get the parent branch\n        parent_plane_01 = sqlite_db.get_placement_with_id(db_path,parentID_01)\n        parent_plane_02 = sqlite_db.get_placement_with_id(db_path,parentID_02)\n        \n        # get the proper plane for the parent branch\n        # proper_plane = get_proper_plane_for_point(plane, parent_plane,18)\n#                    proper_plane = get_proper_plane_from_quaternion(data[\"q_x\"],data[\"q_y\"],data[\"q_z\"],data[\"q_w\"],data[\"p_x\"],data[\"p_y\"],data[\"p_z\"])\n        \n        proper_plane_01 = get_proper_plane_aligned(parent_plane_01, plane_01,18)\n        proper_plane_02 = get_proper_plane_aligned(parent_plane_02, plane_02,18)\n        \n        \n        branch_01 = TimberBranch(placement_plane=plane_01 , user=designer, color=color, state=\"virtual\", branch=None, parentIDs=[parentID_01])\n        branch_02 = TimberBranch(placement_plane=plane_02 , user=designer, color=color, state=\"virtual\", branch=None, parentIDs=[parentID_02])\n        branch_01.ID = data[\"ID_01\"]\n        branch_02.ID = data[\"ID_02\"]\n        return [branch_01,branch_02]\n\ndef process_message(context):\n    request = context.Request\n    response = context.Response\n    response.AddHeader(\"Access-Control-Allow-Origin\", \"https://bonsai.remosharp.com\")\n    response.AddHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n    response.AddHeader(\"Access-Control-Allow-Headers\", \"Content-Type\")\n    \n    \n    # Handle preflight OPTIONS request\n    if request.HttpMethod == \"OPTIONS\":\n        response.StatusCode = 200  # OK\n        response.ContentLength64 = 0\n        response.OutputStream.Close()\n        return  # Skip the rest and wait for another request\n    \n    \n    # Check if it's a POST request\n    if request.HttpMethod == \"POST\":\n        try:\n            # Read and parse the JSON payload\n            reader = StreamReader(request.InputStream, request.ContentEncoding)\n            json_data = reader.ReadToEnd()\n            reader.Close()\n            data = json.loads(json_data)  # Parse JSON\n            # print(\"Received JSON:\", data)\n            stop_server = data[\"stop_server\"] if \"stop_server\" in data else []\n            \n            \n            \n            if stop_server == \"akhajsourcereposSQLiteRhi\":\n                response.StatusCode = 200  # OK\n                response.ContentLength64 = 0\n                listener.Stop()\n                return\n            # Construct a response\n            message_type = data[\"type\"]\n            db_path = r\"D:\\Projects\\source\\repos\\collaborative-bonsai-node-backend-test-01\\Bonsai.db\"\n            if (message_type == \"BridgeRequest\"):\n                \n                designer = data[\"designer\"]\n                register = data[\"register\"]\n                color = sqlite_db.string_to_rgb(data[\"color\"])\n                \n                \n                if not register:\n                    # get many possible solutions\n                    # a range between -2.50 and 2.50\n                    plane_c, plane_d = process_bridge(\n                                    data[\"plane_01\"],\n                                    data[\"plane_02\"],\n                                    data[\"shift_ab\"],\n                                    data[\"shift_a\"],\n                                    data[\"shift_b\"],\n                                    data[\"browse\"],\n                                    data[\"only_valid\"]\n                                    )\n                    \n                    plane_c_CSV = csv_from_plane(plane_c)\n                    plane_d_CSV = csv_from_plane(plane_d)\n                    \n                    data[\"plane_03\"] = plane_c_CSV\n                    data[\"plane_04\"] = plane_d_CSV\n                    \n                    response_json = json.dumps(data)\n                    response.StatusCode = 200  # OK\n                    response.ContentType = \"application/json\"\n                    response.ContentLength64 = len(response_json)\n                    writer = StreamWriter(response.OutputStream)\n                    \n                    writer.Write(response_json)\n                    writer.Flush()\n                    response.OutputStream.Close()\n                else:\n                    \n                    bridge = MakeBridgeFromData(data,db_path)\n                    sqlite_db.save_stick_to_db(True,bridge,db_path)\n                    \n                    \n                    # Send response\n                    result ={\n                        \"status\": \"success\",\n                        \"message\": \"bridge created successfully\"\n                    }\n                    \n                    response_json = json.dumps(result)\n                    response.StatusCode = 200  # OK\n                    response.ContentType = \"application/json\"\n                    response.ContentLength64 = len(response_json)\n                    writer = StreamWriter(response.OutputStream)\n                    \n                    writer.Write(response_json)\n                    writer.Flush()\n                    response.OutputStream.Close()\n                    \n                    ws.Send(\"update_all\")\n            else:\n                plane = sqlite_db.string_to_plane(data[\"placementPlane\"])\n                designer = data[\"designer\"]\n                color = sqlite_db.string_to_rgb(data[\"color\"])\n                parentID = data[\"parentID\"]\n                \n\n                \n                \n                if sqlite_db.db_exists(db_path):\n                    # get the parent branch\n                    parent_plane = sqlite_db.get_placement_with_id(db_path,parentID)\n                    \n                    # get the proper plane for the parent branch\n                    # proper_plane = get_proper_plane_for_point(plane, parent_plane,18)\n#                    proper_plane = get_proper_plane_from_quaternion(data[\"q_x\"],data[\"q_y\"],data[\"q_z\"],data[\"q_w\"],data[\"p_x\"],data[\"p_y\"],data[\"p_z\"])\n                    \n                    proper_plane = get_proper_plane_aligned(parent_plane, plane,18)\n                    \n                    \n                    branch = TimberBranch(placement_plane=proper_plane , user=designer, color=color, state=\"virtual\", branch=None, parentIDs=[parentID])\n                    branch.ID = data[\"ID\"]\n                    dics = \"temp\"\n                    sqlite_db.save_stick_to_db(True,[branch],db_path)\n                \n                \n                # Send response\n                result ={\n                    \"status\": \"success\",\n                    \"message\": \"Branch created successfully\",\n                    \"branch_id\": branch.ID.ToString()\n                }\n                \n                response_json = json.dumps(result)\n                response.StatusCode = 200  # OK\n                response.ContentType = \"application/json\"\n                response.ContentLength64 = len(response_json)\n                writer = StreamWriter(response.OutputStream)\n                \n                writer.Write(response_json)\n                writer.Flush()\n                response.OutputStream.Close()\n                \n                ws.Send(\"update_all\")\n\n        except Exception as e:\n            # Handle JSON errors\n            error_response = {\"status\": \"error\", \"message\": str(e)}\n            response_json = json.dumps(error_response)\n            response.StatusCode = 400  # Bad request\n            response.ContentType = \"application/json\"\n            response.ContentLength64 = len(response_json)\n            writer = StreamWriter(response.OutputStream)\n            writer.Write(response_json)\n            writer.Flush()\n            response.OutputStream.Close()\n\n    else:\n        # Handle unsupported request methods\n        response.StatusCode = 405  # Method Not Allowed\n        response.ContentLength64 = 0\n        response.OutputStream.Close()\n\n\n\n\ntry:\n    while True:\n        context = listener.GetContext()  # Wait for a request\n        ThreadPool.QueueUserWorkItem(WaitCallback(process_message), context)\n    listener.Stop()\n\nexcept KeyboardInterrupt:\n    print(\"\\nShutting down server...\")\n    listener.Stop()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}