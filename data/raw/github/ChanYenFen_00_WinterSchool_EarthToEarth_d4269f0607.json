{
  "source_url": "https://github.com/ChanYenFen/00_WinterSchool_EarthToEarth/blob/03f0f28eb67b6de613776969259533281c1be83b/Script_Files/simple_ur_script.py",
  "repo": "ChanYenFen/00_WinterSchool_EarthToEarth",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Script_Files/simple_ur_script.py",
  "instruction": "This module wraps standard UR Script functions.\nMain change is that plane infromation substitute for pose data",
  "code": "\"\"\"\nThis module wraps standard UR Script functions.\nMain change is that plane infromation substitute for pose data\n\"\"\"\n\nimport utils\nimport Rhino.Geometry as rg\n\n# Some Constants\nMAX_ACCEL = 1.5\nMAX_VELOCITY = 2\n\ndef move_l(plane_to, accel, vel):\n    \"\"\"\n    Function that returns UR script for linear movement in tool-space.\n\n    Args:\n        plane_to: Rhino.Geometry Plane. A target plane for calculating pose (in UR base coordinate system)\n        accel: tool accel in m/s^2\n        vel: tool speed in m/s\n\n    Returns:\n        script: UR script\n    \"\"\"\n\n    # Check acceleration and velocity are non-negative and below a set limit\n    accel = MAX_ACCEL if (abs(accel) >MAX_ACCEL) else abs(accel)\n    vel = MAX_VELOCITY if (abs(vel) > MAX_VELOCITY) else abs(vel)\n\n    _matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,plane_to)\n    _axis_angle= utils.matrix_to_axis_angle(_matrix)\n    # Create pose data\n    _pose = [plane_to.OriginX/1000, plane_to.OriginY/1000, plane_to.OriginZ/1000,_axis_angle[0], _axis_angle[1], _axis_angle[2]]\n    _pose_fmt = \"p[\" + (\"%.4f,\"*6)[:-1]+\"]\"\n    _pose_fmt = _pose_fmt%tuple(_pose)\n    # Format UR script\n    script = \"movel(%s, a = %.2f, v = %.2f)\\n\"%(_pose_fmt,accel,vel)\n    return script\n\n\ndef move_l_blend(plane_to, accel, vel, blend_radius = 0):\n    \"\"\"\n    Function that returns UR script for linear movement in tool-space.\n    \n    Args:\n        plane_to: Rhino.Geometry Plane. A target plane for calculating pose (in UR base coordinate system)\n        accel: tool accel in m/s^2\n        vel: tool speed in m/s\n        \n    Returns:\n        script: UR script\n    \"\"\"\n    \n    # Check acceleration and velocity are non-negative and below a set limit\n    accel = MAX_ACCEL if (abs(accel) >MAX_ACCEL) else abs(accel)\n    vel = MAX_VELOCITY if (abs(vel) > MAX_VELOCITY) else abs(vel)\n    # Check blend radius is positive\n    blend_radius = max(0, blend_radius)\n\n    _matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,plane_to)\n    _axis_angle= utils.matrix_to_axis_angle(_matrix)\n    # Create pose data\n    _pose = [plane_to.OriginX/1000, plane_to.OriginY/1000, plane_to.OriginZ/1000,_axis_angle[0], _axis_angle[1], _axis_angle[2]]\n    _pose_fmt = \"p[\" + (\"%.4f,\"*6)[:-1]+\"]\"\n    _pose_fmt = _pose_fmt%tuple(_pose)\n    # Format UR script\n    script = \"movel(%s, a = %.3f, v = %.3f, r = %.3f)\\n\"%(_pose_fmt, accel, vel, blend_radius)\n    return script\n\ndef move_j(joints, accel, vel):\n    \"\"\"\n    Function that returns UR script for linear movement in joint space.\n\n    Args:\n        joints: A list of 6 joint angles (double).\n        accel: tool accel in m/s^2\n        accel: tool accel in m/s^2\n        vel: tool speed in m/s\n\n    Returns:\n        script: UR script\n    \"\"\"\n    # Check acceleration and velocity are non-negative and below a set limit\n\n    _j_fmt = \"[\" + (\"%.2f,\"*6)[:-1]+\"]\"\n    _j_fmt = _j_fmt%tuple(joints)\n    script = \"movej(%s, a = %.2f, v = %.2f)\\n\"%(_j_fmt,accel,vel)\n    return script\n\ndef set_tcp_by_plane(x_offset, y_offset, z_offset, ref_plane=rg.Plane.WorldXY):\n    \"\"\"\n    TODO: Need to test if this gives the correct result\n    Function that returns UR script for setting tool center point\n\n    Args:\n        x_offset: float. tooltip offset in mm\n        y_offset: float. tooltip offset in mm\n        z_offset: float. tooltip offset in mm\n        ref_plane: Plane that defines orientation of the tip. If none specified, world XY plane used as default. (in UR base coordinate system)\n\n    Returns:\n        script: UR script\n    \"\"\"\n\n    if (ref_plane != rg.Plane.WorldXY):\n        _matrix = rg.Transform.PlaneToPlane(rg.Plane.WorldXY,ref_plane)\n        _axis_angle= utils.matrix_to_axis_angle(_matrix)\n    else:\n        _axis_angle = rg.Vector3d(0,0,0)\n    # Create pose data\n    _pose = [x_offset/1000, y_offset/1000, z_offset/1000,_axis_angle[0], _axis_angle[1], _axis_angle[2]]\n    _pose_fmt = \"p[\" + (\"%.4f,\"*6)[:-1]+\"]\"\n    _pose_fmt = _pose_fmt%tuple(_pose)\n\n    # Format UR script\n    script = \"set_tcp(%s)\\n\"%(_pose_fmt)\n    return script\n\ndef set_tcp_by_angles(x_offset, y_offset, z_offset, x_rotate, y_rotate, z_rotate):\n    \"\"\"\n    TODO(Jason): Need to test this\n    Function that returns UR script for setting tool center point\n\n    Args:\n        x_offset: float. tooltip offset in mm\n        y_offset: float. tooltip offset in mm\n        z_offset: float. tooltip offset in mm\n        x_rotation: float. rotation around world x axis in radians\n        y_rotation: float. rotation around world y axis in radians\n        z_rotation: float. rotation around world z axis in radians\n\n    Returns:\n        script: UR script\n    \"\"\"\n\n    #Create rotation matrix\n    _rX = rg.Transform.Rotation(x_rotate, rg.Vector3d(1,0,0), rg.Point3d(0,0,0))\n    _rY = rg.Transform.Rotation(y_rotate, rg.Vector3d(0,1,0), rg.Point3d(0,0,0))\n    _rZ = rg.Transform.Rotation(z_rotate, rg.Vector3d(0,0,1), rg.Point3d(0,0,0))\n    _r = _rX * _rY * _rZ\n    _axis_angle= utils.matrix_to_axis_angle(_r)\n\n    # Create pose data\n    _pose = [x_offset/1000, y_offset/1000, z_offset/1000,_axis_angle[0], _axis_angle[1], _axis_angle[2]]\n    _pose_fmt = \"p[\" + (\"%.4f,\"*6)[:-1]+\"]\"\n    _pose_fmt = _pose_fmt%tuple(_pose)\n\n    # Format UR script\n    script = \"set_tcp(%s)\\n\"%(_pose_fmt)\n    return script\n\ndef popup(message, title):\n    \"\"\"\n    Function that returns UR script for popup\n\n    Args:\n        message: float. tooltip offset in mm\n        title: float. tooltip offset in mm\n\n    Returns:\n        script: UR script\n    \"\"\"\n    script = 'popup(\"%s\",\"%s\") \\n' %(message,title)\n    return script\n\ndef sleep(time):\n    \"\"\"\n    Function that returns UR script for sleep()\n\n    Args:\n        time: float.in s\n\n    Returns:\n        script: UR script\n    \"\"\"\n    script = \"sleep(%s) \\n\" %(time)\n    return script\n\ndef set_digital_out(id, signal):\n    \"\"\"\n    Function that returns UR script for setting digital out\n    \n    Args:\n        id: int. Input id number\n        signal: boolean. signal level - on or off\n    \n    Returns:\n        script: UR script\n    \"\"\"\n    \n    # Format UR script\n    script = \"set_digital_out(%s,%s)\\n\"%(id,signal)\n    return script\n\ndef get_digital_in(id):\n    \"\"\"\n    Function that returns UR script for getting digital in\n    \n    Args:\n        id: int. Input id number\n    \n    Returns:\n        script: UR script\n    \"\"\"\n    \n    # Format UR script\n    script = \"get_standard_digital_in(%s) \\n\" %(id)\n    return script\n\ndef set_standard_analog_out(n, f):\n    \"\"\"\n    Parameters\n    n: The number (id) of the output, integer: [0:1]\n    f: The relative signal level [0;1] (float)\n\n    Example command: set_standard_analog_out(1,1.0)\n    n is standard analog output port 1\n    f = 1.0, that corresponds to 10V (or 20mA depending on\n    domain setting) on the output port\n    \"\"\"\n    script = \"set_standard_analog_out(%s,%s)\\n\"%(n,f)\n    return script\n\ndef textmsg(s1,s2):\n    \"\"\"\n    Send text message to log\n    \"\"\"\n    # Format UR script\n    script = 'textmsg(\"%s\",\"%s\") \\n' %(s1,s2)\n    return script\n\ndef multi_conditions(c1, c2):\n    \"\"\"\n    Combine 2 digital inputs as one condition\n    \"\"\"\n    script = c1.replace(\"\\n\", \"\")\n    script += \"and \"\n    script += c2.replace(\"\\n\", \"\")\n    return script\n\ndef add_condition(type, con, bool):\n    \"\"\"\n    Add condition to UR script.\n    type : 0 is for loop, 1 is while loop\n           2 is for elif\n    con : string text, can be an UR script\n    bool : True or False\n    eg : if get_standard_digital_in(0) == True:\n    \"\"\"\n    \n    if type == 0:\n        script = \"if \\t\"\n    elif type == 1:\n        script = \"while \\t\"\n    elif type == 2:\n        script = \"elif \\t\"  \n    script += con.replace(\"\\n\", \"\")\n    script += \"\\t==\\t\"\n    if bool == True:\n        script += \" True: \\n\"\n    elif bool == False:\n        script += \" False: \\n\"\n    return script\n\ndef end_condition():\n    \"\"\"\n    End condition \n    \"\"\"\n    script = \"end\\n\"\n    return script",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}