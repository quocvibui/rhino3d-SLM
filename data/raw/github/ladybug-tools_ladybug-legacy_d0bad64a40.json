{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Photovoltaics%20Surface.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Photovoltaics Surface.py",
  "instruction": "Use this component to calculate amount of electrical energy that can be produced by a surface\nif a certain percentage of it is covered with Photovoltaics.\nComponent based on NREL PVWatts v1 fixed...",
  "code": "# Photovoltaics surface\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Jason Sensibaugh and Djordje Spasic <sensij@yahoo.com> and <djordjedspasic@gmail.com>\n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to calculate amount of electrical energy that can be produced by a surface\nif a certain percentage of it is covered with Photovoltaics.\nComponent based on NREL PVWatts v1 fixed tilt calculator for crystalline silicon (c-Si) and thin-film photovoltaics.\n-\nSources:\nhttp://www.nrel.gov/docs/fy14osti/60272.pdf\nhttps://pvpmc.sandia.gov\n-\nProvided by Ladybug 0.0.69\n    \n    input:\n        _epwFile: Input .epw file path by using the \"File Path\" parameter, or Ladybug's \"Open EPW And STAT Weather Files\" component.\n        _PVsurface: - Input planar Grasshopper/Rhino Surface (not a polysurface) on which the PV modules will be applied. If you have a polysurface, explode it (using \"Deconstruct Brep\" component) and then feed its Faces(F) output to _PVsurface. Surface normal should be faced towards the sun.\n                    - Or create the Surface based on initial PV system size by using \"PV SWH system size\" component.\n        PVsurfacePercent_: The percentage of surface which will be used for PV modules (range 0-100).\n                           -\n                           Some countries and states, have local codes which limit the portion of the roof, which can be covered by crystalline silicon modules. For example, this may include having setbacks(distances) of approximatelly 90cm from side and top edges of a roof, as a fire safety regulation.\n                           -\n                           If not supplied, default value of 100 (all surface area will be covered in PV modules) is used.\n                           -\n                           In percent (%).\n        DCtoACderateFactor_: Factor which accounts for various locations and instances in a PV system where power is lost from DC system nameplate to AC power. It ranges from 0 to 1.\n                             It can be calculated with Ladybug's \"DC to AC derate factor\" component.\n                             -\n                             If not supplied, default value of 0.85 will be used.\n        PVmoduleSettings_: A list of PV module settings. Use the \"Simplified Photovoltaics Module\" or \"Import Sandia Photovoltaics Module\" or \"Import CEC Photovoltaics Module\" components to generate them.\n                           -\n                           If not supplied, the following PV module settings will be used by default:\n                           - module material: crystalline silicon (c-Si)\n                           - moduleType: Close (flush) roof mount\n                           - moduleEfficiency: 15 %\n                           - temperatureCoefficient: -0.5 %/C\n                           - moduleActiveAreaPercent: 90 %\n        north_: Input a vector to be used as a true North direction, or a number between 0 and 360 that represents the clockwise degrees off from the Y-axis.\n                -\n                If not supplied, default North direction will be set to the Y-axis (0 degrees).\n        albedo_: A list of 8767 (with header) or 8760 (without the header) albedo values for each hour during a year.\n                 Albedo (or Reflection coefficient) is an average ratio of the global incident solar radiation reflected from the area surrounding the PV surface.\n                 It ranges from 0 to 1.\n                 -\n                 It depends on the time of the year/day, surface type, temperature, vegetation, presence of water, ice and snow etc.\n                 -\n                 If no list supplied, default value of 0.20 will be used, corrected(increased) for the presence of snow (if any).\n                 -\n                 Unitless.\n        annualHourlyData_: An optional list of hourly data from Ladybug's \"Import epw\" component (e.g. dryBulbTemperature), which will be used for \"conditionalStatement_\".\n        conditionalStatement_: This input allows users to calculate the Photovoltaics surface component results only for those annualHourlyData_ values which fit specific conditions or criteria. To use this input correctly, hourly data, such as dryBulbTemperature or windSpeed, must be plugged into the \"annualHourlyData_\" input. The conditional statement input here should be a valid condition statement in Python, such as \"a>25\" or \"b<3\" (without the quotation marks).\n                               conditionalStatement_ accepts \"and\" and \"or\" operators. To visualize the hourly data, English letters should be used as variables, and each letter alphabetically corresponds to each of the lists (in their respective order): \"a\" always represents the 1st list, \"b\" always represents the 2nd list, etc.\n                               -\n                               For example, if you have an hourly dryBulbTemperature connected as the first list, and windSpeed connected as the second list (both to the annualHourlyData_ input), and you want to plot the data for the time period when temperature is between 18C and 23C, and windSpeed is larger than 3m/s, the conditionalStatement_ should be written as \"18<a<23 and b>3\" (without the quotation marks).\n        _runIt: ...\n        \n    output:\n        readMe!: ...\n        ACenergyPerHour: AC power output for each hour during a year.\n                         -\n                         In kWh.\n        ACenergyPerYear: Total AC power output for a whole year.\n                         -\n                         In kWh.\n        averageDailyACenergyPerYear: An average AC power output per day for a whole year.\n                                     -\n                                     In kWh/day.\n        DCenergyPerHour: DC power output of the PV array for each hour during a year.\n                         -\n                         In kWh.\n        totalRadiationPerHour: Total Incident POA (Plane of array) irradiance for each hour during a year.\n                               -\n                               In kWh/m2.\n        cellTemperaturePerHour: Cell temperature for each hour during year.\n                                -\n                                In C.\n        PVsurfaceTiltAngle: The angle from horizontal of the inclination of the PVsurface. Example: 0 = horizontal, 90 = vertical.\n                            It ranges from 0-180.\n                            -\n                            In degrees.\n        PVsurfaceAzimuthAngle: The orientation angle (clockwise from the true north) of the PVsurface normal vector.\n                               It ranges from 0-360.\n                               -\n                               In degrees.\n        systemSize: DC rating of the PV system.\n                    -\n                    In kW.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Photovoltaics Surface\"\nghenv.Component.NickName = \"PhotovoltaicsSurface\"\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"4 | Renewables\"\n#compatibleLBVersion = VER 0.0.64\\nAPR_12_2017\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\nimport re\n\n\ndef getEpwData(epwFile, albedo):\n    \n    if epwFile:\n        try:\n            # location data\n            locationName, latitude, longitude, timeZone, elevationM, locationString = lb_preparation.epwLocation(epwFile)\n            # weather data\n            weatherData = lb_preparation.epwDataReader(epwFile, locationName)\n            dryBulbTemperature, dewPointTemperature, relativeHumidity, windSpeed, windDirection, directNormalRadiation, diffuseHorizontalRadiation, globalHorizontalRadiation, directNormalIlluminance, diffuseHorizontalIlluminance, globalHorizontalIlluminance, totalSkyCover, liquidPrecipitationDepth, barometricPressure, modelYear = weatherData\n            \n            Ta = dryBulbTemperature[7:]\n            ws = windSpeed[7:]\n            DNI = directNormalRadiation[7:]\n            DHI = diffuseHorizontalRadiation[7:]\n            \n            if (len(albedo) == 0) or (albedo[0] is \"\"):\n                albedoL = lb_photovoltaics.calculateAlbedo(Ta)  # default\n            elif (len(albedo) == 8767):\n                albedoL = albedo[7:]\n            elif (len(albedo) == 8760):\n                albedoL = albedo\n            else:\n                locationName = latitude = longitude = timeZone = elevationM = Ta = ws = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = albedoL = None\n                validEpwData = False\n                printMsg = \"Something is wrong with your \\\"albedo_\\\" list input.\\n\\\"albedo_\\\" input accepts a list of 8767 (with header) or 8760 (without the header) abledo values.\"\n                \n                return locationName, latitude, longitude, timeZone, elevationM, Ta, ws, DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, albedoL, validEpwData, printMsg\n            \n            yearsHOY = modelYear[7:]\n            monthsHOY = [1 for i in range(744)] + [2 for i in range(672)] + [3 for i in range(744)] + [4 for i in range(720)] + [5 for i in range(744)] + [6 for i in range(720)] + [7 for i in range(744)] + [8 for i in range(744)] + [9 for i in range(720)] + [10 for i in range(744)] + [11 for i in range(720)] + [12 for i in range(744)]\n            \n            numberOfDaysMonth = [31,28,31,30,31,30,31,31,30,31,30,31]\n            daysHOY = []\n            day = 1\n            for i,item in enumerate(numberOfDaysMonth):\n                for k in range(item):\n                    for g in range(24):\n                        daysHOY.append(day)\n                    day += 1\n                day = 1\n            \n            hoursHOY = []\n            hour = 1\n            for i in range(365):\n                for k in range(24):\n                    hoursHOY.append(hour)\n                    hour += 1\n                hour = 1\n            \n            HOYs = range(1,8761)\n            \n            validEpwData = True\n            printMsg = \"ok\"\n            \n            return locationName, float(latitude), float(longitude), float(timeZone), float(elevationM), Ta, ws, DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, albedoL, validEpwData, printMsg\n        \n        except Exception, e:\n            # something is wrong with \"_epwFile\" input\n            locationName = latitude = longitude = timeZone = elevationM = Ta = ws = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = albedoL = None\n            validEpwData = False\n            printMsg = \"Something is wrong with \\\"_epwFile\\\" input.\"\n    else:\n        locationName = latitude = longitude = timeZone = elevationM = Ta = ws = DNI = DHI = yearsHOY = monthsHOY = daysHOY = hoursHOY = HOYs = albedoL = None\n        validEpwData = False\n        printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n    \n    return locationName, latitude, longitude, timeZone, elevationM, Ta, ws, DNI, DHI, yearsHOY, monthsHOY, daysHOY, hoursHOY, HOYs, albedoL, validEpwData, printMsg\n\n\ndef PVsurfaceInputData(PVsurface, PVsurfacePercent, unitAreaConversionFactor, DCtoACderateFactor, PVmoduleSettings):\n    \n    if (PVsurface == None):\n        PVsurfaceInputType = nameplateDCpowerRating = srfArea = activeArea = PVsurfacePercent = DCtoACderateFactor = None\n        validPVsurfaceData = False\n        printMsg = \"Please input planar Surface (not a polysurface) on which the PV modules will be applied.\\n\" + \\\n                   \"Or create a Surface based on initial PV system size by using \\\"PV SWH system size\\\" component.\"\n        \n        return PVsurfaceInputType, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, validPVsurfaceData, printMsg\n    \n    if (PVsurfacePercent == None) or (PVsurfacePercent < 0) or (PVsurfacePercent > 100):\n        PVsurfacePercent = 100  # default value 100%\n    \n    if (DCtoACderateFactor == None) or (DCtoACderateFactor < 0) or (DCtoACderateFactor > 1):\n        DCtoACderateFactor = 0.85  # default value (corresponds to 11.42% of PVWatts v5 Total Losses)\n    \n    # PV module settings inputs\n    if (len(PVmoduleSettings) != 9) and (len(PVmoduleSettings) != 23) and (len(PVmoduleSettings) != 36) and (len(PVmoduleSettings) != 0):\n        PVsurfaceInputType = nameplateDCpowerRating = srfArea = activeArea = PVsurfacePercent = DCtoACderateFactor = None\n        validPVsurfaceData = False\n        printMsg = \"Your \\\"PVmoduleSettings_\\\" input is incorrect. Please use \\\"PVmoduleSettings\\\" output from \\\"Simplified Photovoltaics Module\\\" or \\\"Import Sandia Photovoltaics Module\\\" or \\\"Import CEC Photovoltaics Module\\\" components.\"\n        \n        return PVsurfaceInputType, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, validPVsurfaceData, printMsg\n    \n    elif (len(PVmoduleSettings) == 0) or (PVmoduleSettings[0] is \"\"):\n        # nothing added into \"PVmoduleSettings_\", use default PVmoduleSettings values:\n        \n        #mountTypeName = \"close roof mount\"  # Glass/cell/glass (moduleType_ = 1)\n        #moduleActiveAreaPercent = 90  # default value in %\n        #moduleEfficiency = 15  # for crystalline silicon\n        #temperatureCoefficientPercent = -0.5  # in %, for crystalline silicon\n        \n        moduleModelName, mountTypeName, moduleMaterial, mountType, moduleActiveAreaPercent, moduleEfficiency, temperatureCoefficientFraction, a, b, deltaT = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n    \n    elif (len(PVmoduleSettings) == 9):\n        # data from \"Simplified Photovoltaics Module\" component added to \"PVmoduleSettings_\" input\n        moduleModelName, mountTypeName, moduleMaterial, mountType, moduleActiveAreaPercent, moduleEfficiency, temperatureCoefficientFraction, a, b, deltaT = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n    \n    elif (len(PVmoduleSettings) == 23):\n        # data from \"Import CEC Photovoltaics Module\" component added to \"PVmoduleSettings_\" input\n        moduleModelName, moduleName, material, moduleMountType, moduleAreaM, moduleActiveAreaPercent, nameplateDCpowerRating_m, moduleEfficiency, Vmp_ref, Imp_ref, Voc_ref, Isc_ref, alpha_sc_ref, beta_oc_ref, IL_ref, Io_ref, Rs_ref, Rsh_ref, A_ref, n_s, adjust, gamma_r_ref, ws_adjusted_factor, Tnoct_adj = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n    \n    elif (len(PVmoduleSettings) == 36):\n        # data from \"Import Sandia Photovoltaics Module\" component added to \"PVmoduleSettings_\" input\n        moduleModelName, moduleName, material, moduleMountType, moduleAreaM, moduleActiveAreaPercent, nameplateDCpowerRating_m, moduleEfficiency, Vmp_ref, Imp_ref, Voc_ref, Isc_ref, alpha_sc_ref, beta_oc_ref, beta_mp_ref, mu_betamp, s, n, Fd, a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, b5, C0, C1, C2, C3, a, b, deltaT = lb_photovoltaics.deconstruct_PVmoduleSettings(PVmoduleSettings)\n    \n    \n    \n    # check PVsurface input\n    PVsurfaceInputType = \"brep\"\n    facesCount = PVsurface.Faces.Count\n    if facesCount > 1:\n        # inputted polysurface\n        PVsurfaceInputType = nameplateDCpowerRating = srfArea = activeArea = PVsurfacePercent = DCtoACderateFactor = None\n        validPVsurfaceData = False\n        printMsg = \"The brep you supplied to \\\"_PVsurface\\\" is a polysurface. Please supply a surface\"\n        \n        return PVsurfaceInputType, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, validPVsurfaceData, printMsg\n    else:\n        # inputted brep with a single surface\n        srfArea = Rhino.Geometry.AreaMassProperties.Compute(PVsurface).Area * (PVsurfacePercent/100)  # area in document units\n        srfArea = srfArea * unitAreaConversionFactor  # area in m2\n        activeArea = srfArea * (moduleActiveAreaPercent/100)  # in m2\n        nameplateDCpowerRating = activeArea * (1 * (moduleEfficiency/100))  # in kW\n        validPVsurfaceData = True\n        printMsg = \"ok\"\n        \n        return PVsurfaceInputType, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, validPVsurfaceData, printMsg\n\n\ndef checkAnnualHourlyInputData(annualHourlyData):\n    \n    if annualHourlyData == []:\n        annualHourlyDataLists = []\n        annualHourlyDataListsEpwNames = []\n        validAnnualHourlyData = True\n        printMsg = \"ok\"\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\n    elif len(annualHourlyData) % 8767 != 0:\n        annualHourlyDataLists = annualHourlyDataListsEpwNames = None\n        validAnnualHourlyData = False\n        printMsg = \"Your annualHourlyData_ input is not correct. Please input complete 8767 items long list(s) from \\\"Ladybug_Import epw\\\" component\"\n        return annualHourlyDataLists, validAnnualHourlyData, annualHourlyDataListsEpwNames, printMsg\n    else:\n        annualHourlyDataLists = []\n        annualHourlyDataListsEpwNames = []\n        startIndex = 0\n        endIndex = 8767\n        for i in range(int(len(annualHourlyData)/8767)):\n            untrimmedList = annualHourlyData[startIndex:endIndex]\n            trimmedList = untrimmedList[7:]\n            annualHourlyDataListsName = untrimmedList[2]\n            annualHourlyDataLists.append(trimmedList)\n            annualHourlyDataListsEpwNames.append(annualHourlyDataListsName)\n            startIndex += 8767\n            endIndex += 8767\n        \n        validAnnualHourlyData = True\n        printMsg = \"ok\"\n        return validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg\n\n\ndef checkConditionalStatement(conditionalStatement, annualHourlyDataLists, annualHourlyDataListsEpwNames, weatherPerHourDataSubLists, addZero):\n    \n    if conditionalStatement == None and len(annualHourlyDataLists) > 0: # conditionalStatement_ not inputted, annualHourlyData_ inputted\n        validConditionalStatement = False\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n        printMsg = \"Please supply \\\"conditionalStatement_\\\" for inputted \\\"annualHourlyData_\\\" data.\"\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n    elif conditionalStatement == None and len(annualHourlyDataLists) == 0:  # conditionalStatement_ not inputted, annualHourlyData_ not inputted\n        conditionalStatement = \"True\"\n    else:  # conditionalStatement_ inputted, annualHourlyData_ not\n        if annualHourlyDataLists == []:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"Please supply \\\"annualHourlyData_\\\" data for inputted \\\"conditionalStatement_\\\".\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        else:  # both conditionalStatement_ and annualHourlyData_ inputted\n            conditionalStatement = conditionalStatement.lower()\n            conditionalStatement = re.sub(r\"\\b([a-z])\\b\", r\"\\1[i]\", conditionalStatement)\n    \n    annualHourlyDataListsNames = map(chr, range(97, 123))\n    \n    # finalPrint conditonal statements for \"printOutput\" function\n    if conditionalStatement != \"True\":  # conditionalStatement_ not inputted\n        # replace conditionalStatement annualHourlyDataListsNames[i] names with annualHourlyDataListsEpwNames:\n        conditionalStatementForFinalPrint = conditionalStatement[:]\n        for i in range(len(annualHourlyDataLists)):\n            conditionalStatementForFinalPrint = conditionalStatementForFinalPrint.replace(annualHourlyDataListsNames[i]+\"[i]\", annualHourlyDataListsEpwNames[i])\n    else:\n        conditionalStatementForFinalPrint = \"No condition\"\n    \n    annualHourlyDataListsNames = map(chr, range(97, 123))\n    numberOfLetters = 0\n    \n    for letter in annualHourlyDataListsNames:\n        changedLetter = letter+\"[i]\"\n        if changedLetter in conditionalStatement:\n            numberOfLetters += 1\n    if numberOfLetters > len(annualHourlyDataLists):\n        validConditionalStatement = False\n        weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n        printMsg = \"The number of a,b,c... variables you supplied in \\\"conditionalStatement_\\\" is larger than the number of \\\"annualHourlyData_\\\" lists you inputted. Please make the numbers of these two equal or less.\"\n        return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n    else:\n        for i in range(len(annualHourlyDataLists)):\n            exec(\"%s = %s\" % (annualHourlyDataListsNames[i],annualHourlyDataLists[i]))\n        \n        try:\n            weatherPerHourDataConditionalStatementSubLists = []\n            for i in range(len(weatherPerHourDataSubLists)):\n                weatherPerHourDataConditionalStatementSubLists.append([])\n            for i in range(len(weatherPerHourDataSubLists[0])):\n                exec(\"conditionalSt = %s\" % conditionalStatement)\n                if addZero == True:  # add 0 if conditionalStatement == False\n                    if conditionalSt:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\n                    else:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(0)\n                else:  # skip the value\n                    if conditionalSt:\n                        for k in range(len(weatherPerHourDataConditionalStatementSubLists)):\n                            weatherPerHourDataConditionalStatementSubLists[k].append(weatherPerHourDataSubLists[k][i])\n        except Exception, e:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"Your \\\"conditionalStatement_\\\" is incorrect. Please provide a valid conditional statement in Python, such as \\\"a>25 and b<80\\\" (without the quotation marks)\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        \n        if len(weatherPerHourDataConditionalStatementSubLists[0]) == 0:\n            validConditionalStatement = False\n            weatherPerHourDataConditionalStatementSubLists = conditionalStatementForFinalPrint = None\n            printMsg = \"No \\\"annualHourlyData_\\\" coresponds to \\\"conditionalStatement_\\\". Please edit your \\\"conditionalStatement_\\\"\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n        else:\n            validConditionalStatement = True\n            printMsg = \"ok\"\n            return validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg\n\n\ndef main(latitude, longitude, timeZone, elevationM, locationName, years, months, days, hours, HOYs, nameplateDCpowerRating, DCtoACderateFactor, srfArea, srfTiltD, srfAzimuthD, PVmoduleSettings, dryBulbTemperature, windSpeed, directNormalRadiation, diffuseHorizontalRadiation, albedoL, conditionalStatementForFinalPrint):\n    # solar radiation, AC,DC power output, module temperature, cell temperature\n    ACenergyPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"AC power output\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)]\n    DCenergyPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"DC power output\", \"kWh\", \"Hourly\", (1, 1, 1), (12, 31, 24)]\n    totalRadiationPerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Total POA irradiance\", \"kWh/m2\", \"Hourly\", (1, 1, 1), (12, 31, 24)]\n    cellTemperaturePerHour = [\"key:location/dataType/units/frequency/startsAt/endsAt\", locationName, \"Cell temperature\", \"C\", \"Hourly\", (1, 1, 1), (12, 31, 24)]\n    beamRadiationPerHour = []\n    diffuseRadiationPerHour = []\n    groundRadiationPerHour = []\n    sunZenithDL = []\n    AOI_RL = []\n    \n    for i,hoy in enumerate(HOYs):\n        sunZenithD, sunAzimuthD, sunAltitudeD = lb_photovoltaics.NRELsunPosition(latitude, longitude, timeZone, years[i], months[i], days[i], hours[i]-1)\n        Epoa, Eb, Ed_sky, Eground, AOI_R = lb_photovoltaics.POAirradiance(sunZenithD, sunAzimuthD, srfTiltD, srfAzimuthD, directNormalRadiation[i], diffuseHorizontalRadiation[i], albedoL[i])\n        Tcell, Pdc_, Pac = lb_photovoltaics.pvwatts(nameplateDCpowerRating, DCtoACderateFactor, srfTiltD, sunZenithD, AOI_R, Epoa, Eb, Ed_sky, Eground, dryBulbTemperature[i], windSpeed[i], directNormalRadiation[i], diffuseHorizontalRadiation[i], PVmoduleSettings, elevationM)\n        Epoa = Epoa/1000 # to kWh/m2\n        ACenergyPerHour.append(Pac)\n        DCenergyPerHour.append(Pdc_)\n        totalRadiationPerHour.append(Epoa)\n        cellTemperaturePerHour.append(Tcell)\n        beamRadiationPerHour.append(Eb)\n        diffuseRadiationPerHour.append(Ed_sky)\n        groundRadiationPerHour.append(Eground)\n        sunZenithDL.append(sunZenithD)\n        AOI_RL.append(AOI_R)\n    \n    ACenergyPerYear = sum(ACenergyPerHour[7:])  # in kWh\n    averageDailyACenergyPerYear = ACenergyPerYear/365  # in kWh/day\n    \n    # optimal pv surface initial data\n    pv_inputData = [conditionalStatementForFinalPrint, DCtoACderateFactor, PVmoduleSettings, elevationM, srfTiltD, sunZenithDL, AOI_RL, [Epoa*1000 for index,Epoa in enumerate(totalRadiationPerHour) if index >= 7], beamRadiationPerHour, diffuseRadiationPerHour, groundRadiationPerHour, dryBulbTemperature, windSpeed, directNormalRadiation, diffuseHorizontalRadiation]\n    sc.sticky[\"pv_inputData\"] = pv_inputData\n    \n    return ACenergyPerHour, ACenergyPerYear, averageDailyACenergyPerYear, DCenergyPerHour, totalRadiationPerHour, cellTemperaturePerHour\n\n\ndef printOutput(unitAreaConversionFactor, locationName, latitude, longitude, northDeg, albedoL, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, srfTiltD, srfAzimuthD, PVmoduleSettings, conditionalStatementForFinalPrint):\n    resultsCompletedMsg = \"PVsurface component results successfully completed!\"\n    moduleTypesL = [\"Insulated back\", \"Close (flush) roof mount\", \"Open rack\"]\n    \n    if (len(PVmoduleSettings) == 9):\n        PVmoduleSettings_printString = \\\n        \"\"\"\n---------\nPVmoduleSettings:\n\nModule Material:  %s,\nModule Mount Type:  %s (%s),\nModule Active Area Percent (perc.):  %s,\nModule Efficiency (perc.):  %s,\nTemperature coefficient (perc./celsius deg.):  %s,\n\nUpper limit coefficient for module temperature at low wind speeds and high solar irradiance:  %s,\nCoefficient for rate at which module temperature drops as wind speed increases:  %s,\nTemperature difference between the cell and the module back surface:  %s,\n        \"\"\" % (PVmoduleSettings[1], PVmoduleSettings[2], PVmoduleSettings[0], PVmoduleSettings[3], PVmoduleSettings[4], PVmoduleSettings[5], PVmoduleSettings[6], PVmoduleSettings[7], PVmoduleSettings[8])\n    \n    \n    elif (len(PVmoduleSettings) == 23):\n        PVmoduleSettings_printString = \\\n    \"\"\"\nInput data:,\n\nModule Name:  %s,\nModule Material:  %s,\nModule Mount Type:  %s,\nModule Area (m2):  %s,\nModule Active Area Percent (perc.):  %s,\n\nPower at Max Power (W):  %s,\nModule Efficiency (perc.):  %s,\nReference Max Power Voltage (V):  %s,\nReference Max Power Current (A):  %s,\nReference Open Circuit Voltage (V):  %s,\nReference Short Circuit Current (A):  %s,\n\nShort circuit current temperature coefficient (A/C deg.):  %s,\nOpen circuit voltage temperature coefficient (V/C deg.):  %s,\n\nReference light current:  %s,\nReference diode saturation current:  %s,\nReference series resistance:  %s,\nReference shunt resistance:  %s,\n\nReference ideality factor:  %s,\nDiode factor:  %s,\n\nTemperature coefficient adjustment factor:  %s,\nTemperature coefficient of Power (perc./C deg.):  %s,\nWind speed adjustment factor:  %s,\nNormal operating cell temperature:  %s,\n    \"\"\" % (PVmoduleSettings[0], PVmoduleSettings[1], PVmoduleSettings[2], PVmoduleSettings[3], PVmoduleSettings[4],\n    PVmoduleSettings[5], PVmoduleSettings[6], PVmoduleSettings[7], PVmoduleSettings[8], PVmoduleSettings[9], PVmoduleSettings[10], \n    PVmoduleSettings[11], PVmoduleSettings[12],\n    PVmoduleSettings[13], PVmoduleSettings[14], PVmoduleSettings[15], PVmoduleSettings[16],\n    PVmoduleSettings[17], PVmoduleSettings[18],\n    PVmoduleSettings[19], PVmoduleSettings[20], PVmoduleSettings[21], PVmoduleSettings[22])\n    \n    \n    elif (len(PVmoduleSettings) == 36):\n        PVmoduleSettings_printString = \\\n        \"\"\"\n---------\nPVmoduleSettings:\n\nModule Name:  %s,\nModule Material:  %s,\nModule Mount Type:  %s (%s),\nModule Area (m2):  %s,\nModule Active Area Percent (perc.):  %s,\n\nModule Power at Max Power (W):  %s,\nModule Efficiency (perc.):  %s,\nReference Max Power Voltage (V):  %s,\nReference Max Power Current (A):  %s,\nReference Open Circuit Voltage (V):  %s,\nReference Short Circuit Current (A):  %s,\nShort circuit temperature coefficient:  %s,\nOpen circuit temperature coefficient:  %s,\nMaximum power voltage temperature coefficient:  %s,\nRelates Maximum power voltage temperature coefficient to Effective irradiance:  %s,\n\nNumber of cells in series:  %s,\nDiode factor:  %s,\nFraction of diffuse irradiance used by module:  %s,\n\nAir mass coefficient 0:  %s,\nAir mass coefficient 1:  %s,\nAir mass coefficient 2:  %s,\nAir mass coefficient 3:  %s,\nAir mass coefficient 4:  %s,\nIncidence angle modifier coefficient 0:  %s,\nIncidence angle modifier coefficient 1:  %s,\nIncidence angle modifier coefficient 2:  %s,\nIncidence angle modifier coefficient 3:  %s,\nIncidence angle modifier coefficient 4:  %s,\nIncidence angle modifier coefficient 5:  %s,\nCoefficients relating Reference Max Power Current to Effective irradiance 0:  %s,\nCoefficients relating Reference Max Power Current to Effective irradiance 1:  %s,\nCoefficients relating Reference Max Power Voltage to Effective irradiance 0:  %s,\nCoefficients relating Reference Max Power Voltage to Effective irradiance 1:  %s,\n\nUpper limit coefficient for module temperature at low wind speeds and high solar irradiance:  %s,\nCoefficient for rate at which module temperature drops as wind speed increases:  %s,\nTemperature difference between the cell and the module back surface:  %s,\n        \"\"\" % (PVmoduleSettings[0], PVmoduleSettings[1], PVmoduleSettings[2], moduleTypesL[PVmoduleSettings[2]], PVmoduleSettings[3], PVmoduleSettings[4], \n        PVmoduleSettings[5], PVmoduleSettings[6], PVmoduleSettings[7], PVmoduleSettings[8], PVmoduleSettings[9], PVmoduleSettings[10], PVmoduleSettings[11], PVmoduleSettings[12], PVmoduleSettings[13], PVmoduleSettings[14], \n        PVmoduleSettings[15], PVmoduleSettings[16], PVmoduleSettings[17], \n        PVmoduleSettings[18], PVmoduleSettings[19], PVmoduleSettings[20], PVmoduleSettings[21], PVmoduleSettings[22], PVmoduleSettings[23], PVmoduleSettings[24], PVmoduleSettings[25], PVmoduleSettings[26], PVmoduleSettings[27], PVmoduleSettings[28], PVmoduleSettings[29], PVmoduleSettings[30], PVmoduleSettings[31], PVmoduleSettings[32], \n        PVmoduleSettings[33], PVmoduleSettings[34], PVmoduleSettings[35])\n    \n    \n    printOutputMsg = \\\n    \"\"\"\nInput data:\n\nLocation:  %s,\nLatitude (deg.):  %s,\nLongitude (deg.):  %s,\nNorth (deg.):  %s,\nAverage annual albedo(-):  %0.2f,\n\nSurface percentage used for PV modules (percent):  %0.2f,\nSurface area (m2):  %0.2f,\nSurface active area (m2):  %0.2f,\nArray type: fixed tilt\nSurface tilt angle (deg.):  %0.2f,\nSurface azimuth angle (deg.):  %0.2f,\n\nOverall DC to AC derate factor (-):  %0.3f,\n\nSystem size (kW):  %0.2f,\n\nCaclulation based on the following condition:  %s,\n\n%s\n    \"\"\" % (locationName, latitude, longitude, northDeg, sum(albedoL)/8760, PVsurfacePercent, srfArea, activeArea, srfTiltD, srfAzimuthD, DCtoACderateFactor, nameplateDCpowerRating, conditionalStatementForFinalPrint, PVmoduleSettings_printString)\n    print resultsCompletedMsg\n    print printOutputMsg\n\n\nlevel = gh.GH_RuntimeMessageLevel.Warning\nif sc.sticky.has_key(\"ladybug_release\"):\n    if sc.sticky[\"ladybug_release\"].isCompatible(ghenv.Component):\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n        lb_photovoltaics = sc.sticky[\"ladybug_Photovoltaics\"]()\n        \n        if _epwFile:\n            locationName, latitude, longitude, timeZone, elevationM, dryBulbTemperature, windSpeed, directNormalRadiation, diffuseHorizontalRadiation, years, months, days, hours, HOYs, albedoL, validEpwData, printMsg = getEpwData(_epwFile, albedo_)\n            if validEpwData:\n                moduleActiveAreaPercent_ = moduleType_ = moduleEfficiency_ = None\n                unitConversionFactor = lb_preparation.checkUnits()\n                unitAreaConversionFactor = unitConversionFactor**2\n                PVsurfaceInputType, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, validPVsurfaceData, printMsg = PVsurfaceInputData(_PVsurface, PVsurfacePercent_, unitAreaConversionFactor, DCtoACderateFactor_, PVmoduleSettings_)\n                if validPVsurfaceData:\n                    validAnnualHourlyData, annualHourlyDataLists, annualHourlyDataListsEpwNames, printMsg = checkAnnualHourlyInputData(annualHourlyData_)\n                    if validAnnualHourlyData:\n                        validConditionalStatement, weatherPerHourDataConditionalStatementSubLists, conditionalStatementForFinalPrint, printMsg = checkConditionalStatement(conditionalStatement_, annualHourlyDataLists, annualHourlyDataListsEpwNames, [dryBulbTemperature, windSpeed, directNormalRadiation, diffuseHorizontalRadiation], True)\n                        if validConditionalStatement:\n                            dryBulbTemperatureCondStat, windSpeedCondStat, directNormalRadiationCondStat, diffuseHorizontalRadiationCondStat = weatherPerHourDataConditionalStatementSubLists\n                            # all inputs ok\n                            if _runIt:\n                                PVsurfaceTiltAngle_ = None; PVsurfaceAzimuthAngle_ = None\n                                srfAzimuthD, surfaceTiltDCalculated = lb_photovoltaics.srfAzimuthAngle(PVsurfaceAzimuthAngle_, PVsurfaceInputType, _PVsurface, latitude)\n                                correctedSrfAzimuthD, northDeg, validNorth, printMsg = lb_photovoltaics.correctSrfAzimuthDforNorth(north_, srfAzimuthD)\n                                srfTiltD = lb_photovoltaics.srfTiltAngle(PVsurfaceTiltAngle_, surfaceTiltDCalculated, PVsurfaceInputType, _PVsurface, latitude)\n                                ACenergyPerHour, ACenergyPerYear, averageDailyACenergyPerYear, DCenergyPerHour, totalRadiationPerHour, cellTemperaturePerHour = main(latitude, longitude, timeZone, elevationM, locationName, years, months, days, hours, HOYs, nameplateDCpowerRating, DCtoACderateFactor, srfArea, srfTiltD, correctedSrfAzimuthD, PVmoduleSettings_, dryBulbTemperatureCondStat, windSpeedCondStat, directNormalRadiationCondStat, diffuseHorizontalRadiationCondStat, albedoL, conditionalStatementForFinalPrint)\n                                printOutput(unitAreaConversionFactor, locationName, latitude, longitude, northDeg, albedoL, nameplateDCpowerRating, srfArea, activeArea, PVsurfacePercent, DCtoACderateFactor, srfTiltD, correctedSrfAzimuthD, PVmoduleSettings_, conditionalStatementForFinalPrint)\n                                systemSize = nameplateDCpowerRating; PVsurfaceTiltAngle = srfTiltD; PVsurfaceAzimuthAngle = correctedSrfAzimuthD\n                            else:\n                                print \"All inputs are ok. Please set the \\\"_runIt\\\" to True, in order to run the Photovoltaics surface component\"\n                        else:\n                            print printMsg\n                            ghenv.Component.AddRuntimeMessage(level, printMsg)\n                    else:\n                        print printMsg\n                        ghenv.Component.AddRuntimeMessage(level, printMsg)\n                else:\n                    print printMsg\n                    ghenv.Component.AddRuntimeMessage(level, printMsg)\n            else:\n                print printMsg\n                ghenv.Component.AddRuntimeMessage(level, printMsg)\n        else:\n            printMsg = \"Please supply .epw file path to \\\"_epwFile\\\" input.\"\n            print printMsg\n            ghenv.Component.AddRuntimeMessage(level, printMsg)\n    else:\n        printMsg = \"You need a newer version of Ladybug to use this component.\" + \\\n            \"Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag the Ladybug_Ladybug component \" + \\\n            \"into the canvas and try again.\"\n        print printMsg\nelse:\n    printMsg = \"First please let the Ladybug fly...\"\n    print printMsg\n    ghenv.Component.AddRuntimeMessage(level, printMsg)",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}